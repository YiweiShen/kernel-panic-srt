1
00:00:00,000 --> 00:00:04,000
白美山的时间 2006 年 1 月 2 日下午 3 点 04 分 05 秒

2
00:00:04,000 --> 00:00:08,000
您正在收听 IPM Podcast 网络旗下的 IT 技术主题节目

3
00:00:08,000 --> 00:00:08,000
内核恐慌

4
00:00:08,000 --> 00:00:11,000
我们号称 Hardcore 但也没有干货

5
00:00:11,000 --> 00:00:12,000
想听的人听

6
00:00:12,000 --> 00:00:13,000
不想听的人就别听

7
00:00:13,000 --> 00:00:17,000
内核恐慌的网址是 ipn.li.com

8
00:00:17,000 --> 00:00:21,000
我们推荐大家使用 Podcast 客户端订阅我们的节目

9
00:00:21,000 --> 00:00:23,000
如果您不知道该用什么客户端

10
00:00:23,000 --> 00:00:25,000
请访问 ipn.li.com

11
00:00:25,000 --> 00:00:27,000
在录音过程中

12
00:00:27,000 --> 00:00:29,000
您可以拨通热心电话参与我们的节目

13
00:00:29,000 --> 00:00:30,000
电话号码是

14
00:00:30,000 --> 00:00:35,000
电话号码是

15
00:00:35,000 --> 00:00:37,000
算了吧

16
00:00:37,000 --> 00:00:41,000
06189998819991197253

17
00:00:41,000 --> 00:00:43,000
我觉得 Lars 其实是把那个

18
00:00:43,000 --> 00:00:45,000
其实把那个

19
00:00:45,000 --> 00:00:46,000
那个节目里面

20
00:00:46,000 --> 00:00:48,000
就是 IT Crowd 里面

21
00:00:48,000 --> 00:00:50,000
唱的音在这边唱

22
00:00:50,000 --> 00:00:51,000
好吧

23
00:00:51,000 --> 00:00:53,000
Anyway

24
00:00:53,000 --> 00:00:55,000
如果你非常喜欢我们的节目

25
00:00:55,000 --> 00:00:58,000
或者说不管你是否喜欢我们的节目

26
00:00:58,000 --> 00:00:59,000
你都可以为我们捐款

27
00:00:59,000 --> 00:01:02,000
捐款地址是 ipn.li.com

28
00:01:02,000 --> 00:01:03,000
Currenlpanic.com

29
00:01:03,000 --> 00:01:04,000
Donate

30
00:01:04,000 --> 00:01:07,000
捐款金额随意

31
00:01:07,000 --> 00:01:10,000
但是必须是可以被巴整出的正整数

32
00:01:10,000 --> 00:01:12,000
OK

33
00:01:12,000 --> 00:01:14,000
等一下那个地址你用的是 ipn 那个吗

34
00:01:14,000 --> 00:01:17,000
你又可以用 Currenlpanic.fm 那个地址

35
00:01:17,000 --> 00:01:17,000
OK

36
00:01:17,000 --> 00:01:21,000
我们有了新的域名是 Currenlpanic.fm

37
00:01:21,000 --> 00:01:23,000
所以捐款地址也可以是

38
00:01:23,000 --> 00:01:23,000
对

39
00:01:23,000 --> 00:01:25,000
这么便宜

40
00:01:25,000 --> 00:01:27,000
不贵的这个域名

41
00:01:27,000 --> 00:01:28,000
对

42
00:01:28,000 --> 00:01:29,000
因此我们更需要大家捐款

43
00:01:29,000 --> 00:01:32,000
贵求大家捐款

44
00:01:32,000 --> 00:01:34,000
最低 8 块上不封顶

45
00:01:34,000 --> 00:01:34,000
对

46
00:01:34,000 --> 00:01:36,000
捐款地址是 ipn.

47
00:01:36,000 --> 00:01:39,000
Currenlpanic.fm

48
00:01:39,000 --> 00:01:40,000
Donate

49
00:01:40,000 --> 00:01:45,000
今天我们是我们的地多少金

50
00:01:45,000 --> 00:01:46,000
13

51
00:01:46,000 --> 00:01:47,000
13

52
00:01:47,000 --> 00:01:50,000
0 x 0 c

53
00:01:50,000 --> 00:01:53,000
Wait a second

54
00:01:53,000 --> 00:01:54,000
0 x 0 d

55
00:01:55,000 --> 00:01:58,000
10 是 A 对吧

56
00:01:58,000 --> 00:01:59,000
11 是 B

57
00:01:59,000 --> 00:02:02,000
14 对所以是 0 x 0 d

58
00:02:02,000 --> 00:02:05,000
13 这个数字不是非常的

59
00:02:05,000 --> 00:02:07,000
吉利吗

60
00:02:07,000 --> 00:02:09,000
好像也我也不知道

61
00:02:09,000 --> 00:02:12,000
在欧洲某些国家 13 好像是个蛮吉利的数字

62
00:02:12,000 --> 00:02:16,000
因为我们这边没有 13 层那么高的楼

63
00:02:16,000 --> 00:02:18,000
所以我不知道没有办法验证

64
00:02:18,000 --> 00:02:22,000
大农村

65
00:02:22,000 --> 00:02:23,000
大农村

66
00:02:23,000 --> 00:02:26,000
你知道加拿大的意思吗

67
00:02:26,000 --> 00:02:26,000
Canada

68
00:02:26,000 --> 00:02:28,000
Canada 是

69
00:02:28,000 --> 00:02:31,000
是当地人的语言吗

70
00:02:31,000 --> 00:02:32,000
就是什么爱斯

71
00:02:32,000 --> 00:02:36,000
就是那种什么就是英纽特人还是什么人的语言里面

72
00:02:36,000 --> 00:02:37,000
就是 big village

73
00:02:37,000 --> 00:02:38,000
大农村的意思

74
00:02:38,000 --> 00:02:39,000
OK

75
00:02:39,000 --> 00:02:42,000
倒也贴切了

76
00:02:42,000 --> 00:02:46,000
黑的好

77
00:02:46,000 --> 00:02:50,000
对我们上一期请到的木瑶里面

78
00:02:50,000 --> 00:02:53,000
我们上一期请到木瑶那期节目里面

79
00:02:53,000 --> 00:02:54,000
我们反复提到了

80
00:02:54,000 --> 00:02:55,000
我反复提到了

81
00:02:55,000 --> 00:02:56,000
How I Met Your Mother 里面

82
00:02:56,000 --> 00:02:58,000
然后里面另外一个除了纽泽西他们

83
00:02:58,000 --> 00:02:58,000
还有一个是纽泽西的节目里面

84
00:02:58,000 --> 00:03:02,000
也许很喜欢黑的另一个地方就是加拿大

85
00:03:02,000 --> 00:03:05,000
不是还有那个地方吗

86
00:03:05,000 --> 00:03:07,000
那个叫 Penny 那里面叫什么

87
00:03:07,000 --> 00:03:09,000
Penny

88
00:03:09,000 --> 00:03:13,000
那个 Big Bang Theory 里面 Penny 老家哪个地方来的

89
00:03:13,000 --> 00:03:14,000
我不知道

90
00:03:14,000 --> 00:03:16,000
那个州叫

91
00:03:16,000 --> 00:03:18,000
查一下

92
00:03:18,000 --> 00:03:20,000
Penny from

93
00:03:20,000 --> 00:03:26,000
这个时候应该问 Siri 对不对

94
00:03:26,000 --> 00:03:26,000
对

95
00:03:26,000 --> 00:03:27,000
对

96
00:03:27,000 --> 00:03:27,000
对

97
00:03:27,000 --> 00:03:27,000
对

98
00:03:27,000 --> 00:03:27,000
对

99
00:03:27,000 --> 00:03:27,000
对

100
00:03:27,000 --> 00:03:27,000
对

101
00:03:27,000 --> 00:03:27,000
对

102
00:03:27,000 --> 00:03:27,000
对

103
00:03:27,000 --> 00:03:27,000
对

104
00:03:27,000 --> 00:03:27,000
对

105
00:03:27,000 --> 00:03:27,000
对

106
00:03:27,000 --> 00:03:27,000
对

107
00:03:27,000 --> 00:03:27,000
对

108
00:03:27,000 --> 00:03:27,000
对

109
00:03:27,000 --> 00:03:27,000
对

110
00:03:27,000 --> 00:03:27,000
对

111
00:03:27,000 --> 00:03:27,000
对

112
00:03:27,000 --> 00:03:27,000
对

113
00:03:27,000 --> 00:03:27,000
对

114
00:03:27,000 --> 00:03:27,000
对

115
00:03:27,000 --> 00:03:27,000
对

116
00:03:27,000 --> 00:03:27,000
对

117
00:03:27,000 --> 00:03:27,000
对

118
00:03:27,000 --> 00:03:27,000
对

119
00:03:27,000 --> 00:03:28,000
对

120
00:03:28,000 --> 00:03:28,000
对

121
00:03:28,000 --> 00:03:28,000
对

123
00:03:58,000 --> 00:03:59,000
was

124
00:03:59,000 --> 00:04:00,000
对

125
00:04:00,000 --> 00:04:01,000
对

126
00:04:01,000 --> 00:04:01,000
对

127
00:04:01,000 --> 00:04:01,000
对

128
00:04:01,000 --> 00:04:01,000
对

129
00:04:01,000 --> 00:04:02,000
对

130
00:04:02,000 --> 00:04:02,000
太惨

131
00:04:02,000 --> 00:04:03,000
嗯

132
00:04:03,000 --> 00:04:08,000
上期我们请到了牧羊大神跟我们

133
00:04:08,000 --> 00:04:12,000
然后我们瞬间多了很多粉丝和

134
00:04:12,000 --> 00:04:13,000
没错

135
00:04:13,000 --> 00:04:14,000
这可能是

136
00:04:14,000 --> 00:04:15,000
对

137
00:04:15,000 --> 00:04:20,000
我们我们之前觉得可能键盘股房那一期是比较比较受欢迎的一期

138
00:04:20,000 --> 00:04:25,000
但是现在看来好像就这已经是一个后无来者的

139
00:04:25,000 --> 00:04:27,000
全物古人后无来者的高度了

140
00:04:27,000 --> 00:04:28,000
对吧

141
00:04:28,000 --> 00:04:28,000
对

142
00:04:28,000 --> 00:04:28,000
对

143
00:04:28,000 --> 00:04:29,000
这期真的是

144
00:04:29,000 --> 00:04:32,000
现在看来

145
00:04:32,000 --> 00:04:34,000
不管是在微博上

146
00:04:34,000 --> 00:04:36,000
还是在推特上

147
00:04:36,000 --> 00:04:39,000
还是由热情听众

148
00:04:39,000 --> 00:04:40,000
热心听众们

149
00:04:40,000 --> 00:04:41,000
写的来信里面

150
00:04:41,000 --> 00:04:43,000
这一期都是非常受欢迎

151
00:04:43,000 --> 00:04:45,000
而且引起热议的一期

152
00:04:45,000 --> 00:04:47,000
而且你发现没

153
00:04:47,000 --> 00:04:48,000
这一期出现之后

154
00:04:48,000 --> 00:04:50,000
我们多了很多女粉丝

155
00:04:50,000 --> 00:04:51,000
对

156
00:04:51,000 --> 00:04:54,000
然后我挨个点

157
00:04:54,000 --> 00:04:55,000
经常用微博去看

158
00:04:55,000 --> 00:04:56,000
都是美女竟然

159
00:04:56,000 --> 00:04:58,000
你居然会挨个点

160
00:04:58,000 --> 00:04:59,000
进去看人家的微博

161
00:04:59,000 --> 00:05:00,000
这样对吗

162
00:05:00,000 --> 00:05:02,000
我这个也是要

163
00:05:02,000 --> 00:05:04,000
关注粉丝的反馈

164
00:05:04,000 --> 00:05:04,000
对不对

165
00:05:04,000 --> 00:05:06,000
但我一般看见

166
00:05:06,000 --> 00:05:06,000
头像是美女

167
00:05:06,000 --> 00:05:07,000
才点进去看一下

168
00:05:07,000 --> 00:05:09,000
Current Panic

169
00:05:09,000 --> 00:05:10,000
这么高冷的节目

170
00:05:10,000 --> 00:05:11,000
都要看脸

171
00:05:11,000 --> 00:05:11,000
这样对吗

172
00:05:11,000 --> 00:05:14,000
我们都不露脸

173
00:05:14,000 --> 00:05:14,000
没有关系

174
00:05:14,000 --> 00:05:16,000
好吧

175
00:05:16,000 --> 00:05:18,000
所以看一下

176
00:05:18,000 --> 00:05:20,000
还是什么男神的魅力很大

177
00:05:20,000 --> 00:05:21,000
对

178
00:05:21,000 --> 00:05:22,000
而且有一个

179
00:05:22,000 --> 00:05:25,000
有一条微博说

180
00:05:25,000 --> 00:05:27,000
这一期毕竟都是男神

181
00:05:27,000 --> 00:05:28,000
得点闷

182
00:05:28,000 --> 00:05:28,000
对

183
00:05:28,000 --> 00:05:31,000
然后咱们俩就可怜的屈居在

184
00:05:31,000 --> 00:05:32,000
屈居在那个闷里面

185
00:05:32,000 --> 00:05:36,000
人家还是为了照顾下

186
00:05:36,000 --> 00:05:37,000
我们的情绪而已

187
00:05:37,000 --> 00:05:38,000
不要太当真

188
00:05:38,000 --> 00:05:39,000
不要太当真

189
00:05:39,000 --> 00:05:39,000
好了

190
00:05:39,000 --> 00:05:43,000
其实我们也在酝酿

191
00:05:43,000 --> 00:05:44,000
或者说在

192
00:05:44,000 --> 00:05:46,000
YY

193
00:05:46,000 --> 00:05:49,000
将来还会有一期

194
00:05:49,000 --> 00:05:50,000
请到重新请到幕僚

195
00:05:50,000 --> 00:05:54,000
不过目前没有一个太

196
00:05:54,000 --> 00:05:57,000
确切的时间表

197
00:05:57,000 --> 00:05:58,000
但我们会有一个

198
00:05:58,000 --> 00:05:59,000
说明弄得很深細

199
00:05:59,000 --> 00:06:00,000
而没的时候

200
00:06:00,000 --> 00:06:02,000
可能就是

201
00:06:02,000 --> 00:06:28,000
也会ве

202
00:06:28,000 --> 00:06:30,000
一个将可能出现的主题

203
00:06:30,000 --> 00:06:31,000
写一些你的看法

204
00:06:31,000 --> 00:06:33,000
因为我们现在

205
00:06:33,000 --> 00:06:36,000
主要是会收到一些

206
00:06:36,000 --> 00:06:37,000
feedback

207
00:06:37,000 --> 00:06:40,000
就是主要是在节目播出之后

208
00:06:40,000 --> 00:06:41,000
比如说我们今天

209
00:06:41,000 --> 00:06:42,000
是今天吧

210
00:06:42,000 --> 00:06:45,000
收到一封 2200 多字的读者来信

211
00:06:45,000 --> 00:06:49,000
是一位微软员工

212
00:06:49,000 --> 00:06:53,000
然后专门提供了

213
00:06:53,000 --> 00:06:55,000
上木瑶这一期的很多反馈

214
00:06:55,000 --> 00:06:57,000
但是这些反馈里面有很多

215
00:06:57,000 --> 00:06:57,000
我们都觉得

216
00:06:57,000 --> 00:06:58,000
其实相当有意义

217
00:06:58,000 --> 00:07:01,000
但是全文念出来

218
00:07:01,000 --> 00:07:04,000
实在是会占用比较长的时间

219
00:07:04,000 --> 00:07:06,000
所以也许比较好的一点

220
00:07:06,000 --> 00:07:09,000
比较好的一种模式

221
00:07:09,000 --> 00:07:11,000
是我们告诉听众朋友们

222
00:07:11,000 --> 00:07:13,000
下一期或者说将来会出现的

223
00:07:13,000 --> 00:07:14,000
某一期的话题是什么

224
00:07:14,000 --> 00:07:16,000
然后各位听众可以就此

225
00:07:16,000 --> 00:07:18,000
写一些感想

226
00:07:18,000 --> 00:07:21,000
然后我们可以在节目里面

227
00:07:21,000 --> 00:07:23,000
或者是念出来

228
00:07:23,000 --> 00:07:24,000
或者是就其观点做出讨论

229
00:07:24,000 --> 00:07:25,000
我觉得也挺好的

230
00:07:25,000 --> 00:07:27,000
不错

231
00:07:27,000 --> 00:07:29,000
然后真的很感动

232
00:07:29,000 --> 00:07:32,000
这是本节目开播以来

233
00:07:32,000 --> 00:07:34,000
这也这不算有史以来最长

234
00:07:34,000 --> 00:07:36,000
但是觉得也是较长的

235
00:07:36,000 --> 00:07:38,000
那一些少数了

236
00:07:38,000 --> 00:07:40,000
对是关键是

237
00:07:40,000 --> 00:07:42,000
关键是他说

238
00:07:42,000 --> 00:07:44,000
他说他是微软的员工

239
00:07:44,000 --> 00:07:46,000
然后我们还这么黑他们

240
00:07:46,000 --> 00:07:47,000
对

241
00:07:47,000 --> 00:07:49,000
以后还坚持听

242
00:07:49,000 --> 00:07:50,000
真的是真爱

243
00:07:50,000 --> 00:07:52,000
我们以后下嘴轻一点

244
00:07:52,000 --> 00:07:53,000
特别照顾

245
00:07:53,000 --> 00:07:56,000
特别照顾女女粉丝的心

246
00:07:56,000 --> 00:07:57,000
那个心情

247
00:07:57,000 --> 00:08:00,000
男粉丝就微软专有女粉丝

248
00:08:00,000 --> 00:08:01,000
这个真的不太正常

249
00:08:01,000 --> 00:08:03,000
不过想想肖记姐也是

250
00:08:03,000 --> 00:08:04,000
等等肖记姐是微软粉丝吗

251
00:08:04,000 --> 00:08:05,000
虽然她是微软的员工

252
00:08:05,000 --> 00:08:07,000
但是肖记姐是微软粉丝吗

253
00:08:07,000 --> 00:08:09,000
我们可以下期找

254
00:08:09,000 --> 00:08:11,000
想办法请到她来

255
00:08:11,000 --> 00:08:13,000
你可以当面问她

256
00:08:13,000 --> 00:08:13,000
好好好

257
00:08:13,000 --> 00:08:15,000
你将来一定要有一期请肖记姐

258
00:08:15,000 --> 00:08:18,000
对

259
00:08:18,000 --> 00:08:19,000
总之我觉得上一期

260
00:08:19,000 --> 00:08:21,000
沐瑶这一期到现在还是觉得

261
00:08:21,000 --> 00:08:22,000
怎么说

262
00:08:22,000 --> 00:08:23,000
纯实流行

263
00:08:23,000 --> 00:08:25,000
然后膝盖酸软

264
00:08:25,000 --> 00:08:26,000
上期

265
00:08:27,000 --> 00:08:30,000
anyway

266
00:08:30,000 --> 00:08:34,000
其实回应一下上一期的一些

267
00:08:34,000 --> 00:08:36,000
一些没有彻底展开的观点

268
00:08:36,000 --> 00:08:38,000
其实我后来想了想

269
00:08:38,000 --> 00:08:40,000
上一期提到一些事情

270
00:08:40,000 --> 00:08:40,000
比如说我觉得

271
00:08:40,000 --> 00:08:43,000
比如说工具不好用这件事情

272
00:08:43,000 --> 00:08:46,000
我不知道你怎么觉得

273
00:08:46,000 --> 00:08:48,000
但我觉得现在的变成工具

274
00:08:48,000 --> 00:08:51,000
要比十年前好用太多了

275
00:08:51,000 --> 00:08:52,000
你不觉得吗

276
00:08:52,000 --> 00:08:54,000
我想想十年前我在干嘛

277
00:08:54,000 --> 00:08:56,000
别这样好了

278
00:08:56,000 --> 00:08:57,000
别这样了

279
00:08:57,000 --> 00:08:57,000
别这样了

280
00:08:57,000 --> 00:08:59,000
十年前我刚上大学

281
00:08:59,000 --> 00:09:01,000
还不怎么

282
00:09:01,000 --> 00:09:03,000
然后学的是商科

283
00:09:03,000 --> 00:09:04,000
也不怎么写

284
00:09:04,000 --> 00:09:05,000
也不怎么写程序

285
00:09:05,000 --> 00:09:06,000
没感觉

286
00:09:06,000 --> 00:09:08,000
好吧

287
00:09:08,000 --> 00:09:10,000
但我是觉得

288
00:09:10,000 --> 00:09:12,000
现在的变成工具要比十年前

289
00:09:12,000 --> 00:09:13,000
就是 2005 年左右

290
00:09:13,000 --> 00:09:15,000
真的好用很多

291
00:09:15,000 --> 00:09:16,000
2005 年的时候

292
00:09:16,000 --> 00:09:20,000
不说别的吧

293
00:09:20,000 --> 00:09:21,000
你写一个最简单的

294
00:09:21,000 --> 00:09:22,000
最基础的东西

295
00:09:22,000 --> 00:09:23,000
你写个网页出来

296
00:09:23,000 --> 00:09:24,000
那个时候哪有什么

297
00:09:24,000 --> 00:09:26,000
Vacuum Console 这种东西

298
00:09:26,000 --> 00:09:27,000
那时候哪有什么

299
00:09:27,000 --> 00:09:28,000
那个时候

300
00:09:28,000 --> 00:09:30,000
那个时候

301
00:09:30,000 --> 00:09:32,000
编辑一下

302
00:09:32,000 --> 00:09:33,000
然后刷新页面查看

303
00:09:33,000 --> 00:09:34,000
对啊

304
00:09:34,000 --> 00:09:36,000
而且那个时候用的是 Internet Explorer

305
00:09:36,000 --> 00:09:36,000
好吗

306
00:09:36,000 --> 00:09:37,000
Internet Explorer

307
00:09:37,000 --> 00:09:38,000
那个时候还没有

308
00:09:38,000 --> 00:09:39,000
没有 Tab 的

309
00:09:39,000 --> 00:09:40,000
就是你

310
00:09:40,000 --> 00:09:41,000
你用

311
00:09:41,000 --> 00:09:43,000
那个时候我是用 Notepad++

312
00:09:43,000 --> 00:09:44,000
写一个

313
00:09:44,000 --> 00:09:46,000
写一堆 Markup

314
00:09:46,000 --> 00:09:47,000
然后在微软

315
00:09:47,000 --> 00:09:49,000
在安音里面刷新

316
00:09:49,000 --> 00:09:50,000
现在呢

317
00:09:50,000 --> 00:09:52,000
然后去猜

318
00:09:52,000 --> 00:09:54,000
然后自己头脑中模拟

319
00:09:54,000 --> 00:09:56,000
那个什么 DOM 解析器的一步一步猜

320
00:09:56,000 --> 00:09:57,000
它为什么会这样

321
00:09:57,000 --> 00:09:58,000
对不对

322
00:09:58,000 --> 00:09:59,000
对

323
00:09:59,000 --> 00:10:02,000
而现在 Vacuum Console 是多么好用的一个东西

324
00:10:02,000 --> 00:10:04,000
你可以随时去改

325
00:10:04,000 --> 00:10:07,000
任何一个页面上的大部分元素

326
00:10:07,000 --> 00:10:09,000
但是除非你在用一些比较二的东西

327
00:10:09,000 --> 00:10:12,000
比如说 GWT 这种东西

328
00:10:12,000 --> 00:10:16,000
那搞出来的东西是真的没有办法在 Vacuum Console 里面 debug 的

329
00:10:16,000 --> 00:10:19,000
但是如果你徒手写的话

330
00:10:19,000 --> 00:10:22,000
那这些工具真的要比十年前好太多

331
00:10:22,000 --> 00:10:23,000
对啊

332
00:10:23,000 --> 00:10:26,000
而且很多语言都

333
00:10:26,000 --> 00:10:30,000
现在很多动态语言或者说尤其是动态语言都提供了自己的所谓 REPL

334
00:10:30,000 --> 00:10:33,000
Repo

335
00:10:33,000 --> 00:10:34,000
对

336
00:10:34,000 --> 00:10:36,000
这是什么缩起来的

337
00:10:36,000 --> 00:10:36,000
Write

338
00:10:36,000 --> 00:10:37,000
Read

339
00:10:37,000 --> 00:10:39,000
Evaluate

340
00:10:39,000 --> 00:10:40,000
Print loop

341
00:10:40,000 --> 00:10:41,000
读入

342
00:10:41,000 --> 00:10:43,000
然后叫什么 Evaluate 中文叫

343
00:10:43,000 --> 00:10:44,000
求职

344
00:10:44,000 --> 00:10:46,000
求职打印

345
00:10:46,000 --> 00:10:47,000
循环

346
00:10:47,000 --> 00:10:48,000
对

347
00:10:48,000 --> 00:10:53,000
当然 Repo 其实并不是一个非常新颖的东西

348
00:10:53,000 --> 00:10:54,000
就比如说

349
00:10:54,000 --> 00:10:55,000
你说

350
00:10:56,000 --> 00:10:57,000
就是说他就有了

351
00:10:57,000 --> 00:10:59,000
对而且

352
00:10:59,000 --> 00:11:05,000
就哪怕是命令式语言在 Basic 上面其实也是一个 Repo 呀

353
00:11:05,000 --> 00:11:06,000
就

354
00:11:06,000 --> 00:11:10,000
在 Apple R 上面的 Basic 也是一个 Repo

355
00:11:10,000 --> 00:11:12,000
也是一行一行解析执行的

356
00:11:12,000 --> 00:11:15,000
除非你打行号然后再

357
00:11:15,000 --> 00:11:16,000
再打 Run

358
00:11:16,000 --> 00:11:19,000
否则他就是一个默认就是一个 Repo

359
00:11:19,000 --> 00:11:24,000
但是现在的 Repo 要比又要比那个时候的 Repo 要好太多了

360
00:11:24,000 --> 00:11:25,000
就

361
00:11:25,000 --> 00:11:26,000
不管是

362
00:11:26,000 --> 00:11:32,000
比如说我们有现在像 iPython 这样的非常实用的日常笔记本工具

363
00:11:32,000 --> 00:11:35,000
Rubio

364
00:11:35,000 --> 00:11:36,000
Pray

365
00:11:36,000 --> 00:11:39,000
是念 Pray 吧

366
00:11:39,000 --> 00:11:40,000
Pry

367
00:11:40,000 --> 00:11:41,000
就是撬棍的那个词

368
00:11:41,000 --> 00:11:43,000
还是念 Pry

369
00:11:43,000 --> 00:11:45,000
Pry 没怎么用

370
00:11:45,000 --> 00:11:46,000
Pry 没怎么用

371
00:11:46,000 --> 00:11:52,000
这些东西都是支持比如说你在书的时候就可以语法高谅然后

372
00:11:52,000 --> 00:11:55,000
甚至你可以把它当成一个

373
00:11:55,000 --> 00:11:56,000
一个包

374
00:11:56,000 --> 00:11:59,000
嵌到你的

375
00:11:59,000 --> 00:12:01,000
嵌到你要想要 debug 的程序里面

376
00:12:01,000 --> 00:12:04,000
然后你在那个地方设置一个以前是要设置一个断点

377
00:12:04,000 --> 00:12:06,000
用什么 PYDB 之类的

378
00:12:06,000 --> 00:12:08,000
而现在你可以直接把 iPython

379
00:12:08,000 --> 00:12:09,000
断在那个地方

380
00:12:09,000 --> 00:12:10,000
然后

381
00:12:10,000 --> 00:12:12,000
执行到那时候你跳出来一个 iPython 执行环境

382
00:12:12,000 --> 00:12:14,000
你可以随便想干什么都干什么

383
00:12:14,000 --> 00:12:16,000
对

384
00:12:16,000 --> 00:12:19,000
然后有比如说我们之前

385
00:12:19,000 --> 00:12:23,000
在苹果的发布会上看到的 Swift 的那个 Playground

386
00:12:23,000 --> 00:12:24,000
他其实也是一个

387
00:12:24,000 --> 00:12:27,000
更为先进的 Ripple 吧

388
00:12:27,000 --> 00:12:31,000
就是他有所谓 Live Programming 的能力

389
00:12:31,000 --> 00:12:35,000
你可以更加直观的看到你写出来的东西是什么

390
00:12:35,000 --> 00:12:39,000
或者说他跑起来他在局部跑起来是一个什么样的

391
00:12:39,000 --> 00:12:40,000
过程

392
00:12:40,000 --> 00:12:43,000
其实都是非常非常方便的一些特性

393
00:12:43,000 --> 00:12:45,000
就是说

394
00:12:45,000 --> 00:12:49,000
我们这么过去十几年间就在普及用的工具还是在进步吧

395
00:12:49,000 --> 00:12:51,000
不过我觉得可能

396
00:12:51,000 --> 00:12:52,000
离真正像

397
00:12:52,000 --> 00:12:54,000
普通人或者是说像穆扬老师之间的工具

398
00:12:54,000 --> 00:12:57,000
就不太喜欢

399
00:12:57,000 --> 00:12:59,000
花时间去学这种工具的人

400
00:12:59,000 --> 00:13:01,000
他可能还是有点困难

401
00:13:01,000 --> 00:13:03,000
比如说至少我们在日常用的时候

402
00:13:03,000 --> 00:13:05,000
很多那种 Ripple

403
00:13:05,000 --> 00:13:07,000
他还是有很多限制的嘛

404
00:13:07,000 --> 00:13:10,000
比如你不能做很多事情有时候

405
00:13:10,000 --> 00:13:12,000
而且对这个环境的 inspection

406
00:13:12,000 --> 00:13:16,000
就是检查的能力也是有一定的限制的

407
00:13:16,000 --> 00:13:17,000
你不像说在

408
00:13:17,000 --> 00:13:21,000
像再早一点什么像 smalltalk 那种虚拟机那叫什么

409
00:13:21,000 --> 00:13:22,000
Scroll 对不对

410
00:13:22,000 --> 00:13:24,000
对他自带一个

411
00:13:24,000 --> 00:13:25,000
核体核指就是怎么说呢

412
00:13:25,000 --> 00:13:27,000
是有点像 IDE 但又不像

413
00:13:27,000 --> 00:13:29,000
都不是 IDE 的这么一个

414
00:13:29,000 --> 00:13:31,000
他的那个好处就是说整个那个

415
00:13:31,000 --> 00:13:35,000
那个整个就是那个环境那个操作系统那个世界

416
00:13:35,000 --> 00:13:36,000
都是可以被 inspection

417
00:13:36,000 --> 00:13:38,000
就是可以很方便的

418
00:13:38,000 --> 00:13:41,000
很统一的规则去做它

419
00:13:41,000 --> 00:13:41,000
所以

420
00:13:41,000 --> 00:13:43,000
历史上是

421
00:13:43,000 --> 00:13:45,000
确实曾经出现过那种所谓

422
00:13:45,000 --> 00:13:47,000
哪怕是按现在的观点来看

423
00:13:47,000 --> 00:13:49,000
就是所谓惊为天人的

424
00:13:49,000 --> 00:13:51,000
这种工具的设计

425
00:13:51,000 --> 00:13:53,000
但是只是因为一些

426
00:13:53,000 --> 00:13:54,000
商业的

427
00:13:54,000 --> 00:13:56,000
或者是这个其他的原因没有流行起来嘛

428
00:13:56,000 --> 00:13:58,000
所以现在我们

429
00:13:58,000 --> 00:13:59,000
还是在

430
00:13:59,000 --> 00:14:01,000
不断的去朝那个方向演进

431
00:14:01,000 --> 00:14:04,000
虽然还没有达到那个高度而已

432
00:14:04,000 --> 00:14:07,000
其实这也是一个很有意思的问题就是

433
00:14:07,000 --> 00:14:11,000
有时候我们很难说一个成功的

434
00:14:11,000 --> 00:14:13,000
事物

435
00:14:13,000 --> 00:14:15,000
就是因为他的技术比较优越

436
00:14:15,000 --> 00:14:17,000
而经常都不是这样子的嘛

437
00:14:17,000 --> 00:14:21,000
特别是在技术界里面不是有个说法吗叫做 Worse is better

438
00:14:21,000 --> 00:14:23,000
就好像经常很多人吐槽说

439
00:14:23,000 --> 00:14:23,000
哎呀你那个 Linux

440
00:14:23,000 --> 00:14:24,000
是这么流行

441
00:14:24,000 --> 00:14:26,000
但是你看下你的底层的设计

442
00:14:26,000 --> 00:14:28,000
很多地方是很不优雅的

443
00:14:28,000 --> 00:14:29,000
很不 unixy 的嘛

444
00:14:29,000 --> 00:14:30,000
对吧

445
00:14:30,000 --> 00:14:30,000
很恶心的

446
00:14:30,000 --> 00:14:33,000
但是反过来你说那些优雅的

447
00:14:33,000 --> 00:14:36,000
比较高竿的东西却又往往流行不起来

448
00:14:36,000 --> 00:14:37,000
比如说 plan 9

449
00:14:37,000 --> 00:14:37,000
就

450
00:14:39,000 --> 00:14:40,000
甚至

451
00:14:40,000 --> 00:14:42,000
不说 plan 9 这么比较冷门的东西

452
00:14:42,000 --> 00:14:45,000
编程语言里面也是

453
00:14:45,000 --> 00:14:46,000
基本上是

454
00:14:46,000 --> 00:14:48,000
比较流行的语言往往是比较糟糕的语言

455
00:14:48,000 --> 00:14:50,000
哈哈哈

456
00:14:50,000 --> 00:14:52,000
尽管他用的语言还可以

457
00:14:52,000 --> 00:14:53,000
算了

458
00:14:53,000 --> 00:14:55,000
我们就不举具体的事例

459
00:14:55,000 --> 00:14:56,000
OK

460
00:14:57,000 --> 00:14:58,000
嗯

461
00:14:59,000 --> 00:14:59,000
对

462
00:14:59,000 --> 00:15:00,000
然后

463
00:15:00,000 --> 00:15:06,000
但是我也承认就是现在的编程工具虽然要比 10 年前好很多

464
00:15:06,000 --> 00:15:09,000
但他们仍旧没有能够好到一个就是

465
00:15:10,000 --> 00:15:11,000
怎么说呢就是造成一个

466
00:15:12,000 --> 00:15:13,000
所谓范式转化

467
00:15:14,000 --> 00:15:14,000
的地步

468
00:15:15,000 --> 00:15:16,000
就是没有说一个

469
00:15:16,000 --> 00:15:18,000
工具是如此好用以至于

470
00:15:18,000 --> 00:15:20,000
整个编程界的

471
00:15:20,000 --> 00:15:23,000
整个编程方法论都被颠覆了

472
00:15:23,000 --> 00:15:24,000
对了

473
00:15:24,000 --> 00:15:25,000
对了还没有

474
00:15:26,000 --> 00:15:27,000
还没有出现过这种东西吧

475
00:15:28,000 --> 00:15:29,000
就出现曾经出现过但是

476
00:15:30,000 --> 00:15:31,000
没有被

477
00:15:32,000 --> 00:15:33,000
保留下来可以这么讲

478
00:15:34,000 --> 00:15:37,000
就就好像有一个电影有部电影叫什么剑与行动

479
00:15:37,000 --> 00:15:38,000
里面

480
00:15:38,000 --> 00:15:39,000
主角

481
00:15:40,000 --> 00:15:40,000
在

482
00:15:41,000 --> 00:15:45,000
在编程的时候他编程的方法就是把一大堆方块拖来拖去

483
00:15:46,000 --> 00:15:47,000
然后而且是

484
00:15:47,000 --> 00:15:48,000
而且是非常

485
00:15:49,000 --> 00:15:52,000
看起来同样很复杂但是你会觉得

486
00:15:52,000 --> 00:15:53,000
你会

487
00:15:53,000 --> 00:15:57,000
就是至少观众们会认为这是在编程但在程序员看来这是在搞

488
00:15:57,000 --> 00:15:58,000
这是在解割方块吗还是怎样

489
00:16:00,000 --> 00:16:02,000
如果真的有那样的工具出现的话呢

490
00:16:03,000 --> 00:16:04,000
也许是一个

491
00:16:04,000 --> 00:16:06,000
非常颠覆性的

492
00:16:06,000 --> 00:16:07,000
创新秘诀

493
00:16:07,000 --> 00:16:09,000
到那个时候也许

494
00:16:09,000 --> 00:16:11,000
慕尧大神们就可以

495
00:16:12,000 --> 00:16:12,000
比较

496
00:16:13,000 --> 00:16:14,000
无障碍的

497
00:16:15,000 --> 00:16:17,000
利用编程工具解决

498
00:16:17,000 --> 00:16:18,000
解决

499
00:16:18,000 --> 00:16:19,000
更

500
00:16:19,000 --> 00:16:22,000
怎么说呢抽象层级更高的问题而不是去

501
00:16:22,000 --> 00:16:23,000
而不是去

502
00:16:24,000 --> 00:16:25,000
操心这些

503
00:16:25,000 --> 00:16:26,000
西子墨节比如说

504
00:16:26,000 --> 00:16:27,000
分号或者是

505
00:16:27,000 --> 00:16:28,000
锁进之类的事情

506
00:16:29,000 --> 00:16:29,000
没错

507
00:16:30,000 --> 00:16:31,000
我觉得

508
00:16:31,000 --> 00:16:33,000
有时候我在想啊其实

509
00:16:33,000 --> 00:16:35,000
可能现在造成现在这种

510
00:16:35,000 --> 00:16:41,000
工具比较乱然后设计也不够优雅的局面是不是我有时候在想

511
00:16:41,000 --> 00:16:47,000
是不是应该等我们这批人死掉之后要从另外一批人重新来设计那么一些理念可能会好一点

512
00:16:48,000 --> 00:16:49,000
从娃娃抓起重新想一下

513
00:16:50,000 --> 00:16:51,000
怎么去教

514
00:16:51,000 --> 00:16:51,000
小朋友

515
00:16:52,000 --> 00:16:53,000
一个比较直观的

516
00:16:54,000 --> 00:16:56,000
或者说更加合理的

517
00:16:56,000 --> 00:16:57,000
抽象层级吧

518
00:16:58,000 --> 00:16:58,000
然后将来

519
00:16:58,000 --> 00:17:00,000
初步就学会新的方式

520
00:17:01,000 --> 00:17:02,000
会有意思很多

521
00:17:03,000 --> 00:17:03,000
对

522
00:17:03,000 --> 00:17:06,000
有时候对有时候我个其实刚刚也在想这个问题就是

523
00:17:06,000 --> 00:17:08,000
我想到

524
00:17:08,000 --> 00:17:13,000
虽然 60 年代的那一批计算机先去美人留门去了但是我们现在活着的

525
00:17:14,000 --> 00:17:15,000
呃

526
00:17:15,000 --> 00:17:16,000
像先去门比如说 rollpack

527
00:17:16,000 --> 00:17:17,000
rollpack

528
00:17:17,000 --> 00:17:18,000
还是在

529
00:17:18,000 --> 00:17:20,000
做在在 Google 做一线的这种

530
00:17:21,000 --> 00:17:22,000
原开发工作

531
00:17:22,000 --> 00:17:23,000
但是我在想说

532
00:17:24,000 --> 00:17:24,000
我们

533
00:17:24,000 --> 00:17:26,000
能够和这些人

534
00:17:26,000 --> 00:17:29,000
仍旧在同一个时代是一种幸福但是如果

535
00:17:29,000 --> 00:17:32,000
再远一点比如过 20 30 年等这批人去了之后

536
00:17:33,000 --> 00:17:34,000
那个时候的编程的

537
00:17:35,000 --> 00:17:37,000
的地平线会是一个什么样的

538
00:17:37,000 --> 00:17:39,000
什么样的风景的可能会跟现在完全不一样

539
00:17:40,000 --> 00:17:40,000
就

540
00:17:41,000 --> 00:17:45,000
就好像那天我做的那个内燃机的比喻也许我们现在用的就是内燃机也许

541
00:17:45,000 --> 00:17:46,000
也许

542
00:17:47,000 --> 00:17:48,000
过了 20 年

543
00:17:48,000 --> 00:17:50,000
电动机出现的时候编程真的

544
00:17:50,000 --> 00:17:51,000
和现在的

545
00:17:51,000 --> 00:17:53,000
和现在我们所熟悉的这些工具

546
00:17:54,000 --> 00:17:54,000
呃

547
00:17:54,000 --> 00:17:56,000
就完全不一样

548
00:17:57,000 --> 00:17:59,000
而且这是一种很难想象的

549
00:18:00,000 --> 00:18:03,000
状态也是那个时候我也不知道三进制计算机

550
00:18:03,000 --> 00:18:05,000
平衡三进制计算机

551
00:18:05,000 --> 00:18:06,000
起码的

552
00:18:06,000 --> 00:18:10,000
起码的人永远不会想到会飞的人是怎么样的一种心态对不对

553
00:18:11,000 --> 00:18:12,000
对就好像

554
00:18:13,000 --> 00:18:14,000
那些

555
00:18:14,000 --> 00:18:20,000
19 世纪初期的科幻画想幻想 20 世纪是什么样子那个时候想到 20 世纪说每个人都在

556
00:18:20,000 --> 00:18:22,000
天上飞然后天上飞的

557
00:18:22,000 --> 00:18:23,000
人会

558
00:18:24,000 --> 00:18:25,000
受到天上

559
00:18:25,000 --> 00:18:27,000
飞的交警的指挥

560
00:18:27,000 --> 00:18:27,000
可是他

561
00:18:28,000 --> 00:18:30,000
可是他画出来那个会在天上飞的交警

562
00:18:30,000 --> 00:18:35,000
身上是一双翅膀而且还是在那边吹哨子

563
00:18:35,000 --> 00:18:36,000
就

564
00:18:36,000 --> 00:18:38,000
如果现在有什么

565
00:18:39,000 --> 00:18:43,000
空中单人的交通工具的话那我相信

566
00:18:43,000 --> 00:18:47,000
去控制这种交通工具的规则肯定不会是吹哨子吧

567
00:18:47,000 --> 00:18:50,000
灵速已经太慢了

568
00:18:50,000 --> 00:18:53,000
对所以我们现在所做出的任何想象可能在那个时候

569
00:18:54,000 --> 00:18:55,000
看来都是非常幼稚而可笑的

570
00:18:57,000 --> 00:18:59,000
但这仍旧拦不住我们去想

571
00:19:01,000 --> 00:19:03,000
好吧那个什么上期的

572
00:19:03,000 --> 00:19:05,000
风浪都到这里

573
00:19:05,000 --> 00:19:05,000
我们

574
00:19:06,000 --> 00:19:07,000
其实还有一个就是

575
00:19:08,000 --> 00:19:09,000
上期

576
00:19:10,000 --> 00:19:14,000
莫要说到的比如说那个有些语言非常要求你

577
00:19:14,000 --> 00:19:15,000
什么

578
00:19:15,000 --> 00:19:18,000
注意分号缩进大小写之类的

579
00:19:18,000 --> 00:19:23,000
他有没有说大小小不记得但是我前两天看了看那个内门元就是新出的那个

580
00:19:24,000 --> 00:19:26,000
之前叫你没有的然后现在的你们的语言

581
00:19:27,000 --> 00:19:30,000
这个原有一个很有趣的一点就是他

582
00:19:31,000 --> 00:19:33,000
区分一个标识符的时候

583
00:19:34,000 --> 00:19:35,000
只区分第一个字母是不是大小写

584
00:19:36,000 --> 00:19:37,000
后面是

585
00:19:37,000 --> 00:19:38,000
无关的

586
00:19:38,000 --> 00:19:39,000
而且

587
00:19:39,000 --> 00:19:40,000
带下滑线也是无关的

588
00:19:41,000 --> 00:19:43,000
这有什么好处呢

589
00:19:43,000 --> 00:19:47,000
就是他他列举的好处是比如说你你的

590
00:19:48,000 --> 00:19:49,000
你写一个

591
00:19:51,000 --> 00:19:52,000
写一个程序要用到别人的库

592
00:19:52,000 --> 00:19:53,000
别人的库有一个

593
00:19:54,000 --> 00:19:55,000
他自己的变量考问神

594
00:19:56,000 --> 00:19:56,000
然后

595
00:19:57,000 --> 00:19:57,000
或者说

596
00:19:57,000 --> 00:19:59,000
韩数考问

597
00:19:59,000 --> 00:20:01,000
当你要掉用那些凯数的时候

598
00:20:01,000 --> 00:20:02,000
你可以

599
00:20:03,000 --> 00:20:07,000
利用自己的考问神因为也许他是用下下滑线做分和分隔幅的

600
00:20:08,000 --> 00:20:09,000
而你喜欢开门

601
00:20:09,000 --> 00:20:10,000
那你可以

602
00:20:10,000 --> 00:20:11,000
在你的程序里面写开门

603
00:20:12,000 --> 00:20:15,000
成那个编辑器会自己去猜

604
00:20:15,000 --> 00:20:15,000
真正的

605
00:20:16,000 --> 00:20:17,000
标识符是什么

606
00:20:18,000 --> 00:20:22,000
就我觉得这是一个很有很有意思的很有意思的 feature

607
00:20:22,000 --> 00:20:23,000
对

608
00:20:24,000 --> 00:20:24,000
但

609
00:20:25,000 --> 00:20:27,000
可能从另外一个角度讲他也是在

610
00:20:27,000 --> 00:20:29,000
试图解决这样一种就是

611
00:20:29,000 --> 00:20:33,000
你可以再去忽略另外一个细节就是你不用去

612
00:20:34,000 --> 00:20:37,000
永远去刻意的注意大小小一致然后你可以

613
00:20:37,000 --> 00:20:41,000
借用这个 feature 来保证自己的编程风格在内部是一致

614
00:20:42,000 --> 00:20:43,000
嗯

615
00:20:44,000 --> 00:20:46,000
说一下最终发生的一些小新闻吧

616
00:20:47,000 --> 00:20:49,000
然后那个你也看到那个苹果发布会了哈

617
00:20:50,000 --> 00:20:50,000
好呀

618
00:20:51,000 --> 00:20:53,000
那我们之前专门讨论过那个谣传中的新的

619
00:20:54,000 --> 00:20:54,000
MacBook

620
00:20:55,000 --> 00:20:57,000
他其实不是 air 就是每个 MacBook

621
00:20:58,000 --> 00:20:58,000
然后

622
00:20:58,000 --> 00:21:00,000
你对其实很有很有很有趣的

623
00:21:01,000 --> 00:21:03,000
为什么 MacBook Air 还叫 MacBook Air

624
00:21:03,000 --> 00:21:05,000
新的这个更薄更 Air 的还叫

625
00:21:05,000 --> 00:21:06,000
反而叫 MacBook

626
00:21:07,000 --> 00:21:09,000
我后来是这么理解的就是

627
00:21:10,000 --> 00:21:14,000
因为你有现在就现在那个 MacBook Pro 他也变得很薄了吗

628
00:21:14,000 --> 00:21:16,000
所以以后就不分

629
00:21:16,000 --> 00:21:17,000
有这个 air 就干了

630
00:21:18,000 --> 00:21:19,000
薄是一个必然的属性

631
00:21:20,000 --> 00:21:21,000
然后只区分是否专业

632
00:21:22,000 --> 00:21:23,000
所以 MacBook Air 那个产品线

633
00:21:23,000 --> 00:21:25,000
可能过几年过两三年就

634
00:21:25,000 --> 00:21:26,000
直接就消失了

635
00:21:26,000 --> 00:21:27,000
OK

636
00:21:27,000 --> 00:21:30,000
就只有 MacBook 和 MacBook Pro 这样的两个分野

637
00:21:30,000 --> 00:21:32,000
这样就是更清晰的一个结构

638
00:21:33,000 --> 00:21:36,000
然后如果你要比 MacBook 更薄的东西就只能去买 iPad 了

639
00:21:38,000 --> 00:21:38,000
对没错

640
00:21:39,000 --> 00:21:39,000
OK

641
00:21:40,000 --> 00:21:43,000
可以最最重要的一件事情是

642
00:21:43,000 --> 00:21:46,000
escape 键没有动

643
00:21:46,000 --> 00:21:50,000
对我觉得他们也应该是内部顶住了巨大的压力

644
00:21:50,000 --> 00:21:53,000
我们先不确定之前那个那个图上面那个

645
00:21:54,000 --> 00:21:56,000
就是真的有原型机长那样吗

646
00:21:57,000 --> 00:21:58,000
其实是挺值得怀疑的

647
00:21:59,000 --> 00:22:03,000
好吧说的是也有可能内部从来没有出现过一个 escape 在这么

648
00:22:03,000 --> 00:22:05,000
在这么让人天动人愿的地方

649
00:22:05,000 --> 00:22:09,000
这个那个那个谁画图的时候不小心就画成那样了

650
00:22:10,000 --> 00:22:10,000
而已

651
00:22:11,000 --> 00:22:12,000
不过不管如何

652
00:22:12,000 --> 00:22:13,000
escape 键的

653
00:22:13,000 --> 00:22:15,000
位置没变而且还变大了

654
00:22:15,000 --> 00:22:16,000
这个是挺好的一件事

655
00:22:17,000 --> 00:22:19,000
你用过那个 11 寸的 MacBook Air 吗

656
00:22:19,000 --> 00:22:21,000
用过一次就是我有一次

657
00:22:22,000 --> 00:22:23,000
借前公司的老板的

658
00:22:24,000 --> 00:22:26,000
那个办公电脑出过一次差

659
00:22:27,000 --> 00:22:30,000
你们公司已经这么惨还要借老板的电脑出差

660
00:22:30,000 --> 00:22:32,000
因为我自己的电脑太大了

661
00:22:32,000 --> 00:22:33,000
太重了

662
00:22:35,000 --> 00:22:37,000
我觉得我不是很喜欢 MacBook Air

663
00:22:37,000 --> 00:22:39,000
当然可能主要也是因为

664
00:22:39,000 --> 00:22:40,000
就是屏幕实在是太小了

665
00:22:41,000 --> 00:22:42,000
11 寸的确实是很小

666
00:22:42,000 --> 00:22:44,000
13 寸的还是很小

667
00:22:45,000 --> 00:22:46,000
它边框也比较大嘛

668
00:22:47,000 --> 00:22:47,000
对

669
00:22:47,000 --> 00:22:49,000
所以你会觉得挺糟糕的

670
00:22:49,000 --> 00:22:52,000
特别是 11 寸那个 escape 键特别小

671
00:22:53,000 --> 00:22:53,000
因为它那个大

672
00:22:53,000 --> 00:22:54,000
半高

673
00:22:54,000 --> 00:22:56,000
三分之一高的那个键吧

674
00:22:57,000 --> 00:22:59,000
然后而且还那么小一坨

675
00:22:59,000 --> 00:23:01,000
现在那个 MacBook Air 的 escape 键

676
00:23:01,000 --> 00:23:02,000
变得很长嘛

677
00:23:02,000 --> 00:23:03,000
我们作为

678
00:23:03,000 --> 00:23:04,000
一个

679
00:23:04,000 --> 00:23:05,000
Vim 档

680
00:23:05,000 --> 00:23:06,000
这件事什么

681
00:23:06,000 --> 00:23:07,000
福音啊

682
00:23:07,000 --> 00:23:08,000
对

683
00:23:09,000 --> 00:23:10,000
所以所以你是要买一台

684
00:23:11,000 --> 00:23:13,000
如果听上次 ID 公论的

685
00:23:14,000 --> 00:23:15,000
印象没错

686
00:23:16,000 --> 00:23:18,000
我老婆那台还要换嘛

687
00:23:18,000 --> 00:23:20,000
给他买台顺便我玩一下到时候

688
00:23:20,000 --> 00:23:21,000
假设我要出门

689
00:23:21,000 --> 00:23:23,000
做点什么事情我就拿他那台去

690
00:23:23,000 --> 00:23:24,000
好了

691
00:23:24,000 --> 00:23:25,000
OK

692
00:23:25,000 --> 00:23:27,000
这就是顺便玩一下

693
00:23:27,000 --> 00:23:28,000
就是

694
00:23:28,000 --> 00:23:30,000
80%时间是你在用

695
00:23:30,000 --> 00:23:36,000
那个性能不太够啊他那个最高就内存是固定的 8 G 不能再扩张了

696
00:23:36,000 --> 00:23:38,000
这是比较一个蛋疼一点

697
00:23:38,000 --> 00:23:40,000
8 G 真的不是很够

698
00:23:40,000 --> 00:23:44,000
因为这个事情其实还是挺麻烦的现在你看一下

699
00:23:44,000 --> 00:23:47,000
我们跑了很多软件的特别是 64 位之后

700
00:23:47,000 --> 00:23:49,000
那些很多软件的体积是

701
00:23:49,000 --> 00:23:50,000
就越来越大了

702
00:23:51,000 --> 00:23:51,000
而且现在

703
00:23:51,000 --> 00:23:53,000
开个网页动不动就几百

704
00:23:53,000 --> 00:23:55,000
一个 Tab 就几百照上一个机的

705
00:23:56,000 --> 00:23:57,000
所以还是

706
00:23:57,000 --> 00:24:00,000
8 G 你要再开虚拟机的话就肯定是不太

707
00:24:00,000 --> 00:24:01,000
有点捉襟见肘吧至少

708
00:24:02,000 --> 00:24:02,000
对

709
00:24:04,000 --> 00:24:06,000
你那台是 16 的吗

710
00:24:06,000 --> 00:24:08,000
我现在这台是 16 的

711
00:24:08,000 --> 00:24:09,000
OK 我也是 16 的

712
00:24:09,000 --> 00:24:14,000
现在就作为一个开发者的话可能还是要 16 才至少一够吧

713
00:24:14,000 --> 00:24:17,000
当然现在可能主要瓶颈不是在

714
00:24:17,000 --> 00:24:18,000
内存上

715
00:24:18,000 --> 00:24:22,000
就有时候跑一些比较大的游戏会风扇狂转

716
00:24:22,000 --> 00:24:23,000
他那个没有风扇狂转

717
00:24:23,000 --> 00:24:24,000
不是内存的问题

718
00:24:25,000 --> 00:24:26,000
对我是说我现在这台的

719
00:24:28,000 --> 00:24:31,000
如果买新的 Macbook 应该就很多游戏又不能玩了

720
00:24:32,000 --> 00:24:37,000
不知道他那款性能现在还没出来昨天我看了一下那个有网上有测评

721
00:24:37,000 --> 00:24:39,000
联想出了一款

722
00:24:39,000 --> 00:24:40,000
就出了一款那个

723
00:24:41,000 --> 00:24:41,000
那个什么

724
00:24:41,000 --> 00:24:43,000
他那种联想不是有个本来可以

725
00:24:43,000 --> 00:24:45,000
变成平板用的那种笔记本吗

726
00:24:45,000 --> 00:24:46,000
就是我本来的

727
00:24:46,000 --> 00:24:47,000
Convert

728
00:24:48,000 --> 00:24:49,000
Tablet 之类的

729
00:24:49,000 --> 00:24:53,000
他用的那个处理器我看了一下性能和那个参数应该是合理的

730
00:24:53,000 --> 00:24:57,000
他用的那个新款的那个 Macbook 里面那款是差不多的

731
00:24:57,000 --> 00:24:59,000
我看了一下他的那个测评的性能

732
00:24:59,000 --> 00:25:03,000
其实跟 14 款的 Macbook Air 是差不多的

733
00:25:03,000 --> 00:25:06,000
我觉得还凑合了就其实很多时候已经够用了

734
00:25:07,000 --> 00:25:12,000
就只要你不是经常要编译什么编译 swift 的代码的话

735
00:25:12,000 --> 00:25:16,000
你只是做一些比如说像我用 go 的话就编译很快嘛就无所谓

736
00:25:16,000 --> 00:25:21,000
然后你说做 web 开发都是动态语言没有这个编译过程那也无所谓所以

737
00:25:21,000 --> 00:25:23,000
我觉得性能可能最大多数情况下

738
00:25:23,000 --> 00:25:24,000
也是也是

739
00:25:24,000 --> 00:25:24,000
凑合够了

740
00:25:27,000 --> 00:25:29,000
好吧我觉得可能做 iOS 开发还是

741
00:25:29,000 --> 00:25:30,000
有点够强

742
00:25:31,000 --> 00:25:32,000
屏幕太小了

743
00:25:34,000 --> 00:25:38,000
我觉得 iOS 开发跑那个模拟器的时候其实还是挺

744
00:25:38,000 --> 00:25:39,000
挺吃虧的

745
00:25:40,000 --> 00:25:40,000
对

746
00:25:41,000 --> 00:25:41,000
而且

747
00:25:41,000 --> 00:25:43,000
他们现在不是说这个事吗就是

748
00:25:43,000 --> 00:25:48,000
因为现在不是所有的 iOS 都是所谓的 Retina 分辨率嘛就是两倍的

749
00:25:48,000 --> 00:25:52,000
那么你要在屏幕上真实华为 1 比 1 的话你的屏幕要比那个大

750
00:25:53,000 --> 00:25:53,000
对

751
00:25:53,000 --> 00:25:59,000
现在如果你屏幕那么小的话就没有办法很好的还原他就装不模拟器装不下来只能缩放

752
00:25:59,000 --> 00:25:59,000
不是太好

753
00:26:00,000 --> 00:26:03,000
但是我相信现在也有很多开发者就是他

754
00:26:03,000 --> 00:26:07,000
如果他真的要跑的话他就不在问题上跑直接接受上真机吗

755
00:26:08,000 --> 00:26:08,000
对

756
00:26:08,000 --> 00:26:14,000
也是那个传输好像还是比较就你那个就是那个 sicco 还是比较长你要传到那个

757
00:26:15,000 --> 00:26:20,000
iOS 上去然后你要马上看结果中间还是要等那么可能一两分钟吧

758
00:26:20,000 --> 00:26:21,000
额

759
00:26:22,000 --> 00:26:23,000
我的

760
00:26:23,000 --> 00:26:25,000
Thin

761
00:26:26,000 --> 00:26:26,000
其实

762
00:26:27,000 --> 00:26:53,000
我们已经

763
00:26:53,000 --> 00:26:55,000
对我觉得到后期 iOS 开发

764
00:26:55,000 --> 00:27:02,000
其实很多人都是会花相对长的时间在写

765
00:27:02,000 --> 00:27:04,000
然后真正看效果的时间

766
00:27:04,000 --> 00:27:07,000
可能只有开发时间的 10%不到

767
00:27:07,000 --> 00:27:10,000
但除非你在 debug 的话

768
00:27:10,000 --> 00:27:12,000
那要另说

769
00:27:12,000 --> 00:27:14,000
对

770
00:27:14,000 --> 00:27:15,000
没错

771
00:27:15,000 --> 00:27:15,000
对

772
00:27:15,000 --> 00:27:20,000
这个新款的本还有一个挺大的事

773
00:27:20,000 --> 00:27:22,000
是它键盘的轴不一样了

774
00:27:23,000 --> 00:27:23,000
蝴蝶轴

775
00:27:23,000 --> 00:27:24,000
蝴蝶轴

776
00:27:24,000 --> 00:27:25,000
你有概念吗

777
00:27:25,000 --> 00:27:28,000
我其实也没有很看懂

778
00:27:28,000 --> 00:27:29,000
这个蝴蝶轴

779
00:27:29,000 --> 00:27:32,000
它是这次才新发明

780
00:27:32,000 --> 00:27:34,000
之前是没有这种机制的是吧

781
00:27:34,000 --> 00:27:34,000
就没有

782
00:27:34,000 --> 00:27:35,000
之前是只有剪刀脚的

783
00:27:35,000 --> 00:27:36,000
对吧

784
00:27:36,000 --> 00:27:37,000
我说苹果上

785
00:27:37,000 --> 00:27:38,000
就在其他人有用过这种

786
00:27:38,000 --> 00:27:39,000
所谓蝴蝶轴

787
00:27:39,000 --> 00:27:40,000
从来没有

788
00:27:40,000 --> 00:27:41,000
从来没有见过

789
00:27:41,000 --> 00:27:41,000
因为我看

790
00:27:41,000 --> 00:27:44,000
他说的是应该是他们自己新发明的一种

791
00:27:44,000 --> 00:27:47,000
一种键盘轴的机制

792
00:27:47,000 --> 00:27:47,000
对

793
00:27:47,000 --> 00:27:49,000
然后他说这里有个好处

794
00:27:49,000 --> 00:27:50,000
就是说剪刀脚

795
00:27:50,000 --> 00:27:50,000
有个问题就是说

796
00:27:50,000 --> 00:27:52,000
如果你它会不平稳

797
00:27:52,000 --> 00:27:52,000
就是

798
00:27:52,000 --> 00:27:55,000
你说你按一个键的一个角落

799
00:27:55,000 --> 00:27:57,000
它会斜着下去

800
00:27:57,000 --> 00:27:58,000
有时候会触发不到

801
00:27:58,000 --> 00:27:59,000
对

802
00:27:59,000 --> 00:28:01,000
虽然我自己从来没有意识到这种情况

803
00:28:01,000 --> 00:28:02,000
但是我不知道

804
00:28:02,000 --> 00:28:03,000
这个是很常见的现象吗

805
00:28:03,000 --> 00:28:04,000
还是怎样

806
00:28:04,000 --> 00:28:05,000
就是你按

807
00:28:05,000 --> 00:28:08,000
你在按苹果的键盘上的一个键的时候

808
00:28:08,000 --> 00:28:09,000
你会明显感觉到

809
00:28:09,000 --> 00:28:10,000
当你按的时候

810
00:28:10,000 --> 00:28:12,000
那个键是随着你按的那一角

811
00:28:12,000 --> 00:28:13,000
先开始下线

812
00:28:13,000 --> 00:28:16,000
然后其他部分一起才跟着下线的

813
00:28:16,000 --> 00:28:18,000
但是不应该你按那个键的中心位置吗

814
00:28:18,000 --> 00:28:20,000
你为什么会按那个边角呢

815
00:28:20,000 --> 00:28:22,000
嗯

816
00:28:22,000 --> 00:28:25,000
我倒是觉得在大部分时候

817
00:28:25,000 --> 00:28:26,000
你是不可能玩

818
00:28:26,000 --> 00:28:29,000
就这样发现按到它的中心位置

819
00:28:29,000 --> 00:28:30,000
OK

820
00:28:30,000 --> 00:28:30,000
对我

821
00:28:30,000 --> 00:28:32,000
因为我自己从来没有留意到

822
00:28:32,000 --> 00:28:34,000
我有发出现过这种

823
00:28:34,000 --> 00:28:38,000
因为按到那个那个剪刀脚的某一个边

824
00:28:38,000 --> 00:28:40,000
而不是中心位置出发不了的情况

825
00:28:40,000 --> 00:28:41,000
所以我还挺好奇

826
00:28:41,000 --> 00:28:42,000
他在发布会说

827
00:28:42,000 --> 00:28:44,000
出发不了是肯定不会的

828
00:28:44,000 --> 00:28:47,000
但是剪刀脚所造成的问题

829
00:28:47,000 --> 00:28:50,000
就是你按那个键的时候

830
00:28:50,000 --> 00:28:51,000
你会觉得键

831
00:28:51,000 --> 00:28:52,000
怎么说呢

832
00:28:52,000 --> 00:28:56,000
我觉得这个区别是只有你在按上去的时候才会感觉到的

833
00:28:56,000 --> 00:28:58,000
就是你按一个

834
00:28:58,000 --> 00:29:03,000
比如说我在按那个 HHKB 的时候

835
00:29:03,000 --> 00:29:03,000
按一个键

836
00:29:03,000 --> 00:29:06,000
这个键是本身是不会晃动的

837
00:29:06,000 --> 00:29:07,000
对吧

838
00:29:07,000 --> 00:29:10,000
就是我按这个键的最左上角

839
00:29:10,000 --> 00:29:12,000
整个键会随着我的手指一起下线

840
00:29:12,000 --> 00:29:15,000
但是你在按一个剪刀脚的时候

841
00:29:15,000 --> 00:29:17,000
那个键的左上角会先下线

842
00:29:17,000 --> 00:29:19,000
然后其他部分才跟着下线

843
00:29:19,000 --> 00:29:20,000
没错

844
00:29:20,000 --> 00:29:21,000
是这样的

845
00:29:21,000 --> 00:29:22,000
就这个键是会有

846
00:29:22,000 --> 00:29:23,000
一定的所谓

847
00:29:23,000 --> 00:29:25,000
摇晃的

848
00:29:25,000 --> 00:29:25,000
对

849
00:29:25,000 --> 00:29:26,000
Wobbling space

850
00:29:26,000 --> 00:29:29,000
就是它会有一种不稳的感觉

851
00:29:29,000 --> 00:29:30,000
但是我相信

852
00:29:30,000 --> 00:29:32,000
它蝴蝶脚所要解决的问题

853
00:29:32,000 --> 00:29:34,000
就是你不会再有这种感觉

854
00:29:34,000 --> 00:29:35,000
这个键就是实的

855
00:29:35,000 --> 00:29:36,000
然后你按下去一点

856
00:29:36,000 --> 00:29:38,000
整个键会跟着一起下线

857
00:29:38,000 --> 00:29:41,000
他们那个现场去测

858
00:29:41,000 --> 00:29:44,000
就是试用过那款新的 MacBook 的那个键盘的时候

859
00:29:44,000 --> 00:29:46,000
都说那个键程非常非常短

860
00:29:46,000 --> 00:29:48,000
因为它整个厚度降低了

861
00:29:48,000 --> 00:29:50,000
而且它这个蝴蝶轴的

862
00:29:50,000 --> 00:29:52,000
这个本来都有一个式的键盘

863
00:29:52,000 --> 00:29:54,000
设计出动就是为了减低这个厚度嘛

864
00:29:54,000 --> 00:29:54,000
对吧

865
00:29:54,000 --> 00:29:54,000
高度

866
00:29:54,000 --> 00:29:58,000
那我不太清楚这种键程极短的情况下

867
00:29:58,000 --> 00:30:02,000
对编程的时候的打字的手感会有什么变化

868
00:30:02,000 --> 00:30:07,000
你喜欢长键程还是短键程的键盘

869
00:30:07,000 --> 00:30:11,000
其实我不怎么挑

870
00:30:11,000 --> 00:30:11,000
但我觉得

871
00:30:11,000 --> 00:30:13,000
对

872
00:30:13,000 --> 00:30:16,000
但我觉得就是在用触摸板的时候

873
00:30:16,000 --> 00:30:19,000
你可以理解为这个键程是零

874
00:30:19,000 --> 00:30:20,000
对吧

875
00:30:20,000 --> 00:30:20,000
那

876
00:30:22,000 --> 00:30:27,000
我不知道就是也许在配了触摸板的笔记本电脑上

877
00:30:27,000 --> 00:30:29,000
按一个键程比较短的键

878
00:30:29,000 --> 00:30:31,000
呃

879
00:30:31,000 --> 00:30:34,000
其感觉是不是至少要比 iPad 好了

880
00:30:34,000 --> 00:30:37,000
就是你至少是有一点点键程的嘛

881
00:30:37,000 --> 00:30:38,000
你在 iPad 上

882
00:30:38,000 --> 00:30:40,000
iPad 上用那个虚拟键盘的时候

883
00:30:40,000 --> 00:30:41,000
手感是非常差的

884
00:30:41,000 --> 00:30:41,000
对吧

885
00:30:41,000 --> 00:30:44,000
那虚拟键盘手感差一个主要是有几个原因吗

886
00:30:44,000 --> 00:30:46,000
不光是它没有键程

887
00:30:46,000 --> 00:30:48,000
这个因为主要是一个是没有触觉的风格

888
00:30:48,000 --> 00:30:50,000
你不知道你按了哪个键了吗

889
00:30:50,000 --> 00:30:51,000
你不如果不看的话

890
00:30:51,000 --> 00:30:51,000
对

891
00:30:51,000 --> 00:30:52,000
就是因为这个键盘的手感是非常差的

892
00:30:52,000 --> 00:30:54,000
因为零键程所以才没有风格不是吗

893
00:30:54,000 --> 00:30:56,000
就是我的意思是这两个其实是一回事

894
00:30:56,000 --> 00:30:58,000
呃

895
00:30:58,000 --> 00:30:59,000
你说这个都没有突出

896
00:30:59,000 --> 00:31:00,000
然后也没有下线

897
00:31:00,000 --> 00:31:01,000
对

898
00:31:01,000 --> 00:31:03,000
就算就算是零键程的话

899
00:31:03,000 --> 00:31:04,000
它也是可以有风格的呀

900
00:31:04,000 --> 00:31:05,000
就是呃

901
00:31:05,000 --> 00:31:09,000
你我不知道你有没有用过那个微软那个 surface

902
00:31:09,000 --> 00:31:10,000
它不是有两款键盘吗

903
00:31:10,000 --> 00:31:13,000
一款是所谓的呃

904
00:31:13,000 --> 00:31:13,000
叫什么

905
00:31:13,000 --> 00:31:14,000
touch

906
00:31:14,000 --> 00:31:14,000
对

907
00:31:14,000 --> 00:31:16,000
就是那个光波键盘吗

908
00:31:16,000 --> 00:31:17,000
呃

909
00:31:17,000 --> 00:31:18,000
它不是一个

910
00:31:18,000 --> 00:31:19,000
就是他们是

911
00:31:19,000 --> 00:31:21,000
它是这个那个就是有风格

912
00:31:21,000 --> 00:31:22,000
但是无键程的

913
00:31:22,000 --> 00:31:22,000
一个键盘

914
00:31:22,000 --> 00:31:25,000
就你其实按的是一个对是一只个平板

915
00:31:25,000 --> 00:31:27,000
然后他也有一款那叫做 type cover 吧

916
00:31:27,000 --> 00:31:28,000
我记得

917
00:31:28,000 --> 00:31:30,000
然后我是用过那个那个键程也蛮短的

918
00:31:30,000 --> 00:31:33,000
然后我我两款都试了一下

919
00:31:33,000 --> 00:31:34,000
都感觉不是很好

920
00:31:34,000 --> 00:31:35,000
就键程短

921
00:31:35,000 --> 00:31:37,000
这件事情本身是不是太好的

922
00:31:37,000 --> 00:31:39,000
就一切情况相同的情况下

923
00:31:39,000 --> 00:31:40,000
OK

924
00:31:40,000 --> 00:31:43,000
因为你就没有办法啊

925
00:31:43,000 --> 00:31:45,000
就有时候你可能会会觉得不确定

926
00:31:45,000 --> 00:31:45,000
就按下去

927
00:31:45,000 --> 00:31:46,000
没有

928
00:31:46,000 --> 00:31:48,000
我觉得可能会这样会是这个原因

929
00:31:48,000 --> 00:31:52,000
但是他们说这个这个蝴蝶轴的这个有些其他的好处

930
00:31:52,000 --> 00:31:54,000
比如说他不会左右乱晃啊

931
00:31:54,000 --> 00:31:57,000
然后他这个打字也很呃

932
00:31:57,000 --> 00:32:01,000
就是就他们说那个手感挺挺特别的

933
00:32:01,000 --> 00:32:02,000
我现在也没有打过

934
00:32:02,000 --> 00:32:03,000
我不知道到底是个什么手感

935
00:32:03,000 --> 00:32:05,000
我想很想去试一下

936
00:32:05,000 --> 00:32:11,000
但我又在想其实键程短反而不是应该能帮助你长时间打字吗

937
00:32:11,000 --> 00:32:13,000
这样利用力会比较小

938
00:32:13,000 --> 00:32:13,000
是不是

939
00:32:15,000 --> 00:32:17,000
这个我觉得可能最终是这个问题

940
00:32:17,000 --> 00:32:18,000
这个我觉得可能最终是这个问题

941
00:32:18,000 --> 00:32:22,000
省下来的力也只有一点点一牛打了一只天

942
00:32:22,000 --> 00:32:24,000
省了一牛的力

943
00:32:24,000 --> 00:32:27,000
对

944
00:32:27,000 --> 00:32:31,000
我觉得这个键程可能更多带来的还是还是还是触觉触感上

945
00:32:31,000 --> 00:32:37,000
而真正的省力什么的都是非常浮云的东西

946
00:32:37,000 --> 00:32:37,000
嗯

947
00:32:37,000 --> 00:32:39,000
这反过来说

948
00:32:39,000 --> 00:32:44,000
你可能你会觉得也许是喜欢长键程的人可以去用一个

949
00:32:44,000 --> 00:32:48,000
就前两天在推特上看到的 USB type writer

950
00:32:48,000 --> 00:32:51,000
打字机转 USB 的接口

951
00:32:51,000 --> 00:32:52,000
然后接电脑上打的

952
00:32:52,000 --> 00:32:52,000
对

953
00:32:52,000 --> 00:32:54,000
我觉得这个这个实际上是太怀旧了

954
00:32:54,000 --> 00:32:56,000
就是你可以去

955
00:32:56,000 --> 00:33:00,000
你可以选择直接从网站上买一台已经转化好的 typewriter

956
00:33:00,000 --> 00:33:03,000
就它是货真价实的打字机

957
00:33:03,000 --> 00:33:05,000
然后你可以把这个打字机接到

958
00:33:05,000 --> 00:33:09,000
对机械式的打字机接到你的 USB 口上

959
00:33:09,000 --> 00:33:11,000
然后把打字机当键盘来用

960
00:33:11,000 --> 00:33:12,000
他那个原理是什么

961
00:33:12,000 --> 00:33:15,000
他是探测那个机械键的位移

962
00:33:15,000 --> 00:33:17,000
然后转成 USB 电讯号吗

963
00:33:17,000 --> 00:33:18,000
对

964
00:33:18,000 --> 00:33:22,000
其实就是如果你去看他的那个 converter kit 的话

965
00:33:22,000 --> 00:33:25,000
那个就是如果你直接从他网站上买的比较贵

966
00:33:25,000 --> 00:33:28,000
可能要 599 还是 699 美元一台

967
00:33:28,000 --> 00:33:30,000
但你可以买另外一个 kit

968
00:33:30,000 --> 00:33:31,000
这 kit 就是 99 美元

969
00:33:31,000 --> 00:33:33,000
然后里面有一大堆触板

970
00:33:33,000 --> 00:33:36,000
就是一个比较长条像梳子一样的东西

971
00:33:36,000 --> 00:33:38,000
和一个很小的

972
00:33:38,000 --> 00:33:39,000
应该不是 aduino

973
00:33:39,000 --> 00:33:41,000
是一个他们自己做的一个 IC 板

974
00:33:41,000 --> 00:33:45,000
你把那个长条的梳子一样的背板贴到

975
00:33:45,000 --> 00:33:47,000
呃

976
00:33:47,000 --> 00:33:48,000
机械打字机的后面

977
00:33:48,000 --> 00:33:49,000
嗯

978
00:33:49,000 --> 00:33:54,000
然后再把那个 IC 电路塞在打字机的内部

979
00:33:54,000 --> 00:33:59,000
然后你就可以把它转化成一个 USB 打字机了

980
00:33:59,000 --> 00:34:01,000
就其实他就是去探测的

981
00:34:01,000 --> 00:34:03,000
因为你在按下一个打字机上面键的时候

982
00:34:03,000 --> 00:34:06,000
他后面会有一个东西抬起来嘛

983
00:34:06,000 --> 00:34:09,000
然后他就他会去感应哪个键抬起来

984
00:34:09,000 --> 00:34:12,000
然后把它转化为键盘性能

985
00:34:12,000 --> 00:34:15,000
对应的那个键按键

986
00:34:15,000 --> 00:34:16,000
这也是挺难的

987
00:34:16,000 --> 00:34:18,000
但其实那个很累的嘛

988
00:34:18,000 --> 00:34:19,000
打机械对吗

989
00:34:19,000 --> 00:34:22,000
机械机械打字机的那个按键是很费力的

990
00:34:22,000 --> 00:34:22,000
对啊

991
00:34:22,000 --> 00:34:24,000
就我小时候用打字机打英语作业的时候

992
00:34:24,000 --> 00:34:27,000
就每天晚上打完了手指会疼的

993
00:34:27,000 --> 00:34:29,000
真的那个时候你小孩手也小了

994
00:34:29,000 --> 00:34:32,000
就而且那时候执法也不好

995
00:34:32,000 --> 00:34:35,000
对只能用食指和中指在按

996
00:34:35,000 --> 00:34:36,000
然后有些字母

997
00:34:36,000 --> 00:34:40,000
如果你用让那个让我那个时候我去用小用小指去按的话

998
00:34:40,000 --> 00:34:40,000
永远是虚的

999
00:34:40,000 --> 00:34:41,000
比如说 p 啊

1000
00:34:41,000 --> 00:34:43,000
之类的 pq 永远是虚的

1001
00:34:44,000 --> 00:34:45,000
对

1002
00:34:46,000 --> 00:34:47,000
这也是一种恶趣

1003
00:34:48,000 --> 00:34:50,000
对就只叫什么蒸汽朋克

1004
00:34:51,000 --> 00:34:54,000
机械机械朋克打机械

1005
00:34:54,000 --> 00:34:55,000
我们的键盘

1006
00:34:56,000 --> 00:34:59,000
说到这个笔记程序员用的笔记本啊

1007
00:34:59,000 --> 00:35:01,000
前两天 Google 就是应该不是前两天

1008
00:35:01,000 --> 00:35:04,000
就是苹果发布那个新款 Macbook 之后

1009
00:35:04,000 --> 00:35:08,000
第二天 Google 也发布了这个新款的 ChromebookPixel

1010
00:35:08,000 --> 00:35:09,000
就他那块

1011
00:35:10,000 --> 00:35:15,000
虽然就官方配就是只能用上网的一个笔记本

1012
00:35:15,000 --> 00:35:17,000
但是他的整个配置还是不错的

1013
00:35:17,000 --> 00:35:17,000
有一个

1014
00:35:18,000 --> 00:35:21,000
分屏啊也是 13 寸一个方头方脑的一个设计吧

1015
00:35:21,000 --> 00:35:25,000
然后我知道很多人就是 Linux 用户

1016
00:35:25,000 --> 00:35:26,000
他会去选这个

1017
00:35:26,000 --> 00:35:30,000
然后他装那个什么一个重一种软件叫做 crumpton 吧

1018
00:35:30,000 --> 00:35:38,000
要是就可以在上面呃在一个类似于这个 container 的环境里面跑一个其他内核的不想钱的

1019
00:35:38,000 --> 00:35:41,000
你还就其他的这个 Linux 的发行版

1020
00:35:41,000 --> 00:35:42,000
比如说看图啊

1021
00:35:42,000 --> 00:35:42,000
之类的

1022
00:35:42,000 --> 00:35:44,000
然后这样的话就有很多好处啊

1023
00:35:44,000 --> 00:35:46,000
因为 crumple 他本身是一个类似于啊

1024
00:35:46,000 --> 00:35:47,000
LS 的设计嘛

1025
00:35:47,000 --> 00:35:49,000
就整个他是杀核机制的

1026
00:35:49,000 --> 00:35:54,000
然后你没有办法去更改系统的东西就安全性是有保有保障的

1027
00:35:54,000 --> 00:35:57,000
让你在在那个 container 里面再跑一个 Linux 发行版

1028
00:35:57,000 --> 00:35:59,000
你就弄坏了再删掉

1029
00:35:59,000 --> 00:36:00,000
重新来一个就好了

1030
00:36:00,000 --> 00:36:03,000
就很多人会选择这种方式来做是

1031
00:36:04,000 --> 00:36:08,000
他那个板的唯一的问题就是存储空间太小了

1032
00:36:08,000 --> 00:36:11,000
他最大只有 64 G 的 SSD

1033
00:36:12,000 --> 00:36:12,000
对

1034
00:36:12,000 --> 00:36:17,000
我觉得我也不知道你见过身边的人在用 chromebook 吗

1035
00:36:17,000 --> 00:36:20,000
我为什么我总有一种感觉就是他是一个怎么哈

1036
00:36:20,000 --> 00:36:22,000
上下我叫好不叫错的成品

1037
00:36:22,000 --> 00:36:24,000
我没有见过有人自己花钱买他

1038
00:36:24,000 --> 00:36:26,000
然后但不过我有个朋友

1039
00:36:26,000 --> 00:36:30,000
他是前年去年前年前年去那个 Google 的时候

1040
00:36:30,000 --> 00:36:33,000
那年不是 Google 是给你去餐铺的

1041
00:36:33,000 --> 00:36:34,000
是每个人送了一台吗

1042
00:36:34,000 --> 00:36:36,000
就那个第一代的 crumplepixel

1043
00:36:36,000 --> 00:36:37,000
然后他他就拿了一台回来

1044
00:36:37,000 --> 00:36:38,000
我玩了一下

1045
00:36:38,000 --> 00:36:41,000
这整个整个做工和工艺还是无错的

1046
00:36:41,000 --> 00:36:45,000
我觉得但是就是能做的事情感觉挺有限

1047
00:36:45,000 --> 00:36:46,000
OK 啊

1048
00:36:46,000 --> 00:36:46,000
因为他那个

1049
00:36:47,000 --> 00:36:48,000
空间确实比较小

1050
00:36:48,000 --> 00:36:51,000
他那个是带那个 LTE 还是 4 G 网络的

1051
00:36:51,000 --> 00:36:53,000
对他可以插那个 SIM 卡

1052
00:36:53,000 --> 00:36:54,000
这点比较有意思

1053
00:36:56,000 --> 00:36:59,000
对就是其实我之前在想说

1054
00:37:00,000 --> 00:37:03,000
新的 MacBook 为什么不能直接内置 LTE

1055
00:37:07,000 --> 00:37:08,000
因为他那个轻薄的程度

1056
00:37:08,000 --> 00:37:12,000
他那个轻薄的程度其实已经非常适合就是带着倒数跑

1057
00:37:12,000 --> 00:37:14,000
但是带着倒数跑有问题就是在没有网络的地方

1058
00:37:14,000 --> 00:37:16,000
比如说他那个宣传广告里面呢

1059
00:37:17,000 --> 00:37:23,000
有一个有一个女孩的拿着他盘腿坐在一个公园旁边的长椅上

1060
00:37:23,000 --> 00:37:24,000
然后我就想说他往从哪来

1061
00:37:26,000 --> 00:37:32,000
那个苹果的解决方案是说你只要有手机在旁边可以通过无线的连接一个

1062
00:37:32,000 --> 00:37:36,000
对对他可以做一个这个好办

1063
00:37:36,000 --> 00:37:37,000
我觉得还可以吧

1064
00:37:37,000 --> 00:37:40,000
因为其实你如果每一个设备都做一个 SIM 卡的话

1065
00:37:40,000 --> 00:37:43,000
你每个月的这个交给运营商的月费还是蛮多的

1066
00:37:43,000 --> 00:37:46,000
就如果是偶尔的就这种场合使用的话

1067
00:37:46,000 --> 00:37:46,000
这样也没问题吧

1068
00:37:47,000 --> 00:37:48,000
有什么不好啊

1069
00:37:48,000 --> 00:37:51,000
之前用做那个 Tethering 还比较麻烦

1070
00:37:51,000 --> 00:37:54,000
你要先配在手机上打开

1071
00:37:54,000 --> 00:37:55,000
然后你在电脑上连接一下

1072
00:37:55,000 --> 00:37:59,000
现在自从那个有 SIM 里面不是你可以直接就只要你说手机在旁边

1073
00:37:59,000 --> 00:38:02,000
你点那个 WiFi 的 logo 里面就可以很方便的有一个选项

1074
00:38:02,000 --> 00:38:05,000
可以直接通过你的手机 iPhoneTethering

1075
00:38:05,000 --> 00:38:07,000
所以我觉得还好吧

1076
00:38:07,000 --> 00:38:10,000
而且是现在就出门

1077
00:38:10,000 --> 00:38:12,000
你要真的静下来办公

1078
00:38:12,000 --> 00:38:14,000
但除非你是去什么公园里面再说

1079
00:38:14,000 --> 00:38:15,000
就是我说你是什么咖啡馆啊

1080
00:38:15,000 --> 00:38:16,000
就有 WiFi 的地方

1081
00:38:16,000 --> 00:38:17,000
还是太多了吧

1082
00:38:17,000 --> 00:38:19,000
说的也是

1083
00:38:19,000 --> 00:38:21,000
我感觉是这样子起来

1084
00:38:21,000 --> 00:38:27,000
你有 ever 带着一个笔记本出去办公这种事情吗

1085
00:38:27,000 --> 00:38:28,000
就是你觉得家里太憋

1086
00:38:28,000 --> 00:38:30,000
或者是外面阳光真好

1087
00:38:30,000 --> 00:38:33,000
想要一边写程序一边享受阳光之类的

1088
00:38:33,000 --> 00:38:34,000
你做这种事情吗

1089
00:38:34,000 --> 00:38:36,000
夏天的时候我经常带出去在海边

1090
00:38:36,000 --> 00:38:37,000
因为我们在我们

1091
00:38:37,000 --> 00:38:39,000
我这个地方就是在靠海吗

1092
00:38:39,000 --> 00:38:42,000
我家离这个大西洋的直线距离

1093
00:38:42,000 --> 00:38:45,000
可能只有两三公里的样子

1094
00:38:45,000 --> 00:38:46,000
我就开车开到海边

1095
00:38:46,000 --> 00:38:48,000
找个这种稍微

1096
00:38:48,000 --> 00:38:51,000
就是视线比较好的地方

1097
00:38:51,000 --> 00:38:54,000
我就坐在附加的位置上

1098
00:38:54,000 --> 00:38:57,000
把椅子往后折

1099
00:38:57,000 --> 00:38:58,000
然后在那里办公

1100
00:38:58,000 --> 00:38:58,000
就是听着

1101
00:38:58,000 --> 00:39:00,000
聆听着拍案的怒涛

1102
00:39:00,000 --> 00:39:02,000
然后我们这里没有怒涛

1103
00:39:02,000 --> 00:39:03,000
只有小浪

1104
00:39:03,000 --> 00:39:04,000
好吧

1105
00:39:04,000 --> 00:39:06,000
看着大西洋的浑浊海浪

1106
00:39:06,000 --> 00:39:08,000
大西洋是很难的

1107
00:39:08,000 --> 00:39:08,000
谢谢

1108
00:39:08,000 --> 00:39:10,000
不像太平洋

1109
00:39:10,000 --> 00:39:11,000
太平洋是很

1110
00:39:11,000 --> 00:39:13,000
太平洋更难吧

1111
00:39:13,000 --> 00:39:13,000
应该

1112
00:39:13,000 --> 00:39:14,000
我不知道

1113
00:39:14,000 --> 00:39:15,000
我之前在

1114
00:39:15,000 --> 00:39:16,000
在

1115
00:39:16,000 --> 00:39:19,000
就起码在东国的海岸线上

1116
00:39:19,000 --> 00:39:22,000
看的太平洋都是挺黄昏灼的

1117
00:39:22,000 --> 00:39:23,000
那是因为中国的

1118
00:39:23,000 --> 00:39:25,000
就是河流

1119
00:39:25,000 --> 00:39:26,000
不对

1120
00:39:26,000 --> 00:39:27,000
那边还比较浅

1121
00:39:27,000 --> 00:39:27,000
像渤海有

1122
00:39:27,000 --> 00:39:29,000
我们家门口的渤海

1123
00:39:29,000 --> 00:39:30,000
有时候会冻上来

1124
00:39:30,000 --> 00:39:31,000
就浅到这个地步

1125
00:39:31,000 --> 00:39:32,000
OK

1126
00:39:32,000 --> 00:39:34,000
蓝海其实是

1127
00:39:34,000 --> 00:39:36,000
就是足够深的地方都是蓝色的

1128
00:39:36,000 --> 00:39:37,000
这个那边可能就是很深的

1129
00:39:37,000 --> 00:39:39,000
我就看都是一望无际那种

1130
00:39:39,000 --> 00:39:42,000
就之前是照片上看到的那种蓝

1131
00:39:42,000 --> 00:39:43,000
现在就是我们家旁边的这种蓝

1132
00:39:43,000 --> 00:39:44,000
OK

1133
00:39:44,000 --> 00:39:46,000
好吧

1134
00:39:46,000 --> 00:39:46,000
我

1135
00:39:46,000 --> 00:39:46,000
我

1136
00:39:46,000 --> 00:39:46,000
我

1139
00:40:46,000 --> 00:40:47,000
for

1140
00:40:47,000 --> 00:40:47,000
x

1141
00:40:47,000 --> 00:40:48,000
u

1142
00:40:48,000 --> 00:40:48,000
n

1143
00:40:48,000 --> 00:40:48,000
o

1144
00:40:48,000 --> 00:40:50,000
theater

1145
00:40:51,000 --> 00:40:52,000
我不太清楚

1146
00:40:52,000 --> 00:40:54,000
不过有那个有那个叫什么

1147
00:40:54,000 --> 00:40:55,000
Vindex

1148
00:40:56,000 --> 00:40:57,000
的这种东西

1149
00:40:57,000 --> 00:40:59,000
然后鼠标的

1150
00:41:00,000 --> 00:41:02,000
就是你用点屏幕咯

1151
00:41:05,000 --> 00:41:07,000
你要用辅导肯定就输了

1152
00:41:07,000 --> 00:41:08,000
好

1153
00:41:08,000 --> 00:41:09,000
听起来有点淡的

1154
00:41:09,000 --> 00:41:12,000
或者用船红键盘的

1155
00:41:12,000 --> 00:41:12,000
创高

1156
00:41:12,000 --> 00:41:14,000
网纪系应该也可以

1157
00:41:14,000 --> 00:41:15,000
的你不是

1158
00:41:15,000 --> 00:41:16,000
反正 visme

1159
00:41:16,000 --> 00:41:16,000
距离的

1160
00:41:16,000 --> 00:41:18,000
用那个 Vim 的 K 班里

1161
00:41:18,000 --> 00:41:19,000
应该也差不多合适了

1162
00:41:19,000 --> 00:41:19,000
我觉得

1163
00:41:19,000 --> 00:41:21,000
好吧

1164
00:41:21,000 --> 00:41:22,000
下次可以试试

1165
00:41:22,000 --> 00:41:25,000
不过你没有吧

1166
00:41:25,000 --> 00:41:25,000
对

1167
00:41:25,000 --> 00:41:26,000
我是一个

1168
00:41:26,000 --> 00:41:27,000
我觉得如果出门的话

1169
00:41:27,000 --> 00:41:28,000
就不要办公

1170
00:41:28,000 --> 00:41:29,000
如果办公的话

1171
00:41:29,000 --> 00:41:29,000
就不要出门

1172
00:41:29,000 --> 00:41:31,000
那你想换个环境

1173
00:41:31,000 --> 00:41:33,000
散散心怎么办

1174
00:41:33,000 --> 00:41:34,000
那就不办公

1175
00:41:34,000 --> 00:41:36,000
就想散心的时候散心

1176
00:41:36,000 --> 00:41:37,000
那什么

1177
00:41:37,000 --> 00:41:40,000
叫什么李大超的那篇文章

1178
00:41:40,000 --> 00:41:42,000
玩就玩个痛快

1179
00:41:42,000 --> 00:41:43,000
学就学个舒服

1180
00:41:43,000 --> 00:41:46,000
不是学就学个舒服

1181
00:41:46,000 --> 00:41:47,000
学就学个什么来着

1182
00:41:47,000 --> 00:41:48,000
然后玩就玩个痛快

1183
00:41:48,000 --> 00:41:51,000
就该干嘛

1184
00:41:51,000 --> 00:41:52,000
Work hard

1185
00:41:52,000 --> 00:41:52,000
Play hard

1186
00:41:52,000 --> 00:41:53,000
对

1187
00:41:53,000 --> 00:41:55,000
就不要又想

1188
00:41:55,000 --> 00:41:56,000
又想轻松

1189
00:41:56,000 --> 00:41:56,000
又想

1190
00:41:56,000 --> 00:41:59,000
要办公就站着

1191
00:41:59,000 --> 00:42:02,000
然后敲一台机械简板

1192
00:42:02,000 --> 00:42:02,000
用一个

1193
00:42:02,000 --> 00:42:04,000
用一台 Power Mac

1194
00:42:04,000 --> 00:42:06,000
然后要出去

1195
00:42:06,000 --> 00:42:07,000
就什么都不要带

1196
00:42:07,000 --> 00:42:09,000
那如果你是这种人的话

1197
00:42:09,000 --> 00:42:10,000
你为什么买一个笔记本

1198
00:42:10,000 --> 00:42:13,000
因为我并不具备

1199
00:42:13,000 --> 00:42:14,000
尚不具备

1200
00:42:14,000 --> 00:42:16,000
一个

1201
00:42:16,000 --> 00:42:16,000
可以

1205
00:43:46,000 --> 00:43:49,000
这种轻薄的笔记本

1206
00:43:49,000 --> 00:43:51,000
就是一个必须的选项

1207
00:43:51,000 --> 00:43:52,000
没错

1208
00:43:52,000 --> 00:43:54,000
今天的主题是什么

1209
00:43:54,000 --> 00:43:58,000
今天的主题是并发和异步

1210
00:43:58,000 --> 00:44:00,000
听起来是不是又

1211
00:44:00,000 --> 00:44:01,000
等一下

1212
00:44:01,000 --> 00:44:03,000
这是不是又太干了

1213
00:44:03,000 --> 00:44:05,000
并发和异步

1214
00:44:05,000 --> 00:44:07,000
其实我们可以讲的比较

1215
00:44:07,000 --> 00:44:08,000
泛一点的

1216
00:44:08,000 --> 00:44:11,000
比较浅入浅出一点

1217
00:44:11,000 --> 00:44:15,000
霍金不是在十年电视里面说

1218
00:44:15,000 --> 00:44:16,000
你

1219
00:44:16,000 --> 00:44:18,000
你在书里面加一个公式

1220
00:44:18,000 --> 00:44:20,000
你的读者就会少一半

1221
00:44:20,000 --> 00:44:22,000
每多加一个公式

1222
00:44:22,000 --> 00:44:24,000
你的读者就会少一半

1223
00:44:24,000 --> 00:44:26,000
所以我们想可能是

1224
00:44:26,000 --> 00:44:27,000
我们每次

1225
00:44:27,000 --> 00:44:30,000
我们每增加一个术语

1226
00:44:30,000 --> 00:44:31,000
可能听众就会少一半

1227
00:44:31,000 --> 00:44:34,000
比如说上一期编程与数学

1228
00:44:34,000 --> 00:44:38,000
可能已经限定了

1229
00:44:38,000 --> 00:44:41,000
很多听很多对数学和编程不感兴趣的听众是不会的

1230
00:44:41,000 --> 00:44:45,000
当然对数学的编程不感兴趣的听众为什么要听的很恐慌

1231
00:44:45,000 --> 00:44:46,000
没事

1232
00:44:46,000 --> 00:44:46,000
对吧

1233
00:44:46,000 --> 00:44:46,000
对吧

1234
00:44:46,000 --> 00:44:48,000
可以听牧羊老师的声音吗

1235
00:44:48,000 --> 00:44:50,000
说点事

1236
00:44:50,000 --> 00:44:58,000
我们应该把牧羊专门挖到 ipn 来单独做一档节目

1237
00:44:58,000 --> 00:44:59,000
各位听众说怎么样

1238
00:44:59,000 --> 00:45:01,000
然后粉丝全过去了

1239
00:45:01,000 --> 00:45:02,000
我们就没剩几个

1240
00:45:02,000 --> 00:45:03,000
对

1241
00:45:03,000 --> 00:45:07,000
此处应该插入幼儿园的所有小朋友

1242
00:45:07,000 --> 00:45:07,000
为不起说

1243
00:45:07,000 --> 00:45:08,000
好

1244
00:45:08,000 --> 00:45:11,000
对

1245
00:45:11,000 --> 00:45:13,000
好

1246
00:45:13,000 --> 00:45:14,000
好

1247
00:45:14,000 --> 00:45:15,000
对

1248
00:45:15,000 --> 00:45:16,000
对

1249
00:45:16,000 --> 00:45:16,000
好吧

1250
00:45:16,000 --> 00:45:16,000
好

1251
00:45:16,000 --> 00:45:20,000
所以并发和并行其实是两个概念

1252
00:45:20,000 --> 00:45:22,000
不不不并发和一步

1253
00:45:22,000 --> 00:45:23,000
对不

1254
00:45:23,000 --> 00:45:25,000
concurrency

1255
00:45:25,000 --> 00:45:26,000
concurrence

1256
00:45:26,000 --> 00:45:26,000
parallel

1257
00:45:26,000 --> 00:45:27,000
ok

1258
00:45:27,000 --> 00:45:34,000
先讲并发这一块对对对并发和并行这个这个术语其实有有点很纠结的

1259
00:45:34,000 --> 00:45:39,000
就我觉得没有一个很清晰的就起码中文没有一个很很清晰的概念吧

1260
00:45:39,000 --> 00:45:40,000
就 concurrence

1261
00:45:40,000 --> 00:45:43,000
英文两边是两个完全完全不一样的词嘛

1262
00:45:43,000 --> 00:45:44,000
对吧

1263
00:45:44,000 --> 00:45:46,000
但是在中文里面你说并发并行有什么太大区别吗

1264
00:45:46,000 --> 00:45:47,000
好像也没有

1265
00:45:47,000 --> 00:45:49,000
但我记

1266
00:45:49,000 --> 00:45:50,000
我觉得就是怎么说

1267
00:45:50,000 --> 00:45:52,000
有人软件公式有很多很多词汇都是这样

1268
00:45:52,000 --> 00:45:54,000
而且你说 concurrency

1269
00:45:54,000 --> 00:45:59,000
parallel 在英文里面的区别是每一个程序员都了解的吗

1270
00:45:59,000 --> 00:46:00,000
可能也不是

1271
00:46:00,000 --> 00:46:04,000
甚至连那个词典的地域都是很非常接近

1272
00:46:04,000 --> 00:46:06,000
你说都没有一个很严格的区分

1273
00:46:06,000 --> 00:46:07,000
到底哪个是哪个

1274
00:46:07,000 --> 00:46:08,000
对

1275
00:46:08,000 --> 00:46:12,000
但是我觉得可能在软件界有很多很多这样的问题

1276
00:46:12,000 --> 00:46:15,000
比如说 argument 和 parameter 的差别

1277
00:46:15,000 --> 00:46:16,000
可能

1278
00:46:16,000 --> 00:46:18,000
有很多时候也会毁用

1279
00:46:18,000 --> 00:46:20,000
就看语境嘛

1280
00:46:20,000 --> 00:46:22,000
就是大部分时候是不分的

1281
00:46:22,000 --> 00:46:22,000
我觉得

1282
00:46:22,000 --> 00:46:23,000
对

1283
00:46:23,000 --> 00:46:28,000
但具体到这一期的话题上来说

1284
00:46:28,000 --> 00:46:32,000
我觉得可能正确的区分 concurrency 和 parallel 也是

1285
00:46:32,000 --> 00:46:35,000
就接下来的讨论比较重要的事情

1286
00:46:35,000 --> 00:46:36,000
甚至可以说

1287
00:46:36,000 --> 00:46:38,000
如果我们这期节目可以让

1288
00:46:38,000 --> 00:46:45,000
可以帮助听过的人确切的了解了 concurrency 和 parallel 之间的差别

1289
00:46:45,000 --> 00:46:46,000
那可能也一定会有的差别

1290
00:46:46,000 --> 00:46:48,000
但是我觉得这个已经是很有成功了

1291
00:46:48,000 --> 00:46:49,000
有好处

1292
00:46:49,000 --> 00:46:49,000
对

1293
00:46:49,000 --> 00:46:50,000
很有成功一点

1294
00:46:50,000 --> 00:46:51,000
很成功一点

1295
00:46:51,000 --> 00:46:54,000
所以我们要先把这个范围缩缩的很窄

1296
00:46:54,000 --> 00:46:56,000
就是说我们在这里讲的并发和并行

1297
00:46:56,000 --> 00:46:59,000
但对应的两个词就是 concur 和 parallel

1298
00:46:59,000 --> 00:47:02,000
这两个词的时候是讲在叫什么

1299
00:47:02,000 --> 00:47:05,000
多多线程

1300
00:47:05,000 --> 00:47:10,000
或者说在这个程序语言的这个构建的时候的一个场景

1301
00:47:10,000 --> 00:47:12,000
那至于说这个场景外

1302
00:47:12,000 --> 00:47:13,000
你要怎么去用这两个词

1303
00:47:13,000 --> 00:47:14,000
那就随你变吧

1304
00:47:14,000 --> 00:47:15,000
对

1305
00:47:15,000 --> 00:47:16,000
嗯

1307
00:47:46,000 --> 00:47:51,000
就是说这个是我就是相对于刚才那一讲是在逻辑层面的话

1308
00:47:51,000 --> 00:47:53,000
那个 concurrence 在逻辑层面的一个概念的话

1309
00:47:53,000 --> 00:47:56,000
并行可能就是在一个物理层面的一个概念了

1310
00:47:56,000 --> 00:48:00,000
就是说在逻辑上并发的东西

1311
00:48:00,000 --> 00:48:02,000
在物理上它并不一定是在并行执行

1312
00:48:02,000 --> 00:48:04,000
它也可以是先做一个后做一个

1313
00:48:04,000 --> 00:48:07,000
只是说它这个先后是没有太大关系的

1314
00:48:07,000 --> 00:48:08,000
就谁先谁后都一样

1315
00:48:08,000 --> 00:48:12,000
但是并就是在实现层面的并行的话

1316
00:48:12,000 --> 00:48:16,000
就是说它两个是在物理事件中同时发生的

1317
00:48:16,000 --> 00:48:17,000
ok

1318
00:48:17,000 --> 00:48:18,000
这样解释可以吗

1319
00:48:18,000 --> 00:48:19,000
我觉得

1320
00:48:19,000 --> 00:48:21,000
我觉得应该是可以的

1321
00:48:21,000 --> 00:48:22,000
就是怎么说呢

1322
00:48:22,000 --> 00:48:23,000
就是有一句

1323
00:48:23,000 --> 00:48:27,000
就是 Roll Pike 曾经作为一个对 go long 的

1324
00:48:27,000 --> 00:48:29,000
go routine 的

1325
00:48:29,000 --> 00:48:30,000
嗯

1326
00:48:30,000 --> 00:48:32,000
叫什么

1327
00:48:32,000 --> 00:48:34,000
幻灯片

1328
00:48:34,000 --> 00:48:35,000
幻灯片

1329
00:48:35,000 --> 00:48:35,000
对

1330
00:48:35,000 --> 00:48:38,000
就对这个幻灯片在网上可以可以得到

1331
00:48:38,000 --> 00:48:46,000
然后他的他对于并发和并行的定义是并发是同一时间应对多件事情的

1332
00:48:46,000 --> 00:48:49,000
就是 dealing with a lot of things

1333
00:48:49,000 --> 00:48:51,000
而并行呢

1334
00:48:51,000 --> 00:48:52,000
就是 parallel

1335
00:48:52,000 --> 00:48:56,000
则是同一时间动手去做很多件事情的东西

1336
00:48:56,000 --> 00:48:58,000
但这里你就要解释什么是

1337
00:48:58,000 --> 00:49:01,000
什么是应对和什么是做

1338
00:49:01,000 --> 00:49:02,000
对吧

1339
00:49:02,000 --> 00:49:04,000
我觉得可以理解为

1340
00:49:04,000 --> 00:49:08,000
就是这两个概念的抽象层级是不一样

1341
00:49:08,000 --> 00:49:12,000
就并发或者说他们描述的问题的领域是不一样

1342
00:49:12,000 --> 00:49:14,000
所谓并发 concurrency

1343
00:49:14,000 --> 00:49:16,000
指的是一个比较

1344
00:49:16,000 --> 00:49:18,000
嗯

1345
00:49:18,000 --> 00:49:23,000
在问题领域的概念

1346
00:49:23,000 --> 00:49:25,000
就是你有很多问题

1347
00:49:25,000 --> 00:49:27,000
你需要去解决这些问题

1348
00:49:27,000 --> 00:49:29,000
而这些问题的发生是同时发生的

1349
00:49:29,000 --> 00:49:31,000
你就可以说

1350
00:49:31,000 --> 00:49:32,000
我要

1351
00:49:32,000 --> 00:49:37,000
我所面对的问题有 concurrency 的特征

1352
00:49:37,000 --> 00:49:41,000
而 parallel 则是在你实际去做一件事情的时候

1353
00:49:41,000 --> 00:49:43,000
你要比如说你你要

1354
00:49:43,000 --> 00:49:46,000
你要去解决一个并发的问题

1355
00:49:46,000 --> 00:49:48,000
你怎么去解决它

1356
00:49:48,000 --> 00:49:48,000
好

1357
00:49:48,000 --> 00:49:51,000
你可以使用并行的手段去解决它

1358
00:49:51,000 --> 00:49:52,000
嗯

1359
00:49:52,000 --> 00:49:55,000
我大概理解你意思

1360
00:49:55,000 --> 00:49:57,000
不然他我觉得听起来有点少

1361
00:49:57,000 --> 00:49:58,000
对吧

1362
00:49:58,000 --> 00:50:03,000
比如说或者说举我们还是举例子来来来来解释好了

1363
00:50:03,000 --> 00:50:05,000
就比如说嗯

1364
00:50:05,000 --> 00:50:10,000
我在我在做一些事情的时候需要去做另外事情

1365
00:50:10,000 --> 00:50:11,000
比如说我要做饭

1366
00:50:11,000 --> 00:50:11,000
好

1367
00:50:11,000 --> 00:50:13,000
我我我而这样

1368
00:50:13,000 --> 00:50:14,000
但我的碗还没洗过也没刷好

1369
00:50:14,000 --> 00:50:16,000
那我要先说先刷过

1370
00:50:16,000 --> 00:50:17,000
再洗碗

1371
00:50:17,000 --> 00:50:18,000
然后再切菜

1372
00:50:18,000 --> 00:50:20,000
然后再把油倒进锅里

1373
00:50:20,000 --> 00:50:21,000
然后开始炒菜

1374
00:50:21,000 --> 00:50:22,000
然后再装盘

1375
00:50:22,000 --> 00:50:23,000
嗯

1376
00:50:23,000 --> 00:50:23,000
呃

1377
00:50:23,000 --> 00:50:27,000
所有这些事情可以理解为我是有些事情是可是可以同时做的

1378
00:50:27,000 --> 00:50:27,000
对吧

1379
00:50:27,000 --> 00:50:29,000
比如说我可以嗯

1380
00:50:29,000 --> 00:50:31,000
先洗一部分碗

1381
00:50:31,000 --> 00:50:32,000
然后先洗先把锅洗了

1382
00:50:32,000 --> 00:50:34,000
然后用锅来炒菜

1383
00:50:34,000 --> 00:50:36,000
然后在菜被煮的过程中

1384
00:50:36,000 --> 00:50:37,000
假设我是做一个炖菜

1385
00:50:37,000 --> 00:50:40,000
不需要长时间的去翻他的嗯

1386
00:50:40,000 --> 00:50:40,000
炖菜

1387
00:50:40,000 --> 00:50:44,000
然后我可以在炖这个菜的时候去呃洗碗

1388
00:50:44,000 --> 00:50:45,000
对吧

1389
00:50:45,000 --> 00:50:46,000
嗯

1391
00:51:16,000 --> 00:51:18,000
,首先我得有一个女朋友

1392
00:51:18,000 --> 00:51:22,000
首先你得有幸幸好幸好我已经有了一个女朋友

1393
00:51:22,000 --> 00:51:23,000
我可以拉着他说好

1394
00:51:23,000 --> 00:51:24,000
我去买菜

1395
00:51:24,000 --> 00:51:26,000
你把锅油洗了

1396
00:51:26,000 --> 00:51:27,000
对吧

1397
00:51:27,000 --> 00:51:29,000
此时我就可以说我在做并行

1398
00:51:29,000 --> 00:51:33,000
因为呃同我在同一时间同时做很多事情

1399
00:51:34,000 --> 00:51:35,000
此时就是拍了

1400
00:51:35,000 --> 00:51:36,000
为什么

1401
00:51:37,000 --> 00:51:38,000
我不知道这样是不是

1402
00:51:38,000 --> 00:51:41,000
所以所以这个从一个开阔的说法来讲

1403
00:51:41,000 --> 00:51:43,000
就是说并发坎坷

1404
00:51:43,000 --> 00:51:45,000
是是一个组织呃事物的项目

1405
00:51:45,000 --> 00:51:48,000
就是说你这个事物的概念就是说你可以把事物独立出来

1406
00:51:48,000 --> 00:51:52,000
他互相之间是没有因果关系或者是依赖关系的

1407
00:51:52,000 --> 00:51:54,000
那可以对他可以被并发执行

1408
00:51:54,000 --> 00:51:56,000
但你实际做的时候

1409
00:51:56,000 --> 00:52:01,000
你这是不是真的同时在做几件互相可以并发的事情

1410
00:52:01,000 --> 00:52:03,000
则不一定就好像刚才说这个做饭的例子

1411
00:52:03,000 --> 00:52:05,000
你有很多并发的那个任务

1412
00:52:05,000 --> 00:52:07,000
比如说洗碗是一个切菜

1413
00:52:07,000 --> 00:52:09,000
可能是一个呃

1414
00:52:09,000 --> 00:52:11,000
然后这个怎么洗锅可能又是一个

1415
00:52:11,000 --> 00:52:13,000
但是因为你就一个人

1416
00:52:13,000 --> 00:52:15,000
你还没有被并没有把这些并发的任务并行

1417
00:52:15,000 --> 00:52:16,000
执行吗

1418
00:52:16,000 --> 00:52:19,000
也就是说你在面对一个可能是一个问题的时候

1419
00:52:19,000 --> 00:52:23,000
你可能没有办法用拍了方式去解去解决他

1420
00:52:24,000 --> 00:52:30,000
而你用拍了方式去解决问题也有可能根本不是坎坷的问题

1421
00:52:30,000 --> 00:52:35,000
但是但是后者这样的例子可能比较比较难以解出来

1422
00:52:35,000 --> 00:52:36,000
对我刚才就在想说啊

1423
00:52:36,000 --> 00:52:37,000
我们刚才讲了说

1424
00:52:39,000 --> 00:52:44,000
那是不是说并行就是派我要的前提是并发了

1425
00:52:44,000 --> 00:52:45,000
你说不是那有什么

1426
00:52:45,000 --> 00:52:46,000
可能性的反例吗

1427
00:52:46,000 --> 00:52:47,000
呃

1428
00:52:47,000 --> 00:52:51,000
比如说吧

1429
00:52:51,000 --> 00:52:51,000
嗯

1430
00:52:51,000 --> 00:52:54,000
我要在五个抽屉里面

1431
00:52:54,000 --> 00:52:57,000
我我有五个抽屉五个抽屉里面装满了围棋子

1432
00:52:57,000 --> 00:53:00,000
其中五个抽屉里面有一万个围棋子

1433
00:53:00,000 --> 00:53:01,000
只有一个是黑的

1434
00:53:01,000 --> 00:53:02,000
其他都是白的

1435
00:53:02,000 --> 00:53:05,000
我要在这我要把那个黑的围棋子找出来

1436
00:53:05,000 --> 00:53:08,000
你说这是这是 concurrency 的问题吗

1437
00:53:08,000 --> 00:53:09,000
其实不是

1438
00:53:09,000 --> 00:53:11,000
啊

1439
00:53:11,000 --> 00:53:14,000
这件事情本身没有任何 concurrency 在里面

1440
00:53:14,000 --> 00:53:15,000
不是吧

1441
00:53:15,000 --> 00:53:15,000
我只是

1442
00:53:15,000 --> 00:53:19,000
只需要找到那个黑找到黑围棋子是我唯一的目的

1443
00:53:19,000 --> 00:53:21,000
嗯

1444
00:53:21,000 --> 00:53:25,000
但我觉得这个可能有看你的这个什么定叫什么

1445
00:53:25,000 --> 00:53:27,000
你的 task 的话定是怎么样子的吗

1446
00:53:27,000 --> 00:53:29,000
如果你画的他说是啊

1447
00:53:29,000 --> 00:53:34,000
我有五个 task 就分别在每一个抽屉里面找那个一个黑色的围棋子

1448
00:53:34,000 --> 00:53:34,000
对吧

1449
00:53:34,000 --> 00:53:35,000
嗯

1450
00:53:35,000 --> 00:53:37,000
这个时候他又是一个并发的概念了

1451
00:53:37,000 --> 00:53:41,000
所以我觉得可能大致上可以这么认为吧

1452
00:53:41,000 --> 00:53:45,000
就是说并发是并行的先决条件

1453
00:53:45,000 --> 00:53:48,000
但并行并不是并发的必然结果

1454
00:53:48,000 --> 00:53:50,000
可以这么说好吧

1455
00:53:50,000 --> 00:53:55,000
就或者说如果你可以把问题转化为一个能够并发的问题

1456
00:53:55,000 --> 00:53:58,000
那你基本上就可以用并行的方式去解决

1457
00:53:58,000 --> 00:53:59,000
嗯

1458
00:53:59,000 --> 00:54:05,000
如果这个多的那个那个 resource 就资源资源去平都并发去做吗

1459
00:54:05,000 --> 00:54:08,000
刚才在你那个做饭的个例子里面

1460
00:54:08,000 --> 00:54:12,000
这个资源就是说你得有两个人或者是三个人或者四个人

1461
00:54:12,000 --> 00:54:14,000
但在电脑的就是处理器这个

1462
00:54:14,000 --> 00:54:18,000
你得有多个处理器就多核或者是多个 CPU 的

1463
00:54:18,000 --> 00:54:21,000
或者说更抽象点就是多个逻辑单元

1464
00:54:21,000 --> 00:54:24,000
你可能对可以去对

1465
00:54:24,000 --> 00:54:30,000
比如说对早期的计算机可能的确是不具备并发

1466
00:54:30,000 --> 00:54:32,000
就是单核处理器吗

1467
00:54:32,000 --> 00:54:36,000
对甚至不是先不说单核处理器这个这件事情

1468
00:54:36,000 --> 00:54:43,000
就是你在单核处理器上可以用可以在操作这种层面去去模拟

1469
00:54:43,000 --> 00:54:43,000
啊

1470
00:54:43,000 --> 00:54:44,000
parallel

1471
00:54:44,000 --> 00:54:54,000
但是在真正的早期的计算机里面就连连连并连这种操作系统层面的并行都是不存在的

1472
00:54:54,000 --> 00:54:56,000
就并发并发

1473
00:54:56,000 --> 00:54:59,000
呃操作系统层面的并行是不存在

1474
00:54:59,000 --> 00:55:06,000
我觉得一五的我想要说的就是比如说那个时候并发肯定是呃存在的

1475
00:55:06,000 --> 00:55:08,000
比如说你一方面要读软盘

1476
00:55:08,000 --> 00:55:10,000
另一方面要刷新屏幕上的字符

1477
00:55:10,000 --> 00:55:12,000
这个时候你已经有那个了吗

1478
00:55:12,000 --> 00:55:13,000
有那个叫什么

1479
00:55:13,000 --> 00:55:16,000
有多任务了吗

1480
00:55:16,000 --> 00:55:16,000
没有多任务

1481
00:55:16,000 --> 00:55:20,000
我的意思就是在很早很早的时代没有多任务的时代

1482
00:55:20,000 --> 00:55:21,000
当你在读软盘的时候

1483
00:55:21,000 --> 00:55:23,000
你的屏幕就是卡死了

1484
00:55:24,000 --> 00:55:29,000
那就那个时候计算机是没有办法用并用任何任用任何

1485
00:55:29,000 --> 00:55:33,000
不管是真实的也还是虚假的并行手段去解决这些并发问题

1486
00:55:35,000 --> 00:55:40,000
对然后后来我们就有了这种就所谓的这个多任务机制

1487
00:55:40,000 --> 00:55:43,000
就是在哪怕是在单一执行单一逻辑

1488
00:55:43,000 --> 00:55:44,000
和的处理这个计算机上

1489
00:55:44,000 --> 00:55:48,000
我们也可以就假装我们是在多的同时执行很多事情啊

1490
00:55:48,000 --> 00:55:52,000
比如说最早实现那个什么就民用的话

1491
00:55:52,000 --> 00:55:54,000
应该是问的三二还是九三二吧

1492
00:55:56,000 --> 00:55:57,000
你要是说最早的话呢

1493
00:55:57,000 --> 00:55:58,000
因为在用的

1494
00:55:58,000 --> 00:55:59,000
是这样的

1495
00:55:59,000 --> 00:56:02,000
不就是大规模使用的情况下

1496
00:56:02,000 --> 00:56:04,000
就是不可能用到真的是 95 吧

1497
00:56:04,000 --> 00:56:04,000
我觉得

1498
00:56:07,000 --> 00:56:10,000
九三九五不是强劲是多任务

1499
00:56:10,000 --> 00:56:12,000
所以三二三二已经有多任务了

1500
00:56:12,000 --> 00:56:13,000
三二已经有多任务了

1501
00:56:13,000 --> 00:56:14,000
就是那个时候就已经多了

1502
00:56:14,000 --> 00:56:20,000
就是可以在你在实现你在前你在放一首歌的时候

1503
00:56:20,000 --> 00:56:21,000
同时打开一个图片

1504
00:56:21,000 --> 00:56:22,000
比如说可以做这么一件事情

1505
00:56:23,000 --> 00:56:25,000
你都是当然是不能这样的嘛

1506
00:56:26,000 --> 00:56:28,000
但是等等

1507
00:56:28,000 --> 00:56:31,000
windows 三二是可能这个术语需要解释一下

1508
00:56:31,000 --> 00:56:32,000
就是啊

1509
00:56:32,000 --> 00:56:34,000
我们说三二其实指 windows 三点零

1510
00:56:34,000 --> 00:56:35,000
因为呃

1511
00:56:35,000 --> 00:56:39,000
我那三点二其实是只有中国地区才有 windows 三点二

1512
00:56:39,000 --> 00:56:40,000
就是三点

1513
00:56:40,000 --> 00:56:40,000
不对

1514
00:56:40,000 --> 00:56:43,000
windows 三点二其实就是一个 windows 三点一的简体中文吧

1515
00:56:43,000 --> 00:56:45,000
啊这样我不知道

1516
00:56:45,000 --> 00:56:47,000
对所以所以我们经常说 windows 三点二

1517
00:56:47,000 --> 00:56:52,000
但其实这个概念仅限于中文圈里面

1518
00:56:52,000 --> 00:56:52,000
windows 三吧

1519
00:56:52,000 --> 00:56:54,000
我们都有多称

1520
00:56:54,000 --> 00:56:58,000
对 windows 三是一个比较好的特别嗯嗯嗯术语

1521
00:56:58,000 --> 00:56:59,000
对对

1522
00:56:59,000 --> 00:57:00,000
然后后来就有了这个多任务

1523
00:57:00,000 --> 00:57:01,000
就可以实现刚才那个功能

1524
00:57:01,000 --> 00:57:04,000
但是那个处理器还是一次只做一件事

1525
00:57:04,000 --> 00:57:06,000
就是他他放一会儿这个歌

1526
00:57:06,000 --> 00:57:09,000
还有把那个处理器核心切到去画一会图

1527
00:57:09,000 --> 00:57:11,000
然后再再切回来放一会儿歌

1528
00:57:11,000 --> 00:57:13,000
然后再切回来画一会图

1529
00:57:13,000 --> 00:57:14,000
他只要切的够快

1530
00:57:14,000 --> 00:57:18,000
给人的错觉是说他同时在做两件事

1531
00:57:18,000 --> 00:57:19,000
就是他在

1532
00:57:19,000 --> 00:57:22,000
并行的执行两件并发的任务

1533
00:57:22,000 --> 00:57:24,000
但其实他只是一个单

1534
00:57:24,000 --> 00:57:25,000
他并不是并行的

1535
00:57:25,000 --> 00:57:27,000
他只是一个不太不太喜欢的一个东西

1536
00:57:27,000 --> 00:57:30,000
他就像闪电侠一样可以自己跟自己打乒乓球

1537
00:57:30,000 --> 00:57:31,000
哎

1538
00:57:31,000 --> 00:57:33,000
就是这个这个切换的非常快

1539
00:57:33,000 --> 00:57:35,000
对对这个是很好的比

1540
00:57:35,000 --> 00:57:38,000
啊然后真正到了要有 pilot 就是有并发的感觉

1541
00:57:38,000 --> 00:57:39,000
还是有这个

1542
00:57:39,000 --> 00:57:42,000
就当时有大号处理就有多线程的时候嘛

1543
00:57:42,000 --> 00:57:43,000
就 hyper threading 的时候

1544
00:57:43,000 --> 00:57:44,000
就是一个处理器核心

1545
00:57:44,000 --> 00:57:47,000
他模拟成两个逻辑核在用

1546
00:57:47,000 --> 00:57:51,000
还有包括到我们现在的真正的多个物理核的情况下

1547
00:57:51,000 --> 00:57:54,000
甚至在一些工作站或者是服务器上

1548
00:57:54,000 --> 00:57:55,000
所谓的那种多 CPU

1549
00:57:55,000 --> 00:57:58,000
就是不只有一个 CPU 的芯片

1550
00:57:58,000 --> 00:58:00,000
还有可能两个或者四个这样

1551
00:58:00,000 --> 00:58:03,000
对这样只有到这个时候才

1552
00:58:03,000 --> 00:58:05,000
我们才说真正的 pilot

1553
00:58:05,000 --> 00:58:09,000
并行对已经是这样

1554
00:58:09,000 --> 00:58:11,000
不过其实并行在

1555
00:58:12,000 --> 00:58:13,000
在

1556
00:58:13,000 --> 00:58:16,000
我们讲 CPU 的时候是可能比较晚进才出现

1557
00:58:16,000 --> 00:58:20,000
但是他在讲那个 GPU 就图形处理器的时候

1558
00:58:20,000 --> 00:58:21,000
他确实一直存在的啊

1559
00:58:21,000 --> 00:58:27,000
因为我们知道这个 GPU 的它是一个大规模并行化的这种一种结构

1560
00:58:27,000 --> 00:58:29,000
就是因为图像处理这件事情

1561
00:58:29,000 --> 00:58:33,000
他与生俱来就存在着这么一个

1562
00:58:33,000 --> 00:58:37,000
呃可以被并行执行的问题

1563
00:58:37,000 --> 00:58:42,000
就是你需要大规模的改变一张图上的每一个点

1564
00:58:42,000 --> 00:58:52,000
那这就就这就有点像你需要呃同时给两万个抽屉里在你两万充里面找有没有黑白黑子这样

1565
00:58:52,000 --> 00:58:59,000
所以这件事情是可以天生的被呃批量的以流水线的方式并行处理的

1566
00:58:59,000 --> 00:59:03,000
所以也就是因为这个这种问题的特别性

1567
00:59:03,000 --> 00:59:06,000
所以才会有 GPU 这种东西出现

1568
00:59:06,000 --> 00:59:07,000
而且就 GPU

1569
00:59:07,000 --> 00:59:11,000
如果你能你的问题可以被简化为啊

1570
00:59:11,000 --> 00:59:15,000
或者不叫复杂化为这个 GPU 的那种适合模型的话

1571
00:59:15,000 --> 00:59:17,000
你能获得到这个所谓的吞吐能力

1572
00:59:17,000 --> 00:59:19,000
就是 throughput 是非常非常惊人的

1573
00:59:19,000 --> 00:59:20,000
没错

1574
00:59:20,000 --> 00:59:21,000
而反过来讲

1575
00:59:21,000 --> 00:59:26,000
这也就是为什么很多跟 GP 跟除跟图像处理

1576
00:59:26,000 --> 00:59:28,000
其实没有任何联系的事情可以交由 GPU 来做

1577
00:59:28,000 --> 00:59:29,000
比如说呃

1578
00:59:29,000 --> 00:59:31,000
Bitcoin mining

1579
00:59:31,000 --> 00:59:33,000
GPU 来做

1580
00:59:33,000 --> 00:59:40,000
就是因为他其实也是一个可以天生的被很好的并行处理的呃任务

1581
00:59:41,000 --> 00:59:41,000
嗯

1582
00:59:41,000 --> 00:59:42,000
对于这一类问题

1583
00:59:42,000 --> 00:59:45,000
我们一般有一个就所谓的一个名称

1584
00:59:45,000 --> 00:59:46,000
专有名称

1585
00:59:46,000 --> 00:59:49,000
就说这种叫做 embarrassingly paralysable task

1586
00:59:49,000 --> 00:59:50,000
对不对

1587
00:59:50,000 --> 00:59:54,000
就非常尴尬的可以被并行化执行的问题

1588
00:59:54,000 --> 00:59:55,000
没错

1589
00:59:55,000 --> 00:59:57,000
这就好像呃

1590
00:59:57,000 --> 01:00:02,000
罚你小学的时候罚你把某一句话超几百遍

1591
01:00:02,000 --> 01:00:05,000
就大家会用五支笔

1592
01:00:05,000 --> 01:00:06,000
呃

1593
01:00:06,000 --> 01:00:08,000
五支笔可能非常惊人的

1594
01:00:08,000 --> 01:00:10,000
非常了不起的小伙伴

1595
01:00:10,000 --> 01:00:11,000
固定在一起

1596
01:00:11,000 --> 01:00:14,000
一般人用三支笔同时抄课文是可以做到

1597
01:00:14,000 --> 01:00:16,000
把一个字写两千遍

1598
01:00:16,000 --> 01:00:19,000
这是就是这就是一个非常 embarrassing

1599
01:00:19,000 --> 01:00:20,000
呃

1600
01:00:20,000 --> 01:00:22,000
paralel task

1601
01:00:22,000 --> 01:00:23,000
没错

1602
01:00:23,000 --> 01:00:24,000
对

1603
01:00:24,000 --> 01:00:25,000
其实这是一个很好的例子

1604
01:00:25,000 --> 01:00:27,000
就是

1605
01:00:27,000 --> 01:00:29,000
把把某一字抄几千遍

1606
01:00:29,000 --> 01:00:30,000
这其实一个

1607
01:00:30,000 --> 01:00:32,000
其实就是一个呃

1608
01:00:32,000 --> 01:00:33,000
并不是非常 concurrency

1609
01:00:33,000 --> 01:00:36,000
但是可以被 parallel 执行的任务

1610
01:00:36,000 --> 01:00:37,000
嗯

1611
01:00:37,000 --> 01:00:37,000
呃

1612
01:00:37,000 --> 01:00:39,000
所以有一件事情是可以确定的

1613
01:00:39,000 --> 01:00:40,000
就是现代的编程世界是呃

1614
01:00:40,000 --> 01:00:40,000
呃

1615
01:00:40,000 --> 01:00:40,000
呃

1616
01:00:40,000 --> 01:00:40,000
呃

1617
01:00:40,000 --> 01:00:40,000
呃

1618
01:00:40,000 --> 01:00:40,000
呃

1619
01:00:40,000 --> 01:00:40,000
呃

1620
01:00:40,000 --> 01:00:40,000
呃

1621
01:00:40,000 --> 01:00:41,000
呃

1622
01:00:41,000 --> 01:00:41,000
呃

1623
01:00:41,000 --> 01:00:41,000
呃

1624
01:00:41,000 --> 01:00:41,000
呃

1625
01:00:41,000 --> 01:00:41,000
呃

1626
01:00:41,000 --> 01:00:43,000
呃

1627
01:00:43,000 --> 01:00:43,000
呃

1628
01:00:43,000 --> 01:00:43,000
呃

1629
01:00:43,000 --> 01:00:46,000
呃

1630
01:00:46,000 --> 01:00:59,000
呃

1631
01:00:59,000 --> 01:01:00,000
呃

1632
01:01:00,000 --> 01:01:01,000
呃

1633
01:01:01,000 --> 01:01:06,000
呃

1634
01:01:06,000 --> 01:01:06,000
呃

1635
01:01:06,000 --> 01:01:10,000
呃

1636
01:01:10,000 --> 01:01:11,000
呃

1637
01:01:11,000 --> 01:01:11,000
呃

1638
01:01:11,000 --> 01:01:12,000
做起来比较简单的概念

1639
01:01:12,000 --> 01:01:14,000
或者当你做起来很复杂

1640
01:01:14,000 --> 01:01:16,000
但做起来人们不同的人

1641
01:01:16,000 --> 01:01:19,000
有不同的意见的这么一个一件事情

1642
01:01:19,000 --> 01:01:25,000
就最最简单的一个一种一种并发模型

1643
01:01:25,000 --> 01:01:26,000
或者说并行模型

1644
01:01:26,000 --> 01:01:28,000
我觉得接下来节目

1645
01:01:28,000 --> 01:01:30,000
我们还是毁用并发和并行这个词

1646
01:01:30,000 --> 01:01:31,000
不然实在是太累了

1647
01:01:32,000 --> 01:01:33,000
你说呢

1648
01:01:33,000 --> 01:01:36,000
就是在不区分这个

1649
01:01:36,000 --> 01:01:39,000
不严格区分并发并行的场合的情况下

1650
01:01:39,000 --> 01:01:41,000
这两者有时候又是在混用的

1651
01:01:41,000 --> 01:01:42,000
对没错

1652
01:01:42,000 --> 01:01:44,000
对

1653
01:01:44,000 --> 01:01:45,000
所以接下来的

1654
01:01:45,000 --> 01:01:48,000
接下来当我说到并发模型的时候

1655
01:01:48,000 --> 01:01:50,000
我其实我的意思有可能是并行模型

1656
01:01:50,000 --> 01:01:54,000
但我说并行模型的时候

1657
01:01:54,000 --> 01:01:56,000
一般肯定是在讲并行模型

1658
01:01:56,000 --> 01:01:57,000
对

1659
01:01:57,000 --> 01:02:01,000
所以最基本的一种并行模型是什么呢

1660
01:02:01,000 --> 01:02:03,000
我觉得是 thread

1661
01:02:03,000 --> 01:02:05,000
就是现成

1662
01:02:05,000 --> 01:02:06,000
或者说

1663
01:02:06,000 --> 01:02:08,000
或者说应该说最基本的一种

1664
01:02:08,000 --> 01:02:09,000
并

1665
01:02:09,000 --> 01:02:12,000
形模型应该是多进程

1666
01:02:12,000 --> 01:02:14,000
multiprocess

1667
01:02:14,000 --> 01:02:17,000
如果真的要追根溯源的话

1668
01:02:17,000 --> 01:02:20,000
那应该可能还是多进程

1669
01:02:20,000 --> 01:02:22,000
先于多现成出现对吧

1670
01:02:22,000 --> 01:02:23,000
没错

1671
01:02:23,000 --> 01:02:24,000
因为起码在

1672
01:02:24,000 --> 01:02:28,000
我记得 Linux 现在是非常晚进才出现多现成

1673
01:02:28,000 --> 01:02:31,000
最开始的一直是多进程的模型

1674
01:02:31,000 --> 01:02:31,000
对

1675
01:02:31,000 --> 01:02:35,000
因为在 Linux 上面开一个进程的方法

1676
01:02:35,000 --> 01:02:37,000
开一个进程要比开一个现成简单很多

1677
01:02:37,000 --> 01:02:38,000
对

1678
01:02:38,000 --> 01:02:39,000
而且开一个进程要比开一个现成简单很多

1679
01:02:39,000 --> 01:02:40,000
开销也不是特别大

1680
01:02:40,000 --> 01:02:43,000
就是它的多一个进程的开销是相对小的

1681
01:02:43,000 --> 01:02:44,000
对

1682
01:02:44,000 --> 01:02:46,000
具体技术细节我们就不解释了

1683
01:02:46,000 --> 01:02:46,000
但是

1684
01:02:46,000 --> 01:02:53,000
其最根本的想法就是在一个编程语言里面

1685
01:02:53,000 --> 01:02:56,000
如果我们要利用多进程或者是多现成的话

1686
01:02:56,000 --> 01:02:56,000
好

1687
01:02:56,000 --> 01:02:58,000
那我就显示的写出来

1688
01:02:58,000 --> 01:03:00,000
这里请开一个新的进程

1689
01:03:00,000 --> 01:03:01,000
或者利用 fork

1690
01:03:01,000 --> 01:03:02,000
或者怎么样

1691
01:03:02,000 --> 01:03:06,000
然后或者说在这里请开一个新的现成

1692
01:03:06,000 --> 01:03:08,000
用 thread

1693
01:03:08,000 --> 01:03:09,000
然后我们就会看到了

1694
01:03:09,000 --> 01:03:15,000
然后这就是非常简单直接

1695
01:03:15,000 --> 01:03:17,000
至少对于硬件来说

1696
01:03:17,000 --> 01:03:21,000
非常简单直接的一种并行开发的模型

1697
01:03:21,000 --> 01:03:25,000
但是这种并行开发的模型有一个问题

1698
01:03:25,000 --> 01:03:27,000
就是对于程序来说比较挑战

1699
01:03:27,000 --> 01:03:32,000
因为受限于我们只有一个大脑的限制

1700
01:03:32,000 --> 01:03:34,000
或者说我们的思维天生就是一个

1701
01:03:34,000 --> 01:03:36,000
线性的思维

1702
01:03:36,000 --> 01:03:38,000
一个单线成的

1703
01:03:38,000 --> 01:03:39,000
一个单进程的思维

1704
01:03:39,000 --> 01:03:43,000
所以在理解多进程的时候

1705
01:03:43,000 --> 01:03:47,000
会有一个会有一个会有个卡

1706
01:03:47,000 --> 01:03:48,000
我不知道你怎么样

1707
01:03:48,000 --> 01:03:52,000
但是当我写出人生第一个多进程的程序的时候

1708
01:03:52,000 --> 01:03:55,000
我是我是愣了很久了

1709
01:03:55,000 --> 01:04:00,000
就是我需要我需要去去拥有那种精神分裂的能力

1710
01:04:00,000 --> 01:04:01,000
就是在这个地方

1711
01:04:01,000 --> 01:04:03,000
我们需要判断说我的 pid 是零

1712
01:04:03,000 --> 01:04:06,000
那我是一个新的进程

1713
01:04:09,000 --> 01:04:11,000
那接下来我所要做这件事情

1714
01:04:11,000 --> 01:04:14,000
然后另外一些事情则要在我的附近城里面进行

1715
01:04:14,000 --> 01:04:19,000
然后这个时候我就会有一种会有一种会有一种

1716
01:04:19,000 --> 01:04:20,000
是什么感觉

1717
01:04:20,000 --> 01:04:21,000
对会有什么非常兴奋的感觉

1718
01:04:21,000 --> 01:04:23,000
就会觉得说好吧

1719
01:04:23,000 --> 01:04:24,000
那

1720
01:04:25,000 --> 01:04:30,000
计算机解释这一切的时候可能会比较比较方便

1721
01:04:30,000 --> 01:04:32,000
但是我我就会不停的去想说

1722
01:04:32,000 --> 01:04:35,000
那我现在是在附近城里还是在紫禁城里呢

1723
01:04:35,000 --> 01:04:37,000
那我我做完这件事情

1724
01:04:37,000 --> 01:04:38,000
我要我要回到附近城里面的附近城里面呢

1725
01:04:38,000 --> 01:04:40,000
附近城里要做收尾工作

1726
01:04:40,000 --> 01:04:44,000
可是万一紫禁城没有及时的完成这些事情

1727
01:04:44,000 --> 01:04:45,000
附近城要等他吗

1728
01:04:45,000 --> 01:04:52,000
就是在我将我记得在学操作性还是什么的时候

1729
01:04:52,000 --> 01:04:59,000
有很大一个篇幅都是在讲多进程或者多现成的实现原理的

1730
01:04:59,000 --> 01:05:03,000
就比如说什么很多很经典的数学问题数学模型

1731
01:05:03,000 --> 01:05:05,000
也是在这个领域被提出来

1732
01:05:05,000 --> 01:05:08,000
比如说什么我忘了哲学家吃饭的地球什么

1733
01:05:08,000 --> 01:05:08,000
你一个哲学家

1734
01:05:08,000 --> 01:05:10,000
左边是刀右边是叉

1735
01:05:10,000 --> 01:05:11,000
对

1736
01:05:11,000 --> 01:05:14,000
没错

1737
01:05:14,000 --> 01:05:16,000
等等

1738
01:05:16,000 --> 01:05:18,000
而且我觉得我印象里面没记错的话

1739
01:05:18,000 --> 01:05:21,000
这本书的英文版里面

1740
01:05:21,000 --> 01:05:24,000
哲学家是左手刀右手叉

1741
01:05:24,000 --> 01:05:28,000
然后在中文版里面变成了哲学家左右各有一只筷子

1742
01:05:28,000 --> 01:05:31,000
就连这个地方要本地化一下

1743
01:05:31,000 --> 01:05:34,000
你不需要拿到两只筷子才可以进餐

1744
01:05:34,000 --> 01:05:35,000
对

1745
01:05:35,000 --> 01:05:37,000
我记得那个时候特别可笑

1746
01:05:37,000 --> 01:05:38,000
呃

1747
01:05:38,000 --> 01:05:38,000
当时

1748
01:05:38,000 --> 01:05:40,000
客场上有个同学讲了一个笑话

1749
01:05:40,000 --> 01:05:43,000
就说他们为什么不都换成长勺子

1750
01:05:43,000 --> 01:05:44,000
然后互相喂饭吃

1751
01:05:44,000 --> 01:05:52,000
这就跟另外一个也是哲学上的一个笑话连起来的

1752
01:05:52,000 --> 01:05:53,000
就是说哲学上说

1753
01:05:53,000 --> 01:05:58,000
有一个一堆人围坐在一口锅前面要吃饭

1754
01:05:58,000 --> 01:06:00,000
但是每个人的勺子都特别长

1755
01:06:00,000 --> 01:06:04,000
没有办法把它转过来喂自己吃饭

1756
01:06:04,000 --> 01:06:08,000
所以每个人必须去喂对方吃饭

1757
01:06:08,000 --> 01:06:08,000
所有人才不会为自己吃饭

1758
01:06:08,000 --> 01:06:10,000
所以这个就是一个很严重的一个论点

1759
01:06:10,000 --> 01:06:15,000
然后这个故事被他在这边转移到这个哲学家饿死的里面

1760
01:06:15,000 --> 01:06:16,000
我觉得当时特别有喜感

1761
01:06:16,000 --> 01:06:22,000
刚才讲你说这个并发

1762
01:06:22,000 --> 01:06:25,000
这个并行变成 parallel programming

1763
01:06:25,000 --> 01:06:33,000
的一个核心的问题就是可能对程序员的要求就就就不是就是数量级的提高吧

1764
01:06:33,000 --> 01:06:35,000
因为确实如你所说

1765
01:06:35,000 --> 01:06:36,000
这个人的思维很多人

1766
01:06:36,000 --> 01:06:37,000
他是一个单线的一个过程

1767
01:06:37,000 --> 01:06:38,000
他没办法去同时考试的过程中

1768
01:06:38,000 --> 01:06:40,000
他没有办法去考虑

1769
01:06:40,000 --> 01:06:43,000
你大脑不是一个多好多合的东西吗

1770
01:06:43,000 --> 01:06:43,000
没错

1771
01:06:43,000 --> 01:06:48,000
那么就其实就就可能在传统的这个线性编程的情况下

1772
01:06:48,000 --> 01:06:52,000
你你你你的这个思维逻辑跟着这个程序程序代码走一遍

1773
01:06:52,000 --> 01:06:54,000
你也知道计算机也是这么执行的

1774
01:06:54,000 --> 01:06:57,000
并且不会有任何人干扰你中间这个执行的步骤

1775
01:06:57,000 --> 01:07:00,000
当然可能中断那些什么除外啊

1776
01:07:00,000 --> 01:07:00,000
啊

1777
01:07:00,000 --> 01:07:01,000
错

1778
01:07:01,000 --> 01:07:03,000
但是在一个并行的条件下

1779
01:07:03,000 --> 01:07:05,000
这个事情就变得非常诡异了

1780
01:07:05,000 --> 01:07:08,000
就是如果你不考虑什么锁的那些机制啊

1781
01:07:08,000 --> 01:07:08,000
那么同步啊

1782
01:07:08,000 --> 01:07:08,000
什么同步啊

1783
01:07:08,000 --> 01:07:08,000
什么同步啊

1784
01:07:08,000 --> 01:07:09,000
什么同步机制的话

1785
01:07:09,000 --> 01:07:15,000
它是有无限多种可能有两个就是两个或者多个这种现成也好进程也好

1786
01:07:15,000 --> 01:07:17,000
它可以我们叫做 interleaving 嘛

1787
01:07:17,000 --> 01:07:20,000
就是互相交织互相交织

1788
01:07:20,000 --> 01:07:21,000
对对对

1789
01:07:21,000 --> 01:07:22,000
这个时候你就很难去看

1790
01:07:22,000 --> 01:07:23,000
看明白说啊

1791
01:07:24,000 --> 01:07:28,000
或者说你要你的脑袋中要装的那个那个 state space

1792
01:07:28,000 --> 01:07:30,000
就是他你到这一步的时候

1793
01:07:30,000 --> 01:07:31,000
其他人可能会怎么样

1794
01:07:31,000 --> 01:07:34,000
这种东西它就是一个指数增长的东西

1795
01:07:34,000 --> 01:07:38,000
所以这个时候对人的思维挑战确实是一个极其困难的一件过程

1796
01:07:38,000 --> 01:07:38,000
一个

1797
01:07:38,000 --> 01:07:39,000
一个过程

1798
01:07:39,000 --> 01:07:40,000
而且啊

1799
01:07:40,000 --> 01:07:42,000
就为了解决这个问题呢

1800
01:07:42,000 --> 01:07:43,000
就是你们也很多这种方案嘛

1801
01:07:43,000 --> 01:07:44,000
比如说啊

1802
01:07:44,000 --> 01:07:50,000
最可能我们听的最多的一条就说就说 share the mutable state is bad is evil

1803
01:07:50,000 --> 01:07:50,000
对吧

1804
01:07:50,000 --> 01:07:53,000
就是如果你是你是并并行

1805
01:07:53,000 --> 01:07:54,000
边并行边程的东西

1806
01:07:54,000 --> 01:07:56,000
然后你还要多个现成也好

1807
01:07:56,000 --> 01:07:57,000
进程也好

1808
01:07:57,000 --> 01:08:04,000
去共去同时访问一个可以被改写的一个一个呃内存区域或者是变量或者文件也好

1809
01:08:04,000 --> 01:08:05,000
这个时候你就非常困难了

1810
01:08:05,000 --> 01:08:08,000
因为你你没有办法从

1811
01:08:08,000 --> 01:08:14,000
从那个被改写的那个区域的角度来看会你会你能预测到会产生什么样的组合

1812
01:08:14,000 --> 01:08:16,000
因为这个组合是不确定性的

1813
01:08:16,000 --> 01:08:17,000
是一个叫做啊

1814
01:08:17,000 --> 01:08:22,000
已经听了 stick 就是呃不不确定性的一个过程

1815
01:08:22,000 --> 01:08:23,000
没错啊

1816
01:08:23,000 --> 01:08:27,000
所以这个很多时候我们的一个解决方案就说那么最好就是叫做 share the nothing

1817
01:08:27,000 --> 01:08:30,000
就是一一切都不要共享的结构

1818
01:08:30,000 --> 01:08:31,000
这样的话有什么好处呢

1819
01:08:31,000 --> 01:08:34,000
这样你就可以在并行的环境下

1820
01:08:34,000 --> 01:08:37,000
对于某一个现成或者进程也好

1821
01:08:37,000 --> 01:08:38,000
你不用考虑他

1822
01:08:38,000 --> 01:08:40,000
和别的进程和现成的交互怎么样

1823
01:08:40,000 --> 01:08:45,000
你只要考虑他自己本身是个现行的这现行的程序走下去就好了

1824
01:08:45,000 --> 01:08:46,000
这个时候就等价

1825
01:08:46,000 --> 01:08:52,000
等于说是把一个并行的问题变成了一个线性的串行的问题来解决了

1826
01:08:52,000 --> 01:08:57,000
但实际上这种这种情况是不太可行的

1827
01:08:57,000 --> 01:09:01,000
就可能有一些比较极端的例子是所以这种切纳森结构的东西

1828
01:09:01,000 --> 01:09:03,000
比如说我们很多的网页服务器

1829
01:09:03,000 --> 01:09:06,000
他可能就是比如说 patch 就是一个很典型的例子

1830
01:09:06,000 --> 01:09:08,000
他每一个请求来

1831
01:09:08,000 --> 01:09:13,000
可能都是开一个新的进程或者开个新的现成来来响应这个请求

1832
01:09:13,000 --> 01:09:15,000
然后想一完毕这个进程或者现成也就被杀掉了

1833
01:09:15,000 --> 01:09:17,000
但这个传统的模型啊

1834
01:09:17,000 --> 01:09:22,000
然后在在这个响应这个请求的现成或者是进程执行的过程中

1835
01:09:22,000 --> 01:09:24,000
他你是不用考虑别的现成和进程怎么样

1836
01:09:24,000 --> 01:09:26,000
因为你没有共享任何东西嘛

1837
01:09:26,000 --> 01:09:28,000
但是在实际应用中

1838
01:09:28,000 --> 01:09:30,000
很多时候你确实是要共享东西的

1839
01:09:30,000 --> 01:09:33,000
比如说我们现在很多做什么 webapp 对吧

1840
01:09:33,000 --> 01:09:35,000
你是要要访问一个共享的数据库的

1841
01:09:35,000 --> 01:09:37,000
那你可能要访问一个啊

1842
01:09:38,000 --> 01:09:40,000
同一个同一共享的数据库

1843
01:09:40,000 --> 01:09:41,000
然后你可能要改写东西

1844
01:09:41,000 --> 01:09:44,000
这个时候你又变成本来是一个 share nothing 的东西

1845
01:09:44,000 --> 01:09:46,000
又变成有一个 shared mutable state

1846
01:09:46,000 --> 01:09:47,000
这样的话

1847
01:09:47,000 --> 01:09:49,000
这个整个模型就又变得很复杂

1848
01:09:49,000 --> 01:09:51,000
而且难以测试起来

1849
01:09:51,000 --> 01:09:56,000
现成加上锁这种结构就好像一个到处漏水的桶

1850
01:09:56,000 --> 01:09:59,000
你总会觉得我堵住这个孔就没问题了

1851
01:09:59,000 --> 01:10:01,000
但是因为你堵住了这个孔

1852
01:10:01,000 --> 01:10:02,000
所以水压变高了

1853
01:10:02,000 --> 01:10:03,000
它会从另外一块漏出来

1854
01:10:03,000 --> 01:10:07,000
所以有时候用现成锁编程的时候

1855
01:10:07,000 --> 01:10:11,000
你会觉得自己不仅思考的

1856
01:10:11,000 --> 01:10:11,000
大地鼠

1857
01:10:11,000 --> 01:10:14,000
对思考的层级非常低

1858
01:10:14,000 --> 01:10:15,000
就是你会被迫自己

1859
01:10:15,000 --> 01:10:20,000
你迫使强迫自己像一个现成管理器那样去思考

1860
01:10:20,000 --> 01:10:24,000
而且与此同时你会发现解决了一个问题

1861
01:10:24,000 --> 01:10:25,000
另外一个问题又冒出来了

1862
01:10:25,000 --> 01:10:26,000
对

1863
01:10:26,000 --> 01:10:27,000
对

1864
01:10:27,000 --> 01:10:28,000
顾此是彼嘛

1865
01:10:28,000 --> 01:10:29,000
没错顾此是彼

1866
01:10:29,000 --> 01:10:33,000
这个是为什么虽然现成或者说多建成

1867
01:10:33,000 --> 01:10:35,000
或者多建成加上锁这种机制

1868
01:10:35,000 --> 01:10:37,000
在几乎所有相应的

1869
01:10:37,000 --> 01:10:40,000
相应一点的程序里面都有支持

1870
01:10:40,000 --> 01:10:43,000
但是用好它们却是非常

1871
01:10:43,000 --> 01:10:45,000
非常难

1872
01:10:45,000 --> 01:10:49,000
而且我觉得这种难是没有必要的一种难的事情

1873
01:10:49,000 --> 01:10:53,000
就是这是一个可能不是一个太好的抽象

1874
01:10:53,000 --> 01:10:54,000
就得出了这么一个

1875
01:10:54,000 --> 01:10:54,000
对

1876
01:10:54,000 --> 01:10:57,000
它的抽象层级可能实在是太低了

1877
01:10:57,000 --> 01:10:57,000
就有点像

1878
01:10:57,000 --> 01:11:01,000
或者说它抽象的那个角度是错的

1879
01:11:01,000 --> 01:11:01,000
就是

1880
01:11:01,000 --> 01:11:03,000
或者说

1881
01:11:03,000 --> 01:11:04,000
我怎么说的

1882
01:11:04,000 --> 01:11:07,000
我觉得它抽象的角度没有错不错之分

1883
01:11:07,000 --> 01:11:09,000
因为在操作性的层面上

1884
01:11:09,000 --> 01:11:12,000
并行就是这么就是这么被实现的

1885
01:11:12,000 --> 01:11:16,000
它与其说它的抽象角度是错的

1886
01:11:16,000 --> 01:11:19,000
不如说它所抽象的东西但是太少了

1887
01:11:19,000 --> 01:11:22,000
就是基本上你要从非常底层的

1888
01:11:22,000 --> 01:11:24,000
够有用的抽象

1889
01:11:24,000 --> 01:11:24,000
对不对

1890
01:11:24,000 --> 01:11:25,000
没错

1891
01:11:25,000 --> 01:11:27,000
这就是为什么

1892
01:11:27,000 --> 01:11:33,000
接下来我们会提到几种其他的并行模型

1893
01:11:33,000 --> 01:11:34,000
就是他们是从从

1894
01:11:34,000 --> 01:11:37,000
他们试图从不同的角度去解决

1895
01:11:37,000 --> 01:11:37,000
这个问题

1896
01:11:37,000 --> 01:11:40,000
但是如果没说错的话

1897
01:11:40,000 --> 01:11:48,000
很多并行模型的基本实现原理还是通过现成的锁

1898
01:11:49,000 --> 01:11:51,000
就底层它是这么实现的

1899
01:11:51,000 --> 01:11:55,000
但是就是它暴露给这个开发者或者程序员的这么一个

1900
01:11:55,000 --> 01:11:57,000
一个接口或者是一个表象

1901
01:11:57,000 --> 01:11:59,000
你看不到那些东西了

1902
01:11:59,000 --> 01:12:00,000
对

1903
01:12:00,000 --> 01:12:03,000
这其实是回到我们前很多

1904
01:12:03,000 --> 01:12:07,000
至少很长时间以前讲的风装的那面积极了

1905
01:12:07,000 --> 01:12:10,000
那么一个那么一个问题领域

1906
01:12:10,000 --> 01:12:15,000
就是我们接下来要介绍的几种并发模型

1907
01:12:15,000 --> 01:12:19,000
其实是对于多线程枷锁的这样一种风装

1908
01:12:19,000 --> 01:12:21,000
但是这种风装

1909
01:12:21,000 --> 01:12:23,000
当你熟悉了它之后

1910
01:12:23,000 --> 01:12:31,000
你会发现在很大程度上增加了你思考的方便程度

1911
01:12:31,000 --> 01:12:33,000
或者说让你变得更像一个人了

1912
01:12:33,000 --> 01:12:34,000
而不像一个机器

1913
01:12:34,000 --> 01:12:36,000
不用再在头脑中模拟

1914
01:12:36,000 --> 01:12:37,000
费力了

1915
01:12:37,000 --> 01:12:37,000
费力了

1916
01:12:37,000 --> 01:12:37,000
费力了

1917
01:12:37,000 --> 01:12:37,000
费力了

1918
01:12:37,000 --> 01:12:42,000
就毕竟的用一个单核处理器的大脑去模拟一个多核处理器的 CPU 了

1919
01:12:42,000 --> 01:12:43,000
对

1920
01:12:43,000 --> 01:12:43,000
没错

1921
01:12:43,000 --> 01:12:51,000
那你觉得除了多线程的模型之外

1922
01:12:51,000 --> 01:12:56,000
哪一种并发模型是最最简单

1923
01:12:56,000 --> 01:12:59,000
或者说最直接能够让人比较方便接受

1924
01:12:59,000 --> 01:13:05,000
那最好就是不要让我去想

1925
01:13:05,000 --> 01:13:06,000
去让我思考

1926
01:13:06,000 --> 01:13:07,000
有这些

1927
01:13:07,000 --> 01:13:12,000
就是底层这些就是最理想的模型是不要让我思考有这么一些东西存在的东西

1928
01:13:12,000 --> 01:13:16,000
那可能用从语言层面上来解决这个问题的话

1929
01:13:16,000 --> 01:13:20,000
如果你能实现我们传统意义上的什么方 FP 吗

1930
01:13:20,000 --> 01:13:22,000
就是函数式编程的话

1931
01:13:22,000 --> 01:13:24,000
就可能就在根本不用考虑这个问题了

1932
01:13:24,000 --> 01:13:33,000
因为函数式编程每一个函数在就是在纯粹的一个函数式编程里面所有的函数都是所谓的确定性结果的嘛

1933
01:13:33,000 --> 01:13:35,000
这样的话不管你怎么去执行它

1934
01:13:35,000 --> 01:13:36,000
你总是得到一个确定性的解的

1935
01:13:36,000 --> 01:13:37,000
那我不管你

1936
01:13:37,000 --> 01:13:38,000
顺序执行

1937
01:13:38,000 --> 01:13:39,000
并发执行

1938
01:13:39,000 --> 01:13:40,000
还是怎么样

1939
01:13:40,000 --> 01:13:41,000
你一个什么一任意组合

1940
01:13:41,000 --> 01:13:42,000
我都不用管

1941
01:13:42,000 --> 01:13:44,000
我只能考虑这个函数是这么写的

1942
01:13:44,000 --> 01:13:47,000
我输入这个数得到这个结果

1943
01:13:47,000 --> 01:13:47,000
那就完了

1944
01:13:47,000 --> 01:13:49,000
就根本不存在并发并行

1945
01:13:49,000 --> 01:13:51,000
那些概念在里面

1946
01:13:51,000 --> 01:13:51,000
没错

1947
01:13:51,000 --> 01:14:07,000
我觉得可能 Functional Programming 所给我们最大的益处就在于之前我们讨论的现成枷锁所要解决的最基本问题就是有一个

1948
01:14:07,000 --> 01:14:08,000
变化的状态

1949
01:14:08,000 --> 01:14:12,000
被 Functional Programming 彻底抹去了

1950
01:14:12,000 --> 01:14:19,000
就是如果一切问题的输入乃至其中间状态全都是确定的话

1951
01:14:19,000 --> 01:14:23,000
那别人根本不可能改它

1952
01:14:23,000 --> 01:14:25,000
在我看来我也就不需要锁了

1953
01:14:25,000 --> 01:14:26,000
不是吗

1954
01:14:26,000 --> 01:14:27,000
对啊

1955
01:14:27,000 --> 01:14:37,000
所以这就是为什么 Functional Programming 为我们提供了这样一种从完全从不同角度去实现并行的机制

1956
01:14:37,000 --> 01:14:40,000
或者我们思考起来更方便的原因

1957
01:14:40,000 --> 01:14:40,000
对

1958
01:14:40,000 --> 01:14:42,000
就是说到一个最极端的例子

1959
01:14:42,000 --> 01:14:46,000
就是如果从先不考虑这个实现的这个经济性来讲

1960
01:14:46,000 --> 01:14:48,000
都是起码从逻辑上来讲

1961
01:14:48,000 --> 01:14:53,000
如果你整个语言是一个纯粹的 Functional 的一个一个就是纯粹是一个函数式的过程的话

1962
01:14:53,000 --> 01:14:57,000
每一步执行都是可以被并发执行的

1963
01:14:57,000 --> 01:15:01,000
就理论上说你每一步都可以分配到任意多个处理上去同时执行

1964
01:15:01,000 --> 01:15:02,000
然后得到一个解

1965
01:15:02,000 --> 01:15:05,000
然后再进行下一步的这个这个叫什么 Reduction

1966
01:15:05,000 --> 01:15:06,000
然后得到一个最终的解出来

1967
01:15:06,000 --> 01:15:07,000
嘛

1968
01:15:07,000 --> 01:15:07,000
对

1969
01:15:07,000 --> 01:15:09,000
对

1970
01:15:09,000 --> 01:15:11,000
然后这样一种模型

1971
01:15:11,000 --> 01:15:15,000
它所带来的便利是非常显著的

1972
01:15:15,000 --> 01:15:17,000
但是从另外一个角度讲

1973
01:15:17,000 --> 01:15:23,000
Functional Programming 写起来也是比较具有挑战性的

1974
01:15:23,000 --> 01:15:26,000
因为你只是

1975
01:15:26,000 --> 01:15:27,000
你不只是

1976
01:15:27,000 --> 01:15:31,000
但是当你没有 Global Changeable State 的时候

1977
01:15:31,000 --> 01:15:34,000
你就会需要用另外的方法去解决它

1978
01:15:36,000 --> 01:15:36,000
而

1979
01:15:36,000 --> 01:15:37,000
Functional Programming

1980
01:15:37,000 --> 01:15:45,000
可能会要求你比较痛苦的去转化你的思维模型

1981
01:15:45,000 --> 01:15:49,000
那有没有一个比较好的例子可以说明为什么

1982
01:15:49,000 --> 01:15:56,000
Functional Programming 可以比较有效的实现并发模型

1983
01:15:56,000 --> 01:16:01,000
我觉得可能最简单就是一个计算器的例子

1984
01:16:01,000 --> 01:16:03,000
就能够可能比较容易懂吧

1985
01:16:03,000 --> 01:16:07,000
就是我们计算一个常用的四则运算模型

1986
01:16:07,000 --> 01:16:07,000
就是我们计算一个常用的四则运算的时候

1987
01:16:07,000 --> 01:16:09,000
我们比如说

1988
01:16:09,000 --> 01:16:10,000
我举个最简单的例子

1989
01:16:10,000 --> 01:16:11,000
三乘以四

1990
01:16:11,000 --> 01:16:12,000
加五乘以六

1991
01:16:12,000 --> 01:16:14,000
这个公式

1992
01:16:14,000 --> 01:16:16,000
我们如果是人做会怎么样

1993
01:16:16,000 --> 01:16:18,000
那我们现在算三乘以四

1994
01:16:18,000 --> 01:16:19,000
十二

1995
01:16:19,000 --> 01:16:20,000
所以写在一边

1996
01:16:20,000 --> 01:16:23,000
然后再算五乘以六等于三十

1997
01:16:23,000 --> 01:16:23,000
写在一边

1998
01:16:23,000 --> 01:16:25,000
然后再两个求和加起来三十二

1999
01:16:25,000 --> 01:16:26,000
对吧

2000
01:16:26,000 --> 01:16:26,000
没错

2001
01:16:26,000 --> 01:16:30,000
但是如果是给机器来做的话

2002
01:16:30,000 --> 01:16:34,000
因为你整个四则运算中间的每一步都是确定性结果

2003
01:16:34,000 --> 01:16:36,000
因为确定性输入的确定性结果

2004
01:16:36,000 --> 01:16:37,000
这样的话

2005
01:16:37,000 --> 01:16:37,000
你会有一个确定性结果

2006
01:16:37,000 --> 01:16:39,000
那么它可以同时计算三乘以四和五乘以六

2007
01:16:39,000 --> 01:16:41,000
或者说它是甚至先计算五乘以六

2008
01:16:41,000 --> 01:16:42,000
再计算三乘以四

2009
01:16:42,000 --> 01:16:44,000
然后再去全之和

2010
01:16:44,000 --> 01:16:47,000
就是在这个过程中你可以看到

2011
01:16:47,000 --> 01:16:50,000
不管你的这个计算结果

2012
01:16:50,000 --> 01:16:54,000
并不会因为你计算的顺序有任何改变

2013
01:16:54,000 --> 01:16:57,000
而导致你的这个结果有任何变化

2014
01:16:57,000 --> 01:16:58,000
这个时候的话

2015
01:16:58,000 --> 01:17:01,000
那机器就可以做很多很多这样的优化

2016
01:17:01,000 --> 01:17:06,000
就可以把那些能够同时并行之性的东西都并行起来

2017
01:17:06,000 --> 01:17:06,000
对

2018
01:17:06,000 --> 01:17:07,000
加起来

2019
01:17:07,000 --> 01:17:08,000
假设你的这个算式

2020
01:17:08,000 --> 01:17:12,000
没有像三乘四加五乘六这么 trivial

2021
01:17:12,000 --> 01:17:16,000
而是一个比如说 200 位的数字

2022
01:17:16,000 --> 01:17:17,000
乘以 200 位的数字

2023
01:17:17,000 --> 01:17:19,000
然后这样的

2024
01:17:19,000 --> 01:17:24,000
然后要给比如说五六百个这样的结果求和

2025
01:17:24,000 --> 01:17:27,000
那这样的多任务

2026
01:17:27,000 --> 01:17:30,000
这样并发的模型就可以很好用

2027
01:17:30,000 --> 01:17:33,000
很好的用 functional program 的并行模型来解决

2028
01:17:33,000 --> 01:17:36,000
甚至我觉得其实也是一个很好的

2029
01:17:36,000 --> 01:17:40,000
就是 mappreduce 的解决

2030
01:17:40,000 --> 01:17:43,000
怎么说一个例子

2031
01:17:43,000 --> 01:17:45,000
如果你要像一个门外人

2032
01:17:45,000 --> 01:17:47,000
门外汉解释什么叫 mappreduce

2033
01:17:47,000 --> 01:17:51,000
当然门外汉为什么要对 mappreduce 成个兴趣是另外一个问题

2034
01:17:51,000 --> 01:17:53,000
但如果你要像一个人解释什么是 mappreduce

2035
01:17:53,000 --> 01:17:58,000
你就可以说让计算机去算三乘四加五乘六

2036
01:17:58,000 --> 01:18:03,000
map 这一步就是给让一个计算器算三乘四

2037
01:18:03,000 --> 01:18:05,000
然后让另外一个算五乘六

2038
01:18:05,000 --> 01:18:06,000
而 reduce 是把计算器算三乘四加五乘六

2039
01:18:06,000 --> 01:18:09,000
然后把三乘四的结果和五乘六的结果加在一起

2040
01:18:09,000 --> 01:18:12,000
没错没错

2041
01:18:12,000 --> 01:18:15,000
但是这个函数式编程

2042
01:18:15,000 --> 01:18:17,000
我怎么说有这么好的这么特性

2043
01:18:17,000 --> 01:18:19,000
但是他问题是在什么地方呢

2044
01:18:19,000 --> 01:18:24,000
问题在于现实世界的很多问题并不能简单

2045
01:18:24,000 --> 01:18:27,000
或者很方便的归结于一个函数式

2046
01:18:27,000 --> 01:18:32,000
一个就是非可变状态的一种一种场景来去解

2047
01:18:32,000 --> 01:18:35,000
比如说最简单的一个输出输出的时候

2048
01:18:35,000 --> 01:18:35,000
你就会牵涉到

2049
01:18:35,000 --> 01:18:37,000
跟外部世界的状态的沟通了

2050
01:18:37,000 --> 01:18:42,000
这个时候根据你的这个输入和的这个值不一样

2051
01:18:42,000 --> 01:18:44,000
你能可能某一些计算结果

2052
01:18:44,000 --> 01:18:47,000
就是如果还是一辆一脉外部输入的话

2053
01:18:47,000 --> 01:18:51,000
他就并不是一个你可以在单看这个程序本身可以预见的一个

2054
01:18:51,000 --> 01:18:53,000
与预见的一个解了吗

2055
01:18:53,000 --> 01:18:57,000
对比如说我们最常打的最常练习的一种

2056
01:18:59,000 --> 01:19:04,000
编程题目就是问操作者的名字

2057
01:19:04,000 --> 01:19:05,000
然后打出 hello

2058
01:19:05,000 --> 01:19:06,000
操作者的名字

2059
01:19:06,000 --> 01:19:08,000
这个就是没有办法用方式的服务

2060
01:19:08,000 --> 01:19:10,000
我没写出来就纯粹的方式

2061
01:19:10,000 --> 01:19:12,000
我朋友们是没有办法处理这种问题的

2062
01:19:12,000 --> 01:19:16,000
因为你总有一步要问操作者的名字到底是什么

2063
01:19:16,000 --> 01:19:22,000
如果如果他的名字就或者说在你获得他的名字之前

2064
01:19:22,000 --> 01:19:26,000
你是没有办法把输出他的名字这一步和问他的名字

2065
01:19:26,000 --> 01:19:28,000
这一步并行之行

2066
01:19:28,000 --> 01:19:32,000
还有一个还有一个方式呢

2067
01:19:32,000 --> 01:19:34,000
就不能很方便的

2068
01:19:34,000 --> 01:19:35,000
就不能归结于

2069
01:19:35,000 --> 01:19:36,000
纯粹的方式的方法

2070
01:19:36,000 --> 01:19:39,000
感觉就是随机数对吧

2071
01:19:39,000 --> 01:19:44,000
比如你要有你要一个函数的结果是你每次执行他的时候得到都是不确定的结果

2072
01:19:44,000 --> 01:19:47,000
这个时候他就并不是一个他甚至不是一个函数

2073
01:19:47,000 --> 01:19:51,000
因为我们讲还说他应该是一个确定确定的结果

2074
01:19:51,000 --> 01:19:52,000
就给定输入的时候

2075
01:19:52,000 --> 01:19:54,000
你应该有确定的结果

2076
01:19:54,000 --> 01:19:56,000
但是问你的这个结果是摇骰子

2077
01:19:56,000 --> 01:19:59,000
那你他本来就不是一个还甚至严格意义上

2078
01:19:59,000 --> 01:20:00,000
他并不是一个函数了

2079
01:20:00,000 --> 01:20:02,000
数学的数学概念的还说没错

2080
01:20:02,000 --> 01:20:05,000
其实这也就是数学世界和

2081
01:20:05,000 --> 01:20:08,000
统计学世界的一个根本分野

2082
01:20:08,000 --> 01:20:12,000
统计学世界所研究的世界是包含随机数发生源的

2083
01:20:12,000 --> 01:20:17,000
而数学世界数学世界所处理的问题是没有这种东西存在

2084
01:20:17,000 --> 01:20:18,000
OK

2085
01:20:18,000 --> 01:20:21,000
对那说完了

2086
01:20:21,000 --> 01:20:28,000
functional programming 解决并发模型的或者说 functional programming 作为并发模型之后

2087
01:20:28,000 --> 01:20:30,000
嗯

2088
01:20:30,000 --> 01:20:35,000
我们可以说说其他的比较不那么 radical 的

2089
01:20:35,000 --> 01:20:35,000
不那么

2090
01:20:35,000 --> 01:20:37,000
疯狂的主义

2091
01:20:37,000 --> 01:20:44,000
对不那么彻底革新人们的世界观的并发模型

2092
01:20:44,000 --> 01:20:44,000
OK

2093
01:20:44,000 --> 01:20:46,000
那对

2094
01:20:46,000 --> 01:20:52,000
所以我们刚才提到 Rob Pike 的那一篇那一个展示

2095
01:20:52,000 --> 01:20:54,000
就是他向人们介绍 Growthing 的那个展示

2096
01:20:54,000 --> 01:20:58,000
所以作为一个 Growthang 的传辅音者呢

2097
01:20:58,000 --> 01:21:02,000
Rio 你对 Growthang 的并发模型是怎么理解的

2098
01:21:02,000 --> 01:21:04,000
或者你可以简单的介绍一下

2099
01:21:04,000 --> 01:21:05,000
Growthang 里面是怎么解释的呢

2100
01:21:05,000 --> 01:21:07,000
怎么解决并发问题呢

2101
01:21:07,000 --> 01:21:07,000
OK

2102
01:21:07,000 --> 01:21:10,000
就 Growthang 里面他采用的并发模型其实是一个非常古老

2103
01:21:10,000 --> 01:21:15,000
而且被就是学术研究的很透彻的一种模型嘛

2104
01:21:15,000 --> 01:21:17,000
简单的来说就是叫做 CSP 嘛

2105
01:21:17,000 --> 01:21:19,000
就是 Communicating Sequential Processes

2106
01:21:19,000 --> 01:21:20,000
什么意思

2107
01:21:20,000 --> 01:21:21,000
就是说每一个

2108
01:21:21,000 --> 01:21:23,000
他们叫 process

2109
01:21:23,000 --> 01:21:24,000
这里是进程

2110
01:21:24,000 --> 01:21:27,000
当然可能包括物理上是一个超线的进程也好

2111
01:21:27,000 --> 01:21:28,000
还是这个

2112
01:21:28,000 --> 01:21:29,000
呃

2113
01:21:29,000 --> 01:21:29,000
线程

2114
01:21:29,000 --> 01:21:31,000
他这个没有关系

2115
01:21:31,000 --> 01:21:33,000
这种 process 是一个逻辑的概念

2116
01:21:33,000 --> 01:21:35,000
就是它是一个线性执行的一个单元嘛

2117
01:21:35,000 --> 01:21:37,000
然后他说什么意思呢

2118
01:21:37,000 --> 01:21:39,000
就说每一个就刚刚讲了吗

2119
01:21:39,000 --> 01:21:41,000
每一个呃

2120
01:21:41,000 --> 01:21:44,000
每一个进程都是单独自己自己管自己的事情

2121
01:21:44,000 --> 01:21:47,000
他只是在需要跟其他进程交互的时候

2122
01:21:47,000 --> 01:21:52,000
才通过消息传递的方式来做这么一件呃事

2123
01:21:52,000 --> 01:21:55,000
就等别人发消息给他或者发消息给别人

2124
01:21:55,000 --> 01:21:57,000
然后就就有一个叫做 synchronization point

2125
01:21:57,000 --> 01:21:58,000
在那个点之后

2126
01:21:58,000 --> 01:22:00,000
然后他完成了这步之后

2127
01:22:00,000 --> 01:22:04,000
他又再回到自己的一个一个比较线性的呃执行呃

2128
01:22:04,000 --> 01:22:07,000
执行呃方式去做下去

2129
01:22:07,000 --> 01:22:10,000
这个是一个比较可能简单的解释吧

2130
01:22:10,000 --> 01:22:13,000
那所以这个 synchronize point 跟锁的差别是什么

2131
01:22:14,000 --> 01:22:15,000
呃

2132
01:22:15,000 --> 01:22:17,000
他本质上就是一个锁

2133
01:22:17,000 --> 01:22:21,000
只是说在在逻辑的这个就在抽象的方式或者抽象的角度上

2134
01:22:21,000 --> 01:22:23,000
他是他是有点不太一样

2135
01:22:23,000 --> 01:22:24,000
他并不是说啊

2136
01:22:24,000 --> 01:22:28,000
我们两个进程要共享一个呃

2137
01:22:28,000 --> 01:22:30,000
资源一个共享一个对共享一个 state 了

2138
01:22:30,000 --> 01:22:32,000
所以我们先把它锁住

2139
01:22:32,000 --> 01:22:33,000
然后我们想啊

2140
01:22:33,000 --> 01:22:34,000
谁先解

2141
01:22:34,000 --> 01:22:34,000
就是谁

2142
01:22:34,000 --> 01:22:35,000
先到达那个锁点的时候

2143
01:22:35,000 --> 01:22:38,000
先等一下他等另外一个人到达那个锁点

2144
01:22:38,000 --> 01:22:39,000
然后再把那个锁解开

2145
01:22:39,000 --> 01:22:41,000
然后我们呃再把那个资源改变

2146
01:22:41,000 --> 01:22:43,000
然后再把这个锁解开

2147
01:22:43,000 --> 01:22:47,000
然后那个被锁住的人才可以接的进行下去吗

2148
01:22:47,000 --> 01:22:48,000
他这样的话

2149
01:22:48,000 --> 01:22:49,000
这就有你要去想啊

2150
01:22:49,000 --> 01:22:51,000
是哪个资源是需要被锁定的

2151
01:22:51,000 --> 01:22:53,000
这就挺麻烦吗

2152
01:22:53,000 --> 01:22:55,000
然后他这个 csp 的话

2153
01:22:55,000 --> 01:22:57,000
他就说那我们不要去考虑这个锁的问题了

2154
01:22:57,000 --> 01:23:01,000
我默认我们要互相通讯的时候就是有一个隐含的锁

2155
01:23:01,000 --> 01:23:03,000
那个锁的的锁的内容就是我要传递的这个锁的内容啊

2156
01:23:03,000 --> 01:23:03,000
就是我要传递的这个锁的内容啊

2157
01:23:03,000 --> 01:23:05,000
就是我要传递的这个锁的内容啊

2158
01:23:05,000 --> 01:23:05,000
对不对

2159
01:23:05,000 --> 01:23:09,000
然后对方取得了这个消息之后

2160
01:23:09,000 --> 01:23:10,000
那我们这个锁就解开了

2161
01:23:10,000 --> 01:23:11,000
那我可以继续往下走下去

2162
01:23:11,000 --> 01:23:14,000
就所以他他本质上是一个锁了

2163
01:23:14,000 --> 01:23:17,000
但是只是说他的抽象的层级是不一样的

2164
01:23:17,000 --> 01:23:19,000
或者说抽象的出发点是不一样的

2165
01:23:19,000 --> 01:23:19,000
这样的话

2166
01:23:19,000 --> 01:23:22,000
对人们或者这个程序员来理解起来

2167
01:23:22,000 --> 01:23:24,000
他来说是更加现实一点的

2168
01:23:24,000 --> 01:23:26,000
呃更加现实的一个抽象吧

2169
01:23:26,000 --> 01:23:27,000
没错

2170
01:23:27,000 --> 01:23:32,000
其实呃我听过一个比喻就是传统的现成于所

2171
01:23:32,000 --> 01:23:33,000
有点像储物厢

2172
01:23:33,000 --> 01:23:34,000
呃

2173
01:23:34,000 --> 01:23:37,000
你要去买东西

2174
01:23:37,000 --> 01:23:38,000
然后你要先把自己的

2175
01:23:38,000 --> 01:23:42,000
你在进商场之前需要把自己的东西锁了一个储物柜里

2176
01:23:42,000 --> 01:23:45,000
显示的锁其实就是正儿八经的锁

2177
01:23:45,000 --> 01:23:47,000
当你把一个储物箱锁起来的时候

2178
01:23:47,000 --> 01:23:48,000
别人就不能再用了

2179
01:23:48,000 --> 01:23:52,000
而呃这样一种 csp 的模型

2180
01:23:52,000 --> 01:23:56,000
则是有一个专门的储物管理员

2181
01:23:56,000 --> 01:23:58,000
你只需要把你的东西给他说

2182
01:23:58,000 --> 01:23:59,000
我要把这个存起来

2183
01:23:59,000 --> 01:24:00,000
然后我去别的地方

2184
01:24:00,000 --> 01:24:03,000
他也许在背后有一另外一个储物厢

2185
01:24:03,000 --> 01:24:07,000
但是你不会去直接这个细节

2186
01:24:07,000 --> 01:24:12,000
你不用去直接关心这个你的东西到底锁在哪个箱子里了

2187
01:24:12,000 --> 01:24:15,000
以及你是不是和别人共享的同样一个储物箱

2188
01:24:15,000 --> 01:24:16,000
这样的这类问题

2189
01:24:16,000 --> 01:24:18,000
你只需要告诉他说我要存东西

2190
01:24:18,000 --> 01:24:18,000
然后我走了

2191
01:24:18,000 --> 01:24:20,000
然后等我回来的时候我要拿东西

2192
01:24:20,000 --> 01:24:21,000
就是这么简单

2193
01:24:21,000 --> 01:24:23,000
这个这个比喻很很好

2194
01:24:23,000 --> 01:24:24,000
就你回来拿的时候

2195
01:24:24,000 --> 01:24:25,000
你就说我要拿我之前

2196
01:24:25,000 --> 01:24:28,000
那我或者说你甚至不一定是你本人去拿

2197
01:24:28,000 --> 01:24:31,000
比如说你的老婆帮你去去拿你的包

2198
01:24:31,000 --> 01:24:32,000
呃但是他有那个什么盘吗

2199
01:24:32,000 --> 01:24:33,000
对吧

2200
01:24:33,000 --> 01:24:36,000
他就说哎我要拿这个几号的那个那个包

2201
01:24:36,000 --> 01:24:38,000
让那个那个柜台那个小姐就去帮你拿出来

2202
01:24:38,000 --> 01:24:42,000
让你去等你你中间并不需要去关心他后面多少个锁格

2203
01:24:42,000 --> 01:24:43,000
对吧

2204
01:24:43,000 --> 01:24:46,000
他们的锁是一个拉锁呢

2205
01:24:46,000 --> 01:24:47,000
还是一个防刀保险柜呢

2206
01:24:47,000 --> 01:24:49,000
还是一个什么样的东西实现对

2207
01:24:49,000 --> 01:24:50,000
嗯

2208
01:24:50,000 --> 01:24:54,000
所以这样一种编程模型也是目前比较嗯

2209
01:24:55,000 --> 01:24:56,000
比较流行的一种模型吧

2210
01:24:56,000 --> 01:25:01,000
我觉得就是在很多人都支持他就够有够够

2211
01:25:01,000 --> 01:25:02,000
而且是在语言层面上

2212
01:25:02,000 --> 01:25:03,000
是直接支持他的

2213
01:25:03,000 --> 01:25:06,000
而其他很多语言也都是通过一个来过

2214
01:25:06,000 --> 01:25:10,000
也或者是其他什么机制一个一个主要是通过来过

2215
01:25:10,000 --> 01:25:12,000
好像只有两种可能吧

2216
01:25:12,000 --> 01:25:14,000
你要么在执行你要么在原理直接执行呢

2217
01:25:14,000 --> 01:25:18,000
对要么通过一个这里要可能要介绍一下

2218
01:25:18,000 --> 01:25:21,000
就除了刚才讲的那个 csp 模型之外

2219
01:25:21,000 --> 01:25:25,000
有一个与他形成叫做队友关系的一个模型

2220
01:25:25,000 --> 01:25:27,000
叫做 actor model

2221
01:25:27,000 --> 01:25:29,000
这个 after 我不知道这个中文怎么翻译好

2222
01:25:29,000 --> 01:25:31,000
叫做呃

2223
01:25:31,000 --> 01:25:31,000
嗯

2224
01:25:31,000 --> 01:25:31,000
嗯

2225
01:25:31,000 --> 01:25:31,000
嗯

2226
01:25:31,000 --> 01:25:31,000
嗯

2227
01:25:31,000 --> 01:25:31,000
嗯

2228
01:25:31,000 --> 01:25:31,000
嗯

2229
01:25:31,000 --> 01:25:31,000
嗯

2230
01:25:31,000 --> 01:25:31,000
嗯

2231
01:25:31,000 --> 01:25:32,000
嗯

2232
01:25:32,000 --> 01:25:32,000
嗯

2233
01:25:32,000 --> 01:25:32,000
嗯

2234
01:25:32,000 --> 01:25:32,000
嗯

2235
01:25:32,000 --> 01:25:32,000
嗯

2236
01:25:32,000 --> 01:25:32,000
嗯

2237
01:25:32,000 --> 01:25:32,000
嗯

2238
01:25:32,000 --> 01:25:32,000
嗯

2239
01:25:32,000 --> 01:25:32,000
嗯

2240
01:25:32,000 --> 01:25:33,000
,

2241
01:25:33,000 --> 01:25:33,000
嗯,

2242
01:25:33,000 --> 01:25:33,000
嗯,

2243
01:25:33,000 --> 01:25:33,000
嗯,

2244
01:25:33,000 --> 01:25:33,000
嗯,

2245
01:25:33,000 --> 01:25:33,000
嗯,

2246
01:25:33,000 --> 01:25:33,000
嗯,

2247
01:25:33,000 --> 01:25:33,000
嗯,

2248
01:25:33,000 --> 01:25:33,000
也不对吧

2249
01:25:33,000 --> 01:25:49,000
就是简单的讲就说你在 csp 的时候有一种经典的方式是说我们两个之间实现一个所谓的这个呃 channel 一个一个渠道我们通过这个渠道来发送这个消息对吧

2250
01:25:49,000 --> 01:25:49,000
嗯

2251
01:25:49,000 --> 01:25:57,000
就是这个渠道就是我要发消息的时候我要我是先把这个消息呃通过这个渠道传传送给你如果你那边没有

2252
01:25:57,000 --> 01:26:00,000
没有还没有来接收这个渠道

2253
01:26:00,000 --> 01:26:01,000
我得我发消息

2254
01:26:01,000 --> 01:26:02,000
这个人还在那边等着你

2255
01:26:02,000 --> 01:26:04,000
接收之后才可以了

2256
01:26:04,000 --> 01:26:05,000
才可以走

2257
01:26:06,000 --> 01:26:07,000
大概明白我这个意思吗

2258
01:26:07,000 --> 01:26:08,000
是

2259
01:26:08,000 --> 01:26:09,000
嗯

2260
01:26:10,000 --> 01:26:11,000
所以

2261
01:26:11,000 --> 01:26:12,000
actor

2262
01:26:12,000 --> 01:26:16,000
比如说支持 actor 的语言像 alan 或者是嗯

2263
01:26:16,000 --> 01:26:18,000
scala 也是一个 scala 支持那个叫什么

2264
01:26:18,000 --> 01:26:21,000
这不够 scala 是通过阿卡支持的

2265
01:26:21,000 --> 01:26:21,000
嗯

2266
01:26:21,000 --> 01:26:23,000
刚刚没有原生的 actor

2267
01:26:23,000 --> 01:26:25,000
他有他原生是啊

2268
01:26:25,000 --> 01:26:30,000
他的他也可以通过 jvm 走啊看啊看那个那个 library 来实现 actor model

2269
01:26:30,000 --> 01:26:31,000
ok

2270
01:26:31,000 --> 01:26:31,000
嗯

2271
01:26:31,000 --> 01:26:32,000
然后

2273
01:27:02,000 --> 01:27:03,000
那消息来的时候呢

2274
01:27:03,000 --> 01:27:07,000
并不直接被这个这个 actor 拿去

2275
01:27:07,000 --> 01:27:09,000
而是说先 c 进这个邮箱里面

2276
01:27:09,000 --> 01:27:13,000
然后等这个 actor 处理他执行到一个一个条件

2277
01:27:13,000 --> 01:27:15,000
然后他说哎我需要收一个邮件

2278
01:27:15,000 --> 01:27:19,000
然后他再去看自己的邮箱说哎有没有别人给我发过来的消息

2279
01:27:19,000 --> 01:27:20,000
我看一下处理一遍

2280
01:27:20,000 --> 01:27:22,000
如果没有的话我再接着做自己的事情

2281
01:27:23,000 --> 01:27:29,000
所以 csp 和 actor model 是两个呃本质上做的同样的事情

2282
01:27:29,000 --> 01:27:33,000
只是说他们在在实现方式上是有一点所谓的队友关系的在里面

2283
01:27:34,000 --> 01:27:35,000
ok

2284
01:27:35,000 --> 01:27:36,000
嗯

2285
01:27:36,000 --> 01:27:39,000
呃在在现实中其实 go 的话

2286
01:27:40,000 --> 01:27:42,000
比较他并不是一个纯粹的 csp 的模型

2287
01:27:42,000 --> 01:27:44,000
因为他的那个 channel 刚讲了吗

2288
01:27:44,000 --> 01:27:47,000
那我他并不是一个完全是主塞的 channel

2289
01:27:47,000 --> 01:27:49,000
因为他的 channel 是可以被 buffer 的

2290
01:27:49,000 --> 01:27:53,000
对其实我就刚才想说 go 的 channel 难道不也是一个邮箱吗

2291
01:27:53,000 --> 01:27:54,000
就他也是一个 q 啊

2292
01:27:55,000 --> 01:27:58,000
对所以这个就是有一个有一个他的他不是一个纯粹的 csp 的模型啊

2293
01:27:58,000 --> 01:28:00,000
就是他就是一个纯粹的 csp 的这一点

2294
01:28:00,000 --> 01:28:01,000
就是因为说他那个 channel

2295
01:28:02,000 --> 01:28:05,000
他他鼓励你使用一个叫做这 blocking channel

2296
01:28:05,000 --> 01:28:06,000
就一次只能发一条消息

2297
01:28:06,000 --> 01:28:09,000
然后你必须要等对方取出这个消息之后

2298
01:28:09,000 --> 01:28:11,000
你这些发送方才能接着执行下一个

2299
01:28:11,000 --> 01:28:14,000
对这就是一种比较纯粹的 csp 的状态

2300
01:28:14,000 --> 01:28:17,000
但是对如果你不用主塞式的 channel 的话

2301
01:28:17,000 --> 01:28:20,000
其实 go somehow 也是用到了 actor

2302
01:28:20,000 --> 01:28:23,000
没错就是他 go 的话其实也是有一个

2303
01:28:23,000 --> 01:28:26,000
因为他的他的 channel 有一个呃扩展

2304
01:28:26,000 --> 01:28:28,000
就是说他那个 channel 是可以有一个 buffer 的

2305
01:28:28,000 --> 01:28:29,000
就是一个缓冲区域的

2306
01:28:29,000 --> 01:28:33,000
比如说我可以声明这个 channel 有一个 100 个位置的缓冲区域

2307
01:28:33,000 --> 01:28:34,000
什么意思呢

2308
01:28:34,000 --> 01:28:37,000
我可以往这个 channel 里面塞

2309
01:28:38,000 --> 01:28:40,000
99 条消息都不足塞

2310
01:28:40,000 --> 01:28:43,000
直到我塞第 100 条消息的时候啊

2311
01:28:43,000 --> 01:28:45,000
不对我可以往那个我那样塞 100 条消息都不足塞

2312
01:28:45,000 --> 01:28:47,000
但我往里面塞第 101 条消息的时候

2313
01:28:47,000 --> 01:28:51,000
我得等那头那个人就是接收方

2314
01:28:51,000 --> 01:28:54,000
挪出一条消息之后我才能够再往里面塞进去

2315
01:28:54,000 --> 01:28:56,000
就是说开始有一个这么一个 buffer 的这么一个 gap

2316
01:28:56,000 --> 01:29:00,000
这个时候的话这种 channel 就比较类似于 actor model 里面的

2317
01:29:00,000 --> 01:29:04,000
这个叫什么啊啊 mailbox 信箱的概念了

2318
01:29:04,000 --> 01:29:09,000
但是他没有那么就灵活度和这个呃自由程度还是不一样的

2319
01:29:09,000 --> 01:29:11,000
比如说 actor model 里面

2320
01:29:11,000 --> 01:29:13,000
你就如果你有信箱的概念的话

2321
01:29:13,000 --> 01:29:15,000
你的必然的推论就是每一个 actor

2322
01:29:15,000 --> 01:29:19,000
他是有一个唯一的确定的那个识别符的一个 id 对吧

2323
01:29:19,000 --> 01:29:23,000
你才知道你这个你这个消息是要发从从哪里来发给谁对吧

2324
01:29:23,000 --> 01:29:25,000
你得有这么这么一个过程

2325
01:29:25,000 --> 01:29:26,000
但是在 go 里面呢

2326
01:29:26,000 --> 01:29:30,000
的话因为你可以每一个 pro 每一个进程是可以建立多个 channel 的嘛

2327
01:29:30,000 --> 01:29:33,000
所以他的这个对应关系是不太一样的

2328
01:29:33,000 --> 01:29:36,000
但本质上他们是其实同一件事情

2329
01:29:36,000 --> 01:29:44,000
所以我们可以说 actor 模型天生就比较适合分布式计算的领域

2330
01:29:44,000 --> 01:29:49,000
因为分当你把你的计算模型采用分布式的方式来实现的时候

2331
01:29:49,000 --> 01:29:55,000
那每一个分布式的呃单元都会天生的带有一个啊

2332
01:29:55,000 --> 01:29:57,000
标识符

2333
01:29:57,000 --> 01:29:58,000
然后在这种状况下

2334
01:29:58,000 --> 01:30:04,000
你用 actor 模型的时候就非常容易的把你的抽象层级啊连在一起了

2335
01:30:04,000 --> 01:30:05,000
嗯

2336
01:30:05,000 --> 01:30:07,000
但是如果用 go routine 的 channel 的话

2337
01:30:07,000 --> 01:30:13,000
那可能应用在分布式分布计算的时候没有那么没有那么自然

2338
01:30:13,000 --> 01:30:14,000
嗯

2339
01:30:14,000 --> 01:30:15,000
其实没有其实没有关系

2340
01:30:15,000 --> 01:30:24,000
这两个是可以完全互相就是可以啊不损失任何啊抽象层级的互相转化的比如说最简单一个转化的道理就是说

2341
01:30:24,000 --> 01:30:25,000
嗯

2342
01:30:25,000 --> 01:30:35,000
那我每我怎么在呃用 channel 实现这个 actor model 呃很简单一个道理就是说我每一个 process 我自建我在建那个 process 的时候

2343
01:30:35,000 --> 01:30:40,000
我给他一个参数就是一个 channel 这个 channel 我就让我把它命名为一个叫做命名为邮箱

2344
01:30:40,000 --> 01:30:43,000
然后这个这个因为 channel 是有 id 的嘛

2345
01:30:43,000 --> 01:30:51,000
这样的话我就可以认为具备这个 channel 读写的功能的那个那个进程就是这个 actor 本身

2346
01:30:52,000 --> 01:30:53,000
对我的意思就是

2347
01:30:53,000 --> 01:30:54,000
你在这样一段时间里面

2348
01:30:54,000 --> 01:30:56,000
你在这样一种解决方案的

2349
01:30:56,000 --> 01:30:58,000
你在实施这样一种解决方案的时候

2350
01:30:58,000 --> 01:31:00,000
你实际上是采用了 actor 模型

2351
01:31:00,000 --> 01:31:03,000
你只不过是在用 channel 的方式去模拟它而已

2352
01:31:03,000 --> 01:31:14,000
而呃我们就不要去考虑这个使用使用一种语言的机制去模拟 actor 模型和真正的使用 actor 模型之间的差别在哪

2353
01:31:14,000 --> 01:31:15,000
嗯

2354
01:31:15,000 --> 01:31:17,000
我的意思是当你使用另外一种语言

2355
01:31:17,000 --> 01:31:21,000
当你使用 golang 的 feature 去模拟 actor 模型的时候

2356
01:31:21,000 --> 01:31:24,000
其实也就意味着 actor 模型是比较实用的

2357
01:31:24,000 --> 01:31:29,000
适合在这样一种呃问题领域里面实施并发的模型

2358
01:31:29,000 --> 01:31:30,000
不是吗

2359
01:31:30,000 --> 01:31:31,000
嗯

2360
01:31:31,000 --> 01:31:34,000
我不太清楚

2361
01:31:34,000 --> 01:31:41,000
就我觉得不一定就是有些有些时候是用 channel 模型是更合适的

2362
01:31:41,000 --> 01:31:43,000
有些时候是用那个 actor 模型是更合适的

2363
01:31:43,000 --> 01:31:45,000
所以你怎么去选择它

2364
01:31:45,000 --> 01:31:46,000
我觉得还是要看你问题的

2365
01:31:46,000 --> 01:31:49,000
就你手上具体的问题的这个啊

2366
01:31:49,000 --> 01:31:51,000
本身的属性来决定的

2367
01:31:51,000 --> 01:31:52,000
就不一不

2368
01:31:52,000 --> 01:31:53,000
并不是说 actor 模型是更合适的

2369
01:31:53,000 --> 01:32:01,000
就是说 actor 模型就一定天然比这种 csp 的模型要来的呃更直观或者是更易懂

2370
01:32:01,000 --> 01:32:02,000
这样

2371
01:32:02,000 --> 01:32:03,000
好吧

2372
01:32:03,000 --> 01:32:08,000
那大概

2373
01:32:08,000 --> 01:32:17,000
我想想我们介绍了传统的现成文语所介绍了 fp 介绍了 csp 和 actor

2374
01:32:17,000 --> 01:32:22,000
那基本上我们可以说已经涵盖了比较主流的

2375
01:32:22,000 --> 01:32:23,000
主流的这种

2376
01:32:23,000 --> 01:32:24,000
这种并发模型

2377
01:32:24,000 --> 01:32:28,000
对当然嗯还有一些其他的并发模型

2378
01:32:28,000 --> 01:32:30,000
比如说有本书叫呃

2379
01:32:30,000 --> 01:32:33,000
叫说 seven

2380
01:32:33,000 --> 01:32:36,000
paralism in seven weeks

2381
01:32:36,000 --> 01:32:39,000
七周七种并发模型

2382
01:32:39,000 --> 01:32:41,000
就他那本书里面已经介绍了七种

2383
01:32:41,000 --> 01:32:44,000
但是我们今天只说了四种

2384
01:32:44,000 --> 01:32:46,000
但是如果我印象没错的话

2385
01:32:46,000 --> 01:32:52,000
那他提到了其他三种其实都是怎么说要不是我们提到的这呃四种比较呃

2386
01:32:52,000 --> 01:32:55,000
四种比较基本的并发模型的混合

2387
01:32:55,000 --> 01:32:56,000
嗯

2388
01:32:56,000 --> 01:32:57,000
嗯

2389
01:32:57,000 --> 01:32:59,000
或者就是在更大规模上的抽象

2390
01:32:59,000 --> 01:33:02,000
但是我不是不是印象不是很深了

2391
01:33:02,000 --> 01:33:14,000
但是我推荐如果有如果对这个问题比较感兴趣的听众们可以去看看这本书就是他是另外一本叫做呃 sevenlanguagein sevenweeks 的姐妹书另外一本书也很好

2392
01:33:14,000 --> 01:33:15,000
嗯

2393
01:33:15,000 --> 01:33:16,000
ok

2394
01:33:16,000 --> 01:33:21,000
然后我们要就要过渡到下一个相关但并不

2395
01:33:21,000 --> 01:33:24,000
同并不等同的话题了

2396
01:33:24,000 --> 01:33:27,000
就是所应该说是在抽象层级上并不等同

2397
01:33:27,000 --> 01:33:28,000
对

2398
01:33:28,000 --> 01:33:30,000
但是他有点相关的

2399
01:33:30,000 --> 01:33:31,000
没错

2400
01:33:31,000 --> 01:33:37,000
就是所谓的这个异步和这个非阻塞式的一个程序设计程序语言的设计吧

2401
01:33:37,000 --> 01:33:38,000
没错

2402
01:33:38,000 --> 01:33:46,000
就当刚刚才刚才我们提到了在呃方式到 programming 难以非常难以解决的一个问题就是当你要处理 io 的时候你怎么办吧

2403
01:33:46,000 --> 01:33:47,000
嗯

2404
01:33:47,000 --> 01:33:49,000
就当你需要问

2405
01:33:49,000 --> 01:33:51,000
那个使用者的姓名的时候

2406
01:33:51,000 --> 01:33:56,000
你你你使用多个呃当你有多

2407
01:33:56,000 --> 01:33:58,000
当你有一种并行机制

2408
01:33:58,000 --> 01:34:02,000
并且你需要解决询问使用者姓名这个问题的时候

2409
01:34:02,000 --> 01:34:04,000
你到底应该怎么办

2410
01:34:04,000 --> 01:34:06,000
这就是我们接下来需要讨论讨论的问题

2411
01:34:06,000 --> 01:34:10,000
就是一步 io 最恰当的抽象到底是什么

2412
01:34:10,000 --> 01:34:11,000
嗯

2413
01:34:11,000 --> 01:34:14,000
呃我们传统上不叫传统上吧

2414
01:34:14,000 --> 01:34:18,000
就可能目前用的可能大家听的最熟悉的就是一个叫做 syncronus

2415
01:34:18,000 --> 01:34:20,000
就是一步 io 这么一个作用

2416
01:34:20,000 --> 01:34:23,000
这个主要存在于像什么 node 啊

2417
01:34:23,000 --> 01:34:31,000
这种一些呃就加了反正是你你要反反正设计 javascript 的话基本上都是走走走这种啊 syncio 的方式吗

2418
01:34:31,000 --> 01:34:36,000
对然后 python 的话有这个像 tornado 啊还是之前那个叫什么 twisted

2419
01:34:36,000 --> 01:34:38,000
对啊对都是这种方式

2420
01:34:38,000 --> 01:34:40,000
然后 ruby 里面是有什么

2421
01:34:40,000 --> 01:34:41,000
ruby

2422
01:34:41,000 --> 01:34:44,000
我还真的不知道就 node

2423
01:34:44,000 --> 01:34:49,000
它比如说它底层也是用的像 c 的那个叫 lib uv 来实现它的这个一步 i 的方式啊

2424
01:34:49,000 --> 01:35:06,000
对我记得 neo vim 它重要非常重要的那个 to do 之一就是要把所有的呃 vi 的那个编辑器人的 event 都转到的 vim 的编辑器人的 event 都转到 lib uv 上实现

2425
01:35:06,000 --> 01:35:15,000
啊对很多人现在有很多这种采用那个呃一步 io 的这种大型程序都在改到用这个包来实现了吗

2426
01:35:15,000 --> 01:35:17,000
因为它确实写的很好

2427
01:35:17,000 --> 01:35:19,000
什么跨平台你也都做的挺不错的

2428
01:35:19,000 --> 01:35:28,000
然后 java 的话有那个叫做 nio 就是新 io 的那么一个库也可以做这种一步的 io 的机制了

2429
01:35:28,000 --> 01:35:29,000
嗯嗯嗯

2430
01:35:29,000 --> 01:35:30,000
现在还有什么其他的主流语言呢

2431
01:35:30,000 --> 01:35:31,000
好像也差不多了

2432
01:35:31,000 --> 01:35:33,000
对

2433
01:35:33,000 --> 01:35:34,000
ok

2434
01:35:34,000 --> 01:35:38,000
然后就是力步 io 到底是做了一件什么样的事情呢

2435
01:35:38,000 --> 01:35:46,000
就是他们都是在一个很就是他们都是在一个单进程的情况下去模拟或者说这么说吧

2436
01:35:46,000 --> 01:35:47,000
他们都是在一个

2437
01:35:47,000 --> 01:35:49,000
单进程的情况下

2438
01:35:49,000 --> 01:35:51,000
去做一些并发的事情

2439
01:35:51,000 --> 01:35:53,000
对他们试图用

2440
01:35:53,000 --> 01:35:57,000
其实就是一个非常简单的呃

2441
01:35:57,000 --> 01:36:01,000
例子就是我先做一件事情

2442
01:36:01,000 --> 01:36:05,000
然后在这件事情跑了间隙之中去做另外一件事情

2443
01:36:05,000 --> 01:36:08,000
比如说回到我们刚才那个做饭的例子

2444
01:36:08,000 --> 01:36:10,000
我我先把锅做在火上

2445
01:36:10,000 --> 01:36:11,000
然后开始烧水

2446
01:36:11,000 --> 01:36:13,000
然后在烧水的间隙里面

2447
01:36:13,000 --> 01:36:14,000
我开始切菜

2448
01:36:14,000 --> 01:36:16,000
然后等到水烧开了

2449
01:36:16,000 --> 01:36:17,000
我看到水在滚

2450
01:36:17,000 --> 01:36:18,000
然后我再去管烧水的事情

2451
01:36:18,000 --> 01:36:24,000
其实就是一个非常力步 io 其实就是这样一个非常简单的问题

2452
01:36:24,000 --> 01:36:31,000
只不过他具体实现起来会比做菜这个这个这个这么简单的一个任务要复杂很多

2453
01:36:31,000 --> 01:36:33,000
对就为什么说哎

2454
01:36:33,000 --> 01:36:37,000
还有一个问题就是说为什么每次提到一步的时候都一定是指 io 呢

2455
01:36:37,000 --> 01:36:39,000
因为这个是牵涉到计算机

2456
01:36:39,000 --> 01:36:43,000
这个之前我们某一期讲过计算机体系结构的一个问题

2457
01:36:43,000 --> 01:36:47,000
就是说在所有的这个这个计算机这个应用里面

2458
01:36:47,000 --> 01:36:49,000
你只要涉及到 io 的时候

2459
01:36:49,000 --> 01:36:56,000
这个 cpu 都是远远高于就是他的处理速度是远远高于你这个就是输入输出的速度的

2460
01:36:56,000 --> 01:37:00,000
这样的话一个 b 的那结果就是说如果你只要一旦设计 io 的操作

2461
01:37:00,000 --> 01:37:02,000
你的 cpu 就要闲置起来等

2462
01:37:02,000 --> 01:37:09,000
那么一步 io 的他们一个一个切入点就是说那我们就不要等那个 io 的响应结果回来

2463
01:37:09,000 --> 01:37:13,000
那个一直等他傻等反正也没没事做嘛

2464
01:37:13,000 --> 01:37:16,000
我们在他的结果返回来之前

2465
01:37:16,000 --> 01:37:17,000
我们先做点别的事

2466
01:37:17,000 --> 01:37:19,000
然后等那边结果返回来之后

2467
01:37:19,000 --> 01:37:24,000
你再通知我再回来把这件事情接着再捡起来接着做下去

2468
01:37:24,000 --> 01:37:25,000
没错

2469
01:37:25,000 --> 01:37:26,000
嗯

2470
01:37:26,000 --> 01:37:32,000
但是一步 io 有一个问题就是很有可能你协调不好

2471
01:37:32,000 --> 01:37:36,000
呃对就还是用做饭的例子来说

2472
01:37:36,000 --> 01:37:40,000
就是可能你想起来你想当然会觉得啊烧水的时候我切菜

2473
01:37:40,000 --> 01:37:44,000
但是你没有办法保证在水烧开之前你一定能把菜选好

2474
01:37:44,000 --> 01:37:45,000
就是嗯

2475
01:37:45,000 --> 01:37:46,000
我相信每一个喜欢做的菜的朋友都会有这个想法啊

2476
01:37:46,000 --> 01:37:49,000
做饭的人都会有这样的窘境或者说什么

2477
01:37:49,000 --> 01:37:52,000
就是就是同时有很多事情要你去

2478
01:37:52,000 --> 01:37:53,000
让你去处理

2479
01:37:53,000 --> 01:38:00,000
甚至我记得新干店英语里面好有一有一期课文就是这个就是说一个主妇在活面

2480
01:38:00,000 --> 01:38:02,000
然后电话响了

2481
01:38:02,000 --> 01:38:05,000
同时呃又有人在敲门

2482
01:38:05,000 --> 01:38:06,000
嗯

2483
01:38:06,000 --> 01:38:11,000
与此同时再加上如果锅开了那在这种情况下你该怎么办吧

2484
01:38:11,000 --> 01:38:16,000
那其实一波一步的 io 呃机器或者说机器回调的一步 io

2485
01:38:16,000 --> 01:38:18,000
呃就是这样一个与生俱来的问题

2486
01:38:18,000 --> 01:38:26,000
你你你你你很难去去理解或者说很难事先判定所有事情的呃发生的先后顺序

2487
01:38:26,000 --> 01:38:33,000
然后因为你你你作为一个程序员你你只能用线性的方式去写代码

2488
01:38:33,000 --> 01:38:40,000
所以你线性的代码是很难处理这样呃一个不知道先后因果顺序的问题

2489
01:38:40,000 --> 01:38:49,000
对就是这里面有一个通常有个词汇来描述呃这个采用一步的程序结构叫做控制流导致吗

2490
01:38:49,000 --> 01:38:51,000
inversal control flow

2491
01:38:51,000 --> 01:38:52,000
ok

2492
01:38:52,000 --> 01:38:56,000
就说就说我们通常写代码的时候都我们也说呃先怎么怎么样后怎么怎么样

2493
01:38:56,000 --> 01:38:59,000
它是一个线性的前因后果的关系走下来的对吧

2494
01:38:59,000 --> 01:39:08,000
但是如果你采用这种一步爱我这种回调方式来做的话就会发现哎呃我这个这个消息过来了

2495
01:39:08,000 --> 01:39:09,000
我这个时候该干嘛呢

2496
01:39:09,000 --> 01:39:10,000
你得去找

2497
01:39:10,000 --> 01:39:12,000
找半天说啊我现在到应该到这一步了

2498
01:39:12,000 --> 01:39:13,000
我应该恢复到之前那个状态

2499
01:39:13,000 --> 01:39:15,000
然后怎么怎么接着做下去

2500
01:39:15,000 --> 01:39:19,000
就其实是一个如果人脑去想是个挺费时费脑的事情

2501
01:39:19,000 --> 01:39:27,000
但如果你写代码来做的话就是要考虑很多可能你预想不到的组合的这种情况出现

2502
01:39:27,000 --> 01:39:28,000
没错

2503
01:39:28,000 --> 01:39:29,000
啊

2504
01:39:29,000 --> 01:39:33,000
但一步爱欧的就是就基于回到一步爱欧有一个什么样的好处呢

2505
01:39:33,000 --> 01:39:39,000
就是他可以保证整个这个因为它是一个单进程的这么一个单进程或者单线程的这么一个

2506
01:39:39,000 --> 01:39:40,000
好

2507
01:39:40,000 --> 01:39:41,000
就是这么一个结构嘛

2508
01:39:41,000 --> 01:39:44,000
他有一个好处是可以完全不用考虑锁的问题

2509
01:39:44,000 --> 01:39:45,000
对

2510
01:39:45,000 --> 01:39:51,000
因为你在任意时刻都只有一个啊控制流在执行

2511
01:39:51,000 --> 01:39:54,000
这样就一个就有工作单元在跑一个人对没错

2512
01:39:54,000 --> 01:40:01,000
你就不会不用去考虑说我在这个我的这个进程或者现成这个呃这个的就是 memory space

2513
01:40:01,000 --> 01:40:04,000
就是内存空间以内我要去修改任何状态

2514
01:40:04,000 --> 01:40:08,000
我不会我改的时候是肯定是不会有有有任何人跟我抢的

2515
01:40:08,000 --> 01:40:09,000
没错

2516
01:40:09,000 --> 01:40:14,000
就这也可能也是呃都会先讲的 java script 的这个呃引擎也好

2517
01:40:14,000 --> 01:40:17,000
他很呃在意的一点

2518
01:40:17,000 --> 01:40:23,000
因为这个你一旦可以避免这个锁或者就同就是就呃就同步叫什么

2519
01:40:23,000 --> 01:40:26,000
share multiple state 就是共享的可变状态的话

2520
01:40:26,000 --> 01:40:30,000
但可以可以避免这个你的整个编程的嗯

2521
01:40:30,000 --> 01:40:31,000
怎么说呢

2522
01:40:31,000 --> 01:40:32,000
难度吧

2523
01:40:32,000 --> 01:40:36,000
就会降低很大的一个什么数量级的降低

2524
01:40:36,000 --> 01:40:38,000
但如果他会让你不能你不能保证这一点的话呢

2525
01:40:38,000 --> 01:40:44,000
你就会牵扯到刚才我们讲那个并行计算的最核心的矛盾

2526
01:40:44,000 --> 01:40:46,000
就是人没有办法去思考

2527
01:40:46,000 --> 01:40:48,000
像机器那样并行的去思考嘛

2528
01:40:48,000 --> 01:40:51,000
对对但是这个机回掉的一般呢

2529
01:40:51,000 --> 01:40:54,000
就是有一个好有一个很大的缺陷

2530
01:40:54,000 --> 01:40:59,000
就是他要把我们这个程序整个逻辑流啊分得非常碎

2531
01:40:59,000 --> 01:41:00,000
就通过回调的方式

2532
01:41:00,000 --> 01:41:04,000
你要把它整个逻辑流做到啊切成很多小片段

2533
01:41:04,000 --> 01:41:06,000
然后每个片段的他之间的关系

2534
01:41:06,000 --> 01:41:08,000
又不是非常的那种很线性很明朗的

2535
01:41:08,000 --> 01:41:09,000
这样的话

2536
01:41:09,000 --> 01:41:14,000
对于你理解整个程序的结构其实是非常不利的

2537
01:41:14,000 --> 01:41:18,000
对在扎克呃程序员里面经常会有这样的效果

2538
01:41:18,000 --> 01:41:21,000
就是呃一个回调欠着另外一个回调

2539
01:41:21,000 --> 01:41:22,000
然后再欠着另外一个回调

2540
01:41:22,000 --> 01:41:26,000
然后整个最后你写这个代码的结尾就是

2541
01:41:26,000 --> 01:41:32,000
括号分号花过号括号分号花过号括号分号

2542
01:41:32,000 --> 01:41:33,000
这样一层一层的嵌套进去

2543
01:41:33,000 --> 01:41:34,000
对没错

2544
01:41:34,000 --> 01:41:36,000
然后这个有一个专门的我们给他一个称呼叫做回调

2545
01:41:36,000 --> 01:41:42,000
回调地狱 callback hell

2546
01:41:42,000 --> 01:41:49,000
对然后呃就说那我们有没有办法说能够既保留这个单

2547
01:41:49,000 --> 01:41:54,000
就是一步爱欧这种单线程不需要考虑锁的机制的好处

2548
01:41:54,000 --> 01:41:58,000
同时呢又可以保留我们这个程序逻辑是线性

2549
01:41:58,000 --> 01:42:01,000
不用分的呃不用切成小片段切的很散

2550
01:42:01,000 --> 01:42:02,000
就是这种状况呢

2551
01:42:02,000 --> 01:42:05,000
就也有一些很很好的尝试嘛

2552
01:42:05,000 --> 01:42:08,000
就是说这个基于携程这么一个概念啊

2553
01:42:08,000 --> 01:42:10,000
对成是什么意思呢

2554
01:42:10,000 --> 01:42:14,000
刚才讲到有有进程有现成有携程

2555
01:42:14,000 --> 01:42:19,000
携程其实是在程序里面自己管理的一个逻辑的

2556
01:42:19,000 --> 01:42:22,000
又要用一个广义的进程了哈

2557
01:42:22,000 --> 01:42:29,000
对我觉得携程其实比较容易理解的呃比较容易理解的

2558
01:42:29,000 --> 01:42:34,000
点就是说携程其实是非常贴近现实的

2559
01:42:34,000 --> 01:42:36,000
贴近现实生活的一个东西

2560
01:42:36,000 --> 01:42:40,000
嗯比如说我在粘模型

2561
01:42:40,000 --> 01:42:43,000
然后这个时候女朋友喊我喊我说啊水开了

2562
01:42:43,000 --> 01:42:47,000
你去把他你去泡个茶

2563
01:42:47,000 --> 01:42:51,000
然后我可以很方便的放下我手中的工具转身去泡茶

2564
01:42:51,000 --> 01:42:58,000
回来的时候接着我刚才沾到一半的呃的 progress

2565
01:42:58,000 --> 01:43:03,000
中文是什么呃进度对呃然后继续粘模型

2566
01:43:03,000 --> 01:43:05,000
然后继续粘我的模型

2567
01:43:05,000 --> 01:43:12,000
就是说其实现实生活中很多很多事情都是呃可以对应到其他的写成

2568
01:43:12,000 --> 01:43:16,000
但是在传统的没有写成的编程模型里面

2569
01:43:16,000 --> 01:43:20,000
编程世界里面计算机是不知道怎么保存现场

2570
01:43:20,000 --> 01:43:26,000
所以说写成其实就是赋予的计算机一种保存一个执行到一半的函数的现场的能力

2571
01:43:26,000 --> 01:43:29,000
然后告诉你说你做到这儿给了你个断点

2572
01:43:29,000 --> 01:43:31,000
你可以跳出去做别的事情

2573
01:43:31,000 --> 01:43:32,000
回来的时候

2574
01:43:32,000 --> 01:43:35,000
刚才执行到哪还可以继续接着执行

2575
01:43:35,000 --> 01:43:37,000
这就是现场所有的你的所谓的 context

2576
01:43:37,000 --> 01:43:40,000
你的上下文都还保留的保留在那个原样

2577
01:43:40,000 --> 01:43:44,000
你可以接着假装没有中断的这件事情发生一下

2578
01:43:44,000 --> 01:43:45,000
你接着往前走下去了

2579
01:43:45,000 --> 01:43:47,000
所以其实从这个意义上来讲

2580
01:43:47,000 --> 01:43:49,000
现成也好进程也好写成也好

2581
01:43:49,000 --> 01:43:51,000
他们都做到同样一件事情

2582
01:43:51,000 --> 01:43:56,000
就是说是一段可以被随时重呃叫叫 resume

2583
01:43:56,000 --> 01:44:00,000
不叫重启叫什么呃恢复随时可以捡起来

2584
01:44:00,000 --> 01:44:02,000
接着再做下去的事情

2585
01:44:02,000 --> 01:44:08,000
就是说他们的执行的区别在哪里

2586
01:44:08,000 --> 01:44:14,000
就是说呃可能在实现的这个就资源的 overhead 上面是不一样的

2587
01:44:14,000 --> 01:44:16,000
可能最重的可能是进程

2588
01:44:16,000 --> 01:44:19,000
因为超新要做很多什么 cpu 寄存器的切换呀

2589
01:44:19,000 --> 01:44:20,000
有那些麻烦的事情

2590
01:44:20,000 --> 01:44:24,000
还要保留一些什么样的状态系统的一些 bookkeeping 的工作

2591
01:44:24,000 --> 01:44:29,000
然后是主要是在需要的时候需要把内存里面的很多数据拷贝一份

2592
01:44:29,000 --> 01:44:30,000
这是非常非常大

2593
01:44:30,000 --> 01:44:31,000
你也要有一个计算机

2594
01:44:31,000 --> 01:44:32,000
对吧

2595
01:44:32,000 --> 01:44:33,000
对的

2596
01:44:33,000 --> 01:44:35,000
对然后进进程的开销呢

2597
01:44:35,000 --> 01:44:37,000
就相相对要少一点

2598
01:44:37,000 --> 01:44:39,000
但是还是还是比较显著的

2599
01:44:39,000 --> 01:44:43,000
那么携程的就是说那直接就绕过操作系统内部

2600
01:44:43,000 --> 01:44:51,000
我直接在程序内部通过一种自制的调度器的方式来管理我自己的那些呃呃那些的 task

2601
01:44:51,000 --> 01:44:52,000
那些责任物嘛

2602
01:44:52,000 --> 01:44:56,000
然后使得有一个非常呃轻量的资源的开销

2603
01:44:56,000 --> 01:45:00,000
同时又能给我带来像类似于进程或者现成那样的一个嗯

2604
01:45:00,000 --> 01:45:01,000
线性的逻辑流的好点

2605
01:45:01,000 --> 01:45:06,000
对这样前面所提到的这种一位是控制浮楼的问题就不会不会再发生了

2606
01:45:06,000 --> 01:45:07,000
没错

2607
01:45:07,000 --> 01:45:10,000
对呃现实中使用携程的例子也是蛮多的哈

2608
01:45:10,000 --> 01:45:14,000
那其实呃呃总体来讲像勾烂的那个勾如替吗

2609
01:45:14,000 --> 01:45:16,000
它就是一种携程的一种一种吧

2610
01:45:16,000 --> 01:45:17,000
一种变种

2611
01:45:17,000 --> 01:45:18,000
然后像拍手的话

2612
01:45:18,000 --> 01:45:20,000
它有一个叫做 gene

2613
01:45:20,000 --> 01:45:21,000
生成器这么个概念

2614
01:45:21,000 --> 01:45:25,000
就是他他这个函数里面是有一个特殊的关键的个关键词叫做 yield

2615
01:45:25,000 --> 01:45:26,000
可以用来做什么

2616
01:45:26,000 --> 01:45:28,000
暂时的让出业务就是让出的意思嘛

2617
01:45:28,000 --> 01:45:30,000
让出这个程序的控制流

2618
01:45:30,000 --> 01:45:32,000
然后等那边呃条件合适的时候

2619
01:45:32,000 --> 01:45:34,000
你再把它回到这个位置

2620
01:45:34,000 --> 01:45:36,000
然后接着从这个点往下置

2621
01:45:36,000 --> 01:45:40,000
然后我知道是 java script 从应该是下一个版本还是还是七的时候

2622
01:45:40,000 --> 01:45:41,000
他也在家

2623
01:45:41,000 --> 01:45:42,000
不就下一个吗

2624
01:45:42,000 --> 01:45:45,000
加一加一就 emax script 六 emax script 六

2625
01:45:45,000 --> 01:45:46,000
这个版本里面

2626
01:45:46,000 --> 01:45:47,000
然后呢

2627
01:45:47,000 --> 01:45:48,000
这个版本里面呢

2628
01:45:48,000 --> 01:45:49,000
这个版本里面呢

2629
01:45:49,000 --> 01:45:50,000
这个版本里面呢

2630
01:45:50,000 --> 01:45:51,000
这个版本里面呢

2631
01:45:51,000 --> 01:45:52,000
这个版本里面呢

2632
01:45:52,000 --> 01:45:53,000
这个版本里面呢

2633
01:45:53,000 --> 01:45:54,000
这个版本里面呢

2634
01:45:54,000 --> 01:45:55,000
这个版本里面呢

2635
01:45:55,000 --> 01:45:56,000
这个版本里面呢

2636
01:45:56,000 --> 01:46:01,000
就已经有这个呃类似的 generator 这么一个概念在里面了

2637
01:46:01,000 --> 01:46:03,000
然后 ruby 的话

2638
01:46:03,000 --> 01:46:05,000
它有一个分有一个特性叫做 fiber 吧

2639
01:46:05,000 --> 01:46:07,000
也是一个写成的例子

2640
01:46:07,000 --> 01:46:08,000
对

2641
01:46:08,000 --> 01:46:09,000
fiber 一般翻译成叫什么

2642
01:46:09,000 --> 01:46:14,000
千成就是比现成更要细的纤维千成

2643
01:46:14,000 --> 01:46:16,000
但是让前面就是写成

2644
01:46:16,000 --> 01:46:20,000
因为它是对于那个 thread 的来的 thread 在那个织布的那个那个那个语境

2645
01:46:20,000 --> 01:46:22,000
就是纺织界的语境里面是讲什么

2646
01:46:22,000 --> 01:46:23,000
线头对不对

2647
01:46:23,000 --> 01:46:24,000
对一个线

2648
01:46:24,000 --> 01:46:26,000
而 fiber 则是组成了

2649
01:46:26,000 --> 01:46:29,000
我们那个线的一根纤维的纱一根纱嘛

2650
01:46:29,000 --> 01:46:30,000
对没错

2651
01:46:30,000 --> 01:46:31,000
这个这个意思

2652
01:46:31,000 --> 01:46:32,000
嗯

2653
01:46:32,000 --> 01:46:35,000
然后 piphone 的话还有一个嗯

2654
01:46:35,000 --> 01:46:36,000
一个 forke 吧

2655
01:46:36,000 --> 01:46:38,000
算是叫做 g event

2656
01:46:38,000 --> 01:46:41,000
它是可以甚至通过那种方式来做啊

2657
01:46:41,000 --> 01:46:44,000
全局的呃写成呃这个写成

2658
01:46:44,000 --> 01:46:49,000
而不是说只仅仅限于这个 generator 这种比较受限的写成

2659
01:46:49,000 --> 01:46:50,000
ok

2660
01:46:50,000 --> 01:46:55,000
所以但问题在于不管是毁掉还是写成

2661
01:46:55,000 --> 01:46:59,000
都没有办法非常有效的利用多核处理器补什么

2662
01:46:59,000 --> 01:47:04,000
因为你你所你无论如何都只有一个单只有一个单个的进程

2663
01:47:04,000 --> 01:47:06,000
嗯

2664
01:47:06,000 --> 01:47:07,000
没错

2665
01:47:07,000 --> 01:47:08,000
一般是这样子的

2666
01:47:08,000 --> 01:47:09,000
比如刚才我们看了那几个例子

2667
01:47:09,000 --> 01:47:13,000
它都是因为有这样那样的限制导致它不能使用多限制

2668
01:47:13,000 --> 01:47:15,000
但是也并不完全是这样

2669
01:47:15,000 --> 01:47:17,000
就是说比如说 go 的那个 go routine

2670
01:47:17,000 --> 01:47:21,000
它其实是可以利用多线那个多个处理器核心的

2671
01:47:21,000 --> 01:47:23,000
就是看你这个系统的调度的时候

2672
01:47:23,000 --> 01:47:25,000
你是怎么去调度它而已

2673
01:47:25,000 --> 01:47:26,000
ok

2674
01:47:26,000 --> 01:47:27,000
哦

2675
01:47:27,000 --> 01:47:31,000
然后还有像而揽这种比较诡异的例子

2676
01:47:31,000 --> 01:47:33,000
但它是非常独特的一种机制

2677
01:47:33,000 --> 01:47:36,000
它它里面的现成不是系统的现成

2678
01:47:36,000 --> 01:47:38,000
它是自己自己内置的现成

2679
01:47:38,000 --> 01:47:40,000
它也并不但也它也并不是一个写成

2680
01:47:40,000 --> 01:47:42,000
就它每个线程都是完全独立

2681
01:47:42,000 --> 01:47:45,000
就是没有任何和其他共享资源的地方

2682
01:47:45,000 --> 01:47:49,000
就是说它的那个调度其实可以很方便的去管理它

2683
01:47:49,000 --> 01:47:52,000
那些那些呃叫做呃执行的步骤嘛

2684
01:47:52,000 --> 01:47:54,000
他们叫做 reduction 这么一个一个步骤的

2685
01:47:54,000 --> 01:47:55,000
嗯

2686
01:47:55,000 --> 01:47:56,000
对

2687
01:47:56,000 --> 01:47:57,000
而那我虽然不是很了解

2688
01:47:57,000 --> 01:48:03,000
但我觉得他的他的思路基本上就是把 thread 当做一种语言内在的机制

2689
01:48:03,000 --> 01:48:07,000
而不是对操作系统提供的机制的一种抽象

2690
01:48:07,000 --> 01:48:08,000
没错

2691
01:48:08,000 --> 01:48:09,000
嗯

2692
01:48:09,000 --> 01:48:11,000
因为因为他使用的那个那个 actor model

2693
01:48:11,000 --> 01:48:15,000
actor 模型对这种事情是有天然的需求的嘛

2694
01:48:15,000 --> 01:48:16,000
而且他整个啊

2695
01:48:16,000 --> 01:48:17,000
这个调度器也好

2696
01:48:17,000 --> 01:48:18,000
解析器也好

2697
01:48:18,000 --> 01:48:21,000
就是为这种方式去去优化的

2698
01:48:21,000 --> 01:48:24,000
虽然说他的可能整就是直提某一个这种就是所谓的

2699
01:48:24,000 --> 01:48:28,000
就 cpu heavy 的中心的性能不怎么样

2700
01:48:28,000 --> 01:48:33,000
但是他对这种啊可以并行计算的任务的处理是非常非常优秀的

2701
01:48:33,000 --> 01:48:34,000
没错

2702
01:48:34,000 --> 01:48:35,000
嗯

2703
01:48:35,000 --> 01:48:40,000
对其实我现在学哈斯口终于开始或者说终于又开始

2704
01:48:40,000 --> 01:48:43,000
为什么突然有这个契机去学他

2705
01:48:43,000 --> 01:48:44,000
啊

2706
01:48:44,000 --> 01:48:51,000
我也不知道就是可能主要契机还是因为之前看的那个 object c 的啊 blog

2707
01:48:51,000 --> 01:48:52,000
嗯

2708
01:48:52,000 --> 01:48:53,000
他们

2709
01:48:53,000 --> 01:48:55,000
受其蛊惑对不对

2710
01:48:55,000 --> 01:48:58,000
对他们提供了大量的呃

2711
01:48:58,000 --> 01:48:59,000
奇迹引巧

2712
01:48:59,000 --> 01:49:03,000
就是为了让你写 swift 的时候看起来更像哈斯口

2713
01:49:03,000 --> 01:49:04,000
我觉得何必呢

2714
01:49:04,000 --> 01:49:05,000
那我干脆去学一只哈斯口

2715
01:49:05,000 --> 01:49:10,000
但这样的这样的这样的尝试已经有过很多次

2716
01:49:10,000 --> 01:49:12,000
但每次都没有坚持下来

2717
01:49:12,000 --> 01:49:14,000
我觉得这次应该坚持坚持

2718
01:49:14,000 --> 01:49:17,000
然后在那之后也许可以试试 L 了

2719
01:49:17,000 --> 01:49:21,000
因为有的在我北边有一个城市叫做艾拉根

2720
01:49:21,000 --> 01:49:22,000
哈哈哈

2721
01:49:22,000 --> 01:49:23,000
我以前

2722
01:49:23,000 --> 01:49:25,000
我以前写过一个写过一条推

2723
01:49:25,000 --> 01:49:33,000
就是说呃艾拉根这个地方就是由呃二战时期被纳粹集中在一起的艾拉根程序员建立的

2724
01:49:33,000 --> 01:49:34,000
所以他叫做艾拉根

2725
01:49:34,000 --> 01:49:37,000
在德语里面就是使用艾拉根编程的意思

2726
01:49:37,000 --> 01:49:38,000
哈哈

2727
01:49:38,000 --> 01:49:39,000
对

2728
01:49:39,000 --> 01:49:42,000
艾拉根在德语里面什么意思

2729
01:49:42,000 --> 01:49:43,000
没有意义吗

2730
01:49:43,000 --> 01:49:44,000
还是只是个名字而已

2731
01:49:44,000 --> 01:49:45,000
嗯

2732
01:49:45,000 --> 01:49:46,000
没有什么意义吧

2733
01:49:46,000 --> 01:49:52,000
就至少我找不出什么特别呃至少我想不到什么特别明显的语言

2734
01:49:52,000 --> 01:49:54,000
我回头会去查查 atmol

2735
01:49:54,000 --> 01:49:58,000
但是我可以基本上可以确定艾拉根跟艾拉根没有任何没有任何

2736
01:49:58,000 --> 01:50:03,000
因为因为艾拉里面那个也和人家讲的是那个爱立信的实验室做的语言嘛

2737
01:50:03,000 --> 01:50:05,000
叫做艾里克森 language

2738
01:50:05,000 --> 01:50:06,000
所以是艾拉根

2739
01:50:06,000 --> 01:50:08,000
啊原来是这么来的

2740
01:50:08,000 --> 01:50:10,000
OK 你不知道不知道啊

2741
01:50:10,000 --> 01:50:13,000
就我原来能理解非理解了解非常非常有限

2742
01:50:13,000 --> 01:50:14,000
对他就是这么样

2743
01:50:14,000 --> 01:50:18,000
而且他有一个这个这个可能之后有一期专门讲二段时候再说吧

2744
01:50:18,000 --> 01:50:20,000
还有一个很有意思的那个

2745
01:50:20,000 --> 01:50:21,000
就看起来甚至有点问题啊

2746
01:50:21,000 --> 01:50:24,000
就看起来甚至有点 weird 的一个短视频

2747
01:50:24,000 --> 01:50:25,000
非常有意思

2748
01:50:25,000 --> 01:50:26,000
嗯

2749
01:50:26,000 --> 01:50:32,000
就是他们因为艾拉最开始的用途是用于做那个叫做什么电话交换机的控制的吧

2750
01:50:32,000 --> 01:50:34,000
对控制拨号

2751
01:50:34,000 --> 01:50:35,000
然后怎么怎么样

2752
01:50:35,000 --> 01:50:39,000
他就他就那个视频就整个过程都在描述这么一个过程中

2753
01:50:39,000 --> 01:50:41,000
这个艾拉是怎么样起作用的

2754
01:50:41,000 --> 01:50:44,000
非常好笑的一个视频一定要看一下

2755
01:50:44,000 --> 01:50:47,000
有一种 monty python 的既视感

2756
01:50:47,000 --> 01:50:48,000
啊

2757
01:50:48,000 --> 01:50:49,000
有意思

2758
01:50:49,000 --> 01:50:50,000
所以处理电话拨号

2759
01:50:50,000 --> 01:50:51,000
其实

2760
01:50:51,000 --> 01:50:57,000
其实听起来也是一个天生就带有并发性质的问题领域

2761
01:50:57,000 --> 01:50:58,000
嗯

2762
01:50:58,000 --> 01:50:59,000
没错

2763
01:50:59,000 --> 01:51:04,000
对所以在从这样一种领域里面所为了解决这样一个领域的问题

2764
01:51:04,000 --> 01:51:11,000
而诞生的变成语言也就天生的非常强调解决这种问题的方便程度

2765
01:51:11,000 --> 01:51:12,000
嗯

2766
01:51:12,000 --> 01:51:16,000
而且我觉得他他这个就是而揽他这种方式

2767
01:51:16,000 --> 01:51:19,000
而且才让他他他采用那种像阿克毛德也好

2768
01:51:19,000 --> 01:51:21,000
他整自己的这种调度器也好

2769
01:51:21,000 --> 01:51:26,000
他有一个很成熟的叫做监控的系统 supervision system

2770
01:51:26,000 --> 01:51:27,000
叫做 otp 嘛

2771
01:51:27,000 --> 01:51:32,000
就是 open telecom platform 开放电信平台听起来很怪哈

2772
01:51:32,000 --> 01:51:35,000
为什么会是听起来非常电信

2773
01:51:35,000 --> 01:51:42,000
对听起来非常爱理性但是但是他但是他确实是解决了很多这种大型软件工程的一些问题

2774
01:51:42,000 --> 01:51:45,000
比如说他里面的所有的那些那些就是现成嘛

2775
01:51:45,000 --> 01:51:46,000
我们叫做 actor 也好

2776
01:51:46,000 --> 01:51:50,000
他是随时可以可以让他就是他的错误处理即使是不处理

2777
01:51:50,000 --> 01:51:52,000
让他让他 crash 掉

2778
01:51:52,000 --> 01:51:53,000
嗯

2779
01:51:53,000 --> 01:51:55,000
然后 crush 掉之后怎么办呢

2780
01:51:55,000 --> 01:52:02,000
他每一个 actor 他会为他分配一个叫做 supervisorsupervisor 就是监管管理者

2781
01:52:02,000 --> 01:52:05,000
然后这个管理者不叫不叫每个不是不是就是说

2782
01:52:05,000 --> 01:52:07,000
呃这里说错了

2783
01:52:07,000 --> 01:52:08,000
应该重新讲一下

2784
01:52:08,000 --> 01:52:13,000
因为说他里面每个 actor 都是被一个 supervisor 管理的

2785
01:52:13,000 --> 01:52:15,000
如果这个 supervisor 探测到那个 actor 挂掉了

2786
01:52:15,000 --> 01:52:17,000
他就会或者死掉了

2787
01:52:17,000 --> 01:52:19,000
他就会重新再起一个一模一样的

2788
01:52:19,000 --> 01:52:20,000
嗯

2789
01:52:20,000 --> 01:52:26,000
然后他里面整个这种这这一套思维哲学是非常非常呃很不一样

2790
01:52:26,000 --> 01:52:33,000
而且你到目前为止我们做那种很多这种像做那种大规模的分布是一种的维护的

2791
01:52:33,000 --> 01:52:34,000
所以会发现

2792
01:52:34,000 --> 01:52:35,000
越你做这种越大

2793
01:52:35,000 --> 01:52:42,000
你越会你的那个什么整个架构会越靠近像那个而懒的这种这种这套模型来讲

2794
01:52:42,000 --> 01:52:44,000
比如说很简单的一个那个 google 的那个例子吧

2795
01:52:44,000 --> 01:52:48,000
你 google 的说他们就是传统上我们做那种呃服务器软件

2796
01:52:48,000 --> 01:52:49,000
我们都要考虑说啊

2797
01:52:49,000 --> 01:52:51,000
我们这个这个服务器不要挂掉

2798
01:52:51,000 --> 01:52:53,000
我们要的还要高稳定可靠对吧

2799
01:52:53,000 --> 01:52:59,000
就好像我们说这个服务器的可靠性要高于工作站的工作站的可靠性要高于这种个人 pc 的

2800
01:52:59,000 --> 01:53:01,000
但是你为了换取那更高可靠性

2801
01:53:01,000 --> 01:53:02,000
你要付出更高的成本啊

2802
01:53:02,000 --> 01:53:05,000
就单位硬件和单位计算能力的成本你是要上去了嘛

2803
01:53:05,000 --> 01:53:08,000
然后 google 当年的做法就是说啊

2804
01:53:08,000 --> 01:53:11,000
我们做大规模的这种这种服务端

2805
01:53:11,000 --> 01:53:13,000
我们不需要用这种所有的服务

2806
01:53:13,000 --> 01:53:17,000
就 servergrade hardware 就是服务器级别的硬件

2807
01:53:17,000 --> 01:53:18,000
什么高档处理器啊

2808
01:53:18,000 --> 01:53:20,000
或者是高档机房啊

2809
01:53:20,000 --> 01:53:24,000
这种东西我们就用普通的所谓的 commodity hard 就是这种呃

2810
01:53:24,000 --> 01:53:25,000
随受可见

2811
01:53:25,000 --> 01:53:27,000
唾手可得的普通机器

2812
01:53:27,000 --> 01:53:30,000
就是普通机器就可以随意替换的机器

2813
01:53:30,000 --> 01:53:35,000
然后他虽然说他的那个故障率要比这种所谓的服务器级别硬件要高

2814
01:53:35,000 --> 01:53:38,000
但是我们只要把软件的容错写好

2815
01:53:38,000 --> 01:53:44,000
我们他随时挂掉任何几个机器都是没有没有不影响我们这个系统整个系统运作的嘛

2816
01:53:44,000 --> 01:53:46,000
然后你要实现这一点

2817
01:53:46,000 --> 01:53:48,000
你就会发现你会越来越的

2818
01:53:48,000 --> 01:53:52,000
用到类似于二轮的那种那种机制要去监控

2819
01:53:52,000 --> 01:53:55,000
然后要去呃假设错误是不可恢复的

2820
01:53:55,000 --> 01:53:57,000
然后你要如果遇到错误

2821
01:53:57,000 --> 01:54:02,000
你再重新起一个新的节点来接替之前挂掉的那些节点的工作

2822
01:54:02,000 --> 01:54:04,000
那诸如此类的事情吧

2823
01:54:04,000 --> 01:54:14,000
对这我脑中浮现出了早期电话系统那种呃一排接线机器前面坐着一大呃坐着很多接线员的场景

2824
01:54:14,000 --> 01:54:17,000
然后一个 super 在那边看说

2825
01:54:17,000 --> 01:54:18,000
我这个

2826
01:54:18,000 --> 01:54:21,000
这个接线员累倒在了工作岗位上

2827
01:54:21,000 --> 01:54:26,000
立刻把它撤走换另外一个来插插线头感觉是谁学汉工厂

2828
01:54:26,000 --> 01:54:27,000
没错

2829
01:54:27,000 --> 01:54:37,000
其实这也就说到这个也就想到上一期我们跟木尧聊的说他们我们你们学哈斯科的动机是什么

2830
01:54:37,000 --> 01:54:47,000
那或者说那学啊那我觉得可以把这个问题泛化为学艾兰或者是哈斯科这种比较家里好小众的辩证员

2831
01:54:47,000 --> 01:55:02,000
他的他的比较比较功利的一个一个效果就是你可能会发现当你需要解决一个特定领域的问题的时候你会发现在这种比较小众的语言里面已经有了相当好的解决方案已经有了

2832
01:55:02,000 --> 01:55:03,000
嗯

2833
01:55:03,000 --> 01:55:11,000
已经有先人是对子深思熟虑过并且设计出了一个非常好的模型

2834
01:55:11,000 --> 01:55:12,000
那么当你在

2835
01:55:12,000 --> 01:55:16,000
当你在用你的所谓原生语言去解决它的时候就会有一个很好的解决方案

2836
01:55:16,000 --> 01:55:40,000
对就甚至说你不一定真的用到这个这个语言的具体的实现甚至你都不会用这个语言去写去写新的代码但是你从这里面学到的这种思想可能会有助于你在现有的工作中去提升你的这个架构的能力也好或者说是你去抽象事物的能力你会发现哎原来还可以从这个角度去思考问题对吧

2837
01:55:40,000 --> 01:55:45,000
对这是为什么人要去做你要去努力做一个 polyglot

2838
01:55:45,000 --> 01:55:46,000
这个好像你多学一个

2839
01:55:46,000 --> 01:55:48,000
杰克有个谚语嘛

2840
01:55:48,000 --> 01:55:51,000
就是你你会几种语言你就有几种人生

2841
01:55:51,000 --> 01:55:52,000
所以

2842
01:55:52,000 --> 01:55:55,000
变成语其实也是这样的

2843
01:55:55,000 --> 01:55:56,000
你会几种语言

2844
01:55:56,000 --> 01:55:58,000
你就可以你就多几种语言

2845
01:55:58,000 --> 01:56:00,000
你就可以多理解几种变成模型

2846
01:56:00,000 --> 01:56:04,000
参差多泰才四美这里又提现出来了

2847
01:56:04,000 --> 01:56:05,000
没错

2848
01:56:05,000 --> 01:56:07,000
嗯

2849
01:56:07,000 --> 01:56:09,000
差不多了

2850
01:56:09,000 --> 01:56:09,000
好吧

2851
01:56:09,000 --> 01:56:12,000
今天是你也结尾一下吧

2852
01:56:12,000 --> 01:56:13,000
嗯

2853
01:56:13,000 --> 01:56:13,000
对

2854
01:56:13,000 --> 01:56:16,000
所以今天我们大概就讲了

2855
01:56:16,000 --> 01:56:19,000
说了当然可能不是非常的满意

2856
01:56:19,000 --> 01:56:21,000
因为做了很多

2857
01:56:21,000 --> 01:56:22,000
嗯

2858
01:56:22,000 --> 01:56:26,000
解释一些比较复杂的问题的尝试

2859
01:56:26,000 --> 01:56:29,000
但是都没有能想失败了

2860
01:56:29,000 --> 01:56:31,000
对都没有能做的很好

2861
01:56:31,000 --> 01:56:34,000
这可能也从另外一个侧面反映出了

2862
01:56:34,000 --> 01:56:35,000
嗯

2863
01:56:35,000 --> 01:56:41,000
并发和异步其实的确是在编程领域比较难的一些问题

2864
01:56:41,000 --> 01:56:42,000
嗯

2865
01:56:42,000 --> 01:56:45,000
就但也有可能说我们俩我们两个太水

2866
01:56:45,000 --> 01:56:46,000
这是肯定的

2867
01:56:46,000 --> 01:56:49,000
我从来不怀疑那句话怎么说来着

2868
01:56:49,000 --> 01:56:50,000
就是说

2869
01:56:50,000 --> 01:56:50,000
啊

2870
01:56:50,000 --> 01:56:53,000
如果你能够用几句话的东西

2871
01:56:53,000 --> 01:56:54,000
真的能够等下

2872
01:56:54,000 --> 01:56:57,000
或者说你能够很清晰明白的给人家解释一个东西

2873
01:56:57,000 --> 01:57:00,000
那么你对这个事情的理解就肯定是比较透彻了

2874
01:57:00,000 --> 01:57:01,000
但如果你解释不了

2875
01:57:01,000 --> 01:57:03,000
很有可能是你自己理解的还不够深刻

2876
01:57:03,000 --> 01:57:04,000
对

2877
01:57:04,000 --> 01:57:07,000
就是有很多东西都会有这样一个阶段

2878
01:57:07,000 --> 01:57:08,000
就是你以为自己懂了

2879
01:57:08,000 --> 01:57:13,000
但是当你要像别人解释的时候会发现自己其实并不是真的理解

2880
01:57:13,000 --> 01:57:15,000
嗯

2881
01:57:15,000 --> 01:57:15,000
对

2882
01:57:15,000 --> 01:57:16,000
从这个侧面

2883
01:57:16,000 --> 01:57:16,000
嗯

2884
01:57:16,000 --> 01:57:17,000
对于我来说

2885
01:57:17,000 --> 01:57:20,000
我觉得可能做 podcast 对对不知道你

2886
01:57:20,000 --> 01:57:23,000
但对我来说是也是一个非常大的帮助

2887
01:57:23,000 --> 01:57:25,000
就是呃

2888
01:57:25,000 --> 01:57:27,000
就像之前我在知乎答案里面说过的那样

2889
01:57:27,000 --> 01:57:28,000
就是非常

2890
01:57:29,000 --> 01:57:36,000
帮助我去把自己之前可能一知半解的部分弄得比较比较二知一解

2891
01:57:36,000 --> 01:57:40,000
就是把它为了像为了做好一些节目

2892
01:57:40,000 --> 01:57:43,000
可能我会去看一些相关的书啊

2893
01:57:43,000 --> 01:57:46,000
这些对于我来说也是非常大的帮助

2894
01:57:46,000 --> 01:57:46,000
不管是什么

2895
01:57:46,000 --> 01:57:50,000
但是这个就是不管你是在呃说就是口述也好

2896
01:57:50,000 --> 01:57:52,000
还是说笔头写下来也好

2897
01:57:52,000 --> 01:57:59,000
就是你整个在输出的过程其实就是在考验你内部的色那个什么知识的组织也好

2898
01:57:59,000 --> 01:58:00,000
还是你的理解也好

2899
01:58:00,000 --> 01:58:00,000
对吧

2900
01:58:00,000 --> 01:58:04,000
都是他对是一个是一个呃使用的过程

2901
01:58:04,000 --> 01:58:05,000
这个时候你会发现啊

2902
01:58:05,000 --> 01:58:08,000
如果你的某对某一点理解不够透彻的话

2903
01:58:08,000 --> 01:58:10,000
你这是没有办法解释清楚的

2904
01:58:10,000 --> 01:58:11,000
对

2905
01:58:11,000 --> 01:58:13,000
所以呃

2906
01:58:13,000 --> 01:58:16,000
也希望这一期节目能够起到抛转你的作用吧

2907
01:58:16,000 --> 01:58:23,000
如果哪位听众对于呃异部和并发有比较深刻的理解

2908
01:58:23,000 --> 01:58:26,000
然后觉得一些我没有讲清楚

2909
01:58:26,000 --> 01:58:28,000
但是讲错了概念可以啊

2910
01:58:28,000 --> 01:58:29,000
值得纠正的话

2911
01:58:29,000 --> 01:58:31,000
那也欢迎你说信给我们

2912
01:58:31,000 --> 01:58:35,000
我们的嗯电子邮件地址是 kernopanic at roses.li

2913
01:58:35,000 --> 01:58:41,000
然后也欢迎你拨打我们的热线电话

2914
01:58:41,000 --> 01:58:45,000
08189998819991197253

2915
01:58:45,000 --> 01:58:46,000
哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈 takiej Chinghanaées.ry bureau 谢谢你问一下

2916
01:58:46,000 --> 01:58:46,000
哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈 although my love school love you really enjoy your deaf voice

2917
01:58:46,000 --> 01:58:47,000
好

2918
01:58:47,000 --> 01:58:49,000
如果你非常喜欢我们的节目

2919
01:58:49,000 --> 01:58:50,000
或者说

2920
01:58:50,000 --> 01:58:51,000
不管你是不是喜欢我们的节目

2921
01:58:51,000 --> 01:58:53,000
都欢迎你为我们捐款

2922
01:58:53,000 --> 01:58:55,000
捐款的地址是

2923
01:58:55,000 --> 01:58:57,000
kernelpanic.fm

2924
01:58:57,000 --> 01:58:57,000
slash

2925
01:58:57,000 --> 01:58:58,000
donate

2926
01:58:58,000 --> 01:59:00,000
d-o-n-a-t

2927
01:59:00,000 --> 01:59:01,000
金额随意

2928
01:59:01,000 --> 01:59:02,000
但必须是

2929
01:59:02,000 --> 01:59:05,000
可以被巴整除的正整数

2930
01:59:05,000 --> 01:59:05,000
然后

2931
01:59:05,000 --> 01:59:10,000
为了向现在这段机的基础组成

2932
01:59:10,000 --> 01:59:11,000
byte 致敬

2933
01:59:11,000 --> 01:59:11,000
我们

2934
01:59:11,000 --> 01:59:13,000
把它设定为

2935
01:59:13,000 --> 01:59:15,000
至少要被巴整除

2936
01:59:15,000 --> 01:59:17,000
好吧

2937
01:59:17,000 --> 01:59:19,000
那今天就到这了

2938
01:59:19,000 --> 01:59:19,000
OK

2939
01:59:19,000 --> 01:59:20,000
对

2940
01:59:20,000 --> 01:59:21,000
感谢

2941
01:59:21,000 --> 01:59:22,000
下期再见

2942
01:59:22,000 --> 01:59:23,000
拜拜

