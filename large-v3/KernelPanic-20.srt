1
00:00:00,000 --> 00:00:04,000
欢迎收听 IPN Podcast 网络旗下的 IT 技术主题娱乐节目

2
00:00:04,000 --> 00:00:05,000
内核恐慌

3
00:00:05,000 --> 00:00:06,000
我们号称 hardcore

4
00:00:06,000 --> 00:00:07,000
但是也没有干货

5
00:00:07,000 --> 00:00:08,000
想听人听

6
00:00:08,000 --> 00:00:10,000
不想听的人就别听

7
00:00:10,000 --> 00:00:13,000
内核恐慌的网址是 ipn.li.com

8
00:00:13,000 --> 00:00:18,000
我们推荐大家使用 podcast 客户端订阅节目

9
00:00:18,000 --> 00:00:20,000
如果您不知道该使用哪种客户端

10
00:00:20,000 --> 00:00:22,000
欢迎访问 ipn.li.com

11
00:00:22,000 --> 00:00:26,000
也同样欢迎你为我们的节目捐款

12
00:00:26,000 --> 00:00:29,000
捐款地址是 ipn.li.com

13
00:00:29,000 --> 00:00:33,000
捐款金额随意

14
00:00:33,000 --> 00:00:35,000
只要是能被巴整出的正正数就可以

15
00:00:35,000 --> 00:00:37,000
捐款不会为你带来什么

16
00:00:37,000 --> 00:00:39,000
不捐也不会让你失去什么

17
00:00:39,000 --> 00:00:42,000
我们的口号是 no hard feelings

18
00:00:42,000 --> 00:00:47,000
所以我们今天是第二十期

19
00:00:47,000 --> 00:00:49,000
居然都已经二十期了

20
00:00:49,000 --> 00:00:52,000
一晃已经过去四十周了

21
00:00:52,000 --> 00:00:53,000
小半年

22
00:00:53,000 --> 00:00:54,000
不对大半年

23
00:00:54,000 --> 00:00:55,000
快一年

24
00:00:55,000 --> 00:00:55,000
对

25
00:00:55,000 --> 00:00:55,000
对

26
00:00:55,000 --> 00:00:56,000
对

29
00:01:56,000 --> 00:01:57,000
提示用吉尸给我们写了邮件

30
00:01:57,000 --> 00:02:00,000
并且我们趁这个 bug 还掀火的时候

31
00:02:00,000 --> 00:02:02,000
给它捉住了

32
00:02:02,000 --> 00:02:02,000
对

33
00:02:02,000 --> 00:02:07,000
那你 each 了一个 curl 的命运

34
00:02:07,000 --> 00:02:10,000
然后及时发现了这个 bug 的所在

35
00:02:10,000 --> 00:02:13,000
所以要解释一下是成因吗

36
00:02:13,000 --> 00:02:14,000
对

37
00:02:14,000 --> 00:02:15,000
我这个肯定要解释一下

38
00:02:15,000 --> 00:02:17,000
好不容易捉住一个虫子

39
00:02:17,000 --> 00:02:18,000
对吧

40
00:02:18,000 --> 00:02:20,000
简单来讲的是这样

41
00:02:20,000 --> 00:02:24,000
就是国内的部分运营商

42
00:02:24,000 --> 00:02:25,000
但这里部分运营商

43
00:02:25,000 --> 00:02:25,000
主要是在美国

44
00:02:25,000 --> 00:02:27,000
以长城宽带这种

45
00:02:27,000 --> 00:02:30,000
这种叫什么来着

46
00:02:30,000 --> 00:02:32,000
二道饭

47
00:02:32,000 --> 00:02:33,000
自营商为主

48
00:02:33,000 --> 00:02:35,000
然后他们

49
00:02:35,000 --> 00:02:37,000
对他们这个

50
00:02:37,000 --> 00:02:41,000
为了减缓他们网络的压力

51
00:02:41,000 --> 00:02:42,000
因为他买的带宽有限嘛

52
00:02:42,000 --> 00:02:44,000
然后他们自己在内部

53
00:02:44,000 --> 00:02:45,000
做了一个缓存

54
00:02:45,000 --> 00:02:47,000
比如说凡是你下载一些

55
00:02:47,000 --> 00:02:49,000
比较就通过 http 协议

56
00:02:49,000 --> 00:02:50,000
下载了一些比较大型的文件

57
00:02:50,000 --> 00:02:54,000
他们会在他们那个内部的

58
00:02:54,000 --> 00:02:55,000
一个服务器上缓存下来

59
00:02:55,000 --> 00:02:56,000
这样的话

60
00:02:56,000 --> 00:02:59,000
如果假设有一百个长宽的用户

61
00:02:59,000 --> 00:03:01,000
都去请求那一个文件的话

62
00:03:01,000 --> 00:03:04,000
他只有第一个人的时候

63
00:03:04,000 --> 00:03:06,000
会去下载

64
00:03:06,000 --> 00:03:08,000
从源那里拿那个文件

65
00:03:08,000 --> 00:03:09,000
然后后面的九十六个人

66
00:03:09,000 --> 00:03:11,000
都是从长宽自己的服务器走了

67
00:03:11,000 --> 00:03:12,000
这样的话

68
00:03:12,000 --> 00:03:14,000
因为长宽内部

69
00:03:14,000 --> 00:03:16,000
到他自己客户的这边网络的

70
00:03:16,000 --> 00:03:18,000
这个带宽是比较充足的

71
00:03:18,000 --> 00:03:20,000
但长宽去到别的网络的带宽

72
00:03:20,000 --> 00:03:22,000
是比较拥堵的

73
00:03:22,000 --> 00:03:25,000
所以通过这种缓存的方法

74
00:03:25,000 --> 00:03:28,000
他们可以用一个比较小的

75
00:03:28,000 --> 00:03:30,000
就比较便宜的

76
00:03:30,000 --> 00:03:31,000
就虚外面带宽

77
00:03:31,000 --> 00:03:33,000
去支撑足够多的用户

78
00:03:33,000 --> 00:03:35,000
从而降低他们的成本

79
00:03:35,000 --> 00:03:38,000
这个做法本来倒也没什么

80
00:03:38,000 --> 00:03:41,000
很多公司也是这么干的

81
00:03:41,000 --> 00:03:43,000
之前我在知乎的时候

82
00:03:43,000 --> 00:03:44,000
我们也是这么用的

83
00:03:44,000 --> 00:03:47,000
就是在网关上会做这么一个

84
00:03:47,000 --> 00:03:48,000
透明缓存

85
00:03:48,000 --> 00:03:50,000
然后到时候那些下载过的文件

86
00:03:50,000 --> 00:03:51,000
大家可以共享

87
00:03:51,000 --> 00:03:52,000
就特别是

88
00:03:52,000 --> 00:03:53,000
因为最主要痛点是

89
00:03:53,000 --> 00:03:55,000
每年一次九十月份

90
00:03:55,000 --> 00:03:57,000
苹果发布新的 OS 10

91
00:03:57,000 --> 00:03:58,000
或者 iOS 的时候

92
00:03:58,000 --> 00:04:03,000
会把那个公司的出口带宽给撑爆

93
00:04:03,000 --> 00:04:05,000
做了这个之后

94
00:04:05,000 --> 00:04:06,000
大家觉得好下载好快

95
00:04:06,000 --> 00:04:09,000
而且公司出口带宽也不怎么受影响

96
00:04:09,000 --> 00:04:12,000
那这个就是说一个在公司级别

97
00:04:12,000 --> 00:04:14,000
和长宽这种在运营商级别

98
00:04:14,000 --> 00:04:15,000
是说同样的事情

99
00:04:15,000 --> 00:04:16,000
对吧

100
00:04:16,000 --> 00:04:18,000
对问题在哪呢

101
00:04:18,000 --> 00:04:20,000
他们实现的太二了

102
00:04:20,000 --> 00:04:23,000
他们的这个缓存系统

103
00:04:23,000 --> 00:04:24,000
我就是无力吐槽了

104
00:04:24,000 --> 00:04:25,000
这样吧

105
00:04:25,000 --> 00:04:27,000
原来讲我们缓存的一个 URL

106
00:04:27,000 --> 00:04:28,000
一个是文件

107
00:04:28,000 --> 00:04:31,000
应该说是你一个 URL 对应的一个文件

108
00:04:31,000 --> 00:04:33,000
可能就是这么一个

109
00:04:33,000 --> 00:04:36,000
就是它的唯一标识服是一个完整的 URL

110
00:04:36,000 --> 00:04:37,000
对吧

111
00:04:37,000 --> 00:04:39,000
比如说我们的那个存放的那个路径

112
00:04:39,000 --> 00:04:43,000
可能是这个 ipn.li 斜杠

113
00:04:43,000 --> 00:04:45,000
然后什么假设目录是

114
00:04:45,000 --> 00:04:46,000
Colonel Panic

115
00:04:46,000 --> 00:04:47,000
然后又斜杠

116
00:04:47,000 --> 00:04:48,000
文件名是 EP

117
00:04:48,000 --> 00:04:50,000
假设是这是 27 吧

118
00:04:50,000 --> 00:04:51,000
EP 20.mp 3

119
00:04:51,000 --> 00:04:53,000
这么一个文件对吧

120
00:04:53,000 --> 00:04:54,000
对

121
00:04:54,000 --> 00:04:56,000
那你做缓存的时候是不是应该说

122
00:04:56,000 --> 00:05:00,000
我把这个 URL 完整的就是复制

123
00:05:00,000 --> 00:05:01,000
就是作为这个文件

124
00:05:01,000 --> 00:05:04,000
在这个缓存系统里面的一个标识服对吧

125
00:05:04,000 --> 00:05:08,000
就包括我们的这个域名 ipn.li

126
00:05:08,000 --> 00:05:12,000
包括它的这个路径 Colonel Panic

127
00:05:12,000 --> 00:05:15,000
包括文件名 EP 20.mp 3

128
00:05:15,000 --> 00:05:16,000
对吧

129
00:05:16,000 --> 00:05:18,000
对一个正常人类会这样实现的

130
00:05:18,000 --> 00:05:19,000
对正常人类

131
00:05:19,000 --> 00:05:22,000
不然的话你说如果正常的是这么想的

132
00:05:22,000 --> 00:05:23,000
没问题

133
00:05:23,000 --> 00:05:25,000
我们发现就根据我们这个

134
00:05:25,000 --> 00:05:28,000
我们帮助这个帮助我们热心出虫的

135
00:05:28,000 --> 00:05:30,000
这位听众给我反馈来看

136
00:05:30,000 --> 00:05:33,000
长宽的那个缓存系统

137
00:05:33,000 --> 00:05:34,000
完全不是这么弄的

138
00:05:34,000 --> 00:05:36,000
它只选择了两个信息

139
00:05:36,000 --> 00:05:37,000
文件名

140
00:05:37,000 --> 00:05:38,000
一个是域名

141
00:05:38,000 --> 00:05:39,000
一个是文件名

142
00:05:39,000 --> 00:05:42,000
它把中间的那个文件路径给漏掉了

143
00:05:42,000 --> 00:05:44,000
对它假设每一台服务器上

144
00:05:44,000 --> 00:05:46,000
所有的文件都是独一无二

145
00:05:46,000 --> 00:05:48,000
所有文件名都是独一无二的

146
00:05:48,000 --> 00:05:50,000
不管它处在哪个路径之下

147
00:05:50,000 --> 00:05:51,000
对

148
00:05:51,000 --> 00:05:52,000
然后碰巧呢

149
00:05:52,000 --> 00:05:54,000
我们这个节目的文件名

150
00:05:54,000 --> 00:05:55,000
名都比较一致

151
00:05:55,000 --> 00:05:56,000
对吧

152
00:05:56,000 --> 00:05:57,000
我们就说

153
00:05:57,000 --> 00:05:58,000
Carnalpanic

154
00:05:58,000 --> 00:05:59,000
雪干

155
00:05:59,000 --> 00:06:00,000
EP 20.mp 3

156
00:06:00,000 --> 00:06:02,000
是这个我们这一期节目的

157
00:06:02,000 --> 00:06:04,000
但是同样的对于这个

158
00:06:04,000 --> 00:06:05,000
假设 IT 功论

159
00:06:05,000 --> 00:06:06,000
它也有第 27

160
00:06:06,000 --> 00:06:07,000
那是 IT 功论雪干

161
00:06:07,000 --> 00:06:09,000
EP 20.mp 3

162
00:06:09,000 --> 00:06:10,000
然后碰巧呢

163
00:06:10,000 --> 00:06:12,000
我们又是同一个域名下面的吧

164
00:06:12,000 --> 00:06:13,000
ipn.li 下面的

165
00:06:13,000 --> 00:06:14,000
对吧

166
00:06:14,000 --> 00:06:17,000
在长宽的这个缓存代理

167
00:06:17,000 --> 00:06:18,000
这么一过呢

168
00:06:18,000 --> 00:06:19,000
就会发现

169
00:06:20,000 --> 00:06:22,000
都是 EP 20.mp 3

170
00:06:22,000 --> 00:06:23,000
这个文件

171
00:06:23,000 --> 00:06:25,000
他们肯定应该是一个吧

172
00:06:25,000 --> 00:06:27,000
然后他就默默的

173
00:06:27,000 --> 00:06:29,000
把 IT 功论的

174
00:06:29,000 --> 00:06:32,000
这个第 27 的那个音频文件

175
00:06:32,000 --> 00:06:35,000
当做了 Carnalpanic 的 27 文件

176
00:06:35,000 --> 00:06:37,000
给发回给你的那个

177
00:06:37,000 --> 00:06:38,000
那个叫什么

178
00:06:38,000 --> 00:06:39,000
你的那个浏览器

179
00:06:39,000 --> 00:06:41,000
或者是你的播客户端了

180
00:06:41,000 --> 00:06:43,000
于是就会出现我们之前很多人遇到的

181
00:06:43,000 --> 00:06:44,000
这个所谓的串台的现象

182
00:06:44,000 --> 00:06:46,000
就是你明明下的是怎么听着太一

183
00:06:46,000 --> 00:06:47,000
怎么变成了未知到

184
00:06:47,000 --> 00:06:49,000
或者是听着什么流行通信

185
00:06:49,000 --> 00:06:52,000
怎么变成了其他的什么节目

186
00:06:52,000 --> 00:06:53,000
对

187
00:06:53,000 --> 00:06:54,000
就这种诡异的事情

188
00:06:54,000 --> 00:06:57,000
我已经无力吐槽

189
00:06:57,000 --> 00:06:58,000
我看你接着说

190
00:06:58,000 --> 00:07:01,000
其实我在想说

191
00:07:01,000 --> 00:07:05,000
如果每一次串台的都可以找到

192
00:07:05,000 --> 00:07:07,000
一个相同之处

193
00:07:07,000 --> 00:07:08,000
就是每一期的

194
00:07:08,000 --> 00:07:10,000
怎么说

195
00:07:10,000 --> 00:07:11,000
番号

196
00:07:11,000 --> 00:07:13,000
是一样的话

197
00:07:13,000 --> 00:07:15,000
我们也许早一点就可以猜想出

198
00:07:15,000 --> 00:07:18,000
这个故障的原因来了

199
00:07:18,000 --> 00:07:21,000
但是之前的故障回报里面

200
00:07:21,000 --> 00:07:23,000
好像从来没有人提起过说

201
00:07:23,000 --> 00:07:25,000
比如说流行通信第 18 期

202
00:07:25,000 --> 00:07:27,000
串到内核广播的第 18 期

203
00:07:27,000 --> 00:07:29,000
都会是第 18 期

204
00:07:29,000 --> 00:07:31,000
我想可能一部分原因也是

205
00:07:31,000 --> 00:07:33,000
因为大部分人发现串台了

206
00:07:33,000 --> 00:07:37,000
就不会再仔细听说主播会是多少期

207
00:07:37,000 --> 00:07:39,000
而且也不是每一个主播都会念

208
00:07:39,000 --> 00:07:41,000
说这一次是多少期

209
00:07:41,000 --> 00:07:43,000
对我们很多节目都不会讲

210
00:07:43,000 --> 00:07:45,000
就是第多少多少期

211
00:07:45,000 --> 00:07:46,000
因为有可能比如说

212
00:07:46,000 --> 00:07:49,000
他可能预先录制了两三期这样

213
00:07:49,000 --> 00:07:50,000
然后发布的时候其实是

214
00:07:50,000 --> 00:07:53,000
在 Lawrence 在决定按发布的时间线号

215
00:07:53,000 --> 00:07:55,000
就去排这个序号

216
00:07:55,000 --> 00:07:57,000
对所以这种情况下

217
00:07:57,000 --> 00:07:58,000
你没有办法

218
00:07:58,000 --> 00:08:01,000
你就是无意中透露了一个商业经

219
00:08:01,000 --> 00:08:03,000
什么商业经

220
00:08:03,000 --> 00:08:04,000
批量生产

221
00:08:04,000 --> 00:08:07,000
然后分批分开几期播放

222
00:08:07,000 --> 00:08:08,000
还是比较少

223
00:08:08,000 --> 00:08:11,000
但是确实以前有做过这种

224
00:08:11,000 --> 00:08:13,000
就所谓的备用方案

225
00:08:13,000 --> 00:08:17,000
对反正找到这个东西的原因

226
00:08:17,000 --> 00:08:19,000
我们的这个什么

227
00:08:19,000 --> 00:08:22,000
消灭它的方法也比较简单

228
00:08:22,000 --> 00:08:24,000
我们直接在文件名前面再加个前缀

229
00:08:24,000 --> 00:08:29,000
因为既然长宽的这种 2 B 缓存系统

230
00:08:29,000 --> 00:08:34,000
竟然能不顾路径直接管文件名

231
00:08:34,000 --> 00:08:35,000
就认为是

232
00:08:35,000 --> 00:08:37,000
就同样文件名的文件

233
00:08:37,000 --> 00:08:38,000
认为是一样了

234
00:08:38,000 --> 00:08:40,000
我们把文件名改的不一样

235
00:08:40,000 --> 00:08:42,000
比如说每个节目的前加了个前缀

236
00:08:42,000 --> 00:08:44,000
比如是 Colonel Panic

237
00:08:44,000 --> 00:08:47,000
然后横杠 EP 20.2.3

238
00:08:47,000 --> 00:08:49,000
然后另外那个是 Actigone

239
00:08:49,000 --> 00:08:51,000
横杠 EP 20.3

240
00:08:51,000 --> 00:08:56,000
希望这样就可以绕过长宽的有 bug

241
00:08:56,000 --> 00:09:00,000
无力吐槽的 bug 的缓存系统吧

242
00:09:00,000 --> 00:09:01,000
对

243
00:09:01,000 --> 00:09:03,000
然后这让我想到说

244
00:09:03,000 --> 00:09:05,000
其实这个 bug 也许会造成更大的伤害

245
00:09:05,000 --> 00:09:09,000
因为我们的节目其实只是一个 podcast 而已

246
00:09:09,000 --> 00:09:11,000
最多只不过串个台而已

247
00:09:11,000 --> 00:09:16,000
但是如果相同 bug 发生在一些比较 mission critical 的软件上

248
00:09:16,000 --> 00:09:17,000
那可能

249
00:09:17,000 --> 00:09:18,000
这不用可能了

250
00:09:18,000 --> 00:09:20,000
这个事情已经确实是在发生了

251
00:09:20,000 --> 00:09:22,000
应该是在造成一定的

252
00:09:22,000 --> 00:09:26,000
已经是出于这种商业恶意的行为在做了

253
00:09:26,000 --> 00:09:29,000
很简单的一个原因就是

254
00:09:29,000 --> 00:09:36,000
安卓那些应用包子可以通过一种软件下载的 APK 的形式去安装的嘛

255
00:09:36,000 --> 00:09:38,000
然后国内有很多

256
00:09:38,000 --> 00:09:40,000
国内有很多应用商店是这么搞的

257
00:09:40,000 --> 00:09:42,000
然后就有运营商

258
00:09:42,000 --> 00:09:43,000
我不说哪一家

259
00:09:43,000 --> 00:09:44,000
大家自己去猜

260
00:09:44,000 --> 00:09:46,000
当然也不是一个普遍现象

261
00:09:46,000 --> 00:09:47,000
可能个别地区吧

262
00:09:47,000 --> 00:09:48,000
对吧

263
00:09:48,000 --> 00:09:54,000
他就直接在你下载 APK 这个过程中给你劫持了

264
00:09:54,000 --> 00:09:57,000
你本来要下一个 A 的应用

265
00:09:57,000 --> 00:09:59,000
他给你劫持成同类的 B 的

266
00:10:01,000 --> 00:10:03,000
然后你作为一个消费者

267
00:10:03,000 --> 00:10:04,000
你下载回来看

268
00:10:04,000 --> 00:10:05,000
咦 怎么回事

269
00:10:05,000 --> 00:10:06,000
我明明下的是

270
00:10:06,000 --> 00:10:07,000
本来是 A 应用的

271
00:10:07,000 --> 00:10:09,000
怎么变成了 B 应用的这个东西

272
00:10:09,000 --> 00:10:11,000
那你觉得是哪里的问题呢

273
00:10:11,000 --> 00:10:12,000
对

274
00:10:12,000 --> 00:10:15,000
如果你不具备这种基础的网络支持

275
00:10:15,000 --> 00:10:17,000
你不具备像上次我们热心听众的这个问题呢

276
00:10:17,000 --> 00:10:18,000
你不具备像上次我们热心听众的这个问题呢

277
00:10:18,000 --> 00:10:19,000
你不具备像上次我们热心听众的这个问题呢

278
00:10:19,000 --> 00:10:20,000
这种桃根问题的这种精神

279
00:10:20,000 --> 00:10:21,000
你想诶

280
00:10:21,000 --> 00:10:22,000
可能是不是你这个应用商店有问题啊

281
00:10:22,000 --> 00:10:23,000
可能是不是你这个应用商店有问题啊

282
00:10:23,000 --> 00:10:24,000
还是怎么样

283
00:10:24,000 --> 00:10:25,000
对吧

284
00:10:25,000 --> 00:10:26,000
对

285
00:10:26,000 --> 00:10:27,000
所以呢

286
00:10:27,000 --> 00:10:28,000
这件事情说到底

287
00:10:28,000 --> 00:10:29,000
技术的解决方案也是有的

288
00:10:29,000 --> 00:10:30,000
技术的解决方案也是有的

289
00:10:30,000 --> 00:10:31,000
那就是全面使用那个 HTTPs

290
00:10:31,000 --> 00:10:32,000
那就是全面使用那个 HTTPs

291
00:10:32,000 --> 00:10:33,000
那就是全面使用那个 HTTPs

292
00:10:33,000 --> 00:10:34,000
就是加密的连接嘛

293
00:10:34,000 --> 00:10:35,000
加密连接有个好处

294
00:10:35,000 --> 00:10:36,000
就是中间那个缓存

295
00:10:36,000 --> 00:10:37,000
它是没有办法去做手脚的

296
00:10:37,000 --> 00:10:38,000
它是没有办法去做手脚的

297
00:10:38,000 --> 00:10:39,000
它是没有办法去做手脚的

298
00:10:39,000 --> 00:10:40,000
因为你做手脚就会被那个报错

299
00:10:40,000 --> 00:10:41,000
因为你做手脚就会被那个报错

300
00:10:41,000 --> 00:10:42,000
啊

301
00:10:42,000 --> 00:10:43,000
至少我希望如此

302
00:10:43,000 --> 00:10:44,000
啊

303
00:10:44,000 --> 00:10:45,000
但是呢

304
00:10:45,000 --> 00:10:46,000
但是呢

305
00:10:46,000 --> 00:10:47,000
这就会有一点点问题

306
00:10:47,000 --> 00:10:48,000
这就会有一点点问题

307
00:10:48,000 --> 00:10:49,000
就假设比如说

308
00:10:49,000 --> 00:10:50,000
因为如果用加密连接的话

309
00:10:50,000 --> 00:10:51,000
因为如果用加密连接的话

310
00:10:51,000 --> 00:10:52,000
就长宽那种代理缓存就没办法用了嘛

311
00:10:52,000 --> 00:10:53,000
就长宽那种代理缓存就没办法用了嘛

312
00:10:53,000 --> 00:10:54,000
就长宽那种代理缓存就没办法用了嘛

313
00:10:54,000 --> 00:10:55,000
那假设你是长宽的用户

314
00:10:55,000 --> 00:10:56,000
那假设你是长宽的用户

315
00:10:56,000 --> 00:10:57,000
你那个

316
00:10:57,000 --> 00:10:59,000
假设你有 100 个长宽的用户

317
00:10:59,000 --> 00:11:02,000
这 100 个人每次都要从长宽

318
00:11:02,000 --> 00:11:06,000
这 100 个用户都要从原始的出口

319
00:11:06,000 --> 00:11:08,000
下载这么一个比较大的文件

320
00:11:08,000 --> 00:11:10,000
那么如果大家都碰巧

321
00:11:10,000 --> 00:11:11,000
就在同一个时间下载的话

322
00:11:11,000 --> 00:11:14,000
可能就会把长宽的出口

323
00:11:14,000 --> 00:11:15,000
大家给称保

324
00:11:15,000 --> 00:11:18,000
所以其实你发现说到这里

325
00:11:18,000 --> 00:11:23,000
就是在安全隐私和这个效率上面

326
00:11:23,000 --> 00:11:25,000
之间是有一些矛盾的

327
00:11:25,000 --> 00:11:26,000
怎么去取舍

328
00:11:26,000 --> 00:11:30,000
我觉得过去我们通常觉得说

329
00:11:30,000 --> 00:11:31,000
效率先嘛

330
00:11:31,000 --> 00:11:32,000
那安全隐私那些

331
00:11:32,000 --> 00:11:35,000
反正我又不在乎有什么问题呢

332
00:11:35,000 --> 00:11:36,000
但是其实今天

333
00:11:36,000 --> 00:11:39,000
以今天这种情况来看

334
00:11:39,000 --> 00:11:41,000
就什么运营商劫持啊

335
00:11:41,000 --> 00:11:42,000
还有各种神仙

336
00:11:42,000 --> 00:11:46,000
在搞那种灰色甚至黑色的

337
00:11:46,000 --> 00:11:48,000
利益的勾当的时候

338
00:11:48,000 --> 00:11:51,000
我们甚至有我们可能是不是

339
00:11:51,000 --> 00:11:53,000
就不得不牺牲一些效率

340
00:11:53,000 --> 00:11:55,000
下载慢去选择

341
00:11:55,000 --> 00:11:56,000
那我至少保证

342
00:11:56,000 --> 00:11:57,000
我们下载的东西会来是可靠的

343
00:11:57,000 --> 00:11:58,000
对吧

344
00:11:58,000 --> 00:11:59,000
对

345
00:11:59,000 --> 00:12:00,000
呃

346
00:12:00,000 --> 00:12:01,000
是啊

347
00:12:01,000 --> 00:12:03,000
反正最无论如何

348
00:12:03,000 --> 00:12:04,000
我们还是要在这边感谢

349
00:12:04,000 --> 00:12:08,000
这个这位帮我们找到这个 bug 的听众

350
00:12:08,000 --> 00:12:11,000
他叫做 Linz

351
00:12:11,000 --> 00:12:13,000
非常感谢

352
00:12:13,000 --> 00:12:14,000
对啊

353
00:12:14,000 --> 00:12:16,000
还还要感谢另外一位是在那个

354
00:12:16,000 --> 00:12:17,000
啊

355
00:12:17,000 --> 00:12:20,000
V 2 EX 上面我们每期节目的那个文章上面

356
00:12:20,000 --> 00:12:22,000
他也另外那位朋友也帮我们做了

357
00:12:22,000 --> 00:12:23,000
这个同样的事情

358
00:12:23,000 --> 00:12:25,000
非常感谢大家

359
00:12:25,000 --> 00:12:25,000
是啊

360
00:12:26,000 --> 00:12:27,000
嗯

361
00:12:27,000 --> 00:12:30,000
接下来一条 follow up 就是

362
00:12:30,000 --> 00:12:35,000
我上一期节目里面提到那个莫尔斯玛的 app

363
00:12:35,000 --> 00:12:36,000
嗯

364
00:12:36,000 --> 00:12:37,000
这个如果大家忘记了

365
00:12:37,000 --> 00:12:39,000
我们这里先描述一下啊

366
00:12:39,000 --> 00:12:46,000
我我我上次让吴涛去捣鼓一下一个在 apple watch 上跑的原生的

367
00:12:46,000 --> 00:12:50,000
通过莫尔斯玛来发送信息的一个应用

368
00:12:50,000 --> 00:12:51,000
所以后来怎么样了

369
00:12:51,000 --> 00:12:53,000
嗯

370
00:12:53,000 --> 00:12:56,000
其实原因也就是

371
00:12:56,000 --> 00:12:57,000
就是

372
00:12:57,000 --> 00:13:01,000
即便在新发布的 watchOS 上面

373
00:13:01,000 --> 00:13:02,000
啊

374
00:13:02,000 --> 00:13:06,000
苹果提供的这一堆空间还是有

375
00:13:06,000 --> 00:13:07,000
啊

376
00:13:07,000 --> 00:13:10,000
还是只支持非常简单的实践模型

377
00:13:10,000 --> 00:13:11,000
就是比如说

378
00:13:11,000 --> 00:13:13,000
你可以在里面放一个 button

379
00:13:13,000 --> 00:13:14,000
嗯

380
00:13:14,000 --> 00:13:15,000
但是你只

381
00:13:15,000 --> 00:13:17,000
你放了 button 之后

382
00:13:17,000 --> 00:13:22,000
你对他做的事情就仅有探测他被按下了一次

383
00:13:22,000 --> 00:13:24,000
这个 action

384
00:13:24,000 --> 00:13:25,000
这个 event

385
00:13:25,000 --> 00:13:26,000
ok

386
00:13:26,000 --> 00:13:28,000
就是说啊

387
00:13:28,000 --> 00:13:31,000
我的手指碰到了 button 按下去了

388
00:13:31,000 --> 00:13:32,000
这是一个 event

389
00:13:32,000 --> 00:13:34,000
或者是我的手指提起来啊

390
00:13:34,000 --> 00:13:37,000
从 button 上面移开了这个 event

391
00:13:37,000 --> 00:13:39,000
就是相当于啊

392
00:13:39,000 --> 00:13:42,000
如果你搞过 iOS 编程的话

393
00:13:42,000 --> 00:13:48,000
就相当于 touch start 和 touch end

394
00:13:48,000 --> 00:13:49,000
嗯

395
00:13:49,000 --> 00:13:50,000
这两个事件

396
00:13:50,000 --> 00:13:53,000
还是 touch leave inside 这两个事件

397
00:13:53,000 --> 00:13:54,000
对他唯一能做的就是哦

398
00:13:54,000 --> 00:13:55,000
这个按钮被按下了一次

399
00:13:55,000 --> 00:13:58,000
但是没有办法判断这个按钮把按下的长短

400
00:13:58,000 --> 00:14:00,000
所以这样一来

401
00:14:00,000 --> 00:14:03,000
你想要像那些比较

402
00:14:03,000 --> 00:14:04,000
嗯

403
00:14:04,000 --> 00:14:05,000
嗯

404
00:14:05,000 --> 00:14:14,000
熟练一点的电报员那样通过快速敲击表盘来发点和滑的

405
00:14:14,000 --> 00:14:15,000
呃希望的泡汤

406
00:14:15,000 --> 00:14:20,000
因为每一个按键被按下去的过程实际上是非常缓慢的

407
00:14:20,000 --> 00:14:23,000
而且我相信苹果为了防止说

408
00:14:23,000 --> 00:14:24,000
嗯

409
00:14:24,000 --> 00:14:26,000
嗯

410
00:14:26,000 --> 00:14:32,000
一个人误触一个快一个一个按键两次

411
00:14:32,000 --> 00:14:34,000
在短时间之内误触按键两次

412
00:14:34,000 --> 00:14:37,000
他故意放了一段怎么说

413
00:14:37,000 --> 00:14:38,000
将职期在那边

414
00:14:38,000 --> 00:14:41,000
就是你我可能想说补应期

415
00:14:41,000 --> 00:14:43,000
哈哈哈

416
00:14:43,000 --> 00:14:44,000
所以在这段时间之内

417
00:14:44,000 --> 00:14:47,000
你是你怎么按这个键都没有反应

418
00:14:47,000 --> 00:14:49,000
嗯

419
00:14:49,000 --> 00:14:52,000
所以从这个角度讲啊

420
00:14:52,000 --> 00:14:53,000
原本的设想是就是这个

421
00:14:53,000 --> 00:14:55,000
设想是就已经做到了

422
00:14:55,000 --> 00:14:59,000
然后我现在临时的方案是放两个按键的上面一个代表点一个代表滑

423
00:14:59,000 --> 00:15:01,000
但是

424
00:15:01,000 --> 00:15:03,000
最大力量是很明显

425
00:15:03,000 --> 00:15:04,000
对这样不酷呀

426
00:15:04,000 --> 00:15:05,000
而且

427
00:15:05,000 --> 00:15:06,000
哈哈哈

428
00:15:06,000 --> 00:15:07,000
人就是比较慢

429
00:15:07,000 --> 00:15:09,000
然后其实我

430
00:15:09,000 --> 00:15:10,000
我打个岔问一个事儿

431
00:15:10,000 --> 00:15:13,000
哈就是他那个表上不是还有两个物理的东西吗

432
00:15:13,000 --> 00:15:16,000
一个是那个叫做数字表冠的东西

433
00:15:16,000 --> 00:15:18,000
还有一个就是旁边有个数字表冠下面有个按钮嘛

434
00:15:18,000 --> 00:15:21,000
那两个是可以通过 API 访问的到的

435
00:15:21,000 --> 00:15:22,000
他的操作的吗

436
00:15:22,000 --> 00:15:24,000
呃

437
00:15:24,000 --> 00:15:27,000
并不直接访问并不能直接访问到

438
00:15:27,000 --> 00:15:29,000
首先朋友的那个键啊

439
00:15:29,000 --> 00:15:31,000
那件的官方名字叫什么

440
00:15:31,000 --> 00:15:32,000
啊

441
00:15:32,000 --> 00:15:33,000
Francky

442
00:15:33,000 --> 00:15:34,000
哈哈哈

443
00:15:34,000 --> 00:15:38,000
我让那个官方反正就就反正我知道上面那个叫 digital crown

444
00:15:38,000 --> 00:15:41,000
下面那个对下面的可能就叫 side button

445
00:15:41,000 --> 00:15:42,000
如果没记错

446
00:15:42,000 --> 00:15:48,000
反正就是按钮对这个按钮的按点就是按一下是可以在你的应用里面探测得到了吗

447
00:15:48,000 --> 00:15:49,000
对

448
00:15:49,000 --> 00:15:52,000
然后这两个键 side button 是没有的

449
00:15:52,000 --> 00:15:54,000
没有办法直接编程获得的

450
00:15:54,000 --> 00:16:02,000
然后 digital crown 也不能直接编程说呃此时发生了一个 digital crown 被转动的事件

451
00:16:02,000 --> 00:16:08,000
而只能通过一个叫做如果没记错的话应该叫 interface picker

452
00:16:09,000 --> 00:16:10,000
的

453
00:16:10,000 --> 00:16:11,000
嗯

454
00:16:11,000 --> 00:16:14,000
空间来接来获取它

455
00:16:14,000 --> 00:16:18,000
就是哪怕是在这个所谓 watchOS 2 也是这样吗

456
00:16:18,000 --> 00:16:20,000
就新版对哪怕在 watchOS 2 里面也是这样

457
00:16:20,000 --> 00:16:22,000
而且好像是只有这个

458
00:16:22,000 --> 00:16:25,000
在 watchOS 2 里面才可以使用这个空间

459
00:16:25,000 --> 00:16:37,000
就是说之前在目前的版本的 Xcode 6 里面是没有办法去以任何方法获得嗯这个 digital crown 被转动的时间

460
00:16:37,000 --> 00:16:40,000
然后在 watchOS 2 里面你可以放一个 picker

461
00:16:40,000 --> 00:16:51,000
然后这个 picker 的呃的外观其实就像啊比如说那个键就是监测你的 activity 的那个 app 里面你可以

462
00:16:51,000 --> 00:16:53,000
啊

463
00:16:53,000 --> 00:16:54,000
通过

464
00:16:54,000 --> 00:16:58,000
指头在表盘上下滑动或者是通过 digital crown 来

465
00:16:59,000 --> 00:17:02,000
转动去选择一个列表之中的某一项

466
00:17:02,000 --> 00:17:03,000
嗯

467
00:17:03,000 --> 00:17:04,000
然后这个 slider

468
00:17:04,000 --> 00:17:06,000
然后这个 picker 会发生一个

469
00:17:07,000 --> 00:17:10,000
呃 selected item changed

470
00:17:10,000 --> 00:17:11,000
怎么样这样一个 event

471
00:17:11,000 --> 00:17:14,000
所以你可以通过这个来间接的判断说哦

472
00:17:15,000 --> 00:17:16,000
cron 现在被转动

473
00:17:16,000 --> 00:17:17,000
啊

474
00:17:17,000 --> 00:17:18,000
那也仅此而已

475
00:17:18,000 --> 00:17:19,000
对

476
00:17:19,000 --> 00:17:20,000
还有一个

477
00:17:20,000 --> 00:17:22,000
就是我提的一个建议

478
00:17:22,000 --> 00:17:23,000
后来好像证明也是不行的

479
00:17:23,000 --> 00:17:29,000
就是说他那个表的那个嗯触屏不是可以探测压感吗

480
00:17:30,000 --> 00:17:35,000
就可以通过什么 force touch 就是用力的压和不用力的压区分 0 和 1

481
00:17:35,000 --> 00:17:37,000
这个后来是一个什么样的情况

482
00:17:37,000 --> 00:17:38,000
事实上也是不行的

483
00:17:38,000 --> 00:17:50,000
因为 force touch 这个动作被啊 sdk 限制为啊呼出快捷菜单这么一个呼出

484
00:17:50,000 --> 00:17:51,000
context menu 这么一个动作

485
00:17:51,000 --> 00:17:56,000
所以如果你要呃处发处理这个事件的话呢

486
00:17:56,000 --> 00:18:00,000
那你唯一能做的就是把它连到一个啊菜单上面

487
00:18:00,000 --> 00:18:01,000
嗯

488
00:18:01,000 --> 00:18:02,000
嗯

489
00:18:02,000 --> 00:18:03,000
别的不能做了

490
00:18:03,000 --> 00:18:05,000
然后这个菜单出来

491
00:18:05,000 --> 00:18:08,000
比如说上面有一个唯一一个按键就是点一下

492
00:18:08,000 --> 00:18:10,000
就是就输入 1 不可以吗

493
00:18:10,000 --> 00:18:11,000
啊

494
00:18:11,000 --> 00:18:15,000
我觉得这个操作还是非常的奇怪

495
00:18:15,000 --> 00:18:16,000
不够帅是吧

496
00:18:16,000 --> 00:18:17,000
对

497
00:18:17,000 --> 00:18:19,000
那他其实还不如放两个按钮

498
00:18:19,000 --> 00:18:20,000
嗯

499
00:18:20,000 --> 00:18:24,000
因为你无论如何在长按之下还要点一下就非常的嗯

500
00:18:24,000 --> 00:18:29,000
关键是我觉得他那个 force touch 的那个力度很不好控制

501
00:18:29,000 --> 00:18:30,000
没错

502
00:18:30,000 --> 00:18:36,000
而且我觉得苹果有点对于上下滚动太敏感了

503
00:18:36,000 --> 00:18:38,000
苹果表对于上下的滚动太敏感了

504
00:18:38,000 --> 00:18:40,000
就是我不知道你有没有这个感觉

505
00:18:40,000 --> 00:18:41,000
但是你在走路的时候

506
00:18:41,000 --> 00:18:42,000
嗯

507
00:18:42,000 --> 00:18:45,000
如果你试图呃按一个按键

508
00:18:45,000 --> 00:18:46,000
嗯

509
00:18:46,000 --> 00:18:49,000
你会发现这个表会更倾向于转动的感觉

510
00:18:49,000 --> 00:18:50,000
嗯

511
00:18:50,000 --> 00:18:54,000
上下滑动他的屏幕而不是让你把这个按键按下去

512
00:18:54,000 --> 00:18:56,000
尤其是这个屏幕可以滑动的时候

513
00:18:56,000 --> 00:18:59,000
比如说回复一个人的短信好

514
00:18:59,000 --> 00:19:02,000
你一边走路一边抬起手腕来看到一个人的短信

515
00:19:02,000 --> 00:19:07,000
然后你想要回复他回复回复那一下就很难点了

516
00:19:07,000 --> 00:19:09,000
因为对这里有一个问题

517
00:19:09,000 --> 00:19:13,000
就就刚才你说的两个事件一个 touch start 和 touch end 的嘛

518
00:19:13,000 --> 00:19:15,000
他们之间是有一个间隙的

519
00:19:15,000 --> 00:19:17,000
然后你你在运动中你这个那个肯定是放下的嘛

520
00:19:17,000 --> 00:19:22,000
那个触摸的手指

521
00:19:22,000 --> 00:19:23,000
对

522
00:19:23,000 --> 00:19:25,000
然后这样一来你在

523
00:19:25,000 --> 00:19:26,000
对

524
00:19:26,000 --> 00:19:28,000
这样一来你在啊

525
00:19:28,000 --> 00:19:31,000
选择回复的时候就已经很吃力了

526
00:19:31,000 --> 00:19:35,000
你可能需要呃把食指按在手腕上

527
00:19:35,000 --> 00:19:37,000
然后用中指去点那个回复键

528
00:19:37,000 --> 00:19:41,000
因为这样可以减少两只手之间的相对移动

529
00:19:41,000 --> 00:19:46,000
然后等你呼呼出了那个一堆灵呃短暂的呃

530
00:19:46,000 --> 00:19:49,000
快捷回复内容的时候

531
00:19:49,000 --> 00:19:56,000
可能你又要很小心的去按其中的某一个不然他会他又会出一位滑动

532
00:19:56,000 --> 00:19:59,000
对这个是挺糟糕的一件事情

533
00:19:59,000 --> 00:20:01,000
可能还有他们还得再微调一下

534
00:20:01,000 --> 00:20:11,000
因为毕竟啊这个这么小的表盘上的这种触呃触摸的操作和手机大屏幕的触摸操作的情况还是有点不同的

535
00:20:11,000 --> 00:20:13,000
怎么去去制定一些边界的条件

536
00:20:13,000 --> 00:20:15,000
我觉得还是挺怎么说呢

537
00:20:15,000 --> 00:20:17,000
挺麻烦一个事儿

538
00:20:17,000 --> 00:20:18,000
对

539
00:20:18,000 --> 00:20:25,000
然后我希望在接下来的几代 ls 啊把 watch os 里面可以提供更多的事件

540
00:20:25,000 --> 00:20:27,000
以及更多的 API 支持

541
00:20:27,000 --> 00:20:36,000
比如说现在好像没有办法去呃检测他的那个陀螺仪或者是血压计都没有办法

542
00:20:36,000 --> 00:20:39,000
就只能做一些非常简单的功能

543
00:20:39,000 --> 00:20:44,000
然后所有动画都必须通过图片来实现

544
00:20:44,000 --> 00:20:46,000
就是如果你想要显示一个动画

545
00:20:46,000 --> 00:20:51,000
你得预先把每一帧都存成一个存成一幅照片

546
00:20:51,000 --> 00:20:55,000
然后就是连着放放那个幻灯片吧

547
00:20:55,000 --> 00:20:57,000
对然后连着放幻灯片

548
00:20:57,000 --> 00:21:05,000
然后苹果的这次 WWDC 上面还劝告开发者说注意图片的尺寸

549
00:21:05,000 --> 00:21:12,000
呃因为在 ls 呃在 watch os 一代里面图片每次都要传到手表上

550
00:21:12,000 --> 00:21:13,000
我拿压力了

551
00:21:13,000 --> 00:21:17,000
而在 watch os 对而在 watch os 二上面

552
00:21:17,000 --> 00:21:20,000
呃至少在第一次安装的时候

553
00:21:20,000 --> 00:21:23,000
这个传输过程也是比较耗时的

554
00:21:23,000 --> 00:21:26,000
并且如果你图片太大的话

555
00:21:26,000 --> 00:21:28,000
他存在手表上也是很占地吧

556
00:21:28,000 --> 00:21:33,000
对好像水宝有个内置有个什么 8 GB 的存储空间吧

557
00:21:33,000 --> 00:21:34,000
总共对

558
00:21:34,000 --> 00:21:39,000
然后其中大概有 3 G 一倍啊超级总用了

559
00:21:39,000 --> 00:21:40,000
嗯

560
00:21:40,000 --> 00:21:41,000
嗯

561
00:21:41,000 --> 00:21:42,000
嗯

562
00:21:42,000 --> 00:21:43,000
嗯

566
00:23:13,000 --> 00:23:14,000
嗯

567
00:23:14,000 --> 00:23:15,000
嗯

568
00:23:15,000 --> 00:23:16,000
嗯

569
00:23:16,000 --> 00:23:17,000
呃

570
00:23:17,000 --> 00:23:18,000
对

571
00:23:18,000 --> 00:23:21,000
这个是也了

572
00:23:21,000 --> 00:23:31,000
是

573
00:23:31,000 --> 00:23:31,000
啊

574
00:23:31,000 --> 00:23:33,000
那你有 standards 啊

575
00:23:33,000 --> 00:23:34,000
啊

576
00:23:34,000 --> 00:23:35,000
我也是

577
00:23:35,000 --> 00:23:36,000
不好意思

578
00:23:36,000 --> 00:23:37,000
呃

579
00:23:37,000 --> 00:23:38,000
呃

580
00:23:38,000 --> 00:23:39,000
里面也这是一个 A.I 的项目

581
00:23:39,000 --> 00:23:40,000
嗯

582
00:23:40,000 --> 00:23:41,000
是我

583
00:23:41,000 --> 00:23:42,000
因为 Это

584
00:23:42,000 --> 00:23:44,000
好吧

585
00:23:44,000 --> 00:23:47,000
那个我们下面念几封

586
00:23:47,000 --> 00:23:48,000
这个听众来信好吧

587
00:23:48,000 --> 00:23:51,000
对上一期的节目

588
00:23:51,000 --> 00:23:52,000
在微博上面

589
00:23:52,000 --> 00:23:54,000
没有太多人评论

590
00:23:54,000 --> 00:23:56,000
但是我们却收到了

591
00:23:56,000 --> 00:23:59,000
好几封又长又热情

592
00:23:59,000 --> 00:23:59,000
读者来信

593
00:23:59,000 --> 00:24:03,000
先念第一位吧

594
00:24:03,000 --> 00:24:06,000
这个是叫陈一鸣

595
00:24:06,000 --> 00:24:08,000
就直拼不知道怎么写

596
00:24:08,000 --> 00:24:10,000
陈一鸣的来信

597
00:24:10,000 --> 00:24:11,000
对

598
00:24:11,000 --> 00:24:12,000
你们好

599
00:24:12,000 --> 00:24:14,000
听了你们这期内核恐慌

600
00:24:14,000 --> 00:24:16,000
我也想发表一下

601
00:24:16,000 --> 00:24:17,000
自己对测试的看法

602
00:24:17,000 --> 00:24:20,000
第一次接触测试

603
00:24:20,000 --> 00:24:21,000
可以说是在高中

604
00:24:21,000 --> 00:24:22,000
算法竞赛的时候

605
00:24:22,000 --> 00:24:23,000
哇好厉害

606
00:24:23,000 --> 00:24:24,000
高中就算法竞赛

607
00:24:24,000 --> 00:24:27,000
当时老师特地请了

608
00:24:27,000 --> 00:24:29,000
ACM 大牛来学校指导我们

609
00:24:29,000 --> 00:24:31,000
在休息的时候

610
00:24:31,000 --> 00:24:32,000
就顺便教我们

611
00:24:32,000 --> 00:24:35,000
如何写对拍程序

612
00:24:35,000 --> 00:24:36,000
什么是对拍程序

613
00:24:36,000 --> 00:24:39,000
对拍程序就是

614
00:24:39,000 --> 00:24:40,000
就像一个

615
00:24:40,000 --> 00:24:44,000
那个节奏器吧

616
00:24:44,000 --> 00:24:44,000
我很理解

617
00:24:44,000 --> 00:24:46,000
就是你要和他对

618
00:24:46,000 --> 00:24:48,000
对对你的拍子

619
00:24:48,000 --> 00:24:49,000
OK

620
00:24:49,000 --> 00:24:51,000
这这点这里有这个

621
00:24:51,000 --> 00:24:52,000
就是有三个步骤

622
00:24:52,000 --> 00:24:54,000
第一第一步是

623
00:24:54,000 --> 00:24:56,000
先写一个低效的程序

624
00:24:56,000 --> 00:24:57,000
保证这个程序的正确性

625
00:24:57,000 --> 00:24:59,000
然后第二步是

626
00:24:59,000 --> 00:25:00,000
再写一个随机生成

627
00:25:00,000 --> 00:25:01,000
输入数据的程序

628
00:25:01,000 --> 00:25:04,000
并保证生成各种边界条件

629
00:25:04,000 --> 00:25:05,000
第三就是最后

630
00:25:05,000 --> 00:25:08,000
写自己打算提交的最终代码

631
00:25:08,000 --> 00:25:09,000
并用以上两个程序

632
00:25:09,000 --> 00:25:10,000
来保证该代码的

633
00:25:10,000 --> 00:25:11,000
正确性

634
00:25:11,000 --> 00:25:14,000
当时还是在 windows 下

635
00:25:14,000 --> 00:25:16,000
用命令行提示符写脚本

636
00:25:16,000 --> 00:25:17,000
对输出进行对比

637
00:25:17,000 --> 00:25:19,000
因此印象深刻

638
00:25:19,000 --> 00:25:20,000
但学了之后

639
00:25:20,000 --> 00:25:21,000
在比赛中

640
00:25:21,000 --> 00:25:22,000
真正用到的人很少

641
00:25:22,000 --> 00:25:24,000
又或者是我没有进到

642
00:25:24,000 --> 00:25:25,000
审计上的比赛

643
00:25:25,000 --> 00:25:26,000
没接触到

644
00:25:26,000 --> 00:25:27,000
这是括号里面的一话

645
00:25:27,000 --> 00:25:28,000
现在看来

646
00:25:28,000 --> 00:25:29,000
当时学的测试方法

647
00:25:29,000 --> 00:25:31,000
已经很标准有效了

648
00:25:31,000 --> 00:25:32,000
然而实践起来

649
00:25:32,000 --> 00:25:33,000
却也难上架了

650
00:25:33,000 --> 00:25:34,000
难

651
00:25:34,000 --> 00:25:36,000
写最终代码都来不及了

652
00:25:36,000 --> 00:25:38,000
哪还有时间写低效程序

653
00:25:38,000 --> 00:25:39,000
和更麻烦的

654
00:25:39,000 --> 00:25:40,000
数据生成脚本呢

655
00:25:40,000 --> 00:25:41,000
也因此

656
00:25:41,000 --> 00:25:44,000
我对测试并没有什么好印象

657
00:25:44,000 --> 00:25:46,000
但是这学期

658
00:25:46,000 --> 00:25:48,000
我在一个课程的这个 project

659
00:25:48,000 --> 00:25:50,000
用的是 python 和 django 中

660
00:25:50,000 --> 00:25:52,000
第一次尝试了 tdd

661
00:25:52,000 --> 00:25:53,000
就像什么叫

662
00:25:53,000 --> 00:25:54,000
test driven development

663
00:25:54,000 --> 00:25:56,000
测试驱动的开发

664
00:25:56,000 --> 00:25:59,000
对测试大大改观

665
00:25:59,000 --> 00:26:00,000
发现测试并没有之前

666
00:26:00,000 --> 00:26:02,000
想象的那么无用

667
00:26:02,000 --> 00:26:04,000
也比二位在节目中

668
00:26:04,000 --> 00:26:06,000
说的重要得多

669
00:26:06,000 --> 00:26:08,000
我在节目中

670
00:26:08,000 --> 00:26:09,000
没有说它不重要

671
00:26:09,000 --> 00:26:10,000
我只是不喜欢

672
00:26:10,000 --> 00:26:12,000
但从来没有说过它不重要

673
00:26:12,000 --> 00:26:13,000
对对对

674
00:26:13,000 --> 00:26:15,000
我们都一致认可测试的重要性

675
00:26:15,000 --> 00:26:16,000
有总是比没有好的

676
00:26:16,000 --> 00:26:18,000
只是我们都不太喜欢写测试

677
00:26:18,000 --> 00:26:18,000
哈哈

678
00:26:18,000 --> 00:26:19,000
ok

679
00:26:19,000 --> 00:26:21,000
他说这个接着讲

680
00:26:21,000 --> 00:26:23,000
他说测试最重要是帮助我们写出

681
00:26:23,000 --> 00:26:25,000
易于测试的代码

682
00:26:25,000 --> 00:26:26,000
单元

683
00:26:26,000 --> 00:26:27,000
单元测试的定义

684
00:26:27,000 --> 00:26:29,000
决定了程序的每一个小功能

685
00:26:29,000 --> 00:26:31,000
都要有一个接口

686
00:26:31,000 --> 00:26:33,000
供测试代码调用

687
00:26:33,000 --> 00:26:34,000
而先写单元测试

688
00:26:34,000 --> 00:26:37,000
这样我们先对这个接口有一个设想

689
00:26:37,000 --> 00:26:39,000
帮助我们降低项目的吻合度

690
00:26:39,000 --> 00:26:40,000
提高内置度

691
00:26:40,000 --> 00:26:42,000
让我们更加有实际的运行

692
00:26:42,000 --> 00:26:44,000
当然有一个架构的过程也能办到

693
00:26:44,000 --> 00:26:45,000
但小一个小团队

694
00:26:45,000 --> 00:26:47,000
或者一个需要快速开发的项目

695
00:26:47,000 --> 00:26:49,000
往往没有那么多时间去架构

696
00:26:49,000 --> 00:26:52,000
测试能在架构上提供帮助

697
00:26:52,000 --> 00:26:54,000
这一点我觉得有点意思

698
00:26:54,000 --> 00:26:55,000
就是说

699
00:26:55,000 --> 00:26:56,000
呃

700
00:26:56,000 --> 00:26:58,000
写单元测试能够帮助我们

701
00:26:58,000 --> 00:27:01,000
所谓做一个就是最小颗粒度的

702
00:27:01,000 --> 00:27:03,000
独立运行的一段代码

703
00:27:03,000 --> 00:27:04,000
对吧

704
00:27:04,000 --> 00:27:05,000
对那这样的话

705
00:27:05,000 --> 00:27:07,000
呃就可以至少说

706
00:27:07,000 --> 00:27:09,000
我们不会写一个

707
00:27:09,000 --> 00:27:10,000
呃

708
00:27:10,000 --> 00:27:12,000
五页都翻不完的单一函数

709
00:27:12,000 --> 00:27:13,000
对吧

710
00:27:13,000 --> 00:27:15,000
这样就没没法测了吗

711
00:27:15,000 --> 00:27:17,000
所以从这个角度上

712
00:27:17,000 --> 00:27:18,000
我觉得还是有有一定好处的

713
00:27:18,000 --> 00:27:21,000
就起码在对你带这个叫什么代码的组织上

714
00:27:21,000 --> 00:27:22,000
是有一定帮助的

715
00:27:22,000 --> 00:27:23,000
对

716
00:27:23,000 --> 00:27:25,000
你每一次是其实就是一个

717
00:27:25,000 --> 00:27:27,000
对于你真正的 API 的考验

718
00:27:27,000 --> 00:27:28,000
对啊

719
00:27:28,000 --> 00:27:32,000
很多考验是如果你没有用过的话

720
00:27:32,000 --> 00:27:34,000
完全不知道自己没有办法

721
00:27:34,000 --> 00:27:36,000
通过这个考验

722
00:27:36,000 --> 00:27:39,000
所以如果一开始能把这个考验就先写出来的话

723
00:27:39,000 --> 00:27:44,000
那涉及 API 的时候其实会方便很多

724
00:27:44,000 --> 00:27:45,000
对

725
00:27:45,000 --> 00:27:47,000
呃然后接着念他这个来信啊

726
00:27:47,000 --> 00:27:49,000
然后他这里马上举了一个反例

727
00:27:49,000 --> 00:27:52,000
就是这学期我做的另一个项目

728
00:27:52,000 --> 00:27:53,000
PYQT 5

729
00:27:53,000 --> 00:27:55,000
完全没有测试

730
00:27:55,000 --> 00:27:57,000
写出来就杂乱无章

731
00:27:57,000 --> 00:27:58,000
呕吼的过激

732
00:27:58,000 --> 00:28:00,000
以至于最后自己都不想再写下去了

733
00:28:00,000 --> 00:28:03,000
当然主要是我没做好前期架构的工作

734
00:28:03,000 --> 00:28:04,000
对吧

735
00:28:04,000 --> 00:28:07,000
就其实就是有这么一个叫什么

736
00:28:07,000 --> 00:28:08,000
没有

737
00:28:08,000 --> 00:28:10,000
有纪律性的程序员

738
00:28:10,000 --> 00:28:14,000
要需要这个通过测试这种一种外部的手段

739
00:28:14,000 --> 00:28:18,000
强制你把这个代码的这个颗粒度缩的比较小

740
00:28:18,000 --> 00:28:20,000
然后每个是可以有独立逻辑

741
00:28:20,000 --> 00:28:22,000
可以独立运作了

742
00:28:22,000 --> 00:28:24,000
我不知道你写代码是怎么样子

743
00:28:24,000 --> 00:28:25,000
但我写代码的时候

744
00:28:25,000 --> 00:28:29,000
我不我不喜欢那种非常长的一段函数

745
00:28:29,000 --> 00:28:32,000
就是有有这种这种洁癖

746
00:28:32,000 --> 00:28:36,000
就是凡事都要抽象出来成一个函数

747
00:28:36,000 --> 00:28:37,000
是吧

748
00:28:37,000 --> 00:28:38,000
是吧

749
00:28:38,000 --> 00:28:42,000
我记得很早以前就在那本书上看到

750
00:28:42,000 --> 00:28:44,000
我是 pragmatical

751
00:28:44,000 --> 00:28:46,000
programmer 还没说

752
00:28:46,000 --> 00:28:50,000
每一个函数最好长度不要超过一平

753
00:28:50,000 --> 00:28:55,000
这样你不用卷动屏幕就可以看明白它是在干嘛

754
00:28:55,000 --> 00:28:56,000
没错

755
00:28:56,000 --> 00:28:58,000
基本上我也是这个习惯

756
00:28:58,000 --> 00:28:59,000
对

757
00:28:59,000 --> 00:29:01,000
当然是字号要足够大才行

758
00:29:01,000 --> 00:29:02,000
不然就是

759
00:29:02,000 --> 00:29:07,000
开 6 号字一平还是数平的你怎么办

760
00:29:07,000 --> 00:29:09,000
没有是挺痛苦的

761
00:29:09,000 --> 00:29:10,000
对

762
00:29:10,000 --> 00:29:12,000
接着念这个

763
00:29:12,000 --> 00:29:16,000
其次是在是保证在重构时不犯错

764
00:29:16,000 --> 00:29:19,000
在我的项目开发的过程短短几天时间里

765
00:29:19,000 --> 00:29:23,000
我就有好几次对大片的代码进行重构或者是优化

766
00:29:23,000 --> 00:29:25,000
如果没有测试做保障

767
00:29:25,000 --> 00:29:29,000
无法想象能在短时间内一个人完成这些工作

768
00:29:29,000 --> 00:29:33,000
使用 TDD 的感受就是对代码的每一次更改都很安心

769
00:29:33,000 --> 00:29:37,000
因为有 test 在代码错错的第一时间帮我完成的工作

770
00:29:37,000 --> 00:29:41,000
我只出而重构不犯错的另一个好处是让他维护更加方便

771
00:29:41,000 --> 00:29:43,000
只要通过测试就可以了

772
00:29:43,000 --> 00:29:46,000
这个其实怎么说呢

773
00:29:46,000 --> 00:29:50,000
这个确实是有好处的

774
00:29:50,000 --> 00:29:52,000
对回归回归测试就是做这个

775
00:29:52,000 --> 00:29:58,000
就是保证你在引入新特性或者重新架构你的程序的时候

776
00:29:58,000 --> 00:30:02,000
可以保证既有的正确的东西不会被改变

777
00:30:02,000 --> 00:30:04,000
这个基本上只有测试可以做了

778
00:30:04,000 --> 00:30:06,000
我没有办法用其他任何办法来打

779
00:30:06,000 --> 00:30:09,000
来试图达到这个目的

780
00:30:09,000 --> 00:30:12,000
都是事倍功万的

781
00:30:12,000 --> 00:30:14,000
但主要是有一点我觉得比较好奇的是

782
00:30:14,000 --> 00:30:17,000
如果他对大片代码进行了重构

783
00:30:17,000 --> 00:30:20,000
那与之对应的单元测试不要重写

784
00:30:20,000 --> 00:30:27,000
其实这是一个集成单单生机的问题

785
00:30:27,000 --> 00:30:32,000
如果一开始的单元测试写的就让你没有那么好重构的话

786
00:30:32,000 --> 00:30:34,000
那重构起来也是困难中的

787
00:30:34,000 --> 00:30:36,000
但如果你一开始单元测试写的可以

788
00:30:36,000 --> 00:30:38,000
你的颗粒足够小

789
00:30:38,000 --> 00:30:41,000
然后你的接口也保证的比较好

790
00:30:41,000 --> 00:30:46,000
基本上单元测试是在很大一部分程度上可以

791
00:30:46,000 --> 00:30:48,000
怎么说

792
00:30:48,000 --> 00:30:49,000
眼流下来

793
00:30:49,000 --> 00:30:50,000
眼用

794
00:30:50,000 --> 00:30:53,000
这本还是要回到一开始

795
00:30:53,000 --> 00:30:56,000
就是你得一开始就做一定的架构

796
00:30:56,000 --> 00:30:59,000
你不能完全一个依赖于自己的单元测试

797
00:30:59,000 --> 00:31:03,000
所以其实我理解在这么一个重构的还是有一定的

798
00:31:03,000 --> 00:31:05,000
就是两个不同的

799
00:31:06,000 --> 00:31:08,000
层次吧

800
00:31:08,000 --> 00:31:11,000
就是说一些比如说你对某一个函数的内部实现

801
00:31:11,000 --> 00:31:13,000
或者某一个就不改变接口情况下

802
00:31:13,000 --> 00:31:17,000
内部是实现了重构是完全没有问题

803
00:31:17,000 --> 00:31:18,000
就做起来非常爽

804
00:31:18,000 --> 00:31:21,000
你只要确保那些因为测试是按照接口

805
00:31:21,000 --> 00:31:22,000
单元测试按接口来做的嘛

806
00:31:22,000 --> 00:31:25,000
把那些边界条件都弄出来

807
00:31:25,000 --> 00:31:27,000
然后看一下能不能跑通

808
00:31:27,000 --> 00:31:30,000
大致上也有这个什么八九不离十的信心了

809
00:31:30,000 --> 00:31:34,000
但是如果你是连这个接口都发生了比较大的改变的重复的话

810
00:31:34,000 --> 00:31:35,000
我觉得

811
00:31:35,000 --> 00:31:37,000
你在过程中也不会爽到哪里去

812
00:31:37,000 --> 00:31:41,000
因为毕竟还是要写很多这个要重写很多单元测试的

813
00:31:41,000 --> 00:31:42,000
因为接口变了嘛

814
00:31:42,000 --> 00:31:43,000
对

815
00:31:43,000 --> 00:31:49,000
接着念下面一个测试还是形式证明

816
00:31:49,000 --> 00:31:51,000
这是个选择题

817
00:31:51,000 --> 00:31:55,000
节目中 real 提到对代码的可靠性进行形式证明更可靠

818
00:31:55,000 --> 00:31:56,000
更靠谱

819
00:31:56,000 --> 00:31:58,000
我认为这理论上没错

820
00:31:58,000 --> 00:32:00,000
但对于一个现代工程来说

821
00:32:00,000 --> 00:32:04,000
对项目的正确性进行形式证明几乎是不可能的

822
00:32:04,000 --> 00:32:05,000
因为一个大体化的方式是什么呢

823
00:32:05,000 --> 00:32:08,000
大项目很少从框架都自己搭起

824
00:32:08,000 --> 00:32:11,000
那么就无法保证使用框架的正确性

825
00:32:11,000 --> 00:32:13,000
比如万一 jango 项本身出了 bug

826
00:32:13,000 --> 00:32:17,000
或者升级后 API 变动导致程序出错

827
00:32:17,000 --> 00:32:19,000
可能我形式证明过我写的部分是对的

828
00:32:19,000 --> 00:32:23,000
但由于这些基础项目是超出我的能力范围外的

829
00:32:23,000 --> 00:32:26,000
那只能用测试来保证代码的正确性了

830
00:32:26,000 --> 00:32:28,000
这怎么说呢

831
00:32:28,000 --> 00:32:29,000
没错

832
00:32:29,000 --> 00:32:31,000
形式证明是一个很好东西

833
00:32:31,000 --> 00:32:34,000
但是我们通常你不会在

834
00:32:34,000 --> 00:32:38,000
非学院学术研究的领域里看到它

835
00:32:38,000 --> 00:32:40,000
不过当然也有一个有实践的例子

836
00:32:40,000 --> 00:32:45,000
我记得那个 windows 上不是有个那个虚拟机的那个叫做 hypervisor

837
00:32:45,000 --> 00:32:47,000
叫什么来的

838
00:32:47,000 --> 00:32:49,000
名字我忘了

839
00:32:49,000 --> 00:32:50,000
据说哈

840
00:32:50,000 --> 00:32:52,000
就是微软研究院是

841
00:32:52,000 --> 00:32:55,000
是对那个 hypervisor 代码进行的形式证明的

842
00:32:55,000 --> 00:32:57,000
但是这一覆盖度有多少我不太清楚

843
00:32:57,000 --> 00:32:59,000
但这我还是蛮吃惊

844
00:32:59,000 --> 00:33:01,000
因为那个代码量还是比较大嘛

845
00:33:01,000 --> 00:33:05,000
微软研究院不差人不差钱

846
00:33:05,000 --> 00:33:06,000
对他们有时间

847
00:33:06,000 --> 00:33:08,000
有的是有的是有的是人

848
00:33:08,000 --> 00:33:09,000
有的是时间

849
00:33:09,000 --> 00:33:12,000
多少个博士生砸进去在搞这种事情

850
00:33:12,000 --> 00:33:14,000
但怎么说呢

851
00:33:14,000 --> 00:33:16,000
我觉得现在事情这样子

852
00:33:16,000 --> 00:33:20,000
就是说需要形式证明可靠性的东西

853
00:33:20,000 --> 00:33:22,000
可能什么要求比较高的

854
00:33:22,000 --> 00:33:26,000
一个是刚才我讲的那个怎么想的虚拟机的这个 hypervisor

855
00:33:26,000 --> 00:33:30,000
另外一些就是之前我们提到的就是 mission critical 的东西

856
00:33:30,000 --> 00:33:34,000
什么 nasa 的发好发火箭的代码

857
00:33:34,000 --> 00:33:37,000
什么 tesla 的控制控制汽车行驶的代码

858
00:33:37,000 --> 00:33:39,000
对那些是需要经过这个东西来做的

859
00:33:39,000 --> 00:33:43,000
还有一些事情是我们觉得过去觉得可能无关紧要

860
00:33:43,000 --> 00:33:47,000
但是其实是急需要形式证明去证明它是安全可靠的

861
00:33:47,000 --> 00:33:50,000
就是我们现在互联网底层的一些

862
00:33:50,000 --> 00:33:52,000
包括一些不是互联网底层

863
00:33:52,000 --> 00:33:55,000
就是我们现在计算机硬件底层一些涉及到安全相关的东西

864
00:33:55,000 --> 00:33:56,000
对吧

865
00:33:56,000 --> 00:33:57,000
前段时间

866
00:33:57,000 --> 00:34:00,000
不就是去年和今年连续报道

867
00:34:00,000 --> 00:34:02,000
都说出来的多个重大的安全漏洞

868
00:34:02,000 --> 00:34:07,000
都是都不是因为测试可以简单的覆盖得到的

869
00:34:07,000 --> 00:34:09,000
我觉得不是靠测试可以解决的

870
00:34:09,000 --> 00:34:10,000
没错

871
00:34:10,000 --> 00:34:15,000
你真的是要去去去证明它每一行代码是经济推敲的

872
00:34:15,000 --> 00:34:18,000
因为那么有那些 bug 非常非常隐晦

873
00:34:18,000 --> 00:34:22,000
因为通常的测试你根本想不到会是那么一种方式去出错

874
00:34:22,000 --> 00:34:27,000
所以我觉得看这个东西的重要性

875
00:34:27,000 --> 00:34:29,000
我觉得如果是足够重要的话

876
00:34:29,000 --> 00:34:32,000
就是要通过形式证明的方式来来它更好

877
00:34:32,000 --> 00:34:34,000
但是我觉得确实没错

878
00:34:34,000 --> 00:34:37,000
对于绝大多数这种商业性的项目来讲

879
00:34:37,000 --> 00:34:40,000
你能给他写测试能都已经不错了

880
00:34:40,000 --> 00:34:41,000
你还要求什么形式证明

881
00:34:41,000 --> 00:34:43,000
这不痴人说梦

882
00:34:43,000 --> 00:34:45,000
对

883
00:34:45,000 --> 00:34:49,000
接下来的一篇

884
00:34:49,000 --> 00:34:50,000
读出来

885
00:34:50,000 --> 00:34:51,000
刚才你这个还没念完

886
00:34:51,000 --> 00:34:53,000
你把这个结尾念完

887
00:34:53,000 --> 00:34:54,000
对

888
00:34:54,000 --> 00:34:56,000
然后大家结尾说了一个事情

889
00:34:56,000 --> 00:34:58,000
就是说现在再回过头来看

890
00:34:58,000 --> 00:35:00,000
这个就是刚出的竞赛测试

891
00:35:00,000 --> 00:35:04,000
也许按 123 步的流程来能更好的完成比赛

892
00:35:04,000 --> 00:35:06,000
低效程序保证的正确性

893
00:35:06,000 --> 00:35:09,000
数据生成帮助思考编解条件

894
00:35:09,000 --> 00:35:12,000
最终程序来优化拿高分

895
00:35:12,000 --> 00:35:15,000
总之测试最大的价值可能不在于它本身

896
00:35:15,000 --> 00:35:19,000
而在于它给我们带来的对代码更加深入的理解

897
00:35:19,000 --> 00:35:20,000
这个其实我挺认可的

898
00:35:20,000 --> 00:35:22,000
我忘了说

899
00:35:22,000 --> 00:35:23,000
刚才讲 123 步的步骤

900
00:35:23,000 --> 00:35:24,000
为什么会有这个东西

901
00:35:24,000 --> 00:35:27,000
因为在各种各样的这种什么程序竞赛的过程中

902
00:35:27,000 --> 00:35:32,000
这种比赛它们的逻辑一般是这么给的

903
00:35:32,000 --> 00:35:34,000
它先给你一个提供的描述

904
00:35:34,000 --> 00:35:35,000
让你做一件事

905
00:35:35,000 --> 00:35:37,000
然后它会给你一个 sample

906
00:35:37,000 --> 00:35:40,000
其实就是一个测试的样本

907
00:35:40,000 --> 00:35:42,000
然后你要用你的程序去跑这个 sample

908
00:35:42,000 --> 00:35:44,000
看那个大致对不对

909
00:35:44,000 --> 00:35:45,000
你觉得大致对了

910
00:35:45,000 --> 00:35:49,000
你就把你的程序提交到他们一个平台上面去

911
00:35:49,000 --> 00:35:52,000
然后平台再用这个东西去跑一个更大的样本

912
00:35:52,000 --> 00:35:56,000
去看你代码是否得到的结果是如预期所料

913
00:35:56,000 --> 00:35:57,000
对吧

914
00:35:57,000 --> 00:35:59,000
如果全都正确的话就是 AC

915
00:35:59,000 --> 00:36:01,000
对其实有点黑盒的意思

916
00:36:01,000 --> 00:36:04,000
就是它给你一个一小组数据

917
00:36:04,000 --> 00:36:07,000
让你去验证你的程序代码怎么样

918
00:36:07,000 --> 00:36:10,000
所以它在这种用力的场合下

919
00:36:10,000 --> 00:36:12,000
用那个就是它那个 123

920
00:36:12,000 --> 00:36:15,000
刚才那个步骤来讲其实就还蛮好的

921
00:36:15,000 --> 00:36:17,000
但是我不太清楚在实际工程中

922
00:36:17,000 --> 00:36:21,000
有多少人会遵循这么一种方式去做

923
00:36:21,000 --> 00:36:26,000
对我之前在

924
00:36:27,000 --> 00:36:30,000
Coursera 上上了一门课也是

925
00:36:30,000 --> 00:36:33,000
基本上也是以 TDD 的方式来查你们作业的

926
00:36:33,000 --> 00:36:35,000
就是给你一道题

927
00:36:35,000 --> 00:36:38,000
然后让你把程序传上去

928
00:36:38,000 --> 00:36:41,000
它其实本质上就是在后台跑的

929
00:36:41,000 --> 00:36:44,000
跑这个大堆 doc test

930
00:36:44,000 --> 00:36:46,000
就是 python doc test

931
00:36:46,000 --> 00:36:48,000
然后最后来告诉你是不是正确

932
00:36:48,000 --> 00:36:51,000
但在实际生产之中

933
00:36:51,000 --> 00:36:55,000
我能想到的基本上就是每天你写完的程序

934
00:36:55,000 --> 00:36:56,000
它会

935
00:36:56,000 --> 00:36:59,000
把所有的单元测试自动跑一遍

936
00:36:59,000 --> 00:37:03,000
然后告诉你今天写的这些东西

937
00:37:03,000 --> 00:37:05,000
质量怎么样

938
00:37:05,000 --> 00:37:09,000
然后也会告诉你说

939
00:37:09,000 --> 00:37:12,000
比如有个叫 Sona 的软件

940
00:37:12,000 --> 00:37:17,000
可以告诉你说你写的代码没有多少被测试覆盖到

941
00:37:17,000 --> 00:37:21,000
然后如果你今天写的代码很多

942
00:37:21,000 --> 00:37:23,000
但是覆盖率却降低了的话

943
00:37:23,000 --> 00:37:26,000
那你经常可以知道你做的东西

944
00:37:26,000 --> 00:37:29,000
出来可能不是特别的可靠

945
00:37:29,000 --> 00:37:31,000
这也是一个比较重要的质量

946
00:37:31,000 --> 00:37:33,000
这不觉得其实挺悲剧的吗

947
00:37:33,000 --> 00:37:35,000
我觉得如果你写一段代码

948
00:37:35,000 --> 00:37:39,000
你都不能自己在不经过机器测试的情况下

949
00:37:39,000 --> 00:37:42,000
对自己写出来代码的质量有足够的信心

950
00:37:42,000 --> 00:37:47,000
我觉得反正我是不太喜欢这种心态的

951
00:37:47,000 --> 00:37:52,000
至少就是一切靠测试去给你增加你的自信

952
00:37:52,000 --> 00:37:54,000
我觉得是这样的

953
00:37:54,000 --> 00:37:57,000
就是这里面有一个信心积累的过程

954
00:37:57,000 --> 00:38:02,000
那些 AT&T 早期的黑客们肯定也不是用 TDD 的

955
00:38:02,000 --> 00:38:08,000
但是你要在一个比较大的公司里面工作

956
00:38:08,000 --> 00:38:12,000
然后你也没有办法保证你和你的所有的同事们

957
00:38:12,000 --> 00:38:15,000
都能够写出来同样高质量的代码

958
00:38:15,000 --> 00:38:20,000
然后你也没有办法保证你的同事

959
00:38:20,000 --> 00:38:22,000
自信满满的写出来的代码

960
00:38:22,000 --> 00:38:23,000
就像他写出来的代码

961
00:38:24,000 --> 00:38:26,000
他希望的那样高质量

962
00:38:26,000 --> 00:38:29,000
那在这个情况下

963
00:38:29,000 --> 00:38:32,000
怎么样来维护一道准绳

964
00:38:32,000 --> 00:38:35,000
那其实单元测试覆盖率

965
00:38:35,000 --> 00:38:43,000
和单元测试的存在本身就已经是一种保护

966
00:38:43,000 --> 00:38:44,000
一种保障

967
00:38:44,000 --> 00:38:46,000
所以你这么说的潜台词

968
00:38:46,000 --> 00:38:47,000
我这么理解

969
00:38:47,000 --> 00:38:53,000
就是说这是一个保障若干平庸的程序员

970
00:38:53,000 --> 00:38:58,000
能够写出质量还测合过的去的一个管理手段

971
00:38:58,000 --> 00:39:01,000
我觉得 TDD 在很大程度上

972
00:39:01,000 --> 00:39:03,000
就像我说的很印度嘛

973
00:39:03,000 --> 00:39:04,000
其实就是这个意思

974
00:39:04,000 --> 00:39:05,000
对

975
00:39:05,000 --> 00:39:07,000
它是工程

976
00:39:07,000 --> 00:39:10,000
就是人类转件工程的规模逐渐大起来

977
00:39:10,000 --> 00:39:15,000
所不得不采用的一种相关的手段

978
00:39:17,000 --> 00:39:22,000
对其实也没有太值得去

979
00:39:23,000 --> 00:39:25,000
去斥它的事情

980
00:39:25,000 --> 00:39:28,000
因为你没有更好的方法

981
00:39:28,000 --> 00:39:31,000
不然你找一个怎么样的方法

982
00:39:31,000 --> 00:39:34,000
来判断一个代码是不是好的

983
00:39:34,000 --> 00:39:35,000
没错

984
00:39:35,000 --> 00:39:38,000
但其实这里还可以扯到一个

985
00:39:38,000 --> 00:39:43,000
就是我们上期节目里面没有提到的测试覆盖率指标

986
00:39:43,000 --> 00:39:45,000
你觉得理想的测试覆盖率是多少

987
00:39:45,000 --> 00:39:49,000
其实一个比较幼稚的答案就少 100%覆盖

988
00:39:49,000 --> 00:39:51,000
其实非常难的

989
00:39:51,000 --> 00:39:53,000
而且如果真的要写到

990
00:39:53,000 --> 00:39:56,000
100%测试的测试覆盖率的话

991
00:39:56,000 --> 00:39:59,000
可能时间成本是

992
00:39:59,000 --> 00:40:02,000
时间成本是非常惊人的

993
00:40:02,000 --> 00:40:05,000
而且有一些东西是根本没有办法测试

994
00:40:05,000 --> 00:40:08,000
比如说你 CSS 你要怎么测试

995
00:40:08,000 --> 00:40:12,000
所以一个比较理想的测试覆盖率

996
00:40:12,000 --> 00:40:15,000
其实是在 50%左右

997
00:40:15,000 --> 00:40:17,000
然后如果你能达到 85%的话

998
00:40:17,000 --> 00:40:21,000
基本上就是极端高质量的代码

999
00:40:21,000 --> 00:40:22,000
等等

1000
00:40:22,000 --> 00:40:26,000
代码的质量为什么会和测试覆盖率手上关系

1001
00:40:26,000 --> 00:40:28,000
就是极端可靠的代码

1002
00:40:28,000 --> 00:40:30,000
这个意思明白

1003
00:40:30,000 --> 00:40:31,000
不是高质量

1004
00:40:31,000 --> 00:40:32,000
不一定高质量

1005
00:40:32,000 --> 00:40:33,000
但至少是可靠

1006
00:40:33,000 --> 00:40:35,000
好吧

1007
00:40:35,000 --> 00:40:38,000
我们进入到下一封图的信息

1008
00:40:38,000 --> 00:40:41,000
这位朋友的名字叫张浩忠

1009
00:40:41,000 --> 00:40:42,000
应该是

1010
00:40:42,000 --> 00:40:43,000
嗨

1011
00:40:43,000 --> 00:40:44,000
吴涛和瑞尔

1012
00:40:44,000 --> 00:40:46,000
我非常喜欢你们主持的 podcast 节目

1013
00:40:46,000 --> 00:40:47,000
内核恐慌

1014
00:40:47,000 --> 00:40:50,000
限于一个理工科学生语文有限的表达能力

1015
00:40:50,000 --> 00:40:51,000
此处省略意美之词

1016
00:40:51,000 --> 00:40:53,000
一万次

1017
00:40:53,000 --> 00:40:55,000
非常感谢你

1018
00:40:55,000 --> 00:40:57,000
这压缩率好高

1019
00:40:57,000 --> 00:41:03,000
比金瓶梅的压缩率还高

1020
00:41:03,000 --> 00:41:09,000
作为一个研究方向为 formal verification 的老博士

1021
00:41:09,000 --> 00:41:11,000
我想评论一下第十九期之中

1022
00:41:11,000 --> 00:41:13,000
关于 formal verification 的部分内容

1023
00:41:13,000 --> 00:41:15,000
终于来了专业人士

1024
00:41:15,000 --> 00:41:16,000
我好激动

1025
00:41:16,000 --> 00:41:19,000
首先如两位主播所言

1026
00:41:19,000 --> 00:41:20,000
formal verification 是什么呢

1027
00:41:20,000 --> 00:41:25,000
formal verification 的中文翻译通常为形式化验证

1028
00:41:25,000 --> 00:41:28,000
这里仅讨论对软件的 formal verification

1029
00:41:28,000 --> 00:41:34,000
其实 formal verification 和测试都在试图解决相同的问题

1030
00:41:34,000 --> 00:41:38,000
也就是给定人们对一个程序的行为的预期

1031
00:41:38,000 --> 00:41:42,000
例如给什么样的输出有什么样的输入

1032
00:41:42,000 --> 00:41:45,000
给什么样的输出有什么样输出

1033
00:41:45,000 --> 00:41:46,000
Wait a second

1034
00:41:46,000 --> 00:41:49,000
给什么样的输入有什么样的输出

1035
00:41:49,000 --> 00:41:54,000
运行的时间效率甚至程序的功耗等等

1036
00:41:54,000 --> 00:41:58,000
以及这个程序本身构建一个 witness

1037
00:41:58,000 --> 00:42:03,000
以表明这个程序的确能够提供预期的行为

1038
00:42:03,000 --> 00:42:06,000
通常我们称这些预期行为为程序的规范

1039
00:42:06,000 --> 00:42:08,000
也就是 specification

1040
00:42:08,000 --> 00:42:13,000
而称这个程序本身为这个 specification 的一个实现

1041
00:42:13,000 --> 00:42:15,000
也就是 implementation

1042
00:42:15,000 --> 00:42:17,000
formal verification 和测试使用不同的手段来解决这些问题

1043
00:42:17,000 --> 00:42:18,000
那就是 formal verification 的实现了

1044
00:42:19,000 --> 00:42:22,000
使用不同的手段来试图构造这样一个 witness

1045
00:42:22,000 --> 00:42:24,000
对于 formal verification 来说

1046
00:42:24,000 --> 00:42:29,000
它使用数学和逻辑语言表示 specification 和 implementation

1047
00:42:29,000 --> 00:42:33,000
并通过数学和逻辑严格证明 implementation

1048
00:42:33,000 --> 00:42:39,000
在任何可能的情况下都能够满足 specification

1049
00:42:39,000 --> 00:42:42,000
而对于测试在很多情况之下

1050
00:42:42,000 --> 00:42:47,000
specification 使用和 implementation 一样的语言表达

1051
00:42:48,000 --> 00:42:53,000
测试保证如果一个测试用力被执行到

1052
00:42:53,000 --> 00:42:57,000
那么可以通过这个测试用力的执行结果

1053
00:42:57,000 --> 00:42:59,000
来检查 implementation 的正确与否

1054
00:42:59,000 --> 00:43:03,000
但是如果一个测试用力没有被执行到

1055
00:43:03,000 --> 00:43:07,000
或者测试用力没有覆盖到程序的所有可能执行路径

1056
00:43:07,000 --> 00:43:09,000
那么测试就无能为力

1057
00:43:09,000 --> 00:43:11,000
似乎这样看来

1058
00:43:11,000 --> 00:43:15,000
formal verification 可以提供比测试更严格和有效的

1059
00:43:15,000 --> 00:43:18,000
对于程序正确性的保证

1060
00:43:18,000 --> 00:43:21,000
理应在工业界得到更为广泛的应用

1061
00:43:21,000 --> 00:43:23,000
但是目前而言

1062
00:43:23,000 --> 00:43:26,000
formal verification 的性价比太低

1063
00:43:26,000 --> 00:43:29,000
并且对于使用者的要求也太高了

1064
00:43:29,000 --> 00:43:30,000
一方面

1065
00:43:30,000 --> 00:43:32,000
平均验证一行元程序

1066
00:43:32,000 --> 00:43:37,000
大概需要几百行甚至更多的形式化证明代码

1067
00:43:37,000 --> 00:43:38,000
口号是的

1068
00:43:38,000 --> 00:43:42,000
我们有专门用于形式化证明的程序语言

1069
00:43:42,000 --> 00:43:43,000
口号结束

1070
00:43:43,000 --> 00:43:46,000
而且在很多情况之下

1071
00:43:46,000 --> 00:43:48,000
这些证明没有办法自动生成

1072
00:43:48,000 --> 00:43:51,000
并且要耗费大量的时间去创造

1073
00:43:51,000 --> 00:43:53,000
另一方面

1074
00:43:53,000 --> 00:43:56,000
对于能够进行 formal verification 的人

1075
00:43:56,000 --> 00:44:01,000
他既要对验证的对象有着深刻的理解

1076
00:44:01,000 --> 00:44:06,000
比如我为了验证一个 hypervisor 中很小的一部分功能

1077
00:44:06,000 --> 00:44:11,000
从零开始写了一个能够实际工作在 x 86 机器上的

1078
00:44:11,000 --> 00:44:15,000
可以同时运行多个 linux 虚拟机的实验性的 hypervisor

1079
00:44:15,000 --> 00:44:16,000
口号完毕

1080
00:44:16,000 --> 00:44:18,000
又要有一个能够实际工作在 x 86 机器上的

1081
00:44:18,000 --> 00:44:23,000
又有足够和复杂的数学与逻辑学知识

1082
00:44:23,000 --> 00:44:25,000
口号各种抽象代数

1083
00:44:25,000 --> 00:44:26,000
数理逻辑

1084
00:44:26,000 --> 00:44:27,000
集合论

1085
00:44:27,000 --> 00:44:28,000
范畴论什么的

1086
00:44:28,000 --> 00:44:29,000
口号结束

1087
00:44:29,000 --> 00:44:30,000
相对而言

1088
00:44:30,000 --> 00:44:35,000
目前的测试则可以在相对可控的成本之下提供不完美

1089
00:44:35,000 --> 00:44:40,000
但是在多数情况下足够好和易于实现的解决方案

1090
00:44:40,000 --> 00:44:40,000
其次

1091
00:44:40,000 --> 00:44:43,000
我要吐槽一下节目中所说到的

1092
00:44:43,000 --> 00:44:47,000
对于非确定性的程序

1093
00:44:47,000 --> 00:44:48,000
很难验证的

1094
00:44:48,000 --> 00:44:49,000
只好测试的观点

1095
00:44:49,000 --> 00:44:51,000
这好像是我说的吧

1096
00:44:51,000 --> 00:44:53,000
恰恰相反

1097
00:44:53,000 --> 00:44:55,000
对于非确定性程序

1098
00:44:55,000 --> 00:45:00,000
特别是并发程序和操作系统内核之中涉及中断的代码

1099
00:45:00,000 --> 00:45:01,000
formal verification

1100
00:45:01,000 --> 00:45:06,000
可以非常简洁和严格的表达并证明它们的正确性

1101
00:45:06,000 --> 00:45:09,000
而测试此时更多是向在碰运气

1102
00:45:09,000 --> 00:45:13,000
以操作系统内核中可以被中断的代码片段为例

1103
00:45:13,000 --> 00:45:17,000
在这个代码片段的每一条指令的执行

1104
00:45:17,000 --> 00:45:18,000
可能被中断打断了

1105
00:45:18,000 --> 00:45:21,000
也就是说每一条指令的执行有可能有二条路径

1106
00:45:21,000 --> 00:45:24,000
所以一个包含 N 条路径的

1107
00:45:24,000 --> 00:45:26,000
N 条指令的代码段

1108
00:45:26,000 --> 00:45:31,000
可能有 Rest Power of N 个执行路径

1109
00:45:31,000 --> 00:45:33,000
因为在实际的机器上

1110
00:45:33,000 --> 00:45:35,000
中断的发生是不确定的

1111
00:45:35,000 --> 00:45:39,000
所以测试很难保证在短时间内

1112
00:45:39,000 --> 00:45:41,000
能够覆盖到所有的执行路径

1113
00:45:41,000 --> 00:45:43,000
相对的

1114
00:45:43,000 --> 00:45:44,000
在 formal verification 之中

1115
00:45:44,000 --> 00:45:45,000
举个例子

1116
00:45:45,000 --> 00:45:48,000
我们可以把每条指令的执行路径

1117
00:45:48,000 --> 00:45:50,000
执行化形式表示成

1118
00:45:50,000 --> 00:45:52,000
这应该怎么念

1119
00:45:52,000 --> 00:45:55,000
你真的要念

1120
00:45:55,000 --> 00:45:57,000
PCQ

1121
00:45:57,000 --> 00:46:00,000
其中 C 是这条指令

1122
00:46:00,000 --> 00:46:01,000
P 称为前条件

1123
00:46:01,000 --> 00:46:03,000
也就是 precondition

1124
00:46:03,000 --> 00:46:07,000
它描述了 C 执行之前机器的状态

1125
00:46:07,000 --> 00:46:10,000
例如某个寄存器的值是什么

1126
00:46:10,000 --> 00:46:12,000
某个内存单元的值是什么

1127
00:46:12,000 --> 00:46:15,000
通常不需要覆盖所有的寄存器的内存单元

1128
00:46:15,000 --> 00:46:17,000
仅需要验证的

1129
00:46:17,000 --> 00:46:18,000
内存单元的值是什么

1130
00:46:18,000 --> 00:46:20,000
只需要根据验证的 specification

1131
00:46:20,000 --> 00:46:22,000
选取我们专关系的目的

1132
00:46:22,000 --> 00:46:24,000
Q 称为后条件

1133
00:46:24,000 --> 00:46:25,000
也就是 postcondition

1134
00:46:25,000 --> 00:46:29,000
它描述了 C 执行之后的机器状态

1135
00:46:29,000 --> 00:46:29,000
注意

1136
00:46:29,000 --> 00:46:32,000
这里的 Q 同时描述

1137
00:46:32,000 --> 00:46:34,000
同时描述了 C 被中断

1138
00:46:34,000 --> 00:46:38,000
和不被中断的执行之后的机器状态

1139
00:46:38,000 --> 00:46:39,000
非形式化的

1140
00:46:39,000 --> 00:46:41,000
PCQ

1141
00:46:41,000 --> 00:46:46,000
表示在满足前条件 P 的机器上执行 C 之后

1142
00:46:46,000 --> 00:46:48,000
得到的机器状态

1143
00:46:48,000 --> 00:46:49,000
满足后条件 Q

1144
00:46:49,000 --> 00:46:50,000
这样一来

1145
00:46:50,000 --> 00:46:52,000
对于上述的一个代表变段

1146
00:46:52,000 --> 00:46:53,000
C 1 C 2

1147
00:46:53,000 --> 00:46:55,000
一直到 Cn

1148
00:46:55,000 --> 00:46:58,000
我们有 P 下标 1

1149
00:46:58,000 --> 00:46:59,000
C 下标 1

1150
00:46:59,000 --> 00:47:01,000
Q 下标 1

1151
00:47:01,000 --> 00:47:02,000
P 下标 2

1152
00:47:02,000 --> 00:47:03,000
C 下标 2

1153
00:47:03,000 --> 00:47:04,000
Q 下标 2

1154
00:47:04,000 --> 00:47:06,000
一直到 P 下标 n

1155
00:47:06,000 --> 00:47:07,000
C 下标 n

1156
00:47:07,000 --> 00:47:08,000
Q 下标 n

1157
00:47:08,000 --> 00:47:09,000
然后我们可以证明

1158
00:47:09,000 --> 00:47:11,000
Q 下标 1

1159
00:47:11,000 --> 00:47:13,000
这该怎么念呢

1160
00:47:13,000 --> 00:47:15,000
推导出

1161
00:47:18,000 --> 00:47:20,000
应该是 implies

1162
00:47:20,000 --> 00:47:22,000
然后我们可以证明出

1163
00:47:22,000 --> 00:47:24,000
如果有 Q 1 那么一定有 P 2

1164
00:47:24,000 --> 00:47:29,000
不对

1165
00:47:29,000 --> 00:47:30,000
这个是

1166
00:47:30,000 --> 00:47:31,000
然后我们可以证明

1167
00:47:31,000 --> 00:47:34,000
Q 下标 1 可以推导出 P 下标 2

1168
00:47:34,000 --> 00:47:39,000
一直到 Q 下标 n-1 可以推导出 P 下标 n

1169
00:47:39,000 --> 00:47:45,000
从而可以证明 P 下标 1 C 下标 1 C 下标 2

1170
00:47:45,000 --> 00:47:46,000
一直到 C 下标 n-1 可以推导出 P 下标 n-1

1171
00:47:46,000 --> 00:47:47,000
一直到 C 下标 n-1 可以推导出 P 下标 n-1

1172
00:47:47,000 --> 00:47:48,000
一直到 C 下标 n-1 可以推导出 P 下标 n-1

1173
00:47:48,000 --> 00:47:50,000
同样的

1174
00:47:50,000 --> 00:47:53,000
如果这个代码片段的 specification 可以写成

1175
00:47:53,000 --> 00:47:59,000
例如 P C 下标 1 C 下标 2

1176
00:47:59,000 --> 00:48:01,000
一直到 C 下标 n-Q

1177
00:48:01,000 --> 00:48:06,000
我们只需要再证明 P 可以推导出 P 下标 1

1178
00:48:06,000 --> 00:48:08,000
和 Q 下标 n 可以推导出 Q

1179
00:48:08,000 --> 00:48:09,000
也就是

1180
00:48:09,000 --> 00:48:15,000
也就可以证明这个代码片段的确满足了给定的 specification

1181
00:48:15,000 --> 00:48:17,000
因为这里的 P Q P 下标 n-1

1182
00:48:17,000 --> 00:48:21,000
Q P 下标 i Q 下标 i 等等描述了所有的可能状况

1183
00:48:21,000 --> 00:48:24,000
并且只需要描述 specification 关心的部分

1184
00:48:24,000 --> 00:48:28,000
所以这里的 formal verification 比测试更加完备和简洁

1185
00:48:28,000 --> 00:48:30,000
在实际工作中

1186
00:48:30,000 --> 00:48:33,000
我们往往会针对验证的所有程序的特点

1187
00:48:33,000 --> 00:48:38,000
设定特定的逻辑系统以进一步降低证明的难度和复杂度

1188
00:48:38,000 --> 00:48:44,000
我念我在读这段文章的时候大概明白他在说什么

1189
00:48:44,000 --> 00:48:46,000
但是我念出来之后发现自己根本不明白这句话了

1190
00:48:47,000 --> 00:48:49,000
其实很简单

1191
00:48:49,000 --> 00:48:50,000
刚才那一段话

1192
00:48:50,000 --> 00:48:52,000
如果你听众肯定是没听明白

1193
00:48:52,000 --> 00:48:54,000
你也没有看见那个东西

1194
00:48:54,000 --> 00:48:58,000
我觉得对这一段还是比较把把他 po 出来比较好

1195
00:48:58,000 --> 00:49:02,000
其实那句话也是有个比较直白的解释

1196
00:49:02,000 --> 00:49:03,000
就是说

1197
00:49:03,000 --> 00:49:04,000
你有一串代码

1198
00:49:04,000 --> 00:49:08,000
那每一个每一个每一步都会有一个所谓的前条件

1199
00:49:08,000 --> 00:49:10,000
就是所谓前因后果

1200
00:49:10,000 --> 00:49:13,000
你执行这段这一个步骤之前是一个什么样的状况

1201
00:49:13,000 --> 00:49:15,000
执行之后你预期它是什么样的状况

1202
00:49:15,000 --> 00:49:16,000
然后如果

1203
00:49:16,000 --> 00:49:22,000
你能够把前面一条代码的结果推到这个状况

1204
00:49:22,000 --> 00:49:27,000
推到这后面一个一行代码的这个叫做前因

1205
00:49:27,000 --> 00:49:29,000
你能把东西连续的串起来

1206
00:49:29,000 --> 00:49:33,000
你只能证明这个东西整个代码片段的可靠性

1207
00:49:33,000 --> 00:49:34,000
你能把这个东西

1208
00:49:34,000 --> 00:49:40,000
这个是我上学的时候不停写作业要做的一个部分

1209
00:49:40,000 --> 00:49:42,000
现在看来真是好痛苦

1210
00:49:42,000 --> 00:49:44,000
所以其实它就是一个状态机

1211
00:49:44,000 --> 00:49:45,000
然后如果

1212
00:49:45,000 --> 00:49:49,000
如果你能证明这个状态机的每一步都是可以达到了

1213
00:49:49,000 --> 00:49:53,000
或者说每一步状态机的每一个状态都是彼此相连的

1214
00:49:53,000 --> 00:49:56,000
那整个状态机的可靠性就是可以被验证的

1215
00:49:56,000 --> 00:49:57,000
大概是这个意思吧

1216
00:49:57,000 --> 00:49:59,000
有点那个意思

1217
00:49:59,000 --> 00:50:02,000
我没有学过这种东西

1218
00:50:02,000 --> 00:50:05,000
我们通讯就是不学这种让人头大

1219
00:50:05,000 --> 00:50:09,000
其实它不算难

1220
00:50:09,000 --> 00:50:11,000
但是非常繁琐

1221
00:50:11,000 --> 00:50:13,000
感觉像解九连环

1222
00:50:13,000 --> 00:50:14,000
你要解

1223
00:50:14,000 --> 00:50:15,000
对非常

1224
00:50:15,000 --> 00:50:18,000
你要一步去达到前面的一步

1225
00:50:18,000 --> 00:50:20,000
对你要一步去弄这个东西

1226
00:50:20,000 --> 00:50:22,000
其实所以为什么讲

1227
00:50:22,000 --> 00:50:25,000
要有专门的程序

1228
00:50:25,000 --> 00:50:26,000
那种语言去

1229
00:50:26,000 --> 00:50:31,000
基于各种各样的 logic 的方法去证明的东西

1230
00:50:31,000 --> 00:50:34,000
就是想把这个繁琐的东西机械化

1231
00:50:34,000 --> 00:50:35,000
让机械去做

1232
00:50:35,000 --> 00:50:38,000
我们人只用把 specification 给好就可以了

1233
00:50:38,000 --> 00:50:40,000
但是其实你在真正在做的时候

1234
00:50:40,000 --> 00:50:44,000
就正如张博士所言

1235
00:50:44,000 --> 00:50:47,000
你为了验证一行代码的可靠性

1236
00:50:47,000 --> 00:50:50,000
去证明它是否符合某个 spec

1237
00:50:50,000 --> 00:50:54,000
你可能要再写好多好多遍的代码

1238
00:50:54,000 --> 00:50:56,000
对没错

1239
00:50:56,000 --> 00:50:58,000
接着呢这封信

1240
00:50:58,000 --> 00:51:01,000
另一个体现 formalification 比测试强大的地方

1241
00:51:01,000 --> 00:51:06,000
是对于各种 logless algorithm 的实现的正确性的验证

1242
00:51:06,000 --> 00:51:10,000
就是无所的算法的实现的正确性的验证

1243
00:51:10,000 --> 00:51:12,000
这是一个非常大和复杂的话题

1244
00:51:12,000 --> 00:51:13,000
这里就不展开了

1245
00:51:13,000 --> 00:51:19,000
另外学术界一直以来都试图将 formalification 的应用

1246
00:51:19,000 --> 00:51:22,000
应用到实际的软件开发之中

1247
00:51:22,000 --> 00:51:26,000
目前两个最为瞩目的结果是 Cell 4

1248
00:51:26,000 --> 00:51:32,000
它是对一个微内核操作系统的完整的形式化验证

1249
00:51:32,000 --> 00:51:34,000
它的网址都很酷

1250
00:51:34,000 --> 00:51:42,000
叫做 htps//cell 4.systems

1251
00:51:42,000 --> 00:51:48,000
所以.systems 是一个顶级域名吗

1252
00:51:48,000 --> 00:51:49,000
你不知道吗

1253
00:51:49,000 --> 00:51:53,000
现在有一批各种各样其实怪怪的新的顶级域冒出来

1254
00:51:53,000 --> 00:51:56,000
我知道 XXX 但是好像没有听说过 systems

1255
00:51:56,000 --> 00:52:01,000
有多啦有.systems 还有各种好像有.bier 吧

1256
00:52:01,000 --> 00:52:04,000
你可以注册一个

1257
00:52:04,000 --> 00:52:07,000
然后还有一个叫做 compcert

1258
00:52:07,000 --> 00:52:09,000
是法国

1259
00:52:09,000 --> 00:52:11,000
INRIA 实现的一个验证功能

1260
00:52:11,000 --> 00:52:14,000
实现的一个验证过的 C 语言编译器

1261
00:52:14,000 --> 00:52:19,000
曾经用在 Airbus 空客的记载软件的开发之中

1262
00:52:19,000 --> 00:52:20,000
这个很这个很屌

1263
00:52:20,000 --> 00:52:21,000
这个很牛

1264
00:52:21,000 --> 00:52:32,000
网址是 htp://compcert.inria.fr

1265
00:52:32,000 --> 00:52:33,000
最后

1266
00:52:33,000 --> 00:52:36,000
既然节目中提到了 TDD 和 BDD

1267
00:52:36,000 --> 00:52:40,000
那么我就不得不提到 formal verification 之中对应的

1268
00:52:40,000 --> 00:52:43,000
叫做 Program Synthesis 的东西

1269
00:52:43,000 --> 00:52:46,000
程序合成的东西

1270
00:52:46,000 --> 00:52:50,000
简单来说就是软件开发要先写 specification

1271
00:52:50,000 --> 00:52:53,000
和程序满足 specification 的数学证明

1272
00:52:53,000 --> 00:52:58,000
然后从这些证明自动生成满足 specification 的程序

1273
00:52:58,000 --> 00:53:02,000
前面提到的 compcert 主要就是用这种方法开发出来的

1274
00:53:02,000 --> 00:53:07,000
简单来说这个东西基于这样一个已经被证明的数学理论基础

1275
00:53:07,000 --> 00:53:10,000
计算和证明是等于什么呢

1276
00:53:10,000 --> 00:53:11,000
就是等价了

1277
00:53:11,000 --> 00:53:13,000
当然这么牛逼闪闪的东西

1278
00:53:13,000 --> 00:53:17,000
目前还有大量的理论和工程方面的问题需要解决

1279
00:53:17,000 --> 00:53:21,000
所以广大程序员在有生之年无需失业

1280
00:53:21,000 --> 00:53:25,000
而我在有生之年也不太靠这个东西发家之富了

1281
00:53:25,000 --> 00:53:26,000
大概就是这些

1282
00:53:26,000 --> 00:53:31,000
刚才读到这些就读到这部分的时候

1283
00:53:31,000 --> 00:53:32,000
我心里一领

1284
00:53:32,000 --> 00:53:37,000
想说我靠要是被这帮 freak 们搞出来

1285
00:53:37,000 --> 00:53:38,000
那我们这些

1286
00:53:38,000 --> 00:53:39,000
下岗了

1287
00:53:39,000 --> 00:53:40,000
对

1288
00:53:40,000 --> 00:53:42,000
吃程序饭的人该怎么办呢

1289
00:53:42,000 --> 00:53:45,000
结果他说有生之年无需担心事业

1290
00:53:45,000 --> 00:53:47,000
我心里的一颗大石头就放了

1291
00:53:47,000 --> 00:53:48,000
对

1292
00:53:48,000 --> 00:53:56,000
因为现在你说什么就是蓝领的工种被各种各样的机械化自动化的东西弃在掉了

1293
00:53:56,000 --> 00:53:57,000
是吧

1294
00:53:57,000 --> 00:54:04,000
反正我觉得至少在我们挂掉之前还不用担心程序员这工种被自动化掉

1295
00:54:04,000 --> 00:54:09,000
但是他提到这件事就是计算和证明是等价的

1296
00:54:09,000 --> 00:54:15,000
所以一切可计算的东西都是可以证明的

1297
00:54:15,000 --> 00:54:21,000
这不是跟那个 p 等是否等于 np 那个东西是一个原理吗

1298
00:54:21,000 --> 00:54:23,000
对是那种

1299
00:54:23,000 --> 00:54:24,000
对吧

1300
00:54:24,000 --> 00:54:26,000
p 和 np 是验证和可计算

1301
00:54:26,000 --> 00:54:36,000
我想到一件事情就是我们在木瑶请来木瑶那一期的时候提到说如果计算机能够做数学题的话

1302
00:54:36,000 --> 00:54:38,000
他能不能证明数学题呢

1303
00:54:38,000 --> 00:54:46,000
我记得当时在木瑶 blog 里面提到说如果一台计算机可以证明一件东西的话

1304
00:54:46,000 --> 00:54:49,000
是将会是非常了不起的一件事

1305
00:54:49,000 --> 00:54:57,000
但是很遗憾的就是我们人类都有时候不太清楚自己证明一个东西到底是怎样的一个过程

1306
00:54:57,000 --> 00:55:07,000
我觉得如果脑洞大台有了你告诉计算机说我要一个什么样的程序

1307
00:55:07,000 --> 00:55:08,000
就是

1308
00:55:08,000 --> 00:55:12,000
给出这样一个程序的 specification

1309
00:55:12,000 --> 00:55:18,000
你还是要用自己的脑力来证明这个 specification

1310
00:55:18,000 --> 00:55:20,000
是可以为算出来

1311
00:55:20,000 --> 00:55:23,000
这个过程终究还是不能用计算机来体验

1312
00:55:23,000 --> 00:55:27,000
所以也许将来的程序员们不一定需要自己去写程序

1313
00:55:27,000 --> 00:55:32,000
但他们仍旧需要自己去想出来这个程序为什么可以被写出来

1314
00:55:32,000 --> 00:55:35,000
感觉又难了一些了

1315
00:55:35,000 --> 00:55:38,000
生活又艰辛了一点点了

1316
00:55:38,000 --> 00:55:50,000
对将来就不是将来写程序这个职业就不再是一个仅仅受过中学教育和一定培训的人就可以胜任的工作了

1317
00:55:50,000 --> 00:55:53,000
不像现在你的意思是说蓝翔要关门了

1318
00:55:53,000 --> 00:55:57,000
其实我觉得是一件好事吧

1319
00:55:57,000 --> 00:56:02,000
就是现在你看我这样的人都可以来转行写程序

1320
00:56:02,000 --> 00:56:03,000
哈哈哈哈

1321
00:56:03,000 --> 00:56:05,000
这个字很漂亮

1322
00:56:05,000 --> 00:56:07,000
三号三号让成绩好

1323
00:56:07,000 --> 00:56:11,000
三号三号让成绩的光环变得

1324
00:56:11,000 --> 00:56:13,000
没有那么圣洁了是不是

1325
00:56:13,000 --> 00:56:14,000
对

1326
00:56:14,000 --> 00:56:16,000
是一个邪恶光环

1327
00:56:16,000 --> 00:56:18,000
哈哈哈哈

1328
00:56:18,000 --> 00:56:19,000
OK

1329
00:56:19,000 --> 00:56:20,000
好了

1330
00:56:20,000 --> 00:56:23,000
接下来是一个非常重头的反馈

1331
00:56:23,000 --> 00:56:24,000
啊

1332
00:56:24,000 --> 00:56:27,000
这位听众朋友不但写了一封很长程的信

1333
00:56:27,000 --> 00:56:34,000
最后还录了一个将近一个小时的视频来向我们展示的 tdd

1334
00:56:34,000 --> 00:56:36,000
哈哈

1335
00:56:36,000 --> 00:56:37,000
怎么办

1336
00:56:37,000 --> 00:56:38,000
来吧

1337
00:56:38,000 --> 00:56:39,000
我来吧

1338
00:56:39,000 --> 00:56:40,000
啊

1339
00:56:40,000 --> 00:56:41,000
嗨

1340
00:56:41,000 --> 00:56:42,000
呃

1341
00:56:42,000 --> 00:56:44,000
首先非常喜欢听你们的节目

1342
00:56:44,000 --> 00:56:46,000
已经从头追了一遍

1343
00:56:46,000 --> 00:56:49,000
受益匪浅也试着反馈一次

1344
00:56:49,000 --> 00:56:55,000
作为一个已经被成功安利的 tdd 和 pair programming

1345
00:56:55,000 --> 00:56:56,000
这叫什么

1346
00:56:56,000 --> 00:56:57,000
结对编程是吧

1347
00:56:57,000 --> 00:56:58,000
对

1348
00:56:58,000 --> 00:56:59,000
对

1349
00:56:59,000 --> 00:57:03,000
这渐行者那个件啊

1350
00:57:03,000 --> 00:57:04,000
哈哈

1351
00:57:04,000 --> 00:57:05,000
嗯

1352
00:57:05,000 --> 00:57:09,000
我最近四年的代码都几乎都是被测试驱动出来的

1353
00:57:09,000 --> 00:57:10,000
可见中毒之声

1354
00:57:10,000 --> 00:57:13,000
我想反馈一些我自己的体会

1355
00:57:13,000 --> 00:57:14,000
我个人理解

1356
00:57:14,000 --> 00:57:15,000
当然测试有两种作用

1357
00:57:15,000 --> 00:57:20,000
一个是保障作用保障代码还是在按预期交付业务价值

1358
00:57:20,000 --> 00:57:21,000
这个就不提

1359
00:57:21,000 --> 00:57:23,000
另外一个是驱动作用

1360
00:57:23,000 --> 00:57:24,000
就是 tdd 中间那个 driven

1361
00:57:24,000 --> 00:57:30,000
大家谈论 tdd 的时候经常忽略的也就是这个 driven 而关注在 test 上

1362
00:57:30,000 --> 00:57:33,000
当 test 起 driven 作用的时候

1363
00:57:33,000 --> 00:57:34,000
一旦 driven 作用完成

1364
00:57:34,000 --> 00:57:37,000
也就是实现被 driven 出来后

1365
00:57:37,000 --> 00:57:41,000
理论就可以被删除

1366
00:57:41,000 --> 00:57:43,000
哎呀怎么没读通顺呢

1367
00:57:43,000 --> 00:57:47,000
他的意思就是当 test 起 driven 作用的时候

1368
00:57:47,000 --> 00:57:48,000
嗯

1369
00:57:48,000 --> 00:57:53,000
呃也就是说这个 test 在驱使你写 test 的时候

1370
00:57:53,000 --> 00:57:59,000
呃他只是一个动力或者说他只是一个刺激源

1371
00:57:59,000 --> 00:58:02,000
他刺激你说我把这些 test 都满足了

1372
00:58:02,000 --> 00:58:03,000
嗯

1373
00:58:03,000 --> 00:58:05,000
我的代码也就写出来了

1374
00:58:05,000 --> 00:58:06,000
啊 ok

1375
00:58:06,000 --> 00:58:07,000
这么理解

1376
00:58:07,000 --> 00:58:09,000
但写都写了稍微需求减减

1377
00:58:09,000 --> 00:58:12,000
你就可以留着继续发挥余热

1378
00:58:12,000 --> 00:58:17,000
转化为可以起到保障作用的单元测试何乐而不为呢

1379
00:58:17,000 --> 00:58:18,000
那追问的作用

1380
00:58:18,000 --> 00:58:19,000
我再插一句

1381
00:58:19,000 --> 00:58:22,000
他的意思就是你要修一栋楼

1382
00:58:22,000 --> 00:58:25,000
呃你修的你修的脚手架

1383
00:58:25,000 --> 00:58:27,000
呃然后再盖这个楼

1384
00:58:27,000 --> 00:58:30,000
理论上楼盖好了之后脚手架就应该拆除了对吧

1385
00:58:30,000 --> 00:58:32,000
但是在软件的世界里面

1386
00:58:32,000 --> 00:58:34,000
做这样的比喻实际上是不恰当的

1387
00:58:34,000 --> 00:58:39,000
就在软件的世界里面这个楼可能是要继续生长和变化的

1388
00:58:39,000 --> 00:58:42,000
呃此时如果你一开始搭的脚手架

1389
00:58:42,000 --> 00:58:44,000
那你大可以留着脚手架

1390
00:58:44,000 --> 00:58:47,000
如果这个变化是在预期之外的话

1391
00:58:47,000 --> 00:58:50,000
那个这个假手架这个脚手架可能就会被撞到

1392
00:58:50,000 --> 00:58:57,000
然后你就知道这个东西已经在你的呃就是你这一部分的更改已经呃变更了

1393
00:58:57,000 --> 00:59:00,000
你一开始对于这个建筑的预期大概是这样一个

1394
00:59:00,000 --> 00:59:02,000
我现在能想到一个比较合适的呃比喻

1395
00:59:02,000 --> 00:59:04,000
嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯

1396
00:59:04,000 --> 00:59:05,000
呃接着说哈

1397
00:59:05,000 --> 00:59:09,000
就他那追问的作用是如何被体现的呢

1398
00:59:09,000 --> 00:59:14,000
我们习惯的开发思路可以理解是自上而下的 topdown approach 对吧

1399
00:59:14,000 --> 00:59:18,000
就碰到一个问题或需求先做完备的设计

1400
00:59:18,000 --> 00:59:20,000
再按再来实现

1401
00:59:20,000 --> 00:59:24,000
而 tdd 所体现的就是一个相反的自下而上的这么一个模式

1402
00:59:24,000 --> 00:59:27,000
就是说程序的设计和算法

1403
00:59:27,000 --> 00:59:31,000
不例识说一在你开始写之前就要想清楚的所有细节

1404
00:59:31,000 --> 00:59:32,000
嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯嗯是

1405
00:59:32,000 --> 00:59:34,000
而是可以基于对目标的任务进行分解

1406
00:59:34,000 --> 00:59:37,000
以及实现的逐步演进

1407
00:59:37,000 --> 00:59:42,000
并通过每次红绿 cycle 后的重构被驱动出来

1408
00:59:42,000 --> 00:59:44,000
哇好多数

1409
00:59:44,000 --> 00:59:47,000
红绿 cycle 就是一开始没通过

1410
00:59:47,000 --> 00:59:48,000
然后你写好了

1411
00:59:48,000 --> 00:59:49,000
就老是挂

1412
00:59:49,000 --> 00:59:51,000
各种测试

1413
00:59:51,000 --> 00:59:51,000
老是挂

1414
00:59:51,000 --> 00:59:52,000
然后绿了一下

1415
00:59:52,000 --> 00:59:53,000
又红了

1416
00:59:53,000 --> 00:59:55,000
接着改又绿了

1417
00:59:55,000 --> 00:59:58,000
好处恰恰就是 real 所吐槽的那种

1418
00:59:58,000 --> 01:00:00,000
外包公司所能达到的

1419
01:00:00,000 --> 01:00:02,000
刚刚好满足需求的实现

1420
01:00:02,000 --> 01:00:04,000
不过我觉得满足

1421
01:00:04,000 --> 01:00:06,000
在满足所有业务需求的前提下

1422
01:00:06,000 --> 01:00:08,000
刚刚好不一定就是坏事

1423
01:00:08,000 --> 01:00:11,000
正好契合当今精益的思想

1424
01:00:11,000 --> 01:00:13,000
这个我不反对

1425
01:00:13,000 --> 01:00:14,000
我觉得这确实是很好的

1426
01:00:14,000 --> 01:00:17,000
前提是有重构的保证

1427
01:00:17,000 --> 01:00:18,000
这种刚刚好的实现

1428
01:00:18,000 --> 01:00:23,000
也是已经消除了识别出的 bad smell

1429
01:00:23,000 --> 01:00:25,000
就是坏味道

1430
01:00:25,000 --> 01:00:26,000
对坏味道

1431
01:00:26,000 --> 01:00:27,000
例如代码重复

1432
01:00:27,000 --> 01:00:29,000
各种 switch

1433
01:00:29,000 --> 01:00:30,000
还有非常长的方法

1434
01:00:30,000 --> 01:00:31,000
或者函数的

1435
01:00:31,000 --> 01:00:36,000
比较干净的实现

1436
01:00:36,000 --> 01:00:38,000
我靠这怎么念

1437
01:00:38,000 --> 01:00:40,000
这种刚刚好的实现

1438
01:00:40,000 --> 01:00:43,000
也就是已经消除了识别出的 bad smell

1439
01:00:43,000 --> 01:00:44,000
之后比较 clean 的实现

1440
01:00:44,000 --> 01:00:45,000
对

1441
01:00:45,000 --> 01:00:46,000
没错

1442
01:00:46,000 --> 01:00:50,000
而这两种开放模式也没有好坏之分

1443
01:00:50,000 --> 01:00:51,000
只是就是他这两种开放模式

1444
01:00:51,000 --> 01:00:52,000
一个是自顶向上

1445
01:00:52,000 --> 01:00:54,000
还是自下而上的

1446
01:00:54,000 --> 01:00:55,000
两种这个区分方式

1447
01:00:55,000 --> 01:00:58,000
只是思考的问题和方向的问题

1448
01:00:58,000 --> 01:00:59,000
可能最终的结果

1449
01:00:59,000 --> 01:01:00,000
是一种

1450
01:01:00,000 --> 01:01:01,000
一致的

1451
01:01:01,000 --> 01:01:02,000
对吧

1452
01:01:02,000 --> 01:01:05,000
其实这怎么说呢

1453
01:01:05,000 --> 01:01:09,000
就这种这种大概念性的这个争吵

1454
01:01:09,000 --> 01:01:10,000
其实也没有什么太大的用处

1455
01:01:10,000 --> 01:01:12,000
就是有些人习惯

1456
01:01:12,000 --> 01:01:14,000
于先有一个大的红

1457
01:01:14,000 --> 01:01:15,000
跟写作文一样的

1458
01:01:15,000 --> 01:01:16,000
有些人习惯说

1459
01:01:16,000 --> 01:01:18,000
先来把七纲写出来

1460
01:01:18,000 --> 01:01:18,000
对吧

1461
01:01:18,000 --> 01:01:20,000
然后再来听那些天细枝摸眼

1462
01:01:20,000 --> 01:01:21,000
有人喜欢写散文

1463
01:01:21,000 --> 01:01:23,000
就是他一定要边写边弄

1464
01:01:23,000 --> 01:01:25,000
然后再拼出来

1465
01:01:25,000 --> 01:01:27,000
看写出了这么个东西

1466
01:01:27,000 --> 01:01:30,000
对我小时候会经常写一些

1467
01:01:30,000 --> 01:01:33,000
很很很没有上下文的片段

1468
01:01:33,000 --> 01:01:35,000
然后最后拼在一起是吧

1469
01:01:35,000 --> 01:01:36,000
最后写作文的时候

1470
01:01:36,000 --> 01:01:38,000
可以想起来一个段子

1471
01:01:38,000 --> 01:01:40,000
然后拼进去

1472
01:01:40,000 --> 01:01:40,000
嗯

1473
01:01:40,000 --> 01:01:41,000
啊

1474
01:01:41,000 --> 01:01:44,000
他有一个什么 TDD 实施的三个步骤

1475
01:01:44,000 --> 01:01:45,000
用他自己的理解

1476
01:01:45,000 --> 01:01:47,000
就是说先写一个测试

1477
01:01:47,000 --> 01:01:48,000
然后让别人通过

1478
01:01:48,000 --> 01:01:49,000
这个上次我们已经提到过

1479
01:01:49,000 --> 01:01:51,000
就是只让你已经解释过一次

1480
01:01:51,000 --> 01:01:55,000
就是只编写能恰好让所有测试通过的代码

1481
01:01:55,000 --> 01:01:56,000
然后不断的重构

1482
01:01:56,000 --> 01:01:58,000
然后去反复这个过程

1483
01:01:58,000 --> 01:01:59,000
然后消灭掉所有的那些

1484
01:01:59,000 --> 01:02:00,000
Best man

1485
01:02:00,000 --> 01:02:02,000
但就我们那期节目中

1486
01:02:02,000 --> 01:02:05,000
他说本期节目中没有提到重构

1487
01:02:05,000 --> 01:02:08,000
这也是人们在谈论 TDD 中经常忽略的

1488
01:02:08,000 --> 01:02:10,000
如果没有重构这个步骤的话

1489
01:02:10,000 --> 01:02:14,000
理论上确实所有的逻辑都可以通过无数的

1490
01:02:14,000 --> 01:02:17,000
义务重举输入与输出的映射来实现

1491
01:02:17,000 --> 01:02:18,000
虽然说挺含蓄的

1492
01:02:18,000 --> 01:02:23,000
这其实也有可能是将来计算机写程序的一种方法

1493
01:02:23,000 --> 01:02:27,000
暴力的把你所有可能需要的场景

1494
01:02:27,000 --> 01:02:28,000
全都自动生成语言

1495
01:02:28,000 --> 01:02:29,000
然后程序写出来

1496
01:02:29,000 --> 01:02:30,000
对

1497
01:02:30,000 --> 01:02:32,000
我们都知道这样是不对的

1498
01:02:32,000 --> 01:02:35,000
代码将很快陷入腐化

1499
01:02:35,000 --> 01:02:38,000
我想这也是为什么节目中说可以调试的代码

1500
01:02:38,000 --> 01:02:40,000
都是啰嗦的代码的原因之一吧

1501
01:02:40,000 --> 01:02:44,000
总之我个人认为没有重构的 TDD 都是耍流氓

1502
01:02:44,000 --> 01:02:49,000
如果说前两步保证我们的代码实现了业务价值

1503
01:02:49,000 --> 01:02:52,000
那重构就保证我们代码本身的质量和设计

1504
01:02:52,000 --> 01:02:54,000
从而避免代码的快速腐化

1505
01:02:54,000 --> 01:02:58,000
只有这样才能体现 TDD 的价值和好处

1506
01:02:58,000 --> 01:03:00,000
但一个重要的前提是测试要写对

1507
01:03:00,000 --> 01:03:02,000
否则很容易适得其反

1508
01:03:02,000 --> 01:03:05,000
严重影响重构以及变化

1509
01:03:05,000 --> 01:03:08,000
最简单的就是重构的时候需要修改测试

1510
01:03:08,000 --> 01:03:10,000
刚才我们已经提到这个问题了

1511
01:03:10,000 --> 01:03:12,000
就是你重构的过程中

1512
01:03:12,000 --> 01:03:15,000
这个导致接口变了

1513
01:03:15,000 --> 01:03:16,000
那么你这个测试就要重写

1514
01:03:16,000 --> 01:03:19,000
这就是其实在他看来

1515
01:03:19,000 --> 01:03:23,000
这个是这个什么测试写的不好的一个典范

1516
01:03:23,000 --> 01:03:23,000
对

1517
01:03:23,000 --> 01:03:24,000
对

1518
01:03:24,000 --> 01:03:27,000
一种常见的问题就是测试 Target

1519
01:03:27,000 --> 01:03:28,000
不是业务价值的问题

1520
01:03:28,000 --> 01:03:28,000
不是业务价值的问题

1521
01:03:28,000 --> 01:03:30,000
不是业务价值的问题

1522
01:03:30,000 --> 01:03:32,000
我来念吧

1523
01:03:32,000 --> 01:03:33,000
这一段应该是

1524
01:03:33,000 --> 01:03:38,000
一种常见的问题就是测试的目标不是业务价值

1525
01:03:38,000 --> 01:03:43,000
比如罗马数字与阿拉伯数字的转化的结果是否正确

1526
01:03:43,000 --> 01:03:46,000
而是实现本身

1527
01:03:46,000 --> 01:03:49,000
也就是他写的这个测试测的是

1528
01:03:49,000 --> 01:03:55,000
是否采用了某种算法来处理罗马数字与阿拉伯数字的转化

1529
01:03:55,000 --> 01:03:57,000
在这种情况之下

1530
01:03:57,000 --> 01:03:58,000
如果你要换算法的话

1531
01:03:58,000 --> 01:03:59,000
你就得修改测试

1532
01:04:00,000 --> 01:04:01,000
肯定是这个意思

1533
01:04:01,000 --> 01:04:06,000
然后他说这个如果测试写的不对

1534
01:04:06,000 --> 01:04:09,000
那么测试的稳定性及价值就会大打折扣

1535
01:04:09,000 --> 01:04:13,000
而且测试回复测试的成本也会大大增加

1536
01:04:13,000 --> 01:04:17,000
这正好说明了为什么大多数人不爱写测试法

1537
01:04:17,000 --> 01:04:21,000
其实写好或者写的对的测试确实挺难的

1538
01:04:21,000 --> 01:04:25,000
有时候要比写好或者写对的这个实现还要难很多

1539
01:04:25,000 --> 01:04:28,000
这也印证刚才那个张博士的说法

1540
01:04:28,000 --> 01:04:30,000
你这个什么形式证明也是很难的

1541
01:04:30,000 --> 01:04:33,000
测试也没有简单的哪里去是吧

1542
01:04:33,000 --> 01:04:33,000
没错

1543
01:04:33,000 --> 01:04:41,000
其实你能写测试已经意味着你对写程序这件事情有相当的了解了

1544
01:04:41,000 --> 01:04:45,000
写测试有点像你要教一个人

1545
01:04:45,000 --> 01:04:48,000
你要教一个人武功

1546
01:04:48,000 --> 01:04:49,000
你自己得先会武功

1547
01:04:49,000 --> 01:04:51,000
你的武功得比他强

1548
01:04:51,000 --> 01:04:53,000
你才能跟他对拆

1549
01:04:53,000 --> 01:04:56,000
然后告诉他哪里打错了

1550
01:04:56,000 --> 01:04:58,000
写测试其实是这样

1551
01:04:58,000 --> 01:05:00,000
如果你能写测试

1552
01:05:00,000 --> 01:05:01,000
写出一个好的测试

1553
01:05:01,000 --> 01:05:06,000
基本上就意味着你是一个比能够写出好的代码更好的程序

1554
01:05:06,000 --> 01:05:08,000
对起码你对整个这个接口啊

1555
01:05:08,000 --> 01:05:10,000
他哪些地方可能会出错啊

1556
01:05:10,000 --> 01:05:13,000
你会有一个比较完备的理解

1557
01:05:13,000 --> 01:05:17,000
你才能做到测试写出来是足够覆盖度的

1558
01:05:17,000 --> 01:05:23,000
然后有足够多的一种所谓边界条件去去验证那些东西的会出问题吗

1559
01:05:23,000 --> 01:05:24,000
没错

1560
01:05:24,000 --> 01:05:27,000
他又说哈

1561
01:05:27,000 --> 01:05:29,000
关于 TDD 很硬度

1562
01:05:29,000 --> 01:05:29,000
就是你说的

1563
01:05:30,000 --> 01:05:36,000
将测试作为详细设计说明书的可运行版本来实现分工和流程化

1564
01:05:37,000 --> 01:05:42,000
因为他们就是他在工作那个地方没有严格的分工和分级

1565
01:05:42,000 --> 01:05:43,000
也没有架构师啊

1566
01:05:43,000 --> 01:05:44,000
设计师这类的角色

1567
01:05:44,000 --> 01:05:47,000
所以他感觉不到他们只有这个 BA

1568
01:05:47,000 --> 01:05:50,000
就是说什么 business analyst

1569
01:05:50,000 --> 01:05:52,000
QA quality assurance

1570
01:05:52,000 --> 01:05:54,000
然后 Dev 开发和 UX

1571
01:05:54,000 --> 01:05:58,000
就是用用物体这些角色开发自己的工程设计说明书的方式

1572
01:05:58,000 --> 01:05:58,000
然后 Dev 开发和 UX 就是用用物体这些角色开发自己的工程设计说明书的方式

1573
01:05:58,000 --> 01:06:00,000
然后 Dev 开发和 UX 就是用用物体这些角色开发自己的工程设计说明书的方式

1574
01:06:00,000 --> 01:06:04,000
要负责一个 story 的需求建设与反馈

1575
01:06:04,000 --> 01:06:06,000
他们的那个好好好好多术语啊

1576
01:06:07,000 --> 01:06:08,000
嗯

1577
01:06:08,000 --> 01:06:09,000
任务拆分

1578
01:06:09,000 --> 01:06:11,000
然后开发前端

1579
01:06:11,000 --> 01:06:13,000
还要甚至给这个客户去 showcase

1580
01:06:13,000 --> 01:06:15,000
应该是 demo 这类的东西啊

1581
01:06:15,000 --> 01:06:15,000
对

1582
01:06:15,000 --> 01:06:17,000
所以这块我们还好

1583
01:06:17,000 --> 01:06:21,000
没有感觉任何不是就没有觉得自己很那个像你吴涛说的那么很印度

1584
01:06:21,000 --> 01:06:25,000
就他们还是很开心的在做这个 DDD 的践行的

1585
01:06:25,000 --> 01:06:27,000
反而在保障测试

1586
01:06:27,000 --> 01:06:28,000
反而在测试的保障下

1587
01:06:28,000 --> 01:06:30,000
我们可以灵活的修改实现

1588
01:06:30,000 --> 01:06:30,000
和设计

1589
01:06:30,000 --> 01:06:32,000
甚至灵活的响应需求的变化

1590
01:06:32,000 --> 01:06:35,000
他们现在这个项目的有四多个人开发

1591
01:06:35,000 --> 01:06:38,000
是基于一个.NET 的 web API

1592
01:06:38,000 --> 01:06:41,000
加前端是 reangler.js

1593
01:06:41,000 --> 01:06:43,000
在换那个 react.js 啊

1594
01:06:43,000 --> 01:06:46,000
然后基于这个微服务的方法来做的

1595
01:06:46,000 --> 01:06:49,000
然后用的是吴涛最爱的 Csharp

1596
01:06:49,000 --> 01:06:50,000
都做了五年了

1597
01:06:50,000 --> 01:06:54,000
然后目前还可以做到相对灵活的

1598
01:06:54,000 --> 01:06:55,000
呃

1599
01:06:55,000 --> 01:06:56,000
响应需求变化

1600
01:06:56,000 --> 01:06:57,000
以及代码实现的演进

1601
01:06:57,000 --> 01:06:59,000
甚至工具框架的演进

1602
01:06:59,000 --> 01:06:59,000
可以说

1603
01:06:59,000 --> 01:07:00,000
tv

1604
01:07:00,000 --> 01:07:01,000
td 也是功不可没

1605
01:07:01,000 --> 01:07:02,000
这确实挺难得的

1606
01:07:02,000 --> 01:07:05,000
一个五年的项目没有积攒出那么多的 craft

1607
01:07:05,000 --> 01:07:08,000
反而还能在这个做一套整个业务

1608
01:07:08,000 --> 01:07:09,000
这个叫什么

1609
01:07:09,000 --> 01:07:10,000
呃

1610
01:07:10,000 --> 01:07:13,000
业务思想的这么指导下能够保持敏捷性

1611
01:07:13,000 --> 01:07:15,000
这确实非常不容易

1612
01:07:15,000 --> 01:07:16,000
对呃

1613
01:07:16,000 --> 01:07:19,000
他说到这个 tdd 很印度

1614
01:07:19,000 --> 01:07:20,000
呃

1615
01:07:20,000 --> 01:07:24,000
我我觉得还是有必要解释一下什么叫印度

1616
01:07:24,000 --> 01:07:25,000
印度就是

1617
01:07:26,000 --> 01:07:26,000
啊

1618
01:07:26,000 --> 01:07:27,000
印度人有一个特点

1619
01:07:27,000 --> 01:07:29,000
就是他只做

1620
01:07:29,000 --> 01:07:30,000
你告诉他

1621
01:07:30,000 --> 01:07:31,000
该做的事情

1622
01:07:31,000 --> 01:07:33,000
然后他你告诉他该做的事情

1623
01:07:33,000 --> 01:07:34,000
他不一定能做好

1624
01:07:34,000 --> 01:07:36,000
所以呃

1625
01:07:36,000 --> 01:07:38,000
印度人为了管理印度人

1626
01:07:38,000 --> 01:07:41,000
我这里没有地域歧视或者种族歧视的意思

1627
01:07:41,000 --> 01:07:43,000
但是如果你听出来了

1628
01:07:43,000 --> 01:07:44,000
我有这个意思

1629
01:07:44,000 --> 01:07:44,000
我也没有

1630
01:07:44,000 --> 01:07:46,000
我也没有什么可以解释

1631
01:07:46,000 --> 01:07:48,000
就是印度人想出来管理印度人的方法

1632
01:07:48,000 --> 01:07:52,000
就是有一个呃

1633
01:07:52,000 --> 01:07:53,000
高高在上的

1634
01:07:54,000 --> 01:07:56,000
拿着鞭子的人

1635
01:07:56,000 --> 01:07:57,000
呃

1636
01:07:57,000 --> 01:07:59,000
告诉你每一步应该做什么

1637
01:07:59,000 --> 01:08:00,000
然后反复来检查

1638
01:08:00,000 --> 01:08:01,000
呃

1639
01:08:01,000 --> 01:08:04,000
我的印度只能是这个意思

1640
01:08:04,000 --> 01:08:08,000
而他所说的他们在公司里面没有严格的分工和分级

1641
01:08:08,000 --> 01:08:11,000
这本身就已经非常不印度了

1642
01:08:11,000 --> 01:08:14,000
然后说没有架构师没有设计师之类的角色

1643
01:08:14,000 --> 01:08:15,000
呃

1644
01:08:15,000 --> 01:08:21,000
但其实一个公司里面没有架构师没有设计师并不意味着这个公司就不需要做架构

1645
01:08:21,000 --> 01:08:22,000
不需要做设计了

1646
01:08:22,000 --> 01:08:23,000
呃

1647
01:08:23,000 --> 01:08:28,000
只不过这个架构和设计的呃职责分担到了每一个代身上

1648
01:08:28,000 --> 01:08:30,000
这个对于

1649
01:08:30,000 --> 01:08:32,000
开发者的要求其实比较高的

1650
01:08:32,000 --> 01:08:36,000
但是反过来也会对也会让开发者有样有这样一种感觉

1651
01:08:36,000 --> 01:08:40,000
就是我做的东西是我自己亲手设处设计出来的

1652
01:08:40,000 --> 01:08:42,000
我做的东西是我想要做的

1653
01:08:42,000 --> 01:08:44,000
然后你在主观能动性上会高一点

1654
01:08:44,000 --> 01:08:46,000
但是呃

1655
01:08:46,000 --> 01:08:52,000
这本身是这我觉得是这种制度保证了你没有那么印度

1656
01:08:52,000 --> 01:08:55,000
他们并不意味着好吧

1657
01:08:55,000 --> 01:08:59,000
我我觉得我也不要一定要说 tp 就是一定非常适合印度的人了

1658
01:08:59,000 --> 01:09:04,000
因为我认为这个制度保证的方法是非常适合印度的

1659
01:09:04,000 --> 01:09:05,000
嗯

1660
01:09:05,000 --> 01:09:06,000
开发方法

1661
01:09:06,000 --> 01:09:07,000
我只是说啊

1662
01:09:07,000 --> 01:09:16,000
tpd 很容易被拿来在这种刚才我说的这种抽象式的符号化的印度式的管理上

1663
01:09:16,000 --> 01:09:16,000
嗯

1664
01:09:16,000 --> 01:09:16,000
嗯

1665
01:09:16,000 --> 01:09:17,000
ok

1666
01:09:17,000 --> 01:09:21,000
然后下一则你来念吧

1667
01:09:21,000 --> 01:09:21,000
对

1668
01:09:21,000 --> 01:09:26,000
然后这位朋友呃说他在公司推荐了我们的节目

1669
01:09:26,000 --> 01:09:29,000
然后自己也会一边开车听节目的时候一边偷笑

1670
01:09:29,000 --> 01:09:30,000
呃

1671
01:09:30,000 --> 01:09:40,000
而且会认为说他的同事们这群被 tpd 安利洗脸老了家外后面肯定会听到我们的这些节目产生各种不适

1672
01:09:40,000 --> 01:09:41,000
啊

1673
01:09:41,000 --> 01:09:49,000
不过他们的同事也比较崇尚和而不同的环境互通游物也没什么不好

1674
01:09:49,000 --> 01:09:49,000
嗯

1675
01:09:49,000 --> 01:09:50,000
嗯

1676
01:09:50,000 --> 01:09:53,000
对其实

1677
01:09:53,000 --> 01:09:59,000
我觉得这位呃先生的工作环境是非常理想的

1678
01:09:59,000 --> 01:10:00,000
一个环境

1679
01:10:00,000 --> 01:10:02,000
就是叫做王健的朋友

1680
01:10:02,000 --> 01:10:03,000
呃

1681
01:10:03,000 --> 01:10:05,000
如果你们招人的话

1682
01:10:05,000 --> 01:10:08,000
可以我们可以给你们打个广告

1683
01:10:08,000 --> 01:10:09,000
然后最

1684
01:10:09,000 --> 01:10:20,000
最牛逼的是他在最后录了一段 tpd 写我这个写我在节目里面提到的这个罗马数字转换为阿拉伯数字转换为罗马数字的

1685
01:10:20,000 --> 01:10:22,000
程序

1686
01:10:22,000 --> 01:10:22,000
嗯

1687
01:10:22,000 --> 01:10:23,000
呃

1688
01:10:23,000 --> 01:10:28,000
就是严格按照相对严格的按照这个 tpd 的先写一个测试

1689
01:10:28,000 --> 01:10:29,000
然后再写一段程序

1690
01:10:29,000 --> 01:10:30,000
再写一点测试

1691
01:10:30,000 --> 01:10:31,000
再写一点程序

1692
01:10:31,000 --> 01:10:32,000
那这样步骤来的

1693
01:10:32,000 --> 01:10:37,000
然后他把视频传到了 youtube 和呃那是优酷上的吗

1694
01:10:37,000 --> 01:10:39,000
我只看了 youtube 版本

1695
01:10:39,000 --> 01:10:40,000
嗯

1696
01:10:40,000 --> 01:10:43,000
我们会把这个链接放在呃节目的末尾

1697
01:10:43,000 --> 01:10:46,000
所以如果你没有你从来没有见过 tpd 是什么样子的话

1698
01:10:46,000 --> 01:10:57,000
你可以看到一位呃活生生的例子是对活生生的大牛给你用呃世界上最好用的编辑器呃编译环境

1699
01:10:57,000 --> 01:10:58,000
不知道 studio

1700
01:10:58,000 --> 01:10:58,000
哈哈哈

1701
01:10:58,000 --> 01:11:02,000
以及世界上最好的语言呃 cshop

1702
01:11:02,000 --> 01:11:03,000
哈哈

1703
01:11:03,000 --> 01:11:06,000
为你执行整个 cd tv 的过程

1704
01:11:06,000 --> 01:11:07,000
嗯

1705
01:11:07,000 --> 01:11:10,000
呃接下来我来来来念两封比较短的读者回馈

1706
01:11:10,000 --> 01:11:17,000
呃一封是一位来自于时侠星的朋友

1707
01:11:17,000 --> 01:11:21,000
呃他的他的署名是 star samurai

1708
01:11:21,000 --> 01:11:24,000
他来自于来自于法国

1709
01:11:24,000 --> 01:11:26,000
我们经常黑法国

1710
01:11:26,000 --> 01:11:28,000
是 star sasumi

1711
01:11:28,000 --> 01:11:31,000
啊 star sasumi

1712
01:11:31,000 --> 01:11:33,000
ok sorry

1713
01:11:33,000 --> 01:11:37,000
呃他来自于法国南特矿业学院

1714
01:11:37,000 --> 01:11:40,000
也是一个名字听起来非常的

1715
01:11:40,000 --> 01:11:44,000
那个但实际上在欧洲也是非常好的学校

1716
01:11:44,000 --> 01:11:45,000
呃他说

1717
01:11:45,000 --> 01:11:47,000
嗨的很喜欢你们的节目

1718
01:11:47,000 --> 01:11:49,000
呃这里是关于室友期测试的一点反馈

1719
01:11:49,000 --> 01:11:54,000
然后 djavu 的读音是 djavu

1720
01:11:54,000 --> 01:11:57,000
不过 djavu 已经被美国人的评论了

1721
01:11:57,000 --> 01:11:59,000
也能算是英文式的发音了吧

1722
01:11:59,000 --> 01:12:01,000
在这里看一下

1723
01:12:01,000 --> 01:12:03,000
乌韬总是黑我们法国

1724
01:12:03,000 --> 01:12:05,000
哈哈哈哈

1725
01:12:05,000 --> 01:12:06,000
对不起对不起

1726
01:12:06,000 --> 01:12:07,000
我我

1727
01:12:07,000 --> 01:12:09,000
我是故意的

1728
01:12:09,000 --> 01:12:10,000
哈哈哈哈

1729
01:12:10,000 --> 01:12:13,000
然后关于女生选择做测试这一点

1730
01:12:13,000 --> 01:12:15,000
根据我们的学姐说就是比较轻松

1731
01:12:15,000 --> 01:12:17,000
也不需要加班

1732
01:12:17,000 --> 01:12:20,000
不论是需求改了还是上线之后出问题了

1733
01:12:20,000 --> 01:12:22,000
测试团队都不用被紧急着急

1734
01:12:22,000 --> 01:12:25,000
哎上线出问题这个测试团队都不用被紧急着急

1735
01:12:25,000 --> 01:12:26,000
哎上线出问题这个测试团队都不用被紧急着急了

1736
01:12:26,000 --> 01:12:27,000
哎上线出问题这个测试团队都不用被紧急着急了

1737
01:12:27,000 --> 01:12:29,000
哎上线出问题这个测试团队都不用被紧急着急了

1738
01:12:29,000 --> 01:12:31,000
他都上线了你招测试团队有什么用

1739
01:12:31,000 --> 01:12:34,000
好像也已经太晚了

1740
01:12:34,000 --> 01:12:37,000
你就拿那个 productive 的环境来当测试环境

1741
01:12:37,000 --> 01:12:39,000
然后测然后改到能用为止

1742
01:12:39,000 --> 01:12:41,000
还能怎么办

1743
01:12:41,000 --> 01:12:47,000
第二篇回馈是一位叫李建宏的朋友问我们一款

1744
01:12:47,000 --> 01:12:52,000
诶那个那个什么那个 trackpad 的那个事情要说一下

1745
01:12:52,000 --> 01:12:53,000
啊对

1746
01:12:53,000 --> 01:12:53,000
OK

1747
01:12:53,000 --> 01:12:55,000
对

1748
01:12:55,000 --> 01:12:56,000
然后这

1749
01:12:56,000 --> 01:13:02,000
听众还问我们说一天下来手指会不会因为 trackpad 用多了而关节疼

1750
01:13:02,000 --> 01:13:06,000
他最近实习下班了总是中指关节微微发疼

1751
01:13:06,000 --> 01:13:08,000
中指是 tap 的主力手指

1752
01:13:08,000 --> 01:13:10,000
两位有合适的解决方法吗

1753
01:13:10,000 --> 01:13:12,000
你有这个问题吗

1754
01:13:12,000 --> 01:13:16,000
呃我的解决方法是换鼠标

1755
01:13:16,000 --> 01:13:19,000
其实我也是

1756
01:13:19,000 --> 01:13:23,000
其实我现在家里面偶尔也会用一下鼠标主要是最近

1757
01:13:23,000 --> 01:13:25,000
打游戏比较多

1758
01:13:25,000 --> 01:13:26,000
啊

1759
01:13:26,000 --> 01:13:32,000
其实我觉得那个什么 trackpad 的最就这种特别是 mac 上面那个多点触碰 trackpad

1760
01:13:32,000 --> 01:13:36,000
一个最严重的问题倒不是说这个关节痛而是会变成

1761
01:13:36,000 --> 01:13:38,000
蓝花指

1762
01:13:38,000 --> 01:13:43,000
嗯是有点因为你用的时候总会把小指翘起来一面

1763
01:13:43,000 --> 01:13:47,000
久而久之就久而久之就娘了

1764
01:13:47,000 --> 01:13:49,000
哈哈哈哈

1765
01:13:49,000 --> 01:13:55,000
对其实我有个解决方案就是用中指和啊不用十指和无名指

1766
01:13:55,000 --> 01:13:56,000
十指啊

1767
01:13:56,000 --> 01:13:59,000
对这是没有握法

1768
01:13:59,000 --> 01:14:01,000
那中指不用了

1769
01:14:01,000 --> 01:14:04,000
中指不用中指始终跳起来一个 screw

1770
01:14:04,000 --> 01:14:07,000
又的这个一个状态就是一直跳

1771
01:14:07,000 --> 01:14:09,000
这是一个很硬朗的做法

1772
01:14:09,000 --> 01:14:10,000
对

1773
01:14:10,000 --> 01:14:11,000
呃

1774
01:14:11,000 --> 01:14:15,000
等着我有三个建议一个是关掉那个触摸板的

1775
01:14:15,000 --> 01:14:17,000
click 按下的

1776
01:14:17,000 --> 01:14:19,000
就是你不要按下去你只用轻触

1777
01:14:19,000 --> 01:14:20,000
这样

1778
01:14:20,000 --> 01:14:23,000
对只用 tap 来代替 click

1779
01:14:23,000 --> 01:14:25,000
然后这样会对手指的

1780
01:14:25,000 --> 01:14:26,000
劳损小一点

1781
01:14:26,000 --> 01:14:28,000
第二个就是可以用那个

1782
01:14:28,000 --> 01:14:34,000
呃 star trek 里面那个 live long and prosper 的手势用

1783
01:14:34,000 --> 01:14:39,000
用把你的十指和中指并在一起把无名指和小指并在一起

1784
01:14:39,000 --> 01:14:40,000
呃

1785
01:14:40,000 --> 01:14:42,000
大部分时候也

1786
01:14:42,000 --> 01:14:44,000
这样可以增强那个手指的

1787
01:14:44,000 --> 01:14:48,000
力度或者说增强手指的依依赖

1788
01:14:48,000 --> 01:14:50,000
第三就是经常在这个

1789
01:14:50,000 --> 01:14:54,000
我刚才说的只用十指和无名指的手势以及呃这个 startrek 手势的力度

1790
01:14:54,000 --> 01:14:57,000
以及呃这个 star trek 手势之间切换

1791
01:14:57,000 --> 01:14:58,000
这样可以

1792
01:14:58,000 --> 01:14:59,000
比较

1793
01:14:59,000 --> 01:15:00,000
有效的

1794
01:15:00,000 --> 01:15:02,000
减少手指的劳损

1795
01:15:02,000 --> 01:15:04,000
当然还有一个 tip 就是经常用左手

1796
01:15:04,000 --> 01:15:05,000
我觉得也挺好

1797
01:15:05,000 --> 01:15:08,000
嗯哼

1798
01:15:08,000 --> 01:15:10,000
对

1799
01:15:10,000 --> 01:15:12,000
呃

1800
01:15:12,000 --> 01:15:17,000
下一篇反馈是一位来自李建鹏的朋友李建宏的朋友

1801
01:15:17,000 --> 01:15:19,000
呃问我们在

1802
01:15:19,000 --> 01:15:22,000
kickstar 上看到那款众筹的键盘怎么样

1803
01:15:22,000 --> 01:15:24,000
呃我就看了一下他说他在这个

1804
01:15:24,000 --> 01:15:25,000
你看了吗

1805
01:15:25,000 --> 01:15:26,000
我看了

1806
01:15:26,000 --> 01:15:26,000
就

1807
01:15:26,000 --> 01:15:28,000
对之前我们

1808
01:15:28,000 --> 01:15:32,000
之前我推荐那款叫什么 true layernomic keyboard 的

1809
01:15:32,000 --> 01:15:34,000
长相有点接近的

1810
01:15:34,000 --> 01:15:35,000
跟他差不多

1811
01:15:35,000 --> 01:15:36,000
只不过他

1812
01:15:36,000 --> 01:15:39,000
更极端一点就是他把

1813
01:15:39,000 --> 01:15:40,000
呃

1814
01:15:40,000 --> 01:15:41,000
首先他

1815
01:15:41,000 --> 01:15:43,000
把键盘做成一个木底

1816
01:15:43,000 --> 01:15:44,000
就是

1817
01:15:44,000 --> 01:15:46,000
下面那个东西是木头做的

1818
01:15:46,000 --> 01:15:46,000
嗯

1819
01:15:46,000 --> 01:15:47,000
呃

1820
01:15:47,000 --> 01:15:49,000
看起来比较

1821
01:15:49,000 --> 01:15:50,000
我很难说他是漂亮但

1822
01:15:50,000 --> 01:15:52,000
有一种不一样的美

1823
01:15:52,000 --> 01:15:53,000
然后呃

1824
01:15:53,000 --> 01:15:59,000
上面的键他做成了一个他一个比较重大的测试呃设计就是

1825
01:15:59,000 --> 01:16:02,000
首先两个键盘键盘的左右部分是可以分开的

1826
01:16:02,000 --> 01:16:04,000
其次啊拇指

1827
01:16:04,000 --> 01:16:07,000
会承担很多工作比如说

1828
01:16:07,000 --> 01:16:08,000
嗯

1829
01:16:08,000 --> 01:16:13,000
空格键被减少减少了一个键然后你在这个拇指的

1830
01:16:13,000 --> 01:16:17,000
最下面那个指关节就是最大那个指关节的部分

1831
01:16:17,000 --> 01:16:17,000
呃

1832
01:16:17,000 --> 01:16:18,000
也有一端键

1833
01:16:18,000 --> 01:16:22,000
然后拇指上拇指的上半部分还要分别控制四个键

1834
01:16:22,000 --> 01:16:23,000
嗯哼

1835
01:16:23,000 --> 01:16:24,000
呃

1836
01:16:24,000 --> 01:16:30,000
我理解就是他的这个设计可以让你保证说你的手指基本上不会移动

1837
01:16:30,000 --> 01:16:32,000
你的手腕基本上不对不会移动

1838
01:16:32,000 --> 01:16:34,000
你的手放在那就可以按到所有软件

1839
01:16:34,000 --> 01:16:39,000
而且那个放在一次是一个就是手掌和这个手

1840
01:16:39,000 --> 01:16:39,000
叫什么

1841
01:16:39,000 --> 01:16:40,000
钱

1842
01:16:40,000 --> 01:16:41,000
币对吧

1843
01:16:41,000 --> 01:16:49,000
他是在一条直线上的而不是说那种一个弯就是一个斜角这样长期的会导致叫什么来的

1844
01:16:49,000 --> 01:16:53,000
万管综合症卖管综合症到底哪个来的万管综合症

1845
01:16:53,000 --> 01:16:57,000
我上次说了我一上一只在说卖管综合症

1846
01:16:57,000 --> 01:17:01,000
对然后被被初遥老师说了

1847
01:17:01,000 --> 01:17:03,000
好吧

1848
01:17:03,000 --> 01:17:04,000
我们今天

1849
01:17:04,000 --> 01:17:05,000
呃

1850
01:17:05,000 --> 01:17:11,000
就不讲其实啊其实那个键盘我要补充一个就是最主要的那种这种异形的键盘

1851
01:17:12,000 --> 01:17:13,000
打字都是提时提好

1852
01:17:13,000 --> 01:17:15,000
挺容易适应的可能打个三五分钟

1853
01:17:16,000 --> 01:17:19,000
或者最慢一点的一两天吧怎么也适应过来了对吧

1854
01:17:19,000 --> 01:17:22,000
最难适应的是各种快捷键的组合

1855
01:17:22,000 --> 01:17:23,000
完全不一样

1856
01:17:23,000 --> 01:17:24,000
对没错

1857
01:17:25,000 --> 01:17:29,000
当然我对这个键盘也不能说完全

1858
01:17:31,000 --> 01:17:32,000
怎么说完全

1859
01:17:33,000 --> 01:17:39,000
完全买他的主意就是他有个问题就是你要把手挪开键盘

1860
01:17:40,000 --> 01:17:42,000
之后再放回去的过程可能会比较痛苦

1861
01:17:43,000 --> 01:17:43,000
嗯

1862
01:17:44,000 --> 01:17:47,000
因为一般的键盘他没有考虑人体工学的话

1863
01:17:48,000 --> 01:17:51,000
你把手挪出去再挪回来你不用特别

1864
01:17:51,000 --> 01:17:53,000
在意说我要把手放来

1865
01:17:53,000 --> 01:17:54,000
你把手放在一个特定的位置

1866
01:17:55,000 --> 01:17:59,000
但是如果你用这个蝴蝶键盘的话你每次把手放回来你都要

1867
01:17:59,000 --> 01:18:00,000
小心的调整

1868
01:18:01,000 --> 01:18:04,000
手掌让手掌落到那个最完美的位置

1869
01:18:05,000 --> 01:18:10,000
我这上想到一个广告就是

1870
01:18:10,000 --> 01:18:12,000
上面是把德国到德国的那个

1871
01:18:12,000 --> 01:18:15,000
双利人的还是 WF 的锄刀

1872
01:18:15,000 --> 01:18:17,000
然后下面是一把

1873
01:18:18,000 --> 01:18:19,000
日本的菜刀

1874
01:18:20,000 --> 01:18:20,000
然后

1875
01:18:21,000 --> 01:18:23,000
德国的锄刀

1876
01:18:23,000 --> 01:18:24,000
非常符合人体工学

1877
01:18:26,000 --> 01:18:27,000
日本的锄刀的那个

1878
01:18:27,000 --> 01:18:30,000
刀柄就是一个平直的木头

1879
01:18:30,000 --> 01:18:32,000
然后下面的注释就说

1880
01:18:33,000 --> 01:18:36,000
德国的刀只有一种最完美的握法

1881
01:18:37,000 --> 01:18:39,000
而日本的刀你想怎么握都可以

1882
01:18:39,000 --> 01:18:41,000
然后基本上也就是

1883
01:18:42,000 --> 01:18:44,000
我觉得我比较喜欢的这种审美就是

1884
01:18:44,000 --> 01:18:46,000
日式的就是你可以把

1885
01:18:46,000 --> 01:18:47,000
这个键盘

1886
01:18:48,000 --> 01:18:50,000
这键盘本身并不去会贴合你

1887
01:18:50,000 --> 01:18:53,000
但是你要去贴合这个键盘但同时也就

1888
01:18:53,000 --> 01:18:56,000
也就意味着你有更多的自由

1889
01:18:58,000 --> 01:19:00,000
对

1890
01:19:00,000 --> 01:19:04,000
其实你说这种人体工学键盘

1891
01:19:04,000 --> 01:19:06,000
其实我一直在想

1892
01:19:06,000 --> 01:19:08,000
所谓真正的人体工学

1893
01:19:08,000 --> 01:19:10,000
好歹是不是每个人还是要

1894
01:19:11,000 --> 01:19:11,000
不同的对吧

1895
01:19:12,000 --> 01:19:14,000
人和人之间是有差异的

1896
01:19:15,000 --> 01:19:17,000
你要真的要做到好的人体工学

1897
01:19:17,000 --> 01:19:20,000
按人的良下来定制

1898
01:19:20,000 --> 01:19:21,000
其实做不到啊

1899
01:19:21,000 --> 01:19:22,000
那不如什么吧

1900
01:19:22,000 --> 01:19:23,000
那除非

1901
01:19:23,000 --> 01:19:26,000
这只有在这个传说中的工业 4.0

1902
01:19:26,000 --> 01:19:27,000
或者工业 4.5

1903
01:19:28,000 --> 01:19:29,000
3 D 打印一块是吧

1904
01:19:29,000 --> 01:19:33,000
你对你先把你的手放到一个扫盘云下面

1905
01:19:33,000 --> 01:19:33,000
扫一下

1906
01:19:34,000 --> 01:19:35,000
看它的尺寸然后

1907
01:19:35,000 --> 01:19:40,000
打印出一个只有你用着最舒服的键盘出来那才是真正的

1908
01:19:40,000 --> 01:19:41,000
别人用各种

1909
01:19:41,000 --> 01:19:42,000
别扭

1910
01:19:42,000 --> 01:19:43,000
就你用的爽

1911
01:19:44,000 --> 01:19:45,000
所以从这个角度讲

1912
01:19:46,000 --> 01:19:49,000
这是一个生意啊我们就可以做 Basebook

1913
01:19:49,000 --> 01:19:50,000
Keyboard

1914
01:19:51,000 --> 01:19:53,000
哈哈哈哈

1915
01:19:53,000 --> 01:19:58,000
我其实我在想说这个工业 4.0 其实有点

1916
01:19:59,000 --> 01:20:00,000
有点朝这个

1917
01:20:01,000 --> 01:20:04,000
Mass production 的反方向跑

1918
01:20:04,000 --> 01:20:04,000
因为

1919
01:20:05,000 --> 01:20:08,000
人类近代史上最伟大的发明之一就是流水线

1920
01:20:09,000 --> 01:20:11,000
或者所谓 massive production

1921
01:20:12,000 --> 01:20:15,000
可以批量化生产我记得我现在看一本

1922
01:20:16,000 --> 01:20:19,000
经济学书里面讲说亚当斯密的时代

1923
01:20:19,000 --> 01:20:23,000
一个人一个工人一个熟练的工人一个小时可能只能

1924
01:20:23,000 --> 01:20:24,000
造十几根针

1925
01:20:24,000 --> 01:20:25,000
大头针

1926
01:20:25,000 --> 01:20:27,000
而我们这时代一个工人在

1927
01:20:28,000 --> 01:20:32,000
平均的小时之内可以造出几万枚大头针

1928
01:20:33,000 --> 01:20:35,000
但是工业 4.0 时代也许

1929
01:20:36,000 --> 01:20:37,000
就意味着

1930
01:20:38,000 --> 01:20:38,000
朝这个

1931
01:20:38,000 --> 01:20:40,000
潮流的

1932
01:20:40,000 --> 01:20:41,000
逆向走

1933
01:20:41,000 --> 01:20:42,000
就是一开始我当然

1934
01:20:43,000 --> 01:20:45,000
基础材料还是 mass production

1935
01:20:45,000 --> 01:20:46,000
mass production 出来

1936
01:20:47,000 --> 01:20:50,000
打印机的粉末但是最终的成品却是

1937
01:20:51,000 --> 01:20:52,000
只有在你需要的时候

1938
01:20:53,000 --> 01:20:54,000
在你需要的那个地方

1939
01:20:55,000 --> 01:20:56,000
被你自己生产出

1940
01:20:56,000 --> 01:20:59,000
对吗这个就是他们之前两年还是

1941
01:21:00,000 --> 01:21:01,000
流行过的一个就是 mass

1942
01:21:01,000 --> 01:21:03,000
mass production

1943
01:21:03,000 --> 01:21:04,000
大规模生产

1944
01:21:04,000 --> 01:21:05,000
大规模定制

1945
01:21:05,000 --> 01:21:07,000
mass customization

1946
01:21:08,000 --> 01:21:08,000
对

1947
01:21:09,000 --> 01:21:10,000
就差不多做嘛

1948
01:21:10,000 --> 01:21:14,000
这两个这些本质是有矛盾的但得益于现在有什么各种各样的

1949
01:21:15,000 --> 01:21:19,000
机器人技术这种 3 D 打印技术可以很快速的

1950
01:21:19,000 --> 01:21:23,000
根据图纸切换出不同的模型出来

1951
01:21:23,000 --> 01:21:27,000
在定制化的

1952
01:21:27,000 --> 01:21:31,000
基础上又能同时满足生产的效率这个还是非常了不得的一个

1953
01:21:31,000 --> 01:21:32,000
一个

1954
01:21:32,000 --> 01:21:34,000
工业史上的一个创新吧

1955
01:21:34,000 --> 01:21:35,000
没错

1956
01:21:35,000 --> 01:21:41,000
说到刚才那个那个快捷键的问题这两天也是为什么一直老觉得很别扭就是在那个

1957
01:21:42,000 --> 01:21:44,000
HKB 上的那些键位和

1958
01:21:44,000 --> 01:21:45,000
这个

1959
01:21:45,000 --> 01:21:48,000
Mac 上的键位和键位有些那种功能键不太一样吧

1960
01:21:49,000 --> 01:21:52,000
那个主键区字母键数字那些都非常容易适应的

1961
01:21:53,000 --> 01:21:55,000
那就是功能键那个

1962
01:21:55,000 --> 01:21:56,000
非常难改

1963
01:21:56,000 --> 01:21:57,000
那你要用这种

1964
01:21:58,000 --> 01:22:00,000
更加人体工学的

1965
01:22:00,000 --> 01:22:02,000
键盘他会考虑把那些

1966
01:22:02,000 --> 01:22:08,000
就是功能键做到一个通常我们说什么小指来按那些功左边的功能键吗

1967
01:22:08,000 --> 01:22:10,000
但是你在这种

1968
01:22:10,000 --> 01:22:14,000
这种完全人体工学的键盘上反而是要用

1969
01:22:14,000 --> 01:22:16,000
食指来按到时候发现

1970
01:22:16,000 --> 01:22:18,000
那我要按一个 Ctrl G 怎么办

1971
01:22:19,000 --> 01:22:20,000
就会很纠结

1972
01:22:21,000 --> 01:22:22,000
最关键是在很多这种

1973
01:22:22,000 --> 01:22:26,000
软件设计者他在制定默认的快捷键的时候

1974
01:22:27,000 --> 01:22:31,000
他会假设是一个正常布局的普通键盘来来去这么设计

1975
01:22:31,000 --> 01:22:33,000
他说比如这个

1976
01:22:33,000 --> 01:22:36,000
这个复制粘贴这个功能比较常用的我们做个快捷键吧

1977
01:22:36,000 --> 01:22:40,000
看哪个快捷键比较顺手按然后大家记得住呢发现

1978
01:22:40,000 --> 01:22:42,000
Ctrl C Ctrl V 不错

1979
01:22:43,000 --> 01:22:43,000
Mac 上就是

1980
01:22:44,000 --> 01:22:44,000
Command C

1981
01:22:45,000 --> 01:22:45,000
Command V

1982
01:22:46,000 --> 01:22:47,000
但是如果你换一下这种

1983
01:22:48,000 --> 01:22:50,000
这种异形的键盘就发现

1984
01:22:50,000 --> 01:22:51,000
好像不是那么顺手

1985
01:22:51,000 --> 01:22:53,000
所以这里面

1986
01:22:53,000 --> 01:22:54,000
就是你要做的

1987
01:22:55,000 --> 01:22:58,000
改动还是蛮多的你得自己定义出一套

1988
01:22:58,000 --> 01:23:02,000
假设你的软件是可以更改这个自己快捷键的话

1989
01:23:02,000 --> 01:23:04,000
有很多人其实不支持的

1990
01:23:04,000 --> 01:23:08,000
就是你要想啊我怎么去在这个键盘的布局上去找一套

1991
01:23:08,000 --> 01:23:10,000
我觉得还不错

1992
01:23:10,000 --> 01:23:12,000
然后我自己能记得住的

1993
01:23:13,000 --> 01:23:17,000
一套快捷键的组合不是一个两个是整套整套的话

1994
01:23:18,000 --> 01:23:18,000
对

1995
01:23:18,000 --> 01:23:19,000
其实挺辛苦的

1996
01:23:20,000 --> 01:23:21,000
是啊

1997
01:23:21,000 --> 01:23:23,000
OK

1998
01:23:23,000 --> 01:23:26,000
现在我们进入今天的主题

1999
01:23:26,000 --> 01:23:27,000
是

2000
01:23:27,000 --> 01:23:28,000
Design Pattern

2001
01:23:29,000 --> 01:23:30,000
设计模式

2002
01:23:31,000 --> 01:23:34,000
又是一期比较

2003
01:23:35,000 --> 01:23:37,000
水可能也不一定但是会比较

2004
01:23:38,000 --> 01:23:39,000
敢

2005
01:23:39,000 --> 01:23:40,000
玄学的东西

2006
01:23:42,000 --> 01:23:44,000
我知道

2007
01:23:45,000 --> 01:23:46,000
就我

2008
01:23:46,000 --> 01:23:47,000
所感受到的一种

2009
01:23:48,000 --> 01:23:49,000
一种

2010
01:23:50,000 --> 01:23:51,000
心态或者一种思潮

2011
01:23:52,000 --> 01:23:52,000
就是

2012
01:23:53,000 --> 01:23:57,000
一切和架构和设计有关的东西都非常的虚

2013
01:23:57,000 --> 01:23:59,000
一切和

2014
01:24:00,000 --> 01:24:04,000
一切比较接近于底层实现或者是比较接近于

2015
01:24:05,000 --> 01:24:08,000
理论和概念性的东西才是真正

2016
01:24:08,000 --> 01:24:11,000
值得人花精力去研究的内功心法

2017
01:24:14,000 --> 01:24:17,000
我不能说这样想不对吧但是我总觉得

2018
01:24:18,000 --> 01:24:19,000
在

2019
01:24:20,000 --> 01:24:21,000
现代这个

2020
01:24:22,000 --> 01:24:24,000
软件越来越大规模的

2021
01:24:25,000 --> 01:24:27,000
工业化的时代

2022
01:24:27,000 --> 01:24:30,000
学点设计模式还是

2023
01:24:31,000 --> 01:24:32,000
有相当必要的因为

2024
01:24:33,000 --> 01:24:35,000
怎么说呢虽然

2025
01:24:35,000 --> 01:24:37,000
最近几年随着这个

2026
01:24:38,000 --> 01:24:41,000
有种打官腔的感觉就是

2027
01:24:41,000 --> 01:24:44,000
最近几年开源运动非常的火

2028
01:24:44,000 --> 01:24:47,000
同时也推行了一大批

2029
01:24:47,000 --> 01:24:48,000
比较黑客比较

2030
01:24:50,000 --> 01:24:51,000
走酷炫流派

2031
01:24:52,000 --> 01:24:52,000
的

2032
01:24:54,000 --> 01:24:55,000
程序员的思潮

2033
01:24:57,000 --> 01:24:58,000
你是想说 Ruby on Rails 吗

2034
01:25:00,000 --> 01:25:04,000
没有特别针对某一个

2035
01:25:05,000 --> 01:25:09,000
Ruby on Rails 没有针对某一个语言或者针对某一个 framework

2036
01:25:09,000 --> 01:25:13,000
但是我想说的一件事情就是比如说有些

2037
01:25:13,000 --> 01:25:14,000
时候

2038
01:25:15,000 --> 01:25:20,000
我不知道你怎么样但是现在我有时候会觉得自己判断一个人是不是牛人的

2039
01:25:20,000 --> 01:25:21,000
标准

2040
01:25:21,000 --> 01:25:22,000
是看他有没有

2041
01:25:23,000 --> 01:25:26,000
有没有搞不出一个知名的工具来

2042
01:25:28,000 --> 01:25:30,000
会看他 GitHub 上面的

2043
01:25:30,000 --> 01:25:31,000
Repository 怎么样

2044
01:25:33,000 --> 01:25:34,000
我想说这

2045
01:25:34,000 --> 01:25:37,000
这些指标的确可以反映出一个人的

2046
01:25:39,000 --> 01:25:40,000
编程能力

2047
01:25:40,000 --> 01:25:41,000
但是

2048
01:25:42,000 --> 01:25:43,000
反过来

2049
01:25:43,000 --> 01:25:46,000
另外有一些编程能力是

2050
01:25:46,000 --> 01:25:49,000
没有办法通过一个 Git repository

2051
01:25:49,000 --> 01:25:50,000
通过一套算法

2052
01:25:51,000 --> 01:25:52,000
或者是画面试题

2053
01:25:52,000 --> 01:25:54,000
或者是通过一篇

2054
01:25:54,000 --> 01:25:56,000
解释某一个

2055
01:25:57,000 --> 01:25:58,000
比较

2056
01:25:58,000 --> 01:26:00,000
晦涩的编程概念能够体现出来的

2057
01:26:02,000 --> 01:26:04,000
而这种能力却恰恰

2058
01:26:04,000 --> 01:26:06,000
很有可能是在

2059
01:26:06,000 --> 01:26:08,000
构建大型程序的时候

2060
01:26:10,000 --> 01:26:11,000
非常需要的

2061
01:26:11,000 --> 01:26:16,000
我觉得这种能力的体现其实就在于

2062
01:26:16,000 --> 01:26:16,000
对于

2063
01:26:17,000 --> 01:26:20,000
比如像设计模式这样一些听起来比较

2064
01:26:21,000 --> 01:26:24,000
大而无当的概念的掌握程度上

2065
01:26:25,000 --> 01:26:28,000
其实我啰嗦的证明大家都想说什么我想说的就是

2066
01:26:29,000 --> 01:26:31,000
最开始提出设计模式的这四个人

2067
01:26:31,000 --> 01:26:35,000
最开始让设计模式这四个人深入人心的

2068
01:26:35,000 --> 01:26:36,000
这四个人

2069
01:26:38,000 --> 01:26:39,000
Erich

2070
01:26:40,000 --> 01:26:40,000
这个

2071
01:26:40,000 --> 01:26:42,000
他是一个瑞士

2072
01:26:43,000 --> 01:26:44,000
Erich Gamma

2073
01:26:44,000 --> 01:26:46,000
Richard Helm

2074
01:26:46,000 --> 01:26:47,000
Ralph Johnson

2075
01:26:48,000 --> 01:26:49,000
还有

2076
01:26:50,000 --> 01:26:51,000
John Vlissier

2077
01:26:51,000 --> 01:26:52,000
Cedis

2078
01:26:52,000 --> 01:26:53,000
这四个人

2079
01:26:53,000 --> 01:26:55,000
他们其实都没有什么

2080
01:26:55,000 --> 01:26:57,000
说出来特别了不起的成绩

2081
01:26:59,000 --> 01:27:00,000
当然 Erich Gamma

2082
01:27:01,000 --> 01:27:02,000
是一个比较

2083
01:27:02,000 --> 01:27:07,000
比较重要的人物他现在在应该是现在应该是在 Microsoft

2084
01:27:08,000 --> 01:27:10,000
这四个人都没有什么

2085
01:27:11,000 --> 01:27:13,000
能够单独摆出来说这个人就是

2086
01:27:13,000 --> 01:27:14,000
做冷链设计的那个人

2087
01:27:15,000 --> 01:27:18,000
但是他们四个人毫无疑问都是在

2088
01:27:18,000 --> 01:27:19,000
工业

2089
01:27:19,000 --> 01:27:21,000
在比较大的软件上

2090
01:27:21,000 --> 01:27:22,000
在软件界

2091
01:27:22,000 --> 01:27:27,000
比较大的软件工程项目之中摸牌不拿很多年的人

2092
01:27:27,000 --> 01:27:30,000
才可以写出这样一些比较

2093
01:27:30,000 --> 01:27:31,000
才可以把

2094
01:27:31,000 --> 01:27:33,000
比较重要的设计模式总结

2095
01:27:34,000 --> 01:27:35,000
成这样一本书然后

2096
01:27:37,000 --> 01:27:38,000
展现给大家

2097
01:27:42,000 --> 01:27:45,000
如果你去搜他们四个人的资料的话

2098
01:27:46,000 --> 01:27:47,000
其实就

2099
01:27:48,000 --> 01:27:48,000
找不到什么

2100
01:27:49,000 --> 01:27:50,000
但是

2101
01:27:50,000 --> 01:27:52,000
并不意味着他们就没有

2102
01:27:53,000 --> 01:27:53,000
能够

2103
01:27:55,000 --> 01:27:56,000
交给别人的东西

2104
01:27:56,000 --> 01:27:58,000
所以 Ryo 你是什么时候接触设计模式

2105
01:27:59,000 --> 01:27:59,000
或者说你

2106
01:27:59,000 --> 01:28:00,000
根本接触过设计模式

2107
01:28:01,000 --> 01:28:02,000
你使用过设计模式

2108
01:28:02,000 --> 01:28:03,000
没有啊

2109
01:28:04,000 --> 01:28:08,000
因为其实在我的理解里面设计模式这种一般是属于

2110
01:28:08,000 --> 01:28:12,000
学这个 software engineering 的专业人才会去

2111
01:28:12,000 --> 01:28:13,000
去

2112
01:28:13,000 --> 01:28:14,000
去关注的

2113
01:28:14,000 --> 01:28:18,000
甚至是连就是这个通常一上 CS 就是肯定是 Science

2114
01:28:18,000 --> 01:28:19,000
他对这个东西的

2115
01:28:20,000 --> 01:28:23,000
就没有那么关注因为它是一个非常工业化的

2116
01:28:24,000 --> 01:28:25,000
需求

2117
01:28:25,000 --> 01:28:27,000
并不是一个学院化的东西

2118
01:28:29,000 --> 01:28:32,000
对所以如果打一个不太强的比例的话

2119
01:28:33,000 --> 01:28:34,000
比方的话那就是

2120
01:28:35,000 --> 01:28:37,000
Design Pattern 所描述的是

2121
01:28:38,000 --> 01:28:40,000
你应该盖什么样的房子

2122
01:28:40,000 --> 01:28:42,000
或者说你应该怎样盖房

2123
01:28:42,000 --> 01:28:45,000
而我们日常在

2124
01:28:45,000 --> 01:28:50,000
在学校里面所学到的更多的是比如像结构力学啊

2125
01:28:50,000 --> 01:28:51,000
或者是

2126
01:28:53,000 --> 01:28:56,000
房屋造价核算啊这样的一些东西

2127
01:28:58,000 --> 01:28:59,000
这基本上是一个

2128
01:29:00,000 --> 01:29:01,000
艺术和科学之间的分野

2129
01:29:02,000 --> 01:29:03,000
就如果你要

2130
01:29:03,000 --> 01:29:07,000
一定要把它往高大上的方向说的话设计模式其实这样的东西

2131
01:29:08,000 --> 01:29:09,000
然后

2132
01:29:10,000 --> 01:29:11,000
我看设计模式已经是

2133
01:29:13,000 --> 01:29:14,000
十年前的事了至少

2134
01:29:15,000 --> 01:29:19,000
所以我为了准备这期节目也没有把它找出来重新看一遍

2135
01:29:20,000 --> 01:29:20,000
我只记得

2136
01:29:21,000 --> 01:29:23,000
那本书的封面是艾舍尔的画

2137
01:29:24,000 --> 01:29:25,000
艾舍尔是一个荷兰画家

2138
01:29:26,000 --> 01:29:27,000
他的画非常有意思

2139
01:29:28,000 --> 01:29:31,000
我对他唯一印象就是他的封面是那幅画

2140
01:29:32,000 --> 01:29:35,000
然后这四个人合起来叫做四人帮

2141
01:29:35,000 --> 01:29:37,000
Gangfor 这个名字其实是

2142
01:29:38,000 --> 01:29:39,000
这本书出来的

2143
01:29:40,000 --> 01:29:42,000
时候中国的这个文化大革命的

2144
01:29:43,000 --> 01:29:47,000
四人帮这个概念刚刚传到国外不久

2145
01:29:47,000 --> 01:29:49,000
所以他们就把这个四人帮的

2146
01:29:49,000 --> 01:29:50,000
称呼

2147
01:29:50,000 --> 01:29:51,000
拿过来套在了这四人身上

2148
01:29:52,000 --> 01:29:53,000
太倒霉了

2149
01:29:54,000 --> 01:29:55,000
这不是说笑

2150
01:29:56,000 --> 01:29:56,000
真的是这样

2151
01:29:57,000 --> 01:29:58,000
我知道他们太倒霉了

2152
01:30:01,000 --> 01:30:03,000
我觉得可能

2153
01:30:03,000 --> 01:30:05,000
英语世界的人不太能够理解

2154
01:30:05,000 --> 01:30:07,000
四人帮在

2155
01:30:07,000 --> 01:30:09,000
至少在中国的

2156
01:30:09,000 --> 01:30:11,000
语境之下说出来是一个

2157
01:30:12,000 --> 01:30:14,000
多么负面和恐怖的

2158
01:30:14,000 --> 01:30:15,000
词但

2159
01:30:16,000 --> 01:30:18,000
也觉得他们看来真的就是一个 Gang 而已

2160
01:30:20,000 --> 01:30:24,000
然后我记得如果没记错的话他们在前言里面提到了

2161
01:30:25,000 --> 01:30:26,000
一本书

2162
01:30:26,000 --> 01:30:28,000
这本书是来自于

2163
01:30:28,000 --> 01:30:29,000
建筑专业的

2164
01:30:30,000 --> 01:30:33,000
一本讲述

2165
01:30:33,000 --> 01:30:34,000
怎么说呢

2166
01:30:35,000 --> 01:30:36,000
建筑方法论的一本书

2167
01:30:36,000 --> 01:30:39,000
这本书叫做建筑的永恒之道

2168
01:30:39,000 --> 01:30:41,000
Timeless way of building

2169
01:30:41,000 --> 01:30:44,000
之后在一个很机缘巧合

2170
01:30:44,000 --> 01:30:46,000
场景下我拿到的这本书的中文版

2171
01:30:48,000 --> 01:30:49,000
翻译一下觉得没有

2172
01:30:50,000 --> 01:30:51,000
这个没有

2173
01:30:51,000 --> 01:30:53,000
摄影模式这本书

2174
01:30:54,000 --> 01:30:55,000
吹加引号那么神奇

2175
01:30:59,000 --> 01:31:03,000
而且我也不是很推荐大家去看因为如果你不结合那个

2176
01:31:04,000 --> 01:31:05,000
这本书的

2177
01:31:05,000 --> 01:31:07,000
当时的

2178
01:31:08,000 --> 01:31:09,000
context 的话是不是

2179
01:31:10,000 --> 01:31:10,000
挺难理解的

2180
01:31:11,000 --> 01:31:13,000
这本书出版于 1979 年

2181
01:31:13,000 --> 01:31:14,000
就比

2182
01:31:15,000 --> 01:31:16,000
90 年代的

2183
01:31:17,000 --> 01:31:18,000
面相模式

2184
01:31:20,000 --> 01:31:22,000
现在的设计模式还要早上

2185
01:31:27,000 --> 01:31:28,000
总的来说

2186
01:31:28,000 --> 01:31:32,000
建筑永恒之道这本书里面所试图表达的一个观点就是你在

2187
01:31:33,000 --> 01:31:35,000
造建筑的时候你必须

2188
01:31:35,000 --> 01:31:38,000
想方设法去达到一种

2189
01:31:39,000 --> 01:31:41,000
没有办法定义的

2190
01:31:41,000 --> 01:31:42,000
quality

2191
01:31:44,000 --> 01:31:49,000
有点像那个神棍书就是禅与摩托车维护的艺术里面

2192
01:31:49,000 --> 01:31:51,000
所提到的所谓量纸

2193
01:31:52,000 --> 01:31:52,000
你要

2194
01:31:53,000 --> 01:31:56,000
使你的建筑能够体现出这样一种

2195
01:31:56,000 --> 01:31:58,000
你说他是煤也好说他是

2196
01:31:59,000 --> 01:32:00,000
道也好这样一种

2197
01:32:00,000 --> 01:32:01,000
质量来

2198
01:32:02,000 --> 01:32:07,000
而为了达成这种质量你必须遵循一些特定的模式

2199
01:32:08,000 --> 01:32:12,000
然后这个概念这个 design pattern 的这个概念就

2200
01:32:12,000 --> 01:32:13,000
源自于这本书

2201
01:32:13,000 --> 01:32:17,000
然后 1994 年的思维作者所写的这个

2202
01:32:18,000 --> 01:32:19,000
设计模式

2203
01:32:19,000 --> 01:32:19,000
或者说

2204
01:32:20,000 --> 01:32:21,000
全称叫做

2205
01:32:23,000 --> 01:32:28,000
如何构建更好的面向对象的程序

2206
01:32:29,000 --> 01:32:35,000
也就借用这个概念是想要总结出一些在使用面向对象的技术来写程序的时候

2207
01:32:35,000 --> 01:32:37,000
人们应该遵循一些比较

2208
01:32:37,000 --> 01:32:39,000
常见的

2209
01:32:39,000 --> 01:32:40,000
技巧和方法

2210
01:32:44,000 --> 01:32:46,000
这基本上就是一个对于设计模式不那么

2211
01:32:48,000 --> 01:32:49,000
教科书式的解释

2212
01:32:50,000 --> 01:32:50,000
至少

2213
01:32:51,000 --> 01:32:52,000
大概就是我的意见

2214
01:32:53,000 --> 01:32:58,000
其实如果我们接着拿那个建筑那个例子来做对比的话

2215
01:32:58,000 --> 01:33:00,000
所谓设计模式会就是说

2216
01:33:00,000 --> 01:33:04,000
有一堆老师傅告诉你说你看我跟你说

2217
01:33:04,000 --> 01:33:04,000
你这个

2218
01:33:05,000 --> 01:33:05,000
你这个什么

2219
01:33:06,000 --> 01:33:08,000
这个墙得这么气

2220
01:33:09,000 --> 01:33:10,000
他才会稳固才会倒

2221
01:33:10,000 --> 01:33:13,000
你要那么你要那个按你那个方法去也可以但是可能

2222
01:33:13,000 --> 01:33:14,000
就是那个什么

2223
01:33:14,000 --> 01:33:16,000
不太结实一推就倒了

2224
01:33:17,000 --> 01:33:18,000
就做的是一个

2225
01:33:19,000 --> 01:33:19,000
把

2226
01:33:19,000 --> 01:33:21,000
过往的经验

2227
01:33:22,000 --> 01:33:23,000
抽象出来

2228
01:33:23,000 --> 01:33:24,000
叫什么来的

2229
01:33:25,000 --> 01:33:26,000
就是成为一个

2230
01:33:27,000 --> 01:33:30,000
可以被后人学习的这么一个东西

2231
01:33:31,000 --> 01:33:32,000
对可以这么说

2232
01:33:33,000 --> 01:33:36,000
但我要强调一点就是设计模式是一个比较

2233
01:33:37,000 --> 01:33:39,000
在更高的抽象层级上

2234
01:33:39,000 --> 01:33:41,000
工作的这样一种机制就是

2235
01:33:41,000 --> 01:33:44,000
你说的气强我觉得可能更

2236
01:33:44,000 --> 01:33:47,000
合适的比喻是比如说 hackers delight

2237
01:33:48,000 --> 01:33:48,000
或者是

2238
01:33:49,000 --> 01:33:53,000
programming pearl 就是编程珠机

2239
01:33:53,000 --> 01:33:55,000
这本书里面所讲的那些

2240
01:33:56,000 --> 01:33:58,000
技巧就是在一些比较

2241
01:34:01,000 --> 01:34:01,000
比较

2242
01:34:02,000 --> 01:34:06,000
颗粒度比较小的级别上面告诉你怎样写出质量更好的代码

2243
01:34:07,000 --> 01:34:09,000
而设计模式则更多的是在

2244
01:34:10,000 --> 01:34:11,000
比较高级的

2245
01:34:11,000 --> 01:34:16,000
层面上比如说沿用建筑的比方的话那可能建筑模式设计模式

2246
01:34:16,000 --> 01:34:19,000
所要表达的是比如说你要怎样用两个

2247
01:34:20,000 --> 01:34:23,000
怎样用一个长廊连接两个

2248
01:34:23,000 --> 01:34:24,000
屋子

2249
01:34:24,000 --> 01:34:29,000
然后你把屋子摆成这样会给人一种什么样的

2250
01:34:29,000 --> 01:34:31,000
给人一种什么样的印象

2251
01:34:31,000 --> 01:34:35,000
让人让这个起居者会有怎样的动线

2252
01:34:35,000 --> 01:34:41,000
乃至于你写的你造的这个屋子要怎样才能跟周围的环境融合起来

2253
01:34:42,000 --> 01:34:45,000
怎样才能保证说你要符合当地的

2254
01:34:46,000 --> 01:34:47,000
比如说风水

2255
01:34:47,000 --> 01:34:49,000
或者是要比如要

2256
01:34:50,000 --> 01:34:52,000
怎样才能不去破坏周围的植被

2257
01:34:52,000 --> 01:34:53,000
乃至于怎样

2258
01:34:53,000 --> 01:34:55,000
故意的让你的建筑

2259
01:34:55,000 --> 01:34:59,000
和周围的建筑产生一定反差比如说那个

2260
01:35:00,000 --> 01:35:01,000
北京的叫什么

2261
01:35:02,000 --> 01:35:04,000
大剧院或者是杜玉明做的那个

2262
01:35:04,000 --> 01:35:05,000
卢浮宫的入口

2263
01:35:06,000 --> 01:35:06,000
诸如此类的东西

2264
01:35:07,000 --> 01:35:09,000
设计模式讨论的是这样一种东西

2265
01:35:09,000 --> 01:35:11,000
就是更接近于艺术性的东西

2266
01:35:13,000 --> 01:35:15,000
但是与此同时它又没有那么的

2267
01:35:17,000 --> 01:35:17,000
渺渺

2268
01:35:18,000 --> 01:35:19,000
就我有时候我觉得

2269
01:35:19,000 --> 01:35:21,000
当然我

2270
01:35:21,000 --> 01:35:22,000
我对建筑只是比较

2271
01:35:23,000 --> 01:35:28,000
奇怪的有比较奇怪的兴趣但有时候我觉得建筑里面的模式是非常难以总结和附用的

2272
01:35:29,000 --> 01:35:30,000
而且

2273
01:35:30,000 --> 01:35:33,000
建筑艺术性太强了建筑师会倾向于用

2274
01:35:34,000 --> 01:35:35,000
比较

2275
01:35:35,000 --> 01:35:38,000
有个性化的方法去去诠释所谓的

2276
01:35:39,000 --> 01:35:42,000
设计模式但是在软件工程的设计模式里面

2277
01:35:42,000 --> 01:35:44,000
基本上每一个模式都是

2278
01:35:46,000 --> 01:35:47,000
不那么风格化的

2279
01:35:47,000 --> 01:35:48,000
就是

2280
01:35:48,000 --> 01:35:49,000
比如说

2281
01:35:50,000 --> 01:35:50,000
,

2282
01:35:51,000 --> 01:35:53,000
你也写 visitor pattern 我也写 visitor pattern

2283
01:35:54,000 --> 01:35:54,000
都一样

2284
01:35:55,000 --> 01:35:56,000
你哪怕起另外一个名字

2285
01:35:57,000 --> 01:35:59,000
玫瑰一千种名字

2286
01:35:59,000 --> 01:36:00,000
还是

2287
01:36:00,000 --> 01:36:02,000
还是那样一个东西就是如果你能

2288
01:36:03,000 --> 01:36:08,000
如果你接触这个模式的话别人哪怕换一个名字来写你还是可以意识到的就是那个模式本身

2289
01:36:09,000 --> 01:36:11,000
它没有那么多的艺术价值

2290
01:36:11,000 --> 01:36:13,000
所以总结来说

2291
01:36:14,000 --> 01:36:16,000
设计模式基本上就是

2292
01:36:16,000 --> 01:36:17,000
比较高层次的

2293
01:36:18,000 --> 01:36:19,000
被总结出来的凝固的模式

2294
01:36:20,000 --> 01:36:20,000
就是一个最好的实验

2295
01:36:21,000 --> 01:36:23,000
然后它的意义就是可以在

2296
01:36:24,000 --> 01:36:25,000
帮助你在

2297
01:36:25,000 --> 01:36:28,000
告诉你在各种情况之下怎样能比较好的

2298
01:36:30,000 --> 01:36:31,000
建构构建代码

2299
01:36:32,000 --> 01:36:33,000
然后让你的代码之间

2300
01:36:33,000 --> 01:36:34,000
解钥

2301
01:36:34,000 --> 01:36:35,000
因为

2302
01:36:36,000 --> 01:36:43,000
设计模式的两大要素就是一个是要 program to interface

2303
01:36:43,000 --> 01:36:44,000
not implementation

2304
01:36:44,000 --> 01:36:46,000
另一个就是

2305
01:36:46,000 --> 01:36:48,000
prefer favor object

2306
01:36:48,000 --> 01:36:51,000
object composition over inheritance

2307
01:36:51,000 --> 01:36:52,000
就是

2308
01:36:52,000 --> 01:36:53,000
你要针对

2309
01:36:54,000 --> 01:36:55,000
这个

2310
01:36:55,000 --> 01:36:57,000
界面而非实现

2311
01:36:57,000 --> 01:36:58,000
来编程

2312
01:36:58,000 --> 01:37:03,000
另外一方面你要更多的使用 object composition 就是你要让一个

2313
01:37:04,000 --> 01:37:06,000
object 去包含另外一个 object

2314
01:37:07,000 --> 01:37:09,000
而不是让一个 object 继承自另外一个 object

2315
01:37:11,000 --> 01:37:12,000
我这两个这两点其实

2316
01:37:13,000 --> 01:37:15,000
算是过了这么久一直

2317
01:37:15,000 --> 01:37:17,000
颠扑不破的两个真理吧

2318
01:37:17,000 --> 01:37:18,000
对

2319
01:37:18,000 --> 01:37:21,000
而且你如果从这个角度去

2320
01:37:21,000 --> 01:37:25,000
反观很多设计的话你会觉得很多设计都是有问题

2321
01:37:27,000 --> 01:37:29,000
我不知道你怎么看但至少

2322
01:37:29,000 --> 01:37:33,000
object composition over inheritance 这一点在

2323
01:37:35,000 --> 01:37:37,000
objective C 里面体现的非常明显

2324
01:37:40,000 --> 01:37:46,000
应该不应该这么说应该说 objective C 的一个库也就是苹果用的 coco 库里面

2325
01:37:46,000 --> 01:37:47,000
这点体现的比较明显

2326
01:37:48,000 --> 01:37:50,000
coco 的所有的

2327
01:37:51,000 --> 01:37:51,000
用力

2328
01:37:52,000 --> 01:37:54,000
基本上都在推荐你使用 composition

2329
01:37:54,000 --> 01:37:56,000
很少会说你来

2330
01:37:56,000 --> 01:37:58,000
继承一下这个

2331
01:37:58,000 --> 01:37:59,000
我的这样一个

2332
01:38:01,000 --> 01:38:03,000
积累然后

2333
01:38:03,000 --> 01:38:06,000
通过继承方法来实现你自己的一些业务

2334
01:38:07,000 --> 01:38:09,000
可是反过来再回到黑帐

2335
01:38:09,000 --> 01:38:16,000
在 java 世界里面你会发现很多人尤其在 J 2 E 的世界里面有很多很多东西很多很多

2336
01:38:16,000 --> 01:38:17,000
时候你都是被逼着使用

2337
01:38:18,000 --> 01:38:19,000
inheritance

2338
01:38:20,000 --> 01:38:26,000
然后你会大量的去找说这个目前这个类他的 inheritance 的 tree 是怎么样的

2339
01:38:26,000 --> 01:38:29,000
他上面继承了谁下面又被谁继承了然后

2340
01:38:29,000 --> 01:38:34,000
导致你牵一发而动学生然后这个时候你再回头来看

2341
01:38:35,000 --> 01:38:40,000
Design Pattern 这本书里面所强调这个 object composition over inheritance 你会觉得

2342
01:38:42,000 --> 01:38:43,000
何苦呢

2343
01:38:44,000 --> 01:38:44,000
真的是

2344
01:38:44,000 --> 01:38:46,000
对这个

2345
01:38:46,000 --> 01:38:48,000
可能也是就为什么大家一直在

2346
01:38:48,000 --> 01:38:50,000
黑这个 java 的一个重要的原因就是

2347
01:38:52,000 --> 01:38:54,000
你总感我总有一种感觉就是

2348
01:38:54,000 --> 01:38:55,000
Java 本身还是

2349
01:38:56,000 --> 01:38:57,000
挺好的但是被一堆

2350
01:38:57,000 --> 01:38:59,000
这个被 OOP

2351
01:38:59,000 --> 01:39:00,000
邪教

2352
01:39:00,000 --> 01:39:04,000
迷惑了的人在那里

2353
01:39:04,000 --> 01:39:09,000
去在 java 平台上写一些东西出来搞得非常臃肿不堪

2354
01:39:09,000 --> 01:39:09,000
不是很迷惑

2355
01:39:11,000 --> 01:39:13,000
对我前段时间在 hacknews 上看了一个

2356
01:39:14,000 --> 01:39:16,000
news group 里面的

2357
01:39:16,000 --> 01:39:17,000
八卦

2358
01:39:18,000 --> 01:39:20,000
那个 java 设计员的

2359
01:39:20,000 --> 01:39:21,000
java 语言的设计者

2360
01:39:22,000 --> 01:39:23,000
的第二设计者就是

2361
01:39:24,000 --> 01:39:26,000
起到了一些

2362
01:39:27,000 --> 01:39:30,000
语法方面的决策作用的一个人叫

2363
01:39:31,000 --> 01:39:31,000
叫什么来着

2364
01:39:32,000 --> 01:39:32,000
Norton

2365
01:39:33,000 --> 01:39:33,000
他应该姓 Norton

2366
01:39:34,000 --> 01:39:34,000
他是一个

2367
01:39:35,000 --> 01:39:39,000
之所以会记住这个名字是因为他在 90 年代末期有过一桩非常有名的恋童案件

2368
01:39:40,000 --> 01:39:40,000
他去

2369
01:39:41,000 --> 01:39:41,000
他

2370
01:39:42,000 --> 01:39:44,000
坐着私人的喷气机去

2371
01:39:45,000 --> 01:39:45,000
迪斯尼

2372
01:39:46,000 --> 01:39:48,000
会一个 13 岁的小女孩

2373
01:39:48,000 --> 01:39:49,000
并且要求

2374
01:39:49,000 --> 01:39:51,000
并且要求这个小女孩

2375
01:39:53,000 --> 01:39:53,000
跳脱音舞

2376
01:39:55,000 --> 01:39:56,000
还是

2377
01:39:56,000 --> 01:39:58,000
做一些别的什么事情

2378
01:39:58,000 --> 01:40:02,000
然后后来这个小女孩其实是 FBI 的一个侦探

2379
01:40:02,000 --> 01:40:05,000
看起来比较小然后

2380
01:40:06,000 --> 01:40:07,000
隐藏了自己的真实年龄

2381
01:40:07,000 --> 01:40:09,000
然后这个人被告到法庭上

2382
01:40:09,000 --> 01:40:09,000
最后

2383
01:40:10,000 --> 01:40:15,000
最后的处罚好像挺荒诞的是让他免费为 FBI 工作一年

2384
01:40:16,000 --> 01:40:17,000
是这个处罚

2385
01:40:19,000 --> 01:40:19,000
然后

2386
01:40:19,000 --> 01:40:23,000
打个岔这个人他是 Java 的语言的发明者然后他在

2387
01:40:24,000 --> 01:40:24,000
之一

2388
01:40:24,000 --> 01:40:25,000
对

2389
01:40:25,000 --> 01:40:28,000
他在 newsgroup 里面提到说

2390
01:40:28,000 --> 01:40:29,000
Java 其实受到了

2391
01:40:30,000 --> 01:40:34,000
非常严重的 objective C 的影响

2392
01:40:35,000 --> 01:40:37,000
但是这种影响

2393
01:40:37,000 --> 01:40:40,000
很显然仅仅局限在这个语言的特性上

2394
01:40:40,000 --> 01:40:42,000
比如说他有很多动态的

2395
01:40:43,000 --> 01:40:45,000
机制

2396
01:40:45,000 --> 01:40:47,000
每个方法都是存储在

2397
01:40:48,000 --> 01:40:51,000
class 内部的一个 field 之类

2398
01:40:51,000 --> 01:40:53,000
但是

2399
01:40:53,000 --> 01:40:57,000
这样一种语言所衍生出来的两个库确实大相径庭了

2400
01:40:57,000 --> 01:40:58,000
我必须说

2401
01:40:59,000 --> 01:41:00,000
在 Java 的

2402
01:41:02,000 --> 01:41:04,000
整个类库里面

2403
01:41:04,000 --> 01:41:06,000
在很多时候都是

2404
01:41:07,000 --> 01:41:10,000
和这个 objective C 所衍生出来的最广泛使用的类库

2405
01:41:11,000 --> 01:41:15,000
完全不相像的一些设计哲学的习惯

2406
01:41:16,000 --> 01:41:18,000
其实这也是我之前在用

2407
01:41:18,000 --> 01:41:20,000
Scalar 的时候遇到的一个问题

2408
01:41:20,000 --> 01:41:22,000
就是因为 Scalar 是

2409
01:41:22,000 --> 01:41:23,000
跑在 JVM

2410
01:41:23,000 --> 01:41:24,000
他也是

2411
01:41:25,000 --> 01:41:27,000
比较能够方便调用 Java 的那些

2412
01:41:27,000 --> 01:41:28,000
用 Java 写的那些

2413
01:41:29,000 --> 01:41:30,000
包嘛

2414
01:41:30,000 --> 01:41:31,000
对目前的

2415
01:41:31,000 --> 01:41:32,000
然后你会发现

2416
01:41:32,000 --> 01:41:33,000
他那个

2417
01:41:34,000 --> 01:41:36,000
一旦到了你用别人一个

2418
01:41:36,000 --> 01:41:38,000
针对 Java 写的这么一个包的时候

2419
01:41:38,000 --> 01:41:41,000
他的一些接口啊整个设计哲学就完全是

2420
01:41:41,000 --> 01:41:43,000
一种纯 OOP 的思维

2421
01:41:43,000 --> 01:41:44,000
然后

2422
01:41:44,000 --> 01:41:45,000
Scalar 他是一个

2423
01:41:46,000 --> 01:41:47,000
OOP 加 FP

2424
01:41:47,000 --> 01:41:48,000
混合的

2425
01:41:48,000 --> 01:41:50,000
这么一种泛式的语言了

2426
01:41:50,000 --> 01:41:52,000
用起来非常非常便宜

2427
01:41:52,000 --> 01:41:55,000
你需要在两种思维泛式之间切换吗

2428
01:41:55,000 --> 01:41:59,000
对有时候你会看到为什么 Java 这不傻逼吗为什么这么设计

2429
01:42:00,000 --> 01:42:01,000
但其实也主要的原因就是说

2430
01:42:01,000 --> 01:42:05,000
Java 语言本身有一些特殊的限制导致不那么写

2431
01:42:05,000 --> 01:42:08,000
反而可能重用和这个

2432
01:42:08,000 --> 01:42:09,000
这个叫什么来的

2433
01:42:10,000 --> 01:42:11,000
代码的构建没有那么

2434
01:42:12,000 --> 01:42:13,000
灵活但是你到一个

2435
01:42:15,000 --> 01:42:17,000
更加灵活的语言里面去看

2436
01:42:18,000 --> 01:42:21,000
那种设计那种限制导致出来的接口的设计

2437
01:42:22,000 --> 01:42:23,000
其实非常笨拙

2438
01:42:25,000 --> 01:42:26,000
是

2439
01:42:26,000 --> 01:42:29,000
其实我最近在写 Swift 的时候有种感觉

2440
01:42:29,000 --> 01:42:32,000
因为 Swift 目前的状态还是有

2441
01:42:33,000 --> 01:42:38,000
虽然在主动减少但还是有一部分东西是要跟那个 Coco

2442
01:42:38,000 --> 01:42:39,000
或者跟

2443
01:42:40,000 --> 01:42:42,000
底层的 Object C 的代码实现相交互

2444
01:42:43,000 --> 01:42:45,000
然后这个时候你会发现

2445
01:42:46,000 --> 01:42:47,000
你会感觉到一种

2446
01:42:48,000 --> 01:42:50,000
从文法上面

2447
01:42:51,000 --> 01:42:52,000
不是文法是从

2448
01:42:54,000 --> 01:42:57,000
Literacy 上面就可以感受到两者的这个

2449
01:42:58,000 --> 01:42:58,000
冲撞

2450
01:42:59,000 --> 01:43:04,000
Swift 的很多东西都是非常简洁的比如说 function 这个词都不愿意拼好

2451
01:43:04,000 --> 01:43:05,000
写个 Funk

2452
01:43:05,000 --> 01:43:07,000
然后或者

2453
01:43:07,000 --> 01:43:10,000
有很多 Shortcut 比如说最新的什么 Fall

2454
01:43:11,000 --> 01:43:12,000
X in Y

2455
01:43:12,000 --> 01:43:13,000
Where Z

2456
01:43:14,000 --> 01:43:15,000
然后你可以少写一个

2457
01:43:16,000 --> 01:43:17,000
你可以少

2458
01:43:17,000 --> 01:43:18,000
可以通过这个

2459
01:43:18,000 --> 01:43:19,000
直接在那个

2460
01:43:20,000 --> 01:43:21,000
Loop

2461
01:43:23,000 --> 01:43:25,000
体的外面就把一些编辑条件过去了

2462
01:43:26,000 --> 01:43:27,000
但是当你

2463
01:43:27,000 --> 01:43:29,000
采用这样一种简洁的写法

2464
01:43:29,000 --> 01:43:33,000
写成序正爽的时候忽然跳到一个地方你需要呼叫一个

2465
01:43:33,000 --> 01:43:35,000
一看就是 Object C

2466
01:43:35,000 --> 01:43:36,000
是在留下

2467
01:43:36,000 --> 01:43:37,000
遗留下来的

2468
01:43:37,000 --> 01:43:38,000
API 的时候

2469
01:43:38,000 --> 01:43:40,000
这个 API 的名字是怒肠

2470
01:43:41,000 --> 01:43:43,000
觉得很另类

2471
01:43:43,000 --> 01:43:47,000
String by Appending another string with format 之类的这样一个

2472
01:43:47,000 --> 01:43:50,000
这样一个非常长的

2473
01:43:50,000 --> 01:43:53,000
如果没有这自动提示真的是

2474
01:43:54,000 --> 01:43:56,000
怎么换来了

2475
01:43:57,000 --> 01:44:00,000
这样一个含出名字出来你就可以明显的感觉到这两种

2476
01:44:01,000 --> 01:44:04,000
编程思维在冲撞

2477
01:44:05,000 --> 01:44:10,000
但是所幸目前看来 Swift 的更新速度还是比较快的也许在

2478
01:44:10,000 --> 01:44:12,000
比较

2479
01:44:12,000 --> 01:44:15,000
足够近的将来我们就可以使用一些比较

2480
01:44:15,000 --> 01:44:16,000
更

2481
01:44:17,000 --> 01:44:20,000
有更多的 Swiftness 在里面的 API

2482
01:44:21,000 --> 01:44:26,000
现在不是上次 WCC 说的时候是他们也逐渐把那些

2483
01:44:26,000 --> 01:44:30,000
Cocoa 那些底层的库要叫做 Swift 化了吗

2484
01:44:31,000 --> 01:44:31,000
对

2485
01:44:31,000 --> 01:44:33,000
就是按照 Swift 方法给一个

2486
01:44:33,000 --> 01:44:34,000
这种

2487
01:44:34,000 --> 01:44:35,000
新的接口

2488
01:44:36,000 --> 01:44:37,000
不要用那种原用的

2489
01:44:37,000 --> 01:44:37,000
确实

2490
01:44:38,000 --> 01:44:39,000
用起来真的很别扭

2491
01:44:39,000 --> 01:44:40,000
对

2492
01:44:41,000 --> 01:44:45,000
我乐观估计这个大概需要 3 到 5 年的时间

2493
01:44:45,000 --> 01:44:47,000
果然很

2494
01:44:47,000 --> 01:44:48,000
乐观

2495
01:44:48,000 --> 01:44:50,000
不是 5 到 10 年吗

2496
01:44:51,000 --> 01:44:53,000
我觉得 3 到 5 年应该差不多

2497
01:44:53,000 --> 01:44:54,000
对因为

2498
01:44:54,000 --> 01:44:56,000
看他们决心怎么样

2499
01:44:56,000 --> 01:44:59,000
我觉得还是要看他们对于新产品的

2500
01:44:59,000 --> 01:45:01,000
投入以及对于改这个

2501
01:45:03,000 --> 01:45:08,000
偿还这个技术债务的投入之间找到的平衡

2502
01:45:08,000 --> 01:45:11,000
但也像你说的你说目前他采用的这个叫什么 TikTak

2503
01:45:12,000 --> 01:45:13,000
的策略

2504
01:45:16,000 --> 01:45:17,000
一年发布新产品

2505
01:45:17,000 --> 01:45:19,000
一次发出新闻新产品

2506
01:45:19,000 --> 01:45:20,000
另一次

2507
01:45:21,000 --> 01:45:22,000
就是

2508
01:45:23,000 --> 01:45:25,000
做维护做升级修复既有产品的

2509
01:45:25,000 --> 01:45:26,000
障碍

2510
01:45:26,000 --> 01:45:27,000
缺陷

2511
01:45:27,000 --> 01:45:28,000
我觉得这个策略还是挺好

2512
01:45:29,000 --> 01:45:30,000
但就看他保持得怎么样

2513
01:45:32,000 --> 01:45:34,000
说回这个设计模式

2514
01:45:34,000 --> 01:45:36,000
其实有一点我一直有点疑惑

2515
01:45:37,000 --> 01:45:38,000
其实我也是看很多人

2516
01:45:38,000 --> 01:45:40,000
对这个设计模式的批评

2517
01:45:40,000 --> 01:45:40,000
就是说

2518
01:45:41,000 --> 01:45:44,000
就是至少在那本书里面的很多设计模式

2519
01:45:44,000 --> 01:45:45,000
其实很

2520
01:45:45,000 --> 01:45:46,000
它的存在的意义

2521
01:45:47,000 --> 01:45:48,000
仅仅是因为

2522
01:45:48,000 --> 01:45:51,000
Java 这个语言本身的一些限制所导致的

2523
01:45:51,000 --> 01:45:52,000
不够

2524
01:45:53,000 --> 01:45:55,000
是怎么是写出来的时候其实是被 C++写的

2525
01:45:57,000 --> 01:45:58,000
之类的就是两种

2526
01:45:59,000 --> 01:46:00,000
所以静态语言嘛

2527
01:46:00,000 --> 01:46:02,000
然后有一些这个所谓这个

2528
01:46:03,000 --> 01:46:05,000
动态语言的鼓吹着就说

2529
01:46:05,000 --> 01:46:05,000
哎呀你

2530
01:46:06,000 --> 01:46:08,000
你费劲搞那么多各种各样的 pattern

2531
01:46:09,000 --> 01:46:10,000
你看我动态语言里面

2532
01:46:10,000 --> 01:46:13,000
根本不用操心这个问题我一个列表我就是可以

2533
01:46:14,000 --> 01:46:16,000
装多种不同类型的元素你把我咋地对吧

2534
01:46:17,000 --> 01:46:17,000
对

2535
01:46:17,000 --> 01:46:23,000
对其实这也是一个正确的一种正确的理解就是编程编程里面的设计模式在

2536
01:46:24,000 --> 01:46:25,000
在很多时候

2537
01:46:26,000 --> 01:46:27,000
与其说是一种

2538
01:46:28,000 --> 01:46:29,000
做

2539
01:46:29,000 --> 01:46:33,000
做事情方法倒不如说是因为语言没有办法让你

2540
01:46:34,000 --> 01:46:37,000
欢快快乐的做某事你不得不

2541
01:46:37,000 --> 01:46:40,000
先以一种比较

2542
01:46:41,000 --> 01:46:44,000
约定俗成的一种比较经过考验的

2543
01:46:45,000 --> 01:46:46,000
Best practice

2544
01:46:47,000 --> 01:46:47,000
这件事情

2545
01:46:48,000 --> 01:46:48,000
做出来

2546
01:46:49,000 --> 01:46:49,000
没错

2547
01:46:50,000 --> 01:46:53,000
美其名曰设计模式但其实他只是一个

2548
01:46:54,000 --> 01:46:55,000
就是前人

2549
01:46:55,000 --> 01:46:57,000
前人在

2550
01:46:58,000 --> 01:47:02,000
这条路上躺过了才冷不出个坑发现这个坑的副作用是最小的

2551
01:47:03,000 --> 01:47:06,000
告诉后人说来我插个小弦在这里

2552
01:47:06,000 --> 01:47:07,000
别走那边那几个坑

2553
01:47:07,000 --> 01:47:10,000
此处有雷的请这样请这样绕行

2554
01:47:10,000 --> 01:47:14,000
给画了一条我们现在抽象出脑子这边是一条路啊

2555
01:47:15,000 --> 01:47:15,000
要从这个

2556
01:47:16,000 --> 01:47:16,000
地图的左侧

2557
01:47:17,000 --> 01:47:19,000
下脚窜的右上角去但是雷区

2558
01:47:19,000 --> 01:47:21,000
遍地你不知道吗新人你可能更

2559
01:47:21,000 --> 01:47:22,000
才家就死了

2560
01:47:22,000 --> 01:47:23,000
所以前在

2561
01:47:24,000 --> 01:47:24,000
他的

2562
01:47:25,000 --> 01:47:29,000
堆堆白骨的技术上总结出一条万非常曲折绕的方法

2563
01:47:30,000 --> 01:47:31,000
可以知道的

2564
01:47:31,000 --> 01:47:33,000
带你顺利到达这个目的地

2565
01:47:33,000 --> 01:47:35,000
对吧这就是我们所谓的设计模式

2566
01:47:36,000 --> 01:47:41,000
但是其实我就很多这个对这个设计模式批评者来看就说

2567
01:47:41,000 --> 01:47:46,000
那你费那么多精力搞这个今天是因为你语言不够好吗你换一个好点语言不就没这么多

2568
01:47:47,000 --> 01:47:49,000
对就想在这个

2569
01:47:50,000 --> 01:47:55,000
沿用这个比方的话就是你要从 A 点到来 B 点在你发展不飞过去呢

2570
01:47:56,000 --> 01:48:02,000
对你发展出隧道绝境技术之前你不得不在山上绕一圈可是如果你的挖条隧道的话

2571
01:48:02,000 --> 01:48:03,000
就不用分

2572
01:48:04,000 --> 01:48:07,000
比如说我我觉得这个地方其实可以

2573
01:48:07,000 --> 01:48:08,000
举几个例子

2574
01:48:09,000 --> 01:48:10,000
你刚才说的动态语言

2575
01:48:11,000 --> 01:48:15,000
相对来说更为强大的容器类型是一个好例子

2576
01:48:16,000 --> 01:48:16,000
他

2577
01:48:17,000 --> 01:48:19,000
另外一方面比如说

2578
01:48:20,000 --> 01:48:24,000
原始的设计模式里面有叫做 observer 的模式

2579
01:48:24,000 --> 01:48:26,000
一个人做

2580
01:48:26,000 --> 01:48:29,000
一个类作为 observer 的

2581
01:48:30,000 --> 01:48:31,000
注册者

2582
01:48:32,000 --> 01:48:33,000
他来生产

2583
01:48:33,000 --> 01:48:36,000
一定的消息然后另外一些这个

2584
01:48:38,000 --> 01:48:41,000
objects 作为这个

2585
01:48:42,000 --> 01:48:44,000
observer 来去注册这个

2586
01:48:45,000 --> 01:48:46,000
注册

2587
01:48:46,000 --> 01:48:50,000
像这个对象注册说我对你的某一些消息感兴趣

2588
01:48:50,000 --> 01:48:51,000
如果你有这个消息

2589
01:48:52,000 --> 01:48:52,000
通知我

2590
01:48:53,000 --> 01:48:58,000
在 Java 里面这一边是当作或者说 C++里面是当作一个模式来用的

2591
01:48:58,000 --> 01:48:59,000
但是到了 Csharp 这一步

2592
01:49:00,000 --> 01:49:02,000
我们都知道 Csharp

2593
01:49:02,000 --> 01:49:03,000
脱胎于 Java

2594
01:49:04,000 --> 01:49:04,000
或者说是

2595
01:49:04,000 --> 01:49:05,000
汲取了 Java 的

2596
01:49:05,000 --> 01:49:06,000
优点

2597
01:49:07,000 --> 01:49:08,000
如果 Java 有什么优点的话

2598
01:49:08,000 --> 01:49:11,000
Csharp 内置有

2599
01:49:11,000 --> 01:49:13,000
所谓 delegate event

2600
01:49:13,000 --> 01:49:14,000
这两个在

2601
01:49:15,000 --> 01:49:15,000
在

2602
01:49:15,000 --> 01:49:17,000
语言层面上实现的

2603
01:49:18,000 --> 01:49:19,000
怎么说呢

2604
01:49:19,000 --> 01:49:21,000
抽象概念

2605
01:49:22,000 --> 01:49:25,000
有了这个语言结构抽象概念 observer 模式就没有用了

2606
01:49:25,000 --> 01:49:30,000
因为你自己不需要去构建这个 observer 的模式你只需要直接使用 Csharp 内部的

2607
01:49:31,000 --> 01:49:32,000
这两个

2608
01:49:33,000 --> 01:49:34,000
怎么说呢语法堂吧

2609
01:49:34,000 --> 01:49:35,000
就可以了

2610
01:49:37,000 --> 01:49:39,000
你还能想到一个别的

2611
01:49:39,000 --> 01:49:45,000
其实这个事情顺着说下去啊你这种经常在这种设计 UI 界面的情况

2612
01:49:45,000 --> 01:49:46,000
用的非常多嘛

2613
01:49:46,000 --> 01:49:52,000
现在就新的思潮是什么来的就是什么 FRP 嘛 functional reactive programming

2614
01:49:53,000 --> 01:49:53,000
他连这个

2615
01:49:54,000 --> 01:49:55,000
这种这种叫什么来的

2616
01:49:55,000 --> 01:49:56,000
啊这种

2617
01:49:57,000 --> 01:50:00,000
就是交互式的观察者啊还有是被观察者

2618
01:50:00,000 --> 01:50:02,000
注册啊这种事情都直接都免了

2619
01:50:03,000 --> 01:50:04,000
我们全部单向流

2620
01:50:04,000 --> 01:50:05,000
就

2621
01:50:06,000 --> 01:50:09,000
就完全是不同的一种思路在做这个事情

2622
01:50:10,000 --> 01:50:11,000
你会发现其实有些

2623
01:50:11,000 --> 01:50:13,000
那个设计模式其实也是非常

2624
01:50:14,000 --> 01:50:14,000
在观念上

2625
01:50:14,000 --> 01:50:16,000
是比较成就的一个东西

2626
01:50:17,000 --> 01:50:21,000
当然我们现在总是站在一种马虎炮的

2627
01:50:21,000 --> 01:50:23,000
这个角度去

2628
01:50:25,000 --> 01:50:29,000
说设计模式里面有些模式其实根本就是在修语言啊或者是

2629
01:50:29,000 --> 01:50:31,000
有些模式根本过时了呀

2630
01:50:31,000 --> 01:50:36,000
但是在 90 年代的时候这本书还是影响还是影响了整整

2631
01:50:37,000 --> 01:50:38,000
一代人必须说

2632
01:50:38,000 --> 01:50:41,000
而且在这本书之后也

2633
01:50:41,000 --> 01:50:44,000
其实出现了很多其他的设计模式

2634
01:50:45,000 --> 01:50:50,000
这本书一上来就提到了 mvc 模式在接下来的很多年里面

2635
01:50:50,000 --> 01:50:52,000
首先他有很多种不同的解读

2636
01:50:52,000 --> 01:50:54,000
基本上每一个

2637
01:50:55,000 --> 01:50:59,000
每两个程序员对于 mvc 的解读都是不一样的

2638
01:51:00,000 --> 01:51:05,000
甚至后来也衍生由 mvc 衍生出来比如什么 mvvm

2639
01:51:05,000 --> 01:51:06,000
或者是

2640
01:51:08,000 --> 01:51:10,000
很多其他莫名其妙我现在已经想不出来的缩写

2641
01:51:11,000 --> 01:51:13,000
都是脱胎原文的 mvc 这样一种模式

2642
01:51:13,000 --> 01:51:14,000
这样一种模式

2643
01:51:15,000 --> 01:51:15,000
是的

2644
01:51:16,000 --> 01:51:22,000
以至于很多语言本身也会说在使用这种语言的时候我会有一个

2645
01:51:22,000 --> 01:51:24,000
特别的模式比如说

2646
01:51:24,000 --> 01:51:27,000
我记得以前看过一个

2647
01:51:27,000 --> 01:51:28,000
Python patterns

2648
01:51:29,000 --> 01:51:32,000
总结了使用 Python 编程的时候

2649
01:51:32,000 --> 01:51:35,000
能够经常使用到的一些 pattern

2650
01:51:35,000 --> 01:51:37,000
印象很深的是里面有个叫做

2651
01:51:38,000 --> 01:51:39,000
Cyborg

2652
01:51:39,000 --> 01:51:40,000
的 pattern

2653
01:51:41,000 --> 01:51:43,000
Cyborg 就是那个星际迷航

2654
01:51:43,000 --> 01:51:44,000
Star Trek 里面有一个

2655
01:51:45,000 --> 01:51:46,000
种族叫 Cyborg

2656
01:51:46,000 --> 01:51:47,000
他们

2657
01:51:47,000 --> 01:51:48,000
没有

2658
01:51:49,000 --> 01:51:50,000
他们的个体没有个体的意识

2659
01:51:51,000 --> 01:51:53,000
然后

2660
01:51:54,000 --> 01:51:59,000
他们的战斗力非常强然后他们每征服一个种族就把这个种族里面的每个个体

2661
01:52:00,000 --> 01:52:01,000
融合到他们

2662
01:52:02,000 --> 01:52:04,000
的一个 mastermind

2663
01:52:04,000 --> 01:52:06,000
他们只有一个集体意识

2664
01:52:07,000 --> 01:52:07,000
然后

2665
01:52:08,000 --> 01:52:09,000
个体服从于集体

2666
01:52:09,000 --> 01:52:13,000
然后 Cyborg 这个名字就被借用来描述这样一种

2667
01:52:13,000 --> 01:52:14,000
Python

2668
01:52:15,000 --> 01:52:15,000
的

2669
01:52:16,000 --> 01:52:17,000
设计模式就是

2670
01:52:18,000 --> 01:52:19,000
很多

2671
01:52:20,000 --> 01:52:23,000
objects 共享一个 global 的

2672
01:52:24,000 --> 01:52:24,000
state

2673
01:52:28,000 --> 01:52:30,000
然后还有比如说

2674
01:52:30,000 --> 01:52:31,000
我前

2675
01:52:31,000 --> 01:52:33,000
前年吧看了一本

2676
01:52:33,000 --> 01:52:34,000
Coco pattern

2677
01:52:35,000 --> 01:52:36,000
Coco design pattern

2678
01:52:36,000 --> 01:52:40,000
也是讲这个在 Coco 里面经常被用到的一些模式

2679
01:52:41,000 --> 01:52:41,000
比如说

2680
01:52:42,000 --> 01:52:43,000
Observer 模式

2681
01:52:44,000 --> 01:52:44,000
不知道

2682
01:52:45,000 --> 01:52:46,000
Coco 叫什么

2683
01:52:46,000 --> 01:52:47,000
Delegation 模式

2684
01:52:50,000 --> 01:52:53,000
乃至于在 Coco 下面的 MVC 模式

2685
01:52:55,000 --> 01:52:57,000
以及比如说

2686
01:52:59,000 --> 01:53:03,000
在写 objects 的时候经常会用到一个就是 selector

2687
01:53:04,000 --> 01:53:08,000
然后你会说我需要延迟一段时间来执行 selector

2688
01:53:09,000 --> 01:53:10,000
Juice 类这样一些模式

2689
01:53:10,000 --> 01:53:11,000
在这本书里面介绍了

2690
01:53:12,000 --> 01:53:14,000
可以说从

2691
01:53:14,000 --> 01:53:16,000
从设计模式这本书开始之后

2692
01:53:16,000 --> 01:53:18,000
陆陆续续人们开始

2693
01:53:18,000 --> 01:53:21,000
人们才开始着眼于总结出

2694
01:53:21,000 --> 01:53:24,000
使用某一种特定工具的时候

2695
01:53:24,000 --> 01:53:26,000
所应该使用的一些

2696
01:53:27,000 --> 01:53:27,000
最佳实践

2697
01:53:28,000 --> 01:53:29,000
然后把它们总结下来

2698
01:53:29,000 --> 01:53:31,000
把它们汇总出来

2699
01:53:31,000 --> 01:53:32,000
起上

2700
01:53:32,000 --> 01:53:33,000
某某

2701
01:53:34,000 --> 01:53:36,000
Domain 之下的设计模式这样一名字

2702
01:53:38,000 --> 01:53:38,000
OK

2703
01:53:39,000 --> 01:53:42,000
所以其实我有一点很疑惑的就是说

2704
01:53:42,000 --> 01:53:43,000
你觉得对于一个

2705
01:53:44,000 --> 01:53:46,000
某一个工具也好

2706
01:53:46,000 --> 01:53:47,000
某一个语言也好

2707
01:53:47,000 --> 01:53:50,000
新手来说设计模式这个东西有多大的意义

2708
01:53:51,000 --> 01:53:53,000
因为我一直是抱着这么一种想法

2709
01:53:54,000 --> 01:53:56,000
刚刚我们说就是这个是一个

2710
01:53:56,000 --> 01:53:58,000
在一个布满雷区的

2711
01:53:58,000 --> 01:54:00,000
地图上给你画了条线这么一个功能对吧

2712
01:54:01,000 --> 01:54:02,000
但是其实对于很多新手来讲

2713
01:54:03,000 --> 01:54:04,000
你不让他去犯那些错误

2714
01:54:04,000 --> 01:54:06,000
他是永远都不知道为什么会这样

2715
01:54:07,000 --> 01:54:09,000
为什么会有另外一种方式来做会更好

2716
01:54:09,000 --> 01:54:10,000
看起来可能更曲折

2717
01:54:11,000 --> 01:54:12,000
但结果可能会更加好

2718
01:54:13,000 --> 01:54:14,000
就是没有这么一个学习

2719
01:54:14,000 --> 01:54:15,000
学习的过程

2720
01:54:15,000 --> 01:54:17,000
就是我们强行给他灌了一碗鸡汤

2721
01:54:17,000 --> 01:54:18,000
说喝这个

2722
01:54:18,000 --> 01:54:19,000
对你有益

2723
01:54:19,000 --> 01:54:20,000
别问为什么

2724
01:54:20,000 --> 01:54:22,000
但他心里一定有无数个为什么

2725
01:54:23,000 --> 01:54:27,000
没错就是如果你没有踩过雷的话是不知道被雷炸死有多疼

2726
01:54:30,000 --> 01:54:33,000
而设计模式其实并不是一个适合

2727
01:54:33,000 --> 01:54:36,000
你刚刚学会编程的时候就看的东西

2728
01:54:36,000 --> 01:54:36,000
因为

2729
01:54:37,000 --> 01:54:38,000
我觉得

2730
01:54:39,000 --> 01:54:41,000
我自己可能也是看设计模式的时候比较

2731
01:54:42,000 --> 01:54:43,000
道行还不够深

2732
01:54:43,000 --> 01:54:44,000
当然我现在道行也不深

2733
01:54:44,000 --> 01:54:46,000
那时候更是

2734
01:54:46,000 --> 01:54:49,000
会觉得这些设计模式里面很多地方就是

2735
01:54:50,000 --> 01:54:51,000
脱了裤子放屁吧

2736
01:54:51,000 --> 01:54:54,000
就是我明明可以直接一步就做到了

2737
01:54:54,000 --> 01:54:57,000
为什么一定要通过这么周章大费周章的方式来

2738
01:54:58,000 --> 01:54:59,000
来实现它呢

2739
01:54:59,000 --> 01:55:00,000
但是

2740
01:55:00,000 --> 01:55:01,000
只有你在

2741
01:55:03,000 --> 01:55:06,000
官方话叫做长期的

2742
01:55:06,000 --> 01:55:07,000
工作实践中

2743
01:55:07,000 --> 01:55:11,000
对大关强是长期的工作实践

2744
01:55:11,000 --> 01:55:12,000
只有你在

2745
01:55:13,000 --> 01:55:14,000
经历过

2746
01:55:14,000 --> 01:55:15,000
呃

2747
01:55:16,000 --> 01:55:18,000
因为自己的代码

2748
01:55:18,000 --> 01:55:19,000
越来越大

2749
01:55:19,000 --> 01:55:21,000
让你每次

2750
01:55:21,000 --> 01:55:23,000
开始写它都会产生一种

2751
01:55:24,000 --> 01:55:25,000
恐惧和

2752
01:55:26,000 --> 01:55:27,000
恶心的情绪的时候

2753
01:55:28,000 --> 01:55:29,000
当你

2754
01:55:30,000 --> 01:55:33,000
因为每天心不在焉被你的女朋友说

2755
01:55:33,000 --> 01:55:36,000
呃你是不是不爱我

2756
01:55:36,000 --> 01:55:37,000
然后

2757
01:55:37,000 --> 01:55:38,000
你

2758
01:55:38,000 --> 01:55:40,000
所能做出的回答只是

2759
01:55:40,000 --> 01:55:41,000
my coat doesnt work

2760
01:55:41,000 --> 01:55:42,000
的时候

2761
01:55:42,000 --> 01:55:44,000
你才会体会到

2762
01:55:44,000 --> 01:55:48,000
设计模式其实是一种多么伟大的存在

2763
01:55:48,000 --> 01:55:52,000
我觉得其实一个比较合适的切入点是

2764
01:55:52,000 --> 01:55:55,000
你可以写一些程序

2765
01:55:55,000 --> 01:55:58,000
然后总结出你自己觉得

2766
01:55:58,000 --> 01:56:04,000
看起来是个不错的模式加引号的时候

2767
01:56:04,000 --> 01:56:06,000
再去回头去看一些

2768
01:56:06,000 --> 01:56:10,000
回头去看比如说设计模式这本书

2769
01:56:10,000 --> 01:56:12,000
至于在这本书出版之后

2770
01:56:12,000 --> 01:56:13,000
有很多很多其他的

2771
01:56:13,000 --> 01:56:16,000
比如说 Design Patterns in C Sharp

2772
01:56:16,000 --> 01:56:19,000
或者是 Design Patterns Implemented in JavaScript

2773
01:56:19,000 --> 01:56:20,000
这类的书

2774
01:56:20,000 --> 01:56:23,000
你才会切身领悟到

2775
01:56:23,000 --> 01:56:25,000
这些设计模式真正的意义何在

2776
01:56:25,000 --> 01:56:26,000
对

2777
01:56:26,000 --> 01:56:30,000
所以其实最合适的阅读这种设计模式

2778
01:56:30,000 --> 01:56:31,000
这种思想

2779
01:56:31,000 --> 01:56:35,000
这种比较玄学的书也好

2780
01:56:35,000 --> 01:56:36,000
还是文章也好的时候

2781
01:56:36,000 --> 01:56:39,000
其实是在你有一定的工作积累

2782
01:56:39,000 --> 01:56:40,000
踩过不少雷

2783
01:56:40,000 --> 01:56:42,000
被炸死过好多次之后

2784
01:56:42,000 --> 01:56:43,000
然后又想

2785
01:56:43,000 --> 01:56:46,000
就进一步提高自己的水平

2786
01:56:46,000 --> 01:56:47,000
又遇到这个瓶颈

2787
01:56:47,000 --> 01:56:49,000
不知道该下一步该怎么走的时候

2788
01:56:49,000 --> 01:56:50,000
来看这个可能有一种那种

2789
01:56:50,000 --> 01:56:52,000
醍醐灌顶的感觉

2790
01:56:52,000 --> 01:56:54,000
对

2791
01:56:54,000 --> 01:57:02,000
然后在应该是前年的时候

2792
01:57:02,000 --> 01:57:03,000
有这样一篇报道

2793
01:57:03,000 --> 01:57:07,000
就是他们请到了 Erich Gammer

2794
01:57:07,000 --> 01:57:08,000
Richard Helm

2795
01:57:08,000 --> 01:57:10,000
还有 Ralph Johnson

2796
01:57:10,000 --> 01:57:11,000
就是四人帮里面三个人

2797
01:57:11,000 --> 01:57:12,000
来

2798
01:57:12,000 --> 01:57:13,000
在

2799
01:57:13,000 --> 01:57:15,000
这本书出版了 15 年之后

2800
01:57:15,000 --> 01:57:21,000
重新讨论设计模式的利与弊

2801
01:57:21,000 --> 01:57:23,000
大概是这么意思

2802
01:57:23,000 --> 01:57:24,000
反思会是吧

2803
01:57:24,000 --> 01:57:27,000
反思会吗

2804
01:57:27,000 --> 01:57:29,000
算吧

2805
01:57:29,000 --> 01:57:31,000
算是一个对

2806
01:57:31,000 --> 01:57:35,000
老兵俱乐部的这种感觉

2807
01:57:35,000 --> 01:57:37,000
然后在那边

2808
01:57:37,000 --> 01:57:41,000
在这个访谈里面有这样一句话说

2809
01:57:41,000 --> 01:57:42,000
Hi I'm a hero

2810
01:57:42,000 --> 01:57:42,000
Hi I'm a hero

2811
01:57:42,000 --> 01:57:57,000
Hello

2812
01:58:05,000 --> 01:58:08,000
我就是这幅っ

2813
01:58:08,000 --> 01:58:12,000
支援

2814
01:58:12,000 --> 01:58:12,000
Erich 的 asegtoo

2815
01:58:12,000 --> 01:58:13,000
想到一个方法

2816
01:58:13,000 --> 01:58:16,000
这个方法的作用就是根据

2817
01:58:16,000 --> 01:58:19,000
实际的类型需求

2818
01:58:19,000 --> 01:58:20,000
来生产出

2819
01:58:20,000 --> 01:58:21,000
不同类型的

2820
01:58:21,000 --> 01:58:23,000
object

2821
01:58:23,000 --> 01:58:25,000
你可以直接跟他说这边是一个

2822
01:58:25,000 --> 01:58:27,000
factory

2823
01:58:27,000 --> 01:58:29,000
工厂

2824
01:58:29,000 --> 01:58:31,000
工厂方法

2825
01:58:31,000 --> 01:58:32,000
这里是一个工厂方法

2826
01:58:32,000 --> 01:58:35,000
然后你甚至可以说

2827
01:58:35,000 --> 01:58:36,000
这里是一个

2828
01:58:36,000 --> 01:58:39,000
metafactory

2829
01:58:39,000 --> 01:58:40,000
不对叫什么

2830
01:58:40,000 --> 01:58:41,000
abstract factory

2831
01:58:41,000 --> 01:58:43,000
这是一个生产工厂的工厂

2832
01:58:43,000 --> 01:58:46,000
非常简单的句子表达

2833
01:58:46,000 --> 01:58:49,000
相对来说更加复杂的概念

2834
01:58:49,000 --> 01:58:50,000
然后这样

2835
01:58:50,000 --> 01:58:52,000
从这个层面来说

2836
01:58:52,000 --> 01:58:53,000
你懂一些设计模式之后

2837
01:58:53,000 --> 01:58:56,000
你也可以更加

2838
01:58:56,000 --> 01:58:59,000
方便的去

2839
01:58:59,000 --> 01:59:00,000
表达

2840
01:59:00,000 --> 01:59:03,000
理解别人通过一大片代码

2841
01:59:03,000 --> 01:59:04,000
或者是

2842
01:59:04,000 --> 01:59:06,000
一些很简短的句子想要表达的意思

2843
01:59:06,000 --> 01:59:09,000
然后这边

2844
01:59:09,000 --> 01:59:11,000
房套里面

2845
01:59:11,000 --> 01:59:12,000
还提到说

2846
01:59:12,000 --> 01:59:13,000
就是

2847
01:59:13,000 --> 01:59:14,000
访谈的主持人说

2848
01:59:14,000 --> 01:59:16,000
访谈主持人也就是那个

2849
01:59:16,000 --> 01:59:17,000
叫什么

2850
01:59:17,000 --> 01:59:18,000
但也不重要

2851
01:59:18,000 --> 01:59:20,000
主持人问说

2852
01:59:20,000 --> 01:59:23,000
在现在这个时代

2853
01:59:23,000 --> 01:59:26,000
我们只需要写一行

2854
01:59:26,000 --> 01:59:27,000
这个 php 代码

2855
01:59:27,000 --> 01:59:30,000
就可以

2856
01:59:30,000 --> 01:59:32,000
做出一个网站来写着 hello world

2857
01:59:32,000 --> 01:59:34,000
the time is

2858
01:59:34,000 --> 01:59:36,000
the time is dollar time

2859
01:59:36,000 --> 01:59:37,000
这样一个网站出来

2860
01:59:37,000 --> 01:59:40,000
那么在这样一个时代里面

2861
01:59:40,000 --> 01:59:41,000
摄影博士还说明天是什么时候来的

2862
01:59:41,000 --> 01:59:43,000
他说是明年呢

2863
01:59:43,000 --> 01:59:46,000
然后这个 Richard 说

2864
01:59:46,000 --> 01:59:52,000
I think there has been an evolution level of sophistication

2865
01:59:52,000 --> 01:59:56,000
也就是说在复杂度的层级上面

2866
01:59:56,000 --> 01:59:58,000
在过去的这 15 年里面

2867
01:59:58,000 --> 02:00:01,000
软件有一个非常大的

2868
02:00:01,000 --> 02:00:03,000
进化

2869
02:00:03,000 --> 02:00:07,000
可以复用的软件已经被移植到了比较

2870
02:00:07,000 --> 02:00:10,000
就是接近于底层的位置

2871
02:00:10,000 --> 02:00:11,000
比如说一个 tool

2872
02:00:11,000 --> 02:00:13,000
或者一个 framework

2873
02:00:13,000 --> 02:00:18,000
然后这些东西的设计应该更多的被

2874
02:00:18,000 --> 02:00:21,000
be left to the experts

2875
02:00:21,000 --> 02:00:25,000
也就是说现在大部分写成序的人都不是 experts

2876
02:00:25,000 --> 02:00:28,000
他们只是在沿用这些个组合一些

2877
02:00:28,000 --> 02:00:34,000
他们所做的工作只是把一些这个 framework 里面的东西组合起来

2878
02:00:34,000 --> 02:00:37,000
然后妥妥通空间写写业务逻辑

2879
02:00:37,000 --> 02:00:38,000
然后就可以用了

2880
02:00:38,000 --> 02:00:40,000
那么在这种情况之下

2881
02:00:40,000 --> 02:00:45,000
the goal for most software developers

2882
02:00:45,000 --> 02:00:48,000
still remains to design for change

2883
02:00:48,000 --> 02:00:50,000
and there are debate is

2884
02:00:50,000 --> 02:00:53,000
do you do it early or later

2885
02:00:53,000 --> 02:00:56,000
in many cases the design should be refactored

2886
02:00:56,000 --> 02:00:59,000
and the patterns provide a target to do this

2887
02:00:59,000 --> 02:01:00,000
也就是说

2888
02:01:00,000 --> 02:01:03,000
即便在这种情况之下

2889
02:01:03,000 --> 02:01:06,000
你虽然不直接参与一个框架

2890
02:01:06,000 --> 02:01:09,000
或者是一个蛋熬酷的开发

2891
02:01:09,000 --> 02:01:11,000
但你仍旧需要做出一些决定

2892
02:01:11,000 --> 02:01:13,000
而这些决定也就是

2893
02:01:13,000 --> 02:01:15,000
我们刚才的读者来信里面也提到了

2894
02:01:15,000 --> 02:01:17,000
在很大程度上它是一种重构

2895
02:01:17,000 --> 02:01:19,000
然后你在做重构的时候

2896
02:01:19,000 --> 02:01:20,000
你就会发现

2897
02:01:20,000 --> 02:01:23,000
设计模式其实是有大用处的

2898
02:01:23,000 --> 02:01:25,000
你在重构的时候

2899
02:01:25,000 --> 02:01:28,000
你会去看到说

2900
02:01:28,000 --> 02:01:30,000
目前的这块代码

2901
02:01:30,000 --> 02:01:33,000
尤其是在比较敏捷的状况下写出来的代码

2902
02:01:33,000 --> 02:01:36,000
它内部可能存在一些什么样的问题

2903
02:01:36,000 --> 02:01:38,000
而设计模式则

2904
02:01:38,000 --> 02:01:41,000
可以为你提供一些解决这些问题的思路

2905
02:01:41,000 --> 02:01:43,000
我觉得这也是设计模式

2906
02:01:43,000 --> 02:01:45,000
即便在很多很多年之后

2907
02:01:45,000 --> 02:01:49,000
我们大部分从业者都不是那么 expert 的情况下

2908
02:01:49,000 --> 02:01:52,000
仍旧有用的一个例子

2909
02:01:52,000 --> 02:01:54,000
没错

2910
02:01:54,000 --> 02:01:57,000
那节目的最后

2911
02:01:57,000 --> 02:02:00,000
我们讲一个跟设计模式相关的

2912
02:02:00,000 --> 02:02:02,000
它的孪生兄弟

2913
02:02:02,000 --> 02:02:04,000
Anti-pattern

2914
02:02:04,000 --> 02:02:05,000
对

2915
02:02:05,000 --> 02:02:07,000
这翻译成中文怎么翻

2916
02:02:07,000 --> 02:02:08,000
反模式吧

2917
02:02:08,000 --> 02:02:09,000
还是翻模式

2918
02:02:09,000 --> 02:02:10,000
反模式

2919
02:02:10,000 --> 02:02:11,000
逆模式

2920
02:02:11,000 --> 02:02:12,000
还是啥呢

2921
02:02:12,000 --> 02:02:13,000
对

2922
02:02:13,000 --> 02:02:16,000
Anti-pattern 就是那些所有

2923
02:02:16,000 --> 02:02:18,000
容易掉进的坑吧

2924
02:02:18,000 --> 02:02:19,000
我觉得可以这么说

2925
02:02:19,000 --> 02:02:22,000
就是有些坑是

2926
02:02:22,000 --> 02:02:24,000
人人避开的

2927
02:02:24,000 --> 02:02:25,000
绕坑的方法

2928
02:02:25,000 --> 02:02:26,000
对

2929
02:02:26,000 --> 02:02:27,000
有些坑是人人避开的

2930
02:02:27,000 --> 02:02:29,000
而有些坑则是人人都会掉进去

2931
02:02:29,000 --> 02:02:32,000
我相信 Anti-pattern

2932
02:02:32,000 --> 02:02:36,000
我相信 Anti-pattern 的数量是要远远多于 Design pattern

2933
02:02:36,000 --> 02:02:37,000
不知道什么

2934
02:02:37,000 --> 02:02:39,000
这个假设是不是正确

2935
02:02:39,000 --> 02:02:41,000
至少你去搜

2936
02:02:41,000 --> 02:02:43,000
如果你去搜 Anti-pattern 的话

2937
02:02:43,000 --> 02:02:45,000
你可以找到一些汇总的页面

2938
02:02:45,000 --> 02:02:47,000
这些页面上列出的

2939
02:02:47,000 --> 02:02:51,000
pattern 可能远远超于超过

2940
02:02:51,000 --> 02:02:54,000
私人帮的所一开始给出的那 23 个

2941
02:02:54,000 --> 02:02:56,000
比较好的 Design pattern

2942
02:02:56,000 --> 02:03:00,000
举几个例子吧

2943
02:03:00,000 --> 02:03:01,000
第一个例子就是

2944
02:03:01,000 --> 02:03:04,000
我能想到的就是高的 objects

2945
02:03:04,000 --> 02:03:06,000
对 Anti-pattern 其实也是有名字的

2946
02:03:06,000 --> 02:03:10,000
我能想到的第一个就是高的 objects

2947
02:03:10,000 --> 02:03:12,000
我不知道各位有没有这样一个阶段

2948
02:03:12,000 --> 02:03:14,000
如果你写过很多程序的话

2949
02:03:14,000 --> 02:03:15,000
什么的什么的

2950
02:03:15,000 --> 02:03:16,000
如果大了一个境界

2951
02:03:16,000 --> 02:03:30,000
你会下意识把那些不知道归给谁的东西归到同一个东西下面

2952
02:03:30,000 --> 02:03:33,000
最常见的就是你会写一个叫做 toolkit

2953
02:03:33,000 --> 02:03:35,000
或者是 utility

2954
02:03:35,000 --> 02:03:38,000
或者是 base

2955
02:03:38,000 --> 02:03:40,000
这样一个 objects

2956
02:03:40,000 --> 02:03:41,000
然后里面放了一大堆

2957
02:03:41,000 --> 02:03:42,000
common 之类的

2958
02:03:42,000 --> 02:03:44,000
对 common 点什么什么

2959
02:03:44,000 --> 02:03:45,000
一大堆根本就不知道

2960
02:03:45,000 --> 02:03:46,000
你不知道该往哪放的

2961
02:03:46,000 --> 02:03:47,000
你全都放在那

2962
02:03:47,000 --> 02:03:52,000
比如说这个 utilities 里面可能有一个汇图函数

2963
02:03:52,000 --> 02:03:54,000
然后一个打开文件的函数

2964
02:03:54,000 --> 02:03:57,000
一个做网络通信的函数

2965
02:03:57,000 --> 02:04:00,000
然后一个帮你存密码函数

2966
02:04:00,000 --> 02:04:03,000
或者是一个帮你烧水的函数全都放在里面

2967
02:04:03,000 --> 02:04:05,000
其实这就是一个函数的函数

2968
02:04:05,000 --> 02:04:08,000
这是一个非常知名的 anti-patent

2969
02:04:08,000 --> 02:04:10,000
叫做 GOLD object

2970
02:04:10,000 --> 02:04:12,000
就是这个 object 无所不能

2971
02:04:12,000 --> 02:04:13,000
全知全能

2972
02:04:13,000 --> 02:04:15,000
有非常多的

2973
02:04:15,000 --> 02:04:21,000
对其实这个 patent 在命令式编程里面也会出现

2974
02:04:21,000 --> 02:04:23,000
如果你放了太多的全球变量的话

2975
02:04:23,000 --> 02:04:29,000
其实也是一个比较明显的 GOLD object

2976
02:04:29,000 --> 02:04:31,000
它违反了一个原则

2977
02:04:31,000 --> 02:04:34,000
就是你应该提供尽量清晰的接口

2978
02:04:34,000 --> 02:04:35,000
对

2979
02:04:35,000 --> 02:04:39,000
你应该尽量让每一个 object 的职责清晰化

2980
02:04:39,000 --> 02:04:41,000
但是在 GOLD object 这里

2981
02:04:41,000 --> 02:04:43,000
这一切都被你毁了

2982
02:04:43,000 --> 02:04:47,000
你会发现这个 GOLD object 真是无处不在

2983
02:04:47,000 --> 02:04:48,000
就是个大杂烩

2984
02:04:48,000 --> 02:04:49,000
对

2985
02:04:49,000 --> 02:04:51,000
然后你会发现重构变得非常艰难

2986
02:04:51,000 --> 02:04:53,000
因为你根本就不知道哪些业务逻辑

2987
02:04:53,000 --> 02:04:56,000
可以从这个 object 里面提取出来

2988
02:04:56,000 --> 02:04:58,000
这是一个比较

2989
02:04:58,000 --> 02:05:02,000
我自己能想到第一个比较著名的 anti-patent

2990
02:05:05,000 --> 02:05:07,000
还有什么

2991
02:05:07,000 --> 02:05:09,000
golden hammer

2992
02:05:09,000 --> 02:05:11,000
golden hammer 是一个比较

2993
02:05:11,000 --> 02:05:15,000
也是一个比较知名的 anti-patent

2994
02:05:15,000 --> 02:05:17,000
就是你这样就是俗话说

2995
02:05:17,000 --> 02:05:19,000
我有一把锤子

2996
02:05:19,000 --> 02:05:21,000
我看什么都像钉子

2997
02:05:21,000 --> 02:05:26,000
这在如果要把它总结成一个 patent 的话

2998
02:05:26,000 --> 02:05:29,000
那就是你会了一门语言

2999
02:05:29,000 --> 02:05:31,000
或者是你掌握了一个 cool

3000
02:05:31,000 --> 02:05:33,000
你会觉得说

3001
02:05:33,000 --> 02:05:35,000
甚至不一定是一个个人

3002
02:05:35,000 --> 02:05:38,000
可能在一个团队上也会体现出这样一种倾向来

3003
02:05:38,000 --> 02:05:41,000
就是说我要用这个工具解决一切的问题

3004
02:05:41,000 --> 02:05:44,000
所有的问题都应该转化到这个工具上来解决

3005
02:05:44,000 --> 02:05:46,000
或者说所有的

3006
02:05:48,000 --> 02:05:51,000
你自己 OOP 本身就是一个 golden hammer

3007
02:05:51,000 --> 02:05:52,000
对

3008
02:05:52,000 --> 02:05:53,000
你有道理

3009
02:05:53,000 --> 02:05:55,000
其实你现在看很多那种

3010
02:05:55,000 --> 02:05:57,000
都是在哪里

3011
02:05:57,000 --> 02:05:58,000
植物上写过这么一段话

3012
02:05:58,000 --> 02:06:03,000
就是说什么时候你觉得这个 OOP 的这条路已经走的太远了

3013
02:06:03,000 --> 02:06:05,000
你看到这种语句

3014
02:06:05,000 --> 02:06:08,000
叫做 executor.execute

3015
02:06:08,000 --> 02:06:11,000
开框框框

3016
02:06:11,000 --> 02:06:13,000
对

3017
02:06:13,000 --> 02:06:15,000
是你那个

3018
02:06:15,000 --> 02:06:18,000
其实我能想到的就是

3019
02:06:18,000 --> 02:06:19,000
有些面试题

3020
02:06:19,000 --> 02:06:21,000
比如说 feet bus

3021
02:06:21,000 --> 02:06:24,000
这样面试题

3022
02:06:24,000 --> 02:06:28,000
你明明写一个函数就可以解决问题

3023
02:06:28,000 --> 02:06:29,000
你不用写函数

3024
02:06:29,000 --> 02:06:31,000
你写一个 follow loop 就可以解决问题

3025
02:06:31,000 --> 02:06:32,000
有些人要先

3026
02:06:32,000 --> 02:06:35,000
因为他只学过面

3027
02:06:35,000 --> 02:06:37,000
因为他只学过面相对上

3028
02:06:37,000 --> 02:06:40,000
所以他情不自禁的一上来要写个类

3029
02:06:40,000 --> 02:06:41,000
不这个也是 java 害的

3030
02:06:41,000 --> 02:06:43,000
因为 java 没有不是类的东西

3031
02:06:43,000 --> 02:06:45,000
你没有类没有办法执行的

3032
02:06:45,000 --> 02:06:49,000
对 java 连一个程序的入口点都要放在一个类里面

3033
02:06:49,000 --> 02:06:51,000
这是何苦

3034
02:06:51,000 --> 02:06:53,000
程序何苦

3035
02:06:53,000 --> 02:06:54,000
没完程序

3036
02:06:54,000 --> 02:06:56,000
对

3037
02:06:56,000 --> 02:07:01,000
与 golden hammer 相对的也有一个 silver bullet

3038
02:07:01,000 --> 02:07:02,000
这个

3039
02:07:02,000 --> 02:07:03,000
也是一个

3040
02:07:03,000 --> 02:07:04,000
对

3041
02:07:04,000 --> 02:07:06,000
其实 silver bullet 后来我查了一下

3042
02:07:06,000 --> 02:07:07,000
它是有一个来历的

3043
02:07:07,000 --> 02:07:09,000
只不过这个来历是如此的久远

3044
02:07:09,000 --> 02:07:11,000
以至于我们新生代的这个

3045
02:07:11,000 --> 02:07:13,000
我们已经是步入中年了

3046
02:07:13,000 --> 02:07:14,000
但我们

3047
02:07:14,000 --> 02:07:16,000
在此中就可以自豪的说一声

3048
02:07:16,000 --> 02:07:21,000
我们新生代的程序员不知道这个梗的来历是全有可能的

3049
02:07:21,000 --> 02:07:23,000
就是在 30 年代

3050
02:07:23,000 --> 02:07:25,000
有这样一些故事

3051
02:07:25,000 --> 02:07:27,000
讲述一个叫做

3052
02:07:27,000 --> 02:07:30,000
The Long Ranger

3053
02:07:30,000 --> 02:07:31,000
嗯

3054
02:07:32,000 --> 02:07:35,000
西部牛仔

3055
02:07:35,000 --> 02:07:36,000
不他不是牛仔

3056
02:07:36,000 --> 02:07:39,000
他应该是西部的一个检察官

3057
02:07:39,000 --> 02:07:42,000
后来变成了一个匡扶正义的侠客

3058
02:07:42,000 --> 02:07:43,000
这么一个形象

3059
02:07:43,000 --> 02:07:44,000
他有把枪

3060
02:07:44,000 --> 02:07:45,000
奇迹吗

3061
02:07:45,000 --> 02:07:48,000
Ranger 就是奇迹吗

3062
02:07:48,000 --> 02:07:52,000
Ranger 最古老的意思指的是寻龄客

3063
02:07:52,000 --> 02:07:57,000
就是在游骑兵

3064
02:07:57,000 --> 02:07:59,000
对

3065
02:07:59,000 --> 02:08:01,000
但这不重要了

3066
02:08:01,000 --> 02:08:06,000
反正他这个形象最大的绝杀就是他有一个

3067
02:08:06,000 --> 02:08:07,000
他有把很长的枪

3068
02:08:07,000 --> 02:08:09,000
然后一枪可以射出 silver bullet

3069
02:08:09,000 --> 02:08:13,000
silver bullet 每一次击中什么东西都是

3070
02:08:13,000 --> 02:08:15,000
首先他是个神枪手

3071
02:08:15,000 --> 02:08:18,000
然后他可以做到比如说这个人快被吊死了

3072
02:08:18,000 --> 02:08:21,000
他的两三百米开外打一颗银弹

3073
02:08:21,000 --> 02:08:22,000
打一个 silver bullet

3074
02:08:22,000 --> 02:08:27,000
把那个人的把这个人把吊着一个人的绳子射断

3075
02:08:27,000 --> 02:08:29,000
然后或者是

3076
02:08:29,000 --> 02:08:30,000
呃

3077
02:08:30,000 --> 02:08:32,000
一枪打爆一个锁

3078
02:08:32,000 --> 02:08:35,000
然后这个锁偏巧就可以弹开

3079
02:08:35,000 --> 02:08:36,000
然后可以让门打开

3080
02:08:36,000 --> 02:08:38,000
这样一种

3081
02:08:38,000 --> 02:08:41,000
非常奇迹引巧的技术

3082
02:08:41,000 --> 02:08:47,000
好像最近应该是前年这个 long ranger 这个故事还重新被搬上荧幕

3083
02:08:47,000 --> 02:08:49,000
而且把你 johnny depp

3084
02:08:49,000 --> 02:08:51,000
对 johnny depp 演的

3085
02:08:51,000 --> 02:08:52,000
对

3086
02:08:52,000 --> 02:08:56,000
对这个 silver bullet 实际上来自于这样一个稿

3087
02:08:56,000 --> 02:09:00,000
然后 silver bullet 的特点也就是相信有这样一种机器

3088
02:09:00,000 --> 02:09:02,000
能够可以

3089
02:09:02,000 --> 02:09:04,000
一劳永逸的解决

3090
02:09:04,000 --> 02:09:06,000
所以我一些

3091
02:09:06,000 --> 02:09:08,000
对无视其呃

3092
02:09:08,000 --> 02:09:12,000
无视其边界条件的难题

3093
02:09:12,000 --> 02:09:13,000
嗯

3094
02:09:13,000 --> 02:09:18,000
然后这个 silver bullet 也是通过人越神话这本书被啊

3095
02:09:18,000 --> 02:09:19,000
发言光大

3096
02:09:19,000 --> 02:09:20,000
以至于现在很多

3097
02:09:20,000 --> 02:09:23,000
我相信大本程选都应该听过这个名字

3098
02:09:23,000 --> 02:09:25,000
但是不太清楚他是怎么来的

3099
02:09:25,000 --> 02:09:28,000
但实际上 silver bullet 也是一个比较比较著名的

3100
02:09:28,000 --> 02:09:29,000
anti-partner

3101
02:09:29,000 --> 02:09:31,000
嗯

3102
02:09:31,000 --> 02:09:32,000
嗯

3103
02:09:32,000 --> 02:09:33,000
啊

3104
02:09:33,000 --> 02:09:36,000
这个翻译成中文应该叫什么来的

3105
02:09:36,000 --> 02:09:38,000
万金油

3106
02:09:38,000 --> 02:09:41,000
对 silver bullet 万金油模式

3107
02:09:41,000 --> 02:09:43,000
and golden hammer 其实也是一个万金油

3108
02:09:43,000 --> 02:09:45,000
也有点万金油的意思

3109
02:09:45,000 --> 02:09:48,000
但是 silver bulletsilver bullet 强调的还是

3110
02:09:48,000 --> 02:09:52,000
强调的是这种这种这种解决方案的魔魔法性

3111
02:09:52,000 --> 02:09:56,000
就是这个解决方案真的是药到病除

3112
02:09:56,000 --> 02:09:58,000
一劳永逸

3113
02:09:58,000 --> 02:10:05,000
而 goldhammer 则更强调的是这样一种方这样某一方法的普世性就是拿它干什么都可以

3114
02:10:05,000 --> 02:10:07,000
所以应该是 goldhammer 等价于万金油

3115
02:10:07,000 --> 02:10:10,000
然后 silver bullet 是叫什么来的

3116
02:10:10,000 --> 02:10:11,000
嗯

3117
02:10:11,000 --> 02:10:12,000
灵丹妙药是不是

3118
02:10:12,000 --> 02:10:13,000
对灵丹妙药

3119
02:10:13,000 --> 02:10:14,000
哎

3120
02:10:14,000 --> 02:10:15,000
反应不错

3121
02:10:15,000 --> 02:10:19,000
以后我们可以试试把所有的 anti-partner 都给一个本土化的中文名

3122
02:10:19,000 --> 02:10:21,000
哈哈哈

3123
02:10:21,000 --> 02:10:23,000
读起来很酸爽

3124
02:10:23,000 --> 02:10:25,000
哈哈哈

3125
02:10:25,000 --> 02:10:27,000
呃感谢你收听本期 ipm podcast

3126
02:10:27,000 --> 02:10:31,000
网络旗下的 it 技术主题娱乐节目内核洪荒

3127
02:10:31,000 --> 02:10:32,000
我们号称 hardcore

3128
02:10:32,000 --> 02:10:33,000
但是也没有干货

3129
02:10:33,000 --> 02:10:35,000
想听的人听不想听人就别听

3130
02:10:35,000 --> 02:10:39,000
你可以为本节目捐款捐款地址是 ipn.li

3131
02:10:39,000 --> 02:10:40,000
slashkernopanic

3132
02:10:40,000 --> 02:10:41,000
slashdonate

3133
02:10:41,000 --> 02:10:42,000
捐款结合随意

3134
02:10:42,000 --> 02:10:44,000
只要是能为大家整出一个正常数就可以

3135
02:10:44,000 --> 02:10:46,000
捐款不会为你带来什么

3136
02:10:46,000 --> 02:10:48,000
不捐也不会让你试试什么

3137
02:10:48,000 --> 02:10:50,000
我们的口号是 no hard feelings

3138
02:10:50,000 --> 02:10:52,000
如果你有什么反馈

3139
02:10:52,000 --> 02:10:56,000
欢迎你发邮件到 kernopanicatipn.li

3140
02:10:56,000 --> 02:10:58,000
如果写的足够长的话

3141
02:10:58,000 --> 02:11:00,000
我们一定会念出来

3142
02:11:00,000 --> 02:11:05,000
同时也欢迎你收听 ipn 旗下的其他几档节目

3143
02:11:05,000 --> 02:11:06,000
it 公论

3144
02:11:06,000 --> 02:11:07,000
未知到太一来了

3145
02:11:07,000 --> 02:11:08,000
流行通信

3146
02:11:08,000 --> 02:11:09,000
high story

3147
02:11:09,000 --> 02:11:10,000
以及映像

3148
02:11:10,000 --> 02:11:12,000
我们下期节目再会

3149
02:11:14,000 --> 02:11:15,000
各位听众大家好

3150
02:11:15,000 --> 02:11:16,000
我是陈军

3151
02:11:16,000 --> 02:11:17,000
主播无套

3152
02:11:17,000 --> 02:11:19,000
因为得了炎炎

3153
02:11:19,000 --> 02:11:22,000
所以上一期的节目都非常痛苦

3154
02:11:22,000 --> 02:11:23,000
在录完节目之后

3155
02:11:23,000 --> 02:11:25,000
我现在才能录了一部节目了

3156
02:11:25,000 --> 02:11:27,000
我现在怎么会成这个样子

3157
02:11:27,000 --> 02:11:32,000
我也不知道自己要为什么录这段

3158
02:11:32,000 --> 02:11:35,000
因为我好像过去十年里面

3159
02:11:35,000 --> 02:11:38,000
没有一次上次可以烂成这个样子

3160
02:11:38,000 --> 02:11:41,000
所以赶紧给我们捐款吧

