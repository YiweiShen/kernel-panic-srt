1
00:00:00,000 --> 00:00:04,000
欢迎收听 IPN Podcast 网络旗下的 IT 技术主题娱乐节目

2
00:00:04,000 --> 00:00:05,000
《内核恐慌》

3
00:00:05,000 --> 00:00:06,000
我们号称 hardcore

4
00:00:06,000 --> 00:00:08,000
但是也没有什么干货

5
00:00:08,000 --> 00:00:09,000
想听的人听

6
00:00:09,000 --> 00:00:10,000
不想听的人就别听

7
00:00:10,000 --> 00:00:15,000
本节目的网址是 ipn.li.com

8
00:00:15,000 --> 00:00:19,000
我们推荐大家使用 Podcast 客户端订阅节目

9
00:00:19,000 --> 00:00:23,000
详情请访问 ipn.li.com

10
00:00:23,000 --> 00:00:26,000
欢迎你为本节目捐款

11
00:00:26,000 --> 00:00:28,000
捐款地址是 ipn.li.com

12
00:00:28,000 --> 00:00:30,000
kernelpanic.com

13
00:00:30,000 --> 00:00:32,000
捐款金额随意

14
00:00:32,000 --> 00:00:33,000
只要是能被扒

15
00:00:33,000 --> 00:00:35,000
除的正整数就可以

16
00:00:35,000 --> 00:00:37,000
捐款不会给你带来什么

17
00:00:37,000 --> 00:00:39,000
不捐也不会让你失去什么

18
00:00:39,000 --> 00:00:40,000
我们的口号是

19
00:00:40,000 --> 00:00:42,000
Hyper is Hyper Awesome

20
00:00:42,000 --> 00:00:44,000
今天我们特别荣幸

21
00:00:44,000 --> 00:00:45,000
听到一位嘉宾

22
00:00:45,000 --> 00:00:47,000
Simon 薛磊

23
00:00:47,000 --> 00:00:49,000
薛磊也给大家介绍一下自己吧

24
00:00:49,000 --> 00:00:50,000
Hello 大家好

25
00:00:50,000 --> 00:00:51,000
我叫 Simon

26
00:00:51,000 --> 00:00:55,000
我现在从事的是一项

27
00:00:55,000 --> 00:00:57,000
基于容器的一个

28
00:00:57,000 --> 00:00:58,000
容器的一个

29
00:00:58,000 --> 00:00:59,000
创业项目

30
00:00:59,000 --> 00:01:01,000
然后目前是处于初创阶段

31
00:01:01,000 --> 00:01:04,000
之前我从事的是主要是

32
00:01:04,000 --> 00:01:05,000
内核相关的工作

33
00:01:05,000 --> 00:01:08,000
之前也非常热衷的关注于

34
00:01:08,000 --> 00:01:09,000
内核相关的所有

35
00:01:09,000 --> 00:01:12,000
创业的相关的项目

36
00:01:12,000 --> 00:01:14,000
然后包括最近特别火的

37
00:01:14,000 --> 00:01:15,000
一个容器

38
00:01:15,000 --> 00:01:17,000
所以也加入了这个

39
00:01:17,000 --> 00:01:19,000
以容器或者说

40
00:01:19,000 --> 00:01:21,000
以 Hypervisor 为主题的一个创业项目

41
00:01:22,000 --> 00:01:23,000
非常荣幸的能参加

42
00:01:23,000 --> 00:01:26,000
内核恐慌

43
00:01:26,000 --> 00:01:26,000
这个节目

44
00:01:26,000 --> 00:01:28,000
之前也很关注

45
00:01:28,000 --> 00:01:29,000
非常谦虚

46
00:01:29,000 --> 00:01:32,000
因为 Simon 的自我介绍很低调

47
00:01:32,000 --> 00:01:35,000
其实 Simon 你之前是在 Sum

48
00:01:35,000 --> 00:01:38,000
就是后来你家卖给 Oracle 的公司

49
00:01:38,000 --> 00:01:39,000
也就是 Java 的诞生地

50
00:01:39,000 --> 00:01:40,000
对吧

51
00:01:40,000 --> 00:01:40,000
对

52
00:01:40,000 --> 00:01:42,000
其实说到 Sum

53
00:01:42,000 --> 00:01:45,000
其实有更多的人

54
00:01:45,000 --> 00:01:46,000
其实只知道是 Java

55
00:01:46,000 --> 00:01:48,000
但是除了 Java 之外

56
00:01:48,000 --> 00:01:52,000
它有非常多的优秀的项目

57
00:01:52,000 --> 00:01:53,000
比如说 Source

58
00:01:53,000 --> 00:01:55,000
就是 Unix 的一个变种

59
00:01:55,000 --> 00:01:57,000
可能目前很多 Linux

60
00:01:57,000 --> 00:01:58,000
内核以及 Linux

61
00:01:58,000 --> 00:02:02,000
分化版本上面的软件

62
00:02:02,000 --> 00:02:04,000
以及内核的模块

63
00:02:04,000 --> 00:02:05,000
都是来自于 Source

64
00:02:05,000 --> 00:02:08,000
比如特别著名的 ZFS

65
00:02:08,000 --> 00:02:10,000
当然可能做存储的人

66
00:02:10,000 --> 00:02:11,000
都知道 ZFS

67
00:02:11,000 --> 00:02:14,000
它的一个特别强大的功能

68
00:02:14,000 --> 00:02:15,000
以及调试

69
00:02:15,000 --> 00:02:17,000
内核的时候

70
00:02:17,000 --> 00:02:19,000
所用到的一些工具

71
00:02:19,000 --> 00:02:21,000
比如说 MDB

72
00:02:21,000 --> 00:02:24,000
Linux 上类似的就是 GDB

73
00:02:24,000 --> 00:02:28,000
然后一种追踪内核

74
00:02:28,000 --> 00:02:28,000
的功能

75
00:02:28,000 --> 00:02:31,000
不极限于内核

76
00:02:31,000 --> 00:02:33,000
除内核还有应用程序

77
00:02:33,000 --> 00:02:35,000
都可以追踪 Dtrace

78
00:02:35,000 --> 00:02:39,000
就像目前的 System Type

79
00:02:39,000 --> 00:02:41,000
以及 Key Type

80
00:02:41,000 --> 00:02:43,000
以及类似这种 Trace 工具

81
00:02:43,000 --> 00:02:45,000
应该说

82
00:02:45,000 --> 00:02:49,000
大多数都来自于 Dtrace 的设计理念

83
00:02:49,000 --> 00:02:50,000
非常酷

84
00:02:50,000 --> 00:02:53,000
Simon 你之前在 Sum 的话

85
00:02:53,000 --> 00:02:55,000
具体是做哪一块工作呢

86
00:02:55,000 --> 00:02:57,000
我之前在 Sum 的时候

87
00:02:57,000 --> 00:02:58,000
是北京研发的

88
00:02:58,000 --> 00:03:01,000
北京研发中心这边主要的一大块

89
00:03:01,000 --> 00:03:04,000
是大概 20 多人的一个团队

90
00:03:04,000 --> 00:03:06,000
主要是从事的是

91
00:03:06,000 --> 00:03:08,000
内核 SWS 的一个存储

92
00:03:08,000 --> 00:03:10,000
存储协议的一个研发

93
00:03:10,000 --> 00:03:12,000
主要集中在 SCAS 协议

94
00:03:12,000 --> 00:03:13,000
这个可能比较底层了

95
00:03:13,000 --> 00:03:17,000
可能不多内核的人不太清楚这一块东西

96
00:03:17,000 --> 00:03:22,000
这就是一个相当于一个标准的网络存储协议

97
00:03:22,000 --> 00:03:25,000
比如现在咱们说的硬盘

98
00:03:25,000 --> 00:03:26,000
就 SCAS 硬盘

99
00:03:26,000 --> 00:03:28,000
像什么 SATA 硬盘等等等等

100
00:03:28,000 --> 00:03:30,000
都是走的 SCAS 协议

101
00:03:30,000 --> 00:03:34,000
所以我们其实在这一条线上去做开发

102
00:03:34,000 --> 00:03:38,000
可能也比较偏存储一点

103
00:03:38,000 --> 00:03:40,000
也比较偏内核一点

104
00:03:40,000 --> 00:03:41,000
对

105
00:03:41,000 --> 00:03:44,000
SCAS 当年还是跟什么 IDE

106
00:03:44,000 --> 00:03:46,000
那些 S 叫 IDE 吧

107
00:03:46,000 --> 00:03:46,000
对

108
00:03:46,000 --> 00:03:47,000
对

109
00:03:47,000 --> 00:03:47,000
对

110
00:03:47,000 --> 00:03:49,000
现在后来是发展成了

111
00:03:49,000 --> 00:03:52,000
是 SATA 对 SaaS

112
00:03:52,000 --> 00:03:52,000
对吧

113
00:03:52,000 --> 00:03:54,000
两个协议

114
00:03:54,000 --> 00:03:56,000
然后 SCAS 是 SaaS 的前身

115
00:03:56,000 --> 00:03:57,000
如果我理解没错的话

116
00:03:57,000 --> 00:03:58,000
对 是的

117
00:03:58,000 --> 00:03:59,000
OK

118
00:03:59,000 --> 00:04:02,000
所以你之前的主要工作是在做存储协议这一块

119
00:04:02,000 --> 00:04:02,000
对 是

120
00:04:02,000 --> 00:04:04,000
所以也是非常一个 hardcore 的人

121
00:04:04,000 --> 00:04:06,000
特别适合我们节目的主题

122
00:04:06,000 --> 00:04:12,000
所以我最开始关注疯狂的节目的时候

123
00:04:12,000 --> 00:04:16,000
就因为自己从事这个行业

124
00:04:16,000 --> 00:04:18,000
所以也关注这个

125
00:04:18,000 --> 00:04:20,000
发现还是挺有意思的

126
00:04:20,000 --> 00:04:23,000
虽然我们节目一直都号称自己非常水

127
00:04:23,000 --> 00:04:26,000
然后这期终于有一个够硬的干货

128
00:04:26,000 --> 00:04:27,000
满足大家的要求了

129
00:04:28,000 --> 00:04:29,000
OK

130
00:04:29,000 --> 00:04:32,000
三本刚才你提到你现在在做一个跟容器相关的

131
00:04:32,000 --> 00:04:37,000
当然我们节目在之前的某一期里面也提到过

132
00:04:37,000 --> 00:04:39,000
这个概念叫做 container

133
00:04:39,000 --> 00:04:39,000
对不对

134
00:04:39,000 --> 00:04:40,000
对

135
00:04:40,000 --> 00:04:41,000
然后

136
00:04:41,000 --> 00:04:45,000
但是毕竟我跟吴涛两个人都属于这个东西的一个叫什么

137
00:04:45,000 --> 00:04:47,000
用户或者说是门外汉

138
00:04:47,000 --> 00:04:50,000
但是你其实是在做这个相关的开发的

139
00:04:50,000 --> 00:04:54,000
所以本期我们可能会就这个问题进入一些更加深入的探讨

140
00:04:54,000 --> 00:04:54,000
OK

141
00:04:54,000 --> 00:04:58,000
所以你现在做这间公司这个项目叫什么

142
00:04:58,000 --> 00:05:00,000
其实这个项目就叫 hyper

143
00:05:00,000 --> 00:05:03,000
然后 hyper 这个我们的这个公司呢

144
00:05:03,000 --> 00:05:04,000
就叫 hyper hq

145
00:05:04,000 --> 00:05:08,000
然后主要为什么取这个名字呢

146
00:05:08,000 --> 00:05:15,000
其实也是想针对国外的用户或者一些企业或者是 partner 来去做

147
00:05:15,000 --> 00:05:19,000
所以这个中文的名字不太好听

148
00:05:19,000 --> 00:05:20,000
所以大家也就忽悦吧

149
00:05:20,000 --> 00:05:23,000
大家更多关注可以关注我们的那个英文的网站

150
00:05:23,000 --> 00:05:26,000
然后可能我们的中文网站还在做

151
00:05:26,000 --> 00:05:30,000
也没有特别的一个进展

152
00:05:30,000 --> 00:05:32,000
但是所以就是我们的一个定位吧

153
00:05:32,000 --> 00:05:36,000
可能跟之前的国内的一个创业团队不太一样

154
00:05:36,000 --> 00:05:39,000
我们还是希望能够做的足够精致吧

155
00:05:39,000 --> 00:05:40,000
OK

156
00:05:40,000 --> 00:05:44,000
对这个事情说来就非常巧啊

157
00:05:44,000 --> 00:05:46,000
其实我跟 Simon 的认识还是一个机缘巧合

158
00:05:46,000 --> 00:05:49,000
就有一天我收到了一封这个邮件

159
00:05:49,000 --> 00:05:54,000
然后发给我的地址是对应到我的那个 GitHub 的账号的那个邮箱的

160
00:05:54,000 --> 00:05:56,000
然后是 Simon 给我来的一封信

161
00:05:56,000 --> 00:05:58,000
然后他是问我说能不能

162
00:05:58,000 --> 00:06:00,000
因为我当时在 GitHub 上面有一个项目

163
00:06:00,000 --> 00:06:03,000
是使用这个命令行控制

164
00:06:03,000 --> 00:06:05,000
通过这个 VirtualBox 的命令行工具去控制它

165
00:06:05,000 --> 00:06:07,000
启动这个讯息机啊

166
00:06:07,000 --> 00:06:09,000
创建讯息机这种基本的小工具

167
00:06:09,000 --> 00:06:12,000
是一个勾拦的一个库吧

168
00:06:12,000 --> 00:06:15,000
然后当时 Simon 给我来了一封邮件说能不能用这个

169
00:06:15,000 --> 00:06:20,000
因为当时我在 GitHub 上面那个 repository 里面没有写这个授权协议

170
00:06:20,000 --> 00:06:22,000
这点我还是当时我就非常感动

171
00:06:22,000 --> 00:06:26,000
因为你知道很多这个大家都是直接拿来主义嘛对吧

172
00:06:26,000 --> 00:06:26,000
对

173
00:06:26,000 --> 00:06:28,000
也不会问这种事情的

174
00:06:28,000 --> 00:06:31,000
所以在这方面我觉得像 Simon 还有 Hyper 这个团队

175
00:06:31,000 --> 00:06:35,000
对这个版权意识还是非常非常看重的

176
00:06:35,000 --> 00:06:37,000
这点我觉得非常非常难得

177
00:06:37,000 --> 00:06:37,000
对对对

178
00:06:37,000 --> 00:06:40,000
因为我们其实我们这个项目

179
00:06:40,000 --> 00:06:46,000
据我们所知因为国内很少有这种创业团队去做开源项目

180
00:06:46,000 --> 00:06:48,000
而我们这个 Hyper 其实是一个开源项目

181
00:06:48,000 --> 00:06:49,000
既然开源项目的话

182
00:06:49,000 --> 00:06:52,000
我们也是希望能够融入足够多的社区

183
00:06:52,000 --> 00:06:53,000
足够大的社区

184
00:06:53,000 --> 00:06:56,000
然后吸引更多的开发者

185
00:06:56,000 --> 00:07:02,000
然后所以在这方面其实也是尽自己微薄之力

186
00:07:02,000 --> 00:07:07,000
然后能尽量的改善一下国人在开发者

187
00:07:07,000 --> 00:07:11,000
在这种全球的开发者的这种印象吧

188
00:07:11,000 --> 00:07:14,000
因为可能更多的提到可能国内的工程师

189
00:07:14,000 --> 00:07:17,000
当然只能是少数吧

190
00:07:17,000 --> 00:07:19,000
他就拿来主义

191
00:07:19,000 --> 00:07:22,000
就直接毁坏了这个圈子的名声了

192
00:07:22,000 --> 00:07:24,000
对对对

193
00:07:24,000 --> 00:07:26,000
刚才我们聊了一堆这个

194
00:07:26,000 --> 00:07:27,000
周边的情况

195
00:07:27,000 --> 00:07:29,000
最后还是回到这个 Hyper 这个本质上

196
00:07:29,000 --> 00:07:31,000
在这个说之前

197
00:07:31,000 --> 00:07:33,000
我们先把这个网址亮出来吧

198
00:07:33,000 --> 00:07:36,000
这个网址是非常酷的一个域名叫做 Hyper.sh

199
00:07:36,000 --> 00:07:36,000
对

200
00:07:36,000 --> 00:07:39,000
当时你们怎么想的会取用这个一个

201
00:07:39,000 --> 00:07:41,000
这么一个域名

202
00:07:41,000 --> 00:07:44,000
因为毕竟其实我们的

203
00:07:44,000 --> 00:07:50,000
就是到的 sh 还是偏技术或者偏 hack 一点

204
00:07:50,000 --> 00:07:54,000
因为 sh 你可以认为是 by 式

205
00:07:54,000 --> 00:07:56,000
或者是认为是其他的

206
00:07:56,000 --> 00:07:58,000
一些那个 share

207
00:07:58,000 --> 00:07:58,000
对对对

208
00:07:58,000 --> 00:08:02,000
所以我们当时也是用了这种

209
00:08:02,000 --> 00:08:08,000
当然也是追求足够精简短一些

210
00:08:08,000 --> 00:08:10,000
然后就选用了这个域名

211
00:08:10,000 --> 00:08:12,000
然后当时我们之前参加

212
00:08:12,000 --> 00:08:13,000
挺有意思的一个事情

213
00:08:13,000 --> 00:08:16,000
就是我们之前参加一个云计算的大会

214
00:08:16,000 --> 00:08:18,000
然后很多人过来说

215
00:08:18,000 --> 00:08:20,000
你们这家公司是成立在上海是吗

216
00:08:20,000 --> 00:08:23,000
对

217
00:08:23,000 --> 00:08:25,000
但其实 sh 是哪个国家的国家地区呢

218
00:08:25,000 --> 00:08:25,000
对对对

219
00:08:25,000 --> 00:08:26,000
这个国家地区来着

220
00:08:26,000 --> 00:08:29,000
这我还真真忘了

221
00:08:29,000 --> 00:08:32,000
OK 这个我们回头查一下

222
00:08:32,000 --> 00:08:35,000
但是一般我们会把这个一些 share 的工具

223
00:08:35,000 --> 00:08:38,000
会用这个.sh 这个顶级域来做

224
00:08:38,000 --> 00:08:39,000
对

225
00:08:39,000 --> 00:08:42,000
然后这个网站当时那个 Simon 给我来信的时候

226
00:08:42,000 --> 00:08:44,000
我就问到这个项目网站之后

227
00:08:44,000 --> 00:08:44,000
我就看了一下

228
00:08:44,000 --> 00:08:47,000
就是令我非常惊艳

229
00:08:47,000 --> 00:08:50,000
因为这确实不像是一个国内的团队做出来那种风格

230
00:08:50,000 --> 00:08:54,000
因为整个就是很美国的那种很酷

231
00:08:54,000 --> 00:08:55,000
很嘻哈的那种风格

232
00:08:55,000 --> 00:08:58,000
这种创业团队做出来的这种技术展示的页面

233
00:08:58,000 --> 00:09:00,000
非常精美非常漂亮

234
00:09:00,000 --> 00:09:02,000
所以说了这么多

235
00:09:02,000 --> 00:09:05,000
我们还没有介绍一个 hyper 到底是一个什么样的东西

236
00:09:05,000 --> 00:09:08,000
Simon 你能够用这个一句简单的话介绍一下

237
00:09:08,000 --> 00:09:11,000
hyper 是一个就给我们不太熟悉这个东西的听众

238
00:09:11,000 --> 00:09:13,000
介绍一下 hyper 到底是个什么样的工具吗

239
00:09:13,000 --> 00:09:17,000
其实我觉得如果要先介绍 hyper 之前

240
00:09:17,000 --> 00:09:19,000
应该先在介绍 hyper 之前

241
00:09:19,000 --> 00:09:21,000
最好先介绍一下 Docker

242
00:09:21,000 --> 00:09:25,000
因为可能很多人没有了解过这个领域

243
00:09:25,000 --> 00:09:28,000
然后如果大家知道 Docker 的话

244
00:09:28,000 --> 00:09:31,000
那么说 hyper 的话就很简单

245
00:09:31,000 --> 00:09:33,000
一句话就可以说明白了

246
00:09:33,000 --> 00:09:34,000
OK

247
00:09:34,000 --> 00:09:37,000
咱们先说 Docker 慢慢来

248
00:09:37,000 --> 00:09:38,000
OK

249
00:09:38,000 --> 00:09:42,000
Docker 它其实属于一个新兴项目

250
00:09:42,000 --> 00:09:45,000
大概也存在了两到三年的发展速度相当相当惊人

251
00:09:45,000 --> 00:09:49,000
大概现在 Docker 的公司大概估值 10 亿美金吧

252
00:09:49,000 --> 00:09:51,000
10 亿美金超过 10 亿美金了

253
00:09:51,000 --> 00:09:55,000
然后它其实本质上是基于容器

254
00:09:55,000 --> 00:09:58,000
它是一个做的一组管理工具

255
00:09:58,000 --> 00:10:00,000
我是这么理解

256
00:10:00,000 --> 00:10:04,000
然后它将一些镜像文件

257
00:10:04,000 --> 00:10:05,000
比如无纹图啊

258
00:10:05,000 --> 00:10:07,000
各种 Linux 文化版本都可以

259
00:10:07,000 --> 00:10:10,000
然后作为一个运行式环境

260
00:10:10,000 --> 00:10:13,000
然后装到容器里面

261
00:10:13,000 --> 00:10:14,000
然后去增加网络

262
00:10:14,000 --> 00:10:15,000
增加存储

263
00:10:15,000 --> 00:10:18,000
这些所有的组件 component

264
00:10:18,000 --> 00:10:25,000
然后使之做一个轻量级的虚拟化工具来去运行

265
00:10:25,000 --> 00:10:27,000
就相当于在同一台机器上

266
00:10:27,000 --> 00:10:30,000
我可以虚拟出来多个单独的容器

267
00:10:30,000 --> 00:10:34,000
然后这样去运行不同的 App

268
00:10:34,000 --> 00:10:36,000
Docker 其中一个理念

269
00:10:36,000 --> 00:10:38,000
或者说容器的一个理念

270
00:10:38,000 --> 00:10:42,000
就是一个容器里面只运行一个 App

271
00:10:42,000 --> 00:10:45,000
相当于我只运行一个 Tomcat

272
00:10:45,000 --> 00:10:50,000
或者说类似一种软件

273
00:10:50,000 --> 00:10:54,000
然后这样的话来做到使每个容器尽量的精简

274
00:10:54,000 --> 00:10:55,000
然后更便于更多的容器进行运行

275
00:10:55,000 --> 00:10:57,000
然后更便于更多的容器进行运行

276
00:10:57,000 --> 00:10:59,000
它其实是为了

277
00:10:59,000 --> 00:11:04,000
为这些运营或者说为这些开发测试

278
00:11:04,000 --> 00:11:09,000
进入一个比较一致的一个运行式环境

279
00:11:09,000 --> 00:11:10,000
然后这样的话就是

280
00:11:10,000 --> 00:11:13,000
你可以自己提交你自己的 contentor 的镜像

281
00:11:13,000 --> 00:11:15,000
然后直接提交过去之后

282
00:11:15,000 --> 00:11:17,000
任何人都可以下载

283
00:11:17,000 --> 00:11:21,000
这样的话就保证了一个非常一致的运行式环境

284
00:11:21,000 --> 00:11:24,000
就解决了一些

285
00:11:24,000 --> 00:11:27,000
像咱们几年前开发软件就是

286
00:11:27,000 --> 00:11:29,000
Java 各种配置环境变量

287
00:11:29,000 --> 00:11:32,000
各种参数配置等等

288
00:11:32,000 --> 00:11:34,000
这些问题就迎刃而解

289
00:11:34,000 --> 00:11:36,000
我直接下载一个镜像直接运行

290
00:11:36,000 --> 00:11:38,000
就可以跟

291
00:11:38,000 --> 00:11:40,000
比如我是一个测试人员

292
00:11:40,000 --> 00:11:43,000
就可以跟开发人员的运行式

293
00:11:43,000 --> 00:11:46,000
开发环境保持一致

294
00:11:46,000 --> 00:11:49,000
就解决了很多环境相关的问题

295
00:11:51,000 --> 00:11:52,000
然后说到容器

296
00:11:52,000 --> 00:11:53,000
容器它是

297
00:11:54,000 --> 00:11:57,000
Docker 用到容器作为运行式环境

298
00:11:57,000 --> 00:11:59,000
然后容器的这个概念

299
00:11:59,000 --> 00:12:03,000
相当于将一个 house 的主机

300
00:12:03,000 --> 00:12:09,000
分成多个子的容器来去运行 APP

301
00:12:09,000 --> 00:12:11,000
它这属于轻量级

302
00:12:11,000 --> 00:12:15,000
轻量级的另外一个好处就是速度足够的快

303
00:12:15,000 --> 00:12:17,000
但是它一个弊端的就是

304
00:12:17,000 --> 00:12:18,000
因为它是 share 的客户

305
00:12:18,000 --> 00:12:21,000
它是在一个内核上面去运行

306
00:12:21,000 --> 00:12:24,000
所以它也造成了一个安全性的

307
00:12:24,000 --> 00:12:26,000
所以它是一个很重要的一个隐患吧

308
00:12:26,000 --> 00:12:29,000
所以这就提到了我们存在的意义

309
00:12:29,000 --> 00:12:32,000
就是解决这个安全性的问题

310
00:12:32,000 --> 00:12:35,000
就是因为这个容器它是 share 的客人

311
00:12:35,000 --> 00:12:37,000
OK 我们不用 share 客人

312
00:12:37,000 --> 00:12:39,000
而是用 hypervisor

313
00:12:39,000 --> 00:12:42,000
就是用 VM 来代替容器

314
00:12:42,000 --> 00:12:46,000
来去运行 Docker 的 image

315
00:12:46,000 --> 00:12:48,000
然后这样的话呢

316
00:12:48,000 --> 00:12:51,000
就是解决了 Docker 的一个安全性问题

317
00:12:51,000 --> 00:12:53,000
但是因为众所周知

318
00:12:53,000 --> 00:12:56,000
就是大家用过 VMware 用过 Washbox

319
00:12:56,000 --> 00:12:59,000
都知道它的启动速度可能会比较慢

320
00:12:59,000 --> 00:13:03,000
即使在你的非常好的高端的服务器上面

321
00:13:03,000 --> 00:13:08,000
大概也要在一两分钟或者是两三分钟吧

322
00:13:08,000 --> 00:13:09,000
没错

323
00:13:09,000 --> 00:13:12,000
所以我们也是极致的优化

324
00:13:12,000 --> 00:13:16,000
让它的启动速度大概在毫秒级别

325
00:13:16,000 --> 00:13:17,000
毫秒级别

326
00:13:17,000 --> 00:13:18,000
对

327
00:13:18,000 --> 00:13:22,000
所以刚才是从一两分钟至少就是 100 秒一级别

328
00:13:22,000 --> 00:13:24,000
我们现在已经到毫秒级别了

329
00:13:24,000 --> 00:13:26,000
有四个数量级的提升了

330
00:13:26,000 --> 00:13:32,000
对所以大概我们的测试在比较好的机器上大概在 300 毫秒

331
00:13:32,000 --> 00:13:35,000
OK 0.3 秒左右

332
00:13:35,000 --> 00:13:40,000
对所以这个相对于容器的运行的启动速度来说

333
00:13:40,000 --> 00:13:43,000
已经算是差距不大了

334
00:13:43,000 --> 00:13:47,000
而且它的安全性有很大的提升

335
00:13:47,000 --> 00:13:50,000
这样的话也就是成为我们一个核心的竞争力

336
00:13:50,000 --> 00:13:51,000
或者说一个存在的

337
00:13:52,000 --> 00:13:57,000
基于这个目的来去做的这个东西

338
00:13:57,000 --> 00:14:03,000
所以就是说 Hyper 是一个可以快速启动的虚拟机

339
00:14:03,000 --> 00:14:04,000
可以这么理解吗

340
00:14:04,000 --> 00:14:08,000
对然后它在虚拟机的基础上

341
00:14:08,000 --> 00:14:12,000
可以很快的将 Docker 的 image 运行起来

342
00:14:12,000 --> 00:14:13,000
OK

343
00:14:13,000 --> 00:14:19,000
然后 Hyper 启动的虚拟机里面是就只跑一个 Docker 的镜像

344
00:14:19,000 --> 00:14:22,000
还是说它里面可以跑多个 Docker 镜像呢

345
00:14:22,000 --> 00:14:25,000
可以跑多个 Docker 的镜像

346
00:14:25,000 --> 00:14:30,000
而我们这个一个虚拟机其实相当于是一个工作单元

347
00:14:30,000 --> 00:14:34,000
这个工作单元其实这个 idea 是来自于

348
00:14:34,000 --> 00:14:37,000
Kubernetes 里面的一个 POD 的概念

349
00:14:37,000 --> 00:14:41,000
就是一组 contentor 的一个集合

350
00:14:41,000 --> 00:14:43,000
而这一组 contentor 是有关系的

351
00:14:43,000 --> 00:14:47,000
它是为了运行一个比如我运行一个网站

352
00:14:47,000 --> 00:14:51,000
肯定要一个 Nidix MySQL 等等这类的东西

353
00:14:52,000 --> 00:14:56,000
所以我买 Secure 一个 contentor

354
00:14:56,000 --> 00:14:58,000
我 Nidix 一个 contentor

355
00:14:58,000 --> 00:15:03,000
然后这样的话就组成一个 POD

356
00:15:03,000 --> 00:15:06,000
这个 POD 的概念就包含了两个 contentor

357
00:15:06,000 --> 00:15:07,000
OK

358
00:15:07,000 --> 00:15:09,000
所以可以这么理解吗

359
00:15:09,000 --> 00:15:14,000
就是说一个 Hyper 的虚拟机是对应一个 POD 的盒子

360
00:15:14,000 --> 00:15:20,000
然后这个 POD 里面是包含了多个 Docker 的 container

361
00:15:20,000 --> 00:15:21,000
对

362
00:15:21,000 --> 00:15:23,000
然后每个 contentor 里面只运行单一的一个应用

363
00:15:23,000 --> 00:15:24,000
它可能是一个数据库

364
00:15:24,000 --> 00:15:25,000
像 MySQL

365
00:15:25,000 --> 00:15:27,000
可能是一个这个 web 服务器

366
00:15:27,000 --> 00:15:28,000
像 EngineX

367
00:15:28,000 --> 00:15:31,000
还有一个就是像这个一个应用服务器

368
00:15:31,000 --> 00:15:32,000
比如说一个 Tomcat

369
00:15:32,000 --> 00:15:34,000
或者其他一些什么像 Python

370
00:15:34,000 --> 00:15:36,000
或者 Ruby 写的一个应用进程

371
00:15:36,000 --> 00:15:40,000
所以它用这种 POD 的概念来管理一组 service

372
00:15:40,000 --> 00:15:46,000
所以这个相比这里听起来就是做这件事情的时候

373
00:15:46,000 --> 00:15:49,000
Hyper 相对一些已有的工具

374
00:15:49,000 --> 00:15:51,000
它们的主要的区别在哪里呢

375
00:15:51,000 --> 00:15:54,000
比如说可能像过去也有像基于这个 KVM

376
00:15:54,000 --> 00:15:56,000
Ninax 上面的 KVM

377
00:15:56,000 --> 00:15:59,000
也可以运行一些轻量级快速启动的

378
00:15:59,000 --> 00:16:03,000
当然这个可能需要定制你跑的那个叫做 Ghast

379
00:16:03,000 --> 00:16:05,000
Ghast OS

380
00:16:05,000 --> 00:16:06,000
对对对

381
00:16:06,000 --> 00:16:07,000
就宾客系统

382
00:16:07,000 --> 00:16:11,000
还有一些像过去基于这种传统的 HyperVisor 的一些工具

383
00:16:11,000 --> 00:16:12,000
像 Rin

384
00:16:12,000 --> 00:16:14,000
它里面也可以做一些事情

385
00:16:14,000 --> 00:16:15,000
那么从这个角度出发的话

386
00:16:15,000 --> 00:16:17,000
Hyper 和它们的区别

387
00:16:17,000 --> 00:16:18,000
刚才提到这个 KVM 和 Rin

388
00:16:18,000 --> 00:16:20,000
它们的区别主要在哪里

389
00:16:20,000 --> 00:16:23,000
其实我们底层也是用了 KVM

390
00:16:23,000 --> 00:16:26,000
Zen 以及 Wordbox 这些 HyperVisor

391
00:16:26,000 --> 00:16:29,000
但是我们跟它们的一个优势

392
00:16:29,000 --> 00:16:31,000
或者说我们做什么东西

393
00:16:31,000 --> 00:16:34,000
就是我们将 Ghast OS

394
00:16:34,000 --> 00:16:38,000
我们实现一个经济最简单的一个 Ghast OS

395
00:16:38,000 --> 00:16:43,000
主要是用于跑 Docker 的 Image

396
00:16:43,000 --> 00:16:45,000
然后形成 Container 这一系列工作

397
00:16:45,000 --> 00:16:48,000
另外我们外边提过一个

398
00:16:48,000 --> 00:16:49,000
一整套管理工具

399
00:16:49,000 --> 00:16:52,000
然后可以管理这些 HyperVisor

400
00:16:52,000 --> 00:16:57,000
然后让它能够以炮的为单位去运行 Docker 的 Image

401
00:16:57,000 --> 00:17:01,000
并且提供了很多监控的工具

402
00:17:01,000 --> 00:17:02,000
这样的话

403
00:17:02,000 --> 00:17:04,000
方便用户运行 DockerImage

404
00:17:04,000 --> 00:17:07,000
并有更好的安全性

405
00:17:07,000 --> 00:17:08,000
OK

406
00:17:08,000 --> 00:17:12,000
所以实际上 Hyper 是分两部分

407
00:17:12,000 --> 00:17:15,000
一个是说管理像传统的像 KVM Zen

408
00:17:15,000 --> 00:17:16,000
这些 HyperVisor 的工具

409
00:17:16,000 --> 00:17:17,000
对

410
00:17:17,000 --> 00:17:20,000
它是说是包含一个你们定制过的

411
00:17:20,000 --> 00:17:23,000
极度精简的一个 Ghast OS 的一个内核

412
00:17:23,000 --> 00:17:24,000
对 是的

413
00:17:24,000 --> 00:17:25,000
可以这么理解吗

414
00:17:25,000 --> 00:17:26,000
对

415
00:17:26,000 --> 00:17:27,000
OK

416
00:17:27,000 --> 00:17:29,000
这里就牵涉到两方面的问题了

417
00:17:29,000 --> 00:17:31,000
就是说在管理工具这一块

418
00:17:31,000 --> 00:17:36,000
Hyper 和 Docker 它们之间的界限是什么

419
00:17:36,000 --> 00:17:40,000
你指哪方面的界限

420
00:17:40,000 --> 00:17:43,000
比如说你刚才提到 Hyper 里面

421
00:17:43,000 --> 00:17:45,000
它 Ghast OS 里面包含哪些的东西

422
00:17:45,000 --> 00:17:47,000
就只有一个基础的内核吗

423
00:17:47,000 --> 00:17:48,000
对

424
00:17:48,000 --> 00:17:51,000
Ghast OS 里面除了内核之外还有什么东西

425
00:17:51,000 --> 00:17:52,000
没有别的了

426
00:17:52,000 --> 00:17:57,000
它只是跟外边的 HyperDemon 去一个交互的作用

427
00:17:57,000 --> 00:18:01,000
然后我们会把用 HyperDemon 会把 DockerImage

428
00:18:01,000 --> 00:18:03,000
从 DockerHub 上面下载下来

429
00:18:03,000 --> 00:18:06,000
然后作为一个 BlockoutDevice

430
00:18:06,000 --> 00:18:14,000
或者是一个 WattIL 9 P 的一个文件 attach 给 HyperVisor

431
00:18:14,000 --> 00:18:16,000
然后 Ghast OS 拿到这个内核之后

432
00:18:16,000 --> 00:18:22,000
就会给用户生成一些运行式环境

433
00:18:22,000 --> 00:18:25,000
这是整个这样的一个大概的一个思路

434
00:18:25,000 --> 00:18:29,000
然后你刚才提到 Hyper 还有一部分是管理

435
00:18:29,000 --> 00:18:32,000
像传统的像 KVM Zyn 这种 HyperVisor 的工具

436
00:18:32,000 --> 00:18:35,000
这一部分的话它又主要包含哪些组件

437
00:18:35,000 --> 00:18:37,000
或者是一些功能模块呢

438
00:18:37,000 --> 00:18:43,000
它主要是我想用过 Docker 的人都会有一些印象

439
00:18:43,000 --> 00:18:45,000
比如它可以直接用 Docker 的

440
00:18:45,000 --> 00:18:50,000
DockerLogs 或者说 DockerESEC

441
00:18:50,000 --> 00:18:54,000
或者是 Docker 类似于 TTY 的这种环境

442
00:18:54,000 --> 00:18:56,000
其实我们也提供了这种工具

443
00:18:56,000 --> 00:19:00,000
就是可以因为如果要用一个用户

444
00:19:00,000 --> 00:19:05,000
要想看 HyperVisor 里边的信息的话

445
00:19:05,000 --> 00:19:08,000
那么或者说它的 Log 的话

446
00:19:08,000 --> 00:19:12,000
就必须要登录或者 SSH 进去

447
00:19:12,000 --> 00:19:14,000
所以我们其实是将这些

448
00:19:15,000 --> 00:19:17,000
这些套路全都简化

449
00:19:17,000 --> 00:19:22,000
然后直接通过客户端或者说通过 API

450
00:19:22,000 --> 00:19:26,000
就可以让用户能够简单的访问

451
00:19:26,000 --> 00:19:31,000
到底 HyperVisor 里面运行的 content 到底怎么样了

452
00:19:31,000 --> 00:19:35,000
然后以及它的是否发生错误等等

453
00:19:35,000 --> 00:19:38,000
就这些全部达到一个监控的效果

454
00:19:38,000 --> 00:19:43,000
当然你也可以完全当这个 content 一运行的时候

455
00:19:43,000 --> 00:19:45,000
你就可以监控这个 content 了

456
00:19:45,000 --> 00:19:48,000
content 的所有状态将 Log 全部收集起来

457
00:19:48,000 --> 00:19:49,000
然后再去分析

458
00:19:49,000 --> 00:19:51,000
这个其实一个很方便的

459
00:19:51,000 --> 00:19:55,000
有很方便的 API 方面用户再次开发

460
00:19:55,000 --> 00:19:56,000
OK

461
00:19:56,000 --> 00:20:00,000
所以如果我们画一个这个层次结构图的话

462
00:20:00,000 --> 00:20:03,000
最底层可能是 host 的操作系统

463
00:20:03,000 --> 00:20:07,000
然后它上面会跑着像诸如 KVM

464
00:20:07,000 --> 00:20:09,000
Zenia 这样的一些 HyperVisor 工具

465
00:20:09,000 --> 00:20:11,000
然后再次上就是 Hyper 这一层

466
00:20:11,000 --> 00:20:14,000
去管理 KVM 和 Zenia 这样的工具

467
00:20:14,000 --> 00:20:18,000
然后再在 Hyper 管理的这些 GuestVM 里面

468
00:20:18,000 --> 00:20:20,000
会跑一个 Docker 的一个镜像

469
00:20:20,000 --> 00:20:25,000
然后再在镜像里面去运行我们最终的应用程序

470
00:20:25,000 --> 00:20:26,000
没错吧

471
00:20:26,000 --> 00:20:28,000
那个概念上有点不太一样

472
00:20:28,000 --> 00:20:34,000
因为刚才你说的可能就是更多人去想到这种方式

473
00:20:34,000 --> 00:20:38,000
其实这种方式就是目前的 boot to Docker

474
00:20:38,000 --> 00:20:43,000
它就是将 Docker 的 demon 放到一个 VM 里面去运行

475
00:20:43,000 --> 00:20:47,000
而我们其实是将 Hyper 的 demon

476
00:20:47,000 --> 00:20:49,000
其实我们这里就没有 Docker 的 demon

477
00:20:49,000 --> 00:20:51,000
因为我最开始其实是依赖于 Docker 的 demon

478
00:20:51,000 --> 00:20:52,000
但现在没有了

479
00:20:52,000 --> 00:20:55,000
所以我们取消了 Docker 的依赖

480
00:20:55,000 --> 00:21:00,000
然后将 Hyper 的 demon 放在 HouseOS 里面去运行

481
00:21:00,000 --> 00:21:08,000
而 Docker 的 image 下载下来是直接把这些文件全部传进 VM

482
00:21:08,000 --> 00:21:12,000
然后盖上 GuestOS 再去用这些文件来去运行

483
00:21:13,000 --> 00:21:17,000
然后去运行这些文件

484
00:21:17,000 --> 00:21:23,000
所以其实你们是 Hyper 是完全替代掉了 Docker 的管理的功能

485
00:21:23,000 --> 00:21:24,000
对

486
00:21:24,000 --> 00:21:27,000
你们只是附用了 Docker 的已经制作好的

487
00:21:27,000 --> 00:21:31,000
它本来是为 Docker 管理工具制作好的 container image

488
00:21:31,000 --> 00:21:32,000
对

489
00:21:32,000 --> 00:21:35,000
这个还和我之前解的有一点点出入

490
00:21:35,000 --> 00:21:37,000
这个话其实就还蛮酷的

491
00:21:37,000 --> 00:21:39,000
就是说如果理论上来讲

492
00:21:39,000 --> 00:21:43,000
如果你们因为 Hyper 管理的 VM 的功能

493
00:21:43,000 --> 00:21:45,000
这个虚拟机也非常轻量

494
00:21:45,000 --> 00:21:46,000
其实也很快

495
00:21:46,000 --> 00:21:52,000
同时它又具备传统的像 Docker 无法提供的内核级别的隔离的安全性

496
00:21:52,000 --> 00:21:53,000
对吧

497
00:21:53,000 --> 00:21:58,000
所以其实是在安全性和性能上是完全可以替代

498
00:21:58,000 --> 00:22:01,000
甚至超越 Dockerdemon 本身的

499
00:22:01,000 --> 00:22:02,000
对

500
00:22:02,000 --> 00:22:03,000
OK 明白明白

501
00:22:03,000 --> 00:22:05,000
非常好的解释

502
00:22:05,000 --> 00:22:08,000
所以现在刚才提到一个最主要的核心要点

503
00:22:08,000 --> 00:22:11,000
就是说安全性这一块面

504
00:22:11,000 --> 00:22:12,000
嗯

505
00:22:12,000 --> 00:22:15,000
很多不是做内核相关的朋友

506
00:22:15,000 --> 00:22:19,000
其实也是现在很多使用 Dockercontainer 的一个新手

507
00:22:19,000 --> 00:22:20,000
可能一个困惑

508
00:22:20,000 --> 00:22:25,000
因为确实你想一个 Dockerimage 给人感觉用起来很像一个虚拟机

509
00:22:25,000 --> 00:22:28,000
但它其实并不是一个虚拟机

510
00:22:28,000 --> 00:22:31,000
只是一个我们叫做集装箱或者叫一个容器

511
00:22:31,000 --> 00:22:32,000
这么一个概念

512
00:22:32,000 --> 00:22:36,000
所以 Simon 肯定这里要给我们这些新手

513
00:22:36,000 --> 00:22:39,000
还有也不太熟悉使用 Docker 的人要普及一下

514
00:22:39,000 --> 00:22:40,000
为什么说 Docker

515
00:22:40,000 --> 00:22:44,000
不能提供像传统的虚拟机那样的这么一个安全性

516
00:22:44,000 --> 00:22:49,000
其实这个的话就是从 Docker 本身用的技术上面就要来讨论

517
00:22:49,000 --> 00:22:52,000
因为 Docker 其实它并没有

518
00:22:52,000 --> 00:22:56,000
可能说的有点太直白了

519
00:22:56,000 --> 00:23:00,000
就是 Docker 其实并没有发明任何新的技术

520
00:23:00,000 --> 00:23:01,000
OK

521
00:23:01,000 --> 00:23:02,000
对

522
00:23:02,000 --> 00:23:04,000
其实很多人对 Docker 的一个指责

523
00:23:04,000 --> 00:23:06,000
就是说因为所有的像 container 这些概念

524
00:23:06,000 --> 00:23:08,000
可能是 10 年前就已经有了

525
00:23:08,000 --> 00:23:09,000
对

526
00:23:09,000 --> 00:23:13,000
很多人都说 Docker 其实只是把一些叫什么新瓶装就酒

527
00:23:13,000 --> 00:23:14,000
对

528
00:23:14,000 --> 00:23:15,000
这个倒也没什么

529
00:23:15,000 --> 00:23:18,000
就是从技术角度上确实是这样子的

530
00:23:18,000 --> 00:23:20,000
我的理解可能 Docker 的主要的价值

531
00:23:20,000 --> 00:23:22,000
还是说它提出了这么一套理念

532
00:23:22,000 --> 00:23:27,000
让大家可以说就更好的去从开发到测试

533
00:23:27,000 --> 00:23:29,000
到实际部署这么一套流程工具流程

534
00:23:29,000 --> 00:23:30,000
对

535
00:23:30,000 --> 00:23:33,000
那么刚才安全性的问题就是说

536
00:23:33,000 --> 00:23:38,000
为什么说我们这些小白们会觉得 container 之间是有隔离的

537
00:23:38,000 --> 00:23:40,000
但其实并没有想象的那么好

538
00:23:40,000 --> 00:23:41,000
对

539
00:23:41,000 --> 00:23:45,000
因为这些 container 之间它的一个实验方式

540
00:23:45,000 --> 00:23:48,000
它是基于 namespace 或者说更底层一点

541
00:23:48,000 --> 00:23:50,000
它是通过 siggroups

542
00:23:50,000 --> 00:23:52,000
siggroups 就是一个内核的一个 module

543
00:23:52,000 --> 00:23:58,000
然后它所做一个隔离性的就是相当于用户可以配置

544
00:23:58,000 --> 00:24:02,000
然后 siggroups 在内核里面去限制某一个某一个模块

545
00:24:02,000 --> 00:24:07,000
比如内存比如 CPU 每个线程可以用多少

546
00:24:07,000 --> 00:24:14,000
但是这样的话它所有的全都是基于一个 houseOS 的 kernel 去做的

547
00:24:14,000 --> 00:24:19,000
然后如果一个 container 里面的一个 process

548
00:24:19,000 --> 00:24:22,000
获取了一些更高级的权限

549
00:24:22,000 --> 00:24:24,000
它就可以控制这个内核

550
00:24:24,000 --> 00:24:26,000
而可能这个就是特别细

551
00:24:26,000 --> 00:24:29,000
特别细怎么 hack 去这个事情

552
00:24:29,000 --> 00:24:35,000
但是本身你 share 的 kernel 它其实就是有这种问题的

553
00:24:35,000 --> 00:24:36,000
因为你如果一个 kernel 就是一个 houseOS 的 kernel

554
00:24:36,000 --> 00:24:38,000
因为你如果一个 container 出个问题

555
00:24:38,000 --> 00:24:40,000
导致 kernelpanic 的话

556
00:24:40,000 --> 00:24:44,000
就会导致整个所有的 container 不可用

557
00:24:44,000 --> 00:24:48,000
看来毕节目的名字还是很有示范意义的

558
00:24:48,000 --> 00:24:52,000
对所以刚才你提到一个很重要的概念

559
00:24:52,000 --> 00:24:54,000
就是如果在传统的一个 docker 的部署里面

560
00:24:54,000 --> 00:25:03,000
如果你在一个虚拟机或者同一个内核里面部署了多个来历不明的这么一个 image 在跑

561
00:25:03,000 --> 00:25:05,000
然后假设某一个内核里面有一个内核

562
00:25:06,000 --> 00:25:09,000
因为这个内核它不可能是完美的一个程序

563
00:25:09,000 --> 00:25:10,000
对吧

564
00:25:10,000 --> 00:25:12,000
所以假设一个内核的一个漏洞

565
00:25:12,000 --> 00:25:14,000
或者说你没有及时打上一些补丁

566
00:25:14,000 --> 00:25:16,000
使得一个恶意的程序抓住这个漏洞

567
00:25:16,000 --> 00:25:20,000
它其实可以越权拿到这个最高级的权限

568
00:25:20,000 --> 00:25:25,000
从而影响或者控制其他的 container 里面的东西

569
00:25:25,000 --> 00:25:26,000
对

570
00:25:26,000 --> 00:25:28,000
OK 所以从这个方面来讲

571
00:25:28,000 --> 00:25:31,000
我们必须采用像传统的这个虚拟机

572
00:25:31,000 --> 00:25:34,000
就是独立 kernel 的这种虚拟机的方式

573
00:25:34,000 --> 00:25:35,000
才能实现

574
00:25:35,000 --> 00:25:39,000
哪怕一个 gast kernel 的被被攻陷之后

575
00:25:39,000 --> 00:25:41,000
我的 host 还是相对来说安全的

576
00:25:41,000 --> 00:25:42,000
对不对

577
00:25:42,000 --> 00:25:44,000
OK 那么这里就会有一个自然而然的问题了

578
00:25:44,000 --> 00:25:45,000
就是说这样的话

579
00:25:45,000 --> 00:25:47,000
毕竟还是多了一个虚拟机

580
00:25:47,000 --> 00:25:49,000
多了一个内核层面的在跑

581
00:25:49,000 --> 00:25:52,000
那么它的这个相对于这种 docker 本身

582
00:25:52,000 --> 00:25:55,000
没有一个它是一个共享内核的情况

583
00:25:55,000 --> 00:25:58,000
它的这个额外的开销会是怎么样的一个情况

584
00:25:58,000 --> 00:26:02,000
对所以这个也就是我们之前一直在关注的一个点

585
00:26:02,000 --> 00:26:03,000
就是它的性能问题

586
00:26:03,000 --> 00:26:04,000
性能问题的话

587
00:26:04,000 --> 00:26:06,000
就是我们做了很多测试

588
00:26:06,000 --> 00:26:11,000
其实我们并没有说更改

589
00:26:11,000 --> 00:26:15,000
或者说修改 hypervisor 的代码

590
00:26:15,000 --> 00:26:18,000
然后让它达到一个非常非常优化的一个

591
00:26:18,000 --> 00:26:22,000
但是我们目前还是希望能够用更加通用的手段

592
00:26:22,000 --> 00:26:24,000
来解决用户的问题

593
00:26:24,000 --> 00:26:31,000
然后就刚才说的一个启动一个 container 的所给动时间

594
00:26:31,000 --> 00:26:33,000
大概在 300 毫秒

595
00:26:33,000 --> 00:26:36,000
就是这个跟 docker 相比

596
00:26:36,000 --> 00:26:39,000
基本上没差太多

597
00:26:39,000 --> 00:26:42,000
然后性能上面这是这点

598
00:26:42,000 --> 00:26:46,000
然后另外就是 cpu 给用户上面基本相似

599
00:26:46,000 --> 00:26:49,000
可能很大的一个问题

600
00:26:49,000 --> 00:26:54,000
就是在网络 io 以及 storage 的 io 上面

601
00:26:54,000 --> 00:26:58,000
可能会有会受限于 hypervisor 它的性能

602
00:26:58,000 --> 00:27:02,000
因为你像 9 P 或者是像直接的宝刀 device

603
00:27:02,000 --> 00:27:05,000
它都毕竟要经过多层的传递

604
00:27:05,000 --> 00:27:08,000
然后可能会达不到很好的效果

605
00:27:08,000 --> 00:27:12,000
但是我们其实目前也在解决这个问题

606
00:27:12,000 --> 00:27:18,000
因为 bogov device 它其实还是传的 storage 的协议

607
00:27:18,000 --> 00:27:19,000
比如 scars 协议

608
00:27:19,000 --> 00:27:22,000
直接 scars 协议怎么能够传递

609
00:27:22,000 --> 00:27:26,000
或者怎么能够更减少它的矿业的层次

610
00:27:26,000 --> 00:27:29,000
就是一些可能 bypass 的技术

611
00:27:29,000 --> 00:27:30,000
OK

612
00:27:30,000 --> 00:27:31,000
所以总结一下

613
00:27:31,000 --> 00:27:32,000
就是因为

614
00:27:32,000 --> 00:27:35,000
这个 hyper 还是一个基于虚拟机的一个技术

615
00:27:35,000 --> 00:27:37,000
所以传统的虚拟机的一些缺陷

616
00:27:37,000 --> 00:27:40,000
可能还是起码在现阶段还是免不了的

617
00:27:40,000 --> 00:27:42,000
刚才提到了几个问题

618
00:27:42,000 --> 00:27:44,000
就是说它可能

619
00:27:44,000 --> 00:27:47,000
我们现在现代 cpu

620
00:27:47,000 --> 00:27:49,000
像英特尔的一些服务器的 cpu

621
00:27:49,000 --> 00:27:52,000
它对硬件虚拟化的一些支持是非常好的

622
00:27:52,000 --> 00:27:55,000
所以在运算这一块的损耗

623
00:27:55,000 --> 00:27:57,000
其实几乎可以忽略不计

624
00:27:57,000 --> 00:27:58,000
我觉得

625
00:27:58,000 --> 00:28:00,000
然后但是像 io 层面

626
00:28:00,000 --> 00:28:02,000
因为它还是需要依赖的

627
00:28:02,000 --> 00:28:05,000
它是有限于硬件的支持和内核的支持

628
00:28:05,000 --> 00:28:08,000
可能还做不到说一个比较好的状态

629
00:28:08,000 --> 00:28:10,000
那么我可以大概问一下

630
00:28:10,000 --> 00:28:11,000
就直观来讲

631
00:28:11,000 --> 00:28:13,000
比如说我网络

632
00:28:13,000 --> 00:28:18,000
我 1 GB 的物理网卡的这么一个吞吐量

633
00:28:18,000 --> 00:28:21,000
传到 hyper 虚拟机里面之后

634
00:28:21,000 --> 00:28:23,000
大概会损耗到多少

635
00:28:23,000 --> 00:28:27,000
我们之前确实是做过调查

636
00:28:27,000 --> 00:28:30,000
但是我现在手头没有这种资料

637
00:28:30,000 --> 00:28:31,000
OK

638
00:28:31,000 --> 00:28:33,000
这个是就是说你刚才提到最主要问题

639
00:28:33,000 --> 00:28:35,000
就是 io 的损耗是这一块了

640
00:28:35,000 --> 00:28:36,000
对对对

641
00:28:36,000 --> 00:28:37,000
特别好奇

642
00:28:37,000 --> 00:28:38,000
但如果说如果你有资料的话

643
00:28:38,000 --> 00:28:40,000
我们可以补到这个 show notes 里面

644
00:28:40,000 --> 00:28:41,000
对

645
00:28:41,000 --> 00:28:43,000
然后就是这个在我们的官网上

646
00:28:43,000 --> 00:28:45,000
其实是有更详细的资料的

647
00:28:45,000 --> 00:28:46,000
然后 OK

648
00:28:46,000 --> 00:28:48,000
对因为这个这部分我没有参与测试

649
00:28:48,000 --> 00:28:51,000
所以具体细节不是特别清楚

650
00:28:51,000 --> 00:28:52,000
OK

651
00:28:52,000 --> 00:28:53,000
没问题

652
00:28:53,000 --> 00:28:55,000
所以这个也说到这个 io 这一块

653
00:28:55,000 --> 00:28:57,000
所以我顺便插发问一句

654
00:28:57,000 --> 00:28:59,000
刚才你也提到有些叫做就是能够绕过

655
00:28:59,000 --> 00:29:01,000
因为 io 最麻烦的问题是这个

656
00:29:01,000 --> 00:29:05,000
因为是虚拟就是叫 guestOS 和 hostOS

657
00:29:05,000 --> 00:29:07,000
它是要互相复制数据的

658
00:29:07,000 --> 00:29:08,000
对对

659
00:29:08,000 --> 00:29:11,000
这个是导致性能损耗最主要的一个原因

660
00:29:11,000 --> 00:29:14,000
那么你刚才也提到一些就是 bypass

661
00:29:14,000 --> 00:29:17,000
就是能够绕过复制的一些机制

662
00:29:17,000 --> 00:29:20,000
可以大概介绍一下你们目前在考虑的

663
00:29:20,000 --> 00:29:23,000
或者说以后可能会采用的一些方法是什么

664
00:29:23,000 --> 00:29:26,000
其实我们目前已经采用过

665
00:29:26,000 --> 00:29:29,000
WaterIO night 的一个模块

666
00:29:29,000 --> 00:29:30,000
然后它其实

667
00:29:30,000 --> 00:29:35,000
它其实就是将网络的 io bypass

668
00:29:35,000 --> 00:29:41,000
相当于跨过了 HyperVisor 底层的一个数据传输

669
00:29:41,000 --> 00:29:46,000
但是 hostOS 它的一个 TZIP 写协议站是没办法跨越的

670
00:29:46,000 --> 00:29:52,000
所以这个技术应该是跨越了 HyperVisor 的一个 TZIP 协议站

671
00:29:52,000 --> 00:29:54,000
它就是减少了它的层数

672
00:29:54,000 --> 00:29:59,000
然后另外其实我们也在基于 block device 去做一些

673
00:29:59,000 --> 00:30:02,000
操作因为 block device 的话

674
00:30:02,000 --> 00:30:11,000
它毕竟还是 Core 设备的传输更偏向于它的 IO 协议本身

675
00:30:11,000 --> 00:30:19,000
所以这样的话能够比文件系统级的优化效果会更好

676
00:30:19,000 --> 00:30:22,000
我们也在关注这些点

677
00:30:22,000 --> 00:30:23,000
OK

678
00:30:23,000 --> 00:30:25,000
刚才你提到两个用力

679
00:30:25,000 --> 00:30:28,000
一个就是对于一个经典的网络层的传输的优化

680
00:30:28,000 --> 00:30:29,000
还有一个是什么呢?

681
00:30:29,000 --> 00:30:33,000
就是对于文件系统存储层的优化

682
00:30:33,000 --> 00:30:37,000
我们提一个就是就着刚才网络层的情况来讲

683
00:30:37,000 --> 00:30:42,000
因为大家可能最常用的还是用来部署一个基于 web 的一个 server

684
00:30:42,000 --> 00:30:44,000
或者服务器之类的应用

685
00:30:44,000 --> 00:30:45,000
所以举一个例子

686
00:30:45,000 --> 00:30:48,000
比如说在一个经典的 Hyper 的部署情况下

687
00:30:48,000 --> 00:30:52,000
就是说底下有个 hostOS 上面跑一个假设 KVM

688
00:30:52,000 --> 00:30:57,000
然后 Hyper 在管理一个 VM 里面再跑一个 DockerImage 的这种情况下

689
00:30:57,000 --> 00:30:58,000
一个数据包

690
00:30:58,000 --> 00:31:06,000
从最里面的假设是一个 Nginx 的服务器里面传出来

691
00:31:06,000 --> 00:31:10,000
一直传到 hostOS 硬件的网卡之间

692
00:31:10,000 --> 00:31:13,000
大概需要经过哪些步骤可以给我描述一下吗?

693
00:31:13,000 --> 00:31:16,000
目前的话咱们先说正常的话

694
00:31:16,000 --> 00:31:21,000
它肯定是经过 Hypervisor 的 TDIP 协议站

695
00:31:21,000 --> 00:31:25,000
然后经过 Hypervisor 它的一个

696
00:31:25,000 --> 00:31:27,000
但是这个就要分

697
00:31:27,000 --> 00:31:32,000
它是硬件模拟还是全虚拟化还是半虚拟化

698
00:31:32,000 --> 00:31:36,000
这个的话就涉及到 QMule 的一些知识

699
00:31:36,000 --> 00:31:38,000
因为 QMule 的话

700
00:31:38,000 --> 00:31:41,000
如果是 QMule 全虚拟化的话

701
00:31:41,000 --> 00:31:45,000
它就是相当于完全硬件虚拟化

702
00:31:45,000 --> 00:31:48,000
网卡都是虚拟出来的

703
00:31:48,000 --> 00:31:54,000
所以它走的路是跟 hostOS 是完全一致的

704
00:31:54,000 --> 00:31:55,000
大家也可以查一下资料

705
00:31:55,000 --> 00:31:56,000
就可能走 TDIP 协议站

706
00:31:57,000 --> 00:32:01,000
然后再走 NIC 的 driver

707
00:32:01,000 --> 00:32:05,000
然后再往下走 Foamware 这些东西

708
00:32:05,000 --> 00:32:09,000
然后如果要是半虚拟化的话

709
00:32:09,000 --> 00:32:12,000
它就可以用 WattIO

710
00:32:12,000 --> 00:32:13,000
NATWattIO

711
00:32:13,000 --> 00:32:17,000
反正就是相当于 Network 可能 Bypass 的一个技术

712
00:32:17,000 --> 00:32:21,000
就是将 Hypervisor 里面的网络包的数据

713
00:32:21,000 --> 00:32:23,000
直接给到 NIC 的 driver

714
00:32:23,000 --> 00:32:25,000
然后用 NIC 调一些 AutoCAD

715
00:32:25,000 --> 00:32:26,000
然后调一些 AutoCAD 的数据

716
00:32:27,000 --> 00:32:29,000
然后就会有一个命令

717
00:32:29,000 --> 00:32:32,000
让 IOS 包直接发送出去

718
00:32:32,000 --> 00:32:34,000
然后交给 heistOS

719
00:32:34,000 --> 00:32:36,000
它其实在这个过程中

720
00:32:36,000 --> 00:32:38,000
如果我没记错的话

721
00:32:38,000 --> 00:32:44,000
应该是 Hypervisor 里面的 NIC 的一个虚拟地址

722
00:32:44,000 --> 00:32:50,000
其实是和 hostOS 里面的网卡的地址

723
00:32:50,000 --> 00:32:52,000
其实映射到一起

724
00:32:52,000 --> 00:32:55,000
这样的话能够缩减很多层

725
00:32:55,000 --> 00:32:56,000
就不用复制那么多次了吗?

726
00:32:56,000 --> 00:32:57,000
对

727
00:32:57,000 --> 00:32:59,000
其实在网络传输过程中

728
00:32:59,000 --> 00:33:03,000
用户差和内核差之间的网络包的复制过程

729
00:33:03,000 --> 00:33:05,000
还是比较耗时的

730
00:33:05,000 --> 00:33:06,000
对

731
00:33:06,000 --> 00:33:09,000
然后另外一个就是它的

732
00:33:09,000 --> 00:33:12,000
相当于用户差和内核差一个切换过程

733
00:33:12,000 --> 00:33:15,000
但是这个的话其实没有特别好的办法

734
00:33:15,000 --> 00:33:17,000
因为你要保证实时性

735
00:33:17,000 --> 00:33:19,000
要保证能够

736
00:33:19,000 --> 00:33:22,000
它的能把这些包全都传送出去

737
00:33:22,000 --> 00:33:25,000
所以必须用一些机制来触发

738
00:33:25,000 --> 00:33:29,000
所以可能用 LTO 或者是用其他方式去触发吧

739
00:33:29,000 --> 00:33:33,000
但是这个东西我们目前也是用过现有的机制

740
00:33:33,000 --> 00:33:35,000
没有特别

741
00:33:35,000 --> 00:33:40,000
目前还没有设计这方面的动作

742
00:33:40,000 --> 00:33:42,000
OK 明白

743
00:33:42,000 --> 00:33:45,000
接着 Hyper 那套工具讲

744
00:33:45,000 --> 00:33:50,000
你也提到了 Hyper 它会提供一个非常轻量级的 GhastOS 的 VM

745
00:33:50,000 --> 00:33:53,000
在那里去运行里面的 Docker Image

746
00:33:53,000 --> 00:33:56,000
这件事情就可能要跟现有的一些其他的

747
00:33:56,000 --> 00:33:59,000
想做同类事情的工具相比了

748
00:33:59,000 --> 00:34:02,000
比如说比较著名的现在也比较火的

749
00:34:02,000 --> 00:34:05,000
像 CoreOS 还有像一个上次

750
00:34:05,000 --> 00:34:07,000
好像英特尔也出了一个吧

751
00:34:07,000 --> 00:34:13,000
是专门跑 Docker Image 的这么一个极度精简的 Linux 的 OS

752
00:34:13,000 --> 00:34:17,000
相比起来你们比它们的区别在哪里

753
00:34:17,000 --> 00:34:19,000
就是精简了什么东西

754
00:34:19,000 --> 00:34:20,000
是这样的

755
00:34:20,000 --> 00:34:22,000
英特尔出的那个叫 Kogelk-Ingels

756
00:34:22,000 --> 00:34:27,000
它的出现对我们来说还是卓为很震惊的

757
00:34:27,000 --> 00:34:31,000
但是其实也是验证了我们的方向是正确的

758
00:34:31,000 --> 00:34:34,000
因为大厂都跟进这件事情了

759
00:34:34,000 --> 00:34:39,000
所以我们既兴奋又担心还有点惊讶

760
00:34:39,000 --> 00:34:47,000
然后它和 CoreOS 其实应该是属于类似的东西

761
00:34:47,000 --> 00:34:49,000
但是它们的目的可能不太一样

762
00:34:49,000 --> 00:34:50,000
就是我们自己的分析

763
00:34:50,000 --> 00:34:51,000
OK

764
00:34:51,000 --> 00:34:58,000
Kogelk-Ingels 它其实是为了验证英特尔的硬件

765
00:34:58,000 --> 00:35:02,000
因为英特尔它虽然说是开源技术中心做出来的

766
00:35:02,000 --> 00:35:07,000
但也不能说一帮人没什么意义去做这个东西

767
00:35:07,000 --> 00:35:13,000
我们分析它应该是为了体现它们的硬件足够的快

768
00:35:13,000 --> 00:35:19,000
可以达到启动一个 Linux 的 Gas OS 能够非常非常快

769
00:35:19,000 --> 00:35:20,000
其实好秒机的

770
00:35:20,000 --> 00:35:21,000
OK

771
00:35:21,000 --> 00:35:27,000
然后当然也有很多人基于这个东西去做了很多的

772
00:35:27,000 --> 00:35:29,000
因为 Docker 目前的形势非常火

773
00:35:29,000 --> 00:35:34,000
所以很多人基于 Conclusion Linux 去做了一些贡献吧

774
00:35:34,000 --> 00:35:37,000
然后把它改造了一下

775
00:35:37,000 --> 00:35:40,000
之前还有一个 PR 专门给 Docker 的

776
00:35:40,000 --> 00:35:43,000
相当于 Docker 的 upstream

777
00:35:43,000 --> 00:35:45,000
然后去提了一个 PR

778
00:35:45,000 --> 00:35:50,000
就是希望能够用 Conclusion Linux 来运行

779
00:35:50,000 --> 00:35:52,000
Docker 的 image

780
00:35:52,000 --> 00:35:55,000
但是这个没有被接受

781
00:35:55,000 --> 00:35:59,000
因为可能觉得做的不太好吧

782
00:35:59,000 --> 00:36:06,000
或者说它的性能或者说整体的一个运动方式跟 Docker 的不太一样

783
00:36:06,000 --> 00:36:12,000
所以我们也关注它很长时间

784
00:36:12,000 --> 00:36:14,000
它目前也在不断的维护

785
00:36:14,000 --> 00:36:18,000
然后它跟 CoreOS

786
00:36:18,000 --> 00:36:20,000
就提到 CoreOS

787
00:36:20,000 --> 00:36:22,000
CoreOS 其实它是在 CoreOS 里面

788
00:36:22,000 --> 00:36:25,000
它给你做了足够多的配置

789
00:36:25,000 --> 00:36:28,000
然后让你直接去运行一个 Docker 的 Demon

790
00:36:28,000 --> 00:36:30,000
或者说 Docker 的 Container

791
00:36:30,000 --> 00:36:32,000
然后你直接

792
00:36:32,000 --> 00:36:38,000
CoreOS 是不可以装在一个 BioMental 的一个机器上面

793
00:36:38,000 --> 00:36:40,000
而 CoreOS 是可以的

794
00:36:40,000 --> 00:36:42,000
它可以装在那个 BioMental 的机器上

795
00:36:42,000 --> 00:36:44,000
然后这样的话配置到一个机房

796
00:36:44,000 --> 00:36:46,000
就可以运行

797
00:36:46,000 --> 00:36:47,000
就可以直接

798
00:36:47,000 --> 00:36:48,000
你装一个 OS

799
00:36:48,000 --> 00:36:50,000
你可以直接运行 Docker 的 Demon

800
00:36:50,000 --> 00:36:52,000
Docker 的任何命令你都可以去直接运行

801
00:36:52,000 --> 00:36:54,000
而且它可以优化了

802
00:36:54,000 --> 00:36:57,000
所以它可能的场景不太一样

803
00:36:57,000 --> 00:37:00,000
所以说我们的 Hyper 其实跟他们

804
00:37:00,000 --> 00:37:03,000
其实不是特别一样

805
00:37:03,000 --> 00:37:06,000
因为我们其实虽然说也提供一个 GasOS

806
00:37:06,000 --> 00:37:08,000
但是我们这用的 GasOS

807
00:37:08,000 --> 00:37:12,000
它其实是为了在 VM 里面

808
00:37:12,000 --> 00:37:15,000
跟外边的 HyperDemon 去配合

809
00:37:15,000 --> 00:37:17,000
然后去运行

810
00:37:17,000 --> 00:37:18,000
Docker 的 Image

811
00:37:18,000 --> 00:37:21,000
其实我们是一个整套的环境

812
00:37:21,000 --> 00:37:27,000
其实就是跟 Docker 平行的另外一套的环境

813
00:37:27,000 --> 00:37:29,000
所以如果我这样理解

814
00:37:29,000 --> 00:37:30,000
没错的话

815
00:37:30,000 --> 00:37:33,000
CoreOS 和 Intel 出的 Clear Linux

816
00:37:33,000 --> 00:37:35,000
他们还是依赖于 DockerDemon 本身

817
00:37:35,000 --> 00:37:36,000
是的

818
00:37:36,000 --> 00:37:38,000
而 Hyper 是可以完全替代它

819
00:37:38,000 --> 00:37:39,000
对

820
00:37:39,000 --> 00:37:41,000
所以其实从我个人角度来讲

821
00:37:41,000 --> 00:37:44,000
肯定是少一层比多一层

822
00:37:44,000 --> 00:37:45,000
简单

823
00:37:45,000 --> 00:37:46,000
对

824
00:37:46,000 --> 00:37:48,000
这个也是看大家应用场景吧

825
00:37:48,000 --> 00:37:50,000
可能关注点不太一样

826
00:37:50,000 --> 00:37:55,000
但是也不能太推销我们的东西

827
00:37:55,000 --> 00:37:56,000
没错

828
00:37:56,000 --> 00:37:59,000
这里就提到应用场景这个非常重要

829
00:37:59,000 --> 00:38:02,000
所以在你们的定位里面

830
00:38:02,000 --> 00:38:07,000
是在什么场景下适用用 Hyper 会比较好

831
00:38:07,000 --> 00:38:09,000
其实我们是希望

832
00:38:09,000 --> 00:38:14,000
我们做 Hyper 这个目的是希望

833
00:38:14,000 --> 00:38:24,000
有想法用 Docker 构建一个公有云的一个场上

834
00:38:24,000 --> 00:38:27,000
当然可能目前已经有了

835
00:38:27,000 --> 00:38:31,000
比如 Docker.io

836
00:38:31,000 --> 00:38:40,000
他们其实就是声称是用 Docker 去构建的一个公有云

837
00:38:40,000 --> 00:38:44,000
但是我不确定他们内部是怎么搭建的

838
00:38:44,000 --> 00:38:46,000
我们还是想来保证用户的安全性

839
00:38:46,000 --> 00:38:47,000
OK

840
00:38:47,000 --> 00:38:49,000
这个涉及到刚才我们讲的那个问题了

841
00:38:49,000 --> 00:38:51,000
如果说因为你没有内核隔离的话

842
00:38:51,000 --> 00:38:56,000
其实是 Docker 本身的 container 隔离是无法保证安全性的

843
00:38:56,000 --> 00:38:57,000
对

844
00:38:57,000 --> 00:38:58,000
然后如果你跑的是一个公有云

845
00:38:58,000 --> 00:39:01,000
就所谓公有云就是说你的两个客户之间

846
00:39:01,000 --> 00:39:04,000
可能不是一家或者一个人

847
00:39:04,000 --> 00:39:05,000
对

848
00:39:05,000 --> 00:39:11,000
然后你也没法保证你运行的应用的性质

849
00:39:11,000 --> 00:39:12,000
或者是它是不是一个恶意程序

850
00:39:12,000 --> 00:39:13,000
你是无法保证的

851
00:39:13,000 --> 00:39:14,000
对

852
00:39:14,000 --> 00:39:16,000
可能是公有云和私有云最大的区别了

853
00:39:16,000 --> 00:39:17,000
对

854
00:39:17,000 --> 00:39:20,000
所以这种情况下是必须采用 VM 隔离才可以实现

855
00:39:20,000 --> 00:39:22,000
我们可以接受的安全性

856
00:39:22,000 --> 00:39:23,000
对

857
00:39:23,000 --> 00:39:26,000
因为目前就我们所知一般的公有云厂商

858
00:39:26,000 --> 00:39:28,000
一般都是用这种方式

859
00:39:28,000 --> 00:39:34,000
就是底层还是用 Hypervisor 去或者 VM 去做隔离

860
00:39:34,000 --> 00:39:35,000
对

861
00:39:35,000 --> 00:39:39,000
然后可能没有用容器直接去做隔离

862
00:39:39,000 --> 00:39:41,000
不太靠谱吧

863
00:39:41,000 --> 00:39:42,000
对

864
00:39:42,000 --> 00:39:49,000
所以 Hyper 的一个主要应用场景就是说给那些有志于提供公有云的厂商

865
00:39:49,000 --> 00:39:56,000
这么一套基础的工具使得他们可以比较快速的启动或者是关闭一个虚拟机

866
00:39:56,000 --> 00:39:58,000
然后这个虚拟机上是可以

867
00:39:58,000 --> 00:40:03,000
但是它面向就暴露给用户的它确实一个叫什么来的

868
00:40:03,000 --> 00:40:06,000
是类似 container 那种的 API 对吧

869
00:40:06,000 --> 00:40:07,000
对

870
00:40:07,000 --> 00:40:08,000
OK

871
00:40:08,000 --> 00:40:10,000
所以这个就是牵涉到另外一个问题了就是说

872
00:40:10,000 --> 00:40:13,000
因为我们现在大部分的像 Linode 也好

873
00:40:13,000 --> 00:40:14,000
AWS 也好

874
00:40:14,000 --> 00:40:17,000
还有现在比较火的 Digital Cloud 也好

875
00:40:17,000 --> 00:40:20,000
他们都是采用传统的虚拟机这种方式

876
00:40:20,000 --> 00:40:22,000
暴露出传统虚拟机这么一个单元

877
00:40:22,000 --> 00:40:28,000
然后由用户再去管理其中的这个是否跑 Docker

878
00:40:28,000 --> 00:40:31,000
是否跑什么 GuestOS 的事情

879
00:40:31,000 --> 00:40:36,000
那么刚才我们讲的你直接暴露给用户一套基于 container 的 API 的好处

880
00:40:36,000 --> 00:40:40,000
相比于现在暴露给用户一个基于 VM 的 API 的好处是什么呢

881
00:40:40,000 --> 00:40:48,000
其实我觉得还是另外从一个应用场景上面来分析吧

882
00:40:48,000 --> 00:40:57,000
如果要是比如说用户他想他已经在本地

883
00:40:57,000 --> 00:40:59,000
他一个开发环境

884
00:40:59,000 --> 00:41:03,000
他本地的话他可以配置任何 Docker 的一个 image

885
00:41:03,000 --> 00:41:08,000
然后去上传到自己的 private 或者是 pubg 的一个 hub 上面

886
00:41:08,000 --> 00:41:09,000
然后

887
00:41:10,000 --> 00:41:11,000
他再去运行

888
00:41:11,000 --> 00:41:16,000
然后如果他要是像直接拿到一个 VM 的一个环境的话

889
00:41:16,000 --> 00:41:18,000
那他完全他要在自己搭 Docker

890
00:41:18,000 --> 00:41:23,000
然后在里面去直接的部署下来再下来再去运行

891
00:41:23,000 --> 00:41:24,000
或者是对

892
00:41:24,000 --> 00:41:30,000
然后但是我们这种方式你直接可以将你的 Docker 的 image 直接下载下来

893
00:41:30,000 --> 00:41:35,000
你只要填一些你所想要的东西直接全都给你部署在后端了

894
00:41:35,000 --> 00:41:37,000
就是不需要你去做任何的配置

895
00:41:37,000 --> 00:41:39,000
你只要填

896
00:41:39,000 --> 00:41:44,000
我们这里有一个叫 json 就是输入文件就是 json file

897
00:41:44,000 --> 00:41:48,000
json file 里面可以定义你的所有的上面运行的东西

898
00:41:48,000 --> 00:41:52,000
比如 contender 运用 contender 从哪运行从哪下载

899
00:41:52,000 --> 00:41:56,000
然后以及 port 那端口影射

900
00:41:56,000 --> 00:42:01,000
然后以及 sourage 等等你都可以去自己去配置

901
00:42:01,000 --> 00:42:05,000
然后所以就是简化用户的操作我觉得

902
00:42:05,000 --> 00:42:06,000
OK

903
00:42:06,000 --> 00:42:09,000
所以这个其实还是其实挺切中我的

904
00:42:09,000 --> 00:42:11,000
这个个人的一个痛点

905
00:42:11,000 --> 00:42:14,000
比如说我自己在运营着这个 ipn 的这个服务

906
00:42:14,000 --> 00:42:17,000
还有一些帮朋友管的一些其他的一些服务

907
00:42:17,000 --> 00:42:22,000
然后他们就是每次要新增一个服务或者是特别是新增的时候会有一个问题

908
00:42:22,000 --> 00:42:26,000
就是说给我的这个虚拟机新开的一个虚拟机是空白的

909
00:42:26,000 --> 00:42:30,000
我要重新打一套比如说建管理对应的这个账号对吧

910
00:42:30,000 --> 00:42:33,000
对应的这个要安装对应的软件

911
00:42:33,000 --> 00:42:37,000
但这个可能有一部分是可以通过 Docker 本那个 image 本身打包来实现的

912
00:42:37,000 --> 00:42:38,000
但是刚才你提到一个很重要的点就是 Docker 本身的这个项目是可以用 Docker 来实现的

913
00:42:38,000 --> 00:42:39,000
但是刚才你提到一个很重要的点就是 Docker 本身打包来实现的

914
00:42:39,000 --> 00:42:40,000
但是刚才你提到一个很重要的点就是

915
00:42:40,000 --> 00:42:43,000
Docker 这个 Demon 这个守护机能本身还是需要配置和安装的对对对

916
00:42:43,000 --> 00:42:43,000
Docker 这个 Demon 这个守护机能本身还是需要配置和安装的对对对

917
00:42:43,000 --> 00:42:47,000
所以其实我觉得还是一个就是抽象诚质诚次的

918
00:42:47,000 --> 00:42:52,000
一个飞跃吧你们其实是通过 Hiper 这套基于 container 的 API

919
00:42:52,000 --> 00:43:01,000
同时再加上这个 VM 的安全性使得我们不用再去操心我当边这个 container

920
00:43:01,000 --> 00:43:05,000
其实我是可以在逻辑上按照 container 来做这个部署了

921
00:43:05,000 --> 00:43:09,000
只是说我不用再操心像传统 Docker 这种 container 之间无法多

922
00:43:09,000 --> 00:43:12,000
内核极隔离的不安全的隐患

923
00:43:12,000 --> 00:43:12,000
对

924
00:43:12,000 --> 00:43:13,000
没错

925
00:43:13,000 --> 00:43:14,000
对

926
00:43:14,000 --> 00:43:16,000
对

927
00:43:16,000 --> 00:43:17,000
然后我们下面就要进入到一个

928
00:43:17,000 --> 00:43:19,000
很关键的一个问题的讨论

929
00:43:19,000 --> 00:43:20,000
就是说因为基于

930
00:43:20,000 --> 00:43:22,000
因为 Docker 其实本身

931
00:43:22,000 --> 00:43:23,000
我觉得到目前为止

932
00:43:23,000 --> 00:43:25,000
也并没有很好的解决这个问题

933
00:43:25,000 --> 00:43:27,000
就是存储空间的问题

934
00:43:27,000 --> 00:43:29,000
因为过去的话

935
00:43:29,000 --> 00:43:30,000
就照我的理解

936
00:43:30,000 --> 00:43:31,000
它 Docker 的

937
00:43:31,000 --> 00:43:32,000
因为它是提倡的

938
00:43:32,000 --> 00:43:34,000
叫做应用是

939
00:43:34,000 --> 00:43:36,000
那个 image container 是不可变的

940
00:43:36,000 --> 00:43:37,000
就 immutable 的 container

941
00:43:37,000 --> 00:43:40,000
那么比如说你作为一个应用层

942
00:43:40,000 --> 00:43:41,000
应用服务器本身

943
00:43:41,000 --> 00:43:42,000
可能这个倒也没什么

944
00:43:42,000 --> 00:43:44,000
你多起几个应用

945
00:43:44,000 --> 00:43:46,000
就可以提高你的这个并发数

946
00:43:46,000 --> 00:43:47,000
那当然是好的

947
00:43:47,000 --> 00:43:51,000
但是我们做大部分的这个网站也好

948
00:43:51,000 --> 00:43:52,000
还是这个什么服务也好

949
00:43:52,000 --> 00:43:55,000
它还是必须要考虑这个数据持久化的问题

950
00:43:55,000 --> 00:43:55,000
就是说这个

951
00:43:55,000 --> 00:43:58,000
你从这个客户那里拿到了这个数据

952
00:43:58,000 --> 00:43:59,000
那你存到哪里

953
00:43:59,000 --> 00:44:02,000
过去 Docker 的一个提倡的一个概念

954
00:44:02,000 --> 00:44:02,000
就是说

955
00:44:02,000 --> 00:44:04,000
那你再建一个

956
00:44:04,000 --> 00:44:07,000
就单纯拿来做这个存储的一个 image

957
00:44:07,000 --> 00:44:08,000
来做这件事情

958
00:44:08,000 --> 00:44:10,000
所以我不知道这件事情

959
00:44:10,000 --> 00:44:12,000
在 Hyper 里面是一个什么样的

960
00:44:12,000 --> 00:44:13,000
一个值得

961
00:44:13,000 --> 00:44:15,000
就是什么样的做法是值得鼓励的

962
00:44:15,000 --> 00:44:23,000
我们目前是有一个单独的 volume 的一个模块

963
00:44:23,000 --> 00:44:24,000
然后它是

964
00:44:24,000 --> 00:44:27,000
你可以在针对某个 container

965
00:44:27,000 --> 00:44:31,000
或者说针对几个 container 去配置

966
00:44:31,000 --> 00:44:35,000
然后你可以自己添加

967
00:44:35,000 --> 00:44:37,000
你想加入的 volume

968
00:44:37,000 --> 00:44:41,000
这个 volume 既可以是文件或者是目录

969
00:44:41,000 --> 00:44:44,000
然后也可以是 blog device

970
00:44:44,000 --> 00:44:47,000
blog device 就是支持非常多的形式

971
00:44:47,000 --> 00:44:48,000
或者就是

972
00:44:48,000 --> 00:44:51,000
然后用户可以自由配置

973
00:44:51,000 --> 00:44:54,000
然后你可以把这个多大多少

974
00:44:54,000 --> 00:44:55,000
你都可以自己配置

975
00:44:55,000 --> 00:44:58,000
然后指定给哪个用户都可以自己配置

976
00:44:58,000 --> 00:44:58,000
然后这样的话

977
00:44:58,000 --> 00:45:01,000
你加入到一个 container 里面

978
00:45:01,000 --> 00:45:03,000
你可能是运行的时候

979
00:45:03,000 --> 00:45:05,000
你可以指定我将数据存到

980
00:45:05,000 --> 00:45:06,000
这个

981
00:45:06,000 --> 00:45:07,000
这个

982
00:45:07,000 --> 00:45:12,000
Blog device 或者说是目录里面

983
00:45:12,000 --> 00:45:13,000
这样的话

984
00:45:13,000 --> 00:45:19,000
目前我们是支持本地的以及加 Safe

985
00:45:19,000 --> 00:45:21,000
或者说你用 SR 自己

986
00:45:21,000 --> 00:45:24,000
当然也可能配直接配 storage

987
00:45:24,000 --> 00:45:25,000
srv 都可以

988
00:45:25,000 --> 00:45:26,000
OK

989
00:45:26,000 --> 00:45:30,000
所以我理解一下大概的一个做法

990
00:45:30,000 --> 00:45:32,000
就是说我把

991
00:45:32,000 --> 00:45:37,000
就是 hyper 它会允许我虚拟出一块 Blog device

992
00:45:37,000 --> 00:45:39,000
就是一个快存储器

993
00:45:39,000 --> 00:45:40,000
然后这个快存储器

994
00:45:40,000 --> 00:45:44,000
我可以直接挂载进我的某一个 hyper 的虚拟机里面

995
00:45:44,000 --> 00:45:46,000
成为一个文件系统也好

996
00:45:46,000 --> 00:45:47,000
一个什么目录也好

997
00:45:47,000 --> 00:45:48,000
然后

998
00:45:48,000 --> 00:45:52,000
使得但这样的话就是 hyper 虚拟机里面本身跑的应用

999
00:45:52,000 --> 00:45:55,000
它还是一个 immutable 就是不可变

1000
00:45:55,000 --> 00:46:01,000
它的写入的数据是通过刚才挂载进去的 block device 持久化到其他地方

1001
00:46:01,000 --> 00:46:01,000
对吧

1002
00:46:01,000 --> 00:46:02,000
对

1003
00:46:02,000 --> 00:46:07,000
然后持久化是要么你可以在本机就是同一台 host 机器上执行

1004
00:46:07,000 --> 00:46:12,000
或者是通过这个 IceGhost 这种网络的存储的协议

1005
00:46:12,000 --> 00:46:14,000
写到另外一台这个一个文件

1006
00:46:14,000 --> 00:46:15,000
比如说一个文件服务器上

1007
00:46:15,000 --> 00:46:16,000
对

1008
00:46:16,000 --> 00:46:16,000
没错

1009
00:46:16,000 --> 00:46:17,000
是这样

1010
00:46:17,000 --> 00:46:18,000
OK

1011
00:46:18,000 --> 00:46:21,000
所以那这里就牵涉到一个效率的问题了

1012
00:46:21,000 --> 00:46:23,000
刚才我们也在前面也提到了

1013
00:46:23,000 --> 00:46:23,000
就是说

1014
00:46:23,000 --> 00:46:25,000
通过这种方式挂载进去

1015
00:46:25,000 --> 00:46:30,000
的这个就是 diskio 的这个效率会有很大的这个损耗吗

1016
00:46:30,000 --> 00:46:30,000
还是说

1017
00:46:31,000 --> 00:46:32,000
什么样的情况

1018
00:46:32,000 --> 00:46:37,000
其实这个主要还是说 hypervisor 本身的

1019
00:46:37,000 --> 00:46:38,000
就是因为我们

1020
00:46:38,000 --> 00:46:40,000
如果你要是挂本机的

1021
00:46:40,000 --> 00:46:42,000
block device 的话

1022
00:46:42,000 --> 00:46:44,000
那么它其实还是涉及到一个

1023
00:46:45,000 --> 00:46:48,000
IO 命令的一个传递的一个转换

1024
00:46:48,000 --> 00:46:49,000
然后这个的话

1025
00:46:49,000 --> 00:46:51,000
消耗应该不大

1026
00:46:51,000 --> 00:46:53,000
但是如果你要是文件级别

1027
00:46:53,000 --> 00:46:54,000
就 mongool 的话

1028
00:46:54,000 --> 00:46:56,000
mongool 的话它其实是走的

1029
00:46:57,000 --> 00:47:00,000
它是通过 hypervisor 的 share 的

1030
00:47:00,000 --> 00:47:02,000
share file

1031
00:47:02,000 --> 00:47:05,000
来 share 或者 share directory 来做的

1032
00:47:05,000 --> 00:47:06,000
所以

1033
00:47:06,000 --> 00:47:07,000
这个过程呢

1034
00:47:07,000 --> 00:47:08,000
就我们之前测过

1035
00:47:08,000 --> 00:47:10,000
就是不管是 vmware

1036
00:47:10,000 --> 00:47:13,000
或者说 watchbox 或者是 cumule

1037
00:47:13,000 --> 00:47:14,000
它的

1038
00:47:14,000 --> 00:47:18,000
share 的 mongool 的性能都不是特别好

1039
00:47:18,000 --> 00:47:21,000
所以我们特别建议用那个 block device 级别的

1040
00:47:21,000 --> 00:47:21,000
去操作

1041
00:47:22,000 --> 00:47:22,000
另外

1042
00:47:22,000 --> 00:47:24,000
就像刚才另外一种方式

1043
00:47:24,000 --> 00:47:26,000
还有第三种方式

1044
00:47:26,000 --> 00:47:27,000
比如我要是

1045
00:47:27,000 --> 00:47:29,000
远端的或者说

1046
00:47:29,000 --> 00:47:30,000
sourcer server 的话

1047
00:47:30,000 --> 00:47:31,000
那这个的话

1048
00:47:31,000 --> 00:47:33,000
它因为可以是报告给

1049
00:47:34,000 --> 00:47:36,000
hypervisor 一个 block device

1050
00:47:36,000 --> 00:47:38,000
所以它这个的性能可能是

1051
00:47:39,000 --> 00:47:41,000
除了应该于 hypervisor block device 的支持

1052
00:47:42,000 --> 00:47:43,000
还有的话就是

1053
00:47:43,000 --> 00:47:44,000
这个

1054
00:47:45,000 --> 00:47:47,000
用的第三方工具的性能了

1055
00:47:48,000 --> 00:47:49,000
对所以

1056
00:47:49,000 --> 00:47:51,000
share 的 mongool 的话

1057
00:47:52,000 --> 00:47:52,000
这个

1058
00:47:52,000 --> 00:47:56,000
这确实是一个硬上没有特别好的办法

1059
00:47:56,000 --> 00:47:57,000
因为 hypervisor 本身

1060
00:47:58,000 --> 00:47:58,000
它

1061
00:47:58,000 --> 00:47:59,000
他们做的

1062
00:47:59,000 --> 00:48:00,000
也不太好

1063
00:48:00,000 --> 00:48:00,000
因为

1064
00:48:01,000 --> 00:48:01,000
它是想

1065
00:48:02,000 --> 00:48:02,000
达到

1066
00:48:03,000 --> 00:48:04,000
更加用户

1067
00:48:04,000 --> 00:48:05,000
就是说

1068
00:48:05,000 --> 00:48:07,000
普通用户级别的使用

1069
00:48:08,000 --> 00:48:09,000
而不是说

1070
00:48:09,000 --> 00:48:11,000
我用这个来做企业级或者说做

1071
00:48:12,000 --> 00:48:13,000
工业级的应用

1072
00:48:13,000 --> 00:48:14,000
不太一样

1073
00:48:14,000 --> 00:48:15,000
OK

1074
00:48:15,000 --> 00:48:17,000
所以那么就牵涉到一个问题了

1075
00:48:17,000 --> 00:48:19,000
就是说在实际大规模部署的时候

1076
00:48:20,000 --> 00:48:21,000
这种比如说类似于

1077
00:48:22,000 --> 00:48:24,000
Google 或者是 Amazon 这种级别的

1078
00:48:24,000 --> 00:48:28,000
用户他们一般会采用什么样的方式去部署

1079
00:48:28,000 --> 00:48:30,000
存储的这个方案呢

1080
00:48:33,000 --> 00:48:34,000
存储的方案呢

1081
00:48:35,000 --> 00:48:39,000
这我还真不确定他们怎么部署的

1082
00:48:39,000 --> 00:48:40,000
OK

1083
00:48:40,000 --> 00:48:40,000
没关系

1084
00:48:41,000 --> 00:48:47,000
那我们进入这个下一个话题啊就是说刚才也提到这个文件存储可能是效率上是一个硬上

1085
00:48:47,000 --> 00:48:47,000
这个

1086
00:48:48,000 --> 00:48:49,000
这个确实在

1087
00:48:49,000 --> 00:48:53,000
目前的技术条件下好像没有特别好的解决的方案

1088
00:48:53,000 --> 00:48:55,000
然后刚才之前我们也提到了这个网络

1089
00:48:56,000 --> 00:48:57,000
这块因为也涉及到 IO 嘛

1090
00:48:58,000 --> 00:48:59,000
也是一个比较尴尬的一个状态

1091
00:49:00,000 --> 00:49:02,000
这个其实这个都说的是在

1092
00:49:02,000 --> 00:49:05,000
刚才我们大家的假设的一个场景都是说在一个

1093
00:49:05,000 --> 00:49:07,000
Linux 的 hostOS 上跑

1094
00:49:08,000 --> 00:49:09,000
这个一个应用的场景

1095
00:49:10,000 --> 00:49:12,000
我现在就问一下如果在开发者在就是想

1096
00:49:13,000 --> 00:49:16,000
大家听众朋友们对这个 hyper 比较感兴趣他想去试一下

1097
00:49:16,000 --> 00:49:17,000
他在

1098
00:49:17,000 --> 00:49:18,000
哪些其他系统上可以

1099
00:49:19,000 --> 00:49:21,000
去玩这个 hyper 呢

1100
00:49:21,000 --> 00:49:21,000
因为我们是

1101
00:49:22,000 --> 00:49:25,000
像那个 Docker 他可以通过这个一些虚拟机的方式

1102
00:49:25,000 --> 00:49:27,000
在像 OS X 上也可以跑

1103
00:49:27,000 --> 00:49:28,000
Hyper 呢

1104
00:49:28,000 --> 00:49:29,000
Hyper

1105
00:49:30,000 --> 00:49:31,000
当然也支持 macOS

1106
00:49:32,000 --> 00:49:33,000
然后这个东西

1107
00:49:34,000 --> 00:49:35,000
这个

1108
00:49:35,000 --> 00:49:35,000
这个

1109
00:49:36,000 --> 00:49:39,000
Hyper 对于 macOS 的支持大概

1110
00:49:39,000 --> 00:49:40,000
是在这个月

1111
00:49:41,000 --> 00:49:41,000
应该是

1112
00:49:41,000 --> 00:49:43,000
这个月初完成的

1113
00:49:43,000 --> 00:49:45,000
然后我们也在不断的去完善

1114
00:49:45,000 --> 00:49:47,000
然后目前呢

1115
00:49:48,000 --> 00:49:51,000
那个在 macOS 上面

1116
00:49:51,000 --> 00:49:56,000
的 hyper 只能用 Waterbox 一种

1117
00:49:56,000 --> 00:49:57,000
Hyper-Az

1118
00:49:58,000 --> 00:49:59,000
然后如果你要是

1119
00:49:59,000 --> 00:50:03,000
在 Linux 上面那你可以用 QMU KVM

1120
00:50:04,000 --> 00:50:04,000
Zen

1121
00:50:05,000 --> 00:50:07,000
以及 Waterbox 都可以用

1122
00:50:07,000 --> 00:50:11,000
但是因为 macOS 上面

1123
00:50:11,000 --> 00:50:17,000
没有说 QMU KVM 或者说 Zen 的这些虚拟化工具

1124
00:50:18,000 --> 00:50:19,000
所以就没有特别好的办法

1125
00:50:20,000 --> 00:50:21,000
OK

1126
00:50:21,000 --> 00:50:23,000
因为 VirtualBox 的

1127
00:50:23,000 --> 00:50:23,000
其实

1128
00:50:24,000 --> 00:50:27,000
从他的稳定可靠性还有他的这个

1129
00:50:27,000 --> 00:50:28,000
性能来讲

1130
00:50:28,000 --> 00:50:30,000
不算特别好

1131
00:50:30,000 --> 00:50:31,000
特别是在

1132
00:50:31,000 --> 00:50:32,000
这个

1133
00:50:32,000 --> 00:50:34,000
就是 OS X 上面

1134
00:50:34,000 --> 00:50:39,000
经常会遇到什么用开了它然后就死机的一个情况也是有发生

1135
00:50:39,000 --> 00:50:40,000
对对对

1136
00:50:40,000 --> 00:50:46,000
其实最近那个我们知道好像是从那个 OS X 是 10.9

1137
00:50:46,000 --> 00:50:49,000
还是 10.10 开始他有一个

1138
00:50:49,000 --> 00:50:51,000
就苹果开发了一套这个

1139
00:50:52,000 --> 00:50:52,000
Firmwork

1140
00:50:52,000 --> 00:50:55,000
Hypervisor.firmwork

1141
00:50:55,000 --> 00:51:01,000
这套其实他可以在 OS X 上实现类似于 KVM 的功能

1142
00:51:01,000 --> 00:51:04,000
所以不知道你们后续有什么计划会用到他吗

1143
00:51:04,000 --> 00:51:07,000
其实我们也在非常关注这个点

1144
00:51:07,000 --> 00:51:10,000
然后目前的有一个开源的工具就是

1145
00:51:10,000 --> 00:51:11,000
XI

1146
00:51:11,000 --> 00:51:11,000
就是

1147
00:51:12,000 --> 00:51:12,000
对对对

1148
00:51:13,000 --> 00:51:14,000
你应该也关注过这个非常

1149
00:51:15,000 --> 00:51:18,000
就是之前在 Hypernews 上面发出来过非常火

1150
00:51:18,000 --> 00:51:20,000
然后关注度也非常高

1151
00:51:22,000 --> 00:51:25,000
他那个的历史还是要追踪到那个 Solaris 上面去对吧

1152
00:51:26,000 --> 00:51:27,000
因为他的前身是一个

1153
00:51:27,000 --> 00:51:29,000
他是基于他是一个 BHive 的 Port

1154
00:51:30,000 --> 00:51:32,000
然后 BHive 是在 Solaris 还是 BSD 上来的

1155
00:51:32,000 --> 00:51:33,000
FreeBSD

1156
00:51:34,000 --> 00:51:37,000
对对对所以 Solaris 上面应该是没有的

1157
00:51:37,000 --> 00:51:38,000
OK

1158
00:51:39,000 --> 00:51:42,000
所以这个目前来说就是我们还是跟那个

1159
00:51:43,000 --> 00:51:43,000
像

1160
00:51:43,000 --> 00:51:45,000
就是那个 Docker 的方案一样

1161
00:51:45,000 --> 00:51:50,000
在 OS X 上测试开发的时候是通过这个 VirtualBox 这个虚拟机

1162
00:51:51,000 --> 00:51:55,000
那里面直接在跑一些是跑的这个是 Hyper 的虚拟机对吧

1163
00:51:55,000 --> 00:52:01,000
这个就是我们的一个费了好多好多心思去做的这个东西就是我们

1164
00:52:02,000 --> 00:52:03,000
这个 Hyper 在 MAC 上面

1165
00:52:03,000 --> 00:52:04,000
的运行

1166
00:52:04,000 --> 00:52:07,000
和 Boot 2 Docker 的运行是不太一样的

1167
00:52:08,000 --> 00:52:10,000
Boot 2 Docker 呢他其实就是

1168
00:52:10,000 --> 00:52:12,000
一个 Docker 的可案端

1169
00:52:12,000 --> 00:52:17,000
然后他把他的 Demon 设成了 VM 的

1170
00:52:17,000 --> 00:52:18,000
Waterbox 的

1171
00:52:20,000 --> 00:52:20,000
地址

1172
00:52:20,000 --> 00:52:23,000
然后这个在 Waterbox 里面去运行 Docker Demon

1173
00:52:24,000 --> 00:52:28,000
然后他其实相当于通过网络然后将这个数据全部

1174
00:52:28,000 --> 00:52:30,000
显示给 Docker 可案的

1175
00:52:30,000 --> 00:52:31,000
用户以为

1176
00:52:31,000 --> 00:52:33,000
他这是本地运行的

1177
00:52:34,000 --> 00:52:37,000
就是在所有的东西在那个 VirtualBox 的那个虚拟机里面运行

1178
00:52:38,000 --> 00:52:38,000
对对对

1179
00:52:38,000 --> 00:52:39,000
是的

1180
00:52:39,000 --> 00:52:40,000
对

1181
00:52:40,000 --> 00:52:42,000
那你们的方案是怎么样

1182
00:52:42,000 --> 00:52:44,000
我们的方案其实是跟 Linux

1183
00:52:45,000 --> 00:52:47,000
它的设计机制是完全一致的

1184
00:52:47,000 --> 00:52:47,000
就是相当于

1185
00:52:48,000 --> 00:52:51,000
我们的 Hyper Demon 是在 MAC OS 上面

1186
00:52:51,000 --> 00:52:52,000
然后

1187
00:52:52,000 --> 00:52:55,000
我们的 Hyper 可案也在 MAC OS 上面

1188
00:52:55,000 --> 00:52:55,000
而

1189
00:52:56,000 --> 00:52:58,000
运行的 Docker 的 Image

1190
00:52:58,000 --> 00:53:00,000
是在 Waterbox

1191
00:53:01,000 --> 00:53:02,000
里面去运行的

1192
00:53:02,000 --> 00:53:04,000
他整个的一个设计是在 Waterbox 里面去运行的

1193
00:53:04,000 --> 00:53:07,000
所以这个设计思路是完全和 Linux

1194
00:53:07,000 --> 00:53:10,000
上面的 Hyper 设计思路是一致的

1195
00:53:11,000 --> 00:53:12,000
所以其实

1196
00:53:12,000 --> 00:53:13,000
我理解就是说

1197
00:53:13,000 --> 00:53:17,000
在这种情况下比如我在 OS X 上跑一个

1198
00:53:17,000 --> 00:53:20,000
Hyper 之后

1199
00:53:20,000 --> 00:53:21,000
它的管理层是

1200
00:53:21,000 --> 00:53:24,000
管理层命令行工具都是在 OS X 的原生的东西

1201
00:53:24,000 --> 00:53:27,000
然后他是控制 VirtualBox 的 Hypervisor

1202
00:53:28,000 --> 00:53:30,000
去里面新建一个虚拟机

1203
00:53:31,000 --> 00:53:34,000
虚拟机内核跑的是你们 Hyper 定制的轻量机

1204
00:53:34,000 --> 00:53:37,000
然后里面在跑的一个

1205
00:53:37,000 --> 00:53:40,000
或者是多个 Docker 的 Image

1206
00:53:41,000 --> 00:53:45,000
OK 这个还真的和 Boot to Docker 的方式非常不一样

1207
00:53:46,000 --> 00:53:48,000
因为 Boot to Docker 你创建一个 container

1208
00:53:48,000 --> 00:53:51,000
它是一个 VM

1209
00:53:51,000 --> 00:53:53,000
然后你创建两个它也是

1210
00:53:53,000 --> 00:53:54,000
创建三个它也是

1211
00:53:54,000 --> 00:53:57,000
它创建的 container 都是在 VM 里面

1212
00:53:57,000 --> 00:54:00,000
而我们这种方式就是你创建一个 container 或者说

1213
00:54:01,000 --> 00:54:02,000
就多一个 VM

1214
00:54:02,000 --> 00:54:04,000
这个可能会受限

1215
00:54:04,000 --> 00:54:07,000
限于开发者的一个机器的一个环境配置

1216
00:54:07,000 --> 00:54:11,000
因为多个 VM 它毕竟要占 CPU 占 Memory

1217
00:54:11,000 --> 00:54:12,000
这个是一个

1218
00:54:14,000 --> 00:54:16,000
但它做了很好的一个隔离性

1219
00:54:16,000 --> 00:54:17,000
对吧

1220
00:54:18,000 --> 00:54:18,000
OK

1221
00:54:19,000 --> 00:54:21,000
所以这里我要问一个很好

1222
00:54:22,000 --> 00:54:24,000
很好玩的问题就是说那你们

1223
00:54:24,000 --> 00:54:27,000
为了实现这个踩了多少 VirtualBox 的坑

1224
00:54:27,000 --> 00:54:30,000
这个我想

1225
00:54:30,000 --> 00:54:33,000
你应该也会知道 VirtualBox 的坑

1226
00:54:33,000 --> 00:54:34,000
就是太多太多

1227
00:54:34,000 --> 00:54:38,000
就是它的 API 很难在 Mac 上面

1228
00:54:39,000 --> 00:54:40,000
因为我们是用 Go 开发的嘛

1229
00:54:40,000 --> 00:54:44,000
所以它的 VirtualBox 的 API 很难跟 Go 去结合到一起

1230
00:54:44,000 --> 00:54:46,000
所以没办法只能掉命个行

1231
00:54:46,000 --> 00:54:51,000
掉命个行的一个另外一个问题就是没办法监测它的一个输出的一个结果

1232
00:54:51,000 --> 00:54:56,000
所以就是用一些很无奈的办法

1233
00:54:56,000 --> 00:54:57,000
去直接

1234
00:54:57,000 --> 00:54:58,000
解它的输出

1235
00:54:59,000 --> 00:55:00,000
这些办法

1236
00:55:00,000 --> 00:55:02,000
另外就是

1237
00:55:02,000 --> 00:55:04,000
不局限于

1238
00:55:04,000 --> 00:55:05,000
Waterbox 的问题

1239
00:55:05,000 --> 00:55:06,000
还有就是

1240
00:55:07,000 --> 00:55:08,000
MacOS 的问题

1241
00:55:08,000 --> 00:55:11,000
因为众所周知因为 Docker

1242
00:55:11,000 --> 00:55:12,000
它的

1243
00:55:12,000 --> 00:55:15,000
他用了 Layer 的 FS

1244
00:55:16,000 --> 00:55:19,000
然后他用这个来做 Layer 的 Image

1245
00:55:19,000 --> 00:55:20,000
然后

1246
00:55:20,000 --> 00:55:21,000
对

1247
00:55:21,000 --> 00:55:22,000
来保证

1248
00:55:22,000 --> 00:55:23,000
足够的快

1249
00:55:23,000 --> 00:55:26,000
然后不至于说直接的拷贝然后

1250
00:55:26,000 --> 00:55:28,000
造成很大的一个

1251
00:55:28,000 --> 00:55:29,000
时间

1252
00:55:29,000 --> 00:55:30,000
然后呢

1253
00:55:30,000 --> 00:55:31,000
我们

1254
00:55:31,000 --> 00:55:34,000
在 MacOS 上面其实也想了很多很多办法

1255
00:55:34,000 --> 00:55:35,000
就怎么能够达到

1256
00:55:38,000 --> 00:55:39,000
Layer 这种效果

1257
00:55:40,000 --> 00:55:43,000
居然让我们找到了 Waterbox 居然能有这种机制

1258
00:55:44,000 --> 00:55:45,000
就是 Waterbox 其实是

1259
00:55:46,000 --> 00:55:48,000
可以做 Layer 的 Disk

1260
00:55:49,000 --> 00:55:49,000
就是

1261
00:55:49,000 --> 00:55:53,000
是通过那个 SnapShot 那个机制吗

1262
00:55:53,000 --> 00:55:56,000
不太一样但是也差不多类似实验机制

1263
00:55:57,000 --> 00:55:58,000
它是通过 Parent

1264
00:55:58,000 --> 00:55:59,000
Disk

1265
00:56:00,000 --> 00:56:01,000
其实就是 SnapShot

1266
00:56:02,000 --> 00:56:03,000
对然后呢

1267
00:56:03,000 --> 00:56:06,000
我们通过这种方式就可以实现用 Layer 的 Disk

1268
00:56:08,000 --> 00:56:12,000
啊你们是这么做的好机制啊这个办法

1269
00:56:13,000 --> 00:56:17,000
那出来的这个实际的就执行效率怎么样因为这个可能

1270
00:56:17,000 --> 00:56:18,000
其实因为

1271
00:56:18,000 --> 00:56:21,000
除非你部署吧其实大部分开发者可能还是在

1272
00:56:21,000 --> 00:56:24,000
像这个 OS X 里面用 VirtualBox 的方式来开发

1273
00:56:24,000 --> 00:56:27,000
然后我们目前这种方式的话大概

1274
00:56:28,000 --> 00:56:32,000
在运行一个 Ubuntu 的 DockerImage

1275
00:56:32,000 --> 00:56:33,000
就整个像这个样子

1276
00:56:33,000 --> 00:56:35,000
然后你下载之后

1277
00:56:36,000 --> 00:56:39,000
运行大概在两分钟

1278
00:56:40,000 --> 00:56:40,000
就是

1279
00:56:41,000 --> 00:56:44,000
就从那个 VirtualBox 运行创建到开始

1280
00:56:44,000 --> 00:56:44,000
对

1281
00:56:45,000 --> 00:56:46,000
就直接你可以直接操作

1282
00:56:47,000 --> 00:56:48,000
两分钟不到两分钟

1283
00:56:48,000 --> 00:56:50,000
不到两分钟

1284
00:56:50,000 --> 00:56:52,000
1900 多毫秒吧

1285
00:56:53,000 --> 00:56:53,000
OK

1286
00:56:53,000 --> 00:56:56,000
那如果这个东西两分钟的主要的花在哪里

1287
00:56:57,000 --> 00:57:00,000
主要花在了其实一部分是

1288
00:57:00,000 --> 00:57:02,000
Waterbox 本身的

1289
00:57:02,000 --> 00:57:03,000
设备的一个

1290
00:57:04,000 --> 00:57:04,000
虚拟化

1291
00:57:04,000 --> 00:57:07,000
就是它的硬件的 Device 的一个虚拟化

1292
00:57:07,000 --> 00:57:08,000
因为它

1293
00:57:08,000 --> 00:57:11,000
就叫配置一个 VirtualBox 的虚拟机出来

1294
00:57:11,000 --> 00:57:12,000
对这是一部分

1295
00:57:12,000 --> 00:57:15,000
另外一部分它就是一些硬件的虚拟化

1296
00:57:15,000 --> 00:57:18,000
比如我要是创建 SATA 的盘

1297
00:57:18,000 --> 00:57:20,000
那我只能

1298
00:57:20,000 --> 00:57:21,000
创建 SATA 的 Device

1299
00:57:22,000 --> 00:57:23,000
而且 Waterbox

1300
00:57:24,000 --> 00:57:28,000
只能是用 SATA 作为 HotPlug 的 Disk

1301
00:57:28,000 --> 00:57:29,000
而呢

1302
00:57:29,000 --> 00:57:33,000
用 SATA 作为 HotPlug 的 Disk 的话

1303
00:57:33,000 --> 00:57:36,000
就时间会比较漫长

1304
00:57:36,000 --> 00:57:39,000
稍微比 SaaS 的要

1305
00:57:39,000 --> 00:57:42,000
因为 SaaS 它不支持 HotPlug

1306
00:57:42,000 --> 00:57:44,000
所以它的机制可能会简单好多

1307
00:57:45,000 --> 00:57:46,000
对所以

1308
00:57:47,000 --> 00:57:48,000
就损耗在这些方面

1309
00:57:49,000 --> 00:57:50,000
就比较无奈

1310
00:57:50,000 --> 00:57:52,000
然后另外一个就是

1311
00:57:52,000 --> 00:57:55,000
当然也是有 GasOS 去运行

1312
00:57:56,000 --> 00:57:57,000
但是这个时间没办法

1313
00:57:57,000 --> 00:57:58,000
就我们已经

1314
00:57:58,000 --> 00:57:59,000
极致的去优化了

1315
00:58:00,000 --> 00:58:02,000
但是相比这个还是会短一些

1316
00:58:03,000 --> 00:58:05,000
所以其实

1317
00:58:05,000 --> 00:58:08,000
就是说如果是在 OS X 上开发的话

1318
00:58:08,000 --> 00:58:11,000
用 Hyper 最主要的开销就是在创建那一块

1319
00:58:12,000 --> 00:58:12,000
然后

1320
00:58:12,000 --> 00:58:14,000
创建好了之后

1321
00:58:14,000 --> 00:58:17,000
的启动那个某一个 Hyper 的虚拟机

1322
00:58:17,000 --> 00:58:19,000
还是要比在

1323
00:58:19,000 --> 00:58:21,000
那个时长原生就部署的时候那个效能

1324
00:58:22,000 --> 00:58:23,000
0.3 秒要慢一些

1325
00:58:23,000 --> 00:58:24,000
对对对

1326
00:58:24,000 --> 00:58:25,000
是这样吗

1327
00:58:25,000 --> 00:58:27,000
因为它本身的 Waterbox 的

1328
00:58:28,000 --> 00:58:29,000
机制没办法

1329
00:58:30,000 --> 00:58:31,000
OK

1330
00:58:31,000 --> 00:58:33,000
所以这个真的要可能要逼得你们

1331
00:58:34,000 --> 00:58:36,000
去研究那个新的 Hypervisor Framework

1332
00:58:36,000 --> 00:58:37,000
去解决这个问题

1333
00:58:37,000 --> 00:58:40,000
我们也在时时刻关注这个东西

1334
00:58:40,000 --> 00:58:41,000
因为这个东西

1335
00:58:41,000 --> 00:58:42,000
最近的

1336
00:58:42,000 --> 00:58:44,000
最近的观察来看就是

1337
00:58:45,000 --> 00:58:45,000
原作者

1338
00:58:45,000 --> 00:58:46,000
可能

1339
00:58:46,000 --> 00:58:48,000
我在忙别的然后不太开

1340
00:58:49,000 --> 00:58:51,000
不太会上心这件事情

1341
00:58:51,000 --> 00:58:53,000
然后我们也在去关注

1342
00:58:53,000 --> 00:58:54,000
希望能够

1343
00:58:56,000 --> 00:58:58,000
能够去做一些贡献吧

1344
00:58:58,000 --> 00:58:58,000
然后但是

1345
00:58:59,000 --> 00:59:01,000
你是说那个 X-Hive 的那个原作者吗

1346
00:59:01,000 --> 00:59:03,000
所以现在我们大概去了解了这个

1347
00:59:04,000 --> 00:59:05,000
Hyper 的一个整个

1348
00:59:05,000 --> 00:59:06,000
它是什么

1349
00:59:06,000 --> 00:59:07,000
然后它

1350
00:59:07,000 --> 00:59:08,000
相对于一些我们

1351
00:59:08,000 --> 00:59:10,000
就是已经熟知的一些工具

1352
00:59:10,000 --> 00:59:11,000
的这么一个

1353
00:59:12,000 --> 00:59:15,000
技术对比它的优劣是在哪里了

1354
00:59:15,000 --> 00:59:17,000
就是说我们其实可能就还在回到一个

1355
00:59:18,000 --> 00:59:19,000
最关键的问题就是说

1356
00:59:19,000 --> 00:59:26,000
为什么我作为一个这个网络管理员或者这个机房的这个这个一个公有云的运营者我要选择 Hyper

1357
00:59:26,000 --> 00:59:27,000
对所以

1358
00:59:27,000 --> 00:59:31,000
所以你刚才说一点非常非常关键的一点就是作为公有云的管理者

1359
00:59:32,000 --> 00:59:33,000
当然作为

1360
00:59:34,000 --> 00:59:40,000
一个相当相当于说我就内部一个运营或者说测试环境我用 Docker 一点问题没有

1361
00:59:40,000 --> 00:59:44,000
但是你要是用公有云的话你必须要考虑它的安全性问题

1362
00:59:45,000 --> 00:59:46,000
对然后

1363
00:59:46,000 --> 00:59:47,000
所以就是

1364
00:59:47,000 --> 00:59:49,000
考虑到安全性的问题呢

1365
00:59:49,000 --> 00:59:52,000
你就必须要考虑

1366
00:59:52,000 --> 00:59:54,000
Docker 他是否能

1367
00:59:55,000 --> 00:59:57,000
怎么能够跟 VM 去结合

1368
00:59:57,000 --> 00:59:59,000
能够最大效率的去

1369
00:59:59,000 --> 01:00:01,000
利用 Barmental 的机制

1370
01:00:01,000 --> 01:00:03,000
所以为什么不去尝试

1371
01:00:04,000 --> 01:00:05,000
Hyper 呢 Hyper 其实就是为你

1372
01:00:06,000 --> 01:00:09,000
为为个为个这种公有云的运营商

1373
01:00:09,000 --> 01:00:10,000
天然去解决这个问题

1374
01:00:11,000 --> 01:00:14,000
你又想用 Docker 又想提供这种

1375
01:00:15,000 --> 01:00:18,000
基于 container 的一个管理方式那个租户的管理方式

1376
01:00:18,000 --> 01:00:20,000
然后你可以用 Docker image

1377
01:00:20,000 --> 01:00:23,000
然后跟 Docker 的使用完全没有

1378
01:00:23,000 --> 01:00:25,000
没有异样但是它的安全性会

1379
01:00:26,000 --> 01:00:27,000
非常非常好

1380
01:00:27,000 --> 01:00:28,000
那么所以

1381
01:00:28,000 --> 01:00:29,000
这个就是一个

1382
01:00:30,000 --> 01:00:31,000
很很好的一个机会

1383
01:00:31,000 --> 01:00:32,000
然后去尝试

1384
01:00:32,000 --> 01:00:32,000
OK

1385
01:00:33,000 --> 01:00:33,000
所以有一个很好的机会去尝试

1386
01:00:33,000 --> 01:00:36,000
有一个 Hyper 其实我们就可以达到一个安全的

1387
01:00:36,000 --> 01:00:37,000
共有的

1388
01:00:38,000 --> 01:00:38,000
一个 CaaS

1389
01:00:39,000 --> 01:00:40,000
CaaS 就是 container as a service

1390
01:00:41,000 --> 01:00:41,000
as a service

1391
01:00:42,000 --> 01:00:44,000
所以我们目前也在提这个概念

1392
01:00:45,000 --> 01:00:46,000
OK

1393
01:00:46,000 --> 01:00:49,000
所以这里就很自然的过渡到我们的下一个话题了

1394
01:00:50,000 --> 01:00:51,000
就是说你们的主要的

1395
01:00:51,000 --> 01:00:53,000
客户其实并不是说

1396
01:00:53,000 --> 01:00:55,000
当然你说这个要大家熟悉的方式

1397
01:00:56,000 --> 01:00:57,000
方式 API 肯定还是要教育用户的

1398
01:00:58,000 --> 01:01:01,000
但是说从你们这个 customer 就是谁为你们付钱这件事情来讲

1399
01:01:01,000 --> 01:01:03,000
可能还是一些这个

1400
01:01:03,000 --> 01:01:04,000
刚才讲的这个供应的管理者

1401
01:01:05,000 --> 01:01:05,000
对

1402
01:01:06,000 --> 01:01:07,000
那这就牵涉到这个

1403
01:01:08,000 --> 01:01:09,000
一个所谓的商业模式的问题

1404
01:01:09,000 --> 01:01:11,000
就是你们这个 Hyper 这个项目

1405
01:01:11,000 --> 01:01:13,000
你们目前打算是怎么去

1406
01:01:13,000 --> 01:01:14,000
盈利呢

1407
01:01:14,000 --> 01:01:18,000
我们目前其实 Hyper 这个项目主啊还是

1408
01:01:19,000 --> 01:01:20,000
作为开源项目为主

1409
01:01:20,000 --> 01:01:23,000
这样的话也是希望吸引能够吸引

1410
01:01:23,000 --> 01:01:25,000
吸引更多的 hacker

1411
01:01:26,000 --> 01:01:29,000
或者说一些 contributor 来参与到我们的项目

1412
01:01:29,000 --> 01:01:30,000
来共同打造一个

1413
01:01:31,000 --> 01:01:32,000
基于 container 的一个

1414
01:01:32,000 --> 01:01:35,000
或者是基于 pod 的一个社区

1415
01:01:35,000 --> 01:01:37,000
然后我们

1416
01:01:38,000 --> 01:01:40,000
也是希望能够跟一些

1417
01:01:40,000 --> 01:01:42,000
一些

1418
01:01:42,000 --> 01:01:46,000
机房或者说一些类似于这种的厂商去合作

1419
01:01:46,000 --> 01:01:49,000
希望能够帮助他们去听更好的解决方案

1420
01:01:49,000 --> 01:01:51,000
目前我们

1421
01:01:51,000 --> 01:01:54,000
我们成立大概半年多的时间

1422
01:01:55,000 --> 01:01:56,000
其实像

1423
01:01:56,000 --> 01:01:59,000
国外一个比较著名的一个也是创业公司吧叫 Packit

1424
01:02:00,000 --> 01:02:02,000
然后他其实就是

1425
01:02:02,000 --> 01:02:04,000
已经推出基于 Hyper 的一个产品

1426
01:02:05,000 --> 01:02:07,000
对现在已经出国大家也可以

1427
01:02:08,000 --> 01:02:10,000
去体验当然可能要绑定信卡

1428
01:02:10,000 --> 01:02:11,000
就比较麻烦

1429
01:02:12,000 --> 01:02:15,000
相信对于这个我们这个有足够

1430
01:02:16,000 --> 01:02:21,000
这个长线精神的开发者来说这不是一个特别大的难题

1431
01:02:21,000 --> 01:02:23,000
当然你可以自己在自己的

1432
01:02:23,000 --> 01:02:25,000
自己的平台上面去部署

1433
01:02:26,000 --> 01:02:28,000
或者是去体验当然也可以

1434
01:02:28,000 --> 01:02:29,000
然后除此之外

1435
01:02:30,000 --> 01:02:30,000
就是跟这种

1436
01:02:31,000 --> 01:02:32,000
这种厂商

1437
01:02:32,000 --> 01:02:33,000
去合作之外

1438
01:02:33,000 --> 01:02:34,000
我们也在

1439
01:02:35,000 --> 01:02:36,000
自己也在做基于

1440
01:02:36,000 --> 01:02:37,000
的公有运

1441
01:02:37,000 --> 01:02:38,000
就刚才说的 CaaS

1442
01:02:39,000 --> 01:02:41,000
你们自己要运营一个公有运

1443
01:02:42,000 --> 01:02:42,000
对对对其实我们

1444
01:02:42,000 --> 01:02:45,000
这个目前提的一个方式叫 HyperStack

1445
01:02:46,000 --> 01:02:48,000
HyperStack

1446
01:02:48,000 --> 01:02:49,000
它其实是

1447
01:02:49,000 --> 01:02:50,000
构建于

1448
01:02:51,000 --> 01:02:52,000
Hyper 的基础上

1449
01:02:52,000 --> 01:02:55,000
然后结合目前非常流行的 Kubernetes

1450
01:02:56,000 --> 01:03:01,000
然后 OpenStack 里面的一些组件比如像 Thunder,Neutron 以及 Keystone

1451
01:03:01,000 --> 01:03:07,000
然后将这几个组件结合到一起

1452
01:03:07,000 --> 01:03:09,000
然后形成一个自己的 Stack

1453
01:03:10,000 --> 01:03:13,000
也是希望能够达到整个生态链

1454
01:03:14,000 --> 01:03:16,000
然后我们已经提了这个 proposal

1455
01:03:16,000 --> 01:03:18,000
然后目前也在去

1456
01:03:19,000 --> 01:03:20,000
组织人手去打造

1457
01:03:21,000 --> 01:03:22,000
OK

1458
01:03:22,000 --> 01:03:24,000
这里就涉及到最开始的一个问题

1459
01:03:24,000 --> 01:03:28,000
就是说因为当时我看你们这个 Hyper.sh 的这个网站上

1460
01:03:29,000 --> 01:03:31,000
也有就是说只有一个英文的介绍了吗

1461
01:03:31,000 --> 01:03:33,000
并没有这个中文的任何介绍

1462
01:03:33,000 --> 01:03:34,000
这跟你们这个

1463
01:03:35,000 --> 01:03:36,000
商业模型和这个客户选择有关系

1464
01:03:37,000 --> 01:03:43,000
对对对我们目前的一个打算的就是希望能够吸引更多

1465
01:03:44,000 --> 01:03:49,000
国外的厂商然后去跟他们去竞争或者说去

1466
01:03:49,000 --> 01:03:54,000
去合作然后之前的一个考虑呢就是国内

1467
01:03:56,000 --> 01:04:00,000
对于开源项目的支持或者说合作

1468
01:04:00,000 --> 01:04:01,000
不是特别

1469
01:04:01,000 --> 01:04:03,000
大胆或者不是特别明显

1470
01:04:03,000 --> 01:04:04,000
所以

1471
01:04:04,000 --> 01:04:07,000
也考虑到这些问题吧

1472
01:04:07,000 --> 01:04:10,000
就是在前期做一个创业公司可能

1473
01:04:11,000 --> 01:04:13,000
用一种最保险或者说

1474
01:04:14,000 --> 01:04:15,000
最妥善的办法吧

1475
01:04:18,000 --> 01:04:18,000
OK

1476
01:04:18,000 --> 01:04:23,000
所以就是其实就面临我们这个一个很尴尬的情况就是中国

1477
01:04:23,000 --> 01:04:24,000
这个网络技术设施

1478
01:04:25,000 --> 01:04:26,000
并不如美国好

1479
01:04:27,000 --> 01:04:27,000
就是从这个

1480
01:04:28,000 --> 01:04:29,000
就是这个

1481
01:04:29,000 --> 01:04:30,000
机房啊

1482
01:04:30,000 --> 01:04:31,000
云的建设

1483
01:04:31,000 --> 01:04:32,000
这一块是比较落后的

1484
01:04:33,000 --> 01:04:39,000
那同时在我们能够数得出来的好国内的一些公用云的运营者也就那么几家把像什么

1485
01:04:39,000 --> 01:04:41,000
阿里云腾讯云

1486
01:04:41,000 --> 01:04:43,000
还有什么美团清云

1487
01:04:43,000 --> 01:04:47,000
美团清云以前还有那京东云好像也有发现他在吗现在现在好像关闭了

1488
01:04:48,000 --> 01:04:54,000
关掉了对好现在他们其实并没有说到了那个足够大胆尝试这种新

1489
01:04:54,000 --> 01:04:55,000
新技术的

1490
01:04:55,000 --> 01:04:56,000
时候

1491
01:04:57,000 --> 01:05:00,000
所以你们选择先去开拓这个海外市场

1492
01:05:00,000 --> 01:05:01,000
然后等这个

1493
01:05:01,000 --> 01:05:07,000
在这个验证好这个模式和这个技术成熟之后再想办法能不能够国内的这些

1494
01:05:07,000 --> 01:05:11,000
云厂商也能够或者说出一些新的这个小的云厂商

1495
01:05:11,000 --> 01:05:13,000
也能够采用这个海盘的技术对

1496
01:05:14,000 --> 01:05:20,000
所以你们在海外的目前的一些合作伙伴就跟你提到除了那个拍给一个这个也是一个

1497
01:05:21,000 --> 01:05:21,000
比较新

1498
01:05:21,000 --> 01:05:27,000
和比较酷的这个一共云的运营商之外还有哪些是你们在目前是在有这个深度合作

1499
01:05:28,000 --> 01:05:30,000
我们现在比较合作的比较多的像振

1500
01:05:31,000 --> 01:05:31,000
在那

1501
01:05:32,000 --> 01:05:32,000
在那里

1502
01:05:32,000 --> 01:05:33,000
门

1503
01:05:33,000 --> 01:05:35,000
门腾的和底外我们都有

1504
01:05:35,000 --> 01:05:36,000
非常多的接触

1505
01:05:36,000 --> 01:05:37,000
然后

1506
01:05:37,000 --> 01:05:39,000
之前参加了真的底外

1507
01:05:39,000 --> 01:05:40,000
三米

1508
01:05:40,000 --> 01:05:42,000
然后去跟他们去交流

1509
01:05:42,000 --> 01:05:44,000
他们也非常支持

1510
01:05:45,000 --> 01:05:46,000
还会对赠的一个

1511
01:05:46,000 --> 01:05:46,000
个支持

1512
01:05:47,000 --> 01:05:49,000
希望能够去

1513
01:05:49,000 --> 01:05:54,000
共同探讨能够把这个性能了或者说

1514
01:05:54,000 --> 01:05:56,000
体验做到足够的好

1515
01:05:56,000 --> 01:05:57,000
所以

1516
01:05:57,000 --> 01:05:58,000
正还是说

1517
01:05:59,000 --> 01:06:00,000
是是是我们一个非常非常

1518
01:06:00,000 --> 01:06:01,000
非常重要的一个盘子

1519
01:06:02,000 --> 01:06:03,000
然后他们对我们

1520
01:06:03,000 --> 01:06:04,000
在底层技术上面

1521
01:06:05,000 --> 01:06:08,000
的一个这或者说在海外上面的支持还是

1522
01:06:08,000 --> 01:06:08,000
挺多的

1523
01:06:09,000 --> 01:06:10,000
OK 对

1524
01:06:11,000 --> 01:06:11,000
明白

1525
01:06:12,000 --> 01:06:13,000
就所以就还是一个非常

1526
01:06:13,000 --> 01:06:14,000
值得

1527
01:06:14,000 --> 01:06:19,000
让人让人激动的一个合作的因为认识我们一个很非常传统的这个

1528
01:06:19,000 --> 01:06:25,000
虚拟器的这个海外的我记得好像 AWS 就是基于这种做的

1529
01:06:26,000 --> 01:06:27,000
现在是一个

1530
01:06:27,000 --> 01:06:28,000
非常对对对

1531
01:06:28,000 --> 01:06:29,000
技术

1532
01:06:29,000 --> 01:06:29,000
给

1533
01:06:30,000 --> 01:06:35,000
刚刚我们讲完了这个海盘这个产品好包括你们商业模式好就现在我们得到这

1534
01:06:35,000 --> 01:06:36,000
是我直接

1535
01:06:36,000 --> 01:06:40,000
我个人来说最关心的方对一个领域就是这个团队

1536
01:06:40,000 --> 01:06:44,000
那个三个你可以大概介绍一下你们现在做这个海盘这个 team 大概什么样情况吗

1537
01:06:45,000 --> 01:06:47,000
我们现在的开发者是五个人

1538
01:06:48,000 --> 01:06:49,000
然后五个人

1539
01:06:49,000 --> 01:06:50,000
这么想

1540
01:06:51,000 --> 01:06:53,000
所以就是每天还是挺忙的

1541
01:06:54,000 --> 01:06:56,000
OK 然后一个人

1542
01:06:56,000 --> 01:06:57,000
主要负责海盘

1543
01:06:57,000 --> 01:06:58,000
一个相关的东西

1544
01:06:58,000 --> 01:07:00,000
另外就是主要集中在

1545
01:07:00,000 --> 01:07:00,000
海盘

1546
01:07:01,000 --> 01:07:02,000
这个核心产品

1547
01:07:02,000 --> 01:07:03,000
然后

1548
01:07:03,000 --> 01:07:03,000
足够

1549
01:07:04,000 --> 01:07:04,000
就是

1550
01:07:04,000 --> 01:07:07,000
新的 feature 开发以及 fix 一些 bug

1551
01:07:08,000 --> 01:07:13,000
然后因为毕竟开源代码也是希望能够让代码质量足够的优质

1552
01:07:15,000 --> 01:07:16,000
对然后 gamebuy

1553
01:07:16,000 --> 01:07:17,000
有

1554
01:07:18,000 --> 01:07:20,000
有三个人主要是负责壁地相关的东西

1555
01:07:20,000 --> 01:07:25,000
然后做一些因为毕竟是海外市场所以我们有些

1556
01:07:26,000 --> 01:07:27,000
国外的朋友

1557
01:07:27,000 --> 01:07:28,000
然后去帮忙推

1558
01:07:29,000 --> 01:07:30,000
或者支持这些东西

1559
01:07:31,000 --> 01:07:35,000
所以整个团队其实加起来也不超过 10 个人吧

1560
01:07:36,000 --> 01:07:36,000
非常非常小

1561
01:07:37,000 --> 01:07:37,000
然后

1562
01:07:37,000 --> 01:07:41,000
精悍的一个团队但是我们的团队还是

1563
01:07:42,000 --> 01:07:43,000
我觉得战斗力还是挺强的

1564
01:07:44,000 --> 01:07:48,000
OK 所以当初你是怎么加入到这个团队里面去

1565
01:07:48,000 --> 01:07:51,000
因为当时其实还是刀铺还是

1566
01:07:51,000 --> 01:07:52,000
挺火的

1567
01:07:52,000 --> 01:07:53,000
我也对

1568
01:07:53,000 --> 01:07:55,000
虚拟化

1569
01:07:55,000 --> 01:07:57,000
因为我毕竟之前是做存储的

1570
01:07:57,000 --> 01:07:59,000
但是我对虚拟化的这块

1571
01:07:59,000 --> 01:08:00,000
还是比较感兴趣的

1572
01:08:01,000 --> 01:08:02,000
所以希望能够

1573
01:08:02,000 --> 01:08:05,000
进入到这个领域吧

1574
01:08:05,000 --> 01:08:06,000
然后看到

1575
01:08:06,000 --> 01:08:09,000
网上有一个招聘吧

1576
01:08:09,000 --> 01:08:10,000
大概

1577
01:08:11,000 --> 01:08:16,000
可能一个想做一个基于虚拟化或者基于一个容器的一个 OS

1578
01:08:17,000 --> 01:08:18,000
然后也

1579
01:08:18,000 --> 01:08:20,000
想深入的去了解一下

1580
01:08:20,000 --> 01:08:20,000
大概就

1581
01:08:21,000 --> 01:08:21,000
后来就认识了

1582
01:08:22,000 --> 01:08:23,000
然后就聊聊聊

1583
01:08:23,000 --> 01:08:24,000
后来

1584
01:08:24,000 --> 01:08:25,000
当然随着

1585
01:08:26,000 --> 01:08:29,000
随着社区的变化或者说

1586
01:08:29,000 --> 01:08:30,000
现在的变化

1587
01:08:30,000 --> 01:08:30,000
可能当时

1588
01:08:30,000 --> 01:08:32,000
有一个想法慢慢再调整

1589
01:08:33,000 --> 01:08:33,000
然后也

1590
01:08:34,000 --> 01:08:35,000
做出现在的产品

1591
01:08:37,000 --> 01:08:40,000
所以你是在哪里看到他们的招聘广告

1592
01:08:40,000 --> 01:08:41,000
是在 v 2 ex

1593
01:08:42,000 --> 01:08:44,000
啊 OK

1594
01:08:45,000 --> 01:08:47,000
v 2 ex 跟我们节目的关系还是

1595
01:08:47,000 --> 01:08:52,000
挺密切的因为我们每次节目都会上面发我们的这个节目介绍和连接

1596
01:08:52,000 --> 01:08:55,000
然后这个 v 2 ex 的这个 Livit 也非常

1597
01:08:55,000 --> 01:08:57,000
很 nice 的给我免费在

1598
01:08:58,000 --> 01:08:59,000
那个 podcast 那个分类里面

1599
01:09:00,000 --> 01:09:02,000
加了一个测栏的广告

1600
01:09:02,000 --> 01:09:03,000
也非常感谢他们

1601
01:09:04,000 --> 01:09:07,000
对不这个也是就国内一个比较

1602
01:09:07,000 --> 01:09:10,000
好的这个程序开发者的一个社区嘛

1603
01:09:11,000 --> 01:09:12,000
其实你在上面

1604
01:09:12,000 --> 01:09:13,000
能找到他们也是其实

1605
01:09:14,000 --> 01:09:15,000
你是意料之内吧

1606
01:09:16,000 --> 01:09:16,000
然后

1607
01:09:16,000 --> 01:09:17,000
其实

1608
01:09:17,000 --> 01:09:18,000
之前

1609
01:09:18,000 --> 01:09:19,000
就一直在关注没想到

1610
01:09:20,000 --> 01:09:22,000
没想到就在那去节远了

1611
01:09:22,000 --> 01:09:26,000
哈哈哈这个还是挺机缘巧合的事

1612
01:09:26,000 --> 01:09:26,000
对对对

1613
01:09:27,000 --> 01:09:29,000
大家是多混这个社区会比较好

1614
01:09:29,000 --> 01:09:30,000
其实这圈子还是挺小的

1615
01:09:31,000 --> 01:09:31,000
OK

1616
01:09:31,000 --> 01:09:37,000
所以你们现在这么一个小五个人的这个开发团队啊你们这个工作模式大概是怎么样子的呢

1617
01:09:37,000 --> 01:09:39,000
我们现在的

1618
01:09:39,000 --> 01:09:41,000
工作模式大概就是

1619
01:09:41,000 --> 01:09:43,000
相当于我们五个开发

1620
01:09:43,000 --> 01:09:44,000
我的 developer

1621
01:09:44,000 --> 01:09:45,000
然后分布在

1622
01:09:46,000 --> 01:09:47,000
南京

1623
01:09:47,000 --> 01:09:48,000
上海

1624
01:09:48,000 --> 01:09:48,000
北京

1625
01:09:49,000 --> 01:09:51,000
然后其实是一个相当于 remotewalk 的

1626
01:09:52,000 --> 01:09:53,000
一个工作方式大家

1627
01:09:53,000 --> 01:09:54,000
平常沟通就是

1628
01:09:55,000 --> 01:09:56,000
Taggram

1629
01:09:56,000 --> 01:09:57,000
以及 Trainload 的一个

1630
01:09:58,000 --> 01:09:58,000
用方式

1631
01:09:59,000 --> 01:10:02,000
所以其实你们五个人并不是在一个地方

1632
01:10:02,000 --> 01:10:03,000
对不是在一个地方

1633
01:10:03,000 --> 01:10:04,000
然后你们都是在

1634
01:10:04,000 --> 01:10:07,000
那你们会在家里工作吗还是去到哪里办公

1635
01:10:08,000 --> 01:10:09,000
主要还是在家里办公

1636
01:10:09,000 --> 01:10:11,000
然后这样的话节省一些

1637
01:10:11,000 --> 01:10:12,000
交通上的

1638
01:10:12,000 --> 01:10:14,000
时间的成本吧

1639
01:10:14,000 --> 01:10:16,000
啊对对对这个好爽的因为

1640
01:10:16,000 --> 01:10:23,000
其实我知道每个人的可能最高效的时段是不一样的然后浪费在交通上的那些非常非常不爽的事情

1641
01:10:23,000 --> 01:10:27,000
对对对尤其像我在北京这种城市这么大然后

1642
01:10:28,000 --> 01:10:29,000
人几人

1643
01:10:29,000 --> 01:10:29,000
这种

1644
01:10:30,000 --> 01:10:32,000
真是有点难受

1645
01:10:32,000 --> 01:10:33,000
所有的

1646
01:10:33,000 --> 01:10:37,000
这个写代码的灵感和激情都磨灭在了公交车上

1647
01:10:37,000 --> 01:10:38,000
对对对

1648
01:10:38,000 --> 01:10:38,000
所以

1649
01:10:39,000 --> 01:10:39,000
呃当然

1650
01:10:40,000 --> 01:10:41,000
远程办公其实

1651
01:10:41,000 --> 01:10:44,000
是当然也是比较吸引我的一种方式

1652
01:10:44,000 --> 01:10:45,000
希望

1653
01:10:45,000 --> 01:10:45,000
能够

1654
01:10:46,000 --> 01:10:48,000
更更高效的去利用时间吧

1655
01:10:48,000 --> 01:10:49,000
OK

1656
01:10:49,000 --> 01:10:54,000
那所以你们五个人在这个远程工作中你刚才提到了有这个 telegram 这个用来

1657
01:10:55,000 --> 01:10:56,000
这个是群组聊天对吧

1658
01:10:57,000 --> 01:10:58,000
对然后还有一样那个是

1659
01:10:59,000 --> 01:11:00,000
哎是用那个什么工具来的

1660
01:11:00,000 --> 01:11:02,000
呃吹吹喽

1661
01:11:02,000 --> 01:11:02,000
吹吹

1662
01:11:03,000 --> 01:11:04,000
吹了吹了做那个协作

1663
01:11:05,000 --> 01:11:10,000
对协作对所以那你们像代码管理啊还是其他一些工具大概是会用到哪些呢

1664
01:11:11,000 --> 01:11:13,000
呃代码管理的话就是给他

1665
01:11:13,000 --> 01:11:13,000
OK

1666
01:11:14,000 --> 01:11:15,000
对然后我们之前是

1667
01:11:16,000 --> 01:11:18,000
呃发布之前是 private

1668
01:11:18,000 --> 01:11:21,000
瑞浦然后现在是公开了大家也可以

1669
01:11:21,000 --> 01:11:22,000
去我们

1670
01:11:22,000 --> 01:11:22,000
的

1671
01:11:23,000 --> 01:11:25,000
官网上以及去给他不得往夜上去

1672
01:11:25,000 --> 01:11:26,000
关注我们项目

1673
01:11:26,000 --> 01:11:27,000
多多点赞

1674
01:11:27,000 --> 01:11:28,000
OK

1675
01:11:28,000 --> 01:11:29,000
OK 那个

1676
01:11:29,000 --> 01:11:33,000
那个项目的地址还包括给他不得地址我们会稍后会放到这个宣传

1677
01:11:33,000 --> 01:11:34,000
你们大家就可以看好

1678
01:11:34,000 --> 01:11:37,000
这里可以其实可以接着聊一下就是

1679
01:11:37,000 --> 01:11:38,000
你们这个

1680
01:11:38,000 --> 01:11:42,000
这个在给他拍上面写作的模式你们是一个会是一个

1681
01:11:42,000 --> 01:11:44,000
大概是一个什么样过程的可以大概描述一下吗

1682
01:11:46,000 --> 01:11:53,000
目前的过程的就是相当于已经过往之前的蜂蜜开发的一个过程所以现在的

1683
01:11:53,000 --> 01:11:56,000
进进进派持的模式的还是跟

1684
01:11:57,000 --> 01:11:58,000
比较比较正

1685
01:11:59,000 --> 01:12:00,000
比较正规吧然后

1686
01:12:00,000 --> 01:12:02,000
有个派持的话是

1687
01:12:02,000 --> 01:12:02,000
提 PR

1688
01:12:03,000 --> 01:12:03,000
然后

1689
01:12:03,000 --> 01:12:04,000
两

1690
01:12:04,000 --> 01:12:08,000
一到两个人去留有如果没问题的话才

1691
01:12:08,000 --> 01:12:09,000
可以

1692
01:12:09,000 --> 01:12:10,000
莫执

1693
01:12:10,000 --> 01:12:11,000
这话就保证了质量

1694
01:12:12,000 --> 01:12:12,000
以及

1695
01:12:12,000 --> 01:12:13,000
效率

1696
01:12:14,000 --> 01:12:14,000
然后

1697
01:12:14,000 --> 01:12:16,000
会有一些第 3 方的工具

1698
01:12:18,000 --> 01:12:21,000
就是我们会写写了一些脚本当然没有

1699
01:12:21,000 --> 01:12:24,000
也在不断的完善过程中希望能够

1700
01:12:24,000 --> 01:12:25,000
在

1701
01:12:26,000 --> 01:12:27,000
有 PR 的时候

1702
01:12:27,000 --> 01:12:28,000
出发一些

1703
01:12:29,000 --> 01:12:30,000
自动化的检测的工具

1704
01:12:31,000 --> 01:12:34,000
OK 所以就大致来说就还是一个标准的一个

1705
01:12:34,000 --> 01:12:38,000
给他把开门项目的流程对对对对通过 PR 驱动这个

1706
01:12:38,000 --> 01:12:40,000
这个 feature 还有 8 个

1707
01:12:40,000 --> 01:12:41,000
然后进行

1708
01:12:42,000 --> 01:12:43,000
就别

1709
01:12:43,000 --> 01:12:45,000
经典的这个 code review

1710
01:12:45,000 --> 01:12:46,000
然后再买对

1711
01:12:46,000 --> 01:12:48,000
QA 这块你说你们是还没有

1712
01:12:48,000 --> 01:12:50,000
做完全自动化的 QA 是吧

1713
01:12:50,000 --> 01:12:55,000
对还没有做完全自动化的 QA 但是就是手动化的测试都会

1714
01:12:56,000 --> 01:12:57,000
都会做的是标配然后

1715
01:12:58,000 --> 01:12:59,000
因为

1716
01:12:59,000 --> 01:13:00,000
Go 本身做过

1717
01:13:00,000 --> 01:13:01,000
他有 unitize

1718
01:13:01,000 --> 01:13:04,000
所以这个的话因为当时开发时间比较紧

1719
01:13:04,000 --> 01:13:05,000
然后我们这个

1720
01:13:06,000 --> 01:13:09,000
有的一些 component 可能没有

1721
01:13:09,000 --> 01:13:11,000
太完善所以这个也在不断完善

1722
01:13:12,000 --> 01:13:18,000
就这个可能需要也就你们一个一方面你们自己努力啊另外就是看能不能开完社区能贡献一些

1723
01:13:18,000 --> 01:13:19,000
对对对

1724
01:13:19,000 --> 01:13:21,000
我们的人手实在是太少

1725
01:13:22,000 --> 01:13:23,000
有意思有意思

1726
01:13:24,000 --> 01:13:28,000
这里刚才你也提到了哈这个 hyper 跟 docker 一样都是基于用 Go 语言开发

1727
01:13:29,000 --> 01:13:29,000
开发的吗

1728
01:13:30,000 --> 01:13:32,000
当初你为什么选择用 Go 语言

1729
01:13:32,000 --> 01:13:35,000
我们之前选择的 Go 语言其实

1730
01:13:36,000 --> 01:13:37,000
也是

1731
01:13:37,000 --> 01:13:39,000
也是考虑到了

1732
01:13:39,000 --> 01:13:42,000
跟 docker 的一个关系因为

1733
01:13:43,000 --> 01:13:50,000
就抛开 Go 语言本身的一些特性比如并发呀他的高效的开发等等一些一些特性

1734
01:13:50,000 --> 01:13:51,000
另外一方面就是

1735
01:13:51,000 --> 01:13:55,000
我们其实最开始的版本是基于 docker demon 来做的

1736
01:13:55,000 --> 01:13:56,000
然后

1737
01:13:56,000 --> 01:13:56,000
因为

1738
01:13:57,000 --> 01:13:59,000
docker demon 会

1739
01:13:59,000 --> 01:14:03,000
因为我们用到 docker demon 去铺他的

1740
01:14:04,000 --> 01:14:08,000
docker 的 image 铺下来然后去

1741
01:14:09,000 --> 01:14:15,000
把这个文件全部传给 hypervisor 这个过程中的可能用 Go 语言直接跟

1742
01:14:15,000 --> 01:14:18,000
docker demon 去交互这样的话是更省事更简单

1743
01:14:20,000 --> 01:14:27,000
对所以但是随着后来我们移除了 docker demon 的一个依赖其实用

1744
01:14:27,000 --> 01:14:29,000
用其他语言当然

1745
01:14:29,000 --> 01:14:30,000
也可以就是

1746
01:14:30,000 --> 01:14:32,000
就是可能也历史原因问题就是我们

1747
01:14:32,000 --> 01:14:33,000
继续沿用了这个

1748
01:14:34,000 --> 01:14:34,000
Go 语言

1749
01:14:35,000 --> 01:14:35,000
OK

1750
01:14:35,000 --> 01:14:38,000
那所以其实你们在这个使用 Go

1751
01:14:38,000 --> 01:14:43,000
写这个 hyper 过程中你们遇到了什么样的问题或者什么心得可以分享吗

1752
01:14:44,000 --> 01:14:46,000
其实 Go 语言还是

1753
01:14:46,000 --> 01:14:49,000
从语法上还是有些坑的

1754
01:14:49,000 --> 01:14:50,000
比如说呢

1755
01:14:50,000 --> 01:14:51,000
比如说

1756
01:14:52,000 --> 01:14:54,000
写 Go 写时间长啊写 C 都

1757
01:14:54,000 --> 01:14:55,000
不加

1758
01:14:55,000 --> 01:14:55,000
分号

1759
01:14:56,000 --> 01:14:58,000
这个是好事

1760
01:14:59,000 --> 01:15:01,000
好吧

1761
01:15:01,000 --> 01:15:04,000
然后另外一些可能就是

1762
01:15:04,000 --> 01:15:05,000
本身 Go 语言

1763
01:15:05,000 --> 01:15:06,000
因为他

1764
01:15:06,000 --> 01:15:09,000
最近刚发布的是 1.6 吧

1765
01:15:09,000 --> 01:15:11,000
还是之前是 1.5

1766
01:15:11,000 --> 01:15:13,000
1.5 的一个版本

1767
01:15:13,000 --> 01:15:17,000
他其实有一些东西还是做的不够完善的

1768
01:15:18,000 --> 01:15:19,000
然后我们

1769
01:15:19,000 --> 01:15:20,000
这过程中也是

1770
01:15:20,000 --> 01:15:21,000
踩了不少坑然后

1771
01:15:22,000 --> 01:15:25,000
用其他方式去转换那可能效率上面不如那个

1772
01:15:25,000 --> 01:15:27,000
有优势但是这个可能就是

1773
01:15:27,000 --> 01:15:28,000
OS 相关的东西

1774
01:15:29,000 --> 01:15:30,000
比如在麦克上面的

1775
01:15:30,000 --> 01:15:32,000
的一些特性他够远

1776
01:15:32,000 --> 01:15:33,000
调用内核的一些东西还是什么

1777
01:15:34,000 --> 01:15:36,000
是 Syscall 的东西

1778
01:15:36,000 --> 01:15:37,000
OK

1779
01:15:37,000 --> 01:15:39,000
支持的不够完整

1780
01:15:39,000 --> 01:15:42,000
OK 然后所以就必须用其他一种更加

1781
01:15:43,000 --> 01:15:45,000
tricky 的方式去做

1782
01:15:45,000 --> 01:15:46,000
啊明白

1783
01:15:47,000 --> 01:15:47,000
对对对

1784
01:15:48,000 --> 01:15:51,000
所以其实像 hyper 除了用 Go 语言写大部分之外

1785
01:15:51,000 --> 01:15:57,000
你们还用到其他语言去编写其他一些小部分的功能吗还是说这个纯 Go 的一个项目

1786
01:15:57,000 --> 01:15:59,000
我们在

1787
01:15:59,000 --> 01:16:00,000
盖搜完色里面是

1788
01:16:00,000 --> 01:16:02,000
c 的东西

1789
01:16:02,000 --> 01:16:03,000
哦那部分是

1790
01:16:03,000 --> 01:16:07,000
我就需要做哪些工作是要用 c 来必须要用 c 来完成

1791
01:16:07,000 --> 01:16:12,000
其实也不是说必须要用 c 来完成只不过用 c 可能效率更快一点

1792
01:16:12,000 --> 01:16:13,000
盖搜完色里面

1793
01:16:13,000 --> 01:16:15,000
他其实就是一个

1794
01:16:15,000 --> 01:16:16,000
嗯

1795
01:16:16,000 --> 01:16:17,000
登

1796
01:16:17,000 --> 01:16:18,000
就是

1797
01:16:18,000 --> 01:16:20,000
相当于修改过的 init

1798
01:16:20,000 --> 01:16:21,000
init 的程序

1799
01:16:22,000 --> 01:16:25,000
然后他是可以解析 JSON 格式因为他这样

1800
01:16:26,000 --> 01:16:27,000
这样的话是通过 JSON

1801
01:16:27,000 --> 01:16:29,000
的那个

1802
01:16:29,000 --> 01:16:30,000
信消息来跟

1803
01:16:31,000 --> 01:16:32,000
hyper daemon 去交互

1804
01:16:33,000 --> 01:16:37,000
啊达到一个传输数据或者是通信的效果

1805
01:16:37,000 --> 01:16:42,000
哎这个有点意思啊就是你们这个 gast os 里面还有一个自己定义的 init 程序

1806
01:16:42,000 --> 01:16:44,000
这个好像现在

1807
01:16:44,000 --> 01:16:45,000
好像比较常见的

1808
01:16:46,000 --> 01:16:47,000
systemd 对吧

1809
01:16:47,000 --> 01:16:49,000
会比较重吗什么原因

1810
01:16:49,000 --> 01:16:51,000
对可能速度

1811
01:16:51,000 --> 01:16:51,000
比较快吧

1812
01:16:52,000 --> 01:16:54,000
速度比

1813
01:16:54,000 --> 01:16:56,000
那个就比较重然后我们这

1814
01:16:56,000 --> 01:16:57,000
用启动速度会很

1815
01:16:58,000 --> 01:16:58,000
很慢

1816
01:16:59,000 --> 01:17:00,000
然后 ok

1817
01:17:00,000 --> 01:17:02,000
我们当时测的时候大概

1818
01:17:03,000 --> 01:17:03,000
十几兆货

1819
01:17:04,000 --> 01:17:06,000
应该是二十几兆的那个空

1820
01:17:06,000 --> 01:17:07,000
的

1821
01:17:07,000 --> 01:17:08,000
memory 就够了

1822
01:17:08,000 --> 01:17:09,000
ok

1823
01:17:09,000 --> 01:17:12,000
对所以就足够的精简足够的小

1824
01:17:12,000 --> 01:17:18,000
就是现在一个 hyper 的 gast vm 用你们自定义这套东西就 20 兆就可以起一个了对吧

1825
01:17:18,000 --> 01:17:19,000
对应该是 20 多兆

1826
01:17:19,000 --> 01:17:20,000
10 兆是不够的

1827
01:17:21,000 --> 01:17:27,000
相对于很多这个什么特别是他跑他们 tomcat 这些家伙也有一上来的一两个机的那层站

1828
01:17:27,000 --> 01:17:29,000
对这个但是我们说的

1829
01:17:29,000 --> 01:17:31,000
那是一个最最最简模式对对对如果就是

1830
01:17:32,000 --> 01:17:32,000
这是一个就是

1831
01:17:33,000 --> 01:17:37,000
我就说这种一二十大的开销基本上可以在现代机上可以忽略了吧

1832
01:17:37,000 --> 01:17:39,000
对对对那还是挺好

1833
01:17:39,000 --> 01:17:40,000
嗯

1834
01:17:40,000 --> 01:17:41,000
最最后补充的就是希望

1835
01:17:42,000 --> 01:17:44,000
大家有至于加入我们还不像

1836
01:17:44,000 --> 01:17:46,000
能够多多为我们

1837
01:17:46,000 --> 01:17:46,000
提

1838
01:17:47,000 --> 01:17:51,000
PR 我们也会非常也会非常积极的反馈如果

1839
01:17:52,000 --> 01:17:56,000
有同学 tpr 或者说被我们接受的话我们

1840
01:17:56,000 --> 01:17:58,000
在初期前 100 人

1841
01:17:58,000 --> 01:18:00,000
应该会提供

1842
01:18:00,000 --> 01:18:00,000
提讯

1843
01:18:00,000 --> 01:18:01,000
作为奖励

1844
01:18:01,000 --> 01:18:04,000
就是我就是之前瑞欧之前在

1845
01:18:04,000 --> 01:18:05,000
推特上面

1846
01:18:05,000 --> 01:18:06,000
穿过的那个提讯

1847
01:18:09,000 --> 01:18:11,000
那个之前我在北京跟

1848
01:18:11,000 --> 01:18:12,000
跟三门

1849
01:18:12,000 --> 01:18:13,000
见面面聊过

1850
01:18:14,000 --> 01:18:16,000
然后非常厚颜无耻的要了一件

1851
01:18:18,000 --> 01:18:20,000
这个也是感谢瑞欧帮我们

1852
01:18:21,000 --> 01:18:23,000
去大力的宣传然后也是希望能更多的开发者

1853
01:18:24,000 --> 01:18:25,000
去接触到开源社区

1854
01:18:26,000 --> 01:18:27,000
接触到开源项目

1855
01:18:27,000 --> 01:18:28,000
然后

1856
01:18:28,000 --> 01:18:29,000
更多

1857
01:18:29,000 --> 01:18:29,000
更

1858
01:18:30,000 --> 01:18:30,000
更

1859
01:18:31,000 --> 01:18:35,000
就是怎么说的就是一个提升一个自身素质加一个

1860
01:18:35,000 --> 01:18:37,000
个写代码工艺的一个水平

1861
01:18:38,000 --> 01:18:39,000
啊对对非常感谢

1862
01:18:40,000 --> 01:18:40,000
其实

1863
01:18:40,000 --> 01:18:44,000
因为这次我要请三门来做这节目也是因为我觉得

1864
01:18:44,000 --> 01:18:46,000
还本是我见过的就是国人

1865
01:18:46,000 --> 01:18:48,000
做的这个开源项目里面

1866
01:18:48,000 --> 01:18:50,000
还比较让我惊艳的一个吗

1867
01:18:51,000 --> 01:18:51,000
所以我也希望

1868
01:18:51,000 --> 01:18:52,000
这次的机会

1869
01:18:52,000 --> 01:18:54,000
让邀请到就让他

1870
01:18:54,000 --> 01:18:57,000
让更多人了解他知道他然后能够去参与到这个开发

1871
01:18:58,000 --> 01:19:00,000
让我们这个中国的开销能够

1872
01:19:00,000 --> 01:19:01,000
有一个

1873
01:19:01,000 --> 01:19:02,000
好的这个一个

1874
01:19:04,000 --> 01:19:05,000
上涨的趋势吧

1875
01:19:05,000 --> 01:19:07,000
对然后另外一点

1876
01:19:07,000 --> 01:19:09,000
如果大家不

1877
01:19:10,000 --> 01:19:12,000
不觉得 tpr 不爽的话也是非常希望

1878
01:19:12,000 --> 01:19:14,000
大家能够加入到我们团队

1879
01:19:14,000 --> 01:19:16,000
团队也是拥有

1880
01:19:17,000 --> 01:19:18,000
非常多的牛人

1881
01:19:18,000 --> 01:19:20,000
然后多年的

1882
01:19:20,000 --> 01:19:21,000
Currenal 的工程师

1883
01:19:21,000 --> 01:19:22,000
以及

1884
01:19:23,000 --> 01:19:25,000
特别资深的 consultant

1885
01:19:25,000 --> 01:19:27,000
都都都在我们团队所以

1886
01:19:28,000 --> 01:19:29,000
如果大家

1887
01:19:29,000 --> 01:19:31,000
有一技之长或者说

1888
01:19:31,000 --> 01:19:35,000
有志于做 hyper stack hyper 项目

1889
01:19:35,000 --> 01:19:36,000
希望大家能够

1890
01:19:37,000 --> 01:19:37,000
积极给我们

1891
01:19:38,000 --> 01:19:38,000
提

1892
01:19:39,000 --> 01:19:41,000
tpr 或者是发简历

1893
01:19:41,000 --> 01:19:42,000
谢谢

1894
01:19:42,000 --> 01:19:44,000
想不到 B 节目还做了一个猎头的工作

1895
01:19:46,000 --> 01:19:48,000
非常好玩

1896
01:19:49,000 --> 01:19:54,000
OK 今天的节目就先到这里感谢收听 IPM podcast 网络之下的 IT 技术

1897
01:19:54,000 --> 01:19:56,000
主题娱乐节目内核恐慌

1898
01:19:56,000 --> 01:19:57,000
我们号称 hardcore

1899
01:19:58,000 --> 01:19:59,000
虽然也没有干货

1900
01:19:59,000 --> 01:20:00,000
但是这期干货还是满满的

1901
01:20:01,000 --> 01:20:03,000
想听的人听不想听的人就别听

1902
01:20:03,000 --> 01:20:05,000
你可以问本节目捐款

1903
01:20:05,000 --> 01:20:07,000
捐款地址是 ipn.li

1904
01:20:07,000 --> 01:20:08,000
slash kernelpanic

1905
01:20:08,000 --> 01:20:09,000
slash donate

1906
01:20:10,000 --> 01:20:11,000
捐款金额随意

1907
01:20:11,000 --> 01:20:13,000
只要是能够 8 整出的正整数就可以

1908
01:20:13,000 --> 01:20:17,000
捐款不会给你带来什么不捐也不会让你失去什么

1909
01:20:17,000 --> 01:20:19,000
我们的口号是 hyper is hyper awesome

1910
01:20:20,000 --> 01:20:21,000
如果你有任何反馈

1911
01:20:21,000 --> 01:20:23,000
可以发电子邮件到 kernelpanic

1912
01:20:24,000 --> 01:20:25,000
at ipn.li

1913
01:20:26,000 --> 01:20:27,000
同时也欢迎你收听 ipn

1914
01:20:28,000 --> 01:20:29,000
其他几档节目

1915
01:20:30,000 --> 01:20:30,000
IT 公论

1916
01:20:31,000 --> 01:20:31,000
物业之道

1917
01:20:31,000 --> 01:20:32,000
太一来了

1918
01:20:32,000 --> 01:20:33,000
流行通信

1919
01:20:33,000 --> 01:20:34,000
high story

1920
01:20:35,000 --> 01:20:35,000
博物志

1921
01:20:36,000 --> 01:20:36,000
选美

1922
01:20:36,000 --> 01:20:37,000
我们下期再会

