1
00:00:00,000 --> 00:00:02,000
大家好 欢迎收听第十期的内核恐慌

2
00:00:02,000 --> 00:00:03,000
我是 Rio

3
00:00:03,000 --> 00:00:04,000
我是吴涛

4
00:00:04,000 --> 00:00:07,000
今天我们请到了一位嘉宾

5
00:00:07,000 --> 00:00:09,000
他叫 Willow

6
00:00:09,000 --> 00:00:10,000
为了跟大家打个招呼

7
00:00:10,000 --> 00:00:12,000
大家好 我是 Willow

8
00:00:12,000 --> 00:00:17,000
又可以跟 Rio 和吴涛插科打魂

9
00:00:17,000 --> 00:00:17,000
非常开心

10
00:00:17,000 --> 00:00:20,000
为什么要说又呢

11
00:00:20,000 --> 00:00:24,000
就是如果大家听过我主持的另外一档节目

12
00:00:24,000 --> 00:00:24,000
IT 功能的话

13
00:00:24,000 --> 00:00:27,000
就知道 Willow 已经在那边做过两三次的嘉宾了

14
00:00:27,000 --> 00:00:31,000
可是我好像没有和 Willow 直接上过

15
00:00:31,000 --> 00:00:33,000
对

16
00:00:33,000 --> 00:00:35,000
对 我们没有上过

17
00:00:35,000 --> 00:00:37,000
你们没有上过

18
00:00:37,000 --> 00:00:40,000
不要一开始就这么 A 嘛

19
00:00:40,000 --> 00:00:44,000
不过其实这是我们内核恐慌这期节目

20
00:00:44,000 --> 00:00:45,000
第一次邀请嘉宾吧

21
00:00:45,000 --> 00:00:45,000
对

22
00:00:45,000 --> 00:00:48,000
之前曾经邀请过一位嘉宾

23
00:00:48,000 --> 00:00:49,000
后来被 IT 功能抢走了

24
00:00:49,000 --> 00:00:51,000
没错 就是王朝年

25
00:00:51,000 --> 00:00:54,000
所以 Willow 你也是我们的处女嘉宾

26
00:00:54,000 --> 00:00:55,000
非常荣幸

27
00:00:55,000 --> 00:00:55,000
非常

28
00:00:55,000 --> 00:00:56,000
不知道

29
00:00:56,000 --> 00:00:57,000
我不知道

30
00:00:57,000 --> 00:00:58,000
我刚刚说到的处女吧

31
00:00:58,000 --> 00:00:59,000
但是

32
00:00:59,000 --> 00:00:59,000
但是

33
00:00:59,000 --> 00:01:00,000
但是

34
00:01:00,000 --> 00:01:00,000
我感谢

35
00:01:00,000 --> 00:01:07,000
今天请 Willow 来是要聊一件跟前端开发有关的事情

36
00:01:07,000 --> 00:01:10,000
因为刚好 Willow 最近应该是前天吧

37
00:01:10,000 --> 00:01:11,000
前天和上前天对吧

38
00:01:11,000 --> 00:01:12,000
上前天

39
00:01:12,000 --> 00:01:13,000
28 号 29 号

40
00:01:13,000 --> 00:01:13,000
应该是

41
00:01:13,000 --> 00:01:14,000
对

42
00:01:14,000 --> 00:01:17,000
然后去参加了 Facebook 搞的

43
00:01:17,000 --> 00:01:18,000
现在已经不算是 Facebook

44
00:01:18,000 --> 00:01:19,000
他们已经独立出来了吗

45
00:01:19,000 --> 00:01:20,000
还是怎么样

46
00:01:20,000 --> 00:01:21,000
还是 Facebook

47
00:01:21,000 --> 00:01:21,000
都是 Facebook

48
00:01:21,000 --> 00:01:22,000
还是 Facebook

49
00:01:22,000 --> 00:01:23,000
OK

50
00:01:23,000 --> 00:01:26,000
就是 Facebook 他们有一个开发者的小型的一个会议吧

51
00:01:26,000 --> 00:01:27,000
是讲一个

52
00:01:27,000 --> 00:01:30,000
叫做 react 这么一个这个前端开发的技术

53
00:01:30,000 --> 00:01:34,000
然后刚好 Willow 去了现场参加了两天的会议呢

54
00:01:34,000 --> 00:01:38,000
然后我们就趁着打铁邀请他来跟我们分享一下他所见所闻吧

55
00:01:38,000 --> 00:01:38,000
对

56
00:01:38,000 --> 00:01:41,000
其实 Willow 你是为什么可以去参加

57
00:01:41,000 --> 00:01:45,000
或者说你是出于什么样的动机去参加 reactJS 的 conference 呢

58
00:01:46,000 --> 00:01:50,000
如果你看前端开发的发展的话

59
00:01:50,000 --> 00:01:51,000
你会发现

60
00:01:52,000 --> 00:01:55,000
去年和前年是非常激动的两年

61
00:01:55,000 --> 00:01:55,000
因为我们

62
00:01:55,000 --> 00:01:56,000
嗯

63
00:01:56,000 --> 00:01:56,000
嗯

64
00:01:56,000 --> 00:01:56,000
嗯

65
00:01:56,000 --> 00:01:57,000
嗯

67
00:02:27,000 --> 00:02:34,000
我们自己公司去年在考虑新的技术的时候

68
00:02:34,000 --> 00:02:38,000
把 React 纳入了我们想要使用的范围

69
00:02:38,000 --> 00:02:42,000
在过去的六到八个月

70
00:02:42,000 --> 00:02:49,000
我们都有在积极地把以前的东西给转移到 React 上

71
00:02:49,000 --> 00:02:51,000
我们之前是写了一个 Backbone App

72
00:02:51,000 --> 00:02:56,000
然后我们现在在 Migrate 它去 React

73
00:02:56,000 --> 00:02:58,000
作为一个 React 开发者本身

74
00:02:58,000 --> 00:03:02,000
然后再作为一个技术的爱好者

75
00:03:02,000 --> 00:03:05,000
我也觉得非常荣幸有机会去 React Comp

76
00:03:05,000 --> 00:03:11,000
去这个 Community 看最新的东西

77
00:03:11,000 --> 00:03:15,000
然后从其他人身上学到一些东西

78
00:03:15,000 --> 00:03:15,000
OK

79
00:03:15,000 --> 00:03:20,000
你刚才提到说整个 App 要从 Backbone 迁移到 React 上面

80
00:03:20,000 --> 00:03:22,000
待会我们也可以讲一下整个迁移过程

81
00:03:22,000 --> 00:03:25,000
是不是的痛苦程度有多少

82
00:03:25,000 --> 00:03:26,000
对

83
00:03:26,000 --> 00:03:26,000
没问题

84
00:03:26,000 --> 00:03:29,000
其实是一个非常有意思的一个过程

85
00:03:29,000 --> 00:03:34,000
相对于像 Angular 这样的庞大的 Framework 来说

86
00:03:34,000 --> 00:03:36,000
React 实际上非常的轻巧

87
00:03:36,000 --> 00:03:42,000
然后正是因此这个 Migration 没有很多人想象的会那么痛苦

88
00:03:42,000 --> 00:03:45,000
我们非常非常享受这个过程

89
00:03:45,000 --> 00:03:46,000
我忘了介绍了

90
00:03:46,000 --> 00:03:48,000
我们自己都很熟悉了

91
00:03:48,000 --> 00:03:49,000
但是忘了给有些听众朋友

92
00:03:49,000 --> 00:03:53,000
可能还第一次听到 Velo 的声音的话

93
00:03:53,000 --> 00:03:55,000
Velo 你还要先介绍一下自己

94
00:03:55,000 --> 00:03:55,000
好

95
00:03:55,000 --> 00:03:55,000
好

96
00:03:55,000 --> 00:03:59,000
,你是在湾区的左前端开发对吧

97
00:03:59,000 --> 00:04:00,000
OK

98
00:04:00,000 --> 00:04:05,000
我在 IT 公论的时候也没有介绍自己

99
00:04:05,000 --> 00:04:12,000
对,我觉得不知道 Velo 是谁的听众们可以回去听 IT 公论

100
00:04:12,000 --> 00:04:14,000
第一期是有介绍的

101
00:04:14,000 --> 00:04:20,000
我是我在湾区生活了三年

102
00:04:20,000 --> 00:04:23,000
然后我一直在这家叫做 Backbone

103
00:04:23,000 --> 00:04:24,000
对不起

104
00:04:24,000 --> 00:04:24,000
对不起

105
00:04:24,000 --> 00:04:26,000
我在湾区生活了三年

106
00:04:26,000 --> 00:04:32,000
然后一直在一家叫做 Backplane 的公司做 software engineer

107
00:04:32,000 --> 00:04:35,000
我很 focus 在前端开发上

108
00:04:35,000 --> 00:04:41,000
然后我要给你们公司做什么负面宣传的答应

109
00:04:41,000 --> 00:04:46,000
就是 Backplane 这家可能在外界最知名的就是什么他的投资人对吧

110
00:04:46,000 --> 00:04:47,000
Whatever

111
00:04:47,000 --> 00:04:49,000
Let's save that for later

112
00:04:49,000 --> 00:04:50,000
OK

113
00:04:50,000 --> 00:04:52,000
What are we doing recently is very exciting

114
00:04:52,000 --> 00:04:53,000
I'm just saying

115
00:04:53,000 --> 00:04:53,000
OK

116
00:04:53,000 --> 00:04:54,000
投资人是谁?

117
00:04:54,000 --> 00:04:56,000
Lady Gaga 还是?

118
00:04:56,000 --> 00:04:58,000
对没错

119
00:04:58,000 --> 00:05:01,000
可以帮我要一个签名吗?

120
00:05:01,000 --> 00:05:05,000
他只是小股东嘛

121
00:05:05,000 --> 00:05:08,000
签名他签我脸上了

122
00:05:08,000 --> 00:05:09,000
他亲了我

123
00:05:09,000 --> 00:05:13,000
下次你来亲我一下

124
00:05:13,000 --> 00:05:16,000
下次他来你亲他一下

125
00:05:16,000 --> 00:05:18,000
这样你就和 Lady Gaga 亲上了

126
00:05:18,000 --> 00:05:19,000
OK

127
00:05:19,000 --> 00:05:21,000
多机智的一个方法

128
00:05:21,000 --> 00:05:24,000
对所以说回来

129
00:05:24,000 --> 00:05:29,000
所以 Velo 是一个在湾区工作的软件开发者

130
00:05:29,000 --> 00:05:33,000
然后 Velo 最有名的一个作品是

131
00:05:33,000 --> 00:05:38,000
或者说如果你跟 Velo 曾经产生过什么交集的话

132
00:05:38,000 --> 00:05:40,000
也许是你用过他写的一个插件

133
00:05:40,000 --> 00:05:42,000
叫做 WhatFonts

134
00:05:42,000 --> 00:05:47,000
就是用来检测网页上某一部分被显示出来的文字

135
00:05:47,000 --> 00:05:51,000
所实际采用的字体的插件

136
00:05:51,000 --> 00:05:54,000
我们之前有一期 IT 公论探讨完

137
00:05:54,000 --> 00:05:56,000
那个产品如果大家有兴趣的话

138
00:05:56,000 --> 00:05:59,000
可以回头听那个 podcast

139
00:05:59,000 --> 00:06:02,000
这个产品已经在上线很多年了

140
00:06:02,000 --> 00:06:08,000
所以说我也很期待能够有新的作品拿出来给大家用

141
00:06:08,000 --> 00:06:12,000
然后我也在积极的做这方面的工作

142
00:06:12,000 --> 00:06:14,000
很好

143
00:06:14,000 --> 00:06:18,000
所以你看 Velo 在湾区就有比较方便的这种机会

144
00:06:18,000 --> 00:06:23,000
去参加到各种各样比较高大上的技术会议

145
00:06:23,000 --> 00:06:25,000
这话不在湾区其实真的蛮难的

146
00:06:25,000 --> 00:06:31,000
就像欧洲很多 conference 都是在各个城市晃来晃去

147
00:06:31,000 --> 00:06:33,000
它很少会有这种

148
00:06:33,000 --> 00:06:35,000
扎堆的现象

149
00:06:35,000 --> 00:06:40,000
比如说 REACJS Europe conference 将在 7 月份举行

150
00:06:40,000 --> 00:06:43,000
在欧洲巴黎

151
00:06:43,000 --> 00:06:49,000
然后 PYCON Europe 更是每一年都要换一个城市

152
00:06:49,000 --> 00:06:51,000
然后去年应该是在阿姆斯特丹吧

153
00:06:51,000 --> 00:06:52,000
我没记错吧

154
00:06:53,000 --> 00:06:54,000
还好啊

155
00:06:54,000 --> 00:06:55,000
欧洲交通方便嘛

156
00:06:55,000 --> 00:06:56,000
我不觉得

157
00:06:56,000 --> 00:06:58,000
是吗

158
00:06:58,000 --> 00:06:59,000
我觉得还可以

159
00:06:59,000 --> 00:07:03,000
不管去哪都要订机票

160
00:07:03,000 --> 00:07:08,000
然后可能要去上那个国家的网站买火车票什么的

161
00:07:08,000 --> 00:07:09,000
就很麻烦

162
00:07:09,000 --> 00:07:10,000
不像

163
00:07:10,000 --> 00:07:13,000
离欧洲大一统的理想还比较远

164
00:07:13,000 --> 00:07:19,000
之所以 REACJS Conf 在欧洲会在巴黎是因为

165
00:07:19,000 --> 00:07:23,000
那个主开发者之一那个人叫什么 Christopher

166
00:07:23,000 --> 00:07:25,000
他是法国人吗

167
00:07:25,000 --> 00:07:26,000
对

168
00:07:26,000 --> 00:07:31,000
他讲英语的时候有非常强的那个法国口音

169
00:07:31,000 --> 00:07:33,000
我还专门去查了他是哪个人

170
00:07:33,000 --> 00:07:34,000
我没有黑色的

171
00:07:34,000 --> 00:07:36,000
他最后的名字是 Chateau

172
00:07:36,000 --> 00:07:38,000
这个很明显了

173
00:07:38,000 --> 00:07:39,000
那挺好的

174
00:07:39,000 --> 00:07:42,000
就是我这也反映一个很大家很开放的态度

175
00:07:42,000 --> 00:07:44,000
其实我说英语也有口音啊

176
00:07:44,000 --> 00:07:47,000
但是这个并不会成为不影响工作的

177
00:07:47,000 --> 00:07:51,000
所以我也很看到他能够

178
00:07:51,000 --> 00:07:56,000
看到他能够 host 这个 conference 也是 validate

179
00:07:56,000 --> 00:07:59,000
大家都能这个英语这个事情不是那么重要嘛

180
00:07:59,000 --> 00:08:01,000
所以是一个很好的事情

181
00:08:01,000 --> 00:08:02,000
嗯嗯

182
00:08:02,000 --> 00:08:06,000
其实 VLOG 在我们三个人里面已经是最没口音的一个了

183
00:08:06,000 --> 00:08:07,000
对啊

184
00:08:07,000 --> 00:08:11,000
摸爬滚打到最久的

185
00:08:11,000 --> 00:08:15,000
anyway 回到这个正题吧

186
00:08:15,000 --> 00:08:19,000
就说其实我们可以先回顾一下在 REAC 之前的那些框架

187
00:08:19,000 --> 00:08:20,000
会有一些什么样的

188
00:08:20,000 --> 00:08:22,000
就有些什么样的选择

189
00:08:22,000 --> 00:08:23,000
会有什么样的问题吧

190
00:08:23,000 --> 00:08:26,000
就为了你们之前是用这个 backbound 对吧

191
00:08:26,000 --> 00:08:27,000
对没错

192
00:08:27,000 --> 00:08:29,000
你们在实际使用中的话

193
00:08:29,000 --> 00:08:32,000
就是刚才你也提到你们在往这个 REAC 迁移嘛

194
00:08:32,000 --> 00:08:35,000
那么就那你们就是说在 backbound 的实际使用中

195
00:08:35,000 --> 00:08:36,000
遇到一些什么样的问题

196
00:08:36,000 --> 00:08:40,000
然后迁移到 REAC 会比较好的解决呢

197
00:08:40,000 --> 00:08:41,000
嗯

198
00:08:41,000 --> 00:08:43,000
有两方面的问题啊

199
00:08:43,000 --> 00:08:45,000
一方面是在

200
00:08:45,000 --> 00:08:47,000
在 engineering 方面会问到一些

201
00:08:47,000 --> 00:08:48,000
遇到一些问题

202
00:08:48,000 --> 00:08:50,000
然后你在 production 方面

203
00:08:50,000 --> 00:08:52,000
在 production 上会遇到一些问题

204
00:08:52,000 --> 00:08:54,000
production 上的问题其实蛮简单的

205
00:08:54,000 --> 00:08:55,000
就是 performance

206
00:08:55,000 --> 00:08:59,000
这个一个 framework 它到底能有多快

207
00:08:59,000 --> 00:09:00,000
渲染的多快

208
00:09:00,000 --> 00:09:04,000
交互能力这些东西是非常好客观评价的

209
00:09:04,000 --> 00:09:12,000
然后如果上网搜的话会看到很多负面的关于 backbound 的一些评测显示

210
00:09:12,000 --> 00:09:15,000
然后我们自己在 production 上也遇到了这些问题

211
00:09:15,000 --> 00:09:17,000
我们网站并不算快

212
00:09:17,000 --> 00:09:20,000
然后在 memory 上也非常难

213
00:09:20,000 --> 00:09:24,000
这个 memory 呢实际上是跨了这个 production and engineering

214
00:09:24,000 --> 00:09:28,000
因为 backbound 的 memory management

215
00:09:28,000 --> 00:09:34,000
就好像你在原来做 ios 开发是那个你要 manually return things

216
00:09:34,000 --> 00:09:37,000
手工管理那一层

217
00:09:37,000 --> 00:09:41,000
所以非常容易出现 memory leak

218
00:09:41,000 --> 00:09:44,000
那整个程序既在 render 上会卖

219
00:09:44,000 --> 00:09:46,000
然后在 memory 上会 leak 的话

220
00:09:46,000 --> 00:09:49,000
那你的 performance 就非常不乐观是不是

221
00:09:49,000 --> 00:09:51,000
就是 production 上的问题

222
00:09:51,000 --> 00:09:53,000
engineering 上的问题呢在于

223
00:09:53,000 --> 00:09:58,000
关键对于我们来说是代码的可重用性和可管理性

224
00:09:58,000 --> 00:10:05,000
在重用性上的问题主要来说就是 view 的重用性

225
00:10:05,000 --> 00:10:10,000
实际上要重用一个 view 在 backbound 中其实蛮复杂的

226
00:10:10,000 --> 00:10:13,000
因为你要在那个 view 里面

227
00:10:13,000 --> 00:10:19,000
在你的 template 里面给这个 subview 腾出一个空间

228
00:10:19,000 --> 00:10:21,000
选一个 container

229
00:10:21,000 --> 00:10:27,000
然后在你的 render function 中要 initialize 那个 subview

230
00:10:27,000 --> 00:10:29,000
然后把 subview 切进来

231
00:10:29,000 --> 00:10:34,000
这一系列过程对于开发者来说还是一个蛮头痛的事情

232
00:10:34,000 --> 00:10:37,000
所以正因为如此呢

233
00:10:37,000 --> 00:10:41,000
你会看到很多人不会去重用

234
00:10:41,000 --> 00:10:45,000
在代码的可管理下的关键呢是

235
00:10:45,000 --> 00:10:48,000
其实 view 它本身并不

236
00:10:49,000 --> 00:10:52,000
管理它所有的 state

237
00:10:52,000 --> 00:10:55,000
很大一部分程度上 state 是在 dom 里头的

238
00:10:55,000 --> 00:10:57,000
你知道我们有时候 utilize class

239
00:10:57,000 --> 00:10:59,000
utilize data props

240
00:10:59,000 --> 00:11:04,000
这样的 dom 的 element 去管理你 view 的 state

241
00:11:04,000 --> 00:11:08,000
就导致呢在大家看这个 view 的时候

242
00:11:08,000 --> 00:11:09,000
并看不到全貌

243
00:11:09,000 --> 00:11:11,000
不知道这个 view 到底能够做什么事情

244
00:11:11,000 --> 00:11:12,000
会做什么事情

245
00:11:12,000 --> 00:11:16,000
其实你在看那个 view 的时候是很难看出来的

246
00:11:16,000 --> 00:11:19,000
这就在多人合作

247
00:11:19,000 --> 00:11:20,000
合作的项目上

248
00:11:20,000 --> 00:11:24,000
或者是说你返回到你多年之前写 dive 的时候

249
00:11:24,000 --> 00:11:26,000
就会是一个很大的问题

250
00:11:26,000 --> 00:11:31,000
这是我们用 backbone 两三年的时间里

251
00:11:31,000 --> 00:11:33,000
所遇到两个方面的问题

252
00:11:33,000 --> 00:11:37,000
我觉得这可能跟那个 backbone 的设计理念有关系

253
00:11:37,000 --> 00:11:40,000
backbone 毕竟它强调的是

254
00:11:40,000 --> 00:11:42,000
它所提供的功能

255
00:11:42,000 --> 00:11:47,000
只是最基本最 backbone 的那一部分

256
00:11:47,000 --> 00:11:48,000
所以

257
00:11:48,000 --> 00:11:53,000
你可能不得不在很多地方要显示的去

258
00:11:53,000 --> 00:11:56,000
去宣告一些东西

259
00:11:56,000 --> 00:11:58,000
然后你需要告诉

260
00:11:58,000 --> 00:12:01,000
你需要显示的把逻辑写出来

261
00:12:01,000 --> 00:12:03,000
而如果你需要显示的写出来的话

262
00:12:03,000 --> 00:12:06,000
那每个人写的逻辑可能会不一样

263
00:12:06,000 --> 00:12:08,000
你说你

264
00:12:08,000 --> 00:12:10,000
这确实是一方面的问题

265
00:12:10,000 --> 00:12:12,000
对你说你直接看

266
00:12:12,000 --> 00:12:14,000
无法直接看到 view 想要干什么呢

267
00:12:14,000 --> 00:12:16,000
其实原因之一也就是

268
00:12:16,000 --> 00:12:18,000
它没有一个 default 的

269
00:12:18,000 --> 00:12:20,000
的 behavior

270
00:12:20,000 --> 00:12:22,000
可以让你去

271
00:12:22,000 --> 00:12:25,000
可以一眼让你猜到它要干什么

272
00:12:25,000 --> 00:12:30,000
backbone 既好又导致这个问题的一方面就是

273
00:12:30,000 --> 00:12:33,000
它不是很 opinionated

274
00:12:33,000 --> 00:12:37,000
我们确实在总结我们的 backbone 的经验的时候

275
00:12:37,000 --> 00:12:38,000
有提到这点

276
00:12:38,000 --> 00:12:41,000
在一个团队写作的范围中

277
00:12:41,000 --> 00:12:44,000
不 opinionated 实际上是一个很麻烦的事情

278
00:12:44,000 --> 00:12:47,000
因为大家可能写东西会用不同的方式

279
00:12:47,000 --> 00:12:49,000
也不是说各种方式

280
00:12:49,000 --> 00:12:50,000
哪个好哪个坏

281
00:12:50,000 --> 00:12:55,000
关键是写作上来说有相同的 mental model

282
00:12:55,000 --> 00:12:57,000
会更方便一点

283
00:12:57,000 --> 00:12:59,000
不管好坏只要一样的话

284
00:12:59,000 --> 00:13:02,000
维护起来的成本可能也不是维护起来的成本

285
00:13:02,000 --> 00:13:04,000
就是沟通起来的成本会小一些

286
00:13:04,000 --> 00:13:07,000
如果你用 amber js 或者是 angular 之类的

287
00:13:07,000 --> 00:13:12,000
比较有自己的一套使用哲学的框架的话

288
00:13:12,000 --> 00:13:16,000
你会比较有一个大致的概念

289
00:13:16,000 --> 00:13:20,000
就是这件事情怎样做才是符合这个框架的理念的

290
00:13:20,000 --> 00:13:22,000
但是 backbone 则比较平淡

291
00:13:22,000 --> 00:13:25,000
或者说比较给了你太多自由权

292
00:13:25,000 --> 00:13:28,000
然后就会导致会有沟通上面的问题

293
00:13:28,000 --> 00:13:29,000
我是觉得

294
00:13:29,000 --> 00:13:32,000
确实有这样的因素在

295
00:13:32,000 --> 00:13:36,000
可是当我们在看就是像 amber 这样的 framework 的时候

296
00:13:36,000 --> 00:13:40,000
它相对于 backbone 是一个比较小的递进

297
00:13:40,000 --> 00:13:41,000
对我们来说

298
00:13:41,000 --> 00:13:44,000
确实它在 backbone 的每一个方面

299
00:13:44,000 --> 00:13:45,000
backbone 所设计的每一个方面

300
00:13:45,000 --> 00:13:48,000
不管是 router 还是 view templating

301
00:13:48,000 --> 00:13:50,000
它都有相当大的进步

302
00:13:50,000 --> 00:13:52,000
however 它所 fundamentally

303
00:13:52,000 --> 00:13:57,000
它们的框架的理念 mvc 的理念是完全一致的

304
00:13:57,000 --> 00:14:03,000
这也是为什么我们在考虑更新我们的 framework 的时候

305
00:14:03,000 --> 00:14:07,000
并没有做太对 amber 并没有做太多的考虑

306
00:14:07,000 --> 00:14:11,000
因为如果你计算时间的

307
00:14:11,000 --> 00:14:12,000
对 exactly

308
00:14:12,000 --> 00:14:15,000
从一种 mvc 换到另一种 mvc

309
00:14:15,000 --> 00:14:17,000
只不过另外一个 mvc 更重量级一点

310
00:14:17,000 --> 00:14:19,000
更 opinion 的一点

311
00:14:19,000 --> 00:14:20,000
没错

312
00:14:20,000 --> 00:14:22,000
ok

313
00:14:22,000 --> 00:14:24,000
所以刚才为了你讲到

314
00:14:24,000 --> 00:14:26,000
提到像 backbone 你们做的时候

315
00:14:26,000 --> 00:14:28,000
我感根据你的描述

316
00:14:28,000 --> 00:14:30,000
我感觉出来有几个比较核心的问题

317
00:14:30,000 --> 00:14:31,000
就一个是说

318
00:14:31,000 --> 00:14:34,000
这个叫什么封装的层级不够

319
00:14:34,000 --> 00:14:36,000
就说它封的太散了

320
00:14:36,000 --> 00:14:39,000
比如说你很多有些数据是在 dom 里面的

321
00:14:39,000 --> 00:14:42,000
有些数据可能是在 javascript 的数据结构里面的

322
00:14:42,000 --> 00:14:43,000
对吧

323
00:14:43,000 --> 00:14:45,000
这可能是一个还有你说那个 view 不能够够够够的

324
00:14:45,000 --> 00:14:47,000
能在同一个地方一眼看出来

325
00:14:47,000 --> 00:14:48,000
它的相关的那一部分是怎么样

326
00:14:48,000 --> 00:14:51,000
这个其实是在你们在工程上的话

327
00:14:51,000 --> 00:14:53,000
就是没有把这些相关的部分很好的

328
00:14:53,000 --> 00:14:55,000
就是 uncapsulate 起来

329
00:14:55,000 --> 00:14:56,000
没错

330
00:14:56,000 --> 00:14:59,000
因为这个主要是因为 dom 这个事情

331
00:14:59,000 --> 00:15:01,000
就太太太他妈操蛋了

332
00:15:01,000 --> 00:15:02,000
你知道就是这样

333
00:15:02,000 --> 00:15:04,000
大家都明白

334
00:15:04,000 --> 00:15:06,000
我说为什么这么说

335
00:15:06,000 --> 00:15:10,000
因为 dom 的问题

336
00:15:10,000 --> 00:15:12,000
首先 API 很烂

337
00:15:12,000 --> 00:15:14,000
这个 dequery kind of

338
00:15:14,000 --> 00:15:16,000
resolve that problem

339
00:15:16,000 --> 00:15:17,000
kind of

340
00:15:17,000 --> 00:15:21,000
然后关键的因素在于说 performance 太烂

341
00:15:21,000 --> 00:15:24,000
因为这是历史因素

342
00:15:24,000 --> 00:15:25,000
因为 dom 的

343
00:15:25,000 --> 00:15:26,000
对

344
00:15:26,000 --> 00:15:30,000
你跟 dom 交互的话肯定就是有这个 so-called overhead 比较高

345
00:15:30,000 --> 00:15:31,000
对

346
00:15:31,000 --> 00:15:36,000
实际上如果你真正去 compare backbone 跟 react

347
00:15:36,000 --> 00:15:39,000
最关键就是他们怎么去处理这个 dom

348
00:15:39,000 --> 00:15:42,000
你怎么去处理 dom 这个事情上不一样

349
00:15:42,000 --> 00:15:43,000
在 backbone 里头

350
00:15:44,000 --> 00:15:46,000
如果你要追求 performance

351
00:15:46,000 --> 00:15:49,000
如果说你不 care performance

352
00:15:49,000 --> 00:15:50,000
totally different story

353
00:15:50,000 --> 00:15:54,000
但是如果你就是在意真正可用东西

354
00:15:54,000 --> 00:15:56,000
还不是好用是可用的话

355
00:15:56,000 --> 00:15:58,000
你一定要在意 performance

356
00:15:58,000 --> 00:16:02,000
然后就导致说你的 dom 的

357
00:16:02,000 --> 00:16:05,000
操作都要很小非常小

358
00:16:05,000 --> 00:16:10,000
比方说如果我要写一个选项的列表

359
00:16:10,000 --> 00:16:13,000
一个用户去点一个选项

360
00:16:13,000 --> 00:16:15,000
然后那个选项要变成红色

361
00:16:15,000 --> 00:16:16,000
这么一个小小的功能

362
00:16:16,000 --> 00:16:18,000
在你的 backbone view 中

363
00:16:18,000 --> 00:16:23,000
你一定是会 manually 把这个 class 给

364
00:16:23,000 --> 00:16:26,000
从其他的 element 上移除出去

365
00:16:26,000 --> 00:16:32,000
然后加在 target 的 element 上的

366
00:16:32,000 --> 00:16:33,000
就这么小小一点

367
00:16:33,000 --> 00:16:34,000
操作

368
00:16:34,000 --> 00:16:35,000
要便利一遍

369
00:16:35,000 --> 00:16:39,000
就导致你的 state 就从 view 上 lose 掉了

370
00:16:39,000 --> 00:16:42,000
因为你整个 state 是在 dom 里面的

371
00:16:42,000 --> 00:16:45,000
active class 这个因素上的

372
00:16:45,000 --> 00:16:47,000
但是你又不可能说

373
00:16:47,000 --> 00:16:51,000
每次都把这个列表重新给 render 一下

374
00:16:51,000 --> 00:16:54,000
这就回到我们说的 performance 上面

375
00:16:54,000 --> 00:16:56,000
对于开发者来说

376
00:16:56,000 --> 00:16:57,000
如果你不需要去担心

377
00:16:57,000 --> 00:16:59,000
这么小小的这种细节操作

378
00:16:59,000 --> 00:17:02,000
而是描述清楚你到底

379
00:17:02,000 --> 00:17:05,000
这个 view end result 是怎么样

380
00:17:05,000 --> 00:17:07,000
那你的 code 就会清楚很多

381
00:17:07,000 --> 00:17:09,000
可是因为 performance 的因素

382
00:17:09,000 --> 00:17:11,000
你必须得到这么

383
00:17:12,000 --> 00:17:14,000
到那个细节的小的程度去操作它

384
00:17:14,000 --> 00:17:18,000
就导致你不能够每次都 re-render

385
00:17:18,000 --> 00:17:20,000
backbone 的时代就是这样子的

386
00:17:20,000 --> 00:17:24,000
然后这就是 reacted magic happens

387
00:17:24,000 --> 00:17:26,000
when the magic happens

388
00:17:26,000 --> 00:17:29,000
在 reacted conf 里头

389
00:17:29,000 --> 00:17:33,000
Tom who is the product manager

390
00:17:33,000 --> 00:17:37,000
有提到 facebook 内部

391
00:17:37,000 --> 00:17:39,000
去做这个

392
00:17:39,000 --> 00:17:42,000
去 initialize 这个 project 的动机

393
00:17:42,000 --> 00:17:45,000
就有提到说他们很想要

394
00:17:45,000 --> 00:17:50,000
把这个这种细小的 dom 操作

395
00:17:50,000 --> 00:17:51,000
隔离出来

396
00:17:51,000 --> 00:17:52,000
abstract out

397
00:17:52,000 --> 00:17:54,000
就像刚刚 Rio 说的

398
00:17:54,000 --> 00:17:58,000
但是他们担心 performance

399
00:17:58,000 --> 00:18:00,000
所以他们做了 performance 的测试

400
00:18:00,000 --> 00:18:02,000
实际上 performance 的测试结果

401
00:18:02,000 --> 00:18:05,000
比我们所要预想的都乐观很多

402
00:18:05,000 --> 00:18:07,000
实际上 dom 没有那么烂

403
00:18:07,000 --> 00:18:09,000
他们的原话是

404
00:18:09,000 --> 00:18:11,000
我记得是 IE 9 还是 IE 10

405
00:18:11,000 --> 00:18:13,000
才会非常烂

406
00:18:13,000 --> 00:18:14,000
我们知道的

407
00:18:14,000 --> 00:18:15,000
不过这不是真的

408
00:18:15,000 --> 00:18:18,000
这是一个

409
00:18:18,000 --> 00:18:21,000
这是浏览器相关的毫无疑问

410
00:18:21,000 --> 00:18:22,000
对

411
00:18:22,000 --> 00:18:25,000
所以这是在比方说

412
00:18:25,000 --> 00:18:27,000
modern chrome 中

413
00:18:27,000 --> 00:18:29,000
如果你就是不停的 re-render 的话

414
00:18:29,000 --> 00:18:31,000
实际上也没有那么烂

415
00:18:31,000 --> 00:18:33,000
可是我们当然想要

416
00:18:33,000 --> 00:18:35,000
更好的 performance

417
00:18:35,000 --> 00:18:37,000
所以他们有

418
00:18:37,000 --> 00:18:41,000
脑洞大开的想把这个 dom

419
00:18:41,000 --> 00:18:43,000
这个事情整个给 incapsulate

420
00:18:43,000 --> 00:18:46,000
整个给 virtualize

421
00:18:46,000 --> 00:18:51,000
所以开发者就完全去不去操作 dom

422
00:18:51,000 --> 00:18:54,000
然后通过 react 本身的一套算法

423
00:18:54,000 --> 00:18:59,000
react 会试图发现

424
00:18:59,000 --> 00:19:02,000
两个 state 之间的区别

425
00:19:02,000 --> 00:19:04,000
帮你自动的去 update

426
00:19:04,000 --> 00:19:06,000
真正的浏览器的 dom

427
00:19:06,000 --> 00:19:10,000
这就移除了 performance 的问题

428
00:19:10,000 --> 00:19:12,000
从而回过头来

429
00:19:12,000 --> 00:19:18,000
enable 了开发者去写更 descriptive

430
00:19:18,000 --> 00:19:20,000
更 declarative 的 code

431
00:19:20,000 --> 00:19:23,000
而不是直接告诉浏览器去做什么

432
00:19:23,000 --> 00:19:24,000
对

433
00:19:24,000 --> 00:19:26,000
这里就提到有一个

434
00:19:26,000 --> 00:19:27,000
就 react

435
00:19:27,000 --> 00:19:29,000
它这个新的前端的

436
00:19:29,000 --> 00:19:30,000
它也比较框架

437
00:19:30,000 --> 00:19:31,000
这个工具

438
00:19:31,000 --> 00:19:33,000
它最核心的一点就是说

439
00:19:33,000 --> 00:19:36,000
它本身是和浏览器的 dom 是脱节的

440
00:19:36,000 --> 00:19:38,000
就是它没有一个很

441
00:19:38,000 --> 00:19:39,000
就所谓的 tight coupling 在里面

442
00:19:39,000 --> 00:19:40,000
就是它

443
00:19:40,000 --> 00:19:41,000
render 出来的结果

444
00:19:41,000 --> 00:19:43,000
并不是得到的一个真正的浏览器的 dom

445
00:19:43,000 --> 00:19:44,000
而是一个

446
00:19:44,000 --> 00:19:46,000
所以他们讲的一个虚拟的 dom

447
00:19:46,000 --> 00:19:47,000
然后它

448
00:19:47,000 --> 00:19:48,000
对

449
00:19:48,000 --> 00:19:51,000
然后他们再有做了这么一个 diff 这一层

450
00:19:51,000 --> 00:19:52,000
然后再去说

451
00:19:52,000 --> 00:19:54,000
怎么用最小的代价

452
00:19:54,000 --> 00:19:56,000
使得浏览器里面现在有的

453
00:19:56,000 --> 00:19:57,000
那个真实的 dom

454
00:19:57,000 --> 00:19:59,000
能够变成你

455
00:19:59,000 --> 00:20:01,000
这个 virtualdom 需要的形状

456
00:20:01,000 --> 00:20:04,000
这样的话就可以尽量减少

457
00:20:04,000 --> 00:20:06,000
这个 dom 那边的交货的开销

458
00:20:06,000 --> 00:20:07,000
对

459
00:20:07,000 --> 00:20:09,000
当然这个的前提假设就是说

460
00:20:09,000 --> 00:20:14,000
你跟浏览器真实的 dom 的交货是一个比较高成本的

461
00:20:14,000 --> 00:20:16,000
但是在一个现代浏览器

462
00:20:16,000 --> 00:20:18,000
现代的 JavaScript 的解析器的情况下

463
00:20:18,000 --> 00:20:23,000
它的 JavaScript 内部的执行和解析的速度是非常快的

464
00:20:23,000 --> 00:20:25,000
所以要解决这两个之间的差异的话

465
00:20:25,000 --> 00:20:28,000
它就通过这种做 diff 的方法来实现了

466
00:20:28,000 --> 00:20:29,000
对 没错

467
00:20:29,000 --> 00:20:37,000
很有意思的是 David Nolan 是 closure script 的作者

468
00:20:37,000 --> 00:20:39,000
然后他们有

469
00:20:39,000 --> 00:20:41,000
把 react 给

470
00:20:41,000 --> 00:20:44,000
写了一个 closure script 的 react

471
00:20:44,000 --> 00:20:45,000
叫做 om

472
00:20:45,000 --> 00:20:47,000
他给了一个 presentation

473
00:20:47,000 --> 00:20:50,000
然后他不把 virtualdom 叫做 virtualdom

474
00:20:50,000 --> 00:20:53,000
他把 virtualdom 叫做 dom virtual machine

475
00:20:53,000 --> 00:20:56,000
这是一个非常小的差异

476
00:20:56,000 --> 00:20:59,000
但是我想他想要说的是说

477
00:20:59,000 --> 00:21:04,000
这个 virtualdom 实际上是非常 powerful

478
00:21:04,000 --> 00:21:08,000
然后这个 react 它的

479
00:21:08,000 --> 00:21:10,000
可能在思维哲学上

480
00:21:10,000 --> 00:21:11,000
我觉得有一点很大的不同

481
00:21:11,000 --> 00:21:14,000
就是说传统上我们像用 backbone 之类的

482
00:21:14,000 --> 00:21:15,000
其实是你是在

483
00:21:15,000 --> 00:21:17,000
你是把 dom 当成一个巨大的 state

484
00:21:17,000 --> 00:21:20,000
然后你是在手工的去管理那些 state 对吧

485
00:21:20,000 --> 00:21:23,000
然后这可能就很多的操作

486
00:21:23,000 --> 00:21:27,000
就是可能要手动去添加什么 event handler

487
00:21:27,000 --> 00:21:28,000
然后它发生什么事情

488
00:21:28,000 --> 00:21:30,000
你要记得把它取掉

489
00:21:30,000 --> 00:21:32,000
然后要做一些相应的修改

490
00:21:32,000 --> 00:21:37,000
整个来看交互的流程和你的 view

491
00:21:37,000 --> 00:21:41,000
就是混杂的比较就是什么

492
00:21:41,000 --> 00:21:43,000
怎么这个叫什么

493
00:21:43,000 --> 00:21:45,000
犬牙交错对吧

494
00:21:45,000 --> 00:21:47,000
终于想起这个

495
00:21:47,000 --> 00:21:49,000
难为你用这么复杂的头

496
00:21:49,000 --> 00:21:50,000
对

497
00:21:50,000 --> 00:21:52,000
但是像 react 这种思路的话

498
00:21:52,000 --> 00:21:53,000
他用那 virtualdom 的思路

499
00:21:53,000 --> 00:21:57,000
其实刚才 villow 已经解释过一下

500
00:21:57,000 --> 00:21:59,000
就是说他其实是放弃了这一条

501
00:21:59,000 --> 00:22:02,000
就是说我们不要去手工去改

502
00:22:02,000 --> 00:22:05,000
一个浏览器里面 dom 的每一个小细节

503
00:22:05,000 --> 00:22:07,000
而是说我们流程器里面

504
00:22:07,000 --> 00:22:08,000
你只要告诉我

505
00:22:08,000 --> 00:22:10,000
你需要让它达到什么样的状态

506
00:22:10,000 --> 00:22:11,000
当然这个需要你说

507
00:22:11,000 --> 00:22:13,000
你是一次性的描述性的状态嘛

508
00:22:13,000 --> 00:22:14,000
对

509
00:22:14,000 --> 00:22:15,000
然后这样的话

510
00:22:15,000 --> 00:22:17,000
我就只需要说

511
00:22:17,000 --> 00:22:20,000
那我不需要考虑怎么去变到那个状态

512
00:22:20,000 --> 00:22:21,000
我只需要声明

513
00:22:21,000 --> 00:22:23,000
我最后要达到什么样的状态就可以了

514
00:22:23,000 --> 00:22:26,000
其实这个让我想起 backbone 的

515
00:22:26,000 --> 00:22:28,000
一个一句宣传口号

516
00:22:28,000 --> 00:22:33,000
就是 get the truth out from your dom

517
00:22:33,000 --> 00:22:35,000
但实际上

518
00:22:35,000 --> 00:22:37,000
他的这个口号

519
00:22:37,000 --> 00:22:39,000
所指的是要把

520
00:22:39,000 --> 00:22:41,000
其实就是很简单的

521
00:22:41,000 --> 00:22:45,000
要把 dom 所要呈现的那一层那些数据

522
00:22:45,000 --> 00:22:49,000
作为你的 model

523
00:22:49,000 --> 00:22:51,000
从 dom 里面抽吸出来

524
00:22:51,000 --> 00:22:55,000
但如果沿着这一句宣传口号

525
00:22:55,000 --> 00:22:57,000
更进一步研发的话

526
00:22:57,000 --> 00:23:00,000
会我觉得可能最终结果就是像 react 这样

527
00:23:00,000 --> 00:23:03,000
就是将 dom 作为某种

528
00:23:03,000 --> 00:23:06,000
就像 screenbuffer 一样

529
00:23:07,000 --> 00:23:10,000
就是计算出最终需要的 dom

530
00:23:10,000 --> 00:23:14,000
然后去更新它与实际的 dom 所差异的这部分

531
00:23:14,000 --> 00:23:18,000
这样可能更就是更多的 truth

532
00:23:18,000 --> 00:23:21,000
被从 dom 里面抽吸出来

533
00:23:21,000 --> 00:23:25,000
其实他这个思想也不是说原创性的

534
00:23:25,000 --> 00:23:27,000
就是在很多年前做游戏的

535
00:23:27,000 --> 00:23:29,000
大家都已经发现有这么一个

536
00:23:29,000 --> 00:23:31,000
就做那种就是电脑游戏的人

537
00:23:31,000 --> 00:23:33,000
都已经有这么一个概念了

538
00:23:33,000 --> 00:23:35,000
过去游戏有个叫做

539
00:23:35,000 --> 00:23:37,000
就是绘制图形的游戏

540
00:23:37,000 --> 00:23:38,000
绘制图形的话

541
00:23:38,000 --> 00:23:39,000
有个所谓的叫做 immediate mode

542
00:23:39,000 --> 00:23:40,000
就是立即模式

543
00:23:40,000 --> 00:23:42,000
就是你画什么就在图像

544
00:23:42,000 --> 00:23:44,000
都在屏幕上出现什么

545
00:23:44,000 --> 00:23:46,000
然后发现其实这样的话

546
00:23:46,000 --> 00:23:50,000
对性能其实是不好的

547
00:23:50,000 --> 00:23:53,000
后来他们发现用什么 retain mode 的话

548
00:23:53,000 --> 00:23:58,000
你其实可以再让游戏引擎去做一些优化

549
00:23:58,000 --> 00:24:01,000
就是说把你先告诉他下一帧

550
00:24:01,000 --> 00:24:02,000
应该显示什么

551
00:24:02,000 --> 00:24:05,000
让他计算出两者的差异

552
00:24:05,000 --> 00:24:07,000
其实在 react 的 converter 上

553
00:24:07,000 --> 00:24:12,000
没有人提到跟游戏上的差异

554
00:24:12,000 --> 00:24:15,000
所以我有点就是自己在想

555
00:24:15,000 --> 00:24:18,000
在好奇说到底这个是一个殊途同归呢

556
00:24:18,000 --> 00:24:24,000
还是他们有真正的在游戏开发者身上提取灵感

557
00:24:24,000 --> 00:24:26,000
但我更倾向于是

558
00:24:26,000 --> 00:24:28,000
相信是一个殊途同归的结果

559
00:24:28,000 --> 00:24:30,000
对我也觉得

560
00:24:30,000 --> 00:24:35,000
Pete Hunt 他在去年的介绍 react 的会议上面

561
00:24:35,000 --> 00:24:36,000
他就讲了

562
00:24:36,000 --> 00:24:38,000
就是说他们做完发现

563
00:24:38,000 --> 00:24:40,000
他们做成了 3 D 游戏的人

564
00:24:40,000 --> 00:24:42,000
好像也是用的同样一套思路

565
00:24:42,000 --> 00:24:45,000
其实确实是一个殊途同归的结果

566
00:24:45,000 --> 00:24:49,000
其实我相信现在的 webapp 领域的很多技术

567
00:24:49,000 --> 00:24:57,000
可能在古早的 3 D 技术发展道路上都已经讨论过了

568
00:24:57,000 --> 00:25:04,000
然后有些经验可能也是会需要被 backport 过来的

569
00:25:04,000 --> 00:25:05,000
或者说其实

570
00:25:05,000 --> 00:25:10,000
我们把领域放得更宽广一点

571
00:25:10,000 --> 00:25:15,000
就是说前端如果不仅限于网页或者是一个客户端的 app 的话

572
00:25:15,000 --> 00:25:19,000
其实游戏从某种意义上来讲也是在做一个前端的东西

573
00:25:19,000 --> 00:25:23,000
我觉得游戏可能最大的差别是

574
00:25:23,000 --> 00:25:29,000
它和它的前端和后端之间的差异

575
00:25:29,000 --> 00:25:35,000
它的前端后端之间没有中间隔着这么巨大的一个互联网的鸿沟

576
00:25:35,000 --> 00:25:40,000
它中间的通讯没有这么大的一个延迟

577
00:25:40,000 --> 00:25:44,000
或者说有这么大的一个协议站摆在那边

578
00:25:44,000 --> 00:25:48,000
现在你很多游戏也是这种网络的 network game

579
00:25:48,000 --> 00:25:50,000
所以其实还是有很大相似点

580
00:25:50,000 --> 00:25:54,000
但那一部分仅仅是用来交互游戏数据的

581
00:25:54,000 --> 00:26:03,000
你的表现层的数据仍旧是在本地生成

582
00:26:03,000 --> 00:26:04,000
除非你是在做 streaming

583
00:26:04,000 --> 00:26:05,000
但是 streaming 是在做的

584
00:26:05,000 --> 00:26:07,000
streaming 又是另外一个话题了

585
00:26:07,000 --> 00:26:10,000
对 这也是一个问题

586
00:26:10,000 --> 00:26:12,000
React 其实还有一点

587
00:26:12,000 --> 00:26:16,000
它是更倾向于你使用所谓的 immutable data structure

588
00:26:16,000 --> 00:26:19,000
就是不可修改的数据结构

589
00:26:19,000 --> 00:26:22,000
这点我们在 count 上有提到

590
00:26:22,000 --> 00:26:26,000
然后顺带说我非常喜欢

591
00:26:26,000 --> 00:26:29,000
我在这个 React count 上我真的非常高兴非常激动

592
00:26:29,000 --> 00:26:34,000
因为传统意义上来说前端不是一个很 hardcore CS 的东西

593
00:26:34,000 --> 00:26:35,000
对吧

594
00:26:35,000 --> 00:26:40,000
很多大家一般看前端开发者都有一点小笔式的意思

595
00:26:40,000 --> 00:26:41,000
对

596
00:26:41,000 --> 00:26:45,000
更加工程导向而不是理论导向

597
00:26:45,000 --> 00:26:47,000
更加 25 岁以下导向

598
00:26:47,000 --> 00:26:49,000
不要这么

599
00:26:49,000 --> 00:26:51,000
不不 我又想起来那个

600
00:26:51,000 --> 00:26:55,000
所以正是在这个 conference 上

601
00:26:55,000 --> 00:26:58,000
我们有听到很多很有意思的东西

602
00:26:58,000 --> 00:27:00,000
其中有一个是 immutable data

603
00:27:00,000 --> 00:27:04,000
我们有一个演讲是 Leigh Byron 给的演讲

604
00:27:04,000 --> 00:27:11,000
在专门说 immutabledata 就是 Facebook 的 immutabledata

605
00:27:11,000 --> 00:27:12,000
JavaScript 实现

606
00:27:12,000 --> 00:27:16,000
她有讲到很多这个 immutabledata 到底是什么东西

607
00:27:16,000 --> 00:27:20,000
怎么在 JavaScript 上实现的非常好

608
00:27:20,000 --> 00:27:24,000
但是 back 到这个 React 上来说的话

609
00:27:24,000 --> 00:27:27,000
之所以 immutabledata 是 preferred

610
00:27:27,000 --> 00:27:30,000
not required but preferred 是因为

611
00:27:30,000 --> 00:27:32,000
正因为 React 它的设计方式

612
00:27:32,000 --> 00:27:38,000
整个的 render 的过程整个的 component 实际上就是 props

613
00:27:38,000 --> 00:27:42,000
plus state equal to something

614
00:27:42,000 --> 00:27:45,000
这个 equal 是 render function 所做的事情

615
00:27:45,000 --> 00:27:49,000
所以如果你的 props 跟你的 state 不变化的话

616
00:27:49,000 --> 00:27:52,000
你的 render result 总是一致的

617
00:27:52,000 --> 00:27:54,000
总会是一样的

618
00:27:54,000 --> 00:27:58,000
虽然说 virtual DOM 会帮助你不去 update 你的 DOM

619
00:27:58,000 --> 00:28:01,000
但是如果你在你连 render 都连

620
00:28:01,000 --> 00:28:06,000
连 render function 都不用去 run 的话

621
00:28:06,000 --> 00:28:10,000
那你就实现了更好的 performance

622
00:28:10,000 --> 00:28:12,000
然后省下更多的时间

623
00:28:12,000 --> 00:28:15,000
特别是在大型的 application 上

624
00:28:15,000 --> 00:28:20,000
但是怎么去判断这个 props 跟 state 有没有改变

625
00:28:20,000 --> 00:28:22,000
就变成了一个很大的问题

626
00:28:22,000 --> 00:28:23,000
传统的 mutabledata 的话呢

627
00:28:23,000 --> 00:28:25,000
就至少是个 ON 的操作

628
00:28:25,000 --> 00:28:30,000
你必须得把整个 object 给便利了

629
00:28:30,000 --> 00:28:33,000
然后如果你要做 deep comparison 的话

630
00:28:33,000 --> 00:28:36,000
就更大了是一个竖状结构

631
00:28:36,000 --> 00:28:42,000
in mutable data 实现了 constant time 的 comparison

632
00:28:42,000 --> 00:28:44,000
就是 01

633
00:28:44,000 --> 00:28:46,000
你只用判断一个指针吗

634
00:28:46,000 --> 00:28:47,000
等于说

635
00:28:47,000 --> 00:28:48,000
是一个空间

636
00:28:48,000 --> 00:28:52,000
时间跟空间是花在其他的部分了

637
00:28:52,000 --> 00:28:56,000
但是在这个 render 上就更有帮助

638
00:28:56,000 --> 00:28:57,000
非常快

639
00:28:57,000 --> 00:28:59,000
我们在跟其他的

640
00:29:00,000 --> 00:29:02,000
与会者讨论的时候

641
00:29:02,000 --> 00:29:04,000
也提到很多人就是

642
00:29:04,000 --> 00:29:08,000
一开始也没有用 in mutable data

643
00:29:08,000 --> 00:29:09,000
但越用 react

644
00:29:09,000 --> 00:29:11,000
越说这个 total make sense

645
00:29:11,000 --> 00:29:13,000
为什么不用呢

646
00:29:13,000 --> 00:29:14,000
对吧

647
00:29:14,000 --> 00:29:17,000
所以 in mutable data 这个事情非常有意思

648
00:29:17,000 --> 00:29:21,000
就不是一个传统以上 java script 人 care 的东西

649
00:29:21,000 --> 00:29:29,000
正因为对于 in mutable data 的喜好

650
00:29:29,000 --> 00:29:33,000
才导致了 closure script 也加入 react 的行列

651
00:29:33,000 --> 00:29:36,000
因为 closure 它所有的本来就是 in mutable

652
00:29:36,000 --> 00:29:37,000
它是 functional language

653
00:29:37,000 --> 00:29:39,000
然后它所有的都是 in mutable 的

654
00:29:39,000 --> 00:29:41,000
所以就很 natural

655
00:29:41,000 --> 00:29:45,000
它的那个 framework 就很好的利用了这样一个特性

656
00:29:45,000 --> 00:29:47,000
对

657
00:29:47,000 --> 00:29:49,000
上次我看了一个那个 om

658
00:29:49,000 --> 00:29:52,000
就是那个 clear script 写的 react 实现

659
00:29:52,000 --> 00:29:54,000
他们的性能确实非常了不得多

660
00:29:54,000 --> 00:29:55,000
因为刚才讲了

661
00:29:55,000 --> 00:29:58,000
你只要因为在 om 里面整个

662
00:29:58,000 --> 00:30:00,000
就大部分的 data structure 都是这个

663
00:30:00,000 --> 00:30:02,000
所有的 in mutable 的话

664
00:30:02,000 --> 00:30:03,000
他们在渲染的时候

665
00:30:03,000 --> 00:30:06,000
就真的只用逐个走那个树状结构

666
00:30:06,000 --> 00:30:10,000
然后判断那个根节点的指针的就好了

667
00:30:10,000 --> 00:30:12,000
这是非常非常快速的一个过程

668
00:30:12,000 --> 00:30:16,000
顺带说在整个这个 conference 中

669
00:30:16,000 --> 00:30:20,000
我们有提到非常多的 performance 的 trick

670
00:30:20,000 --> 00:30:21,000
怎么样实现更好的 performance

671
00:30:21,000 --> 00:30:22,000
in mutable 是其中之一

672
00:30:22,000 --> 00:30:24,000
我们有提到很多其他的东西

673
00:30:24,000 --> 00:30:27,000
如果观众听众朋友们有兴趣的话

674
00:30:27,000 --> 00:30:28,000
可以去看看

675
00:30:28,000 --> 00:30:30,000
可以找到这些 keynote

676
00:30:30,000 --> 00:30:31,000
也可以写信问我

677
00:30:31,000 --> 00:30:33,000
或者告诉 real

678
00:30:33,000 --> 00:30:36,000
我们说不定下期可以做更多关于 react 的

679
00:30:36,000 --> 00:30:39,000
更细节更优化的东西

680
00:30:39,000 --> 00:30:40,000
对

681
00:30:40,000 --> 00:30:44,000
不过他们看现场视频

682
00:30:44,000 --> 00:30:45,000
现在跟他说一下

683
00:30:45,000 --> 00:30:49,000
这次的 react conf 2015 的所有的视频

684
00:30:49,000 --> 00:30:51,000
都在 youtube 上面有的

685
00:30:51,000 --> 00:30:55,000
但是因为现在国内 vpn 也打击的比较严重

686
00:30:55,000 --> 00:30:57,000
能不能看到就不好说了

687
00:30:57,000 --> 00:30:58,000
个人有个人的方法

688
00:30:58,000 --> 00:30:59,000
他不是所有都在吧

689
00:30:59,000 --> 00:31:00,000
好像可以吧

690
00:31:00,000 --> 00:31:03,000
我在看因为 youtube 上有个频道

691
00:31:03,000 --> 00:31:07,000
叫做 facebook developer 的频道

692
00:31:07,000 --> 00:31:09,000
然后这个 channel 上基本上

693
00:31:09,000 --> 00:31:12,000
应该你需要的都可以看到

694
00:31:12,000 --> 00:31:13,000
不我就说国内的

695
00:31:13,000 --> 00:31:15,000
我们听众很多人都在国内

696
00:31:15,000 --> 00:31:18,000
他们没有办法去上这个 youtube

697
00:31:18,000 --> 00:31:21,000
我觉得我们要 fact check 一下

698
00:31:21,000 --> 00:31:24,000
好像只有他只有三个只有 relay

699
00:31:24,000 --> 00:31:26,000
他有那 in mutable.js 的那个听到吗

700
00:31:26,000 --> 00:31:28,000
他现在他在逐渐放

701
00:31:28,000 --> 00:31:32,000
他已经我觉得他应该可能还是在做一些剪辑之类的工作

702
00:31:32,000 --> 00:31:35,000
大家对中是要他要找他全部放上去

703
00:31:35,000 --> 00:31:37,000
他没有理由不放出来

704
00:31:37,000 --> 00:31:39,000
因为对的

705
00:31:39,000 --> 00:31:42,000
反正一共是有多少个是一个是多少个 talk 来的

706
00:31:42,000 --> 00:31:45,000
有两天是十二个

707
00:31:45,000 --> 00:31:46,000
anyways

708
00:31:46,000 --> 00:31:49,000
就是就是讲这 fact check

709
00:31:49,000 --> 00:31:51,000
没有没有没有其他意思

710
00:31:51,000 --> 00:31:54,000
嗯你有的有的这个不用担心

711
00:31:54,000 --> 00:31:55,000
嗯

712
00:31:55,000 --> 00:31:56,000
啊

727
00:38:56,000 --> 00:38:58,000
就是说为大规模杀杀性武器

728
00:38:58,000 --> 00:39:01,000
哈哈哈

729
00:39:01,000 --> 00:39:03,000
对啊

730
00:39:03,000 --> 00:39:05,000
啊 react 还有一个好处哈

731
00:39:05,000 --> 00:39:11,000
就是说这个所谓构建这个 isomorphic 的 javascript 的应用的情况下比较好的

732
00:39:11,000 --> 00:39:13,000
因为他可以同样的一个 react 组件

733
00:39:13,000 --> 00:39:17,000
只要你构建的方式稍微注意一点点

734
00:39:17,000 --> 00:39:20,000
他是可以在客户端渲染

735
00:39:20,000 --> 00:39:22,000
或者是在客户的服务端渲染

736
00:39:22,000 --> 00:39:24,000
然后在服务端线他有一个什么好处呢

737
00:39:24,000 --> 00:39:25,000
他可以在服务端线

738
00:39:25,000 --> 00:39:27,000
从最初的那个页面那个结构之后

739
00:39:27,000 --> 00:39:29,000
你把这个送给浏览器

740
00:39:29,000 --> 00:39:31,000
然后在浏览器再接着

741
00:39:31,000 --> 00:39:34,000
呃服务端渲染那个部分开始

742
00:39:34,000 --> 00:39:36,000
在完成后面的后续的工作

743
00:39:36,000 --> 00:39:38,000
这个我我不太清楚

744
00:39:38,000 --> 00:39:41,000
就是之前有其他类型的框架的实现过这种功能没

745
00:39:41,000 --> 00:39:44,000
但是就我第一次看到这个时候觉得还是蛮惊奇的

746
00:39:44,000 --> 00:39:46,000
as far as i know

747
00:39:46,000 --> 00:39:47,000
啊

748
00:39:47,000 --> 00:39:50,000
如果你小心翼翼的写你的 app 的话

749
00:39:50,000 --> 00:39:54,000
是有可能用其他的啊框架加上 phantom

750
00:39:54,000 --> 00:39:57,000
就是用 headless webkit 来实现相同的功能

751
00:39:57,000 --> 00:39:59,000
是我觉得理论上是有可能的

752
00:39:59,000 --> 00:40:00,000
啊

753
00:40:00,000 --> 00:40:02,000
但是啊

754
00:40:02,000 --> 00:40:03,000
在这个太高了

755
00:40:03,000 --> 00:40:04,000
对 exactly

756
00:40:04,000 --> 00:40:05,000
就性能上的话还会损失很多

757
00:40:05,000 --> 00:40:09,000
因为你毕竟要 run 一个 webkit 在你的 serve 上

758
00:40:09,000 --> 00:40:13,000
我 fantom js 发展到现在实际上也解决了非常多的问题吧

759
00:40:13,000 --> 00:40:14,000
他他变成了一个 server

760
00:40:14,000 --> 00:40:16,000
而不是你每次都要啊

761
00:40:16,000 --> 00:40:18,000
复那个 overhead 去 run 这个

762
00:40:18,000 --> 00:40:20,000
run 这个 webkit 在里头

763
00:40:20,000 --> 00:40:21,000
啊

764
00:40:21,000 --> 00:40:22,000
当然 react

765
00:40:22,000 --> 00:40:24,000
有更大的可能性是

766
00:40:24,000 --> 00:40:27,000
因为因为毕竟那个 dom 是 virtualized

767
00:40:27,000 --> 00:40:31,000
所以对他不需要去 load 的一个真正的 webkit 的引擎

768
00:40:31,000 --> 00:40:36,000
他只需要在 javascript 内部去虚构一个这么一个一个 dom 结构就好

769
00:40:36,000 --> 00:40:38,000
这次我们在 conference 上有听到

770
00:40:38,000 --> 00:40:41,000
很多公司谈到这个他们的应用

771
00:40:41,000 --> 00:40:44,000
大部分的原因呢也不是因为性能

772
00:40:44,000 --> 00:40:45,000
而是因为啊

773
00:40:45,000 --> 00:40:46,000
aceo

774
00:40:46,000 --> 00:40:48,000
很多公司很 concernaceo 嘛

775
00:40:48,000 --> 00:40:53,000
然后现在 javascriptaceo 啊对啊还是一个没能解决问题

776
00:40:53,000 --> 00:40:55,000
surprise me

777
00:40:55,000 --> 00:40:56,000
过去这么多年了

778
00:40:56,000 --> 00:40:58,000
仍旧是一个疯狂的问题

779
00:40:58,000 --> 00:40:59,000
it's crazy

780
00:40:59,000 --> 00:41:00,000
somehow sorry

781
00:41:00,000 --> 00:41:03,000
有有有公司啊提到说啊

782
00:41:03,000 --> 00:41:07,000
你知道 google 有就是有有一个有一个 convention 嘛

783
00:41:07,000 --> 00:41:08,000
就是啊

784
00:41:08,000 --> 00:41:11,000
你如果你的 url 是一个特别的什么结构的话

785
00:41:11,000 --> 00:41:12,000
他会

786
00:41:12,000 --> 00:41:16,000
他会尝试去 fetch 另外一个 url

787
00:41:16,000 --> 00:41:18,000
which is supposed to be static page

788
00:41:18,000 --> 00:41:20,000
但是啊

789
00:41:20,000 --> 00:41:22,000
according to you know some other companies

790
00:41:22,000 --> 00:41:26,000
这个功能非常啊就是 google 不怎么在意这个功能

791
00:41:26,000 --> 00:41:27,000
然后经常就坏掉

792
00:41:27,000 --> 00:41:33,000
所以他们经常经常就是没就是那个 fetch rate drop 到零你知道吗

793
00:41:33,000 --> 00:41:36,000
这是对于公司来说就是个 disaster

794
00:41:36,000 --> 00:41:39,000
他们他们很多公司都是很靠 google 的流量嘛

795
00:41:39,000 --> 00:41:41,000
如果说有这样一个问题的话

796
00:41:41,000 --> 00:41:44,000
那这个对他们的 business 是 critical 的

797
00:41:44,000 --> 00:41:46,000
他们所以他们就很

798
00:41:46,000 --> 00:41:47,000
电达希特

799
00:41:47,000 --> 00:41:51,000
非常非常在意这个 asomorphic 的啊可能性

800
00:41:51,000 --> 00:41:53,000
对而且之前之前说那个 google 说

801
00:41:53,000 --> 00:41:57,000
他说干一种是一种方式通过一种特殊的 url 结构去说告知 google 的爬虫啊

802
00:41:57,000 --> 00:42:01,000
我这个动态网页你可以在另外一个地址找到他的静态版本

803
00:42:01,000 --> 00:42:04,000
这是一个一个比较传统的解决方案

804
00:42:04,000 --> 00:42:07,000
然后 google 是最应该是去年年末的时候

805
00:42:07,000 --> 00:42:10,000
他是说他们也会渲染 javascript 的这个页面

806
00:42:10,000 --> 00:42:14,000
就是他会当把自己模拟成一个浏览器啊

807
00:42:14,000 --> 00:42:17,000
一个浏览器的引擎去解决这个问题

808
00:42:17,000 --> 00:42:18,000
然后他就说

809
00:42:18,000 --> 00:42:19,000
我这个浏览器啊

810
00:42:19,000 --> 00:42:20,000
我这个浏览器啊

811
00:42:20,000 --> 00:42:22,000
我这个浏览器的引擎去解析那个页面的 javascript 引擎

812
00:42:22,000 --> 00:42:26,000
但是现在问题就是说他没有办法去判断哪些东西是可以点的

813
00:42:26,000 --> 00:42:29,000
因为你知道浏览器就是 javascript 里面的很多可以点击

814
00:42:29,000 --> 00:42:31,000
可以可以 navigate 的项目

815
00:42:31,000 --> 00:42:35,000
他并不像说网页上你是一个 a 的那种这个 anchor 的 tag

816
00:42:35,000 --> 00:42:37,000
可以去很明显的发现了对吧

817
00:42:37,000 --> 00:42:39,000
所以其实对他们来讲

818
00:42:39,000 --> 00:42:43,000
速落引擎去去发现这些动态的内容始终是有问题的嘛

819
00:42:43,000 --> 00:42:49,000
所以这种情况下那种 asomorphic 的还是不可避免

820
00:42:49,000 --> 00:42:50,000
然后我

821
00:42:50,000 --> 00:42:54,000
我感觉就是说用 react 这种方式来实现 asomorphic 的话

822
00:42:54,000 --> 00:42:57,000
它的难度是相就极大的被降低了吧

823
00:42:57,000 --> 00:43:02,000
就相对于你之前手工的去要么用 fantasyjs 去做一个这个什么 render farm

824
00:43:02,000 --> 00:43:04,000
手工的去渲染一下

825
00:43:04,000 --> 00:43:05,000
因为这个比较高成本嘛

826
00:43:05,000 --> 00:43:09,000
然后另外就是说它可以实现那个所谓的无缝迁移

827
00:43:09,000 --> 00:43:12,000
就是你可以随意决定哪一部分是在服务端渲染

828
00:43:12,000 --> 00:43:14,000
然后哪一部分是在这个客户端渲染嘛

829
00:43:14,000 --> 00:43:17,000
这个是非常不不错的一个一个工具

830
00:43:17,000 --> 00:43:19,000
刚刚 real 做了一个非常好的总结

831
00:43:19,000 --> 00:43:25,000
在实际的运营中 react 可能是最好的 balance

832
00:43:25,000 --> 00:43:28,000
就是性能跟可管理性最好的 balance

833
00:43:28,000 --> 00:43:34,000
如果你的应用场景是你需要非常好的 performance 的话

834
00:43:34,000 --> 00:43:38,000
那或许你应该去看其他的一些选项

835
00:43:38,000 --> 00:43:43,000
比方说用共用 template 而不是共用 javascript logic

836
00:43:43,000 --> 00:43:48,000
然后在服务器端用服务器的 native languagewhateverphp orjavascript

837
00:43:48,000 --> 00:43:54,000
来写这个 template 的 render function

838
00:43:54,000 --> 00:43:59,000
这样的话你要写两个 rendering 的 application

839
00:43:59,000 --> 00:44:03,000
在你的工程上是更麻烦

840
00:44:03,000 --> 00:44:06,000
但是如果你要追求性能的话那是一个更好的选项

841
00:44:06,000 --> 00:44:09,000
react 现在的问题是在于说

842
00:44:09,000 --> 00:44:12,000
即使你在服务器端渲染

843
00:44:12,000 --> 00:44:17,000
react 还是会给你做很多不必要的 dom 的操作

844
00:44:18,000 --> 00:44:20,000
或者是模拟

845
00:44:20,000 --> 00:44:23,000
有什么具体的情况

846
00:44:23,000 --> 00:44:27,000
as a result 有公司做了测试

847
00:44:27,000 --> 00:44:33,000
然后 as a result 相对于说就是我刚说的那个用 php 来 render 这个 template 的话

848
00:44:33,000 --> 00:44:42,000
它的输出只有只有那个 template 的大概 25%

849
00:44:42,000 --> 00:44:43,000
有差这么多吗

850
00:44:43,000 --> 00:44:45,000
但是这个是非常可以优化的

851
00:44:45,000 --> 00:44:47,000
因为有很多 dom 的

852
00:44:47,000 --> 00:44:48,000
就是比方说

853
00:44:48,000 --> 00:44:49,000
event handling 这些东西

854
00:44:49,000 --> 00:44:52,000
在服务器端都没有必要去关联了嘛

855
00:44:52,000 --> 00:44:53,000
对吧

856
00:44:53,000 --> 00:44:55,000
因为你最终只需要一个静态的页面

857
00:44:55,000 --> 00:44:57,000
你只需要这个静态的结果

858
00:44:57,000 --> 00:45:02,000
但是这就是一个 open source project 很有趣的地方了嘛

859
00:45:02,000 --> 00:45:05,000
Facebook 本身对这个没有太大的兴趣

860
00:45:05,000 --> 00:45:07,000
因为他们没有太大的这个需求

861
00:45:07,000 --> 00:45:10,000
但是如果其他公司或者是你

862
00:45:10,000 --> 00:45:12,000
我们听众对此有需求的话

863
00:45:12,000 --> 00:45:14,000
可以去看他们的 source code

864
00:45:14,000 --> 00:45:17,000
然后对这个 virtual dom 做出一些修改

865
00:45:17,000 --> 00:45:20,000
来实现更好的在 server 上 render 的功能

866
00:45:20,000 --> 00:45:22,000
我想这个潜力是非常非常大的

867
00:45:22,000 --> 00:45:25,000
因为它现在是基本上是没有任何优化的

868
00:45:25,000 --> 00:45:26,000
对对对

869
00:45:26,000 --> 00:45:28,000
就在这种情况下都还是挺好

870
00:45:28,000 --> 00:45:29,000
我觉得

871
00:45:29,000 --> 00:45:31,000
说到这个 react

872
00:45:31,000 --> 00:45:33,000
在实际使用的时候

873
00:45:33,000 --> 00:45:35,000
就会牵涉到一个很有意思的

874
00:45:35,000 --> 00:45:37,000
它的写法或者一个语言

875
00:45:37,000 --> 00:45:39,000
叫做 jsx

876
00:45:39,000 --> 00:45:40,000
就是什么概念呢

877
00:45:40,000 --> 00:45:42,000
就是说因为我们是在传统上

878
00:45:42,000 --> 00:45:44,000
我们写一个前端应用的时候

879
00:45:44,000 --> 00:45:46,000
我们是把这个模板和这个数据

880
00:45:46,000 --> 00:45:49,000
或者逻辑完全分离开来的嘛

881
00:45:49,000 --> 00:45:52,000
就模板可能会用什么什么 mustache

882
00:45:52,000 --> 00:45:55,000
之类的一些东西来用 html 来写一个模板

883
00:45:55,000 --> 00:45:56,000
然后留些空

884
00:45:56,000 --> 00:46:00,000
然后当那个 javascript 去把模板这个 load

885
00:46:00,000 --> 00:46:01,000
然后把那个空填上

886
00:46:01,000 --> 00:46:03,000
就 render 出一个进它的页面

887
00:46:03,000 --> 00:46:05,000
再发给出去填到页面里面去

888
00:46:05,000 --> 00:46:07,000
但是在 react 里面去

889
00:46:07,000 --> 00:46:09,000
他们推荐的方式是说

890
00:46:09,000 --> 00:46:12,000
不要区分这个模板和这个数据和逻辑

891
00:46:12,000 --> 00:46:14,000
你是做一个前端应用

892
00:46:14,000 --> 00:46:16,000
你的这个模板就是你的这个要求

893
00:46:16,000 --> 00:46:18,000
你把这个核心考虑的一部分

894
00:46:18,000 --> 00:46:22,000
我觉得这是 react 的 rethink best practice 的一部分吧

895
00:46:22,000 --> 00:46:25,000
理论上来说我们之前做 follow 的那个 best practice

896
00:46:25,000 --> 00:46:27,000
是说把模板分离开来

897
00:46:27,000 --> 00:46:29,000
这样的话你有更好的重用性

898
00:46:29,000 --> 00:46:32,000
因为你那个模板是可以被重用的对吧

899
00:46:32,000 --> 00:46:34,000
可是如果你看这个 jsx 的话

900
00:46:34,000 --> 00:46:36,000
它实际上不是一个模板

901
00:46:36,000 --> 00:46:37,000
它完全不是一个模板

902
00:46:37,000 --> 00:46:39,000
你其实就是写 javascript code 嘛

903
00:46:39,000 --> 00:46:40,000
你你你所写的

904
00:46:40,000 --> 00:46:45,000
你只不过是用一种类似于写模板的语法去描述数据吧

905
00:46:45,000 --> 00:46:46,000
对 exactly

906
00:46:46,000 --> 00:46:52,000
就是它你对你在你你在你用一种写模板的方式去写你的 data model

907
00:46:52,000 --> 00:46:54,000
这其实是一种进步

908
00:46:54,000 --> 00:46:58,000
而不是就是某种抨击的某种某些人抨击的那样

909
00:46:58,000 --> 00:46:59,000
是一种历史的跳退

910
00:46:59,000 --> 00:47:02,000
我觉得可能对这个事情就其实挺好玩

911
00:47:02,000 --> 00:47:07,000
因为刚那个就是 react 去年刚发布正式对外发布的时候

912
00:47:07,000 --> 00:47:08,000
很多人就是吐槽这一点嘛

913
00:47:08,000 --> 00:47:11,000
因为大家都可能被这个教条教条惯了啊

914
00:47:11,000 --> 00:47:14,000
就说这个模板和数据要分离

915
00:47:14,000 --> 00:47:16,000
但其实我觉得当时那个 p

916
00:47:16,000 --> 00:47:18,000
他有一个话说的很好

917
00:47:18,000 --> 00:47:19,000
就是说这个模板

918
00:47:19,000 --> 00:47:23,000
他他分的那个就 supersionconcern 是分错了

919
00:47:23,000 --> 00:47:26,000
他把两个不应该分开的东西强行分开了

920
00:47:26,000 --> 00:47:28,000
但其实没有太多的好处嘛

921
00:47:28,000 --> 00:47:31,000
啊所以通过这上那个 react 这种 jsx 方式

922
00:47:31,000 --> 00:47:35,000
其实把这两个本来就应该紧密联系在一起的

923
00:47:35,000 --> 00:47:37,000
呃不两个部分放在一个地方

924
00:47:37,000 --> 00:47:38,000
然后大家可以一眼看到

925
00:47:38,000 --> 00:47:41,000
就好像那个为了之前抱怨的说

926
00:47:41,000 --> 00:47:45,000
那个 backbone 里面写很多这种 subview 的时候不方便说

927
00:47:45,000 --> 00:47:47,000
对一个文件里面就看出他在干什么

928
00:47:47,000 --> 00:47:49,000
然后用这种 jsx 的方式

929
00:47:49,000 --> 00:47:50,000
你可以一眼看出啊

930
00:47:50,000 --> 00:47:52,000
我这个是在做一个模板

931
00:47:52,000 --> 00:47:54,000
我在这个模板里面填充了这么一个数据

932
00:47:54,000 --> 00:47:57,000
然后这个数据是从这个对象哪个地方来的

933
00:47:57,000 --> 00:48:00,000
然后这个我要添加哪些这个 event handler

934
00:48:00,000 --> 00:48:02,000
都在同一个地方完成这个东西

935
00:48:02,000 --> 00:48:06,000
这个才是一个好的所谓的这个这个 encapsulation

936
00:48:06,000 --> 00:48:07,000
我要再一次提醒大家

937
00:48:07,000 --> 00:48:09,000
就是你需要考虑自己的实际问题

938
00:48:09,000 --> 00:48:11,000
然后选择正确的啊

939
00:48:11,000 --> 00:48:13,000
framework 或者 conventionadopt

940
00:48:13,000 --> 00:48:14,000
啊

941
00:48:15,000 --> 00:48:17,000
我们刚刚说那个 asomorphic 对不对

942
00:48:17,000 --> 00:48:18,000
在那种情况下

943
00:48:18,000 --> 00:48:21,000
实际上你如果你分离出模板来的话是有好处的

944
00:48:21,000 --> 00:48:28,000
因为如果你要在啊在你的你的后端用另外一种语言来写你的 render logic 的话

945
00:48:28,000 --> 00:48:31,000
那那个共用模板是可以共用的

946
00:48:31,000 --> 00:48:33,000
但你得看在你的实际上实用过程中

947
00:48:33,000 --> 00:48:35,000
我们是没有这么错的

948
00:48:35,000 --> 00:48:38,000
然后我们所有的模板是没有任何重用性的

949
00:48:38,000 --> 00:48:40,000
就是也不是没有任何重用性

950
00:48:40,000 --> 00:48:41,000
而是没有

951
00:48:41,000 --> 00:48:43,000
呃它是有很强的重用性

952
00:48:43,000 --> 00:48:45,000
因为因为它它它在

953
00:48:45,000 --> 00:48:48,000
另外一个就是单独的自己的那个文件中的话

954
00:48:48,000 --> 00:48:50,000
但是我们从来没有重用过它

955
00:48:50,000 --> 00:48:51,000
从来没有重用过它

956
00:48:51,000 --> 00:48:54,000
在三年的写这个程序的过程中

957
00:48:54,000 --> 00:48:56,000
那那到底做这个事情是为了什么

958
00:48:56,000 --> 00:48:59,000
我们其实也不是很清楚

959
00:48:59,000 --> 00:49:00,000
没想明白

960
00:49:00,000 --> 00:49:02,000
所以在在特定的应用场景下

961
00:49:02,000 --> 00:49:04,000
特定的 best practice 是有道理的

962
00:49:04,000 --> 00:49:06,000
比方说我们刚刚说那个

963
00:49:06,000 --> 00:49:09,000
你如果一个一个模板要在不同的语言中被 render 的话

964
00:49:09,000 --> 00:49:11,000
那实际上是非常好的一个设计

965
00:49:11,000 --> 00:49:12,000
但如果你仅仅是在加号说呢

966
00:49:12,000 --> 00:49:15,000
那可能真的你得重新考虑这个事情

967
00:49:15,000 --> 00:49:16,000
那你到底是不是有意义的

968
00:49:16,000 --> 00:49:18,000
何况你用 react 的时候

969
00:49:18,000 --> 00:49:20,000
这就真的不是模板了

970
00:49:20,000 --> 00:49:21,000
这个模板这个东西不存在的

971
00:49:21,000 --> 00:49:23,000
它所有的东西都是呃

972
00:49:23,000 --> 00:49:24,000
JavaScript object

973
00:49:24,000 --> 00:49:26,000
There's no string template

974
00:49:26,000 --> 00:49:28,000
这个这个念头你得转过弯来

975
00:49:28,000 --> 00:49:30,000
对啊你写这

976
00:49:30,000 --> 00:49:31,000
它只是看起来像而已

977
00:49:31,000 --> 00:49:32,000
但完全不是

978
00:49:32,000 --> 00:49:34,000
呃好处在于说啊

979
00:49:34,000 --> 00:49:35,000
嗯

980
00:49:35,000 --> 00:49:40,000
呃刚刚我们说呃把 subview 的问题在在 backbone 里头

981
00:49:40,000 --> 00:49:43,000
你你得呃在模板里头给它留空间

982
00:49:43,000 --> 00:49:45,000
然后再 manually insert

983
00:49:45,000 --> 00:49:47,000
进去在呃 react 中

984
00:49:47,000 --> 00:49:48,000
这就不是问题了

985
00:49:48,000 --> 00:49:50,000
你直接 import 一下

986
00:49:50,000 --> 00:49:52,000
然后 import 那个 sub sub sub component

987
00:49:52,000 --> 00:49:55,000
然后直接把这个 tag 写上去就好了

988
00:49:55,000 --> 00:49:58,000
这这是个非常非常非常好的呃

989
00:49:58,000 --> 00:49:59,000
呃

990
00:49:59,000 --> 00:50:00,000
呃

991
00:50:00,000 --> 00:50:02,000
就是重用性的进步吧

992
00:50:02,000 --> 00:50:08,000
对而且实际上也在也大量减轻了开发者的呃

993
00:50:08,000 --> 00:50:09,000
门头猫楼

994
00:50:09,000 --> 00:50:14,000
就是在在维护一个门头猫楼的的的的负担

995
00:50:14,000 --> 00:50:19,000
就是你不用总是在啊我现在写一个 template 啊我现在写 model

996
00:50:19,000 --> 00:50:23,000
你不用在维护这个不停的 contact switch 的成本上

997
00:50:23,000 --> 00:50:25,000
还有必须得提到的是

998
00:50:25,000 --> 00:50:28,000
gsx 并不是一个全新的东西

999
00:50:28,000 --> 00:50:30,000
在 facebook 内部

1000
00:50:30,000 --> 00:50:32,000
我这是一个开源的项目已经是啊

1001
00:50:32,000 --> 00:50:34,000
他们一直在用类似的产品

1002
00:50:34,000 --> 00:50:39,000
叫做 xhp 是 php 的呃版本

1003
00:50:39,000 --> 00:50:42,000
所以他们很长时间已经在 php 里写所谓 hp 的版本了

1004
00:50:42,000 --> 00:50:49,000
所以在这点上也是对这个 concept 的一个 validation 吧

1005
00:50:49,000 --> 00:50:53,000
因为毕竟 facebook 有用相同的概念用了很久了

1006
00:50:53,000 --> 00:50:58,000
所以我觉得他们先人一步啊已经 accept 的这个概念了

1007
00:50:58,000 --> 00:51:03,000
所以所以对他们来说啊就就不是一个事你知道吗

1008
00:51:03,000 --> 00:51:08,000
对我我大概也是就是前年去湾区的时候

1009
00:51:08,000 --> 00:51:12,000
然后看到他们就是在 facebook 内部是怎么用这个叫做 hp 的

1010
00:51:12,000 --> 00:51:14,000
这么个语言吗

1011
00:51:14,000 --> 00:51:18,000
去写这个啊这个他们都这个服务端的软件

1012
00:51:18,000 --> 00:51:19,000
当时我就震撼到了

1013
00:51:19,000 --> 00:51:23,000
我说哇这个就因为他们那个等于是可以任意构建一种

1014
00:51:23,000 --> 00:51:24,000
就传统上我们写这个模板的时候

1015
00:51:24,000 --> 00:51:27,000
你是只能用一个抽象程度很低的方式

1016
00:51:27,000 --> 00:51:29,000
因为你模板的话

1017
00:51:29,000 --> 00:51:32,000
你要么就在模板层别上你可以构建一些东西出来

1018
00:51:32,000 --> 00:51:36,000
或者是说呃你呃就你在写那些那些标签的时候

1019
00:51:36,000 --> 00:51:38,000
你还是要用那些标准的标签嘛

1020
00:51:38,000 --> 00:51:41,000
但是他们在用那个 xhp 的时候其实可以定义自己的一个标签嘛

1021
00:51:42,000 --> 00:51:47,000
然后这个标签可以包含很多很复杂的这种行为和数据

1022
00:51:47,000 --> 00:51:48,000
包括内部的结构在里面

1023
00:51:48,000 --> 00:51:51,000
而这个对这个标签的调用方来讲

1024
00:51:51,000 --> 00:51:53,000
完全可以不用关心里面到底是如何实现的

1025
00:51:53,000 --> 00:51:58,000
对其实就有点像一个 angular js 所做出来的新的 html tag

1026
00:51:58,000 --> 00:52:04,000
只不过这一切对他们他们这个他们应该也是叫做叫做 complement 吧

1027
00:52:04,000 --> 00:52:07,000
那个时候就就他就所谓这个组件化的时候

1028
00:52:07,000 --> 00:52:11,000
就组件化的时候就一个什么一个要达到一个什么样的呃场景呢

1029
00:52:11,000 --> 00:52:12,000
就是说什么呢

1030
00:52:12,000 --> 00:52:14,000
就是说我只要构建好我这个组件

1031
00:52:14,000 --> 00:52:17,000
我这个组件对外部来说是一个完全封闭的

1032
00:52:17,000 --> 00:52:23,000
你只要外部提供给我需要的这个数据和我需要的包括一些呃这个回调函数的话

1033
00:52:23,000 --> 00:52:25,000
我这个组件就能完成你需要的工作

1034
00:52:25,000 --> 00:52:28,000
就不再需要去每个人都去看到这个组件啊

1035
00:52:28,000 --> 00:52:33,000
内部是有多少个什么多少个 a tag 多少个 div 这种层层包起来这么一个东西

1036
00:52:33,000 --> 00:52:37,000
这一点我觉得是一个在抽象层级上是一个划时代的进步

1037
00:52:37,000 --> 00:52:40,000
我觉得嗯是啊啊

1038
00:52:40,000 --> 00:52:42,000
然后当时那个就是

1039
00:52:42,000 --> 00:52:44,000
我看到 facebook 他们内部在用这个最后这么好

1040
00:52:44,000 --> 00:52:50,000
就是哇这个真是因为我没有在其他地方看到有类似的产品或者是语言吧

1041
00:52:50,000 --> 00:52:51,000
在做类似的事情

1042
00:52:51,000 --> 00:53:00,000
我真的是感觉走走在什么时代的前列的那种不跟我们不跟其他的人确实差的领先的蛮远的

1043
00:53:00,000 --> 00:53:04,000
那我们下面讲那个 reactive 吧

1044
00:53:04,000 --> 00:53:06,000
呃 es 6

1045
00:53:06,000 --> 00:53:07,000
我讲了

1046
00:53:07,000 --> 00:53:09,000
那个那其实不是很重要

1047
00:53:09,000 --> 00:53:11,000
我觉得 ok 这个是为了为了这个

1048
00:53:11,000 --> 00:53:13,000
为了为了你觉得呢

1049
00:53:13,000 --> 00:53:14,000
说到 es 6 呢

1050
00:53:14,000 --> 00:53:15,000
啊

1051
00:53:15,000 --> 00:53:20,000
我觉得 angular 跟这主要是 hangular 跟 reactive 区别之一吧

1052
00:53:20,000 --> 00:53:21,000
因为啊

1053
00:53:21,000 --> 00:53:23,000
就是 reactive 似乎在啊

1054
00:53:23,000 --> 00:53:28,000
他的发展过程中考虑了更多的 java script native 的东西

1055
00:53:28,000 --> 00:53:31,000
while angular 好像在创造一个自己的小世界

1056
00:53:31,000 --> 00:53:32,000
啊

1057
00:53:32,000 --> 00:53:34,000
我们有一个 panel 上啊

1058
00:53:34,000 --> 00:53:36,000
有那个 substion 啊

1059
00:53:36,000 --> 00:53:38,000
是 reactive 的主要的啊

1060
00:53:38,000 --> 00:53:39,000
维护者之一

1061
00:53:39,000 --> 00:53:40,000
然后他实际上他就是一个人的主要的维护者之一

1062
00:53:40,000 --> 00:53:44,000
然后他实际上他本身是在那个 es 6 的啊

1063
00:53:44,000 --> 00:53:46,000
那个委员会上的

1064
00:53:46,000 --> 00:53:48,000
所以他有提到说啊

1065
00:53:48,000 --> 00:53:53,000
reactive 是非常非常 aggressive 在推 es 6 的支持

1066
00:53:53,000 --> 00:53:56,000
他甚至把那个 mixing 的支持给去掉了

1067
00:53:56,000 --> 00:53:57,000
在最新的版本

1068
00:53:57,000 --> 00:53:58,000
拿掉了吗

1069
00:53:58,000 --> 00:54:04,000
他解释呢是因为 es 6 的啊 mixing 支持在那个

1070
00:54:04,000 --> 00:54:06,000
不是比较糟糕

1071
00:54:06,000 --> 00:54:08,000
而是而是在那个 standard 中被去掉了

1072
00:54:08,000 --> 00:54:10,000
就是 es 6 现在

1073
00:54:10,000 --> 00:54:14,000
的那个标准就是在这一版中的话是不没有 mixing 的

1074
00:54:14,000 --> 00:54:15,000
没有提到 mixing 的

1075
00:54:15,000 --> 00:54:18,000
他们在 es 7 中才会支持 mixing

1076
00:54:18,000 --> 00:54:21,000
或者说才会把这个事情再提上一层

1077
00:54:21,000 --> 00:54:22,000
所以这因为如此呢

1078
00:54:22,000 --> 00:54:25,000
在那个 native 的 classup 过程中

1079
00:54:25,000 --> 00:54:28,000
reactive 把那个 mixing 给给给去掉了

1080
00:54:28,000 --> 00:54:29,000
啊

1081
00:54:29,000 --> 00:54:30,000
当然这些事情都是 on going events

1082
00:54:30,000 --> 00:54:31,000
所以所以啊

1083
00:54:31,000 --> 00:54:34,000
还有可能有其他的变化啊

1084
00:54:34,000 --> 00:54:35,000
不过我觉得啊

1085
00:54:35,000 --> 00:54:37,000
至少在我看来的话啊

1086
00:54:37,000 --> 00:54:38,000
reactive 是非常啊

1087
00:54:38,000 --> 00:54:40,000
在积极的推动

1088
00:54:40,000 --> 00:54:42,000
和啊 common 就是啊

1089
00:54:42,000 --> 00:54:46,000
实现这个 es 6 的这个标准

1090
00:54:46,000 --> 00:54:54,000
哎其实你为了你对这个 es 6 就是 javascript 下一个版本的这个语言

1091
00:54:54,000 --> 00:54:56,000
你你什么样你是什么样的态度啊

1092
00:54:56,000 --> 00:54:59,000
老实说我不是很熟悉

1093
00:54:59,000 --> 00:55:01,000
所以我把这段剪辑掉吧

1094
00:55:01,000 --> 00:55:03,000
哈哈哈

1095
00:55:03,000 --> 00:55:04,000
我没有用

1096
00:55:04,000 --> 00:55:06,000
我没有我自己有谁比较熟悉吗

1097
00:55:06,000 --> 00:55:08,000
有人有人紧跟着 e 7

1098
00:55:08,000 --> 00:55:09,000
二我有我有在跟这个啊

1099
00:55:09,000 --> 00:55:10,000
你再跟了啊

1100
00:55:10,000 --> 00:55:12,000
对你现在在搞这个吧

1101
00:55:12,000 --> 00:55:14,000
没有没有我有在也有在用它嘛

1102
00:55:14,000 --> 00:55:16,000
就是在就尝试去使用它

1103
00:55:16,000 --> 00:55:18,000
现在我把说我昨天还在转

1104
00:55:18,000 --> 00:55:23,000
就是那个那个 ipn 背后不是有个我自己写的 cms 吗

1105
00:55:23,000 --> 00:55:24,000
嗯哼

1106
00:55:24,000 --> 00:55:25,000
然后有一个管理后台

1107
00:55:25,000 --> 00:55:26,000
那个其实是用 react 写的

1108
00:55:26,000 --> 00:55:27,000
嗯

1109
00:55:27,000 --> 00:55:30,000
那哎那我想想那我是先讲 relai 呢

1110
00:55:30,000 --> 00:55:31,000
还是先讲这个 reactive

1111
00:55:31,000 --> 00:55:35,000
因为 native 实际上是个非常非常非常啊自然的过渡

1112
00:55:35,000 --> 00:55:36,000
因为啊

1113
00:55:36,000 --> 00:55:38,000
在 react 中

1114
00:55:38,000 --> 00:55:43,000
你的最最初的版本中你的那个 render target 是 virtual dom

1115
00:55:43,000 --> 00:55:44,000
对不对

1116
00:55:44,000 --> 00:55:47,000
嗯但是为什么一定要 render 到 dom 上来

1117
00:55:47,000 --> 00:55:48,000
已经反正已经 virtualized 了

1118
00:55:48,000 --> 00:55:51,000
你你就就好像你你你用那个虚拟机一样

1119
00:55:51,000 --> 00:55:54,000
你到底那个虚拟机是在 window 上 run

1120
00:55:54,000 --> 00:55:55,000
是在 mac 上 run

1121
00:55:55,000 --> 00:55:59,000
是在 you know likeos 2 上 run

1122
00:55:59,000 --> 00:56:01,000
不并不重要嘛对吧

1123
00:56:01,000 --> 00:56:02,000
啊所以

1124
00:56:02,000 --> 00:56:03,000
对对对

1125
00:56:03,000 --> 00:56:06,000
就等于它提供一层新的抽象

1126
00:56:06,000 --> 00:56:08,000
然后借入这层新的抽象

1127
00:56:08,000 --> 00:56:09,000
你就有了新的自由

1128
00:56:09,000 --> 00:56:10,000
你可以把它

1129
00:56:10,000 --> 00:56:14,000
你可以把呃它的底层迁移到其他的 platform 上面

1130
00:56:14,000 --> 00:56:18,000
对我我忘了是那个是 tom 还是那个 christopher 说的

1131
00:56:18,000 --> 00:56:21,000
就是说他说我们他们之前做那个 virtual dom 的时候

1132
00:56:21,000 --> 00:56:25,000
的最终目的并不是说要把这个 dom virtualize

1133
00:56:25,000 --> 00:56:26,000
这件事情本身

1134
00:56:26,000 --> 00:56:28,000
而是说要完全去掉这个 dom

1135
00:56:28,000 --> 00:56:31,000
就是要把 react 跟这个 dom 的依赖直接切掉

1136
00:56:31,000 --> 00:56:32,000
就没完全没有关系

1137
00:56:32,000 --> 00:56:34,000
我可以不依赖一个 dom

1138
00:56:34,000 --> 00:56:36,000
然后最终的结果就是我们现在看到的

1139
00:56:36,000 --> 00:56:38,000
他这次发布了一个重量级的产品

1140
00:56:38,000 --> 00:56:39,000
叫做 react

1141
00:56:39,000 --> 00:56:40,000
呃一个一个工具吧

1142
00:56:40,000 --> 00:56:41,000
叫做 react native

1143
00:56:41,000 --> 00:56:42,000
呃什么意思呢

1144
00:56:42,000 --> 00:56:43,000
简单描述一下

1145
00:56:43,000 --> 00:56:44,000
就是说

1146
00:56:44,000 --> 00:56:46,000
我还是用 java script 写我的应用

1147
00:56:46,000 --> 00:56:48,000
但是呃相比在网页上

1148
00:56:48,000 --> 00:56:54,000
我是是是把它渲染成一个网页的那些呃 html 的这种嗯 tag 标签的话

1149
00:56:54,000 --> 00:56:59,000
我是直接用呃这个某一个平台原生的 UI 组件

1150
00:56:59,000 --> 00:57:01,000
比如说在 iOS 里面就是一个原生的

1151
00:57:01,000 --> 00:57:02,000
比如说这个列表

1152
00:57:02,000 --> 00:57:04,000
那个可以滚动的那种有带重力

1153
00:57:04,000 --> 00:57:08,000
呃不叫带什么加速度的惯性的那种呃滚动的那种呃

1154
00:57:08,000 --> 00:57:14,000
或者说是我用一个原生的这个地图这个组件来实现我的这个功能

1155
00:57:14,000 --> 00:57:17,000
呃但是我的这个这个程序的实际的后台的所有的这个 model 啊

1156
00:57:17,000 --> 00:57:18,000
还有所有的数据啊

1157
00:57:18,000 --> 00:57:19,000
还有包括这些逻辑啊

1158
00:57:19,000 --> 00:57:21,000
都其实是在 java script 里面运行的

1159
00:57:21,000 --> 00:57:22,000
对

1160
00:57:22,000 --> 00:57:25,000
而这个我觉得是非常了不了不得的一个事情啊

1161
00:57:25,000 --> 00:57:29,000
就是说呃我知道很多这个 iOS 或者是安卓开发都在吐槽

1162
00:57:29,000 --> 00:57:37,000
这个开就在其实哪怕是现在应该开发一个新应用或者安卓应用都还不是那么爽的一件事情啊

1163
00:57:37,000 --> 00:57:38,000
他有点像

1164
00:57:38,000 --> 00:57:39,000
在 backbound 时代的

1165
00:57:39,000 --> 00:57:43,000
有一点像在 backbound 时代的开发 webapp 的感觉

1166
00:57:43,000 --> 00:57:44,000
对啊

1167
00:57:44,000 --> 00:57:51,000
我觉得对我来讲最重要的概念在 react native 中最重要的概念是呃 what Tom said

1168
00:57:51,000 --> 00:57:52,000
um

1169
00:57:52,000 --> 00:57:55,000
learn once write everywhere

1170
00:57:55,000 --> 00:57:59,000
react native 它本身是要你 write once run everywhere

1171
00:57:59,000 --> 00:58:07,000
他没有他没有他 react native 本身他没有啊 merge the gap between android and ios

1172
00:58:07,000 --> 00:58:09,000
android 还是要写 androidapp

1173
00:58:09,000 --> 00:58:11,000
iOS 还是要写 iOSapp

1174
00:58:11,000 --> 00:58:14,000
但是你写程序的方方式发生了根本的变化

1175
00:58:14,000 --> 00:58:19,000
不管是写 webapp 好还是写 androidapp 好还是写 iOSapp 好

1176
00:58:19,000 --> 00:58:27,000
你会用 exact the same way 来写这三个不同的啊环境下的 application

1177
00:58:27,000 --> 00:58:32,000
只是你你你会用这个这个环境的对内部的组件嘛

1178
00:58:32,000 --> 00:58:35,000
这这一点上是非常非常有意义的啊

1179
00:58:35,000 --> 00:58:38,000
我本人对此也是深有感触

1180
00:58:38,000 --> 00:58:43,000
因为啊我之前有写一个 iOSapp 啊我不是 word font

1181
00:58:43,000 --> 00:58:48,000
我我我现在还在写另外一个啊小小的小小的说一下

1182
00:58:48,000 --> 00:58:50,000
我有在写另外一个 iOSapp

1183
00:58:50,000 --> 00:58:52,000
然后其中有很多的 layouting

1184
00:58:52,000 --> 00:58:53,000
嗯

1185
00:58:53,000 --> 00:58:55,000
实际上是一个逻辑上来讲是一个比较简单的 app

1186
00:58:55,000 --> 00:58:58,000
但是有很多 layouting 啊我有一个 ui label

1187
00:58:58,000 --> 00:59:01,000
这个 ui label 是可变的长度

1188
00:59:01,000 --> 00:59:05,000
然后这个 ui label 呢又在那个啊一个可变的长度上

1189
00:59:05,000 --> 00:59:08,000
可变长度的 ui table sale 中

1190
00:59:08,000 --> 00:59:12,000
啊就实际上如果你想用 auto layouting 的话

1191
00:59:12,000 --> 00:59:14,000
这是一个非常非常麻烦的事情

1192
00:59:14,000 --> 00:59:17,000
因为在 ui label 第一次 render 的时候

1193
00:59:17,000 --> 00:59:19,000
他并不知道他的宽度

1194
00:59:19,000 --> 00:59:20,000
他如果他不知道他的宽度呢

1195
00:59:20,000 --> 00:59:22,000
他就不知道他的高度

1196
00:59:22,000 --> 00:59:23,000
他不知道他的高度呢

1197
00:59:23,000 --> 00:59:24,000
他就乱 render

1198
00:59:24,000 --> 00:59:29,000
你就得啊 auto layouting 呢是 all about constraints

1199
00:59:29,000 --> 00:59:32,000
所以你需要设计一系列的 constraints

1200
00:59:32,000 --> 00:59:35,000
然后这个 layout 引擎会来猜测

1201
00:59:35,000 --> 00:59:38,000
怎么样的结果能够满足你所有的 constraints

1202
00:59:38,000 --> 00:59:40,000
或者尽量满足你的 constraints

1203
00:59:40,000 --> 00:59:42,000
这是一个非常 non-tunitive 的 way

1204
00:59:42,000 --> 00:59:47,000
然后从 web 的角度来说的话 box model 多多简单啊

1205
00:59:47,000 --> 00:59:49,000
虽然说 box model 有时候不工作

1206
00:59:49,000 --> 00:59:52,000
但是多简单啊你知道就是所有的东西就是 box top box

1207
00:59:52,000 --> 00:59:54,000
box 在 box 之上

1208
00:59:54,000 --> 00:59:56,000
然后你有 margin

1209
00:59:56,000 --> 00:59:57,000
你有 padding

1210
00:59:57,000 --> 00:59:58,000
你有 border

1211
00:59:58,000 --> 01:00:00,000
其实非常非常容易理解

1212
01:00:00,000 --> 01:00:05,000
非常直观的直观的一种模式

1213
01:00:05,000 --> 01:00:08,000
反观的 iOS 如果你不用 auto layout

1214
01:00:08,000 --> 01:00:10,000
就是 constraints 非常难以理解

1215
01:00:10,000 --> 01:00:12,000
然后你那个结果也不 intuitive

1216
01:00:12,000 --> 01:00:15,000
你如果只给我一系列的 constraints

1217
01:00:15,000 --> 01:00:17,000
如果你不告诉我结果的话

1218
01:00:17,000 --> 01:00:22,000
我很难说我很有信心说这些 constraints 会得到我想要的结果

1219
01:00:22,000 --> 01:00:27,000
我觉得可能最重大的一个差别就是 constraints based layout

1220
01:00:27,000 --> 01:00:35,000
要求你能够在头脑中维护一个最终视觉效果的模式

1221
01:00:35,000 --> 01:00:39,000
而 box model 对此要求就低一点

1222
01:00:39,000 --> 01:00:41,000
或者说低很多吧应该说

1223
01:00:41,000 --> 01:00:43,000
如果你不用 auto layout 的话呢

1224
01:00:43,000 --> 01:00:47,000
你又得就是 manually 去做很多的 math

1225
01:00:47,000 --> 01:00:50,000
如果你看那个 Christopher 的 slide

1226
01:00:50,000 --> 01:00:53,000
他有一张全都是 math math math math

1227
01:00:53,000 --> 01:00:54,000
Exactly right

1228
01:00:54,000 --> 01:00:57,000
但倒也不是说有多难多容易

1229
01:00:57,000 --> 01:00:59,000
很多那个 iOS 看法就跟我说那不难

1230
01:00:59,000 --> 01:01:00,000
麻烦嘛

1231
01:01:00,000 --> 01:01:02,000
但是那 ugly 啊多丑陋啊我靠

1232
01:01:02,000 --> 01:01:05,000
然后你想要改一点什么东西的话

1233
01:01:05,000 --> 01:01:06,000
又回头得去算

1234
01:01:06,000 --> 01:01:09,000
然后哦妈呀真的是真可怕

1235
01:01:09,000 --> 01:01:10,000
对吧

1236
01:01:10,000 --> 01:01:12,000
React Native

1237
01:01:12,000 --> 01:01:16,000
所以我觉得其实他们这次做的那个就是他们发布的 react native

1238
01:01:16,000 --> 01:01:17,000
他们也解决了这个问题啊

1239
01:01:17,000 --> 01:01:24,000
他们用 javascript 实现了一套那个 css 最新的那个叫做 flexbox 的那个 box model 嘛

1240
01:01:24,000 --> 01:01:25,000
对

1241
01:01:25,000 --> 01:01:32,000
然后他们用那个模型就去解决了这个在去怎么去布局那些原生的 UI 组件的问题

1242
01:01:32,000 --> 01:01:34,000
这个我觉得就刚才那个 Will 也已经

1243
01:01:34,000 --> 01:01:35,000
大家相信已经听出来啊

1244
01:01:35,000 --> 01:01:39,000
为了对这个什么 constraint layoutauto layout 这东西已经吐槽很久了

1245
01:01:39,000 --> 01:01:43,000
其实就从我一个意义上讲那个什么 constraint based layout 的话

1246
01:01:43,000 --> 01:01:49,000
其实它是要你在你头脑中构建一个这个就是这个就是什么动态规划机

1247
01:01:49,000 --> 01:01:50,000
对吧

1248
01:01:50,000 --> 01:01:53,000
你得自己在头脑中随时解那个解那个方程

1249
01:01:53,000 --> 01:01:55,000
解完之后才说哦这个这个会出现在那里

1250
01:01:55,000 --> 01:01:56,000
这个会出现在那里

1251
01:01:56,000 --> 01:01:57,000
就不像那个 box model

1252
01:01:57,000 --> 01:02:00,000
它是更加反映出是一个比较直观的话

1253
01:02:00,000 --> 01:02:01,000
这个应该是多大

1254
01:02:01,000 --> 01:02:02,000
它应该有多宽

1255
01:02:02,000 --> 01:02:04,000
然后它多到一个

1256
01:02:04,000 --> 01:02:07,000
一个一个边框是就那个什么 margin 东西叫什么来的

1257
01:02:07,000 --> 01:02:08,000
留白对吧

1258
01:02:08,000 --> 01:02:12,000
留白要多少或者是跟其他的东西间距要多少

1259
01:02:12,000 --> 01:02:17,000
我这个确实是 CSS 就是这个比较好的解决的一个地方

1260
01:02:17,000 --> 01:02:23,000
就我我很好奇为什么像 iOS 啊 Android 之前他们没有用到这种同样的模型去做这个事情

1261
01:02:23,000 --> 01:02:25,000
这是一个很好问题

1262
01:02:25,000 --> 01:02:34,000
其实这个可以将来专门找一期谈这个就是为什么 box model 这种看起来如此简单

1263
01:02:34,000 --> 01:02:36,000
一行又呃

1264
01:02:36,000 --> 01:02:37,000
呃

1265
01:02:37,000 --> 01:02:40,000
又呃大量解放生产力的布局

1266
01:02:40,000 --> 01:02:42,000
仅仅在 web 领域独树一帜

1267
01:02:42,000 --> 01:02:49,000
就甚至很多比如说排版软件都完全不去考虑这种这种嗯

1268
01:02:49,000 --> 01:02:52,000
但我觉得可能还是惯性在里面吧

1269
01:02:52,000 --> 01:02:55,000
对这个是挺挺奇怪的

1270
01:02:55,000 --> 01:02:56,000
比如说你说 iOS 为什么不用它

1271
01:02:56,000 --> 01:02:59,000
iOS 不用它是因为 OS 10 不用它

1272
01:02:59,000 --> 01:03:00,000
哈哈哈哈

1273
01:03:00,000 --> 01:03:03,000
iOS 毕竟一开始只是啊 OS 10 的一个改版嘛

1274
01:03:03,000 --> 01:03:04,000
就

1275
01:03:04,000 --> 01:03:05,000
嗯

1276
01:03:05,000 --> 01:03:10,000
就麦克上的 app 不可能来不从来没有用过 box layout

1277
01:03:10,000 --> 01:03:13,000
所以对 iOS 上面也就不用了

1278
01:03:13,000 --> 01:03:16,000
就这次这个 react native 它发布的

1279
01:03:16,000 --> 01:03:17,000
我觉得还有一点

1280
01:03:17,000 --> 01:03:23,000
我觉得特别特别特别就是说就令人觉得比较呃惊奇的一点哈

1281
01:03:23,000 --> 01:03:33,000
就是它因为这个整个这个呃程序的逻辑和这些啊包括这个呃 model 啊都是在 javascript 里面实现的嘛

1282
01:03:33,000 --> 01:03:38,000
然后这个 javascript 它是依赖于一个就是所谓解析器或者是 javascript 引擎的嘛

1283
01:03:38,000 --> 01:03:42,000
对然后这个引擎可以不用跑在那个手机上面

1284
01:03:42,000 --> 01:03:47,000
它可以跑在他们在现场 demo 的时候它那个解解析器是跑在浏览器里面的

1285
01:03:47,000 --> 01:03:52,000
然后它可以在就是在 chrome 里面去改那个浏览器

1286
01:03:52,000 --> 01:03:54,000
然后及时重刷新一下

1287
01:03:54,000 --> 01:03:57,000
然后这个在那个 iOS 的这个 iphone 模拟器里面

1288
01:03:57,000 --> 01:04:02,000
那个对应的一个原生的 UI 的主那个那个界面

1289
01:04:02,000 --> 01:04:04,000
就随之发生改变了

1290
01:04:04,000 --> 01:04:05,000
这个非常非常了不得

1291
01:04:05,000 --> 01:04:10,000
这个在实际的 production 中是不不可能就是很很难实现的

1292
01:04:10,000 --> 01:04:19,000
啊 however 但是这反映了就是说啊 react 它 native 到底是怎么样实现从 javascript 到 native 的这个转换

1293
01:04:19,000 --> 01:04:24,000
啊 react maybe 不想要成为一个性能瓶颈

1294
01:04:24,000 --> 01:04:25,000
of course not right

1295
01:04:25,000 --> 01:04:32,000
啊所以它的实现方式就是在啊把 javascript 这个引擎放到单独的啊

1296
01:04:32,000 --> 01:04:36,000
background thread 中一个一个单独它自己一个单独的线程中

1297
01:04:36,000 --> 01:04:46,000
啊然后在这个线程中有一个 javascript 的引擎在啊不断的啊渲染然后得到结果

1298
01:04:46,000 --> 01:04:53,000
再通过 channel 的方式把这个渲染结果发回到那个你的主线程中

1299
01:04:53,000 --> 01:04:55,000
所以你的主线程是没有被 block 的

1300
01:04:55,000 --> 01:05:00,000
你随时这个结果就是说你的主线程总是很 smooth 的

1301
01:05:00,000 --> 01:05:01,000
反观

1302
01:05:01,000 --> 01:05:04,000
如果你用一个 webview 的啊一个一个解决方式

1303
01:05:04,000 --> 01:05:10,000
到先不说就是你你不能够用 native component 这种这种极大的问题

1304
01:05:10,000 --> 01:05:14,000
啊关键是说你的 javascript 是会 block 你的主线程的

1305
01:05:14,000 --> 01:05:18,000
所以说如果你 javascript 在做一些啊大量的运算的时候

1306
01:05:18,000 --> 01:05:23,000
那个啊用户如果在比方说在在在在向下滑那个页面

1307
01:05:23,000 --> 01:05:24,000
那页面就会不动嘛

1308
01:05:24,000 --> 01:05:26,000
就所以那个页面就不 smooth 嘛

1309
01:05:26,000 --> 01:05:31,000
你整个的那个体验就就很不意就就很不乐观了嘛

1310
01:05:31,000 --> 01:05:38,000
所以 react 既让你 react native 既让你使用 native component

1311
01:05:38,000 --> 01:05:43,000
有 native 的 experience 也从性能上帮助你啊

1312
01:05:43,000 --> 01:05:47,000
呃不要啊就是提供不好的体验

1313
01:05:47,000 --> 01:05:56,000
就他把这个啊 UI 的渲染和这个逻辑的就是就业务逻辑的执行是完全隔裂开朗

1314
01:05:56,000 --> 01:05:59,000
通过异步的方式进行通讯同步的嘛

1315
01:05:59,000 --> 01:06:01,000
啊这个是我觉得非常好

1316
01:06:01,000 --> 01:06:03,000
非常好的一件事情啊

1317
01:06:03,000 --> 01:06:05,000
但是这就牵涉到另外一个问题了

1318
01:06:05,000 --> 01:06:11,000
就他这样的话对这个后台的那个执行 javascript 解析器的那个进程的性能会有要求吗

1319
01:06:11,000 --> 01:06:13,000
比如比如说据我所知

1320
01:06:13,000 --> 01:06:19,000
在呃 iOS 上面这个你单独自己跑一个 javascript 的这个解析器的话

1321
01:06:19,000 --> 01:06:21,000
是没有那个他们那个叫什么来的

1322
01:06:21,000 --> 01:06:23,000
那个呃 JIT 的优化

1323
01:06:23,000 --> 01:06:29,000
啊这一点上我并不是特别清楚他们主要实现方式

1324
01:06:29,000 --> 01:06:31,000
但是有一点很重要的是

1325
01:06:31,000 --> 01:06:39,000
你刚刚说的那个问题只只有在你直接使用呃 webview 的情况下才会出现

1326
01:06:39,000 --> 01:06:40,000
嗯为什么

1327
01:06:40,000 --> 01:06:43,000
因为那个引擎是在那个 webview 里头啊

1328
01:06:43,000 --> 01:06:49,000
但是他们的那个 react 的实现方式是并不代表说他一定要用那个呃 javascript 引擎

1329
01:06:49,000 --> 01:06:53,000
他可以自己包装一个其他的呃 js 引擎在里头

1330
01:06:53,000 --> 01:06:59,000
就是他可以说我不用苹果那个 iOS 自带的那个 javascript 引擎

1331
01:06:59,000 --> 01:07:03,000
然后就是然后我自己包一个带 JIT 的这个 javascript 解析进去

1332
01:07:03,000 --> 01:07:04,000
这样执行吗

1333
01:07:04,000 --> 01:07:05,000
没错

1334
01:07:05,000 --> 01:07:12,000
ok 那这样不会就会撞到那个 apps 的审核条例的那某一条说不能自带解析器吗

1335
01:07:12,000 --> 01:07:13,000
真的吗

1336
01:07:13,000 --> 01:07:15,000
嗯有这么一条的曾经

1337
01:07:15,000 --> 01:07:20,000
我记得后来就因为那条苹果条约我记得我还写过 blog

1338
01:07:20,000 --> 01:07:23,000
就说他只能用规定的几种语言来写

1339
01:07:23,000 --> 01:07:26,000
但好像没有说不能自带虚拟机吧

1340
01:07:26,000 --> 01:07:28,000
不然那些什么带落案的东西是怎么背后的呢

1341
01:07:28,000 --> 01:07:32,000
对这就是一个挺模糊的一点

1342
01:07:32,000 --> 01:07:37,000
就是后来因为很多游戏他需要用那个路外解析器作为一些辅助的事情嘛

1343
01:07:37,000 --> 01:07:39,000
说他就后来又又通过

1344
01:07:39,000 --> 01:07:44,000
现在我要不太清楚苹果在对这件事情的这个的立场是什么

1345
01:07:44,000 --> 01:07:47,000
但是这个只能在在意了

1346
01:07:47,000 --> 01:07:48,000
呃我可以 factor check 一下

1347
01:07:48,000 --> 01:07:57,000
因为我有那个啊他们把那个 native 就是他的那个演示的代码给所有的语汇者都分享了一份

1348
01:07:57,000 --> 01:07:58,000
所以我是可以 factor check 一下

1349
01:07:58,000 --> 01:08:01,000
去看他们到底用什么硬体

1350
01:08:01,000 --> 01:08:02,000
ok

1351
01:08:02,000 --> 01:08:04,000
你可以看一下他用的是苹果原生的

1352
01:08:04,000 --> 01:08:08,000
就是那个叫什么 javascript core 的对对对 javascript core

1353
01:08:08,000 --> 01:08:09,000
我理解应该是吧

1354
01:08:09,000 --> 01:08:12,000
今天这个是个成成本比较低的方案嘛

1355
01:08:12,000 --> 01:08:15,000
你不用自己做任何事情

1356
01:08:15,000 --> 01:08:18,000
而且如果每个应用都要自己带一个 javascript 解析器的话

1357
01:08:18,000 --> 01:08:21,000
那个应用的尺寸也会比较大

1358
01:08:21,000 --> 01:08:22,000
嗯

1359
01:08:22,000 --> 01:08:23,000
这是一个问题

1360
01:08:23,000 --> 01:08:25,000
我觉得好啊

1361
01:08:25,000 --> 01:08:27,000
就是其实现在用那个 react native 就是这个问题了

1362
01:08:27,000 --> 01:08:31,000
其实用那个 react native 其实有已经有一个 app 的一个典范了

1363
01:08:31,000 --> 01:08:34,000
就在 iOS 这个 app store 里面

1364
01:08:34,000 --> 01:08:36,000
facebook 一个叫做新的应用叫做 groups

1365
01:08:36,000 --> 01:08:39,000
就是 facebook 群组的这个这个单独的一个应用

1366
01:08:39,000 --> 01:08:43,000
他其实是在很大程度上用的这个 react native 写的

1367
01:08:43,000 --> 01:08:47,000
然后我之前我我再知道他是用 react native 之前

1368
01:08:47,000 --> 01:08:49,000
我就已经下载过了

1369
01:08:49,000 --> 01:08:53,000
我用过他当时我完全没有感觉到他不是一个 native 的软件

1370
01:08:53,000 --> 01:08:56,000
就是非常就整个体验是非常好的

1371
01:08:56,000 --> 01:09:01,000
问题是我们并不是很清楚说他到底哪一部分是 UI 的那个

1372
01:09:01,000 --> 01:09:03,000
就多少比例是用的

1373
01:09:03,000 --> 01:09:06,000
或许这是正是这个好处所在

1374
01:09:06,000 --> 01:09:09,000
你知道用户如果说他他都他都不知道哪一部分

1375
01:09:09,000 --> 01:09:11,000
他都感受不出来

1376
01:09:11,000 --> 01:09:13,000
那就证明这个东西说不定就成功了

1377
01:09:13,000 --> 01:09:15,000
对

1378
01:09:15,000 --> 01:09:20,000
我们所拿就是与会者所拿到的这个版本跟

1379
01:09:20,000 --> 01:09:23,000
facebook 他所用的版本实际上是不同步的

1380
01:09:23,000 --> 01:09:25,000
facebook 他还在做很多的工作来

1381
01:09:25,000 --> 01:09:28,000
把这个东西给完善

1382
01:09:28,000 --> 01:09:31,000
然后才会正式的向大众发布

1383
01:09:31,000 --> 01:09:35,000
目前来说的话我们的所看到的版本都是一个

1384
01:09:35,000 --> 01:09:38,000
就是一个人的 tech preview

1385
01:09:38,000 --> 01:09:39,000
看的

1386
01:09:41,000 --> 01:09:44,000
对了明白

1387
01:09:44,000 --> 01:09:47,000
就是说 react native 刚才你为了你也提到他们的口号

1388
01:09:47,000 --> 01:09:49,000
就叫做 learn once write everywhere

1389
01:09:49,000 --> 01:09:51,000
然后我其实我也在想

1390
01:09:51,000 --> 01:09:54,000
如果你按这种方式去构建你的 app 之后

1391
01:09:54,000 --> 01:09:59,000
其实还是可以有蛮多部件是可以在各平台间重用的

1392
01:09:59,000 --> 01:10:00,000
比如说之前

1393
01:10:00,000 --> 01:10:03,000
我好像是在前期还是上前期的时候

1394
01:10:03,000 --> 01:10:04,000
我们在讨论过

1395
01:10:04,000 --> 01:10:07,000
那个 google 不是做了个叫 inbox 那个 app 吗

1396
01:10:07,000 --> 01:10:08,000
就新的

1397
01:10:08,000 --> 01:10:10,000
但是他是有安卓版有 s 版

1398
01:10:10,000 --> 01:10:12,000
然后还有一个这个 chrome

1399
01:10:12,000 --> 01:10:14,000
只有 chrome 的软件可以用的 web 版

1400
01:10:14,000 --> 01:10:17,000
然后他们后来发了一篇博客文章去讲

1401
01:10:17,000 --> 01:10:19,000
他们怎么去做这么一件事

1402
01:10:19,000 --> 01:10:22,000
就是说他们把这个假设你把这个整个应用分成两部分

1403
01:10:22,000 --> 01:10:23,000
一对是前端

1404
01:10:23,000 --> 01:10:25,000
一对是跟那个用户交互的那部分

1405
01:10:25,000 --> 01:10:27,000
那么这部分就是说在

1406
01:10:27,000 --> 01:10:29,000
在上就是 objc 写的

1407
01:10:29,000 --> 01:10:31,000
然后在安卓上就是用那个 java 写的

1408
01:10:31,000 --> 01:10:35,000
然后在这个 web 上就是 javascript 写的

1409
01:10:35,000 --> 01:10:37,000
但是他们其实是都是用 java 写的

1410
01:10:37,000 --> 01:10:40,000
然后通过 gwt 转化成 javascript

1411
01:10:40,000 --> 01:10:44,000
然后通过一个叫做 j 2 objc 的一个工具转换成 objc 代码来做

1412
01:10:44,000 --> 01:10:47,000
做那个逻辑的那一部分

1413
01:10:47,000 --> 01:10:50,000
就是就是跟原生界面无关

1414
01:10:50,000 --> 01:10:52,000
但是是跟这个后台的事物逻辑相关的

1415
01:10:52,000 --> 01:10:53,000
就是通过同一套语言

1416
01:10:53,000 --> 01:10:55,000
然后再转化成不同的

1417
01:10:55,000 --> 01:10:57,000
同样用 java 写

1418
01:10:57,000 --> 01:11:01,000
然后通过这两种工具转化成对应的 javascript 或者是 objc

1419
01:11:01,000 --> 01:11:03,000
但如果我们用这个 real native 来写的话

1420
01:11:03,000 --> 01:11:05,000
其实就这一步都可以省去了

1421
01:11:05,000 --> 01:11:11,000
我直接把所有的事物和逻辑都写成 javascript 就好了

1422
01:11:11,000 --> 01:11:18,000
对其实这让我想起那个 appcelerator 出的 titanium

1423
01:11:18,000 --> 01:11:21,000
他也是用 javascript 来写整个所有的事物逻辑

1424
01:11:21,000 --> 01:11:22,000
但是

1425
01:11:22,000 --> 01:11:24,000
其实他用的那个 javascript

1426
01:11:24,000 --> 01:11:28,000
其实使用的那个 UI widget 全都是原生的

1427
01:11:28,000 --> 01:11:30,000
他那个体验怎么样呢

1428
01:11:30,000 --> 01:11:32,000
不是特别好

1429
01:11:32,000 --> 01:11:38,000
就因为前公司在做 web 在做 mobileapp 的时候

1430
01:11:38,000 --> 01:11:40,000
考虑过用 titanium

1431
01:11:40,000 --> 01:11:43,000
可能当时最大的一个问题就是

1432
01:11:43,000 --> 01:11:47,000
首先那个时候正好是 iOS 6 升到 7 的过程中

1433
01:11:47,000 --> 01:11:51,000
然后他们大概是比 7 落后了

1434
01:11:51,000 --> 01:11:52,000
落后了

1435
01:11:52,000 --> 01:11:54,000
三到五个月的时间

1436
01:11:54,000 --> 01:11:56,000
我觉得这个是不可忍受的

1437
01:11:56,000 --> 01:11:58,000
新的 iOS 版本已经在那边了

1438
01:11:58,000 --> 01:11:59,000
如果你用 titanium 的话

1439
01:11:59,000 --> 01:12:01,000
你用不到新的那些 widget

1440
01:12:02,000 --> 01:12:03,000
对

1441
01:12:03,000 --> 01:12:10,000
然后他们的那一套东西据说其实是非常优秀的

1442
01:12:10,000 --> 01:12:13,000
但是没有什么文档

1443
01:12:13,000 --> 01:12:14,000
主要是

1444
01:12:16,000 --> 01:12:20,000
这可能是用任何第三方平台或者框架都会遇到的问题

1445
01:12:20,000 --> 01:12:21,000
对

1446
01:12:21,000 --> 01:12:24,000
那现在还在搞现在还在搞一些新的什么东西

1447
01:12:24,000 --> 01:12:27,000
但我一时也想不出来名字了

1448
01:12:28,000 --> 01:12:34,000
其大概的走向可能和 react 有点一举同工的地方

1449
01:12:34,000 --> 01:12:35,000
我还要看一下

1450
01:12:35,000 --> 01:12:36,000
ok

1451
01:12:36,000 --> 01:12:37,000
嗯

1452
01:12:37,000 --> 01:12:39,000
那说回这个 react native 这种方式

1453
01:12:39,000 --> 01:12:43,000
其实我还不是特别赞同他们说完全不在乎这个 write once

1454
01:12:43,000 --> 01:12:45,000
wrong anywhere 这么一个口号的话

1455
01:12:45,000 --> 01:12:48,000
就说起码你假设你看到像这些后台的逻辑啊

1456
01:12:48,000 --> 01:12:50,000
还有这些数据这些模型啊

1457
01:12:50,000 --> 01:12:51,000
都可以用 java script 构建

1458
01:12:51,000 --> 01:12:53,000
这一块是完全可以在各平台间重用

1459
01:12:53,000 --> 01:12:54,000
没错

1460
01:12:54,000 --> 01:12:55,000
嗯

1461
01:12:55,000 --> 01:12:59,000
而且我可以预见到肯定会有人做一个中间层

1462
01:12:59,000 --> 01:13:01,000
然后说用这些组件的话

1463
01:13:01,000 --> 01:13:05,000
这些组件可以就就变成那个 environmental sensitive

1464
01:13:05,000 --> 01:13:08,000
然后他们会根据 environmental 来

1465
01:13:08,000 --> 01:13:10,000
就原生的组件

1466
01:13:10,000 --> 01:13:11,000
对

1467
01:13:11,000 --> 01:13:12,000
比如说那个 tabview 你可以用这个组件的 tabview

1468
01:13:12,000 --> 01:13:18,000
然后这个 tabview 背后的实现会根据你的 target 是 android

1469
01:13:18,000 --> 01:13:20,000
或 target 的 ios 来自动

1470
01:13:20,000 --> 01:13:23,000
选择相应平台的 tabview

1471
01:13:23,000 --> 01:13:27,000
这并不是 react native 自己本身的一个设计理念

1472
01:13:27,000 --> 01:13:34,000
react native 非常鼓励你去根据各种平台本身的特性

1473
01:13:34,000 --> 01:13:37,000
来设计不一样的 UI

1474
01:13:37,000 --> 01:13:39,000
来用不一样的 component

1475
01:13:39,000 --> 01:13:43,000
而不是像这样的简单的替换的逻辑

1476
01:13:43,000 --> 01:13:48,000
但是我想我们肯定会看到第三方的一些 solution 出来的

1477
01:13:50,000 --> 01:13:53,000
对我觉得这个就是很多像什么企业级软件

1478
01:13:53,000 --> 01:13:54,000
可能会采取这种方式

1479
01:13:54,000 --> 01:13:56,000
因为它没有那么多的资源

1480
01:13:56,000 --> 01:14:00,000
或者说是人手去优化每一个平台的细节的体验

1481
01:14:00,000 --> 01:14:03,000
那么更加就是节省成本的

1482
01:14:03,000 --> 01:14:04,000
节省开发时间的一个方式

1483
01:14:04,000 --> 01:14:07,000
就是通过这种什么中间层去转换一下

1484
01:14:07,000 --> 01:14:10,000
我觉得就虽然体验不是太好

1485
01:14:10,000 --> 01:14:12,000
但是起码成本下去了

1486
01:14:12,000 --> 01:14:15,000
我觉得这个对很多企业软件来讲就是这样的一个一个诉求

1487
01:14:15,000 --> 01:14:16,000
没错

1488
01:14:16,000 --> 01:14:19,000
就我们现在等于说如果

1489
01:14:19,000 --> 01:14:21,000
如果 native

1490
01:14:21,000 --> 01:14:24,000
sorry react native 这一套

1491
01:14:24,000 --> 01:14:29,000
能够吸引到一部分人去把它炒起来的话

1492
01:14:29,000 --> 01:14:35,000
那可以说企业级跨平台应用开发又多了一个新的选择

1493
01:14:35,000 --> 01:14:38,000
对从 java 变成 javascript

1494
01:14:38,000 --> 01:14:42,000
我有跟我们的 developer 讨论这个问题

1495
01:14:42,000 --> 01:14:45,000
它并不单是在 solution 上

1496
01:14:45,000 --> 01:14:49,000
这个 tech solution 上有改变你的组织架构

1497
01:14:49,000 --> 01:14:51,000
而关键是说

1498
01:14:51,000 --> 01:14:52,000
如果你想这个

1499
01:14:52,000 --> 01:14:55,000
如果你真的实现 learn once write everywhere 的话

1500
01:14:55,000 --> 01:15:03,000
那所谓 web developer 跟 mobile developer 之间的界限就变得更模糊了

1501
01:15:03,000 --> 01:15:04,000
我觉得对于

1502
01:15:04,000 --> 01:15:06,000
可能是二合一的很多时候

1503
01:15:06,000 --> 01:15:07,000
对这个资源的

1504
01:15:07,000 --> 01:15:10,000
对这个企业资源的一个运用

1505
01:15:10,000 --> 01:15:12,000
实际上是一个非常有意思的事情

1506
01:15:12,000 --> 01:15:18,000
所以我们的比方说如果现在 web application 不需要太多维护的话

1507
01:15:18,000 --> 01:15:22,000
那这时程就可以去写那个 androidapp 去写 irisapp

1508
01:15:22,000 --> 01:15:23,000
对不对

1509
01:15:23,000 --> 01:15:26,000
所以这一点上对于企业来说可能是一个非常重要的事情

1510
01:15:26,000 --> 01:15:30,000
所以我也有跟我们的 web developer 开玩笑说

1511
01:15:30,000 --> 01:15:34,000
那你现在得赶紧去学 HTML CSS

1512
01:15:34,000 --> 01:15:37,000
对赶紧去赶紧开始学

1513
01:15:40,000 --> 01:15:45,000
他现在那个 real native 这个是还是在什么 alpha 阶段

1514
01:15:45,000 --> 01:15:46,000
可能是 pre-alpha 阶段

1515
01:15:46,000 --> 01:15:47,000
他们现在是说有一个私有的

1516
01:15:47,000 --> 01:15:49,000
github 的 repository

1517
01:15:49,000 --> 01:15:50,000
你们可以访问

1518
01:15:50,000 --> 01:15:52,000
就参与会者可以访问

1519
01:15:52,000 --> 01:15:53,000
外界还没有公开

1520
01:15:53,000 --> 01:15:55,000
我不知道你看了多少

1521
01:15:55,000 --> 01:16:02,000
但是我就比较好奇他怎么去实现他这个就是 javascript 那部分的业务代码

1522
01:16:02,000 --> 01:16:06,000
业务逻辑怎么去和原生的那些进行交互那块

1523
01:16:06,000 --> 01:16:11,000
我没有还来还没有来得及对这个代码本身做很多的研究

1524
01:16:11,000 --> 01:16:14,000
但是对 developer 来说的话

1525
01:16:14,000 --> 01:16:17,000
你所做的事情真的跟以前写

1526
01:16:17,000 --> 01:16:19,000
那个 webapplication 没有太大的区别

1527
01:16:19,000 --> 01:16:20,000
我可以把流程说一下

1528
01:16:20,000 --> 01:16:25,000
就是说从那个纯粹的开发者的这个角度来说的话

1529
01:16:25,000 --> 01:16:28,000
你 clone 这个 repository

1530
01:16:28,000 --> 01:16:31,000
然后你做 npm install

1531
01:16:31,000 --> 01:16:34,000
就是传统的 javascript

1532
01:16:34,000 --> 01:16:35,000
大家都对

1533
01:16:35,000 --> 01:16:37,000
然后你写说 npm start

1534
01:16:37,000 --> 01:16:40,000
npm start 的理由

1535
01:16:40,000 --> 01:16:44,000
原因是现在是在一个 dev environment 里头

1536
01:16:44,000 --> 01:16:46,000
这些 javascript 的文件

1537
01:16:46,000 --> 01:16:50,000
需要 serve 到那个 simulator 里头去

1538
01:16:50,000 --> 01:16:52,000
那个 simulator 里头去

1539
01:16:52,000 --> 01:16:56,000
所以这个 npm start 就会

1540
01:16:56,000 --> 01:16:59,000
启动一个这样的 server

1541
01:16:59,000 --> 01:17:02,000
然后 watch 的那些文件

1542
01:17:02,000 --> 01:17:04,000
然后你如果去看那些文件的话呢

1543
01:17:04,000 --> 01:17:11,000
实际上跟你写 react 的那个 web 的那个 application

1544
01:17:11,000 --> 01:17:13,000
并没有太大的区别

1545
01:17:13,000 --> 01:17:15,000
如果真的要说最大的区别可能就是说

1546
01:17:16,000 --> 01:17:18,000
你没有 css file 了

1547
01:17:18,000 --> 01:17:20,000
你所有的 file 都是 inline

1548
01:17:20,000 --> 01:17:21,000
所有的 style 都是 inline

1549
01:17:21,000 --> 01:17:22,000
这是最大的区别了

1550
01:17:22,000 --> 01:17:24,000
其他的东西都看起来非常的相似

1551
01:17:24,000 --> 01:17:28,000
然后你写的是真的是纯就是 common js 那种组件

1552
01:17:28,000 --> 01:17:31,000
最神奇的地方在于

1553
01:17:31,000 --> 01:17:33,000
如果你看到那个 video 的话有这一点

1554
01:17:33,000 --> 01:17:35,000
就是你把在那个

1555
01:17:35,000 --> 01:17:38,000
比方说如果你改变一下 css

1556
01:17:38,000 --> 01:17:42,000
那个 ios 的 simulator 是直接可以得到这个结果的

1557
01:17:42,000 --> 01:17:44,000
你是不需要去 recompile 的

1558
01:17:44,000 --> 01:17:46,000
这点非常的神奇

1559
01:17:46,000 --> 01:17:48,000
对对对

1560
01:17:48,000 --> 01:17:49,000
ok

1561
01:17:49,000 --> 01:17:51,000
他们有一个说法就是说要实现

1562
01:17:51,000 --> 01:17:54,000
你在这边就编辑器里面改一行代码

1563
01:17:54,000 --> 01:17:57,000
然后在 ios 那个那个模拟器里面实现

1564
01:17:57,000 --> 01:18:00,000
呃就是出现改动只需要不到一秒

1565
01:18:00,000 --> 01:18:01,000
ok

1566
01:18:01,000 --> 01:18:05,000
这个我觉得对开发效率非常大的大的提升

1567
01:18:05,000 --> 01:18:07,000
library load 的时间级别嘛

1568
01:18:07,000 --> 01:18:08,000
对对对对

1569
01:18:08,000 --> 01:18:13,000
java 世界里面有个叫 jrebel 也做类似的事情

1570
01:18:13,000 --> 01:18:15,000
哈哈哈

1571
01:18:15,000 --> 01:18:16,000
这个我觉得真的

1572
01:18:16,000 --> 01:18:18,000
看那个 demo 真的是挺酷炫的

1573
01:18:18,000 --> 01:18:19,000
嗯

1574
01:18:19,000 --> 01:18:22,000
哎不过你们觉得这样的话那不变成

1575
01:18:22,000 --> 01:18:24,000
javascript 变成一个什么通用的

1576
01:18:24,000 --> 01:18:26,000
这已经是现实了啊

1577
01:18:27,000 --> 01:18:28,000
对啊

1578
01:18:28,000 --> 01:18:29,000
哈哈哈哈

1579
01:18:29,000 --> 01:18:30,000
这浏览器

1580
01:18:30,000 --> 01:18:31,000
你们觉得是好事吗

1581
01:18:31,000 --> 01:18:32,000
呃

1582
01:18:32,000 --> 01:18:34,000
这个电脑上面的另一层电脑

1583
01:18:34,000 --> 01:18:35,000
对对对

1584
01:18:35,000 --> 01:18:38,000
这个浏览器那边我们毫无疑问 javascript 已经是一个

1585
01:18:38,000 --> 01:18:39,000
就如果他不是同样语言

1586
01:18:39,000 --> 01:18:40,000
他至少是一个构建的基石

1587
01:18:40,000 --> 01:18:44,000
因为很多语言可以所谓 compile to javascript 嘛

1588
01:18:44,000 --> 01:18:45,000
对我觉得 javascript 其实就是现在的 C++嘛

1589
01:18:45,000 --> 01:18:47,000
就现在的

1590
01:18:47,000 --> 01:18:48,000
会变了

1591
01:18:48,000 --> 01:18:51,000
浏览器就是当初的 pdp 11 之类的

1592
01:18:51,000 --> 01:18:58,000
然后就是 C 语言本来是多设计的多么粗糙的一个语言啊

1593
01:18:58,000 --> 01:19:03,000
但就是因为实事造英雄把它推的推到了现在的霸主地位

1594
01:19:03,000 --> 01:19:06,000
我觉得 javascript 基本上就是另外一个 C 嘛

1595
01:19:06,000 --> 01:19:12,000
对啊但是现在 reality 他要做的事情就是说把这件事情再往这个就是 mobile 移动端再推嘛

1596
01:19:12,000 --> 01:19:14,000
因为之前移动端大家还是在

1597
01:19:14,000 --> 01:19:19,000
就至少我们是鼓励或者说消费者也愿意使用所谓的一个原生的应用嘛

1598
01:19:19,000 --> 01:19:23,000
但这原生打引号就可能说说你要用这个平台自己的那种工具

1599
01:19:23,000 --> 01:19:25,000
也要自己的语言来写

1600
01:19:25,000 --> 01:19:31,000
但现在也在看 reality 他能够把这个整个效果做的这么跟原生就是说以假乱真吧

1601
01:19:31,000 --> 01:19:35,000
至少是那就完全没有必要再用平台原生的语言来写了

1602
01:19:35,000 --> 01:19:38,000
就好像说哎我是现在是一个 web developer

1603
01:19:38,000 --> 01:19:42,000
那我也可以做 ls 应用不需要学什么 objects 或者 swift 了嘛

1604
01:19:42,000 --> 01:19:43,000
对啊这就好像把

1605
01:19:44,000 --> 01:19:48,000
C 语言移植到不同的架构的处理器上嘛

1606
01:19:48,000 --> 01:19:56,000
我觉得吴涛刚刚说的很好就是这怎么说就是就是既定事实

1607
01:19:56,000 --> 01:19:59,000
JavaScript 的应用就是既定事实

1608
01:19:59,000 --> 01:20:06,000
所以我很期待 ES 6 ES 7 因为这个语言本身还是有非常非常多的问题的

1609
01:20:06,000 --> 01:20:10,000
特别是他的 prototype 这样一个架构而不是 class based

1610
01:20:10,000 --> 01:20:12,000
ES 6 ES 7 我很期待他们把这些问题解决了

1611
01:20:12,000 --> 01:20:19,000
这样的话对于我们这些语言的使用者来说是一个非常好的事情

1612
01:20:19,000 --> 01:20:20,000
因为啊

1613
01:20:20,000 --> 01:20:24,000
啊作为一个 web dev 你竟然不喜欢 prototype

1614
01:20:24,000 --> 01:20:28,000
不是不喜欢而是说在真正的应用上面

1615
01:20:28,000 --> 01:20:33,000
我们很多时候都是在用 prototype 去 simulate class

1616
01:20:33,000 --> 01:20:35,000
因为没有 native class support 嘛

1617
01:20:35,000 --> 01:20:39,000
这是我所不喜欢的一点不是说 prototype 本身

1618
01:20:39,000 --> 01:20:41,000
在 ES 6 中加入真正的 class support 嘛

1619
01:20:41,000 --> 01:20:46,000
这是我所期待的 prototype 当然有 prototype 的好处和应用

1620
01:20:46,000 --> 01:20:49,000
但是实际的应用中的话如果我们要用 class 的话

1621
01:20:49,000 --> 01:20:51,000
那我还是希望能有真正的 class

1622
01:20:51,000 --> 01:20:56,000
对 OK 我觉得 class 出现其实是比较

1623
01:20:56,000 --> 01:20:59,000
如果有比较合理的 class 的支持的话

1624
01:20:59,000 --> 01:21:04,000
那对于构建大型程序实际上是更加有利的

1625
01:21:04,000 --> 01:21:10,000
因为 prototype based object orientation 它的优点我觉得就在于你

1626
01:21:10,000 --> 01:21:13,000
你做原型开发非常的快

1627
01:21:13,000 --> 01:21:21,000
你不需要去考虑那个模板和实际的 instance 之间的抽象的问题

1628
01:21:21,000 --> 01:21:26,000
但当你要做大一些的东西的时候这个抽象其实还是相当必要

1629
01:21:26,000 --> 01:21:34,000
OK 对我不知道因为我对这种所谓传统的经典的 gbclass 的这种 OO 的话

1630
01:21:34,000 --> 01:21:37,000
其实并没有太特别的偏好

1631
01:21:37,000 --> 01:21:39,000
所以我觉得这两种都还好了

1632
01:21:39,000 --> 01:21:44,000
没有那么 class based 没有那么好

1633
01:21:44,000 --> 01:21:45,000
prototype based 也没有那么差

1634
01:21:45,000 --> 01:21:46,000
我觉得是这样

1635
01:21:46,000 --> 01:21:48,000
go 也是没有 class 对吧

1636
01:21:48,000 --> 01:21:50,000
go 根本就没有连 prototype 都没有

1637
01:21:50,000 --> 01:21:53,000
它是基于 interface 的完全更不一样

1638
01:21:53,000 --> 01:21:56,000
我觉得其实用直接用起来我觉得那种是更灵活的

1639
01:21:56,000 --> 01:22:01,000
所以我觉得你其实就是一个你比你比较不喜欢的经典的 class

1640
01:22:01,000 --> 01:22:03,000
对没错

1641
01:22:03,000 --> 01:22:05,000
Java 看太多了

1642
01:22:05,000 --> 01:22:08,000
我觉得你可以去看一看 io 就是 eo 这个语言

1643
01:22:08,000 --> 01:22:09,000
我不喜欢

1644
01:22:09,000 --> 01:22:10,000
不知道怎么念的

1645
01:22:10,000 --> 01:22:13,000
它其实也是 prototype based

1646
01:22:13,000 --> 01:22:16,000
这个说来其实还蛮奇怪的

1647
01:22:16,000 --> 01:22:21,000
object c 算是一个经典的 gbclass 的既成 OO 语言也不算

1648
01:22:21,000 --> 01:22:24,000
它是类似于 smalltalk 那种方式

1649
01:22:24,000 --> 01:22:27,000
它是在 c 上面加了一层 smalltalk

1650
01:22:27,000 --> 01:22:31,000
然后用一个最近看到一句话来说

1651
01:22:31,000 --> 01:22:35,000
object c 就是过去 25 年计算机语言发展史的缩影

1652
01:22:35,000 --> 01:22:38,000
你在看里面不同的语言特性的时候你会

1653
01:22:38,000 --> 01:22:43,000
如果你从一个计算机历史学家家里号的角度来看的话

1654
01:22:43,000 --> 01:22:47,000
就你会看到这个特征来自于那个时代的一个思潮

1655
01:22:47,000 --> 01:22:49,000
考古语言

1656
01:22:49,000 --> 01:22:51,000
对所以其实我觉得就很好奇

1657
01:22:51,000 --> 01:22:54,000
就是就是 alchemy object c 也已经证明了

1658
01:22:54,000 --> 01:22:57,000
就是说你没有一个大规模的

1659
01:22:57,000 --> 01:23:03,000
就没有 class 的支持的一个 OO 的语言也可以做得很好

1660
01:23:03,000 --> 01:23:06,000
就是是不是不能证明这一点

1661
01:23:06,000 --> 01:23:07,000
我觉得不能不太

1662
01:23:07,000 --> 01:23:09,000
不太能证明吧

1663
01:23:09,000 --> 01:23:11,000
不过这算了

1664
01:23:11,000 --> 01:23:13,000
我们可以留待以后这个讨论吧

1665
01:23:13,000 --> 01:23:16,000
专门讲这个编程员的一期

1666
01:23:16,000 --> 01:23:20,000
我们刚刚说到就是 javascript 应用这么广泛

1667
01:23:20,000 --> 01:23:27,000
实际上在这个 talk 中我们有一个 netflix 的那个 speaker

1668
01:23:27,000 --> 01:23:32,000
然后他有说到说就是我们现在有很多智能那个电视嘛

1669
01:23:32,000 --> 01:23:35,000
智能电视上有很多可以看 netflix

1670
01:23:35,000 --> 01:23:36,000
然后他们都是用

1671
01:23:37,000 --> 01:23:39,000
javascript 来写这个东西的

1672
01:23:39,000 --> 01:23:47,000
他们都是 ship 一个 webkit 的封装给那个电视厂上

1673
01:23:47,000 --> 01:23:50,000
然后就其中有他们的 netflix 的 application

1674
01:23:50,000 --> 01:23:54,000
对你知道那个 apple tv 也是用方式实现的吗

1675
01:23:54,000 --> 01:23:56,000
哦 interesting

1676
01:23:56,000 --> 01:24:04,000
netflix 的 nextflix 他们实际上现在是用 react 来写那个 tv app

1677
01:24:04,000 --> 01:24:06,000
就好像 react native 一样

1678
01:24:06,000 --> 01:24:08,000
他们是 react tv

1679
01:24:08,000 --> 01:24:10,000
那个不是开源的程序

1680
01:24:10,000 --> 01:24:13,000
但是但是他有介绍说这个是怎么样实现的

1681
01:24:13,000 --> 01:24:14,000
嗯哼嗯哼

1682
01:24:14,000 --> 01:24:20,000
之前我也在玩那个你有那个叫什么 chromecast 那个小棒子吗

1683
01:24:20,000 --> 01:24:23,000
我在公司有但是我没有我没有很经常

1684
01:24:23,000 --> 01:24:26,000
我自己有一个然后我之前玩过一段时间

1685
01:24:26,000 --> 01:24:27,000
就他也是那种方式

1686
01:24:27,000 --> 01:24:29,000
他整个就是其实就是一个浏览器窗口

1687
01:24:29,000 --> 01:24:31,000
他你可以电视上的

1688
01:24:31,000 --> 01:24:34,000
然后你们也可以做类似的事情就是你

1689
01:24:34,000 --> 01:24:35,000
你可以把这个整个 react 的东西做成一个 tv 的视频啊

1690
01:24:36,000 --> 01:24:37,000
然后你就可以把这个组件丢过去

1691
01:24:37,000 --> 01:24:39,000
然后做一些很好玩的事

1692
01:24:39,000 --> 01:24:40,000
哎我插问一句

1693
01:24:40,000 --> 01:24:43,000
嗯 chromecast 的那个小小棒子

1694
01:24:43,000 --> 01:24:46,000
他要求有外界的 wifi 在是吧

1695
01:24:46,000 --> 01:24:49,000
对他只能通过 wifi 和外界

1696
01:24:49,000 --> 01:24:51,000
他自己不能提供一个热点

1697
01:24:51,000 --> 01:24:53,000
他自己不他是一个 wifi 接受器而已

1698
01:24:53,000 --> 01:24:54,000
ok

1699
01:24:54,000 --> 01:24:55,000
当然你你把他 hack 掉

1700
01:24:55,000 --> 01:24:56,000
应该也可能做一个热点出来

1701
01:24:56,000 --> 01:24:57,000
但你为什么你会想的

1702
01:24:57,000 --> 01:24:59,000
因为他会是一个 wifi 的热点

1703
01:24:59,000 --> 01:25:02,000
如果他能够自己成为一个 wifi 接点的话

1704
01:25:02,000 --> 01:25:04,000
我出去在酒店里面

1705
01:25:04,000 --> 01:25:06,000
用酒店的电视

1706
01:25:06,000 --> 01:25:13,000
看在 ipad 上面预先 load 好的视频

1707
01:25:13,000 --> 01:25:15,000
你想发送过去是吧

1708
01:25:15,000 --> 01:25:17,000
首先有两点是有问题的

1709
01:25:17,000 --> 01:25:21,000
第一个他只能是一个 wifi 的 client

1710
01:25:21,000 --> 01:25:22,000
他不是一个 ap

1711
01:25:22,000 --> 01:25:24,000
但估计你 hack 一下应该也行

1712
01:25:24,000 --> 01:25:29,000
但第二个问题就是说 chromecast 整个的一个 api

1713
01:25:29,000 --> 01:25:35,000
包括认证机制是不允许你随意播放你本机的视频文件的

1714
01:25:35,000 --> 01:25:36,000
ok

1715
01:25:36,000 --> 01:25:37,000
那你怎么办

1716
01:25:37,000 --> 01:25:38,000
你可以做

1717
01:25:38,000 --> 01:25:39,000
但是比较麻烦

1718
01:25:39,000 --> 01:25:40,000
就是私人做

1719
01:25:40,000 --> 01:25:42,000
没有那种比较现成的 app 来搞这种

1720
01:25:42,000 --> 01:25:43,000
好吧

1721
01:25:43,000 --> 01:25:44,000
不过不影响

1722
01:25:44,000 --> 01:25:46,000
现在很多手机都可以建一个热点

1723
01:25:46,000 --> 01:25:49,000
然后你可以用手机的有很多 android 的 apps

1724
01:25:49,000 --> 01:25:51,000
可以让你做到这件事情

1725
01:25:51,000 --> 01:25:52,000
ok

1726
01:25:52,000 --> 01:25:55,000
iOS 就暂时没有解决了

1727
01:25:55,000 --> 01:25:57,000
apple tv 都没有

1728
01:25:57,000 --> 01:25:58,000
没有办法

1729
01:25:58,000 --> 01:25:59,000
打个差

1730
01:25:59,000 --> 01:26:01,000
我们接下来讲

1731
01:26:01,000 --> 01:26:03,000
reality 还有什么要补充的吗

1732
01:26:03,000 --> 01:26:04,000
我跟他差不多

1733
01:26:04,000 --> 01:26:05,000
我想一下

1734
01:26:05,000 --> 01:26:06,000
多了吧

1735
01:26:06,000 --> 01:26:12,000
讲其实有一个问题就是 react native 可以用来写游戏吗

1736
01:26:12,000 --> 01:26:17,000
那种什么 light game 应该是可以的吧

1737
01:26:17,000 --> 01:26:18,000
我觉得

1738
01:26:18,000 --> 01:26:19,000
对

1739
01:26:19,000 --> 01:26:25,000
不过也不一定有人用什么 webGL 来写那种很复杂的设计游戏

1740
01:26:25,000 --> 01:26:34,000
可是在 react native 所能操纵的原生组件到底到一个什么层级呢

1741
01:26:34,000 --> 01:26:40,000
比如说 iOS 上面的 sprite kit 它可以用吗

1742
01:26:40,000 --> 01:26:43,000
这个就只有威老强能回答了

1743
01:26:43,000 --> 01:26:45,000
有人问过类似的问题

1744
01:26:45,000 --> 01:26:46,000
但不是直接问游戏

1745
01:26:46,000 --> 01:26:48,000
而是说到底它可以

1746
01:26:48,000 --> 01:26:50,000
哪些组件是可以用是吧

1747
01:26:50,000 --> 01:26:51,000
对

1748
01:26:51,000 --> 01:26:53,000
然后所得到答案是说

1749
01:26:53,000 --> 01:26:56,000
我的理解不是 call and quote

1750
01:26:56,000 --> 01:26:58,000
是说所有的组件都是可以用的

1751
01:26:58,000 --> 01:27:02,000
但可能有些组件你得自己手工把它包装一下

1752
01:27:02,000 --> 01:27:03,000
ok

1753
01:27:03,000 --> 01:27:04,000
对

1754
01:27:04,000 --> 01:27:05,000
以什么方式包装

1755
01:27:05,000 --> 01:27:12,000
是说我必须在用 swift 或者是 rjc 写一个 wrapper 然后它可以调用吗

1756
01:27:12,000 --> 01:27:15,000
不是是在 javascript 端写一个 wrapper

1757
01:27:15,000 --> 01:27:17,000
你这样想

1758
01:27:17,000 --> 01:27:19,000
你这样想

1759
01:27:19,000 --> 01:27:24,000
不考虑 react native 就考虑那个 react 的 js 的 part

1760
01:27:24,000 --> 01:27:26,000
你可以用 div 对吧

1761
01:27:26,000 --> 01:27:30,000
你可以用 div 你可以用 almost any html component

1762
01:27:30,000 --> 01:27:32,000
但是 div 本身

1763
01:27:32,000 --> 01:27:39,000
它有一个中间层是 react 已经提供给你的 react 已经写了这个 div 这个 component 对不对

1764
01:27:39,000 --> 01:27:44,000
就 virtual dom 里面会有一个 div 的对应的一个一个对象吧

1765
01:27:44,000 --> 01:27:47,000
然后这个东西是 javascript

1766
01:27:47,000 --> 01:27:52,000
是在 javascript 里头有一个组件来告诉 virtual dom 说我自己要做什么

1767
01:27:52,000 --> 01:27:53,000
我能够做什么

1768
01:27:53,000 --> 01:27:56,000
如果我的 state change 我应该怎么变化

1769
01:27:56,000 --> 01:27:59,000
这个是在那个 javascript 的 definition 里头的

1770
01:27:59,000 --> 01:28:02,000
同样的如果说你现在 html

1771
01:28:02,000 --> 01:28:03,000
出现了一个新的东西

1772
01:28:03,000 --> 01:28:04,000
出现了一个新的 tag

1773
01:28:04,000 --> 01:28:06,000
然后你想要用这个 tag

1774
01:28:06,000 --> 01:28:12,000
by the way 那个 react 还有一些 svg 所相关的那个 tag 它没有实现

1775
01:28:12,000 --> 01:28:14,000
如果大家有兴趣的话可以去 contribute

1776
01:28:14,000 --> 01:28:20,000
现在要加入这个对这些新的原生 tag 的实现的话呢

1777
01:28:20,000 --> 01:28:25,000
那你也写一个 react 的 component 来实现它对不对

1778
01:28:25,000 --> 01:28:28,000
所以转换成 react native 的逻辑呢

1779
01:28:28,000 --> 01:28:31,000
如果你有一个原生的 native 的那个

1780
01:28:32,000 --> 01:28:34,000
component 你要使用的话

1781
01:28:34,000 --> 01:28:39,000
你需要在 javascript 端写一个 adapter 来说

1782
01:28:39,000 --> 01:28:41,000
这个东西是个什么东西

1783
01:28:41,000 --> 01:28:43,000
怎么样 initialize 它

1784
01:28:43,000 --> 01:28:46,000
它能够提供什么样的操作

1785
01:28:46,000 --> 01:28:52,000
然后 react 的那个引擎肯定有一个 protocol 来说

1786
01:28:52,000 --> 01:28:54,000
你要怎么写这个文件在 javascript

1787
01:28:54,000 --> 01:28:57,000
然后你按照它一幅画条把它写出来之后呢

1788
01:28:57,000 --> 01:28:59,000
那你就可以用这个原生组件了

1789
01:28:59,000 --> 01:29:01,000
但我觉得可能无套的问题就是说

1790
01:29:01,000 --> 01:29:06,000
那是就是说是 react native 这个 library 提供

1791
01:29:06,000 --> 01:29:12,000
javascript 到这个 ios 的那些原生组件这一个桥吗

1792
01:29:12,000 --> 01:29:13,000
还是怎么样

1793
01:29:13,000 --> 01:29:16,000
是 react native 自己本身实现的那一个

1794
01:29:16,000 --> 01:29:20,000
那这会不会有这样类似于这个叫什么 titanium

1795
01:29:20,000 --> 01:29:21,000
那种同样的问题

1796
01:29:21,000 --> 01:29:27,000
就是说你要等这个 react native 这个 library 提供了对应的这个

1797
01:29:27,000 --> 01:29:30,000
比如说 ios 的一些原生的组件的这个桥来说呢

1798
01:29:31,000 --> 01:29:33,000
你只要做了这个 react native 的这个桥

1799
01:29:33,000 --> 01:29:34,000
你才可以用的

1800
01:29:34,000 --> 01:29:36,000
而不是说我自己可以比如假设苹果 ios 9

1801
01:29:36,000 --> 01:29:38,000
它又出了一些新的原生组件

1802
01:29:38,000 --> 01:29:40,000
那我作为开发者我可以自己包一下就可以用

1803
01:29:40,000 --> 01:29:43,000
而不是说要等到这个 react native 发布一个新版

1804
01:29:43,000 --> 01:29:48,000
支持说就所 expose 那些原生的组件出来才可以用了

1805
01:29:48,000 --> 01:29:53,000
根据在那个会上的 q&a 的答案的话

1806
01:29:53,000 --> 01:29:56,000
我相信是你可以自己来做这个事情的

1807
01:29:56,000 --> 01:29:57,000
就他们做了一个通用的桥

1808
01:29:57,000 --> 01:29:58,000
这个非常好

1809
01:29:58,000 --> 01:29:59,000
这个就很厉害了

1810
01:29:59,000 --> 01:30:00,000
就不用考虑

1811
01:30:00,000 --> 01:30:02,000
就遇到那个之前那个 titanic 那种问题了

1812
01:30:02,000 --> 01:30:03,000
对

1813
01:30:03,000 --> 01:30:05,000
这个真的不真的了不得

1814
01:30:05,000 --> 01:30:07,000
我看那这样那么 swift 不就挂了

1815
01:30:07,000 --> 01:30:11,000
javascript 多简单

1816
01:30:11,000 --> 01:30:15,000
你知道这个技术的发展都是有很多不确定性的

1817
01:30:15,000 --> 01:30:18,000
所以大家不要把鸡蛋放在同一个栏子里头

1818
01:30:18,000 --> 01:30:19,000
这是没错

1819
01:30:19,000 --> 01:30:21,000
还好我已经不做前端了

1820
01:30:21,000 --> 01:30:24,000
不这也是一个问题

1821
01:30:24,000 --> 01:30:25,000
前端就是变化好快

1822
01:30:25,000 --> 01:30:28,000
对其实这也是我在那个提纲里面写的

1823
01:30:28,000 --> 01:30:29,000
就是

1824
01:30:29,000 --> 01:30:32,000
我觉得现在前端真的是没有人知道风会往里面吹

1825
01:30:32,000 --> 01:30:36,000
就是什么三天一小便七天一大便

1826
01:30:36,000 --> 01:30:38,000
对就是 frontend technology

1827
01:30:38,000 --> 01:30:41,000
可能你这个网站你所用的东西

1828
01:30:41,000 --> 01:30:44,000
跟另外一个网站所用的东西 completely different

1829
01:30:44,000 --> 01:30:46,000
没有任何一点点交集

1830
01:30:46,000 --> 01:30:50,000
然后两个人都觉得自己做的才是前途

1831
01:30:50,000 --> 01:30:53,000
或者反过来两个人都觉得对方做的才是正确的

1832
01:30:53,000 --> 01:30:56,000
这个是非常让人疑惑的一件事情

1833
01:30:56,000 --> 01:30:58,000
其实你这个都是高端了

1834
01:30:58,000 --> 01:31:00,000
你想遇到那种比较低端的人家就说

1835
01:31:00,000 --> 01:31:02,000
我们不是都是用 j curry 吗

1836
01:31:02,000 --> 01:31:03,000
对

1837
01:31:03,000 --> 01:31:08,000
你知道就是所谓最好的时代也是最坏的时代

1838
01:31:08,000 --> 01:31:09,000
对

1839
01:31:09,000 --> 01:31:11,000
看你自己所处的位置是怎么样

1840
01:31:11,000 --> 01:31:12,000
对

1841
01:31:12,000 --> 01:31:18,000
我觉得这也可能就是前端技术比较让人有兴趣的一部分

1842
01:31:18,000 --> 01:31:21,000
你总是可以看到一些新的

1843
01:31:21,000 --> 01:31:23,000
然后看到一些有趣的东西

1844
01:31:23,000 --> 01:31:25,000
看到年轻人的活力

1845
01:31:25,000 --> 01:31:26,000
对

1846
01:31:26,000 --> 01:31:28,000
这从你

1847
01:31:28,000 --> 01:31:29,000
程度上来讲的话

1848
01:31:29,000 --> 01:31:33,000
它也是有就是技术也有很固定的时候

1849
01:31:33,000 --> 01:31:35,000
比方说算是阶段性发展

1850
01:31:35,000 --> 01:31:38,000
你知道就 j curry 有 j curry 的一段时间

1851
01:31:38,000 --> 01:31:39,000
大家都用 j curry

1852
01:31:39,000 --> 01:31:40,000
然后 backbone 有段时间

1853
01:31:40,000 --> 01:31:41,000
大家都用 backbone

1854
01:31:41,000 --> 01:31:44,000
然后我觉得我们可能之所以这么就是现在这么精彩

1855
01:31:44,000 --> 01:31:46,000
是因为我们在进入一个新的阶段

1856
01:31:46,000 --> 01:31:50,000
从我的角度来说的话

1857
01:31:50,000 --> 01:31:52,000
我觉得 react 是最 promising 的一个 solution

1858
01:31:52,000 --> 01:31:55,000
因为 angler can shoot itself in the foot 对不对

1859
01:31:55,000 --> 01:31:56,000
你看

1860
01:31:56,000 --> 01:31:57,000
没办法

1861
01:31:57,000 --> 01:31:58,000
没办法

1862
01:31:58,000 --> 01:31:59,000
这个对

1863
01:31:59,000 --> 01:32:00,000
太复杂了

1864
01:32:00,000 --> 01:32:04,000
他们所以而且他那个 2.0 跟 1.0 又不匹配

1865
01:32:04,000 --> 01:32:07,000
然后 2.0 又在又需要那么长时间来开发

1866
01:32:07,000 --> 01:32:11,000
所以 angler 有点就是自身的

1867
01:32:11,000 --> 01:32:13,000
即将做死

1868
01:32:13,000 --> 01:32:15,000
真的有点这个意思

1869
01:32:15,000 --> 01:32:21,000
所以 react 很可能就是下一个阶段的一个主力了

1870
01:32:21,000 --> 01:32:26,000
所以我不管你对 react 自己本身什么想

1871
01:32:26,000 --> 01:32:29,000
就是做一个前端开发者的话真的应该去了解他

1872
01:32:29,000 --> 01:32:31,000
至少知道他为什么好

1873
01:32:31,000 --> 01:32:33,000
或者是他哪里好

1874
01:32:33,000 --> 01:32:38,000
而且从公司的支持来说的话

1875
01:32:38,000 --> 01:32:42,000
facebook 对 react 其实是非常非常强烈的

1876
01:32:42,000 --> 01:32:49,000
你可以看到他他从他最初是最初最初的模型是那个 facebook aids group

1877
01:32:49,000 --> 01:32:51,000
就是 ads group 来做出来的

1878
01:32:51,000 --> 01:32:54,000
然后现在后来到 chat 到大部分的前端

1879
01:32:54,000 --> 01:32:55,000
他们所现在写的都会是 react 的

1880
01:32:55,000 --> 01:33:00,000
到 group 现在又用那个 react native 写

1881
01:33:00,000 --> 01:33:03,000
所以 react 背后有非常多 facebook 的支持

1882
01:33:03,000 --> 01:33:06,000
反观 angler 反倒是在 google 里头

1883
01:33:06,000 --> 01:33:07,000
他自己都不怎么用

1884
01:33:07,000 --> 01:33:11,000
对我们并不知道特别多的 angler 所写的应用

1885
01:33:11,000 --> 01:33:15,000
那个 inbox 倒是一个 angler 的案例

1886
01:33:15,000 --> 01:33:22,000
上次 real 说是 gwc 写的

1887
01:33:22,000 --> 01:33:24,000
然后我成功的破碎了这个谣言

1888
01:33:24,000 --> 01:33:25,000
对他

1889
01:33:25,000 --> 01:33:26,000
他是这样的

1890
01:33:26,000 --> 01:33:27,000
他是两部分

1891
01:33:27,000 --> 01:33:28,000
他的前端那部分不知道

1892
01:33:28,000 --> 01:33:30,000
没有说但是后就是那个业务逻辑那边

1893
01:33:30,000 --> 01:33:32,000
他是加把转过去的

1894
01:33:32,000 --> 01:33:33,000
ok

1895
01:33:33,000 --> 01:33:34,000
ok

1896
01:33:34,000 --> 01:33:35,000
对

1897
01:33:35,000 --> 01:33:40,000
就有很有可能就是他他的这个 inbox 的这个网页版的前端

1898
01:33:40,000 --> 01:33:43,000
可能是用这个 angler 写的

1899
01:33:43,000 --> 01:33:44,000
对

1900
01:33:44,000 --> 01:33:46,000
还有他或许有很多 internet tool 用用 angler 写

1901
01:33:46,000 --> 01:33:49,000
但是我们并没有看到很很多直接的知识

1902
01:33:49,000 --> 01:33:54,000
我觉得这一点上是对于那个技术本身的发展是不是很不是特别好

1903
01:33:54,000 --> 01:33:57,000
因为没有干爹支持

1904
01:33:57,000 --> 01:33:58,000
对

1905
01:33:58,000 --> 01:33:59,000
哈哈哈哈

1906
01:33:59,000 --> 01:34:01,000
天这个是个很大的问题

1907
01:34:01,000 --> 01:34:02,000
嗯

1908
01:34:02,000 --> 01:34:06,000
我们看看看选技术技术选行的时候就先先看爹嘛

1909
01:34:06,000 --> 01:34:07,000
对吧

1910
01:34:07,000 --> 01:34:08,000
对选了够

1911
01:34:08,000 --> 01:34:09,000
真的是这样子

1912
01:34:09,000 --> 01:34:10,000
对

1913
01:34:10,000 --> 01:34:11,000
啊

1914
01:34:11,000 --> 01:34:13,000
那我们接下来说一下那个 relay 吧

1915
01:34:13,000 --> 01:34:15,000
这个还是要留在下期还是怎么样

1916
01:34:15,000 --> 01:34:18,000
还是一次过把他讲完好了

1917
01:34:18,000 --> 01:34:19,000
啊

1918
01:34:19,000 --> 01:34:23,000
他们这次这个 real 大会上面除除了发布这个激令人激动人心

1919
01:34:23,000 --> 01:34:29,000
什么令这个 webapp 可以秒杀这个 iOS 或者

1920
01:34:29,000 --> 01:34:36,000
就直接直接就秒秒适了的这么一个什么对 ground breaking 的技术之外

1921
01:34:36,000 --> 01:34:37,000
还发布了一个

1922
01:34:37,000 --> 01:34:39,000
其实作为一个前端开发

1923
01:34:39,000 --> 01:34:41,000
半个前端开发者的我来讲

1924
01:34:41,000 --> 01:34:43,000
这个还是非常令我激动的

1925
01:34:43,000 --> 01:34:45,000
要做一个 relay 的这么一个技术啊

1926
01:34:45,000 --> 01:34:46,000
嗯

1927
01:34:46,000 --> 01:34:50,000
这个事情跟之前讲的那个 flux 是有或多或少的关系的啊

1928
01:34:50,000 --> 01:34:52,000
因为他们在去年发布那个 flux 架构的时候

1929
01:34:52,000 --> 01:34:54,000
并没有说因为 flux 它只是一个 idea 嘛

1930
01:34:54,000 --> 01:34:55,000
刚才威德也讲了

1931
01:34:55,000 --> 01:34:59,000
他并没有说告诉你一些具具体的执行的措施是怎么样子的

1932
01:34:59,000 --> 01:35:04,000
然后其中有一个很一个就是任何一个 webapp 都逃不掉的问题

1933
01:35:04,000 --> 01:35:07,000
就是你怎么去从服务端获取数据嘛

1934
01:35:07,000 --> 01:35:08,000
对

1935
01:35:08,000 --> 01:35:10,000
然后在这个传统的方式下

1936
01:35:10,000 --> 01:35:11,000
那个可能很最简单的

1937
01:35:11,000 --> 01:35:15,000
我就用 jquery 写个或者用那个什么 httpxmlhttprequest

1938
01:35:15,000 --> 01:35:16,000
发一个请求

1939
01:35:16,000 --> 01:35:19,000
然后回来用什么一个 callback 就更新了一下这个 dome

1940
01:35:19,000 --> 01:35:22,000
这个可能是最最原始的一个从这个

1941
01:35:22,000 --> 01:35:23,000
从服务端取数据

1942
01:35:23,000 --> 01:35:25,000
然后在一个 webapp 里面展示的方法

1943
01:35:25,000 --> 01:35:27,000
但是到了一定层级之后

1944
01:35:27,000 --> 01:35:29,000
这种方式就是完全是不可以管理的嘛

1945
01:35:29,000 --> 01:35:31,000
有很多很多奇奇怪怪的问题要解决

1946
01:35:31,000 --> 01:35:32,000
没错

1947
01:35:32,000 --> 01:35:34,000
然后他们这次发布的这个 relay 呢

1948
01:35:34,000 --> 01:35:36,000
其实就是要解决这么一个问题

1949
01:35:36,000 --> 01:35:38,000
嗯

1950
01:35:38,000 --> 01:35:42,000
哎我不知道为了你们在之前的时候是怎么去做这个从服务端获取数据

1951
01:35:42,000 --> 01:35:44,000
这么一个过程的

1952
01:35:44,000 --> 01:35:45,000
嗯

1953
01:35:45,000 --> 01:35:46,000
哦

1954
01:35:46,000 --> 01:35:47,000
因为我们都啊

1955
01:35:47,000 --> 01:35:51,000
之前都是在用那个啊传统意义上的啊 mvc 的 model 嘛

1956
01:35:51,000 --> 01:35:52,000
我们还没有

1957
01:35:52,000 --> 01:35:55,000
我们并没有使用 storage 的概念

1958
01:35:55,000 --> 01:36:00,000
但是我觉得 store 的概念可能跟那个 model 是可以 map 的

1959
01:36:00,000 --> 01:36:03,000
所以然后我们的后台是一个 restful api

1960
01:36:03,000 --> 01:36:04,000
ok

1961
01:36:04,000 --> 01:36:06,000
在在前端我们有 model

1962
01:36:06,000 --> 01:36:07,000
然后这个 model

1963
01:36:07,000 --> 01:36:08,000
啊

1964
01:36:08,000 --> 01:36:10,000
他可以去跟那个后台去 sync

1965
01:36:10,000 --> 01:36:11,000
right

1966
01:36:11,000 --> 01:36:14,000
然后这个 sync 是一个 restful 的 http request

1967
01:36:14,000 --> 01:36:19,000
然后那个 server 会把你所获取的需要获取的信息给发送回来

1968
01:36:19,000 --> 01:36:20,000
然后这样 model 就有了

1969
01:36:20,000 --> 01:36:22,000
就就就得到了这个所有信息

1970
01:36:22,000 --> 01:36:25,000
那么这里就有一个问题啊

1971
01:36:25,000 --> 01:36:29,000
就是说刚才我们那个可能要介入这么一个新的这个一个一个概念也比较显示

1972
01:36:29,000 --> 01:36:33,000
如果你说前端开发肯定会遇到就是 rest 的这么一个一个 api

1973
01:36:33,000 --> 01:36:34,000
那什么意思呢

1974
01:36:34,000 --> 01:36:36,000
就是说他起码他就是说把我把这个我后台

1975
01:36:36,000 --> 01:36:42,000
我能够提供的你所有的资源一个 resource 通过一个这个 url 的这么一个节点暴露出来

1976
01:36:42,000 --> 01:36:50,000
然后你通过像什么标准的什么什么 put delete 啊 post 啊 get 的这种方法去获取这些这些这些呃资源嘛

1977
01:36:50,000 --> 01:36:51,000
但是这里一个问题就是说

1978
01:36:51,000 --> 01:36:53,000
呃我不知道你们那边是不是怎么样子啊

1979
01:36:53,000 --> 01:36:57,000
就是我我看到的大部分的这个 restapi 都有一个共通的问题

1980
01:36:57,000 --> 01:37:00,000
就是他有太多的这个所谓 endpoint 太多的节点了

1981
01:37:00,000 --> 01:37:01,000
因为每一个资源就要对应一个节点嘛

1982
01:37:01,000 --> 01:37:02,000
没错

1983
01:37:02,000 --> 01:37:04,000
然后包括如果为了你讲的那种情况

1984
01:37:04,000 --> 01:37:06,000
如果我理解的没有错的话

1985
01:37:06,000 --> 01:37:10,000
你们你们也是说每一个 model 应该是对应一个有一个 resource 一个资源

1986
01:37:10,000 --> 01:37:17,000
然后这个每个 model 去负责去那个节点的那个那个资源对应的 rest 的节点去访问他对吧

1987
01:37:17,000 --> 01:37:21,000
但这样我觉得其实这样管理和编写起来都不是很容易的

1988
01:37:21,000 --> 01:37:22,000
不是很方便

1989
01:37:22,000 --> 01:37:24,000
而且在使用起来我就有很多问题

1990
01:37:24,000 --> 01:37:26,000
就我我先讲讲我的体验怎么样子啊

1991
01:37:26,000 --> 01:37:28,000
感觉就像一个刚才讲那个节点太多

1992
01:37:28,000 --> 01:37:31,000
你要为每一个资源增就增加一个节点

1993
01:37:31,000 --> 01:37:35,000
然后你要考虑每个资源他能够支持的这些这种所谓的这些动词吗

1994
01:37:35,000 --> 01:37:38,000
verb 他对应的一些所谓的这个这个语义是什么

1995
01:37:38,000 --> 01:37:42,000
比如说我有一个 user 如果 put 的 user 是一个什么意思对吧

1996
01:37:42,000 --> 01:37:44,000
那我 post user 又是一个什么意思

1997
01:37:44,000 --> 01:37:46,000
然后 delete 当然可能更好理解一点

1998
01:37:46,000 --> 01:37:48,000
但是因为会牵涉到资源的种类又不一样

1999
01:37:48,000 --> 01:37:50,000
有所谓的什么 collection

2000
01:37:50,000 --> 01:37:51,000
啊有所谓的 individual

2001
01:37:51,000 --> 01:37:52,000
啊这种这种 resource

2002
01:37:52,000 --> 01:37:54,000
其实很多事情还是不是那么清晰的

2003
01:37:54,000 --> 01:37:55,000
对啊

2004
01:37:55,000 --> 01:37:59,000
而且这个 rest 的本身的定义就是很多人有很不同的理解嘛

2005
01:37:59,000 --> 01:38:03,000
虽然那个最开始那篇博士论文里面有把这个概念阐述的很详细

2006
01:38:03,000 --> 01:38:08,000
但是我我我可以确信绝大部分做 rest 的人都是没有看过那篇博士论文的

2007
01:38:08,000 --> 01:38:09,000
嗯

2008
01:38:09,000 --> 01:38:15,000
然后 rest 我觉得还有一个问题就是说他的那个这个就约束太多了

2009
01:38:15,000 --> 01:38:20,000
首先一个一个约束就是说假说你要要要暴露出来一个 user 这么一个节点

2010
01:38:20,000 --> 01:38:21,000
这个这个

2011
01:38:21,000 --> 01:38:25,000
你可能代表的是一个账号体系的一个用户对吧

2012
01:38:25,000 --> 01:38:29,000
他返回给你的数据肯定是固定结构的

2013
01:38:29,000 --> 01:38:31,000
就是你取一个 user 你就取到他所有的信息

2014
01:38:31,000 --> 01:38:34,000
比如说你要取他的这个用户名这个 email

2015
01:38:34,000 --> 01:38:37,000
他才会把那个所有的详细的信息都返给你

2016
01:38:37,000 --> 01:38:45,000
哪怕你只是需要用他的这个所谓的一个用户名来显示这显示出一个或者一个头像的显示出一个一个什么的一个头像框而已对吧

2017
01:38:45,000 --> 01:38:48,000
对你没有他对于他的更为精细的控制

2018
01:38:48,000 --> 01:38:50,000
对对每对每一个资源来讲

2019
01:38:50,000 --> 01:38:54,000
你比较难去说你你在做一些更精细的要求

2020
01:38:54,000 --> 01:38:58,000
而且就是他所谓的这个可组合性也比较低

2021
01:38:58,000 --> 01:39:01,000
比如说就是最举个最简单的例子

2022
01:39:01,000 --> 01:39:03,000
我有一个 user 这么一个节点

2023
01:39:03,000 --> 01:39:07,000
然后有一个像一个 post 一个一个一个文章或者帖子这么一个节点

2024
01:39:07,000 --> 01:39:12,000
我想在取到说这个用户发过的那个文章的时候

2025
01:39:12,000 --> 01:39:14,000
你会牵涉到一个很麻烦的问题

2026
01:39:14,000 --> 01:39:16,000
就是说你把这个这个对应的请求

2027
01:39:16,000 --> 01:39:19,000
那显然不是完全归属于用户那个节点

2028
01:39:19,000 --> 01:39:22,000
他也不是完全归属于这个 post 那个节点

2029
01:39:22,000 --> 01:39:23,000
对吧

2030
01:39:23,000 --> 01:39:26,000
就有些这种很不正交的东西出现在里面

2031
01:39:26,000 --> 01:39:31,000
而且你又办法很很方便的在同一个请求里面去同时取这两个不同的东西

2032
01:39:31,000 --> 01:39:34,000
就他们的这个可组合性我觉得是比较比较低的

2033
01:39:34,000 --> 01:39:35,000
没错

2034
01:39:35,000 --> 01:39:37,000
然后最后最后一个呢就是说我实际用的体验中

2035
01:39:37,000 --> 01:39:42,000
就是因为这个大部分的 rest API 是通过 http 的这种方法去访问的嘛

2036
01:39:42,000 --> 01:39:43,000
嗯哼

2037
01:39:43,000 --> 01:39:49,000
然后我们现在用的 http 所谓这个 1.0 1.1 这个版本有一个问题就是说他有一个很严酷的就是 request

2038
01:39:49,000 --> 01:39:53,000
response 就是请求请求答复请求答复这么一个流程

2039
01:39:53,000 --> 01:39:57,000
你不可能说我发五个请求出去然后等五个回复出来对吧

2040
01:39:57,000 --> 01:40:00,000
这样这这种这种一个有效率的问题

2041
01:40:00,000 --> 01:40:02,000
那么很多人就为了解决这个效率问题

2042
01:40:02,000 --> 01:40:05,000
他要去考虑说我把这个请求所谓打包就是 batching 嘛

2043
01:40:05,000 --> 01:40:10,000
比如我把我要请求五个用户或者说请求五个用户三个文章

2044
01:40:10,000 --> 01:40:13,000
我要把这几个请求包在一起然后发一个请求过去

2045
01:40:13,000 --> 01:40:16,000
这个时候你用 rest API 的话就不是非常好做了

2046
01:40:16,000 --> 01:40:17,000
没错

2047
01:40:17,000 --> 01:40:18,000
所以所以总体来讲

2048
01:40:18,000 --> 01:40:21,000
这个 rest 在他的他的逻辑是很好的

2049
01:40:21,000 --> 01:40:23,000
就是说整整个概念是非常方便

2050
01:40:23,000 --> 01:40:30,000
他是但是我觉得他始终是一个更适用于那种所谓面向文档的那种类型的应用是比较好的

2051
01:40:30,000 --> 01:40:34,000
但是在我们目前在做的很多这种面向一些什么社交网络也好

2052
01:40:34,000 --> 01:40:37,000
还有其他一些更新形态的应用的时候

2053
01:40:37,000 --> 01:40:41,000
用 rest 这种 API 其实我觉得并不是一个特别好的选择

2054
01:40:41,000 --> 01:40:42,000
嗯

2055
01:40:42,000 --> 01:40:43,000
我我吃饱了一讲

2056
01:40:43,000 --> 01:40:46,000
我觉得啊就是我们所看到 relai

2057
01:40:46,000 --> 01:40:48,000
他的确在解决啊

2058
01:40:48,000 --> 01:40:51,000
另外一个问题但是啊

2059
01:40:51,000 --> 01:40:56,000
而且是非常有非常有意义的一个一个一个解决方案

2060
01:40:56,000 --> 01:40:59,000
还有我总总总会是觉得啊

2061
01:40:59,000 --> 01:41:08,000
relai 他的他的意义更在于是帮助像 facebook 这样大型的公司来来管理他的复杂度

2062
01:41:08,000 --> 01:41:13,000
因为只有在那个规模上你才会在意那么小级别

2063
01:41:13,000 --> 01:41:18,000
就是说到底是哪个哪个 view 得到哪个 field 来没有解决啊

2064
01:41:18,000 --> 01:41:20,000
那那个 career 都没有了吧

2065
01:41:20,000 --> 01:41:21,000
对

2066
01:41:21,000 --> 01:41:22,000
自己能准备的话

2067
01:41:22,000 --> 01:41:23,000
那也非常扯

2068
01:41:23,000 --> 01:41:24,000
ono

2069
01:41:24,000 --> 01:41:25,000
直接就可以放进 któregowater perché

2070
01:41:25,000 --> 01:41:26,000
对

2071
01:41:26,000 --> 01:41:29,000
所以就是 italoa

2072
01:41:29,000 --> 01:41:30,000
可以有什么的

2073
01:41:30,000 --> 01:41:31,000
好

2074
01:41:31,000 --> 01:41:32,000
嗯

2075
01:41:32,000 --> 01:41:33,000
ok

2076
01:41:33,000 --> 01:41:39,000
其实我的 Lucy 又点 MS

2077
01:41:39,000 --> 01:41:42,000
PA

2078
01:41:42,000 --> 01:41:43,000
不是

2079
01:41:43,000 --> 01:41:44,000
人在调的

2080
01:41:44,000 --> 01:41:45,000
大家都很多人也来这里

2081
01:41:45,000 --> 01:41:46,000
那一些对者 DEV scary

2082
01:41:46,000 --> 01:41:47,000
接着问他

2083
01:41:47,000 --> 01:41:49,000
API 的基础上

2084
01:41:49,000 --> 01:41:50,000
加上一些

2085
01:41:50,000 --> 01:41:52,000
控制的变量

2086
01:41:52,000 --> 01:41:53,000
比方说

2087
01:41:53,000 --> 01:41:55,000
Facebook 自己本身的

2088
01:41:55,000 --> 01:41:56,000
那个 graph API

2089
01:41:56,000 --> 01:41:57,000
有一个叫

2090
01:41:57,000 --> 01:41:57,000
fields 的概念

2091
01:41:57,000 --> 01:41:58,000
就是

2092
01:41:58,000 --> 01:41:58,000
你

2093
01:41:58,000 --> 01:42:00,000
fields 会

2094
01:42:00,000 --> 01:42:01,000
帮助你

2095
01:42:01,000 --> 01:42:04,000
控制它所返回的

2096
01:42:04,000 --> 01:42:05,000
那个 attributes

2097
01:42:05,000 --> 01:42:06,000
到底是哪一些 fields

2098
01:42:06,000 --> 01:42:07,000
这跟

2099
01:42:07,000 --> 01:42:08,000
这跟 relay 中的

2100
01:42:08,000 --> 01:42:09,000
一些概念

2101
01:42:09,000 --> 01:42:09,000
是非常相似的

2102
01:42:09,000 --> 01:42:11,000
非常 map 的

2103
01:42:11,000 --> 01:42:13,000
我也可以预见

2104
01:42:13,000 --> 01:42:14,000
就是在 relay

2105
01:42:14,000 --> 01:42:15,000
真正的发布的时候

2106
01:42:15,000 --> 01:42:16,000
会有人给

2107
01:42:16,000 --> 01:42:17,000
传统的

2108
01:42:17,000 --> 01:42:18,000
reserve API

2109
01:42:18,000 --> 01:42:20,000
写一些 adapter

2110
01:42:20,000 --> 01:42:21,000
然后从而

2111
01:42:21,000 --> 01:42:22,000
到那个

2112
01:42:22,000 --> 01:42:23,000
传统的 reserve API

2113
01:42:23,000 --> 01:42:24,000
也支持这个

2114
01:42:24,000 --> 01:42:25,000
relay 的

2115
01:42:25,000 --> 01:42:26,000
实现方式

2116
01:42:26,000 --> 01:42:27,000
刚好昨天

2117
01:42:27,000 --> 01:42:27,000
那个

2118
01:42:27,000 --> 01:42:29,000
因为 relay 现在还没有

2119
01:42:29,000 --> 01:42:30,000
它只是

2120
01:42:30,000 --> 01:42:31,000
发布了这个概念

2121
01:42:31,000 --> 01:42:32,000
它并没有公布

2122
01:42:32,000 --> 01:42:33,000
它后面的一些产品

2123
01:42:33,000 --> 01:42:33,000
然后昨天

2124
01:42:33,000 --> 01:42:35,000
在那个 hacker news 上面

2125
01:42:35,000 --> 01:42:36,000
Facebook 上面

2126
01:42:36,000 --> 01:42:37,000
有一个叫做

2127
01:42:37,000 --> 01:42:38,000
Vincent

2128
01:42:38,000 --> 01:42:39,000
不是 Vincent

2129
01:42:39,000 --> 01:42:40,000
是 Vincent

2130
01:42:40,000 --> 01:42:40,000
这么一个人

2131
01:42:40,000 --> 01:42:41,000
他不是在

2132
01:42:41,000 --> 01:42:42,000
Github 上写了一个

2133
01:42:42,000 --> 01:42:44,000
relay 的 FAQ 吗

2134
01:42:44,000 --> 01:42:45,000
常见问题解答

2135
01:42:45,000 --> 01:42:46,000
然后他

2136
01:42:46,000 --> 01:42:46,000
上面我就

2137
01:42:46,000 --> 01:42:47,000
问了他们

2138
01:42:47,000 --> 01:42:48,000
他们这么一个问题

2139
01:42:48,000 --> 01:42:49,000
就是说

2140
01:42:49,000 --> 01:42:50,000
relay 它很

2141
01:42:50,000 --> 01:42:51,000
依赖一个核心的组件

2142
01:42:51,000 --> 01:42:52,000
就是那个什么 graphql

2143
01:42:52,000 --> 01:42:54,000
就是这个图

2144
01:42:54,000 --> 01:42:55,000
查询语言

2145
01:42:55,000 --> 01:42:56,000
这个是跟 Facebook

2146
01:42:56,000 --> 01:42:57,000
他们后台有一个叫做

2147
01:42:57,000 --> 01:42:59,000
TAO 的一个图数据库

2148
01:42:59,000 --> 01:43:01,000
紧密相关的

2149
01:43:01,000 --> 01:43:02,000
但我不太清楚

2150
01:43:02,000 --> 01:43:03,000
就是说

2151
01:43:03,000 --> 01:43:04,000
对于一个第三方

2152
01:43:04,000 --> 01:43:05,000
就是作为一个 Facebook 以外的人

2153
01:43:05,000 --> 01:43:07,000
或者是中小开发者

2154
01:43:07,000 --> 01:43:08,000
或中小网站

2155
01:43:08,000 --> 01:43:09,000
你没有一个基于

2156
01:43:09,000 --> 01:43:11,000
这么一个图的

2157
01:43:11,000 --> 01:43:12,000
结构的后台的话

2158
01:43:12,000 --> 01:43:14,000
你怎么去

2159
01:43:14,000 --> 01:43:16,000
去适应这种

2160
01:43:16,000 --> 01:43:17,000
graphql 的要求

2161
01:43:17,000 --> 01:43:18,000
去做到 relay 这种效果

2162
01:43:18,000 --> 01:43:20,000
我觉得还是很大的一个疑惑

2163
01:43:20,000 --> 01:43:21,000
OK

2164
01:43:21,000 --> 01:43:22,000
这是一个机会

2165
01:43:22,000 --> 01:43:23,000
这是一个空白

2166
01:43:23,000 --> 01:43:25,000
市场现在是空白的

2167
01:43:25,000 --> 01:43:25,000
对不对

2168
01:43:25,000 --> 01:43:25,000
对

2169
01:43:25,000 --> 01:43:26,000
然后如果

2170
01:43:26,000 --> 01:43:29,000
如果我们有听众

2171
01:43:29,000 --> 01:43:29,000
you know

2172
01:43:29,000 --> 01:43:30,000
like

2173
01:43:30,000 --> 01:43:31,000
想要

2174
01:43:31,000 --> 01:43:32,000
再

2175
01:43:32,000 --> 01:43:34,000
借此机会来写一个什么

2176
01:43:34,000 --> 01:43:35,000
open source library

2177
01:43:35,000 --> 01:43:36,000
或者是甚至去开一个东西

2178
01:43:36,000 --> 01:43:39,000
我觉得这个机会是有可能存在的

2179
01:43:39,000 --> 01:43:40,000
你要知道

2180
01:43:40,000 --> 01:43:43,000
这个 graphql

2181
01:43:43,000 --> 01:43:43,000
它

2182
01:43:43,000 --> 01:43:45,000
最终

2183
01:43:45,000 --> 01:43:49,000
最终即使是 open source

2184
01:43:49,000 --> 01:43:49,000
不是即使

2185
01:43:49,000 --> 01:43:51,000
就是最终它会 open source

2186
01:43:51,000 --> 01:43:52,000
但是我们需要等一段时间

2187
01:43:52,000 --> 01:43:53,000
它的 open source 之后

2188
01:43:54,000 --> 01:43:57,000
它也更多的是作为一个 protocol 的存在

2189
01:43:57,000 --> 01:43:58,000
就像 flux

2190
01:43:58,000 --> 01:43:58,000
对

2191
01:43:58,000 --> 01:44:00,000
真正实现的是需要

2192
01:44:00,000 --> 01:44:01,000
是你自己去做的

2193
01:44:01,000 --> 01:44:06,000
根据它所用的软件来实现的

2194
01:44:06,000 --> 01:44:06,000
对

2195
01:44:06,000 --> 01:44:08,000
我觉得有点像 sql

2196
01:44:08,000 --> 01:44:12,000
你可以做一个 graphql database

2197
01:44:12,000 --> 01:44:15,000
然后或者说类 database 的 graphql

2198
01:44:15,000 --> 01:44:15,000
然后或者说类 database 的 graphql

2199
01:44:15,000 --> 01:44:16,000
然后或者说类 database 的 graphql

2200
01:44:16,000 --> 01:44:18,000
然后这个 server 可能会

2201
01:44:18,000 --> 01:44:21,000
会说一种 graphql 的 dialect

2202
01:44:21,000 --> 01:44:24,000
然后带某种扩展

2203
01:44:24,000 --> 01:44:25,000
就

2204
01:44:25,000 --> 01:44:26,000
就和 sql 一模一样

2205
01:44:26,000 --> 01:44:27,000
对没错

2206
01:44:27,000 --> 01:44:29,000
他们就算 relay 以后发布的时候

2207
01:44:29,000 --> 01:44:29,000
它也只会包含

2208
01:44:29,000 --> 01:44:32,000
首先第一个是客户端的 graphql

2209
01:44:32,000 --> 01:44:32,000
那些组件

2210
01:44:32,000 --> 01:44:34,000
比如说它可以在每一个

2211
01:44:34,000 --> 01:44:35,000
react

2212
01:44:35,000 --> 01:44:37,000
它可以在每个 react 组件里面声明

2213
01:44:37,000 --> 01:44:39,000
你组件需要哪一个

2214
01:44:39,000 --> 01:44:40,000
哪一种类型的数据

2215
01:44:40,000 --> 01:44:41,000
然后它可以通过

2216
01:44:41,000 --> 01:44:44,000
这个 relay 的 library 去把这些

2217
01:44:44,000 --> 01:44:45,000
这些需求都

2218
01:44:45,000 --> 01:44:46,000
都一次抽出来

2219
01:44:46,000 --> 01:44:49,000
然后往服务端发一个请求

2220
01:44:49,000 --> 01:44:49,000
就可以解决

2221
01:44:49,000 --> 01:44:51,000
包括它会帮你去做好

2222
01:44:51,000 --> 01:44:52,000
刚才讲的 batching

2223
01:44:52,000 --> 01:44:54,000
就是请求打包

2224
01:44:54,000 --> 01:44:56,000
包括哪些是可以重用的请求

2225
01:44:56,000 --> 01:44:57,000
就可以不用发送

2226
01:44:57,000 --> 01:44:59,000
包括本地的缓存

2227
01:44:59,000 --> 01:45:00,000
它都给你解决了

2228
01:45:00,000 --> 01:45:02,000
但是我觉得始终是在

2229
01:45:02,000 --> 01:45:04,000
反而就问题在客户端那边

2230
01:45:04,000 --> 01:45:05,000
在服务端那边

2231
01:45:05,000 --> 01:45:06,000
你是没有办法

2232
01:45:06,000 --> 01:45:08,000
因为最终它只会给你一个 graphql 的

2233
01:45:08,000 --> 01:45:09,000
这个叫什么

2234
01:45:09,000 --> 01:45:10,000
parser

2235
01:45:10,000 --> 01:45:12,000
然后它会给你一个语法术

2236
01:45:12,000 --> 01:45:14,000
但你怎么去满足

2237
01:45:14,000 --> 01:45:14,000
它每一个

2238
01:45:14,000 --> 01:45:14,000
这个 graphql

2239
01:45:14,000 --> 01:45:16,000
写的这么一个查询

2240
01:45:16,000 --> 01:45:18,000
你还是要挺费脑筋的

2241
01:45:18,000 --> 01:45:22,000
而且我觉得这不是一个小企业

2242
01:45:22,000 --> 01:45:24,000
或者是个人能够很轻易

2243
01:45:24,000 --> 01:45:24,000
做得到的事情

2244
01:45:25,000 --> 01:45:26,000
对

2245
01:45:26,000 --> 01:45:28,000
我很期待看到有人做一个

2246
01:45:28,000 --> 01:45:30,000
riskful API 的 adopter

2247
01:45:30,000 --> 01:45:34,000
因为虽然说他们两者的概念

2248
01:45:34,000 --> 01:45:35,000
是很有区别

2249
01:45:35,000 --> 01:45:36,000
但是实际上最终

2250
01:45:38,000 --> 01:45:39,000
graphql 和 riskful

2251
01:45:39,000 --> 01:45:41,000
都是访问数据的一个方式

2252
01:45:41,000 --> 01:45:43,000
所以说他们两个之间

2253
01:45:43,000 --> 01:45:44,000
是有可以 map 的地方

2254
01:45:44,000 --> 01:45:47,000
所以如果说有人能做一个

2255
01:45:47,000 --> 01:45:50,000
比方说 reelsapps

2256
01:45:50,000 --> 01:45:53,000
肯定可以有人做一个 reels graphql

2257
01:45:53,000 --> 01:45:55,000
然后一个 gym

2258
01:45:55,000 --> 01:45:56,000
你把这个加上之后

2259
01:45:56,000 --> 01:45:57,000
它的 riskful API

2260
01:45:57,000 --> 01:45:59,000
就可以通过这个 adopter

2261
01:45:59,000 --> 01:46:02,000
来实现 graphql

2262
01:46:02,000 --> 01:46:04,000
我觉得对这个可能在性能上

2263
01:46:04,000 --> 01:46:05,000
会有一些损失

2264
01:46:05,000 --> 01:46:07,000
然后也不是说直接你实现了 graphql

2265
01:46:07,000 --> 01:46:09,000
但是对于推广这个技术

2266
01:46:09,000 --> 01:46:11,000
你应用这个技术是非常好处的

2267
01:46:11,000 --> 01:46:13,000
因为作为一个过渡方案

2268
01:46:13,000 --> 01:46:14,000
对作为一个过渡方案

2269
01:46:14,000 --> 01:46:15,000
应该是挺好的

2270
01:46:15,000 --> 01:46:15,000
对吧

2271
01:46:15,000 --> 01:46:17,000
所以我就还是在想

2272
01:46:17,000 --> 01:46:18,000
因为之前在知乎的时候

2273
01:46:18,000 --> 01:46:20,000
我的很大的一部分工作

2274
01:46:20,000 --> 01:46:23,000
就是在琢磨这些乌七八糟的

2275
01:46:23,000 --> 01:46:25,000
有的没的图的结构

2276
01:46:25,000 --> 01:46:27,000
其实我后来的一个体验

2277
01:46:27,000 --> 01:46:28,000
就是说

2278
01:46:28,000 --> 01:46:30,000
其实真的是蛮难的

2279
01:46:30,000 --> 01:46:32,000
作为一个普通的团队

2280
01:46:32,000 --> 01:46:33,000
你像很多这种所谓的 web 应用

2281
01:46:33,000 --> 01:46:35,000
它都是一个什么

2282
01:46:35,000 --> 01:46:36,000
mysql 一个后台

2283
01:46:36,000 --> 01:46:37,000
然后前面加

2284
01:46:37,000 --> 01:46:40,000
封一个 rest 的一个 API 层

2285
01:46:40,000 --> 01:46:41,000
然后再加几个 redis 的这种

2286
01:46:42,000 --> 01:46:43,000
叫什么

2287
01:46:43,000 --> 01:46:44,000
就是缓冲层吗

2288
01:46:44,000 --> 01:46:48,000
然后它就可以满足一个中型网站的应用了

2289
01:46:48,000 --> 01:46:53,000
但是你要实现像 graphq 那么灵活多变的查询

2290
01:46:53,000 --> 01:46:57,000
而且要达到那种好用程度

2291
01:46:57,000 --> 01:46:59,000
你真的是要后台要做很多工作

2292
01:46:59,000 --> 01:47:01,000
它能够实现 graph 的结构的

2293
01:47:01,000 --> 01:47:02,000
就 graphq 出现了

2294
01:47:02,000 --> 01:47:08,000
我发现其实这一个抽象层级的需求是非常明显的

2295
01:47:08,000 --> 01:47:09,000
但是在它做出来

2296
01:47:09,000 --> 01:47:11,000
在 graphq 而出现之前

2297
01:47:11,000 --> 01:47:12,000
好像没有人去讨论它

2298
01:47:12,000 --> 01:47:14,000
是有的

2299
01:47:14,000 --> 01:47:14,000
就是

2300
01:47:14,000 --> 01:47:15,000
但是就是说

2301
01:47:15,000 --> 01:47:16,000
因为它不是 Facebook

2302
01:47:16,000 --> 01:47:18,000
没有吸引到足够的眼球

2303
01:47:18,000 --> 01:47:18,000
是吧

2304
01:47:18,000 --> 01:47:20,000
我觉得主要是因为现在的主流

2305
01:47:20,000 --> 01:47:23,000
就是就除了像 Facebook 这种巨头

2306
01:47:23,000 --> 01:47:24,000
能够有精力

2307
01:47:24,000 --> 01:47:28,000
或者有资源去把它的后端做成一个这种类

2308
01:47:28,000 --> 01:47:30,000
这种结构的方式去查询的话

2309
01:47:30,000 --> 01:47:32,000
其他那些中小企业真的是还蛮难

2310
01:47:32,000 --> 01:47:34,000
因为没有一个现成的

2311
01:47:34,000 --> 01:47:36,000
或者说被像 mysql 这种级别

2312
01:47:36,000 --> 01:47:38,000
能被大众广泛接受

2313
01:47:38,000 --> 01:47:39,000
有好用的图数据库

2314
01:47:39,000 --> 01:47:41,000
有几个例子

2315
01:47:41,000 --> 01:47:42,000
像什么

2316
01:47:42,000 --> 01:47:43,000
neo 4 j

2317
01:47:43,000 --> 01:47:44,000
什么 orandy

2318
01:47:44,000 --> 01:47:45,000
b 这类的

2319
01:47:45,000 --> 01:47:49,000
他们但是就是你可以看到就成功案例很少

2320
01:47:49,000 --> 01:47:52,000
就是你首先一个熟悉程度也就是它的成熟程度本身也不够

2321
01:47:52,000 --> 01:47:54,000
然后大家也不太敢用

2322
01:47:54,000 --> 01:47:59,000
然后这样的话就会反而导致这一块其实在市场上是很弱的

2323
01:47:59,000 --> 01:48:02,000
我倒是希望说这个 relay 或者是 graphq

2324
01:48:02,000 --> 01:48:05,000
这个正式开源出来之后

2325
01:48:05,000 --> 01:48:07,000
大家会意识到这个的好处

2326
01:48:07,000 --> 01:48:12,000
以及对包括前端开发的难度的降低

2327
01:48:12,000 --> 01:48:14,000
然后包括后端的开发

2328
01:48:14,000 --> 01:48:15,000
开发的成本的降低

2329
01:48:15,000 --> 01:48:17,000
然后能够使得大家更多去思考

2330
01:48:17,000 --> 01:48:19,000
我要不要用一下这种图

2331
01:48:19,000 --> 01:48:23,000
以图为主要结构的这种数据后台

2332
01:48:23,000 --> 01:48:23,000
对

2333
01:48:23,000 --> 01:48:29,000
这算是 Facebook 对于整个 tech stack 做出了一个贡献吗

2334
01:48:29,000 --> 01:48:33,000
其实 real

2335
01:48:33,000 --> 01:48:38,000
You mention 了图结构的 database

2336
01:48:38,000 --> 01:48:41,000
我其实我就是 honest question

2337
01:48:41,000 --> 01:48:43,000
我并不清楚这个东西

2338
01:48:43,000 --> 01:48:48,000
它那个命名是一个出于一个 branding 的考虑

2339
01:48:48,000 --> 01:48:50,000
还是他真的就是所谓图

2340
01:48:50,000 --> 01:48:52,000
我没有听说过图 database

2341
01:48:52,000 --> 01:48:54,000
就是 honest 没有听说过

2342
01:48:54,000 --> 01:48:59,000
对这个是一个相对于没有那么大众的一个应用

2343
01:48:59,000 --> 01:49:02,000
其实图数字固定解决的问题也是蛮简单的

2344
01:49:02,000 --> 01:49:05,000
你可以想象一个普通的是一个社交网络

2345
01:49:05,000 --> 01:49:07,000
只有一种类型的节点

2346
01:49:07,000 --> 01:49:08,000
我们就考虑最简单的一个情况

2347
01:49:08,000 --> 01:49:11,000
我们有用户就 user 你和我

2348
01:49:11,000 --> 01:49:12,000
然后无他我们三个人

2349
01:49:13,000 --> 01:49:14,000
然后图数字固存有什么

2350
01:49:14,000 --> 01:49:16,000
这个就存有节点

2351
01:49:16,000 --> 01:49:18,000
我们本身节点有些什么样的属性

2352
01:49:18,000 --> 01:49:20,000
比如说我作为一个人

2353
01:49:20,000 --> 01:49:22,000
这个 user 这么一个节点

2354
01:49:22,000 --> 01:49:23,000
有什么名字

2355
01:49:23,000 --> 01:49:23,000
性别

2356
01:49:23,000 --> 01:49:24,000
年龄

2357
01:49:24,000 --> 01:49:27,000
出生日期之类的一些 attributes

2358
01:49:27,000 --> 01:49:28,000
对吧

2359
01:49:28,000 --> 01:49:32,000
这个是跟传统的包括这种我们像 Mysql 这种

2360
01:49:32,000 --> 01:49:33,000
就是 RDB

2361
01:49:33,000 --> 01:49:34,000
就是 relational database

2362
01:49:34,000 --> 01:49:35,000
其实没有太大区别的

2363
01:49:35,000 --> 01:49:37,000
就是无非就是说

2364
01:49:37,000 --> 01:49:41,000
每一个节点对于 relational database 里面的一个行

2365
01:49:41,000 --> 01:49:41,000
一个 row

2366
01:49:41,000 --> 01:49:43,000
然后每一个 attribute

2367
01:49:43,000 --> 01:49:48,000
对应它的传统的 relational database 的一个 column

2368
01:49:48,000 --> 01:49:49,000
对吧

2369
01:49:49,000 --> 01:49:49,000
对

2370
01:49:49,000 --> 01:49:55,000
然后但是一个图数字固更加重要的一点

2371
01:49:55,000 --> 01:49:57,000
其实是存储这个节点

2372
01:49:57,000 --> 01:49:58,000
节点之间的关系

2373
01:49:58,000 --> 01:50:00,000
比方说我可以说我可以 friend 你们两个

2374
01:50:00,000 --> 01:50:02,000
你们可以两个之间互相 friend

2375
01:50:02,000 --> 01:50:06,000
然后你可以和别的人也互相 friend

2376
01:50:06,000 --> 01:50:07,000
这个时候的话

2377
01:50:07,000 --> 01:50:09,000
这个时候它表现出来的结构

2378
01:50:09,000 --> 01:50:12,000
如果我们在传统的一个 relational database 里面去实现

2379
01:50:12,000 --> 01:50:13,000
会怎么样

2380
01:50:13,000 --> 01:50:14,000
会通过一个

2381
01:50:14,000 --> 01:50:17,000
因为一张表来做一个连接

2382
01:50:17,000 --> 01:50:18,000
比如说对

2383
01:50:18,000 --> 01:50:20,000
你们要比较狭小的时候叫做关注

2384
01:50:20,000 --> 01:50:20,000
对

2385
01:50:20,000 --> 01:50:21,000
就会想

2386
01:50:21,000 --> 01:50:21,000
sorry

2387
01:50:21,000 --> 01:50:22,000
cut it off

2388
01:50:22,000 --> 01:50:25,000
我只是做一个 check 而已

2389
01:50:25,000 --> 01:50:26,000
所以谢谢你的解释

2390
01:50:26,000 --> 01:50:28,000
但是我们还是不挖吧

2391
01:50:28,000 --> 01:50:30,000
我觉得这段就不用再 podcast

2392
01:50:30,000 --> 01:50:30,000
没啥

2393
01:50:30,000 --> 01:50:32,000
可以放进来接着解释完

2394
01:50:32,000 --> 01:50:33,000
很多人不理解

2395
01:50:34,000 --> 01:50:36,000
就听众里面可能不是很熟悉这个概念

2396
01:50:36,000 --> 01:50:37,000
因为这个确实在工业中

2397
01:50:37,000 --> 01:50:38,000
我有用的不多了

2398
01:50:38,000 --> 01:50:39,000
对

2399
01:50:39,000 --> 01:50:40,000
因为对我来讲的话

2400
01:50:40,000 --> 01:50:42,000
我觉得就是说 graphqls

2401
01:50:43,000 --> 01:50:44,000
只是一个 branding 而已

2402
01:50:44,000 --> 01:50:46,000
并不是并不是真正在说

2403
01:50:46,000 --> 01:50:47,000
不

2404
01:50:47,000 --> 01:50:49,000
他真的是就是说 graphql 本身

2405
01:50:49,000 --> 01:50:51,000
他真的是要有这么一种

2406
01:50:52,000 --> 01:50:54,000
对后端其实是有很大要求的

2407
01:50:54,000 --> 01:50:56,000
你才可以做到他那么灵活的查询

2408
01:50:56,000 --> 01:50:58,000
不然的话你可以做

2409
01:50:58,000 --> 01:51:00,000
你可以去用什么叫 adapt 的方式

2410
01:51:00,000 --> 01:51:02,000
去把 graphql 的查询

2411
01:51:02,000 --> 01:51:04,000
转换成对应的 rest 的查询

2412
01:51:04,000 --> 01:51:05,000
但是这样的效率非常低

2413
01:51:05,000 --> 01:51:09,000
因为整个你的后台的数据库的组织的结构

2414
01:51:09,000 --> 01:51:12,000
就不是按照一个那种图的查询的方式

2415
01:51:13,000 --> 01:51:13,000
来查询的

2416
01:51:13,000 --> 01:51:15,000
因为图里面查询的最常见的什么

2417
01:51:15,000 --> 01:51:17,000
就是便利节点便利

2418
01:51:17,000 --> 01:51:18,000
对吧

2419
01:51:18,000 --> 01:51:20,000
这个在你的 adapt

2420
01:51:20,000 --> 01:51:23,000
这个什么在如果在一个传统 relation

2421
01:51:23,000 --> 01:51:25,000
在那边是你做你这个性能是作死的

2422
01:51:25,000 --> 01:51:25,000
你想一下

2423
01:51:25,000 --> 01:51:29,000
你要假设你在一个社交网状图里面

2424
01:51:29,000 --> 01:51:31,000
你要从某个节点为中心查询

2425
01:51:31,000 --> 01:51:32,000
他的好友的话

2426
01:51:32,000 --> 01:51:34,000
你在一个传统的 relation

2427
01:51:34,000 --> 01:51:35,000
在那边是里面

2428
01:51:35,000 --> 01:51:37,000
你要去要查好多张表

2429
01:51:38,000 --> 01:51:40,000
你要不要你查三个维度的好友

2430
01:51:40,000 --> 01:51:42,000
就是三就是什么三度分割的好友的话

2431
01:51:43,000 --> 01:51:45,000
你要用传统的 relation 的 data base 查询的话

2432
01:51:45,000 --> 01:51:46,000
这是非常困难的

2433
01:51:46,000 --> 01:51:49,000
所以我就是在想就是说

2434
01:51:49,000 --> 01:51:53,000
其实现在有这么多的社交场合的应用

2435
01:51:53,000 --> 01:51:58,000
反而是没有一个基于能够很好满足社交查询的

2436
01:51:58,000 --> 01:52:00,000
这么一种数据存储的引擎

2437
01:52:00,000 --> 01:52:02,000
能够大规模的方便的使用

2438
01:52:02,000 --> 01:52:04,000
其实是蛮悲哀的一个现状

2439
01:52:04,000 --> 01:52:05,000
其实也是挺奇怪的

2440
01:52:05,000 --> 01:52:08,000
难做嘛

2441
01:52:08,000 --> 01:52:09,000
这确实挺难的

2442
01:52:09,000 --> 01:52:12,000
就比如说我们传统的

2443
01:52:13,000 --> 01:52:14,000
做一个 relation 的 data base

2444
01:52:14,000 --> 01:52:14,000
你可以性能不够

2445
01:52:14,000 --> 01:52:16,000
你可以做简单的什么 sharding

2446
01:52:16,000 --> 01:52:17,000
就分割

2447
01:52:17,000 --> 01:52:21,000
按照 key 的范围来分割

2448
01:52:21,000 --> 01:52:23,000
但是你怎么去分割一个图

2449
01:52:23,000 --> 01:52:24,000
就很难的一件事情

2450
01:52:24,000 --> 01:52:25,000
对

2451
01:52:26,000 --> 01:52:28,000
所以就里面还是有很多这种非常 hardcore 的

2452
01:52:28,000 --> 01:52:30,000
computer science 的东西

2453
01:52:30,000 --> 01:52:31,000
在里面要解决

2454
01:52:31,000 --> 01:52:34,000
而市面上现有的解决方案

2455
01:52:34,000 --> 01:52:37,000
都给人一种信心不足的感觉

2456
01:52:39,000 --> 01:52:39,000
对了

2457
01:52:39,000 --> 01:52:42,000
其实这段我就是蛮担忧的

2458
01:52:42,000 --> 01:52:44,000
就是说如果解决不好

2459
01:52:44,000 --> 01:52:45,000
graphcare 这种东西

2460
01:52:45,000 --> 01:52:48,000
就真的是只能局限于像 Facebook

2461
01:52:48,000 --> 01:52:50,000
像 Google 这种庞大的企业

2462
01:52:50,000 --> 01:52:51,000
它能够有资源

2463
01:52:51,000 --> 01:52:53,000
或者能力去实现自己的

2464
01:52:53,000 --> 01:52:56,000
或者维护自己的这么一套基于图的

2465
01:52:56,000 --> 01:52:58,000
或者是以图结构为导向的

2466
01:52:58,000 --> 01:53:00,000
这么一个后台系统

2467
01:53:00,000 --> 01:53:02,000
否则其他人还是只能很乐呵呵的

2468
01:53:02,000 --> 01:53:04,000
继续用的 rest

2469
01:53:08,000 --> 01:53:08,000
对 什么

2470
01:53:08,000 --> 01:53:10,000
那威罗你说一下整个

2471
01:53:10,000 --> 01:53:12,000
就是说刚才我们讲了 react 相关

2472
01:53:12,000 --> 01:53:14,000
还包括你在会上看到一些东西

2473
01:53:14,000 --> 01:53:16,000
但是你说整个来讲

2474
01:53:16,000 --> 01:53:18,000
你对这个会本身是什么样的一个感受

2475
01:53:21,000 --> 01:53:24,000
这是我所去过的比较好的一个会之一了

2476
01:53:24,000 --> 01:53:26,000
因为整个的所有的 speech

2477
01:53:26,000 --> 01:53:28,000
都非常的有意义

2478
01:53:28,000 --> 01:53:30,000
非常能觉得从中能够学到东西

2479
01:53:30,000 --> 01:53:31,000
都不是在

2480
01:53:33,000 --> 01:53:34,000
都非常有意义

2481
01:53:34,000 --> 01:53:35,000
非常 hardcore

2482
01:53:35,000 --> 01:53:37,000
也是我觉得这一点是非常难得的

2483
01:53:38,000 --> 01:53:41,000
会的组织肯定做了很好的工作

2484
01:53:41,000 --> 01:53:41,000
来

2485
01:53:42,000 --> 01:53:43,000
来取这些

2486
01:53:44,000 --> 01:53:46,000
这些演讲者和演讲本身

2487
01:53:48,000 --> 01:53:50,000
我们有非常多的那个搜索的机会

2488
01:53:50,000 --> 01:53:52,000
在其中也遇到了非常非常多人

2489
01:53:52,000 --> 01:53:56,000
然后 reaction 的真的是被应用到各种各方各面

2490
01:53:56,000 --> 01:54:00,000
很多你想不到的一些 application

2491
01:54:00,000 --> 01:54:01,000
都在使用 react

2492
01:54:01,000 --> 01:54:03,000
都在或者在考虑使用 react

2493
01:54:04,000 --> 01:54:05,000
非常的激动人心的

2494
01:54:05,000 --> 01:54:08,000
就是可能会看到这么多实际的应用

2495
01:54:08,000 --> 01:54:11,000
这么多积极主动来参与这个设计的活动

2496
01:54:11,000 --> 01:54:11,000
这么多积极主动来参与这个设计的活动

2497
01:54:11,000 --> 01:54:12,000
这么多积极主动来参与这个设计的活动

2498
01:54:12,000 --> 01:54:13,000
这个区的人

2499
01:54:13,000 --> 01:54:14,000
所以整体来说

2500
01:54:14,000 --> 01:54:19,000
我觉得是一个非常好的一个气氛

2501
01:54:19,000 --> 01:54:24,000
大家都非常对这个 react 的前景都非常乐观

2502
01:54:25,000 --> 01:54:29,000
我也很高兴看到 facebook 对整个会议的支持

2503
01:54:29,000 --> 01:54:33,000
跟对整个这个 react 的技术的支持

2504
01:54:33,000 --> 01:54:34,000
after all

2505
01:54:34,000 --> 01:54:39,000
我也觉得非常开心能够得到这个 react native 的一个 preview

2506
01:54:39,000 --> 01:54:41,000
我有给我的同事演示

2507
01:54:42,000 --> 01:54:47,000
这对我们做接下来的一些 technology 选项都是非常有帮助的

2508
01:54:47,000 --> 01:54:52,000
所以贵公司也是要出一个 mobile 领域的客户端的吗

2509
01:54:52,000 --> 01:54:55,000
我们一直有那个 mobile 的客户端

2510
01:54:55,000 --> 01:54:57,000
我们有 ios 跟 android 的客户端

2511
01:54:57,000 --> 01:54:58,000
然后 oh well

2512
01:54:58,000 --> 01:55:02,000
foreseeable future 肯定不是 react native 对不对

2513
01:55:02,000 --> 01:55:05,000
但是对于那个技术的选情

2514
01:55:05,000 --> 01:55:06,000
观察这个技术的发展来说的话

2515
01:55:06,000 --> 01:55:10,000
我们肯定现在是把它是摆在一个比较重要的位置了

2516
01:55:10,000 --> 01:55:12,000
对没错

2517
01:55:12,000 --> 01:55:14,000
ok 那行吧

2518
01:55:14,000 --> 01:55:18,000
今天我们非常高兴邀请到 villow 来给我们讨论这个 react

2519
01:55:18,000 --> 01:55:20,000
的一系列相关的东西

2520
01:55:20,000 --> 01:55:24,000
然后那今天的节目就到此为止

2521
01:55:24,000 --> 01:55:25,000
谢谢大家

2522
01:55:25,000 --> 01:55:26,000
谢谢大家的收听

2523
01:55:26,000 --> 01:55:28,000
谢谢大家

2524
01:55:28,000 --> 01:55:30,000
我们下期再见

2525
01:55:30,000 --> 01:55:32,000
我还要念那个吗

2526
01:55:32,000 --> 01:55:33,000
你念吧

2527
01:55:33,000 --> 01:55:34,000
ok

2528
01:55:34,000 --> 01:55:36,000
感谢大家收听内核恐慌

2529
01:55:36,000 --> 01:55:40,000
也欢迎大家收听 ipn 旗下的其他舞蹈 podcast

2530
01:55:40,000 --> 01:55:42,000
包括技术主题节目

2531
01:55:42,000 --> 01:55:43,000
it 公论

2532
01:55:43,000 --> 01:55:44,000
医疗主题节目

2533
01:55:44,000 --> 01:55:45,000
太医来了

2534
01:55:45,000 --> 01:55:46,000
美食节目未知道

2535
01:55:46,000 --> 01:55:50,000
以及艺术类节目流行通信

2536
01:55:50,000 --> 01:55:53,000
最后还有不知道是在播什么的五主题节目五次元

2537
01:55:53,000 --> 01:55:55,000
感谢大家的收听

