1
00:00:00,000 --> 00:00:01,000
您正在收听的是

2
00:00:01,000 --> 00:00:03,000
IPN Podcast 网络旗下的

3
00:00:03,000 --> 00:00:05,000
IT 技术主义节目

4
00:00:05,000 --> 00:00:06,000
内核恐慌

5
00:00:06,000 --> 00:00:07,000
我们号称 hardcore

6
00:00:07,000 --> 00:00:09,000
但是也没有干货

7
00:00:09,000 --> 00:00:10,000
想听的人听

8
00:00:10,000 --> 00:00:11,000
不想听的人就别听

9
00:00:11,000 --> 00:00:13,000
内核恐慌的网址是

10
00:00:13,000 --> 00:00:15,000
kernelpanic.fm

11
00:00:15,000 --> 00:00:17,000
我们推荐大家使用

12
00:00:17,000 --> 00:00:19,000
泛用型 podcast 客户端

13
00:00:19,000 --> 00:00:20,000
订阅我们的节目

14
00:00:20,000 --> 00:00:21,000
如果您不知道

15
00:00:21,000 --> 00:00:22,000
什么是客户端

16
00:00:22,000 --> 00:00:25,000
请访问 ipn.ai

17
00:00:25,000 --> 00:00:29,000
欢迎你为我们的节目捐款

18
00:00:29,000 --> 00:00:30,000
捐款地址是

19
00:00:30,000 --> 00:00:31,000
ipn.ai

20
00:00:31,000 --> 00:00:34,000
kernelpanic.fm

21
00:00:34,000 --> 00:00:37,000
捐款金额随意

22
00:00:37,000 --> 00:00:39,000
捐款不会为你带来什么

23
00:00:39,000 --> 00:00:41,000
不捐也不会让你失去什么

24
00:00:41,000 --> 00:00:43,000
OK

25
00:00:43,000 --> 00:00:46,000
今天是我们的第 18 期节目

26
00:00:46,000 --> 00:00:48,000
不过 Rail 因为非常忙

27
00:00:48,000 --> 00:00:51,000
不能参加本期节目的录音了

28
00:00:51,000 --> 00:00:53,000
不过他一定会参加

29
00:00:53,000 --> 00:00:55,000
明天的 IT 攻略录音

30
00:00:55,000 --> 00:00:56,000
所以各位

31
00:00:56,000 --> 00:00:58,000
尤其是会员们

32
00:00:58,000 --> 00:00:58,000
可以

33
00:00:58,000 --> 00:01:00,000
送一口气

34
00:01:00,000 --> 00:01:01,000
另外

35
00:01:01,000 --> 00:01:04,000
单纯因为迷恋 Rail 的

36
00:01:04,000 --> 00:01:06,000
Rail 的声音的朋友

37
00:01:06,000 --> 00:01:08,000
听到这里

38
00:01:08,000 --> 00:01:09,000
其实就可以转台了

39
00:01:09,000 --> 00:01:10,000
因为

40
00:01:10,000 --> 00:01:12,000
必须说

41
00:01:12,000 --> 00:01:14,000
有台的节目更好听

42
00:01:14,000 --> 00:01:16,000
尤其推荐上一期

43
00:01:16,000 --> 00:01:17,000
太一来了

44
00:01:17,000 --> 00:01:19,000
主题是情趣用品

45
00:01:19,000 --> 00:01:22,000
请在家长缺席一下

46
00:01:22,000 --> 00:01:22,000
所以

47
00:01:22,000 --> 00:01:26,000
仍旧坚守着

48
00:01:26,000 --> 00:01:27,000
内科恐慌的朋友们

49
00:01:27,000 --> 00:01:27,000
你们好

50
00:01:27,000 --> 00:01:28,000
本期没有

51
00:01:28,000 --> 00:01:29,000
Rail

52
00:01:29,000 --> 00:01:31,000
但是也没有嘉宾

53
00:01:31,000 --> 00:01:33,000
只有我一个人在这边

54
00:01:33,000 --> 00:01:35,000
孤独的坚守着阵地

55
00:01:35,000 --> 00:01:38,000
但是这是你听起来的错觉

56
00:01:38,000 --> 00:01:39,000
因为实际情况是

57
00:01:39,000 --> 00:01:40,000
我的女朋友

58
00:01:40,000 --> 00:01:41,000
此刻正坐在旁边

59
00:01:41,000 --> 00:01:42,000
为我端茶倒水

60
00:01:42,000 --> 00:01:43,000
煽风垂背

61
00:01:43,000 --> 00:01:46,000
所以本期的主题就是

62
00:01:46,000 --> 00:01:47,000
程序员怎么样

63
00:01:47,000 --> 00:01:49,000
才能找到一个女朋友

64
00:01:49,000 --> 00:01:53,000
但是在进入主题之前

65
00:01:53,000 --> 00:01:55,000
我们先来念几封读者来信

66
00:01:55,000 --> 00:01:58,000
首先是

67
00:01:58,000 --> 00:02:02,000
一位叫做萤火的朋友

68
00:02:02,000 --> 00:02:07,000
他说第 17 期的后面提到

69
00:02:07,000 --> 00:02:10,000
吴涛说不知道 DLL 的图标是什么意思

70
00:02:10,000 --> 00:02:13,000
所以不知道可不可以删

71
00:02:13,000 --> 00:02:17,000
而我小时候试过将系统的 DLL 文件删除了

72
00:02:17,000 --> 00:02:19,000
那个时候玩表哥家的电脑

73
00:02:19,000 --> 00:02:20,000
他们出去了

74
00:02:20,000 --> 00:02:22,000
剩我一个人在玩核心弹头

75
00:02:22,000 --> 00:02:23,000
玩了一会儿觉得无聊

76
00:02:23,000 --> 00:02:24,000
就用鼠标乱点

77
00:02:24,000 --> 00:02:26,000
花花绿绿的图标可以点开

78
00:02:26,000 --> 00:02:28,000
有齿轮的图标都点不开

79
00:02:28,000 --> 00:02:28,000
我得点开了

80
00:02:28,000 --> 00:02:29,000
我理所当然的认为

81
00:02:29,000 --> 00:02:30,000
点不开是没有用的

82
00:02:30,000 --> 00:02:31,000
没有用的就应该被删掉

83
00:02:31,000 --> 00:02:34,000
所以我将所有能看到的

84
00:02:34,000 --> 00:02:36,000
点不开的文件都删除了

85
00:02:36,000 --> 00:02:37,000
后来要吃饭

86
00:02:37,000 --> 00:02:38,000
就心满意足的关了机

87
00:02:38,000 --> 00:02:40,000
到晚上表哥回来

88
00:02:40,000 --> 00:02:41,000
发现电脑启动不了

89
00:02:41,000 --> 00:02:43,000
我以为弄烂了电脑很害怕

90
00:02:43,000 --> 00:02:46,000
因为那个时候电脑比电视机和摩托车都贵

91
00:02:46,000 --> 00:02:47,000
赔不起

92
00:02:47,000 --> 00:02:50,000
后来表哥打电话

93
00:02:50,000 --> 00:02:51,000
叫了个同学过来

94
00:02:51,000 --> 00:02:53,000
那个同学在一个黑乎乎的窗口里面打字

95
00:02:53,000 --> 00:02:55,000
折腾了半个钟头

96
00:02:55,000 --> 00:02:57,000
电脑重新可以用了

97
00:02:57,000 --> 00:02:58,000
小小的我觉得那个人

98
00:02:58,000 --> 00:02:59,000
是大大高手

99
00:02:59,000 --> 00:03:01,000
很久以后我才醒过来

100
00:03:01,000 --> 00:03:03,000
那个时候删掉的文件是 DLL

101
00:03:03,000 --> 00:03:06,000
那个高手所做的叫做重装系统

102
00:03:07,000 --> 00:03:08,000
不玩了

103
00:03:08,000 --> 00:03:10,000
这让我想起

104
00:03:10,000 --> 00:03:11,000
DOS 时代

105
00:03:11,000 --> 00:03:13,000
好像没有这样的疑惑

106
00:03:13,000 --> 00:03:14,000
因为 DOS 时代

107
00:03:14,000 --> 00:03:19,000
如果你不区分可执行文件和不可执行文件的话

108
00:03:19,000 --> 00:03:22,000
是很难知道哪个文件有用

109
00:03:22,000 --> 00:03:23,000
哪个文件没有用的

110
00:03:23,000 --> 00:03:25,000
你只能看扩展名

111
00:03:25,000 --> 00:03:27,000
而如果你不懂扩展名的意义的话

112
00:03:27,000 --> 00:03:28,000
你只能看扩展名

113
00:03:28,000 --> 00:03:30,000
你是不会默密全报去删他的

114
00:03:30,000 --> 00:03:33,000
这可能也是另外一个

115
00:03:33,000 --> 00:03:36,000
命令行比较安全的因素吧

116
00:03:36,000 --> 00:03:39,000
或者说早期的图形化界面

117
00:03:39,000 --> 00:03:43,000
没有默认用户有可能不知道自己在干什么

118
00:03:43,000 --> 00:03:45,000
现在的操作系统都做得很好了

119
00:03:45,000 --> 00:03:50,000
把比较容易弄坏的部分都隐藏起来

120
00:03:50,000 --> 00:03:53,000
这让我想起 DOS 时代重装系统

121
00:03:53,000 --> 00:03:56,000
好像只需要格式化一下系统盘就可以了

122
00:03:56,000 --> 00:03:57,000
好像一条命令吧

123
00:03:58,000 --> 00:03:59,000
SYS 还是什么

124
00:03:59,000 --> 00:04:01,000
还是斜杠 SYS

125
00:04:01,000 --> 00:04:06,000
就可以把 DOS 传播到一个软盘或者硬盘上

126
00:04:06,000 --> 00:04:07,000
让它变成可以 boot

127
00:04:07,000 --> 00:04:08,000
对

128
00:04:08,000 --> 00:04:11,000
如果各位 90 后听众没有经历过那个时代的话

129
00:04:11,000 --> 00:04:13,000
那个时代重装系统

130
00:04:13,000 --> 00:04:14,000
没有光盘可以用

131
00:04:14,000 --> 00:04:17,000
当然更可能网络可以用

132
00:04:17,000 --> 00:04:20,000
基本上就是你有 10 张软盘

133
00:04:20,000 --> 00:04:21,000
甚至更多

134
00:04:21,000 --> 00:04:25,000
我现在已经不记得那个时候第一版 Windows 3.2

135
00:04:25,000 --> 00:04:25,000
或者是

136
00:04:25,000 --> 00:04:27,000
我相信 Windows 9.5

137
00:04:27,000 --> 00:04:28,000
都出过软盘吧

138
00:04:28,000 --> 00:04:30,000
对

139
00:04:30,000 --> 00:04:31,000
你要把一张一张软盘

140
00:04:31,000 --> 00:04:35,000
依次插入软盘驱动器

141
00:04:35,000 --> 00:04:36,000
天哪软盘驱动器

142
00:04:36,000 --> 00:04:38,000
我有多久没收过这次了

143
00:04:38,000 --> 00:04:42,000
然后每张软盘可能装给 10% 5%左右

144
00:04:42,000 --> 00:04:46,000
然后你要耐心的坐着

145
00:04:46,000 --> 00:04:48,000
一张一张手动的去换软盘

146
00:04:48,000 --> 00:04:50,000
那像现在科技昌明

147
00:04:50,000 --> 00:04:52,000
就像写一个文本文件

148
00:04:52,000 --> 00:04:55,000
告诉电脑你需要一台什么样的虚拟机

149
00:04:55,000 --> 00:04:56,000
电脑很快就可以

150
00:04:56,000 --> 00:04:57,000
在一瞬间帮你

151
00:04:57,000 --> 00:05:01,000
竖起来一台具有完整的骚扰系统

152
00:05:01,000 --> 00:05:04,000
和程序开发环境的虚拟机

153
00:05:04,000 --> 00:05:07,000
我真是老了

154
00:05:07,000 --> 00:05:11,000
不过其实我从很小的时候就建立起一个信念

155
00:05:11,000 --> 00:05:13,000
只要你不去拆机箱

156
00:05:13,000 --> 00:05:14,000
电脑就是弄不坏

157
00:05:14,000 --> 00:05:17,000
我不知道现在学编程的朋友们

158
00:05:17,000 --> 00:05:19,000
是不是还有这个疑惑

159
00:05:19,000 --> 00:05:22,000
就是有时候会很担心把电脑弄坏

160
00:05:22,000 --> 00:05:24,000
但实际情况就是

161
00:05:24,000 --> 00:05:26,000
只要你好好做备份

162
00:05:26,000 --> 00:05:27,000
数据上的话

163
00:05:27,000 --> 00:05:30,000
你绝对别弄丢

164
00:05:30,000 --> 00:05:36,000
操作系统本身基本上是非常耐操的

165
00:05:36,000 --> 00:05:38,000
哪怕你删掉所有的 DLL

166
00:05:38,000 --> 00:05:42,000
且不论你现在你是否能够安全的删除一堆 DLL

167
00:05:42,000 --> 00:05:43,000
而不被电脑发现

168
00:05:43,000 --> 00:05:46,000
或者被电脑补丢回来

169
00:05:46,000 --> 00:05:47,000
即便你删掉了

170
00:05:47,000 --> 00:05:48,000
电脑也是永远可以恢复的

171
00:05:48,000 --> 00:05:50,000
只要你不拆机箱

172
00:05:50,000 --> 00:05:53,000
OK 接下来念下一封堵着来信

173
00:05:53,000 --> 00:05:56,000
一位叫做陶器鸿的朋友说

174
00:05:56,000 --> 00:05:57,000
第十七期提到

175
00:05:57,000 --> 00:06:00,000
飞机重启的时候要是听到了

176
00:06:00,000 --> 00:06:02,000
提示音是

177
00:06:02,000 --> 00:06:04,000
小霸王骑得不穷啊

178
00:06:04,000 --> 00:06:05,000
那才是整个人都不好

179
00:06:09,000 --> 00:06:12,000
来自马来西亚的听众李先生

180
00:06:12,000 --> 00:06:14,000
写了一封堵着来信说

181
00:06:14,000 --> 00:06:17,000
您们说了在 Windows 平台上

182
00:06:17,000 --> 00:06:19,000
现在可以开发 Objective-C 的事情

183
00:06:19,000 --> 00:06:22,000
虽然我还没有用过微软这款新的开发工具

184
00:06:22,000 --> 00:06:24,000
但是我是这样理解的

185
00:06:24,000 --> 00:06:27,000
微软的 Visual Studio 是主要让您编译

186
00:06:27,000 --> 00:06:30,000
Objective-C 的源代码

187
00:06:30,000 --> 00:06:34,000
但并不会生成 iOS OS X 平台上的 Binary Code

188
00:06:34,000 --> 00:06:38,000
而是生成 Windows 平台的 Universal Binary Code

189
00:06:38,000 --> 00:06:40,000
所以并不存在你们所说的

190
00:06:40,000 --> 00:06:45,000
如何在 Windows 上提交 iOS App 到 App Store 的问题

191
00:06:45,000 --> 00:06:49,000
因为微软并没有想要以 Visual Studio 取代 Xcode 的想法

192
00:06:49,000 --> 00:06:51,000
括号 差个话题

193
00:06:51,000 --> 00:06:53,000
无套 HashRail 有提到说

194
00:06:53,000 --> 00:06:55,000
Xcode 的 Alternative 查核工具

195
00:06:55,000 --> 00:06:57,000
那应该是 JetBrain 的 AppCode

196
00:06:57,000 --> 00:07:02,000
不过这款工具是用你们讨厌的 Java 所开发的

197
00:07:02,000 --> 00:07:04,000
笑脸 括号完毕

198
00:07:04,000 --> 00:07:09,000
这差一句就是后来我也想起来的 JetBrain 的 AppCode

199
00:07:09,000 --> 00:07:12,000
对 JetBrain 的 AppCode 是用 Java 开发的

200
00:07:12,000 --> 00:07:18,000
不过这并不妨碍它是一款优秀的 IDE

201
00:07:18,000 --> 00:07:19,000
Java 是可以做出好东西的

202
00:07:19,000 --> 00:07:21,000
这个我从来没有否认过

203
00:07:21,000 --> 00:07:25,000
但是只是你用 Java 做东西的过程比较蛋疼

204
00:07:25,000 --> 00:07:27,000
取决于你是比较注重结果

205
00:07:27,000 --> 00:07:29,000
还是比较注重过程

206
00:07:29,000 --> 00:07:32,000
我觉得过程还是挺重要的

207
00:07:32,000 --> 00:07:36,000
回到李先生的来信

208
00:07:36,000 --> 00:07:39,000
他接着说微软主要想要

209
00:07:39,000 --> 00:07:41,000
借此新版的 Visual Studio 来让

210
00:07:41,000 --> 00:07:44,000
许多只为 Apple 开发软件的开发者

211
00:07:44,000 --> 00:07:48,000
提供一个快速从 iOS 移植到 Windows 的工具

212
00:07:48,000 --> 00:07:52,000
我认为这是一个比较聪明的手段来拉拢 iOS 和 Android 的开发者

213
00:07:52,000 --> 00:07:56,000
Apple 早期在推出 OS X 的时候也用过这一招

214
00:07:56,000 --> 00:07:57,000
他们当时使用 Rosetto

215
00:07:57,000 --> 00:08:01,000
来这位朋友这边可能写错了

216
00:08:01,000 --> 00:08:03,000
我记得那个东西叫做 Rosetta

217
00:08:03,000 --> 00:08:05,000
就是 Rosetta 石碑的那个词

218
00:08:05,000 --> 00:08:11,000
来帮助开发者过渡从 OS 9 过渡到 OS 10

219
00:08:11,000 --> 00:08:14,000
同时也在 Xcode 里面提供了多元的编译

220
00:08:14,000 --> 00:08:16,000
比如 Object C

221
00:08:16,000 --> 00:08:18,000
C 和 C++

222
00:08:18,000 --> 00:08:24,000
来以这种方式让 Adobe 或者微软这些用 C 或者 C++的

223
00:08:24,000 --> 00:08:27,000
开发软件的公司也可以顺利的将 Photoshop 的软件

224
00:08:27,000 --> 00:08:30,000
上传到 Office 等旗舰级别的软件

225
00:08:30,000 --> 00:08:33,000
顺利移植到 OS 10

226
00:08:33,000 --> 00:08:36,000
如果您有兴趣知道详情

227
00:08:36,000 --> 00:08:40,000
以下的视频是 ViroStudio Compiler Team 在 Build 大会上的展示

228
00:08:40,000 --> 00:08:42,000
请从 27 分 20 秒开始看

229
00:08:42,000 --> 00:08:45,000
然后给那个 Channel 9 的

230
00:08:45,000 --> 00:08:46,000
Link

231
00:08:46,000 --> 00:08:48,000
这个 Link 我们会贴在 show notes 里面

232
00:08:48,000 --> 00:08:50,000
我会贴在 show notes 里面

233
00:08:50,000 --> 00:08:52,000
我怎么听不了说我们呢

234
00:08:52,000 --> 00:08:55,000
哎呀好孤单啊

235
00:08:55,000 --> 00:08:57,000
这里减数视频里的一些重点

236
00:08:57,000 --> 00:09:01,000
编辑器采用 C 浪

237
00:09:01,000 --> 00:09:06,000
也就是 C++ Object C 的编辑器的 frontend

238
00:09:06,000 --> 00:09:07,000
和 C 2

239
00:09:07,000 --> 00:09:11,000
也就是微软编辑器的 backend

240
00:09:11,000 --> 00:09:14,000
在 ViroStudio 里面可以使用

241
00:09:14,000 --> 00:09:16,000
Object C

242
00:09:16,000 --> 00:09:19,000
直接调用 Windows API

243
00:09:19,000 --> 00:09:24,000
然后编译后的代码并不是在 Emulator 上运行的

244
00:09:24,000 --> 00:09:27,000
而是 Windows Universal 的原生代码

245
00:09:27,000 --> 00:09:30,000
微软实现了 iOS 上的一部分 API

246
00:09:30,000 --> 00:09:33,000
他们称之为 subset of iOS API

247
00:09:33,000 --> 00:09:38,000
计划实现的 API 包括 OpenGL OpenAL Sensor

248
00:09:38,000 --> 00:09:40,000
UI Kit Core Animation 等等

249
00:09:40,000 --> 00:09:43,000
最后视频里面有个小花絮

250
00:09:43,000 --> 00:09:49,000
当台上的微软成品经理问台下有多少人在为 Apple 开发产品的时候

251
00:09:49,000 --> 00:09:52,000
台下的有一半人举手

252
00:09:52,000 --> 00:09:55,000
好非常感谢这位李先生的来信啊

253
00:09:55,000 --> 00:09:57,000
干货相当多

254
00:09:57,000 --> 00:10:01,000
他提到了这个 Apple 早期在推出 OS X 的时候

255
00:10:01,000 --> 00:10:05,000
使用 Rosetta 来帮助开发者从 OS 9 过渡到 OS X

256
00:10:05,000 --> 00:10:11,000
我记得那个时候给 Apple 开发程序是要用

257
00:10:11,000 --> 00:10:13,000
除了 Scode 还有一个东西叫什么

258
00:10:13,000 --> 00:10:15,000
Cold Warrior

259
00:10:15,000 --> 00:10:18,000
好像是 Boland 公司出的

260
00:10:18,000 --> 00:10:20,000
我好像又信口开回来了

261
00:10:20,000 --> 00:10:22,000
就是没有做调查就是这样

262
00:10:22,000 --> 00:10:26,000
如果 Cold Warrior 不是 Boland 做的话

263
00:10:26,000 --> 00:10:27,000
那是谁做的

264
00:10:27,000 --> 00:10:29,000
这不重要

265
00:10:29,000 --> 00:10:35,000
总之那个时候为 OS 9 开发程序是要用到 C

266
00:10:35,000 --> 00:10:37,000
那时候还没有 Rosetta C

267
00:10:37,000 --> 00:10:39,000
天哪那是一个多么洪荒的时代

268
00:10:39,000 --> 00:10:45,000
不过那个时候好像也是可以用 Java 为 OS 9 开发程序的吧

269
00:10:45,000 --> 00:10:47,000
我没有记错了

270
00:10:47,000 --> 00:10:49,000
我还是比较年轻的没有经历过那个时代

271
00:10:49,000 --> 00:10:52,000
如果我们听众里面有经历过那个时代的话

272
00:10:52,000 --> 00:10:55,000
也就是怎样的 OS 9 或者是 OS

273
00:10:55,000 --> 00:10:57,000
乃至 OS 8

274
00:10:57,000 --> 00:11:04,000
开发程序的听众的话也欢迎你来信提供一下这个经验

275
00:11:04,000 --> 00:11:09,000
就那个时代的苹果电脑是怎样开发程序的

276
00:11:09,000 --> 00:11:16,000
因为虽然目前我们都是已经皈依苹果教的铁杆果粉

277
00:11:16,000 --> 00:11:23,000
但是早期我们开发程序的经历就真的只有 Windows 乃至 Linux

278
00:11:23,000 --> 00:11:25,000
好像我跟 Rio 都没有做过 OS 9 时代的经历

279
00:11:25,000 --> 00:11:27,000
好像我跟 Rio 都没有做过 OS 9 时代的经历

280
00:11:27,000 --> 00:11:31,000
至少是给图形界面编程的经历

281
00:11:31,000 --> 00:11:34,000
对欢迎各位提供宝贵经验

282
00:11:34,000 --> 00:11:37,000
然后他提到说

283
00:11:37,000 --> 00:11:42,000
在 Visual Studio 里面可以直接以 OFGC 调用 Windows API

284
00:11:42,000 --> 00:11:43,000
这个听起来非常的

285
00:11:43,000 --> 00:11:45,000
龙太奇

286
00:11:45,000 --> 00:11:45,000
就是

287
00:11:45,000 --> 00:11:52,000
所以言下之意就是我可以用 OFGC 在 Windows 上面写 Windows 程序了

288
00:11:52,000 --> 00:11:54,000
嗯

289
00:11:54,000 --> 00:11:55,000
有意思

290
00:11:55,000 --> 00:11:57,000
什么想到今天呢

291
00:11:57,000 --> 00:12:05,000
接下来是一位叫做 YPolyDiary 的朋友给我们寄来的听众来信

292
00:12:05,000 --> 00:12:07,000
他说 Rio 吴涛你们好

293
00:12:07,000 --> 00:12:10,000
还是给两位发一个邮件吧

294
00:12:10,000 --> 00:12:11,000
之前总是在微博留言

295
00:12:11,000 --> 00:12:16,000
担心写信会写的太长浪费两位的时间

296
00:12:16,000 --> 00:12:19,000
关于 VR 的问题我就不多说了

297
00:12:19,000 --> 00:12:21,000
两位只是偶尔谈到

298
00:12:21,000 --> 00:12:24,000
并没有把它当做一个正式的题目来讲

299
00:12:24,000 --> 00:12:26,000
而我也是仅仅怀有热情

300
00:12:26,000 --> 00:12:27,000
并不是相当于是一个正式的题目来讲

301
00:12:27,000 --> 00:12:29,000
我还是想要提供一些关于这个计划的参考

302
00:12:29,000 --> 00:12:32,000
所以我今天反馈是关于很早的一期

303
00:12:32,000 --> 00:12:35,000
关于机械键盘的

304
00:12:35,000 --> 00:12:38,000
那是我们的第二期吧

305
00:12:38,000 --> 00:12:40,000
好像迄今也是

306
00:12:40,000 --> 00:12:42,000
人气最高的一期

307
00:12:42,000 --> 00:12:46,000
当然我相信沐瑶和肖姬姐的那两期早晚会超过这一期

308
00:12:46,000 --> 00:12:46,000
不过

309
00:12:46,000 --> 00:12:48,000
目前来看

310
00:12:48,000 --> 00:12:52,000
键盘这一期的下达量是非常高

311
00:12:52,000 --> 00:12:56,000
我是从那一期开始才知道机械键盘是怎么回事

312
00:12:56,000 --> 00:12:58,000
然后就多了解了一些

313
00:12:58,000 --> 00:13:01,000
但是有一个很大的遗憾就是

314
00:13:01,000 --> 00:13:05,000
没有人谈到机械键盘压力克数的问题

315
00:13:05,000 --> 00:13:07,000
而我觉得这是一个很大的问题

316
00:13:07,000 --> 00:13:08,000
我的意思是

317
00:13:08,000 --> 00:13:15,000
没有把机械键盘的压力曲线和薄膜键盘的压力曲线进行计算比较

318
00:13:15,000 --> 00:13:18,000
这个问题重要吗?我觉得很重要,请看后面

319
00:13:18,000 --> 00:13:21,000
我这里就不画图了,简单的说一下就是

320
00:13:21,000 --> 00:13:24,000
机械键盘的弹力结构是弹簧

321
00:13:24,000 --> 00:13:26,000
暂时没有见到其他结构

322
00:13:26,000 --> 00:13:29,000
单方的压力曲线是从小到大

323
00:13:29,000 --> 00:13:32,000
而且压力曲线基本上是平直的

324
00:13:32,000 --> 00:13:33,000
这就导致了一个问题

325
00:13:33,000 --> 00:13:36,000
就是按压的过程中要不断的施加压力

326
00:13:36,000 --> 00:13:40,000
而薄膜键盘的弹力结构是橡胶板

327
00:13:40,000 --> 00:13:42,000
这种结构初始压力比较大

328
00:13:42,000 --> 00:13:46,000
但是一旦突破之后就很轻松了

329
00:13:46,000 --> 00:13:48,000
实际表现出来的结果就是

330
00:13:48,000 --> 00:13:52,000
机械键盘要保持按压状态需要一直用力按住

331
00:13:52,000 --> 00:13:55,000
这里先不谈各种轴高差异影响

332
00:13:55,000 --> 00:13:56,000
而薄膜键盘一旦按压了之后

333
00:13:56,000 --> 00:14:00,000
就很容易保持按压的状态不需要很大的力

334
00:14:00,000 --> 00:14:03,000
还有就是每次按压所需要付出的力

335
00:14:03,000 --> 00:14:05,000
机械键盘也要比薄膜键盘大

336
00:14:05,000 --> 00:14:09,000
关于力的多少可以通过计算压力曲线获得

337
00:14:09,000 --> 00:14:11,000
我没有专业的工具没法测量计算

338
00:14:11,000 --> 00:14:14,000
但是参考对弓箭势能的计算方式

339
00:14:14,000 --> 00:14:18,000
可以知道压力曲线越平直收集的能量就越大

340
00:14:18,000 --> 00:14:23,000
其实我能想到这个问题是因为我的弓箭感兴趣

341
00:14:23,000 --> 00:14:24,000
之前看过一些研究资料

342
00:14:24,000 --> 00:14:26,000
比如反曲弓为什么效能更高

343
00:14:26,000 --> 00:14:26,000
但是我没有看过一些研究资料

344
00:14:26,000 --> 00:14:29,000
当然为了验证我的猜想

345
00:14:29,000 --> 00:14:31,000
我专门订了一个机械键盘试用一下

346
00:14:31,000 --> 00:14:34,000
我只是为了体验一下就退货有点不道德

347
00:14:34,000 --> 00:14:36,000
我试用的是茶肘

348
00:14:36,000 --> 00:14:38,000
因为听你们说茶肘比较轻

349
00:14:38,000 --> 00:14:40,000
体验的结果就是

350
00:14:40,000 --> 00:14:46,000
在 Counter Strike 这种需要长时间按住几个键的游戏里面

351
00:14:46,000 --> 00:14:47,000
非常的累

352
00:14:47,000 --> 00:14:51,000
打字的话也感觉要比我用的薄膜键盘要累一点

353
00:14:51,000 --> 00:14:53,000
机械键盘的初始压力很小

354
00:14:53,000 --> 00:14:55,000
给人一个很轻的错觉

355
00:14:55,000 --> 00:14:56,000
但是实际上通过几个键盘

356
00:14:56,000 --> 00:14:57,000
前面的计算就知道

357
00:14:57,000 --> 00:15:00,000
每次按压需要的力实际上很大

358
00:15:00,000 --> 00:15:02,000
这也许从理论上说明了

359
00:15:02,000 --> 00:15:04,000
机械键盘不适合长时间操作

360
00:15:04,000 --> 00:15:06,000
当然

361
00:15:06,000 --> 00:15:09,000
我只是想说明压力曲线这一个问题

362
00:15:09,000 --> 00:15:11,000
不涉及对机械键盘优劣的评论

363
00:15:11,000 --> 00:15:12,000
好吧

364
00:15:12,000 --> 00:15:16,000
其实有点担心让喜欢机械键盘的两位大神反感

365
00:15:16,000 --> 00:15:17,000
另外

366
00:15:17,000 --> 00:15:20,000
我个人因为身体原因对轻动比较敏感

367
00:15:20,000 --> 00:15:21,000
所以我的手

368
00:15:21,000 --> 00:15:23,000
所以我的感受可能不代表大多数人

369
00:15:23,000 --> 00:15:25,000
我一直用的是

370
00:15:25,000 --> 00:15:26,000
鸣机海背键盘

371
00:15:26,000 --> 00:15:26,000
是一种

372
00:15:26,000 --> 00:15:27,000
是薄薄键盘

373
00:15:27,000 --> 00:15:31,000
但是支撑组件是笔记本的 X 型结构

374
00:15:31,000 --> 00:15:33,000
手感介于笔记本和普通电脑之间

375
00:15:33,000 --> 00:15:35,000
这是我用的第二个键盘

376
00:15:35,000 --> 00:15:36,000
不好意思

377
00:15:37,000 --> 00:15:39,000
这一期又写长了

378
00:15:39,000 --> 00:15:42,000
好不容易找到一个自己能谈的话题

379
00:15:42,000 --> 00:15:42,000
OK

380
00:15:42,000 --> 00:15:45,000
这位听众的来信就已经完了

381
00:15:45,000 --> 00:15:48,000
怎么说呢

382
00:15:48,000 --> 00:15:51,000
就是首先前面他说

383
00:15:51,000 --> 00:15:55,000
机械键盘压力刻数的问题

384
00:15:56,000 --> 00:16:00,000
他认为机械键盘的弹力结构是弹簧

385
00:16:00,000 --> 00:16:04,000
而弹簧的压力曲线是线性的

386
00:16:04,000 --> 00:16:08,000
按压过程中需要不断的施加压力等等

387
00:16:08,000 --> 00:16:10,000
怎么说呢

388
00:16:10,000 --> 00:16:13,000
压力曲线每一个轴

389
00:16:13,000 --> 00:16:16,000
如果你用 cherry 的轴来判断的话

390
00:16:16,000 --> 00:16:17,000
每个轴其实不一样的

391
00:16:17,000 --> 00:16:21,000
有些轴是的确是线性的

392
00:16:21,000 --> 00:16:23,000
但是另外一些轴是你按到一半的时候

393
00:16:23,000 --> 00:16:24,000
它会有一个出发点

394
00:16:24,000 --> 00:16:25,000
你只要按到这个出发点的时候

395
00:16:25,000 --> 00:16:26,000
你会看到这个轴的出发点

396
00:16:26,000 --> 00:16:29,000
之后就可以松开了

397
00:16:29,000 --> 00:16:32,000
这位朋友提到的一个用用场景

398
00:16:32,000 --> 00:16:34,000
就是 counter strike

399
00:16:34,000 --> 00:16:37,000
其实我个人觉得打 counter strike 的话

400
00:16:37,000 --> 00:16:39,000
还是薄膜键盘比较好

401
00:16:39,000 --> 00:16:41,000
原因倒不是薄膜键盘显示比较好

402
00:16:41,000 --> 00:16:43,000
而是因为怎么说呢

403
00:16:43,000 --> 00:16:46,000
薄膜键盘比较便宜

404
00:16:46,000 --> 00:16:48,000
打 counter strike 是非常

405
00:16:48,000 --> 00:16:50,000
对键盘非常凌虐的一种方式

406
00:16:50,000 --> 00:16:55,000
我个人还是会只会用机械键盘打字

407
00:16:55,000 --> 00:16:56,000
我也不是

408
00:16:56,000 --> 00:16:59,000
反正现在我大部分时候打这个

409
00:16:59,000 --> 00:17:01,000
比如说暴雪的风暴英雄

410
00:17:01,000 --> 00:17:04,000
或者是 war thunder

411
00:17:04,000 --> 00:17:07,000
就是一个二战的坦克仿真游戏的时候

412
00:17:07,000 --> 00:17:10,000
基本上都是在用笔记本的薄膜键盘在打

413
00:17:10,000 --> 00:17:16,000
手感这个东西是非常主观的一件事情

414
00:17:16,000 --> 00:17:22,000
其实如果你单纯的从手感上来说的话

415
00:17:22,000 --> 00:17:24,000
机械键盘里面很多东西都是选选

416
00:17:24,000 --> 00:17:25,000
但是

417
00:17:25,000 --> 00:17:26,000
嗯

418
00:17:26,000 --> 00:17:27,000
打字比较累

419
00:17:27,000 --> 00:17:29,000
这个可能是可能的确是这样

420
00:17:29,000 --> 00:17:31,000
有时候我现在也会觉得

421
00:17:31,000 --> 00:17:34,000
用机械键盘打字会稍微累一点

422
00:17:34,000 --> 00:17:35,000
怎么说呢

423
00:17:35,000 --> 00:17:38,000
就是打字累的这么一点点

424
00:17:38,000 --> 00:17:42,000
可能跟你每天多走几步的能量消耗都差不多

425
00:17:42,000 --> 00:17:44,000
基本上可以忽略不计的

426
00:17:44,000 --> 00:17:46,000
各位想靠打字减肥的朋友们

427
00:17:46,000 --> 00:17:48,000
就可以醒醒了

428
00:17:48,000 --> 00:17:51,000
最后一封读者来信

429
00:17:51,000 --> 00:17:55,000
一位来自叫做肖志博

430
00:17:55,000 --> 00:17:56,000
我不知道念对了没有

431
00:17:56,000 --> 00:17:58,000
的博士先生

432
00:17:58,000 --> 00:18:01,000
对他的 email 里面就是 doctor 头衔

433
00:18:01,000 --> 00:18:02,000
这个跟德国很像

434
00:18:02,000 --> 00:18:05,000
德国人都喜欢把自己的 doctor 头衔写出来

435
00:18:05,000 --> 00:18:06,000
嗨

436
00:18:06,000 --> 00:18:07,000
两位主播好

437
00:18:07,000 --> 00:18:09,000
听了第 15 期的 Current Panic

438
00:18:09,000 --> 00:18:13,000
听众来信中有人讨论的 data science

439
00:18:13,000 --> 00:18:14,000
我又坐不住了

440
00:18:14,000 --> 00:18:16,000
之前我买了本书的 data science handbook

441
00:18:16,000 --> 00:18:19,000
是 Cura 的 data scientist

442
00:18:19,000 --> 00:18:20,000
William Chen

443
00:18:20,000 --> 00:18:23,000
联合一众 data scientist

444
00:18:23,000 --> 00:18:25,000
做的回馈大众的一件大好事

445
00:18:25,000 --> 00:18:27,000
我觉得大家都可以买来看一下

446
00:18:27,000 --> 00:18:29,000
虽然现在还没有看完

447
00:18:29,000 --> 00:18:30,000
不过写的真的挺好的

448
00:18:30,000 --> 00:18:33,000
对于想要入行 data science

449
00:18:33,000 --> 00:18:35,000
以及已经在这个行业中的同学

450
00:18:35,000 --> 00:18:36,000
都会有所帮助

451
00:18:36,000 --> 00:18:39,000
来信中的那位同学说

452
00:18:39,000 --> 00:18:43,000
现在 Azure 和 Amazon 这样的大公司

453
00:18:43,000 --> 00:18:46,000
把机器学习算法当成服务推出来了

454
00:18:46,000 --> 00:18:49,000
可以让大家不用编程就能用起来

455
00:18:49,000 --> 00:18:50,000
这的确是好事

456
00:18:50,000 --> 00:18:53,000
不过说到自然语言处理

457
00:18:53,000 --> 00:18:55,000
其实还是有很多很难的事情

458
00:18:55,000 --> 00:18:56,000
要做的

459
00:18:56,000 --> 00:18:59,000
而其实这些很难的工作

460
00:18:59,000 --> 00:19:01,000
都是人可以轻而易举的做到了

461
00:19:01,000 --> 00:19:04,000
比如说从一个句子里面

462
00:19:04,000 --> 00:19:06,000
准确的时约出日期和时间

463
00:19:06,000 --> 00:19:08,000
这个听起来非常简单

464
00:19:08,000 --> 00:19:12,000
现有的 Stanford NLP

465
00:19:12,000 --> 00:19:17,000
也就是斯坦福的自然语言处理技术

466
00:19:17,000 --> 00:19:20,000
用基于 conditional random field 的

467
00:19:20,000 --> 00:19:22,000
实体命名算法也可以用

468
00:19:22,000 --> 00:19:24,000
但是达到非常精确的效果

469
00:19:24,000 --> 00:19:25,000
还是有很长的时间的

470
00:19:25,000 --> 00:19:26,000
很长的路要走

471
00:19:26,000 --> 00:19:27,000
再说另一个

472
00:19:27,000 --> 00:19:32,000
从数据集中让算法自动识别出变量的值

473
00:19:32,000 --> 00:19:35,000
是连续型的还是离散型的都很难

474
00:19:35,000 --> 00:19:40,000
剑桥大学的 Zobin Gahramani 教授

475
00:19:40,000 --> 00:19:43,000
在 2014 年的 NIPS

476
00:19:43,000 --> 00:19:50,000
这是一个 Neural Information Processing System

477
00:19:50,000 --> 00:19:52,000
它是一个年会应该是

478
00:19:52,000 --> 00:19:52,000
对

479
00:19:52,000 --> 00:19:55,000
跟这个神经信息处理的

480
00:19:55,000 --> 00:19:56,000
处理系统有关

481
00:19:56,000 --> 00:20:03,000
这位教授在 2014 年的 NIPS 会议上面

482
00:20:03,000 --> 00:20:05,000
就这个问题发表了篇论文

483
00:20:05,000 --> 00:20:08,000
然后顺便再推一下另外一个 Podcast

484
00:20:08,000 --> 00:20:09,000
Talking Machine

485
00:20:09,000 --> 00:20:17,000
网址是 htp://www.thetalkingmachines.com

486
00:20:17,000 --> 00:20:19,000
然后其中一个主持人就是

487
00:20:19,000 --> 00:20:24,000
哈佛大学的 Ray M. Proscott Adams 教授

488
00:20:24,000 --> 00:20:25,000
他利用了这篇论文来说

489
00:20:25,000 --> 00:20:25,000
他利用了这篇论文来说

490
00:20:25,000 --> 00:20:28,000
他的关系几乎在每一期都请来了

491
00:20:28,000 --> 00:20:30,000
一听名字就让我心跳加速的嘉宾

492
00:20:30,000 --> 00:20:35,000
不过 Adams 教授在节目里面的一个保留项目

493
00:20:35,000 --> 00:20:38,000
就是用人类可以听懂的非常简单的语言

494
00:20:38,000 --> 00:20:40,000
解释非常复杂的算法

495
00:20:40,000 --> 00:20:42,000
比如推荐系统里面的

496
00:20:42,000 --> 00:20:45,000
Collaborative Filtering

497
00:20:45,000 --> 00:20:47,000
怎么翻译

498
00:20:47,000 --> 00:20:48,000
协同过滤

499
00:20:48,000 --> 00:20:53,000
再比如非参数贝叶斯推断中的

500
00:20:53,000 --> 00:20:54,000
非常难的

501
00:20:54,000 --> 00:20:55,000
Chinese Restoration

502
00:20:55,000 --> 00:20:59,000
中餐馆过程

503
00:20:59,000 --> 00:21:02,000
我查了一下中餐馆过程是

504
00:21:02,000 --> 00:21:05,000
模拟一个有无限张圆桌

505
00:21:05,000 --> 00:21:08,000
每张圆桌能做无限个人的中餐馆里面

506
00:21:08,000 --> 00:21:09,000
做客人的随机过程

507
00:21:09,000 --> 00:21:11,000
为什么叫这个名字

508
00:21:11,000 --> 00:21:13,000
大概是在洋人家里面

509
00:21:13,000 --> 00:21:16,000
只有中餐馆才会有圆桌吧

510
00:21:16,000 --> 00:21:18,000
以上是这位听众所推荐的

511
00:21:18,000 --> 00:21:21,000
应该是关于自然语言处理的一个 podcast

512
00:21:21,000 --> 00:21:24,000
有兴趣的听众们不妨去听听

513
00:21:24,000 --> 00:21:25,000
最后我会把这个视频给大家看完

514
00:21:25,000 --> 00:21:25,000
最后他说

515
00:21:25,000 --> 00:21:27,000
PS 虽然吴涛说了

516
00:21:27,000 --> 00:21:28,000
不让再推荐嘉宾了

517
00:21:28,000 --> 00:21:28,000
但是

518
00:21:28,000 --> 00:21:30,000
Please Please

519
00:21:30,000 --> 00:21:31,000
能试着请一下

520
00:21:31,000 --> 00:21:32,000
Kura 的 Villiam Chen 吗

521
00:21:32,000 --> 00:21:34,000
我想如果是要做一期

522
00:21:34,000 --> 00:21:35,000
有关 Data Science 的话题

523
00:21:35,000 --> 00:21:39,000
请来这样一个 Data Science 才好吧

524
00:21:39,000 --> 00:21:41,000
我也知道请一个陌生人

525
00:21:41,000 --> 00:21:43,000
陌生人上节目还是挺难的

526
00:21:43,000 --> 00:21:44,000
Anyway

527
00:21:44,000 --> 00:21:47,000
Please keep up the good work

528
00:21:47,000 --> 00:21:49,000
感谢这位听众

529
00:21:49,000 --> 00:21:52,000
对我们的确是想要请一位

530
00:21:52,000 --> 00:21:54,000
或人家是 Data Scientist

531
00:21:54,000 --> 00:21:54,000
来

532
00:21:54,000 --> 00:21:55,000
来

533
00:21:55,000 --> 00:21:58,000
l 聊 Data Science 的话题

534
00:21:58,000 --> 00:21:59,000
不过

535
00:21:59,000 --> 00:22:01,000
目前还没有合适的人选

536
00:22:01,000 --> 00:22:04,000
我去看一下这位 Villiam Chen

537
00:22:04,000 --> 00:22:04,000
是不是

538
00:22:04,000 --> 00:22:09,000
首先是不是一个适合接近的人

539
00:22:09,000 --> 00:22:11,000
感谢这位听众

540
00:22:11,000 --> 00:22:15,000
接下来我想要提到的一些新闻

541
00:22:15,000 --> 00:22:15,000
就是

542
00:22:15,000 --> 00:22:17,000
其实有一条

543
00:22:17,000 --> 00:22:19,000
就是 Google I O

544
00:22:19,000 --> 00:22:23,000
我不知道明天的 IT 功能会怎样聊这个话题

545
00:22:23,000 --> 00:22:24,000
我

546
00:22:24,000 --> 00:22:25,000
希望他们会聊的话题

547
00:22:25,000 --> 00:22:27,000
但是从开发者层面上来说

548
00:22:27,000 --> 00:22:33,000
这一次 Google I O 大会让我印象比较深的

549
00:22:33,000 --> 00:22:36,000
当然我没有完全看这个大会

550
00:22:36,000 --> 00:22:39,000
我只是事后就看了一下 summary

551
00:22:39,000 --> 00:22:40,000
因为要上班

552
00:22:40,000 --> 00:22:44,000
就这次 Google I O 的在我看来的亮点

553
00:22:44,000 --> 00:22:47,000
就是首先是 Android Studio IE

554
00:22:47,000 --> 00:22:49,000
应该是 1.3 版吧

555
00:22:49,000 --> 00:22:51,000
增加了 NDK 的支持

556
00:22:51,000 --> 00:22:53,000
就是 Native Developer Kit

557
00:22:53,000 --> 00:22:54,000
就是 Native Developer Kit

558
00:22:54,000 --> 00:22:56,000
你可以在

559
00:22:56,000 --> 00:23:00,000
它应该是使用了 JetBrains 的 C-Line

560
00:23:00,000 --> 00:23:05,000
来支持用 C++写 Android 的 App

561
00:23:05,000 --> 00:23:08,000
其次就是 Google I O 此次出现了一个

562
00:23:08,000 --> 00:23:13,000
专门为 Internet of Things 所开发的操作系统

563
00:23:13,000 --> 00:23:14,000
叫做 Briddle

564
00:23:14,000 --> 00:23:16,000
名字有点奇怪

565
00:23:16,000 --> 00:23:18,000
Briddle 就是一个

566
00:23:18,000 --> 00:23:19,000
怎么说呢

567
00:23:19,000 --> 00:23:23,000
是一个比较被 stripped down 的 Android 系统

568
00:23:23,000 --> 00:23:24,000
然后你可以把它装在手机上

569
00:23:24,000 --> 00:23:26,000
或者是用在一些智能家电上

570
00:23:26,000 --> 00:23:27,000
甚至都不一定是家电

571
00:23:27,000 --> 00:23:28,000
就是一些电器

572
00:23:28,000 --> 00:23:29,000
比如说电灯啊

573
00:23:29,000 --> 00:23:31,000
电扇啊之类的东西上

574
00:23:31,000 --> 00:23:33,000
烟火冷气啊之类的

575
00:23:33,000 --> 00:23:35,000
你在上面插一个芯片

576
00:23:35,000 --> 00:23:37,000
然后装上这个浪水桶

577
00:23:37,000 --> 00:23:40,000
然后 automatically

578
00:23:40,000 --> 00:23:42,000
这个东西就变成了一个智能家电

579
00:23:42,000 --> 00:23:46,000
你可以用你的 Android 设备去操纵它

580
00:23:46,000 --> 00:23:52,000
然后配套推出的也就是这个

581
00:23:52,000 --> 00:23:57,000
这种小芯片互相通信的一种

582
00:23:57,000 --> 00:23:58,000
怎么说呢

583
00:23:58,000 --> 00:24:00,000
communication layer

584
00:24:00,000 --> 00:24:02,000
应该叫做 communication layer

585
00:24:02,000 --> 00:24:03,000
就是一个通信层

586
00:24:03,000 --> 00:24:05,000
它的名字叫做 weave

587
00:24:05,000 --> 00:24:09,000
也就是 weave

588
00:24:09,000 --> 00:24:13,000
这让我想起那个 Google wave

589
00:24:13,000 --> 00:24:18,000
就是那个已经正式开死服中

590
00:24:18,000 --> 00:24:20,000
理念超前

591
00:24:20,000 --> 00:24:21,000
hype 无比

592
00:24:21,000 --> 00:24:22,000
但是最后

593
00:24:22,000 --> 00:24:23,000
对

594
00:24:23,000 --> 00:24:26,000
就这么默默的消失掉了 Google wave

595
00:24:26,000 --> 00:24:30,000
其实我希望 Bredo 和 Wave

596
00:24:30,000 --> 00:24:32,000
可以早点推广开来

597
00:24:32,000 --> 00:24:34,000
因为这样的话可能

598
00:24:34,000 --> 00:24:38,000
智能家电会比较提前进入我们生活

599
00:24:38,000 --> 00:24:40,000
对我其实已经妄想过

600
00:24:40,000 --> 00:24:45,000
智能家电无处不在的场景了

601
00:24:45,000 --> 00:24:47,000
未来怎么还不到

602
00:24:47,000 --> 00:24:50,000
有一部电影叫做回到未来

603
00:24:50,000 --> 00:24:51,000
Back to future

604
00:24:51,000 --> 00:24:56,000
应该是拍摄于 85 年及之后的三部

605
00:24:56,000 --> 00:24:59,000
关于时空旅行的电影

606
00:24:59,000 --> 00:25:09,000
其中主角在 1985 年所前近 30 年去到了 2015 年

607
00:25:09,000 --> 00:25:12,000
也就是今年 incidentally

608
00:25:12,000 --> 00:25:16,000
10 月 15 号吧

609
00:25:16,000 --> 00:25:17,000
还是 20 号

610
00:25:17,000 --> 00:25:18,000
没记错的话

611
00:25:18,000 --> 00:25:20,000
那天离我们

612
00:25:20,000 --> 00:25:25,000
离我录节目的今天大概也只有 150 天左右

613
00:25:25,000 --> 00:25:29,000
然后电影里面的 2015 年

614
00:25:29,000 --> 00:25:34,000
在有些地方是不如现在的 2015 年

615
00:25:34,000 --> 00:25:38,000
但是在很多其他地方是远远超越今天的科技水准的

616
00:25:38,000 --> 00:25:41,000
就是智能家电都不说了

617
00:25:41,000 --> 00:25:45,000
比如说它里面有个叫做 Mr.Fusion 的能源装置

618
00:25:45,000 --> 00:25:47,000
可以装在车上

619
00:25:47,000 --> 00:25:49,000
然后你只要往里面扔一些垃圾

620
00:25:49,000 --> 00:25:52,000
它就可以通过巨变来产生非常多的能量

621
00:25:52,000 --> 00:25:57,000
这能量足以支持让一辆车产生时空旅行

622
00:25:57,000 --> 00:25:59,000
然后还有一些非常神奇的其他的东西

623
00:25:59,000 --> 00:26:03,000
比如说漂浮滑板

624
00:26:03,000 --> 00:26:08,000
对漂浮滑板这个东西在我们的 2015 年还是没有被实现出来

625
00:26:08,000 --> 00:26:11,000
最重要的一点是里面的车都是能飞的

626
00:26:11,000 --> 00:26:13,000
我觉得前一阵子在知乎上有个问题

627
00:26:13,000 --> 00:26:18,000
就是为什么说我们在 40 年前想要的是飞车

628
00:26:18,000 --> 00:26:21,000
而现在我们得到的只是 140 个字符

629
00:26:21,000 --> 00:26:24,000
当然说这个话的人是

630
00:26:24,000 --> 00:26:28,000
没记错的话是 Tesla 的投资人之一吧

631
00:26:28,000 --> 00:26:30,000
不是 Elon Musk 他自己

632
00:26:30,000 --> 00:26:34,000
但是这个人也是一个科技界的推手人士了

633
00:26:34,000 --> 00:26:37,000
他说这些话的原因其实本质上是励志的

634
00:26:37,000 --> 00:26:40,000
但是当然有些人把它当成一句吐槽来看

635
00:26:40,000 --> 00:26:47,000
重点就是我们对于未来的想象很有可能是偏差非常大的

636
00:26:48,000 --> 00:26:52,000
但是这并不应该妨碍我们去想象感

637
00:26:52,000 --> 00:26:58,000
对我就是希望智能家居可以早一天铺开来应用

638
00:26:58,000 --> 00:27:03,000
让我们今天能够在某种程度上

639
00:27:03,000 --> 00:27:07,000
在比较方便的部分

640
00:27:07,000 --> 00:27:11,000
能够超越那个时候对于未来的想象

641
00:27:11,000 --> 00:27:16,000
关于飞车这个东西

642
00:27:16,000 --> 00:27:21,000
我觉得就是我之前在知乎上看到这个问题的时候

643
00:27:21,000 --> 00:27:22,000
里面有人说

644
00:27:22,000 --> 00:27:25,000
里面有人通过各种例子来论证了

645
00:27:25,000 --> 00:27:28,000
为什么 140 个字符与飞车更重要

646
00:27:28,000 --> 00:27:35,000
说如果你可以更便捷的和离你很远的人通讯

647
00:27:35,000 --> 00:27:38,000
那你就不需要去到那个人身边了

648
00:27:38,000 --> 00:27:41,000
如果你可以开 teleconference 的话

649
00:27:41,000 --> 00:27:44,000
那你就不需要亲自跑到那个地方去了

650
00:27:44,000 --> 00:27:45,000
所以

651
00:27:46,000 --> 00:27:51,000
有 140 个字符的便捷的交流方式其实是要比飞车重要的

652
00:27:51,000 --> 00:27:52,000
我承认它有一定的道理

653
00:27:52,000 --> 00:27:59,000
但是我总觉得如果飞车这个东西真的可以出现的话

654
00:27:59,000 --> 00:28:00,000
或者说一个比较

655
00:28:00,000 --> 00:28:02,000
飞车其实已经出现了

656
00:28:02,000 --> 00:28:05,000
就是现在已经有可以飞起来的汽车

657
00:28:05,000 --> 00:28:08,000
但是最大的问题是这个汽车

658
00:28:08,000 --> 00:28:10,000
首先它需要专门的跑道

659
00:28:10,000 --> 00:28:14,000
第二它飞的时候其实不是非常的灵活

660
00:28:16,000 --> 00:28:18,000
第三就是能耗非常高

661
00:28:18,000 --> 00:28:20,000
但是如果有 mister fusion 出现的话

662
00:28:20,000 --> 00:28:22,000
能耗不是问题

663
00:28:22,000 --> 00:28:24,000
但最大的问题是

664
00:28:24,000 --> 00:28:27,000
我们想要的飞车其实是像 back to the future 里面那样

665
00:28:27,000 --> 00:28:28,000
只需要把四个轮子朝下

666
00:28:28,000 --> 00:28:31,000
然后就可以直接悬浮起来的飞车

667
00:28:31,000 --> 00:28:33,000
或者像什么第五元素里面那种飞车

668
00:28:33,000 --> 00:28:35,000
那才是真正实用的飞车对吧

669
00:28:35,000 --> 00:28:38,000
这样的飞车解决了一个什么样的问题呢

670
00:28:38,000 --> 00:28:39,000
就是你不再需要坐飞机了

671
00:28:39,000 --> 00:28:43,000
你不再需要坐越洋飞机了

672
00:28:43,000 --> 00:28:44,000
就是

673
00:28:44,000 --> 00:28:45,000
点对点的直线

674
00:28:45,000 --> 00:28:48,000
交通变得非常的简单

675
00:28:48,000 --> 00:28:50,000
单一模式化

676
00:28:50,000 --> 00:28:52,000
就是比如说在 back to the future 里面

677
00:28:52,000 --> 00:28:58,000
他们里面设想说整个美洲乃至于跨州的这个航路

678
00:28:58,000 --> 00:29:04,000
就有点像高速公路一样是已经预先划好了

679
00:29:04,000 --> 00:29:06,000
比如说如果你想从中国到美国的话

680
00:29:06,000 --> 00:29:08,000
你只需要开上自己的飞车

681
00:29:08,000 --> 00:29:11,000
从自己家的门前出发

682
00:29:11,000 --> 00:29:13,000
然后飞到高速公路上

683
00:29:13,000 --> 00:29:14,000
然后就沿着

684
00:29:14,000 --> 00:29:15,000
我现在的飞车

685
00:29:15,000 --> 00:29:16,000
我相信一定有什么导航技术

686
00:29:16,000 --> 00:29:18,000
就是你只要坐在车里面

687
00:29:18,000 --> 00:29:19,000
然后等

688
00:29:19,000 --> 00:29:23,000
这个车就会把你带到你在美国要去的那个地方的路旁

689
00:29:23,000 --> 00:29:25,000
这是一个非常点对点的服务

690
00:29:25,000 --> 00:29:29,000
就是不像现在我们需要先从家里面坐车到机场

691
00:29:29,000 --> 00:29:30,000
然后拖远行李

692
00:29:30,000 --> 00:29:31,000
然后 check in

693
00:29:31,000 --> 00:29:32,000
然后过安检

694
00:29:32,000 --> 00:29:33,000
然后 blah blah blah

695
00:29:33,000 --> 00:29:36,000
跟几百个不知道是不是恐怖分子的人坐在一起

696
00:29:36,000 --> 00:29:39,000
然后把自己的生命交在机场上

697
00:29:39,000 --> 00:29:40,000
如果有飞车的话

698
00:29:40,000 --> 00:29:41,000
这一切都不需要了

699
00:29:41,000 --> 00:29:44,000
就我们可以单独的

700
00:29:44,000 --> 00:29:48,000
坐在属于自己一样一个一个封闭空间里面

701
00:29:48,000 --> 00:29:50,000
自己想带什么就带什么

702
00:29:50,000 --> 00:29:51,000
想带多少带多少

703
00:29:51,000 --> 00:29:52,000
只要你能

704
00:29:52,000 --> 00:29:55,000
如果有 mr.fusion 的话

705
00:29:55,000 --> 00:29:56,000
能源不是问题

706
00:29:56,000 --> 00:30:00,000
就这样的技术带给我们的自由度

707
00:30:00,000 --> 00:30:05,000
其实是要远远高于飞机或者是现有的任何交通工具

708
00:30:05,000 --> 00:30:09,000
所以我觉得飞车仍旧是一个非常重要值得梦想的事情

709
00:30:09,000 --> 00:30:11,000
不过有生之年应该是看不到了

710
00:30:11,000 --> 00:30:12,000
我觉得

711
00:30:12,000 --> 00:30:13,000
而且

712
00:30:13,000 --> 00:30:16,000
更不用提在 back to the future 里面

713
00:30:16,000 --> 00:30:19,000
主角其实不是主角

714
00:30:19,000 --> 00:30:20,000
就是未来 2015 年

715
00:30:20,000 --> 00:30:22,000
其实根本就没有不需要飞车

716
00:30:22,000 --> 00:30:25,000
而是所谓的飞车改装服务

717
00:30:25,000 --> 00:30:27,000
就是只需要装四个轮子

718
00:30:27,000 --> 00:30:29,000
就可以让自己的车飞起来

719
00:30:29,000 --> 00:30:32,000
就远远不是像现在这样

720
00:30:32,000 --> 00:30:35,000
你需要把整个其实的构造都改了

721
00:30:35,000 --> 00:30:36,000
嗯

722
00:30:36,000 --> 00:30:37,000
OK

723
00:30:37,000 --> 00:30:39,000
在进入主题之前呢

724
00:30:39,000 --> 00:30:40,000
为了填充节目时间

725
00:30:40,000 --> 00:30:42,000
我们先来讨论一下

726
00:30:43,000 --> 00:30:45,000
计算机的编码

727
00:30:45,000 --> 00:30:48,000
这是一个压箱底的话题

728
00:30:48,000 --> 00:30:50,000
对就是为了专门应付今天这种

729
00:30:50,000 --> 00:30:53,000
为了保证节目不断档

730
00:30:53,000 --> 00:30:58,000
但是又有可能有人缺席的情况准备

731
00:30:58,000 --> 00:31:00,000
编码或者说 uncoding

732
00:31:00,000 --> 00:31:03,000
是一个非常常见的时候非常复杂的概念

733
00:31:03,000 --> 00:31:06,000
首先 uncoding 和 coding 是不一样的

734
00:31:06,000 --> 00:31:10,000
就我们口语里面应该会用写代码

735
00:31:10,000 --> 00:31:12,000
来指代写程序这件事情

736
00:31:12,000 --> 00:31:13,000
但是呢

737
00:31:13,000 --> 00:31:18,000
有时候人们也会口误或者说无心的说编码

738
00:31:18,000 --> 00:31:21,000
来用编码这个词来指代写程序

739
00:31:21,000 --> 00:31:23,000
但是像编码在比较

740
00:31:23,000 --> 00:31:27,000
当你比较严格的区分自己的措辞的时候

741
00:31:27,000 --> 00:31:29,000
编码指的是 uncoding

742
00:31:29,000 --> 00:31:32,000
uncoding 是一个非常常见的时候非常复杂的概念

743
00:31:32,000 --> 00:31:36,000
常见是因为每时每刻我们每时每时跟它的接触

744
00:31:36,000 --> 00:31:39,000
尤其是如果要 coding 的话

745
00:31:39,000 --> 00:31:42,000
几乎完全是绕不开 uncoding 的

746
00:31:42,000 --> 00:31:45,000
尤其是如果你不是一个专职的程序员

747
00:31:45,000 --> 00:31:46,000
你可以不懂算法

748
00:31:46,000 --> 00:31:47,000
可以不懂数学结构

749
00:31:47,000 --> 00:31:49,000
你比如说你是一个搞 web 的

750
00:31:49,000 --> 00:31:52,000
你可能 sorry 我有黑 web

751
00:31:52,000 --> 00:31:54,000
你是一个搞 web 前端的

752
00:31:54,000 --> 00:31:57,000
你可能完全不需要去接触算法或者数学结构

753
00:31:57,000 --> 00:31:59,000
你照样可以活得很好

754
00:31:59,000 --> 00:32:03,000
但是 uncoding 这个问题你是没有可能绕开的

755
00:32:03,000 --> 00:32:07,000
如果你像回避算法数学结构一样去回避 uncoding

756
00:32:07,000 --> 00:32:10,000
很有可能会摔得很惨

757
00:32:10,000 --> 00:32:11,000
嗯

758
00:32:11,000 --> 00:32:14,000
而即便是不写程序的人

759
00:32:14,000 --> 00:32:18,000
懂一些 uncoding 也是一个也是一件非常有意义的事情

760
00:32:18,000 --> 00:32:21,000
比如说我记得很久以前

761
00:32:21,000 --> 00:32:23,000
大概是天哪

762
00:32:23,000 --> 00:32:25,000
那个时候我还在读研究室

763
00:32:25,000 --> 00:32:27,000
那时候有一个网站叫做

764
00:32:27,000 --> 00:32:28,000
现在也有这个网站

765
00:32:28,000 --> 00:32:30,000
叫做 dailywtf

766
00:32:30,000 --> 00:32:31,000
dailywtf

767
00:32:31,000 --> 00:32:35,000
当然它的官方名字叫做 dailyworsethanfailure

768
00:32:35,000 --> 00:32:37,000
但是我们都知道 wtf 是什么意思

769
00:32:37,000 --> 00:32:39,000
然后在这个网站上面有这样一则

770
00:32:39,000 --> 00:32:40,000
当时应该是

771
00:32:41,000 --> 00:32:43,000
一堆图片信息

772
00:32:43,000 --> 00:32:44,000
里面的一条

773
00:32:44,000 --> 00:32:47,000
我记得是有人拍了一个包裹单

774
00:32:47,000 --> 00:32:49,000
这个包裹单是贴在一个包裹上面的

775
00:32:49,000 --> 00:32:51,000
然后这个包裹是寄给德国某个地址的

776
00:32:51,000 --> 00:32:57,000
这个地址里面有一个地方被寄件人画成了一个方块

777
00:32:57,000 --> 00:33:02,000
就是比如说有一个德国的地址叫做 gr 方块

778
00:33:02,000 --> 00:33:05,000
然后 blah blah str

779
00:33:05,000 --> 00:33:07,000
然后多少号号

780
00:33:07,000 --> 00:33:08,000
就是原因是什么呢

781
00:33:08,000 --> 00:33:09,000
就是这个人

782
00:33:09,000 --> 00:33:12,000
他显然在显示这个德国的地址的时候

783
00:33:12,000 --> 00:33:16,000
没能正确的把 o 上加两点

784
00:33:16,000 --> 00:33:20,000
就是 oomlout 这个字母显示出来

785
00:33:20,000 --> 00:33:23,000
他的计算机系统就把那个地方显示成了一个方块

786
00:33:23,000 --> 00:33:26,000
然后他就非常忠诚的在那个地方画了一个方块

787
00:33:26,000 --> 00:33:29,000
如果这位寄件人懂一点 encoding 的知识的话

788
00:33:29,000 --> 00:33:33,000
这样的笑话就不会发生了

789
00:33:33,000 --> 00:33:36,000
另外比如说有时候各位在看网页的时候

790
00:33:36,000 --> 00:33:38,000
会发现网页上面有问号或者是

791
00:33:38,000 --> 00:33:41,000
莫名其妙的一些符号

792
00:33:41,000 --> 00:33:43,000
我们会说这个时候有乱码了

793
00:33:43,000 --> 00:33:45,000
那这个时候应该怎么解决呢

794
00:33:45,000 --> 00:33:47,000
知道的人可能会去

795
00:33:47,000 --> 00:33:50,000
我忘了 chrome 是在哪了

796
00:33:50,000 --> 00:33:52,000
chrome 好像是在 tools 里面

797
00:33:52,000 --> 00:33:54,000
对你要去一个地方选

798
00:33:54,000 --> 00:34:01,000
你要说这个网页是用什么样的 encoding 来 encoding 的

799
00:34:01,000 --> 00:34:05,000
这个网页是用什么标准来 encoding 的

800
00:34:05,000 --> 00:34:07,000
你选对了一个标准

801
00:34:07,000 --> 00:34:11,000
然后你就可以看到正确无误的信息

802
00:34:11,000 --> 00:34:18,000
又比如以前我们玩一些很有意思的日本游戏的时候

803
00:34:18,000 --> 00:34:22,000
为什么在简体中文操作许多人跑起来是乱码

804
00:34:22,000 --> 00:34:24,000
对

805
00:34:24,000 --> 00:34:28,000
这一切的原因其实都是因为 encoding

806
00:34:28,000 --> 00:34:31,000
那为什么会有 encoding 的问题呢

807
00:34:31,000 --> 00:34:33,000
答案是因为二进制

808
00:34:33,000 --> 00:34:36,000
也就是所谓计算机是一个二进制的

809
00:34:36,000 --> 00:34:40,000
东西这句话我们多多少少都听过

810
00:34:40,000 --> 00:34:46,000
但是就比如说我们都明白计算机在内部只懂得 0 和 1

811
00:34:46,000 --> 00:34:50,000
具体来说就是芯片上面有一个地方是高电平

812
00:34:50,000 --> 00:34:52,000
它就是 1 低电平就是 0

813
00:34:52,000 --> 00:34:57,000
然后磁盘上面有一个地方比如说它的北磁极朝上就是 1

814
00:34:57,000 --> 00:34:59,000
北磁极朝下就是 0

815
00:34:59,000 --> 00:35:01,000
我不确定这个说法正不正确

816
00:35:01,000 --> 00:35:05,000
是代磁是 1 不代磁是 0 还是北磁极是 1 南磁极是 0

817
00:35:06,000 --> 00:35:08,000
欢迎大家指正

818
00:35:08,000 --> 00:35:13,000
然后比如说光盘上面有坑就是 1 没坑就是 0

819
00:35:13,000 --> 00:35:18,000
然后反过来平时使用电脑的时候

820
00:35:18,000 --> 00:35:22,000
你跟我却明明没有直接在跟 0 和 1 打交道

821
00:35:22,000 --> 00:35:24,000
比如说我们能看到文字

822
00:35:24,000 --> 00:35:26,000
我们能听到声音

823
00:35:26,000 --> 00:35:28,000
比如说各位现在听的 podcast

824
00:35:28,000 --> 00:35:34,000
我们能看到图片以及一些高雅的小电影

825
00:35:34,000 --> 00:35:36,000
这些东西就是我们的计算机的原因

826
00:35:36,000 --> 00:35:38,000
这些都不是 0 和 1 不是吗

827
00:35:38,000 --> 00:35:40,000
就是在我们的观感来说

828
00:35:40,000 --> 00:35:45,000
这些东西都是切切实实的一些模拟信号不是吗

829
00:35:45,000 --> 00:35:48,000
那么具体来讲那些 0 和 1 在哪呢

830
00:35:48,000 --> 00:35:55,000
这个就要扯到比较古早的历史

831
00:35:55,000 --> 00:36:00,000
才能让大家有一个比较清晰的认识

832
00:36:00,000 --> 00:36:04,000
乃至于包括程序本身其实也都是 0 和 1

833
00:36:04,000 --> 00:36:06,000
写过程序的各位都知道

834
00:36:06,000 --> 00:36:09,000
我们写程序的时候并不是直接写下 0 和 1

835
00:36:09,000 --> 00:36:13,000
以下内容部分摘字我在知乎上的一个答案

836
00:36:13,000 --> 00:36:16,000
所以如果各位读过的话基本上就可以跳过了

837
00:36:16,000 --> 00:36:20,000
就可以直接拉到最后来听这个本期的主题

838
00:36:20,000 --> 00:36:23,000
就是程序员怎样泡的女朋友

839
00:36:23,000 --> 00:36:25,000
用泡这个词是不太正确的

840
00:36:25,000 --> 00:36:27,000
首先要抛弃泡这个概念

841
00:36:27,000 --> 00:36:28,000
anyway

842
00:36:28,000 --> 00:36:32,000
在计算机还都是一些庞然大物的实际时代

843
00:36:32,000 --> 00:36:34,000
我们写程序是靠机器的方式来做的

844
00:36:34,000 --> 00:36:36,000
就是用机器语言

845
00:36:36,000 --> 00:36:39,000
虽然名字叫做机器语言

846
00:36:39,000 --> 00:36:41,000
但实际上用到的只有两个数字而已

847
00:36:41,000 --> 00:36:43,000
就是 0 和 1

848
00:36:43,000 --> 00:36:47,000
当然前提是你不去考虑三进制计算机

849
00:36:47,000 --> 00:36:51,000
三进制计算机实际上是一个非常有意思的话题

850
00:36:51,000 --> 00:36:55,000
准确来说是平衡三进制计算机

851
00:36:55,000 --> 00:37:01,000
就是各位应该可以比较容易的想象什么是三进制

852
00:37:01,000 --> 00:37:02,000
就是纯粹的三进制

853
00:37:02,000 --> 00:37:04,000
就是只用 0 1 2 这样的

854
00:37:04,000 --> 00:37:09,000
0 是 0 1 是 1 22 3 是 10

855
00:37:09,000 --> 00:37:12,000
那么什么是平衡三进制呢

856
00:37:12,000 --> 00:37:14,000
平衡三进制是说

857
00:37:14,000 --> 00:37:20,000
用 1 0 和-1 这三个数字

858
00:37:20,000 --> 00:37:22,000
来代表一切其他

859
00:37:22,000 --> 00:37:23,000
来代表一切数字

860
00:37:23,000 --> 00:37:25,000
来组合成为一切数字

861
00:37:25,000 --> 00:37:26,000
也就是说在每一个

862
00:37:26,000 --> 00:37:29,000
比如说在个位上是 0 就是 0

863
00:37:29,000 --> 00:37:31,000
然后在个位上是 1 就是 1

864
00:37:31,000 --> 00:37:34,000
在个位上是-1 就是-1

865
00:37:34,000 --> 00:37:35,000
那么 2 怎么表示呢

866
00:37:35,000 --> 00:37:36,000
很有意思

867
00:37:36,000 --> 00:37:45,000
因为 10 的话在平衡三进制里面是代表 3

868
00:37:45,000 --> 00:37:48,000
所以如果你想要凑出一个 2 来的话

869
00:37:48,000 --> 00:37:53,000
你必须先在个位上面写上一个-1

870
00:37:53,000 --> 00:37:58,000
也就是平衡三进制的 0 是 0 1 是 1

871
00:37:58,000 --> 00:38:01,000
2 则是 1-1

872
00:38:01,000 --> 00:38:02,000
就是平衡三进制里面

873
00:38:02,000 --> 00:38:05,000
通常会把-1 这个数字写成 t

874
00:38:05,000 --> 00:38:08,000
也就是 2 会变成 1 t

875
00:38:08,000 --> 00:38:10,000
写成 t 是因为负号

876
00:38:10,000 --> 00:38:12,000
如果你把负号放在 1 上面的话

877
00:38:12,000 --> 00:38:14,000
它看着它像一个 t

878
00:38:14,000 --> 00:38:18,000
这是一个非常特别

879
00:38:18,000 --> 00:38:20,000
但是对于计算机来说

880
00:38:20,000 --> 00:38:23,000
比较好实现的一种进制方法

881
00:38:23,000 --> 00:38:26,000
就是如果你维持一个中等电位的话

882
00:38:26,000 --> 00:38:27,000
它是 0

883
00:38:27,000 --> 00:38:30,000
一个比较高的电位的话是 1

884
00:38:30,000 --> 00:38:31,000
然后一个比较低的电位的话是 4

885
00:38:31,000 --> 00:38:33,000
一个比较低的电位的话是-1

886
00:38:33,000 --> 00:38:38,000
平衡三进制有一些比较特别的数学特性

887
00:38:38,000 --> 00:38:40,000
比如说在平衡三进制里面

888
00:38:40,000 --> 00:38:43,000
有时候一些数字的表示方法有两个

889
00:38:43,000 --> 00:38:48,000
比如说 1 可以表示为 0.11 无线循环

890
00:38:48,000 --> 00:38:52,000
或者是 1.-1 无线循环

891
00:38:52,000 --> 00:38:57,000
然后有时候也会有一些比较特别的特性

892
00:38:57,000 --> 00:38:58,000
比如说在乘法的时候

893
00:38:58,000 --> 00:38:59,000
有时候你会

894
00:38:59,000 --> 00:39:01,000
明明是两个多位数学特性

895
00:39:01,000 --> 00:39:04,000
最后你得出的结果的位数

896
00:39:04,000 --> 00:39:10,000
反而要比原来你用来乘的两个数字的位数要短

897
00:39:10,000 --> 00:39:16,000
但是三进制计算机最终是没有能乘气候

898
00:39:16,000 --> 00:39:20,000
我相信如果三体人

899
00:39:20,000 --> 00:39:23,000
或者是比较正儿八经的科幻里面

900
00:39:23,000 --> 00:39:26,000
有一部科幻叫做与拉玛相会

901
00:39:26,000 --> 00:39:27,000
如果各位没有看过的话

902
00:39:27,000 --> 00:39:29,000
非常欢迎去看一看

903
00:39:29,000 --> 00:39:30,000
要比三体人

904
00:39:31,000 --> 00:39:34,000
三体不知道高到哪里去了

905
00:39:34,000 --> 00:39:38,000
也许三体人会使用三进制计算机

906
00:39:38,000 --> 00:39:41,000
但是在我们地球上面

907
00:39:41,000 --> 00:39:43,000
目前占主流的

908
00:39:43,000 --> 00:39:46,000
绝对主流的压倒性主流的

909
00:39:46,000 --> 00:39:48,000
是二进制计算机

910
00:39:48,000 --> 00:39:51,000
所以早期的写程序

911
00:39:51,000 --> 00:39:55,000
也就是使用特定的二进制的组合

912
00:39:55,000 --> 00:39:57,000
来给计算机下命令

913
00:39:57,000 --> 00:39:59,000
因为一些特定的数字组合

914
00:39:59,000 --> 00:40:00,000
对于计算机来说

915
00:40:00,000 --> 00:40:02,000
有特定的意义

916
00:40:02,000 --> 00:40:05,000
会让计算机做出一些特定的动作

917
00:40:05,000 --> 00:40:10,000
其实我们甚至不应该叫这些二进制的数字

918
00:40:10,000 --> 00:40:11,000
数字

919
00:40:11,000 --> 00:40:13,000
因为它们其实并不代表任何数量

920
00:40:13,000 --> 00:40:17,000
它们所代表的只是一种模式

921
00:40:17,000 --> 00:40:19,000
这是一个什么概念呢

922
00:40:19,000 --> 00:40:21,000
各位可以想象一台钢琴

923
00:40:21,000 --> 00:40:24,000
假设在钢琴上所有的键都被拉平了

924
00:40:24,000 --> 00:40:28,000
就是它的黑键不是嵌在白键之间

925
00:40:28,000 --> 00:40:29,000
而是就是很简单的道理

926
00:40:30,000 --> 00:40:32,000
除非 ahead 的时间

927
00:40:32,000 --> 00:40:33,000
十三个手段

928
00:40:33,000 --> 00:40:59,000
IP 介绍中心

929
00:40:59,000 --> 00:41:03,000
它只是代表这个按下钢琴的状态

930
00:41:03,000 --> 00:41:05,000
我们在使用 CPU 的时候

931
00:41:05,000 --> 00:41:10,000
情况跟这个钢琴是类似的

932
00:41:10,000 --> 00:41:15,000
就是我们把一个 01010101 这样的指令

933
00:41:15,000 --> 00:41:17,000
输入一小块芯片的时候

934
00:41:17,000 --> 00:41:19,000
真实做的事情

935
00:41:19,000 --> 00:41:21,000
其实是在这个芯片上面的

936
00:41:21,000 --> 00:41:24,000
不同引脚上面输入高或者低的电压

937
00:41:24,000 --> 00:41:26,000
然后芯片里面会有

938
00:41:26,000 --> 00:41:32,000
很多驮小小的晶体管组成的小装置

939
00:41:32,000 --> 00:41:34,000
被我们按下了

940
00:41:34,000 --> 00:41:39,000
然后这个组合会进而引发更多的

941
00:41:39,000 --> 00:41:42,000
由芯片工程师预先设计的

942
00:41:42,000 --> 00:41:43,000
一系列的连锁反应

943
00:41:43,000 --> 00:41:48,000
然后无数这样的模式数字

944
00:41:48,000 --> 00:41:51,000
一个接一个的被输入芯片里面

945
00:41:51,000 --> 00:41:53,000
最终你屏幕上就会出现一些

946
00:41:53,000 --> 00:41:54,000
能够被人理解的图案

947
00:41:54,000 --> 00:41:56,000
然后给计算机

948
00:41:56,000 --> 00:41:58,000
输入这种相当于命令的数字

949
00:41:58,000 --> 00:42:02,000
称作指令的东西

950
00:42:02,000 --> 00:42:03,000
让它来做一些事情

951
00:42:03,000 --> 00:42:08,000
包括但不限于处理其他那些数字

952
00:42:08,000 --> 00:42:11,000
其实就是编程的本质活动

953
00:42:11,000 --> 00:42:13,000
比如有一台古早的计算机

954
00:42:13,000 --> 00:42:15,000
叫做 Cosmic Elf

955
00:42:15,000 --> 00:42:18,000
它的面板上有一排开关

956
00:42:18,000 --> 00:42:21,000
应该是有 8 个还是 10 个开关

957
00:42:21,000 --> 00:42:23,000
这些开关可以拨上或者拨下

958
00:42:23,000 --> 00:42:26,000
那给这台计算机编程的方法

959
00:42:26,000 --> 00:42:29,000
就是把你想要输入的数字

960
00:42:29,000 --> 00:42:32,000
或者说把你想要按下的琴键

961
00:42:32,000 --> 00:42:37,000
在这排开关上面搬好

962
00:42:37,000 --> 00:42:40,000
比如说搬上去就是 1

963
00:42:40,000 --> 00:42:41,000
搬下去就是 0

964
00:42:41,000 --> 00:42:43,000
搬好一排之后

965
00:42:43,000 --> 00:42:44,000
你按一下右上角

966
00:42:44,000 --> 00:42:45,000
它有一个按钮

967
00:42:45,000 --> 00:42:48,000
你就可以输入下一条指令

968
00:42:48,000 --> 00:42:50,000
这就有好像你在

969
00:42:50,000 --> 00:42:51,000
怎么说呢

970
00:42:51,000 --> 00:42:54,000
有那种早期的打孔钢琴

971
00:42:54,000 --> 00:42:56,000
你输入一排

972
00:42:56,000 --> 00:43:00,000
输入一条这个上面布满了小眼的纸带

973
00:43:00,000 --> 00:43:04,000
每一个眼都代表这个地方应该有个琴键

974
00:43:04,000 --> 00:43:05,000
被按下去

975
00:43:05,000 --> 00:43:08,000
那给这台计算机编程的过程

976
00:43:08,000 --> 00:43:11,000
就有点像你在手工去钻一个纸带

977
00:43:11,000 --> 00:43:14,000
或者你在手工做一个八音盒

978
00:43:14,000 --> 00:43:17,000
如果你看过八音盒是怎么工作的话

979
00:43:17,000 --> 00:43:19,000
你一定明白我是什么意思

980
00:43:19,000 --> 00:43:24,000
问题在于就是你在这台计算机上面输入一系列零和一

981
00:43:24,000 --> 00:43:25,000
和在那台计算机上面输入一系列零和一

982
00:43:25,000 --> 00:43:26,000
和在那台计算机上面输入一系列零和一

983
00:43:26,000 --> 00:43:28,000
你得到的反应可能是完全不一样的

984
00:43:28,000 --> 00:43:36,000
这是从最开始就有一个差异的问题

985
00:43:36,000 --> 00:43:37,000
对

986
00:43:37,000 --> 00:43:40,000
因为各个各家计算机厂商会自己去研发自己的芯片

987
00:43:40,000 --> 00:43:45,000
同样那种数字对于不同型号的计算机来说

988
00:43:45,000 --> 00:43:47,000
有可能是完全代表不同的指令的

989
00:43:47,000 --> 00:43:50,000
而这一点直到今天都没有改变

990
00:43:50,000 --> 00:43:54,000
那些通过金属引脚受到零和一输入的 CPU

991
00:43:54,000 --> 00:43:56,000
所谓有这样一个指令级的改变

992
00:43:56,000 --> 00:44:02,000
本质上指令级其实就是由芯片制造厂商给出的数字组合的定义

993
00:44:02,000 --> 00:44:03,000
对

994
00:44:03,000 --> 00:44:06,000
如果你去查什么 AMD 或者是 Intel 的手册的话

995
00:44:06,000 --> 00:44:14,000
你会发现他们的指令级里面会给出一组数字

996
00:44:14,000 --> 00:44:22,000
这组数字其实就是真正的 CPU 所会接触到的那些高低电瓶组合

997
00:44:22,000 --> 00:44:22,000
对

998
00:44:22,000 --> 00:44:24,000
嗯

999
00:44:24,000 --> 00:44:26,000
由于芯片设计界上的数字组合是很重要的

1000
00:44:26,000 --> 00:44:28,000
每种芯片的指令级也就不同

1001
00:44:28,000 --> 00:44:32,000
比如常见于台式计算机的 Intel 芯片指令级

1002
00:44:32,000 --> 00:44:35,000
就与常见于手持设备的 ARM 芯片的指令级不一样

1003
00:44:36,000 --> 00:44:42,000
计算机语言在这个层面开始就已经产生了区别

1004
00:44:42,000 --> 00:44:49,000
不过用纯数字的计算机语言编程的难度可想而知

1005
00:44:49,000 --> 00:44:54,000
所以从数字到助记符号的转移很快就随之出现了

1006
00:44:54,000 --> 00:44:56,000
我们把这个东西叫做汇编语言

1007
00:44:56,000 --> 00:45:05,000
比如说一组数字 0010000 可以让芯片把内部的一个存储单位

1008
00:45:05,000 --> 00:45:07,000
我们叫它存储器

1009
00:45:07,000 --> 00:45:10,000
寄存器 X 加上一个值 Y

1010
00:45:10,000 --> 00:45:14,000
那么不妨就把这组数字和助记符 ADD 对应起来

1011
00:45:14,000 --> 00:45:19,000
比如说上面的指令就可以写成 ADDXY 这样

1012
00:45:19,000 --> 00:45:23,000
一条条类似的指令写成一串就是一个对于程序的描述

1013
00:45:23,000 --> 00:45:24,000
对吧

1014
00:45:24,000 --> 00:45:26,000
相对于纯数字来说

1015
00:45:26,000 --> 00:45:26,000
这也是一个准备的方法

1016
00:45:26,000 --> 00:45:26,000
对吧

1017
00:45:26,000 --> 00:45:27,000
就是一个制的飞跃

1018
00:45:27,000 --> 00:45:31,000
因为你终于不用去手动搬那个开关了

1019
00:45:31,000 --> 00:45:32,000
不是吗

1020
00:45:33,000 --> 00:45:36,000
然后这样的一串字符呢

1021
00:45:36,000 --> 00:45:39,000
就是这些 ADDXY

1022
00:45:40,000 --> 00:45:44,000
或者是 MoveXY 这样的

1023
00:45:45,000 --> 00:45:51,000
字符串可以由专门的小程序来翻译成那些 0101 的二进制代码

1024
00:45:51,000 --> 00:45:55,000
也就是真正可以被输入处理去

1025
00:45:55,000 --> 00:45:56,000
去按下那些晶体管的

1026
00:45:56,000 --> 00:46:00,000
开关的电子信号

1027
00:46:00,000 --> 00:46:03,000
当然每一种处理器的汇变语言中就是不一样的

1028
00:46:03,000 --> 00:46:08,000
机器语言或者说汇变语言的优点是呢

1029
00:46:08,000 --> 00:46:11,000
每一条指令几乎都对应于芯片能做的一件事情

1030
00:46:11,000 --> 00:46:16,000
比如说有一条指令可以把一个数字从内存里面转到计算器里面

1031
00:46:16,000 --> 00:46:21,000
另一条指令可以把这个被转入计算器的值加上 1

1032
00:46:21,000 --> 00:46:24,000
第三条指令又把它放回内存去

1033
00:46:24,000 --> 00:46:25,000
嗯

1034
00:46:25,000 --> 00:46:26,000
这就是一条指令的优点了

1035
00:46:26,000 --> 00:46:28,000
直接对一块芯片下命令效率非常高

1036
00:46:28,000 --> 00:46:31,000
但是对应的缺点就是

1037
00:46:31,000 --> 00:46:33,000
如果你只是想要把一个数字加上 1 的话

1038
00:46:33,000 --> 00:46:36,000
每次都要写三条指令

1039
00:46:36,000 --> 00:46:38,000
时间一长是非常痛苦的一件事

1040
00:46:38,000 --> 00:46:40,000
而且还有一个问题就是

1041
00:46:40,000 --> 00:46:44,000
因为不同的芯片所支持的指令机是不一样的

1042
00:46:44,000 --> 00:46:48,000
也就意味着你在这一块芯片上需要三条指令能完成的事情

1043
00:46:48,000 --> 00:46:52,000
在另外一块芯片上可能需要五条指令

1044
00:46:52,000 --> 00:46:56,000
所以如果我们能够将一部分固定的指令

1045
00:46:56,000 --> 00:46:57,000
出现的操作

1046
00:46:57,000 --> 00:47:00,000
像连续剂一样的一次性释放

1047
00:47:00,000 --> 00:47:02,000
每次只需要打一个指令

1048
00:47:02,000 --> 00:47:07,000
却能够在不同结构的芯片上都做同样的事情该有多好

1049
00:47:07,000 --> 00:47:08,000
换句话说

1050
00:47:08,000 --> 00:47:12,000
如果能有一种更倾向于描述那些需要解决的问题

1051
00:47:12,000 --> 00:47:14,000
比如说给一个数字加上 1

1052
00:47:14,000 --> 00:47:17,000
而不是手把手的告诉计算机说

1053
00:47:17,000 --> 00:47:20,000
你读一个数字加上一个数字

1054
00:47:20,000 --> 00:47:21,000
再写一个数字

1055
00:47:21,000 --> 00:47:24,000
有这样一种比较高级的语言

1056
00:47:24,000 --> 00:47:26,000
来封装这些比较

1057
00:47:26,000 --> 00:47:28,000
不需要我们去操心的细节

1058
00:47:28,000 --> 00:47:31,000
该有多好

1059
00:47:31,000 --> 00:47:33,000
对吧

1060
00:47:33,000 --> 00:47:35,000
然后所谓的高级语言

1061
00:47:35,000 --> 00:47:38,000
也就是各位学编程的时候学到的那种语言

1062
00:47:38,000 --> 00:47:39,000
就是做这件事

1063
00:47:39,000 --> 00:47:41,000
比如说最古老的高级语言

1064
00:47:41,000 --> 00:47:42,000
有 Fortune

1065
00:47:42,000 --> 00:47:43,000
有 Algo

1066
00:47:43,000 --> 00:47:44,000
Cobble

1067
00:47:44,000 --> 00:47:49,000
乃至于比较同样古老

1068
00:47:49,000 --> 00:47:50,000
但是来源迥异的 Lisp

1069
00:47:50,000 --> 00:47:53,000
我觉得我们应该专门找一期来说 Lisp

1070
00:47:53,000 --> 00:47:55,000
所有这些语言

1071
00:47:55,000 --> 00:47:56,000
他们都会

1072
00:47:56,000 --> 00:47:59,000
最终被转化为二进制的形式

1073
00:47:59,000 --> 00:48:03,000
包括现在大家比较喜欢的动态语言

1074
00:48:03,000 --> 00:48:06,000
比如说 Python

1075
00:48:06,000 --> 00:48:07,000
Ruby

1076
00:48:07,000 --> 00:48:08,000
Lua

1077
00:48:08,000 --> 00:48:14,000
它们归根结底都是会被转化为二进制代码

1078
00:48:14,000 --> 00:48:16,000
输入到 CPU 之中

1079
00:48:16,000 --> 00:48:19,000
它们和这个比较低端的

1080
00:48:19,000 --> 00:48:21,000
或者说比较原始的语言

1081
00:48:21,000 --> 00:48:23,000
比如说 C 或者是 Fortune 的区别就在于

1082
00:48:23,000 --> 00:48:26,000
它们单一一条

1083
00:48:26,000 --> 00:48:26,000
比如说

1084
00:48:26,000 --> 00:48:26,000
C 或者是 Fortune 的区别就在于

1085
00:48:26,000 --> 00:48:27,000
它们单一条的语言

1086
00:48:27,000 --> 00:48:27,000
它们单一条的语言

1087
00:48:27,000 --> 00:48:27,000
它们单一条的语言

1088
00:48:27,000 --> 00:48:27,000
它们单一条的语言

1089
00:48:27,000 --> 00:48:28,000
它们单一条的语言

1090
00:48:28,000 --> 00:48:28,000
它们单一条的语言

1091
00:48:28,000 --> 00:48:28,000
它们单一条的语言

1092
00:48:28,000 --> 00:48:28,000
它们单一条的语言

1093
00:48:28,000 --> 00:48:28,000
它们单一条的语言

1094
00:48:28,000 --> 00:48:29,000
它们单一条的语言

1095
00:48:29,000 --> 00:48:29,000
它们单一条的语言

1096
00:48:29,000 --> 00:48:33,000
包括所涵盖的那些二进制指令要多很多

1097
00:48:33,000 --> 00:48:36,000
然后它们完成这件

1098
00:48:36,000 --> 00:48:39,000
这个特点的手段就是

1099
00:48:39,000 --> 00:48:42,000
它们的底层

1100
00:48:42,000 --> 00:48:45,000
其实又是利用你的实体 CPU

1101
00:48:45,000 --> 00:48:47,000
去模拟一个

1102
00:48:47,000 --> 00:48:52,000
只在逻辑意义上存在的虚拟的 CPU

1103
00:48:52,000 --> 00:48:56,000
这个就不展开讲了

1104
00:48:56,000 --> 00:48:59,000
有进去的同学可以自己去找一些

1105
00:48:59,000 --> 00:49:01,000
这个方面的书看

1106
00:49:01,000 --> 00:49:03,000
我会推荐一本 Code

1107
00:49:03,000 --> 00:49:05,000
我相信之前我已经 Code 过了

1108
00:49:05,000 --> 00:49:06,000
我已经推荐过了

1109
00:49:06,000 --> 00:49:07,000
Sorry

1110
00:49:07,000 --> 00:49:10,000
可能是在某一期的 IT 工作上面

1111
00:49:10,000 --> 00:49:12,000
我说这本书是奇义书

1112
00:49:12,000 --> 00:49:13,000
推荐大家去看看

1113
00:49:13,000 --> 00:49:17,000
以上大概讲了

1114
00:49:17,000 --> 00:49:22,000
编程语言是怎么样利用

1115
00:49:22,000 --> 00:49:22,000
编程语言是怎么样利用

1116
00:49:22,000 --> 00:49:23,000
零和一

1117
00:49:23,000 --> 00:49:26,000
或者说编程语言是怎样转化为零和一

1118
00:49:26,000 --> 00:49:29,000
但是征秀没有解释

1119
00:49:29,000 --> 00:49:30,000
我们一开始提出的一个问题

1120
00:49:30,000 --> 00:49:32,000
就是我们看到的图像

1121
00:49:32,000 --> 00:49:34,000
看到的文字

1122
00:49:34,000 --> 00:49:36,000
是怎样转化为零和一的

1123
00:49:36,000 --> 00:49:39,000
其实道理是类似的

1124
00:49:39,000 --> 00:49:42,000
就是我们约定说

1125
00:49:42,000 --> 00:49:44,000
在计算机里面

1126
00:49:44,000 --> 00:49:46,000
某一些特定的零和一的组合

1127
00:49:46,000 --> 00:49:48,000
代表一个特定的数字

1128
00:49:48,000 --> 00:49:51,000
或者代表一个特定的字符

1129
00:49:51,000 --> 00:49:52,000
或者代表一个特定的字符

1130
00:49:52,000 --> 00:49:53,000
或者代表一个特定的图像

1131
00:49:53,000 --> 00:49:57,000
以我们最常见的 ASCII 码

1132
00:49:57,000 --> 00:50:00,000
也就是美国国家标准局的代码

1133
00:50:00,000 --> 00:50:03,000
ASCII 代码来看的话

1134
00:50:03,000 --> 00:50:06,000
它的方法是挑出一个七位的

1135
00:50:06,000 --> 00:50:09,000
注意是七位的二进制数字

1136
00:50:09,000 --> 00:50:10,000
把它第一位标成一

1137
00:50:10,000 --> 00:50:12,000
最后一位标成一

1138
00:50:12,000 --> 00:50:17,000
也就是 1000001

1139
00:50:17,000 --> 00:50:19,000
这样一个数字

1140
00:50:19,000 --> 00:50:22,000
让它来代表大写字

1141
00:50:22,000 --> 00:50:23,000
字母 A

1142
00:50:23,000 --> 00:50:24,000
对

1143
00:50:24,000 --> 00:50:26,000
然后这个数字被转化成十进制

1144
00:50:26,000 --> 00:50:28,000
就是 65

1145
00:50:28,000 --> 00:50:30,000
然后 65 代表 A

1146
00:50:30,000 --> 00:50:34,000
所以如果你从十进制的角度去看这个数字的话

1147
00:50:34,000 --> 00:50:35,000
你会觉得很奇怪

1148
00:50:35,000 --> 00:50:37,000
为什么要用 65 来代表 A 呢

1149
00:50:37,000 --> 00:50:42,000
但是当你把 65 转化成一个七位的二进制数字的时候

1150
00:50:42,000 --> 00:50:45,000
就会发现它其实是一个相对来说

1151
00:50:45,000 --> 00:50:47,000
比较有规律的码点

1152
00:50:47,000 --> 00:50:49,000
比较有意义的码点

1153
00:50:49,000 --> 00:50:52,000
所以码点就是一个字符

1154
00:50:52,000 --> 00:50:57,000
相对应于它的二进制数字所在的位置

1155
00:50:57,000 --> 00:50:59,000
叫做码点

1156
00:50:59,000 --> 00:51:03,000
那么在 65 这个码点上面是 A

1157
00:51:03,000 --> 00:51:05,000
那么符合逻辑的方式就是

1158
00:51:05,000 --> 00:51:07,000
把 B 放在 66 上

1159
00:51:07,000 --> 00:51:08,000
然后依次里推

1160
00:51:08,000 --> 00:51:12,000
大写字母完了之后是一对标点符号

1161
00:51:12,000 --> 00:51:13,000
然后是小写字母

1162
00:51:13,000 --> 00:51:17,000
那有一个问题就是

1163
00:51:17,000 --> 00:51:20,000
七位的二进制数字

1164
00:51:20,000 --> 00:51:22,000
可以表示

1165
00:51:22,000 --> 00:51:24,000
127 个字符

1166
00:51:24,000 --> 00:51:27,000
对于英语来说是够了

1167
00:51:27,000 --> 00:51:28,000
甚至可以表示大写小写

1168
00:51:28,000 --> 00:51:30,000
加上数字等等

1169
00:51:30,000 --> 00:51:33,000
那么为什么要选用七位这个数字

1170
00:51:33,000 --> 00:51:34,000
也是因为

1171
00:51:34,000 --> 00:51:37,000
如果你把第八位也用上的话

1172
00:51:37,000 --> 00:51:42,000
就可以让其他人去定义一些比较额外的东西

1173
00:51:42,000 --> 00:51:46,000
比如说西欧语言会用到各种各样的 diatric

1174
00:51:46,000 --> 00:51:49,000
就是在字母上面加点

1175
00:51:49,000 --> 00:51:51,000
打撇等等

1176
00:51:51,000 --> 00:51:51,000
诸如此类

1177
00:51:51,000 --> 00:51:52,000
非常愚蠢的事情

1178
00:51:52,000 --> 00:51:56,000
那么他们所使用的方法就是

1179
00:51:56,000 --> 00:52:00,000
把这个七位数字扩展到八位

1180
00:52:00,000 --> 00:52:03,000
或者说利用这个 ASCII 编码标准

1181
00:52:03,000 --> 00:52:07,000
刻意将第八位永远设为零的特点

1182
00:52:07,000 --> 00:52:10,000
规定了当第八位变成一的时候

1183
00:52:10,000 --> 00:52:13,000
多出来的那 127 个码点

1184
00:52:13,000 --> 00:52:15,000
应该具体代表什么

1185
00:52:15,000 --> 00:52:17,000
那么在这个标准上

1186
00:52:17,000 --> 00:52:19,000
西欧多了很多自己的字符标准

1187
00:52:19,000 --> 00:52:21,000
每个国家都不一样

1188
00:52:21,000 --> 00:52:22,000
然后

1189
00:52:22,000 --> 00:52:25,000
我记得 CGK 也是

1190
00:52:25,000 --> 00:52:27,000
在日本也是

1191
00:52:27,000 --> 00:52:29,000
他们利用着多出来的 127 个码点

1192
00:52:29,000 --> 00:52:31,000
加入了评价名

1193
00:52:31,000 --> 00:52:32,000
片价名等等

1194
00:52:32,000 --> 00:52:35,000
所以有了日本的一套自己的规则

1195
00:52:35,000 --> 00:52:38,000
但是那个时候这个编码只能表示价名

1196
00:52:38,000 --> 00:52:41,000
但是我们都知道

1197
00:52:41,000 --> 00:52:43,000
汉字的数量繁多

1198
00:52:43,000 --> 00:52:46,000
256 个显示是不够用的

1199
00:52:46,000 --> 00:52:48,000
早期的一个解决方案就是

1200
00:52:48,000 --> 00:52:51,000
用两个二进制的

1201
00:52:51,000 --> 00:52:55,000
八位数来代表一个汉字

1202
00:52:55,000 --> 00:52:58,000
所以你就有 256 乘 256

1203
00:52:58,000 --> 00:53:01,000
256 乘 256 种可能性

1204
00:53:01,000 --> 00:53:04,000
问题在于由于政治原因

1205
00:53:04,000 --> 00:53:08,000
早期的中国台湾和香港

1206
00:53:08,000 --> 00:53:11,000
对于汉字的编码规定是不一样的

1207
00:53:11,000 --> 00:53:13,000
日本还有一套自己的体系

1208
00:53:13,000 --> 00:53:16,000
不过好在后来出现了一种叫做 unicode 的东西

1209
00:53:16,000 --> 00:53:19,000
unicode 首先它规定了一个序列

1210
00:53:19,000 --> 00:53:21,000
在这个序列里面就是一系列

1211
00:53:21,000 --> 00:53:23,000
怎么说呢就是一系列的码点

1212
00:53:23,000 --> 00:53:28,000
在每个码点上规定了这个码点对应哪个汉字

1213
00:53:28,000 --> 00:53:32,000
不管这个汉字是采用什么样的字型

1214
00:53:32,000 --> 00:53:33,000
来自哪个国家

1215
00:53:36,000 --> 00:53:39,000
全都会归在这个 unicode 的序列里面

1216
00:53:39,000 --> 00:53:43,000
然后 unicode 指定了一个编码的方法

1217
00:53:43,000 --> 00:53:46,000
也就是在某一个特定码点上的汉字

1218
00:53:46,000 --> 00:53:47,000
比如说

1219
00:53:49,000 --> 00:53:53,000
0002 码点上面的汉字

1220
00:53:53,000 --> 00:53:54,000
是假一柄跟假

1221
00:53:54,000 --> 00:53:56,000
它规定说

1222
00:53:56,000 --> 00:53:58,000
当你把这个假字

1223
00:53:58,000 --> 00:54:01,000
以二进制形式表示的时候

1224
00:54:01,000 --> 00:54:03,000
你有很多种选择

1225
00:54:03,000 --> 00:54:05,000
最常见的一种选择

1226
00:54:05,000 --> 00:54:07,000
我们现在叫做 utf-8

1227
00:54:07,000 --> 00:54:13,000
在 utf-8 的表示之下

1228
00:54:13,000 --> 00:54:16,000
位于码点 30002 的假

1229
00:54:16,000 --> 00:54:18,000
这个字

1230
00:54:18,000 --> 00:54:19,000
会被转化为

1231
00:54:19,000 --> 00:54:20,000
有点长了

1232
00:54:20,000 --> 00:54:26,000
是一个三成八位的二进制数字

1233
00:54:26,000 --> 00:54:28,000
是 10011

1234
00:54:28,000 --> 00:54:31,000
1001010

1235
00:54:31,000 --> 00:54:33,000
10110010

1236
00:54:33,000 --> 00:54:37,000
我是这个世界上唯一一个

1237
00:54:37,000 --> 00:54:41,000
把假的汉字转化为语音形式的二进制代码

1238
00:54:41,000 --> 00:54:43,000
太搞笑了

1239
00:54:43,000 --> 00:54:46,000
本质上来讲

1240
00:54:46,000 --> 00:54:47,000
或者说对于计算机来讲

1241
00:54:47,000 --> 00:54:49,000
你告诉它

1242
00:54:49,000 --> 00:54:54,000
100001 也好

1243
00:54:54,000 --> 00:54:55,000
还是你告诉它

1244
00:54:55,000 --> 00:54:57,000
我刚才说的是 24 个

1245
00:54:57,000 --> 00:54:59,000
二进制的数字也好

1246
00:54:59,000 --> 00:55:01,000
在它看来都是一样的

1247
00:55:01,000 --> 00:55:04,000
但是对于人类来说

1248
00:55:04,000 --> 00:55:05,000
其解读方式是不一样

1249
00:55:05,000 --> 00:55:07,000
那么无论音频文件

1250
00:55:07,000 --> 00:55:10,000
还是视频文件

1251
00:55:10,000 --> 00:55:11,000
归根结底

1252
00:55:11,000 --> 00:55:12,000
基本上都可以这样类推

1253
00:55:12,000 --> 00:55:15,000
只不过里面还包含了更多其他的因素

1254
00:55:15,000 --> 00:55:15,000
比如说

1255
00:55:15,000 --> 00:55:18,000
你可以把一个点上面的颜色

1256
00:55:18,000 --> 00:55:19,000
把它的颜色

1257
00:55:19,000 --> 00:55:26,000
划分为红绿蓝三个分量

1258
00:55:26,000 --> 00:55:28,000
然后每个分量

1259
00:55:28,000 --> 00:55:33,000
用一个 0-255 的数字表示

1260
00:55:33,000 --> 00:55:35,000
那么你就可以规定每个

1261
00:55:35,000 --> 00:55:37,000
你都可以得到每个点上的

1262
00:55:37,000 --> 00:55:39,000
选用了 RGB 的值

1263
00:55:39,000 --> 00:55:42,000
但是如果你要记载每一

1264
00:55:42,000 --> 00:55:45,000
如果你要记载一部电影里面的每一

1265
00:55:45,000 --> 00:55:48,000
真的每一个点上的这个数字

1266
00:55:48,000 --> 00:55:50,000
其代价会是非常高昂的

1267
00:55:50,000 --> 00:55:53,000
因为我们目前的科技手段

1268
00:55:53,000 --> 00:55:55,000
还没有办法保证说

1269
00:55:55,000 --> 00:55:57,000
能够完全不去考虑

1270
00:55:57,000 --> 00:56:02,000
存储或者说传输过程之中的空间

1271
00:56:02,000 --> 00:56:04,000
乃至于时间的损耗

1272
00:56:04,000 --> 00:56:07,000
所以人们有想出另外一个方法

1273
00:56:07,000 --> 00:56:12,000
就是找出所有这些数字里面的重复部分

1274
00:56:12,000 --> 00:56:14,000
用一个更短的数字去代替

1275
00:56:14,000 --> 00:56:16,000
这就是压缩的本质

1276
00:56:16,000 --> 00:56:18,000
所以我们可以把它理解为

1277
00:56:18,000 --> 00:56:21,000
对于编码的再编码

1278
00:56:21,000 --> 00:56:24,000
这是另外一层的考虑

1279
00:56:24,000 --> 00:56:31,000
其实这期的提纲里面

1280
00:56:31,000 --> 00:56:33,000
还数了一些其他话题

1281
00:56:33,000 --> 00:56:33,000
包括 Unicode

1282
00:56:33,000 --> 00:56:36,000
本来都是打算在展开讲的

1283
00:56:36,000 --> 00:56:39,000
还有很多历史之类的

1284
00:56:39,000 --> 00:56:42,000
但是目前的状况是

1285
00:56:42,000 --> 00:56:44,000
我这边录音的时间

1286
00:56:44,000 --> 00:56:46,000
刚刚突破了一个小时的 mark

1287
00:56:46,000 --> 00:56:48,000
当然最后剪出来

1288
00:56:48,000 --> 00:56:48,000
可能会有更多的问题

1289
00:56:48,000 --> 00:56:49,000
可能没有一个小时

1290
00:56:49,000 --> 00:56:52,000
不过此时的我已经觉得嗓子非常疼了

1291
00:56:52,000 --> 00:56:57,000
而且很不幸过敏性鼻炎又开始犯了

1292
00:56:57,000 --> 00:56:59,000
所以这期只能

1293
00:56:59,000 --> 00:57:02,000
我们还没有进入正题是吧

1294
00:57:02,000 --> 00:57:05,000
那么来赶紧进入一下正题好了

1295
00:57:05,000 --> 00:57:09,000
正题就是程序员怎样才能找到女朋友呢

1296
00:57:09,000 --> 00:57:10,000
问好

1297
00:57:10,000 --> 00:57:12,000
答案很简单

1298
00:57:12,000 --> 00:57:15,000
就是除非你的女朋友候选人就是好这一口

1299
00:57:15,000 --> 00:57:18,000
那么单纯以程序员的身份

1300
00:57:18,000 --> 00:57:22,000
对于找到女朋友来说没有任何意义

1301
00:57:22,000 --> 00:57:23,000
true story

1302
00:57:23,000 --> 00:57:26,000
只有抛开我是程序员这一个字

1303
00:57:26,000 --> 00:57:27,000
我认同之后

1304
00:57:27,000 --> 00:57:30,000
找女朋友才会变得比较容易

1305
00:57:30,000 --> 00:57:34,000
比如你要弄明白人和人之间沟通的编码

1306
00:57:34,000 --> 00:57:36,000
这个编码体系

1307
00:57:36,000 --> 00:57:39,000
一方面要比计算机系统

1308
00:57:39,000 --> 00:57:41,000
我们刚才所说的一些编码简单的多

1309
00:57:41,000 --> 00:57:44,000
另一方面要比它复杂

1310
00:57:44,000 --> 00:57:46,000
你要去学会理解

1311
00:57:46,000 --> 00:57:48,000
不同的事情

1312
00:57:48,000 --> 00:57:49,000
性别之间的心理差异

1313
00:57:49,000 --> 00:57:52,000
不管这种差异是怎么来的

1314
00:57:52,000 --> 00:57:54,000
都必须了解它

1315
00:57:54,000 --> 00:57:58,000
你要去了解什么是弦外之音

1316
00:57:58,000 --> 00:58:01,000
你要弄明白女孩子说话

1317
00:58:01,000 --> 00:58:03,000
有时候是话里有话

1318
00:58:03,000 --> 00:58:04,000
对吧

1319
00:58:04,000 --> 00:58:07,000
我女朋友在点头

1320
00:58:07,000 --> 00:58:09,000
好吧

1321
00:58:09,000 --> 00:58:12,000
您正在您刚刚收听完的是

1322
00:58:12,000 --> 00:58:16,000
IPM podcast 网络旗下的 IT 技术节目内核股况

1323
00:58:16,000 --> 00:58:18,000
也欢迎你收听 IPM

1324
00:58:18,000 --> 00:58:18,000
请点击订阅点赞

1325
00:58:18,000 --> 00:58:48,000
请不吝点赞 订阅 转发 打赏支持明镜与点点栏目

