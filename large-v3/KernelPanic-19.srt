1
00:00:00,000 --> 00:00:04,000
欢迎收听 IPN Podcast 网络旗下的 IT 技术主题娱乐节目内核恐慌

2
00:00:04,000 --> 00:00:06,000
我们号称 HALCOA 但是也没有干货

3
00:00:06,000 --> 00:00:08,000
想听的人听不想听的人就别听

4
00:00:08,000 --> 00:00:11,000
内核恐慌的网址是 ipn.li.com

5
00:00:11,000 --> 00:00:16,000
我们推荐大家使用 podcast 泛用性客户端订阅我们的节目

6
00:00:16,000 --> 00:00:18,000
如果您不知道什么是泛用性客户端

7
00:00:18,000 --> 00:00:20,000
或者您不知道该用什么客户端

8
00:00:20,000 --> 00:00:23,000
欢迎访问 ipn.li.com

9
00:00:23,000 --> 00:00:26,000
同时也欢迎你为我们的节目捐款

10
00:00:26,000 --> 00:00:28,000
捐款地址是 ipn.li.com

11
00:00:28,000 --> 00:00:31,000
捐款金额随意

12
00:00:31,000 --> 00:00:33,000
只要是能被巴掌处的证人数就可以

13
00:00:33,000 --> 00:00:35,000
捐款不会为你带来什么

14
00:00:35,000 --> 00:00:36,000
不捐也不会让你失去什么

15
00:00:36,000 --> 00:00:37,000
我们的口号是

16
00:00:37,000 --> 00:00:41,000
越来越熟练了这一段话

17
00:00:41,000 --> 00:00:42,000
对这是苦练的结果

18
00:00:42,000 --> 00:00:46,000
每天晚上含着小狮子在洗澡的时候

19
00:00:46,000 --> 00:00:47,000
背这段观感

20
00:00:47,000 --> 00:00:49,000
不是这么耳熟

21
00:00:49,000 --> 00:00:51,000
这谁来着

22
00:00:51,000 --> 00:00:52,000
我不记得了

23
00:00:52,000 --> 00:00:57,000
反正是某个演说家要克服口吃的毛病

24
00:00:57,000 --> 00:00:57,000
然后

25
00:00:57,000 --> 00:00:58,000
这故事真的吗

26
00:00:58,000 --> 00:01:00,000
还是一个鸡汤文

27
00:01:00,000 --> 00:01:01,000
Good question

28
00:01:01,000 --> 00:01:02,000
我不知道

29
00:01:02,000 --> 00:01:03,000
有可能是真的

30
00:01:03,000 --> 00:01:05,000
因为我在想了一下

31
00:01:05,000 --> 00:01:07,000
含着小狮子练春话这件事情的意义何在

32
00:01:07,000 --> 00:01:09,000
就增加你的障碍

33
00:01:09,000 --> 00:01:16,000
就好像绑着沙包在操场上跑圈一样

34
00:01:16,000 --> 00:01:18,000
可以让你吐了小狮子之后

35
00:01:18,000 --> 00:01:21,000
发现自己的舌头好像变得灵活了

36
00:01:21,000 --> 00:01:23,000
所以以此类比的话

37
00:01:23,000 --> 00:01:25,000
如果程序员要提高自己的水平

38
00:01:25,000 --> 00:01:26,000
应该怎么增加这个难度呢

39
00:01:26,000 --> 00:01:26,000
对吧

40
00:01:27,000 --> 00:01:29,000
不用显示器写程序

41
00:01:29,000 --> 00:01:34,000
用什么

42
00:01:34,000 --> 00:01:35,000
那个打孔吗

43
00:01:35,000 --> 00:01:39,000
就或者降低点难度

44
00:01:39,000 --> 00:01:42,000
就只用单色显示器写程序

45
00:01:42,000 --> 00:01:46,000
然后等你有了语法高亮之后

46
00:01:46,000 --> 00:01:49,000
效率就可以升起来

47
00:01:49,000 --> 00:01:50,000
所以用什么

48
00:01:50,000 --> 00:01:52,000
非语法高亮的

49
00:01:52,000 --> 00:01:55,000
用记事本写程序

50
00:01:55,000 --> 00:01:55,000
对

51
00:01:55,000 --> 00:01:57,000
This is partially true

52
00:01:57,000 --> 00:01:58,000
我不许说

53
00:01:58,000 --> 00:02:00,000
你不用 IDE 写程序的话

54
00:02:00,000 --> 00:02:03,000
如果你一开始就坚持不用 IDE 写程序

55
00:02:03,000 --> 00:02:05,000
那么等到你又开始用 IDE 的时候

56
00:02:05,000 --> 00:02:08,000
你的效率应该会有成倍的提升

57
00:02:08,000 --> 00:02:11,000
是不是这个道理

58
00:02:11,000 --> 00:02:14,000
想来应该是的

59
00:02:14,000 --> 00:02:15,000
所以这么说来

60
00:02:15,000 --> 00:02:17,000
我们都算是一直在背着沙包在跑

61
00:02:17,000 --> 00:02:18,000
对

62
00:02:18,000 --> 00:02:20,000
Doing it the hard way

63
00:02:20,000 --> 00:02:24,000
然后当你 do it the normal way 的时候

64
00:02:24,000 --> 00:02:25,000
你就会发现容易了很多

65
00:02:25,000 --> 00:02:26,000
好吧

66
00:02:26,000 --> 00:02:26,000
好吧

67
00:02:27,000 --> 00:02:29,000
,这就好像打星际竞选吧

68
00:02:29,000 --> 00:02:31,000
先用现在 brutal 下面通过关

69
00:02:31,000 --> 00:02:33,000
然后再回去打 easy

70
00:02:33,000 --> 00:02:35,000
简直小菜一碟

71
00:02:35,000 --> 00:02:36,000
没错

72
00:02:36,000 --> 00:02:38,000
OK

73
00:02:38,000 --> 00:02:42,000
先进入我们的第一个环节 follow up

74
00:02:42,000 --> 00:02:46,000
我听说 Rail 拿到一块 Happy Hacking Keyboard Pro R

75
00:02:46,000 --> 00:02:47,000
是真的吗

76
00:02:47,000 --> 00:02:47,000
对

77
00:02:47,000 --> 00:02:53,000
那个上次 Lawrence 把他那块闲置不用的 HHKB Pro 2

78
00:02:53,000 --> 00:02:54,000
送给了我

79
00:02:54,000 --> 00:02:56,000
这是什么时候的事情

80
00:02:56,000 --> 00:02:57,000
这是两个月之前的事情吧

81
00:02:57,000 --> 00:02:59,000
这快递走的这么久吗

82
00:02:59,000 --> 00:03:00,000
还是

83
00:03:00,000 --> 00:03:02,000
我是挺早拿到

84
00:03:02,000 --> 00:03:05,000
但是因为还没来得及感觉上手

85
00:03:05,000 --> 00:03:08,000
所以就也一直没有讲

86
00:03:08,000 --> 00:03:10,000
但是就算也用了一段时间

87
00:03:10,000 --> 00:03:13,000
现在也因为整个键位都变了

88
00:03:13,000 --> 00:03:16,000
所以还是花了一点时间来适应的

89
00:03:16,000 --> 00:03:19,000
现在适应之后觉得还不错

90
00:03:19,000 --> 00:03:21,000
所以我们可以讨论一下

91
00:03:21,000 --> 00:03:25,000
其实我一直有一个疑问

92
00:03:25,000 --> 00:03:26,000
好像 HHKB 到底有几个版本

93
00:03:26,000 --> 00:03:27,000
对吧

94
00:03:27,000 --> 00:03:29,000
应该是有若干版本

95
00:03:29,000 --> 00:03:32,000
首先它有若干版本

96
00:03:32,000 --> 00:03:36,000
因为我看 Wikipedia 上面写的时候

97
00:03:36,000 --> 00:03:40,000
它有可能是有四五个版本

98
00:03:40,000 --> 00:03:40,000
还有什么

99
00:03:40,000 --> 00:03:43,000
但是根据日本的和 International 不一样

100
00:03:43,000 --> 00:03:46,000
但是包括有 HHKB Professional 2

101
00:03:46,000 --> 00:03:49,000
然后现在我看到是在卖的是 Lite

102
00:03:49,000 --> 00:03:50,000
对吧

103
00:03:50,000 --> 00:03:51,000
应该是这样的

104
00:03:51,000 --> 00:03:54,000
一开始有 HHKB 普通版本

105
00:03:54,000 --> 00:03:55,000
就是第一代 HHKB

106
00:03:55,000 --> 00:03:57,000
后来有了 HHKB

107
00:03:57,000 --> 00:03:59,000
Lite

108
00:03:59,000 --> 00:04:03,000
再后来有了 HHKB Pro 2

109
00:04:03,000 --> 00:04:06,000
然后 Pro 2 后面又出了一个 S 版

110
00:04:06,000 --> 00:04:08,000
Ultimum S

111
00:04:08,000 --> 00:04:10,000
就是加了橡皮圈的比较

112
00:04:10,000 --> 00:04:12,000
降噪版本

113
00:04:12,000 --> 00:04:14,000
S stand for silent

114
00:04:14,000 --> 00:04:16,000
所以它们之间有什么区别呢

115
00:04:16,000 --> 00:04:20,000
Lite 版本有方向键

116
00:04:20,000 --> 00:04:21,000
啊

117
00:04:21,000 --> 00:04:22,000
OK

118
00:04:22,000 --> 00:04:26,000
然后日语版本是

119
00:04:26,000 --> 00:04:28,000
就是那种大的 T 型

120
00:04:28,000 --> 00:04:31,000
不是 L 型到 L 型回车的

121
00:04:31,000 --> 00:04:31,000
应该是

122
00:04:31,000 --> 00:04:32,000
oh no

123
00:04:32,000 --> 00:04:33,000
对啊

124
00:04:33,000 --> 00:04:34,000
因为

125
00:04:34,000 --> 00:04:35,000
所以它所有

126
00:04:35,000 --> 00:04:36,000
就我们这么说吧

127
00:04:36,000 --> 00:04:39,000
它是分型号和国家的

128
00:04:39,000 --> 00:04:41,000
如果我们不考虑国家的区别

129
00:04:41,000 --> 00:04:43,000
只考虑型号的区别的话

130
00:04:43,000 --> 00:04:44,000
它有几个不同

131
00:04:44,000 --> 00:04:46,000
有最就是 The original

132
00:04:46,000 --> 00:04:48,000
是哪一款

133
00:04:48,000 --> 00:04:49,000
就最原始的那款

134
00:04:49,000 --> 00:04:51,000
Original 现在应该已经找不着了

135
00:04:51,000 --> 00:04:52,000
就已经停产了

136
00:04:52,000 --> 00:04:55,000
但是我想知道那款应该叫什么名字

137
00:04:55,000 --> 00:04:56,000
就叫 HHKB man

138
00:04:56,000 --> 00:04:58,000
应该是就叫 HHKB Pro

139
00:04:58,000 --> 00:05:01,000
应该是就只叫 HHKB

140
00:05:01,000 --> 00:05:05,000
然后 Lite 和 Pro 的区分是从第二版才有

141
00:05:05,000 --> 00:05:07,000
所以 Lite 和 Pro 之间是什么区别

142
00:05:07,000 --> 00:05:09,000
就 Lite 是 Lite 版本

143
00:05:09,000 --> 00:05:13,000
这是一个很有趣的问题

144
00:05:13,000 --> 00:05:18,000
Lite 和 Pro 之间的版本

145
00:05:18,000 --> 00:05:21,000
很有可能剑帽是有差别的

146
00:05:21,000 --> 00:05:22,000
然后那个 Pro 的版本

147
00:05:22,000 --> 00:05:25,000
现在是不是已经没有卖了

148
00:05:25,000 --> 00:05:25,000
对

149
00:05:25,000 --> 00:05:26,000
第一代的版本是没有卖了

150
00:05:26,000 --> 00:05:27,000
第二代的版本应该已经没有卖了

151
00:05:27,000 --> 00:05:30,000
甚至第一代的版本可能是没有 international 版本

152
00:05:30,000 --> 00:05:32,000
就是一个纯日文的 Lite

153
00:05:32,000 --> 00:05:36,000
因为我们现在用的都是所谓的 Professional 2

154
00:05:36,000 --> 00:05:36,000
对吧

155
00:05:36,000 --> 00:05:37,000
对

156
00:05:37,000 --> 00:05:38,000
Pro 2

157
00:05:38,000 --> 00:05:39,000
然后我去它官网看

158
00:05:39,000 --> 00:05:41,000
好像现在这款也没有卖了吗

159
00:05:41,000 --> 00:05:42,000
还是怎么样

160
00:05:42,000 --> 00:05:44,000
有吧

161
00:05:44,000 --> 00:05:46,000
不会停产了吧

162
00:05:46,000 --> 00:05:47,000
因为我去它官网

163
00:05:47,000 --> 00:05:49,000
它官网也长得很奇怪

164
00:05:49,000 --> 00:05:52,000
就是你不知道它到底是个什么样的性质吗

165
00:05:52,000 --> 00:05:56,000
因为做的很日本网站

166
00:05:56,000 --> 00:05:59,000
这个描述太抽象了

167
00:05:59,000 --> 00:06:02,000
反正日本电商网站都不怎么样

168
00:06:02,000 --> 00:06:03,000
这是肯定的

169
00:06:03,000 --> 00:06:06,000
而且 PFU 甚至不是做电商的

170
00:06:06,000 --> 00:06:07,000
它只是一个

171
00:06:07,000 --> 00:06:07,000
没错

172
00:06:07,000 --> 00:06:10,000
其实它 PFU 它叫做 embedded keyboard

173
00:06:10,000 --> 00:06:12,000
这个 HGKB 页面上

174
00:06:12,000 --> 00:06:13,000
只有一款就是 Lite 2

175
00:06:13,000 --> 00:06:16,000
它在展示的只有 Lite 2

176
00:06:16,000 --> 00:06:17,000
你看是英文网页吧

177
00:06:17,000 --> 00:06:17,000
对

178
00:06:17,000 --> 00:06:19,000
日本内容

179
00:06:19,000 --> 00:06:21,000
日本版本和英文版本不一样

180
00:06:21,000 --> 00:06:23,000
为什么会这样呢

181
00:06:23,000 --> 00:06:24,000
对

182
00:06:24,000 --> 00:06:25,000
为什么会这样呢

183
00:06:25,000 --> 00:06:25,000
对吧

184
00:06:25,000 --> 00:06:25,000
对吧

185
00:06:25,000 --> 00:06:26,000
对吧

186
00:06:26,000 --> 00:06:26,000
为什么会这样

187
00:06:26,000 --> 00:06:27,000
我不知道

188
00:06:27,000 --> 00:06:31,000
也许他们绝大多数用户都是集中在日本

189
00:06:31,000 --> 00:06:34,000
我的这一块键盘实际上是托朋友从日本买的

190
00:06:34,000 --> 00:06:35,000
所以

191
00:06:35,000 --> 00:06:36,000
好吧

192
00:06:36,000 --> 00:06:38,000
所以你那款是日本版吗

193
00:06:38,000 --> 00:06:38,000
不是

194
00:06:38,000 --> 00:06:39,000
是 international 版本

195
00:06:39,000 --> 00:06:43,000
我特别强调说一定要用 international 版本

196
00:06:43,000 --> 00:06:44,000
好乱了

197
00:06:44,000 --> 00:06:46,000
所以你那个是没有方向键

198
00:06:46,000 --> 00:06:48,000
然后只有一个在最右边有一个 FNK 的

199
00:06:48,000 --> 00:06:49,000
对吧

200
00:06:49,000 --> 00:06:50,000
对

201
00:06:50,000 --> 00:06:51,000
跟我那款是一样

202
00:06:51,000 --> 00:06:51,000
但你的是无刻印

203
00:06:51,000 --> 00:06:52,000
我的是有刻印

204
00:06:52,000 --> 00:06:54,000
对

205
00:06:54,000 --> 00:06:54,000
其实

206
00:06:54,000 --> 00:06:55,000
一股

207
00:06:55,000 --> 00:06:57,000
一股优越感由然而生

208
00:06:57,000 --> 00:07:00,000
哈哈哈

209
00:07:00,000 --> 00:07:01,000
键帽可以换是吧

210
00:07:01,000 --> 00:07:02,000
对

211
00:07:02,000 --> 00:07:03,000
键帽可以换

212
00:07:03,000 --> 00:07:05,000
我要准备买一套无刻印的

213
00:07:05,000 --> 00:07:05,000
接着装逼

214
00:07:05,000 --> 00:07:06,000
哈哈哈

215
00:07:06,000 --> 00:07:08,000
嗯

216
00:07:08,000 --> 00:07:09,000
就你

217
00:07:09,000 --> 00:07:13,000
然后我就看那个官网上那个现在在说这个 light two 吗

218
00:07:13,000 --> 00:07:14,000
然后 light two

219
00:07:14,000 --> 00:07:17,000
刚才你你也不你你所以你也不知道 light 和 professional 的区别是什么

220
00:07:17,000 --> 00:07:24,000
我怀疑 light 所用的那个按下去的那个开关应该不是

221
00:07:24,000 --> 00:07:27,000
是什么 tower

222
00:07:27,000 --> 00:07:28,000
topray

223
00:07:28,000 --> 00:07:30,000
topray 的不是 topray 的吧

224
00:07:30,000 --> 00:07:31,000
不是 topray 的键帽

225
00:07:31,000 --> 00:07:35,000
所以那还是所谓的静电容键盘吗

226
00:07:35,000 --> 00:07:37,000
还是什么其他的一个什么东西

227
00:07:37,000 --> 00:07:38,000
有一定可能

228
00:07:38,000 --> 00:07:40,000
因为 light 好像卖便宜

229
00:07:40,000 --> 00:07:41,000
而且不是便宜

230
00:07:41,000 --> 00:07:43,000
而且不止便宜点吧

231
00:07:43,000 --> 00:07:46,000
好吧

232
00:07:46,000 --> 00:07:49,000
然后那个一和就是就是呃

233
00:07:49,000 --> 00:07:53,000
比如说 hkb pro 就是没有数字二的都是已经停产了是吧

234
00:07:53,000 --> 00:07:54,000
只有 pro two 和 light two 才有了

235
00:07:54,000 --> 00:07:57,000
对应该是找到

236
00:07:57,000 --> 00:07:59,000
你说这个这个玩意有日文版

237
00:07:59,000 --> 00:08:01,000
这个日文版在哪里啊

238
00:08:01,000 --> 00:08:04,000
呃我给你找找

239
00:08:04,000 --> 00:08:08,000
哈哈哈这个我我搜那个 hkb 的 wikipedia

240
00:08:08,000 --> 00:08:10,000
他给了一个 official website

241
00:08:10,000 --> 00:08:12,000
点过来就这个然后这边只有一款 light two

242
00:08:12,000 --> 00:08:13,000
什么都没有了

243
00:08:13,000 --> 00:08:15,000
就没有其他任何新款型

244
00:08:15,000 --> 00:08:21,000
只有在 wikipedia 的里面那个列表里面能找得到一些在说那个还在售的款

245
00:08:21,000 --> 00:08:23,000
他有一个他有个列表

246
00:08:23,000 --> 00:08:24,000
有个 end of life

247
00:08:24,000 --> 00:08:26,000
就有一堆都是

248
00:08:26,000 --> 00:08:28,000
应该是已经停产了的

249
00:08:28,000 --> 00:08:33,000
OK 呃 pfu.fujitsu.com

250
00:08:33,000 --> 00:08:34,000
啊

251
00:08:34,000 --> 00:08:36,000
所以现在在说的是 type s

252
00:08:36,000 --> 00:08:39,000
professional jp 就是日文版

253
00:08:39,000 --> 00:08:42,000
professional two light two 还有一个 light two for mac

254
00:08:42,000 --> 00:08:46,000
对这个 professional jp 应该就是第一代的

255
00:08:46,000 --> 00:08:52,000
呃然后其他四款都是国际键是所谓的 international layout

256
00:08:52,000 --> 00:08:54,000
professional two professional two

257
00:08:54,000 --> 00:08:55,000
也有 jp 的版本

258
00:08:55,000 --> 00:08:56,000
我没理解错的话

259
00:08:57,000 --> 00:08:59,000
然后 light two 也有 jp 的版本

260
00:08:59,000 --> 00:09:03,000
然后那个 jp 这款的

261
00:09:04,000 --> 00:09:06,000
键的位置好像又不一样了

262
00:09:07,000 --> 00:09:09,000
呃就像我说 professional jp 的

263
00:09:10,000 --> 00:09:12,000
是第一代然后这一代只有日语版本

264
00:09:12,000 --> 00:09:15,000
然后这一代的那个下面的空格键非常短

265
00:09:16,000 --> 00:09:19,000
呃多了好几个什么其他的键不知道是干嘛的

266
00:09:19,000 --> 00:09:19,000
对

267
00:09:20,000 --> 00:09:23,000
然后从 professional 二开始有了 international layout

268
00:09:24,000 --> 00:09:27,000
呃 light two 也有 international layout

269
00:09:27,000 --> 00:09:28,000
同时也有日语键的

270
00:09:28,000 --> 00:09:29,000
好吧

271
00:09:29,000 --> 00:09:33,000
哎所以那个那个具体型号我们就不去那个啰嗦了

272
00:09:33,000 --> 00:09:34,000
我问你一件事

273
00:09:34,000 --> 00:09:38,000
那个你觉得那个方向键对你来说有用吗

274
00:09:38,000 --> 00:09:41,000
嗯其实还是

275
00:09:41,000 --> 00:09:42,000
有一些用处

276
00:09:42,000 --> 00:09:47,000
就这么说吧因为那个就我们两个都是 pro two 的版本是没有方向键的吧

277
00:09:47,000 --> 00:09:49,000
你在那个

278
00:09:50,000 --> 00:09:54,000
非文本输入框的时候怎么去用方向键

279
00:09:54,000 --> 00:09:57,000
你要用那个 fn key 然后按那个叫什么

280
00:09:58,000 --> 00:09:59,000
那四个键嘛对吧

281
00:09:59,000 --> 00:10:00,000
对

282
00:10:00,000 --> 00:10:01,000
你经常这样干吗

283
00:10:02,000 --> 00:10:06,000
还是挺经常的而且我其实右手的小拇指在

284
00:10:06,000 --> 00:10:08,000
右手的小指在

285
00:10:08,000 --> 00:10:09,000
有一段时间

286
00:10:09,000 --> 00:10:10,000
是疼着的

287
00:10:12,000 --> 00:10:14,000
就按 fn key 的原因是吧

288
00:10:14,000 --> 00:10:15,000
对

289
00:10:15,000 --> 00:10:21,000
而且不止那个就是在公司里面我把那个 fn 加上 a 和 s

290
00:10:22,000 --> 00:10:24,000
弄成了这个

291
00:10:24,000 --> 00:10:25,000
调节音量大小

292
00:10:25,000 --> 00:10:27,000
所以调节音量也要按那两个

293
00:10:28,000 --> 00:10:29,000
fn 是可以自定义的吗

294
00:10:32,000 --> 00:10:37,000
fn 加 a 和 fn 加 s 在普通 pc 上也是调节音量

295
00:10:37,000 --> 00:10:38,000
其实

296
00:10:38,000 --> 00:10:39,000
在 mac 上也是

297
00:10:40,000 --> 00:10:42,000
然后这个组合

298
00:10:42,000 --> 00:10:44,000
你在公司用的是 linux 系统对吧

299
00:10:44,000 --> 00:10:45,000
不是 os 10

300
00:10:46,000 --> 00:10:46,000
对

301
00:10:46,000 --> 00:10:49,000
因为我上次的印象是我用那个 fn

302
00:10:49,000 --> 00:10:51,000
键定义的时候好像没有按出来有什么

303
00:10:52,000 --> 00:10:52,000
就是

304
00:10:52,000 --> 00:10:53,000
fn 加个什么

305
00:10:54,000 --> 00:10:54,000
不能在

306
00:10:55,000 --> 00:10:58,000
苹果那个键盘的设置里面调成一个快捷键吧

307
00:10:58,000 --> 00:10:59,000
可以吗

308
00:10:59,000 --> 00:11:01,000
这个不行但是 fn 加 a

309
00:11:01,000 --> 00:11:05,000
直接对应了多媒体键里面的

310
00:11:05,000 --> 00:11:06,000
volume up

311
00:11:07,000 --> 00:11:08,000
如果没错的话

312
00:11:08,000 --> 00:11:09,000
ok

313
00:11:09,000 --> 00:11:10,000
good to know

314
00:11:10,000 --> 00:11:12,000
所以我还可以

315
00:11:12,000 --> 00:11:15,000
你这个怎么查在哪里知道有这些对应的关系

316
00:11:17,000 --> 00:11:18,000
你的

317
00:11:19,000 --> 00:11:19,000
键

318
00:11:20,000 --> 00:11:22,000
你不是有刻意的键盘

319
00:11:22,000 --> 00:11:23,000
那个键盘的正下方

320
00:11:23,000 --> 00:11:24,000
没有啊没有啊

321
00:11:24,000 --> 00:11:27,000
在 fn 就是那个

322
00:11:27,000 --> 00:11:28,000
这么说吧

323
00:11:28,000 --> 00:11:32,000
在左手键那些区上的只有键帽

324
00:11:32,000 --> 00:11:34,000
没有下没有侧边那个印的

325
00:11:34,000 --> 00:11:36,000
那个额外的键的

326
00:11:36,000 --> 00:11:37,000
含义的

327
00:11:39,000 --> 00:11:43,000
所以我不知道为什么你知道按 fn 加 a 和 s 是调音量我从来没有试过

328
00:11:43,000 --> 00:11:46,000
因为说明书上有写吧我记得

329
00:11:47,000 --> 00:11:48,000
还有说明书

330
00:11:48,000 --> 00:11:49,000
对

331
00:11:49,000 --> 00:11:51,000
你是哪来的山寨

332
00:11:51,000 --> 00:11:52,000
是

333
00:11:52,000 --> 00:11:54,000
李如依直接寄给你的

334
00:11:54,000 --> 00:11:55,000
对啊

335
00:11:55,000 --> 00:11:56,000
因为是

336
00:11:56,000 --> 00:12:01,000
那个就是没有原装盒子吗而且

337
00:12:02,000 --> 00:12:04,000
这点做的太不靠谱了

338
00:12:04,000 --> 00:12:05,000
要是我我一定会吧

339
00:12:06,000 --> 00:12:08,000
原厂说明书

340
00:12:08,000 --> 00:12:10,000
这个事情不管他好意

341
00:12:10,000 --> 00:12:14,000
因为是他说家人打包机的所以比较麻烦

342
00:12:14,000 --> 00:12:15,000
OK

343
00:12:15,000 --> 00:12:19,000
我拿到的时候连那个那个 USB 的线都没有

344
00:12:19,000 --> 00:12:20,000
都是那个通用的一个

345
00:12:21,000 --> 00:12:21,000
应该是

346
00:12:23,000 --> 00:12:23,000
不是迈克

347
00:12:24,000 --> 00:12:24,000
USB 吧

348
00:12:25,000 --> 00:12:25,000
对没错

349
00:12:25,000 --> 00:12:27,000
还挺常见我就自己配了一个

350
00:12:28,000 --> 00:12:28,000
还可以

351
00:12:29,000 --> 00:12:31,000
但是我不知道还有说明书的证明会上

352
00:12:31,000 --> 00:12:32,000
是的还有什么

353
00:12:32,000 --> 00:12:35,000
而且他说明书里会写的后面就跳线

354
00:12:35,000 --> 00:12:37,000
班到什么状态是什么样的功用

355
00:12:38,000 --> 00:12:41,000
那个 dip 可以在网站上查的到但是

356
00:12:41,000 --> 00:12:44,000
这个你说这个快捷键是这个快捷键应该也能在网上查

357
00:12:45,000 --> 00:12:46,000
Pretty sure

358
00:12:47,000 --> 00:12:47,000
哈

359
00:12:48,000 --> 00:12:48,000
Really

360
00:12:49,000 --> 00:12:50,000
好吧那我查一下

361
00:12:52,000 --> 00:12:52,000
哦

362
00:12:52,000 --> 00:12:54,000
OK 我还看到了

363
00:12:54,000 --> 00:12:54,000
这个

364
00:12:55,000 --> 00:12:55,000
这个 format

365
00:12:56,000 --> 00:12:59,000
他是 light 2 的话多了一个 fn key 在左边是吧

366
00:13:00,000 --> 00:13:01,000
右边的 fn 还有吗

367
00:13:02,000 --> 00:13:03,000
有有也有

368
00:13:03,000 --> 00:13:04,000
但左边又多了一个 fn

369
00:13:04,000 --> 00:13:05,000
这个还蛮有用的

370
00:13:05,000 --> 00:13:07,000
就我发现最严重的问题就是

371
00:13:08,000 --> 00:13:09,000
fn 在

372
00:13:09,000 --> 00:13:10,000
右边然后在那个

373
00:13:10,000 --> 00:13:12,000
苹果键盘上 fn 是在左下角嘛

374
00:13:13,000 --> 00:13:15,000
就是说还蛮人格分裂的

375
00:13:15,000 --> 00:13:16,000
一会按左边一会按右边

376
00:13:20,000 --> 00:13:22,000
然后再问你就是说

377
00:13:22,000 --> 00:13:23,000
在这个

378
00:13:24,000 --> 00:13:27,000
就是 os 10 的系统的文本编辑框里面

379
00:13:27,000 --> 00:13:29,000
你要换上下行的时候你怎么办

380
00:13:30,000 --> 00:13:33,000
在这边 os 10 系统的文本框

381
00:13:33,000 --> 00:13:35,000
就是比如说在

382
00:13:35,000 --> 00:13:35,000
这么说嘛

383
00:13:36,000 --> 00:13:38,000
在就现在用的是这个我们用那个 nv-alt

384
00:13:39,000 --> 00:13:39,000
编辑这个

385
00:13:40,000 --> 00:13:40,000
notes 嘛

386
00:13:41,000 --> 00:13:43,000
你要切换上下行怎么办

387
00:13:45,000 --> 00:13:46,000
用方向键啊

388
00:13:46,000 --> 00:13:52,000
然后你要左右移动光标怎么办

389
00:13:52,000 --> 00:13:53,000
啊

390
00:13:54,000 --> 00:13:55,000
那你 ctrl 加 pn 是可以的吧

391
00:13:56,000 --> 00:14:00,000
那个是 emax keybinding 但是你是一个 vim 用户

392
00:14:00,000 --> 00:14:00,000
对

393
00:14:01,000 --> 00:14:03,000
所以我用方向键

394
00:14:03,000 --> 00:14:08,000
我为了这件事情因为方向键不好用嘛要用那个

395
00:14:08,000 --> 00:14:10,000
那个

396
00:14:10,000 --> 00:14:11,000
都是要用小指的

397
00:14:11,000 --> 00:14:17,000
左边的话是按 ctrl 键也上用小指在那个普通键盘的 caps lock 的位置嘛

398
00:14:19,000 --> 00:14:20,000
对吧

399
00:14:21,000 --> 00:14:22,000
然后你要用那个 ctrl-n

400
00:14:23,000 --> 00:14:23,000
然后

401
00:14:23,000 --> 00:14:26,000
ctrl-n 是下一行 p 是上一行然后 f 是

402
00:14:27,000 --> 00:14:29,000
右移然后 b 是左移光标嘛

403
00:14:30,000 --> 00:14:32,000
但是如果你用方向键的话其实就是用

404
00:14:32,000 --> 00:14:35,000
右手的小指按着 f 然后按那几个方向键的

405
00:14:35,000 --> 00:14:36,000
附用的键

406
00:14:36,000 --> 00:14:38,000
其实是好像是差不多的我觉得

407
00:14:39,000 --> 00:14:44,000
所以你的点是什么就是你作为一个 vim 用户为了捍卫自己的尊严所以一定要

408
00:14:44,000 --> 00:14:48,000
我现在很分裂因为我一会要用 emax keybinding

409
00:14:48,000 --> 00:14:49,000
一会要用那个

410
00:14:50,000 --> 00:14:52,000
就是我本质上就遇到这种

411
00:14:52,000 --> 00:14:53,000
非

412
00:14:53,000 --> 00:14:54,000
vim

413
00:14:54,000 --> 00:14:55,000
的 kbinding

414
00:14:55,000 --> 00:14:56,000
支持的情况下比如说在

415
00:14:57,000 --> 00:14:59,000
这个这个故意界面上你选择

416
00:15:00,000 --> 00:15:01,000
上下的一个菜单举个例子

417
00:15:02,000 --> 00:15:04,000
你只能用这个方向键了嘛

418
00:15:04,000 --> 00:15:04,000
对

419
00:15:05,000 --> 00:15:05,000
这时候我就

420
00:15:06,000 --> 00:15:09,000
只能按住用一个右手的小指按住 f 然后用方向键

421
00:15:10,000 --> 00:15:10,000
去调那个

422
00:15:11,000 --> 00:15:11,000
选择

423
00:15:12,000 --> 00:15:17,000
但是在很多我们编辑框里面我又又在用那个 emax keybinding 比如说在 nv-aut 或者是这个

424
00:15:17,000 --> 00:15:18,000
比如说这个

425
00:15:18,000 --> 00:15:21,000
safari 的这个地址栏吧我要编辑它的时候我又会用那个

426
00:15:22,000 --> 00:15:22,000
这个

427
00:15:22,000 --> 00:15:27,000
emax keybinding 去加速我的那个光调移动比如说我可以一个 word 一个 word

428
00:15:27,000 --> 00:15:29,000
而不是一个 character 一个 character 移动

429
00:15:31,000 --> 00:15:32,000
所以

430
00:15:32,000 --> 00:15:36,000
就我最近特别人格分裂你知道吗然后在那个

431
00:15:36,000 --> 00:15:40,000
terminal 或者是在 vim 里面打的就是用的那个 vim 的 keybinding

432
00:15:41,000 --> 00:15:44,000
你在 terminal 里面用 vim 的 keybinding

433
00:15:44,000 --> 00:15:46,000
你是说你的

434
00:15:46,000 --> 00:15:49,000
line edits 用的是 vim 的 keybinding

435
00:15:49,000 --> 00:15:50,000
对啊对啊

436
00:15:50,000 --> 00:15:52,000
我已经把 line

437
00:15:52,000 --> 00:15:54,000
line edits 的 keybinding

438
00:15:54,000 --> 00:15:56,000
就是改回默认的 emax

439
00:15:57,000 --> 00:15:57,000
emax 的吗

440
00:15:58,000 --> 00:16:00,000
对所以你也叛逃了

441
00:16:00,000 --> 00:16:05,000
我不是对主要是向现实妥协吧就是

442
00:16:05,000 --> 00:16:07,000
当因为一天要连

443
00:16:08,000 --> 00:16:10,000
无数台 remote

444
00:16:10,000 --> 00:16:14,000
session 的话就 ssh 到其他的机器上的话

445
00:16:15,000 --> 00:16:15,000
不想每次都改

446
00:16:16,000 --> 00:16:17,000
不想每次都改对

447
00:16:17,000 --> 00:16:20,000
而且去用别人的

448
00:16:20,000 --> 00:16:22,000
键盘的时候也会非常

449
00:16:22,000 --> 00:16:23,000
非常地痛苦

450
00:16:24,000 --> 00:16:25,000
好吧理解了

451
00:16:25,000 --> 00:16:27,000
所以总体来说这个 HKV

452
00:16:27,000 --> 00:16:29,000
这个 pro 2 你用起来

453
00:16:30,000 --> 00:16:31,000
你用了多久了到底

454
00:16:32,000 --> 00:16:33,000
一年多吧

455
00:16:34,000 --> 00:16:35,000
所以感觉如何

456
00:16:35,000 --> 00:16:39,000
我也不知道我觉得他已经内化了你不说的话不觉得他是

457
00:16:39,000 --> 00:16:41,000
不觉得他是一个什么事了是吧

458
00:16:41,000 --> 00:16:43,000
对现在我已经不觉得他是一个

459
00:16:43,000 --> 00:16:47,000
因为我刚用一个月嘛所以感觉还不太一样就有时候会觉得

460
00:16:47,000 --> 00:16:48,000
有点人格分裂

461
00:16:49,000 --> 00:16:51,000
因为我还用那个笔记本的那个 MAC 自带那个键盘嘛

462
00:16:52,000 --> 00:16:53,000
对我也是

463
00:16:53,000 --> 00:16:55,000
而且我的两个 layout 是不一样的

464
00:16:56,000 --> 00:16:57,000
所以我其实我在想那个

465
00:16:57,000 --> 00:17:01,000
他现在在卖那个 light for Mac 那个感觉可能稍微正常一点

466
00:17:02,000 --> 00:17:03,000
所以要买一块吗

467
00:17:03,000 --> 00:17:08,000
再说吧这个先先适应一段时间再说看到底

468
00:17:08,000 --> 00:17:09,000
能不能够接受这种方式

469
00:17:10,000 --> 00:17:11,000
我觉得整个手感还是不错的

470
00:17:12,000 --> 00:17:14,000
这个 Toprate 的那个按键的感觉还是登登登

471
00:17:15,000 --> 00:17:15,000
一种

472
00:17:16,000 --> 00:17:18,000
比较登的感觉

473
00:17:19,000 --> 00:17:21,000
OK

474
00:17:22,000 --> 00:17:23,000
不出这个单

475
00:17:25,000 --> 00:17:26,000
那今天我们就下个环节了

476
00:17:27,000 --> 00:17:29,000
读两封这个听众来信

477
00:17:30,000 --> 00:17:30,000
第一封你来吧

478
00:17:33,000 --> 00:17:39,000
这两封读来信都是针对上一期那个我读白的那一期

479
00:17:40,000 --> 00:17:43,000
反正事后这个

480
00:17:43,000 --> 00:17:50,000
布鸟万如一和布鸟万 real 先生都表达了惊讶说你一个人得不得不得居然可以得一小时这个真的

481
00:17:52,000 --> 00:17:54,000
我自己没想到我可以得一个小时但事实上

482
00:17:55,000 --> 00:17:57,000
我本来是计划得两个小时

483
00:18:00,000 --> 00:18:01,000
我觉得已经很厉害了

484
00:18:03,000 --> 00:18:04,000
谢谢

485
00:18:05,000 --> 00:18:09,000
首先是我们的老朋友 Virgil 明先生

486
00:18:09,000 --> 00:18:10,000
是先生吗

487
00:18:11,000 --> 00:18:12,000
我小朋友对

488
00:18:12,000 --> 00:18:14,000
记来一封听众来信

489
00:18:16,000 --> 00:18:17,000
吴涛你好

490
00:18:17,000 --> 00:18:20,000
这是对新鲜出炉的第 18 期节目的反馈

491
00:18:21,000 --> 00:18:22,000
对我记得这一期

492
00:18:22,000 --> 00:18:25,000
应该是在上线之后可能

493
00:18:26,000 --> 00:18:27,000
五六个小时

494
00:18:27,000 --> 00:18:28,000
他就写了一封

495
00:18:28,000 --> 00:18:29,000
写了一封这封信来

496
00:18:30,000 --> 00:18:30,000
真是

497
00:18:31,000 --> 00:18:31,000
太热心了

498
00:18:34,000 --> 00:18:35,000
他说

499
00:18:35,000 --> 00:18:42,000
高级程序员到汇编到可执行文件到机器指令这一系列过程并不算是编码吧

500
00:18:43,000 --> 00:18:45,000
Compile 和 Encode 是两回事

501
00:18:46,000 --> 00:18:47,000
这个

502
00:18:48,000 --> 00:18:50,000
对其实我之所以说自己本来计划

503
00:18:50,000 --> 00:18:52,000
计划说了

504
00:18:52,000 --> 00:18:55,000
两个小时就是因为我后一小时是要说编码的

505
00:18:55,000 --> 00:18:58,000
但是说到一个小时的时候已经就撑不住了

506
00:18:59,000 --> 00:19:01,000
前一部分是说 compile

507
00:19:02,000 --> 00:19:06,000
就是说计算机的指令是怎样转化为二进式指令的

508
00:19:06,000 --> 00:19:08,000
计算机的文本指令

509
00:19:08,000 --> 00:19:10,000
是如何转化为二进式指令

510
00:19:11,000 --> 00:19:13,000
然后我本来计划在后半部

511
00:19:13,000 --> 00:19:14,000
讲这个编码

512
00:19:15,000 --> 00:19:17,000
就是什么 unicode 啊

513
00:19:17,000 --> 00:19:18,000
asky 啊

514
00:19:18,000 --> 00:19:19,000
什么 GB

515
00:19:20,000 --> 00:19:21,000
blah blah 一系列

516
00:19:21,000 --> 00:19:22,000
但是

517
00:19:22,000 --> 00:19:24,000
后来实在是撑不下去了

518
00:19:25,000 --> 00:19:28,000
所以才会给人这种印象

519
00:19:28,000 --> 00:19:31,000
其实上一期的真正的主题的确是编码

520
00:19:31,000 --> 00:19:31,000
只不过

521
00:19:32,000 --> 00:19:33,000
没能进入真正的主题

522
00:19:36,000 --> 00:19:36,000
这叫什么

523
00:19:37,000 --> 00:19:37,000
戛然而止

524
00:19:38,000 --> 00:19:38,000
对

525
00:19:39,000 --> 00:19:40,000
对那个字了

526
00:19:42,000 --> 00:19:42,000
接着读

527
00:19:43,000 --> 00:19:45,000
有件事情让我有些感叹

528
00:19:45,000 --> 00:19:48,000
asky 编码里面大写字母的 a 是 65

529
00:19:48,000 --> 00:19:52,000
这件事情存在我记忆里面应该已经 10 年了吧

530
00:19:52,000 --> 00:19:55,000
然而直到今天我才明白那是 64 加 1

531
00:19:56,000 --> 00:19:57,000
当年只是把 65

532
00:19:58,000 --> 00:20:01,000
当年只是把 65 做一个 magic number

533
00:20:02,000 --> 00:20:03,000
强行记住而已

534
00:20:04,000 --> 00:20:07,000
因为当时刚刚学二进制对此丝毫不敏感

535
00:20:07,000 --> 00:20:09,000
老师也没有多解释

536
00:20:09,000 --> 00:20:10,000
我也没有觉得有什么不对

537
00:20:10,000 --> 00:20:13,000
然而现在看来明天是少了一块拼图

538
00:20:13,000 --> 00:20:16,000
以此类推小写字母 a 是 97

539
00:20:16,000 --> 00:20:18,000
97 就等于 64 加 32 加 1

540
00:20:18,000 --> 00:20:19,000
也是很符合逻辑

541
00:20:20,000 --> 00:20:21,000
所以

542
00:20:22,000 --> 00:20:24,000
这里就是

543
00:20:24,000 --> 00:20:26,000
他的意思就是 64 这个数字

544
00:20:28,000 --> 00:20:29,000
就是

545
00:20:29,000 --> 00:20:31,000
二进制的

546
00:20:32,000 --> 00:20:33,000
七位的

547
00:20:33,000 --> 00:20:34,000
1

548
00:20:34,000 --> 00:20:35,000
然后跟 6 个 0

549
00:20:36,000 --> 00:20:37,000
所以这是一个特别的数字

550
00:20:37,000 --> 00:20:38,000
然后

551
00:20:39,000 --> 00:20:43,000
97 是 64 加 32 也就是 1 后面 6 个 0 加上 1 后面 5 个 0

552
00:20:43,000 --> 00:20:45,000
也就是 110000

553
00:20:46,000 --> 00:20:48,000
这个数字是 96

554
00:20:49,000 --> 00:20:50,000
然后 96 后面的第 1 个

555
00:20:51,000 --> 00:20:52,000
就是

556
00:20:52,000 --> 00:20:54,000
1100001

557
00:20:55,000 --> 00:20:58,000
这个二进制编码是代表小写字母 a

558
00:20:58,000 --> 00:20:59,000
所以这些

559
00:20:59,000 --> 00:21:02,000
其实在最开始规定 asky 码的时候都已经

560
00:21:03,000 --> 00:21:05,000
都是有一定的内在逻辑

561
00:21:07,000 --> 00:21:07,000
然后

562
00:21:08,000 --> 00:21:11,000
然后 asky 码的这个 64 呢就是 at

563
00:21:11,000 --> 00:21:17,000
所以各位如果你要想去铭记某一个事件的时候你可以多拉几个 at

564
00:21:17,000 --> 00:21:19,000
然后前面可以加上一个大写字母 y

565
00:21:19,000 --> 00:21:20,000
OK

566
00:21:20,000 --> 00:21:21,000
OK

567
00:21:22,000 --> 00:21:23,000
tick

568
00:21:25,000 --> 00:21:26,000
接着读

569
00:21:26,000 --> 00:21:27,000
这让我想到另一件事

570
00:21:27,000 --> 00:21:30,000
大一的思学家课程里面有一道习题

571
00:21:30,000 --> 00:21:32,000
实现一个支持 reverse

572
00:21:32,000 --> 00:21:33,000
polish notation 的计算器

573
00:21:34,000 --> 00:21:36,000
当时也没觉得有什么特别之处

574
00:21:36,000 --> 00:21:37,000
无非就是个循环练习嘛

575
00:21:38,000 --> 00:21:40,000
为什么要弄出这么一套反直觉的技法呢

576
00:21:41,000 --> 00:21:44,000
直到两年之后上到 functional programming 的课

577
00:21:44,000 --> 00:21:48,000
快到期中考试的时候才突然反应过来

578
00:21:48,000 --> 00:21:50,000
这无非就是换了个形式

579
00:21:50,000 --> 00:21:52,000
针对四则运算这个非常

580
00:21:52,000 --> 00:21:53,000
特别的情况

581
00:21:54,000 --> 00:21:57,000
显然显示的把地归优化成循环

582
00:21:59,000 --> 00:22:00,000
而

583
00:22:00,000 --> 00:22:04,000
reversepolish notation 发明早于 Lisp 二三十年

584
00:22:05,000 --> 00:22:06,000
我也没读 Lisp 最早那篇论文

585
00:22:07,000 --> 00:22:10,000
但我相信两者形式上相通绝不只是偶然

586
00:22:11,000 --> 00:22:13,000
这种感觉我不知道怎么形容 deja vu 吗

587
00:22:14,000 --> 00:22:18,000
如果在一开始学习的时候就能了解背后这些神秘的东西

588
00:22:18,000 --> 00:22:19,000
Computer science

589
00:22:19,000 --> 00:22:20,000
本来应该可以更迷人

590
00:22:22,000 --> 00:22:26,000
至于你的节目里面只有一分钟不到的正题

591
00:22:27,000 --> 00:22:31,000
省略几百字的吐槽但有一点我想说明

592
00:22:31,000 --> 00:22:32,000
这么说吧

593
00:22:32,000 --> 00:22:33,000
我们

594
00:22:33,000 --> 00:22:34,000
括号

595
00:22:34,000 --> 00:22:36,000
仅指我自己周边的人

596
00:22:36,000 --> 00:22:38,000
我生于 1992 年

597
00:22:38,000 --> 00:22:39,000
括号结束

598
00:22:39,000 --> 00:22:43,000
这就是为什么我说他是个小朋友 1992 年了

599
00:22:45,000 --> 00:22:47,000
90 后的明先生你好

600
00:22:47,000 --> 00:22:49,000
对 90 后的明小朋友你好

601
00:22:50,000 --> 00:22:50,000
嗯

602
00:22:52,000 --> 00:22:56,000
我们生长起来的环境里面并没有什么机制来保证人们

603
00:22:57,000 --> 00:23:03,000
人们在生长过程中能够以较温和的方式了解如何谈恋爱这个常识

604
00:23:04,000 --> 00:23:06,000
独生子女和父母离婚成风

605
00:23:06,000 --> 00:23:07,000
括号

606
00:23:07,000 --> 00:23:12,000
90 年代人们突然像赶尸毛似的开始考虑甚至执行离婚

607
00:23:12,000 --> 00:23:12,000
括号结束

608
00:23:13,000 --> 00:23:14,000
但影响都不提了

609
00:23:14,000 --> 00:23:16,000
我可以确定的是

610
00:23:16,000 --> 00:23:19,000
在大学之前三观上位定型的时候

611
00:23:19,000 --> 00:23:19,000
在国内

612
00:23:20,000 --> 00:23:22,000
练习谈恋爱的机会不仅是少

613
00:23:22,000 --> 00:23:27,000
而且大多数情况下是离经叛道得不到任何可靠的第三方支持的

614
00:23:27,000 --> 00:23:28,000
于是

615
00:23:28,000 --> 00:23:34,000
等到上了大学之后我听到看到了许多不知道该称为悲剧还是黑色幽默的故事

616
00:23:35,000 --> 00:23:38,000
我自己也不知道有幸还是不幸

617
00:23:38,000 --> 00:23:40,000
参与了其中的一个

618
00:23:41,000 --> 00:23:43,000
Larit 的 Hardway 的确是有效的策略

619
00:23:43,000 --> 00:23:45,000
但是如果我们讨论的是感情

620
00:23:46,000 --> 00:23:47,000
这里的 Hardway

621
00:23:47,000 --> 00:23:48,000
可能对你

622
00:23:48,000 --> 00:23:49,000
或者对

623
00:23:49,000 --> 00:23:51,000
对对方造成不可逆的伤害

624
00:23:52,000 --> 00:23:53,000
真的没问题吗

625
00:23:53,000 --> 00:23:54,000
更重要的是

626
00:23:54,000 --> 00:23:56,000
最好的时机已经过去了

627
00:23:56,000 --> 00:23:58,000
这个 bug 改起来会非常痛苦

628
00:23:58,000 --> 00:23:59,000
尽会于不可行

629
00:23:59,000 --> 00:24:01,000
这不只是程序员的问题

630
00:24:01,000 --> 00:24:06,000
我承认外行人甚至业内人士对于程序员的 stereotype 有时候不可理喻

631
00:24:07,000 --> 00:24:08,000
但问题的本质仅仅是

632
00:24:09,000 --> 00:24:09,000
作为一个人

633
00:24:10,000 --> 00:24:12,000
如何发展处理和另一个人的亲密关系而已

634
00:24:14,000 --> 00:24:18,000
把职业甚至相关的 stereotype 卷进来作为预设处理

635
00:24:18,000 --> 00:24:19,000
难道不是原木求鱼吗

636
00:24:20,000 --> 00:24:21,000
最后你为什么要一次性录完这个视频

637
00:24:22,000 --> 00:24:24,000
不能休息一天接着录吗

638
00:24:25,000 --> 00:24:26,000
OK

639
00:24:28,000 --> 00:24:29,000
Ryu 有什么想说吗

640
00:24:31,000 --> 00:24:34,000
其实我觉得他对你上期的

641
00:24:34,000 --> 00:24:36,000
打引号的政题的诠释挺好的呀

642
00:24:37,000 --> 00:24:39,000
这个真的是一件跟职业啊

643
00:24:39,000 --> 00:24:41,000
什么其他关系不大的事情

644
00:24:41,000 --> 00:24:42,000
这就是一个

645
00:24:43,000 --> 00:24:46,000
做人的基本的一些东西

646
00:24:46,000 --> 00:24:47,000
在我们现在这个

647
00:24:48,000 --> 00:24:50,000
社会的一个欠缺吧

648
00:24:51,000 --> 00:24:52,000
但我觉得很神奇

649
00:24:52,000 --> 00:24:54,000
你觉得 90 后现在谈恋爱还是

650
00:24:54,000 --> 00:24:55,000
这么受限吗

651
00:24:55,000 --> 00:25:01,000
对我有这个感想就是我觉得我们这 80 年代后的这一批人啊

652
00:25:01,000 --> 00:25:03,000
这次 Ryu 你挑不到了你好歹是个 80 后

653
00:25:04,000 --> 00:25:07,000
我们在年轻的时候

654
00:25:07,000 --> 00:25:10,000
谈恋爱也很受限制这个是实情

655
00:25:10,000 --> 00:25:11,000
但是我怎么觉得好像

656
00:25:12,000 --> 00:25:12,000
好像

657
00:25:13,000 --> 00:25:15,000
90 后应该不存在这样的限制啊

658
00:25:16,000 --> 00:25:16,000
难道

659
00:25:17,000 --> 00:25:18,000
难道是

660
00:25:19,000 --> 00:25:20,000
中国还是那个样子吗

661
00:25:22,000 --> 00:25:24,000
作为两个

662
00:25:24,000 --> 00:25:25,000
外国

663
00:25:25,000 --> 00:25:27,000
生活在外国的人

664
00:25:28,000 --> 00:25:29,000
怎么说真的是

665
00:25:32,000 --> 00:25:34,000
我们觉得我不够了解他们

666
00:25:34,000 --> 00:25:40,000
不够了解这个后一个 10 年出生的人他们的一个成长的状况这个是挺

667
00:25:40,000 --> 00:25:41,000
挺讨厌的一件事情

668
00:25:43,000 --> 00:25:44,000
不过

669
00:25:44,000 --> 00:25:46,000
可能也可以理解因为你想

670
00:25:46,000 --> 00:25:48,000
我们毕业的时候

671
00:25:48,000 --> 00:25:49,000
带我们的那些老师

672
00:25:50,000 --> 00:25:52,000
至少还会在

673
00:25:52,000 --> 00:25:53,000
教职上

674
00:25:53,000 --> 00:25:55,000
至少还会在教职上

675
00:25:55,000 --> 00:25:57,000
再待个 10 年吧

676
00:25:57,000 --> 00:25:58,000
所以

677
00:26:00,000 --> 00:26:00,000
也许

678
00:26:01,000 --> 00:26:04,000
现在的谈恋爱的环境没有我们想象的那么开放

679
00:26:05,000 --> 00:26:05,000
或者

680
00:26:05,000 --> 00:26:06,000
这么理解就是

681
00:26:06,000 --> 00:26:08,000
只要高考这件事情还存在

682
00:26:08,000 --> 00:26:10,000
只要中国还是这么一种

683
00:26:11,000 --> 00:26:11,000
这种

684
00:26:11,000 --> 00:26:15,000
就是说人多的竞争的模式可能这件事情就很难

685
00:26:15,000 --> 00:26:16,000
幸免

686
00:26:19,000 --> 00:26:20,000
有道理

687
00:26:21,000 --> 00:26:22,000
说到高考

688
00:26:22,000 --> 00:26:22,000
可能是

689
00:26:23,000 --> 00:26:25,000
昨天还是前几天刚刚高考结束吧

690
00:26:26,000 --> 00:26:26,000
不知道

691
00:26:26,000 --> 00:26:28,000
我们听众朋友里面有没有

692
00:26:29,000 --> 00:26:31,000
现在是属于解脱呢

693
00:26:31,000 --> 00:26:32,000
还是什么状态

694
00:26:33,000 --> 00:26:36,000
或者是刚刚考完打算报计算机系

695
00:26:37,000 --> 00:26:38,000
你千万别啊

696
00:26:38,000 --> 00:26:40,000
算思

697
00:26:41,000 --> 00:26:42,000
你得想清楚

698
00:26:44,000 --> 00:26:44,000
好吧

699
00:26:45,000 --> 00:26:47,000
然后我觉得他说的那个

700
00:26:48,000 --> 00:26:49,000
程序员的 stereotype

701
00:26:49,000 --> 00:26:51,000
就是我其实上一期

702
00:26:51,000 --> 00:26:52,000
我已经不记得自己说了

703
00:26:52,000 --> 00:26:57,000
但是你上期我觉得有一点就是我觉得就他这里

704
00:26:57,000 --> 00:26:58,000
又又又

705
00:26:58,000 --> 00:26:59,000
又提到吗就是说

706
00:27:00,000 --> 00:27:01,000
这件事情跟职业真的没有太大关系

707
00:27:02,000 --> 00:27:05,000
对其实我上一期之所以会想到这个就是因为

708
00:27:06,000 --> 00:27:12,000
可能是在网上看到那个天子说什么我是程序员找不到女朋友 blah blah

709
00:27:12,000 --> 00:27:17,000
或者是什么我男朋友程序员我想要送他一个什么什么什么什么玩意

710
00:27:17,000 --> 00:27:20,000
然后总是在想说程序员那个身份有那么重要吗

711
00:27:20,000 --> 00:27:21,000
为什么

712
00:27:22,000 --> 00:27:24,000
因为我现在是在想说这个

713
00:27:24,000 --> 00:27:28,000
要把这个身份单独提出来好像他 somehowsomehow 就改变了你是一个

714
00:27:30,000 --> 00:27:31,000
人这个

715
00:27:32,000 --> 00:27:32,000
基本

716
00:27:33,000 --> 00:27:35,000
现实一样

717
00:27:37,000 --> 00:27:40,000
有可能是跟你有一次说到这么一件事情有关系就是

718
00:27:41,000 --> 00:27:43,000
编程其实是一个逐渐异化的过程

719
00:27:44,000 --> 00:27:46,000
就是刨掉你作为人的那一面然后

720
00:27:47,000 --> 00:27:51,000
要把你假设成为一个理性的机器去一行一行

721
00:27:51,000 --> 00:27:52,000
去解析这个

722
00:27:52,000 --> 00:27:54,000
你执行那段代码的这么一个过程

723
00:27:54,000 --> 00:27:58,000
然后所以我不知道是不是时间长了之后会让人变得

724
00:27:59,000 --> 00:28:00,000
非

725
00:28:02,000 --> 00:28:05,000
非人类变得过于理性和非人类的

726
00:28:05,000 --> 00:28:06,000
然后

727
00:28:06,000 --> 00:28:09,000
很多这个中国国内的这种

728
00:28:09,000 --> 00:28:11,000
教育出来的那种理工科生会

729
00:28:11,000 --> 00:28:13,000
有个字叫什么特别轴你知道吗

730
00:28:14,000 --> 00:28:15,000
就认死脸

731
00:28:15,000 --> 00:28:16,000
就不知道怎么变

732
00:28:16,000 --> 00:28:20,000
经常会把我们理科生挂在嘴边

733
00:28:20,000 --> 00:28:21,000
没错没错

734
00:28:21,000 --> 00:28:22,000
然后这个时候就这种

735
00:28:22,000 --> 00:28:22,000
因为在

736
00:28:23,000 --> 00:28:28,000
感情上出现问题就是说你觉得逻辑上是成立的但是你要知道这个事件并不是

737
00:28:29,000 --> 00:28:30,000
逻辑的方式运行

738
00:28:31,000 --> 00:28:37,000
这件事情可能会让很多人感到伤感但现实就是在现实世界里面如果你把一个

739
00:28:38,000 --> 00:28:40,000
condition 测试一万遍的可能

740
00:28:41,000 --> 00:28:42,000
有 5000 遍

741
00:28:43,000 --> 00:28:44,000
是 true

742
00:28:44,000 --> 00:28:45,000
另外 5000 遍是 false

743
00:28:45,000 --> 00:28:47,000
得不到一个确定的

744
00:28:47,000 --> 00:28:49,000
而不像程式里面

745
00:28:50,000 --> 00:28:51,000
我们接下来

746
00:28:51,000 --> 00:28:54,000
要接触的主题就是有些事情是可以重复的

747
00:28:54,000 --> 00:28:57,000
重复的事情就是可以被测试

748
00:28:57,000 --> 00:29:00,000
但现实生活里面很多的东西是没有办法

749
00:29:01,000 --> 00:29:01,000
重复验证

750
00:29:02,000 --> 00:29:03,000
也许你再来一次

751
00:29:04,000 --> 00:29:06,000
得到结果就会完全不一样

752
00:29:06,000 --> 00:29:07,000
谁知道

753
00:29:07,000 --> 00:29:11,000
甚至就说他们经常说那句话嘛两点之间的最短的线路可能不是值的

754
00:29:11,000 --> 00:29:13,000
但这句话你怎么理解你自己去想

755
00:29:13,000 --> 00:29:15,000
取决于你怎么定义最短

756
00:29:18,000 --> 00:29:19,000
最省时间而已

757
00:29:19,000 --> 00:29:20,000
对

758
00:29:20,000 --> 00:29:21,000
这就好像

759
00:29:21,000 --> 00:29:21,000
一个

760
00:29:21,000 --> 00:29:24,000
GPS 导航仪会问你你是要最省时间的还是要最短的线路

761
00:29:25,000 --> 00:29:28,000
刚刚学开车的时候我想说质量整的那不一样吗

762
00:29:29,000 --> 00:29:30,000
后来才明白真的不一样

763
00:29:33,000 --> 00:29:35,000
而且我觉得对很多这个

764
00:29:35,000 --> 00:29:37,000
就是程序员也好

765
00:29:37,000 --> 00:29:37,000
他的

766
00:29:38,000 --> 00:29:38,000
可能

767
00:29:39,000 --> 00:29:43,000
很多人的职业规划是说要在几年三五年十年之后做成一个

768
00:29:44,000 --> 00:29:44,000
所谓的技术

769
00:29:45,000 --> 00:29:45,000
岗位的

770
00:29:45,000 --> 00:29:46,000
管理者

771
00:29:46,000 --> 00:29:47,000
这么一个

772
00:29:47,000 --> 00:29:49,000
这个时候其实

773
00:29:49,000 --> 00:29:51,000
你会发现你一旦走向所谓的

774
00:29:51,000 --> 00:29:53,000
所谓的管理岗位你是你要写代码的时候就不多了

775
00:29:53,000 --> 00:29:55,000
这反而是考验你对这个人的

776
00:29:56,000 --> 00:29:56,000
理解

777
00:29:56,000 --> 00:29:58,000
对人性的

778
00:29:58,000 --> 00:29:58,000
思考的

779
00:29:59,000 --> 00:29:59,000
地方

780
00:30:00,000 --> 00:30:01,000
会比你

781
00:30:01,000 --> 00:30:02,000
逻辑的地方多的

782
00:30:03,000 --> 00:30:04,000
那个多了多的时候

783
00:30:04,000 --> 00:30:04,000
所以

784
00:30:05,000 --> 00:30:07,000
你如果处理不好你和你

785
00:30:09,000 --> 00:30:12,000
亲密的人的关系估计你走管理岗位也会挺

786
00:30:12,000 --> 00:30:13,000
郁闷的

787
00:30:13,000 --> 00:30:17,000
对你会发现自己此前一直努力压抑的情商忽然变得无比重要了

788
00:30:18,000 --> 00:30:19,000
哈哈哈

789
00:30:19,000 --> 00:30:20,000
觉得自己

790
00:30:20,000 --> 00:30:21,000
其实

791
00:30:21,000 --> 00:30:22,000
这个白痴一样在那里

792
00:30:23,000 --> 00:30:23,000
对

793
00:30:24,000 --> 00:30:25,000
当然说到最后这个事情

794
00:30:26,000 --> 00:30:26,000
那我们

795
00:30:27,000 --> 00:30:28,000
可以反正你上次

796
00:30:29,000 --> 00:30:30,000
你吐槽了吗

797
00:30:30,000 --> 00:30:31,000
那我也来

798
00:30:31,000 --> 00:30:32,000
吐槽一下就是

799
00:30:33,000 --> 00:30:35,000
反正我找你朋友是我当成员之前的事

800
00:30:35,000 --> 00:30:37,000
后面怎么着我也管不着了

801
00:30:37,000 --> 00:30:39,000
赤果果的炫耀

802
00:30:43,000 --> 00:30:47,000
OK 我们讲那个下一条的这个听众反馈

803
00:30:47,000 --> 00:30:49,000
这一封来自一位叫

804
00:30:51,000 --> 00:30:52,000
Fleely

805
00:30:52,000 --> 00:30:52,000
徐

806
00:30:53,000 --> 00:30:54,000
应该是徐

807
00:30:54,000 --> 00:30:54,000
对

808
00:30:55,000 --> 00:30:57,000
对

809
00:30:58,000 --> 00:30:58,000
他说

810
00:30:59,000 --> 00:31:02,000
我不知道是不是 podcast 客户端有问题

811
00:31:02,000 --> 00:31:05,000
或者是你们的 podcast 发布服务器有问题

812
00:31:05,000 --> 00:31:06,000
总之有一段时间

813
00:31:06,000 --> 00:31:09,000
当我下载内核恐慌并打开来收听的时候

814
00:31:09,000 --> 00:31:12,000
会传出一个很好听很温柔的女生说

815
00:31:12,000 --> 00:31:15,000
大家好欢迎收听游戏通信的叉叉戏

816
00:31:15,000 --> 00:31:18,000
我并不知道 APN 还有另外一档叫做游行通信的节目

817
00:31:19,000 --> 00:31:21,000
我多次以为是两位主播说的

818
00:31:21,000 --> 00:31:22,000
我受不了之前许多没有主题

819
00:31:23,000 --> 00:31:26,000
重点和深度的 softcore 讨论

820
00:31:26,000 --> 00:31:30,000
终于找来了哪一位美女大牛进行一个高级话题的讨论

821
00:31:31,000 --> 00:31:33,000
但是后来我才意识到原来是下载错了节目

822
00:31:34,000 --> 00:31:37,000
再后来当我看到录音的时间短于一个小时的时候

823
00:31:37,000 --> 00:31:38,000
我就会本能的以为

824
00:31:38,000 --> 00:31:41,000
podcast 又出问题了然后三处重新下载

825
00:31:41,000 --> 00:31:44,000
这个事情在 edicono 里面其实我有次已经

826
00:31:44,000 --> 00:31:45,000
提到过了就是

827
00:31:46,000 --> 00:31:47,000
这是一个 bug

828
00:31:47,000 --> 00:31:48,000
not a feature

829
00:31:48,000 --> 00:31:51,000
这是我们的 podcast 发布服务器的

830
00:31:51,000 --> 00:31:51,000
或者是

831
00:31:52,000 --> 00:31:52,000
但是

832
00:31:52,000 --> 00:31:55,000
但是这个 bug 的成因我到目前为止都没有找到

833
00:31:55,000 --> 00:31:56,000
因为

834
00:31:56,000 --> 00:31:57,000
我没有办法重现的

835
00:31:57,000 --> 00:32:03,000
我们应该在这里发动广大的程序员听众帮我们测试一下如果你遇到这个场景

836
00:32:04,000 --> 00:32:05,000
请千万去

837
00:32:05,000 --> 00:32:09,000
somehow someway traceback 一下这个网址是怎么来的

838
00:32:09,000 --> 00:32:11,000
他经过了那些路由

839
00:32:11,000 --> 00:32:13,000
他是到底是怎么一回事

840
00:32:15,000 --> 00:32:17,000
因为我现在想了几个可能出现

841
00:32:17,000 --> 00:32:18,000
问题的地方一个是

842
00:32:19,000 --> 00:32:21,000
我们的自己的那个 APN 的那个

843
00:32:21,000 --> 00:32:22,000
CMS 有问题

844
00:32:22,000 --> 00:32:23,000
但是我

845
00:32:24,000 --> 00:32:25,000
我做了很多测试

846
00:32:25,000 --> 00:32:26,000
这个是今天我们的

847
00:32:26,000 --> 00:32:27,000
后面的主题啊

848
00:32:27,000 --> 00:32:28,000
一会再说

849
00:32:28,000 --> 00:32:30,000
我做很多测试啊

850
00:32:30,000 --> 00:32:32,000
就是我完全没办法重现这件事情

851
00:32:32,000 --> 00:32:35,000
然后我就是我就想到说那是不是这个

852
00:32:35,000 --> 00:32:36,000
运营商的劫持

853
00:32:36,000 --> 00:32:37,000
但现在看来又

854
00:32:37,000 --> 00:32:38,000
不是一个

855
00:32:39,000 --> 00:32:40,000
非常确定的东西

856
00:32:41,000 --> 00:32:43,000
有不同的人在不同的网络环境下不同的运营商

857
00:32:43,000 --> 00:32:44,000
他都遇到类似的问题

858
00:32:45,000 --> 00:32:47,000
而且这个事情似乎是一个

859
00:32:48,000 --> 00:32:50,000
难以预测规律的东西

860
00:32:50,000 --> 00:32:50,000
就

861
00:32:51,000 --> 00:32:52,000
我不知道到底是为什么

862
00:32:52,000 --> 00:32:56,000
然后之前又是考虑说是不是因为这个强的问题因为我们的服务器在国外

863
00:32:57,000 --> 00:32:57,000
但是

864
00:32:57,000 --> 00:33:01,000
他来找一些朋友测试都也没有得出一个确定结论

865
00:33:01,000 --> 00:33:03,000
所以到目前为止这是一个叫什么 Fantom bug

866
00:33:05,000 --> 00:33:06,000
隐虫

867
00:33:06,000 --> 00:33:09,000
就是他

868
00:33:09,000 --> 00:33:13,000
一会出现一会不出现你也不知道他什么时候出现以及他在什么情况下会出现

869
00:33:14,000 --> 00:33:14,000
所以我也很郁闷

870
00:33:15,000 --> 00:33:16,000
OK

871
00:33:16,000 --> 00:33:17,000
这是一个声明啊

872
00:33:17,000 --> 00:33:19,000
大家如果能够帮助我们

873
00:33:19,000 --> 00:33:20,000
这个

874
00:33:21,000 --> 00:33:21,000
除下虫

875
00:33:22,000 --> 00:33:22,000
万分感谢

876
00:33:24,000 --> 00:33:25,000
然后接着念这个

877
00:33:26,000 --> 00:33:27,000
Fleely 的来信

878
00:33:27,000 --> 00:33:30,000
他说而这次我重新下载了三次

879
00:33:30,000 --> 00:33:33,000
发现节目的长度依然只有 59 分钟我发现

880
00:33:33,000 --> 00:33:37,000
原来这一次没有下错节目真的只有 59 分钟所以

881
00:33:37,000 --> 00:33:44,000
少了那么多内容和水分是因为少了一个人吗对呀正常吗我们两个人一人加完水就是两个

882
00:33:44,000 --> 00:33:44,000
小时

883
00:33:44,000 --> 00:33:46,000
如果只有一个人打个对折差不多

884
00:33:49,000 --> 00:33:51,000
他说以上只是一个问题

885
00:33:51,000 --> 00:33:51,000
我玩一下

886
00:33:52,000 --> 00:33:53,000
接着说

887
00:33:53,000 --> 00:33:55,000
关于机械键盘的手感是玄学的观点

888
00:33:56,000 --> 00:33:57,000
感觉非常扯淡

889
00:33:57,000 --> 00:33:58,000
我用过各种键盘

890
00:33:59,000 --> 00:34:01,000
我长时间使用过红轴和黑轴

891
00:34:01,000 --> 00:34:02,000
薄膜键盘也用

892
00:34:03,000 --> 00:34:05,000
而现在主要使用的是

893
00:34:05,000 --> 00:34:07,000
real force 的静电容键盘

894
00:34:08,000 --> 00:34:09,000
在我身边

895
00:34:09,000 --> 00:34:11,000
喜欢薄膜键盘的人也不少

896
00:34:11,000 --> 00:34:13,000
他们不喜欢机械键盘的手感

897
00:34:13,000 --> 00:34:15,000
但是对于薄膜键盘的不好

898
00:34:15,000 --> 00:34:16,000
非常清楚

899
00:34:16,000 --> 00:34:19,000
就在薄膜键盘老化的时候按键无法回弹

900
00:34:19,000 --> 00:34:21,000
或者回弹缓的

901
00:34:21,000 --> 00:34:24,000
而这就是让人们对薄膜键盘手感感觉不好的原因

902
00:34:25,000 --> 00:34:25,000
真的是这样吗

903
00:34:26,000 --> 00:34:26,000
我不太清楚

904
00:34:27,000 --> 00:34:28,000
应该是没错吧

905
00:34:30,000 --> 00:34:31,000
接着念

906
00:34:31,000 --> 00:34:35,000
我们平时所说的薄膜键盘是依靠底部的这个碗状硅胶

907
00:34:35,000 --> 00:34:36,000
进行回弹的

908
00:34:37,000 --> 00:34:37,000
在一些键盘中

909
00:34:38,000 --> 00:34:40,000
还会辅助利用到一些机械结构

910
00:34:40,000 --> 00:34:43,000
比如最知名的笔记本电脑使用的

911
00:34:43,000 --> 00:34:43,000
X 结构

912
00:34:44,000 --> 00:34:45,000
就是叫做 scissors switch

913
00:34:46,000 --> 00:34:47,000
剪刀脚

914
00:34:47,000 --> 00:34:48,000
但是

915
00:34:48,000 --> 00:34:49,000
硅胶碗的寿命

916
00:34:50,000 --> 00:34:51,000
根据键盘质量

917
00:34:51,000 --> 00:34:52,000
在几十万次到百万次不等

918
00:34:53,000 --> 00:34:55,000
不同键盘的使用寿命也不太一样

919
00:34:55,000 --> 00:34:56,000
但是必须承认

920
00:34:56,000 --> 00:34:58,000
新买回来的薄膜键盘手感是非常好的

921
00:34:59,000 --> 00:35:00,000
之所以不选择它

922
00:35:01,000 --> 00:35:02,000
就是因为你很可能在几个月之后

923
00:35:03,000 --> 00:35:04,000
这些按键就不能回弹

924
00:35:04,000 --> 00:35:05,000
甚至回弹缓慢了

925
00:35:06,000 --> 00:35:07,000
这个时候的手感

926
00:35:07,000 --> 00:35:08,000
就很糟糕

927
00:35:08,000 --> 00:35:10,000
这样缓慢的回弹

928
00:35:10,000 --> 00:35:13,000
是我们的手指可能需要自己费力抬起来

929
00:35:14,000 --> 00:35:14,000
而不是

930
00:35:15,000 --> 00:35:17,000
放松之后被按键推上来

931
00:35:17,000 --> 00:35:19,000
这种细微的变化会被手指

932
00:35:19,000 --> 00:35:20,000
敏感

933
00:35:21,000 --> 00:35:22,000
感到察觉到

934
00:35:22,000 --> 00:35:24,000
而抬起手指的力气会比

935
00:35:24,000 --> 00:35:25,000
按下按

936
00:35:25,000 --> 00:35:26,000
键更费力

937
00:35:27,000 --> 00:35:28,000
而在按键无法

938
00:35:28,000 --> 00:35:29,000
彻底回弹的时候

939
00:35:30,000 --> 00:35:32,000
按下按键的心情会变得烦躁不安

940
00:35:32,000 --> 00:35:35,000
其实也说明了为什么这么多人喜欢 real force

941
00:35:35,000 --> 00:35:36,000
和 HHKV 这类不是

942
00:35:37,000 --> 00:35:37,000
键盘

943
00:35:37,000 --> 00:35:39,000
不是机械键盘的高级键盘

944
00:35:40,000 --> 00:35:42,000
因为静电容键盘的原理和手感

945
00:35:42,000 --> 00:35:45,000
因为静电容键盘的原理和手感

946
00:35:46,000 --> 00:35:48,000
跟普通的薄膜键盘太相似了

947
00:35:49,000 --> 00:35:50,000
静电容键盘内部是一个

948
00:35:51,000 --> 00:35:51,000
橡胶瓦

949
00:35:51,000 --> 00:35:53,000
里面是一个碗形的弹簧

950
00:35:54,000 --> 00:35:57,000
所使用的橡胶的寿命要高于普通的硅胶

951
00:35:57,000 --> 00:35:59,000
并且里面的碗形弹簧

952
00:35:59,000 --> 00:36:00,000
不仅是用来改变

953
00:36:01,000 --> 00:36:02,000
电容触发按键

954
00:36:02,000 --> 00:36:03,000
还可以帮助回弹

955
00:36:03,000 --> 00:36:05,000
所以静电容键盘的感觉

956
00:36:05,000 --> 00:36:06,000
像是回弹有力

957
00:36:07,000 --> 00:36:09,000
并且永远是新买回来状态的薄膜键盘

958
00:36:10,000 --> 00:36:14,000
这其实跟我刚刚讲的那个 HHKV 的那个语段有点关系

959
00:36:15,000 --> 00:36:16,000
我的感觉就是

960
00:36:16,000 --> 00:36:21,000
因为之前我们讨论过键盘内切的 HHKV 总筋量键盘

961
00:36:21,000 --> 00:36:22,000
我自己从来没有用过

962
00:36:22,000 --> 00:36:24,000
就知道上次这个 Lawrence 把他那块机给我

963
00:36:24,000 --> 00:36:26,000
我当时第 1 次拿到的时候

964
00:36:26,000 --> 00:36:27,000
感觉还是蛮特别的

965
00:36:27,000 --> 00:36:28,000
这个手感

966
00:36:28,000 --> 00:36:29,000
因为他并不像

967
00:36:30,000 --> 00:36:33,000
我预期的那种机械键盘当中很硬朗的感觉

968
00:36:33,000 --> 00:36:35,000
你刚才念对了

969
00:36:35,000 --> 00:36:37,000
他原文的确是 real force

970
00:36:37,000 --> 00:36:39,000
HHKV 这类不是机械键盘的关键

971
00:36:40,000 --> 00:36:43,000
他漏写了机械两个字但是你的

972
00:36:43,000 --> 00:36:44,000
你的结果应该是正确

973
00:36:45,000 --> 00:36:46,000
我理解是这么理解的

974
00:36:47,000 --> 00:36:48,000
所以这个我觉得就

975
00:36:48,000 --> 00:36:49,000
挺有意思嘛因为

976
00:36:51,000 --> 00:36:53,000
这个键盘的手感真的是很难形容

977
00:36:54,000 --> 00:36:55,000
他说是这个薄膜键盘

978
00:36:56,000 --> 00:37:00,000
我觉得也不太像我没有用过任何一款薄膜键盘是这种感觉的

979
00:37:01,000 --> 00:37:04,000
对没错就是机械键盘你会有明显的那种

980
00:37:04,000 --> 00:37:06,000
咔嚓的感觉就是

981
00:37:06,000 --> 00:37:09,000
你会感觉到自己在按一个

982
00:37:09,000 --> 00:37:11,000
弹簧一样的东西但是在

983
00:37:12,000 --> 00:37:14,000
静电容键盘里面这种感觉被

984
00:37:14,000 --> 00:37:17,000
淡化你能感觉到自己没有在按一个薄膜

985
00:37:19,000 --> 00:37:21,000
按下去你也肯定不是弹簧

986
00:37:21,000 --> 00:37:23,000
所以这件事情我觉得真的

987
00:37:23,000 --> 00:37:24,000
像很多这个东西

988
00:37:25,000 --> 00:37:26,000
越来越多的实体物件一样

989
00:37:26,000 --> 00:37:28,000
你光听描述是没有用的

990
00:37:28,000 --> 00:37:31,000
除非你自己真的按上去那天或者说甚至说除非你

991
00:37:31,000 --> 00:37:35,000
要连续使用相当长一段时间你才能感觉到这种细微的差别

992
00:37:36,000 --> 00:37:39,000
给你的手感给你的工作带来什么样的一种影响和变化

993
00:37:40,000 --> 00:37:41,000
所以这个就

994
00:37:41,000 --> 00:37:43,000
不再多说了大家有机会去摸一下吧

995
00:37:43,000 --> 00:37:47,000
接着念几个他后面还有一些你一大段的反馈

996
00:37:49,000 --> 00:37:50,000
对于这一期主题的变化

997
00:37:51,000 --> 00:37:53,000
我觉得主播在答案周围转了一圈

998
00:37:53,000 --> 00:37:58,000
甚至延伸扯到了指令集以及三进制这些更无关的其他东西

999
00:37:58,000 --> 00:38:00,000
但是始终就没有说到底

1000
00:38:00,000 --> 00:38:01,000
到底什么是编码

1001
00:38:02,000 --> 00:38:04,000
主播已经提到比如说我们能看到文字

1002
00:38:04,000 --> 00:38:05,000
我们能听到声音

1003
00:38:06,000 --> 00:38:07,000
比如说各位现在听到的 podcast

1004
00:38:08,000 --> 00:38:10,000
我们能看到图片以及一些高雅的小电影

1005
00:38:11,000 --> 00:38:11,000
这东西都

1006
00:38:12,000 --> 00:38:16,000
不是 0 和 1 不是吗如何用 0 和 1 表示这些东西就是编码

1007
00:38:16,000 --> 00:38:18,000
而用这些 0 和 1 或者说数字

1008
00:38:18,000 --> 00:38:21,000
或者说更准确的说是用整数

1009
00:38:21,000 --> 00:38:21,000
表示文字

1010
00:38:22,000 --> 00:38:23,000
就是文字编码

1011
00:38:23,000 --> 00:38:25,000
那表示音乐就是音乐的编码

1012
00:38:25,000 --> 00:38:26,000
MP 3

1013
00:38:26,000 --> 00:38:27,000
WMA 之类的

1014
00:38:28,000 --> 00:38:30,000
为了让本来只能表示

1015
00:38:30,000 --> 00:38:31,000
二进制

1016
00:38:31,000 --> 00:38:35,000
数的计算机能够处理文本就必须将文本变化为相应的数字

1017
00:38:36,000 --> 00:38:38,000
这种对于文本的数值

1018
00:38:38,000 --> 00:38:39,000
就成为文本编码

1019
00:38:39,000 --> 00:38:42,000
这段话是在松本信宏

1020
00:38:43,000 --> 00:38:45,000
松本信宏是一个日本的程序员

1021
00:38:46,000 --> 00:38:47,000
好像我记得他很自学称才

1022
00:38:48,000 --> 00:38:48,000
怎么着

1023
00:38:48,000 --> 00:38:49,000
写了几本书

1024
00:38:51,000 --> 00:38:52,000
这段话是在松本

1025
00:38:53,000 --> 00:38:57,000
行红在他的书松本行红的成全世界 7.1.1

1026
00:38:57,000 --> 00:38:59,000
这个章节里面早期文字编码中

1027
00:39:00,000 --> 00:39:02,000
对于文字编码的描述

1028
00:39:02,000 --> 00:39:05,000
这大概算是一个非常简洁而且易懂的描述吧

1029
00:39:05,000 --> 00:39:07,000
松本行红就是 MATS

1030
00:39:08,000 --> 00:39:09,000
Ruby 那个作者

1031
00:39:11,000 --> 00:39:14,000
我一直没反应过来我就是看他名字特别眼熟但我不确定到底是谁

1032
00:39:14,000 --> 00:39:16,000
我把它用另外一个

1033
00:39:16,000 --> 00:39:18,000
日本名字怎么念

1034
00:39:18,000 --> 00:39:19,000
MATS 是什么

1035
00:39:19,000 --> 00:39:21,000
Yukihiro

1036
00:39:21,000 --> 00:39:22,000
Matsumoto

1037
00:39:23,000 --> 00:39:24,000
Matsumoto

1038
00:39:24,000 --> 00:39:25,000
Matsumoto

1039
00:39:26,000 --> 00:39:26,000
Kato

1040
00:39:27,000 --> 00:39:27,000
OK

1041
00:39:27,000 --> 00:39:28,000
嗯

1042
00:39:28,000 --> 00:39:29,000
接下来

1043
00:39:29,000 --> 00:39:31,000
此外这本书中还介绍了一些

1044
00:39:31,000 --> 00:39:32,000
很有历史

1045
00:39:33,000 --> 00:39:35,000
但是很奇葩的文字编码

1046
00:39:35,000 --> 00:39:36,000
如定义了

1047
00:39:37,000 --> 00:39:38,000
半角

1048
00:39:38,000 --> 00:39:39,000
片假名的

1049
00:39:39,000 --> 00:39:42,000
标准 JIS X 0201

1050
00:39:42,000 --> 00:39:45,000
以及一种类似 ISO 8859 的方法实现

1051
00:39:45,000 --> 00:39:47,000
但是 ASCII 部分以

1052
00:39:48,000 --> 00:39:48,000
这个

1053
00:39:49,000 --> 00:39:49,000
这叫什么来的

1054
00:39:50,000 --> 00:39:50,000
日文

1055
00:39:51,000 --> 00:39:53,000
日元符号或者是人民币符号因为都是一个吧

1056
00:39:54,000 --> 00:39:55,000
就是那个洋少一横

1057
00:39:56,000 --> 00:39:57,000
替代了反斜杠

1058
00:39:57,000 --> 00:39:58,000
以上

1059
00:39:58,000 --> 00:40:01,000
画线替代了这个波浪号

1060
00:40:01,000 --> 00:40:03,000
洋少一横

1061
00:40:03,000 --> 00:40:04,000
他有这种

1062
00:40:05,000 --> 00:40:10,000
他其实就是那个日元的那个印外印上打了两横嘛

1063
00:40:11,000 --> 00:40:12,000
人民币也是用它呀对吧

1064
00:40:12,000 --> 00:40:17,000
我一直好奇为什么反日这个反日分子从来没有拿这个符号

1065
00:40:17,000 --> 00:40:18,000
开刀的

1066
00:40:19,000 --> 00:40:21,000
这个符号是什么呢

1067
00:40:21,000 --> 00:40:23,000
人民币完全搬迁日元

1068
00:40:23,000 --> 00:40:25,000
你看卢布都有自己的符号

1069
00:40:26,000 --> 00:40:27,000
说我们应该用洋嘛

1070
00:40:27,000 --> 00:40:28,000
他们比他们还多一横

1071
00:40:29,000 --> 00:40:30,000
对

1072
00:40:30,000 --> 00:40:31,000
东石高级

1073
00:40:32,000 --> 00:40:34,000
下次我们不打那个音了

1074
00:40:34,000 --> 00:40:35,000
我们打洋

1075
00:40:35,000 --> 00:40:36,000
对

1076
00:40:36,000 --> 00:40:40,000
另一个编码则是奇葩的 ISO-2022

1077
00:40:41,000 --> 00:40:47,000
这种单身于 93 年的神奇编码方式使用类似于编程语言中引号或者

1078
00:40:47,000 --> 00:40:48,000
注释的方法

1079
00:40:48,000 --> 00:40:50,000
通过一个特殊的引号

1080
00:40:50,000 --> 00:40:50,000
将

1081
00:40:51,000 --> 00:40:52,000
asky 编码和其他语言的编码

1082
00:40:53,000 --> 00:40:56,000
汉语的 GB 2312 和日语的 JS

1083
00:40:56,000 --> 00:40:58,000
X 0208 引起来

1084
00:40:58,000 --> 00:40:59,000
也就是

1085
00:40:59,000 --> 00:41:01,000
在 asky 编码的文本当中

1086
00:41:01,000 --> 00:41:03,000
当遇到三个特殊字符

1087
00:41:04,000 --> 00:41:04,000
escape

1088
00:41:04,000 --> 00:41:05,000
$和 b

1089
00:41:06,000 --> 00:41:10,000
则后面的内容开始切换到 JSX 0208 编码

1090
00:41:11,000 --> 00:41:13,000
当遇到另外三个特殊字符 escape

1091
00:41:14,000 --> 00:41:15,000
开括好

1092
00:41:15,000 --> 00:41:15,000
b

1093
00:41:16,000 --> 00:41:16,000
又切换回

1094
00:41:17,000 --> 00:41:18,000
asky 编码

1095
00:41:18,000 --> 00:41:20,000
在我看到这本书的时候

1096
00:41:20,000 --> 00:41:23,000
不尽感叹原来人类还设计过如此愚蠢的编码

1097
00:41:23,000 --> 00:41:24,000
相比起来

1098
00:41:24,000 --> 00:41:27,000
UTF 系列真是不知道搞到哪里去了

1099
00:41:27,000 --> 00:41:29,000
是没错

1100
00:41:29,000 --> 00:41:33,000
所以他那个都不叫那个就最后那个提到的 ISO

1101
00:41:34,000 --> 00:41:36,000
2022 这个都已经不算是一个

1102
00:41:36,000 --> 00:41:37,000
编码方式他就是一个

1103
00:41:38,000 --> 00:41:38,000
怎么讲

1104
00:41:39,000 --> 00:41:39,000
escape 方式

1105
00:41:39,000 --> 00:41:45,000
规定一组规则告诉你在这个时候可以插入其他编码的东西

1106
00:41:46,000 --> 00:41:47,000
这感觉好像在写 XML 对吧

1107
00:41:48,000 --> 00:41:49,000
开括号

1108
00:41:49,000 --> 00:41:50,000
快快快

1109
00:41:50,000 --> 00:41:52,000
他是这种原编码

1110
00:41:52,000 --> 00:41:53,000
关于编码

1111
00:41:54,000 --> 00:41:58,000
我其实这个方式在那个 UTF 里面也实现过上期我今天也聊到那个叫做

1112
00:41:59,000 --> 00:42:01,000
这个叫什么 Pair 的 SeveragePair

1113
00:42:03,000 --> 00:42:03,000
呃

1114
00:42:05,000 --> 00:42:07,000
我没有提到 SeveragePair

1115
00:42:07,000 --> 00:42:11,000
就是在那个 UTF 16 这个编码因为 UTF 16 是固定两个字节的

1116
00:42:12,000 --> 00:42:15,000
但是 UTF 的 unicode 的那个那个平面那个总的

1117
00:42:15,000 --> 00:42:17,000
字符数是远远超过 16 个字节可以容纳的

1118
00:42:18,000 --> 00:42:19,000
所以怎么在

1119
00:42:19,000 --> 00:42:20,000
16 个字节

1120
00:42:20,000 --> 00:42:22,000
这种定常的编码里面装

1121
00:42:23,000 --> 00:42:25,000
超过 16 个字节那些东西怎么办

1122
00:42:25,000 --> 00:42:26,000
对我没有提到这个

1123
00:42:26,000 --> 00:42:29,000
那我可以先往下位解释一下这个我之前做

1124
00:42:30,000 --> 00:42:32,000
研究的时候写过这么一段小笔记

1125
00:42:33,000 --> 00:42:33,000
就是说

1126
00:42:34,000 --> 00:42:35,000
那我们必然有一个有一个办法要用

1127
00:42:36,000 --> 00:42:38,000
多于 16 个字节

1128
00:42:38,000 --> 00:42:40,000
就两个 byte 的方式来编码

1129
00:42:40,000 --> 00:42:41,000
其他东西嘛所以

1130
00:42:41,000 --> 00:42:43,000
他在他定义了一个

1131
00:42:43,000 --> 00:42:45,000
特殊的一个

1132
00:42:45,000 --> 00:42:47,000
就有一个范围的字节

1133
00:42:48,000 --> 00:42:49,000
只要那个字节开始的时候

1134
00:42:49,000 --> 00:42:50,000
他会进入另外一种

1135
00:42:50,000 --> 00:42:54,000
就是非定常 16 个

1136
00:42:55,000 --> 00:42:55,000
bit

1137
00:42:56,000 --> 00:42:56,000
两个字节的模式

1138
00:42:57,000 --> 00:42:59,000
刚说错了不是 16 个字节那也太差了

1139
00:42:59,000 --> 00:43:01,000
16 个位就是两个字节的方式

1140
00:43:01,000 --> 00:43:05,000
就有一些特殊组合的这个那个两个

1141
00:43:06,000 --> 00:43:06,000
byte

1142
00:43:07,000 --> 00:43:09,000
他会定义说从这里开始我们进入另外一种模式

1143
00:43:10,000 --> 00:43:13,000
然后另外还有一些特殊的这个两个 byte 他会说从这里

1144
00:43:13,000 --> 00:43:17,000
开始我们结束那个特殊模式回到那个正常的 UTF 16 的编码

1145
00:43:17,000 --> 00:43:18,000
这种

1146
00:43:18,000 --> 00:43:19,000
特殊的

1147
00:43:19,000 --> 00:43:20,000
byte

1148
00:43:20,000 --> 00:43:21,000
叫做 severage pair

1149
00:43:22,000 --> 00:43:22,000
叫做什么

1150
00:43:22,000 --> 00:43:23,000
代理组

1151
00:43:24,000 --> 00:43:24,000
代理对

1152
00:43:25,000 --> 00:43:28,000
其实跟那个这个 S 202 的方式差不多了

1153
00:43:28,000 --> 00:43:35,000
那你不得不说在当时的这个物理史就是 UTF 16 应该是在 90 年代中后期实现的嘛

1154
00:43:35,000 --> 00:43:35,000
开发出来

1155
00:43:36,000 --> 00:43:38,000
在那个当时历史情况下

1156
00:43:38,000 --> 00:43:39,000
只用两个字节

1157
00:43:40,000 --> 00:43:40,000
来处理

1158
00:43:41,000 --> 00:43:43,000
这个就可能应对绝大部分的所谓的

1159
00:43:44,000 --> 00:43:50,000
主流的文本因为在那个时代能够用到计算机进行文本处理的也就是什么一些发达国家呀大国

1160
00:43:50,000 --> 00:43:51,000
这种小国那种

1161
00:43:52,000 --> 00:43:53,000
非常不起眼的文字就已经

1162
00:43:54,000 --> 00:43:55,000
无暇顾及也无所谓的

1163
00:43:56,000 --> 00:43:59,000
我觉得那个时候还是主要为了应对东亚语言

1164
00:43:59,000 --> 00:44:00,000
对啊

1165
00:44:00,000 --> 00:44:01,000
刚需吗

1166
00:44:02,000 --> 00:44:03,000
东亚市场

1167
00:44:03,000 --> 00:44:05,000
振兴得非常快然后微软

1168
00:44:06,000 --> 00:44:09,000
切入这个市场就不得不采用了这么一个

1169
00:44:10,000 --> 00:44:13,000
也是一个比较临时的方式但是

1170
00:44:13,000 --> 00:44:17,000
那个时候做出的技术选择对我们今天来说其实影响非常深

1171
00:44:17,000 --> 00:44:20,000
UTF 如此愚蠢的东西真的

1172
00:44:21,000 --> 00:44:21,000
这是

1173
00:44:21,000 --> 00:44:23,000
温州市场又有一个痛点

1174
00:44:23,000 --> 00:44:24,000
并不得不认

1175
00:44:24,000 --> 00:44:25,000
没错

1176
00:44:26,000 --> 00:44:30,000
我当时在我的我的个笔记里面有有写到过至少是在

1177
00:44:30,000 --> 00:44:32,000
我想想应该是在

1178
00:44:32,000 --> 00:44:34,000
温州门替的内核是莫的是这个

1179
00:44:35,000 --> 00:44:37,000
也不是这个不是 UTF-16 它是叫 UCS 2

1180
00:44:38,000 --> 00:44:39,000
这么一个方式来的

1181
00:44:40,000 --> 00:44:42,000
就是 UTF-16 其实是 UCS 2 就是刚才那种

1182
00:44:42,000 --> 00:44:45,000
就是所有东西都是两个字节的没有没有额外的情况

1183
00:44:45,000 --> 00:44:48,000
GTF-16 是这个 UCS 2

1184
00:44:48,000 --> 00:44:49,000
在加了刚才我讲那个

1185
00:44:50,000 --> 00:44:50,000
那个叫什么

1186
00:44:50,000 --> 00:44:53,000
Server-Gate pair 的方法去编码超过那种

1187
00:44:54,000 --> 00:44:55,000
就是超过那个

1188
00:44:55,000 --> 00:44:56,000
就是 OXF

1189
00:44:57,000 --> 00:45:00,000
4 个 F 这么一个段的更高的点位的那些字

1190
00:45:00,000 --> 00:45:01,000
对吧

1191
00:45:01,000 --> 00:45:04,000
但其实就是 UCS 2 这种方式在很多这种

1192
00:45:04,000 --> 00:45:06,000
超系统里面也好

1193
00:45:06,000 --> 00:45:08,000
包括那个 NT 的那个

1194
00:45:08,000 --> 00:45:10,000
我记得 NT 的那个默认的

1195
00:45:11,000 --> 00:45:12,000
文件路径

1196
00:45:12,000 --> 00:45:14,000
是用 UCS 2 来实现的

1197
00:45:14,000 --> 00:45:16,000
然后像那个 Java 是 1.

1198
00:45:17,000 --> 00:45:18,000
几吧到 1.

1199
00:45:19,000 --> 00:45:19,000
5 之前

1200
00:45:19,000 --> 00:45:21,000
1.6 之前都是用的这个

1201
00:45:22,000 --> 00:45:23,000
UCS 的方法

1202
00:45:23,000 --> 00:45:25,000
到 Java 1.6

1203
00:45:26,000 --> 00:45:28,000
应该是还是 Java 5

1204
00:45:28,000 --> 00:45:29,000
Java 1.2

1205
00:45:29,000 --> 00:45:30,000
一直到 1.6 之前应该都是这样

1206
00:45:31,000 --> 00:45:32,000
1.7 后面我不知道怎么办

1207
00:45:33,000 --> 00:45:35,000
反正它在换 UTF-16 嘛

1208
00:45:35,000 --> 00:45:37,000
它就可以用那个 Server-Gate pair 的方法来实现

1209
00:45:37,000 --> 00:45:38,000
然后 Python 也是

1210
00:45:38,000 --> 00:45:39,000
Python 2

1211
00:45:40,000 --> 00:45:41,000
2.2.不管什么

1212
00:45:41,000 --> 00:45:42,000
全部都是用的这个 UCS 2

1213
00:45:43,000 --> 00:45:45,000
UCS 2 或者 UCS 4 的方法来表达

1214
00:45:46,000 --> 00:45:46,000
Unicode

1215
00:45:46,000 --> 00:45:48,000
就它连那个 UTF-16 都没有

1216
00:45:49,000 --> 00:45:49,000
对

1217
00:45:49,000 --> 00:45:51,000
所以其实你会看到这种

1218
00:45:52,000 --> 00:45:55,000
编码的选择对后市的影响还是非常深远的

1219
00:45:55,000 --> 00:45:57,000
但我们日常可能觉得

1220
00:45:57,000 --> 00:45:58,000
我怎么没有遇到

1221
00:45:58,000 --> 00:45:59,000
那是因为你出的文本

1222
00:46:00,000 --> 00:46:02,000
还不够不足以

1223
00:46:02,000 --> 00:46:03,000
不够奇怪

1224
00:46:03,000 --> 00:46:04,000
没有用过 Windows 的

1225
00:46:04,000 --> 00:46:07,000
和字符串相关的一些 API

1226
00:46:07,000 --> 00:46:09,000
这些 API 每一个都有两个版本

1227
00:46:10,000 --> 00:46:12,000
一个是 A 版本一个是 W 版本

1228
00:46:12,000 --> 00:46:14,000
A 代表说它可以处理 ASCII 编码

1229
00:46:15,000 --> 00:46:18,000
W 版本说它可以处理这种所谓宽字节的

1230
00:46:18,000 --> 00:46:19,000
WideCat

1231
00:46:19,000 --> 00:46:21,000
这是一个

1232
00:46:21,000 --> 00:46:22,000
Giant 我的 fuck

1233
00:46:23,000 --> 00:46:23,000
但是

1234
00:46:24,000 --> 00:46:25,000
有什么办法呢

1235
00:46:25,000 --> 00:46:26,000
谁叫人家商业上成功呢

1236
00:46:27,000 --> 00:46:29,000
这是 legacy

1237
00:46:29,000 --> 00:46:30,000
所以其实

1238
00:46:31,000 --> 00:46:33,000
我们要往 Future compatible 方法的话

1239
00:46:33,000 --> 00:46:35,000
大家还是尽量使用 UTF-8 这种

1240
00:46:36,000 --> 00:46:38,000
比较通用的方式来实现表达

1241
00:46:38,000 --> 00:46:39,000
虽然说可能

1242
00:46:39,000 --> 00:46:42,000
UTF-8 我觉得很多人反对它的都是一个效率的原因

1243
00:46:42,000 --> 00:46:43,000
它不是定长的嘛对吧

1244
00:46:44,000 --> 00:46:45,000
它要是一个变长的

1245
00:46:45,000 --> 00:46:47,000
处理起来效率可能会比较低

1246
00:46:48,000 --> 00:46:49,000
但我觉得在现代的这种

1247
00:46:49,000 --> 00:46:50,000
计算机的

1248
00:46:50,000 --> 00:46:52,000
处理器的形态说这点完全不是问题

1249
00:46:52,000 --> 00:46:53,000
而且

1250
00:46:53,000 --> 00:46:55,000
还有一个抱怨就是 UTF-8

1251
00:46:55,000 --> 00:46:56,000
因为它的编码方式的原因

1252
00:46:57,000 --> 00:46:57,000
它的这个

1253
00:46:58,000 --> 00:47:00,000
编码非 ASCII 的时候的效率不高

1254
00:47:01,000 --> 00:47:03,000
特别是编码东亚文字的时候可能效率比较低

1255
00:47:03,000 --> 00:47:04,000
对 经常需要 3 到 4 个字节

1256
00:47:05,000 --> 00:47:05,000
没错

1257
00:47:06,000 --> 00:47:07,000
就越冷 P 的那些字节

1258
00:47:08,000 --> 00:47:09,000
那些字符可能需要的字节数越多

1259
00:47:10,000 --> 00:47:11,000
但是其实

1260
00:47:12,000 --> 00:47:13,000
现在不是有压缩吗对吧

1261
00:47:13,000 --> 00:47:14,000
这种东西

1262
00:47:14,000 --> 00:47:19,000
我觉得问题并不大而且就是用 GZip 流失压缩的话

1263
00:47:19,000 --> 00:47:20,000
你在

1264
00:47:20,000 --> 00:47:21,000
一台正常的

1265
00:47:21,000 --> 00:47:23,000
现代的计算机上根本感觉不到这种

1266
00:47:23,000 --> 00:47:25,000
性能的差异所以我觉得

1267
00:47:26,000 --> 00:47:26,000
还是为了

1268
00:47:27,000 --> 00:47:28,000
处理方便起见

1269
00:47:28,000 --> 00:47:30,000
尽量采用这种方式实现吧

1270
00:47:30,000 --> 00:47:30,000
没错

1271
00:47:31,000 --> 00:47:32,000
但是我不知道你

1272
00:47:32,000 --> 00:47:36,000
了不到这个情况国内很多这种网站还是

1273
00:47:36,000 --> 00:47:38,000
直到现在都是 GB 对吧

1274
00:47:39,000 --> 00:47:43,000
好吧那个我们下个环节有什么

1275
00:47:43,000 --> 00:47:45,000
这个这周有什么小新闻吗

1276
00:47:45,000 --> 00:47:47,000
这一个月有什么小新闻

1277
00:47:48,000 --> 00:47:48,000
哈哈哈

1278
00:47:49,000 --> 00:47:51,000
我现在和 Rail 已经阔别四周了

1279
00:47:52,000 --> 00:47:55,000
两周一期的节目如果 miss 掉一期就是一个月

1280
00:47:57,000 --> 00:47:58,000
再四周五周一下就是半年

1281
00:47:59,000 --> 00:48:00,000
没错

1282
00:48:02,000 --> 00:48:03,000
一期不见如鸽半年

1283
00:48:06,000 --> 00:48:08,000
其实也没有什么

1284
00:48:08,000 --> 00:48:09,000
太

1285
00:48:09,000 --> 00:48:13,000
特别的新闻然后我最近比较忙没有怎么看新闻唯一值得

1286
00:48:14,000 --> 00:48:15,000
提起或者唯一

1287
00:48:15,000 --> 00:48:18,000
我知道你肯定会感兴趣的东西就是

1288
00:48:19,000 --> 00:48:21,000
前两天刚刚结束的

1289
00:48:23,000 --> 00:48:26,000
还没有结束吧现在还在进行中

1290
00:48:26,000 --> 00:48:26,000
Exactly

1291
00:48:27,000 --> 00:48:30,000
我只是想到如果这一期节目上线的时候也许

1292
00:48:31,000 --> 00:48:33,000
对没就但我们在录制的时候

1293
00:48:33,000 --> 00:48:36,000
WC 其实才开到第

1294
00:48:36,000 --> 00:48:37,000
三天

1295
00:48:38,000 --> 00:48:40,000
一下子暴露了录制的这期

1296
00:48:41,000 --> 00:48:42,000
没关系这个

1297
00:48:42,000 --> 00:48:42,000
又不是什么

1298
00:48:43,000 --> 00:48:44,000
行业机密

1299
00:48:45,000 --> 00:48:48,000
所以其实现在你的表也拿到了对吧

1300
00:48:49,000 --> 00:48:49,000
对

1301
00:48:50,000 --> 00:48:51,000
你买了一款什么表

1302
00:48:51,000 --> 00:48:55,000
女朋友给我买的那个 42 毫米的

1303
00:48:56,000 --> 00:48:58,000
是 sport 还是钢的

1304
00:48:58,000 --> 00:49:01,000
高档然后呢什么袋子

1305
00:49:02,000 --> 00:49:03,000
就最普通的黑色的

1306
00:49:04,000 --> 00:49:07,000
是那个皮带那一款吗

1307
00:49:07,000 --> 00:49:09,000
不是皮带吧硅胶应该是

1308
00:49:10,000 --> 00:49:12,000
钢袋是默认陪硅胶的吗

1309
00:49:12,000 --> 00:49:15,000
钢也是默认陪硅胶那个不叫硅胶

1310
00:49:15,000 --> 00:49:15,000
那个叫

1311
00:49:16,000 --> 00:49:17,000
想想什么那个

1312
00:49:17,000 --> 00:49:19,000
Fluorastoma

1313
00:49:19,000 --> 00:49:23,000
终于想起他叫他终于就在他念什么了

1314
00:49:25,000 --> 00:49:27,000
你觉得那个手感怎么样那个袋子

1315
00:49:29,000 --> 00:49:30,000
还 OK 吧

1316
00:49:30,000 --> 00:49:31,000
还 OK 啊

1317
00:49:31,000 --> 00:49:34,000
我也不知道因为我从来不带表

1318
00:49:34,000 --> 00:49:35,000
不是

1319
00:49:35,000 --> 00:49:39,000
实话说穷玩车富玩表嘛我肯定是不是玩表那一期

1320
00:49:39,000 --> 00:49:41,000
所以我也说不上来

1321
00:49:41,000 --> 00:49:44,000
而且我有一件很惨痛的事情就是我在

1322
00:49:45,000 --> 00:49:48,000
初中的时候有一天看到那个

1323
00:49:49,000 --> 00:49:53,000
地摊上卖的漂亮的塑料电子角非常高兴

1324
00:49:54,000 --> 00:49:55,000
买了一块

1325
00:49:55,000 --> 00:49:56,000
然后从那个

1326
00:49:56,000 --> 00:49:59,000
那个那个塑料电子角的后盖是镀镍

1327
00:50:00,000 --> 00:50:04,000
然后从那天开始我对镍产生了过敏

1328
00:50:06,000 --> 00:50:08,000
真的有金属过敏

1329
00:50:08,000 --> 00:50:11,000
任何活泼金属戴到我手上都会立刻起包

1330
00:50:13,000 --> 00:50:15,000
这是什么原理到底

1331
00:50:15,000 --> 00:50:18,000
我就是对活泼金属过敏

1332
00:50:18,000 --> 00:50:19,000
对贵重金属过敏

1333
00:50:19,000 --> 00:50:22,000
比较比较比较惰性一点的金属就没问题

1334
00:50:22,000 --> 00:50:23,000
什么铝啊

1335
00:50:23,000 --> 00:50:26,000
所以你是暗示我们给你买个金表

1336
00:50:27,000 --> 00:50:27,000
对

1337
00:50:28,000 --> 00:50:29,000
给我买个金表吧

1338
00:50:29,000 --> 00:50:30,000
不过还是现在我们的商号

1339
00:50:31,000 --> 00:50:32,000
所以你连铝的都不能戴

1340
00:50:33,000 --> 00:50:33,000
铝的应该可以

1341
00:50:34,000 --> 00:50:37,000
铝会被氧化嘛对吧

1342
00:50:38,000 --> 00:50:40,000
你说活泼金属怎么定义

1343
00:50:41,000 --> 00:50:43,000
活泼金属是镍啊

1344
00:50:43,000 --> 00:50:45,000
铬啊

1345
00:50:45,000 --> 00:50:47,000
猛啊

1346
00:50:47,000 --> 00:50:48,000
主要是镍其实

1347
00:50:48,000 --> 00:50:49,000
我相信

1348
00:50:49,000 --> 00:50:51,000
我之前查过因为德国也有很多人

1349
00:50:52,000 --> 00:50:55,000
主要是镍这种东西

1350
00:50:56,000 --> 00:50:59,000
因为我想如果你对铝过敏的话那你还用得了 iPhone

1351
00:50:59,000 --> 00:51:00,000
不行啊肯定不行

1352
00:51:01,000 --> 00:51:03,000
我连铝锅都端不了是吧

1353
00:51:06,000 --> 00:51:08,000
好吧所以那个

1354
00:51:09,000 --> 00:51:10,000
就是体验上我觉得可能

1355
00:51:11,000 --> 00:51:12,000
不我的意思就是我

1356
00:51:13,000 --> 00:51:15,000
这么大以来这是第一次正儿八经的每天都代表

1357
00:51:16,000 --> 00:51:17,000
当然我之前有一块那个

1358
00:51:19,000 --> 00:51:20,000
德国那个叫什么

1359
00:51:20,000 --> 00:51:21,000
Browl

1360
00:51:21,000 --> 00:51:22,000
就是博朗的那个

1361
00:51:23,000 --> 00:51:24,000
复刻版的

1362
00:51:25,000 --> 00:51:26,000
最普通的电子表

1363
00:51:26,000 --> 00:51:27,000
就是看起来和 iPhone

1364
00:51:27,000 --> 00:51:29,000
看起来和 iPhone 神似

1365
00:51:30,000 --> 00:51:31,000
只不过那个是正儿八经的

1366
00:51:31,000 --> 00:51:33,000
只能显示六个数字这样

1367
00:51:34,000 --> 00:51:35,000
非常古老的

1368
00:51:36,000 --> 00:51:38,000
所以你戴了多久了拿到

1369
00:51:39,000 --> 00:51:39,000
不到

1370
00:51:39,000 --> 00:51:41,000
那一个月了差不多

1371
00:51:41,000 --> 00:51:42,000
OK 所以感觉如何

1372
00:51:44,000 --> 00:51:47,000
但就只是一块表而已吧

1373
00:51:47,000 --> 00:51:48,000
我觉得

1374
00:51:48,000 --> 00:51:49,000
不不不你就上面那些

1375
00:51:49,000 --> 00:51:51,000
那些软件啊那种各种

1376
00:51:51,000 --> 00:51:52,000
Watch extension 啊

1377
00:51:53,000 --> 00:51:53,000
你觉得好用啊

1378
00:51:53,000 --> 00:51:56,000
实用性并不太高

1379
00:51:56,000 --> 00:51:56,000
必须说

1380
00:51:57,000 --> 00:51:58,000
对我觉得

1381
00:51:58,000 --> 00:52:00,000
主要原因就是因为他太慢了

1382
00:52:00,000 --> 00:52:03,000
我今天很久的状况我点那个

1383
00:52:04,000 --> 00:52:05,000
Glass 出来一个比如说

1384
00:52:05,000 --> 00:52:08,000
地图吧上次做我跟在 iPhone 吐槽最久的

1385
00:52:08,000 --> 00:52:10,000
我等 10 秒我有那个功夫

1386
00:52:10,000 --> 00:52:12,000
屏幕已经黑了他还没有漏出来对吧

1387
00:52:12,000 --> 00:52:15,000
对啊我等那个功夫出来我都直接手机看了好吧

1388
00:52:15,000 --> 00:52:18,000
Somehow someway 我发现这个是就是你用一段时间

1389
00:52:18,000 --> 00:52:20,000
他就会变快的

1390
00:52:21,000 --> 00:52:27,000
我不知道这是我的错觉还是怎么样就是一开始一周我也有这样的状况但是后来就真的还好

1391
00:52:29,000 --> 00:52:33,000
所以我一直在今天我在那个推荐跟他们讨论吗

1392
00:52:33,000 --> 00:52:33,000
就说

1393
00:52:34,000 --> 00:52:35,000
就他们在说

1394
00:52:35,000 --> 00:52:38,000
也不是不是刚好大陆地上说了那个 WatchOS 2

1395
00:52:39,000 --> 00:52:40,000
他会出那个原生的 SDK 吗

1396
00:52:41,000 --> 00:52:42,000
可以直接跑在

1397
00:52:42,000 --> 00:52:42,000
Watch 上面

1398
00:52:43,000 --> 00:52:43,000
之前的话

1399
00:52:43,000 --> 00:52:45,000
那个其实所有的那个 watchapp

1400
00:52:46,000 --> 00:52:46,000
都只是一个

1401
00:52:46,000 --> 00:52:48,000
远程桌面

1402
00:52:48,000 --> 00:52:49,000
差不多这个意思

1403
00:52:50,000 --> 00:52:51,000
你是显示

1404
00:52:51,000 --> 00:52:54,000
在手表上但是那个整个逻辑是跑在手机上面的通过蓝牙来通讯

1405
00:52:55,000 --> 00:52:55,000
对

1406
00:52:55,000 --> 00:52:56,000
这是

1407
00:52:57,000 --> 00:53:00,000
这是一个物理世界里的 MVC 风格

1408
00:53:01,000 --> 00:53:04,000
MVC 跑在你的裤兜里然后

1409
00:53:04,000 --> 00:53:05,000
V 在那个手腕上

1410
00:53:07,000 --> 00:53:09,000
那这个就是一个问题就是说挺费电而且挺

1411
00:53:09,000 --> 00:53:11,000
但慢到你讲了就是一个很

1412
00:53:11,000 --> 00:53:14,000
大的问题就是蓝牙通讯的时候

1413
00:53:14,000 --> 00:53:16,000
手机的 CPU 和表的 CPU 都不能使用

1414
00:53:17,000 --> 00:53:18,000
表的屏幕还是亮着的嘛

1415
00:53:19,000 --> 00:53:20,000
你的等于是看着它对吧

1416
00:53:21,000 --> 00:53:22,000
这样其实对

1417
00:53:22,000 --> 00:53:24,000
两边的电池续航时间都会有影响

1418
00:53:24,000 --> 00:53:27,000
其实反而你是跑在这个表上原生的一个 SDK 的话反而

1419
00:53:27,000 --> 00:53:28,000
要好一些

1420
00:53:29,000 --> 00:53:30,000
要好一些因为它可以

1421
00:53:30,000 --> 00:53:30,000
快速的玩

1422
00:53:31,000 --> 00:53:32,000
因为现在 CPU 其实是很快的

1423
00:53:32,000 --> 00:53:34,000
那个 watch 里面他们说的是

1424
00:53:34,000 --> 00:53:36,000
应该是就是 A 5 的那个架构

1425
00:53:36,000 --> 00:53:37,000
做小的然后放进去的

1426
00:53:37,000 --> 00:53:38,000
然后那个

1427
00:53:39,000 --> 00:53:40,000
计算是非常快的

1428
00:53:40,000 --> 00:53:42,000
Performance 不是说只有 A 4 的级别吗

1429
00:53:43,000 --> 00:53:45,000
A 5 我当时比较清楚记得是 A 5

1430
00:53:45,000 --> 00:53:48,000
因为现在 A 5 是在苹果大多数的

1431
00:53:48,000 --> 00:53:52,000
未升级的老旧设备里面大量存在的比如说那个 iPad

1432
00:53:52,000 --> 00:53:54,000
2

1433
00:53:54,000 --> 00:53:55,000
还没有在卖的吧还在卖

1434
00:53:56,000 --> 00:53:59,000
然后 iPad mini

1435
00:53:59,000 --> 00:54:01,000
然后那个 Apple touch

1436
00:54:02,000 --> 00:54:04,000
就这个都在用 A 5 还有那个 Apple TV

1437
00:54:04,000 --> 00:54:05,000
都是 A 5 处理器

1438
00:54:06,000 --> 00:54:07,000
反正

1439
00:54:07,000 --> 00:54:10,000
用到现在我的感觉就是

1440
00:54:12,000 --> 00:54:15,000
有一些 App 我觉得自己可能会用到比如说

1441
00:54:16,000 --> 00:54:19,000
德铁的 App 就是它会告诉你说下一班火车还有几点来

1442
00:54:19,000 --> 00:54:24,000
下一班火车现在在哪然后你需要去哪个站台

1443
00:54:24,000 --> 00:54:26,000
但是

1444
00:54:26,000 --> 00:54:28,000
从来没有机会用到

1445
00:54:28,000 --> 00:54:29,000
然后

1446
00:54:29,000 --> 00:54:31,000
最实用的功能就是

1447
00:54:32,000 --> 00:54:32,000
有

1448
00:54:33,000 --> 00:54:37,000
或者说最常用的功能就是有邮件来的时候抬手看一下这邮件值不值得看

1449
00:54:38,000 --> 00:54:39,000
如果值得看的话就

1450
00:54:40,000 --> 00:54:42,000
切换到手机或者电脑上去看

1451
00:54:42,000 --> 00:54:43,000
然后

1452
00:54:44,000 --> 00:54:45,000
再就是回软件

1453
00:54:46,000 --> 00:54:47,000
然后就是它我觉得

1454
00:54:47,000 --> 00:54:54,000
让我最气筋让我最舒服或者说让我最意外的一点就是它的语音识别准确率非常非常高

1455
00:54:55,000 --> 00:54:57,000
对比 iPhone 上的还高

1456
00:54:58,000 --> 00:55:01,000
而且很神奇的是我的手表的系统语言是英语

1457
00:55:02,000 --> 00:55:03,000
手机的系统语言是德语

1458
00:55:03,000 --> 00:55:05,000
然后

1459
00:55:05,000 --> 00:55:06,000
我用中文说话

1460
00:55:07,000 --> 00:55:10,000
他可以准确的把我说的话识别为中文即便对方给我发的是英文

1461
00:55:11,000 --> 00:55:15,000
没错没错我也觉得这个事情超神奇我不知道他怎么做到的

1462
00:55:15,000 --> 00:55:19,000
我现在没法重现那个事情了我不知道怎么弄

1463
00:55:19,000 --> 00:55:20,000
什么意思

1464
00:55:21,000 --> 00:55:22,000
就是我现在又只能输入英文了

1465
00:55:23,000 --> 00:55:23,000
就是语音输入

1466
00:55:24,000 --> 00:55:25,000
就很奇怪啊

1467
00:55:25,000 --> 00:55:26,000
之前我刚来的时候

1468
00:55:27,000 --> 00:55:32,000
是又有一段时间是用就是你说那种语言是英文吗

1469
00:55:32,000 --> 00:55:35,000
然后回复的时候是说中文他竟然能听出来是中文然后给我出中文的字

1470
00:55:36,000 --> 00:55:39,000
但是自从升那个 1.0.1 之后发现又不行了

1471
00:55:39,000 --> 00:55:44,000
这个太奇怪了我一直都可以而且他很神奇的就是我说奥迪

1472
00:55:45,000 --> 00:55:45,000
我说奥迪

1473
00:55:46,000 --> 00:55:47,000
他会帮我

1474
00:55:48,000 --> 00:55:49,000
转成奥迪

1475
00:55:49,000 --> 00:55:51,000
然后这四个

1476
00:55:51,000 --> 00:55:52,000
拉丁字母加在中文里面

1477
00:55:53,000 --> 00:55:56,000
所以我的猜想是这样子就是说他

1478
00:55:56,000 --> 00:55:59,000
为了因为那个手表上的输入比较受限了

1479
00:55:59,000 --> 00:56:05,000
他肯他苹果肯定在后台上对这个事情做了一个什么特殊的处理就是后台上放一个人在那听

1480
00:56:08,000 --> 00:56:09,000
顾了 100 万个印度人

1481
00:56:10,000 --> 00:56:12,000
这不是那个什么那个

1482
00:56:12,000 --> 00:56:14,000
Silicon Valley 里面那一期黑他们的

1483
00:56:14,000 --> 00:56:15,000
用的事情吗

1484
00:56:15,000 --> 00:56:16,000
对

1485
00:56:18,000 --> 00:56:20,000
我觉得他可能是用了一个更加

1486
00:56:20,000 --> 00:56:25,000
费劲的方式去处理这个 Siri 的语音输入就包括这个多语言识别啊

1487
00:56:25,000 --> 00:56:27,000
还有这个准确度上是有很大的提升的吗

1488
00:56:27,000 --> 00:56:30,000
相比于那个 iPhone 上面那个 Siri 来讲

1489
00:56:30,000 --> 00:56:31,000
对

1490
00:56:31,000 --> 00:56:34,000
感觉这样成本应该是服务器成本是蛮高的

1491
00:56:36,000 --> 00:56:39,000
所以其实你看你用的那几个都是所有的原生的

1492
00:56:40,000 --> 00:56:42,000
你没有用第就是第 3 方的 app

1493
00:56:43,000 --> 00:56:44,000
那个体验都不太好吧

1494
00:56:44,000 --> 00:56:46,000
也还可以吧

1495
00:56:47,000 --> 00:56:49,000
我最有用哪个第 3 方的体验比较

1496
00:56:49,000 --> 00:56:50,000
还比较流畅的吗

1497
00:56:50,000 --> 00:56:51,000
我猜不

1498
00:56:51,000 --> 00:56:52,000
我猜不可以

1499
00:56:53,000 --> 00:56:55,000
通讯里的对还行

1500
00:56:56,000 --> 00:56:57,000
然后 gmail 其实也还可以

1501
00:56:57,000 --> 00:56:58,000
就是

1502
00:56:59,000 --> 00:57:02,000
Gmail 有 watch 的扩展

1503
00:57:02,000 --> 00:57:07,000
他没有直接过去扩展但是他可以把 message 送到 watch

1504
00:57:08,000 --> 00:57:09,000
这个还不错

1505
00:57:10,000 --> 00:57:12,000
然后我还用其他比如说

1506
00:57:12,000 --> 00:57:13,000
Instagram 也还 ok 了

1507
00:57:13,000 --> 00:57:14,000
然后有一个

1508
00:57:15,000 --> 00:57:15,000
德国的

1509
00:57:16,000 --> 00:57:17,000
天气网站

1510
00:57:17,000 --> 00:57:18,000
也还挺好的

1511
00:57:18,000 --> 00:57:19,000
然后

1512
00:57:20,000 --> 00:57:20,000
对反正

1513
00:57:21,000 --> 00:57:22,000
还比如说那个

1514
00:57:23,000 --> 00:57:24,000
叫什么

1515
00:57:24,000 --> 00:57:25,000
Clear

1516
00:57:25,000 --> 00:57:27,000
就是那个 todo list clear

1517
00:57:27,000 --> 00:57:28,000
也不错

1518
00:57:28,000 --> 00:57:30,000
然后在 Lufthansa 的汉商航空也还 ok

1519
00:57:31,000 --> 00:57:34,000
就做的好的第 3 方 app 还是有的

1520
00:57:34,000 --> 00:57:36,000
但总体来说

1521
00:57:39,000 --> 00:57:40,000
就还好

1522
00:57:42,000 --> 00:57:43,000
这不是一块

1523
00:57:43,000 --> 00:57:44,000
这不是一个像 iPad 的

1524
00:57:45,000 --> 00:57:47,000
就是我在拿到 iPad 的第 2 天我说

1525
00:57:47,000 --> 00:57:48,000
我靠

1526
00:57:48,000 --> 00:57:49,000
我的后半生离不开这个东西

1527
00:57:50,000 --> 00:57:51,000
Apple watch 没有给我这样的感觉

1528
00:57:53,000 --> 00:57:54,000
就是一个

1529
00:57:55,000 --> 00:57:56,000
可有可无的产品吧

1530
00:57:56,000 --> 00:57:57,000
这样说

1531
00:57:58,000 --> 00:57:58,000
准确吗

1532
00:57:58,000 --> 00:58:00,000
Nice to have 的产品

1533
00:58:01,000 --> 00:58:02,000
没有也无所谓

1534
00:58:02,000 --> 00:58:04,000
有的当然更好了

1535
00:58:04,000 --> 00:58:07,000
还没有出现什么 Tiller feature

1536
00:58:08,000 --> 00:58:11,000
但我觉得 Killer feature 早晚会出现

1537
00:58:11,000 --> 00:58:14,000
等他那个原生的 SDK 出来之后

1538
00:58:15,000 --> 00:58:15,000
现在是什么情况

1539
00:58:16,000 --> 00:58:16,000
就是说是

1540
00:58:17,000 --> 00:58:17,000
可以

1541
00:58:18,000 --> 00:58:21,000
开发者可以马上你已经可以拿到这个 SDK 来测试了吗

1542
00:58:21,000 --> 00:58:25,000
应该是我昨天下了那个

1543
00:58:25,000 --> 00:58:28,000
我昨天重新激活了我的 Apple developer 账户

1544
00:58:29,000 --> 00:58:30,000
扔了 100 欧元进去

1545
00:58:30,000 --> 00:58:36,000
因为我之前在公司就是在我前公司里面有一个那个

1546
00:58:36,000 --> 00:58:37,000
Enterprise program

1547
00:58:38,000 --> 00:58:40,000
然后我就把个人的退了

1548
00:58:40,000 --> 00:58:44,000
然后离职之后反正一直没碰就一直没重新

1549
00:58:45,000 --> 00:58:46,000
然后直到昨天再重新续

1550
00:58:47,000 --> 00:58:48,000
续上之后又把那个

1551
00:58:49,000 --> 00:58:51,000
把新的

1552
00:58:51,000 --> 00:58:53,000
现在有两个版本的

1553
00:58:53,000 --> 00:58:55,000
Xcode beta

1554
00:58:55,000 --> 00:58:57,000
一个是 Xcode 7.0 的 Beta

1555
00:58:57,000 --> 00:58:59,000
另一个是 Xcode 6.4 的 Beta

1556
00:58:59,000 --> 00:59:02,000
然后 7.0 的 Beta 里面已经包含了

1557
00:59:02,000 --> 00:59:05,000
如果没理解错的话应该已经包含了 WatchOS 2.0

1558
00:59:06,000 --> 00:59:07,000
然后

1559
00:59:08,000 --> 00:59:10,000
愿意的话可以去摆弄摆弄试试

1560
00:59:10,000 --> 00:59:13,000
我反正今天做完节目之后应该就会摆弄摆弄试试

1561
00:59:14,000 --> 00:59:16,000
所以你体验一下到底能做出一个

1562
00:59:17,000 --> 00:59:19,000
这都是什么样一个画来然后看看

1563
00:59:19,000 --> 00:59:20,000
有什么

1564
00:59:20,000 --> 00:59:21,000
提升体验上的

1565
00:59:21,000 --> 00:59:22,000
提升了我觉得

1566
00:59:22,000 --> 00:59:23,000
就如果

1567
00:59:23,000 --> 00:59:26,000
能原生在表上跑然后那个响应速度

1568
00:59:26,000 --> 00:59:28,000
能到原生那些 app 的

1569
00:59:28,000 --> 00:59:30,000
层次的话我觉得

1570
00:59:30,000 --> 00:59:32,000
整个体验会好很多但现在确实

1571
00:59:33,000 --> 00:59:34,000
太糟糕了

1572
00:59:34,000 --> 00:59:35,000
嗯

1573
00:59:35,000 --> 00:59:37,000
我觉得就是 somehow someway 我觉得这个

1574
00:59:38,000 --> 00:59:41,000
Apple Watch 其实可以拿来做很多

1575
00:59:42,000 --> 00:59:44,000
不需要那个显示屏的事情

1576
00:59:44,000 --> 00:59:45,000
就是

1577
00:59:46,000 --> 00:59:46,000
比如说

1578
00:59:47,000 --> 00:59:48,000
就是在

1579
00:59:49,000 --> 00:59:49,000
中国应该是

1580
00:59:51,000 --> 00:59:51,000
汉朝的时候

1581
00:59:52,000 --> 00:59:54,000
商人们有一种

1582
00:59:54,000 --> 00:59:57,000
秀礼术就是他们

1583
00:59:57,000 --> 01:00:02,000
看了一个商品然后两个人要交易的时候他们会把那个很长的袖子

1584
01:00:02,000 --> 01:00:04,000
套在彼此的手上

1585
01:00:04,000 --> 01:00:05,000
然后按对方的手

1586
01:00:06,000 --> 01:00:08,000
然后按对方的手就可以知道对方就是

1587
01:00:08,000 --> 01:00:09,000
要出什么价

1588
01:00:09,000 --> 01:00:14,000
你按对方手指的某一个部分对方就明白了你要出多少钱然后对方可以

1589
01:00:15,000 --> 01:00:15,000
按回来还价

1590
01:00:16,000 --> 01:00:18,000
我觉得 Apple Watch 可以做类似的事情

1591
01:00:18,000 --> 01:00:19,000
比如说

1592
01:00:20,000 --> 01:00:21,000
我把手背到后面然后

1593
01:00:21,000 --> 01:00:24,000
以某种特定的频率晃这块表

1594
01:00:24,000 --> 01:00:28,000
然后这块表就可以在别人手腕上产生某种特定的信号

1595
01:00:30,000 --> 01:00:31,000
这样就可以

1596
01:00:31,000 --> 01:00:35,000
不用啊你现在不是就直接那个在表盘上画那个小花吗

1597
01:00:35,000 --> 01:00:38,000
但此时旁边看你表盘的人是看得到的呀

1598
01:00:39,000 --> 01:00:42,000
啊你要有一个秘密的手持

1599
01:00:42,000 --> 01:00:43,000
你要有一个

1600
01:00:43,000 --> 01:00:43,000
别人

1601
01:00:44,000 --> 01:00:47,000
察觉不到的方式来彼此通讯

1602
01:00:48,000 --> 01:00:49,000
所以一个比较

1603
01:00:50,000 --> 01:00:51,000
宅比较 geek 的方式是什么

1604
01:00:52,000 --> 01:00:53,000
经常那些你看到那个

1605
01:00:54,000 --> 01:00:55,000
比如说这个

1606
01:00:55,000 --> 01:00:56,000
就是欧美的那个

1607
01:00:57,000 --> 01:01:01,000
年轻人或者说兄弟会碰头的时候会有一堆手特别的手势吗

1608
01:01:02,000 --> 01:01:03,000
对吧

1609
01:01:04,000 --> 01:01:06,000
我们以后要带着表来玩这件事情吗

1610
01:01:06,000 --> 01:01:11,000
把那个整个要记录下来要计算一下你这个是否某一个动作做标准了

1611
01:01:12,000 --> 01:01:12,000
不标准

1612
01:01:12,000 --> 01:01:13,000
不给开锁

1613
01:01:13,000 --> 01:01:14,000
或者

1614
01:01:14,000 --> 01:01:16,000
或者最简单的就是

1615
01:01:17,000 --> 01:01:21,000
直接做一个那个摩尔斯马

1616
01:01:21,000 --> 01:01:25,000
然后你敲表盘然后对方就可以收到那个

1617
01:01:25,000 --> 01:01:29,000
你敲的那个什么 taptic engine

1618
01:01:29,000 --> 01:01:31,000
直接打到手上是吧

1619
01:01:31,000 --> 01:01:32,000
对

1620
01:01:32,000 --> 01:01:34,000
通过人工的方式去读那个 code

1621
01:01:34,000 --> 01:01:42,000
然后你提供一个菜鸟模式就是对方发摩尔斯马然后你看表盘这个表盘会把对方的

1622
01:01:43,000 --> 01:01:43,000
摩尔斯马

1623
01:01:43,000 --> 01:01:44,000
翻译出来

1624
01:01:44,000 --> 01:01:46,000
然后就可以用这个 TAPTICS 来做这个

1625
01:01:47,000 --> 01:01:49,000
要不你这个第一个 watchapp 就做这个吧

1626
01:01:49,000 --> 01:01:50,000
我觉得挺有时尚的

1627
01:01:50,000 --> 01:01:51,000
可以试试做

1628
01:01:51,000 --> 01:01:53,000
感觉实现起来也比较简单

1629
01:01:53,000 --> 01:01:54,000
对

1630
01:01:56,000 --> 01:01:58,000
我前两天看那个

1631
01:01:58,000 --> 01:01:59,000
这段我们要咖掉吗

1632
01:01:59,000 --> 01:02:01,000
因为这个属于那个什么

1633
01:02:01,000 --> 01:02:02,000
product idea

1634
01:02:03,000 --> 01:02:05,000
我始终觉得 idea is cheap

1635
01:02:06,000 --> 01:02:06,000
show me the code

1636
01:02:07,000 --> 01:02:07,000
所以

1637
01:02:07,000 --> 01:02:13,000
各位听众里面如果有哪个人做出来一个欢迎你来开源然后大家可以

1638
01:02:13,000 --> 01:02:14,000
大家可以下来

1639
01:02:14,000 --> 01:02:15,000
编译一下

1640
01:02:15,000 --> 01:02:17,000
有一个新闻就是

1641
01:02:17,000 --> 01:02:19,000
有一个新闻就是现在好像 apple 可以

1642
01:02:20,000 --> 01:02:23,000
不用注册 developer 就可以把

1643
01:02:23,000 --> 01:02:25,000
程序跑在实体机器上了

1644
01:02:27,000 --> 01:02:29,000
对就是如果各位听众不知道的话就是

1645
01:02:29,000 --> 01:02:32,000
在以前你要为 iOS 开发程序

1646
01:02:32,000 --> 01:02:35,000
理论上是不需要交钱的你只需要

1647
01:02:35,000 --> 01:02:38,000
下载 Xcode 然后写一个程序然后在模拟器里面跑

1648
01:02:39,000 --> 01:02:43,000
但是如果你想要把这个 app 在你的实体机器上跑的话你必须先去注册

1649
01:02:43,000 --> 01:02:45,000
但是

1650
01:02:45,000 --> 01:02:50,000
目前看来就是如果理解的这个新闻没错的话将来你不需要

1651
01:02:50,000 --> 01:02:55,000
一个开发者账号也可以把你的 app 直接跑在你实体设备上

1652
01:02:55,000 --> 01:02:57,000
但只能是把你自己那台机器

1653
01:02:57,000 --> 01:02:58,000
应该是只能把你自己那台机器

1654
01:02:59,000 --> 01:03:02,000
那也完全够了自己玩票用

1655
01:03:02,000 --> 01:03:06,000
那种早期的 homebrew 的方式又可以流行起来的

1656
01:03:06,000 --> 01:03:12,000
你把原单法发到 github 上然后别人当下来然后编译一下就可以跑在自己的机器上

1657
01:03:12,000 --> 01:03:13,000
对这可能是

1658
01:03:14,000 --> 01:03:19,000
很多这种就是玩票他也不打算真的是放一个东西上架到 app store 里面那种

1659
01:03:19,000 --> 01:03:20,000
票友吧

1660
01:03:20,000 --> 01:03:22,000
编程票友的

1661
01:03:22,000 --> 01:03:27,000
抱怨就是我干嘛要花个每年 100 刀去买这个我一年用两次的东西对吧

1662
01:03:29,000 --> 01:03:33,000
安卓就没有这个问题插上线什么都可以装

1663
01:03:34,000 --> 01:03:39,000
对有这个我觉得还是挺好的起码我会有更多东西那我也学一下这个

1664
01:03:40,000 --> 01:03:42,000
来写一个东西来玩一下

1665
01:03:44,000 --> 01:03:46,000
但是现在到目前为止我们对这个

1666
01:03:46,000 --> 01:03:47,000
对这个表的那个

1667
01:03:47,000 --> 01:03:48,000
物理的

1668
01:03:49,000 --> 01:03:50,000
就是 spec

1669
01:03:51,000 --> 01:03:53,000
硬件参数是还不太清楚的是吧

1670
01:03:53,000 --> 01:03:57,000
嗯对吧那个 chipwag 好像还没有把它

1671
01:03:57,000 --> 01:03:58,000
chipwork

1672
01:03:58,000 --> 01:03:59,000
还没有把它拆开然后

1673
01:04:00,000 --> 01:04:01,000
chipwag

1674
01:04:02,000 --> 01:04:03,000
sorry 德语翻译不出来

1675
01:04:06,000 --> 01:04:08,000
把它放在 x 光机下面

1676
01:04:09,000 --> 01:04:10,000
照一下然后

1677
01:04:10,000 --> 01:04:11,000
告诉我们上面都是什么

1678
01:04:13,000 --> 01:04:16,000
然后包括内存那内存是确定是 512

1679
01:04:18,000 --> 01:04:22,000
但是多少能给应用用多少是被那个系统占掉了

1680
01:04:22,000 --> 01:04:22,000
现在也不知道

1681
01:04:23,000 --> 01:04:26,000
刚才我们讨论的是 A 4 的芯片还是 A 5 的芯片

1682
01:04:26,000 --> 01:04:28,000
然后它做那么小到底是有多

1683
01:04:29,000 --> 01:04:30,000
就是功耗上会有多大限制

1684
01:04:30,000 --> 01:04:31,000
这都不太清楚

1685
01:04:33,000 --> 01:04:33,000
所以

1686
01:04:33,000 --> 01:04:36,000
这就靠你去研究一下这个

1687
01:04:36,000 --> 01:04:38,000
Xcode 7.0 的版本

1688
01:04:38,000 --> 01:04:40,000
能不能做出一个好玩的东西

1689
01:04:40,000 --> 01:04:42,000
好

1690
01:04:42,000 --> 01:04:43,000
快把那个摩尔斯码做出来

1691
01:04:43,000 --> 01:04:43,000
我们接下来

1692
01:04:44,000 --> 01:04:45,000
先给我装上我们先试试

1693
01:04:47,000 --> 01:04:49,000
release date

1694
01:04:49,000 --> 01:04:51,000
我还得先得学摩尔斯 code 的这个怎么办

1695
01:04:52,000 --> 01:04:53,000
这个学下来挺快

1696
01:04:54,000 --> 01:04:57,000
至少你是会两个的 S 和 O

1697
01:04:57,000 --> 01:04:59,000
SOS 就是

1698
01:05:00,000 --> 01:05:03,000
三短然后三长再三短

1699
01:05:03,000 --> 01:05:04,000
三短三长三短

1700
01:05:06,000 --> 01:05:07,000
为什么不是三长两短

1701
01:05:07,000 --> 01:05:09,000
因为 S 是三长

1702
01:05:10,000 --> 01:05:12,000
S 是三短 O 是三长

1703
01:05:12,000 --> 01:05:13,000
好吧

1704
01:05:13,000 --> 01:05:20,000
所以现在其实我们对这个原生的 OSR 的 SDK 还没有太多可以讲

1705
01:05:21,000 --> 01:05:22,000
因为现在只是公布出来

1706
01:05:22,000 --> 01:05:24,000
还没有真的去试过

1707
01:05:24,000 --> 01:05:25,000
可能以后等

1708
01:05:26,000 --> 01:05:27,000
我们的吴涛同志去试了之后

1709
01:05:28,000 --> 01:05:30,000
我们在今后的节目里面再来提一下

1710
01:05:30,000 --> 01:05:33,000
这次 WTC 上还发布了一个

1711
01:05:33,000 --> 01:05:36,000
我觉得挺开心的消息就是 Swift R

1712
01:05:36,000 --> 01:05:37,000
并且

1713
01:05:37,000 --> 01:05:38,000
它开了

1714
01:05:38,000 --> 01:05:41,000
这个是当时我也是在看电视的时候

1715
01:05:42,000 --> 01:05:43,000
我会回来看电视

1716
01:05:43,000 --> 01:05:44,000
我女朋友一边在做饭

1717
01:05:44,000 --> 01:05:45,000
然后一边在看 WTC

1718
01:05:46,000 --> 01:05:47,000
然后我看到说

1719
01:05:47,000 --> 01:05:49,000
多么温馨的一个场面

1720
01:05:49,000 --> 01:05:51,000
忽然双手举高说

1721
01:05:51,000 --> 01:05:53,000
Swift R 开源了

1722
01:05:53,000 --> 01:05:54,000
然后女朋友疑惑的问

1723
01:05:54,000 --> 01:05:55,000
那是什么意思呢

1724
01:05:56,000 --> 01:05:59,000
然后又进入了教学模式

1725
01:06:00,000 --> 01:06:02,000
多么幸福的一个场景

1726
01:06:03,000 --> 01:06:06,000
你看在听的单身狗们感受到深深的恶意没

1727
01:06:07,000 --> 01:06:10,000
我没有这个意思

1728
01:06:11,000 --> 01:06:12,000
没有

1729
01:06:13,000 --> 01:06:17,000
但他开完是说发布了这个

1730
01:06:17,000 --> 01:06:19,000
iOS OS X 和

1731
01:06:20,000 --> 01:06:21,000
Linux 的版本

1732
01:06:21,000 --> 01:06:23,000
对我觉得这个还挺

1733
01:06:23,000 --> 01:06:25,000
当时我听到 Linux 也是心里一惊

1734
01:06:26,000 --> 01:06:27,000
心里想说我靠这是

1735
01:06:29,000 --> 01:06:34,000
多久没有在 WTC 上听到 Linux 的名字了

1736
01:06:35,000 --> 01:06:35,000
而且

1737
01:06:35,000 --> 01:06:37,000
不敢相信的是

1738
01:06:37,000 --> 01:06:40,000
稍后又听到了一次 Android

1739
01:06:40,000 --> 01:06:41,000
而且是一种

1740
01:06:41,000 --> 01:06:43,000
一种正面的方式听到 Android

1741
01:06:43,000 --> 01:06:44,000
对

1742
01:06:46,000 --> 01:06:50,000
就是他在宣布那个 Apple Music 将会在 Android 上推出的时候

1743
01:06:50,000 --> 01:06:52,000
我心里还觉得

1744
01:06:53,000 --> 01:06:54,000
这是发生了什么

1745
01:06:54,000 --> 01:06:56,000
而且我跟你说那个

1746
01:06:56,000 --> 01:06:58,000
他们还出了一个 Android 的 App

1747
01:06:58,000 --> 01:06:59,000
不是音乐那个

1748
01:07:00,000 --> 01:07:00,000
叫做

1749
01:07:01,000 --> 01:07:03,000
Android Migration

1750
01:07:03,000 --> 01:07:05,000
可以从 Android 上

1751
01:07:05,000 --> 01:07:07,000
就帮助你从 Android 手机切换到 iPhone 了

1752
01:07:08,000 --> 01:07:08,000
简单来讲

1753
01:07:08,000 --> 01:07:11,000
因为 Android 是可以拿到很多系统的资料的嘛

1754
01:07:12,000 --> 01:07:12,000
对

1755
01:07:12,000 --> 01:07:15,000
所以你做了这么一个一键导入切换到那个 Apple ID 里面

1756
01:07:15,000 --> 01:07:19,000
然后直接可以帮你设置好很多东西了

1757
01:07:19,000 --> 01:07:20,000
这个还是蛮狠的

1758
01:07:21,000 --> 01:07:24,000
Mac 上面也曾经有过这个什么

1759
01:07:24,000 --> 01:07:25,000
没错可以从 Windows

1760
01:07:26,000 --> 01:07:30,000
他就把这个就是 iOS 版的那个东西了

1761
01:07:30,000 --> 01:07:31,000
OK

1762
01:07:31,000 --> 01:07:34,000
叫做 Migration Assistant 吧

1763
01:07:34,000 --> 01:07:34,000
应该是

1764
01:07:35,000 --> 01:07:36,000
我去认识一下是不是叫这个来的

1765
01:07:37,000 --> 01:07:38,000
对 Migration Assistant

1766
01:07:39,000 --> 01:07:40,000
就是这点还是蛮狠的

1767
01:07:40,000 --> 01:07:41,000
因为你知道这个东西是

1768
01:07:41,000 --> 01:07:42,000
是单向接嘛

1769
01:07:43,000 --> 01:07:44,000
对那肯定有

1770
01:07:45,000 --> 01:07:47,000
因为 iOS 里面没有

1771
01:07:47,000 --> 01:07:49,000
就除了苹果之外没有

1772
01:07:49,000 --> 01:07:52,000
哪怕苹果吧应该是不太可能拿得到

1773
01:07:52,000 --> 01:07:54,000
那些应用里面的资料就是有这个沙盒模型的限制

1774
01:07:55,000 --> 01:07:56,000
而且他把系统全线锁得很死嘛

1775
01:07:57,000 --> 01:07:57,000
你不可能做

1776
01:07:58,000 --> 01:08:00,000
就第三方向没有办法做这么一个应用

1777
01:08:00,000 --> 01:08:03,000
装到一个 iOS 里面然后再把数据导到

1778
01:08:03,000 --> 01:08:04,000
那个

1779
01:08:05,000 --> 01:08:07,000
另外的地方去但可能拿那个

1780
01:08:07,000 --> 01:08:08,000
通讯录啊这种比较

1781
01:08:08,000 --> 01:08:11,000
还有照片啊这种常见的还可以但其他的就不行

1782
01:08:12,000 --> 01:08:15,000
我不太清楚那个 Android migration 这个 app 到底能做多少的事

1783
01:08:15,000 --> 01:08:18,000
总之苹果的反正这一套东西就是

1784
01:08:18,000 --> 01:08:22,000
一堆生满稻次的丛林进去就出来

1785
01:08:22,000 --> 01:08:23,000
没错

1786
01:08:23,000 --> 01:08:25,000
那再说回那个 Swift 开源的事情

1787
01:08:26,000 --> 01:08:27,000
你觉得他们为什么会选

1788
01:08:27,000 --> 01:08:28,000
会

1789
01:08:28,000 --> 01:08:29,000
会做这件事情

1790
01:08:29,000 --> 01:08:30,000
他们的动机是什么

1791
01:08:34,000 --> 01:08:38,000
我觉得他们还是想要把 Swift 这个

1792
01:08:39,000 --> 01:08:41,000
目前看起来非常优秀的语言特性

1793
01:08:42,000 --> 01:08:44,000
尽可能的拓展开来然后

1794
01:08:44,000 --> 01:08:46,000
借此来

1795
01:08:47,000 --> 01:08:50,000
一方面是能让语言本身能够

1796
01:08:51,000 --> 01:08:52,000
心静火传下去

1797
01:08:53,000 --> 01:08:57,000
另外一方面也是希望能够借此让其他平台上的人尝一尝

1798
01:08:59,000 --> 01:09:02,000
给苹果编程是一种什么样的体验

1799
01:09:03,000 --> 01:09:09,000
没错因为以前在除非你是一个非常非常非常非常有受虐形象的人你是一般

1800
01:09:09,000 --> 01:09:10,000
不会在

1801
01:09:10,000 --> 01:09:11,000
其他

1802
01:09:11,000 --> 01:09:12,000
系统上

1803
01:09:12,000 --> 01:09:14,000
试图去搞

1804
01:09:14,000 --> 01:09:15,000
Objective-C 这套东西

1805
01:09:16,000 --> 01:09:16,000
就是你去

1806
01:09:17,000 --> 01:09:17,000
可以去

1807
01:09:18,000 --> 01:09:19,000
采用那个叫什么 OpenStep

1808
01:09:20,000 --> 01:09:21,000
这套东西来

1809
01:09:22,000 --> 01:09:24,000
在其他平台上编译 Objective-C

1810
01:09:25,000 --> 01:09:27,000
是可行的但是从来没有人这样做

1811
01:09:27,000 --> 01:09:27,000
或者说

1812
01:09:29,000 --> 01:09:32,000
这样做的人最后都把头发抓光然后出家了

1813
01:09:32,000 --> 01:09:40,000
而 Swift 二如果开源并且跨平台的话那你也许将来可以在不知不觉的在

1814
01:09:41,000 --> 01:09:47,000
Linux 上面按上这边语言然后你发现你的这个知识可以迁移到给苹果开发系统

1815
01:09:48,000 --> 01:09:49,000
给苹果开发软件

1816
01:09:50,000 --> 01:09:52,000
那也许你就会

1817
01:09:52,000 --> 01:09:53,000
随手去做一个呢

1818
01:09:53,000 --> 01:09:55,000
也许这是苹果的考量值

1819
01:09:56,000 --> 01:09:57,000
我觉得可能最

1820
01:09:58,000 --> 01:10:00,000
眼下最务实的一个事情就是说

1821
01:10:00,000 --> 01:10:07,000
很多这个 iOS 开发者他因为你知道 iOS 现在不是有个风潮吗就是说我们做一个新的产品或者

1822
01:10:07,000 --> 01:10:07,000
服务的时候

1823
01:10:08,000 --> 01:10:09,000
连网站那个都省了

1824
01:10:09,000 --> 01:10:10,000
直接就做一个

1825
01:10:10,000 --> 01:10:11,000
API 的后台

1826
01:10:12,000 --> 01:10:12,000
再加一个

1827
01:10:13,000 --> 01:10:14,000
iOS 客户端就搞定了对吧

1828
01:10:15,000 --> 01:10:15,000
但是呢

1829
01:10:15,000 --> 01:10:16,000
这个

1830
01:10:16,000 --> 01:10:18,000
服务端那边一般不可能用

1831
01:10:18,000 --> 01:10:19,000
刚才讲了不可能用

1832
01:10:20,000 --> 01:10:21,000
苹果的东西来写之前

1833
01:10:22,000 --> 01:10:22,000
非常少

1834
01:10:23,000 --> 01:10:25,000
用 Object C 写后台

1835
01:10:25,000 --> 01:10:27,000
已经是 20 年前的视频了

1836
01:10:30,000 --> 01:10:34,000
就连应该我就是连苹果自己那个叫什么 web 什么来的

1837
01:10:34,000 --> 01:10:36,000
Weblogic

1838
01:10:37,000 --> 01:10:40,000
他有一个叫什么

1839
01:10:40,000 --> 01:10:41,000
Olyso

1840
01:10:41,000 --> 01:10:43,000
webobjects

1841
01:10:43,000 --> 01:10:44,000
对对对 webobjects

1842
01:10:45,000 --> 01:10:47,000
webobjects 后来转成

1843
01:10:48,000 --> 01:10:48,000
Java 了

1844
01:10:49,000 --> 01:10:49,000
后来转成 Java 吗

1845
01:10:50,000 --> 01:10:51,000
没错

1846
01:10:51,000 --> 01:10:51,000
ok

1847
01:10:52,000 --> 01:10:53,000
这个我很确定

1848
01:10:53,000 --> 01:10:57,000
就是苹果曾经他自己设有一套这个当然那个是 web 1.0 时代

1849
01:10:57,000 --> 01:11:00,000
对非常非常古老的时代

1850
01:11:00,000 --> 01:11:03,000
最初发布的时候是 19 年前 96 年的时候

1851
01:11:04,000 --> 01:11:04,000
然后

1852
01:11:05,000 --> 01:11:07,000
他最开始的时候是那个 Object C 写的

1853
01:11:07,000 --> 01:11:08,000
后来是

1854
01:11:08,000 --> 01:11:11,000
都因为面对现实改成了 Java

1855
01:11:11,000 --> 01:11:11,000
来实现了

1856
01:11:11,000 --> 01:11:15,000
这还是蛮坑爹的嘛

1857
01:11:15,000 --> 01:11:16,000
你要学两个语言

1858
01:11:16,000 --> 01:11:17,000
两种 Runtime

1859
01:11:18,000 --> 01:11:20,000
然后各种不一样的区别 API 都完全不一样

1860
01:11:21,000 --> 01:11:22,000
然后有了这个 Swift 2

1861
01:11:22,000 --> 01:11:24,000
就 Swift 他如果开源有这么实现的时候

1862
01:11:24,000 --> 01:11:25,000
你可以做到这么一件事

1863
01:11:25,000 --> 01:11:26,000
就是

1864
01:11:26,000 --> 01:11:30,000
那个客户端的开发者和服务端 API 的开发者

1865
01:11:30,000 --> 01:11:32,000
可以是同一班人嘛

1866
01:11:33,000 --> 01:11:34,000
或者说就不用再学两套语言了

1867
01:11:35,000 --> 01:11:35,000
就整个都是一样的

1868
01:11:36,000 --> 01:11:39,000
唯一现在可能比较存疑的就是这个

1869
01:11:39,000 --> 01:11:41,000
标准库和第三方库的问题

1870
01:11:41,000 --> 01:11:42,000
因为刚出来肯定是没有了

1871
01:11:43,000 --> 01:11:43,000
因为他

1872
01:11:43,000 --> 01:11:45,000
那些比较好的现成的

1873
01:11:45,000 --> 01:11:46,000
那个

1874
01:11:46,000 --> 01:11:48,000
就是因为为什么说这个 Object C

1875
01:11:48,000 --> 01:11:51,000
做那个客户端开发比较好用或者说 Swift

1876
01:11:52,000 --> 01:11:55,000
做客户端开发比较好用是因为他有那个

1877
01:11:55,000 --> 01:11:56,000
Coco 嘛

1878
01:11:56,000 --> 01:11:57,000
也是叫 Coco 嘛

1879
01:11:57,000 --> 01:11:58,000
but UI kit

1880
01:11:58,000 --> 01:11:59,000
这一套东西

1881
01:11:59,000 --> 01:12:00,000
Coco 也对啊

1882
01:12:00,000 --> 01:12:01,000
在 Mac 上面

1883
01:12:02,000 --> 01:12:03,000
对

1884
01:12:04,000 --> 01:12:05,000
Mac 和 iOS 上面都是

1885
01:12:06,000 --> 01:12:07,000
同一套一个是今年版

1886
01:12:07,000 --> 01:12:08,000
差不多这么理解吧

1887
01:12:08,000 --> 01:12:09,000
嗯

1888
01:12:10,000 --> 01:12:11,000
但是

1889
01:12:11,000 --> 01:12:13,000
他现在如果开源到 Linux 上面的话其实

1890
01:12:13,000 --> 01:12:16,000
我不清楚他只有语言还有编译器开源呢

1891
01:12:16,000 --> 01:12:18,000
还是说他会把这一套

1892
01:12:18,000 --> 01:12:21,000
比较完善的这个标准库也拿过去用

1893
01:12:21,000 --> 01:12:23,000
我觉得可能不太现实

1894
01:12:24,000 --> 01:12:25,000
我希望

1895
01:12:25,000 --> 01:12:28,000
我觉得苹果的希望应该是

1896
01:12:28,000 --> 01:12:32,000
能够让第三方开发者自己生长出一套

1897
01:12:32,000 --> 01:12:34,000
就开发社区来做这个事

1898
01:12:35,000 --> 01:12:36,000
Swift on Rails

1899
01:12:39,000 --> 01:12:40,000
Swift on Pulse

1900
01:12:41,000 --> 01:12:42,000
就说会有一个

1901
01:12:43,000 --> 01:12:45,000
就是一群燕子站在这个电线上

1902
01:12:45,000 --> 01:12:47,000
OK

1903
01:12:47,000 --> 01:12:49,000
这个我们的这个连项目名字都想好了

1904
01:12:49,000 --> 01:12:49,000
开始干嘛

1905
01:12:54,000 --> 01:12:56,000
所以这个我觉得好处还是很显而易见的

1906
01:12:56,000 --> 01:12:58,000
就是可以看实现刚才我说的那点

1907
01:12:58,000 --> 01:13:00,000
然后其实从一个

1908
01:13:00,000 --> 01:13:01,000
就是这个 mind share

1909
01:13:02,000 --> 01:13:05,000
脑力的争夺战来讲

1910
01:13:05,000 --> 01:13:08,000
其实我觉得现在定位最好的应该是

1911
01:13:09,000 --> 01:13:11,000
Android 吧因为 Java 很多人都会嘛

1912
01:13:11,000 --> 01:13:14,000
Java 可以写这个客户端

1913
01:13:14,000 --> 01:13:15,000
可以写嵌入式

1914
01:13:15,000 --> 01:13:16,000
可以写服务端

1915
01:13:16,000 --> 01:13:17,000
可以写桌面应用

1916
01:13:17,000 --> 01:13:19,000
但桌面应用不太适合

1917
01:13:19,000 --> 01:13:23,000
但是总体来说还是一个适用性非常广的语言

1918
01:13:23,000 --> 01:13:25,000
但有意思的是 Google 正在

1919
01:13:25,000 --> 01:13:27,000
有意无意的把 Java ditching 了

1920
01:13:27,000 --> 01:13:28,000
你不觉得吧

1921
01:13:28,000 --> 01:13:30,000
就是首先 Service side

1922
01:13:30,000 --> 01:13:31,000
可能用 go language 写

1923
01:13:32,000 --> 01:13:35,000
这件事情已经成立了吗我觉得还没有吧

1924
01:13:35,000 --> 01:13:37,000
他正在试图找一个方向前进不是吗

1925
01:13:38,000 --> 01:13:38,000
你不觉得

1926
01:13:39,000 --> 01:13:41,000
这点事情我是觉得

1927
01:13:41,000 --> 01:13:42,000
这是存疑的就是

1928
01:13:43,000 --> 01:13:43,000
你觉得

1929
01:13:44,000 --> 01:13:46,000
Google 在我们有生之年不会抛弃 Java 吗

1930
01:13:47,000 --> 01:13:49,000
起码在 Android 的这一端我觉得是

1931
01:13:49,000 --> 01:13:50,000
可能比较难

1932
01:13:51,000 --> 01:13:53,000
因为其实你真的用 go language 写客户端的话

1933
01:13:53,000 --> 01:13:55,000
发现还是坑蛮多的

1934
01:13:55,000 --> 01:13:58,000
不 可是我们上次不是提到了他的那个叫什么

1935
01:13:58,000 --> 01:13:59,000
Sky

1936
01:13:59,000 --> 01:14:04,000
对他有这个尝试嘛但是我不太清楚这件事情是否真的能够做得成

1937
01:14:04,000 --> 01:14:07,000
因为这个惯性还是蛮大的你不知道因为

1938
01:14:07,000 --> 01:14:08,000
这个

1939
01:14:08,000 --> 01:14:09,000
Java 是什么

1940
01:14:10,000 --> 01:14:11,000
教学级语

1941
01:14:11,000 --> 01:14:11,000
语言啊

1942
01:14:12,000 --> 01:14:14,000
我以为你要说小强级语言

1943
01:14:14,000 --> 01:14:16,000
有一个意思

1944
01:14:16,000 --> 01:14:20,000
就是在学校里面他的培养的人啊就是教学的时候就说这个东西

1945
01:14:21,000 --> 01:14:22,000
我觉得这个对

1946
01:14:22,000 --> 01:14:23,000
一大批的

1947
01:14:24,000 --> 01:14:27,000
这个程序员的成长的经验还是非常重要的影响

1948
01:14:27,000 --> 01:14:30,000
所以我不太确定他这个能够短期内实现这一点而且

1949
01:14:32,000 --> 01:14:33,000
他说在服务端他

1950
01:14:34,000 --> 01:14:39,000
在用 go 去替代 Java 也是在比较小范围的有限度的去整理一个尝试而并不是说全

1951
01:14:39,000 --> 01:14:40,000
就全公司的

1952
01:14:40,000 --> 01:14:41,000
怎么去推这么一个东西

1953
01:14:42,000 --> 01:14:49,000
如果纯粹以前后端使用单一语言来衡量的话不考虑市场份额那 windows phone 来的不是最好

1954
01:14:49,000 --> 01:14:54,000
对所以其实我们来现在看现在微软其实挺有意思的一个情况就是他

1955
01:14:54,000 --> 01:14:55,000
那个 Csharp

1956
01:14:55,000 --> 01:14:56,000
其实是做的挺好的

1957
01:14:57,000 --> 01:14:59,000
对啊通吃所有平台所有端

1958
01:15:00,000 --> 01:15:02,000
对而且如果我理解没错的话他有那个 CLR 的

1959
01:15:03,000 --> 01:15:04,000
Runtime 之后

1960
01:15:04,000 --> 01:15:07,000
他编译那个生成那个 C 就是

1961
01:15:07,000 --> 01:15:09,000
你甚至不一定要用 Csharp 来写 windows phone 的应用

1962
01:15:09,000 --> 01:15:10,000
对

1963
01:15:10,000 --> 01:15:10,000
可以用那么 Azure 的应用来写 windows phone 的应用

1964
01:15:10,000 --> 01:15:12,000
Fsharp 来写也可以对吧

1965
01:15:13,000 --> 01:15:16,000
或者什么 objectivec.net

1966
01:15:17,000 --> 01:15:21,000
对这之类的东西就其实他的那个定位是更好但他因为没有

1967
01:15:22,000 --> 01:15:22,000
没有什么

1968
01:15:23,000 --> 01:15:25,000
没有市场占有量这件事情就

1969
01:15:25,000 --> 01:15:29,000
对大伙说来说没有什么意义就我们只讨论

1970
01:15:29,000 --> 01:15:32,000
安卓和 rc 两个情况来干

1971
01:15:32,000 --> 01:15:35,000
苹果在这上面上是我就稍微是有点吃亏的

1972
01:15:38,000 --> 01:15:39,000
很难说吧我觉得

1973
01:15:39,000 --> 01:15:40,000
就

1974
01:15:40,000 --> 01:15:42,000
我觉得

1975
01:15:44,000 --> 01:15:46,000
苹果是试图以

1976
01:15:47,000 --> 01:15:52,000
语言本身的优势以及他在客户端的

1977
01:15:53,000 --> 01:15:56,000
比较相对来说比较广泛的开发者群

1978
01:15:56,000 --> 01:15:58,000
去反攻服务端

1979
01:15:59,000 --> 01:16:02,000
去反过来去试图向服务端

1980
01:16:03,000 --> 01:16:04,000
扩展这一技术

1981
01:16:05,000 --> 01:16:05,000
而

1982
01:16:06,000 --> 01:16:10,000
我看不到 Google 有一种新的语言可以

1983
01:16:10,000 --> 01:16:15,000
单词重任另外一方面公共好像本身也没有这个心思

1984
01:16:16,000 --> 01:16:19,000
他之前不是大家都在猜他会不会用那个叫

1985
01:16:19,000 --> 01:16:20,000
那就什么来的

1986
01:16:20,000 --> 01:16:22,000
之前宣布有没有搭载的

1987
01:16:23,000 --> 01:16:24,000
Dart

1988
01:16:24,000 --> 01:16:25,000
对 Dart

1989
01:16:25,000 --> 01:16:27,000
Dart 不就是 Sky

1990
01:16:28,000 --> 01:16:30,000
但是我觉得那个事情可能

1991
01:16:31,000 --> 01:16:31,000
他想的

1992
01:16:32,000 --> 01:16:34,000
还不太一样那个 Dart 是初衷是要

1993
01:16:34,000 --> 01:16:37,000
从 web 那段开始简化这个 UI 就是

1994
01:16:37,000 --> 01:16:39,000
就是 UI 的那个构建的方法

1995
01:16:40,000 --> 01:16:43,000
但是到了这个安卓上

1996
01:16:43,000 --> 01:16:46,000
不知道性能啊还有什么方面真的是靠谱吗

1997
01:16:46,000 --> 01:16:47,000
反正他现在没有做这件事

1998
01:16:48,000 --> 01:16:49,000
可能还是有一定的技术门槛我觉得

1999
01:16:52,000 --> 01:16:54,000
拭目以待反正 Google 东西都是要等

2000
01:16:55,000 --> 01:16:58,000
然后随时可能就 cancel 了

2001
01:16:58,000 --> 01:17:01,000
对我觉得这次 WWDC 给我的一个印象就是

2002
01:17:01,000 --> 01:17:05,000
你在那边看着他说这个东西我们是什么什么样的

2003
01:17:05,000 --> 01:17:08,000
然后你转连就可以下载下来用了

2004
01:17:09,000 --> 01:17:09,000
还是

2005
01:17:10,000 --> 01:17:11,000
deliver 的

2006
01:17:11,000 --> 01:17:13,000
到了不像 Google 老师画饼子

2007
01:17:13,000 --> 01:17:14,000
对说

2008
01:17:15,000 --> 01:17:20,000
说这个东西我们有啊然后各位再等两年就可以用到

2009
01:17:21,000 --> 01:17:21,000
对还有一个

2010
01:17:22,000 --> 01:17:25,000
比较小的重点就是 Syft 2 里面有

2011
01:17:26,000 --> 01:17:26,000
这个

2012
01:17:27,000 --> 01:17:27,000
Try catch

2013
01:17:28,000 --> 01:17:30,000
当然他们的语法是 do catch

2014
01:17:31,000 --> 01:17:33,000
do 里面就是一个 do block

2015
01:17:33,000 --> 01:17:35,000
do block 里面有一些关键的部分

2016
01:17:35,000 --> 01:17:38,000
可能会抛出一场的部分你要用 try

2017
01:17:38,000 --> 01:17:39,000
try 关键词

2018
01:17:39,000 --> 01:17:40,000
就是有那个

2019
01:17:40,000 --> 01:17:41,000
exception 机制了吗

2020
01:17:41,000 --> 01:17:44,000
对然后我之前在直播上写过一篇

2021
01:17:44,000 --> 01:17:46,000
答案比较

2022
01:17:48,000 --> 01:17:49,000
比较

2023
01:17:49,000 --> 01:17:50,000
笃定的

2024
01:17:51,000 --> 01:17:55,000
阐述了为什么没有 exception 机制比较好

2025
01:17:55,000 --> 01:17:59,000
然后现在 exception 机制出来了

2026
01:18:00,000 --> 01:18:02,000
anyway

2027
01:18:02,000 --> 01:18:03,000
当然我那篇

2028
01:18:03,000 --> 01:18:06,000
文章里面非常圆滑的没有把话说死

2029
01:18:06,000 --> 01:18:09,000
我也默默的去改了那个

2030
01:18:09,000 --> 01:18:10,000
当时的措辞

2031
01:18:10,000 --> 01:18:11,000
就说现在已经有了

2032
01:18:12,000 --> 01:18:12,000
所以

2033
01:18:14,000 --> 01:18:18,000
OK 那我们接下来可以进入本期的正题

2034
01:18:18,000 --> 01:18:20,000
在一小时

2035
01:18:20,000 --> 01:18:22,000
一个多小时之后开始进入正题

2036
01:18:23,000 --> 01:18:24,000
太好了我们只能谈半个小时

2037
01:18:26,000 --> 01:18:27,000
所以本期的主题是

2038
01:18:28,000 --> 01:18:28,000
测试

2039
01:18:28,000 --> 01:18:30,000
testing testing

2040
01:18:30,000 --> 01:18:31,000
testing testing

2041
01:18:32,000 --> 01:18:33,000
然后

2042
01:18:33,000 --> 01:18:34,000
什么是测试

2043
01:18:34,000 --> 01:18:34,000
解释一下

2044
01:18:35,000 --> 01:18:36,000
好问题

2045
01:18:36,000 --> 01:18:38,000
你说什么是测试

2046
01:18:38,000 --> 01:18:40,000
就我其实今天在准备

2047
01:18:40,000 --> 01:18:43,000
我说这段时间在准备这个提纲的时候

2048
01:18:43,000 --> 01:18:46,000
想了很多测试的例子但是

2049
01:18:48,000 --> 01:18:51,000
我觉得可以这么说吧就是测试有两个含义

2050
01:18:51,000 --> 01:18:54,000
一个是广义的测试一个是狭义的测试就像相对论一样

2051
01:18:54,000 --> 01:18:58,000
广义的测试可以指比如说

2052
01:18:58,000 --> 01:18:59,000
penetration test

2053
01:19:00,000 --> 01:19:01,000
也是一种测试

2054
01:19:01,000 --> 01:19:02,000
就是

2055
01:19:02,000 --> 01:19:04,000
看贵公司的网站是否安全

2056
01:19:04,000 --> 01:19:08,000
我作为一个不管是黑帽子还是白帽子是去

2057
01:19:09,000 --> 01:19:10,000
扫一扫端口呀

2058
01:19:10,000 --> 01:19:13,000
找一找注入点呀这些可以叫做

2059
01:19:14,000 --> 01:19:15,000
测试甚至

2060
01:19:16,000 --> 01:19:17,000
英文名字也叫 penetration test

2061
01:19:17,000 --> 01:19:18,000
甚至有一个专门的

2062
01:19:18,000 --> 01:19:20,000
搓写叫做 pen test

2063
01:19:21,000 --> 01:19:23,000
然后

2064
01:19:23,000 --> 01:19:25,000
发烟测试也可以叫做测试

2065
01:19:25,000 --> 01:19:26,000
就比如说

2066
01:19:27,000 --> 01:19:28,000
smoke testing

2067
01:19:29,000 --> 01:19:33,000
这个我还不太理解这种各种数量这个是讲什么

2068
01:19:33,000 --> 01:19:34,000
smoke test

2069
01:19:35,000 --> 01:19:37,000
smoke testing 实际上大家每天都在做

2070
01:19:38,000 --> 01:19:39,000
或者说经常会做

2071
01:19:39,000 --> 01:19:40,000
比如说你装

2072
01:19:40,000 --> 01:19:41,000
好的 ruion rails

2073
01:19:42,000 --> 01:19:43,000
然后你

2074
01:19:44,000 --> 01:19:46,000
开始运行服务器

2075
01:19:46,000 --> 01:19:48,000
打开浏览器

2076
01:19:48,000 --> 01:19:49,000
输入 localhost 8080

2077
01:19:49,000 --> 01:19:50,000
回车

2078
01:19:50,000 --> 01:19:52,000
诶屏幕上出现了这个

2079
01:19:52,000 --> 01:19:53,000
it works

2080
01:19:53,000 --> 01:19:54,000
之类的这么一个

2081
01:19:55,000 --> 01:19:58,000
一个表示说啊这个东西开始运行了这么一个提示

2082
01:19:59,000 --> 01:20:01,000
这就是这个过程就是一个 smoke test

2083
01:20:01,000 --> 01:20:03,000
这个 smoke 是

2084
01:20:03,000 --> 01:20:04,000
和什么一个说法

2085
01:20:05,000 --> 01:20:06,000
他应该是

2086
01:20:06,000 --> 01:20:08,000
介于

2087
01:20:08,000 --> 01:20:10,000
借用字

2088
01:20:10,000 --> 01:20:13,000
另外一个领域我忘了是哪个领域是矿工还是什么

2089
01:20:14,000 --> 01:20:16,000
工种的一个

2090
01:20:16,000 --> 01:20:21,000
既有的测试就是如果你看到冒烟了说明这个东西是已经开始正常

2091
01:20:21,000 --> 01:20:22,000
好像是孤独

2092
01:20:23,000 --> 01:20:25,000
之类的一个非常古老的

2093
01:20:25,000 --> 01:20:26,000
术语

2094
01:20:26,000 --> 01:20:26,000
发烟测试

2095
01:20:27,000 --> 01:20:29,000
确定不是摩托车之类的吗

2096
01:20:30,000 --> 01:20:33,000
不是摩托车吧摩托车冒烟的肯定是有故障

2097
01:20:35,000 --> 01:20:35,000
好吧

2098
01:20:36,000 --> 01:20:38,000
发烟测试指的就是你在

2099
01:20:38,000 --> 01:20:39,000
你在试一个东西

2100
01:20:39,000 --> 01:20:41,000
你想要看一看他的那些

2101
01:20:41,000 --> 01:20:43,000
最为 critical 最为基本的

2102
01:20:44,000 --> 01:20:44,000
功能是不是运行

2103
01:20:45,000 --> 01:20:45,000
比如说你

2104
01:20:45,000 --> 01:20:47,000
你想知道

2105
01:20:48,000 --> 01:20:50,000
你想知道来电了没有

2106
01:20:50,000 --> 01:20:51,000
或者你想知道是不是停电了

2107
01:20:52,000 --> 01:20:54,000
你去搬一个电动的开关

2108
01:20:54,000 --> 01:20:54,000
这就是一种

2109
01:20:55,000 --> 01:20:55,000
smoke testing

2110
01:20:56,000 --> 01:20:57,000
因为他

2111
01:20:57,000 --> 01:21:02,000
所测试的并不是你家整个电路是不是完好无缺是不是有地方有坡损

2112
01:21:02,000 --> 01:21:04,000
是不是有地方电阻太高是不是有可能

2113
01:21:04,000 --> 01:21:06,000
有火灾的风险

2114
01:21:06,000 --> 01:21:09,000
他唯一测试的就是你家的电路是不是在运行

2115
01:21:10,000 --> 01:21:10,000
但是

2116
01:21:11,000 --> 01:21:16,000
狭义的测试则是不包括刚才说的比如说 penetration testing 或者 smoke testing

2117
01:21:17,000 --> 01:21:19,000
狭义的测试其实

2118
01:21:19,000 --> 01:21:22,000
如果要用比较简单的语言来说就是

2119
01:21:25,000 --> 01:21:29,000
让你知道让你有种可以重复的方法

2120
01:21:30,000 --> 01:21:33,000
来知道自己写的软件是

2121
01:21:34,000 --> 01:21:35,000
按照你

2122
01:21:35,000 --> 01:21:37,000
所希望的那些

2123
01:21:38,000 --> 01:21:39,000
方式而运行了一些

2124
01:21:39,000 --> 01:21:40,000
系列的东西

2125
01:21:40,000 --> 01:21:41,000
就会叫做测试

2126
01:21:42,000 --> 01:21:44,000
刚才讲了各种各样的测试测试的

2127
01:21:45,000 --> 01:21:46,000
主要的一个目的是什么

2128
01:21:46,000 --> 01:21:47,000
主要的目的是什么

2129
01:21:47,000 --> 01:21:48,000
基本上就是要

2130
01:21:49,000 --> 01:21:54,000
基本上测试的意义就是让你有一个可以度量的准则

2131
01:21:54,000 --> 01:21:56,000
就是你因为我们知道

2132
01:21:56,000 --> 01:21:59,000
你写了一个程序之后你会说这个程序

2133
01:21:59,000 --> 01:22:01,000
看起来是正确的

2134
01:22:01,000 --> 01:22:03,000
或者说他在大部分情况下也都是正确的

2135
01:22:04,000 --> 01:22:04,000
但是你

2136
01:22:05,000 --> 01:22:06,000
怎么样才能有一种比较

2137
01:22:07,000 --> 01:22:08,000
可以验证的客观的

2138
01:22:09,000 --> 01:22:10,000
可以量化的

2139
01:22:11,000 --> 01:22:14,000
指标来告诉你说对这个软件的确是可以工作的呢

2140
01:22:15,000 --> 01:22:15,000
这就是测试了

2141
01:22:16,000 --> 01:22:21,000
就是你为了获得一些特定的指标而对你写好的软件

2142
01:22:21,000 --> 01:22:23,000
采取的一系列度量的方法

2143
01:22:24,000 --> 01:22:25,000
就是测试

2144
01:22:26,000 --> 01:22:29,000
所以就是其实它是一个质量的就 QA 的概念

2145
01:22:30,000 --> 01:22:31,000
对

2146
01:22:31,000 --> 01:22:33,000
早期的

2147
01:22:34,000 --> 01:22:36,000
早期的测试

2148
01:22:36,000 --> 01:22:39,000
是为了验证程序的

2149
01:22:39,000 --> 01:22:40,000
behaviour 是不是正确

2150
01:22:41,000 --> 01:22:46,000
而后期比如说现今的测试很大程度上已经变成一种

2151
01:22:47,000 --> 01:22:49,000
质检的关卡

2152
01:22:49,000 --> 01:22:51,000
就是我们知道有一个

2153
01:22:53,000 --> 01:22:54,000
验证体系应该是

2154
01:22:55,000 --> 01:22:57,000
ISO 9000 吧

2155
01:22:57,000 --> 01:23:00,000
在软件界好像还有另外的编号 92

2156
01:23:01,000 --> 01:23:02,000
然后这个

2157
01:23:02,000 --> 01:23:07,000
认证体系很大的一个指标就是要看你这个软件公司的

2158
01:23:07,000 --> 01:23:07,000
测试

2159
01:23:09,000 --> 01:23:13,000
有没有写如果有的话是什么样的能够写然后有没有一个专门的

2160
01:23:13,000 --> 01:23:16,000
负责把关的部门来去

2161
01:23:16,000 --> 01:23:18,000
去盯着这些测试

2162
01:23:19,000 --> 01:23:20,000
诸如此类

2163
01:23:20,000 --> 01:23:25,000
如今测试已经成为一个特别重要的一个软件工程里面的环节

2164
01:23:26,000 --> 01:23:27,000
然后测试又可以分为

2165
01:23:28,000 --> 01:23:31,000
功能性的测试以及非功能性的测试

2166
01:23:31,000 --> 01:23:36,000
也就是说狭义上的测试又可以分为功能性的测试和非功能性的测试

2167
01:23:36,000 --> 01:23:38,000
功能性测试也就是说比如说

2168
01:23:39,000 --> 01:23:41,000
你写了一个函数这个函数可以返回两个

2169
01:23:42,000 --> 01:23:43,000
数值的和

2170
01:23:43,000 --> 01:23:46,000
然后你写所谓功能性的测试就是你

2171
01:23:46,000 --> 01:23:47,000
输入 3 和 4

2172
01:23:47,000 --> 01:23:49,000
然后看这个函数是不是返回 7

2173
01:23:50,000 --> 01:23:53,000
比如说你写了一个

2174
01:23:53,000 --> 01:23:54,000
除法的

2175
01:23:55,000 --> 01:23:57,000
函数然后你输入 1 和 0 想要看这个

2176
01:23:58,000 --> 01:24:00,000
函数会不会返回说除 0 错

2177
01:24:01,000 --> 01:24:02,000
这是一种功能性的测试

2178
01:24:03,000 --> 01:24:06,000
而非功能性的测试则是比如说看你这个函数的

2179
01:24:07,000 --> 01:24:08,000
执行的速度怎么样

2180
01:24:08,000 --> 01:24:09,000
比如说你写了一个

2181
01:24:09,000 --> 01:24:13,000
一个加法的函数是正确的没错但是他需要一天才能得出结果

2182
01:24:15,000 --> 01:24:19,000
这样的函数可能没有办法通过所谓功能性的测试来

2183
01:24:19,000 --> 01:24:23,000
验证它对功能性的测试会告诉你说他没问题

2184
01:24:23,000 --> 01:24:25,000
但是一旦你去做一个

2185
01:24:25,000 --> 01:24:27,000
Performance testing

2186
01:24:27,000 --> 01:24:30,000
你会立刻意识到这样的函数是完全不过关的

2187
01:24:31,000 --> 01:24:32,000
这个

2188
01:24:32,000 --> 01:24:36,000
Performance testing 其实有一个专门的书我们叫做 Benchmark 对吧

2189
01:24:36,000 --> 01:24:37,000
可以这么说对

2190
01:24:39,000 --> 01:24:44,000
其实就这么说就是这么算就是 Benchmark 是测试的一个

2191
01:24:45,000 --> 01:24:45,000
子集

2192
01:24:46,000 --> 01:24:49,000
怎么说呢 Performance testing

2193
01:24:49,000 --> 01:24:52,000
可以归类为

2194
01:24:52,000 --> 01:24:54,000
Profiling 的一种

2195
01:24:54,000 --> 01:24:57,000
而 Benchmark 则是 Profiling 的一个指标

2196
01:24:58,000 --> 01:25:00,000
所以我倾向于认为

2197
01:25:01,000 --> 01:25:02,000
两者还是有

2198
01:25:03,000 --> 01:25:04,000
多少有点不一样

2199
01:25:05,000 --> 01:25:05,000
OK

2200
01:25:07,000 --> 01:25:08,000
因为

2201
01:25:09,000 --> 01:25:14,000
当然也是可以用 Benchmark 最终的分数来作为

2202
01:25:14,000 --> 01:25:16,000
Performance testing 的一个指标

2203
01:25:16,000 --> 01:25:17,000
也没错

2204
01:25:18,000 --> 01:25:20,000
这不重要因为我们本次

2205
01:25:20,000 --> 01:25:23,000
节目所要集中的

2206
01:25:23,000 --> 01:25:26,000
这个话题其实是在狭义的

2207
01:25:27,000 --> 01:25:27,000
非

2208
01:25:27,000 --> 01:25:29,000
功能性测试上

2209
01:25:29,000 --> 01:25:30,000
而不是非功能性测试

2210
01:25:30,000 --> 01:25:32,000
因为非功能性测试可以

2211
01:25:33,000 --> 01:25:35,000
可能涉及到的面实在是太广太广了

2212
01:25:36,000 --> 01:25:37,000
对因为

2213
01:25:37,000 --> 01:25:39,000
软离工程本身就是一个非常

2214
01:25:39,000 --> 01:25:40,000
非常广的话题集

2215
01:25:41,000 --> 01:25:41,000
而

2216
01:25:41,000 --> 01:25:43,000
测试又是软离工程上面

2217
01:25:44,000 --> 01:25:45,000
相当大的一个分支

2218
01:25:45,000 --> 01:25:47,000
我们显然不可能在一个

2219
01:25:47,000 --> 01:25:50,000
预计时间只有两个小时

2220
01:25:51,000 --> 01:25:52,000
左右的

2221
01:25:52,000 --> 01:25:53,000
节目里面把

2222
01:25:53,000 --> 01:25:55,000
面与资料的吧

2223
01:25:56,000 --> 01:25:59,000
测试每个方面都谈到所以我们这次主要的

2224
01:25:59,000 --> 01:26:00,000
集中的

2225
01:26:01,000 --> 01:26:03,000
主题还是在

2226
01:26:04,000 --> 01:26:04,000
功能性测试上

2227
01:26:05,000 --> 01:26:09,000
而且功能性测试里面我们应该只会谈及

2228
01:26:09,000 --> 01:26:10,000
Unit test

2229
01:26:11,000 --> 01:26:11,000
就是单元测试

2230
01:26:12,000 --> 01:26:16,000
以及部分的所谓 acceptance test

2231
01:26:17,000 --> 01:26:18,000
就是接受性测试

2232
01:26:19,000 --> 01:26:19,000
我不知道这是

2233
01:26:20,000 --> 01:26:21,000
交接测试

2234
01:26:23,000 --> 01:26:24,000
中文术语是什么忘记了

2235
01:26:25,000 --> 01:26:25,000
没关系

2236
01:26:26,000 --> 01:26:26,000
anyway

2237
01:26:27,000 --> 01:26:27,000
对

2238
01:26:28,000 --> 01:26:30,000
所以 Ryo 你写测试吗

2239
01:26:31,000 --> 01:26:34,000
很惭愧我不写

2240
01:26:35,000 --> 01:26:36,000
伟大的成员都是不写测试的

2241
01:26:37,000 --> 01:26:37,000
这话我们现在

2242
01:26:38,000 --> 01:26:39,000
不是我一直就在写

2243
01:26:39,000 --> 01:26:41,000
想了解这么一个事

2244
01:26:41,000 --> 01:26:42,000
就是说

2245
01:26:42,000 --> 01:26:45,000
我们经常有这个也有一种开发程序的思路

2246
01:26:45,000 --> 01:26:46,000
Test driven development

2247
01:26:47,000 --> 01:26:48,000
TDD 对吧

2248
01:26:48,000 --> 01:26:49,000
我一直很好奇这事

2249
01:26:50,000 --> 01:26:51,000
靠谱吗

2250
01:26:51,000 --> 01:26:52,000
就这么说吧

2251
01:26:53,000 --> 01:26:54,000
如果我们把软件工程

2252
01:26:54,000 --> 01:26:55,000
真的作为一项工程来讲

2253
01:26:56,000 --> 01:26:57,000
我们会这么去想

2254
01:26:57,000 --> 01:26:58,000
就是

2255
01:26:58,000 --> 01:26:59,000
你修一栋楼

2256
01:27:00,000 --> 01:27:03,000
你会说这个楼我们算出来它的承重是比如说

2257
01:27:04,000 --> 01:27:04,000
1000 吨

2258
01:27:05,000 --> 01:27:05,000
某一层对吧

2259
01:27:06,000 --> 01:27:07,000
不知道这个数字是不是靠谱

2260
01:27:08,000 --> 01:27:08,000
反正就随便举一个

2261
01:27:09,000 --> 01:27:11,000
我们会从力学结构上计算出

2262
01:27:11,000 --> 01:27:13,000
他没错他确实可以

2263
01:27:13,000 --> 01:27:14,000
这个承受 1000 吨

2264
01:27:14,000 --> 01:27:16,000
就是从计算物理算数

2265
01:27:16,000 --> 01:27:18,000
这个什么就是公式算法就这么多

2266
01:27:18,000 --> 01:27:22,000
但我们不会真的弄一个 1000 东西上去给他实际压一下对吧

2267
01:27:26,000 --> 01:27:28,000
是这样说没错但我有办法反驳你

2268
01:27:29,000 --> 01:27:30,000
你还有别的要说的吗

2269
01:27:30,000 --> 01:27:32,000
没有我就是就这个思路说下去

2270
01:27:32,000 --> 01:27:35,000
其实有很多事情

2271
01:27:35,000 --> 01:27:37,000
我们是没有办法

2272
01:27:37,000 --> 01:27:38,000
去真的真的去实践

2273
01:27:39,000 --> 01:27:41,000
但是我们是有一个条件去测的就是有些所谓的 edge cases

2274
01:27:41,000 --> 01:27:42,000
对吧

2275
01:27:42,000 --> 01:27:45,000
但是软件不一样因为软件很适合

2276
01:27:45,000 --> 01:27:47,000
模拟各种情况出来你都可以

2277
01:27:47,000 --> 01:27:49,000
就是你 1000 多吨的努力输个

2278
01:27:49,000 --> 01:27:52,000
多加个零一万吨我都可以给你测出来

2279
01:27:52,000 --> 01:27:52,000
没有问题

2280
01:27:53,000 --> 01:27:54,000
但我觉得这个

2281
01:27:54,000 --> 01:27:57,000
我一直很好奇这会不会让人变得

2282
01:27:57,000 --> 01:27:58,000
奇怪

2283
01:27:58,000 --> 01:27:59,000
变得或者变得懒

2284
01:27:59,000 --> 01:28:00,000
因为我一直觉得

2285
01:28:01,000 --> 01:28:03,000
要保证软件质量

2286
01:28:03,000 --> 01:28:07,000
测试当然是少不了一个环节但是这个不是最根本的问题

2287
01:28:07,000 --> 01:28:09,000
最根本的问题是你要在设计

2288
01:28:09,000 --> 01:28:09,000
的时候就要想好

2289
01:28:10,000 --> 01:28:13,000
这个在理论上可不可能会出现这种问题

2290
01:28:13,000 --> 01:28:15,000
就或者说这么说吧你写了一个函数

2291
01:28:15,000 --> 01:28:16,000
他有多少

2292
01:28:16,000 --> 01:28:18,000
种可能的进入方法

2293
01:28:18,000 --> 01:28:20,000
有多少种可能的退出方法

2294
01:28:20,000 --> 01:28:22,000
中间有多少种可能的这个

2295
01:28:22,000 --> 01:28:23,000
出现异常的

2296
01:28:23,000 --> 01:28:24,000
这个原因

2297
01:28:24,000 --> 01:28:25,000
我们把这些都

2298
01:28:25,000 --> 01:28:29,000
每一个都考虑过了我们那些函数就才可以说他是一个

2299
01:28:30,000 --> 01:28:31,000
无错的

2300
01:28:32,000 --> 01:28:33,000
一定是按就是

2301
01:28:33,000 --> 01:28:34,000
就是证明过确实

2302
01:28:35,000 --> 01:28:36,000
被

2303
01:28:36,000 --> 01:28:37,000
证明过确实没有

2304
01:28:38,000 --> 01:28:39,000
你所有的

2305
01:28:39,000 --> 01:28:43,000
的路径都考虑了没有一个漏掉的东西这个时候你不用写测试因为你的

2306
01:28:44,000 --> 01:28:46,000
在设计的阶段已经把所有的可能都考虑过了

2307
01:28:47,000 --> 01:28:47,000
但是呢

2308
01:28:48,000 --> 01:28:49,000
做这件事情本身可能是比较难的

2309
01:28:51,000 --> 01:28:54,000
就是说特别是软件过程大了之后你可能不可能面面俱到对吧

2310
01:28:55,000 --> 01:28:57,000
所以我们才要测试一些选择一些点

2311
01:28:58,000 --> 01:28:58,000
就是说甚至

2312
01:28:59,000 --> 01:29:02,000
做统计抽样的办法吗我们假设如果这一点过了之后

2313
01:29:02,000 --> 01:29:06,000
我们有较大的信心认为这个东西是设计上是没有问题的

2314
01:29:06,000 --> 01:29:08,000
但是这个和我刚才讲的那种修楼

2315
01:29:08,000 --> 01:29:09,000
修楼你用力学公式

2316
01:29:10,000 --> 01:29:12,000
结构力学算出来之后

2317
01:29:12,000 --> 01:29:14,000
他肯定能成出这么多

2318
01:29:14,000 --> 01:29:15,000
然后我们

2319
01:29:15,000 --> 01:29:18,000
并不需要真的去加上那个极限的重量去测

2320
01:29:18,000 --> 01:29:21,000
他能不能实际成就那么多是一个概念

2321
01:29:21,000 --> 01:29:24,000
就说我们能够算出来说我们不需要真的去做那些测试

2322
01:29:24,000 --> 01:29:25,000
所以

2323
01:29:25,000 --> 01:29:27,000
我一直很好奇我们是不是

2324
01:29:27,000 --> 01:29:28,000
把测试的

2325
01:29:29,000 --> 01:29:30,000
功能想的太伟大了

2326
01:29:31,000 --> 01:29:32,000
我就说测试的

2327
01:29:32,000 --> 01:29:33,000
重点他都而

2328
01:29:33,000 --> 01:29:34,000
把这个

2329
01:29:34,000 --> 01:29:35,000
从这个设计

2330
01:29:36,000 --> 01:29:37,000
从这个原理层面的东西

2331
01:29:37,000 --> 01:29:38,000
放的转眼也太少

2332
01:29:38,000 --> 01:29:39,000
好

2333
01:29:39,000 --> 01:29:40,000
OK

2334
01:29:43,000 --> 01:29:44,000
槽点太多不知道从哪

2335
01:29:47,000 --> 01:29:50,000
我其实

2336
01:29:50,000 --> 01:29:51,000
其实我还是很

2337
01:29:51,000 --> 01:29:53,000
比较认同你的看法

2338
01:29:54,000 --> 01:29:54,000
因为

2339
01:29:58,000 --> 01:30:00,000
这么说吧我其实对于测试一直是抱有

2340
01:30:01,000 --> 01:30:02,000
多多少少有点抵触情绪

2341
01:30:05,000 --> 01:30:07,000
甚至我自己也不是一个非常喜欢写测试的人

2342
01:30:08,000 --> 01:30:08,000
但是我

2343
01:30:08,000 --> 01:30:14,000
我必须反驳你的一点就是你觉得测试似乎在软件工程里面被

2344
01:30:14,000 --> 01:30:15,000
高估了

2345
01:30:15,000 --> 01:30:17,000
而我则觉得

2346
01:30:17,000 --> 01:30:21,000
从目前大部分软件的水平来看他应该是被低估

2347
01:30:22,000 --> 01:30:23,000
啊

2348
01:30:24,000 --> 01:30:26,000
拿回你这个钢机构的例子

2349
01:30:26,000 --> 01:30:27,000
就是你的建筑的

2350
01:30:28,000 --> 01:30:30,000
就是你会说你设计这一层

2351
01:30:31,000 --> 01:30:31,000
他的

2352
01:30:34,000 --> 01:30:35,000
硬力可能是

2353
01:30:36,000 --> 01:30:38,000
2000 吨或者是

2354
01:30:38,000 --> 01:30:39,000
2010 吨

2355
01:30:39,000 --> 01:30:40,000
但是

2356
01:30:40,000 --> 01:30:42,000
你之所以能得出这个

2357
01:30:43,000 --> 01:30:45,000
数值本身其实就是因为

2358
01:30:45,000 --> 01:30:47,000
用来搭这个

2359
01:30:48,000 --> 01:30:49,000
建筑的钢材

2360
01:30:50,000 --> 01:30:52,000
真的经历过

2361
01:30:52,000 --> 01:30:55,000
在一个比较小的规模上的硬力测试

2362
01:30:56,000 --> 01:31:02,000
你才可以拿到这个钢材相关的数据然后才能算出这个钢材在什么样的

2363
01:31:02,000 --> 01:31:06,000
高度什么样的长度什么样的直径上面能够承受多大的重力

2364
01:31:07,000 --> 01:31:07,000
就是

2365
01:31:08,000 --> 01:31:13,000
在现实生活里面在实体世界里面有很多东西的数值

2366
01:31:13,000 --> 01:31:14,000
真的不是

2367
01:31:14,000 --> 01:31:16,000
可以算出来的就比如说化学或者是

2368
01:31:17,000 --> 01:31:18,000
但是这个是扯远

2369
01:31:18,000 --> 01:31:20,000
就很大一部分程度上

2370
01:31:20,000 --> 01:31:23,000
我们对于很多材料的认知

2371
01:31:23,000 --> 01:31:24,000
都是

2372
01:31:24,000 --> 01:31:28,000
非常愚蠢的去拿在实验室里面不停的去试

2373
01:31:28,000 --> 01:31:29,000
试出来

2374
01:31:31,000 --> 01:31:33,000
包括合金或者是

2375
01:31:34,000 --> 01:31:37,000
算了不说这些了但总之最重要的一点就是

2376
01:31:37,000 --> 01:31:38,000
在现实生活里面

2377
01:31:38,000 --> 01:31:40,000
在现实生活里面测试本身就已经是一个

2378
01:31:41,000 --> 01:31:42,000
比较

2379
01:31:42,000 --> 01:31:43,000
fundamental 的东西

2380
01:31:43,000 --> 01:31:46,000
它如此的四中间观以至于你有可能

2381
01:31:47,000 --> 01:31:49,000
不会去重视它因为

2382
01:31:50,000 --> 01:31:53,000
如果你是一个建筑工人的话或者如果你是一个

2383
01:31:53,000 --> 01:31:54,000
材料

2384
01:31:54,000 --> 01:31:59,000
力学专家的话你可能会觉得我在那个软件里面拖一拖

2385
01:31:59,000 --> 01:32:00,000
线图然后

2386
01:32:01,000 --> 01:32:04,000
它自动不就会帮我估算出来这个东西

2387
01:32:04,000 --> 01:32:07,000
大概有什么样的能够承受多大的重量吗

2388
01:32:07,000 --> 01:32:08,000
但实际上

2389
01:32:08,000 --> 01:32:10,000
这个数字本身就是

2390
01:32:11,000 --> 01:32:14,000
首先通过测试才能得到的好吗

2391
01:32:15,000 --> 01:32:15,000
OK

2392
01:32:15,000 --> 01:32:21,000
然后这个是其实对应软件的这个所谓的 unit test 保证每一个

2393
01:32:21,000 --> 01:32:23,000
结构就是每一个 component

2394
01:32:23,000 --> 01:32:25,000
每个组件是正确的

2395
01:32:27,000 --> 01:32:28,000
是意思吗

2396
01:32:28,000 --> 01:32:30,000
差不多吧但实际上

2397
01:32:31,000 --> 01:32:32,000
软件的 unit test

2398
01:32:33,000 --> 01:32:37,000
更如果一定要在建筑里面找出一个对应的话

2399
01:32:37,000 --> 01:32:38,000
的话可能更像

2400
01:32:38,000 --> 01:32:39,000
是说

2401
01:32:40,000 --> 01:32:42,000
OK 我为这个楼设计了

2402
01:32:45,000 --> 01:32:45,000
一层

2403
01:32:46,000 --> 01:32:47,000
然后我要在

2404
01:32:48,000 --> 01:32:52,000
我就想起小姐姐说的对你拿小姐说的那个体育馆的意思吧

2405
01:32:52,000 --> 01:32:54,000
就是他设计了一个体育馆

2406
01:32:54,000 --> 01:32:55,000
然后体育馆里面

2407
01:32:55,000 --> 01:32:57,000
每一层要摆上 20 个厕所

2408
01:32:58,000 --> 01:33:01,000
那 unit test 更像是说

2409
01:33:02,000 --> 01:33:03,000
把每一个厕所

2410
01:33:04,000 --> 01:33:07,000
假如每个厕所都可以做成一个预购件的话

2411
01:33:07,000 --> 01:33:08,000
把每一个厕所都做成一个预购件的话

2412
01:33:08,000 --> 01:33:12,000
把每个厕所的预购件拿出来单独给它通上水通上电

2413
01:33:12,000 --> 01:33:13,000
然后

2414
01:33:14,000 --> 01:33:15,000
你进去使用一次

2415
01:33:16,000 --> 01:33:17,000
然后看它能不能充水

2416
01:33:19,000 --> 01:33:24,000
或者说你进去用一次之后看看它有没有什么不合理的地方

2417
01:33:25,000 --> 01:33:26,000
这才更接近一个 unit test

2418
01:33:27,000 --> 01:33:27,000
然后

2419
01:33:28,000 --> 01:33:29,000
最重要的一点就是

2420
01:33:29,000 --> 01:33:31,000
世界上没有两栋建筑是一模一样的

2421
01:33:33,000 --> 01:33:34,000
Wait a second

2422
01:33:36,000 --> 01:33:38,000
脑中浮现出来

2423
01:33:38,000 --> 01:33:40,000
脑中浮现出了这个

2424
01:33:41,000 --> 01:33:43,000
社会主义国家里面那些

2425
01:33:43,000 --> 01:33:44,000
非常

2426
01:33:44,000 --> 01:33:46,000
一个小厕所简直都是一样的

2427
01:33:47,000 --> 01:33:50,000
有个笑话说把你截到一个中国三线城市

2428
01:33:51,000 --> 01:33:52,000
的郊区扔下来

2429
01:33:52,000 --> 01:33:55,000
给你一个小时的时间让你找出自己是在哪个城市

2430
01:33:56,000 --> 01:33:56,000
你是找不出来的

2431
01:34:01,000 --> 01:34:05,000
软件里面可能也是很多软件都彼此相似但是

2432
01:34:05,000 --> 01:34:07,000
没有两个软件是彼此相同的

2433
01:34:07,000 --> 01:34:08,000
所以

2434
01:34:08,000 --> 01:34:10,000
如果你不写测试的话

2435
01:34:11,000 --> 01:34:16,000
很有可能在你认为这个软件的这一部分应该

2436
01:34:17,000 --> 01:34:18,000
那样

2437
01:34:18,000 --> 01:34:19,000
工作的

2438
01:34:20,000 --> 01:34:24,000
这个想法本身就是没有办法验证而且不成立

2439
01:34:24,000 --> 01:34:25,000
最终你会发现它是不成立的

2440
01:34:30,000 --> 01:34:31,000
另外一个就是

2441
01:34:32,000 --> 01:34:34,000
有些软件是

2442
01:34:35,000 --> 01:34:38,000
无关紧要的比如说你打一个 hello world 然后

2443
01:34:38,000 --> 01:34:44,000
你可能最后会露了那个换行符或者是你把 hello world 打成了

2444
01:34:44,000 --> 01:34:45,000
HAL

2445
01:34:46,000 --> 01:34:50,000
这些都是无关紧要的但是另外一些软件则是人命关天的比如说你

2446
01:34:51,000 --> 01:34:52,000
你开着车

2447
01:34:52,000 --> 01:34:53,000
那个

2448
01:34:54,000 --> 01:34:55,000
控制刹车的部分

2449
01:34:55,000 --> 01:34:56,000
或者控制转向的部分

2450
01:34:57,000 --> 01:35:00,000
如果这个部分的软件出了问题那很有可能是

2451
01:35:00,000 --> 01:35:01,000
会死的

2452
01:35:02,000 --> 01:35:05,000
我们之前请到了那个元浩哥哥

2453
01:35:05,000 --> 01:35:06,000
他

2454
01:35:06,000 --> 01:35:07,000
在

2455
01:35:07,000 --> 01:35:08,000
他所在的那个

2456
01:35:08,000 --> 01:35:09,000
那家 electro bits

2457
01:35:10,000 --> 01:35:12,000
所做的工作

2458
01:35:13,000 --> 01:35:14,000
之所以会非常

2459
01:35:15,000 --> 01:35:18,000
强调测试就是因为他们的软件

2460
01:35:18,000 --> 01:35:24,000
里面有四个人身伤害的标准如果没有记错的话第一个标准是

2461
01:35:24,000 --> 01:35:25,000
这个软件如果

2462
01:35:26,000 --> 01:35:26,000
出了问题

2463
01:35:27,000 --> 01:35:30,000
有可能这个标准的第一等级就是如果

2464
01:35:30,000 --> 01:35:32,000
这个软件出了问题

2465
01:35:32,000 --> 01:35:33,000
那

2466
01:35:33,000 --> 01:35:35,000
可能会有一个人受伤

2467
01:35:36,000 --> 01:35:38,000
第二等级是如果这个软件出了问题

2468
01:35:38,000 --> 01:35:40,000
可能会有一个人死亡

2469
01:35:41,000 --> 01:35:44,000
第三个等级是如果这个软件出了问题可能会有多个人受伤

2470
01:35:45,000 --> 01:35:46,000
第四个等级就是

2471
01:35:46,000 --> 01:35:48,000
可能会有多个人死亡

2472
01:35:48,000 --> 01:35:49,000
你看看人家的这个

2473
01:35:49,000 --> 01:35:52,000
人这个软件的危险标准是这么来的

2474
01:35:53,000 --> 01:35:56,000
在这样如果你是负责开发这样一个软件的话

2475
01:35:56,000 --> 01:35:57,000
可能

2476
01:35:58,000 --> 01:35:59,000
不是可能就是

2477
01:35:59,000 --> 01:36:01,000
任何级别的测试都是必不可少

2478
01:36:03,000 --> 01:36:05,000
所以其实面对这种

2479
01:36:05,000 --> 01:36:06,000
我理解你说那个意思啊

2480
01:36:06,000 --> 01:36:07,000
就是面对这种所谓的

2481
01:36:07,000 --> 01:36:08,000
Mission critical 的

2482
01:36:08,000 --> 01:36:09,000
组件

2483
01:36:09,000 --> 01:36:14,000
不是更应该从源头上去解决他的问题而不是依赖过度依赖于测试吗

2484
01:36:14,000 --> 01:36:15,000
呃

2485
01:36:15,000 --> 01:36:16,000
就是

2486
01:36:17,000 --> 01:36:21,000
我刚才一直在试图绕开你的问题就是你会你想说

2487
01:36:21,000 --> 01:36:24,000
好的架构可以取代测试

2488
01:36:26,000 --> 01:36:28,000
不不不这面有可能要再解释一下

2489
01:36:28,000 --> 01:36:29,000
就是说

2490
01:36:31,000 --> 01:36:33,000
好的架构可以减轻对于测试的依赖

2491
01:36:34,000 --> 01:36:36,000
我觉得就是一个

2492
01:36:36,000 --> 01:36:38,000
验证一个软件正确性的方法

2493
01:36:38,000 --> 01:36:39,000
有两个吗

2494
01:36:39,000 --> 01:36:40,000
一个是你测出他

2495
01:36:40,000 --> 01:36:42,000
所有的输入所有的输出

2496
01:36:42,000 --> 01:36:43,000
对吧

2497
01:36:43,000 --> 01:36:46,000
如果他这个这个输入输出是一个有限级的话

2498
01:36:46,000 --> 01:36:50,000
你看是不是符合你的预期吧就暴力暴力重聚法

2499
01:36:50,000 --> 01:36:52,000
但是另外一个方法就是说

2500
01:36:53,000 --> 01:36:55,000
你跟他做那个逻辑分析

2501
01:36:55,000 --> 01:36:57,000
我们叫 formal verification

2502
01:36:58,000 --> 01:37:00,000
就是你给你给他一个描述

2503
01:37:01,000 --> 01:37:03,000
他应该怎么怎么样然后你通过一些

2504
01:37:03,000 --> 01:37:04,000
正式的方法

2505
01:37:05,000 --> 01:37:06,000
formal

2506
01:37:06,000 --> 01:37:07,000
对正式的方法

2507
01:37:07,000 --> 01:37:08,000
形式方法应该说

2508
01:37:08,000 --> 01:37:10,000
对形式的方法去

2509
01:37:10,000 --> 01:37:13,000
证明他确实是为按照这种情况没有特例

2510
01:37:14,000 --> 01:37:14,000
没有考虑过的

2511
01:37:15,000 --> 01:37:16,000
对吧

2512
01:37:16,000 --> 01:37:17,000
所以

2513
01:37:17,000 --> 01:37:21,000
测试其实是在我说的前途嘛就是去看他的

2514
01:37:21,000 --> 01:37:22,000
输入输出

2515
01:37:22,000 --> 01:37:24,000
然后看我们选取一些点

2516
01:37:25,000 --> 01:37:26,000
比如说一些比较奇怪的点

2517
01:37:26,000 --> 01:37:27,000
看会出什么问题

2518
01:37:27,000 --> 01:37:28,000
选取正常的点看是不是

2519
01:37:29,000 --> 01:37:30,000
产生符合我们预期的

2520
01:37:30,000 --> 01:37:31,000
答案

2521
01:37:31,000 --> 01:37:33,000
选择一些奇怪点看是不是

2522
01:37:33,000 --> 01:37:35,000
出现我们预期的异常或者错误

2523
01:37:36,000 --> 01:37:36,000
对吧

2524
01:37:36,000 --> 01:37:38,000
但其实这个覆盖和

2525
01:37:38,000 --> 01:37:40,000
有一个 formal verification

2526
01:37:40,000 --> 01:37:41,000
就是正

2527
01:37:41,000 --> 01:37:41,000
什么

2528
01:37:42,000 --> 01:37:43,000
这不叫正式

2529
01:37:43,000 --> 01:37:44,000
形式证明

2530
01:37:45,000 --> 01:37:46,000
对形式证明的

2531
01:37:46,000 --> 01:37:48,000
这个得出的结论是完全不具有

2532
01:37:49,000 --> 01:37:50,000
可比性的因为一个是说

2533
01:37:50,000 --> 01:37:52,000
我们有 50%的

2534
01:37:52,000 --> 01:37:53,000
5%的把握证明

2535
01:37:54,000 --> 01:37:55,000
他们应该没问题

2536
01:37:55,000 --> 01:37:56,000
好这边形式证明是说

2537
01:37:56,000 --> 01:37:57,000
我们把我们的确定

2538
01:37:58,000 --> 01:37:58,000
他不会出错

2539
01:37:59,000 --> 01:38:00,000
你明白我意思吗

2540
01:38:01,000 --> 01:38:03,000
但我觉得有两点

2541
01:38:03,000 --> 01:38:04,000
首先

2542
01:38:04,000 --> 01:38:05,000
第一点是

2543
01:38:05,000 --> 01:38:07,000
你通过形式证明

2544
01:38:08,000 --> 01:38:10,000
知道了

2545
01:38:10,000 --> 01:38:13,000
这一个软件这样写应该没有问题

2546
01:38:13,000 --> 01:38:17,000
但是你仍旧没有办法确定说你写出来的就一定

2547
01:38:18,000 --> 01:38:19,000
完全符合你的形式证明

2548
01:38:20,000 --> 01:38:20,000
比如说

2549
01:38:20,000 --> 01:38:22,000
你在某个地方多打了一个点

2550
01:38:22,000 --> 01:38:25,000
或者是在某个地方把加号写成了成号

2551
01:38:26,000 --> 01:38:29,000
这些东西都是没有办法通过形式证明来

2552
01:38:29,000 --> 01:38:30,000
唯一确认的

2553
01:38:32,000 --> 01:38:36,000
可以吧如果你把那个 specification 写的足够

2554
01:38:37,000 --> 01:38:38,000
但你可以说这个界限

2555
01:38:38,000 --> 01:38:39,000
就比较模糊了对吧

2556
01:38:40,000 --> 01:38:42,000
如果这个 specification 就写的那么详细的

2557
01:38:43,000 --> 01:38:44,000
这不就是 BDD 吗

2558
01:38:44,000 --> 01:38:46,000
这不就是 Behaviour Driven Development 吗

2559
01:38:46,000 --> 01:38:49,000
这不就是测试先行驱动的一种特殊形式

2560
01:38:51,000 --> 01:38:52,000
然后其次第二点是

2561
01:38:55,000 --> 01:38:56,000
做形式分析是非常花时间的

2562
01:38:57,000 --> 01:38:59,000
而且很多时候是不可能的

2563
01:38:59,000 --> 01:39:03,000
而现代软件里面有很大的一个问题就是你刚才说

2564
01:39:03,000 --> 01:39:05,000
如果你知道自己想要什么

2565
01:39:05,000 --> 01:39:08,000
但现在的问题就是在很多领域里面

2566
01:39:08,000 --> 01:39:11,000
最终负责验收业软件的那个人

2567
01:39:12,000 --> 01:39:14,000
是不知道自己要什么的

2568
01:39:14,000 --> 01:39:16,000
只有把它做出来才知道自己要什么

2569
01:39:17,000 --> 01:39:21,000
这个可能就是学院派和工程派做事情的不同的一个出发点我觉得

2570
01:39:22,000 --> 01:39:24,000
对这就是 V 型模型

2571
01:39:24,000 --> 01:39:29,000
瀑布模型和螺旋模型就是敏捷模型最大的区别

2572
01:39:31,000 --> 01:39:32,000
你要解释一下吗

2573
01:39:33,000 --> 01:39:34,000
这个

2574
01:39:34,000 --> 01:39:35,000
好吧

2575
01:39:35,000 --> 01:39:38,000
有一个问题就是我没学过人家个人的个人

2576
01:39:38,000 --> 01:39:39,000
你学过人家工程吗

2577
01:39:39,000 --> 01:39:40,000
你也没学过

2578
01:39:41,000 --> 01:39:41,000
对啊

2579
01:39:41,000 --> 01:39:43,000
本质上我是一个学通信的人

2580
01:39:43,000 --> 01:39:44,000
然后

2581
01:39:44,000 --> 01:39:46,000
本质上我不是学 CS 的人

2582
01:39:46,000 --> 01:39:49,000
好吧我就因为了解释一下

2583
01:39:49,000 --> 01:39:50,000
所谓

2584
01:39:50,000 --> 01:39:53,000
瀑布模型的意思就是

2585
01:39:54,000 --> 01:39:54,000
你就像

2586
01:39:55,000 --> 01:39:56,000
盖房子一样

2587
01:39:56,000 --> 01:39:58,000
一上来给你一个蓝图

2588
01:39:58,000 --> 01:40:01,000
假设你是业主你

2589
01:40:02,000 --> 01:40:03,000
就像对我的

2590
01:40:04,000 --> 01:40:05,000
同事正在盖房子他

2591
01:40:05,000 --> 01:40:08,000
经历过程首先你去一个设计师书馆

2592
01:40:08,000 --> 01:40:11,000
说我买了一亩地

2593
01:40:11,000 --> 01:40:13,000
然后我要在这亩地上盖一个房子

2594
01:40:14,000 --> 01:40:15,000
然后

2595
01:40:15,000 --> 01:40:16,000
设计师公司说行

2596
01:40:16,000 --> 01:40:18,000
然后他拿了这个

2597
01:40:18,000 --> 01:40:23,000
这个小区的规划比如说德国有一个小区规定说房顶必须是尖的然后尖的这个

2598
01:40:24,000 --> 01:40:26,000
角度必须是多少度以上

2599
01:40:27,000 --> 01:40:29,000
他拿了一大堆 regulation

2600
01:40:29,000 --> 01:40:33,000
然后我帮你看一遍说好根据这些 regulation 我可以给你

2601
01:40:35,000 --> 01:40:36,000
三个房型

2602
01:40:37,000 --> 01:40:38,000
然后你看着三个房型

2603
01:40:38,000 --> 01:40:42,000
然后看着三个房型的平面图看着三个房型的效果图

2604
01:40:43,000 --> 01:40:49,000
看着三个房型的内部结构图然后你说好我要我觉得这间房子太小了我要把它改大一点

2605
01:40:49,000 --> 01:40:50,000
然后经过这个过程

2606
01:40:51,000 --> 01:40:53,000
你最终确定一个方案你要在这个方案上签字

2607
01:40:54,000 --> 01:40:55,000
然后

2608
01:40:56,000 --> 01:40:58,000
这个设计公司把他

2609
01:40:58,000 --> 01:41:01,000
交给他们认识的一个包工头然后包工头开始干

2610
01:41:01,000 --> 01:41:02,000
然后

2611
01:41:02,000 --> 01:41:05,000
干上一段时间你隔一段时间去看一看然后这个

2612
01:41:06,000 --> 01:41:07,000
你

2613
01:41:07,000 --> 01:41:08,000
会看到他

2614
01:41:08,000 --> 01:41:13,000
挖一个坑然后打地基然后盖第一层盖第二层把预制板插上盖第三层然后

2615
01:41:13,000 --> 01:41:15,000
外墙装修内装修最后

2616
01:41:16,000 --> 01:41:17,000
水道去上

2617
01:41:18,000 --> 01:41:18,000
这么一个

2618
01:41:19,000 --> 01:41:25,000
你拿到了你拿到一间和自己最初的图纸可能略有出入但是基本上是你想象的那个样子

2619
01:41:26,000 --> 01:41:26,000
房子

2620
01:41:26,000 --> 01:41:29,000
这是一个在实体世界里面非常司空见惯的事情

2621
01:41:29,000 --> 01:41:30,000
然后

2622
01:41:30,000 --> 01:41:35,000
在软件工程的早期人们也的确是这样做的就是一开始就找一些

2623
01:41:35,000 --> 01:41:37,000
最终会使用软件的人说

2624
01:41:37,000 --> 01:41:38,000
哦

2625
01:41:38,000 --> 01:41:40,000
你最终会拿到的可能是这个样子的

2626
01:41:40,000 --> 01:41:42,000
然后你按这个按钮就会出现那个

2627
01:41:43,000 --> 01:41:45,000
点这里就会做那个

2628
01:41:45,000 --> 01:41:47,000
然后按下这个按钮

2629
01:41:47,000 --> 01:41:49,000
核弹就会飞起来之类的

2630
01:41:50,000 --> 01:41:52,000
这所谓的需求文档吗

2631
01:41:52,000 --> 01:41:53,000
对

2632
01:41:53,000 --> 01:41:55,000
首先你有一套需求文档就像房子蓝图一样

2633
01:41:56,000 --> 01:41:57,000
接下来软件工程的

2634
01:41:58,000 --> 01:41:58,000
团队开始施工

2635
01:41:59,000 --> 01:42:01,000
然后在这个施工过程中你是没有办法去

2636
01:42:03,000 --> 01:42:04,000
勒令他们停下来

2637
01:42:04,000 --> 01:42:06,000
说不行我不要这套房子了

2638
01:42:06,000 --> 01:42:07,000
我把他

2639
01:42:08,000 --> 01:42:11,000
我把他重新建一面或者说不对这个地方我要

2640
01:42:11,000 --> 01:42:13,000
本来我是三层楼然后我现在改成五层

2641
01:42:14,000 --> 01:42:17,000
这些这都是不行的在那个美好的时代

2642
01:42:18,000 --> 01:42:19,000
如果你是一个

2643
01:42:19,000 --> 01:42:21,000
足够土豪的甲方好像是可以的吧

2644
01:42:25,000 --> 01:42:27,000
如果是一个足够土豪的甲方

2645
01:42:28,000 --> 01:42:30,000
你所面临的

2646
01:42:30,000 --> 01:42:36,000
损失仍旧远远不如你从一开始就明确的知道自己要什么要来

2647
01:42:36,000 --> 01:42:37,000
当然这个没错

2648
01:42:37,000 --> 01:42:38,000
没错

2649
01:42:38,000 --> 01:42:39,000
我觉得

2650
01:42:39,000 --> 01:42:42,000
瀑布这个使用的很好就是你知道瀑布的水都是往下走的对吧

2651
01:42:42,000 --> 01:42:43,000
一线而下

2652
01:42:44,000 --> 01:42:44,000
你是

2653
01:42:44,000 --> 01:42:45,000
在

2654
01:42:45,000 --> 01:42:48,000
这个瀑布模型里面的任何一步都是回不了头的

2655
01:42:48,000 --> 01:42:48,000
现在盖房子

2656
01:42:49,000 --> 01:42:52,000
而反过来敏捷模型则是

2657
01:42:53,000 --> 01:42:55,000
在软件瀑布发展的

2658
01:42:56,000 --> 01:42:57,000
90 年代

2659
01:42:58,000 --> 01:43:00,000
人们终于有

2660
01:43:00,000 --> 01:43:04,000
怎么说终于有更多的人可以有这个资本去

2661
01:43:05,000 --> 01:43:06,000
买

2662
01:43:07,000 --> 01:43:08,000
或者说定购

2663
01:43:08,000 --> 01:43:09,000
一套属于他们自己的软件

2664
01:43:10,000 --> 01:43:11,000
比如说一些小商贩啊

2665
01:43:11,000 --> 01:43:17,000
一个小公司啊可以有自己的网站或者是可以有自己专门的应用

2666
01:43:17,000 --> 01:43:20,000
此时人们发现了一个问题就是

2667
01:43:20,000 --> 01:43:22,000
早期的瀑布模型再也进不通了

2668
01:43:22,000 --> 01:43:24,000
因为很多很多人是

2669
01:43:25,000 --> 01:43:26,000
包括你和我

2670
01:43:26,000 --> 01:43:27,000
都是那些

2671
01:43:27,000 --> 01:43:29,000
不知道自己要什么

2672
01:43:30,000 --> 01:43:31,000
对于自己的想象力和

2673
01:43:32,000 --> 01:43:33,000
怎么说呢

2674
01:43:33,000 --> 01:43:37,000
高估了自己的想象力同时又低估了自己的野心这门确认

2675
01:43:38,000 --> 01:43:39,000
可以站在那边

2676
01:43:39,000 --> 01:43:39,000
表达能力啊

2677
01:43:40,000 --> 01:43:40,000
对

2678
01:43:42,000 --> 01:43:43,000
有了一点

2679
01:43:43,000 --> 01:43:50,000
资本可以来做一个项目的验收方的时候他们你会发现这些人是

2680
01:43:50,000 --> 01:43:51,000
完全没有

2681
01:43:51,000 --> 01:43:52,000
办法

2682
01:43:52,000 --> 01:43:53,000
在

2683
01:43:53,000 --> 01:43:56,000
瀑布模型之下工作

2684
01:43:56,000 --> 01:43:57,000
无法验收

2685
01:43:58,000 --> 01:43:59,000
对你一开始给他

2686
01:44:00,000 --> 01:44:02,000
跟他答应了好好的一些东西他

2687
01:44:02,000 --> 01:44:03,000
做了一半

2688
01:44:03,000 --> 01:44:06,000
你给他看一个半成品的时候他说我靠

2689
01:44:06,000 --> 01:44:07,000
我用的不是这样的

2690
01:44:08,000 --> 01:44:11,000
在这种情况之下呢

2691
01:44:12,000 --> 01:44:14,000
人们就推出一种叫做

2692
01:44:14,000 --> 01:44:16,000
extreme program

2693
01:44:17,000 --> 01:44:17,000
对早期

2694
01:44:18,000 --> 01:44:19,000
extreme program 早于 agile

2695
01:44:21,000 --> 01:44:22,000
推出一种所谓

2696
01:44:23,000 --> 01:44:25,000
XP 就是极限编程的这么一种理念

2697
01:44:25,000 --> 01:44:27,000
就是在这种模型之下呢

2698
01:44:28,000 --> 01:44:32,000
你一开始只问这个最终客户很小的一个问题

2699
01:44:32,000 --> 01:44:33,000
比如说

2700
01:44:34,000 --> 01:44:36,000
打个比方吧你希望你的网站

2701
01:44:36,000 --> 01:44:38,000
你希望你的网站基色是什么也行

2702
01:44:38,000 --> 01:44:39,000
你希望你的网站基色是纯纯色的

2703
01:44:39,000 --> 01:44:40,000
他说蓝色

2704
01:44:40,000 --> 01:44:41,000
然后你好

2705
01:44:41,000 --> 01:44:42,000
写一网页然后把

2706
01:44:42,000 --> 01:44:45,000
这个背景换成某种蓝色说这样吗

2707
01:44:46,000 --> 01:44:48,000
客户一看说我靠

2708
01:44:48,000 --> 01:44:49,000
纯蓝色怎么这么丑

2709
01:44:49,000 --> 01:44:50,000
不行我要粉红色

2710
01:44:51,000 --> 01:44:51,000
好

2711
01:44:51,000 --> 01:44:52,000
你马上就可以换成粉红色

2712
01:44:53,000 --> 01:44:54,000
然后

2713
01:44:54,000 --> 01:44:54,000
就算什么

2714
01:44:55,000 --> 01:44:57,000
就也算是交后式编程了吧

2715
01:44:57,000 --> 01:44:59,000
对这就是一个非常非常小的迭代

2716
01:45:00,000 --> 01:45:00,000
iteration

2717
01:45:01,000 --> 01:45:05,000
在这个过程中你首先确立了用户一个非常基本的需求

2718
01:45:05,000 --> 01:45:06,000
然后你把这个需求实现出来

2719
01:45:07,000 --> 01:45:08,000
实现出来

2720
01:45:08,000 --> 01:45:10,000
这一部分最小的功能找客户去反馈

2721
01:45:11,000 --> 01:45:11,000
客户

2722
01:45:11,000 --> 01:45:15,000
对你的反馈如果是正的话你就可以继续做下去如果是负的话你就要改

2723
01:45:16,000 --> 01:45:16,000
然后

2724
01:45:17,000 --> 01:45:18,000
把整个

2725
01:45:18,000 --> 01:45:19,000
软件工程的

2726
01:45:21,000 --> 01:45:24,000
过程切分为很多很多这样的

2727
01:45:24,000 --> 01:45:25,000
很小的迭代过程

2728
01:45:26,000 --> 01:45:28,000
如果你画成一个图的话大概就是

2729
01:45:29,000 --> 01:45:32,000
一个越做越大的软件不停的经历这样的 iteration

2730
01:45:32,000 --> 01:45:35,000
最终画出来就是一个大概螺旋性的这么一个

2731
01:45:37,000 --> 01:45:37,000
唉

2732
01:45:38,000 --> 01:45:38,000
应该怎么说呢

2733
01:45:38,000 --> 01:45:39,000
进度度

2734
01:45:40,000 --> 01:45:41,000
这就是我

2735
01:45:41,000 --> 01:45:45,000
这是我刚才提到的泡沫情况和敏捷模型之间的区别

2736
01:45:45,000 --> 01:45:47,000
所以敏捷编程或者说

2737
01:45:48,000 --> 01:45:51,000
极限编程所解决的问题就是

2738
01:45:51,000 --> 01:45:53,000
如何应对需求的改变

2739
01:45:54,000 --> 01:45:54,000
对吧

2740
01:45:55,000 --> 01:45:56,000
那

2741
01:45:56,000 --> 01:45:58,000
怎么才能知道

2742
01:45:58,000 --> 01:45:59,000
一个需求的改变

2743
01:46:00,000 --> 01:46:02,000
有没有准确的在

2744
01:46:04,000 --> 01:46:06,000
不管是被更改的软件也好还是

2745
01:46:06,000 --> 01:46:07,000
刚刚

2746
01:46:07,000 --> 01:46:10,000
写出来的软件的新的那一部分里面

2747
01:46:11,000 --> 01:46:12,000
正确的实现出来的呢

2748
01:46:13,000 --> 01:46:16,000
那这个时候软件测试的意义也就凸显出来了

2749
01:46:21,000 --> 01:46:23,000
也就是说比如说

2750
01:46:24,000 --> 01:46:25,000
客户

2751
01:46:25,000 --> 01:46:27,000
告诉你说这个地方

2752
01:46:27,000 --> 01:46:29,000
我希望他

2753
01:46:29,000 --> 01:46:31,000
在最终的成品里面

2754
01:46:31,000 --> 01:46:34,000
一个按钮是在另外一个按钮的左边的

2755
01:46:34,000 --> 01:46:35,000
那你就可以写一个测试去

2756
01:46:36,000 --> 01:46:37,000
判断

2757
01:46:37,000 --> 01:46:39,000
这个两个按钮的 ID

2758
01:46:39,000 --> 01:46:41,000
以及他们之间相关位置

2759
01:46:41,000 --> 01:46:42,000
是不是正

2760
01:46:42,000 --> 01:46:42,000
比如说

2761
01:46:43,000 --> 01:46:45,000
右边这个按钮的 ID 的

2762
01:46:45,000 --> 01:46:45,000
X

2763
01:46:47,000 --> 01:46:49,000
对 X-去左边这个按钮的

2764
01:46:49,000 --> 01:46:49,000
X

2765
01:46:50,000 --> 01:46:52,000
如果他是正的话就可以确定说这个按钮是在

2766
01:46:52,000 --> 01:46:53,000
另外一个按钮的右边

2767
01:46:55,000 --> 01:46:56,000
我觉得可以说

2768
01:46:56,000 --> 01:46:58,000
正是

2769
01:46:58,000 --> 01:47:03,000
敏捷的这个过程或者说整个软件工程向敏捷这个方向

2770
01:47:04,000 --> 01:47:05,000
所转移的这样一个

2771
01:47:07,000 --> 01:47:08,000
范式迁移

2772
01:47:08,000 --> 01:47:10,000
导致现在这样一个

2773
01:47:10,000 --> 01:47:14,000
人们相对来说比较强调测试的什么一个状态

2774
01:47:15,000 --> 01:47:17,000
所以其实如果归纳来讲就是说

2775
01:47:19,000 --> 01:47:20,000
需求不明确

2776
01:47:20,000 --> 01:47:21,000
然后这个

2777
01:47:21,000 --> 01:47:22,000
就是

2778
01:47:22,000 --> 01:47:24,000
形式证明不可能的情况下

2779
01:47:24,000 --> 01:47:26,000
我们只能用测试来尽可能的保障

2780
01:47:27,000 --> 01:47:27,000
我们在

2781
01:47:30,000 --> 01:47:33,000
快速迭代中能够有一个相对稳定的产品质量

2782
01:47:34,000 --> 01:47:34,000
对

2783
01:47:34,000 --> 01:47:37,000
就是因为测试会给你一个比较

2784
01:47:37,000 --> 01:47:39,000
清晰的一个比较客观的

2785
01:47:40,000 --> 01:47:42,000
关于你的这个

2786
01:47:42,000 --> 01:47:44,000
软件产品的质量的反应

2787
01:47:46,000 --> 01:47:52,000
所以才能让你有信心去执行一个比较敏捷的软件迭代的过程

2788
01:47:52,000 --> 01:47:53,000
因为

2789
01:47:53,000 --> 01:47:55,000
很有可能说

2790
01:47:55,000 --> 01:47:58,000
如果你不写测试的话你可能做了一部分

2791
01:48:00,000 --> 01:48:01,000
去弄坏另一部分

2792
01:48:01,000 --> 01:48:03,000
而直到你在最后给

2793
01:48:03,000 --> 01:48:05,000
客户演示的时候这个 bug 才暴露出来

2794
01:48:05,000 --> 01:48:06,000
我们知道

2795
01:48:06,000 --> 01:48:07,000
根据莫非定律

2796
01:48:07,000 --> 01:48:08,000
这种情况是永远会出

2797
01:48:08,000 --> 01:48:09,000
会出现的

2798
01:48:10,000 --> 01:48:10,000
而

2799
01:48:10,000 --> 01:48:11,000
书写

2800
01:48:11,000 --> 01:48:13,000
足够多的测试以及

2801
01:48:14,000 --> 01:48:16,000
执行所谓回归测试可以帮助你

2802
01:48:17,000 --> 01:48:18,000
减少这种情况的发生

2803
01:48:20,000 --> 01:48:20,000
然后

2804
01:48:21,000 --> 01:48:23,000
另外一方面如果你

2805
01:48:23,000 --> 01:48:24,000
一定要写测试的话

2806
01:48:25,000 --> 01:48:26,000
首先你

2807
01:48:26,000 --> 01:48:28,000
得写出能够被测试的代码

2808
01:48:29,000 --> 01:48:30,000
然后

2809
01:48:30,000 --> 01:48:31,000
这样一来

2810
01:48:31,000 --> 01:48:33,000
你如果在写代码的时候会想到说啊

2811
01:48:33,000 --> 01:48:34,000
这个地方要被测试了

2812
01:48:35,000 --> 01:48:37,000
那你可能会强迫自己写一些

2813
01:48:37,000 --> 01:48:39,000
比较干净的

2814
01:48:39,000 --> 01:48:40,000
比较模块化的代码

2815
01:48:41,000 --> 01:48:45,000
然后这也会从另外一方面去帮助你提升整个软件的

2816
01:48:46,000 --> 01:48:48,000
可控程度以及整个质量

2817
01:48:48,000 --> 01:48:51,000
然后我们刚才提到的一个所谓

2818
01:48:52,000 --> 01:48:52,000
软件

2819
01:48:53,000 --> 01:48:55,000
测试驱动开发的这么一个概念

2820
01:48:56,000 --> 01:48:56,000
就

2821
01:48:58,000 --> 01:48:58,000
TDD

2822
01:48:59,000 --> 01:49:00,000
对 TDD

2823
01:49:00,000 --> 01:49:02,000
TDD 是什么呢就是

2824
01:49:02,000 --> 01:49:04,000
人们一发现这个

2825
01:49:04,000 --> 01:49:05,000
驱动

2826
01:49:05,000 --> 01:49:06,000
测试是如此好的

2827
01:49:06,000 --> 01:49:07,000
是一个东西

2828
01:49:08,000 --> 01:49:09,000
以至于有些人

2829
01:49:10,000 --> 01:49:11,000
朝这个

2830
01:49:12,000 --> 01:49:14,000
比较原教旨主义的方向发展

2831
01:49:14,000 --> 01:49:14,000
就说好

2832
01:49:15,000 --> 01:49:16,000
那我们

2833
01:49:16,000 --> 01:49:17,000
在写软件之前

2834
01:49:17,000 --> 01:49:18,000
先写测试吧

2835
01:49:19,000 --> 01:49:21,000
这就是 TDD

2836
01:49:21,000 --> 01:49:23,000
让测试成为需求的一部分

2837
01:49:26,000 --> 01:49:27,000
这还要更进一步了

2838
01:49:27,000 --> 01:49:29,000
我们先说 TDD 吧

2839
01:49:29,000 --> 01:49:31,000
TDD 最基本的一个实践就是

2840
01:49:32,000 --> 01:49:34,000
好我上来要写个 hello world

2841
01:49:35,000 --> 01:49:36,000
在我写 hello world

2842
01:49:36,000 --> 01:49:37,000
之前

2843
01:50:06,000 --> 01:50:06,000
我要写一行程序

2844
01:50:06,000 --> 01:50:08,000
但是在我写这项程序之前

2845
01:50:08,000 --> 01:50:09,000
我先要写一个

2846
01:50:10,000 --> 01:50:12,000
没有这项程序就肯定会失败的单元测试

2847
01:50:15,000 --> 01:50:17,000
那你怎么测这个 hello world

2848
01:50:17,000 --> 01:50:19,000
hello world 实在太 trivial

2849
01:50:20,000 --> 01:50:21,000
比如说我之前很喜欢的一个

2850
01:50:22,000 --> 01:50:23,000
Cata 就是

2851
01:50:23,000 --> 01:50:26,000
把阿拉伯数字转为罗马数字

2852
01:50:28,000 --> 01:50:29,000
我要写这个

2853
01:50:29,000 --> 01:50:32,000
就是我面对一门新的陌生语

2854
01:50:32,000 --> 01:50:33,000
比如说 Haskell

2855
01:50:33,000 --> 01:50:34,000
Swift

2856
01:50:34,000 --> 01:50:36,000
我首先

2857
01:50:36,000 --> 01:50:40,000
可以用其他的语言

2858
01:50:40,000 --> 01:50:42,000
来判断

2859
01:50:42,000 --> 01:50:43,000
这个语言

2860
01:50:43,000 --> 01:50:46,000
我将要学的这个语言所输出的是不是正确的

2861
01:50:46,000 --> 01:50:47,000
比如说

2862
01:50:47,000 --> 01:50:51,000
我知道阿拉伯数字的 1 会转为罗马数字的 i

2863
01:50:51,000 --> 01:50:54,000
那我就先写这样一个测试

2864
01:50:54,000 --> 01:50:55,000
这个程序运行之后

2865
01:50:56,000 --> 01:50:57,000
它应该在屏幕上

2866
01:50:57,000 --> 01:50:58,000
输出

2867
01:50:58,000 --> 01:50:59,000
或者这么说吧

2868
01:50:59,000 --> 01:51:03,000
我将要写的程序首先应该接纳一个文本文件

2869
01:51:03,000 --> 01:51:04,000
里面是

2870
01:51:04,000 --> 01:51:06,000
1 到 1000 的罗马数字

2871
01:51:06,000 --> 01:51:07,000
对

2872
01:51:08,000 --> 01:51:08,000
sorry

2873
01:51:09,000 --> 01:51:10,000
首先

2874
01:51:10,000 --> 01:51:12,000
他应该接受一个文本文件

2875
01:51:12,000 --> 01:51:14,000
然后输出另外一个文本文件

2876
01:51:14,000 --> 01:51:18,000
然后我也需要把他输出的这个文本文件和我的目标文本文件作为对比

2877
01:51:21,000 --> 01:51:22,000
比如说一开始这个

2878
01:51:23,000 --> 01:51:25,000
一开始的文本文件里面只有一个 1

2879
01:51:26,000 --> 01:51:29,000
然后在目标文件文本文件里面应该有个 i

2880
01:51:29,000 --> 01:51:34,000
当我准备好了这一切之后我才开始着手用这种新的语言

2881
01:51:35,000 --> 01:51:36,000
去写

2882
01:51:36,000 --> 01:51:36,000
我接着

2883
01:51:37,000 --> 01:51:38,000
我将要写的这个

2884
01:51:38,000 --> 01:51:41,000
我希望写的这个阿拉伯数字转成罗马数字的程序

2885
01:51:42,000 --> 01:51:42,000
好

2886
01:51:43,000 --> 01:51:44,000
然后

2887
01:51:44,000 --> 01:51:46,000
这个第二准则是

2888
01:51:46,000 --> 01:51:51,000
只编写恰好能体现一个失败情况的测试代码

2889
01:51:51,000 --> 01:51:54,000
一个比较简单的例子就是说你可以判断说

2890
01:51:55,000 --> 01:51:57,000
如果输入是阿拉伯数字 1

2891
01:51:58,000 --> 01:52:00,000
那么输出必然是罗马数字 i

2892
01:52:00,000 --> 01:52:03,000
对然后如果你先给他一个

2893
01:52:03,000 --> 01:52:05,000
因为没有功能代码就是一个空含数对吧

2894
01:52:06,000 --> 01:52:06,000
对

2895
01:52:06,000 --> 01:52:08,000
输入什么出来都是空

2896
01:52:09,000 --> 01:52:10,000
对嘛你知道

2897
01:52:10,000 --> 01:52:11,000
这个测试会挂掉

2898
01:52:11,000 --> 01:52:11,000
对

2899
01:52:12,000 --> 01:52:14,000
然后呢第 3 条准则更变态说

2900
01:52:14,000 --> 01:52:17,000
只编写恰好能通过测试的功能代码

2901
01:52:18,000 --> 01:52:19,000
这是什么概念就是

2902
01:52:20,000 --> 01:52:21,000
我们

2903
01:52:21,000 --> 01:52:23,000
完成了刚才两步一

2904
01:52:23,000 --> 01:52:26,000
在写一个测试失败单元测试之前不写功能代码

2905
01:52:26,000 --> 01:52:31,000
好我写了会让测试失败的单元测试

2906
01:52:32,000 --> 01:52:32,000
二

2907
01:52:32,000 --> 01:52:35,000
我写了刚好只能通过

2908
01:52:35,000 --> 01:52:36,000
刚好只能

2909
01:52:36,000 --> 01:52:37,000
能体现一个失败情况

2910
01:52:38,000 --> 01:52:40,000
好我给在左边文件里面给了 1

2911
01:52:41,000 --> 01:52:42,000
阿拉伯数字的 1

2912
01:52:42,000 --> 01:52:44,000
右边的文件里面给了

2913
01:52:44,000 --> 01:52:45,000
拉尼茨姆 i

2914
01:52:45,000 --> 01:52:49,000
好第 3 条我只编写恰好能通过该测试的功能代码

2915
01:52:50,000 --> 01:52:52,000
我在

2916
01:52:52,000 --> 01:52:54,000
新的程序里面写说

2917
01:52:54,000 --> 01:52:56,000
if input is 1

2918
01:52:56,000 --> 01:52:57,000
then output i

2919
01:52:58,000 --> 01:52:58,000
就可以了

2920
01:53:00,000 --> 01:53:00,000
对吧

2921
01:53:01,000 --> 01:53:01,000
对

2922
01:53:02,000 --> 01:53:03,000
那

2923
01:53:04,000 --> 01:53:05,000
这样一种比较

2924
01:53:05,000 --> 01:53:08,000
变态的开发方法

2925
01:53:09,000 --> 01:53:11,000
你仔细想一下其实

2926
01:53:11,000 --> 01:53:12,000
是很难让你

2927
01:53:13,000 --> 01:53:14,000
让一个

2928
01:53:15,000 --> 01:53:16,000
神志正常的人

2929
01:53:17,000 --> 01:53:17,000
去接受的

2930
01:53:18,000 --> 01:53:18,000
对吧

2931
01:53:18,000 --> 01:53:20,000
比如说我刚才说了一句话

2932
01:53:20,000 --> 01:53:21,000
你是说

2933
01:53:21,000 --> 01:53:22,000
TDP 的践行者

2934
01:53:22,000 --> 01:53:24,000
神志不正常

2935
01:53:24,000 --> 01:53:25,000
我也是

2936
01:53:30,000 --> 01:53:30,000
好

2937
01:53:30,000 --> 01:53:32,000
先让我话说完就是

2938
01:53:32,000 --> 01:53:33,000
如果你是一个神志正常的人的话

2939
01:53:34,000 --> 01:53:35,000
你肯定知道

2940
01:53:35,000 --> 01:53:36,000
如果输出是

2941
01:53:36,000 --> 01:53:37,000
如果输出是 1

2942
01:53:38,000 --> 01:53:39,000
直接输出 i

2943
01:53:39,000 --> 01:53:40,000
是一个非常蠢的

2944
01:53:41,000 --> 01:53:42,000
主意

2945
01:53:42,000 --> 01:53:43,000
因为

2946
01:53:43,000 --> 01:53:45,000
从一开始你就把自己

2947
01:53:45,000 --> 01:53:47,000
限定在一个

2948
01:53:48,000 --> 01:53:52,000
非常着眼欲非常短视的这么一个数不纯光的状态

2949
01:53:53,000 --> 01:53:54,000
就是你只看得到输出

2950
01:53:54,000 --> 01:53:55,000
输入是 1

2951
01:53:55,000 --> 01:53:57,000
然后也只输出 1

2952
01:53:57,000 --> 01:53:58,000
打个岔哈

2953
01:53:58,000 --> 01:53:59,000
那个

2954
01:53:59,000 --> 01:54:01,000
你觉得这个方法特别适合外包团队

2955
01:54:02,000 --> 01:54:03,000
因为你可以给别人干活

2956
01:54:03,000 --> 01:54:05,000
你先满足他的需求

2957
01:54:05,000 --> 01:54:06,000
他会插回去测嘛

2958
01:54:06,000 --> 01:54:07,000
然后

2959
01:54:07,000 --> 01:54:08,000
你干多了没有用

2960
01:54:08,000 --> 01:54:10,000
你只要干的刚刚好就可以了

2961
01:54:12,000 --> 01:54:17,000
事实上也的确是外包团队在最多使用 TDP

2962
01:54:17,000 --> 01:54:19,000
我必须这么说

2963
01:54:19,000 --> 01:54:20,000
好吧

2964
01:54:24,000 --> 01:54:25,000
总之

2965
01:54:25,000 --> 01:54:26,000
刚才你说的这句话其实是

2966
01:54:27,000 --> 01:54:29,000
有道理的就是使用 TDP 的人神志不太清楚

2967
01:54:30,000 --> 01:54:33,000
我心里其实很认同这句话因为

2968
01:54:33,000 --> 01:54:35,000
TDP 就好像安利一样

2969
01:54:36,000 --> 01:54:39,000
你只有深陷其中了你才会真正的

2970
01:54:40,000 --> 01:54:41,000
感受到他的好

2971
01:54:42,000 --> 01:54:47,000
我刚才这句话绝对不是一个一种 complement 的方式来说

2972
01:54:47,000 --> 01:54:47,000
就是

2973
01:54:48,000 --> 01:54:51,000
因为我从来没有深陷其中过所以我从来不觉得他的好

2974
01:54:51,000 --> 01:54:52,000
但是

2975
01:54:53,000 --> 01:54:57,000
somehow someway 我也可以理解其用户者所持的这样一种观点就是

2976
01:54:58,000 --> 01:55:00,000
别看你使用的这三个原则非常的愚蠢

2977
01:55:01,000 --> 01:55:03,000
但是到你开发一个大型软件的后面

2978
01:55:04,000 --> 01:55:05,000
你会发现

2979
01:55:06,000 --> 01:55:08,000
迁移放而动全身的

2980
01:55:08,000 --> 01:55:10,000
状况是经常有的

2981
01:55:11,000 --> 01:55:14,000
而如果你能坚持着用这种非常愚蠢的方法

2982
01:55:14,000 --> 01:55:17,000
把每一个最微微小的修改

2983
01:55:18,000 --> 01:55:19,000
都以

2984
01:55:19,000 --> 01:55:21,000
测试先行的方式写出来的话

2985
01:55:21,000 --> 01:55:24,000
你会发现到后期你犯一点点小错

2986
01:55:25,000 --> 01:55:26,000
都可以马上被发现出

2987
01:55:27,000 --> 01:55:27,000
而

2988
01:55:28,000 --> 01:55:32,000
所有这些被发现出来的小错保证了你的软件质量

2989
01:55:34,000 --> 01:55:34,000
对

2990
01:55:35,000 --> 01:55:39,000
然后刚才你说的这个一上来就描述整个系统的 behaviour

2991
01:55:40,000 --> 01:55:42,000
那其实是 TDD 更进一步叫做

2992
01:55:42,000 --> 01:55:44,000
BDD

2993
01:55:44,000 --> 01:55:46,000
Behaviour Driven Development

2994
01:55:47,000 --> 01:55:52,000
它的核心理念其实就是像你说的至于可以更进一步就是

2995
01:55:52,000 --> 01:55:53,000
不是用代码

2996
01:55:53,000 --> 01:55:55,000
而是用一种比较

2997
01:55:57,000 --> 01:56:00,000
项目经理也能读懂的

2998
01:56:00,000 --> 01:56:01,000
普通语言

2999
01:56:01,000 --> 01:56:02,000
大白话嘛

3000
01:56:02,000 --> 01:56:03,000
对用大白话来

3001
01:56:03,000 --> 01:56:07,000
这个近似于大白话的普通的简单的句子

3002
01:56:07,000 --> 01:56:10,000
来描述出整个系统的状态

3003
01:56:10,000 --> 01:56:12,000
不是整个系统是整个组件的状态

3004
01:56:13,000 --> 01:56:16,000
所以这个一个最古老的例子就是那个创世纪对吧

3005
01:56:17,000 --> 01:56:18,000
创世纪

3006
01:56:18,000 --> 01:56:21,000
对呀因为上次说要有光嘛

3007
01:56:22,000 --> 01:56:25,000
最早的 BDD

3008
01:56:25,000 --> 01:56:26,000
说得没错

3009
01:56:27,000 --> 01:56:30,000
只不过在 BDD 里面这个

3010
01:56:30,000 --> 01:56:32,000
创始人和

3011
01:56:32,000 --> 01:56:33,000
开发者

3012
01:56:34,000 --> 01:56:35,000
和验收人是同一个人

3013
01:56:36,000 --> 01:56:37,000
这是比较

3014
01:56:37,000 --> 01:56:38,000
操蛋的一点

3015
01:56:39,000 --> 01:56:40,000
上帝只需要说

3016
01:56:40,000 --> 01:56:42,000
上帝看着这一切是好的

3017
01:56:42,000 --> 01:56:43,000
就可以了

3018
01:56:43,000 --> 01:56:44,000
而不是

3019
01:56:44,000 --> 01:56:46,000
验收通过合格

3020
01:56:46,000 --> 01:56:49,000
上帝的老婆看到这一切把上帝揍了一顿之类的

3021
01:56:53,000 --> 01:56:55,000
你在写 BDD 的

3022
01:56:56,000 --> 01:56:57,000
你说什么太不严肃了

3023
01:57:01,000 --> 01:57:02,000
我们两个都是不可

3024
01:57:02,000 --> 01:57:03,000
我不知道你我是不可知的

3025
01:57:04,000 --> 01:57:04,000
我就是一个理论者所以

3026
01:57:05,000 --> 01:57:07,000
圣经就是一部 bullshit

3027
01:57:10,000 --> 01:57:12,000
歌王

3028
01:57:13,000 --> 01:57:16,000
希望没有 insult 到

3029
01:57:16,000 --> 01:57:17,000
足够少

3030
01:57:17,000 --> 01:57:18,000
我觉得已经发生了但是

3031
01:57:18,000 --> 01:57:19,000
doesn't matter

3032
01:57:22,000 --> 01:57:24,000
你在写这个 BDD 的

3033
01:57:25,000 --> 01:57:29,000
测试行为描述的时候就会很有那种上帝的感觉

3034
01:57:29,000 --> 01:57:31,000
play go

3035
01:57:32,000 --> 01:57:33,000
你可以说

3036
01:57:34,000 --> 01:57:34,000
it should

3037
01:57:36,000 --> 01:57:39,000
throw division by zero error

3038
01:57:39,000 --> 01:57:41,000
when input is given by zero

3039
01:57:42,000 --> 01:57:43,000
之类的句子

3040
01:57:43,000 --> 01:57:45,000
然后

3041
01:57:46,000 --> 01:57:48,000
比较牛逼的这个

3042
01:57:49,000 --> 01:57:50,000
BDD 的工具比如说

3043
01:57:51,000 --> 01:57:52,000
cucumber

3044
01:57:52,000 --> 01:57:53,000
cucumber

3045
01:57:54,000 --> 01:57:58,000
可以让可以有一个工具可以自然而然的把你的这些

3046
01:57:59,000 --> 01:57:59,000
对于

3047
01:58:00,000 --> 01:58:03,000
整个组件的行为的描述

3048
01:58:03,000 --> 01:58:05,000
转化为相应的测试代码

3049
01:58:07,000 --> 01:58:07,000
然后

3050
01:58:07,000 --> 01:58:10,000
自动的在你写出来之后帮你执行

3051
01:58:11,000 --> 01:58:12,000
这就是更重要

3052
01:58:12,000 --> 01:58:15,000
要用那个 NLP 的方式来去解析那些东西吗

3053
01:58:15,000 --> 01:58:18,000
其实是一个非常简单的 regular expression

3054
01:58:18,000 --> 01:58:19,000
如果没记错吧

3055
01:58:20,000 --> 01:58:22,000
就是用一些比较

3056
01:58:22,000 --> 01:58:24,000
规则的结构去描述那个

3057
01:58:24,000 --> 01:58:26,000
首先你在写那个

3058
01:58:27,000 --> 01:58:29,000
behaviour description 的时候就不能用

3059
01:58:30,000 --> 01:58:30,000
完全的自然语言

3060
01:58:31,000 --> 01:58:33,000
你必须用一些特定的句式就像你说的那个

3061
01:58:34,000 --> 01:58:34,000
你在

3062
01:58:35,000 --> 01:58:39,000
指使 CRE 去做什么事情的时候你必须用一个特定的范式的句子

3063
01:58:40,000 --> 01:58:43,000
然后 TDD 的这个描述语言跟它比较相似

3064
01:58:43,000 --> 01:58:45,000
就是你必须用一些特定的句式

3065
01:58:45,000 --> 01:58:46,000
it should

3066
01:58:47,000 --> 01:58:47,000
之类的

3067
01:58:47,000 --> 01:58:52,000
对其实你知道这个是为什么比较讨厌这种 BDD 的那个

3068
01:58:52,000 --> 01:58:53,000
test suite

3069
01:58:53,000 --> 01:58:55,000
一个原因就是

3070
01:58:56,000 --> 01:58:58,000
感觉好像 Apple script

3071
01:59:00,000 --> 01:59:02,000
对看起来好像都写上去但是又

3072
01:59:04,000 --> 01:59:05,000
没有真的写上去

3073
01:59:05,000 --> 01:59:07,000
然后你就很难去模糊到

3074
01:59:07,000 --> 01:59:13,000
我要到底写一个什么样的语句才能够满足他生成一个可以被他执行的 Test case 呢

3075
01:59:13,000 --> 01:59:17,000
就很郁闷不要搞这个直接给一个写正常的语句好不好

3076
01:59:18,000 --> 01:59:23,000
这可能就是怎么说呢编程语言里面的恐怖鼓里

3077
01:59:24,000 --> 01:59:26,000
你要么写非常非常贴近

3078
01:59:26,000 --> 01:59:27,000
机器的编程语言

3079
01:59:28,000 --> 01:59:29,000
你要么就直接用自然语言

3080
01:59:30,000 --> 01:59:33,000
要不你就逻辑一点要不你就自然就真的是自然语言

3081
01:59:33,000 --> 01:59:36,000
但是你这个建议之间就不中不息的

3082
01:59:37,000 --> 01:59:38,000
非常难受

3083
01:59:39,000 --> 01:59:40,000
而且就是

3084
01:59:40,000 --> 01:59:40,000
就是

3085
01:59:41,000 --> 01:59:43,000
就是用 BDD 的践行者经常会在

3086
01:59:44,000 --> 01:59:47,000
Ruby 算是做的比较极端的 Ruby Scala 这种也好

3087
01:59:48,000 --> 01:59:53,000
他会把那个 DSL 就是 Domain Specific Language 的特性用到极致

3088
01:59:54,000 --> 01:59:57,000
对我经常发现一些匪夷所思的语法在那里用着

3089
01:59:57,000 --> 01:59:59,000
相当坑爹

3090
02:00:00,000 --> 02:00:01,000
谁知道他们灵活

3091
02:00:01,000 --> 02:00:02,000
灵活有灵活的代价

3092
02:00:03,000 --> 02:00:04,000
好吧

3093
02:00:06,000 --> 02:00:07,000
对

3094
02:00:07,000 --> 02:00:11,000
所以其实就可以过渡到我们的

3095
02:00:11,000 --> 02:00:12,000
下一个

3096
02:00:12,000 --> 02:00:13,000
重点就是

3097
02:00:13,000 --> 02:00:15,000
为什么人们讨厌测试

3098
02:00:16,000 --> 02:00:17,000
或者说为什么人们

3099
02:00:18,000 --> 02:00:20,000
会觉得测试是可有可无的东西

3100
02:00:22,000 --> 02:00:23,000
你为什么讨厌测试

3101
02:00:23,000 --> 02:00:25,000
或者你为什么不喜欢写测试

3102
02:00:26,000 --> 02:00:27,000
我觉得吧就是

3103
02:00:28,000 --> 02:00:32,000
刚才我讲我喜欢有一些确定性的经过形式证明的东西

3104
02:00:32,000 --> 02:00:33,000
就是说

3105
02:00:33,000 --> 02:00:35,000
我写的这么一堆小段代码

3106
02:00:35,000 --> 02:00:36,000
经过

3107
02:00:36,000 --> 02:00:38,000
严密的理论推敲

3108
02:00:38,000 --> 02:00:39,000
他是不可能出错的

3109
02:00:39,000 --> 02:00:40,000
那我觉得

3110
02:00:40,000 --> 02:00:41,000
这是好的

3111
02:00:42,000 --> 02:00:43,000
然后你突然跳起来跟我说

3112
02:00:44,000 --> 02:00:47,000
哎不对你这个太麻烦了有些你做不到我这个代码

3113
02:00:47,000 --> 02:00:48,000
有 200 行长

3114
02:00:49,000 --> 02:00:50,000
你怎么证明它对吧

3115
02:00:50,000 --> 02:00:51,000
还有那个什么

3116
02:00:51,000 --> 02:00:52,000
就是什么叫做

3117
02:00:53,000 --> 02:00:57,000
非确定性的 indeterministic

3118
02:00:57,000 --> 02:00:57,000
对吧

3119
02:00:59,000 --> 02:01:00,000
你怎么去去证明的

3120
02:01:01,000 --> 02:01:01,000
没有办法

3121
02:01:02,000 --> 02:01:02,000
那么

3122
02:01:02,000 --> 02:01:04,000
我们来个突然去这次写测试吧

3123
02:01:05,000 --> 02:01:08,000
写一个就是写的 50 个 unit test

3124
02:01:08,000 --> 02:01:10,000
这个这个 case

3125
02:01:10,000 --> 02:01:13,000
那可能覆盖到大多数常见和不常见的情况

3126
02:01:13,000 --> 02:01:15,000
那然后你都都跑通了那么觉得

3127
02:01:15,000 --> 02:01:18,000
在心理上有一定的把握证明这个事情是可行的

3128
02:01:18,000 --> 02:01:19,000
但是呢

3129
02:01:20,000 --> 02:01:22,000
我还是有一种深深的不安的感觉总觉得

3130
02:01:22,000 --> 02:01:22,000
哎呀

3131
02:01:23,000 --> 02:01:24,000
那万一没有一个情况没覆盖到怎么办

3132
02:01:27,000 --> 02:01:30,000
然后就觉得还是从逻辑上就一层一层分析他

3133
02:01:30,000 --> 02:01:32,000
哪里会出错哪里会

3134
02:01:32,000 --> 02:01:35,000
会跳出这样会比较好

3135
02:01:35,000 --> 02:01:36,000
但这也是一个

3136
02:01:36,000 --> 02:01:38,000
间接的原因导致为什么我不喜欢

3137
02:01:39,000 --> 02:01:41,000
那个异常机制就是 exception mechanism

3138
02:01:41,000 --> 02:01:44,000
因为它会导致你那个逻辑那个那个 control flow

3139
02:01:45,000 --> 02:01:46,000
是多重的 exit point

3140
02:01:47,000 --> 02:01:48,000
对吧

3141
02:01:48,000 --> 02:01:50,000
这样会导致你整个这个状态是

3142
02:01:51,000 --> 02:01:51,000
不干净

3143
02:01:52,000 --> 02:01:54,000
如果你状态不干净的话你就很难去

3144
02:01:54,000 --> 02:01:55,000
那个什么用那个

3145
02:01:56,000 --> 02:02:02,000
formal verification 的方法去验证它或者说你很难用那个推理的方法去证明它是不可能

3146
02:02:02,000 --> 02:02:02,000
出错的

3147
02:02:03,000 --> 02:02:04,000
嗯哼

3148
02:02:04,000 --> 02:02:05,000
这是一就是一些相关的问题

3149
02:02:06,000 --> 02:02:06,000
然后

3150
02:02:07,000 --> 02:02:08,000
写测试是一个很痛苦的过程

3151
02:02:09,000 --> 02:02:10,000
对

3152
02:02:11,000 --> 02:02:13,000
我觉得很大一个原因就是

3153
02:02:15,000 --> 02:02:17,000
为什么会说写测试是一个很痛苦的过程

3154
02:02:17,000 --> 02:02:18,000
就是因为

3155
02:02:18,000 --> 02:02:19,000
他没有给你

3156
02:02:20,000 --> 02:02:21,000
他不会给你一种

3157
02:02:22,000 --> 02:02:23,000
achievement 的感觉

3158
02:02:23,000 --> 02:02:25,000
你写测试是不会有成就的

3159
02:02:26,000 --> 02:02:28,000
你不会觉得自己在创造新的东西

3160
02:02:29,000 --> 02:02:29,000
你只是

3161
02:02:31,000 --> 02:02:31,000
你只是

3162
02:02:32,000 --> 02:02:35,000
在做一件比如说给别人批作业或者是

3163
02:02:35,000 --> 02:02:39,000
写完了卷子之后在那边验算自己写的对不对这样一种

3164
02:02:40,000 --> 02:02:41,000
对对对对

3165
02:02:41,000 --> 02:02:45,000
就刚才我讲那个你写代码的时候你总有一种创造的快感对吧

3166
02:02:45,000 --> 02:02:46,000
creation

3167
02:02:46,000 --> 02:02:47,000
就这种感觉的

3168
02:02:47,000 --> 02:02:49,000
你这一种上帝的视角在里面

3169
02:02:49,000 --> 02:02:51,000
然后你证明它的时候你有一种

3170
02:02:52,000 --> 02:02:54,000
我不知道有些人做数学题他证明那道很难的题

3171
02:02:54,000 --> 02:02:55,000
他可能会有一种快感

3172
02:02:56,000 --> 02:03:00,000
其实写那个就是写那个 formal verification 其实有类似的作用

3173
02:03:00,000 --> 02:03:01,000
但是你说写测试

3174
02:03:02,000 --> 02:03:03,000
感觉就好像什么呢

3175
02:03:03,000 --> 02:03:04,000
就为了证明到数学题

3176
02:03:04,000 --> 02:03:06,000
你只拿个计算机在那按

3177
02:03:06,000 --> 02:03:07,000
说先输入一个 5

3178
02:03:07,000 --> 02:03:08,000
得出是 50

3179
02:03:08,000 --> 02:03:10,000
结果是先出一个 6

3180
02:03:10,000 --> 02:03:11,000
得出是 600

3181
02:03:12,000 --> 02:03:13,000
你觉得这是对的

3182
02:03:13,000 --> 02:03:14,000
一切都没错

3183
02:03:14,000 --> 02:03:20,000
写了这么做重复做了试了 100 次之后你就说我这个过程应该是正确的我这个答案应该是正确的吧因为我测试了 100 个

3184
02:03:21,000 --> 02:03:23,000
觉得都是正确的但其实没有经过证明你还是不确定

3185
02:03:24,000 --> 02:03:25,000
就没有那个成就感

3186
02:03:26,000 --> 02:03:27,000
就是一个很机械的劳动

3187
02:03:29,000 --> 02:03:31,000
另外一方面也是因为我们

3188
02:03:31,000 --> 02:03:32,000
就是

3189
02:03:33,000 --> 02:03:41,000
从来没有在哪怕科班出身的人都很难会说自己曾经在求学就学编程的过程中学得过

3190
02:03:41,000 --> 02:03:43,000
怎样写测试

3191
02:03:44,000 --> 02:03:45,000
我相信

3192
02:03:46,000 --> 02:03:51,000
应该现在没有那个大学里面会专门开设软件测试这个课程吧

3193
02:03:51,000 --> 02:03:55,000
哪怕是可能会在那个 software engineer 里面作为一个

3194
02:03:55,000 --> 02:03:56,000
使用的工具

3195
02:03:56,000 --> 02:03:59,000
去讲这个我有体会

3196
02:03:59,000 --> 02:04:00,000
OK

3197
02:04:00,000 --> 02:04:01,000
所以你还是

3198
02:04:01,000 --> 02:04:02,000
都上过人间工程了

3199
02:04:03,000 --> 02:04:05,000
没我但是我做了助教

3200
02:04:06,000 --> 02:04:08,000
啊哈原来如此

3201
02:04:08,000 --> 02:04:09,000
对

3202
02:04:11,000 --> 02:04:12,000
但是

3203
02:04:12,000 --> 02:04:14,000
科班出身的人可能有这样一个

3204
02:04:14,000 --> 02:04:18,000
机会但是那些自学成才的人可能就完全没有

3205
02:04:18,000 --> 02:04:20,000
学过怎样才能写怎样

3206
02:04:20,000 --> 02:04:21,000
怎样去写测试

3207
02:04:22,000 --> 02:04:24,000
乃至于怎样写出可以为测试代码

3208
02:04:25,000 --> 02:04:26,000
我们必须承认的也是

3209
02:04:27,000 --> 02:04:31,000
拿对一个很就编程编的相对熟练的人来说你要他

3210
02:04:31,000 --> 02:04:35,000
去去适应一个把所有的代码都写的

3211
02:04:36,000 --> 02:04:38,000
一语测试的这么一个

3212
02:04:38,000 --> 02:04:41,000
写出一语测试这么一个风格来

3213
02:04:41,000 --> 02:04:42,000
也其实挺难的

3214
02:04:45,000 --> 02:04:46,000
就

3215
02:04:47,000 --> 02:04:50,000
尤其是有时候可以测试的代码

3216
02:04:51,000 --> 02:04:56,000
跟不啰嗦的代码其实是非常相彼此抵触的这么一个状态

3217
02:04:57,000 --> 02:04:59,000
就是有时候也许你可以判断一个条件

3218
02:04:59,000 --> 02:05:00,000
必然啰嗦呀

3219
02:05:01,000 --> 02:05:05,000
可测试的代码必然是能做的

3220
02:05:06,000 --> 02:05:07,000
测试本身当然是

3221
02:05:07,000 --> 02:05:09,000
就是完全是不必要的废话

3222
02:05:09,000 --> 02:05:13,000
可测试的代码为了保证其可测试性

3223
02:05:13,000 --> 02:05:15,000
可能要比不可测试的代码啰嗦很多

3224
02:05:16,000 --> 02:05:17,000
比如说可能有一个编辑条件

3225
02:05:18,000 --> 02:05:19,000
然后去检测这个编辑条件

3226
02:05:19,000 --> 02:05:22,000
同时根据这个编辑条件给某一个数值

3227
02:05:22,000 --> 02:05:25,000
同时根据这个编辑条件去改变某一个数值

3228
02:05:26,000 --> 02:05:28,000
那如果不需要写测试的话你可以

3229
02:05:29,000 --> 02:05:29,000
直接

3230
02:05:30,000 --> 02:05:31,000
测试

3231
02:05:31,000 --> 02:05:33,000
直接去

3232
02:05:33,000 --> 02:05:36,000
测验这个验证这个编辑条件并且同

3233
02:05:36,000 --> 02:05:37,000
并且马上再改数值

3234
02:05:38,000 --> 02:05:38,000
但是如果你要

3235
02:05:39,000 --> 02:05:40,000
为了把这个

3236
02:05:40,000 --> 02:05:43,000
这一部分功能做的可以测试的话你可能会要

3237
02:05:43,000 --> 02:05:47,000
你可能会需要把那个修改数值那一部分单独立出去

3238
02:05:47,000 --> 02:05:50,000
专门去测量先去先来测量一下这个编辑条件

3239
02:05:51,000 --> 02:05:52,000
对 Juice 这种的

3240
02:05:53,000 --> 02:05:55,000
都让人觉得何必呢

3241
02:05:55,000 --> 02:05:59,000
刚才那个提到那个你说科班那个培养的

3242
02:05:59,000 --> 02:06:01,000
培训练的都没有训练这个写测试的

3243
02:06:01,000 --> 02:06:03,000
但是我想补充一点就刚才我讲

3244
02:06:03,000 --> 02:06:07,000
哪怕是我做过这个软件工程这种课的助教我去看了他们的

3245
02:06:07,000 --> 02:06:08,000
其实

3246
02:06:08,000 --> 02:06:13,000
我的感觉在现在的大学的教育里面还是没有把这个事情放到一个

3247
02:06:13,000 --> 02:06:14,000
非常重要的地位上来去讲

3248
02:06:15,000 --> 02:06:17,000
一方面是因为大学的一个

3249
02:06:17,000 --> 02:06:18,000
一个

3250
02:06:18,000 --> 02:06:18,000
定位吧

3251
02:06:19,000 --> 02:06:21,000
他并不是说我不是一个 vacation school

3252
02:06:21,000 --> 02:06:24,000
不是一个职业技术学院对吧

3253
02:06:24,000 --> 02:06:27,000
我并不是要培养出一帮长安工人能够上线职业用的

3254
02:06:28,000 --> 02:06:29,000
而是说培养一种思维

3255
02:06:29,000 --> 02:06:30,000
这种

3256
02:06:30,000 --> 02:06:31,000
定性的

3257
02:06:31,000 --> 02:06:36,000
这个这个这个这个这个出发点会导致他们会轻视就重视原理

3258
02:06:36,000 --> 02:06:37,000
轻视实践

3259
02:06:37,000 --> 02:06:39,000
而测试属于那种

3260
02:06:39,000 --> 02:06:41,000
实践远远超过原理的东西

3261
02:06:42,000 --> 02:06:46,000
就哪怕是在现在的一些大学里面开软件工程的课里面他对测试

3262
02:06:46,000 --> 02:06:47,000
怎么写都只是提前说

3263
02:06:48,000 --> 02:06:50,000
我在给你展示一个案例

3264
02:06:50,000 --> 02:06:55,000
然后你剩下的原理自己去看数据吧我会提讲一些大的原则但并不会告诉你

3265
02:06:55,000 --> 02:06:58,000
说话说来告诉你怎么去实操这个东西所以

3266
02:06:58,000 --> 02:06:59,000
这也难怪

3267
02:06:59,000 --> 02:07:00,000
你说就

3268
02:07:00,000 --> 02:07:01,000
哪怕是科班出身了

3269
02:07:01,000 --> 02:07:02,000
他也不会有

3270
02:07:02,000 --> 02:07:03,000
特别好的这种

3271
02:07:04,000 --> 02:07:05,000
那种实践的经验去写测试

3272
02:07:06,000 --> 02:07:08,000
其实也就牵上了另外一个问题

3273
02:07:08,000 --> 02:07:09,000
就是

3274
02:07:09,000 --> 02:07:11,000
作为工程学的计算机软件

3275
02:07:12,000 --> 02:07:13,000
其实可以作为一种降

3276
02:07:14,000 --> 02:07:14,000
就是所谓的

3277
02:07:15,000 --> 02:07:16,000
craftsmanship

3278
02:07:17,000 --> 02:07:18,000
他其实

3279
02:07:18,000 --> 02:07:21,000
更适合呀使用这种

3280
02:07:21,000 --> 02:07:21,000
就是

3281
02:07:22,000 --> 02:07:24,000
工匠制或者说学徒制的方法

3282
02:07:25,000 --> 02:07:25,000
来传授

3283
02:07:26,000 --> 02:07:28,000
强调实践

3284
02:07:28,000 --> 02:07:30,000
强调

3285
02:07:31,000 --> 02:07:31,000
经验的传授

3286
02:07:31,000 --> 02:07:33,000
强调手把手

3287
02:07:33,000 --> 02:07:37,000
比如说敏捷编程里面有一个很强很转的原则就是节对编程

3288
02:07:39,000 --> 02:07:44,000
两个程序员共用一个键盘共用一个共用一个鼠标用一个屏幕这其实是

3289
02:07:44,000 --> 02:07:46,000
同样也是就像

3290
02:07:46,000 --> 02:07:49,000
TDD 那三个原则一样非常难以接受的

3291
02:07:49,000 --> 02:07:50,000
一件事情

3292
02:07:51,000 --> 02:07:51,000
但是

3293
02:07:52,000 --> 02:07:52,000
其

3294
02:07:53,000 --> 02:07:54,000
就是会

3295
02:07:54,000 --> 02:07:55,000
就像安利一样

3296
02:07:55,000 --> 02:07:57,000
喜欢他的人会觉得他是

3297
02:07:57,000 --> 02:07:58,000
非常非常好的

3298
02:07:58,000 --> 02:08:00,000
一个一个实践原则

3299
02:08:01,000 --> 02:08:01,000
那

3300
02:08:01,000 --> 02:08:07,000
在大学里面所进行的软件工程的教育可能会比较

3301
02:08:08,000 --> 02:08:09,000
流于理论因为

3302
02:08:11,000 --> 02:08:16,000
毕竟在很多时候教授软件工程的教授本身可能完全没搞过软件工程

3303
02:08:16,000 --> 02:08:17,000
他是一个比较

3304
02:08:17,000 --> 02:08:20,000
从相对来说比较学院派的角度去

3305
02:08:23,000 --> 02:08:26,000
在向学生传授一个自己想象之中的软件工程是

3306
02:08:27,000 --> 02:08:28,000
怎样实施

3307
02:08:28,000 --> 02:08:29,000
这是

3308
02:08:30,000 --> 02:08:31,000
这是为什么

3309
02:08:31,000 --> 02:08:34,000
测试一直没能得到

3310
02:08:34,000 --> 02:08:36,000
足够的在课堂里面的重视

3311
02:08:37,000 --> 02:08:39,000
因为他本身就不是不适合于课堂

3312
02:08:39,000 --> 02:08:40,000
应该这么说

3313
02:08:41,000 --> 02:08:41,000
对

3314
02:08:43,000 --> 02:08:47,000
其实这还让我想到另外一个问题就是

3315
02:08:48,000 --> 02:08:51,000
我不知道你的感官是什么呀

3316
02:08:51,000 --> 02:08:52,000
我好像

3317
02:08:52,000 --> 02:08:54,000
印象里面很多女孩子都会在

3318
02:08:55,000 --> 02:08:58,000
毕业之后如果进了软件公司的话选择去做测试

3319
02:08:58,000 --> 02:08:59,000
这是为什么

3320
02:09:00,000 --> 02:09:01,000
哎这个事情我

3321
02:09:01,000 --> 02:09:03,000
我也是很好奇因为之前

3322
02:09:03,000 --> 02:09:05,000
在知乎的时候我们最早的

3323
02:09:05,000 --> 02:09:06,000
这个测试的

3324
02:09:07,000 --> 02:09:07,000
工作

3325
02:09:08,000 --> 02:09:08,000
也是一个

3326
02:09:09,000 --> 02:09:10,000
一个女孩子在那边做

3327
02:09:11,000 --> 02:09:13,000
可能有一种传统要认为说女性会

3328
02:09:13,000 --> 02:09:14,000
心细一些

3329
02:09:15,000 --> 02:09:17,000
我觉得这是一种骑士

3330
02:09:17,000 --> 02:09:18,000
三号三位

3331
02:09:18,000 --> 02:09:20,000
我觉得是但是

3332
02:09:20,000 --> 02:09:20,000
好像

3333
02:09:21,000 --> 02:09:21,000
你

3334
02:09:21,000 --> 02:09:27,000
就像觉得测试是一个没有创造力然后又非常需要心细的人去做

3335
02:09:27,000 --> 02:09:30,000
就如果即便不算骑士的话至少是一种偏见我觉得

3336
02:09:31,000 --> 02:09:32,000
对他他

3337
02:09:32,000 --> 02:09:36,000
三号带了一个默认的性别偏见就是他觉得

3338
02:09:38,000 --> 02:09:40,000
女性适合于做这种

3339
02:09:41,000 --> 02:09:44,000
括号没有什么技术水准的话

3340
02:09:45,000 --> 02:09:46,000
测试

3341
02:09:46,000 --> 02:09:47,000
好吧

3342
02:09:48,000 --> 02:09:50,000
但其实测试是相当有技术水准的

3343
02:09:50,000 --> 02:09:54,000
如果你要把对啊我觉得要写好一个测试的那个 test case 还是

3344
02:09:55,000 --> 02:09:57,000
蛮多事情要考虑的

3345
02:09:57,000 --> 02:09:58,000
但不

3346
02:09:58,000 --> 02:10:01,000
这里面有些测试就是说是一个看有的 smoke test

3347
02:10:01,000 --> 02:10:02,000
就是他甚至不会去接触到

3348
02:10:03,000 --> 02:10:05,000
圆码只会说测试成品怎么样就是另外一种

3349
02:10:06,000 --> 02:10:09,000
新测试跟我们今天讲的那个单元测试还不是一个一个东西

3350
02:10:11,000 --> 02:10:12,000
这就不展开讲哈

3351
02:10:13,000 --> 02:10:15,000
这个有兴趣的

3352
02:10:15,000 --> 02:10:17,000
或者对此有感触的

3353
02:10:17,000 --> 02:10:20,000
听众欢迎你写信来谈一谈你所遇到的

3354
02:10:20,000 --> 02:10:22,000
开启吐槽模式

3355
02:10:22,000 --> 02:10:22,000
对

3356
02:10:23,000 --> 02:10:28,000
是不是很多乃至于我相信也是我们的听众里面的确有很多做测试的女孩子

3357
02:10:28,000 --> 02:10:29,000
女性听众

3358
02:10:30,000 --> 02:10:30,000
啊

3359
02:10:31,000 --> 02:10:33,000
不妨也谈谈你为什么会选择去做测试呢

3360
02:10:33,000 --> 02:10:34,000
是因为你觉得

3361
02:10:36,000 --> 02:10:37,000
测试真的

3362
02:10:37,000 --> 02:10:38,000
比较适合

3363
02:10:39,000 --> 02:10:40,000
女性吗

3364
02:10:41,000 --> 02:10:43,000
然后你觉得你有这个过程中你有成就感吗

3365
02:10:45,000 --> 02:10:46,000
欢迎来信

3366
02:10:47,000 --> 02:10:48,000
长短不限

3367
02:10:50,000 --> 02:10:51,000
OK

3368
02:10:51,000 --> 02:10:52,000
那

3369
02:10:53,000 --> 02:10:55,000
根据提高我们接下来要讲到的是

3370
02:10:55,000 --> 02:10:56,000
一系列

3371
02:10:57,000 --> 02:10:58,000
和单元测试相关工具

3372
02:10:59,000 --> 02:11:00,000
就是

3373
02:11:00,000 --> 02:11:01,000
嗯

3375
02:11:10,000 --> 02:11:12,000
本意也是希望对测试感兴趣的

3376
02:11:13,000 --> 02:11:14,000
听众可以

3377
02:11:14,000 --> 02:11:17,000
而对测试没有足够多经验的听众可以去

3378
02:11:17,000 --> 02:11:21,000
找一些这个去搜一些相关的工具然后看一看他们是怎么使用的

3379
02:11:22,000 --> 02:11:27,000
总之进行到下一个环节之下我们可以最后来吐槽一下这个 tdd 啦我觉得

3380
02:11:28,000 --> 02:11:28,000
火力全开

3381
02:11:29,000 --> 02:11:29,000
来吧

3382
02:11:29,000 --> 02:11:30,000
对

3383
02:11:30,000 --> 02:11:31,000
,这怎么讲

3384
02:11:31,000 --> 02:11:33,000
这是一个非常地图炮而地狱骑士的说法

3385
02:11:34,000 --> 02:11:34,000
就是

3386
02:11:34,000 --> 02:11:37,000
TDD 是一个

3387
02:11:39,000 --> 02:11:40,000
为了保证质量

3388
02:11:42,000 --> 02:11:43,000
而忽视了

3389
02:11:45,000 --> 02:11:47,000
而压抑了人的创造性的

3390
02:11:48,000 --> 02:11:48,000
这么一个

3391
02:11:50,000 --> 02:11:51,000
软件方法

3392
02:11:51,000 --> 02:11:55,000
就是你可以说 TDD 的出现是历史的必然就好像

3393
02:11:56,000 --> 02:11:58,000
福特的 P 型车会在

3394
02:11:58,000 --> 02:12:00,000
会以流水线的方式来生长

3395
02:12:00,000 --> 02:12:01,000
当时历史的必然

3396
02:12:01,000 --> 02:12:02,000
但是

3397
02:12:03,000 --> 02:12:09,000
也正是因为 TDD 或者说流水线的出现这种所谓 mass production 的出现

3398
02:12:10,000 --> 02:12:11,000
导致了

3399
02:12:13,000 --> 02:12:14,000
Human

3400
02:12:15,000 --> 02:12:16,000
变成了 Human resource

3401
02:12:18,000 --> 02:12:18,000
就是

3402
02:12:19,000 --> 02:12:21,000
我这么说可能

3403
02:12:21,000 --> 02:12:25,000
扯得有点大有点形而上

3404
02:12:25,000 --> 02:12:29,000
没有我觉得这个很好我觉得这个点很好就是如果你看

3405
02:12:29,000 --> 02:12:30,000
一个公司一旦出现了

3406
02:12:30,000 --> 02:12:31,000
HR 这个部门之后

3407
02:12:32,000 --> 02:12:35,000
这个公司通常都会有一点点问题

3408
02:12:36,000 --> 02:12:37,000
对

3409
02:12:37,000 --> 02:12:38,000
就好像

3410
02:12:40,000 --> 02:12:41,000
Benz 在

3411
02:12:42,000 --> 02:12:43,000
开发第一辆车的时候

3412
02:12:43,000 --> 02:12:45,000
它显然不会

3413
02:12:45,000 --> 02:12:47,000
给每一个零件做测试

3414
02:12:48,000 --> 02:12:49,000
AT&T

3415
02:12:49,000 --> 02:12:50,000
贝尔实验室的

3416
02:12:51,000 --> 02:12:53,000
黑客们在一开始写

3417
02:12:53,000 --> 02:12:55,000
第一版 UNIX 的时候

3418
02:12:55,000 --> 02:12:56,000
肯定也不会

3419
02:12:57,000 --> 02:12:58,000
去写单元测试

3420
02:12:58,000 --> 02:13:00,000
真正只有创造性的

3421
02:13:00,000 --> 02:13:01,000
工作是

3422
02:13:02,000 --> 02:13:03,000
不会写测试

3423
02:13:05,000 --> 02:13:10,000
就我觉得 TDD 最大的问题就是它打破了那个创造的这个所谓的流

3424
02:13:10,000 --> 02:13:10,000
flow 啊

3425
02:13:11,000 --> 02:13:12,000
就是

3426
02:13:12,000 --> 02:13:16,000
比如你在想你在做一个很投入很有创造性的事情

3427
02:13:16,000 --> 02:13:17,000
在进入一种状态

3428
02:13:18,000 --> 02:13:20,000
你会持续说去做一个创造性的

3429
02:13:20,000 --> 02:13:23,000
工作去构建一整套的东西出来在脑海中

3430
02:13:23,000 --> 02:13:28,000
然后把它落实到笔头也好还是键盘上也好把它变成一个实体的物件

3431
02:13:28,000 --> 02:13:29,000
但是

3432
02:13:29,000 --> 02:13:30,000
TDD 其实

3433
02:13:30,000 --> 02:13:33,000
其实把这个流给切成无数无数的碎片

3434
02:13:33,000 --> 02:13:34,000
然后你不断的在这个

3435
02:13:35,000 --> 02:13:37,000
跳出来跳出跳出去

3436
02:13:37,000 --> 02:13:39,000
跳出去写那个测试然后再跳回来创造

3437
02:13:40,000 --> 02:13:41,000
整个这个 flow 就已经没有了嘛

3438
02:13:42,000 --> 02:13:42,000
对

3439
02:13:43,000 --> 02:13:50,000
我觉得在 TDD 的整个过程里面唯一爽的人其实就是架构师或者说是那个拆分工作的人

3440
02:13:50,000 --> 02:13:52,000
他是唯一一个有创造性的角色

3441
02:13:53,000 --> 02:13:54,000
他把那个什么

3442
02:13:54,000 --> 02:13:55,000
Blueprint

3443
02:13:55,000 --> 02:13:57,000
都给你画好了然后你说

3444
02:13:58,000 --> 02:13:59,000
那个什么你们这些

3445
02:13:59,000 --> 02:14:00,000
呃

3446
02:14:00,000 --> 02:14:00,000
呃

3447
02:14:01,000 --> 02:14:01,000
包工头

3448
02:14:01,000 --> 02:14:02,000
Human resource

3449
02:14:02,000 --> 02:14:03,000
Human resource 什么包工头

3450
02:14:03,000 --> 02:14:04,000
你们这些小工

3451
02:14:05,000 --> 02:14:06,000
照这个图纸干就好了

3452
02:14:06,000 --> 02:14:08,000
你们如果干不好我随时可以换一个人

3453
02:14:09,000 --> 02:14:10,000
没错

3454
02:14:10,000 --> 02:14:13,000
对就好像在建筑领域里面

3455
02:14:13,000 --> 02:14:14,000
一个建筑

3456
02:14:14,000 --> 02:14:15,000
造了在

3457
02:14:16,000 --> 02:14:20,000
美轮美奂在功能完善人们也只会记住建筑师的名字

3458
02:14:20,000 --> 02:14:21,000
而不是你这个搬砖子小王的名字

3459
02:14:22,000 --> 02:14:23,000
对

3460
02:14:23,000 --> 02:14:24,000
这就是为什么我

3461
02:14:25,000 --> 02:14:27,000
看到任何一个

3462
02:14:27,000 --> 02:14:29,000
N-force TDD 的公司

3463
02:14:29,000 --> 02:14:31,000
都会觉得

3464
02:14:31,000 --> 02:14:33,000
简直是 living hell

3465
02:14:34,000 --> 02:14:35,000
能躲就躲是吧

3466
02:14:35,000 --> 02:14:36,000
对

3467
02:14:36,000 --> 02:14:40,000
这其实让我想起来前阵子李如依说在有一期

3468
02:14:41,000 --> 02:14:44,000
IT 公论里面你们提到一个独立游戏开发者说

3469
02:14:45,000 --> 02:14:49,000
什么去 EA 或者去 EA 这样的大公司大游戏公司

3470
02:14:50,000 --> 02:14:51,000
简直就是 hell

3471
02:14:51,000 --> 02:14:53,000
对对对有类似的原因

3472
02:14:53,000 --> 02:14:56,000
对他的道理其实就是你在那个

3473
02:14:56,000 --> 02:14:59,000
这样的公司里面扮演的其实就是一个流水线上的工人

3474
02:14:59,000 --> 02:15:00,000
然后你

3475
02:15:01,000 --> 02:15:01,000
传说中的

3476
02:15:02,000 --> 02:15:05,000
对你的个性被抹杀了你成为那个 human resource

3477
02:15:05,000 --> 02:15:06,000
然后

3478
02:15:07,000 --> 02:15:11,000
你唯一出现的就是那个最终的演出原表里面一个

3479
02:15:11,000 --> 02:15:16,000
没有大部分玩家都会立刻按 A 去跳过的什么字幕里面的一部分

3480
02:15:17,000 --> 02:15:21,000
是不过不过这件事如果反过来讲呢也可以说

3481
02:15:21,000 --> 02:15:24,000
这样才可以保证出品的稳定吗对吧如果

3482
02:15:24,000 --> 02:15:29,000
也只有采用这样的方式也只有采用这种不幸人让人成为可以被替代的

3483
02:15:29,000 --> 02:15:31,000
灵见的方式才可以做出

3484
02:15:32,000 --> 02:15:35,000
规模足够大的东西这个我是毫不否认

3485
02:15:35,000 --> 02:15:41,000
而且就是能保证这个他的出品是稳定的就好像为什么老师我们老是吐槽说

3486
02:15:41,000 --> 02:15:42,000
中餐难以标准化

3487
02:15:43,000 --> 02:15:45,000
就是因为他的那个出品不不够稳的你换一个人

3488
02:15:46,000 --> 02:15:47,000
换一个厨师

3489
02:15:47,000 --> 02:15:51,000
这个或者换身手换一种调料这个事情就就就就口味就变掉了

3490
02:15:52,000 --> 02:15:53,000
所以

3491
02:15:53,000 --> 02:15:57,000
我就是在想这个到底是一个怎么样的情况怎么能能够

3492
02:15:57,000 --> 02:15:58,000
拿到两者的好处

3493
02:15:59,000 --> 02:16:00,000
一面两者的短板

3494
02:16:00,000 --> 02:16:02,000
好像现在看来没有什么太好的解决方案

3495
02:16:03,000 --> 02:16:05,000
我觉得一个解决方案可能就是人工智能

3496
02:16:07,000 --> 02:16:08,000
TDD

3497
02:16:09,000 --> 02:16:14,000
可能现在的 TDD 还太原始就是假如将来我们可以直接先给出所有的编辑条件

3498
02:16:15,000 --> 02:16:18,000
然后让 AI 自己去帮我们写出

3499
02:16:18,000 --> 02:16:19,000
程序来

3500
02:16:19,000 --> 02:16:23,000
那可能到那个时候我们也就不需要再为这种事情发愁

3501
02:16:24,000 --> 02:16:28,000
其实这个已经也有了这个所谓的什么第四代编程语言不就做这种事情吧

3502
02:16:28,000 --> 02:16:29,000
人指定

3503
02:16:29,000 --> 02:16:30,000
这个

3504
02:16:30,000 --> 02:16:34,000
他自己去去去解决这个怎么去找到

3505
02:16:34,000 --> 02:16:35,000
满足这个 constraint 的一个解

3506
02:16:36,000 --> 02:16:36,000
但是

3507
02:16:37,000 --> 02:16:38,000
效率是很成问题的

3508
02:16:39,000 --> 02:16:44,000
对然后这个就又跟我们之前提到的那个

3509
02:16:46,000 --> 02:16:47,000
the rabbits

3510
02:16:47,000 --> 02:16:47,000
还是

3511
02:16:48,000 --> 02:16:50,000
那个网站叫什么来着

3512
02:16:50,000 --> 02:16:52,000
那个代

3513
02:16:52,000 --> 02:16:54,000
代工代研写代码那个

3514
02:16:54,000 --> 02:16:55,000
叫什么来着

3515
02:16:56,000 --> 02:16:57,000
反正和兔子有关

3516
02:16:58,000 --> 02:16:58,000
对不起

3517
02:16:59,000 --> 02:17:00,000
然后还有

3518
02:17:01,000 --> 02:17:01,000
OK

3519
02:17:02,000 --> 02:17:08,000
以及和之前和沐阳聊到了没能跟沐阳聊起的那个话题就是

3520
02:17:09,000 --> 02:17:12,000
计算机可以做数学吗

3521
02:17:12,000 --> 02:17:13,000
计算机可以做出

3522
02:17:14,000 --> 02:17:16,000
计算机可以设立出来一个

3523
02:17:17,000 --> 02:17:18,000
有创造性的算法吗

3524
02:17:19,000 --> 02:17:20,000
其实也是

3525
02:17:21,000 --> 02:17:23,000
目前现阶段看来不太可能也是

3526
02:17:23,000 --> 02:17:24,000
就是

3527
02:17:24,000 --> 02:17:26,000
我们也许可以通过 TDD

3528
02:17:26,000 --> 02:17:29,000
通过第四代第五代计算机语言来

3529
02:17:29,000 --> 02:17:31,000
完成一些枯燥的

3530
02:17:31,000 --> 02:17:34,000
只有现阶段只有依靠 TDD 或者 BDD 才可以

3531
02:17:35,000 --> 02:17:35,000
达到的

3532
02:17:36,000 --> 02:17:37,000
大规模软件

3533
02:17:38,000 --> 02:17:39,000
就所谓的

3534
02:17:39,000 --> 02:17:41,000
穷举法证明吗

3535
02:17:41,000 --> 02:17:42,000
对

3536
02:17:42,000 --> 02:17:46,000
说这个其实已经有像 TDD 那个证明那个什么来着

3537
02:17:46,000 --> 02:17:49,000
Coloring problem

3538
02:17:50,000 --> 02:17:53,000
地图填色的那个那个难题

3539
02:17:53,000 --> 02:17:56,000
那个好像不是证明出来吗就是靠报纸获取

3540
02:17:57,000 --> 02:17:57,000
对啊

3541
02:17:57,000 --> 02:17:58,000
这个就是什么

3542
02:17:58,000 --> 02:18:00,000
数学领域的 TDD 吧

3543
02:18:01,000 --> 02:18:01,000
对

3544
02:18:04,000 --> 02:18:06,000
也不尽然

3545
02:18:07,000 --> 02:18:09,000
各位理解这是什么意思

3546
02:18:10,000 --> 02:18:13,000
有神似之处但并不是一回事

3547
02:18:14,000 --> 02:18:17,000
另外一个我又想起来一个暴利的方法就是

3548
02:18:18,000 --> 02:18:18,000
说最近

3549
02:18:19,000 --> 02:18:22,000
近段时间围棋的 AI 有比较大的提升

3550
02:18:23,000 --> 02:18:24,000
就是因为他们采用了一种

3551
02:18:25,000 --> 02:18:26,000
比较暴力的算法就是

3552
02:18:26,000 --> 02:18:28,000
穷举所有

3553
02:18:28,000 --> 02:18:30,000
用蒙特卡洛算法

3554
02:18:30,000 --> 02:18:33,000
随机的去

3555
02:18:33,000 --> 02:18:34,000
随机的去

3556
02:18:34,000 --> 02:18:39,000
去采用一些可能的走法然后从里面找出来一个

3557
02:18:39,000 --> 02:18:44,000
效果最好的然后成功的让业余棋手

3558
02:18:45,000 --> 02:18:47,000
基本上没有人能够下过这个围棋算法

3559
02:18:48,000 --> 02:18:51,000
OK 回头可以把相关的那个报道找出来

3560
02:18:51,000 --> 02:18:52,000
大概就是这么意思

3561
02:18:54,000 --> 02:18:58,000
我觉得 TDD 是一个

3562
02:18:58,000 --> 02:19:02,000
历史的必然但就好就好像

3563
02:19:02,000 --> 02:19:03,000
这个

3564
02:19:03,000 --> 02:19:05,000
汽车的生产线

3565
02:19:06,000 --> 02:19:12,000
可能还有一些地方是在用手工但至少德国基本上四大车厂全都是在用机器人

3566
02:19:13,000 --> 02:19:18,000
来完成那些以往需要人类才可以完成的流水线工作

3567
02:19:18,000 --> 02:19:19,000
将来我觉得

3568
02:19:19,000 --> 02:19:20,000
这些

3569
02:19:20,000 --> 02:19:21,000
比较

3570
02:19:21,000 --> 02:19:23,000
低级的代码

3571
02:19:24,000 --> 02:19:25,000
验证

3572
02:19:26,000 --> 02:19:28,000
乃至于生成工作应该是可以进行的

3573
02:19:28,000 --> 02:19:29,000
人工智能自动完成

3574
02:19:30,000 --> 02:19:31,000
所以

3575
02:19:31,000 --> 02:19:34,000
这就是我为什么说 TDD 非常印度就是因为

3576
02:19:34,000 --> 02:19:37,000
印度加引号我只不过不愿意说中国

3577
02:19:38,000 --> 02:19:38,000
就是在

3578
02:19:40,000 --> 02:19:43,000
这个第三个国家确实是很印度啊因为那个

3579
02:19:43,000 --> 02:19:45,000
亚马逊那个 mechanic

3580
02:19:45,000 --> 02:19:45,000
Turk

3581
02:19:46,000 --> 02:19:47,000
好像那些服务商都在印度吧

3582
02:19:48,000 --> 02:19:50,000
但这种说法比较怎么说政治不正确

3583
02:19:51,000 --> 02:19:53,000
但是我们也没有在追求政治正确

3584
02:19:54,000 --> 02:19:57,000
言下之意就是在地下世界国家这种

3585
02:19:58,000 --> 02:19:59,000
密集脑力劳动的

3586
02:20:00,000 --> 02:20:01,000
产业

3587
02:20:01,000 --> 02:20:02,000
链的

3588
02:20:02,000 --> 02:20:03,000
这样一个

3589
02:20:03,000 --> 02:20:06,000
环节这还算脑力劳动这个算体力活了吧已经

3590
02:20:07,000 --> 02:20:10,000
区分脑力劳动和体力劳动的区别只是你用没有敲电盘

3591
02:20:11,000 --> 02:20:11,000
我觉得

3592
02:20:11,000 --> 02:20:13,000
TDD 还是要敲电盘

3593
02:20:14,000 --> 02:20:15,000
所以还是

3594
02:20:16,000 --> 02:20:22,000
只有在这样一个环节里面我相信在印度这帮人还是会定性为高科技

3595
02:20:23,000 --> 02:20:23,000
产业的

3596
02:20:23,000 --> 02:20:24,000
那肯定

3597
02:20:26,000 --> 02:20:27,000
但这种说法其实也比较

3598
02:20:28,000 --> 02:20:29,000
偏激或者说比较

3599
02:20:30,000 --> 02:20:30,000
cynical

3600
02:20:30,000 --> 02:20:32,000
因为其实在美国在

3601
02:20:33,000 --> 02:20:35,000
在欧美还是有大量的

3602
02:20:36,000 --> 02:20:36,000
企业

3603
02:20:36,000 --> 02:20:37,000
会

3604
02:20:37,000 --> 02:20:40,000
采用类似于 BD 的

3605
02:20:40,000 --> 02:20:41,000
方法来开发自己的软件

3606
02:20:42,000 --> 02:20:42,000
而且

3607
02:20:43,000 --> 02:20:45,000
即便硅谷的这些

3608
02:20:46,000 --> 02:20:51,000
当红炸子机们也是有很多会非常强的我相信 Facebook 也是一个非常非常强调

3609
02:20:51,000 --> 02:20:52,000
测试的公司

3610
02:20:53,000 --> 02:20:56,000
微软就不用说了微软据说有一个

3611
02:20:58,000 --> 02:21:00,000
非常非常非常非常大的测试部

3612
02:21:02,000 --> 02:21:04,000
他不是整个公司都是测试部吗

3613
02:21:04,000 --> 02:21:06,000
这样不好

3614
02:21:07,000 --> 02:21:10,000
在测试那个 windows 10 的 alpha

3615
02:21:11,000 --> 02:21:12,000
之类的

3616
02:21:12,000 --> 02:21:15,000
所以苹果是不怎么喜欢写测试呢

3617
02:21:15,000 --> 02:21:16,000
Who knows

3618
02:21:16,000 --> 02:21:19,000
看他们出品的这个质量应该是不写了吧

3619
02:21:19,000 --> 02:21:25,000
当然不毕竟这一次 WDWDC 上发布的这一系列

3620
02:21:26,000 --> 02:21:27,000
在怎么说呢

3621
02:21:28,000 --> 02:21:28,000
对

3622
02:21:28,000 --> 02:21:30,000
偿还他们的技术债务的这个

3623
02:21:30,000 --> 02:21:31,000
补丁我觉得还是

3624
02:21:33,000 --> 02:21:33,000
比较好

3625
02:21:33,000 --> 02:21:34,000
就是

3626
02:21:35,000 --> 02:21:37,000
软件质量至少在

3627
02:21:38,000 --> 02:21:39,000
这一代叫什么

3628
02:21:40,000 --> 02:21:40,000
Lcapitan

3629
02:21:41,000 --> 02:21:42,000
在这一代

3630
02:21:42,000 --> 02:21:43,000
对

3631
02:21:43,000 --> 02:21:46,000
在这一代没有太大的新特性嘛

3632
02:21:46,000 --> 02:21:49,000
对所以就说明了他们把

3633
02:21:49,000 --> 02:21:51,000
时间都花在了修办上面

3634
02:21:51,000 --> 02:21:55,000
那也不一定你可能在搞什么 watchOS 之类的事情

3635
02:21:56,000 --> 02:21:57,000
I don't say

3636
02:21:57,000 --> 02:21:58,000
好吧

3637
02:21:58,000 --> 02:22:00,000
就是不要太乐观我觉得

3638
02:22:01,000 --> 02:22:02,000
OK

3639
02:22:03,000 --> 02:22:09,000
所以我们接下来可以进入到本期的最后一个环节就是介绍一些常用的

3640
02:22:10,000 --> 02:22:11,000
写测试的工具

3641
02:22:12,000 --> 02:22:15,000
尤其是 unit test

3642
02:22:15,000 --> 02:22:16,000
就是单元测试

3643
02:22:16,000 --> 02:22:19,000
单元测试是所有的你所能写的测试里面

3644
02:22:19,000 --> 02:22:20,000
颗粒最小的一个

3645
02:22:20,000 --> 02:22:21,000
同时也是

3646
02:22:22,000 --> 02:22:23,000
作为一个开发者而不是

3647
02:22:24,000 --> 02:22:25,000
QA 人员

3648
02:22:25,000 --> 02:22:27,000
也是软件验收者来说

3649
02:22:27,000 --> 02:22:28,000
所能接触的

3650
02:22:28,000 --> 02:22:29,000
最普

3651
02:22:29,000 --> 02:22:30,000
最常见的一种测试

3652
02:22:31,000 --> 02:22:33,000
首先介绍给大家的就是

3653
02:22:33,000 --> 02:22:34,000
Xunit family

3654
02:22:37,000 --> 02:22:38,000
怎么说呢就是因为

3655
02:22:39,000 --> 02:22:40,000
差单元

3656
02:22:40,000 --> 02:22:40,000
对

3657
02:22:40,000 --> 02:22:41,000
差单元 family

3658
02:22:42,000 --> 02:22:43,000
就是因为

3659
02:22:43,000 --> 02:22:47,000
软件测试单元测试非常非常的普遍

3660
02:22:47,000 --> 02:22:48,000
以至于有这么一套

3661
02:22:51,000 --> 02:22:52,000
Pattern

3662
02:22:52,000 --> 02:22:53,000
可以被

3663
02:22:54,000 --> 02:22:57,000
套用在各个语言所写的程序里面

3664
02:22:58,000 --> 02:23:01,000
而这个 Pattern 在最开始的创始人

3665
02:23:03,000 --> 02:23:06,000
是一个叫做 Kent Beck 的

3666
02:23:08,000 --> 02:23:09,000
大神

3667
02:23:09,000 --> 02:23:10,000
他应该也算大神

3668
02:23:10,000 --> 02:23:16,000
而他最开始所写的这一套 unit test 的

3669
02:23:17,000 --> 02:23:19,000
工具呢是叫做 Sunit

3670
02:23:20,000 --> 02:23:22,000
是写给 small talk

3671
02:23:23,000 --> 02:23:24,000
跟 Sunet

3672
02:23:24,000 --> 02:23:26,000
跟 Sun 没什么关系

3673
02:23:26,000 --> 02:23:27,000
至少是 Sunit

3674
02:23:28,000 --> 02:23:31,000
OK 你是说他是可以念出来是吧

3675
02:23:32,000 --> 02:23:33,000
Sunit

3676
02:23:33,000 --> 02:23:34,000
Sunit

3677
02:23:36,000 --> 02:23:37,000
所以 J unit 应该怎么念

3678
02:23:38,000 --> 02:23:38,000
Janet

3679
02:23:39,000 --> 02:23:39,000
Janet

3680
02:23:41,000 --> 02:23:42,000
怎么像

3681
02:23:43,000 --> 02:23:44,000
Janet

3682
02:23:44,000 --> 02:23:48,000
R unit 就是 ruined

3683
02:23:48,000 --> 02:23:49,000
毁了它吧

3684
02:23:49,000 --> 02:23:51,000
不是 run it

3685
02:23:51,000 --> 02:23:52,000
OK

3686
02:23:52,000 --> 02:23:54,000
对

3687
02:23:54,000 --> 02:23:56,000
我还是轻易把它念成 S unit

3688
02:23:56,000 --> 02:23:57,000
Sunit

3689
02:23:57,000 --> 02:23:58,000
天哪

3690
02:23:58,000 --> 02:23:59,000
这是个正确的念法

3691
02:24:00,000 --> 02:24:00,000
OK

3692
02:24:00,000 --> 02:24:03,000
Kent Beck 这个人呢为 small talk

3693
02:24:04,000 --> 02:24:07,000
所研发出的这一套单元测试的工具

3694
02:24:09,000 --> 02:24:09,000
在

3695
02:24:10,000 --> 02:24:12,000
紧紧跟随着这个

3696
02:24:12,000 --> 02:24:18,000
极限编程的方法以及整个象敏节转向的这么一个轮流

3697
02:24:19,000 --> 02:24:22,000
逐渐被套用到了其他所有几乎所有语言上

3698
02:24:22,000 --> 02:24:26,000
是几乎这两个字都不用加就是除了什么 brainfuck 之外

3699
02:24:26,000 --> 02:24:29,000
可能没有不支持 unitest

3700
02:24:30,000 --> 02:24:32,000
不支持这个 x unit 的

3701
02:24:33,000 --> 02:24:34,000
语言存在

3702
02:24:34,000 --> 02:24:35,000
就是

3703
02:24:35,000 --> 02:24:38,000
基本上你能想出来的什么 CR PHP

3704
02:24:39,000 --> 02:24:40,000
Ruby

3705
02:24:40,000 --> 02:24:41,000
Java

3706
02:24:41,000 --> 02:24:42,000
Java 就更不用说了

3707
02:24:42,000 --> 02:24:44,000
J unit 简直是 Java 世界里面

3708
02:24:46,000 --> 02:24:48,000
如果你想要找到工作一定要选什么一个工具

3709
02:24:49,000 --> 02:24:53,000
然后.net 世界当然也有相应的比如说

3710
02:24:53,000 --> 02:24:54,000
N unit

3711
02:24:54,000 --> 02:24:55,000
或者是

3712
02:24:56,000 --> 02:24:57,000
微软自家出的

3713
02:24:58,000 --> 02:24:59,000
之前叫 ms test

3714
02:25:00,000 --> 02:25:01,000
后来改叫 VSTest

3715
02:25:01,000 --> 02:25:02,000
Visual Studio Test

3716
02:25:05,000 --> 02:25:07,000
然后如果你使用

3717
02:25:07,000 --> 02:25:11,000
Objective-C 的话之前有这个所谓

3718
02:25:11,000 --> 02:25:12,000
XC test

3719
02:25:13,000 --> 02:25:15,000
XC stand for Xcode

3720
02:25:15,000 --> 02:25:17,000
XC test

3721
02:25:17,000 --> 02:25:19,000
就好像 VSTest 一样

3722
02:25:19,000 --> 02:25:23,000
是在 Xcode 里面执行的

3723
02:25:23,000 --> 02:25:25,000
专门为 Objective-C 以及

3724
02:25:26,000 --> 02:25:27,000
SWIFT 应该也有

3725
02:25:28,000 --> 02:25:30,000
所开发的这个单元测试框架

3726
02:25:31,000 --> 02:25:33,000
其实这边直接给一个这个

3727
02:25:33,000 --> 02:25:37,000
链接就好了因为 Wikipedia 上有一个比较好的

3728
02:25:38,000 --> 02:25:43,000
叫做 list of unit testing frameworks

3729
02:25:43,000 --> 02:25:44,000
然后

3730
02:25:46,000 --> 02:25:48,000
这个我们想要说的一个比较

3731
02:25:48,000 --> 02:25:50,000
有意思的东西其实是 dog test

3732
02:25:51,000 --> 02:25:53,000
我不知道你用没有我

3733
02:25:53,000 --> 02:25:55,000
Python 的语言里面有一个

3734
02:25:56,000 --> 02:25:58,000
当然有一个 unit test 的包

3735
02:25:58,000 --> 02:26:01,000
然后另外 Python 有一个很有意思的包叫 dog test

3736
02:26:02,000 --> 02:26:04,000
你有用过吗

3737
02:26:05,000 --> 02:26:07,000
一个不写测试的

3738
02:26:10,000 --> 02:26:15,000
这比较想要安利一下的东西就是 dog test 这个东西

3739
02:26:15,000 --> 02:26:19,000
它有意思或者说它实用的点在哪呢

3740
02:26:20,000 --> 02:26:24,000
我们知道如果你在一个方法或者在一个类里面

3741
02:26:24,000 --> 02:26:25,000
它的定义下面

3742
02:26:26,000 --> 02:26:27,000
你可以写一个 string

3743
02:26:28,000 --> 02:26:31,000
这个东西被称为 dog string

3744
02:26:33,000 --> 02:26:34,000
然后你可以

3745
02:26:34,000 --> 02:26:38,000
我想起来我有见到过这个但自己没有试过

3746
02:26:39,000 --> 02:26:44,000
然后 dog test 这个包所支持的一个功能就是你可以在这个 dog string 里面

3747
02:26:44,000 --> 02:26:46,000
写一些

3748
02:26:46,000 --> 02:26:47,000
测试

3749
02:26:48,000 --> 02:26:50,000
语法很简单就是

3750
02:26:50,000 --> 02:26:55,000
Python 的这个提示符大家都知道是三个相用的代语号

3751
02:26:56,000 --> 02:26:59,000
那么你只需要在这个 dog string 里面

3752
02:26:59,000 --> 02:27:00,000
写三个相用的代语号

3753
02:27:01,000 --> 02:27:02,000
然后写

3754
02:27:02,000 --> 02:27:05,000
这个测试所应该执行的语句

3755
02:27:05,000 --> 02:27:06,000
然后在

3756
02:27:07,000 --> 02:27:09,000
新另起一行在不写这个

3757
02:27:09,000 --> 02:27:13,000
三个代语号的情况下写出这个程序执行之后

3758
02:27:13,000 --> 02:27:14,000
所应该有的值

3759
02:27:15,000 --> 02:27:15,000
你就写好这个测试

3760
02:27:16,000 --> 02:27:17,000
是不是很神奇呢

3761
02:27:17,000 --> 02:27:18,000
就好像

3762
02:27:18,000 --> 02:27:22,000
你在这个 dog string 里面给你的这个函数写了一个

3763
02:27:23,000 --> 02:27:24,000
用法的示例

3764
02:27:25,000 --> 02:27:26,000
然后这个示例本身

3765
02:27:26,000 --> 02:27:28,000
忽然就可以当作单元测试来用了

3766
02:27:29,000 --> 02:27:33,000
这是一个非常好的一个工具

3767
02:27:33,000 --> 02:27:38,000
但我觉得这个的唯一的问题就是有时候那个力度

3768
02:27:38,000 --> 02:27:41,000
就是它不是一个 unit 的时候你也没法用这个方法

3769
02:27:41,000 --> 02:27:42,000
对

3770
02:27:42,000 --> 02:27:45,000
这个就 dog test 仅限于 unit test 的用

3771
02:27:46,000 --> 02:27:48,000
一旦跨了一个函数就不行

3772
02:27:49,000 --> 02:27:51,000
其实也是有别的方法比如说

3773
02:27:52,000 --> 02:27:56,000
dog test 这个包可以单独拿出来就是生成一个专门的

3774
02:27:56,000 --> 02:27:57,000
Python 文件

3775
02:27:57,000 --> 02:28:00,000
然后这个 Python 文件里面除了

3776
02:28:01,000 --> 02:28:02,000
这样

3777
02:28:02,000 --> 02:28:08,000
dog test 的语法写成的测试之外别无他物然后你可以在这里面

3778
02:28:08,000 --> 02:28:10,000
用这个

3779
02:28:11,000 --> 02:28:17,000
dog test 来或者说滥用 dog test 来写一些跨模块跨函数乃至于跨模块的测试

3780
02:28:18,000 --> 02:28:21,000
Zoap 有一个测试框架就是干这个

3781
02:28:22,000 --> 02:28:24,000
不过这个 dog test 其实是

3782
02:28:26,000 --> 02:28:27,000
有点像那个叫什么

3783
02:28:28,000 --> 02:28:30,000
Dona Knuth

3784
02:28:30,000 --> 02:28:31,000
那个叫 literate programming

3785
02:28:32,000 --> 02:28:32,000
反过来做

3786
02:28:33,000 --> 02:28:35,000
literate program 中文翻译叫什么来的

3787
02:28:35,000 --> 02:28:36,000
文化编程

3788
02:28:36,000 --> 02:28:37,000
文艺编程

3789
02:28:37,000 --> 02:28:38,000
文青编程

3790
02:28:41,000 --> 02:28:42,000
我不知道这个怎么翻

3791
02:28:43,000 --> 02:28:44,000
我怎么翻译

3792
02:28:44,000 --> 02:28:46,000
他那个东西就是说其实就是在

3793
02:28:47,000 --> 02:28:47,000
就是

3794
02:28:48,000 --> 02:28:49,000
其实一直在写注释

3795
02:28:49,000 --> 02:28:51,000
代码就是穿插在

3796
02:28:51,000 --> 02:28:53,000
你用写注释的方式来写代码

3797
02:28:53,000 --> 02:28:56,000
没错然后这个就是有点反过来就是说

3798
02:28:56,000 --> 02:29:00,000
你也主要是写代码但是注释呢是对代码的一个解释

3799
02:29:00,000 --> 02:29:02,000
然后注释这个解释还是可以

3800
02:29:02,000 --> 02:29:03,000
还是可以执行的

3801
02:29:04,000 --> 02:29:05,000
这就还比较不错

3802
02:29:06,000 --> 02:29:08,000
最后一个问题就是

3803
02:29:08,000 --> 02:29:10,000
现在正夯的一个

3804
02:29:11,000 --> 02:29:12,000
functional programming 的概念

3805
02:29:13,000 --> 02:29:16,000
我们知道在敏捷方法

3806
02:29:17,000 --> 02:29:22,000
崛起的过程中其实基本上也就伴随着面向对象

3807
02:29:22,000 --> 02:29:23,000
这个思潮的崛起

3808
02:29:25,000 --> 02:29:25,000
基本上可以说

3809
02:29:25,000 --> 02:29:29,000
如果没有面向对象理念的话敏捷是完全实现不了

3810
02:29:30,000 --> 02:29:31,000
那

3811
02:29:32,000 --> 02:29:36,000
面向对象编程也已经被证明了是更适合

3812
02:29:36,000 --> 02:29:38,000
与写测试的一种方法

3813
02:29:38,000 --> 02:29:40,000
那我们可以把

3814
02:29:40,000 --> 02:29:41,000
封装得好

3815
02:29:43,000 --> 02:29:45,000
面向对象可以保证你把

3816
02:29:46,000 --> 02:29:47,000
系统的偶合度降到最低

3817
02:29:50,000 --> 02:29:55,000
那么相同的问题我们可以套用在目前正夯的这个 functional programming 的概念上

3818
02:29:55,000 --> 02:29:59,000
functional programming 适合写测试吗

3819
02:30:01,000 --> 02:30:03,000
其实我觉得还蛮合适的

3820
02:30:03,000 --> 02:30:04,000
因为

3821
02:30:04,000 --> 02:30:05,000
怎么说呢

3822
02:30:05,000 --> 02:30:05,000
就是

3823
02:30:06,000 --> 02:30:07,000
functional programming 的

3824
02:30:08,000 --> 02:30:12,000
的一个思潮就是说每一个函数的独立性很好

3825
02:30:12,000 --> 02:30:13,000
至少就是在

3826
02:30:13,000 --> 02:30:14,000
在

3827
02:30:15,000 --> 02:30:17,000
在原则上我们是鼓励每个函数是可以叫做

3828
02:30:18,000 --> 02:30:19,000
它是认识一个函数对吧

3829
02:30:19,000 --> 02:30:20,000
所谓函数就是说它是

3830
02:30:20,000 --> 02:30:21,000
确定数

3831
02:30:21,000 --> 02:30:22,000
没有副作用

3832
02:30:22,000 --> 02:30:23,000
对

3833
02:30:23,000 --> 02:30:24,000
side effect free

3834
02:30:24,000 --> 02:30:25,000
就是我确定一个数

3835
02:30:25,000 --> 02:30:25,000
就确定一个函数

3836
02:30:26,000 --> 02:30:28,000
这个时候你写测试就比较简单了

3837
02:30:28,000 --> 02:30:29,000
因为你不用考虑说

3838
02:30:30,000 --> 02:30:33,000
你从某一种状态进入这个函数

3839
02:30:33,000 --> 02:30:37,000
或者进入一个过程的时候会得到一个解但是你从另外一个状态进入的时候会得到另外一个解

3840
02:30:38,000 --> 02:30:39,000
这样的话

3841
02:30:39,000 --> 02:30:41,000
你这个测试没法写了

3842
02:30:41,000 --> 02:30:42,000
你得先

3843
02:30:42,000 --> 02:30:43,000
set up the

3844
02:30:43,000 --> 02:30:44,000
environment

3845
02:30:44,000 --> 02:30:46,000
你得先设置这个环境才可以

3846
02:30:46,000 --> 02:30:47,000
但是如果是 fp 的话

3847
02:30:48,000 --> 02:30:48,000
就不存在这个问题

3848
02:30:48,000 --> 02:30:50,000
你只要照着写

3849
02:30:50,000 --> 02:30:51,000
什么输出给什么结果

3850
02:30:52,000 --> 02:30:54,000
你可以马上把人与对应的这个关系列出来

3851
02:30:55,000 --> 02:30:55,000
对

3852
02:30:55,000 --> 02:31:01,000
所以这也就为我们提供另外一个拥抱函数编程的理由

3853
02:31:02,000 --> 02:31:03,000
对没错

3854
02:31:04,000 --> 02:31:05,000
测试好写

3855
02:31:06,000 --> 02:31:06,000
没错

3856
02:31:06,000 --> 02:31:07,000
测试好写

3857
02:31:07,000 --> 02:31:09,000
所以如果你们还没有接触函数编程的话

3858
02:31:10,000 --> 02:31:11,000
一定要去试试

3859
02:31:12,000 --> 02:31:15,000
对找工作很有帮助

3860
02:31:16,000 --> 02:31:18,000
可以瞬间提升

3861
02:31:19,000 --> 02:31:19,000
那个什么来的

3862
02:31:20,000 --> 02:31:20,000
逼格

3863
02:31:22,000 --> 02:31:23,000
提升内力吧

3864
02:31:24,000 --> 02:31:25,000
这个逼格不逼格

3865
02:31:25,000 --> 02:31:26,000
又是一个 lump

3866
02:31:27,000 --> 02:31:35,000
是鸦鸦

3867
02:31:36,000 --> 02:31:40,000
分离

3868
02:31:41,000 --> 02:31:43,000
你 Circ 长

3869
02:31:43,000 --> 02:31:47,000
还有全场

3870
02:31:47,000 --> 02:31:48,000
'RE

3871
02:31:48,000 --> 02:31:49,000
高

3872
02:31:49,000 --> 02:31:50,000
开

3873
02:31:50,000 --> 02:31:50,000
M

3874
02:31:51,000 --> 02:31:51,000
是

3875
02:31:52,000 --> 02:31:52,000
真的

3876
02:31:52,000 --> 02:31:53,000
虽无

3877
02:31:53,000 --> 02:31:54,000
不

3878
02:31:54,000 --> 02:31:55,000
这

3879
02:31:55,000 --> 02:31:56,000
一个比较好的统一的规范

3880
02:31:56,000 --> 02:31:59,000
就不用单独再学一个

3881
02:31:59,000 --> 02:32:00,000
第三方的东西

3882
02:32:00,000 --> 02:32:02,000
就其实写测试

3883
02:32:02,000 --> 02:32:03,000
就特别写单人测试的话

3884
02:32:03,000 --> 02:32:05,000
还是挺方便的

3885
02:32:05,000 --> 02:32:06,000
就要承认一下

3886
02:32:06,000 --> 02:32:07,000
有时候还有点用

3887
02:32:07,000 --> 02:32:10,000
可能现在原式的一个思潮

3888
02:32:10,000 --> 02:32:11,000
也是要越来越多的

3889
02:32:11,000 --> 02:32:13,000
在原内部集成一些

3890
02:32:13,000 --> 02:32:14,000
比如说测试

3891
02:32:14,000 --> 02:32:17,000
比如说调试之类的特性

3892
02:32:17,000 --> 02:32:21,000
OK

3893
02:32:21,000 --> 02:32:23,000
那好吧

3894
02:32:23,000 --> 02:32:24,000
今天就到这了

3895
02:32:24,000 --> 02:32:26,000
您刚刚收听的是

3896
02:32:26,000 --> 02:32:27,000
IPM Podcast 网络旗下的

3897
02:32:27,000 --> 02:32:30,000
IT 技术主题娱乐节目

3898
02:32:30,000 --> 02:32:30,000
内核风风

3899
02:32:30,000 --> 02:32:33,000
IPM 旗下的其他六档 Podcast

3900
02:32:33,000 --> 02:32:34,000
包括 softcore 技术主题节目

3901
02:32:34,000 --> 02:32:36,000
非娱乐技术节目

3902
02:32:36,000 --> 02:32:37,000
IT 公论

3903
02:32:37,000 --> 02:32:38,000
意料主题节目

3904
02:32:38,000 --> 02:32:39,000
太一来了

3905
02:32:39,000 --> 02:32:40,000
美食主题节目

3906
02:32:40,000 --> 02:32:40,000
未知到

3907
02:32:40,000 --> 02:32:41,000
艺术主题节目

3908
02:32:41,000 --> 02:32:42,000
流行通信

3909
02:32:42,000 --> 02:32:43,000
无主题节目

3910
02:32:43,000 --> 02:32:43,000
无资源

3911
02:32:43,000 --> 02:32:44,000
故事主题节目

3912
02:32:44,000 --> 02:32:45,000
high story

3913
02:32:45,000 --> 02:32:47,000
以及影像主题节目

3914
02:32:47,000 --> 02:32:47,000
映像

3915
02:32:47,000 --> 02:32:49,000
如果你喜欢我们的节目

3916
02:32:49,000 --> 02:32:51,000
欢迎你为我们的节目捐款

3917
02:32:51,000 --> 02:32:53,000
捐款的意思是

3918
02:32:53,000 --> 02:32:55,000
你可以把本节目再听一遍

3919
02:32:55,000 --> 02:32:56,000
开头我又讲

3920
02:32:56,000 --> 02:32:59,000
这个要念

3921
02:32:59,000 --> 02:32:59,000
这个要念是

3922
02:32:59,000 --> 02:33:02,000
kernelpanic.fm

3923
02:33:02,000 --> 02:33:03,000
写个 donate

3924
02:33:03,000 --> 02:33:05,000
D-O-N-A-T-E

3925
02:33:05,000 --> 02:33:06,000
好吧

3926
02:33:06,000 --> 02:33:08,000
要提醒大家一点是

3927
02:33:08,000 --> 02:33:10,000
不要加 https

3928
02:33:10,000 --> 02:33:12,000
这个网址

3929
02:33:12,000 --> 02:33:14,000
反正它会跳转的

3930
02:33:14,000 --> 02:33:14,000
无所谓

3931
02:33:14,000 --> 02:33:15,000
对

3932
02:33:15,000 --> 02:33:17,000
但是为了保证您安全

3933
02:33:17,000 --> 02:33:18,000
它会自动跳转到一个

3934
02:33:18,000 --> 02:33:21,000
带 https 加密

3935
02:33:21,000 --> 02:33:23,000
带 https 加密

3936
02:33:23,000 --> 02:33:25,000
OK

3937
02:33:25,000 --> 02:33:29,000
今天的节目就到这里了

3938
02:33:29,000 --> 02:33:31,000
1.79 Gb

