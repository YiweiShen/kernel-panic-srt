1
00:00:00,000 --> 00:00:04,000
大家好 欢迎收听第七期的内核恐慌

2
00:00:04,000 --> 00:00:04,000
我是 Rail

3
00:00:04,000 --> 00:00:05,000
我是吴涛

4
00:00:05,000 --> 00:00:07,000
哎呀 终于第七期了

5
00:00:07,000 --> 00:00:09,000
七是个我很喜欢的数字

6
00:00:09,000 --> 00:00:15,000
其实今天这期节目的时间会比较奇怪

7
00:00:15,000 --> 00:00:17,000
我们是提前了很久

8
00:00:17,000 --> 00:00:18,000
就是你们听到的时候应该是

9
00:00:18,000 --> 00:00:20,000
圣诞节之后了

10
00:00:20,000 --> 00:00:20,000
对

11
00:00:20,000 --> 00:00:23,000
你吴涛解释一下为什么要这么干的

12
00:00:23,000 --> 00:00:25,000
因为在这个神秘的时间点

13
00:00:25,000 --> 00:00:30,000
我们还没有办法得到足够的听众反馈

14
00:00:30,000 --> 00:00:33,000
我们相信我们在上一期里面

15
00:00:33,000 --> 00:00:35,000
遇到了犯了很多很低级的错误

16
00:00:35,000 --> 00:00:37,000
有可能是非常常识性的错误

17
00:00:37,000 --> 00:00:42,000
但是在目前这个 time space 的 point 上面

18
00:00:42,000 --> 00:00:44,000
我们还没有这些反馈信息

19
00:00:44,000 --> 00:00:47,000
所以我们这一期暂时先不做 follow up

20
00:00:47,000 --> 00:00:49,000
但是我保证下一期

21
00:00:49,000 --> 00:00:51,000
大家会听到我们两个在这边

22
00:00:51,000 --> 00:00:53,000
怎么说

23
00:00:53,000 --> 00:00:54,000
痛哭流泪

24
00:00:55,000 --> 00:00:59,000
捶胸顿足的道歉

25
00:00:59,000 --> 00:01:01,000
说我们犯了一些低级的错误

26
00:01:01,000 --> 00:01:02,000
包括上一期以及这一期

27
00:01:02,000 --> 00:01:09,000
所以这一期我们的主题是什么

28
00:01:09,000 --> 00:01:10,000
package management

29
00:01:10,000 --> 00:01:16,000
其实有一点点像上一期的主题的自然延伸

30
00:01:16,000 --> 00:01:18,000
就是上一期我们讨论了软件

31
00:01:18,000 --> 00:01:21,000
或者说程序生命周期的管理

32
00:01:21,000 --> 00:01:25,000
主要还是从比较小的一个主要点

33
00:01:25,000 --> 00:01:26,000
入手

34
00:01:26,000 --> 00:01:27,000
就是那主要是

35
00:01:27,000 --> 00:01:30,000
其实我一开始只是想谈内存管理

36
00:01:30,000 --> 00:01:31,000
但是没有想到后面扯到那么多

37
00:01:31,000 --> 00:01:34,000
那这一期的内容其实就是

38
00:01:34,000 --> 00:01:37,000
当你的软件写出来

39
00:01:37,000 --> 00:01:38,000
或者说你在写软件的时候

40
00:01:38,000 --> 00:01:41,000
你会需要用到许许多多内部外部的工具

41
00:01:41,000 --> 00:01:43,000
并且你希望你的软件可以以某种

42
00:01:43,000 --> 00:01:46,000
比较方便的方式被别人使用

43
00:01:46,000 --> 00:01:49,000
那你就需要把它包装起来

44
00:01:49,000 --> 00:01:52,000
我们这一期主要讨论就是这个问题

45
00:01:52,000 --> 00:01:53,000
嗯哼

46
00:01:53,000 --> 00:01:55,000
所以在开始的这一期的时候

47
00:01:55,000 --> 00:01:57,000
我们要先解释一下什么叫做

48
00:01:57,000 --> 00:01:59,000
这个概念是 package management

49
00:01:59,000 --> 00:02:01,000
对 package 实际上是一个非常

50
00:02:01,000 --> 00:02:05,000
泛泛的称呼

51
00:02:05,000 --> 00:02:08,000
就是它是一个指涉非常不清楚的词

52
00:02:08,000 --> 00:02:10,000
在很多不同语境之下会有很多不同的意义

53
00:02:10,000 --> 00:02:11,000
比如说

54
00:02:11,000 --> 00:02:15,000
以 OS X 来说

55
00:02:15,000 --> 00:02:16,000
package 可以是指

56
00:02:16,000 --> 00:02:18,000
比如说一个 application bundle

57
00:02:18,000 --> 00:02:19,000
可以是一个 package

58
00:02:19,000 --> 00:02:20,000
对吧

59
00:02:20,000 --> 00:02:21,000
然后

60
00:02:21,000 --> 00:02:23,000
但是与此同时

61
00:02:23,000 --> 00:02:25,000
你又可以通过一种叫做

62
00:02:25,000 --> 00:02:29,000
.pkg 的文件来安装一个程序

63
00:02:29,000 --> 00:02:32,000
然后那个.pkg 文件也是一个 package

64
00:02:32,000 --> 00:02:33,000
对

65
00:02:33,000 --> 00:02:34,000
有点

66
00:02:34,000 --> 00:02:37,000
就在不同的语境下 package 的概念

67
00:02:37,000 --> 00:02:40,000
就是有点比较不清晰的

68
00:02:40,000 --> 00:02:40,000
对

69
00:02:40,000 --> 00:02:45,000
然后加码程序员可能会非常习惯于一个 package

70
00:02:45,000 --> 00:02:47,000
就是一个 jar file

71
00:02:47,000 --> 00:02:48,000
或者是一个 var file

72
00:02:48,000 --> 00:02:52,000
然后它既可以只拿来

73
00:02:52,000 --> 00:02:55,000
可以拿来用第三方库

74
00:02:55,000 --> 00:02:58,000
也可以指自己写出来的什么东西

75
00:02:58,000 --> 00:03:01,000
在部署的时候所打包成的一个文件

76
00:03:01,000 --> 00:03:02,000
对

77
00:03:02,000 --> 00:03:04,000
就是在对开发的时候

78
00:03:04,000 --> 00:03:06,000
我们讲的 package 和部署的时候 package

79
00:03:06,000 --> 00:03:08,000
就其实又不是同一个

80
00:03:08,000 --> 00:03:09,000
就相关的

81
00:03:09,000 --> 00:03:10,000
但并不完全一致

82
00:03:10,000 --> 00:03:11,000
对

83
00:03:11,000 --> 00:03:13,000
那什么是开发时的 package 呢

84
00:03:13,000 --> 00:03:15,000
对

85
00:03:15,000 --> 00:03:17,000
这个要解释一下吧

86
00:03:17,000 --> 00:03:18,000
就大概可以理解为

87
00:03:18,000 --> 00:03:20,000
你要写一个软件

88
00:03:20,000 --> 00:03:22,000
然后你需要依赖

89
00:03:22,000 --> 00:03:23,000
你不是从

90
00:03:23,000 --> 00:03:25,000
从头到尾都是用

91
00:03:25,000 --> 00:03:26,000
全部自己写

92
00:03:26,000 --> 00:03:27,000
你肯定要用到别人的一些什么

93
00:03:27,000 --> 00:03:28,000
第三方的代码

94
00:03:28,000 --> 00:03:32,000
或者是你那个语言的原生的标准库里面那些东西

95
00:03:32,000 --> 00:03:34,000
然后这些

96
00:03:34,000 --> 00:03:35,000
你要用的那些东西

97
00:03:35,000 --> 00:03:37,000
大概可以理解为一个 package

98
00:03:37,000 --> 00:03:39,000
这个时候你就要去调用那些 package

99
00:03:39,000 --> 00:03:41,000
才能完成你这个软件的功能

100
00:03:41,000 --> 00:03:41,000
对

101
00:03:41,000 --> 00:03:43,000
我记得小时候写程序

102
00:03:43,000 --> 00:03:46,000
如果需要用到别人的第三方代码

103
00:03:46,000 --> 00:03:48,000
我就直接把那代码拷贝一遍

104
00:03:48,000 --> 00:03:50,000
粘贴到我的文件里就可以了

105
00:03:50,000 --> 00:03:52,000
对的

106
00:03:52,000 --> 00:03:55,000
这是 package management done and run 了

107
00:03:55,000 --> 00:03:55,000
对的

108
00:03:55,000 --> 00:03:55,000
对的

109
00:03:55,000 --> 00:04:00,000
,不过其实在今天我们做了很多事情

110
00:04:00,000 --> 00:04:03,000
跟这个其实在本质上也是很类似的

111
00:04:03,000 --> 00:04:06,000
就把别人的代码挪到自己的代码库里面去

112
00:04:06,000 --> 00:04:07,000
这样可以保证

113
00:04:07,000 --> 00:04:11,000
以后你就不用再管别人他怎么改他

114
00:04:11,000 --> 00:04:13,000
你反正你有一份副本了

115
00:04:13,000 --> 00:04:15,000
在你的本地的这个目录里面去

116
00:04:15,000 --> 00:04:16,000
对吧

117
00:04:16,000 --> 00:04:17,000
对现在的 package management

118
00:04:17,000 --> 00:04:20,000
或者说在开发时的 package management

119
00:04:20,000 --> 00:04:21,000
所解决的问题就是

120
00:04:21,000 --> 00:04:23,000
怎样让你不尽量

121
00:04:23,000 --> 00:04:25,000
怎样让你尽量

122
00:04:25,000 --> 00:04:28,000
不 dirty 的去拷贝别人的文件

123
00:04:28,000 --> 00:04:30,000
到你的工程里面去

124
00:04:30,000 --> 00:04:33,000
就如果你需要依赖别人的代码

125
00:04:33,000 --> 00:04:36,000
而通过简单的复制粘贴

126
00:04:36,000 --> 00:04:37,000
像我们童年做的那样的话

127
00:04:37,000 --> 00:04:41,000
那假如对方升级了一下他的一个功能

128
00:04:41,000 --> 00:04:42,000
你怎么用呢

129
00:04:42,000 --> 00:04:44,000
你还要再拷贝再粘贴一遍

130
00:04:44,000 --> 00:04:47,000
这还不是最痛苦的部分

131
00:04:47,000 --> 00:04:48,000
最痛苦的部分是

132
00:04:48,000 --> 00:04:52,000
假如你想要把别人的库扔出去的时候

133
00:04:52,000 --> 00:04:54,000
有可能你会非常苦恼的发现

134
00:04:54,000 --> 00:04:56,000
已经不记得哪一部分是你

135
00:04:56,000 --> 00:04:59,000
拷贝复制粘贴进来的

136
00:04:59,000 --> 00:05:00,000
而哪一部分是你自己写的

137
00:05:00,000 --> 00:05:03,000
这个要什么

138
00:05:03,000 --> 00:05:05,000
要有这个版本管理才能发现

139
00:05:05,000 --> 00:05:06,000
要回去找那个 log

140
00:05:06,000 --> 00:05:09,000
而在你发明版本管理

141
00:05:09,000 --> 00:05:11,000
自己发明一个版本管理系统之前

142
00:05:11,000 --> 00:05:13,000
你可能已经会先发现

143
00:05:13,000 --> 00:05:15,000
原来世界上有 package management

144
00:05:15,000 --> 00:05:17,000
这种东西

145
00:05:17,000 --> 00:05:21,000
然后另外一个我们常说的状态

146
00:05:21,000 --> 00:05:22,000
就是说在部署的时候

147
00:05:22,000 --> 00:05:24,000
就是所谓把软件分发

148
00:05:24,000 --> 00:05:26,000
如果你是卖给消费者的话

149
00:05:26,000 --> 00:05:27,000
你是分发给别人

150
00:05:27,000 --> 00:05:30,000
或者是你是像我部署的服务器的软件的话

151
00:05:30,000 --> 00:05:34,000
你是要怎么把它弄导腾到这个服务器上去运行

152
00:05:34,000 --> 00:05:37,000
这个时候的这个要求又有点不一样

153
00:05:37,000 --> 00:05:39,000
这个时候我们要求

154
00:05:39,000 --> 00:05:41,000
这个 package 是尽可能的

155
00:05:41,000 --> 00:05:43,000
是什么可重复的

156
00:05:43,000 --> 00:05:45,000
就是你整个 deploy 的过程

157
00:05:45,000 --> 00:05:46,000
应该是可以重复的

158
00:05:46,000 --> 00:05:47,000
对

159
00:05:47,000 --> 00:05:50,000
那这个这么说可能稍微有点抽象

160
00:05:50,000 --> 00:05:52,000
但是如果你是一个 Windows 用户的话

161
00:05:52,000 --> 00:05:54,000
你可能会习惯于

162
00:05:54,000 --> 00:05:55,000
安装什么软件

163
00:05:55,000 --> 00:05:59,000
就是打开一个安装软件的

164
00:05:59,000 --> 00:06:00,000
install.exe

165
00:06:00,000 --> 00:06:03,000
然后还是或者叫 setup.exe

166
00:06:03,000 --> 00:06:05,000
然后你一路回车

167
00:06:05,000 --> 00:06:07,000
执行一个叫做 setup visa 的东西

168
00:06:07,000 --> 00:06:10,000
然后指定一个安装的目标路径

169
00:06:10,000 --> 00:06:10,000
对

170
00:06:10,000 --> 00:06:14,000
然后他会把所有东西给你塞到那个目录下面之后

171
00:06:14,000 --> 00:06:16,000
然后你去那个目录找

172
00:06:16,000 --> 00:06:17,000
就可以找到你要运行的程序

173
00:06:17,000 --> 00:06:19,000
所以在 Windows 的世界里面

174
00:06:19,000 --> 00:06:22,000
我们安装程序的过程是用一个程序去安装另一个程序

175
00:06:22,000 --> 00:06:24,000
或者说你为了安装你的程序

176
00:06:24,000 --> 00:06:26,000
你必须创建另外一个

177
00:06:26,000 --> 00:06:27,000
你用另外一个程序

178
00:06:27,000 --> 00:06:30,000
把你的程序打包在一个 package 里面

179
00:06:30,000 --> 00:06:32,000
然后交给别人

180
00:06:32,000 --> 00:06:36,000
别人在同样要利用另外一个程序来解压你的程序

181
00:06:36,000 --> 00:06:40,000
然后把它安装到对方的电脑下面

182
00:06:40,000 --> 00:06:41,000
对

183
00:06:41,000 --> 00:06:46,000
这个就跟在 OS 3 上面的常用的安装方式还不太一样

184
00:06:46,000 --> 00:06:47,000
刚才你也讲了

185
00:06:47,000 --> 00:06:51,000
就是比如说我们通常的一种方式是通过一个 DMG 的镜像

186
00:06:51,000 --> 00:06:53,000
或者是存在一个.zip 的压缩包

187
00:06:53,000 --> 00:06:54,000
然后解压的方式

188
00:06:54,000 --> 00:06:57,000
你把它拿出来一个.app 的这么一个目录

189
00:06:57,000 --> 00:06:59,000
然后这个目录整个是一个完整的程序

190
00:06:59,000 --> 00:07:03,000
你直接把它拖到你的 application 的 folder 里面

191
00:07:03,000 --> 00:07:04,000
这个事情就算完成了

192
00:07:04,000 --> 00:07:08,000
但是刚才你说那种 Windows 上面安装的方式

193
00:07:08,000 --> 00:07:09,000
在 OS 3 下的对比

194
00:07:09,000 --> 00:07:12,000
就是你之前也提到的那个.pkg 那种方式

195
00:07:12,000 --> 00:07:13,000
运行一个脚本

196
00:07:13,000 --> 00:07:16,000
然后把那些文件塞到你的系统的各个角落

197
00:07:16,000 --> 00:07:18,000
主要来说

198
00:07:18,000 --> 00:07:21,000
其实我们说 Mac 下面

199
00:07:21,000 --> 00:07:23,000
把一个.app 的

200
00:07:23,000 --> 00:07:24,000
把一个.app 的

201
00:07:24,000 --> 00:07:26,000
文件拖到你的 application 下面

202
00:07:26,000 --> 00:07:27,000
就可以得到这个

203
00:07:27,000 --> 00:07:29,000
或者说以这种方式

204
00:07:29,000 --> 00:07:30,000
你就完成安装

205
00:07:30,000 --> 00:07:31,000
这种安装是一种

206
00:07:31,000 --> 00:07:33,000
仅仅是一次拷贝而已

207
00:07:33,000 --> 00:07:36,000
你安装一个程序的方法

208
00:07:36,000 --> 00:07:37,000
就是通过拷贝

209
00:07:37,000 --> 00:07:39,000
而什么是.app 呢

210
00:07:39,000 --> 00:07:40,000
就是可能

211
00:07:40,000 --> 00:07:43,000
我觉得这是一种

212
00:07:43,000 --> 00:07:46,000
不同的封装层级的思路的体现

213
00:07:46,000 --> 00:07:47,000
就是在 Mac 下面

214
00:07:47,000 --> 00:07:49,000
所谓 app 文件

215
00:07:49,000 --> 00:07:52,000
实际上只是一个 folder 而已

216
00:07:52,000 --> 00:07:53,000
它只是一个文件夹而已

217
00:07:54,000 --> 00:07:56,000
但如果你把它改名成了.app

218
00:07:56,000 --> 00:08:00,000
并且在里面加上一个叫做 info.plist 的文件

219
00:08:00,000 --> 00:08:04,000
Mac 就会试图把它作为一个整体处理

220
00:08:04,000 --> 00:08:07,000
就是说你不能很方便的直接打开它的

221
00:08:07,000 --> 00:08:10,000
看到那个 app 那个目录里面的内容

222
00:08:10,000 --> 00:08:12,000
但是你如果右键可以叫什么

223
00:08:12,000 --> 00:08:14,000
show content

224
00:08:14,000 --> 00:08:16,000
show package content

225
00:08:16,000 --> 00:08:19,000
对这个呢就可以把它当成目录展开了

226
00:08:19,000 --> 00:08:19,000
对

227
00:08:19,000 --> 00:08:23,000
这个是我们在分发给消费者的时候的一种

228
00:08:24,000 --> 00:08:26,000
分发时候的 package

229
00:08:26,000 --> 00:08:28,000
然后如果在服务端的话

230
00:08:28,000 --> 00:08:34,000
这种方式就非常非常多的不同的安装方式了

231
00:08:34,000 --> 00:08:37,000
待会我们待会讲到不同的发行版的时候

232
00:08:37,000 --> 00:08:37,000
一个一个说吧

233
00:08:37,000 --> 00:08:38,000
对

234
00:08:38,000 --> 00:08:42,000
所以其实你们看到我们在这个 package management 的

235
00:08:42,000 --> 00:08:44,000
两个不同的应用场合

236
00:08:44,000 --> 00:08:47,000
但其实他们还是有一点的共性的

237
00:08:47,000 --> 00:08:50,000
就比如说至少我们要求说

238
00:08:50,000 --> 00:08:54,000
我们能够清楚的知道我们安装的是什么版本的一个 package

239
00:08:54,000 --> 00:08:54,000
对吧

240
00:08:54,000 --> 00:08:55,000
对

241
00:08:55,000 --> 00:08:59,000
我们知道有什么方法可以能够删掉它

242
00:08:59,000 --> 00:09:00,000
能够重复的安装

243
00:09:00,000 --> 00:09:01,000
对

244
00:09:01,000 --> 00:09:04,000
或者说比如说你把某一个文件修改

245
00:09:04,000 --> 00:09:05,000
就是意外修改了

246
00:09:05,000 --> 00:09:07,000
你能够把那个东西再拿回来

247
00:09:08,000 --> 00:09:10,000
还有就是说

248
00:09:10,000 --> 00:09:12,000
你安装的多个 package 之间

249
00:09:12,000 --> 00:09:15,000
最好不要互相有影响对吧

250
00:09:15,000 --> 00:09:18,000
比如说我安装了 A 这个包

251
00:09:18,000 --> 00:09:19,000
那我再安装 B 这个包

252
00:09:19,000 --> 00:09:20,000
他们会不会冲突啊

253
00:09:20,000 --> 00:09:22,000
我们最好能避免这种事情

254
00:09:22,000 --> 00:09:24,000
就是这些基本的需求吧

255
00:09:24,000 --> 00:09:24,000
对

256
00:09:24,000 --> 00:09:28,000
你在用 windows 的时候有没有感觉到

257
00:09:29,000 --> 00:09:32,000
windows 安装程序的过程是一个很神秘的过程

258
00:09:32,000 --> 00:09:34,000
或者是很复杂的过程

259
00:09:35,000 --> 00:09:39,000
其实我到今天为止也一直不是很清楚他们到底在做什么

260
00:09:39,000 --> 00:09:42,000
我想想有些什么事情我能想得起的啊

261
00:09:42,000 --> 00:09:45,000
就主程序他们就作为一个

262
00:09:46,000 --> 00:09:47,000
常见的 windows

263
00:09:47,000 --> 00:09:50,000
就符合 windows 规范的安装程序

264
00:09:50,000 --> 00:09:51,000
他是把自己塞到

265
00:09:51,000 --> 00:09:53,000
那个叫 C 下面的 program files

266
00:09:53,000 --> 00:09:54,000
program files

267
00:09:54,000 --> 00:09:57,000
然后建一个自己公司的名字的目录

268
00:09:57,000 --> 00:10:00,000
在下面建一个你这个程序的名字的目录

269
00:10:00,000 --> 00:10:02,000
然后再把东西的东西放进去吧

270
00:10:02,000 --> 00:10:03,000
包括你的那些什么

271
00:10:04,000 --> 00:10:04,000
需要依赖的

272
00:10:05,000 --> 00:10:07,000
软件库啊还有什么

273
00:10:07,000 --> 00:10:08,000
静态文件对吧

274
00:10:08,000 --> 00:10:09,000
都放在里面去

275
00:10:09,000 --> 00:10:11,000
然后还要加什么

276
00:10:11,000 --> 00:10:14,000
就是用户配就是写到什么注册表里面对不对

277
00:10:15,000 --> 00:10:17,000
现在 windows 8 里面好像又有一些什么

278
00:10:17,000 --> 00:10:18,000
又有点什么不一样

279
00:10:18,000 --> 00:10:20,000
有个什么 apps data 这个目录了

280
00:10:21,000 --> 00:10:23,000
所以 windows 8 要包起注册表吗

281
00:10:23,000 --> 00:10:24,000
不可能吧

282
00:10:24,000 --> 00:10:26,000
注册表是 windows 核心技术一部分

283
00:10:27,000 --> 00:10:29,000
这个不太清楚具体怎么样子

284
00:10:30,000 --> 00:10:33,000
但是我上次在虚拟机里面装的时候是发现有这么一些

285
00:10:34,000 --> 00:10:36,000
新的就是新是相对于

286
00:10:36,000 --> 00:10:39,000
之前 windows xp 或者是 windows 7 的时代的东西

287
00:10:39,000 --> 00:10:40,000
但这个因为我

288
00:10:40,000 --> 00:10:42,000
我不是这个 windows 中度用户

289
00:10:42,000 --> 00:10:43,000
也不太清楚他怎么一回事

290
00:10:43,000 --> 00:10:46,000
appdata 会不会是 app 在运行时产生的数据

291
00:10:47,000 --> 00:10:47,000
有可能

292
00:10:47,000 --> 00:10:50,000
那个是什么 data 我记得有个什么 data roaming

293
00:10:51,000 --> 00:10:51,000
folder

294
00:10:51,000 --> 00:10:53,000
是拿来做这件事情的

295
00:10:53,000 --> 00:10:54,000
ok

296
00:10:54,000 --> 00:10:55,000
我也不是很清楚

297
00:10:56,000 --> 00:10:56,000
但其实

298
00:10:56,000 --> 00:11:01,000
我觉得目前让我觉得回想起来很疑惑的一点就是

299
00:11:01,000 --> 00:11:03,000
windows 安装过程之中

300
00:11:04,000 --> 00:11:06,000
所产生的那些数据

301
00:11:07,000 --> 00:11:11,000
有时候在有些安装程序里面是可以看到的那点

302
00:11:11,000 --> 00:11:13,000
而另外一些安装程序里面是看不到的

303
00:11:14,000 --> 00:11:17,000
就比如说我记得 windapp 在安装的时候会

304
00:11:17,000 --> 00:11:21,000
跳出来一个列表然后不停的告诉你哪个文件被拷到哪个地方

305
00:11:22,000 --> 00:11:23,000
然后最后可以重新

306
00:11:23,000 --> 00:11:26,000
重新的去审查一遍这个安装程序到底干了些什么

307
00:11:27,000 --> 00:11:29,000
当然我相信 99%的人不会这么做

308
00:11:30,000 --> 00:11:31,000
但是提供这种可能性

309
00:11:32,000 --> 00:11:34,000
而另外一些安装程序好像从头到尾就

310
00:11:35,000 --> 00:11:36,000
就一直 next

311
00:11:36,000 --> 00:11:37,000
对而且

312
00:11:37,000 --> 00:11:43,000
有一个很著名的现象就是进度条从 0 到 99%需要大概一秒钟然后从 99%到 100%

313
00:11:44,000 --> 00:11:45,000
需要 10 分钟

314
00:11:45,000 --> 00:11:48,000
没算好

315
00:11:48,000 --> 00:11:53,000
刚刚你讲那个 windapp 那种形式他是有一种我记得印象中是有一种

316
00:11:53,000 --> 00:11:55,000
专门的这种

317
00:11:55,000 --> 00:11:57,000
生成安装程序的

318
00:11:57,000 --> 00:12:01,000
程序就是你其实就是不同的 installer 的供应商不同而已

319
00:12:02,000 --> 00:12:10,000
然后之前有这种很常用的那种 installer 就是可以让你有一个列表框显示每个步骤在干嘛

320
00:12:10,000 --> 00:12:14,000
但其实这个是非常用户不友好的一个东西

321
00:12:14,000 --> 00:12:22,000
作为一个普通用户你为什么要知道 windapp 装了多少个文件在哪个位置是吧这个是对你来说是没有什么实际价值的信息

322
00:12:23,000 --> 00:12:31,000
当然除非你有什么洁癖之外说你卸载的时候一定要逐个对照着那个列表把那个文件一个一个删掉

323
00:12:31,000 --> 00:12:33,000
这还是一个约定

324
00:12:33,000 --> 00:12:35,000
我也不知道就有时候

325
00:12:35,000 --> 00:12:39,000
window 上面提供的过渡信息在有些人看来是

326
00:12:39,000 --> 00:12:40,000
好事

327
00:12:40,000 --> 00:12:44,000
是一种是一种他时刻要看到

328
00:12:44,000 --> 00:12:47,000
电脑在做什么而反过来你给他一台

329
00:12:47,000 --> 00:12:49,000
比较不那么

330
00:12:51,000 --> 00:12:53,000
intrusive 的

331
00:12:53,000 --> 00:12:56,000
他会觉得是怎么这么

332
00:12:56,000 --> 00:12:59,000
这么安静啊我

333
00:12:59,000 --> 00:13:04,000
我在用你你给我点回应好吗就比如说我记得刚刚学那个 Linux 命令行的时候

334
00:13:05,000 --> 00:13:10,000
执行文执行命令他什么都不告诉你

335
00:13:10,000 --> 00:13:12,000
就把你默认是

336
00:13:13,000 --> 00:13:21,000
默认这种状态是没什么可做的所以他就什么也不说这样我觉得当时非常的难以忍受因为在道子下面不敢

337
00:13:21,000 --> 00:13:23,000
干嘛他都会告诉你啊我干了什么

338
00:13:23,000 --> 00:13:26,000
没什么可干的就算没什么可干的他又告诉你说没什么可干的

339
00:13:27,000 --> 00:13:31,000
对了就切换到刚刚切换到 Linux 就觉得我好酷啊

340
00:13:32,000 --> 00:13:36,000
不奇怪这可能也是那个什么 unix 用户和

341
00:13:37,000 --> 00:13:42,000
或者类 unix 系统的用户和那个 windows 和 dos 用户的本质区别吧

342
00:13:43,000 --> 00:13:43,000
就是

343
00:13:44,000 --> 00:13:46,000
可能用类 unix 用户就觉得

344
00:13:47,000 --> 00:13:51,000
你们这事情做就好了只要没出什么问题就别来烦我了因为我还有别的

345
00:13:51,000 --> 00:13:53,000
烦心的事多着呢对吧

346
00:13:53,000 --> 00:14:01,000
然后因为他们很多都是所谓早期都是什么专业用户啊他的这种程序员他知道在干嘛然后也知道结果是怎么样子

347
00:14:02,000 --> 00:14:04,000
但是像 dos 啊 windows 这种

348
00:14:04,000 --> 00:14:10,000
面向消费者的他可能需要一些什么存在感他需要知道

349
00:14:11,000 --> 00:14:14,000
我花 20 刀买了这个程序他干嘛了呢最后对吧

350
00:14:14,000 --> 00:14:17,000
对有回应是用户友好的一种表现

351
00:14:17,000 --> 00:14:19,000
但没有回应则是

352
00:14:19,000 --> 00:14:21,000
Programmatical 的一种表现

353
00:14:22,000 --> 00:14:23,000
嗯可以这么说吧

354
00:14:23,000 --> 00:14:27,000
我不确定是不是一定用户友好都有可能说那有些人

355
00:14:28,000 --> 00:14:29,000
不要来烦我啊

356
00:14:30,000 --> 00:14:36,000
哥们我至少对于一个初学者来说没有回应其实是一个非常费解的 behaviour

357
00:14:37,000 --> 00:14:38,000
你必须要一上来就跟他说

358
00:14:39,000 --> 00:14:45,000
这个程序如果没有回应的话意味着他没有他去认为自己没有什么可做的或者是他完成了该做的事情

359
00:14:45,000 --> 00:14:46,000
他就没有什么回应

360
00:14:47,000 --> 00:14:49,000
他只有他唯一有回应的时候就是报错

361
00:14:50,000 --> 00:14:51,000
嗯哼

362
00:14:51,000 --> 00:14:53,000
对这是两种不同的

363
00:14:53,000 --> 00:14:54,000
这个思想

364
00:14:55,000 --> 00:14:58,000
就看场景或者看你的这个应用吧有时候

365
00:14:59,000 --> 00:15:01,000
我的感觉倾向于就是

366
00:15:02,000 --> 00:15:04,000
用一个新的软件或者是新的

367
00:15:04,000 --> 00:15:08,000
产品的时候你可能需要了解一下一些具体的状况但这可能也是你可以

368
00:15:09,000 --> 00:15:13,000
从另一个角度说这个产品做的不好需要我了解那么多细节其实没必要嘛对吧

369
00:15:13,000 --> 00:15:14,000
但另外一种就说

370
00:15:15,000 --> 00:15:19,000
反正你这个工作就好了不要那么多废话

371
00:15:19,000 --> 00:15:22,000
嗯对说回到我们的

372
00:15:23,000 --> 00:15:24,000
这个 pick

373
00:15:24,000 --> 00:15:26,000
的话题上来就是

374
00:15:27,000 --> 00:15:29,000
还有一个问题 windows 上面

375
00:15:29,000 --> 00:15:35,000
当时一直让我疑惑的是假如一个程序同时需要一个

376
00:15:35,000 --> 00:15:36,000
酷的两版本

377
00:15:36,000 --> 00:15:37,000
windows 到底是怎么解决的

378
00:15:38,000 --> 00:15:41,000
这不是没法解决吗他们后来

379
00:15:41,000 --> 00:15:43,000
他就在那个叫做什么 dll hell

380
00:15:43,000 --> 00:15:47,000
对那 dll hell 具体来说其实就是

381
00:15:47,000 --> 00:15:51,000
A 软件需要某一个酷的

382
00:15:51,000 --> 00:15:53,000
假版本

383
00:15:53,000 --> 00:15:55,000
B 软件需要这个酷的乙版本

384
00:15:55,000 --> 00:15:58,000
那 windows 会同时保留甲乙两个版本对不对

385
00:15:59,000 --> 00:16:01,000
应该是这样的对

386
00:16:01,000 --> 00:16:07,000
那甲乙两个版本的差别在哪是在用户名文件名上有一个版本号的差别

387
00:16:08,000 --> 00:16:14,000
这个我不太清楚 windows 具体怎么做但是这个在不同就在不同的这种

388
00:16:14,000 --> 00:16:16,000
环境里面都是存在的就是

389
00:16:16,000 --> 00:16:20,000
这个最麻烦的问题是因为同一个软件不同版本那可能是互不兼容的嘛

390
00:16:20,000 --> 00:16:22,000
然后如果

391
00:16:22,000 --> 00:16:28,000
你刚才说的情况其实还还好了就是他 A 程序的时候他掉 A 加版本好了 B 程序掉乙版本

392
00:16:29,000 --> 00:16:29,000
互相不冲突

393
00:16:30,000 --> 00:16:32,000
比较坑的是这种

394
00:16:32,000 --> 00:16:34,000
是说你自己要写个 A 程序

395
00:16:34,000 --> 00:16:36,000
然后你可能需要这个

396
00:16:36,000 --> 00:16:39,000
某个酷的 1.0 版本

397
00:16:39,000 --> 00:16:42,000
然后你同时还要使用另外一个酷的

398
00:16:42,000 --> 00:16:44,000
另外一个酷 B 吧

399
00:16:44,000 --> 00:16:49,000
然后 B 他可能需要这个同样你依赖那个酷的 1.2 版本

400
00:16:50,000 --> 00:16:50,000
这个时候你就

401
00:16:50,000 --> 00:16:51,000
很坑了

402
00:16:51,000 --> 00:16:54,000
你就是要同时支持不同的

403
00:16:55,000 --> 00:16:59,000
同意在同一个程序里面你要依赖同一个软件库的不同的版本

404
00:16:59,000 --> 00:17:01,000
就是会会出现这种

405
00:17:01,000 --> 00:17:03,000
交叉有这种这种

406
00:17:03,000 --> 00:17:04,000
这种

407
00:17:04,000 --> 00:17:07,000
这个怎么形容比较好

408
00:17:07,000 --> 00:17:08,000
循环依赖

409
00:17:09,000 --> 00:17:11,000
也不叫循环会什么会什么

410
00:17:12,000 --> 00:17:13,000
有可能会是循环

411
00:17:14,000 --> 00:17:16,000
对对就反正就很很糟糕吗这样

412
00:17:16,000 --> 00:17:20,000
对脑中脑中立刻成成出现了一个一个错综复杂的数字

413
00:17:20,000 --> 00:17:21,000
对对对

414
00:17:21,000 --> 00:17:25,000
如果是个数还好

415
00:17:26,000 --> 00:17:28,000
对他就有可能是会有 circular reference

416
00:17:28,000 --> 00:17:29,000
他可能是个永向图

417
00:17:31,000 --> 00:17:31,000
就很搞死你

418
00:17:32,000 --> 00:17:32,000
对

419
00:17:33,000 --> 00:17:36,000
那 Linux 上面就没有 dependency help

420
00:17:36,000 --> 00:17:37,000
就没有 DHL help

421
00:17:38,000 --> 00:17:38,000
其实也有吧

422
00:17:39,000 --> 00:17:45,000
其实也是有的是现在我们大部分用的发行版他都是通过这个原生的他们一般

423
00:17:45,000 --> 00:17:47,000
每个发行版会自带一个包裹安装系统

424
00:17:48,000 --> 00:17:50,000
然后那个包裹安装系统会想办法去解决

425
00:17:50,000 --> 00:17:52,000
这些冲突啊这些

426
00:17:52,000 --> 00:17:54,000
之类的问题而且那个

427
00:17:55,000 --> 00:17:57,000
那个发行版的维护者他在

428
00:17:57,000 --> 00:18:00,000
打包的时候他也会考虑说这个问题比如说你

429
00:18:01,000 --> 00:18:02,000
他比如这个

430
00:18:02,000 --> 00:18:04,000
拿 Debian 来举例子吧他可能

431
00:18:04,000 --> 00:18:08,000
我发行的这个版本里面我把所有的都测过他们互相安装

432
00:18:09,000 --> 00:18:10,000
应该是没有问题的

433
00:18:10,000 --> 00:18:13,000
当然你如果有那种不同版本的这种

434
00:18:14,000 --> 00:18:18,000
酷的需求的话他会通过不同的文件名号不同路径来实现

435
00:18:18,000 --> 00:18:20,000
具体来说其实就是

436
00:18:20,000 --> 00:18:28,000
假如在 Linux 上面有一个就是和 Windows 一模一样的困境的话

437
00:18:28,000 --> 00:18:30,000
Linux 会

438
00:18:31,000 --> 00:18:34,000
支持你链接到不同版本的库

439
00:18:34,000 --> 00:18:34,000
上面

440
00:18:35,000 --> 00:18:38,000
而这些库每个库会有一个默认版本

441
00:18:39,000 --> 00:18:40,000
对

442
00:18:41,000 --> 00:18:45,000
一般会是用那个吧会用那个软链接来实现

443
00:18:46,000 --> 00:18:47,000
嗯

444
00:18:48,000 --> 00:18:50,000
有时候我在用

445
00:18:50,000 --> 00:18:57,000
Debian 的时候需要升级某一个我想要的工具到某一个版本

446
00:18:57,000 --> 00:18:57,000
比如说 Win 吧

447
00:18:58,000 --> 00:19:00,000
然后

448
00:19:00,000 --> 00:19:06,000
使用其内置的包管理工具升级的时候包管理工具说啊这个东西依赖于那个东西

449
00:19:07,000 --> 00:19:08,000
但是

450
00:19:09,000 --> 00:19:10,000
那个东西的版本已经过旧了

451
00:19:10,000 --> 00:19:12,000
所以你也需要一起升级那个东西

452
00:19:12,000 --> 00:19:14,000
好玩的就一起升级他好了

453
00:19:14,000 --> 00:19:18,000
可是升级的时候又会说啊这个东西会安装那个

454
00:19:19,000 --> 00:19:19,000
就是

455
00:19:19,000 --> 00:19:20,000
B 会

456
00:19:20,000 --> 00:19:24,000
在安装 C 的另外一个版本而 C 的另外一个版本在你这边会跟

457
00:19:24,000 --> 00:19:26,000
D 的什么东西冲突

458
00:19:27,000 --> 00:19:28,000
然后我就就啊

459
00:19:28,000 --> 00:19:30,000
怎么也是有这样的问题

460
00:19:30,000 --> 00:19:32,000
所以这样的问题其实在各个平台之下都是

461
00:19:32,000 --> 00:19:33,000
都是很难避免的

462
00:19:34,000 --> 00:19:35,000
可以说

463
00:19:35,000 --> 00:19:37,000
对其实我一直有一点

464
00:19:37,000 --> 00:19:39,000
想不明白比如说

465
00:19:39,000 --> 00:19:40,000
为什么

466
00:19:40,000 --> 00:19:41,000
我们

467
00:19:41,000 --> 00:19:46,000
这点可能在 Linux 上面比较明显就是我们经常会你装一个软件你会发现

468
00:19:46,000 --> 00:19:48,000
他会一来一堆其他乱七八糟的其他的软件或者是

469
00:19:50,000 --> 00:19:52,000
然后

470
00:19:52,000 --> 00:19:59,000
Linux 的大部分的发行版的做法是说这个我们发行版做的时候就会把这个东西考虑好他们之间的

471
00:19:59,000 --> 00:20:01,000
依赖关系然后我们会告诉你怎么去

472
00:20:01,000 --> 00:20:03,000
我会一套算法去解决这个依赖问题

473
00:20:04,000 --> 00:20:05,000
但

474
00:20:05,000 --> 00:20:11,000
其实你会发现这个时候你也会有那种情况就是问你升级到某一个他没有被

475
00:20:11,000 --> 00:20:12,000
发行版在那个

476
00:20:13,000 --> 00:20:14,000
版本支持的

477
00:20:14,000 --> 00:20:19,000
时候你就没有办法升级你那帮很大的风险去打破这个或者用自己编译的包吗

478
00:20:19,000 --> 00:20:21,000
那我就不明白了为什么

479
00:20:22,000 --> 00:20:23,000
在现在这个

480
00:20:23,000 --> 00:20:24,000
你直接

481
00:20:24,000 --> 00:20:28,000
装一个软件你把所有的依赖都打包好不要去

482
00:20:28,000 --> 00:20:30,000
和别人共享不就好了吗

483
00:20:30,000 --> 00:20:33,000
这个我觉得还是出于一个

484
00:20:34,000 --> 00:20:37,000
节省空间的考虑吧就如果你

485
00:20:37,000 --> 00:20:43,000
打包进去你自己需要那个库而这个库其实很多很多其他程序都需要

486
00:20:44,000 --> 00:20:45,000
你总要找出个界限吧就是哪

487
00:20:46,000 --> 00:20:46,000
到

488
00:20:46,000 --> 00:20:49,000
具体到什么库上你是一定要自己

489
00:20:49,000 --> 00:20:50,000
打包进去

490
00:20:51,000 --> 00:20:57,000
这个是有这么一个问题啊如果这个的理由是因为为了节省空间的话那

491
00:20:57,000 --> 00:20:59,000
在现代

492
00:20:59,000 --> 00:21:02,000
硬件条件下根本就已经不成立了吗你现在

493
00:21:02,000 --> 00:21:03,000
磁盘你动

494
00:21:03,000 --> 00:21:05,000
动轴多少一两个 T 对吧

495
00:21:05,000 --> 00:21:06,000
那个程序多大点空间

496
00:21:07,000 --> 00:21:10,000
不但并不仅仅是存储空间还有传输空间你需要考虑进去

497
00:21:11,000 --> 00:21:11,000
假如说

498
00:21:12,000 --> 00:21:19,000
我对啊我这个包从事无巨细从 Lipsy 一直到所有我可能用到的包我全都打包在一起

499
00:21:19,000 --> 00:21:24,000
给用户下载这个好像有点有点二吧

500
00:21:25,000 --> 00:21:26,000
嗯

501
00:21:26,000 --> 00:21:32,000
虽然是这么说但是其实你看在 OS 下面的大部分的点是这么干的呀

502
00:21:33,000 --> 00:21:34,000
嗯对吧

503
00:21:35,000 --> 00:21:41,000
其实倒是他们我后来也专门去想过这个问题也看了一些别人的说法有一个事情到

504
00:21:41,000 --> 00:21:43,000
我觉得是可以理解的就是

505
00:21:43,000 --> 00:21:49,000
因为你知道那是一种开放的系统吗他希望如果你在使用某个软件

506
00:21:49,000 --> 00:21:49,000
某个软件的时候

507
00:21:49,000 --> 00:21:52,000
发现了有问题你可以去修正他

508
00:21:53,000 --> 00:21:56,000
那么他希望你把这个修正比如是 buck fix 能够也

509
00:21:57,000 --> 00:21:58,000
因为你做 buck fix 其实在

510
00:21:59,000 --> 00:21:59,000
在

511
00:21:59,000 --> 00:22:03,000
从某种意义上来说是在帮助编写这个软件吗对吧

512
00:22:03,000 --> 00:22:08,000
那么他希望把这种成果这种劳动的工作不要浪费掉就你能够

513
00:22:08,000 --> 00:22:14,000
在你使用那个版本修正中你也向他的那个上游就是这个原作者那里

514
00:22:14,000 --> 00:22:16,000
能够把这个整合进去

515
00:22:16,000 --> 00:22:18,000
这样的话大家都可以

516
00:22:18,000 --> 00:22:19,000
享受到你修改这个软件

517
00:22:19,000 --> 00:22:22,000
这个 buck fix 带来的好处嘛

518
00:22:22,000 --> 00:22:23,000
对

519
00:22:23,000 --> 00:22:23,000
但

520
00:22:24,000 --> 00:22:28,000
我是觉得就是这是一种人为我为人的

521
00:22:28,000 --> 00:22:34,000
对对我就说这个他们的就是究其原因他们的理念就是这样子的那么同样的道理

522
00:22:34,000 --> 00:22:39,000
如果每个程序都是打包自己的依赖的那东西那么

523
00:22:39,000 --> 00:22:40,000
他可能肯定会出现

524
00:22:41,000 --> 00:22:48,000
比如说同样你的这个两个程序会依赖比如说同一个 openSSL 的这个包对吧然后他可能是依赖了不同的版本

525
00:22:48,000 --> 00:22:49,000
但是可能

526
00:22:49,000 --> 00:22:49,000
比如说他

527
00:22:49,000 --> 00:22:52,000
发现一个安全漏洞然后某个

528
00:22:52,000 --> 00:22:57,000
系统升级的时候就把它升了但是如果你用的是自己打包的包包的话那你可能

529
00:22:57,000 --> 00:23:00,000
你必须再重新发布一下你这个软件你这个

530
00:23:00,000 --> 00:23:02,000
才会有那个安全补丁打上去

531
00:23:02,000 --> 00:23:05,000
如果你把这个事情交给系统来做就是这个系统说

532
00:23:06,000 --> 00:23:11,000
哎我把这个整个你们需要用到的 openSSL 这个包的补丁都打了你们只要重启一下

533
00:23:11,000 --> 00:23:12,000
就重新

534
00:23:12,000 --> 00:23:14,000
这个 app 关掉重新启动一下

535
00:23:14,000 --> 00:23:16,000
就可以享受到这个带来的安全的好处

536
00:23:16,000 --> 00:23:19,000
而不是说要等每一个开发者重新去做一遍嘛

537
00:23:19,000 --> 00:23:20,000
就这里其实也是有一定的

538
00:23:21,000 --> 00:23:23,000
劳动力上面的节省

539
00:23:23,000 --> 00:23:26,000
对所以说其实这是一个取舍有一个取舍在里面有个

540
00:23:27,000 --> 00:23:28,000
TRADE OFF

541
00:23:28,000 --> 00:23:31,000
就是你要么选择

542
00:23:31,000 --> 00:23:35,000
同时发布更多的依赖

543
00:23:35,000 --> 00:23:39,000
来避免用户可能产生的包冲突的问题

544
00:23:40,000 --> 00:23:45,000
而另一方面你也可以选择尽量减少自己所发布的软件

545
00:23:46,000 --> 00:23:47,000
其内置的

546
00:23:47,000 --> 00:23:48,000
内部包括的依赖

547
00:23:48,000 --> 00:23:50,000
你来连来享受这种

548
00:23:51,000 --> 00:23:52,000
有一个

549
00:23:53,000 --> 00:23:54,000
有一个平台吧

550
00:23:54,000 --> 00:23:57,000
加固号平台在那边的

551
00:23:57,000 --> 00:23:59,000
便捷和

552
00:23:59,000 --> 00:24:00,000
和稳定性或者说安全性

553
00:24:02,000 --> 00:24:06,000
对这就可以看到就是跟他讲这两种不同的思路和这个做法

554
00:24:07,000 --> 00:24:12,000
就一般像那种像什么商用的就是消费者级别用的然后是为了

555
00:24:13,000 --> 00:24:17,000
简单方便然后互相不冲突的话会采用像刚才讲的把所有的

556
00:24:17,000 --> 00:24:18,000
东西都打包到自己里面去

557
00:24:19,000 --> 00:24:21,000
然后你就依赖于一个比较稳定的

558
00:24:22,000 --> 00:24:23,000
系统提供你的一些宝

559
00:24:24,000 --> 00:24:29,000
像麦克上面就这样子问的上面应该很多也是这样子的因为他要减少这个下载的体积吗跟你说这是一个原因之一

560
00:24:30,000 --> 00:24:30,000
但是

561
00:24:30,000 --> 00:24:33,000
像 Linux 啊这种发行板他很多就是说

562
00:24:33,000 --> 00:24:37,000
我们整个系统都是开源的对吧那我们肯定是希望能够把这种

563
00:24:37,000 --> 00:24:40,000
就是能够把各种合力都

564
00:24:40,000 --> 00:24:43,000
都就集中起来就不要大家都去自己搞一份

565
00:24:44,000 --> 00:24:48,000
对但实际上现在 Linux 社区面临一个问题是

566
00:24:49,000 --> 00:24:51,000
Linux 已经越来越不是一种

567
00:24:51,000 --> 00:24:56,000
人人为我为人的模型了就是有很多的

568
00:24:56,000 --> 00:25:01,000
企业级的用户在用 Linux 而从来他们基本上是不会去

569
00:25:02,000 --> 00:25:02,000
考虑

570
00:25:03,000 --> 00:25:05,000
或者是有这个利益

571
00:25:05,000 --> 00:25:09,000
驱使让他们能够把自己的某些修正反馈给上游的

572
00:25:09,000 --> 00:25:12,000
对他们来说 Linux 最重要的就是

573
00:25:13,000 --> 00:25:16,000
不要有冲突然后部署起来简单快捷好用

574
00:25:17,000 --> 00:25:18,000
就能够稳定

575
00:25:18,000 --> 00:25:18,000
可靠的

576
00:25:19,000 --> 00:25:21,000
运行就好了不要我才不跟你扯那些什么

577
00:25:21,000 --> 00:25:23,000
回不回馈到上游去是不是

578
00:25:23,000 --> 00:25:24,000
对没错

579
00:25:25,000 --> 00:25:28,000
其实这个行为是会被谴责的

580
00:25:28,000 --> 00:25:34,000
也不是吧因为毕竟你看很多 Linux 发行商 redhat 之流吧

581
00:25:35,000 --> 00:25:36,000
他们其实很大一部分工作

582
00:25:37,000 --> 00:25:39,000
或者很大一部分利润的来源就来自于对于

583
00:25:40,000 --> 00:25:41,000
企业级用户提供支持

584
00:25:42,000 --> 00:25:47,000
所以其实是有人来付钱让他们来做事让用户满意的

585
00:25:49,000 --> 00:25:51,000
对对就是还是根据你这个需求来嘛就说

586
00:25:52,000 --> 00:25:56,000
如果你需求是稳定可靠的话你可能要考虑一下采取刚才那种方式

587
00:25:56,000 --> 00:25:58,000
就是你宁可放弃别人

588
00:25:59,000 --> 00:26:01,000
帮你修复了这个

589
00:26:02,000 --> 00:26:02,000
bug

590
00:26:03,000 --> 00:26:04,000
带来的好处你也要

591
00:26:05,000 --> 00:26:10,000
说我不管那个风险太大了对吧你改改说不定我这个应用就 crush 了

592
00:26:11,000 --> 00:26:13,000
还是追求那个是第一目标嘛

593
00:26:14,000 --> 00:26:17,000
不过这里说到 Linux 我们可以这里

594
00:26:17,000 --> 00:26:18,000
就顺便提一下

595
00:26:19,000 --> 00:26:21,000
就是在大部分的这种

596
00:26:21,000 --> 00:26:25,000
比较大的 Linux 发行版的他都有自己的一个一套系统吧

597
00:26:25,000 --> 00:26:27,000
一套的这个什么包管理系统

598
00:26:28,000 --> 00:26:29,000
然后这里可能比较

599
00:26:30,000 --> 00:26:33,000
著名的两个一个是以 debian 为首的那个

600
00:26:34,000 --> 00:26:35,000
那个叫 db 那个

601
00:26:35,000 --> 00:26:36,000
那个

602
00:26:36,000 --> 00:26:42,000
体系然后一个是 redhat 为头的叫什么 rpm 对 RPM 最开始是 redhat package management

603
00:26:42,000 --> 00:26:45,000
缩写了但后来现在好像

604
00:26:46,000 --> 00:26:47,000
somehow

605
00:26:47,000 --> 00:26:48,000
缩写变了变成

606
00:26:48,000 --> 00:26:48,000
就叫

607
00:26:49,000 --> 00:26:50,000
RPM package

608
00:26:50,000 --> 00:26:51,000
package management

609
00:26:52,000 --> 00:26:52,000
system

610
00:26:52,000 --> 00:26:55,000
就是他变成了一个像 GNU 那样的

611
00:26:55,000 --> 00:26:57,000
叫什么 recursive

612
00:26:57,000 --> 00:26:58,000
recursive acronym

613
00:26:58,000 --> 00:26:59,000
对对对

614
00:27:00,000 --> 00:27:01,000
就不是很扯

615
00:27:03,000 --> 00:27:04,000
那么其实

616
00:27:05,000 --> 00:27:10,000
有一个问题啊我其实是没有怎么接触过这个 rpm 这套

617
00:27:10,000 --> 00:27:11,000
体系的我因为

618
00:27:11,000 --> 00:27:14,000
大部分都是在 debian 或者是 ubuntu 系统上面用

619
00:27:14,000 --> 00:27:16,000
所以我觉得用 debian 还挺顺手

620
00:27:16,000 --> 00:27:18,000
我不知道你有没有接触过

621
00:27:18,000 --> 00:27:23,000
在进入目前的公司之前也是从来没有接触过 rpm

622
00:27:23,000 --> 00:27:29,000
或者说接触过但非常有限但是我们公司目前在用 centOS

623
00:27:29,000 --> 00:27:29,000
所以

624
00:27:31,000 --> 00:27:35,000
在服务器的环境上面的确是在跑 rpm

625
00:27:35,000 --> 00:27:37,000
但我的所有的私人的

626
00:27:38,000 --> 00:27:42,000
包括 vps 或者是讯息全都是 debian 所以

627
00:27:42,000 --> 00:27:44,000
我也可以说算是一个

628
00:27:45,000 --> 00:27:48,000
debian 的阵营的人吧

629
00:27:48,000 --> 00:27:48,000
就

630
00:27:48,000 --> 00:27:52,000
其实挺可笑的 debian 和 rpm 都可以有 flame war

631
00:27:53,000 --> 00:27:56,000
这个还是很大的一个坑

632
00:27:57,000 --> 00:27:59,000
知乎上之前有一个

633
00:28:00,000 --> 00:28:01,000
也是就这个坑吧

634
00:28:01,000 --> 00:28:04,000
有写的就是两边都有

635
00:28:04,000 --> 00:28:07,000
有支持 debian 这一派的

636
00:28:07,000 --> 00:28:09,000
然后有支持 rpm 这一派的

637
00:28:09,000 --> 00:28:09,000
他们在那边炒

638
00:28:10,000 --> 00:28:11,000
但是这个炒

639
00:28:11,000 --> 00:28:13,000
这也不是

640
00:28:13,000 --> 00:28:14,000
中国首次了也是

641
00:28:15,000 --> 00:28:17,000
很多国外地方都已经炒过了

642
00:28:17,000 --> 00:28:18,000
然后中国的 Ninux 社区

643
00:28:18,000 --> 00:28:19,000
早就炒过无数遍了

644
00:28:20,000 --> 00:28:21,000
不过最近

645
00:28:21,000 --> 00:28:21,000
前一阵子吧

646
00:28:22,000 --> 00:28:23,000
在租屋上又在炒这个事

647
00:28:23,000 --> 00:28:26,000
但是因为我自己个人并没有什么太多的经验呢

648
00:28:27,000 --> 00:28:27,000
所以我觉得

649
00:28:28,000 --> 00:28:29,000
没什么特别感觉

650
00:28:29,000 --> 00:28:32,000
如果今天没有什么经验我们可以直接跳过这个话题

651
00:28:32,000 --> 00:28:35,000
对总体来说就是我的印象好像是

652
00:28:36,000 --> 00:28:40,000
做运维的一方好像会比较偏向于 rpm

653
00:28:40,000 --> 00:28:44,000
对然后做开发的一方会觉得 debian 比较好

654
00:28:44,000 --> 00:28:47,000
因为 rpm 比较强调于

655
00:28:48,000 --> 00:28:51,000
怎么说呢就是强调一个包一定要

656
00:28:52,000 --> 00:28:56,000
来自 upstream 然后一定要正统然后一定不能是 patch 过的

657
00:28:57,000 --> 00:28:59,000
然后

658
00:29:01,000 --> 00:29:04,000
就是企业级的部署用 rpm 相对来说无痛一点

659
00:29:04,000 --> 00:29:08,000
而 debian 包的优点则是它相对来说一般比较新

660
00:29:09,000 --> 00:29:12,000
然后它可以在包里面加上 patch

661
00:29:12,000 --> 00:29:13,000
然后

662
00:29:14,000 --> 00:29:17,000
其实我作为一个用户我看了这么久我的理解就是说

663
00:29:18,000 --> 00:29:23,000
因为作为开发者你可能会经常需要一些比较稍微新一点的工具对吧

664
00:29:23,000 --> 00:29:27,000
或者你需要用的一些比较方便安装的东西

665
00:29:27,000 --> 00:29:30,000
但是 debian 可以让你比较方便的安装

666
00:29:30,000 --> 00:29:34,000
也不叫最新吧或者叫新的版本然后能够比较方便的

667
00:29:34,000 --> 00:29:36,000
做一些修改然后再发布出去

668
00:29:36,000 --> 00:29:38,000
对那 rpm 的话你刚才讲就是

669
00:29:38,000 --> 00:29:40,000
首先它包的数量

670
00:29:40,000 --> 00:29:42,000
应该是比 debian 的包要少的多

671
00:29:42,000 --> 00:29:46,000
小心说话说不定就不能找到

672
00:29:46,000 --> 00:29:47,000
我应该

673
00:29:47,000 --> 00:29:51,000
但这点我是看到就是在草的两边对这个事情都没有异议的

674
00:29:52,000 --> 00:29:54,000
这个应该还是比较安全的一个说法

675
00:29:54,000 --> 00:29:59,000
然后就说但是它每一个就是它有的包的那个

676
00:30:01,000 --> 00:30:03,000
如果它有的包是有的话它是做的不错就是稳定可靠

677
00:30:04,000 --> 00:30:06,000
对而且反复经过很多次测试

678
00:30:07,000 --> 00:30:11,000
就我听过一个版本就说所谓 debian 的 stable

679
00:30:11,000 --> 00:30:16,000
就是 debian 的 stable 版本其中的测试其实也不是很多啊

680
00:30:16,000 --> 00:30:17,000
就真的

681
00:30:17,000 --> 00:30:22,000
算不得真的是 stable 里面还是比较不稳定的

682
00:30:22,000 --> 00:30:28,000
那个 debian 的测试其实也很简单它也不叫什么测试就是它先测一测然后放到那个什么

683
00:30:29,000 --> 00:30:31,000
unstable 吧还是哪里

684
00:30:31,000 --> 00:30:35,000
然后再到 testing 里面再看看有什么 bug 没有稳定的话

685
00:30:35,000 --> 00:30:38,000
就挪到那个 stable 里面去了吧应该是这么一个流程

686
00:30:39,000 --> 00:30:45,000
因为它本来就是一个并不是像 redhead 那种有这种企业能够去专门去做这种事情

687
00:30:45,000 --> 00:30:47,000
还是靠这个大家

688
00:30:47,000 --> 00:30:49,000
这个维护者虽然有很多很多

689
00:30:50,000 --> 00:30:52,000
去做每一个做法还是一个比较

690
00:30:52,000 --> 00:30:54,000
相对松散吧我觉得

691
00:30:54,000 --> 00:30:55,000
对

692
00:30:55,000 --> 00:30:59,000
对说到这个 debian 的发行版后面好像的确没有一个

693
00:31:00,000 --> 00:31:03,000
一个一个怎么说财团在支持

694
00:31:03,000 --> 00:31:06,000
对那就是 debian 是一个就靠社区嘛

695
00:31:06,000 --> 00:31:10,000
就不像那个 redhead 还有这个公司的商业支持

696
00:31:10,000 --> 00:31:12,000
但就这个问题是说

697
00:31:12,000 --> 00:31:15,000
到底商业支持能到什么程度

698
00:31:15,000 --> 00:31:17,000
或者是他支持的是不是刚好你需要的

699
00:31:18,000 --> 00:31:19,000
这就是另外一回事

700
00:31:19,000 --> 00:31:19,000
反正

701
00:31:20,000 --> 00:31:22,000
就是你只要你肯花钱问题总是可以解决的

702
00:31:22,000 --> 00:31:24,000
现在问题是说没钱了就怎么办

703
00:31:25,000 --> 00:31:25,000
对

704
00:31:26,000 --> 00:31:30,000
那就有这么两个问题

705
00:31:30,000 --> 00:31:33,000
还有一个叫 yam 是哪里面的

706
00:31:33,000 --> 00:31:35,000
yam 是就是

707
00:31:35,000 --> 00:31:39,000
这么说吧就是 apt 是 debian 的高层

708
00:31:39,000 --> 00:31:44,000
debian 包系统就是最底层的工具是 dpackage

709
00:31:44,000 --> 00:31:45,000
然后 rpm

710
00:31:46,000 --> 00:31:47,000
rpm 包的工具是 dpackage

711
00:31:48,000 --> 00:31:49,000
就是管理器就是 rpm

712
00:31:49,000 --> 00:31:53,000
但是 apt 是基于 dpackage 的一个比较高层管理工具

713
00:31:53,000 --> 00:31:56,000
他会去帮你做什么 dependency management 之类的

714
00:31:56,000 --> 00:32:02,000
而 yam 和 zipper 则是分别来自于 redhead 和

715
00:32:02,000 --> 00:32:06,000
suse 的两个基于 rpm 管理工具的高层工具

716
00:32:07,000 --> 00:32:08,000
OK

717
00:32:08,000 --> 00:32:15,000
对我这也是一个挺有趣的一个事情就是他们我们会把这个包管理分的层级分得很细

718
00:32:15,000 --> 00:32:17,000
就跟你说有些底层的工具去做一些

719
00:32:18,000 --> 00:32:18,000
最基础的事情

720
00:32:19,000 --> 00:32:21,000
然后上面高层工具去做一些

721
00:32:21,000 --> 00:32:22,000
把这个

722
00:32:22,000 --> 00:32:27,000
整个流程变得没有那么繁琐然后界面对用户友好那么一丁点的事情

723
00:32:28,000 --> 00:32:30,000
对我觉得这个友好的其实

724
00:32:30,000 --> 00:32:30,000
就是

725
00:32:31,000 --> 00:32:36,000
不是一丁点因为比如说 apt 这一套工具 apt 这套工具可以帮你

726
00:32:37,000 --> 00:32:41,000
自动去分析这个包需要依赖于哪些东西然后自动帮你

727
00:32:41,000 --> 00:32:43,000
给出一个

728
00:32:43,000 --> 00:32:46,000
就是解决依赖的方案

729
00:32:46,000 --> 00:32:47,000
诸如此类的

730
00:32:47,000 --> 00:32:54,000
如果你自己要一个一个用这个 dpkg 的工具去搞的话或者 rpm 自己去弄的话其实非常非常繁琐

731
00:32:54,000 --> 00:33:00,000
我记得我刚上大学的时候 Binon Linux 的当时的疑点之一就是

732
00:33:00,000 --> 00:33:03,000
安装程序真的一定要用 rpm 吗

733
00:33:03,000 --> 00:33:07,000
然后为什么就不能有一个什么东西

734
00:33:07,000 --> 00:33:09,000
给我然后我双击一下就安好了呢

735
00:33:10,000 --> 00:33:16,000
现在还是不能你还是得敲几个命令然后让他安装这个和那个

736
00:33:16,000 --> 00:33:17,000
你得知道那个命令是什么

737
00:33:18,000 --> 00:33:21,000
然后你得知道那个命令的参数怎么样

738
00:33:21,000 --> 00:33:22,000
如果一切正常

739
00:33:23,000 --> 00:33:26,000
在大部分情况下应该是一切正常他能够顺利的给你安装完没问题

740
00:33:26,000 --> 00:33:29,000
但如果他报错了然后你怎么办

741
00:33:29,000 --> 00:33:30,000
对

742
00:33:30,000 --> 00:33:31,000
但这个时候就是

743
00:33:31,000 --> 00:33:32,000
经验就要 kick in 了

744
00:33:32,000 --> 00:33:34,000
经验就要拍照

745
00:33:34,000 --> 00:33:40,000
对我有这样一个印象就是在早期 windows 在 windows 上面安装程序或者说在

746
00:33:40,000 --> 00:33:44,000
在 mac 上面安装程序要远远方便于

747
00:33:44,000 --> 00:33:45,000
在 Linux 上面

748
00:33:45,000 --> 00:33:47,000
但是从某一个时间点开始

749
00:33:48,000 --> 00:33:49,000
我

750
00:33:49,000 --> 00:33:52,000
somehow 得到的这种印象就是在

751
00:33:52,000 --> 00:33:56,000
Linux 上面得到我想要的工具反而要比 windows 上面简单了因为

752
00:33:56,000 --> 00:33:59,000
Linux 比如说 debian 吧

753
00:34:00,000 --> 00:34:05,000
我想要用什么东西然后比如说我在网上看别人说这个工具很好用

754
00:34:05,000 --> 00:34:09,000
然后我就直接 applicate 然后 search

755
00:34:09,000 --> 00:34:10,000
我要找的东西

756
00:34:10,000 --> 00:34:12,000
在那然后 applicate install 我有了

757
00:34:13,000 --> 00:34:14,000
可是在 windows 上你就要去

758
00:34:14,000 --> 00:34:17,000
先去一个网站下载一个东西然后双击那个文件然后

759
00:34:18,000 --> 00:34:18,000
一路 next

760
00:34:18,000 --> 00:34:21,000
然后最后才要去双击什么一个

761
00:34:22,000 --> 00:34:23,000
快捷方式之类的

762
00:34:23,000 --> 00:34:24,000
才可以运行我需要的东西

763
00:34:25,000 --> 00:34:28,000
就是在某一个时间点 Linux 社区

764
00:34:28,000 --> 00:34:31,000
或者是 Linux 文化创造出了这么一种

765
00:34:32,000 --> 00:34:33,000
自动化安装某一个

766
00:34:34,000 --> 00:34:35,000
傻瓜性

767
00:34:35,000 --> 00:34:37,000
傻瓜是一条龙安装软件的功能

768
00:34:39,000 --> 00:34:45,000
对或者你可以从某种角度这么讲就是我们现在包括 iOS 上面那个 app store 也好还是在 mac

769
00:34:45,000 --> 00:34:46,000
上面的 app store 也好

770
00:34:46,000 --> 00:34:47,000
还包括 windows 现在也好

771
00:34:48,000 --> 00:34:49,000
也在他们也有个 windows app store 里面

772
00:34:50,000 --> 00:34:51,000
其实他们做的事情就是

773
00:34:52,000 --> 00:34:57,000
把 linux 这种包管理器就各个发行板的包管理器的功能

774
00:34:57,000 --> 00:35:01,000
通过一种图形化的方式比较有好的呈现给普通消费者

775
00:35:01,000 --> 00:35:02,000
而不是说只是像我们这种

776
00:35:03,000 --> 00:35:04,000
维护什么后端的

777
00:35:04,000 --> 00:35:07,000
或者用 linux 的这种小众的 geek 用户

778
00:35:07,000 --> 00:35:10,000
对没错所以从这个意义上讲 Linux

779
00:35:10,000 --> 00:35:12,000
对于人类的最大贡献之一就是

780
00:35:13,000 --> 00:35:14,000
发明了

781
00:35:14,000 --> 00:35:16,000
app store 的

782
00:35:16,000 --> 00:35:17,000
某种

783
00:35:18,000 --> 00:35:18,000
gig 方式

784
00:35:19,000 --> 00:35:21,000
某种 hardcore 形式

785
00:35:22,000 --> 00:35:27,000
所以我们刚才现在在谈的这些各种发行板的

786
00:35:27,000 --> 00:35:31,000
就是包管理器的话其实我们就等同于是在讲

787
00:35:31,000 --> 00:35:33,000
某个发行板的 app store 一样

788
00:35:33,000 --> 00:35:37,000
然后对我觉得你刚才说那点很好就是之前最开始我接触 Linux

789
00:35:38,000 --> 00:35:39,000
确实是

790
00:35:39,000 --> 00:35:40,000
非常

791
00:35:40,000 --> 00:35:46,000
对普通用户不友好因为那个时候也不是特别熟悉然后就慢慢去摸索有些东西完全

792
00:35:46,000 --> 00:35:47,000
不懂嘛就是

793
00:35:47,000 --> 00:35:49,000
概念上都不一样的跟 windows 上面的

794
00:35:50,000 --> 00:35:55,000
那种那种逻辑啊那种你对这个世界的认知都是不一样的后来

795
00:35:55,000 --> 00:36:02,000
他慢慢改了我印象中大概是在就我拿一个 ubuntu 这个可能他有是有那个年份的时间比较

796
00:36:02,000 --> 00:36:03,000
清楚我觉得大概是在 ubuntu

797
00:36:04,000 --> 00:36:04,000
9

798
00:36:04,000 --> 00:36:07,000
10 大概之后就是 10 年左右

799
00:36:07,000 --> 00:36:08,000
开始

800
00:36:08,000 --> 00:36:12,000
在在起码跟我个人使用的经验来讲在 ubuntu 这种

801
00:36:13,000 --> 00:36:16,000
就是 debian 系统上安装程序是一个相当还蛮愉悦的体验

802
00:36:17,000 --> 00:36:22,000
就是越来越少遇到包管理器不能帮你解决的这种版本冲突的时候

803
00:36:22,000 --> 00:36:23,000
现在基本上很少遇到

804
00:36:24,000 --> 00:36:27,000
对其实可以感受到他的整个

805
00:36:27,000 --> 00:36:31,000
工具有一套慢慢磨合好的这样一个过程在里面

806
00:36:32,000 --> 00:36:32,000
对对

807
00:36:32,000 --> 00:36:33,000
不过

808
00:36:33,000 --> 00:36:39,000
不过但是这里还是有一个小小的代价就是刚才讲的说哎现在你什么去一个

809
00:36:39,000 --> 00:36:43,000
在 apt 里面搜一下然后找装个软件很方便

810
00:36:43,000 --> 00:36:45,000
但问题是说这个是有前提的

811
00:36:45,000 --> 00:36:47,000
前提就是首先这个软件得是在

812
00:36:47,000 --> 00:36:50,000
apt 那个那个仓库里面能找到的

813
00:36:50,000 --> 00:36:51,000
就是有人把它提交上去了

814
00:36:51,000 --> 00:36:54,000
要么是软件的作者也好要么是一个第三方的这个

815
00:36:55,000 --> 00:36:57,000
发行板的这个维护的人员把它加进去了

816
00:36:57,000 --> 00:37:00,000
但如果你要找一个不是在那里面的

817
00:37:00,000 --> 00:37:01,000
程序的话

818
00:37:01,000 --> 00:37:03,000
就这个过程还是蛮辛苦的

819
00:37:03,000 --> 00:37:04,000
对这个就

820
00:37:04,000 --> 00:37:07,000
比较算有一个

821
00:37:07,000 --> 00:37:09,000
叫什么积攒动量的过程吧

822
00:37:09,000 --> 00:37:10,000
就是

823
00:37:10,000 --> 00:37:11,000
当你这个软件

824
00:37:12,000 --> 00:37:17,000
包管理系统大到一个一定程度那么你可以理解为任何一个不会在这个

825
00:37:18,000 --> 00:37:19,000
apt source

826
00:37:19,000 --> 00:37:21,000
apt 的原

827
00:37:22,000 --> 00:37:26,000
仓库之中出现的软件都不是什么太大或者值得你去信赖的软件

828
00:37:27,000 --> 00:37:33,000
你说这个要小心因为有些很小众的软件他可能只是因为

829
00:37:33,000 --> 00:37:37,000
作者也没怎么去维护他嘛你可能比较简单或者怎么样也好

830
00:37:37,000 --> 00:37:39,000
对或者比较偏转一点

831
00:37:39,000 --> 00:37:41,000
如果这个软件

832
00:37:41,000 --> 00:37:47,000
简单到不需要 apt 来安装的话那你很可能安装它的过程也不会比

833
00:37:47,000 --> 00:37:50,000
使用 apt 安装其他软件复杂多少

834
00:37:52,000 --> 00:37:55,000
对这是一个这个是一个不错的这个 argument

835
00:37:55,000 --> 00:37:59,000
但是有些是也有软件挺复杂这个我印象还蛮深的

836
00:37:59,000 --> 00:38:04,000
就是我不知道你有段时间我在经常折腾一些视频的东西吗然后你知道在

837
00:38:05,000 --> 00:38:12,000
Linux 处理视频到目前为止还不是一个比较好的体验所以他在这一块还是比较弱的

838
00:38:12,000 --> 00:38:13,000
那比如说最简单一个例子你要

839
00:38:14,000 --> 00:38:17,000
重新封装像 mp 4 啊这些视频的一些个

840
00:38:18,000 --> 00:38:19,000
他会用的一些软件包

841
00:38:20,000 --> 00:38:25,000
然后这些软件包呢因为一个是因为版权的原因他不能够直接提供这个二二进制的发行版

842
00:38:26,000 --> 00:38:30,000
另外一个就是他的有些可能用到的这种代码

843
00:38:30,000 --> 00:38:34,000
可能跟某一个发新版的这个授权协议有点不兼容

844
00:38:34,000 --> 00:38:37,000
就他就处于这种比较尴尬的状态

845
00:38:37,000 --> 00:38:43,000
就是爹娘都不爱你就发行版的维护者没法把它装没法把它够加进去因为有这个这个

846
00:38:43,000 --> 00:38:44,000
软件协议的问题

847
00:38:45,000 --> 00:38:47,000
他自己就没有没有没有办法提供二进制的版本

848
00:38:48,000 --> 00:38:50,000
你得自己去下载原码来包因为有那个法律的问题

849
00:38:51,000 --> 00:38:56,000
就遇到这种情况你就很很沮丧你作为一个用户的话你只能想办法说啊好吧那我

850
00:38:56,000 --> 00:38:57,000
做梦说怎么去

851
00:38:58,000 --> 00:38:58,000
把那个

852
00:38:58,000 --> 00:39:01,000
他的 source 抓回来

853
00:39:01,000 --> 00:39:03,000
然后根据他的手册一个去一个去安装

854
00:39:04,000 --> 00:39:06,000
这里就就是提到这么一个概念就说

855
00:39:06,000 --> 00:39:07,000
从

856
00:39:08,000 --> 00:39:10,000
安装别人给你包好的软件包

857
00:39:10,000 --> 00:39:11,000
好

858
00:39:11,000 --> 00:39:15,000
和是从这个直接那个软件的原始出处去下载他的原

859
00:39:15,000 --> 00:39:17,000
文件回来从自己自行编译啊

860
00:39:18,000 --> 00:39:20,000
这是两种比较大的区别吧

861
00:39:20,000 --> 00:39:23,000
对这是这可能也是当初从

862
00:39:23,000 --> 00:39:27,000
windows 切换到 Linux 上面的一个很大的迷思就是

863
00:39:27,000 --> 00:39:29,000
当时我的理解是在

864
00:39:29,000 --> 00:39:33,000
Linux 上面你要安装一个程序的唯一方法就是

865
00:39:33,000 --> 00:39:37,000
先找到这个程序的原代码然后自己在 windows 上面编译它

866
00:39:37,000 --> 00:39:41,000
但是我但是我一方面觉得这个方向法实在是太酷了然后

867
00:39:42,000 --> 00:39:44,000
另一方面我觉得这不是有一点

868
00:39:44,000 --> 00:39:46,000
就是为什么呢

869
00:39:46,000 --> 00:39:47,000
为什么呢为什么呢

870
00:39:48,000 --> 00:39:50,000
为什么你不能给我一个已经编译好的二线程序让我来运行呢

871
00:39:52,000 --> 00:39:55,000
这里其实又有涉及到另外一个问题就是有些

872
00:39:55,000 --> 00:40:00,000
人会觉得我要有原代码然后因为你知道很多软件的编译的时候就会有各种各样的选项嘛

873
00:40:00,000 --> 00:40:01,000
有人会觉得说

874
00:40:02,000 --> 00:40:07,000
我装这个软件我只需要编译我需要的那部分功能然后我不需要那部分功能

875
00:40:08,000 --> 00:40:09,000
我就不编译

876
00:40:09,000 --> 00:40:10,000
这样我的

877
00:40:10,000 --> 00:40:11,000
代码会

878
00:40:11,000 --> 00:40:13,000
出来结果会小然后可能运行的会快一点

879
00:40:14,000 --> 00:40:15,000
或者说更从一个务实的角度来说

880
00:40:16,000 --> 00:40:17,000
如果我这个软件包里面没有

881
00:40:18,000 --> 00:40:18,000
那些我不需要的

882
00:40:19,000 --> 00:40:19,000
拥有的代码

883
00:40:20,000 --> 00:40:24,000
那么是不是我可以在某种程度上减小我的安全的这个叫做暴露的

884
00:40:24,000 --> 00:40:25,000
被攻击的面

885
00:40:25,000 --> 00:40:26,000
对吧

886
00:40:27,000 --> 00:40:30,000
这也是一种想法然后另外一种想法就是说

887
00:40:30,000 --> 00:40:37,000
如果每一个软件你都要根据你自己的方法去定义一遍这个安装的就编译的选项那么会导致

888
00:40:37,000 --> 00:40:40,000
同一个软件的所有的安装的那个选项

889
00:40:41,000 --> 00:40:43,000
安装的最终结果都是有一点点不一样的

890
00:40:43,000 --> 00:40:45,000
这样的话会导致支持起来

891
00:40:46,000 --> 00:40:47,000
就是软件做的

892
00:40:47,000 --> 00:40:49,000
你已经一定的支持或者是

893
00:40:49,000 --> 00:40:50,000
你要除错

894
00:40:50,000 --> 00:40:54,000
起来就非常困难因为别人很可能没办法在他那个

895
00:40:54,000 --> 00:40:55,000
编译的

896
00:40:55,000 --> 00:40:59,000
结果上重现你的问题吗对看到 tree produce one face

897
00:40:59,000 --> 00:41:02,000
这是所有的软件维护者最喜欢选的一个选项

898
00:41:03,000 --> 00:41:09,000
对对所以这里其实其实也看就是在自由灵活和这个谱就是你要什么

899
00:41:09,000 --> 00:41:13,000
你要定制化和你要用这种大众产品

900
00:41:14,000 --> 00:41:17,000
的之间也是有一个取舍的这个取舍就是说

901
00:41:17,000 --> 00:41:22,000
定制化当然好说刚才也讲了比如说有可能更安全可能性能更好

902
00:41:23,000 --> 00:41:24,000
可能更灵活对吧

903
00:41:25,000 --> 00:41:27,000
但是你要牺牲的就是这个可维护性吗

904
00:41:28,000 --> 00:41:34,000
另外一个讲的就是大众产品说那我大家都一个版本有问题的话我们都在这个一个版本里面修

905
00:41:34,000 --> 00:41:36,000
一个编译方式出来修修好大家都能够受益对吧

906
00:41:37,000 --> 00:41:39,000
所以这是一个也是两种不同的思路吧

907
00:41:40,000 --> 00:41:41,000
但是

908
00:41:41,000 --> 00:41:44,000
其实并不是所有的包裹管理器都是

909
00:41:45,000 --> 00:41:47,000
从这个二进制的

910
00:41:47,000 --> 00:41:49,000
大部分都不是二进制的方式吧

911
00:41:49,000 --> 00:41:52,000
现在很难说了一半一半吧

912
00:41:53,000 --> 00:41:55,000
但至少在 BSD 上面

913
00:41:55,000 --> 00:41:56,000
BSD ports

914
00:41:57,000 --> 00:42:00,000
基本上还全都是以获得原码的方式

915
00:42:01,000 --> 00:42:02,000
现编译的方式来

916
00:42:03,000 --> 00:42:05,000
安装软件

917
00:42:05,000 --> 00:42:08,000
对这点我觉得其实当时我

918
00:42:08,000 --> 00:42:11,000
接触的时候觉得还是蛮特别的哈就是因为

919
00:42:11,000 --> 00:42:16,000
首先一个就是 BSD 的那个就这个以那个 freeBSD 这个例子来说我以前用过

920
00:42:16,000 --> 00:42:19,000
就他那个叫做 port system

921
00:42:19,000 --> 00:42:20,000
就比较他

922
00:42:21,000 --> 00:42:24,000
做的比较好因为首先这个 freeBSD 这个系统整个维护的比较好

923
00:42:24,000 --> 00:42:25,000
因为他是一个

924
00:42:25,000 --> 00:42:27,000
他不像 Linux 这种是一个

925
00:42:27,000 --> 00:42:30,000
以内核和这个 user space

926
00:42:30,000 --> 00:42:32,000
user land 是分开

927
00:42:33,000 --> 00:42:36,000
的对他是两波人嘛在维护然后这个

928
00:42:36,000 --> 00:42:42,000
发行版是说要把这两个包在一起然后给你一个定制的产品但就会导致很多各种各样极其怪怪的发行版

929
00:42:43,000 --> 00:42:45,000
也会导致各种各样的什么包裹管理的问题

930
00:42:45,000 --> 00:42:46,000
但 freeBSD

931
00:42:47,000 --> 00:42:50,000
这个起码他是有一套人马在维护的然后

932
00:42:50,000 --> 00:42:51,000
他可以确保说

933
00:42:52,000 --> 00:42:53,000
他给你这套这个 port

934
00:42:53,000 --> 00:42:57,000
这个 port file 你是一定可以在你那天的机器上编译成功然后装上的

935
00:42:58,000 --> 00:43:03,000
对其实 Linux 的生态有一点像就是有一个人

936
00:43:03,000 --> 00:43:06,000
或者一个人马为了做出这么一个 kernel 来然后

937
00:43:07,000 --> 00:43:10,000
围绕这个 kernel 有一群人在上面插各种各样的插件

938
00:43:11,000 --> 00:43:14,000
然后会造成其实我倒觉得 Linux

939
00:43:15,000 --> 00:43:16,000
在这方面

940
00:43:16,000 --> 00:43:21,000
他的所谓 kernel space 和 user space 的分野是比较模糊的

941
00:43:23,000 --> 00:43:26,000
Linux 真正意义上的 kernel 其实只有那么一点点

942
00:43:27,000 --> 00:43:30,000
而后面外面很大一个外围都是 user land

943
00:43:30,000 --> 00:43:31,000
可以这么理解

944
00:43:31,000 --> 00:43:39,000
而在 BSD 这边则你可以说每一个 BSD 发行版都有一个明确的 kernel space 和一个明确的 user land

945
00:43:42,000 --> 00:43:44,000
而且他们都是同一帮人为

946
00:43:44,000 --> 00:43:46,000
而且版本号

947
00:43:46,000 --> 00:43:51,000
好像是比较一致的不像你在一个 Linux 下面可能有一个

948
00:43:52,000 --> 00:43:56,000
软件的版本特别新而另外其他部分则基本上是

949
00:43:57,000 --> 00:44:03,000
可能要倒退那么两三年的水平而在 BSD 上面你会基本上

950
00:44:03,000 --> 00:44:05,000
在每一个发行版里面拿到

951
00:44:05,000 --> 00:44:08,000
比较年份相近的一批工具

952
00:44:09,000 --> 00:44:12,000
对当然我也很久没有用过 BSD 了

953
00:44:12,000 --> 00:44:15,000
现在我们看从那个

954
00:44:15,000 --> 00:44:16,000
实际使用的

955
00:44:17,000 --> 00:44:21,000
情况来看也是就是 BSD 的市场份额应该是比较小了已经

956
00:44:21,000 --> 00:44:24,000
因为有一个我又一个比较明显的例子就是

957
00:44:24,000 --> 00:44:28,000
上一节目我们提到一个叫做 varnish 的那个反向代理缓存

958
00:44:28,000 --> 00:44:29,000
软件

959
00:44:30,000 --> 00:44:36,000
他那个本来最开始说是在 freeBSD 上写的那个开发者也是 freeBSD 的这个内核开发者之一嘛

960
00:44:36,000 --> 00:44:39,000
然后来发现他们在做商业化的时候

961
00:44:39,000 --> 00:44:42,000
其实大部分人都是在 Linux 上面跑他们的系统的

962
00:44:42,000 --> 00:44:46,000
他们现在连做新的那些扩展的功能都是先考虑

963
00:44:46,000 --> 00:44:46,000
或者是

964
00:44:47,000 --> 00:44:48,000
只考虑 Linux 版本了

965
00:44:49,000 --> 00:44:50,000
然后 freeBSD 那边都已经不这么管

966
00:44:51,000 --> 00:44:51,000
对

967
00:44:51,000 --> 00:44:54,000
这也是一个多少有点可惜的现状吧

968
00:44:55,000 --> 00:44:56,000
对

969
00:44:56,000 --> 00:45:02,000
因为其实如果 freeBSD 流行像 Linux 那边流行的话那我们如果这 Mac 用会就比较爽

970
00:45:02,000 --> 00:45:08,000
这都是 BSD 的内核它切换起来就是包括一些那种系统调用啊

971
00:45:08,000 --> 00:45:14,000
还有这种软件的包啊还有这种这种包括很多这种规范行为方式都是比较接近的嘛

972
00:45:14,000 --> 00:45:15,000
爽一点

973
00:45:15,000 --> 00:45:16,000
但其实现在就

974
00:45:16,000 --> 00:45:19,000
比较糟糕了比如说我们现在跑服务器上面大部分都是 Linux

975
00:45:20,000 --> 00:45:20,000
但是

976
00:45:21,000 --> 00:45:25,000
Mac 上面又是另外就是 BSD 的内核嘛这样的话

977
00:45:26,000 --> 00:45:27,000
就经常会不 match

978
00:45:27,000 --> 00:45:29,000
搞一下这个还是挺

979
00:45:29,000 --> 00:45:30,000
挺折腾的

980
00:45:31,000 --> 00:45:32,000
我觉得

981
00:45:32,000 --> 00:45:34,000
不管怎么说 Mac 作为一套

982
00:45:35,000 --> 00:45:39,000
或者是 Darwin 这个东西作为一套 free 作为一套 BSD 系统

983
00:45:39,000 --> 00:45:44,000
还是可以从开源界受益的

984
00:45:44,000 --> 00:45:46,000
这点已经是很不错了

985
00:45:46,000 --> 00:45:50,000
就无论至少我们有至少我们有

986
00:45:50,000 --> 00:45:56,000
第三方工具可以用就至少我们有 Linux 上面很多很多工具可以通过 homebrew 或者是 Macports

987
00:45:57,000 --> 00:46:00,000
来直接拿来用这已经是很好的一点了

988
00:46:01,000 --> 00:46:04,000
反观 Linux 用户可能就没有那么幸运

989
00:46:05,000 --> 00:46:11,000
这里就说到了在 OS X 上面的就除了那个官方苹果那个 app store 之外

990
00:46:12,000 --> 00:46:15,000
我们还其实有很古老的最早的叫什么 Fink

991
00:46:15,000 --> 00:46:17,000
Fink 这么一个包管理器

992
00:46:17,000 --> 00:46:19,000
Fink

993
00:46:19,000 --> 00:46:20,000
这个其实我自己是没有用过

994
00:46:21,000 --> 00:46:22,000
我也没有用过我只是

995
00:46:22,000 --> 00:46:23,000
听说过

996
00:46:23,000 --> 00:46:26,000
在用 Macports 的时候听说过说已经

997
00:46:28,000 --> 00:46:29,000
deprecated

998
00:46:30,000 --> 00:46:31,000
Forket about Fink

999
00:46:31,000 --> 00:46:31,000
Use Macports

1000
00:46:32,000 --> 00:46:32,000
ok

1001
00:46:32,000 --> 00:46:39,000
所以我接触到在 Mac 上面用的这种类似 Linux 包管理器其实就是从 Macports

1002
00:46:39,000 --> 00:46:40,000
开始的

1003
00:46:40,000 --> 00:46:42,000
然后 Macports 又是

1004
00:46:42,000 --> 00:46:45,000
因为你看名字也看得出来它是那种 Port 系统

1005
00:46:45,000 --> 00:46:48,000
跟 BSD 的 Port 是有一点点相似之处的

1006
00:46:48,000 --> 00:46:51,000
很大程度上是同一套系统

1007
00:46:51,000 --> 00:46:52,000
只不过 BSD port

1008
00:46:52,000 --> 00:46:53,000
如果我

1009
00:46:53,000 --> 00:46:57,000
当然我的 BSD 可能我已经有三五年没碰过 BSD 了

1010
00:46:57,000 --> 00:46:58,000
但是我的 BSD

1011
00:46:59,000 --> 00:47:02,000
知识没有欺骗我的话 BSD 上面的 Port

1012
00:47:02,000 --> 00:47:03,000
其实就是一个 Make 法

1013
00:47:03,000 --> 00:47:07,000
就是你要进到那个 Port 的

1014
00:47:07,000 --> 00:47:10,000
子墨录下面然后手动运行 make

1015
00:47:10,000 --> 00:47:11,000
make install 之类的

1016
00:47:12,000 --> 00:47:13,000
然后 Macports

1017
00:47:14,000 --> 00:47:15,000
跟这套系统唯一差别的

1018
00:47:16,000 --> 00:47:17,000
就是 Macports 会自动帮你运行 make

1019
00:47:18,000 --> 00:47:19,000
make 这个过程

1020
00:47:19,000 --> 00:47:20,000
仅此而已

1021
00:47:21,000 --> 00:47:21,000
对对

1022
00:47:22,000 --> 00:47:28,000
你整个你下回来的还是软件的原始代码然后你要去通过这个手工编译但这编译之前你还要

1023
00:47:28,000 --> 00:47:29,000
先装一些

1024
00:47:29,000 --> 00:47:31,000
什么编译器啊那些是另外的基础需求

1025
00:47:31,000 --> 00:47:32,000
这些都是

1026
00:47:32,000 --> 00:47:36,000
然后然后 Macports 唯一的

1027
00:47:37,000 --> 00:47:42,000
特点就是它是用 TCL 把整套编译和安装的过程帮你自动化了

1028
00:47:42,000 --> 00:47:45,000
然后当时还有一个优点就是当时有一

1029
00:47:45,000 --> 00:47:48,000
一些那个苹果员工在

1030
00:47:48,000 --> 00:47:49,000
直接的

1031
00:47:49,000 --> 00:47:50,000
贡献这个

1032
00:47:50,000 --> 00:47:52,000
这个系统所以他们有很大的优势

1033
00:47:52,000 --> 00:47:55,000
他们知道自己在干什么而且他们可以做的比较

1034
00:47:55,000 --> 00:47:57,000
比较 Apple like

1035
00:47:59,000 --> 00:47:59,000
对

1036
00:47:59,000 --> 00:48:07,000
其实就在相当长一段时间里面那个 OS X 的用户就做软件开发者的话或多或少的也会接触到这个 Macports

1037
00:48:08,000 --> 00:48:10,000
这个系统要么你自己写一点要么你装别人的东西

1038
00:48:10,000 --> 00:48:14,000
不过在我有限的记忆里面 Macports 的使用体验

1039
00:48:15,000 --> 00:48:17,000
并不是特别好因为经常会

1040
00:48:17,000 --> 00:48:23,000
有这种各种各样的问题导致安装不成功编译失败然后这个时候就会进入一个

1041
00:48:23,000 --> 00:48:28,000
比较混乱的状态你要去找那个你要去看那个他的那个 port file 然后去看

1042
00:48:28,000 --> 00:48:32,000
安装到哪一步了哪一步失败了要清理哪些垃圾文件怎么怎么的

1043
00:48:32,000 --> 00:48:35,000
对他的用户界面不是那么的友好

1044
00:48:37,000 --> 00:48:41,000
所以后来就有一个叫做这个 Homebrew

1045
00:48:41,000 --> 00:48:42,000
我们通常简称他叫 brew

1046
00:48:43,000 --> 00:48:44,000
横空出世啊

1047
00:48:44,000 --> 00:48:44,000
对啊

1048
00:48:45,000 --> 00:48:46,000
然后一刀

1049
00:48:47,000 --> 00:48:50,000
解决了这个问题然后现在基本上 Macports 也是被淘汰掉了

1050
00:48:50,000 --> 00:48:57,000
还是有一对怎么说呢就是 Macports 还是一批死忠的拥吨在那边用

1051
00:48:57,000 --> 00:49:00,000
然后他们会觉得 Homebrew 就有点像

1052
00:49:00,000 --> 00:49:04,000
就像所有沾染了 Ruby 的东西一样都是一群

1053
00:49:04,000 --> 00:49:10,000
喝了 coolkits 的这个这个这个小屁孩们在那边闹说这个比较好

1054
00:49:12,000 --> 00:49:14,000
所以这里提到了就是

1055
00:49:15,000 --> 00:49:18,000
就刚才讲那个 Macports 的那个 port file 是用 TCL 脚本来写的

1056
00:49:19,000 --> 00:49:22,000
Homebrew

1057
00:49:22,000 --> 00:49:23,000
是吗

1058
00:49:23,000 --> 00:49:26,000
应该是应该是没错的

1059
00:49:26,000 --> 00:49:28,000
Macport port file 是 TCL 写的

1060
00:49:29,000 --> 00:49:37,000
然后这个 Homebrew 的这个安装的他们叫一个 formula 对吧是一个 Ruby 的 class 文件其实是

1061
00:49:39,000 --> 00:49:43,000
因为其实我个人对 Ruby 没什么特别感觉我不知道你觉得怎么样

1062
00:49:44,000 --> 00:49:44,000
啊

1063
00:49:45,000 --> 00:49:51,000
具体的 Homebrew 的 formula 上面它其实你可以把它理解当成一门 DSL 来学习嘛

1064
00:49:51,000 --> 00:49:59,000
所以你可以完全不懂那个 Ruby 里面那个那个什么两个竖线中间加一个

1065
00:50:00,000 --> 00:50:04,000
变量名到底是什么意思你也可以去操作 Homebrew 的 formula

1066
00:50:04,000 --> 00:50:06,000
已经一壶话瓢嘛

1067
00:50:06,000 --> 00:50:07,000
所以他其实是

1068
00:50:07,000 --> 00:50:09,000
把它做的相当

1069
00:50:09,000 --> 00:50:12,000
傻瓜化的这么一个 formula

1070
00:50:12,000 --> 00:50:14,000
我刚刚写

1071
00:50:14,000 --> 00:50:17,000
我记得你还在推特上问过我说你难道没有

1072
00:50:18,000 --> 00:50:19,000
那个写过自己的 formula 吗

1073
00:50:19,000 --> 00:50:23,000
我当时很老实而且很骄傲的说没有

1074
00:50:23,000 --> 00:50:26,000
我都还写过一两

1075
00:50:27,000 --> 00:50:34,000
但后来我也写了但我觉得就是即便像我这样对 Ruby 其实没有什么太深了解的人也是可以

1076
00:50:36,000 --> 00:50:40,000
驾轻就熟的去去去操作一个 formula

1077
00:50:40,000 --> 00:50:41,000
所以不是

1078
00:50:41,000 --> 00:50:42,000
不是没有什么太大问题

1079
00:50:42,000 --> 00:50:44,000
对

1080
00:50:44,000 --> 00:50:50,000
不过说回来这个 Homebrew 本身哈就是我觉得他就现在他 Homebrew 已经现在就是这个 OS 的

1081
00:50:51,000 --> 00:50:51,000
这种

1082
00:50:51,000 --> 00:50:53,000
继承事实的

1083
00:50:54,000 --> 00:50:56,000
打引号的官方

1084
00:50:56,000 --> 00:50:57,000
这个

1085
00:50:57,000 --> 00:50:59,000
包管理器了吧

1086
00:51:00,000 --> 00:51:04,000
你如果你现在去关注一下 Github 上面的那些各种软件

1087
00:51:04,000 --> 00:51:06,000
你发现他只要涉及到

1088
00:51:06,000 --> 00:51:09,000
跟 OS 有关的大部分会选用 Homebrew 的方式

1089
00:51:10,000 --> 00:51:12,000
而且尤其是新工具会倾向于

1090
00:51:12,000 --> 00:51:14,000
提供一个 Homebrew formula

1091
00:51:14,000 --> 00:51:16,000
比如我们上次提到那个 neo v

1092
00:51:17,000 --> 00:51:17,000
就提供一个

1093
00:51:18,000 --> 00:51:19,000
Homebrew 的 type

1094
00:51:21,000 --> 00:51:23,000
所以这里就有一个延伸的问题就是

1095
00:51:24,000 --> 00:51:28,000
你觉得为什么 Homebrew 会在如此短的时间内完全

1096
00:51:28,000 --> 00:51:30,000
就替代掉了 Mac ports

1097
00:51:33,000 --> 00:51:36,000
这个和当年那个 Mac ports 取代 Think

1098
00:51:36,000 --> 00:51:38,000
就蛮大区别当时我记得印象中

1099
00:51:38,000 --> 00:51:41,000
Mac ports 和 Think 还是共存过相当长一段时间的

1100
00:51:42,000 --> 00:51:43,000
我觉得第一是

1101
00:51:43,000 --> 00:51:44,000
他把

1102
00:51:45,000 --> 00:51:48,000
提供一个新软件的门槛降低了

1103
00:51:49,000 --> 00:51:52,000
因为 Ruby 的强项就是写一个 DSL 码

1104
00:51:52,000 --> 00:51:54,000
然后他用的这种 DSL 使得你

1105
00:51:56,000 --> 00:52:02,000
发布一个新的软件到 Homebrew repository 的过程变得

1106
00:52:02,000 --> 00:52:04,000
荒唐的简单

1107
00:52:04,000 --> 00:52:07,000
而 Mac ports

1108
00:52:07,000 --> 00:52:11,000
他因为用 TCL,TCL 毕竟是一个从来没有大动作的

1109
00:52:12,000 --> 00:52:15,000
然后你写它还是需要花一点脑筋的

1110
00:52:15,000 --> 00:52:18,000
你要去明白它是一个什么样的原理

1111
00:52:19,000 --> 00:52:22,000
然后我觉得还有一个可能会成为一个

1112
00:52:23,000 --> 00:52:26,000
决定性因素的是 Homebrew 给你一种虚假的安全感

1113
00:52:26,000 --> 00:52:27,000
就是

1114
00:52:27,000 --> 00:52:30,000
你每次 Brew 安装什么东西你不需要速度

1115
00:52:31,000 --> 00:52:35,000
前提是你安装的时候用的速度

1116
00:52:35,000 --> 00:52:40,000
你要把那个 user local 设定为你自己账户可读写

1117
00:52:40,000 --> 00:52:40,000
对啊

1118
00:52:40,000 --> 00:52:41,000
但是一般

1119
00:52:42,000 --> 00:52:42,000
来说

1120
00:52:42,000 --> 00:52:47,000
一般来说每一个就是如果你默认一台新电脑默认

1121
00:52:47,000 --> 00:52:49,000
直接用它的安装脚本去安装 Homebrew 的话

1122
00:52:50,000 --> 00:52:50,000
它就自动会帮你这样做

1123
00:52:51,000 --> 00:52:52,000
现在已经是这样了吗

1124
00:52:52,000 --> 00:52:55,000
应该是这样的吧我反正安装这台新的

1125
00:52:57,000 --> 00:53:00,000
新的 MacBook 的时候好像是

1126
00:53:00,000 --> 00:53:01,000
完全没有自己去改

1127
00:53:02,000 --> 00:53:03,000
他会推

1128
00:53:03,000 --> 00:53:05,000
他会推荐你这么干我记得确实是这样

1129
00:53:05,000 --> 00:53:07,000
我不太确定是不是他会默认吧

1130
00:53:07,000 --> 00:53:11,000
他可能会在安装过程中询问你要不要这样干

1131
00:53:11,000 --> 00:53:14,000
然后你应该我也是草率的打了一个歪

1132
00:53:17,000 --> 00:53:18,000
其实有一点我一直在想

1133
00:53:19,000 --> 00:53:20,000
就是 Github

1134
00:53:20,000 --> 00:53:24,000
对这个 Homebrew 的帮助有多大其实我觉得这个应该是挺关键的

1135
00:53:24,000 --> 00:53:25,000
应该说是相当大

1136
00:53:26,000 --> 00:53:26,000
因为

1137
00:53:26,000 --> 00:53:33,000
就是你刚才说他是一个 de facto 既成事实的软件包安装工具

1138
00:53:33,000 --> 00:53:37,000
我就想说他其实仅仅是对程序员这样而言而已

1139
00:53:37,000 --> 00:53:40,000
但正是因为此

1140
00:53:41,000 --> 00:53:47,000
几乎每一个稍微有点自尊的程序员肯定都会去搞搞 Github 然后 Homebrew 就是在 Github

1141
00:53:47,000 --> 00:53:48,000
对

1142
00:53:48,000 --> 00:53:54,000
这点我觉得就是跟那个像 MacBook 是很不一样 MacBook 那些我都不知道那那 port file 文件从哪里来的

1143
00:53:54,000 --> 00:53:58,000
然后怎么去提交然后整个看了一下那个网站也做得很丑对吧

1144
00:53:58,000 --> 00:54:04,000
但是 Homebrew 不一样他所有的这个那个所谓的他们叫 formula 就是我们类似于 make file 或者 port file

1145
00:54:05,000 --> 00:54:06,000
这么一个东西

1146
00:54:06,000 --> 00:54:07,000
他都是整个

1147
00:54:08,000 --> 00:54:10,000
包是放在这个 Github 上面的

1148
00:54:10,000 --> 00:54:11,000
然后

1149
00:54:11,000 --> 00:54:12,000
给他们是比较

1150
00:54:13,000 --> 00:54:16,000
友好的一个工具嘛对程序员来说至少

1151
00:54:16,000 --> 00:54:17,000
然后都会大家觉得

1152
00:54:17,000 --> 00:54:18,000
那我

1153
00:54:18,000 --> 00:54:22,000
给你添加我就是 fork 一下你这个嘛然后把这个加进去然后再给你

1154
00:54:23,000 --> 00:54:24,000
发一个这个 pool request

1155
00:54:24,000 --> 00:54:26,000
这个东西就算搞定了对吧

1156
00:54:26,000 --> 00:54:29,000
整个流程是非常方便的所以这里其实

1157
00:54:30,000 --> 00:54:31,000
就说

1158
00:54:31,000 --> 00:54:37,000
我们要说要做 UI 做得好但一个 UI 是广义上的不只是说用户最终消费者我们看到一个按钮

1159
00:54:37,000 --> 00:54:39,000
这个就应该叫做 UX

1160
00:54:39,000 --> 00:54:40,000
User experience

1161
00:54:41,000 --> 00:54:42,000
用户体验非常好

1162
00:54:43,000 --> 00:54:45,000
这个叫这个用户就是我们那种

1163
00:54:45,000 --> 00:54:47,000
GEEK 的宅程序员

1164
00:54:47,000 --> 00:54:53,000
对我们的友好的话我们也更加乐意去给他什么添砖加瓦你刚才说这点很好

1165
00:54:53,000 --> 00:54:54,000
就是

1166
00:54:54,000 --> 00:54:56,000
当你打开

1167
00:54:57,000 --> 00:55:00,000
Homebrew 的页面的时候他会用

1168
00:55:00,000 --> 00:55:04,000
一上来就告诉你一上来给你讲一个展示给你这个工具能干嘛

1169
00:55:04,000 --> 00:55:05,000
给你讲一个例子

1170
00:55:05,000 --> 00:55:06,000
给你讲一个故事

1171
00:55:07,000 --> 00:55:10,000
然后用大字用一读的

1172
00:55:11,000 --> 00:55:14,000
简单的文字告诉你这个工具是干嘛的这工具

1173
00:55:15,000 --> 00:55:18,000
怎样安装怎样使用感兴趣的话去干这个

1174
00:55:19,000 --> 00:55:23,000
反观 MacPulse 你打开他网页他网页是一个很典型的这种

1175
00:55:24,000 --> 00:55:29,000
门户网站的感觉就是一上来密密麻麻一大堆信息

1176
00:55:29,000 --> 00:55:32,000
什么 documentation

1177
00:55:32,000 --> 00:55:33,000
update

1178
00:55:33,000 --> 00:55:34,000
recent news

1179
00:55:35,000 --> 00:55:36,000
blah blah blah blah

1180
00:55:36,000 --> 00:55:37,000
你想要干嘛

1181
00:55:37,000 --> 00:55:40,000
你想要知道这个工具到底干嘛的你不知道

1182
00:55:41,000 --> 00:55:41,000
对

1183
00:55:42,000 --> 00:55:42,000
所以其实

1184
00:55:43,000 --> 00:55:46,000
所以刚才你提到好就说那个什么我们都讲那个什么

1185
00:55:46,000 --> 00:55:48,000
cool a drinking kit

1186
00:55:48,000 --> 00:55:51,000
其实这个我觉得是所有的

1187
00:55:51,000 --> 00:55:57,000
开发者包括这个产品经理都要学习的一个东西就怎么把这个叫做我们

1188
00:55:57,000 --> 00:55:59,000
这个其实有个专门的叫做什么

1189
00:55:59,000 --> 00:56:00,000
user landing 吧

1190
00:56:01,000 --> 00:56:07,000
就是就是第一批用户当用户第一眼目睹你的产品的时候你给他一个什么样的印象

1191
00:56:08,000 --> 00:56:11,000
就是在用户已经知道有你这么一个东西但是还不知道

1192
00:56:11,000 --> 00:56:16,000
怎么用的时候你怎么让他能够快速的去上手那么那么这个过程变得比较爽

1193
00:56:16,000 --> 00:56:17,000
我觉得这个是

1194
00:56:17,000 --> 00:56:21,000
可能是 ruby 社区就 ruby 或者 real 这个社区给

1195
00:56:22,000 --> 00:56:26,000
整个其他软件生这个社区的一个最大的

1196
00:56:26,000 --> 00:56:27,000
叫什么

1197
00:56:28,000 --> 00:56:30,000
财富吧就他们展示了这一点就让一个

1198
00:56:31,000 --> 00:56:34,000
哪怕他只是对这个有兴趣但是可能并不知道

1199
00:56:34,000 --> 00:56:38,000
一些具体的细节的人也能很快的上手然后之后再去想办法

1200
00:56:38,000 --> 00:56:40,000
去摸清那些细节吗不是说

1201
00:56:41,000 --> 00:56:42,000
你先上来甩给他一个

1202
00:56:43,000 --> 00:56:45,000
我这个什么高冷的形象然后

1203
00:56:46,000 --> 00:56:49,000
你看不懂就自己去吃屎吧这样就

1204
00:56:50,000 --> 00:56:53,000
不太好以这种姿态能最终取得成功人

1205
00:56:54,000 --> 00:56:58,000
在矿谷至今只有 Linux 推出的一个人

1206
00:57:01,000 --> 00:57:02,000
所以是不是我们节目的姿态要放低

1207
00:57:04,000 --> 00:57:06,000
好了

1208
00:57:07,000 --> 00:57:08,000
下次放低点

1209
00:57:08,000 --> 00:57:09,000
好

1210
00:57:09,000 --> 00:57:11,000
那接着说这个 homebrew

1211
00:57:11,000 --> 00:57:11,000
这个事儿

1212
00:57:12,000 --> 00:57:15,000
所以就现在我们看到就基本上那些新的包最新的版本

1213
00:57:16,000 --> 00:57:20,000
他们就因为用户很多嘛然后他大家都会为他去贡献去出错

1214
00:57:20,000 --> 00:57:23,000
就是他变成一个很良性的一个循环

1215
00:57:23,000 --> 00:57:24,000
就是

1216
00:57:24,000 --> 00:57:28,000
你作为一个新软件的作者或者你要用的一个软件里面没有你会想

1217
00:57:28,000 --> 00:57:29,000
我去 homebrew 里面

1218
00:57:29,000 --> 00:57:35,000
找一下如果没有我就去提交这个 formula 然后把那个提交的 formula 也加回到这个

1219
00:57:35,000 --> 00:57:38,000
upstream 上面去这样别人也因此而收益

1220
00:57:39,000 --> 00:57:40,000
所以其实到今天的话

1221
00:57:41,000 --> 00:57:42,000
这个 lc 上面这个 homebrew 的

1222
00:57:42,000 --> 00:57:45,000
包管理器基本上已经可以在某种程度上

1223
00:57:45,000 --> 00:57:50,000
达到了在 Linux 上面做的比较好的那些包管理器的那种规模或者是效果

1224
00:57:50,000 --> 00:57:53,000
对而且 homebrew 甚至还被 port 到 Linux 上面

1225
00:57:53,000 --> 00:57:54,000
当时就

1226
00:57:54,000 --> 00:57:57,000
刚听到这个新闻的时候我觉得还挺吃惊的就是

1227
00:57:58,000 --> 00:58:03,000
Linux 我们在 Mac 上面用 homebrew 是因为 Mac 上面没有 apt-get

1228
00:58:03,000 --> 00:58:05,000
或者是没有 yam

1229
00:58:06,000 --> 00:58:06,000
而

1230
00:58:06,000 --> 00:58:07,000
为什么

1231
00:58:08,000 --> 00:58:10,000
今天这个时代居然要把 homebrew 这种

1232
00:58:11,000 --> 00:58:20,000
因为没有所以不得不造出来的工具 backport 到你们那边已经比较成熟的解决方案的地方

1233
00:58:20,000 --> 00:58:23,000
这让我挺吃惊的但仔细想想

1234
00:58:23,000 --> 00:58:26,000
就是 homebrew 的理念其实是相当相当先进的吧

1235
00:58:27,000 --> 00:58:27,000
可以这么说

1236
00:58:27,000 --> 00:58:33,000
对对而且它的整个就刚刚就讲了我们这个整个用户体验是蛮非常友好的嘛就是让大家能够很快上手

1237
00:58:33,000 --> 00:58:39,000
这其实我觉得也是一个很好的类比比如说那个 formula 刚才讲的 DSL 的一个 Ruby 的文件

1238
00:58:39,000 --> 00:58:40,000
你可以写下来

1239
00:58:40,000 --> 00:58:41,000
就我

1240
00:58:41,000 --> 00:58:43,000
你看一下就大概知道他在干嘛

1241
00:58:43,000 --> 00:58:46,000
但我到现在为止也没搞懂这个怎么去自己编

1242
00:58:47,000 --> 00:58:52,000
搞一个什么 debian package 出来然后能够很方便的发布出去就是这个过程还是蛮繁琐的

1243
00:58:52,000 --> 00:58:57,000
而且 homebrew 更优雅

1244
00:58:57,000 --> 00:58:58,000
加以好一点就是

1245
00:58:59,000 --> 00:59:00,000
他是

1246
00:59:00,000 --> 00:59:01,000
跟 git

1247
00:59:01,000 --> 00:59:02,000
结合的非常紧密

1248
00:59:03,000 --> 00:59:06,000
他本身 host 在 github 上面就不用说了

1249
00:59:07,000 --> 00:59:09,000
而这个 homebrew 本身的

1250
00:59:10,000 --> 00:59:11,000
升级

1251
00:59:11,000 --> 00:59:13,000
也只不过是一个 gitpool

1252
00:59:14,000 --> 00:59:16,000
的某种被包装过的 gitpool 而已

1253
00:59:17,000 --> 00:59:19,000
就是他这个工具本身就是

1254
00:59:19,000 --> 00:59:22,000
以一套版本管理系统

1255
00:59:22,000 --> 00:59:24,000
的方式

1256
00:59:25,000 --> 00:59:27,000
经过版本管理的软件

1257
00:59:29,000 --> 00:59:31,000
repository 形式出现在电脑上

1258
00:59:31,000 --> 00:59:33,000
他需要升级的时候就只需要

1259
00:59:34,000 --> 00:59:36,000
从他的 upstream 上更新一下就可以了

1260
00:59:36,000 --> 00:59:38,000
这个也是挺

1261
00:59:39,000 --> 00:59:40,000
优雅的一个部分吧

1262
00:59:41,000 --> 00:59:42,000
对

1263
00:59:43,000 --> 00:59:45,000
所以刚才讲的那么都是

1264
00:59:46,000 --> 00:59:53,000
根据某一个操作系统上面而选择的不同的这个包管理器好比如说刚才讲的 debian 上面有没有一个 apt

1265
00:59:53,000 --> 00:59:55,000
然后 rpm 系统的话是 yam

1266
00:59:56,000 --> 00:59:58,000
然后有 bsd 的 port

1267
00:59:58,000 --> 01:00:00,000
然后 mac 上面现在最新的是这个 homebrew

1268
01:00:01,000 --> 01:00:02,000
下面我们接下来

1269
01:00:02,000 --> 01:00:04,000
你刻意跳过了 windows

1270
01:00:06,000 --> 01:00:07,000
windows 有吗

1271
01:00:07,000 --> 01:00:08,000
有啊有啊

1272
01:00:08,000 --> 01:00:10,000
看来你真是硬验了我们的手机

1273
01:00:10,000 --> 01:00:10,000
有什么

1274
01:00:11,000 --> 01:00:15,000
我们听中一句话就是对 windows 的了解连大学毕业生都不如

1275
01:00:16,000 --> 01:00:19,000
那肯定已经彻底放弃好多年了

1276
01:00:19,000 --> 01:00:25,000
其实很惭愧的就是我也是现学现卖也是因为前阵子去关注那个

1277
01:00:25,000 --> 01:00:27,000
dotnet

1278
01:00:27,000 --> 01:00:30,000
的开源才注意到了就是 windows 下面有一叫做

1279
01:00:31,000 --> 01:00:33,000
不确定这应该怎么念

1280
01:00:34,000 --> 01:00:34,000
nuget

1281
01:00:34,000 --> 01:00:37,000
n u g e t

1282
01:00:37,000 --> 01:00:38,000
nuget

1283
01:00:39,000 --> 01:00:40,000
鸡块吗

1284
01:00:41,000 --> 01:00:42,000
和鸡块谐音

1285
01:00:42,000 --> 01:00:47,000
总之他就是 nuget 就是一个

1286
01:00:48,000 --> 01:00:54,000
包括 dotnet 平台在内的专门为微软开发而研发了一套

1287
01:00:55,000 --> 01:00:56,000
package manager

1288
01:00:56,000 --> 01:00:59,000
等一下他是跑在命令行下面的吗

1289
01:00:59,000 --> 01:01:02,000
他有一个命令行界面然后也有一个图形界面 as always

1290
01:01:02,000 --> 01:01:06,000
windows 程序怎么可能没有图形界面你让 windows 程序员怎么活

1291
01:01:07,000 --> 01:01:08,000
对我就在想怎么

1292
01:01:09,000 --> 01:01:11,000
怎么会有这种需求他们不是都直接在那个

1293
01:01:11,000 --> 01:01:13,000
跑一个这个什么

1294
01:01:14,000 --> 01:01:15,000
故意的东西然后

1295
01:01:15,000 --> 01:01:16,000
做个

1296
01:01:16,000 --> 01:01:17,000
很

1297
01:01:17,000 --> 01:01:19,000
500 个按钮的软件

1298
01:01:19,000 --> 01:01:21,000
此处省去

1299
01:01:21,000 --> 01:01:22,000
对 windows 程序员的冷嘲热讽

1300
01:01:23,000 --> 01:01:23,000
五千字

1301
01:01:25,000 --> 01:01:27,000
总之这个谁在用的我从

1302
01:01:27,000 --> 01:01:30,000
所有微软程序员所有现在的微软程序员都在用

1303
01:01:31,000 --> 01:01:34,000
OK 所以他们是一个

1304
01:01:34,000 --> 01:01:40,000
Parallel universe 我们不知道对在这个平行宇宙里面比如说什么 jquery 呀或者是

1305
01:01:41,000 --> 01:01:45,000
他这个可以对这个之类的东西都可以通过

1306
01:01:45,000 --> 01:01:46,000
在那个那个

1307
01:01:46,000 --> 01:01:50,000
图形界面之下搜这个然后点一下你导他就往庄好了

1308
01:01:51,000 --> 01:01:51,000
虽然

1309
01:01:52,000 --> 01:01:52,000
天

1310
01:01:52,000 --> 01:01:53,000
对而且他

1311
01:01:55,000 --> 01:01:55,000
他可能有

1312
01:01:55,000 --> 01:01:58,000
三两三万个那个拍给是累进

1313
01:01:59,000 --> 01:02:04,000
那还不挺大规模的这个是有什么微软官方的维护

1314
01:02:05,000 --> 01:02:06,000
官方家

1315
01:02:06,000 --> 01:02:06,000
Holy

1316
01:02:07,000 --> 01:02:08,000
Yes

1317
01:02:08,000 --> 01:02:10,000
而且在那个

1318
01:02:10,000 --> 01:02:11,000
你安装

1319
01:02:11,000 --> 01:02:12,000
安装了

1320
01:02:13,000 --> 01:02:15,000
Dotnet 在

1321
01:02:15,000 --> 01:02:18,000
MacOS 上的那个 homebrew 工具之后

1322
01:02:18,000 --> 01:02:19,000
你就有了 nugget

1323
01:02:19,000 --> 01:02:20,000
好好

1324
01:02:23,000 --> 01:02:23,000
等一下

1325
01:02:23,000 --> 01:02:25,000
Nugget 这个是不是一个脏话

1326
01:02:26,000 --> 01:02:27,000
不是吧

1327
01:02:27,000 --> 01:02:30,000
Nigger 是脏话 Nugget 不是吧

1328
01:02:31,000 --> 01:02:34,000
微软不会蠢到这么政治不正确

1329
01:02:34,000 --> 01:02:37,000
这个时候叫寄出 urban dict

1330
01:02:38,000 --> 01:02:41,000
Nugget a person with no arms or legs

1331
01:02:41,000 --> 01:02:44,000
机块吗就一个人

1332
01:02:44,000 --> 01:02:45,000
把一个人

1333
01:02:45,000 --> 01:02:47,000
人贯吗人质

1334
01:02:47,000 --> 01:02:48,000
人贯

1335
01:02:48,000 --> 01:02:51,000
我忘记了就是那个女后做的那件事吗

1336
01:02:52,000 --> 01:02:53,000
对啊不是

1337
01:02:53,000 --> 01:02:55,000
中那个叫人质

1338
01:02:55,000 --> 01:02:56,000
人质吧

1339
01:02:57,000 --> 01:02:57,000
好吧

1340
01:02:58,000 --> 01:03:02,000
对反正从 Nugget 上面你可以

1341
01:03:02,000 --> 01:03:07,000
下载比如什么 JQuery 啊

1342
01:03:07,000 --> 01:03:09,000
包括 sp net 的 mvc

1343
01:03:09,000 --> 01:03:10,000
库啊

1344
01:03:11,000 --> 01:03:14,000
甚至还有很多什么 bootstrap

1345
01:03:14,000 --> 01:03:15,000
好像也可以从上面下下来

1346
01:03:15,000 --> 01:03:16,000
我记得

1347
01:03:16,000 --> 01:03:17,000
就是面

1348
01:03:17,000 --> 01:03:18,000
针对前端的吗还是

1349
01:03:18,000 --> 01:03:19,000
针对一切

1350
01:03:19,000 --> 01:03:20,000
开发者

1351
01:03:21,000 --> 01:03:25,000
OK 因为你举的几个例子都是跟前端开发有关系的

1352
01:03:26,000 --> 01:03:29,000
还是说你暴露了你是在上面做前端开发这件事

1353
01:03:29,000 --> 01:03:32,000
我在上面做了

1354
01:03:32,000 --> 01:03:37,000
很简单的 windows 用户 windows 编程摸底而已

1355
01:03:37,000 --> 01:03:40,000
没有在上面做过任何开发

1356
01:03:40,000 --> 01:03:41,000
OK

1357
01:03:41,000 --> 01:03:45,000
好吧这个反正我也没问过

1358
01:03:46,000 --> 01:03:51,000
没法没法接着讨论下去到底怎么样总之有这么一个东西存在就是

1359
01:03:51,000 --> 01:03:58,000
对啊刚才我们讲的就是基于每一个各个操作系统或者是这个 Linux 发行版本的这个包管理工具

1360
01:03:58,000 --> 01:03:59,000
具的一些相关的情况

1361
01:04:00,000 --> 01:04:03,000
现在我们要切换到另外一个比较重要也是我们

1362
01:04:03,000 --> 01:04:05,000
吐槽比较多的

1363
01:04:05,000 --> 01:04:10,000
就是基于各个语言的这个这包管理的东西了

1364
01:04:11,000 --> 01:04:17,000
这里有一个比较显著的区别就是刚才讲的那些像 homebrew 也好还是 debian 也好

1365
01:04:17,000 --> 01:04:19,000
他也很大程度上是

1366
01:04:19,000 --> 01:04:22,000
为了这个我们讲部署的时候用的嘛

1367
01:04:22,000 --> 01:04:23,000
就是可能最终用户自己安装

1368
01:04:24,000 --> 01:04:28,000
或者是我们把它弄到服务器上运行的时候这样去的一个用法

1369
01:04:28,000 --> 01:04:34,000
然后包括你用 homebrew 安装的很多这种所谓的命令行软件你是做他的一个用户你不是做他的开发者

1370
01:04:35,000 --> 01:04:35,000
去安装的

1371
01:04:35,000 --> 01:04:36,000
当然也有例外

1372
01:04:37,000 --> 01:04:39,000
其实这是一个比较大的

1373
01:04:40,000 --> 01:04:40,000
比较明显的

1374
01:04:41,000 --> 01:04:43,000
但是目前还没有人做出来的

1375
01:04:43,000 --> 01:04:44,000
区别吧

1376
01:04:44,000 --> 01:04:48,000
就是你通过一个包管理工具

1377
01:04:48,000 --> 01:04:52,000
安装的一个东西有可能是有一个直接可执行文件的

1378
01:04:53,000 --> 01:04:56,000
这么一套东西也有可能他仅仅是一个

1379
01:04:56,000 --> 01:04:57,000
lib 对吧

1380
01:04:57,000 --> 01:04:58,000
仅仅是一个 library 而已

1381
01:04:59,000 --> 01:05:00,000
有很多这种情况

1382
01:05:00,000 --> 01:05:06,000
在我的有限人址里面好像 homebrew 其实是对此有一个比较

1383
01:05:07,000 --> 01:05:07,000
模糊的

1384
01:05:08,000 --> 01:05:10,000
而且是一个稍微有点绕人的概念的

1385
01:05:10,000 --> 01:05:13,000
就是有些东西所谓 cask only

1386
01:05:14,000 --> 01:05:18,000
homebrew 有自己一套 jargon 对吧虽然我对此也不是非常理解

1387
01:05:18,000 --> 01:05:23,000
因为他整个借用了这个酿丝酒的这么一套

1388
01:05:24,000 --> 01:05:24,000
术语

1389
01:05:25,000 --> 01:05:25,000
语汇对

1390
01:05:25,000 --> 01:05:28,000
比如说 cask 就是一个酒桶

1391
01:05:28,000 --> 01:05:32,000
然后你从 cask 里面 pour 出来什么东西

1392
01:05:32,000 --> 01:05:35,000
然后再自己 brew 这个套其实就是类比

1393
01:05:35,000 --> 01:05:37,000
或者说他把整个

1394
01:05:37,000 --> 01:05:39,000
编译的过程类比为发酵的过程

1395
01:05:39,000 --> 01:05:43,000
而 cask only 的意思就是这套东西是不发酵的

1396
01:05:43,000 --> 01:05:44,000
这套东西只是存在酒桶里面

1397
01:05:45,000 --> 01:05:47,000
发酵

1398
01:05:47,000 --> 01:05:49,000
ok 我又念错字了

1399
01:05:49,000 --> 01:05:50,000
sorry

1400
01:05:50,000 --> 01:05:52,000
我先纠正了免得你又被

1401
01:05:52,000 --> 01:05:54,000
被搞

1402
01:05:54,000 --> 01:05:59,000
对他有那个就当然有个事情没有解释啊他有这个就

1403
01:05:59,000 --> 01:06:03,000
就之前我们讲那个 debent 包一般是发行的二进制版本

1404
01:06:03,000 --> 01:06:05,000
port 是一般是发行原码

1405
01:06:05,000 --> 01:06:08,000
homebrew 的话其实是比较诡异的就是他

1406
01:06:09,000 --> 01:06:12,000
两种都有他两种都有支持应该说

1407
01:06:13,000 --> 01:06:15,000
对然后他会有三个样有不同的语语

1408
01:06:15,000 --> 01:06:18,000
词去描述他我记得他的

1409
01:06:18,000 --> 01:06:20,000
二进制版本是叫做 bottle

1410
01:06:21,000 --> 01:06:22,000
就是瓶子

1411
01:06:22,000 --> 01:06:29,000
这个逻辑你想想很简单就是你编译的过程是在 brew 发酵嘛发酵完了就就是一个成瓶的酒

1412
01:06:29,000 --> 01:06:29,000
已经装瓶了

1413
01:06:30,000 --> 01:06:35,000
就叫装瓶然后就直接可以给别人用了就他是有这么一个概念然后但是他对于很多那种

1414
01:06:36,000 --> 01:06:39,000
软件就不方便装瓶的一个是可能因为法律

1415
01:06:39,000 --> 01:06:42,000
法律的问题或者是因为版权的问题他没办法装瓶的

1416
01:06:43,000 --> 01:06:47,000
或者甚至最简单的情况就是这个东西他根本就不是拿来用的他只是拿来

1417
01:06:48,000 --> 01:06:50,000
作为一个建筑材料而已

1418
01:06:50,000 --> 01:06:53,000
对他就会直接发布这个 source

1419
01:06:54,000 --> 01:06:57,000
这个我想想能够比较明显那个 fm

1420
01:06:57,000 --> 01:06:59,000
fmpeg

1421
01:06:59,000 --> 01:07:00,000
fmpg 这个工具

1422
01:07:01,000 --> 01:07:03,000
他就是发布的原码然后你要自己编译的

1423
01:07:04,000 --> 01:07:04,000
但是你像

1424
01:07:05,000 --> 01:07:05,000
vim

1425
01:07:05,000 --> 01:07:08,000
macvim 好像是他是弄成一个 bottle 了我记得

1426
01:07:08,000 --> 01:07:09,000
macvim 是 bottle

1427
01:07:10,000 --> 01:07:12,000
我没记错的话应该是这样子

1428
01:07:13,000 --> 01:07:14,000
macvim 也是要编译的

1429
01:07:15,000 --> 01:07:16,000
是吗那可能我记错

1430
01:07:16,000 --> 01:07:18,000
他有很多这种是 bottle

1431
01:07:18,000 --> 01:07:20,000
你可以发现安装很快也不需要

1432
01:07:21,000 --> 01:07:22,000
没有那个编译的过程

1433
01:07:24,000 --> 01:07:26,000
继续说我们这个

1434
01:07:26,000 --> 01:07:29,000
和编程员相关的包管理系统

1435
01:07:29,000 --> 01:07:33,000
对这里就有可能比较奇特的一个事情就是

1436
01:07:33,000 --> 01:07:34,000
在

1437
01:07:34,000 --> 01:07:36,000
某具体到某个语言来讲他还有

1438
01:07:36,000 --> 01:07:39,000
通常是一个我自己的一套这个包管理器的然后

1439
01:07:40,000 --> 01:07:40,000
这个包管理器

1440
01:07:40,000 --> 01:07:43,000
要解决的绝大部分场合是

1441
01:07:44,000 --> 01:07:48,000
作为就为了帮助开发者写程序的时候用的

1442
01:07:48,000 --> 01:07:49,000
对

1443
01:07:49,000 --> 01:07:50,000
这么说安全吧

1444
01:07:50,000 --> 01:07:51,000
我现在是安全的吧

1445
01:07:52,000 --> 01:07:53,000
但就是其实

1446
01:07:53,000 --> 01:07:57,000
这这里也有一个很有趣的事实就是

1447
01:07:57,000 --> 01:08:00,000
不管是 Python 也好还是 Ruby 也好

1448
01:08:00,000 --> 01:08:03,000
有很多包其实

1449
01:08:03,000 --> 01:08:04,000
他不是拿来

1450
01:08:05,000 --> 01:08:06,000
不是帮你提供一个开发工具的

1451
01:08:07,000 --> 01:08:09,000
他是拿来就是提供一个命令行工具

1452
01:08:09,000 --> 01:08:09,000
对他是给你提供一个开发工具的

1453
01:08:10,000 --> 01:08:13,000
比如说我很喜欢一个叫做

1454
01:08:13,000 --> 01:08:14,000
Lolcat

1455
01:08:16,000 --> 01:08:16,000
他的

1456
01:08:16,000 --> 01:08:18,000
效果是把

1457
01:08:18,000 --> 01:08:22,000
你可以把任何字符串 Pype 给他

1458
01:08:22,000 --> 01:08:25,000
然后他把你 Pype 进去的那个字符串

1459
01:08:25,000 --> 01:08:26,000
七彩的形式

1460
01:08:26,000 --> 01:08:27,000
显示在屏幕上

1461
01:08:28,000 --> 01:08:30,000
所以你可以用比如说你可以 call say

1462
01:08:31,000 --> 01:08:32,000
就是 Linux 上有一个

1463
01:08:33,000 --> 01:08:34,000
有趣的小工具就是

1464
01:08:34,000 --> 01:08:39,000
牛说工具他在屏幕上显示一头牛然后这个牛

1465
01:08:39,000 --> 01:08:39,000
会

1466
01:08:40,000 --> 01:08:41,000
头上会冒出来一个

1467
01:08:41,000 --> 01:08:42,000
气泡矿

1468
01:08:42,000 --> 01:08:43,000
然后里面

1469
01:08:43,000 --> 01:08:44,000
显示你要想说的话

1470
01:08:44,000 --> 01:08:46,000
然后你先把你要说的话

1471
01:08:46,000 --> 01:08:47,000
cat 进 call say

1472
01:08:47,000 --> 01:08:49,000
然后再 cat 进 Lolcat

1473
01:08:49,000 --> 01:08:52,000
然后最终结果就是一个七彩的

1474
01:08:52,000 --> 01:08:55,000
牛说了一句七彩的话

1475
01:08:55,000 --> 01:08:57,000
这个东西就是用

1476
01:08:58,000 --> 01:08:59,000
好 fancy 啊

1477
01:08:59,000 --> 01:09:00,000
就是用 Jam 来发布的

1478
01:09:01,000 --> 01:09:03,000
他本质就只是给你提供一个额外的工具而已

1479
01:09:04,000 --> 01:09:06,000
对对所以就是刚才我

1480
01:09:06,000 --> 01:09:08,000
说要特别限定一下

1481
01:09:08,000 --> 01:09:09,000
只能说是

1482
01:09:09,000 --> 01:09:11,000
大部分场合包管的其实为了做

1483
01:09:12,000 --> 01:09:18,000
这个开发用的工具但是其实你看也听到有这种场合是他那个本来就是拿来发布成一个

1484
01:09:18,000 --> 01:09:18,000
可知

1485
01:09:19,000 --> 01:09:20,000
最面向最终用户使用的一个工具

1486
01:09:21,000 --> 01:09:24,000
所以这里面这界限不是那么清晰

1487
01:09:24,000 --> 01:09:26,000
只能说是一个大概的这么一个分类

1488
01:09:27,000 --> 01:09:32,000
而且你比较难的很难去一刀切说我就要硬行在我的

1489
01:09:32,000 --> 01:09:35,000
包管理系统里面提供

1490
01:09:35,000 --> 01:09:37,000
比如说 Jam Jam as a tool

1491
01:09:38,000 --> 01:09:39,000
和 Jam as a level

1492
01:09:39,000 --> 01:09:41,000
的区别因为有些是两者都提供

1493
01:09:42,000 --> 01:09:43,000
对对对

1494
01:09:43,000 --> 01:09:47,000
他提供了一个让你调试的工具比如说对吧

1495
01:09:48,000 --> 01:09:51,000
你可以很方便的启动他但是他都主要做的还是提供一个库

1496
01:09:52,000 --> 01:09:53,000
比如 Pray

1497
01:09:54,000 --> 01:09:58,000
或者是 iPython 这种他既是一个工具又是一套

1498
01:09:58,000 --> 01:09:59,000
库

1499
01:09:59,000 --> 01:10:00,000
对还是不一样

1500
01:10:01,000 --> 01:10:03,000
Software is hard

1501
01:10:03,000 --> 01:10:04,000
So confusing

1502
01:10:07,000 --> 01:10:08,000
那现在我们就来

1503
01:10:08,000 --> 01:10:09,000
就我们

1504
01:10:09,000 --> 01:10:11,000
先着眼来讲就我们先

1505
01:10:11,000 --> 01:10:12,000
不讲那个

1506
01:10:13,000 --> 01:10:14,000
用这种

1507
01:10:14,000 --> 01:10:20,000
某个语言独特的包管理器来发布命令行工具这么一个情况我们就先只看

1508
01:10:21,000 --> 01:10:23,000
用它来做这个开发者的

1509
01:10:23,000 --> 01:10:24,000
事情的时候

1510
01:10:24,000 --> 01:10:27,000
会有一些什么样的东西我们还是按语言来分吧对吧

1511
01:10:28,000 --> 01:10:31,000
加码程式源无他同学请你开始吐槽

1512
01:10:31,000 --> 01:10:34,000
开启你的吐槽模式

1513
01:10:35,000 --> 01:10:35,000
没问

1514
01:10:37,000 --> 01:10:38,000
对

1515
01:10:38,000 --> 01:10:39,000
所以没问为什么

1516
01:10:39,000 --> 01:10:41,000
为什么会给你带着这么惨痛的

1517
01:10:41,000 --> 01:10:42,000
这个感觉

1518
01:10:42,000 --> 01:10:45,000
其实我没问没有真正的伤害过我

1519
01:10:45,000 --> 01:10:48,000
但是那你那你为什么都仇视

1520
01:10:49,000 --> 01:10:50,000
公司里面

1521
01:10:51,000 --> 01:10:53,000
公司至少因为没问的

1522
01:10:53,000 --> 01:10:55,000
一些

1523
01:10:56,000 --> 01:10:57,000
林林总总的事情

1524
01:10:58,000 --> 01:11:02,000
在我的印象里面可能有两次推迟过 release

1525
01:11:03,000 --> 01:11:06,000
Release 推迟一天其实是非常

1526
01:11:07,000 --> 01:11:08,000
并不是什么

1527
01:11:08,000 --> 01:11:09,000
天塌下来的

1528
01:11:09,000 --> 01:11:12,000
灾难性事件但至少也是让所有人不爽

1529
01:11:12,000 --> 01:11:13,000
你不是做游戏的对吧

1530
01:11:14,000 --> 01:11:17,000
我们不是做游戏我们是做比游戏更

1531
01:11:17,000 --> 01:11:18,000
海洛因的东西

1532
01:11:19,000 --> 01:11:19,000
但对

1533
01:11:20,000 --> 01:11:21,000
不重要

1534
01:11:21,000 --> 01:11:21,000
但

1535
01:11:22,000 --> 01:11:26,000
就是推迟一天的话就意味着首先运维人员要

1536
01:11:27,000 --> 01:11:32,000
从鸡飞狗跳鸡飞狗跳 24 小时变成鸡飞狗跳 28 48 小时

1537
01:11:32,000 --> 01:11:36,000
然后开发人员呢也会因为

1538
01:11:36,000 --> 01:11:39,000
发布的被推迟而不得不

1539
01:11:40,000 --> 01:11:42,000
要么临时被抓上丁去解决

1540
01:11:42,000 --> 01:11:43,000
这个

1541
01:11:43,000 --> 01:11:45,000
推导致这个推迟的问题

1542
01:11:45,000 --> 01:11:47,000
要么就因为

1543
01:11:48,000 --> 01:11:51,000
这一次发布不能及时运行而不及时进行而

1544
01:11:52,000 --> 01:11:57,000
得不到一些比较宝贵的资源比如说 QA 比如说 staging server 之类的

1545
01:11:58,000 --> 01:12:01,000
因为所有这些 server 都还在备战状态就是要

1546
01:12:02,000 --> 01:12:03,000
去

1547
01:12:03,000 --> 01:12:05,000
迎合这个发布的 deadline

1548
01:12:06,000 --> 01:12:08,000
saturation

1549
01:12:08,000 --> 01:12:09,000
versus

1550
01:12:09,000 --> 01:12:10,000
为什么

1551
01:12:10,000 --> 01:12:11,000
就是

1552
01:12:12,000 --> 01:12:13,000
也在

1553
01:12:26,000 --> 01:12:27,000
你的

1554
01:12:28,000 --> 01:12:29,000
上去

1555
01:12:30,000 --> 01:12:31,000
告情

1556
01:12:33,000 --> 01:12:33,000
啊

1557
01:12:34,000 --> 01:12:34,000
计划

1558
01:12:34,000 --> 01:12:36,000
这里

1559
01:12:36,000 --> 01:12:36,000
好

1560
01:12:36,000 --> 01:12:36,000
这么厉害啊

1561
01:12:36,000 --> 01:12:39,000
当然你可以说

1562
01:12:39,000 --> 01:12:40,000
你可以站出来说

1563
01:12:40,000 --> 01:12:42,000
你可以用各种各样的图形界面

1564
01:12:42,000 --> 01:12:43,000
去管理 XML

1565
01:12:43,000 --> 01:12:44,000
生成它的

1566
01:12:44,000 --> 01:12:44,000
对

1567
01:12:44,000 --> 01:12:46,000
有一句名言是

1568
01:12:46,000 --> 01:12:47,000
XML 就像 violence

1569
01:12:47,000 --> 01:12:49,000
XML 就像暴力

1570
01:12:49,000 --> 01:12:51,000
如果它不能解决

1571
01:12:51,000 --> 01:12:52,000
如果它不能解决你的问题

1572
01:12:52,000 --> 01:12:54,000
那一定是你用的还不够多

1573
01:12:54,000 --> 01:13:01,000
好吧

1574
01:13:01,000 --> 01:13:01,000
对

1575
01:13:01,000 --> 01:13:03,000
所以但是 Maven

1576
01:13:03,000 --> 01:13:05,000
其实是一个比较

1577
01:13:05,000 --> 01:13:05,000
就是在 Java

1578
01:13:05,000 --> 01:13:06,000
这个开发圈里面

1579
01:13:06,000 --> 01:13:07,000
是一个比较什么

1580
01:13:07,000 --> 01:13:10,000
通用常见的一个方案了吗

1581
01:13:10,000 --> 01:13:11,000
可能有一半程序员

1582
01:13:11,000 --> 01:13:13,000
会反驳你的看法

1583
01:13:13,000 --> 01:13:13,000
但

1584
01:13:13,000 --> 01:13:16,000
要我说 Maven

1585
01:13:16,000 --> 01:13:17,000
其实是一种

1586
01:13:17,000 --> 01:13:21,000
一个一个一个

1587
01:13:21,000 --> 01:13:23,000
过早优化的典型

1588
01:13:23,000 --> 01:13:24,000
可以这么说吗

1589
01:13:24,000 --> 01:13:26,000
为什么这么说呢

1590
01:13:26,000 --> 01:13:26,000
因为

1591
01:13:26,000 --> 01:13:27,000
比如说 Maven

1592
01:13:27,000 --> 01:13:29,000
一个 Maven project

1593
01:13:29,000 --> 01:13:30,000
一上来就

1594
01:13:30,000 --> 01:13:33,000
强制你使用一种特定的

1595
01:13:33,000 --> 01:13:34,000
项目的格式

1596
01:13:34,000 --> 01:13:38,000
就是你所有的包

1597
01:13:38,000 --> 01:13:39,000
文件的格式

1598
01:13:39,000 --> 01:13:41,000
就是你组织员的码格式

1599
01:13:41,000 --> 01:13:42,000
在所有的 Maven project 里面

1600
01:13:42,000 --> 01:13:43,000
是一模一样的

1601
01:13:43,000 --> 01:13:45,000
就 directly layout

1602
01:13:45,000 --> 01:13:45,000
对

1603
01:13:45,000 --> 01:13:46,000
directly layout 就是一上来

1604
01:13:46,000 --> 01:13:47,000
要有一个 source

1605
01:13:47,000 --> 01:13:48,000
source 里面有 main

1606
01:13:48,000 --> 01:13:49,000
main 里面要有

1607
01:13:49,000 --> 01:13:50,000
sorry

1608
01:13:50,000 --> 01:13:51,000
main

1609
01:13:51,000 --> 01:13:51,000
对

1610
01:13:51,000 --> 01:13:53,000
main 里面有一个

1611
01:13:53,000 --> 01:13:53,000
有一个 main

1612
01:13:53,000 --> 01:13:54,000
然后有一个 test

1613
01:13:54,000 --> 01:13:56,000
然后 main 和 test 下面的

1614
01:13:56,000 --> 01:13:58,000
所有的文件结构要一模一样

1615
01:13:58,000 --> 01:14:00,000
对

1616
01:14:00,000 --> 01:14:01,000
总之是

1617
01:14:01,000 --> 01:14:02,000
其实这个没什么

1618
01:14:02,000 --> 01:14:04,000
这个有这个规范是好事吗

1619
01:14:04,000 --> 01:14:04,000
我不觉得

1620
01:14:04,000 --> 01:14:06,000
这个是一个特别不好的

1621
01:14:06,000 --> 01:14:07,000
一个事情

1622
01:14:07,000 --> 01:14:10,000
但是在你仅仅想要

1623
01:14:10,000 --> 01:14:12,000
写一些比较小的东西的时候

1624
01:14:12,000 --> 01:14:13,000
你就会觉得这种

1625
01:14:13,000 --> 01:14:15,000
这种强加于你的结构

1626
01:14:15,000 --> 01:14:17,000
是非常让人不爽的

1627
01:14:17,000 --> 01:14:18,000
对

1628
01:14:18,000 --> 01:14:19,000
我觉得这就是问题所在的

1629
01:14:19,000 --> 01:14:20,000
你为什么要用加码

1630
01:14:20,000 --> 01:14:22,000
写一个很小的东西呢

1631
01:14:22,000 --> 01:14:23,000
为什么我有个脚本语言去写

1632
01:14:23,000 --> 01:14:24,000
好吧

1633
01:14:24,000 --> 01:14:26,000
这里有个审美观念的

1634
01:14:26,000 --> 01:14:29,000
的问题在里面

1635
01:14:29,000 --> 01:14:29,000
就是

1636
01:14:29,000 --> 01:14:31,000
你可以说 Maven 是一种

1637
01:14:31,000 --> 01:14:33,000
专门为了企业级应用

1638
01:14:33,000 --> 01:14:34,000
而推出的

1639
01:14:34,000 --> 01:14:37,000
一种硬性的解决方案

1640
01:14:37,000 --> 01:14:39,000
就是它通过

1641
01:14:39,000 --> 01:14:43,000
永长繁琐的配置

1642
01:14:43,000 --> 01:14:46,000
和强制

1643
01:14:46,000 --> 01:14:48,000
加在你身上的工序

1644
01:14:48,000 --> 01:14:50,000
保证了你是一个

1645
01:14:50,000 --> 01:14:51,000
可以被替换的罗斯顶

1646
01:14:51,000 --> 01:14:53,000
因为不管你是谁

1647
01:14:53,000 --> 01:14:54,000
你只要用 Maven

1648
01:14:54,000 --> 01:14:55,000
那么你能做的东西

1649
01:14:55,000 --> 01:14:56,000
都是可以预定的

1650
01:14:56,000 --> 01:14:58,000
都是可以预见到的

1651
01:14:58,000 --> 01:14:59,000
而不像你说

1652
01:14:59,000 --> 01:15:00,000
比如说早期的

1653
01:15:00,000 --> 01:15:01,000
洪荒时代

1654
01:15:01,000 --> 01:15:02,000
在用 ant 的时候

1655
01:15:02,000 --> 01:15:03,000
你可能你的 ant file

1656
01:15:03,000 --> 01:15:04,000
可能是一个天数一样的东西

1657
01:15:04,000 --> 01:15:05,000
你的接手者

1658
01:15:05,000 --> 01:15:07,000
是没有办法去理解你

1659
01:15:07,000 --> 01:15:09,000
去替代你

1660
01:15:09,000 --> 01:15:11,000
但是反过来

1661
01:15:11,000 --> 01:15:11,000
我会觉得

1662
01:15:11,000 --> 01:15:13,000
就像

1663
01:15:13,000 --> 01:15:15,000
我对所有的

1664
01:15:15,000 --> 01:15:16,000
带有 enterprise 的

1665
01:15:16,000 --> 01:15:17,000
字样的东西

1666
01:15:17,000 --> 01:15:18,000
天生的反感一样

1667
01:15:18,000 --> 01:15:19,000
这是一种

1668
01:15:19,000 --> 01:15:22,000
我很难说

1669
01:15:22,000 --> 01:15:23,000
它到底错在哪儿

1670
01:15:23,000 --> 01:15:24,000
但我就觉得

1671
01:15:24,000 --> 01:15:26,000
它不是我希望的那样

1672
01:15:26,000 --> 01:15:28,000
但如果你是抱着

1673
01:15:28,000 --> 01:15:29,000
这种心态的话

1674
01:15:29,000 --> 01:15:30,000
你是不是不应该

1675
01:15:30,000 --> 01:15:31,000
写 Java 程序呢

1676
01:15:31,000 --> 01:15:31,000
at all

1677
01:15:34,000 --> 01:15:36,000
因为 Java 版就是为 enterprise

1678
01:15:36,000 --> 01:15:37,000
这种场景是

1679
01:15:37,000 --> 01:15:40,000
我只能说我是为了谋生

1680
01:15:40,000 --> 01:15:42,000
不得不做这件事情的

1681
01:15:42,000 --> 01:15:43,000
但就像所有的

1682
01:15:43,000 --> 01:15:46,000
就像 Paul Graham 说过的那句话一样

1683
01:15:46,000 --> 01:15:50,000
就是在他知道的所有程序里面

1684
01:15:50,000 --> 01:15:51,000
在他认识的十个

1685
01:15:51,000 --> 01:15:52,000
在他能想出的

1686
01:15:52,000 --> 01:15:53,000
原号我不太记得

1687
01:15:53,000 --> 01:15:54,000
反正大意就是说

1688
01:15:54,000 --> 01:15:57,000
在他能想到的十个 Java 程序里面

1689
01:15:57,000 --> 01:16:01,000
有九个不是出于自愿的目的

1690
01:16:01,000 --> 01:16:03,000
而去写 Java

1691
01:16:03,000 --> 01:16:04,000
我可能也是

1692
01:16:04,000 --> 01:16:08,000
明白

1693
01:16:08,000 --> 01:16:10,000
生活所迫

1694
01:16:10,000 --> 01:16:11,000
对

1695
01:16:11,000 --> 01:16:12,000
而且这也

1696
01:16:12,000 --> 01:16:14,000
我觉得这可能也是

1697
01:16:14,000 --> 01:16:15,000
我辞职的原因之一

1698
01:16:15,000 --> 01:16:18,000
就是去寻找更绿的

1699
01:16:18,000 --> 01:16:18,000
哥不干了

1700
01:16:18,000 --> 01:16:19,000
对

1701
01:16:19,000 --> 01:16:21,000
去寻找更绿的草坪的动机之一

1702
01:16:21,000 --> 01:16:24,000
也就是我终于收购了 Java 这一套

1703
01:16:24,000 --> 01:16:26,000
对

1704
01:16:26,000 --> 01:16:27,000
而且

1705
01:16:27,000 --> 01:16:28,000
所以这里要

1706
01:16:28,000 --> 01:16:28,000
所以这里要

1707
01:16:28,000 --> 01:16:30,000
要查问一句

1708
01:16:30,000 --> 01:16:32,000
你下一份工作是准备写什么

1709
01:16:32,000 --> 01:16:33,000
可能是 Python

1710
01:16:33,000 --> 01:16:34,000
应该是 Python

1711
01:16:34,000 --> 01:16:34,000
OK

1712
01:16:34,000 --> 01:16:34,000
对

1715
01:17:34,000 --> 01:17:35,000
,所以这是一个

1716
01:17:35,000 --> 01:17:37,000
大家都知道很不爽

1717
01:17:37,000 --> 01:17:38,000
但是大家都知道

1718
01:17:38,000 --> 01:17:40,000
起码这个不爽是可以预期的

1719
01:17:40,000 --> 01:17:41,000
对吧

1720
01:17:41,000 --> 01:17:41,000
有多不爽

1721
01:17:41,000 --> 01:17:42,000
也就那样

1722
01:17:42,000 --> 01:17:44,000
对网上有一幅漫画

1723
01:17:44,000 --> 01:17:46,000
我觉得一定要放在我们 show notes 里面

1724
01:17:46,000 --> 01:17:48,000
以享读者

1725
01:17:48,000 --> 01:17:51,000
对大意就是你

1726
01:17:51,000 --> 01:17:54,000
大意是一个你采用

1727
01:17:54,000 --> 01:17:57,000
美文之后的生产率曲线

1728
01:17:57,000 --> 01:18:01,000
刚刚开始这个曲线是有一点点向上

1729
01:18:01,000 --> 01:18:03,000
就是刚刚采用美文之后

1730
01:18:03,000 --> 01:18:04,000
你会觉得哇一切

1731
01:18:04,000 --> 01:18:06,000
包都精英有条

1732
01:18:06,000 --> 01:18:08,000
然后一切

1733
01:18:08,000 --> 01:18:10,000
就是还有一个特点

1734
01:18:10,000 --> 01:18:10,000
就是它的

1735
01:18:10,000 --> 01:18:14,000
它给你预先定义了

1736
01:18:14,000 --> 01:18:16,000
一套非常永长繁琐

1737
01:18:16,000 --> 01:18:19,000
啰嗦的那个编译步骤

1738
01:18:19,000 --> 01:18:21,000
你比如说你可以运行

1739
01:18:21,000 --> 01:18:23,000
就是帮你删掉所有东西

1740
01:18:23,000 --> 01:18:24,000
然后

1741
01:18:24,000 --> 01:18:27,000
就是帮你从

1742
01:18:27,000 --> 01:18:29,000
然后

1743
01:18:29,000 --> 01:18:30,000
然后

1744
01:18:30,000 --> 01:18:31,000
然后

1745
01:18:31,000 --> 01:18:31,000
然后

1746
01:18:31,000 --> 01:18:32,000
然后

1747
01:18:32,000 --> 01:18:33,000
然后

1748
01:18:33,000 --> 01:18:33,000
然后

1749
01:18:33,000 --> 01:18:33,000
然后

1750
01:18:33,000 --> 01:18:33,000
然后

1751
01:18:33,000 --> 01:18:34,000
然后

1752
01:18:34,000 --> 01:18:34,000
然后

1753
01:18:34,000 --> 01:18:35,000
然后

1754
01:18:35,000 --> 01:18:35,000
然后

1755
01:18:35,000 --> 01:18:35,000
然后

1756
01:18:35,000 --> 01:18:35,000
然后

1757
01:18:35,000 --> 01:18:35,000
然后

1758
01:18:35,000 --> 01:18:35,000
然后

1759
01:18:35,000 --> 01:18:35,000
然后

1760
01:18:35,000 --> 01:18:35,000
然后

1761
01:18:35,000 --> 01:18:35,000
然后

1762
01:18:35,000 --> 01:18:35,000
然后

1763
01:18:35,000 --> 01:18:35,000
然后

1764
01:18:35,000 --> 01:18:36,000
然后

1765
01:18:36,000 --> 01:18:36,000
然后

1766
01:18:36,000 --> 01:18:36,000
然后

1767
01:18:36,000 --> 01:18:36,000
然后

1768
01:18:36,000 --> 01:18:36,000
然后

1769
01:18:36,000 --> 01:18:36,000
然后

1770
01:18:36,000 --> 01:18:36,000
然后

1771
01:18:36,000 --> 01:18:37,000
然后

1772
01:18:37,000 --> 01:18:37,000
然后

1773
01:18:37,000 --> 01:18:37,000
然后

1774
01:18:37,000 --> 01:18:37,000
然后

1775
01:18:37,000 --> 01:18:37,000
然后

1776
01:18:37,000 --> 01:18:37,000
然后

1777
01:18:37,000 --> 01:18:37,000
然后

1778
01:18:37,000 --> 01:18:37,000
然后

1779
01:18:37,000 --> 01:18:38,000
然后

1780
01:18:38,000 --> 01:18:38,000
然后

1781
01:18:38,000 --> 01:18:38,000
然后

1782
01:18:38,000 --> 01:18:38,000
然后

1783
01:18:38,000 --> 01:18:38,000
然后

1784
01:18:38,000 --> 01:18:38,000
然后

1785
01:18:38,000 --> 01:18:39,000
然后

1786
01:18:39,000 --> 01:18:39,000
然后

1787
01:18:39,000 --> 01:18:39,000
然后

1788
01:18:39,000 --> 01:18:39,000
然后

1789
01:18:39,000 --> 01:18:39,000
然后

1790
01:18:39,000 --> 01:18:39,000
然后

1791
01:18:39,000 --> 01:18:39,000
然后

1792
01:18:39,000 --> 01:18:40,000
然后

1793
01:18:40,000 --> 01:18:41,000
因为一切都尽可能自动化

1794
01:18:41,000 --> 01:18:42,000
但是

1795
01:18:42,000 --> 01:18:44,000
好景不长

1796
01:18:44,000 --> 01:18:45,000
当某一个时间

1797
01:18:45,000 --> 01:18:49,000
你遭遇到某一个安装包的依赖

1798
01:18:49,000 --> 01:18:50,000
冲突问题的时候

1799
01:18:50,000 --> 01:18:51,000
你会发现

1800
01:18:51,000 --> 01:18:54,000
你已经失去了对整个项目的控制

1801
01:18:54,000 --> 01:18:55,000
然后整个情况

1802
01:18:55,000 --> 01:18:56,000
直转直下

1803
01:18:56,000 --> 01:18:57,000
然后

1804
01:18:57,000 --> 01:19:01,000
生产率曲线就跌落了一个万劫不复的深渊

1805
01:19:01,000 --> 01:19:02,000
我又发现

1806
01:19:02,000 --> 01:19:05,000
我把整个 project 已经

1807
01:19:05,000 --> 01:19:05,000
怎么说

1808
01:19:05,000 --> 01:19:07,000
meanized

1809
01:19:07,000 --> 01:19:09,000
然后在这个

1810
01:19:09,000 --> 01:19:11,000
感觉这个时候好像得了癌

1811
01:19:11,000 --> 01:19:12,000
就像癌症感染一样

1812
01:19:12,000 --> 01:19:12,000
对

1813
01:19:12,000 --> 01:19:14,000
我已经骑虎难下

1814
01:19:14,000 --> 01:19:15,000
再也回不去了

1815
01:19:15,000 --> 01:19:18,000
所以还有一个什么

1816
01:19:18,000 --> 01:19:20,000
还能够恢复的阶段吗

1817
01:19:20,000 --> 01:19:23,000
好像那幅漫画里面是没有恢复的阶段

1818
01:19:23,000 --> 01:19:25,000
所以直接死了

1819
01:19:25,000 --> 01:19:27,000
而且在有一个

1820
01:19:27,000 --> 01:19:29,000
就像我上次提到了过

1821
01:19:29,000 --> 01:19:31,000
一个 tumblr 的一个

1822
01:19:31,000 --> 01:19:33,000
以 gif 网站

1823
01:19:33,000 --> 01:19:35,000
以 gif 动画为主的 tumblr

1824
01:19:35,000 --> 01:19:38,000
叫做 devops reactions

1825
01:19:38,000 --> 01:19:40,000
里面就有一个

1826
01:19:40,000 --> 01:19:45,000
有一期就是讲

1827
01:19:45,000 --> 01:19:46,000
Maven 的

1828
01:19:46,000 --> 01:19:48,000
人力如何令人痛苦的

1829
01:19:48,000 --> 01:19:50,000
很简单

1830
01:19:50,000 --> 01:19:53,000
就是一个人在雨中流泪

1831
01:19:53,000 --> 01:19:54,000
然后另外一个人

1832
01:19:54,000 --> 01:19:55,000
从后面

1833
01:19:55,000 --> 01:19:57,000
贴近他的耳朵说

1834
01:19:57,000 --> 01:20:00,000
好像是

1835
01:20:00,000 --> 01:20:05,000
it's gonna be painful

1836
01:20:05,000 --> 01:20:06,000
大概是

1837
01:20:06,000 --> 01:20:08,000
就是大概说了这么一句话

1838
01:20:08,000 --> 01:20:10,000
然后这个 gif 的标题就是

1839
01:20:10,000 --> 01:20:14,000
得知项目里面需要用到 Maven

1840
01:20:14,000 --> 01:20:18,000
好吧

1841
01:20:18,000 --> 01:20:21,000
我们知道你的痛苦了

1842
01:20:21,000 --> 01:20:22,000
不过我马上就要解脱了

1843
01:20:22,000 --> 01:20:23,000
还有一个礼拜

1844
01:20:23,000 --> 01:20:25,000
而且各位听到这个

1845
01:20:25,000 --> 01:20:27,000
听到这些节目的时候

1846
01:20:27,000 --> 01:20:28,000
说我们已经解脱了

1847
01:20:28,000 --> 01:20:28,000
我已经解脱了

1848
01:20:28,000 --> 01:20:31,000
我已经开开心心的在意大利游玩

1849
01:20:31,000 --> 01:20:34,000
好吧

1850
01:20:34,000 --> 01:20:39,000
就说到 java 要说一个相关的语言

1851
01:20:39,000 --> 01:20:42,000
就是这边叫做 scala 的语言

1852
01:20:42,000 --> 01:20:44,000
或者说 next generation java

1853
01:20:44,000 --> 01:20:48,000
我觉得不能这么说

1854
01:20:48,000 --> 01:20:50,000
因为它并不是它的一个超级

1855
01:20:50,000 --> 01:20:50,000
首先

1856
01:20:50,000 --> 01:20:52,000
它是怎么说呢

1857
01:20:52,000 --> 01:20:55,000
scala 的目的就是取代现有的 java

1858
01:20:55,000 --> 01:20:55,000
成为下一代的 java

1859
01:20:55,000 --> 01:20:58,000
成为下一代的企业级应用的标准语言

1860
01:20:58,000 --> 01:21:00,000
我觉得这件事情是不会发生的

1861
01:21:00,000 --> 01:21:01,000
对你觉得不会发生

1862
01:21:01,000 --> 01:21:04,000
但至少我在我这边

1863
01:21:04,000 --> 01:21:06,000
在我看到的新闻里面

1864
01:21:06,000 --> 01:21:07,000
scala 这是 scala 的目标

1865
01:21:07,000 --> 01:21:09,000
而且欧盟也的确

1866
01:21:09,000 --> 01:21:12,000
欧盟给 scala 扔了很多很多钱

1867
01:21:12,000 --> 01:21:15,000
因为 scala 是某种意义上是一个欧洲语言

1868
01:21:15,000 --> 01:21:17,000
它是德国人开发

1869
01:21:17,000 --> 01:21:18,000
瑞士人制造

1870
01:21:18,000 --> 01:21:20,000
德国人开发瑞士人制造

1871
01:21:20,000 --> 01:21:22,000
基本上是你所能得到的

1872
01:21:22,000 --> 01:21:24,000
编程语言里面最复杂的一种可能性

1873
01:21:25,000 --> 01:21:26,000
对

1874
01:21:26,000 --> 01:21:30,000
就为什么我讲 scala 不可能替代 java 成为主流

1875
01:21:30,000 --> 01:21:34,000
我觉得在工业定性上就已经有这点

1876
01:21:34,000 --> 01:21:35,000
光说一点

1877
01:21:35,000 --> 01:21:37,000
它 scala 的语言规范

1878
01:21:37,000 --> 01:21:39,000
叫一个大布头的书

1879
01:21:39,000 --> 01:21:40,000
才能讲得清楚

1880
01:21:40,000 --> 01:21:41,000
才能讲得完

1881
01:21:41,000 --> 01:21:43,000
然后我觉得这个世界上能够跟它比的

1882
01:21:43,000 --> 01:21:45,000
估计只有 c++了

1883
01:21:45,000 --> 01:21:45,000
对

1884
01:21:45,000 --> 01:21:48,000
c++的现状就是没有任何一个

1885
01:21:48,000 --> 01:21:50,000
纠正我如果我说错的话

1886
01:21:50,000 --> 01:21:53,000
实际上没有任何一个 c++编译器

1887
01:21:53,000 --> 01:21:54,000
是完全

1888
01:21:55,000 --> 01:21:59,000
就是可以符合这个 c++标准

1889
01:21:59,000 --> 01:22:00,000
是不是这样

1890
01:22:00,000 --> 01:22:03,000
我觉得应该是吧

1891
01:22:03,000 --> 01:22:03,000
OK

1892
01:22:03,000 --> 01:22:04,000
对

1893
01:22:04,000 --> 01:22:06,000
然后 scala 也是一个就是属于一个

1894
01:22:06,000 --> 01:22:12,000
就我在我的心目中归类是把它归于 c++同类复杂度的语言

1895
01:22:12,000 --> 01:22:15,000
但是它确实有很多这种很爽的语言特性

1896
01:22:15,000 --> 01:22:17,000
但这不是这次讨论的重点

1897
01:22:17,000 --> 01:22:23,000
但是要提到它是因为要说它的一个包管理器叫做 sbt

1898
01:22:23,000 --> 01:22:24,000
傻变态

1899
01:22:24,000 --> 01:22:25,000
哈哈

1900
01:22:25,000 --> 01:22:28,000
还好你没有选择另外一种更

1901
01:22:28,000 --> 01:22:32,000
那么它特别在哪呢

1902
01:22:32,000 --> 01:22:36,000
它的特别在于它的你知道你心里没有问题是要写这个 xml 吗

1903
01:22:36,000 --> 01:22:36,000
对

1904
01:22:36,000 --> 01:22:39,000
那你知道 xml 本来就不是拿给人写的吗

1905
01:22:39,000 --> 01:22:39,000
对吧

1906
01:22:39,000 --> 01:22:43,000
因为它本来是要给机器生成系统去的吗

1907
01:22:43,000 --> 01:22:44,000
嗯

1908
01:22:44,000 --> 01:22:49,000
sbt 的这个文件是一个 scala 的 DSL

1909
01:22:49,000 --> 01:22:50,000
你可以这么想

1910
01:22:50,000 --> 01:22:51,000
嗯

1911
01:22:51,000 --> 01:22:54,000
对它是相就比 xml 是绝对要简洁很多的

1912
01:22:54,000 --> 01:22:55,000
不过呢

1913
01:22:55,000 --> 01:22:58,000
它作为一个 DSL 呢

1914
01:22:58,000 --> 01:22:59,000
它也有它自己的问题

1915
01:22:59,000 --> 01:23:02,000
就是你首先得知道你能够在这里面写什么

1916
01:23:02,000 --> 01:23:03,000
不能在里面写什么

1917
01:23:03,000 --> 01:23:06,000
就是你要用 sbt 这个包管理器

1918
01:23:06,000 --> 01:23:11,000
首先你得比较熟悉的理解 scala 那套复杂回色的语言规范怎么一回事

1919
01:23:11,000 --> 01:23:13,000
OK

1920
01:23:13,000 --> 01:23:17,000
scala 里面反正有很多很难忘文生义的东西

1921
01:23:17,000 --> 01:23:18,000
这个我是知道的

1922
01:23:18,000 --> 01:23:20,000
对因为它是一个 you know

1923
01:23:20,000 --> 01:23:23,000
它是一个来自学术圈的语言

1924
01:23:23,000 --> 01:23:24,000
你可以这么想吧

1925
01:23:24,000 --> 01:23:24,000
嗯

1926
01:23:25,000 --> 01:23:27,000
难说吧

1927
01:23:27,000 --> 01:23:28,000
作者毕竟也是

1928
01:23:28,000 --> 01:23:29,000
但是

1929
01:23:29,000 --> 01:23:29,000
对

1930
01:23:29,000 --> 01:23:36,000
你可以理解它是一个工业界和学术界都双修的大牛吧

1931
01:23:36,000 --> 01:23:38,000
对因为这个人起码到现在为止

1932
01:23:38,000 --> 01:23:40,000
他是待在这个学习大学里面教书嘛

1933
01:23:40,000 --> 01:23:41,000
对

1934
01:23:41,000 --> 01:23:44,000
待在他美丽的瑞士小城洛桑

1935
01:23:44,000 --> 01:23:46,000
每天看着日内瓦湖

1936
01:23:46,000 --> 01:23:47,000
然后写写编译器

1937
01:23:47,000 --> 01:23:49,000
好悠闲的生活

1938
01:23:49,000 --> 01:23:50,000
教教课

1939
01:23:50,000 --> 01:23:51,000
对他在那个

1940
01:23:51,000 --> 01:23:52,000
洛桑理工

1941
01:23:52,000 --> 01:23:53,000
对

1942
01:23:53,000 --> 01:23:55,000
他在他的联邦里面呢

1943
01:23:55,000 --> 01:23:56,000
工作三分远

1944
01:23:56,000 --> 01:23:56,000
对

1945
01:23:56,000 --> 01:23:58,000
然后他应该是在

1946
01:23:58,000 --> 01:23:59,000
Coursera

1947
01:23:59,000 --> 01:24:02,000
应该是在 Coursera 上面教一门那个公开课

1948
01:24:02,000 --> 01:24:02,000
对

1949
01:24:02,000 --> 01:24:03,000
Functional Programming

1950
01:24:03,000 --> 01:24:06,000
Functional Programming Principles in Scala

1951
01:24:06,000 --> 01:24:07,000
OK

1952
01:24:07,000 --> 01:24:09,000
Martin Odeski

1953
01:24:09,000 --> 01:24:09,000
对

1954
01:24:09,000 --> 01:24:11,000
在这个大牛哈

1955
01:24:11,000 --> 01:24:12,000
德语口音

1956
01:24:12,000 --> 01:24:13,000
长了一口德语

1957
01:24:13,000 --> 01:24:14,000
口音很重的

1958
01:24:14,000 --> 01:24:16,000
长了一张德国人的脸

1959
01:24:16,000 --> 01:24:20,000
但在瑞士的法语去教书

1960
01:24:20,000 --> 01:24:21,000
对

1961
01:24:21,000 --> 01:24:22,000
很奇怪的事

1962
01:24:22,000 --> 01:24:23,000
嗯

1963
01:24:23,000 --> 01:24:24,000
SBT 的

1964
01:24:24,000 --> 01:24:24,000
他的

1965
01:24:24,000 --> 01:24:25,000
就我

1966
01:24:25,000 --> 01:24:27,000
当时学 SKL 的时候

1967
01:24:27,000 --> 01:24:28,000
就是用他来编译东西嘛

1968
01:24:28,000 --> 01:24:29,000
他能够也

1969
01:24:29,000 --> 01:24:31,000
他可以支持加纯加了项目也可以

1970
01:24:31,000 --> 01:24:34,000
然后 SKL 加了混合项目的也可以

1971
01:24:34,000 --> 01:24:35,000
就给我感觉他那套

1972
01:24:35,000 --> 01:24:37,000
就是这个文件

1973
01:24:37,000 --> 01:24:39,000
就是那个配置文件还是比较好写了

1974
01:24:39,000 --> 01:24:40,000
就起码嗯

1975
01:24:40,000 --> 01:24:41,000
比美文好多了

1976
01:24:41,000 --> 01:24:42,000
我觉得

1977
01:24:42,000 --> 01:24:44,000
但吐槽到刚刚也吐了

1978
01:24:44,000 --> 01:24:48,000
就是我对这个东西的理解就因为我没有让他用用过来

1979
01:24:48,000 --> 01:24:49,000
只是他们在学习而已

1980
01:24:49,000 --> 01:24:51,000
没有用什么作为大规模的应用

1981
01:24:51,000 --> 01:24:54,000
所以不太清楚具体使用的时候会怎么样

1982
01:24:54,000 --> 01:24:55,000
但是

1983
01:24:55,000 --> 01:24:55,000
据

1984
01:24:55,000 --> 01:24:59,000
SBT 的用户的描述来讲应该是比

1985
01:24:59,000 --> 01:25:01,000
美文之流要好很多的

1986
01:25:01,000 --> 01:25:02,000
OK

1987
01:25:02,000 --> 01:25:07,000
你确定你说的 DSL 好写是真的吗

1988
01:25:07,000 --> 01:25:10,000
因为我们现在看这个 SBT 教程上面的一段就是

1989
01:25:10,000 --> 01:25:11,000
哇

1990
01:25:11,000 --> 01:25:12,000
这是什么

1991
01:25:12,000 --> 01:25:14,000
为什么一个 build 要有 object

1992
01:25:14,000 --> 01:25:15,000
hello build

1993
01:25:15,000 --> 01:25:16,000
extends build

1994
01:25:16,000 --> 01:25:19,000
就在 build 文件里面居然要用到继承

1995
01:25:19,000 --> 01:25:25,000
或者说非常显示的写出继承关系来

1996
01:25:25,000 --> 01:25:25,000
这个原则是说

1997
01:25:25,000 --> 01:25:25,000
这个原则是说

1998
01:25:25,000 --> 01:25:26,000
原理很简单

1999
01:25:26,000 --> 01:25:28,000
就好像在 Java 里面你没有办法不写一个 class

2000
01:25:28,000 --> 01:25:30,000
进行一个程序一样

2001
01:25:30,000 --> 01:25:32,000
你在 Scalar 里面你至少

2002
01:25:32,000 --> 01:25:34,000
对你在 Scalar 里面你至少得了一个 object

2003
01:25:34,000 --> 01:25:37,000
就是 in Scala everything is an object

2004
01:25:37,000 --> 01:25:39,000
object 在 Scalar 里面相当于

2005
01:25:39,000 --> 01:25:40,000
如果没记错

2006
01:25:40,000 --> 01:25:41,000
相当于 singleton 吧

2007
01:25:41,000 --> 01:25:43,000
对对对

2008
01:25:43,000 --> 01:25:44,000
差不多这个概念

2009
01:25:44,000 --> 01:25:51,000
然后为什么 settings 这个东西前面要有 override lazy valve

2010
01:25:51,000 --> 01:25:55,000
这个时候你就要去研究 Scalar

2011
01:25:55,000 --> 01:25:57,000
这个语言到底本身怎么一回事

2012
01:25:57,000 --> 01:25:58,000
你还得理解他这个文

2013
01:25:58,000 --> 01:26:00,000
就是说他的门槛是蛮高的

2014
01:26:00,000 --> 01:26:03,000
然后但一旦你入了门之后

2015
01:26:03,000 --> 01:26:05,000
which is a long long time

2016
01:26:05,000 --> 01:26:08,000
日经大学入了门之后

2017
01:26:08,000 --> 01:26:11,000
就之后还是写起来还还行

2018
01:26:11,000 --> 01:26:13,000
反正就那套 DS 一旦学会之后

2019
01:26:13,000 --> 01:26:16,000
你能够以一个非常简练的方式把它写出来

2020
01:26:16,000 --> 01:26:18,000
但难度在于你要达到那个简练方式

2021
01:26:18,000 --> 01:26:22,000
你得先读他啃那本那个 Scalar 的那本书

2022
01:26:22,000 --> 01:26:24,000
你就要啃上个什么小半年了吧

2023
01:26:24,000 --> 01:26:25,000
对

2024
01:26:25,000 --> 01:26:28,000
对

2025
01:26:28,000 --> 01:26:34,000
那用那个来管理 Scalar 的这个 project 也是可以的

2026
01:26:34,000 --> 01:26:37,000
但是我很怀疑这件事情的可行之处

2027
01:26:37,000 --> 01:26:39,000
因为确实是太难学了

2028
01:26:39,000 --> 01:26:47,000
我是觉得他应该像很多很多欧盟看好的所有其他项目一样

2029
01:26:47,000 --> 01:26:52,000
因为过度的繁琐而最后被抛弃在历史的车下面

2030
01:26:52,000 --> 01:26:54,000
很有可能

2031
01:26:54,000 --> 01:26:56,000
对

2032
01:26:56,000 --> 01:26:59,000
所以我们就那也这或者从另外一个角度理解

2033
01:26:59,000 --> 01:27:03,000
也是我们这些选择了够或者是选择了更多

2034
01:27:03,000 --> 01:27:11,000
更更更简单的菜鸟们的一种无望的西季吧

2035
01:27:11,000 --> 01:27:13,000
也许他最后还是会像 Java 一样

2036
01:27:13,000 --> 01:27:14,000
Take over the world

2037
01:27:14,000 --> 01:27:21,000
像斯迪迦加一样盘踞在这个 TIOB 的那个排行榜上

2038
01:27:21,000 --> 01:27:23,000
中年阴魂不散

2039
01:27:23,000 --> 01:27:24,000
也不是没有可能的

2040
01:27:24,000 --> 01:27:29,000
现在比如说你像像 Twitter 还有一些什么中度用户都在用这个写他的后台

2041
01:27:29,000 --> 01:27:31,000
那也这种也是可以

2042
01:27:31,000 --> 01:27:32,000
就如果他出现了

2043
01:27:32,000 --> 01:27:35,000
我觉得也也也不难理解嘛

2044
01:27:35,000 --> 01:27:37,000
嗯嗯嗯好

2045
01:27:37,000 --> 01:27:41,000
下面要进入一个终于我们两个都可以共同吐槽的一个

2046
01:27:41,000 --> 01:27:46,000
Python 也就是你的下一份工作要做的事情

2047
01:27:46,000 --> 01:27:51,000
不要以为你从 Java 里面那个那个什么你你你择里面挣脱出来

2048
01:27:51,000 --> 01:27:52,000
你就爽了

2049
01:27:52,000 --> 01:27:54,000
Python 里面坑也不爽了

2050
01:27:54,000 --> 01:27:57,000
我给你讲刚出龙团又入虎穴

2051
01:27:57,000 --> 01:28:03,000
对拍到这个问题其实也是怎么讲历史遗留问题比较多吧

2052
01:28:03,000 --> 01:28:06,000
就首先啊就这样这个事情是蛮讽刺的哈

2053
01:28:06,000 --> 01:28:09,000
就拍上我们都知道他有一个哲学嘛

2054
01:28:09,000 --> 01:28:14,000
就是这是 one and hopefully only one obvious way to do things

2055
01:28:14,000 --> 01:28:14,000
对

2056
01:28:14,000 --> 01:28:19,000
然后一边高举高唱这个口号一边出了拍照拍到三

2057
01:28:19,000 --> 01:28:23,000
然后又有了 set of tools 和和和和很多的东西啊

2058
01:28:23,000 --> 01:28:24,000
然后又有了 set of tools 和和和很多的东西啊

2059
01:28:24,000 --> 01:28:27,000
和呃不止啊还多着呢

2060
01:28:27,000 --> 01:28:29,000
最开始有这个有 set up tools

2061
01:28:29,000 --> 01:28:32,000
有 distill your tears

2062
01:28:32,000 --> 01:28:34,000
有 peep 有 build out

2063
01:28:34,000 --> 01:28:35,000
这些是比较老的

2064
01:28:35,000 --> 01:28:36,000
是啥啊

2065
01:28:36,000 --> 01:28:37,000
我会给你解释

2066
01:28:37,000 --> 01:28:39,000
这是个很神奇的存在

2067
01:28:39,000 --> 01:28:40,000
OK 嗯

2068
01:28:40,000 --> 01:28:43,000
然后后来有大家后来觉得这个事情玩不下去了

2069
01:28:43,000 --> 01:28:46,000
后来出现那个叫什么啊

2070
01:28:46,000 --> 01:28:49,000
distill 2

2071
01:28:49,000 --> 01:28:54,000
所以你看这个这一个标榜者这里这一个标榜只有一通常

2072
01:28:54,000 --> 01:28:57,000
一个正确的方式做事的语言

2073
01:28:57,000 --> 01:29:00,000
有着五六七八种

2074
01:29:00,000 --> 01:29:01,000
包管理工具

2075
01:29:01,000 --> 01:29:04,000
对有这五六七八种不同的做事的方式

2076
01:29:04,000 --> 01:29:08,000
而且他们互相之间是不太兼容的

2077
01:29:08,000 --> 01:29:11,000
但我觉得这也可能也不能完全怪 pison

2078
01:29:11,000 --> 01:29:18,000
他的设计理念并不能保证他所确认的那种方式就是大家最喜欢的

2079
01:29:18,000 --> 01:29:23,000
或者是大家最觉得与时俱进的方式

2080
01:29:23,000 --> 01:29:24,000
对

2081
01:29:24,000 --> 01:29:24,000
所以

2082
01:29:24,000 --> 01:29:25,000
,其实这就是一个是跟你讲嘛

2083
01:29:25,000 --> 01:29:27,000
是一个历史一个遗留的问题

2084
01:29:27,000 --> 01:29:29,000
因为他刚才提到那些工具

2085
01:29:29,000 --> 01:29:33,000
他出现的是就他的最开始的版本出现都比较早

2086
01:29:33,000 --> 01:29:36,000
其实在过去这么十几年中

2087
01:29:36,000 --> 01:29:38,000
我们对这个包管理的很多认识啊

2088
01:29:38,000 --> 01:29:39,000
包括这个网络技术设施

2089
01:29:39,000 --> 01:29:42,000
其实发生过很大很大的这个变化

2090
01:29:42,000 --> 01:29:44,000
但是他那些工具呢

2091
01:29:44,000 --> 01:29:46,000
就没有太跟得上时代吧

2092
01:29:46,000 --> 01:29:47,000
你可以这么想

2093
01:29:47,000 --> 01:29:50,000
而且另外一个比较显著的问题是说

2094
01:29:50,000 --> 01:29:53,000
因为拍上他通常是在威尼克斯发行版里面

2095
01:29:53,000 --> 01:29:54,000
作为系统

2096
01:29:54,000 --> 01:29:56,000
组件之一发行的

2097
01:29:56,000 --> 01:30:01,000
那么对导致一个很严重的问题就是如果那个系统发行版不升级的话

2098
01:30:01,000 --> 01:30:04,000
那个绑定的拍上的版本也是不升级的

2099
01:30:04,000 --> 01:30:12,000
这样在实际使用的时候就会出现一个非常多的不同的版本要支持

2100
01:30:12,000 --> 01:30:13,000
这个互相之间

2101
01:30:13,000 --> 01:30:16,000
不同版本他们之间的兼容性又是有问题的

2102
01:30:16,000 --> 01:30:17,000
所以在这么一个

2103
01:30:17,000 --> 01:30:19,000
就是说在漫漫长的历史场合中

2104
01:30:19,000 --> 01:30:21,000
散落下这么多版本

2105
01:30:21,000 --> 01:30:23,000
然后你作为一个包管理器的编写者

2106
01:30:23,000 --> 01:30:23,000
你也去很难

2107
01:30:23,000 --> 01:30:26,000
很难说能够那个什么的 wan

2108
01:30:26,000 --> 01:30:28,000
三个费尔摩对吧

2109
01:30:28,000 --> 01:30:30,000
对嗯对

2110
01:30:30,000 --> 01:30:31,000
但是这并不能改变

2111
01:30:31,000 --> 01:30:33,000
我们要吐槽他这件事实啊

2112
01:30:33,000 --> 01:30:34,000
因为他确实就是很糟糕

2113
01:30:36,000 --> 01:30:42,000
对他拍上的这个每个拍上他自己有一个这个发行的这个一个一个渠道吧

2114
01:30:42,000 --> 01:30:44,000
就是他自己会有可以官方下载

2115
01:30:44,000 --> 01:30:47,000
但是更多的时候用的是从系统里面自带的

2116
01:30:47,000 --> 01:30:49,000
他每个系统面自带的又是某一个版本

2117
01:30:49,000 --> 01:30:53,000
他会标准库里面会有这么一个叫做塞拉布兔是吧

2118
01:30:53,000 --> 01:30:53,000
对

2119
01:30:53,000 --> 01:30:54,000
对

2120
01:30:54,000 --> 01:30:57,000
然后这个东西的命令行的体现应该是叫什么

2121
01:30:57,000 --> 01:30:58,000
ez install

2122
01:30:58,000 --> 01:30:59,000
ez install

2123
01:30:59,000 --> 01:31:00,000
ez underline install

2124
01:31:00,000 --> 01:31:03,000
对他的问题是

2125
01:31:04,000 --> 01:31:07,000
他只能 install 不能 uninstall

2126
01:31:10,000 --> 01:31:13,000
你会发现 ez install 好简单好方便啊

2127
01:31:13,000 --> 01:31:16,000
那怎么 ez uninstall 好像没有这个命令

2128
01:31:18,000 --> 01:31:21,000
ez install hard manually uninstall

2129
01:31:21,000 --> 01:31:22,000
对对

2130
01:31:22,000 --> 01:31:23,000
就你会觉得这个方法很简单啊

2131
01:31:24,000 --> 01:31:24,000
好

2132
01:31:32,000 --> 01:31:33,000
没事

2133
01:31:33,000 --> 01:31:33,000
所以说

2134
01:31:33,000 --> 01:31:34,000
这

2135
01:31:35,000 --> 01:31:38,000
我可以把这个背景都把 trumpking Poly deriv 产 像这样大和

2136
01:31:38,000 --> 01:31:40,000
三个修理房间一个按钮

2137
01:31:41,000 --> 01:31:41,000
然后就什么我们

2138
01:31:41,000 --> 01:31:42,000
都能直接进来

2139
01:31:43,000 --> 01:31:43,000
以后

2140
01:31:43,000 --> 01:31:44,000
一直里面

2141
01:31:44,000 --> 01:31:45,000
我都不会 twin-channel

2142
01:31:45,000 --> 01:31:45,000
很异常

2143
01:31:45,000 --> 01:31:45,000
你知道吗

2144
01:31:45,000 --> 01:31:46,000
那一旦做一个粗末调变

2145
01:31:46,000 --> 01:31:53,000
从这里

2146
01:31:53,000 --> 01:31:55,000
只有 Easy Install 而已

2147
01:31:55,000 --> 01:31:57,000
给的感觉就很像

2148
01:31:57,000 --> 01:31:59,000
中国的很多流氓软件

2149
01:31:59,000 --> 01:32:01,000
很方便的装上去

2150
01:32:01,000 --> 01:32:02,000
管啥不管买

2151
01:32:02,000 --> 01:32:04,000
这不叫一键式安装

2152
01:32:04,000 --> 01:32:05,000
就无键式安装

2153
01:32:05,000 --> 01:32:07,000
你不装它都给你装了

2154
01:32:07,000 --> 01:32:08,000
但是发现装的时候

2155
01:32:08,000 --> 01:32:10,000
就没法回头了

2156
01:32:10,000 --> 01:32:13,000
对 有这么一个问题

2157
01:32:13,000 --> 01:32:15,000
而且它这个 Easy Install

2158
01:32:15,000 --> 01:32:16,000
它并不支持

2159
01:32:16,000 --> 01:32:19,000
全部的 Tubectron 的安装

2160
01:32:19,000 --> 01:32:20,000
安装的很多

2161
01:32:20,000 --> 01:32:22,000
就发现装盘据报错

2162
01:32:22,000 --> 01:32:23,000
装不了

2163
01:32:23,000 --> 01:32:24,000
不支持这个格式

2164
01:32:24,000 --> 01:32:25,000
因为它也是对

2165
01:32:25,000 --> 01:32:26,000
软件包的这种

2166
01:32:26,000 --> 01:32:27,000
所有的 layout

2167
01:32:27,000 --> 01:32:28,000
或者这种封装方式

2168
01:32:28,000 --> 01:32:30,000
包括那些文件里面

2169
01:32:30,000 --> 01:32:32,000
要填什么 meta 的信息

2170
01:32:32,000 --> 01:32:33,000
它都是有一些要求的

2171
01:32:33,000 --> 01:32:34,000
但是并不是所有

2172
01:32:34,000 --> 01:32:36,000
因为这个四分五

2173
01:32:36,000 --> 01:32:37,000
列了这么一个

2174
01:32:37,000 --> 01:32:38,000
生态圈的状况

2175
01:32:38,000 --> 01:32:40,000
并不是所有的软件包

2176
01:32:40,000 --> 01:32:40,000
都是觉得

2177
01:32:40,000 --> 01:32:42,000
要用这个方式来写的

2178
01:32:42,000 --> 01:32:44,000
而且据我所知

2179
01:32:44,000 --> 01:32:44,000
应该大部分人

2180
01:32:44,000 --> 01:32:46,000
都不是不用那个方式来写

2181
01:32:46,000 --> 01:32:49,000
对 我记得当年

2182
01:32:49,000 --> 01:32:51,000
听说 Guido

2183
01:32:51,000 --> 01:32:52,000
是什么 Dict

2184
01:32:52,000 --> 01:32:52,000
的时候

2185
01:32:52,000 --> 01:32:54,000
我心里还觉得

2186
01:32:54,000 --> 01:32:55,000
我靠 有个 Dict

2187
01:32:55,000 --> 01:32:56,000
难道不会站出来

2188
01:32:56,000 --> 01:32:57,000
管一管这件事情吗

2189
01:32:57,000 --> 01:33:00,000
但事实上

2190
01:33:00,000 --> 01:33:01,000
有一件一个不管事的

2191
01:33:01,000 --> 01:33:03,000
对 在我们

2192
01:33:03,000 --> 01:33:04,000
如果对比一下

2193
01:33:04,000 --> 01:33:05,000
Python 社区和 Ruby 社区的时候

2194
01:33:05,000 --> 01:33:07,000
就会发现 Ruby 的

2195
01:33:07,000 --> 01:33:10,000
虽然我们默默鄙视着

2196
01:33:10,000 --> 01:33:10,000
Ruby 社区的人

2197
01:33:10,000 --> 01:33:12,000
但是 Ruby 社区有一点好

2198
01:33:12,000 --> 01:33:16,000
就是当 Math 说一句

2199
01:33:16,000 --> 01:33:17,000
大家升级到 2.08

2200
01:33:17,000 --> 01:33:18,000
所有人都升级到 2.08

2201
01:33:18,000 --> 01:33:20,000
而我们现在

2202
01:33:20,000 --> 01:33:21,000
我记得刚刚前几天

2203
01:33:21,000 --> 01:33:22,000
还说了一句

2204
01:33:22,000 --> 01:33:23,000
我发到一封邮件

2205
01:33:23,000 --> 01:33:25,000
让我们在投票说

2206
01:33:25,000 --> 01:33:27,000
你觉得 Python 3 是一个错误吗

2207
01:33:27,000 --> 01:33:29,000
必然是

2208
01:33:29,000 --> 01:33:31,000
现在的状况来看

2209
01:33:31,000 --> 01:33:32,000
对

2210
01:33:32,000 --> 01:33:32,000
anyway

2211
01:33:32,000 --> 01:33:34,000
Python 3 本意是好的

2212
01:33:34,000 --> 01:33:35,000
但目前的现状

2213
01:33:35,000 --> 01:33:37,000
毫无疑问是个错误

2214
01:33:37,000 --> 01:33:39,000
Python 语言吐槽

2215
01:33:39,000 --> 01:33:41,000
这个单独在吐槽

2216
01:33:41,000 --> 01:33:42,000
这里只吐槽它的发布工具

2217
01:33:42,000 --> 01:33:44,000
所以这里其实也是体现了

2218
01:33:44,000 --> 01:33:45,000
这一个问题

2219
01:33:45,000 --> 01:33:47,000
就是 Python 还有一句口号

2220
01:33:47,000 --> 01:33:49,000
叫做 Batteries Included

2221
01:33:49,000 --> 01:33:49,000
叫什么

2222
01:33:49,000 --> 01:33:51,000
自带电池

2223
01:33:51,000 --> 01:33:52,000
自带电池

2224
01:33:52,000 --> 01:33:52,000
自带电池

2225
01:33:52,000 --> 01:33:53,000
它这个标准库里面

2226
01:33:53,000 --> 01:33:54,000
自带了这个 Setup 2

2227
01:33:54,000 --> 01:33:56,000
这么一个标准的安装包

2228
01:33:56,000 --> 01:33:58,000
但是就和它的标准库里面

2229
01:33:58,000 --> 01:34:00,000
其他很多 Batteries 一样

2230
01:34:00,000 --> 01:34:02,000
它们都是 Dead on Arrival

2231
01:34:02,000 --> 01:34:04,000
已经至少是五年旧的电池了

2232
01:34:04,000 --> 01:34:05,000
而且装进去的时候

2233
01:34:05,000 --> 01:34:06,000
根本没有

2234
01:34:06,000 --> 01:34:06,000
直接没电

2235
01:34:06,000 --> 01:34:08,000
装进去的时候

2236
01:34:08,000 --> 01:34:11,000
根本没有做这个绝缘

2237
01:34:11,000 --> 01:34:14,000
导致你拿到机器拆开之后

2238
01:34:14,000 --> 01:34:16,000
发现电池已经烂在里面了

2239
01:34:16,000 --> 01:34:17,000
那个电池电浆

2240
01:34:17,000 --> 01:34:18,000
已经跑出来的感觉

2241
01:34:18,000 --> 01:34:20,000
对

2242
01:34:20,000 --> 01:34:22,000
他们带了一个很烂的工具

2243
01:34:22,000 --> 01:34:23,000
然后没法用

2244
01:34:23,000 --> 01:34:24,000
然后有人想办法

2245
01:34:24,000 --> 01:34:26,000
我们再解决

2246
01:34:26,000 --> 01:34:27,000
后来就出了什么

2247
01:34:27,000 --> 01:34:30,000
我这么说其实不对

2248
01:34:30,000 --> 01:34:31,000
但是为了把这个故事讲下去

2249
01:34:31,000 --> 01:34:32,000
就这么说

2250
01:34:32,000 --> 01:34:33,000
后来就出了什么

2251
01:34:33,000 --> 01:34:35,000
Distill Teal 这么一个工具

2252
01:34:35,000 --> 01:34:38,000
说试图解决 Setup Tools 的各种问题

2253
01:34:38,000 --> 01:34:42,000
但其实后来也发现也没解决掉

2254
01:34:42,000 --> 01:34:44,000
然后又多了这么一个碎片

2255
01:34:44,000 --> 01:34:47,000
又多了一个工具要支持

2256
01:34:47,000 --> 01:34:49,000
然后 Distill Teal 也不是特别友好

2257
01:34:49,000 --> 01:34:50,000
我觉得

2258
01:34:50,000 --> 01:34:52,000
我的印象是

2259
01:34:52,000 --> 01:34:55,000
我几乎从来没有怎么用过 Distill Teal

2260
01:34:55,000 --> 01:34:56,000
Trust me

2261
01:34:56,000 --> 01:34:56,000
你肯定用过

2262
01:34:56,000 --> 01:34:58,000
只是你不知道而已

2263
01:34:58,000 --> 01:34:58,000
What

2264
01:34:58,000 --> 01:35:00,000
他 3 号应该和 Setup Tools

2265
01:35:00,000 --> 01:35:02,000
有点这种扯无亲到不明的关系

2266
01:35:02,000 --> 01:35:04,000
最新的说法是这两个东西要融合了

2267
01:35:04,000 --> 01:35:07,000
就是在

2268
01:35:07,000 --> 01:35:10,000
叫再催生出第三个怪胎来是吗

2269
01:35:10,000 --> 01:35:10,000
对

2270
01:35:10,000 --> 01:35:11,000
就是因为他们

2271
01:35:11,000 --> 01:35:14,000
Setup Tools 那帮人和 Distill Teal 这帮人

2272
01:35:14,000 --> 01:35:15,000
开发的后来发现不行

2273
01:35:15,000 --> 01:35:19,000
我们各自为政搞一套新版本

2274
01:35:19,000 --> 01:35:21,000
首先和自己过去不兼容

2275
01:35:21,000 --> 01:35:22,000
然后和对方不兼容

2276
01:35:22,000 --> 01:35:22,000
对吧?

2277
01:35:22,000 --> 01:35:23,000
本本就二变四了

2278
01:35:23,000 --> 01:35:23,000
对吧?

2279
01:35:23,000 --> 01:35:24,000
这就很沮丧

2280
01:35:24,000 --> 01:35:26,000
所以后来他们说算了

2281
01:35:26,000 --> 01:35:28,000
我们还是合作一把

2282
01:35:28,000 --> 01:35:32,000
所以以后的什么 Distill Teal 2 和 Setup Tools

2283
01:35:32,000 --> 01:35:34,000
的下一个版本应该是融合在一起的

2284
01:35:34,000 --> 01:35:35,000
然后具体叫什么

2285
01:35:35,000 --> 01:35:36,000
我现在已经不知道了

2286
01:35:36,000 --> 01:35:38,000
我已经放弃理解他们的行为了

2287
01:35:38,000 --> 01:35:42,000
我觉得已经 Beyond my comprehension

2288
01:35:42,000 --> 01:35:42,000
OK

2289
01:35:42,000 --> 01:35:45,000
但是那个美好的局面还没有出现

2290
01:35:45,000 --> 01:35:45,000
是吗?

2291
01:35:45,000 --> 01:35:48,000
到目前为止还是一个挺令人沮丧的情况

2292
01:35:48,000 --> 01:35:50,000
后来也有人受不了了

2293
01:35:50,000 --> 01:35:52,000
就是出现了一个弹弹

2294
01:35:52,000 --> 01:35:52,000
大牛吧

2295
01:35:52,000 --> 01:35:53,000
名字忘了

2296
01:35:53,000 --> 01:35:55,000
大家写了叫 PIP 的工具

2297
01:35:55,000 --> 01:35:56,000
PIP

2298
01:35:56,000 --> 01:35:57,000
对

2299
01:35:57,000 --> 01:36:00,000
其实你刚才说我们要一起吐槽 Python

2300
01:36:00,000 --> 01:36:01,000
我心里默默低估一句

2301
01:36:01,000 --> 01:36:03,000
我现在其实不需要怎么吐槽 Python 了

2302
01:36:03,000 --> 01:36:04,000
我也是

2303
01:36:04,000 --> 01:36:05,000
我已经放弃了

2304
01:36:05,000 --> 01:36:08,000
我把 Painful 的部分就默默绕过了

2305
01:36:08,000 --> 01:36:11,000
比如说我会用 Python Z

2306
01:36:11,000 --> 01:36:12,000
就是 Python Z

2307
01:36:12,000 --> 01:36:14,000
装好几个版本的 Python

2308
01:36:14,000 --> 01:36:17,000
然后每次跑什么东西的时候

2309
01:36:17,000 --> 01:36:19,000
就选择一个 Python

2310
01:36:19,000 --> 01:36:22,000
然后再如果需要什么 package 的话

2311
01:36:22,000 --> 01:36:26,000
我用 Python 在该版本的 Python 之下

2312
01:36:26,000 --> 01:36:29,000
只供该版本的 Python 使用的 package

2313
01:36:29,000 --> 01:36:31,000
你是这样玩

2314
01:36:31,000 --> 01:36:33,000
好像也没有什么太痛苦的部分

2315
01:36:33,000 --> 01:36:34,000
你肯定是装的还不够多

2316
01:36:34,000 --> 01:36:36,000
总会装多了

2317
01:36:36,000 --> 01:36:37,000
总会遇到坑的

2318
01:36:37,000 --> 01:36:38,000
这个是一定的

2319
01:36:38,000 --> 01:36:43,000
当年之前我前几年在知乎工作的时候

2320
01:36:43,000 --> 01:36:45,000
就有遇到这个比较令人沮丧的状况

2321
01:36:45,000 --> 01:36:48,000
因为我们用了 Python 的包比较多

2322
01:36:48,000 --> 01:36:48,000
比较杂

2323
01:36:48,000 --> 01:36:50,000
然后其实是挺痛苦的

2324
01:36:50,000 --> 01:36:51,000
对

2325
01:36:51,000 --> 01:36:51,000
一定是我还没有用过的包子

2326
01:36:51,000 --> 01:36:56,000
我还没有进入到企业级 Python 的世界

2327
01:36:56,000 --> 01:36:57,000
对

2328
01:36:57,000 --> 01:37:00,000
不过我的解决方案比你更加决绝

2329
01:37:00,000 --> 01:37:02,000
首先我现在已经不在知乎了

2330
01:37:02,000 --> 01:37:04,000
已经一直好久了

2331
01:37:04,000 --> 01:37:07,000
然后另外我也不再写 Python 相关的东西了

2332
01:37:07,000 --> 01:37:10,000
就全面转向 Go 和 Node

2333
01:37:10,000 --> 01:37:11,000
OK

2334
01:37:11,000 --> 01:37:13,000
就直接避免了这个问题

2335
01:37:13,000 --> 01:37:16,000
你现在在搞学术的时候用的是什么工具

2336
01:37:16,000 --> 01:37:18,000
我这

2337
01:37:18,000 --> 01:37:20,000
Node

2338
01:37:20,000 --> 01:37:21,000
你敢信吗

2339
01:37:21,000 --> 01:37:21,000
对

2340
01:37:21,000 --> 01:37:23,000
Node

2341
01:37:23,000 --> 01:37:23,000
Demo 的

2342
01:37:23,000 --> 01:37:24,000
Seriously

2343
01:37:24,000 --> 01:37:26,000
因为要做一个 Demo

2344
01:37:26,000 --> 01:37:29,000
然后这个东西这个场景比较适合在浏览器里面搞

2345
01:37:29,000 --> 01:37:30,000
OK

2346
01:37:30,000 --> 01:37:32,000
所以 JavaScript

2347
01:37:32,000 --> 01:37:34,000
然后必然就跟 Node 撤不掉关系了

2348
01:37:34,000 --> 01:37:36,000
这个问题就会再说

2349
01:37:36,000 --> 01:37:38,000
现在接着说回 Python 这个东西

2350
01:37:38,000 --> 01:37:41,000
就有人也受不了各种四分五裂局面

2351
01:37:41,000 --> 01:37:43,000
他又搞出一个又不见

2352
01:37:43,000 --> 01:37:44,000
也不叫又不见

2353
01:37:44,000 --> 01:37:46,000
就大部分情况下兼容

2354
01:37:46,000 --> 01:37:49,000
只有小部分什么不兼容的工具叫 PIP

2355
01:37:49,000 --> 01:37:51,000
叫 Pipe 还是 Peep?

2356
01:37:51,000 --> 01:37:52,000
Peep 吧

2357
01:37:52,000 --> 01:37:54,000
我一般念 Peep

2358
01:37:54,000 --> 01:37:57,000
他的好处就是他支持 Uninstall

2359
01:37:57,000 --> 01:37:58,000
耶

2360
01:37:58,000 --> 01:37:59,000
耶

2361
01:37:59,000 --> 01:37:59,000
就是非常

2362
01:37:59,000 --> 01:38:05,000
一个包括那些综艺家族的一个 Uninstall 的功能也好耶

2363
01:38:05,000 --> 01:38:09,000
听起来有点奇怪

2364
01:38:09,000 --> 01:38:10,000
为什么好像有点

2365
01:38:10,000 --> 01:38:11,000
对啊

2366
01:38:11,000 --> 01:38:11,000
难道不是

2367
01:38:11,000 --> 01:38:12,000
很炒热

2368
01:38:12,000 --> 01:38:13,000
对

2369
01:38:13,000 --> 01:38:16,000
普通用户已经用了十几年的功能

2370
01:38:16,000 --> 01:38:17,000
Peep 有什么好呢

2371
01:38:17,000 --> 01:38:19,000
就是他首先支持

2372
01:38:19,000 --> 01:38:22,000
就是支持这个卸载

2373
01:38:22,000 --> 01:38:24,000
这个是很大的一个进步

2374
01:38:24,000 --> 01:38:25,000
然后第二个我觉得比较重要的

2375
01:38:25,000 --> 01:38:28,000
他支持一个所谓的版本冻结

2376
01:38:28,000 --> 01:38:31,000
对就是 Peep Freeze

2377
01:38:31,000 --> 01:38:33,000
对你可以装好一堆包之后

2378
01:38:33,000 --> 01:38:34,000
你可以说好

2379
01:38:34,000 --> 01:38:38,000
我这个我这个什么我这个什么开发环境搭建好了

2380
01:38:38,000 --> 01:38:40,000
看一下有什么版本的包我是依赖的

2381
01:38:40,000 --> 01:38:42,000
然后你用 Peep Freeze 一下

2382
01:38:42,000 --> 01:38:44,000
然后你还会返回一个列表

2383
01:38:44,000 --> 01:38:47,000
说你当前装了哪些呃 Python 的这个包

2384
01:38:47,000 --> 01:38:49,000
然后那个包是哪些版本对吧

2385
01:38:49,000 --> 01:38:50,000
嗯

2386
01:38:50,000 --> 01:38:52,000
你申请一个列表

2387
01:38:52,000 --> 01:38:53,000
下次你再用那个列表

2388
01:38:53,000 --> 01:38:55,000
然后在 Peep 再装一遍

2389
01:38:55,000 --> 01:38:58,000
他就会按照那个列表一行一行的去给你装对应的版本就好了

2390
01:38:58,000 --> 01:39:00,000
就 hopefully it works

2391
01:39:00,000 --> 01:39:01,000
哈哈哈

2392
01:39:01,000 --> 01:39:06,000
而且以我有限的 hobby list 的经验来看

2393
01:39:06,000 --> 01:39:08,000
基本上 99%的时间他是 works

2394
01:39:08,000 --> 01:39:09,000
对啊

2395
01:39:09,000 --> 01:39:10,000
但这也是因为你在国外

2396
01:39:10,000 --> 01:39:12,000
你不知道中国人民的痛苦

2397
01:39:12,000 --> 01:39:13,000
嗯

2398
01:39:13,000 --> 01:39:14,000
哈哈

2399
01:39:14,000 --> 01:39:17,000
可是我听说贵网站写下来是机密

2400
01:39:17,000 --> 01:39:18,000
机密内容

2401
01:39:18,000 --> 01:39:19,000
听众情务

2402
01:39:19,000 --> 01:39:21,000
互相泄露

2403
01:39:21,000 --> 01:39:26,000
就是贵站难道不是内部直接 VPN 翻墙的吗

2404
01:39:26,000 --> 01:39:26,000
啊

2405
01:39:26,000 --> 01:39:29,000
但是你知道即便是这样翻墙

2406
01:39:29,000 --> 01:39:30,000
网络也是不稳定的嘛

2407
01:39:30,000 --> 01:39:34,000
就是你如果用到东西是网络的话

2408
01:39:34,000 --> 01:39:35,000
你首先要假设一点

2409
01:39:35,000 --> 01:39:37,000
网络是可以随时断掉的

2410
01:39:37,000 --> 01:39:40,000
他可能会在你最不希望他断断时间断掉

2411
01:39:40,000 --> 01:39:40,000
OK

2412
01:39:40,000 --> 01:39:41,000
莫非定律

2413
01:39:41,000 --> 01:39:42,000
对

2414
01:39:42,000 --> 01:39:43,000
基本上是这样

2415
01:39:43,000 --> 01:39:45,000
就是如果你一旦做了什么企业的运维

2416
01:39:45,000 --> 01:39:47,000
之后你发现这个件事情是一定成立的

2417
01:39:47,000 --> 01:39:48,000
哈哈哈

2418
01:39:48,000 --> 01:39:48,000
对啊

2419
01:39:48,000 --> 01:39:48,000
嗯

2420
01:39:48,000 --> 01:39:55,000
其实这就是有一次 Maven 导致我们发布推迟的原因之一

2421
01:39:55,000 --> 01:39:56,000
就是我们 Nexus 挂掉了

2422
01:39:56,000 --> 01:39:56,000
啊

2423
01:39:56,000 --> 01:39:58,000
不是不是连不上网络

2424
01:39:58,000 --> 01:39:59,000
而是 Nexus 挂掉了

2425
01:39:59,000 --> 01:40:04,000
就 Nexus 是 Maven 这一套系统里面的一个

2426
01:40:04,000 --> 01:40:07,000
或者说支持 Maven 系统很重要的一个特征

2427
01:40:07,000 --> 01:40:12,000
就是你可以自定义一个包管理服务器

2428
01:40:12,000 --> 01:40:12,000
嗯

2429
01:40:12,000 --> 01:40:15,000
然后把你生你写好的软件

2430
01:40:15,000 --> 01:40:16,000
呃

2431
01:40:16,000 --> 01:40:18,000
作为一个源

2432
01:40:18,000 --> 01:40:18,000
呃

2433
01:40:18,000 --> 01:40:18,000
呃

2434
01:40:18,000 --> 01:40:18,000
呃

2435
01:40:18,000 --> 01:40:18,000
呃

2436
01:40:18,000 --> 01:40:18,000
呃

2437
01:40:18,000 --> 01:40:18,000
呃

2438
01:40:18,000 --> 01:40:18,000
呃

2439
01:40:18,000 --> 01:40:18,000
呃

2440
01:40:18,000 --> 01:40:22,000
呃

2441
01:40:22,000 --> 01:40:22,000
呃

2442
01:40:22,000 --> 01:40:22,000
呃

2443
01:40:22,000 --> 01:40:24,000
呃

2444
01:40:24,000 --> 01:40:27,000
呃

2445
01:40:27,000 --> 01:40:28,000
呃

2446
01:40:28,000 --> 01:40:30,000
呃

2447
01:40:30,000 --> 01:40:30,000
呃

2448
01:40:30,000 --> 01:40:32,000
呃

2449
01:40:32,000 --> 01:40:33,000
呃

2450
01:40:33,000 --> 01:40:33,000
呃

2451
01:40:33,000 --> 01:40:35,000
呃

2452
01:40:35,000 --> 01:40:35,000
呃

2453
01:40:35,000 --> 01:40:41,000
呃

2454
01:40:44,000 --> 01:40:44,000
呃

2455
01:40:44,000 --> 01:40:44,000
呃

2456
01:40:44,000 --> 01:40:45,000
呃

2457
01:40:45,000 --> 01:40:45,000
呃

2458
01:40:45,000 --> 01:40:45,000
呃

2459
01:40:45,000 --> 01:40:45,000
呃

2460
01:40:45,000 --> 01:40:45,000
呃

2461
01:40:45,000 --> 01:40:46,000
呃

2462
01:40:46,000 --> 01:40:46,000
呃

2463
01:40:46,000 --> 01:40:46,000
呃

2464
01:40:46,000 --> 01:40:46,000
呃

2465
01:40:46,000 --> 01:40:46,000
呃

2466
01:40:46,000 --> 01:40:48,000
〈單点失败〉

2467
01:40:48,000 --> 01:40:48,000
对

2468
01:40:48,000 --> 01:40:48,000
嗯

2469
01:40:48,000 --> 01:40:51,000
把所有的鸡蛋放在一个篮子里

2470
01:40:51,000 --> 01:40:53,000
是非常愚蠢的一件事情

2471
01:40:53,000 --> 01:40:53,000
但

2472
01:40:53,000 --> 01:40:54,000
对

2473
01:40:54,000 --> 01:40:55,000
当然

2474
01:40:55,000 --> 01:40:57,000
对

2475
01:40:57,000 --> 01:40:58,000
但其实刚才讲的

2476
01:40:58,000 --> 01:40:59,000
I don't blame you

2477
01:40:59,000 --> 01:41:03,000
刚才讲的那些

2478
01:41:03,000 --> 01:41:04,000
就是 Python 的三个

2479
01:41:04,000 --> 01:41:06,000
三大工具吧

2480
01:41:06,000 --> 01:41:06,000
都是

2481
01:41:06,000 --> 01:41:08,000
他们都依赖于同样一个东西

2482
01:41:08,000 --> 01:41:09,000
叫做

2483
01:41:09,000 --> 01:41:11,000
PYPI

2484
01:41:11,000 --> 01:41:12,000
叫 PyP 吧

2485
01:41:12,000 --> 01:41:14,000
叫 Python Package Index

2486
01:41:14,000 --> 01:41:15,000
对

2487
01:41:15,000 --> 01:41:16,000
Python Package Index

2488
01:41:16,000 --> 01:41:17,000
对

2489
01:41:17,000 --> 01:41:18,000
我不知道到 PyPy 叫 PyP

2490
01:41:18,000 --> 01:41:19,000
我就叫 PyPy 吧

2491
01:41:19,000 --> 01:41:20,000
PyPy 吧

2492
01:41:20,000 --> 01:41:21,000
PyPy 是另外一个东西

2493
01:41:21,000 --> 01:41:23,000
PYPY 又是另外一个东西了

2494
01:41:23,000 --> 01:41:24,000
对

2495
01:41:24,000 --> 01:41:25,000
这里就不说

2496
01:41:25,000 --> 01:41:27,000
先讲这个 PyPy 吧

2497
01:41:27,000 --> 01:41:29,000
PyPy 呢

2498
01:41:29,000 --> 01:41:29,000
是一个什么

2499
01:41:29,000 --> 01:41:31,000
就是它是一个 Python

2500
01:41:31,000 --> 01:41:32,000
这个

2501
01:41:32,000 --> 01:41:34,000
这个 Foundation

2502
01:41:34,000 --> 01:41:36,000
Python Software Foundation

2503
01:41:36,000 --> 01:41:37,000
维护的一个中央服务器

2504
01:41:37,000 --> 01:41:39,000
就是你们那个 Nexus 差不多

2505
01:41:39,000 --> 01:41:40,000
但是它是通过网络访问的

2506
01:41:40,000 --> 01:41:43,000
然后你每次 PyPy install

2507
01:41:43,000 --> 01:41:43,000
或者 DST

2508
01:41:43,000 --> 01:41:45,000
去什么 Easy install 的时候

2509
01:41:45,000 --> 01:41:47,000
它都要去那里

2510
01:41:47,000 --> 01:41:47,000
去下载

2511
01:41:47,000 --> 01:41:48,000
搜一遍

2512
01:41:48,000 --> 01:41:50,000
你那个要装上哪个名字

2513
01:41:50,000 --> 01:41:50,000
然后在哪里

2514
01:41:50,000 --> 01:41:51,000
找到那个位置

2515
01:41:51,000 --> 01:41:52,000
去下载回来

2516
01:41:52,000 --> 01:41:53,000
不是找到

2517
01:41:53,000 --> 01:41:54,000
它应该是传到那里

2518
01:41:54,000 --> 01:41:55,000
一个服务器上

2519
01:41:55,000 --> 01:41:55,000
直接下载回来

2520
01:41:55,000 --> 01:41:57,000
它有一个 FTP 服务器吧

2521
01:41:57,000 --> 01:41:57,000
你可以这么想

2522
01:41:57,000 --> 01:42:00,000
然后它经常挂掉

2523
01:42:00,000 --> 01:42:02,000
OK

2524
01:42:02,000 --> 01:42:03,000
它挂掉的

2525
01:42:03,000 --> 01:42:04,000
就是它挂掉的

2526
01:42:04,000 --> 01:42:06,000
这个概率之频繁

2527
01:42:06,000 --> 01:42:07,000
真是令我

2528
01:42:07,000 --> 01:42:08,000
令我堂目结舌

2529
01:42:08,000 --> 01:42:11,000
是在你们公司挂掉

2530
01:42:11,000 --> 01:42:12,000
就是在你

2531
01:42:12,000 --> 01:42:14,000
你从你们公司访问的时候挂掉

2532
01:42:14,000 --> 01:42:14,000
不不不

2533
01:42:14,000 --> 01:42:15,000
它自己就挂掉了

2534
01:42:15,000 --> 01:42:17,000
所有人都不能访问

2535
01:42:17,000 --> 01:42:17,000
What

2536
01:42:17,000 --> 01:42:18,000
真的

2537
01:42:18,000 --> 01:42:19,000
前几年的时候

2538
01:42:19,000 --> 01:42:21,000
这个事情超级严重

2539
01:42:21,000 --> 01:42:21,000
OK

2540
01:42:21,000 --> 01:42:23,000
也是因为

2541
01:42:23,000 --> 01:42:24,000
就两个原因

2542
01:42:24,000 --> 01:42:25,000
它自己经常挂掉

2543
01:42:25,000 --> 01:42:25,000
一个是我们访问

2544
01:42:25,000 --> 01:42:26,000
它的网络的情况

2545
01:42:26,000 --> 01:42:27,000
经常会挂掉

2546
01:42:27,000 --> 01:42:28,000
你知道有段时间

2547
01:42:28,000 --> 01:42:30,000
Python.org

2548
01:42:30,000 --> 01:42:31,000
到 com

2549
01:42:31,000 --> 01:42:31,000
到 org 吧

2550
01:42:31,000 --> 01:42:34,000
这个网站是被封掉了吗

2551
01:42:34,000 --> 01:42:34,000
对

2552
01:42:34,000 --> 01:42:36,000
现在也是被封掉了

2553
01:42:36,000 --> 01:42:37,000
不然它为什么要再

2554
01:42:37,000 --> 01:42:38,000
加个中文

2555
01:42:38,000 --> 01:42:40,000
首页上面出现

2556
01:42:40,000 --> 01:42:41,000
中文的下载两个字

2557
01:42:41,000 --> 01:42:42,000
但这就不是

2558
01:42:42,000 --> 01:42:43,000
你们觉得很奇怪吗

2559
01:42:43,000 --> 01:42:44,000
你都被封掉了

2560
01:42:44,000 --> 01:42:45,000
你出现中文

2561
01:42:45,000 --> 01:42:46,000
又有什么用

2562
01:42:46,000 --> 01:42:48,000
这是 parody 吗

2563
01:42:48,000 --> 01:42:48,000
就是

2564
01:42:48,000 --> 01:42:49,000
它故意

2565
01:42:49,000 --> 01:42:50,000
我觉得这就是

2566
01:42:50,000 --> 01:42:51,000
它以一个技术

2567
01:42:51,000 --> 01:42:53,000
从一个技术社区来表达

2568
01:42:53,000 --> 01:42:56,000
对于某些政府行为的

2569
01:42:56,000 --> 01:42:56,000
微弱的反抗

2570
01:42:56,000 --> 01:42:57,000
whatever

2571
01:42:57,000 --> 01:42:58,000
就是对

2572
01:42:58,000 --> 01:43:00,000
这个就不知道了

2573
01:43:00,000 --> 01:43:00,000
秀个姿态

2574
01:43:00,000 --> 01:43:02,000
反正就是双重原因

2575
01:43:02,000 --> 01:43:04,000
它自己本身也不是很稳定

2576
01:43:04,000 --> 01:43:05,000
它自己的 availability

2577
01:43:05,000 --> 01:43:06,000
也不是很高

2578
01:43:06,000 --> 01:43:07,000
加上网络的原因

2579
01:43:07,000 --> 01:43:09,000
导致我们经常访问不了它

2580
01:43:09,000 --> 01:43:09,000
所以

2581
01:43:09,000 --> 01:43:12,000
大部分用 Python

2582
01:43:12,000 --> 01:43:14,000
做生产的公司也好

2583
01:43:14,000 --> 01:43:15,000
团队也好

2584
01:43:15,000 --> 01:43:16,000
基本上都自己在

2585
01:43:16,000 --> 01:43:18,000
内部局网维护了

2586
01:43:18,000 --> 01:43:18,000
一个

2587
01:43:18,000 --> 01:43:18,000
Python 的

2588
01:43:18,000 --> 01:43:20,000
Python 的镜像

2589
01:43:20,000 --> 01:43:21,000
OK

2590
01:43:21,000 --> 01:43:21,000
简单说就是

2591
01:43:21,000 --> 01:43:22,000
很大吗

2592
01:43:22,000 --> 01:43:23,000
你不一定会

2593
01:43:23,000 --> 01:43:24,000
你不一定需要全部的

2594
01:43:24,000 --> 01:43:26,000
你只需要你用常用的

2595
01:43:26,000 --> 01:43:26,000
那些

2596
01:43:26,000 --> 01:43:26,000
你需要

2597
01:43:26,000 --> 01:43:27,000
OK

2598
01:43:27,000 --> 01:43:29,000
可是你怎么知道哪些常用

2599
01:43:29,000 --> 01:43:29,000
它是这种

2600
01:43:29,000 --> 01:43:30,000
它有一种

2601
01:43:30,000 --> 01:43:31,000
这个做的还比较不错

2602
01:43:31,000 --> 01:43:32,000
就是有

2603
01:43:32,000 --> 01:43:34,000
就因为 Python

2604
01:43:34,000 --> 01:43:35,000
Python 经常挂掉

2605
01:43:35,000 --> 01:43:36,000
所以有人写出这种工具

2606
01:43:36,000 --> 01:43:40,000
可以很方便的让你在自己的服务器上架设一个镜像

2607
01:43:40,000 --> 01:43:42,000
然后镜像可以说

2608
01:43:42,000 --> 01:43:43,000
就代理

2609
01:43:43,000 --> 01:43:44,000
就是你设置一下

2610
01:43:44,000 --> 01:43:46,000
你装的时候

2611
01:43:46,000 --> 01:43:48,000
他会先去镜像服务器上

2612
01:43:48,000 --> 01:43:48,000
找

2613
01:43:48,000 --> 01:43:49,000
如果他找不到

2614
01:43:49,000 --> 01:43:49,000
他这个

2615
01:43:49,000 --> 01:43:54,000
他会让这个镜像服务器去拍皮的官方去把那个抓了回镜像服务器

2616
01:43:54,000 --> 01:43:55,000
这样下次的话

2617
01:43:55,000 --> 01:43:57,000
你就在那个镜像服务器上有了吗

2618
01:43:57,000 --> 01:43:58,000
嗯

2619
01:43:58,000 --> 01:44:00,000
就是人也是一个缓存代理的意思

2620
01:44:00,000 --> 01:44:00,000
对

2621
01:44:00,000 --> 01:44:01,000
嗯

2622
01:44:01,000 --> 01:44:02,000
对

2623
01:44:02,000 --> 01:44:04,000
就是就到了这种程度了

2624
01:44:04,000 --> 01:44:05,000
当然不过

2625
01:44:05,000 --> 01:44:06,000
从这个可用线的角度来讲

2626
01:44:06,000 --> 01:44:09,000
你有一个本地的这个镜像也是好的

2627
01:44:09,000 --> 01:44:12,000
就可以避免网络和你们遇到那种情况

2628
01:44:12,000 --> 01:44:14,000
单点失败吗

2629
01:44:14,000 --> 01:44:15,000
嗯

2630
01:44:15,000 --> 01:44:16,000
OK

2631
01:44:16,000 --> 01:44:18,000
但是事情还是没有进步

2632
01:44:18,000 --> 01:44:18,000
嗯

2633
01:44:18,000 --> 01:44:19,000
结束

2634
01:44:19,000 --> 01:44:20,000
为什么呢

2635
01:44:20,000 --> 01:44:23,000
因为不管是 Easy Install 也好

2636
01:44:23,000 --> 01:44:25,000
Distribute 也好

2637
01:44:25,000 --> 01:44:27,000
Pip 也好

2638
01:44:27,000 --> 01:44:32,000
他们基本上不能安装非纯 Python 的包

2639
01:44:32,000 --> 01:44:36,000
Python 作为一个

2640
01:44:36,000 --> 01:44:38,000
这个多少有点强人所难了

2641
01:44:38,000 --> 01:44:39,000
说实话呢

2642
01:44:39,000 --> 01:44:41,000
这个就要解释为什么

2643
01:44:41,000 --> 01:44:43,000
为什么要出现这种一个应用场景

2644
01:44:43,000 --> 01:44:43,000
就是说

2645
01:44:43,000 --> 01:44:48,000
首先是因为 Python 语言本身是一个比较归宿的语言

2646
01:44:48,000 --> 01:44:48,000
好

2647
01:44:48,000 --> 01:44:53,000
它是一个解释型不带 JIT 的语言

2648
01:44:53,000 --> 01:44:54,000
大部分情况下

2649
01:44:54,000 --> 01:44:58,000
或者说它的 JIT 支持的特征还不够全面

2650
01:44:58,000 --> 01:44:58,000
对

2651
01:44:58,000 --> 01:44:59,000
简单来说就是慢

2652
01:44:59,000 --> 01:45:02,000
那么导致它做很多事情的时候就不能

2653
01:45:02,000 --> 01:45:04,000
都需要 Native Pythons

2654
01:45:04,000 --> 01:45:04,000
对

2655
01:45:04,000 --> 01:45:07,000
不能用原生的 Python 的这个代码来实现

2656
01:45:07,000 --> 01:45:08,000
要用这个

2657
01:45:08,000 --> 01:45:10,000
比如用 C 或者是 C++来实现

2658
01:45:10,000 --> 01:45:14,000
然后通过一个那种这种什么 Bridge 的方式

2659
01:45:14,000 --> 01:45:16,000
再通过 Python 去调用它

2660
01:45:16,000 --> 01:45:18,000
比如说最常见的两个

2661
01:45:18,000 --> 01:45:22,000
这种例子是一个叫做 NumericalPy

2662
01:45:22,000 --> 01:45:23,000
NumericPy

2663
01:45:23,000 --> 01:45:25,000
是做数值计算的

2664
01:45:25,000 --> 01:45:27,000
比如说什么矩阵运算

2665
01:45:27,000 --> 01:45:28,000
那些八道

2666
01:45:28,000 --> 01:45:30,000
另外一个叫做 Python Image Library

2667
01:45:30,000 --> 01:45:32,000
然后这个是干嘛

2668
01:45:32,000 --> 01:45:33,000
就处理图像的

2669
01:45:33,000 --> 01:45:34,000
OK

2670
01:45:34,000 --> 01:45:37,000
处理图像其实用图还蛮多的

2671
01:45:37,000 --> 01:45:39,000
比如说你做一个社交网站

2672
01:45:39,000 --> 01:45:41,000
你要用户传个头像上来的时候

2673
01:45:41,000 --> 01:45:42,000
你得想办法剪裁一下

2674
01:45:42,000 --> 01:45:43,000
压缩一下

2675
01:45:43,000 --> 01:45:44,000
对吧

2676
01:45:44,000 --> 01:45:45,000
你就用这个 PIL

2677
01:45:45,000 --> 01:45:46,000
Python Image Library

2678
01:45:46,000 --> 01:45:48,000
PIL 说实话已经好像

2679
01:45:48,000 --> 01:45:50,000
曾经非常喜欢它

2680
01:45:50,000 --> 01:45:52,000
但是现在好像已经有一阵子

2681
01:45:52,000 --> 01:45:53,000
从来没有用过

2682
01:45:53,000 --> 01:45:54,000
爱不起来了是吧

2683
01:45:54,000 --> 01:45:55,000
对

2684
01:45:55,000 --> 01:45:56,000
我理解你

2685
01:45:56,000 --> 01:45:57,000
那么 PY 也是

2686
01:45:57,000 --> 01:45:58,000
其实有一阵子

2687
01:45:58,000 --> 01:46:00,000
我非常痴迷于在 Mac 上面

2688
01:46:00,000 --> 01:46:03,000
时刻保持一个

2689
01:46:03,000 --> 01:46:04,000
iPython

2690
01:46:04,000 --> 01:46:07,000
iPython 的 QT 版本的 Console 在跑

2691
01:46:07,000 --> 01:46:09,000
因为用 QT 你可以

2692
01:46:09,000 --> 01:46:12,000
内连显示很多

2693
01:46:12,000 --> 01:46:14,000
就有点像 Mathematica

2694
01:46:14,000 --> 01:46:18,000
或者是 Mapple 的那种感觉

2695
01:46:18,000 --> 01:46:21,000
就是你潇洒的写下几行代码

2696
01:46:21,000 --> 01:46:22,000
真正的科学计算环境

2697
01:46:22,000 --> 01:46:23,000
对

2698
01:46:23,000 --> 01:46:24,000
冒出一个图表来

2699
01:46:24,000 --> 01:46:27,000
我当时有一阵子非常痴迷于

2700
01:46:27,000 --> 01:46:29,000
一定要保持我的 Mac 上面跑着

2701
01:46:29,000 --> 01:46:29,000
这么一个东西

2702
01:46:29,000 --> 01:46:31,000
其实现在也很多人这么用

2703
01:46:31,000 --> 01:46:34,000
它现在 iPython 出了一个叫做 Notebook

2704
01:46:34,000 --> 01:46:35,000
对

2705
01:46:35,000 --> 01:46:38,000
其实 Python Notebook 是网页版的

2706
01:46:38,000 --> 01:46:39,000
但我就痴迷于

2707
01:46:39,000 --> 01:46:41,000
一定要有一个原生的图形界面的

2708
01:46:41,000 --> 01:46:42,000
这么一个东西

2709
01:46:42,000 --> 01:46:44,000
它不就是为了解决跨平台的问题吗

2710
01:46:44,000 --> 01:46:46,000
看起来非常高大上主要是

2711
01:46:46,000 --> 01:46:47,000
简单一点

2712
01:46:47,000 --> 01:46:48,000
但是后来

2713
01:46:48,000 --> 01:46:48,000
对

2714
01:46:48,000 --> 01:46:49,000
但是后来我

2715
01:46:49,000 --> 01:46:52,000
因为我在 GitHub 上面

2716
01:46:52,000 --> 01:46:55,000
维护一个小 Note

2717
01:46:55,000 --> 01:46:58,000
就是怎样解决一些

2718
01:46:58,000 --> 01:47:00,000
安装一台新 Mac 的时候

2719
01:47:00,000 --> 01:47:03,000
需要面对的小问题

2720
01:47:03,000 --> 01:47:05,000
然后我写在这个

2721
01:47:05,000 --> 01:47:10,000
我在 iPython QT 版本的

2722
01:47:10,000 --> 01:47:12,000
这一段 Note 里面

2723
01:47:12,000 --> 01:47:13,000
倾注了大量的心血

2724
01:47:13,000 --> 01:47:14,000
然后最后

2725
01:47:14,000 --> 01:47:16,000
最后最后的时候

2726
01:47:16,000 --> 01:47:17,000
我绝望在里面写说

2727
01:47:17,000 --> 01:47:21,000
这一切都需要太多努力了

2728
01:47:21,000 --> 01:47:22,000
还是直接

2729
01:47:22,000 --> 01:47:24,000
give it up

2730
01:47:24,000 --> 01:47:27,000
and use iPython Notebook

2731
01:47:27,000 --> 01:47:29,000
好吧

2732
01:47:29,000 --> 01:47:30,000
明白了

2733
01:47:30,000 --> 01:47:31,000
OK

2734
01:47:31,000 --> 01:47:32,000
接着说回来这个好东西

2735
01:47:32,000 --> 01:47:34,000
就是说前面那几个工具

2736
01:47:34,000 --> 01:47:35,000
setup tool

2737
01:47:35,000 --> 01:47:35,000
discuteal

2738
01:47:35,000 --> 01:47:36,000
还有 peep

2739
01:47:36,000 --> 01:47:37,000
都不能解决

2740
01:47:37,000 --> 01:47:38,000
不能很好地解决

2741
01:47:38,000 --> 01:47:40,000
带有这种 C binding

2742
01:47:40,000 --> 01:47:42,000
或者这种其他语言 binding 的

2743
01:47:42,000 --> 01:47:44,000
Python 的包的安装

2744
01:47:44,000 --> 01:47:46,000
这个时候你有两种方案

2745
01:47:46,000 --> 01:47:47,000
就是像

2746
01:47:47,000 --> 01:47:50,000
Python image library 这种巨无霸的

2747
01:47:50,000 --> 01:47:51,000
因为它很大嘛

2748
01:47:51,000 --> 01:47:52,000
这种巨无霸的

2749
01:47:52,000 --> 01:47:55,000
它通常给你提供一个官方的安装包

2750
01:47:55,000 --> 01:47:56,000
当然你就装上

2751
01:47:56,000 --> 01:47:57,000
你就用那个官方安装包

2752
01:47:57,000 --> 01:47:59,000
通常是一个比较靠谱的办法

2753
01:47:59,000 --> 01:48:00,000
但是如果你就想

2754
01:48:00,000 --> 01:48:02,000
从某种方式去把这个东西管理起来

2755
01:48:02,000 --> 01:48:04,000
或者是能够帮我自动化起来

2756
01:48:04,000 --> 01:48:06,000
就没有办法能够帮到你了

2757
01:48:06,000 --> 01:48:09,000
所以后来就有另外一种

2758
01:48:09,000 --> 01:48:10,000
另外一个工具叫做 build out

2759
01:48:10,000 --> 01:48:12,000
这个你估计没有用过

2760
01:48:12,000 --> 01:48:13,000
其实我之前也没有听说过

2761
01:48:13,000 --> 01:48:16,000
我也是去了知乎之后发现

2762
01:48:16,000 --> 01:48:17,000
还有这么一个东西

2763
01:48:17,000 --> 01:48:20,000
这个东西来源其实还挺古老的

2764
01:48:20,000 --> 01:48:24,000
你知道 Python 在很 web 1.0

2765
01:48:24,000 --> 01:48:25,000
web 0.9 的时代

2766
01:48:25,000 --> 01:48:29,000
出现过一个叫做 ZOAP 的这么一个机构

2767
01:48:29,000 --> 01:48:31,000
你不知道你有印象没

2768
01:48:31,000 --> 01:48:33,000
ZOPE

2769
01:48:33,000 --> 01:48:33,000
我知道

2770
01:48:33,000 --> 01:48:37,000
而且号称 ZOAP 是当时

2771
01:48:37,000 --> 01:48:39,000
如日中天的这么一个

2772
01:48:39,000 --> 01:48:43,000
史诗级伟大的库

2773
01:48:43,000 --> 01:48:45,000
是这样吗

2774
01:48:45,000 --> 01:48:47,000
它是一个

2775
01:48:47,000 --> 01:48:47,000
SIM

2776
01:48:47,000 --> 01:48:47,000
SIM

2777
01:48:47,000 --> 01:48:47,000
SIM

2778
01:48:47,000 --> 01:48:50,000
说它是 SIMS 好像不太严谨

2779
01:48:50,000 --> 01:48:54,000
它其实就算一个 framework

2780
01:48:54,000 --> 01:48:55,000
took it

2781
01:48:55,000 --> 01:48:56,000
它自称一个 took it

2782
01:48:56,000 --> 01:48:57,000
对它是一个

2783
01:48:57,000 --> 01:49:00,000
本来是用来建一个 SIMS 的一个 framework

2784
01:49:00,000 --> 01:49:02,000
确实可以这么理解

2785
01:49:02,000 --> 01:49:04,000
但是后来它就越来越臃肿

2786
01:49:04,000 --> 01:49:05,000
已经可以做很多事情了

2787
01:49:05,000 --> 01:49:08,000
然后 build out 的这个工具

2788
01:49:08,000 --> 01:49:09,000
其实就是最开始

2789
01:49:09,000 --> 01:49:10,000
如果我没记错的话

2790
01:49:10,000 --> 01:49:11,000
就是 ZOAP 那帮人

2791
01:49:11,000 --> 01:49:14,000
为了解决他们巨无霸的 framework 的安装

2792
01:49:14,000 --> 01:49:17,000
和开发的问题

2793
01:49:17,000 --> 01:49:20,000
就写出来的这么一个工具

2794
01:49:20,000 --> 01:49:22,000
然后这个工具的特色是什么呢

2795
01:49:22,000 --> 01:49:24,000
它能支持这种

2796
01:49:24,000 --> 01:49:26,000
带

2797
01:49:26,000 --> 01:49:28,000
native binding 的

2798
01:49:28,000 --> 01:49:29,000
Python 的包的安装

2799
01:49:29,000 --> 01:49:31,000
因为这里说起来就要提另外一件事情

2800
01:49:31,000 --> 01:49:33,000
就是比如说这个 Python image library

2801
01:49:33,000 --> 01:49:35,000
它虽然说是一个非纯

2802
01:49:35,000 --> 01:49:37,000
就它虽然说需要有 native binding

2803
01:49:37,000 --> 01:49:37,000
它

2804
01:49:37,000 --> 01:49:39,000
但你安装的时候并不是

2805
01:49:39,000 --> 01:49:41,000
安装它自己本身这么简单

2806
01:49:41,000 --> 01:49:44,000
你还得再装一些其他的什么 C 的一些库

2807
01:49:44,000 --> 01:49:47,000
比如说 Zip PNG 什么乱七八糟的

2808
01:49:47,000 --> 01:49:49,000
然后在 Linux 上面这些话

2809
01:49:49,000 --> 01:49:50,000
你就要通过

2810
01:49:50,000 --> 01:49:52,000
就在你装这个 PIL 之前

2811
01:49:52,000 --> 01:49:54,000
你还得用什么 apt 或者是 yaml 的方式

2812
01:49:54,000 --> 01:49:58,000
把那些的依赖给先给装上去

2813
01:49:58,000 --> 01:50:01,000
然后你再可以再装这个 Python image library

2814
01:50:01,000 --> 01:50:01,000
才可以成功

2815
01:50:01,000 --> 01:50:02,000
对

2816
01:50:02,000 --> 01:50:04,000
然后这样的话就其实成功

2817
01:50:04,000 --> 01:50:06,000
手工操作是非常繁琐

2818
01:50:06,000 --> 01:50:08,000
和容易出错的一个过程

2819
01:50:08,000 --> 01:50:08,000
你可以

2820
01:50:08,000 --> 01:50:10,000
如果你不信你可以去试一下

2821
01:50:10,000 --> 01:50:13,000
我对此还是有所提问

2822
01:50:13,000 --> 01:50:13,000
因为装

2823
01:50:13,000 --> 01:50:16,000
就像我说的 iPython 的 Qt console

2824
01:50:16,000 --> 01:50:18,000
其实也是这么一个过程

2825
01:50:18,000 --> 01:50:23,000
首先要用包管理工具去安装一些 library

2826
01:50:23,000 --> 01:50:26,000
然后再安装 Qt 之类的

2827
01:50:26,000 --> 01:50:30,000
然后再去再用 Python 去安装对应的组件

2828
01:50:30,000 --> 01:50:32,000
然后还有什么 0 MQ 之类的东西

2829
01:50:32,000 --> 01:50:34,000
都要一个一个都装上

2830
01:50:34,000 --> 01:50:34,000
对对对

2831
01:50:34,000 --> 01:50:36,000
其实我当时在中国用的时候

2832
01:50:36,000 --> 01:50:38,000
也是因为就是最主要原因就是

2833
01:50:38,000 --> 01:50:42,000
尝试用那个 0 MQ 要装一些 C 的东西

2834
01:50:42,000 --> 01:50:43,000
对

2835
01:50:43,000 --> 01:50:45,000
然后 Buildout 就可以用一个这种方式

2836
01:50:45,000 --> 01:50:46,000
它可以解决

2837
01:50:46,000 --> 01:50:48,000
它可以指定一些脚本

2838
01:50:48,000 --> 01:50:50,000
在你安装某个包之前

2839
01:50:50,000 --> 01:50:54,000
你可以先声明它依赖哪些非 Python 的东西

2840
01:50:54,000 --> 01:50:55,000
然后系统先帮你安装好

2841
01:50:55,000 --> 01:50:57,000
比如支持一个 apt 什么的

2842
01:50:57,000 --> 01:50:58,000
帮你装好

2843
01:50:58,000 --> 01:50:58,000
然后你再装

2844
01:50:58,000 --> 01:51:00,000
然后再包那个过程

2845
01:51:00,000 --> 01:51:02,000
但是 Buildout 是一个神一样的存在

2846
01:51:02,000 --> 01:51:03,000
你知道吗

2847
01:51:03,000 --> 01:51:05,000
当时现在我不知道情况会不会好转一些

2848
01:51:05,000 --> 01:51:06,000
当时我用的时候

2849
01:51:06,000 --> 01:51:07,000
我想去学它

2850
01:51:07,000 --> 01:51:09,000
就是一个三无产品

2851
01:51:09,000 --> 01:51:09,000
就你上它网上之后

2852
01:51:09,000 --> 01:51:11,000
你知道你看不出

2853
01:51:11,000 --> 01:51:12,000
没有文档

2854
01:51:12,000 --> 01:51:14,000
没有没有官方文档

2855
01:51:14,000 --> 01:51:15,000
所有的人找到的

2856
01:51:15,000 --> 01:51:15,000
都是

2857
01:51:15,000 --> 01:51:18,000
只有网上稀稀拉拉一些教程

2858
01:51:18,000 --> 01:51:19,000
然后你不知道这个东西

2859
01:51:19,000 --> 01:51:21,000
最开始是不知道是谁在维护的

2860
01:51:21,000 --> 01:51:22,000
因为他现在没有

2861
01:51:22,000 --> 01:51:24,000
没有说这个东西是找

2862
01:51:24,000 --> 01:51:25,000
你都不知道去找谁

2863
01:51:25,000 --> 01:51:26,000
他有一个 main list

2864
01:51:26,000 --> 01:51:28,000
然后那那那那

2865
01:51:28,000 --> 01:51:29,000
就是你没有办法再

2866
01:51:29,000 --> 01:51:29,000
等等

2867
01:51:29,000 --> 01:51:31,000
三无产品

2868
01:51:31,000 --> 01:51:32,000
我们可以定义一下

2869
01:51:32,000 --> 01:51:33,000
三无产品到底是哪三无

2870
01:51:33,000 --> 01:51:34,000
没有文档是肯定的

2871
01:51:34,000 --> 01:51:35,000
没有文档

2872
01:51:35,000 --> 01:51:38,000
没有这个稳定的开发者

2873
01:51:38,000 --> 01:51:39,000
然后你出了问题

2874
01:51:39,000 --> 01:51:40,000
不知道去哪里问

2875
01:51:40,000 --> 01:51:44,000
无文档

2876
01:51:44,000 --> 01:51:45,000
无稳定维护者

2877
01:51:45,000 --> 01:51:46,000
还有一个无

2878
01:51:46,000 --> 01:51:48,000
就是不知道去哪里问问题

2879
01:51:48,000 --> 01:51:49,000
就是不是出了问题找谁

2880
01:51:49,000 --> 01:51:50,000
不知道

2881
01:51:50,000 --> 01:51:51,000
无社区对

2882
01:51:51,000 --> 01:51:53,000
然后就发现

2883
01:51:53,000 --> 01:51:53,000
哇

2884
01:51:53,000 --> 01:51:54,000
这这也可以

2885
01:51:54,000 --> 01:51:56,000
而且这既然是

2886
01:51:56,000 --> 01:51:58,000
我所知道的

2887
01:51:58,000 --> 01:51:59,000
能够解决这个 python

2888
01:51:59,000 --> 01:52:00,000
呃

2889
01:52:00,000 --> 01:52:02,000
这种就安装非纯 python

2890
01:52:02,000 --> 01:52:04,000
报的唯一的一个比较好的

2891
01:52:04,000 --> 01:52:06,000
能用的工具都不能说他好了

2892
01:52:06,000 --> 01:52:07,000
能用的自动工具

2893
01:52:07,000 --> 01:52:08,000
对

2894
01:52:08,000 --> 01:52:10,000
然后他的体验是相当

2895
01:52:10,000 --> 01:52:11,000
使用体验相当糟糕的

2896
01:52:11,000 --> 01:52:14,000
他的配置文件是一个.ini 的文件

2897
01:52:15,000 --> 01:52:15,000
what

2898
01:52:15,000 --> 01:52:18,000
然后你需要在开发者是什么背景

2899
01:52:18,000 --> 01:52:19,000
很 zop 吗

2900
01:52:19,000 --> 01:52:20,000
你自己想想这么古老的

2901
01:52:20,000 --> 01:52:21,000
ancient 的东西

2902
01:52:21,000 --> 01:52:24,000
就有出现这种情况也不奇怪了

2903
01:52:24,000 --> 01:52:24,000
就还好还好

2904
01:52:24,000 --> 01:52:26,000
可不是太糟糕

2905
01:52:26,000 --> 01:52:27,000
但糟糕的是

2906
01:52:27,000 --> 01:52:29,000
你需要在这个 ini 文件里面

2907
01:52:29,000 --> 01:52:30,000
你 i 文件的格式

2908
01:52:30,000 --> 01:52:31,000
他你想他应该也很明白

2909
01:52:31,000 --> 01:52:33,000
就是有他分几个

2910
01:52:33,000 --> 01:52:33,000
就是一小节

2911
01:52:33,000 --> 01:52:34,000
一小一个 section

2912
01:52:34,000 --> 01:52:36,000
每个 section 是一个放过号

2913
01:52:36,000 --> 01:52:37,000
不要分开

2914
01:52:37,000 --> 01:52:37,000
有个 biao

2915
01:52:37,000 --> 01:52:38,000
一个 section

2916
01:52:38,000 --> 01:52:39,000
不管怎么说

2917
01:52:39,000 --> 01:52:40,000
还是要比 xml 好

2918
01:52:40,000 --> 01:52:41,000
对

2919
01:52:41,000 --> 01:52:42,000
还是比 xml 好一点

2920
01:52:42,000 --> 01:52:44,000
但是他们把这个已经用到了

2921
01:52:44,000 --> 01:52:45,000
极致了

2922
01:52:45,000 --> 01:52:47,000
然后每个 section 里面

2923
01:52:47,000 --> 01:52:51,000
它是一个 key value 的一个 pair

2924
01:52:51,000 --> 01:52:51,000
一个对

2925
01:52:51,000 --> 01:52:53,000
就是一个主件

2926
01:52:53,000 --> 01:52:54,000
然后上面一个数值

2927
01:52:54,000 --> 01:52:58,000
为了解决 biao 的中间的各种问题

2928
01:52:58,000 --> 01:52:59,000
你需要在里面插入

2929
01:52:59,000 --> 01:53:02,000
用一些很诡异的方法

2930
01:53:02,000 --> 01:53:04,000
去写版本字符串

2931
01:53:04,000 --> 01:53:08,000
你需要在里面插入这个 shell 脚本

2932
01:53:08,000 --> 01:53:11,000
在 ini 里面插入 shell 脚本

2933
01:53:11,000 --> 01:53:12,000
这是什么黑魔法

2934
01:53:12,000 --> 01:53:14,000
所以你知道 biao 是多么一个

2935
01:53:15,000 --> 01:53:16,000
惨痛的存在了

2936
01:53:16,000 --> 01:53:16,000
对

2937
01:53:16,000 --> 01:53:21,000
这是我就一直对他吐槽不能

2938
01:53:21,000 --> 01:53:22,000
但是又不得不用的一个

2939
01:53:22,000 --> 01:53:24,000
很令人沮丧的攻击

2940
01:53:24,000 --> 01:53:27,000
可是我刚刚在 build out

2941
01:53:27,000 --> 01:53:29,000
我刚刚在 github 上面发现了

2942
01:53:29,000 --> 01:53:29,000
build out

2943
01:53:29,000 --> 01:53:30,000
slash build out

2944
01:53:30,000 --> 01:53:31,000
这个 repository

2945
01:53:31,000 --> 01:53:33,000
什么话

2946
01:53:33,000 --> 01:53:34,000
对

2947
01:53:34,000 --> 01:53:36,000
这难道是他们官方的库吗

2948
01:53:36,000 --> 01:53:38,000
所以他已经去了 github 了

2949
01:53:38,000 --> 01:53:41,000
是那所以可能事情有所好转

2950
01:53:41,000 --> 01:53:42,000
有可能

2951
01:53:42,000 --> 01:53:43,000
好吧

2952
01:53:43,000 --> 01:53:45,000
但起起码你可以去看了

2953
01:53:45,000 --> 01:53:45,000
你可能有所好转了

2954
01:53:45,000 --> 01:53:47,000
你可以去他的什么 build out.org

2955
01:53:47,000 --> 01:53:48,000
这个网站

2956
01:53:48,000 --> 01:53:50,000
你可以发现他有一个 learn

2957
01:53:50,000 --> 01:53:51,000
这个选项

2958
01:53:51,000 --> 01:53:53,000
里面就是一堆 tutorial

2959
01:53:53,000 --> 01:53:54,000
然后完了

2960
01:53:54,000 --> 01:53:59,000
然后他教你用他的唯一的方式

2961
01:53:59,000 --> 01:54:00,000
就是给你一堆例子

2962
01:54:00,000 --> 01:54:06,000
而且在 github repository 里面的

2963
01:54:06,000 --> 01:54:10,000
贡献最多的这个人叫做 Jim Fulton

2964
01:54:10,000 --> 01:54:15,000
他显示的工作地点是 Zope Corporation

2965
01:54:15,000 --> 01:54:21,000
所以有可能他就是你一直苦苦在寻找的主要维护者

2966
01:54:21,000 --> 01:54:22,000
对

2967
01:54:22,000 --> 01:54:23,000
因为这个 build out 是他写的

2968
01:54:23,000 --> 01:54:24,000
最开始是他

2969
01:54:24,000 --> 01:54:26,000
但是我相当确定应该没有

2970
01:54:26,000 --> 01:54:28,000
他没有在更新这个东西了

2971
01:54:28,000 --> 01:54:29,000
OK

2972
01:54:29,000 --> 01:54:32,000
所以这是一个半死不活的项目

2973
01:54:32,000 --> 01:54:34,000
靠着社区也不知道谁在维护

2974
01:54:34,000 --> 01:54:35,000
anyway

2975
01:54:35,000 --> 01:54:38,000
就像游魂一样的软件

2976
01:54:38,000 --> 01:54:38,000
对

2977
01:54:38,000 --> 01:54:39,000
但是你又不得不用它

2978
01:54:39,000 --> 01:54:41,000
而且你发现

2979
01:54:41,000 --> 01:54:44,000
3 号你竟然能够用它来

2980
01:54:44,000 --> 01:54:45,000
还能用

2981
01:54:45,000 --> 01:54:45,000
对

2983
01:55:15,000 --> 01:55:16,000
我就 refer 过某个版本

2984
01:55:16,000 --> 01:55:18,000
他会把那个版本的这个源码

2985
01:55:18,000 --> 01:55:21,000
就从 pipe 或者是哪个地方抓回来的

2986
01:55:21,000 --> 01:55:26,000
在你本地的它管理的一个隐藏的目录下面去存起来

2987
01:55:26,000 --> 01:55:27,000
这样你下次装它的

2988
01:55:27,000 --> 01:55:28,000
你下次再运行 Build out 的时候

2989
01:55:28,000 --> 01:55:30,000
它就不用再去网上抓

2990
01:55:30,000 --> 01:55:33,000
而且直接本地从里面复制一份过来就好了

2991
01:55:33,000 --> 01:55:33,000
OK

2992
01:55:33,000 --> 01:55:34,000
为什么我毫不惊讶

2993
01:55:34,000 --> 01:55:35,000
因为 Meme 也有这个功能

2994
01:55:35,000 --> 01:55:35,000
对

2995
01:55:35,000 --> 01:55:38,000
但是你想它是一个多古老的软件

2996
01:55:38,000 --> 01:55:41,000
有这种功能还是还是相当不错的

2997
01:55:41,000 --> 01:55:42,000
挺好的一个事情

2998
01:55:42,000 --> 01:55:45,000
但是它的使用体验实在是太糟糕的

2999
01:55:45,000 --> 01:55:47,000
好

3000
01:55:47,000 --> 01:55:49,000
我对 Python 的吐槽

3001
01:55:49,000 --> 01:55:52,000
为了不要拉太多仇恨

3002
01:55:52,000 --> 01:55:53,000
吐槽到此为止

3003
01:55:53,000 --> 01:55:55,000
还好吧

3004
01:55:55,000 --> 01:55:57,000
只要我们是保持自黑的姿态

3005
01:55:57,000 --> 01:55:59,000
应该就不会招来太多的

3006
01:55:59,000 --> 01:56:00,000
不要黑别人的

3007
01:56:00,000 --> 01:56:01,000
黑自己就行了

3008
01:56:01,000 --> 01:56:02,000
对

3009
01:56:02,000 --> 01:56:04,000
而我们来看一看敌对阵营

3010
01:56:04,000 --> 01:56:08,000
现在我已经叛逃了

3011
01:56:08,000 --> 01:56:10,000
我已经加入了这个阵营

3012
01:56:10,000 --> 01:56:11,000
Node

3013
01:56:11,000 --> 01:56:12,000
这个 JavaScript

3014
01:56:12,000 --> 01:56:15,000
你觉得 Node 是敌对阵营

3015
01:56:15,000 --> 01:56:15,000
我不觉得

3016
01:56:15,000 --> 01:56:17,000
我觉得 Node 是兄弟阵营

3017
01:56:17,000 --> 01:56:17,000
不是吗

3018
01:56:17,000 --> 01:56:18,000
那敌对阵营是哪里

3019
01:56:18,000 --> 01:56:20,000
敌对阵营那是 Ruby

3020
01:56:20,000 --> 01:56:22,000
其实 Ruby 我不是很熟

3021
01:56:22,000 --> 01:56:23,000
我也不熟

3022
01:56:23,000 --> 01:56:25,000
但至少 Gem

3023
01:56:25,000 --> 01:56:28,000
包括你系统

3024
01:56:28,000 --> 01:56:29,000
在我有限的使用经验里面

3025
01:56:29,000 --> 01:56:32,000
要比 Python 的体验好很多

3026
01:56:32,000 --> 01:56:34,000
首先那只有一套对吧

3027
01:56:34,000 --> 01:56:37,000
不像 Python 那种四分五

3028
01:56:37,000 --> 01:56:38,000
那样搞五套出来

3029
01:56:38,000 --> 01:56:39,000
对

3030
01:56:39,000 --> 01:56:41,000
Ruby 社区不管怎么说

3031
01:56:41,000 --> 01:56:42,000
最好的一点就是团结

3032
01:56:42,000 --> 01:56:45,000
这是我们 Python 社区做不到的

3033
01:56:45,000 --> 01:56:45,000
对

3034
01:56:45,000 --> 01:56:47,000
我觉得他们更加乐于去

3035
01:56:47,000 --> 01:56:51,000
为了达成一个共识

3036
01:56:51,000 --> 01:56:52,000
去改变自己

3037
01:56:52,000 --> 01:56:53,000
对

3038
01:56:53,000 --> 01:56:54,000
这点是挺好的

3039
01:56:54,000 --> 01:56:56,000
所以 Gem 的体验

3040
01:56:56,000 --> 01:56:57,000
我其实体验不多的

3041
01:56:57,000 --> 01:56:59,000
你有什么体验吗

3042
01:56:59,000 --> 01:57:03,000
老实说我也不是特别多

3043
01:57:03,000 --> 01:57:07,000
只不过 Ruby 简直是

3044
01:57:07,000 --> 01:57:10,000
你接触一点稍微新一点的东西

3045
01:57:10,000 --> 01:57:12,000
绕不开一个工具

3046
01:57:12,000 --> 01:57:12,000
最简单的

3047
01:57:12,000 --> 01:57:14,000
上面提到 Homebrew

3048
01:57:14,000 --> 01:57:15,000
是 Ruby

3049
01:57:15,000 --> 01:57:16,000
你必须要

3050
01:57:16,000 --> 01:57:17,000
Homebrew 是 Ruby 的

3051
01:57:17,000 --> 01:57:21,000
比如说写 iOS 的

3052
01:57:21,000 --> 01:57:22,000
iOS 上面的包裹的工具

3053
01:57:22,000 --> 01:57:24,000
或者 Object C 的包裹的工具

3054
01:57:24,000 --> 01:57:26,000
Cocoa Pod

3055
01:57:26,000 --> 01:57:28,000
也是 Ruby 写的

3056
01:57:28,000 --> 01:57:28,000
What

3057
01:57:28,000 --> 01:57:29,000
Yes

3058
01:57:29,000 --> 01:57:30,000
我没有说错

3059
01:57:30,000 --> 01:57:33,000
Cocoa Pod 本身是一个 Ruby Gem

3060
01:57:33,000 --> 01:57:34,000
很神奇吧

3061
01:57:34,000 --> 01:57:35,000
OK

3062
01:57:35,000 --> 01:57:37,000
它其实跟 Homebrew 的形式

3063
01:57:37,000 --> 01:57:38,000
比较类似了吗

3064
01:57:38,000 --> 01:57:39,000
它的 Cocoa Pod

3065
01:57:39,000 --> 01:57:40,000
一个 Pod 文件

3066
01:57:40,000 --> 01:57:42,000
也是一个 Ruby 的文件吗

3067
01:57:42,000 --> 01:57:45,000
应该是

3068
01:57:45,000 --> 01:57:45,000
应该是这样的吧

3069
01:57:45,000 --> 01:57:47,000
我忘了 Pod

3070
01:57:47,000 --> 01:57:49,000
你证明说我还真

3071
01:57:49,000 --> 01:57:52,000
Pod file 的语法是 Ruby 的语法吗

3072
01:57:52,000 --> 01:57:53,000
还是一个 Jason

3073
01:57:53,000 --> 01:57:54,000
还是一个什么东西

3074
01:57:54,000 --> 01:57:59,000
它是一个也是用 Ruby 写的 DSL

3075
01:57:59,000 --> 01:58:01,000
对 Ruby 开发者最喜欢做的事情

3076
01:58:01,000 --> 01:58:03,000
就是写 DSL

3077
01:58:03,000 --> 01:58:05,000
对 Ruby 毕竟是一个非常适合

3078
01:58:05,000 --> 01:58:06,000
写 DSL 的语言

3079
01:58:06,000 --> 01:58:07,000
这也不能怪他

3080
01:58:07,000 --> 01:58:08,000
你知道这句话我听的最熟的地方

3081
01:58:08,000 --> 01:58:09,000
是在哪里吗

3082
01:58:09,000 --> 01:58:09,000
哪

3083
01:58:09,000 --> 01:58:10,000
Skala

3084
01:58:10,000 --> 01:58:12,000
Skala 写 DSL

3085
01:58:12,000 --> 01:58:14,000
对 Ruby 写 DSL

3086
01:58:14,000 --> 01:58:14,000
你还觉得

3087
01:58:14,000 --> 01:58:16,000
你从看出来一眼就能看出它是一个 Ruby 的文

3088
01:58:16,000 --> 01:58:17,000
Skala 写 DSL

3089
01:58:17,000 --> 01:58:18,000
My ass

3090
01:58:18,000 --> 01:58:19,000
你听我解释

3091
01:58:19,000 --> 01:58:21,000
就是说你说 Ruby 写 DSL

3092
01:58:21,000 --> 01:58:22,000
它还有一些东西是很明显的

3093
01:58:22,000 --> 01:58:24,000
Ruby 的语法痕迹在里面

3094
01:58:24,000 --> 01:58:24,000
对吧

3095
01:58:24,000 --> 01:58:26,000
你看出它是一个 class

3096
01:58:26,000 --> 01:58:28,000
然后它那个什么 block 的语法

3097
01:58:28,000 --> 01:58:30,000
就是很鲜明的特点

3098
01:58:30,000 --> 01:58:30,000
对吧

3099
01:58:30,000 --> 01:58:32,000
Skala 写出来 DSL

3100
01:58:32,000 --> 01:58:33,000
你甚至看不出

3101
01:58:33,000 --> 01:58:34,000
它有时候你不仔细看

3102
01:58:34,000 --> 01:58:36,000
你还看不出它是 Skala

3103
01:58:36,000 --> 01:58:38,000
这是它的优点还是缺点

3104
01:58:38,000 --> 01:58:39,000
我总觉得越听越像缺点

3105
01:58:39,000 --> 01:58:40,000
这都是

3106
01:58:40,000 --> 01:58:41,000
就是优点就是说

3107
01:58:41,000 --> 01:58:44,000
它能够可以让你定义一些很诡异的语法

3108
01:58:44,000 --> 01:58:45,000
编程能力非常强大

3109
01:58:45,000 --> 01:58:46,000
对非常强大

3110
01:58:46,000 --> 01:58:46,000
缺点也就是

3111
01:58:46,000 --> 01:58:50,000
它可以编得连亲爹都不认识的

3112
01:58:50,000 --> 01:58:50,000
对

3113
01:58:50,000 --> 01:58:53,000
就是 Skala 那种写的 DSL

3114
01:58:53,000 --> 01:58:56,000
如果你不知道 DSL 的实现方式

3115
01:58:56,000 --> 01:58:57,000
或者模板是怎么样子

3116
01:58:57,000 --> 01:58:58,000
你根本别想

3117
01:58:58,000 --> 01:58:59,000
你别想往下写下去

3118
01:58:59,000 --> 01:59:01,000
这根本不现实

3119
01:59:01,000 --> 01:59:02,000
对

3120
01:59:02,000 --> 01:59:03,000
有这种情况发生

3121
01:59:03,000 --> 01:59:06,000
还有什么呢

3122
01:59:06,000 --> 01:59:09,000
我前两天还用了一个什么东西

3123
01:59:09,000 --> 01:59:09,000
对对对

3124
01:59:09,000 --> 01:59:10,000
Rig File

3125
01:59:10,000 --> 01:59:11,000
Rig File

3126
01:59:11,000 --> 01:59:12,000
这个这种

3127
01:59:12,000 --> 01:59:14,000
这种

3128
01:59:14,000 --> 01:59:14,000
这

3129
01:59:14,000 --> 01:59:14,000
这

3132
02:00:14,000 --> 02:00:18,000
你去试试吧

3133
02:00:18,000 --> 02:00:20,000
然后我兴高采的 APD

3134
02:00:20,000 --> 02:00:21,000
跑过去看

3135
02:00:21,000 --> 02:00:23,000
里面是个 Rig File

3136
02:00:23,000 --> 02:00:26,000
相关问题是一个 Swift 的问题

3137
02:00:26,000 --> 02:00:27,000
但最后它

3138
02:00:27,000 --> 02:00:30,000
somehow 给了我一个 Rig File 的解决方案

3139
02:00:30,000 --> 02:00:31,000
而且

3140
02:00:31,000 --> 02:00:34,000
对它默认我是能理解这个东西

3141
02:00:34,000 --> 02:00:36,000
然后我

3142
02:00:36,000 --> 02:00:39,000
愚蠢莽撞的 Rig 了一下

3143
02:00:39,000 --> 02:00:40,000
然后出错了

3144
02:00:42,000 --> 02:00:44,000
理解你的痛苦了

3145
02:00:44,000 --> 02:00:47,000
就不懂 Ruby

3146
02:00:47,000 --> 02:00:50,000
以如今就是到处被人欺负的感觉

3147
02:00:50,000 --> 02:00:51,000
好吧

3148
02:00:51,000 --> 02:00:54,000
那什么 Ruby 的吐槽

3149
02:00:54,000 --> 02:00:55,000
我没法吐

3150
02:00:55,000 --> 02:00:55,000
因为我不用

3151
02:00:55,000 --> 02:00:56,000
然后也不甚熟

3152
02:00:56,000 --> 02:00:58,000
Ruby 没有什么可吐槽的

3153
02:00:58,000 --> 02:00:58,000
说实话真的

3154
02:00:58,000 --> 02:00:59,000
好

3155
02:00:59,000 --> 02:01:01,000
现在我们来说

3156
02:01:01,000 --> 02:01:02,000
另外一个敌对阵

3157
02:01:02,000 --> 02:01:03,000
Node

3158
02:01:03,000 --> 02:01:06,000
Node 有一个很不错

3159
02:01:06,000 --> 02:01:07,000
就在我看来

3160
02:01:07,000 --> 02:01:10,000
在这些主流的动态语言里

3161
02:01:10,000 --> 02:01:11,000
动态语言里面

3162
02:01:11,000 --> 02:01:14,000
比较好的实现的一个比较好语言是什么呢

3163
02:01:14,000 --> 02:01:15,000
就是这个包管理器

3164
02:01:15,000 --> 02:01:16,000
这个叫 NPM

3165
02:01:16,000 --> 02:01:19,000
其实它都甚至都不完全是一个包管理器

3166
02:01:19,000 --> 02:01:20,000
它还能做一些别的事

3167
02:01:20,000 --> 02:01:25,000
什么运行态的东西部署它也能做

3168
02:01:25,000 --> 02:01:26,000
其实还挺好的

3169
02:01:26,000 --> 02:01:27,000
不过我觉得

3170
02:01:27,000 --> 02:01:30,000
它有点像一个 configuration tool

3171
02:01:30,000 --> 02:01:31,000
对

3172
02:01:31,000 --> 02:01:33,000
它的范畴有点还不太一样

3173
02:01:33,000 --> 02:01:35,000
但是这个先不去纠结这些细节了

3174
02:01:35,000 --> 02:01:38,000
但是就说它作为包管理器的优点

3175
02:01:38,000 --> 02:01:40,000
我觉得还是比较明显的

3176
02:01:40,000 --> 02:01:41,000
它干净

3177
02:01:41,000 --> 02:01:43,000
干净什么意思呢

3178
02:01:43,000 --> 02:01:44,000
就是我们用的这个 Node 是什么呢

3179
02:01:44,000 --> 02:01:46,000
就是我们用这个 PIV 安装也好

3180
02:01:46,000 --> 02:01:47,000
还是 Ruby gem 安装也好

3181
02:01:47,000 --> 02:01:50,000
默认是安装进系统目录的

3182
02:01:50,000 --> 02:01:51,000
换句话说

3183
02:01:51,000 --> 02:01:53,000
你只要没什么事

3184
02:01:53,000 --> 02:01:54,000
你只要在这里装一个了

3185
02:01:54,000 --> 02:01:55,000
你的系统

3186
02:01:55,000 --> 02:01:56,000
你的系统

3187
02:01:56,000 --> 02:01:57,000
那个就系统的 Python

3188
02:01:57,000 --> 02:02:01,000
那个包的目录就已经被打引号的污染了

3189
02:02:01,000 --> 02:02:03,000
你没法再回到之前那个状态了

3190
02:02:03,000 --> 02:02:06,000
特别是你用了 Python 那种只可 install

3191
02:02:06,000 --> 02:02:08,000
不可 uninstall 的状态的这种工具的情况下

3192
02:02:09,000 --> 02:02:11,000
Gem 可以 uninstall 吗

3193
02:02:11,000 --> 02:02:11,000
可以啊

3194
02:02:11,000 --> 02:02:13,000
Gem 等等啊

3195
02:02:13,000 --> 02:02:14,000
Gem 当然可以 uninstall

3196
02:02:14,000 --> 02:02:18,000
而且 Gem 是可以装在本身的那个

3197
02:02:18,000 --> 02:02:19,000
local project 下面

3198
02:02:19,000 --> 02:02:21,000
JAM 或者是本地目录吗

3199
02:02:21,000 --> 02:02:24,000
直接装在那个 Windows 下面的

3200
02:02:24,000 --> 02:02:27,000
但是它的默认也是装到那个系统吧

3201
02:02:27,000 --> 02:02:28,000
是吗

3202
02:02:28,000 --> 02:02:29,000
默认呢

3203
02:02:29,000 --> 02:02:32,000
就系统可能是说一个用户嘛

3204
02:02:32,000 --> 02:02:33,000
或者是你用 sudo 的话

3205
02:02:33,000 --> 02:02:35,000
就是系统的根里面那些什么

3206
02:02:35,000 --> 02:02:36,000
user local 那些

3207
02:02:36,000 --> 02:02:37,000
等等啊

3208
02:02:37,000 --> 02:02:39,000
这不是一个非常

3209
02:02:39,000 --> 02:02:40,000
就是

3210
02:02:40,000 --> 02:02:42,000
如果你用 bundler 的话

3211
02:02:42,000 --> 02:02:43,000
bundler 本身是个 Gem

3212
02:02:44,000 --> 02:02:47,000
然后你用 bundler 来管理你的 Gem 依赖的话

3213
02:02:47,000 --> 02:02:49,000
bundler 默认是安装在当前目录下的

3214
02:02:49,000 --> 02:02:51,000
啊

3215
02:02:51,000 --> 02:02:52,000
ok

3216
02:02:52,000 --> 02:02:56,000
就如果你只要用一个他给的那个

3217
02:02:56,000 --> 02:02:57,000
不是他给的

3218
02:02:57,000 --> 02:03:03,000
就是他如果你用 bundler 这个 Gem 来管理你的项目的依赖的 Gem 的话

3219
02:03:03,000 --> 02:03:07,000
which is industry standard

3220
02:03:07,000 --> 02:03:11,000
就是几乎每一个好一点的 Ruby 项目几乎都是用 bundler 的

3221
02:03:11,000 --> 02:03:11,000
ok

3222
02:03:11,000 --> 02:03:14,000
然后你就不会去污染你的全局的项目了

3223
02:03:14,000 --> 02:03:17,000
所以还是有一个 best practice 在那里的

3224
02:03:17,000 --> 02:03:18,000
对有一个 best practice

3225
02:03:18,000 --> 02:03:18,000
ok

3226
02:03:18,000 --> 02:03:21,000
不像我不像不像笔阵营

3227
02:03:21,000 --> 02:03:22,000
我已经不是了

3228
02:03:22,000 --> 02:03:24,000
我已经宣布脱离了

3229
02:03:24,000 --> 02:03:24,000
好吧

3230
02:03:24,000 --> 02:03:25,000
ok

3231
02:03:25,000 --> 02:03:27,000
讲回 node 这个东西啊

3232
02:03:27,000 --> 02:03:28,000
npm

3233
02:03:28,000 --> 02:03:31,000
就它是默认是装在当前目的上面的

3234
02:03:31,000 --> 02:03:35,000
就是你可能每个工程每个项目是一个有一个自己的一个 node module

3235
02:03:35,000 --> 02:03:36,000
这么一个目录

3236
02:03:36,000 --> 02:03:41,000
然后你在里面执行 npm install 的之后的装的所有东西都会在默认在那里面

3237
02:03:41,000 --> 02:03:43,000
然后如果你是要装在系统级别的话

3238
02:03:43,000 --> 02:03:47,000
你就要加一个就-g global 这个选项

3239
02:03:47,000 --> 02:03:49,000
它才会装到你的这个加目录

3240
02:03:49,000 --> 02:03:52,000
或者是你速度的情况下装在你的系统级别的目录里面去

3241
02:03:52,000 --> 02:03:58,000
说它在一开始就鼓励一种就是所谓分完全分离嘛

3242
02:03:58,000 --> 02:04:02,000
就是我觉得他们觉得磁盘空间的损失算不得什么

3243
02:04:02,000 --> 02:04:04,000
重点是不要互相干扰

3244
02:04:04,000 --> 02:04:05,000
啊

3245
02:04:05,000 --> 02:04:06,000
所以这个就啊

3246
02:04:06,000 --> 02:04:07,000
是这种方式

3247
02:04:07,000 --> 02:04:09,000
但他有他自己的原因哈

3248
02:04:09,000 --> 02:04:12,000
就是因为在所有的这个软件包里面

3249
02:04:12,000 --> 02:04:13,000
可能 node 的

3250
02:04:13,000 --> 02:04:16,000
软件包的版本跳跃是最快的

3251
02:04:16,000 --> 02:04:21,000
我上个月装的一个什么开发一个软件的版本

3252
02:04:21,000 --> 02:04:23,000
用了一个库可能是 0.2 点几

3253
02:04:23,000 --> 02:04:26,000
有这个月升级看就已经 1.2 点几

3254
02:04:26,000 --> 02:04:28,000
对如果你想最快

3255
02:04:28,000 --> 02:04:29,000
最短

3256
02:04:29,000 --> 02:04:34,000
在最短时间之内在屏幕上获得最多的数据流

3257
02:04:34,000 --> 02:04:36,000
并且多多少少能让人看得懂的话

3258
02:04:36,000 --> 02:04:40,000
那请执行 npm update

3259
02:04:40,000 --> 02:04:41,000
对啊

3260
02:04:41,000 --> 02:04:42,000
所以也是因为这个这个残酷的现实啊

3261
02:04:42,000 --> 02:04:42,000
对啊

3262
02:04:42,000 --> 02:04:42,000
对啊

3263
02:04:42,000 --> 02:04:43,000
对啊

3264
02:04:43,000 --> 02:04:43,000
对啊

3265
02:04:43,000 --> 02:04:43,000
对啊

3266
02:04:43,000 --> 02:04:43,000
对啊

3267
02:04:43,000 --> 02:04:46,000
就是在现实使得这个可能我就是这么猜的

3268
02:04:46,000 --> 02:04:50,000
就是了这个 node 社区必须要把这种版本依赖

3269
02:04:50,000 --> 02:04:53,000
就是这个要做本就是叫什么 contained

3270
02:04:53,000 --> 02:04:56,000
就是要对局局部化

3271
02:04:56,000 --> 02:04:57,000
因为一旦安装全机

3272
02:04:57,000 --> 02:04:58,000
这个事没法玩了

3273
02:04:58,000 --> 02:04:58,000
啊

3274
02:04:58,000 --> 02:05:01,000
就是他们拥抱改变那种方式

3275
02:05:01,000 --> 02:05:01,000
对啊

3276
02:05:01,000 --> 02:05:04,000
然后他们这个他们对这个版本的

3277
02:05:04,000 --> 02:05:06,000
刚才我们讲那个交叉依赖解决这个很好

3278
02:05:06,000 --> 02:05:09,000
就他是说用我说的那种方式

3279
02:05:09,000 --> 02:05:12,000
就是各个包去用装自己的依赖

3280
02:05:12,000 --> 02:05:14,000
互相不要干扰

3281
02:05:14,000 --> 02:05:16,000
就是同样就一个最简单的例子

3282
02:05:16,000 --> 02:05:19,000
就是我写这个程序叫 A

3283
02:05:19,000 --> 02:05:21,000
然后它依赖 B 然后也依赖 C

3284
02:05:21,000 --> 02:05:25,000
然后这依赖我的程序 A 依赖 B 和 C 这两个包

3285
02:05:25,000 --> 02:05:27,000
然后 C 这个包它又依赖于 B

3286
02:05:27,000 --> 02:05:29,000
但是可能它是依赖于 B 的

3287
02:05:29,000 --> 02:05:31,000
另外一个较早或者较新的版本

3288
02:05:32,000 --> 02:05:33,000
NPM 解决方案就是说

3289
02:05:33,000 --> 02:05:35,000
那我这个程序装的时候

3290
02:05:35,000 --> 02:05:38,000
我写我要 B 的包的这个版本

3291
02:05:38,000 --> 02:05:39,000
我要 C 的包的那个版本

3292
02:05:39,000 --> 02:05:41,000
然后它就会去装这个 B

3293
02:05:41,000 --> 02:05:44,000
然后就会把这个在我当前目录的 node module 里面

3294
02:05:44,000 --> 02:05:47,000
这个有一个目录名字是 B 这个包的名字

3295
02:05:47,000 --> 02:05:49,000
还有一个名字是 C 的包的名字

3296
02:05:49,000 --> 02:05:50,000
然后你进到这个 node module

3297
02:05:50,000 --> 02:05:52,000
然后 B 那个包的那个名字的目录里面

3298
02:05:52,000 --> 02:05:56,000
就会发现它又是一个带有 node module 的一个包

3299
02:05:56,000 --> 02:05:58,000
所以它就是在每一个包里面

3300
02:05:58,000 --> 02:06:03,000
它都是独立的一个 node package 的层级关系在里面

3301
02:06:04,000 --> 02:06:07,000
就不会出现说我依赖 A 我依赖 B

3302
02:06:08,000 --> 02:06:10,000
我也依赖 CC 依赖 B 的另外一个版本

3303
02:06:10,000 --> 02:06:11,000
这种交叉

3304
02:06:11,000 --> 02:06:12,000
它依赖的会对我导致的影响

3305
02:06:12,000 --> 02:06:15,000
对我来说我是看不见 C 依赖了什么东西的

3306
02:06:16,000 --> 02:06:19,000
嗯对就这点是我觉得他做的比较好的地方

3307
02:06:19,000 --> 02:06:21,000
就是整个是很干净

3308
02:06:21,000 --> 02:06:23,000
就很这个明确很干净

3309
02:06:23,000 --> 02:06:26,000
而且是就是局域化的

3310
02:06:26,000 --> 02:06:30,000
嗯而且它的这个删除也很简单

3311
02:06:30,000 --> 02:06:31,000
你不想用了

3312
02:06:31,000 --> 02:06:34,000
你直接把那个 node module 里面的那些东西清掉就好了

3313
02:06:34,000 --> 02:06:39,000
对就不会在你操作系统的其他任何地方留下垃圾

3314
02:06:39,000 --> 02:06:39,000
如果你有洁癖的话

3315
02:06:39,000 --> 02:06:40,000
这个也是相当

3316
02:06:41,000 --> 02:06:41,000
相当解

3317
02:06:41,000 --> 02:06:43,000
令人解放的一件事情

3318
02:06:43,000 --> 02:06:45,000
对啊然后这跟 JavaScript 的特性有关嘛

3319
02:06:45,000 --> 02:06:52,000
就 JavaScript 它不是一种呃严格意义上的为

3320
02:06:52,000 --> 02:06:59,000
几年和不同系统组建的 Glue language 而出现的

3321
02:06:59,000 --> 02:07:03,000
对对对嗯啊然后他的其实这也出了一个问题

3322
02:07:03,000 --> 02:07:06,000
就是 JavaScript 有 native keybinding

3323
02:07:06,000 --> 02:07:09,000
呃 native binding 需要 compile 的情况出现吗

3324
02:07:09,000 --> 02:07:10,000
应该是有的

3325
02:07:10,000 --> 02:07:16,000
其实我经常安装的时候他会检查会去运行一下 C 的什么 compile 的装什么东西

3326
02:07:16,000 --> 02:07:18,000
但是具体他在做什么我也不是太清楚

3327
02:07:19,000 --> 02:07:29,000
OK 因为我印象里面 JavaScript 的 NPM 社区极端到连什么 myseqo 的二进制代码都要二进制的协议都要写一个 JavaScript 的版本

3328
02:07:29,000 --> 02:07:30,000
what

3329
02:07:30,000 --> 02:07:32,000
就不要去调用 C 库

3330
02:07:32,000 --> 02:07:33,000
这是为什么呢

3331
02:07:34,000 --> 02:07:34,000
不能调用 C 库吗

3332
02:07:34,000 --> 02:07:35,000
我不太确定

3333
02:07:36,000 --> 02:07:39,000
就你乍问我 JavaScript 怎么调用 C 库

3334
02:07:39,000 --> 02:07:40,000
但是但是对确实有一个问题是什么呢

3335
02:07:40,000 --> 02:07:43,000
第一点他们是很愿意把所有东西都用 JavaScript 重新写一遍

3336
02:07:43,000 --> 02:07:44,000
这里面其实是有好处的

3337
02:07:44,000 --> 02:07:51,000
比如说对呃你可以直接用到那个 V 8 的那个重新连动里面跑进一步 V 8 的 JIT 的特性对吧

3338
02:07:51,000 --> 02:07:53,000
然后你可以调试那些出错都很方便

3339
02:07:53,000 --> 02:07:59,000
然后你包括这样管理起来也会很方便嘛

3340
02:07:59,000 --> 02:08:01,000
嗯嗯你选极端主义者对啊

3341
02:08:01,000 --> 02:08:04,000
然后那个 NPM 他在每一个包的里面

3342
02:08:04,000 --> 02:08:07,000
他那个就是 package.json 这个文件也很简单

3343
02:08:07,000 --> 02:08:09,000
就是你把一些常见东西写进来

3344
02:08:09,000 --> 02:08:10,000
然后依赖关系进来

3345
02:08:10,000 --> 02:08:14,000
然后 NPM 这个命令行的工具也是比较强大的

3346
02:08:14,000 --> 02:08:19,000
他能他甚至连那种连你的版本号的写法都有快捷命令帮你去搞定

3347
02:08:19,000 --> 02:08:23,000
他们是遵从这个就是 Semantic version 这个做法嘛

3348
02:08:23,000 --> 02:08:26,000
就是你看 A 点 B 点 C 然后 A 是大版本号

3349
02:08:26,000 --> 02:08:28,000
说变了 API 肯定变了

3350
02:08:28,000 --> 02:08:30,000
然后 B 是小版本号是一个变的话

3351
02:08:30,000 --> 02:08:33,000
肯定是肯定是有很多各种呃新增内容

3352
02:08:33,000 --> 02:08:36,000
但是应该是下下皆容的

3353
02:08:36,000 --> 02:08:40,000
然后 C 是这个小的小升级什么 bug fix 之类不影响接口的

3354
02:08:40,000 --> 02:08:41,000
这种情况

3355
02:08:42,000 --> 02:08:45,000
嗯对他他他连这个都已经忘你忘你考虑好了

3356
02:08:45,000 --> 02:08:50,000
而且如果你这个 NPM 的包是在一个 git 里面的 reposter 里面的话

3357
02:08:50,000 --> 02:08:53,000
他甚至你做完 NPM version

3358
02:08:53,000 --> 02:08:55,000
然后 patch 或者是 minor 这种命令之后

3359
02:08:55,000 --> 02:08:59,000
就是把那个命令版本号升级一位

3360
02:08:59,000 --> 02:09:02,000
他连那个 git 的 tag 的事情都帮你做好了

3361
02:09:02,000 --> 02:09:06,000
哦真是贴心的对就是简直就是贴心小棉啊

3362
02:09:06,000 --> 02:09:08,000
哈哈哈非常方便

3363
02:09:08,000 --> 02:09:09,000
非常用起来很爽

3364
02:09:09,000 --> 02:09:10,000
而且就对

3365
02:09:10,000 --> 02:09:14,000
从一个侧面反映了 NPM 的社区其实是一个非常活力的社区

3366
02:09:14,000 --> 02:09:16,000
不管多少人怎么样

3367
02:09:16,000 --> 02:09:17,000
整个世界在嘲笑他们

3368
02:09:17,000 --> 02:09:21,000
对但可能就是因为这种受嫩者的姿态

3369
02:09:21,000 --> 02:09:23,000
迫使他们紧紧团结到了一起

3370
02:09:23,000 --> 02:09:27,000
对 NPM 社区就是软件开发界的犹太人

3371
02:09:27,000 --> 02:09:29,000
哈哈哈

3372
02:09:29,000 --> 02:09:31,000
对就反正这整个来说

3373
02:09:31,000 --> 02:09:39,000
这个 NPM 的体验是我目前用过所有的这种就是原语言原生的包管理器里面体验最好的一个吧

3374
02:09:39,000 --> 02:09:40,000
那也可能是我

3375
02:09:40,000 --> 02:09:41,000
咕噜寡没见过更好的

3376
02:09:43,000 --> 02:09:45,000
我也真的没有见过更好的

3377
02:09:45,000 --> 02:09:48,000
更好的可能就只能是什么图形化的

3378
02:09:48,000 --> 02:09:50,000
然后给最终用胡用的

3379
02:09:50,000 --> 02:09:51,000
嗯哼

3380
02:09:52,000 --> 02:09:52,000
啊

3381
02:09:52,000 --> 02:09:57,000
所以对所以这个是 NPM 的一个挺好的地方啊

3382
02:09:57,000 --> 02:09:59,000
现在再说一个现在本人的大爱

3383
02:09:59,000 --> 02:10:01,000
go 里面是怎么做的这件事

3384
02:10:01,000 --> 02:10:03,000
go 传教士 real 同学又来了

3385
02:10:03,000 --> 02:10:04,000
嗯

3386
02:10:04,000 --> 02:10:06,000
其实你知道 go 里面怎么做这件事情吗

3387
02:10:06,000 --> 02:10:07,000
go get 吗

3388
02:10:07,000 --> 02:10:08,000
不是吗

3389
02:10:08,000 --> 02:10:08,000
对但是他的哲学就是蛮奇怪的啊

3390
02:10:08,000 --> 02:10:08,000
但是他的哲学就是蛮奇怪的啊

3391
02:10:08,000 --> 02:10:08,000
但是他的哲学就是蛮奇怪的啊

3392
02:10:08,000 --> 02:10:09,000
但是他的哲学就是蛮奇怪的啊

3393
02:10:09,000 --> 02:10:09,000
但是他的哲学就是蛮奇怪的啊

3394
02:10:09,000 --> 02:10:09,000
但是他的哲学就是蛮奇怪的啊

3395
02:10:09,000 --> 02:10:10,000
但是他的哲学就是蛮奇怪的啊

3396
02:10:10,000 --> 02:10:13,000
就通常来讲前面我们提到这个像比如说啊

3397
02:10:14,000 --> 02:10:15,000
java 也好

3398
02:10:15,000 --> 02:10:16,000
拍手也好

3399
02:10:16,000 --> 02:10:17,000
node 也好

3400
02:10:17,000 --> 02:10:18,000
还有 ruby jam 也好

3401
02:10:18,000 --> 02:10:27,000
他们都有一个所谓的这个所谓官方正式认可的这么一个集中发布软件包的渠道对吧

3402
02:10:27,000 --> 02:10:28,000
对有一个 repository 在那边

3403
02:10:28,000 --> 02:10:29,000
对

3404
02:10:29,000 --> 02:10:30,000
而 go 是没有的

3405
02:10:30,000 --> 02:10:31,000
对 go 是没有的

3406
02:10:31,000 --> 02:10:37,000
go 是完全是一个去中心化的一个东一个一个一个一个这个发布方式

3407
02:10:37,000 --> 02:10:39,000
然后就会导致一些很奇怪的一些

3408
02:10:39,000 --> 02:10:40,000
状况

3409
02:10:40,000 --> 02:10:49,000
比如说你我们通常一个包的名字你要引用它的时候在比如说在拍放里面你是比如说 import json 就好了对吧

3410
02:10:49,000 --> 02:10:53,000
那可能用官方标准的你可以用 import 的一个啊

3411
02:10:53,000 --> 02:10:53,000
这个例子吧

3412
02:10:53,000 --> 02:10:56,000
另外一句个什么例子 request 的吧

3413
02:10:56,000 --> 02:10:59,000
这个这个一个 import request

3414
02:10:59,000 --> 02:10:59,000
你都整点好了

3415
02:10:59,000 --> 02:11:05,000
对他你在用的时候和他的你和怎么拿到他是一个完全分离的过程对吧

3416
02:11:05,000 --> 02:11:09,000
你是在对 people install request 他去那个拍

3417
02:11:09,000 --> 02:11:09,000
屏幕

3418
02:11:09,000 --> 02:11:10,000
上面下载回来

3419
02:11:10,000 --> 02:11:12,000
但你并不知道他到底是在哪儿

3420
02:11:12,000 --> 02:11:16,000
然后你就用的时候你也不需要关心这个东西本来是后死在哪里的

3421
02:11:16,000 --> 02:11:18,000
但 go 里面不一样

3422
02:11:18,000 --> 02:11:22,000
go 里面的 import 的那个路径

3423
02:11:22,000 --> 02:11:28,000
就是官方认可的方式就是你的那个原代码库的路径

3424
02:11:28,000 --> 02:11:30,000
就是比如说他和 repository 相关的

3425
02:11:30,000 --> 02:11:33,000
他不能做到比如说我自己有一个 github 的目录

3426
02:11:33,000 --> 02:11:38,000
我是 realgithub.com-realbar 下面一个什么软件

3427
02:11:38,000 --> 02:11:39,000
这是我的一个 go 的软件

3428
02:11:39,000 --> 02:11:44,000
我就直接要把那一段写到那个 go 的成员程序里面去

3429
02:11:44,000 --> 02:11:49,000
这样我就可以就如果我要引用某一个其他软件

3430
02:11:49,000 --> 02:11:53,000
我也得把他的那个 repository 的地址放到那个路径里面去

3431
02:11:53,000 --> 02:11:55,000
然后 go get 这个东西有个黑魔法

3432
02:11:55,000 --> 02:12:00,000
就是他能够自动识别常见的包管理的地址

3433
02:12:00,000 --> 02:12:02,000
比如他知道 github 怎么去取

3434
02:12:02,000 --> 02:12:04,000
他知道那个 bucket 怎么去取

3435
02:12:04,000 --> 02:12:06,000
他知道那个什么 mercury 那些东西怎么去取

3436
02:12:06,000 --> 02:12:09,000
然后他会自动的给

3437
02:12:09,000 --> 02:12:12,000
通过这个路径去找到那个 repository

3438
02:12:12,000 --> 02:12:12,000
下载回来

3439
02:12:12,000 --> 02:12:15,000
放到你本地的一个约定好的那个路径里面去

3440
02:12:15,000 --> 02:12:17,000
然后这样就把这个事情完成了

3441
02:12:17,000 --> 02:12:20,000
而且他是这个所谓的是一个 recursive 的一个过程

3442
02:12:20,000 --> 02:12:23,000
就是比如说我我要去 go get 一个包

3443
02:12:23,000 --> 02:12:27,000
比如大家在 github 下面某一个-bar 这个包

3444
02:12:27,000 --> 02:12:31,000
然后这个-bar 这个包他有引用的-spam 这个包

3445
02:12:31,000 --> 02:12:35,000
他会连带的把那些东西也拿回来

3446
02:12:35,000 --> 02:12:37,000
因为他能够分析到里面的 import path

3447
02:12:37,000 --> 02:12:38,000
他能够知道缺什么

3448
02:12:38,000 --> 02:12:39,000
然后他也知道一半的 report path

3449
02:12:39,000 --> 02:12:42,000
因为那个 import path 就是你的那个 gith 项目的地址

3450
02:12:42,000 --> 02:12:44,000
或者是那个 HG 项目的地址

3451
02:12:44,000 --> 02:12:47,000
他能够去到那里就把所有东西给你抓回来

3452
02:12:50,000 --> 02:12:52,000
所以他通过一种非常复杂的方式

3453
02:12:52,000 --> 02:12:56,000
使得一个包的 repository

3454
02:12:56,000 --> 02:12:58,000
somehow 成为了他的命名空间的一部分

3455
02:12:58,000 --> 02:13:00,000
对 没错

3456
02:13:00,000 --> 02:13:00,000
就这样的

3457
02:13:00,000 --> 02:13:01,000
有意思

3458
02:13:01,000 --> 02:13:05,000
那你觉得这种做法是咸的蛋疼呢

3459
02:13:05,000 --> 02:13:07,000
还是自有其道的所在

3460
02:13:07,000 --> 02:13:08,000
这个怎么说呢

3461
02:13:08,000 --> 02:13:09,000
就是友好

3462
02:13:09,000 --> 02:13:12,000
当然是友好处友坏处的好处就是简单嘛

3463
02:13:12,000 --> 02:13:17,000
就是首先他没我们讲的给他不是一个集中化的东西

3464
02:13:17,000 --> 02:13:18,000
他可是一个分布式东西

3465
02:13:18,000 --> 02:13:21,000
他没有一个所谓就他不能说你给他一个包的名字

3466
02:13:21,000 --> 02:13:23,000
他默认去哪个地方去找

3467
02:13:23,000 --> 02:13:24,000
然后帮你下载回来对吧

3468
02:13:24,000 --> 02:13:27,000
因为他没有这么一个中央存储的地方

3469
02:13:27,000 --> 02:13:30,000
所以他只能把这种方式把这个地址的信息隐藏

3470
02:13:30,000 --> 02:13:36,000
就这个这个这个嵌入到这个包的这个源代码里面去

3471
02:13:36,000 --> 02:13:37,000
然后通过这种工具这种勾给的工具去把这个事情包起来的方式是这样的

3472
02:13:37,000 --> 02:13:38,000
然后通过这种工具这种勾给的工具去把这个事情包起来的方式是这样的

3473
02:13:39,000 --> 02:13:40,000
把你解决了

3474
02:13:40,000 --> 02:13:42,000
但是他不好的地方其实也很明显了

3475
02:13:42,000 --> 02:13:44,000
比如说最简单一个例子哈

3476
02:13:44,000 --> 02:13:47,000
我用了一个包啊

3477
02:13:47,000 --> 02:13:50,000
然后我妇可了他就他的官方功能不太好

3478
02:13:50,000 --> 02:13:53,000
我妇可他我要改的时候就有你会发现很痛苦

3479
02:13:53,000 --> 02:13:58,000
因为你改的时候就会必然你妇可的就会必然改变他的那个一波的路径嘛

3480
02:13:58,000 --> 02:14:03,000
对但是如果里面有又又又一波的自己的或者别人又一波你的时候

3481
02:14:03,000 --> 02:14:08,000
你也去改相关引破到你的那个包的软件

3482
02:14:08,000 --> 02:14:09,000
才能够使得你

3483
02:14:09,000 --> 02:14:12,000
你的这个修改能够被被被别人看见

3484
02:14:15,000 --> 02:14:21,000
所以他三号增加了软件包维护的难度

3485
02:14:21,000 --> 02:14:22,000
对就有点这里有点小不爽嘛

3486
02:14:22,000 --> 02:14:25,000
就是你得去手工改一下那个一波的路径

3487
02:14:25,000 --> 02:14:30,000
如果你否可之后如果你否会没有被这个门去回去的话

3488
02:14:30,000 --> 02:14:33,000
就说你做了一个本地的不兼容的 Fuck

3489
02:14:34,000 --> 02:14:39,000
然后另外一个问题就是说你会发现没整整个过程都没有出现版本这个概念

3490
02:14:39,000 --> 02:14:43,000
比如说你可以在拍手也好还是那个 NPM 也好

3491
02:14:43,000 --> 02:14:46,000
他你去安装一个包的时候他会告诉你安装了什么版本对吧

3492
02:14:46,000 --> 02:14:53,000
对他甚至可以告诉你说请尽量安装接近于那个版本的版本对这个还挺对

3493
02:14:53,000 --> 02:14:56,000
嗯就他有一个中央存在他会有这个就是包的名字

3494
02:14:56,000 --> 02:15:00,000
然后有这个版本号包历史的版本号他会记录下来

3495
02:15:00,000 --> 02:15:07,000
然后他你可以说我可以指定说 2.02.X 版本都可以或者我一定 2.1 或者一定 2.5 或者一定 2.5.5 对吧

3496
02:15:07,000 --> 02:15:10,000
这都你都可以这么去指定或者说不高于某个版本的版本

3497
02:15:10,000 --> 02:15:14,000
这也是采用这个所谓 Semantic versioning 的一个优点嘛

3498
02:15:14,000 --> 02:15:18,000
对对没错你可以做了诸如此类的 convention 基于 convention 的事情

3499
02:15:18,000 --> 02:15:20,000
对 goal 里面完全没有版本的概念

3500
02:15:21,000 --> 02:15:26,000
goal 里面所有东西都是一个就是一个 git 就是一个 repository 的地址完了

3501
02:15:26,000 --> 02:15:33,000
然后他们的说法是说如果你发布了一个包你就不要改它的接口 forever

3502
02:15:36,000 --> 02:15:37,000
这个有点太太过了

3503
02:15:37,000 --> 02:15:37,000
太过了这个有点太太过了

3504
02:15:37,000 --> 02:15:38,000
太任性了吧

3505
02:15:38,000 --> 02:15:41,000
这简直就是 google 就是这么任性

3506
02:15:41,000 --> 02:15:45,000
对简直就是任这哪里是任性简直是强硬好不好

3507
02:15:45,000 --> 02:15:49,000
嗯然后其实然后他们的这个说法也很简单

3508
02:15:49,000 --> 02:15:54,000
就是说如果你做了一个啊就是什么接口不兼容的改进

3509
02:15:54,000 --> 02:15:57,000
那么请用一个新的 import 的地址

3510
02:15:57,000 --> 02:16:04,000
这个我觉得有点那为什么不能再就让他更进一步就直接指定这个 repository 的 branch

3511
02:16:04,000 --> 02:16:07,000
对这个是很多人要吐槽的地方就是说

3512
02:16:07,000 --> 02:16:07,000
那为什么不能再就让他更进一步就直接指定这个 repository 的 branch

3513
02:16:07,000 --> 02:16:11,000
那为什么不支持你那我直接说你我可以 tag 吗对吧

3514
02:16:11,000 --> 02:16:14,000
我可以 tag 某一个版本这样也可以啊

3515
02:16:14,000 --> 02:16:16,000
但是你想想按理说还蛮合理的对吧

3516
02:16:16,000 --> 02:16:18,000
但问题出在哪呢

3517
02:16:18,000 --> 02:16:25,000
问题出在 go 也没有指定一个默认的软件控制的软件

3518
02:16:25,000 --> 02:16:26,000
version control 的东西

3519
02:16:26,000 --> 02:16:28,000
就说比如说 git 里面有 branch 的概念

3520
02:16:28,000 --> 02:16:31,000
然后这个 mercury 里面有这个 branch 的概念

3521
02:16:31,000 --> 02:16:32,000
scv 有吗

3522
02:16:34,000 --> 02:16:35,000
也有好像有创作

3523
02:16:35,000 --> 02:16:35,000
scv

3524
02:16:36,000 --> 02:16:37,000
c s

3525
02:16:37,000 --> 02:16:37,000
不 c s

3526
02:16:37,000 --> 02:16:38,000
s v s

3527
02:16:38,000 --> 02:16:40,000
s v s

3528
02:16:40,000 --> 02:16:40,000
是错

3529
02:16:40,000 --> 02:16:41,000
不好意思

3530
02:16:41,000 --> 02:16:41,000
s v s

3531
02:16:41,000 --> 02:16:42,000
c s v

3532
02:16:42,000 --> 02:16:43,000
c s v s

3533
02:16:43,000 --> 02:16:43,000
comma

3534
02:16:43,000 --> 02:16:44,000
comma separated

3535
02:16:45,000 --> 02:16:46,000
对

3536
02:16:46,000 --> 02:16:47,000
挖矿机是吧

3537
02:16:47,000 --> 02:16:48,000
c s v

3538
02:16:48,000 --> 02:16:49,000
c s v 不支持对吧

3539
02:16:49,000 --> 02:16:50,000
还有 subversion

3540
02:16:50,000 --> 02:16:52,000
它里面也是没有 tag 的概念

3541
02:16:52,000 --> 02:16:54,000
就就很 subversion 是有 ok

3542
02:16:54,000 --> 02:16:56,000
subversion 其实是有 branch 的

3543
02:16:56,000 --> 02:16:58,000
不过这 branch 是非常重量级的 branch

3544
02:16:58,000 --> 02:16:58,000
对

3545
02:16:58,000 --> 02:17:01,000
就是说其实你要去兼容那个你没有这些东西

3546
02:17:01,000 --> 02:17:05,000
就是最最基础的你只有一个 url 而已

3547
02:17:05,000 --> 02:17:07,000
就你不能去指定其他东西

3548
02:17:07,000 --> 02:17:12,000
而且因为 go get 也是封装了那些命令行工具而已

3549
02:17:12,000 --> 02:17:14,000
就是包括封装了 git 封装了 hg

3550
02:17:14,000 --> 02:17:18,000
封装了那个什么 subversion 是什么命令

3551
02:17:19,000 --> 02:17:21,000
s v n

3552
02:17:21,000 --> 02:17:23,000
s v n 对它封装那些命令的调用

3553
02:17:23,000 --> 02:17:26,000
它也没有办法去强制说

3554
02:17:27,000 --> 02:17:30,000
哎你能用个一个什么样的方法去

3555
02:17:30,000 --> 02:17:32,000
大家在不同的版本库之间

3556
02:17:32,000 --> 02:17:35,000
不同的用不同的方法管理软件版本的

3557
02:17:35,000 --> 02:17:35,000
也能够指定同一个版本出版的版本呢

3558
02:17:35,000 --> 02:17:36,000
也能够指定同一个版本出版的版本呢

3559
02:17:36,000 --> 02:17:37,000
对吧

3560
02:17:37,000 --> 02:17:39,000
所以其实就就变得这个很难嘛

3561
02:17:39,000 --> 02:17:42,000
你知道凡是一旦变成分布式

3562
02:17:42,000 --> 02:17:47,000
没有一个中央集权的东西就变得很很很难很难解决

3563
02:17:47,000 --> 02:17:49,000
对这也是其中之一

3564
02:17:49,000 --> 02:17:52,000
啊所以现在有一些就是社区来的一些方法

3565
02:17:52,000 --> 02:17:59,000
就是说那我们不要这就为了解决这个刚才说这个版本管理的问题

3566
02:17:59,000 --> 02:18:04,000
我们指定版本我们不简单的直接用 go get

3567
02:18:04,000 --> 02:18:06,000
我们是说写一个文件

3568
02:18:06,000 --> 02:18:10,000
声明我需要哪一个软件的哪一个版本

3569
02:18:10,000 --> 02:18:12,000
通过一个 branch 也好

3570
02:18:12,000 --> 02:18:14,000
还是通过这个 git tag 或者什么方式也好

3571
02:18:14,000 --> 02:18:15,000
把它写在一起

3572
02:18:15,000 --> 02:18:21,000
然后我再通过这个第三方的社区维护的工具去去安装这软件版本

3573
02:18:21,000 --> 02:18:23,000
而不是用这个官方的这个 go get 的这种形式

3574
02:18:25,000 --> 02:18:31,000
OK 对那具体来说有什么样的呃有一个比较常见的一个叫 go dep

3575
02:18:31,000 --> 02:18:32,000
go dep

3576
02:18:32,000 --> 02:18:35,000
第一批就是 go dependency 的一个 go dependency

3577
02:18:35,000 --> 02:18:36,000
对

3578
02:18:36,000 --> 02:18:37,000
对没有一个工具吗

3579
02:18:37,000 --> 02:18:42,000
还有一些其其其他就在这一块沟里面就社区里面还是有三四个选项吧

3580
02:18:42,000 --> 02:18:44,000
就是看看我不知道之后会怎么样

3581
02:18:44,000 --> 02:18:48,000
那现在 go dep 这个是一个比较用的比较多的一个工具

3582
02:18:48,000 --> 02:18:51,000
嗯啊然后另外一个要解决的问题就是说

3583
02:18:51,000 --> 02:18:55,000
如果你分布是你也没有一个集中存储代码的地方

3584
02:18:55,000 --> 02:19:00,000
那同样的你也不能保证那个代码你今天在哪儿明天还在那儿对吧

3585
02:19:00,000 --> 02:19:03,000
那个人可能就直接把他的 git 项目删除了对吧

3586
02:19:03,000 --> 02:19:06,000
之前也有遇到过什么那个什么 y 啊

3587
02:19:06,000 --> 02:19:12,000
还有那几个人他从网上消失的时候连带着把他的那个什么 github 账号也给清掉了

3588
02:19:12,000 --> 02:19:16,000
这样如果你一来他代码你会想哇没了怎么办

3589
02:19:16,000 --> 02:19:17,000
没错

3590
02:19:17,000 --> 02:19:22,000
对所以这其实是一个比较推在这种分布社场下一个比较推荐的方式就是说

3591
02:19:22,000 --> 02:19:27,000
你把你需要依赖代码也加入你的版本地的版本控制里面去

3592
02:19:27,000 --> 02:19:35,000
对然后这样的话有一些什么难度呢就是那你要想办法你怎么去分离你自己写代码和你依赖的代码的这个历史的版本的管理呢

3593
02:19:35,000 --> 02:19:37,000
你看你最好是能够区别开来对吧

3594
02:19:37,000 --> 02:19:39,000
这样可以分别升级嘛

3595
02:19:39,000 --> 02:19:46,000
对这也就无形中增加了你对要求你对版本管理系统又要有足够多的知识

3596
02:19:46,000 --> 02:19:53,000
而相比之下其他的语言就可以比较专心的放在开发上

3597
02:19:53,000 --> 02:19:58,000
对对对但其实这个怎么来说从总体来可用性的角度来讲这个反而是好的

3598
02:19:58,000 --> 02:20:02,000
因为这样的话你就可以确保你你只要拿到这个软件包

3599
02:20:02,000 --> 02:20:04,000
只要这个软件包里面的所有依赖是通过这种方式来做的

3600
02:20:04,000 --> 02:20:08,000
就是你把它 check 进你的本地的这个代码库里面

3601
02:20:08,000 --> 02:20:11,000
那么你拿到这个代码库里面你知道它是一个完整的

3602
02:20:11,000 --> 02:20:14,000
就是你可以用代码库编辑出来一个最终的结果

3603
02:20:14,000 --> 02:20:17,000
不需要去再经过一个网络的下载的这么一个过程

3604
02:20:17,000 --> 02:20:22,000
OK 所以如果你要用你要为世界的终结做准备的话

3605
02:20:22,000 --> 02:20:24,000
那请跟我来编辑

3606
02:20:24,000 --> 02:20:27,000
对所以所以就是它是一个你可以看到的

3607
02:20:27,000 --> 02:20:32,000
刚才我们这一系列的主题都是一个无中心的这么一个一个一个诉求

3608
02:20:32,000 --> 02:20:34,000
所以从从这个

3609
02:20:34,000 --> 02:20:38,000
这一点来讲它跟 git 的想法其实是还是蛮不谋而合的

3610
02:20:38,000 --> 02:20:44,000
对就 git 说我不要什么 svn 和 svc 都是需要有个中央服务器

3611
02:20:44,000 --> 02:20:45,000
你才可以 check in

3612
02:20:45,000 --> 02:20:47,000
才可以同步软件的代码

3613
02:20:47,000 --> 02:20:51,000
但是 git 不需要你可以本地修改本地 commit 对吧

3614
02:20:51,000 --> 02:20:56,000
对 go 的话也是这样本地编译本地出结果这样就比较好一点

3615
02:20:56,000 --> 02:21:01,000
当然代价也就是用起来会比较繁琐

3616
02:21:01,000 --> 02:21:02,000
而且在就是 go 官方是对这个事情是美好的

3617
02:21:02,000 --> 02:21:03,000
对吧

3618
02:21:04,000 --> 02:21:07,000
所以没有说法就是说你们自己想办法解决我们不管

3619
02:21:07,000 --> 02:21:13,000
因为因为这里面有一个很务实的情况就是因为 go 的大部分开发者还是 google 嘛

3620
02:21:13,000 --> 02:21:14,000
google 的一些过程师

3621
02:21:14,000 --> 02:21:20,000
然后他们 google 内部是用一个非常复杂先进的 build 的系统在写程序

3622
02:21:20,000 --> 02:21:23,000
哪怕是但是他们是这个跨语言的

3623
02:21:23,000 --> 02:21:26,000
啊所以他们也不用这个 go get 来装程序

3624
02:21:26,000 --> 02:21:28,000
所以那么内部

3625
02:21:28,000 --> 02:21:30,000
go get 到底是做给谁做给谁用的

3626
02:21:30,000 --> 02:21:33,000
如果不吃自己狗食的话那么他们是开发条是用吗

3627
02:21:33,000 --> 02:21:36,000
就是你可以因为他大部分时候还是可以用的

3628
02:21:36,000 --> 02:21:38,000
你不是说你每天要 go get 一遍对吧

3629
02:21:38,000 --> 02:21:39,000
你 go get 回来一个版本

3630
02:21:39,000 --> 02:21:41,000
他大部分时候还是稳定可靠的

3631
02:21:41,000 --> 02:21:45,000
因为他还是鼓励说这个 API 要尽量稳定可靠嘛

3632
02:21:45,000 --> 02:21:48,000
所以你拿回来大部分时候还是可还是可用的

3633
02:21:48,000 --> 02:21:50,000
只是说当你要正式发布的时候

3634
02:21:50,000 --> 02:21:55,000
你最好把你的依赖那些通过刚才我讲的那些方法 check 到你本地的一个目录里面去

3635
02:21:55,000 --> 02:21:59,000
这样的话会呃稳就可靠性会好一些嘛

3636
02:21:59,000 --> 02:22:02,000
ok 嗯对对所以也是就是说

3637
02:22:02,000 --> 02:22:12,000
因为 go 它官方没有一个呃说法也没有一个他们自己内部也用的东西也他们那个用内部用那个也不是开源的嘛

3638
02:22:12,000 --> 02:22:13,000
也不是一个商业系统

3639
02:22:13,000 --> 02:22:19,000
所以就没有办法把它共享给我们共享就是哪个也用不了太复杂

3640
02:22:19,000 --> 02:22:25,000
对这个其实 sum 好跟呃苹果这边的阵营差不多啊

3641
02:22:25,000 --> 02:22:32,000
苹果也是不管 objects c 还是 swift 其实都没有一个官方的版本呃包管理系统

3642
02:22:32,000 --> 02:22:40,000
嗯哼呃 cocoapos 虽然是目前的既成事实的包管系统

3643
02:22:40,000 --> 02:22:49,000
但好像官方也没有表表现出任何态度是支持他还是觉得可能要拿出来要自己另做一套的

3644
02:22:49,000 --> 02:22:51,000
苹果应该不会管这种事情吧

3645
02:22:51,000 --> 02:22:57,000
我觉得嗯我觉得对于开发者来说这个东西其实还是蛮重要的

3646
02:22:57,000 --> 02:23:01,000
对这这肯定毫不怀疑但问题是说苹果会觉得这个事情很重要

3647
02:23:02,000 --> 02:23:11,000
我很怀疑嗯我是觉得上次 wc 之后苹果既然对开发者有了这么难得一次的微笑呢

3648
02:23:11,000 --> 02:23:14,000
也许接下来有些事情也是可以梦想的啊是吗

3649
02:23:14,000 --> 02:23:20,000
那你我你我强烈建议你听一下还没应该是明天发布的 it 功能第 131 期

3650
02:23:20,000 --> 02:23:25,000
看一下苹果对开发者的真实态度是什么啊好吧嗯

3651
02:23:25,000 --> 02:23:32,000
就觉得又要被泼冷水了对今年的那个 youtube 的 reven 的 somehow 泼冷水泼了很久了

3652
02:23:32,000 --> 02:23:43,000
为什么就 youtube 年末的时候会有 reven 的视频嘛就是隶属那个今年知名的比较动词应该是 sorry

3653
02:23:43,000 --> 02:23:50,000
对 reven 啊 sorry 我记得应该是动词的情况下 reven 啊 anyway 嗯

3654
02:23:50,000 --> 02:24:02,000
对然后它里面会隶属今年的 reven 比较知名的视频然后把它们以某种方式重新拍一遍然后在里面因为今年冰桶挑战很出名嘛 ok

3655
02:24:02,000 --> 02:24:08,000
然后在里面有大量那个知名人士互相泼冷水泼冰水泼冰水的情节

3656
02:24:08,000 --> 02:24:12,000
然后难道明天我要被泼冰水了

3657
02:24:12,000 --> 02:24:21,000
嗯不过刚才今天刚才前面讲了这么多就是各个语言自己本身的一些包管理的机制也好一些软件也好

3658
02:24:21,000 --> 02:24:28,000
其实我一直有一个问题为什么没有一个能够跨语言解决这个问题的工具呢

3659
02:24:28,000 --> 02:24:31,000
就是我们为什么每个语言出来都要自己在重复这么一个语言呢

3660
02:24:31,000 --> 02:24:39,000
重复这么一套很麻烦啰嗦的事情然后要把这个已经解决问题再解决一遍呢

3661
02:24:39,000 --> 02:24:43,000
嗯

3662
02:24:43,000 --> 02:24:48,000
如果你要说这个的话那我觉得 nugget 可能是一个这样的工具吧

3663
02:24:48,000 --> 02:24:50,000
为什么

3664
02:24:50,000 --> 02:24:58,000
因为你觉得 nugget 并不限定于是专门为 csh 或者是专门为 dotnet 平台所做的一个包管的工具啊

3665
02:24:58,000 --> 02:24:59,000
它

3666
02:24:59,000 --> 02:25:01,000
它你像我刚才说的它可以它可以

3667
02:25:01,000 --> 02:25:03,000
拿到 jquery 这种东西

3668
02:25:03,000 --> 02:25:04,000
啊这个我没有意义

3669
02:25:04,000 --> 02:25:11,000
但我是说比如说像啊那个这个什么 node 的那些 npm 它只能装 javascript 的包嘛

3670
02:25:11,000 --> 02:25:14,000
然后 ruby 也只能装 ruby 的包嘛

3671
02:25:14,000 --> 02:25:20,000
就是说在现在流行的那些东西都是根据各个语言那个独特的一些系统

3672
02:25:20,000 --> 02:25:23,000
并不能有一个通用的系统去解决它们之间的问题

3673
02:25:23,000 --> 02:25:29,000
你是说如果 nugget 这种方式流行起来我们也可以用 nugget 装那个 javascript 的包

3674
02:25:29,000 --> 02:25:31,000
然后用 nugget 装 gold 的包吗

3675
02:25:31,000 --> 02:25:32,000
还是怎么样

3676
02:25:32,000 --> 02:25:44,000
可是反过来我的理解是有些语言的部分包也是可以通过比如说 app 之类的东西来安装的呀

3677
02:25:44,000 --> 02:25:45,000
对对对

3678
02:25:45,000 --> 02:25:52,000
但是如果朝这个方向发展的话你是不是就可以说那整个系统平台上干脆只有一个包管的系统

3679
02:25:52,000 --> 02:26:00,000
它既负责软件安装又负责所有语言的相关包安装就可以了呢

3680
02:26:00,000 --> 02:26:01,000
那我觉得

3681
02:26:01,000 --> 02:26:07,000
其实对于 c 语言来说 c 语言没有一个系统实时的安装包管理系统对吧

3682
02:26:07,000 --> 02:26:12,000
那可是反过来说你可以说任何一个 apt 也好那个 yam 也好

3683
02:26:12,000 --> 02:26:20,000
你在安装那些 develop dev 或者是 develop 包的时候

3684
02:26:20,000 --> 02:26:25,000
你不就已经安装了这个语言 c 语言所需要的投文件吗

3685
02:26:25,000 --> 02:26:30,000
那也许一个语言发展到足够壮大的时候它也许就可以

3686
02:26:30,000 --> 02:26:36,000
可以通过一个泛用的 package manager 来解决这个问题了

3687
02:26:36,000 --> 02:26:41,000
其实还是一个就是说这个不够成熟的表现嘛

3688
02:26:41,000 --> 02:26:43,000
对应该是这样的

3689
02:26:43,000 --> 02:26:49,000
但参差不齐乃是生活之美的来源是这么说吗

3690
02:26:49,000 --> 02:26:59,000
确实但我不确定这在程序语言这一套就在包管理器这一样是不是一定是好的但是

3691
02:26:59,000 --> 02:27:05,000
每次跨一个语言都要重新学习一遍还是蛮高成本的一件事情吧我觉得

3692
02:27:05,000 --> 02:27:08,000
这就是 polyglot 的宿命

3693
02:27:08,000 --> 02:27:10,000
好悲伤

3694
02:27:10,000 --> 02:27:17,000
如果你只会 java 的话也许就没有所有这些痛苦了你会生活在一种无知的幸福里面

3695
02:27:17,000 --> 02:27:19,000
这是一个悲伤的故事

3696
02:27:21,000 --> 02:27:24,000
好吧已经两个半小时了

3697
02:27:24,000 --> 02:27:25,000
好今天结束吧要不然

3698
02:27:25,000 --> 02:27:28,000
对今天我们的吐槽那就到这里为止吧

3699
02:27:29,000 --> 02:27:34,000
对我们今天的主题是 package management

3700
02:27:34,000 --> 02:27:41,000
其实我们本来还想就这个话题延伸到比如说一个做好的包子

3701
02:27:41,000 --> 02:27:46,000
然后部署到服务器上以及围绕着部署所产生的一系列问题

3702
02:27:46,000 --> 02:27:52,000
比如说部署并不简简简简简单单的是把一个 binary 扔到服务器上去运行这么简单

3703
02:27:52,000 --> 02:27:55,000
当然对于某些构成学员来说这是可能的

3704
02:27:55,000 --> 02:27:58,000
但对于我们其他的熟民来说

3705
02:27:58,000 --> 02:28:01,000
这里面还是有很多学问所在

3706
02:28:01,000 --> 02:28:04,000
但是今天我们也没有时间展开了

3707
02:28:04,000 --> 02:28:09,000
所以还是下次吧下次找机会吧就明年再说吧

3708
02:28:09,000 --> 02:28:11,000
See you in 2015

3709
02:28:13,000 --> 02:28:18,000
就是各位听到我们这期节目的时候应该还有两三天就要新年了

3710
02:28:18,000 --> 02:28:21,000
那也在这里祝大家新年快乐

3711
02:28:23,000 --> 02:28:25,000
好我们下期再见

3712
02:28:25,000 --> 02:28:28,000
连同这前两期的

3713
02:28:28,000 --> 02:28:30,000
所有的 feedback

3714
02:28:30,000 --> 02:28:32,000
明年再见

3715
02:28:32,000 --> 02:28:33,000
我写着新年的新气象

3716
02:28:33,000 --> 02:28:33,000
对

3717
02:28:33,000 --> 02:28:38,000
重新来做一期新的内核工

3718
02:28:38,000 --> 02:28:40,000
OK

3719
02:28:40,000 --> 02:28:41,000
我们今天做了七期

3720
02:28:41,000 --> 02:28:42,000
不错

