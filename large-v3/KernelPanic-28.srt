1
00:00:00,000 --> 00:00:01,000
欢迎收听 IPM Podcast

2
00:00:01,000 --> 00:00:03,000
网络旗下的 IT 技术主题娱乐节目

3
00:00:03,000 --> 00:00:04,000
内核恐慌

4
00:00:04,000 --> 00:00:05,000
我们号称 hardcore

5
00:00:05,000 --> 00:00:06,000
但是也没有干货

6
00:00:06,000 --> 00:00:07,000
想听的人听

7
00:00:07,000 --> 00:00:08,000
不想听的人就别听

8
00:00:08,000 --> 00:00:11,000
本节目的网址是 kernelpanic.fm

9
00:00:11,000 --> 00:00:12,000
我们推荐大家使用 podcast 客户端

10
00:00:12,000 --> 00:00:13,000
订阅我们的节目

11
00:00:13,000 --> 00:00:16,000
想请请访问 ipm.li.faq

12
00:00:16,000 --> 00:00:18,000
欢迎你为本节目捐款

13
00:00:18,000 --> 00:00:22,000
捐款地址是 kernelpanic.fm.donate

14
00:00:22,000 --> 00:00:23,000
捐款金额随意

15
00:00:23,000 --> 00:00:25,000
只要是 8 的正常数倍就可以

16
00:00:25,000 --> 00:00:27,000
捐款不会为你带来什么

17
00:00:27,000 --> 00:00:28,000
不捐也不会让你失去什么

18
00:00:28,000 --> 00:00:31,000
这句话好像成了一个密码

19
00:00:31,000 --> 00:00:33,000
你们上期 IT 公论

20
00:00:33,000 --> 00:00:34,000
为什么要插入这句话

21
00:00:34,000 --> 00:00:35,000
非常突兀

22
00:00:35,000 --> 00:00:35,000
我觉得

23
00:00:35,000 --> 00:00:37,000
anyway

24
00:00:37,000 --> 00:00:39,000
我们的口号是

25
00:00:39,000 --> 00:00:42,000
it's easier to port a shell

26
00:00:42,000 --> 00:00:43,000
than a shell script

27
00:00:43,000 --> 00:00:45,000
from level 1

28
00:00:45,000 --> 00:00:48,000
对

29
00:00:48,000 --> 00:00:50,000
所以我们这期又有主题了

30
00:00:50,000 --> 00:00:52,000
不过在进入主题之前

31
00:00:52,000 --> 00:00:54,000
我们先来做一下

32
00:00:54,000 --> 00:00:55,000
上一期的听众反馈

33
00:00:55,000 --> 00:00:58,000
首先是我们的热心听众

34
00:00:58,000 --> 00:00:58,000
我们的热心听众

35
00:00:58,000 --> 00:01:00,000
Chatlaw 先生

36
00:01:00,000 --> 00:01:05,000
远在澳大利亚为我们写来的听众反馈

37
00:01:05,000 --> 00:01:05,000
说

38
00:01:05,000 --> 00:01:06,000
二位前辈好

39
00:01:06,000 --> 00:01:09,000
第 27 期提到了用 QQ 发来码的问题

40
00:01:09,000 --> 00:01:12,000
二位似乎在疑惑什么场景需要怎么做

41
00:01:12,000 --> 00:01:15,000
一个典型的例子就是 group assignment

42
00:01:15,000 --> 00:01:16,000
虽然我本课不在国内

43
00:01:16,000 --> 00:01:17,000
不了解国内院校的细节

44
00:01:17,000 --> 00:01:19,000
不过如果不用 GIT

45
00:01:19,000 --> 00:01:20,000
而且没有退而求其次

46
00:01:20,000 --> 00:01:23,000
使用丢丢盒等同步盘的话

47
00:01:23,000 --> 00:01:25,000
组员动下来

48
00:01:25,000 --> 00:01:26,000
这是什么东西

49
00:01:26,000 --> 00:01:28,000
这是

50
00:01:28,000 --> 00:01:31,000
这是绾营教会我使用的

51
00:01:31,000 --> 00:01:32,000
Jobbox 的昵称

52
00:01:32,000 --> 00:01:33,000
丢丢

53
00:01:33,000 --> 00:01:34,000
丢丢

54
00:01:34,000 --> 00:01:35,000
对

55
00:01:35,000 --> 00:01:37,000
组员共享代码

56
00:01:37,000 --> 00:01:40,000
就只有使用 QQ 这种门槛交递的方式

57
00:01:40,000 --> 00:01:41,000
然而即使在国外

58
00:01:41,000 --> 00:01:42,000
效果

59
00:01:42,000 --> 00:01:44,000
情况也不能说理想

60
00:01:44,000 --> 00:01:46,000
我校虽然有顶级大牛

61
00:01:46,000 --> 00:01:52,000
本科毕设就是给 GHC 添加 LMVM 后端

62
00:01:52,000 --> 00:01:54,000
也还是有人不会用 GIT

63
00:01:54,000 --> 00:01:56,000
做 group assignment 的时候

64
00:01:56,000 --> 00:01:58,000
把代码从自己的 Eclipser

65
00:01:58,000 --> 00:02:01,000
拷贝到 Bitbucket 的网页编辑器

66
00:02:01,000 --> 00:02:04,000
不经意间就三番五次覆盖掉别人的成果

67
00:02:04,000 --> 00:02:06,000
以我一介本科生的潜见

68
00:02:06,000 --> 00:02:08,000
这大概与计算机课程覆盖面太广

69
00:02:08,000 --> 00:02:10,000
与其他学科相比

70
00:02:10,000 --> 00:02:13,000
签烧线系统性也有关系

71
00:02:13,000 --> 00:02:15,000
如果以理工划分

72
00:02:15,000 --> 00:02:17,000
计算机是既有理又有工

73
00:02:17,000 --> 00:02:18,000
除了计算理论

74
00:02:18,000 --> 00:02:22,000
PLT 等非常形式化理论化的东西

75
00:02:22,000 --> 00:02:25,000
也有例如 GIT 这样乍一看非常的脏

76
00:02:25,000 --> 00:02:28,000
但是考虑了很多因素的

77
00:02:28,000 --> 00:02:28,000
Best of the best

78
00:02:28,000 --> 00:02:29,000
Best practice

79
00:02:29,000 --> 00:02:32,000
当然指望学校覆盖这么多内容也不现实

80
00:02:32,000 --> 00:02:35,000
毕竟这是一个非常依赖个人修行的行业

81
00:02:35,000 --> 00:02:37,000
猪本节目就没有了

82
00:02:37,000 --> 00:02:38,000
所以其实让我想起

83
00:02:38,000 --> 00:02:40,000
今天我们后面要提到一个小插曲

84
00:02:40,000 --> 00:02:42,000
就是为什么说

85
00:02:42,000 --> 00:02:45,000
就是这个马农

86
00:02:45,000 --> 00:02:46,000
就是什么

87
00:02:46,000 --> 00:02:48,000
不能把马农称为软件工程师的一个原因

88
00:02:48,000 --> 00:02:52,000
Programmers stop calling yourself engineers

89
00:02:52,000 --> 00:02:56,000
就是如果说你对这些工具流程都没有一个很

90
00:02:56,000 --> 00:02:58,000
或者说

91
00:02:58,000 --> 00:02:58,000
其实

92
00:02:58,000 --> 00:02:59,000
这怎么说

93
00:02:59,000 --> 00:03:00,000
可能要反过来讲

94
00:03:00,000 --> 00:03:02,000
就是像那种就是理

95
00:03:02,000 --> 00:03:04,000
叫 computer science 的学校

96
00:03:04,000 --> 00:03:06,000
他可能很多人会觉得这种工具层面的东西

97
00:03:06,000 --> 00:03:09,000
跟这个 science 其实并没有什么太多的关系

98
00:03:09,000 --> 00:03:10,000
对吧

99
00:03:10,000 --> 00:03:14,000
然后他会觉得或多或少的会在这个层面上轻视这个东西

100
00:03:14,000 --> 00:03:15,000
因为觉得

101
00:03:15,000 --> 00:03:16,000
都是脏货

102
00:03:16,000 --> 00:03:20,000
他不是就是非核心的东西吗

103
00:03:20,000 --> 00:03:22,000
也就是属于叫什么来的

104
00:03:22,000 --> 00:03:24,000
技校教的东西

105
00:03:24,000 --> 00:03:26,000
不应该是大学教的东西

106
00:03:26,000 --> 00:03:28,000
其实我觉得这个就不太

107
00:03:28,000 --> 00:03:29,000
对

108
00:03:29,000 --> 00:03:31,000
如果说你真的是想做工程的话

109
00:03:31,000 --> 00:03:34,000
你真的要做 software engineer 的话

110
00:03:34,000 --> 00:03:35,000
你很难想象一个

111
00:03:35,000 --> 00:03:37,000
什么传统建筑行业的

112
00:03:37,000 --> 00:03:39,000
或者就是建筑工程师

113
00:03:39,000 --> 00:03:42,000
你会让他说他不会用那些什么那些工具

114
00:03:42,000 --> 00:03:43,000
比如什么仪器

115
00:03:43,000 --> 00:03:44,000
还有那个量

116
00:03:44,000 --> 00:03:45,000
那种架子

117
00:03:45,000 --> 00:03:47,000
什么测试用的那些东西

118
00:03:47,000 --> 00:03:47,000
对吧

119
00:03:47,000 --> 00:03:49,000
你肯定是要学这些基本的操作的

120
00:03:49,000 --> 00:03:52,000
就是我还记得像哪怕是学物理的话

121
00:03:52,000 --> 00:03:54,000
你他要学会用各种各样的

122
00:03:54,000 --> 00:03:55,000
这个叫什么来的

123
00:03:55,000 --> 00:03:57,000
有标卡尺

124
00:03:57,000 --> 00:03:58,000
或者是一些根根的东西

125
00:03:58,000 --> 00:03:59,000
高级的一些工具

126
00:03:59,000 --> 00:03:59,000
对吧

127
00:03:59,000 --> 00:04:01,000
那是高中物理吧

128
00:04:01,000 --> 00:04:04,000
我觉得其实物理学的分野已经很明显了

129
00:04:04,000 --> 00:04:06,000
有些理论物理学家真的是完全不做实验的

130
00:04:06,000 --> 00:04:08,000
你看那个 TBBT 里面

131
00:04:08,000 --> 00:04:09,000
Sheldon 不是也一直在嘲笑

132
00:04:09,000 --> 00:04:11,000
动手做实验

133
00:04:11,000 --> 00:04:12,000
对啊

134
00:04:12,000 --> 00:04:19,000
我觉得其实就是有这个理论和实践的分野的学科

135
00:04:19,000 --> 00:04:21,000
可能都会有这种多多少少的

136
00:04:21,000 --> 00:04:23,000
就是做纯理论的人会轻视

137
00:04:23,000 --> 00:04:25,000
需要动手做实践的人

138
00:04:25,000 --> 00:04:27,000
因为有理论就够了

139
00:04:27,000 --> 00:04:28,000
但你刚才说的

140
00:04:28,000 --> 00:04:34,000
建筑又是完全一个比较不一样的东西

141
00:04:34,000 --> 00:04:36,000
因为建筑本身就是从实践而来的

142
00:04:36,000 --> 00:04:39,000
建筑没有什么纯理论的东西

143
00:04:39,000 --> 00:04:42,000
或者说有但没有那么脱离现实的纯理论

144
00:04:42,000 --> 00:04:46,000
他不会研究真空中的纯球形建筑

145
00:04:46,000 --> 00:04:51,000
以后我们造那个 space ship 的时候

146
00:04:51,000 --> 00:04:52,000
就需要考虑这个问题

147
00:04:52,000 --> 00:04:53,000
真空中的球形建筑

148
00:04:53,000 --> 00:04:54,000
不就是水滴吗

149
00:04:54,000 --> 00:04:55,000
不是水滴

150
00:04:55,000 --> 00:04:55,000
是

151
00:04:55,000 --> 00:04:57,000
那个啊

152
00:04:57,000 --> 00:04:58,000
Dance star

153
00:04:58,000 --> 00:05:00,000
死星和那个一切人要散

154
00:05:00,000 --> 00:05:03,000
对

155
00:05:28,000 --> 00:05:31,000
我觉得你是不配去叫自己是一个工程系的

156
00:05:31,000 --> 00:05:31,000
对

157
00:05:31,000 --> 00:05:33,000
这是肯定的

158
00:05:33,000 --> 00:05:34,000
但是如果你做纯理论的话

159
00:05:34,000 --> 00:05:40,000
又会觉得说学那些系统而为的工具的时间

160
00:05:40,000 --> 00:05:43,000
还是挺好像有点浪费

161
00:05:43,000 --> 00:05:45,000
我觉得我三号有这种印象

162
00:05:45,000 --> 00:05:47,000
就是有些学计算机的人

163
00:05:47,000 --> 00:05:49,000
他之所以不懂那些具体的工具

164
00:05:49,000 --> 00:05:50,000
乃至于学计算机科学的人

165
00:05:50,000 --> 00:05:51,000
不会修计算机

166
00:05:51,000 --> 00:05:53,000
也是因为就是

167
00:05:53,000 --> 00:05:55,000
他是工具吗

168
00:05:55,000 --> 00:05:57,000
太耗时间了

169
00:05:57,000 --> 00:05:58,000
是不是

170
00:05:58,000 --> 00:05:58,000
对

171
00:05:58,000 --> 00:06:00,000
所以我觉得就是说

172
00:06:00,000 --> 00:06:02,000
纯理论的也

173
00:06:02,000 --> 00:06:04,000
theoretical 的研究也好

174
00:06:04,000 --> 00:06:04,000
培训啊

175
00:06:04,000 --> 00:06:05,000
research 啊

176
00:06:05,000 --> 00:06:06,000
这点完全没有问题

177
00:06:06,000 --> 00:06:08,000
但是如果说你还是指望你的毕业生

178
00:06:08,000 --> 00:06:10,000
有能够在就业市场上

179
00:06:10,000 --> 00:06:11,000
起码本科哈

180
00:06:11,000 --> 00:06:12,000
你说这个博士研究生

181
00:06:12,000 --> 00:06:13,000
你说你不指望他

182
00:06:13,000 --> 00:06:15,000
你不去管他们的就业

183
00:06:15,000 --> 00:06:17,000
在那个职场

184
00:06:17,000 --> 00:06:19,000
就是做马龙这个方向的就

185
00:06:19,000 --> 00:06:21,000
其实我觉得情有可原啊

186
00:06:21,000 --> 00:06:23,000
但是如果说你是一个本科

187
00:06:23,000 --> 00:06:25,000
本科的一个教学目标

188
00:06:25,000 --> 00:06:27,000
然后你说把这些完全

189
00:06:27,000 --> 00:06:28,000
就做了这些工程系的学生

190
00:06:28,000 --> 00:06:29,000
就踢掉不不看

191
00:06:29,000 --> 00:06:30,000
我觉得是其实是有问题的

192
00:06:30,000 --> 00:06:33,000
就从务实的角度来讲

193
00:06:33,000 --> 00:06:37,000
还是从这个对这些人的未来的就业的情况来讲

194
00:06:37,000 --> 00:06:39,000
我觉得这个是有有欠考虑

195
00:06:39,000 --> 00:06:39,000
没错

196
00:06:40,000 --> 00:06:40,000
啊

197
00:06:40,000 --> 00:06:42,000
然后如果你真的这么干了

198
00:06:42,000 --> 00:06:46,000
就不要叫自己的毕业生是 software engineer

199
00:06:46,000 --> 00:06:47,000
这种这种 title 好

200
00:06:47,000 --> 00:06:47,000
对

201
00:06:49,000 --> 00:06:51,000
嗯

202
00:06:51,000 --> 00:06:52,000
下一则听这种反馈啊

203
00:06:52,000 --> 00:06:53,000
这个呃

204
00:06:53,000 --> 00:06:56,000
这个他先揪了我们一个错啊

205
00:06:56,000 --> 00:06:58,000
上次上期我们提到了

206
00:06:58,000 --> 00:06:59,000
那个那个叫做 let's encrypt

207
00:06:59,000 --> 00:07:03,000
那个一个叫 ssl 的这么一个服务吧

208
00:07:03,000 --> 00:07:07,000
他的 fonderg 的 university of michigan 是密歇根大学

209
00:07:07,000 --> 00:07:08,000
不是密歇根州立大学啊

210
00:07:08,000 --> 00:07:10,000
这个应该是我说错了

211
00:07:10,000 --> 00:07:11,000
一是最快

212
00:07:11,000 --> 00:07:14,000
所以就美国这个学校也是挺搞挺有意思

213
00:07:14,000 --> 00:07:20,000
他会有这个 michigan state 或者 university of michigan 这样两种比较坑的状况

214
00:07:20,000 --> 00:07:25,000
对你看呃武汉大学和湖北大学就是这是两所大学对吧

215
00:07:25,000 --> 00:07:26,000
没有人搞混

216
00:07:26,000 --> 00:07:26,000
但是

217
00:07:26,000 --> 00:07:35,000
为什么不不不这个是不这个是呃如果可以比的话应该是湖北大学和湖北省立大学的区别

218
00:07:35,000 --> 00:07:37,000
呃

219
00:07:37,000 --> 00:07:38,000
ok

220
00:07:38,000 --> 00:07:39,000
哈哈

221
00:07:39,000 --> 00:07:42,000
对因为没有一个城市叫了密歇根

222
00:07:42,000 --> 00:07:42,000
对

223
00:07:42,000 --> 00:07:42,000
就是

224
00:07:42,000 --> 00:07:45,000
接着念这则听众反馈啊

225
00:07:45,000 --> 00:07:46,000
啊

226
00:07:46,000 --> 00:07:49,000
本来只想随手回复一下这个小小的口误

227
00:07:49,000 --> 00:07:51,000
反正也要发邮件

228
00:07:51,000 --> 00:07:53,000
不如多说几句感想

229
00:07:53,000 --> 00:07:53,000
夸号废话

230
00:07:53,000 --> 00:07:55,000
那条恐慌

231
00:07:55,000 --> 00:07:55,000
我是

232
00:07:55,000 --> 00:07:56,000
我是从

233
00:07:56,000 --> 00:07:58,000
从第一期开始听的

234
00:07:58,000 --> 00:08:01,000
追了热情不亚于追翻和美剧

235
00:08:01,000 --> 00:08:02,000
哇这么高的评价

236
00:08:02,000 --> 00:08:03,000
真是不胜惶恐

237
00:08:03,000 --> 00:08:05,000
嗯

238
00:08:05,000 --> 00:08:06,000
早晨上班

239
00:08:06,000 --> 00:08:09,000
单位和公寓之间 commute 很久

240
00:08:09,000 --> 00:08:12,000
经常在路上消化各种 podcast 节目

241
00:08:12,000 --> 00:08:15,000
IT 公论和内核恐慌真是一级不辣

242
00:08:15,000 --> 00:08:16,000
对面对了

243
00:08:16,000 --> 00:08:23,000
有有时候听到有意思的片段都是一个人带着耳机坐在车上傻笑

244
00:08:23,000 --> 00:08:23,000
哎呀

245
00:08:23,000 --> 00:08:25,000
这种随身便携

246
00:08:25,000 --> 00:08:26,000
还只能独享的愉悦

247
00:08:26,000 --> 00:08:28,000
真是弥扬自豪呢

248
00:08:28,000 --> 00:08:33,000
这位同学你这个中毒男生的真的不用怀疑

249
00:08:33,000 --> 00:08:35,000
不用考虑一下临座的感受吗

250
00:08:37,000 --> 00:08:37,000
OK

251
00:08:37,000 --> 00:08:38,000
接着你好

252
00:08:38,000 --> 00:08:41,000
我是从事交互行交互设计行业的

253
00:08:41,000 --> 00:08:43,000
所以对设计了产品了

254
00:08:43,000 --> 00:08:46,000
mvp 了相关的话题更感兴趣

255
00:08:46,000 --> 00:08:48,000
其他片开发的内容也能接受

256
00:08:48,000 --> 00:08:51,000
之前是从 CS 转行过来的

257
00:08:51,000 --> 00:08:56,000
心里多少有点没能继续坚持走马的阳关大陆啊

258
00:08:56,000 --> 00:08:58,000
到不动摇的遗憾

259
00:08:58,000 --> 00:08:59,000
不对啊

260
00:08:59,000 --> 00:09:00,000
你这选对方向了

261
00:09:00,000 --> 00:09:00,000
我觉得

262
00:09:00,000 --> 00:09:03,000
嗯

263
00:09:03,000 --> 00:09:05,000
于是靠听播客了解大家都在干嘛

264
00:09:05,000 --> 00:09:08,000
讨论什么呃维系

265
00:09:08,000 --> 00:09:11,000
你看我还是很积极关注技术的安全感

266
00:09:11,000 --> 00:09:14,000
特别喜欢邀请的嘉宾的几期消极节目

267
00:09:14,000 --> 00:09:16,000
姚老师威楼还有最近的 L 大

268
00:09:18,000 --> 00:09:20,000
感免是各位爹

269
00:09:20,000 --> 00:09:23,000
然后提供上门学生科普的那段小说

270
00:09:24,000 --> 00:09:25,000
虽是不一样的领域

271
00:09:25,000 --> 00:09:26,000
但都会对自己的学习有所提升的感觉

272
00:09:26,000 --> 00:09:29,000
自己思考问题解决问题的方式有启发

273
00:09:29,000 --> 00:09:31,000
对我来说已经很可贵了

274
00:09:32,000 --> 00:09:33,000
这个我还是蛮满满满欣慰的

275
00:09:34,000 --> 00:09:35,000
嗯

276
00:09:35,000 --> 00:09:36,000
接着念呃

277
00:09:36,000 --> 00:09:41,000
李如意这个文青有时候会把爱奇功论的气氛弄成辩论会

278
00:09:41,000 --> 00:09:44,000
我隔着 wifi 都觉得这是要剑拔弩张了

279
00:09:44,000 --> 00:09:46,000
可能是我多虑了呢

280
00:09:46,000 --> 00:09:47,000
呃

281
00:09:47,000 --> 00:09:48,000
这个要插话

282
00:09:48,000 --> 00:09:49,000
确实是多虑了

283
00:09:50,000 --> 00:09:51,000
相较而言

284
00:09:51,000 --> 00:09:53,000
内核恐慌就和谐得多

285
00:09:53,000 --> 00:09:56,000
果然程序员是天底下最可爱无害的

286
00:09:56,000 --> 00:09:57,000
神般存在

287
00:09:57,000 --> 00:10:00,000
有进有退有分寸还特自然

288
00:10:00,000 --> 00:10:01,000
不管怎样

289
00:10:01,000 --> 00:10:02,000
我还是爱你们所有人

290
00:10:02,000 --> 00:10:04,000
包括很有逼格

291
00:10:04,000 --> 00:10:06,000
括号就是包一的

292
00:10:06,000 --> 00:10:07,000
李如意

293
00:10:07,000 --> 00:10:12,000
最后我其实我本来想说要是有靠谱湾区南马农

294
00:10:12,000 --> 00:10:19,000
愿意每周末出来泡个咖啡店图书馆做做自己想做的 side project

295
00:10:19,000 --> 00:10:22,000
觉得有个设计师一起也不赖

296
00:10:22,000 --> 00:10:23,000
请联系我

297
00:10:23,000 --> 00:10:26,000
不过我觉得这样被解误解成 hr

298
00:10:26,000 --> 00:10:27,000
的概率太大

299
00:10:27,000 --> 00:10:30,000
而且听上去总有总是不像好人

300
00:10:30,000 --> 00:10:32,000
有种无耻的猥琐感

301
00:10:32,000 --> 00:10:33,000
于是算了吧

302
00:10:33,000 --> 00:10:34,000
这挺好的

303
00:10:34,000 --> 00:10:34,000
我觉得挺好的

304
00:10:34,000 --> 00:10:36,000
你们这个自己组组合吧

305
00:10:36,000 --> 00:10:38,000
他强调这个湾区南马农

306
00:10:38,000 --> 00:10:40,000
所以这应该是个妹对

307
00:10:40,000 --> 00:10:41,000
为什么要一定是男吗

308
00:10:41,000 --> 00:10:42,000
是不是女生吗

309
00:10:42,000 --> 00:10:46,000
可能嗯好吧

310
00:10:46,000 --> 00:10:47,000
呃

311
00:10:47,000 --> 00:10:48,000
还是说呃

312
00:10:48,000 --> 00:10:51,000
住内核恐慌越做越棒

313
00:10:51,000 --> 00:10:53,000
达到新闻联播的境界

314
00:10:53,000 --> 00:10:54,000
蹦蹦蹦蹦

315
00:10:54,000 --> 00:10:55,000
是指风雨

316
00:10:55,000 --> 00:10:55,000
哈哈哈

317
00:10:56,000 --> 00:11:00,000
当然是指风雨无阻的任性和权威性咯

318
00:11:00,000 --> 00:11:02,000
又没鼓励你们写固定排比句

319
00:11:02,000 --> 00:11:03,000
模板报喜不报忧

320
00:11:03,000 --> 00:11:05,000
嗯

321
00:11:05,000 --> 00:11:05,000
嗯

322
00:11:05,000 --> 00:11:05,000
嗯

323
00:11:05,000 --> 00:11:06,000
嗯

324
00:11:06,000 --> 00:11:06,000
嗯

325
00:11:06,000 --> 00:11:07,000
我这样也蛮开心的哈

326
00:11:07,000 --> 00:11:11,000
就其实这个节目能够给大家带来

327
00:11:11,000 --> 00:11:13,000
一点点这个快乐的时光

328
00:11:13,000 --> 00:11:14,000
好

329
00:11:14,000 --> 00:11:15,000
然后觉得还有所启发

330
00:11:15,000 --> 00:11:17,000
这个其实对我个人觉得是个挺高的

331
00:11:17,000 --> 00:11:18,000
评价的

332
00:11:18,000 --> 00:11:19,000
听起来好激动

333
00:11:19,000 --> 00:11:21,000
然后对

334
00:11:21,000 --> 00:11:24,000
然后我还是这个叫什么

335
00:11:24,000 --> 00:11:25,000
很纠结于这个

336
00:11:26,000 --> 00:11:27,000
这个线男马龙呢

337
00:11:27,000 --> 00:11:28,000
就没有女马龙吗

338
00:11:28,000 --> 00:11:32,000
你们这是要要前两天我昨天我女朋友跟我说

339
00:11:32,000 --> 00:11:34,000
那个唯蜜里有一模特

340
00:11:34,000 --> 00:11:38,000
深了纽约大学去学编程了

341
00:11:38,000 --> 00:11:42,000
然后他还成年基金会那个是那个那个呃

342
00:11:42,000 --> 00:11:46,000
就是黑黑黑人女孩子我我我没有看说什么长超症

343
00:11:46,000 --> 00:11:50,000
然后那个毅然解约去学编程

344
00:11:50,000 --> 00:11:54,000
还要还要每年支持 N 个女生去学编程之类的一个啊

345
00:11:54,000 --> 00:11:55,000
我知道就是那个就是那个他他是

346
00:11:56,000 --> 00:11:56,000
他是哪个学校

347
00:11:56,000 --> 00:11:58,000
他是做那个 ls 开发的嘛

348
00:11:58,000 --> 00:12:05,000
然后就是呃业余做一下这个维多米亚的这个秘密的模特身材超

349
00:12:05,000 --> 00:12:06,000
超赞

350
00:12:06,000 --> 00:12:08,000
然后就是哇

351
00:12:08,000 --> 00:12:11,000
今天就是乱结果去看一下马马龙女神好不好

352
00:12:11,000 --> 00:12:17,000
这个是哎之前那个什么直呼上也有一个来也有一个模特女孩子

353
00:12:17,000 --> 00:12:18,000
后来就学牌房了吧

354
00:12:18,000 --> 00:12:26,000
我记得然后后来还搞了一个创业项目是做是做一个什么订阅器来的我忘了

355
00:12:26,000 --> 00:12:27,000
OK

356
00:12:27,000 --> 00:12:31,000
找找那个链接加到手脑资料

357
00:12:31,000 --> 00:12:36,000
那就我们只有这两期只有这两封反馈了

358
00:12:36,000 --> 00:12:38,000
应该是

359
00:12:38,000 --> 00:12:39,000
呃对啊

360
00:12:39,000 --> 00:12:45,000
其实还有一个比较简短的就是有位听众给我们写信来说推荐一篇文章叫的 programmers

361
00:12:45,000 --> 00:12:48,000
should stop call themselves engineers

362
00:12:48,000 --> 00:12:51,000
是来自于那个 telegram

363
00:12:51,000 --> 00:12:52,000
but the atlantic

364
00:12:52,000 --> 00:12:52,000
啊

365
00:12:52,000 --> 00:12:53,000
sorry

366
00:12:53,000 --> 00:12:55,000
呃报纸报纸网站上的一个文章

367
00:12:56,000 --> 00:12:59,000
这篇文章这篇文章其实我前两周也看过了

368
00:12:59,000 --> 00:13:03,000
就是呃他因为他曾经在 hacker news 上出现

369
00:13:03,000 --> 00:13:06,000
然后嗯其大意就是说这个

370
00:13:06,000 --> 00:13:11,000
工程师是一个非常高大上的 title

371
00:13:11,000 --> 00:13:15,000
其实他就按照这篇文章的这个调子来说

372
00:13:15,000 --> 00:13:18,000
工程师是一个非常庄严

373
00:13:18,000 --> 00:13:19,000
呃

374
00:13:19,000 --> 00:13:22,000
一个一个一个让人可以信赖

375
00:13:22,000 --> 00:13:24,000
然后门槛非常高的这么一个 title

376
00:13:24,000 --> 00:13:26,000
而呃嗯

377
00:13:26,000 --> 00:13:28,000
这些 tech industry

378
00:13:28,000 --> 00:13:36,000
就是我们这些搞这个搞电脑的这帮人总是会总是希望把自己呃总是会使用什么 software engineer 这种 title

379
00:13:36,000 --> 00:13:40,000
然后这样的 title 实际上是在给 engineer 抹黑

380
00:13:40,000 --> 00:13:42,000
因为很多 software 是非常不可靠的

381
00:13:42,000 --> 00:13:44,000
就他原句里面有句话

382
00:13:44,000 --> 00:13:45,000
我就记得就是嗯

383
00:13:45,000 --> 00:13:50,000
许多软件服务在今天其实已经成了 infrastructure

384
00:13:50,000 --> 00:13:53,000
但是他们却远远不如传统的 infrastructure 可靠

385
00:13:53,000 --> 00:13:54,000
比如说嗯

386
00:13:54,000 --> 00:13:55,000
对啊

387
00:13:56,000 --> 00:13:58,000
我我其实我可以理解这种像他的这种说法

388
00:13:58,000 --> 00:14:05,000
比如说 facebook 对于很多人来说 facebook 呃或者 i message 已经全都是非常每天离不开的东西了

389
00:14:05,000 --> 00:14:11,000
但是就今天明天什么时候莫名其妙 facebook 就 outrage 一下

390
00:14:11,000 --> 00:14:13,000
呃什么 outrage

391
00:14:13,000 --> 00:14:14,000
呃 outage 一下

392
00:14:14,000 --> 00:14:16,000
twitter 也是对吧

393
00:14:16,000 --> 00:14:21,000
呃你很难想象在一个在一个呃翻来过家会一天到晚停电

394
00:14:21,000 --> 00:14:25,000
但早就至少 twitter 也有一阶段就是这样

395
00:14:25,000 --> 00:14:26,000
但是

396
00:14:26,000 --> 00:14:30,000
那现在的像 facebook 啊 google 这些的 outage 基本上很少了吧

397
00:14:30,000 --> 00:14:34,000
对是相对相对来说是比较大面积的

398
00:14:34,000 --> 00:14:35,000
对

399
00:14:35,000 --> 00:14:38,000
但我的意思就是从统计学的角度来看

400
00:14:38,000 --> 00:14:46,000
他们还是要比这个传统 infrastructure 要要要来的那么频繁一点

401
00:14:46,000 --> 00:14:47,000
那倒不一定吧

402
00:14:47,000 --> 00:14:48,000
我觉得这个看你怎么去

403
00:14:48,000 --> 00:14:52,000
你要考虑一个叫什么量级的问题

404
00:14:52,000 --> 00:14:55,000
比如说你见过哪一栋楼

405
00:14:55,000 --> 00:14:58,000
每天有 11 人在同时使用它

406
00:14:58,000 --> 00:14:59,000
没有吧

407
00:14:59,000 --> 00:15:00,000
好吧

408
00:15:01,000 --> 00:15:05,000
对所以这个我觉得你如果要考虑这个可靠性的话

409
00:15:05,000 --> 00:15:07,000
得考虑他的这个使用评测啊

410
00:15:07,000 --> 00:15:08,000
还有那些问题啊

411
00:15:08,000 --> 00:15:14,000
呃还有像那些就建筑的豆腐干豆腐渣工程也不好

412
00:15:14,000 --> 00:15:16,000
那些也不是工程师干出来的吗

413
00:15:16,000 --> 00:15:17,000
对吧

414
00:15:17,000 --> 00:15:19,000
所以也不尽然好吧

415
00:15:19,000 --> 00:15:20,000
反正是一个论调

416
00:15:20,000 --> 00:15:22,000
然后大家可以去看一看这篇文章

417
00:15:22,000 --> 00:15:23,000
我觉得还行挺有意思

418
00:15:23,000 --> 00:15:24,000
对哈哈哈

419
00:15:24,000 --> 00:15:25,000
ok

420
00:15:25,000 --> 00:15:27,000
现在进入我们这个新闻环节

421
00:15:27,000 --> 00:15:30,000
对其实就两条新闻

422
00:15:30,000 --> 00:15:33,000
对因为我们两个最近都没有怎么看新闻

423
00:15:33,000 --> 00:15:34,000
你你忙什么

424
00:15:34,000 --> 00:15:37,000
我我反正是在忙着打 fault

425
00:15:37,000 --> 00:15:39,000
你你打什么

426
00:15:39,000 --> 00:15:40,000
呃

427
00:15:40,000 --> 00:15:42,000
辐射 4 刚出来的好吧

428
00:15:42,000 --> 00:15:45,000
那个是一个什么射击游戏吗

429
00:15:45,000 --> 00:15:46,000
哈哈哈

430
00:15:46,000 --> 00:15:50,000
射击游戏是个呃

431
00:15:50,000 --> 00:15:53,000
反乌托邦的这大灾难的一个游戏吗

432
00:15:53,000 --> 00:15:56,000
这大灾难之后的 rpg

433
00:15:56,000 --> 00:15:57,000
rpg

434
00:15:57,000 --> 00:15:59,000
史诗版的史诗版的游戏

435
00:15:59,000 --> 00:16:00,000
就出到 4 了

436
00:16:00,000 --> 00:16:02,000
应该差不多是这样

437
00:16:02,000 --> 00:16:05,000
不是史诗应该不会出到 4

438
00:16:05,000 --> 00:16:09,000
对呃对所以我就只看了两则新闻

439
00:16:09,000 --> 00:16:10,000
等一下你只打 fault

440
00:16:10,000 --> 00:16:12,000
你没有没有打 league of

441
00:16:12,000 --> 00:16:15,000
legacy of the void

442
00:16:15,000 --> 00:16:18,000
呃他们是从同一天出来的

443
00:16:18,000 --> 00:16:19,000
但是迄今为止

444
00:16:19,000 --> 00:16:21,000
我刚刚只把那个 legacy of the void

445
00:16:21,000 --> 00:16:23,000
呃第一关玩了一段时间

446
00:16:23,000 --> 00:16:25,000
玩了大概两分钟

447
00:16:25,000 --> 00:16:26,000
然后就

448
00:16:26,000 --> 00:16:28,000
然后就一直在打 fault

449
00:16:28,000 --> 00:16:30,000
好吧你这个叛徒

450
00:16:30,000 --> 00:16:31,000
哈哈哈

451
00:16:31,000 --> 00:16:32,000
sorry

452
00:16:32,000 --> 00:16:33,000
好吧你有玩吗

453
00:16:33,000 --> 00:16:34,000
我还没买

454
00:16:34,000 --> 00:16:35,000
哈哈

455
00:16:35,000 --> 00:16:36,000
ok 因为最近比较忙嘛

456
00:16:36,000 --> 00:16:38,000
然后也没空去玩游戏

457
00:16:38,000 --> 00:16:40,000
ok 讲新闻吧

458
00:16:40,000 --> 00:16:41,000
第一则是什么

459
00:16:41,000 --> 00:16:42,000
其实这个是旧文了

460
00:16:42,000 --> 00:16:45,000
这个应该是这是两周之前的事情吧

461
00:16:45,000 --> 00:16:47,000
这个历周多之前的事情

462
00:16:47,000 --> 00:16:48,000
不止我

463
00:16:48,000 --> 00:16:49,000
我觉得这个东西

464
00:16:49,000 --> 00:16:51,000
我好像好几个月前就已经看到过了

465
00:16:51,000 --> 00:16:52,000
what

466
00:16:53,000 --> 00:16:54,000
i think

467
00:16:54,000 --> 00:16:55,000
难道那

468
00:16:55,000 --> 00:16:56,000
anyway

469
00:16:56,000 --> 00:16:59,000
反正这个东西也许是两一周之前才正式有了自己的网站

470
00:16:59,000 --> 00:17:01,000
然后有了 faq 什么的

471
00:17:01,000 --> 00:17:02,000
ok

472
00:17:02,000 --> 00:17:07,000
对就是总之它是一个来自于 google 的移动

473
00:17:07,000 --> 00:17:09,000
编程框架

474
00:17:09,000 --> 00:17:10,000
嗯

475
00:17:10,000 --> 00:17:11,000
呃名字叫做 flutter

476
00:17:11,000 --> 00:17:13,000
flutter

477
00:17:13,000 --> 00:17:14,000
嗯

478
00:17:14,000 --> 00:17:15,000
嗯

479
00:17:15,000 --> 00:17:19,000
它最大的特点大概就是使用 dart language 来写

480
00:17:19,000 --> 00:17:22,000
可以支持你能用 dart language 来写这个

481
00:17:22,000 --> 00:17:24,000
移动短信

482
00:17:24,000 --> 00:17:26,000
所以这样做有什么好处呢

483
00:17:26,000 --> 00:17:31,000
如果你看他安卓的话

484
00:17:31,000 --> 00:17:32,000
以后也许不用写差了

485
00:17:32,000 --> 00:17:35,000
但是 dart 比 java 好吗

486
00:17:35,000 --> 00:17:36,000
呃

487
00:17:36,000 --> 00:17:38,000
我觉得它是好一些的吧

488
00:17:38,000 --> 00:17:39,000
因为

489
00:17:39,000 --> 00:17:42,000
有什么语言能比 java 还长

490
00:17:42,000 --> 00:17:45,000
c++ php

491
00:17:45,000 --> 00:17:48,000
javascript

492
00:17:48,000 --> 00:17:49,000
对

493
00:17:49,000 --> 00:17:51,000
但 dart 跟 javascript

494
00:17:51,000 --> 00:18:01,000
可能

495
00:18:09,000 --> 00:18:09,000
呃

496
00:18:09,000 --> 00:18:10,000
框架

497
00:18:10,000 --> 00:18:11,000
他可以把

498
00:18:11,000 --> 00:18:12,000
呃

499
00:18:12,000 --> 00:18:15,000
写出来的程序编译成 os 10 的

500
00:18:15,000 --> 00:18:16,000
IOS 的程序

501
00:18:16,000 --> 00:18:20,000
然后我也可以在安卓上跑

502
00:18:20,000 --> 00:18:22,000
但 windows phone 我目前还没有印象的

503
00:18:22,000 --> 00:18:24,000
应该将来可能也会支持

504
00:18:25,000 --> 00:18:27,000
其实说到 android

505
00:18:27,000 --> 00:18:28,000
其实用 scala

506
00:18:28,000 --> 00:18:30,000
也可以写开发 android 应用吧

507
00:18:32,000 --> 00:18:34,000
理论上是可以的

508
00:18:34,000 --> 00:18:36,000
而且好像是有框架的吧

509
00:18:36,000 --> 00:18:38,000
对只是我反正你你不关注

510
00:18:38,000 --> 00:18:39,000
我也更不关注

511
00:18:39,000 --> 00:18:40,000
不是太流行好像

512
00:18:41,000 --> 00:18:44,000
对然后 flutter 也采用了一些

513
00:18:44,000 --> 00:18:47,000
类似于 facebook 的

514
00:18:47,000 --> 00:18:51,000
叫什么来着 reactive 的

515
00:18:51,000 --> 00:18:54,000
相似的设计模式

516
00:18:54,000 --> 00:18:55,000
然后可以支持你比较

517
00:18:56,000 --> 00:18:58,000
使用这种类似于 functional

518
00:18:58,000 --> 00:19:01,000
reactive 的方式来写他的界面

519
00:19:02,000 --> 00:19:04,000
所以这个 flutter 算什么

520
00:19:04,000 --> 00:19:06,000
算是 google 的亲儿子了

521
00:19:08,000 --> 00:19:08,000
应该是吧

522
00:19:08,000 --> 00:19:10,000
看这个意义但是 dart 其实

523
00:19:11,000 --> 00:19:13,000
一直搞不懂他们是到底是要

524
00:19:13,000 --> 00:19:14,000
主推这个还怎么样

525
00:19:14,000 --> 00:19:15,000
因为之前

526
00:19:16,000 --> 00:19:17,000
说是要把这个 dart

527
00:19:17,000 --> 00:19:17,000
做

528
00:19:17,000 --> 00:19:18,000
进 chrome 里面嘛

529
00:19:18,000 --> 00:19:20,000
就直接支持这个语言了

530
00:19:20,000 --> 00:19:22,000
但后来好像这个计划就取消了

531
00:19:22,000 --> 00:19:23,000
所以给人

532
00:19:24,000 --> 00:19:26,000
给外界的信心好像不是很足的样子

533
00:19:27,000 --> 00:19:28,000
对我觉得 google 可能

534
00:19:29,000 --> 00:19:32,000
如果 go language 是亲定

535
00:19:32,000 --> 00:19:35,000
是亲定的这个后端语言的话

536
00:19:35,000 --> 00:19:36,000
那前端

537
00:19:37,000 --> 00:19:40,000
或者是更比较没那么工业级别的

538
00:19:40,000 --> 00:19:42,000
使用的这种

539
00:19:42,000 --> 00:19:43,000
叫类似于脚本的更快的

540
00:19:43,000 --> 00:19:46,000
更易于执行的语言应该是 dart 吧

541
00:19:46,000 --> 00:19:46,000
但

542
00:19:47,000 --> 00:19:49,000
总觉得背后的推力不够

543
00:19:49,000 --> 00:19:52,000
他没有在努力的去 pr 这件事情

544
00:19:53,000 --> 00:19:54,000
对啊所以我觉得很可能

545
00:19:54,000 --> 00:19:56,000
因为 google 经常出这种

546
00:19:56,000 --> 00:19:57,000
觉得听起来还不错

547
00:19:57,000 --> 00:19:59,000
挺酷的一个项目

548
00:19:59,000 --> 00:20:01,000
然后他过过一段时间就不推

549
00:20:01,000 --> 00:20:03,000
然后这个项目就又又死翘翘了

550
00:20:03,000 --> 00:20:05,000
这种这也不是第一次了

551
00:20:05,000 --> 00:20:06,000
我觉得在 google 这边有一个

552
00:20:06,000 --> 00:20:07,000
有一个魔咒

553
00:20:07,000 --> 00:20:09,000
就是他们努力推的东西一般都不会成功

554
00:20:09,000 --> 00:20:11,000
比如说比如 google plus

555
00:20:11,000 --> 00:20:13,000
哈哈哈或者是

556
00:20:14,000 --> 00:20:17,000
对或者是什么那个东之前胎死腹中的东西

557
00:20:17,000 --> 00:20:18,000
那个一出来

558
00:20:18,000 --> 00:20:19,000
哇哦所有人都惊呆了

559
00:20:19,000 --> 00:20:20,000
然后最后死掉了

560
00:20:20,000 --> 00:20:21,000
你能叫什么

561
00:20:21,000 --> 00:20:23,000
嗯啊干嘛用的

562
00:20:23,000 --> 00:20:26,000
嗯号称要代替电子邮件的那个东西

563
00:20:26,000 --> 00:20:27,000
google wave 啊 ok

564
00:20:28,000 --> 00:20:30,000
对 google wave 也是一顿狂推

565
00:20:30,000 --> 00:20:31,000
然后就完蛋了

566
00:20:31,000 --> 00:20:34,000
所以他们可能也学会了闷声发大财的

567
00:20:34,000 --> 00:20:34,000
这个不行

568
00:20:34,000 --> 00:20:36,000
我走去最近这个节目里面

569
00:20:36,000 --> 00:20:37,000
那个哈梗太多了

570
00:20:37,000 --> 00:20:38,000
应该应该应该借一下

571
00:20:39,000 --> 00:20:40,000
然后

572
00:20:40,000 --> 00:20:41,000
然后

573
00:20:42,000 --> 00:20:44,000
不推东西反而会慢慢活起来

574
00:20:44,000 --> 00:20:45,000
所以你看好这个吗

575
00:20:45,000 --> 00:20:46,000
这个 flatter

576
00:20:47,000 --> 00:20:48,000
嗯

577
00:20:48,000 --> 00:20:49,000
呃

578
00:20:49,000 --> 00:20:51,000
我也不知道我现在已经

579
00:20:51,000 --> 00:20:53,000
没有再写过移动端的东西了

580
00:20:53,000 --> 00:20:54,000
所以

581
00:20:54,000 --> 00:20:56,000
那你已经放弃作为移动开发者了吗

582
00:20:57,000 --> 00:21:00,000
没有我还是在看 swift 相关的东西

583
00:21:00,000 --> 00:21:02,000
放弃 android 开发者

584
00:21:03,000 --> 00:21:04,000
对好吧

585
00:21:04,000 --> 00:21:05,000
阵营不同吗

586
00:21:05,000 --> 00:21:06,000
屁股决定了

587
00:21:06,000 --> 00:21:08,000
所以我对他没有没有没有意见

588
00:21:08,000 --> 00:21:10,000
只是让大家知道一下

589
00:21:10,000 --> 00:21:11,000
有这么一个东西是吧

590
00:21:11,000 --> 00:21:13,000
然后是不是坑

591
00:21:13,000 --> 00:21:15,000
明年再说你们可以先跳进去

592
00:21:15,000 --> 00:21:17,000
是不是坑你跳了告诉我

593
00:21:17,000 --> 00:21:18,000
哈哈哈

594
00:21:18,000 --> 00:21:19,000
哈哈哈哈哈哈

595
00:21:19,000 --> 00:21:20,000
ok 这个不错

596
00:21:21,000 --> 00:21:21,000
对

597
00:21:22,000 --> 00:21:24,000
然后这条新闻就是

598
00:21:25,000 --> 00:21:27,000
比较有意思的一个网站

599
00:21:27,000 --> 00:21:31,000
呃数字 0.2

600
00:21:31,000 --> 00:21:32,000
就是 0.3

601
00:21:32,000 --> 00:21:34,000
然后有 15 个数字 0

602
00:21:34,000 --> 00:21:35,000
004

603
00:21:36,000 --> 00:21:38,000
对这个理论上

604
00:21:39,000 --> 00:21:42,000
就是你看名字其实也大概猜到了吧

605
00:21:42,000 --> 00:21:43,000
这个是讲一个 floating point

606
00:21:43,000 --> 00:21:45,000
浮点数的一个网站

607
00:21:45,000 --> 00:21:47,000
对如果你遇到这个问题的话

608
00:21:47,000 --> 00:21:47,000
你一定会想到这个问题了

609
00:21:47,000 --> 00:21:49,000
你一定会立刻明白这到底是一个什么梗

610
00:21:49,000 --> 00:21:51,000
但是如果你不知道的话欢迎你

611
00:21:51,000 --> 00:21:54,000
嗯就是如果你朋友手边有电脑的话

612
00:21:54,000 --> 00:21:56,000
不妨不妨去看一看

613
00:21:56,000 --> 00:21:59,000
它是一个讲解浮点运算的网站

614
00:21:59,000 --> 00:22:02,000
就是在有些语言里面

615
00:22:02,000 --> 00:22:04,000
有些非常坑爹的语言里面

616
00:22:05,000 --> 00:22:09,000
啊如果你去计算 0.1 加 0.2 的话

617
00:22:09,000 --> 00:22:10,000
结果将会是 0.3

618
00:22:11,000 --> 00:22:15,000
跟着 15 个零然后 4 对就是它不是一个

619
00:22:15,000 --> 00:22:17,000
这个你理想中的

620
00:22:18,000 --> 00:22:19,000
然后究其原因是为什么呢

621
00:22:19,000 --> 00:22:22,000
就是这篇这个网站想要告诉你的

622
00:22:22,000 --> 00:22:23,000
它来自于一个

623
00:22:24,000 --> 00:22:28,000
呃这个对他们工这是他们工程界的作用

624
00:22:28,000 --> 00:22:32,000
他们工程界定了这么一个 IEE 754 标准

625
00:22:32,000 --> 00:22:37,000
然后这个标准里面规定了计算机应该怎样用二进制来表达浮点数

626
00:22:37,000 --> 00:22:40,000
就是表达带小数点数的非整数

627
00:22:41,000 --> 00:22:44,000
然后这个标准如果你严格去按照它实施的话

628
00:22:44,000 --> 00:22:44,000
那你

629
00:22:45,000 --> 00:22:47,000
最终就会得出 0.315 个零

630
00:22:47,000 --> 00:22:48,000
然后一个 4 这种

631
00:22:48,000 --> 00:22:50,000
诡异的 0.1 加 0.2 的答案

632
00:22:50,000 --> 00:22:55,000
就是一个进 0.3 的进 4 值而非确切值

633
00:22:55,000 --> 00:22:59,000
因为你又没有办法在二进制的里面表示

634
00:22:59,000 --> 00:23:01,000
就没办法在二进制里面精确表示 0.3

635
00:23:03,000 --> 00:23:06,000
对在二进制里面在其实这是一个 general 的问题

636
00:23:06,000 --> 00:23:09,000
就是在你你采用什么样的数字就会产生什么样的问题

637
00:23:09,000 --> 00:23:12,000
比如说如果我们采用 11 进制的话

638
00:23:12,000 --> 00:23:12,000
那

639
00:23:13,000 --> 00:23:15,000
呃 11 分之一就是一个

640
00:23:15,000 --> 00:23:16,000
可以被表达出来的

641
00:23:16,000 --> 00:23:20,000
等一下如果你采用 11 进制只能表达 11 分之一精确的吧

642
00:23:22,000 --> 00:23:24,000
对如果你用 11 进制的话

643
00:23:24,000 --> 00:23:26,000
你就可以表达 11 分之一 11 分之二之类的这种数字

644
00:23:26,000 --> 00:23:27,000
非常精确的吧

645
00:23:27,000 --> 00:23:28,000
0.102

646
00:23:29,000 --> 00:23:30,000
但如果你用 10 进制的话

647
00:23:30,000 --> 00:23:33,000
那 11 分之一和 11 分之二就是一个无限循环小数

648
00:23:33,000 --> 00:23:33,000
对吧

649
00:23:33,000 --> 00:23:36,000
对对对你连 11 分之二你也没法表达

650
00:23:37,000 --> 00:23:39,000
为什么不能 0.2 不就是 11 分之二吗

651
00:23:40,000 --> 00:23:42,000
0.1 是 10 进制的

652
00:23:42,000 --> 00:23:44,000
10 进制的 0.1 是十分之一啊

653
00:23:45,000 --> 00:23:48,000
啊我明白你明白你的意思

654
00:23:48,000 --> 00:23:53,000
0.11 进制下的 0.1 不就是 10 进制下面的 11 分之一吗

655
00:23:54,000 --> 00:23:56,000
啊对没错没错

656
00:23:56,000 --> 00:23:57,000
不对对对对对对对理解

657
00:23:57,000 --> 00:23:58,000
你说的是这个意思

658
00:23:59,000 --> 00:23:59,000
没错

659
00:24:00,000 --> 00:24:04,000
然后对所以在二进制下面就有很多十进制的数字是没有办法

660
00:24:04,000 --> 00:24:07,000
表达为一个二进制下面的整数的

661
00:24:09,000 --> 00:24:10,000
就整的这个分数

662
00:24:12,000 --> 00:24:14,000
听着有点绕但用 you get point

663
00:24:14,000 --> 00:24:16,000
就 0.1 可以带可以表达 0.5

664
00:24:16,000 --> 00:24:18,000
但是 0.6 就没办法表达了

665
00:24:18,000 --> 00:24:19,000
就大概这个意思

666
00:24:21,000 --> 00:24:25,000
嗯对所以在实际的一些编程语言里面怎么处理

667
00:24:25,000 --> 00:24:27,000
然后这个网页上就给了一个

668
00:24:28,000 --> 00:24:31,000
相对来说比较详细的列表会出现什么样的状况

669
00:24:32,000 --> 00:24:36,000
对然后就你可以使用什么样的呃

670
00:24:36,000 --> 00:24:39,000
你在遇到什么样的语言的时候可能会得到什么样的结果

671
00:24:39,000 --> 00:24:40,000
以及你

672
00:24:40,000 --> 00:24:41,000
怎样解决这些问题

673
00:24:41,000 --> 00:24:44,000
比如说有些语言里面像 cshop

674
00:24:44,000 --> 00:24:47,000
比如说这个什么 decimal cool 就是专门用来解决这个

675
00:24:48,000 --> 00:24:50,000
任意精度的十进制数的问题

676
00:24:51,000 --> 00:24:56,000
你可能会问为什么不把这个任意实践制精度的数字

677
00:24:57,000 --> 00:25:00,000
做成一个默认的数数字的实现的有些语言是这样的

678
00:25:00,000 --> 00:25:01,000
但另外一些语言不是这样的

679
00:25:01,000 --> 00:25:04,000
因为根据使用场景这个库可能会非常的慢

680
00:25:05,000 --> 00:25:07,000
而有些时候你是不需要这个功能

681
00:25:07,000 --> 00:25:12,000
就一般是这样这个金融的系统里面要算设计到钱呢

682
00:25:12,000 --> 00:25:14,000
都会有那种就是任意精度的

683
00:25:14,000 --> 00:25:15,000
实境制的呃

684
00:25:16,000 --> 00:25:20,000
任意精度的实境制的一个包去处理这些钱的数目对吧

685
00:25:21,000 --> 00:25:22,000
没错

686
00:25:22,000 --> 00:25:25,000
但其他的一些就为了追求效率就是用这个

687
00:25:26,000 --> 00:25:28,000
呃浮点形来表示

688
00:25:28,000 --> 00:25:28,000
然后浮点形

689
00:25:29,000 --> 00:25:31,000
在现在的计算机上一般有两种长度嘛

690
00:25:31,000 --> 00:25:34,000
一种是叫做 float 是 32 位长的

691
00:25:35,000 --> 00:25:37,000
然后另外一种是叫做 double 是 64 位长的

692
00:25:37,000 --> 00:25:39,000
精度的话

693
00:25:39,000 --> 00:25:42,000
double 应该有 53 位的精度 53 个 bit 的精度吧

694
00:25:44,000 --> 00:25:50,000
对 53 个 53 个 digit 的 53 个 digit 的精度应该是

695
00:25:51,000 --> 00:25:54,000
你是说小数点是后面的不管不管是小数点钱

696
00:25:54,000 --> 00:25:57,000
因为那个浮点数那个小数点是可以浮动的嘛

697
00:25:57,000 --> 00:25:59,000
那精度就是代表它有效数字那一部分

698
00:25:59,000 --> 00:26:03,000
对对没错是这样然后然后 float 的话

699
00:26:03,000 --> 00:26:04,000
应该只有好像只有多少

700
00:26:05,000 --> 00:26:12,000
二十二十七二十二十八位 27 百个一位我想一位的符号

701
00:26:12,000 --> 00:26:14,000
他有 27 个 bit

702
00:26:14,000 --> 00:26:20,000
但是他的实际的表示成那个呃叫做哦对对你说说 range 对他的那个他表达出了的那个

703
00:26:21,000 --> 00:26:28,000
有效的数字好像只有 8 位还是 9 位就 8 个有效出差 9 个有效数字很小的一个数反正对对对

704
00:26:28,000 --> 00:26:32,000
然后在实际语言上就会就这个跟编程其实会有点关系

705
00:26:32,000 --> 00:26:43,000
就是说如果你要做一个这个浮点数的呃加减乘除的话你要特别小心这一点特别是你用 float 这种 32 位的精度的 32 位这种这种窄的浮点数的

706
00:26:43,000 --> 00:26:47,000
的时候很容易用的用就是发现你累比如说你做一个累加对吧

707
00:26:48,000 --> 00:26:54,000
你加完之后发现哎这个跟你预想的这个出入怎么那么大就是因为浮点数这个精度在作怪嘛

708
00:26:54,000 --> 00:26:57,000
就你设想一下啊你加一个特别大的一个数字

709
00:26:57,000 --> 00:27:02,000
加上一个特别小的一个数字两加起来因为精度的问题可能直接就无效了

710
00:27:02,000 --> 00:27:05,000
但是如果说你有很多很多特别小的数字累加起来

711
00:27:06,000 --> 00:27:12,000
你再加了一个特别大的数字那边去你这个这个物这个这个精度的牺牲导致的误差会当时会逐渐累积的

712
00:27:12,000 --> 00:27:18,000
对所以这个面是有很多坑爹的事情

713
00:27:18,000 --> 00:27:23,000
对所以有一个 rule of thumb 就是如果能够不使用是浮点数的话尽量不要使用浮点数

714
00:27:24,000 --> 00:27:28,000
就是在早期早期学习完成的时候应该学到的一点

715
00:27:28,000 --> 00:27:37,000
刚才说除了这个解决方案除了说用一个这个叫做 dissimilar 就是实际性质的这个无限就是无限精度的一个库去

716
00:27:38,000 --> 00:27:42,000
表达就是一个任意进度的数字还有一个方法就是用一个叫做 rational

717
00:27:42,000 --> 00:27:44,000
就是分数的形式或者是 fraction

718
00:27:44,000 --> 00:27:46,000
他这个原理就比较简单了

719
00:27:46,000 --> 00:27:49,000
他说我们没有办法通过这个

720
00:27:50,000 --> 00:27:55,000
我们把处境那我干脆不处号直接就按分子分母大家还记得小学学那个吗怎么去

721
00:27:56,000 --> 00:28:00,000
两个分数相乘的时候那个方法就是在程序上实现同样的原理

722
00:28:01,000 --> 00:28:07,000
最终得出来的结果还是一个分数就是几分之多少分之多少当然那个多少和分子分母都可能会比较大

723
00:28:07,000 --> 00:28:12,000
但你可以通过削减什么公因数公约数的方法去

724
00:28:12,000 --> 00:28:22,000
把它尽量说成一个最大公我我已经至少两次一听到你在提供里面是说什么最大公约数我每次都记不住到底是哪个是哪个

725
00:28:24,000 --> 00:28:31,000
对应该是最大公约数和最小公倍数最小公倍数差不多然后距离是哪个我也忘了

726
00:28:34,000 --> 00:28:39,000
比较有意思的是在有些就是我们常见的语言里面它实现还有点奇怪比如说这个

727
00:28:40,000 --> 00:28:41,000
呃

728
00:28:42,000 --> 00:28:48,000
这个这个 c 可能还比较简单为什么 php 里面呃 0.1 加 0.2 是出来是 0.3 呢

729
00:28:49,000 --> 00:28:56,000
然后发现 php 这么世界上最强大的语言他偷偷的把这个 0.315 个零 4

730
00:28:57,000 --> 00:29:02,000
这么一个伏点数转化成了一个字符串然后把它变为 0.3

731
00:29:05,000 --> 00:29:11,000
太强大了然后哎我不知道这个 mysql 里面这个是怎么做的它这个原理是什么应该还是用的这种就是

732
00:29:12,000 --> 00:29:13,000
折中的办法吧

733
00:29:13,000 --> 00:29:15,000
就是四手不是四手五入的方法

734
00:29:16,000 --> 00:29:19,000
要看 sql 是怎么实现因为 sql 呃

735
00:29:20,000 --> 00:29:26,000
不是 sqlsql 规范肯定是没有定义这件事情规范没有说但是 mysql 实现了 0.3

736
00:29:27,000 --> 00:29:30,000
对是个好问题然后在

737
00:29:31,000 --> 00:29:41,000
python 里面有点意思 python 里面是如果你把它打印出来它是一个 0.3 对吧对但是实际上那个数值应该还是 0.3

738
00:29:42,000 --> 00:29:48,000
所以会有一个算法去告诉说你要打印的这个值它是一个某一个

739
00:29:49,000 --> 00:30:01,000
更短的分数小小数的近视指示然后他会默认去把它近视这个 pilot 的方法也是用跟 php 一样的嘛就是通过转换成字符串的形式去做这个事

740
00:30:02,000 --> 00:30:10,000
对然后在 pilot 3 里面这一点被会这一点被啊纠正就是不要做这些莫名其妙的优化因为其实如果一个用户看到的值和他的

741
00:30:10,000 --> 00:30:17,000
实际的值不一样的话是有可能出麻烦的对所以所以在实际使用中比如说你们做一些什么

742
00:30:19,000 --> 00:30:24,000
举个简单例子你要做一个工业的一个什么测量它读出来的这个数值它可能是一个

743
00:30:26,000 --> 00:30:31,000
伏点数的时候他们是怎么去判断就是比如说你要判断这个值是否是

744
00:30:31,000 --> 00:30:37,000
是不是大于或者小于某个值的时候是要算上一个在合适的精度范围内吗还是怎么样

745
00:30:39,000 --> 00:30:40,000
工业上面一般会

746
00:30:40,000 --> 00:30:49,000
有一个指定的呃精确范围但不同工业不一样啊有但不过大部分都是小数点之后三位吧应该

747
00:30:49,000 --> 00:30:54,000
就是你我就是说你在编程的时候你要判断两个伏点数的大小的时候你怎么办

748
00:30:55,000 --> 00:31:04,000
呃是你说要判断两个伏点数的相等于否吧还是大小不是很好判断就就就就其实

749
00:31:04,000 --> 00:31:10,000
其实我觉得用判断两个伏点数是否相等这件事情本身就是跟你的初衷是有这个常识的

750
00:31:10,000 --> 00:31:14,000
是有有相悖的除非你特别理解这个爱 1754 到底怎么一回事对

751
00:31:16,000 --> 00:31:23,000
对呃在在计算机的世界里面伏点数是非常棘手的一个东西反正对是所以一般的话应该是两个数 a 要判断两个数是否

752
00:31:23,000 --> 00:31:30,000
近相近应该是用 a-b 然后算它的差值是不是在某一个然后看其差差值是不是在一个

753
00:31:31,000 --> 00:31:39,000
就有点像那个公公呃工业里面造两零件然后看两零件是不是合乎要求呢就要看它的偏差是不是在一个

754
00:31:39,000 --> 00:31:39,000
可见的

755
00:31:40,000 --> 00:31:50,000
这个说法文是法文内的嗯对这个还是蛮坑的反正没错万万的书店你看这就是基础的科学和进行工程全都超工程的区

756
00:31:52,000 --> 00:31:56,000
ok in theory there is no difference in practical

757
00:31:57,000 --> 00:31:57,000
我想那话怎么说

758
00:31:58,000 --> 00:32:02,000
in theory there is no difference between theory and practical in practical there is

759
00:32:04,000 --> 00:32:10,000
不是不是叫做 in theory there is no difference between theory and practice practice ok in practice

760
00:32:10,000 --> 00:32:10,000
对

761
00:32:12,000 --> 00:32:12,000
那

762
00:32:13,000 --> 00:32:17,000
今天的主题就是比较 in practice 的一个东西

763
00:32:18,000 --> 00:32:19,000
嗯

764
00:32:20,000 --> 00:32:21,000
主题是命令行

765
00:32:23,000 --> 00:32:29,000
嗯哼对这也是这是我们上期提到了吗还是上上期提到了一个主题反正某一期你承诺过对你就要讲

766
00:32:30,000 --> 00:32:39,000
对然后其实这个主题也的确是挺挺挺值得说的因为嗯尤其是对于初学者来说或者对于

767
00:32:40,000 --> 00:32:46,000
正在朝这条路上越走越远的人来说呃命令好像是一个

768
00:32:48,000 --> 00:32:49,000
是一个绕不开的话题

769
00:32:50,000 --> 00:32:56,000
就基本上我其实我我觉得这个这个我要先问一个问题现在很多这种新就是

770
00:32:57,000 --> 00:33:07,000
新人们好像他们学电脑都不用都直接开过命令行了或者很多用 windows 的人都基本不用命令好了但是我觉得将来还是会早晚有一天你会撞上

771
00:33:08,000 --> 00:33:10,000
所以所以你觉得他们还是会把这课程

772
00:33:10,000 --> 00:33:11,000
给补上是吧

773
00:33:11,000 --> 00:33:25,000
嗯对其实这也是一个这也是一个值得讨论的话题吧就是在在我们小时候在嗯嗯大家就至少在 windows 或者是道斯微软的操作系统用户的

774
00:33:26,000 --> 00:33:33,000
早期的同源同年记忆里面计算机开机是不会自动记住图形界面的同学们就是像你们这些

775
00:33:34,000 --> 00:33:40,000
呃饱受溺爱的麦克用户一开机就可以看到一个闪闪发光的大苹果

776
00:33:40,000 --> 00:33:42,000
然后一进去就有鼠标用这种事情在

777
00:33:43,000 --> 00:33:45,000
至少 90 年代的中国是不可想象的

778
00:33:47,000 --> 00:33:58,000
对吧在开机先写一个 bios 对对吧对然后进到那个 cdaw 听到那个熟悉的磁盘自检的声音啊对对我们应该把磁盘自检的声音拿来当我们的开头曲

779
00:33:58,000 --> 00:33:59,000
就能我就像那个

780
00:34:00,000 --> 00:34:03,000
对那个怎么形成一个开头曲就像那个

781
00:34:05,000 --> 00:34:10,000
这 atp 一样他们用那个调整几条系的声音我们可以用

782
00:34:10,000 --> 00:34:14,000
我们可以用那个磁盘自检的声音来当开头曲

783
00:34:15,000 --> 00:34:26,000
终于找到一个符合本节目主旨的这么一个对呃声音的特质了我是在那个辐射 4 里面因为辐射 4 里面经常需要去黑一些那个 terminal

784
00:34:26,000 --> 00:34:29,000
然后那个 terminal 有个特别的声音我是听那个声音的时候想到

785
00:34:31,000 --> 00:34:31,000
ok

786
00:34:31,000 --> 00:34:32,000
yeah

787
00:34:33,000 --> 00:34:40,000
然后对然后我们在 90 年代的时候需要开机看到一个 boss bios 自检然后

788
00:34:40,000 --> 00:34:43,000
屏幕清明左上角出现一个闪烁的 c 冒号

789
00:34:44,000 --> 00:34:50,000
反斜杠大于号然后一个闪动的东西 90 年代你就看那 c 了吗应该是 a 或者是 b 吧

790
00:34:52,000 --> 00:34:55,000
啊对 a 冒号反斜杠大于

791
00:34:56,000 --> 00:34:56,000
没错

792
00:34:57,000 --> 00:34:58,000
嗯哼

793
00:34:58,000 --> 00:35:03,000
c 呀没有我没有那么没有那么哈套了我觉得我小时候就在我的那个

794
00:35:04,000 --> 00:35:07,000
呃你来就是磁盘就硬盘学习机之后的

795
00:35:08,000 --> 00:35:10,000
电脑其实我遇到了已经大了的电脑了

796
00:35:10,000 --> 00:35:11,000
大部分都是带磁盘的

797
00:35:13,000 --> 00:35:13,000
想想

798
00:35:14,000 --> 00:35:17,000
对你没用过那种叫做叫做无盘工作站吗

799
00:35:19,000 --> 00:35:21,000
无盘工作站是

800
00:35:22,000 --> 00:35:23,000
就那个时候磁盘很会买

801
00:35:23,000 --> 00:35:25,000
联网了之后才有的呀

802
00:35:26,000 --> 00:35:29,000
对就我知道就是有些那种以前那种叫做什么来的

803
00:35:30,000 --> 00:35:34,000
这不叫叫机房吧对他不是不是每台电脑都有磁盘的

804
00:35:34,000 --> 00:35:40,000
我知道但我我的意思是我第一次接触计算机就接触啊 ibm pc 兼容机

805
00:35:40,000 --> 00:35:45,000
应该是在我爸单位的那个一个一个秘书室里

806
00:35:45,000 --> 00:35:50,000
类似的这么一个地方然后那个那个那个电脑不仅有磁盘还有还有游戏在上面

807
00:35:50,000 --> 00:35:54,000
所以我第一次接触到私隐帽号反斜杠大约好像应该是在那边

808
00:35:55,000 --> 00:36:01,000
那你那个还运气还是蛮好的对在此之前我只能在那个中华学习机上用一个录音带的那个

809
00:36:02,000 --> 00:36:07,000
读取的东西但是中华学习机反正没有那个那个就是 apple 2 嘛反正没有磁盘的感觉

810
00:36:07,000 --> 00:36:09,000
就没有那个盘符的感觉

811
00:36:10,000 --> 00:36:18,000
ok 对所以进到 c 之后要怎么进图形里面还差个 win 吧是不是对你要打 win 回车然后才可以进 windows

812
00:36:19,000 --> 00:36:22,000
是什么 windows 3.1 windows 3.2

813
00:36:23,000 --> 00:36:29,000
3.3.2 是简体说的嘛 windows 3.1 只有在世界其他版本特别短命

814
00:36:29,000 --> 00:36:36,000
对嗯 windows 3.1 或者 windows 3.2 是那个 windows 95 之前世界上最流行的 windows 版本

815
00:36:39,000 --> 00:36:39,000
嗯是吧

816
00:36:39,000 --> 00:36:43,000
我的家亲国演过一部电影叫什么来着谎言语

817
00:36:44,000 --> 00:36:53,000
真实谎言真实的谎言里面那个呃他潜入一个反正是阿拉伯语的这么一个机构里面然后那个 windows

818
00:36:54,000 --> 00:36:57,000
那个 3.2 的上面显示的是阿拉伯语的 windows 我还

819
00:36:58,000 --> 00:37:05,000
挺惊讶的印象很深刻所以在那个时代是开机不默认进图形界面的 you know 所以那是一个非常

820
00:37:06,000 --> 00:37:08,000
哎那个记得我还记得有一个

821
00:37:08,000 --> 00:37:09,000
就是当时

822
00:37:09,000 --> 00:37:13,000
就是图形界面还没有完全普及

823
00:37:13,000 --> 00:37:14,000
或者说有些机器太古老

824
00:37:14,000 --> 00:37:16,000
它跑图形界面会比较慢

825
00:37:16,000 --> 00:37:20,000
但是还用一个叫做命令行的文件管理软件

826
00:37:20,000 --> 00:37:22,000
叫什么来的

827
00:37:22,000 --> 00:37:23,000
什么 Commander

828
00:37:23,000 --> 00:37:24,000
Total Commander

829
00:37:24,000 --> 00:37:27,000
PC Tools Total Commander

830
00:37:27,000 --> 00:37:31,000
还有好多东西都是命令行下面的一个命令行界面

831
00:37:31,000 --> 00:37:32,000
就是命令

832
00:37:32,000 --> 00:37:35,000
有一个专门名字来形容这种东西

833
00:37:35,000 --> 00:37:37,000
CUI 就是 Command Line User Interface

834
00:37:37,000 --> 00:37:39,000
它虽然不是图形界面

835
00:37:39,000 --> 00:37:43,000
但是它是用各种各样的符号来组成一个可以点的窗口

836
00:37:43,000 --> 00:37:46,000
有鼠标可以用

837
00:37:46,000 --> 00:37:50,000
鼠标就是一个一大块字符

838
00:37:50,000 --> 00:37:51,000
一个字符

839
00:37:51,000 --> 00:37:56,000
它一个是个 80 乘以 24 个字符的一个窗口

840
00:37:56,000 --> 00:37:58,000
鼠标就跟上占一格

841
00:37:58,000 --> 00:38:00,000
一个字符的位置

842
00:38:00,000 --> 00:38:02,000
然后挪动鼠标的时候

843
00:38:02,000 --> 00:38:04,000
屏幕上就有一个大黑块在挪动

844
00:38:04,000 --> 00:38:08,000
其实在好多 Linux 安装界面里面

845
00:38:08,000 --> 00:38:09,000
还是可以看到这个东西

846
00:38:09,000 --> 00:38:09,000
我记得

847
00:38:09,000 --> 00:38:10,000
Appetitues

848
00:38:10,000 --> 00:38:17,000
然后其实 Linux 上面的这种工具

849
00:38:17,000 --> 00:38:21,000
一般很多时候基本上叫 Encurse

850
00:38:21,000 --> 00:38:23,000
Encurse 这个包来写的

851
00:38:23,000 --> 00:38:24,000
然后还挺常

852
00:38:24,000 --> 00:38:26,000
还算常用吧

853
00:38:26,000 --> 00:38:31,000
至少我们在节目最后会介绍一些类似这种工具

854
00:38:31,000 --> 00:38:33,000
这里就先放一放

855
00:38:33,000 --> 00:38:34,000
扯远了

856
00:38:34,000 --> 00:38:35,000
反正在那个时候

857
00:38:35,000 --> 00:38:37,000
你可能你打开电脑会

858
00:38:37,000 --> 00:38:39,000
你有一个明确的想法

859
00:38:39,000 --> 00:38:39,000
说

860
00:38:39,000 --> 00:38:40,000
今天我要干什么

861
00:38:40,000 --> 00:38:41,000
然后根据你要干什么

862
00:38:41,000 --> 00:38:42,000
你要决定说

863
00:38:42,000 --> 00:38:45,000
是在 DOS 的命令行

864
00:38:45,000 --> 00:38:47,000
命令提示服务下面打

865
00:38:47,000 --> 00:38:50,000
比如说 PAL

866
00:38:50,000 --> 00:38:54,000
或者是 CNC

867
00:38:54,000 --> 00:38:55,000
还是打 Win

868
00:38:55,000 --> 00:38:57,000
因为如果你要玩游戏的话

869
00:38:57,000 --> 00:38:59,000
你可能不需要图形界面的操作

870
00:38:59,000 --> 00:39:02,000
你只需要打入游戏的名字

871
00:39:02,000 --> 00:39:03,000
然后游戏就会独占整台计算机

872
00:39:03,000 --> 00:39:05,000
然后把所有

873
00:39:05,000 --> 00:39:07,000
大风的启动名是不是 Rich

874
00:39:07,000 --> 00:39:08,000
我记得

875
00:39:08,000 --> 00:39:09,000
对没错

876
00:39:09,000 --> 00:39:12,000
还有三国

877
00:39:12,000 --> 00:39:14,000
战功群传之类的

878
00:39:14,000 --> 00:39:18,000
你都需要在盘符下面输入

879
00:39:18,000 --> 00:39:20,000
金庸群侠传也是这样吧

880
00:39:20,000 --> 00:39:22,000
对金庸群侠传也是

881
00:39:22,000 --> 00:39:24,000
在那个时候很多人都记

882
00:39:24,000 --> 00:39:25,000
仙剑

883
00:39:25,000 --> 00:39:26,000
不要忘了

884
00:39:26,000 --> 00:39:31,000
然后 PL 是什么

885
00:39:31,000 --> 00:39:32,000
PALADIN

886
00:39:32,000 --> 00:39:36,000
这个游戏的英文名很奇怪

887
00:39:36,000 --> 00:39:38,000
叫做 PALADIN 之类的

888
00:39:38,000 --> 00:39:39,000
就是十字军的名字

889
00:39:39,000 --> 00:39:41,000
还是我记错了

890
00:39:41,000 --> 00:39:42,000
为什么会这样

891
00:39:42,000 --> 00:39:43,000
我也不知道

892
00:39:43,000 --> 00:39:44,000
我觉得很奇怪

893
00:39:44,000 --> 00:39:46,000
然后反正在那个时候

894
00:39:46,000 --> 00:39:47,000
很多人不学电脑

895
00:39:47,000 --> 00:39:49,000
或者说没有那么 tech savvy

896
00:39:49,000 --> 00:39:50,000
来自于很多小孩子

897
00:39:50,000 --> 00:39:52,000
可能打开电脑

898
00:39:52,000 --> 00:39:53,000
唯一会做的一件事情

899
00:39:53,000 --> 00:39:55,000
就是在那个命令后面输入

900
00:39:55,000 --> 00:39:56,000
游戏的名字

901
00:39:56,000 --> 00:39:57,000
然后按回车

902
00:39:57,000 --> 00:39:58,000
这就已经算是

903
00:39:58,000 --> 00:40:00,000
懂电脑的表象

904
00:40:00,000 --> 00:40:02,000
对这大概就是相当于

905
00:40:02,000 --> 00:40:03,000
在 Windows 下面

906
00:40:03,000 --> 00:40:04,000
你会按开始菜单

907
00:40:04,000 --> 00:40:05,000
就是这种感觉

908
00:40:05,000 --> 00:40:07,000
对

909
00:40:07,000 --> 00:40:09,000
后来 1995 年

910
00:40:09,000 --> 00:40:10,000
有了 Windows

911
00:40:10,000 --> 00:40:13,000
就整个世界才进入一个

912
00:40:13,000 --> 00:40:16,000
就是开机默认进图形界面的时代

913
00:40:16,000 --> 00:40:17,000
当然苹果用户另外

914
00:40:17,000 --> 00:40:21,000
但我们至少我们小时候都不是苹果

915
00:40:21,000 --> 00:40:24,000
你是吧

916
00:40:24,000 --> 00:40:26,000
你不是从苹果机开始起家

917
00:40:26,000 --> 00:40:31,000
但是 Apple 2 开机也不是进图形界面的

918
00:40:31,000 --> 00:40:32,000
对 Apple 2 还是一个

919
00:40:32,000 --> 00:40:33,000
我的意思是

920
00:40:33,000 --> 00:40:34,000
除非你是 Macintosh

921
00:40:34,000 --> 00:40:36,000
或者你是 Apple Lisa 的用户

922
00:40:36,000 --> 00:40:38,000
你小时候是 Apple Lisa 的用户

923
00:40:38,000 --> 00:40:39,000
那你

924
00:40:39,000 --> 00:40:41,000
那你肯定不会跟我们是同一个阶级的人好吗

925
00:40:41,000 --> 00:40:42,000
所以

926
00:40:42,000 --> 00:40:43,000
我意思是

927
00:40:43,000 --> 00:40:44,000
对

928
00:40:44,000 --> 00:40:47,000
在普通人的童年里面

929
00:40:47,000 --> 00:40:48,000
在中国普通人的童年里面

930
00:40:48,000 --> 00:40:50,000
很少有人会接触到

931
00:40:50,000 --> 00:40:52,000
一开机就进入图形界面的电脑

932
00:40:52,000 --> 00:40:55,000
当然这是我们那个时代

933
00:40:55,000 --> 00:40:56,000
现在很多人可能你

934
00:40:56,000 --> 00:40:58,000
我相信我们的听众里面

935
00:40:58,000 --> 00:41:01,000
很多人已经在 Windows 95 发布会之后出生的了

936
00:41:01,000 --> 00:41:01,000
所以

937
00:41:01,000 --> 00:41:06,000
OK

938
00:41:06,000 --> 00:41:07,000
Yeah

939
00:41:07,000 --> 00:41:08,000
Come on

940
00:41:08,000 --> 00:41:08,000
Go on

941
00:41:08,000 --> 00:41:10,000
The hard code truth

942
00:41:10,000 --> 00:41:14,000
接着讲历史

943
00:41:14,000 --> 00:41:16,000
命令行的历史要追根溯源

944
00:41:16,000 --> 00:41:18,000
其实还蛮久远的

945
00:41:18,000 --> 00:41:21,000
其实这是一个非常自然的事情

946
00:41:21,000 --> 00:41:22,000
就是在早期

947
00:41:22,000 --> 00:41:24,000
早到什么时候

948
00:41:24,000 --> 00:41:26,000
就是在 50 年代 60 年代

949
00:41:26,000 --> 00:41:28,000
世界上根本没有人想过

950
00:41:28,000 --> 00:41:33,000
要能够实时的在屏幕上画出一个图形

951
00:41:33,000 --> 00:41:35,000
然后你去操作它这种事情

952
00:41:35,000 --> 00:41:37,000
虽然那时候电视已经问世了

953
00:41:37,000 --> 00:41:38,000
嗯

954
00:41:38,000 --> 00:41:38,000
嗯

956
00:42:08,000 --> 00:42:10,000
的打字机

957
00:42:10,000 --> 00:42:11,000
打字机的意思就是

958
00:42:11,000 --> 00:42:12,000
你按一个键

959
00:42:12,000 --> 00:42:13,000
然后你前面有一个纸

960
00:42:13,000 --> 00:42:14,000
纸滚

961
00:42:14,000 --> 00:42:15,000
然后这个纸滚

962
00:42:15,000 --> 00:42:17,000
这个滚动的纸卷上面

963
00:42:17,000 --> 00:42:19,000
会显示出你打的字符

964
00:42:19,000 --> 00:42:21,000
然后这个电传打字机是

965
00:42:21,000 --> 00:42:22,000
Teletype

966
00:42:22,000 --> 00:42:24,000
就是由 Teletype 公司所制造的

967
00:42:24,000 --> 00:42:26,000
然后 Teletype 公司

968
00:42:26,000 --> 00:42:27,000
所制造的这些机器

969
00:42:27,000 --> 00:42:29,000
在五十年代末六十年代初的时候

970
00:42:29,000 --> 00:42:31,000
基本上是遍布整个

971
00:42:31,000 --> 00:42:33,000
西方世界

972
00:42:33,000 --> 00:42:35,000
尤其是美国

973
00:42:35,000 --> 00:42:36,000
基本上每一个

974
00:42:36,000 --> 00:42:38,000
每个大学

975
00:42:38,000 --> 00:42:40,000
每一个机构都会有

976
00:42:40,000 --> 00:42:42,000
因为这个东西真的是非常

977
00:42:42,000 --> 00:42:43,000
非常的

978
00:42:43,000 --> 00:42:45,000
在那个时候就像一个

979
00:42:45,000 --> 00:42:46,000
像什么

980
00:42:46,000 --> 00:42:49,000
可以类比为今天的什么东西

981
00:42:49,000 --> 00:42:51,000
点击的键

982
00:42:51,000 --> 00:42:53,000
其实就是有点像今天的

983
00:42:53,000 --> 00:42:55,000
笔记本电脑

984
00:42:55,000 --> 00:42:57,000
就是基本上

985
00:42:57,000 --> 00:42:59,000
可以用到的地方非常多

986
00:42:59,000 --> 00:43:00,000
然后

987
00:43:00,000 --> 00:43:04,000
有点稍微有点尊严的地方

988
00:43:04,000 --> 00:43:05,000
都会弄上来

989
00:43:05,000 --> 00:43:06,000
对

990
00:43:06,000 --> 00:43:06,000
对

994
00:44:36,000 --> 00:44:37,000
我现在是在这个地方

995
00:44:37,000 --> 00:44:38,000
我现在是在这个地方

996
00:44:38,000 --> 00:44:39,000
我现在是在这个地方

997
00:44:39,000 --> 00:44:40,000
我现在是在这个地方

998
00:44:40,000 --> 00:44:41,000
我现在是在这个地方

999
00:44:41,000 --> 00:44:42,000
我现在是在这个地方

1000
00:44:42,000 --> 00:44:43,000
我现在是在这个地方

1001
00:44:43,000 --> 00:44:44,000
我现在是在这个地方

1002
00:44:44,000 --> 00:44:45,000
我现在是在这个地方

1003
00:44:45,000 --> 00:44:46,000
我现在是在这个地方

1004
00:44:46,000 --> 00:44:47,000
我现在是在这个地方

1005
00:44:47,000 --> 00:44:48,000
我现在是在这个地方

1006
00:44:48,000 --> 00:44:49,000
我现在是在这个地方

1007
00:44:49,000 --> 00:44:50,000
我现在是在这个地方

1008
00:44:50,000 --> 00:44:51,000
我现在是在这个地方

1009
00:44:51,000 --> 00:44:52,000
我现在是在这个地方

1010
00:44:52,000 --> 00:44:53,000
我现在是在这个地方

1011
00:44:53,000 --> 00:44:54,000
我现在是在这个地方

1012
00:44:54,000 --> 00:44:55,000
我现在是在这个地方

1013
00:44:55,000 --> 00:44:56,000
我现在是在这个地方

1014
00:44:56,000 --> 00:44:57,000
我现在是在这个地方

1015
00:44:57,000 --> 00:44:58,000
我现在是在这个地方

1016
00:44:58,000 --> 00:44:59,000
我现在是在这个地方

1017
00:44:59,000 --> 00:45:00,000
我现在是在这个地方

1018
00:45:00,000 --> 00:45:01,000
我现在是在这个地方

1019
00:45:01,000 --> 00:45:02,000
我现在是在这个地方

1020
00:45:02,000 --> 00:45:03,000
我现在是在这个地方

1021
00:45:03,000 --> 00:45:04,000
我们在一起

1022
00:45:04,000 --> 00:45:05,000
我们整个生活

1023
00:45:05,000 --> 00:45:06,000
我们整个生活

1024
00:45:06,000 --> 00:45:07,000
当然 drag

1025
00:45:07,000 --> 00:45:07,000
当然,已经有很多事项

1026
00:45:07,000 --> 00:45:09,000
当然,已经有很多事项

1027
00:45:09,000 --> 00:45:10,000
但在第二季

1028
00:45:10,000 --> 00:45:12,000
2022 年的

1029
00:45:12,000 --> 00:45:13,000
20 layout

1030
00:45:13,000 --> 00:45:14,000
那不知道

1031
00:45:14,000 --> 00:45:15,000
我们是 er 我试玩力

1032
00:45:15,000 --> 00:45:16,000
我们核心 chief

1033
00:45:16,000 --> 00:45:17,000
Mansion

1034
00:45:17,000 --> 00:45:19,000
我们核心

1035
00:45:19,000 --> 00:45:21,000
我们 corona

1036
00:45:21,000 --> 00:45:22,000
能试玩

1037
00:45:22,000 --> 00:45:24,000
对寸

1038
00:45:24,000 --> 00:45:25,000
然后最后

1039
00:45:25,000 --> 00:45:26,000
我们输入了

1040
00:45:26,000 --> 00:45:27,000
那个时候

1041
00:45:27,000 --> 00:45:32,000
流

1042
00:45:32,000 --> 00:45:33,000
老实说

1043
00:45:33,000 --> 00:45:35,000
81 年还是哪一年为止

1044
00:45:35,000 --> 00:45:36,000
一直都是美国一个

1045
00:45:36,000 --> 00:45:39,000
独占垄断的这么一个电话公司

1046
00:45:39,000 --> 00:45:41,000
就是如果你在美国使用电话的话

1047
00:45:41,000 --> 00:45:43,000
那你使用一定是贝尔公司服务

1048
00:45:43,000 --> 00:45:45,000
然后就是 90 年代的中国电信

1049
00:45:45,000 --> 00:45:46,000
没错就是那种感觉

1050
00:45:46,000 --> 00:45:49,000
所以我们通过读历史就知道

1051
00:45:49,000 --> 00:45:51,000
这个电信公司永远是邪恶的

1052
00:45:51,000 --> 00:45:53,000
在 60 年的时候

1053
00:45:53,000 --> 00:45:56,000
贝尔公司有这么一条规定

1054
00:45:56,000 --> 00:45:57,000
就是我的电话线路

1055
00:45:57,000 --> 00:45:58,000
只能用来打电话

1056
00:45:58,000 --> 00:46:01,000
你不能在上面传输其他电信号

1057
00:46:01,000 --> 00:46:04,000
这就意味着你不能说

1058
00:46:04,000 --> 00:46:05,000
我把电话拆了

1059
00:46:05,000 --> 00:46:06,000
然后把它连到电传达子机上

1060
00:46:06,000 --> 00:46:08,000
然后让这台电传达子机

1061
00:46:08,000 --> 00:46:09,000
和另外一台电传达子机联络

1062
00:46:09,000 --> 00:46:11,000
那怎么办呢

1063
00:46:11,000 --> 00:46:13,000
人们有这么一个方法

1064
00:46:13,000 --> 00:46:16,000
就是用一个小盒子

1065
00:46:16,000 --> 00:46:19,000
然后这小盒子上面有两个圆形的

1066
00:46:19,000 --> 00:46:22,000
用这个皮

1067
00:46:22,000 --> 00:46:24,000
人道格包起来的这么一个

1068
00:46:24,000 --> 00:46:25,000
两个基座

1069
00:46:25,000 --> 00:46:27,000
然后你可以把电话拿起来

1070
00:46:27,000 --> 00:46:28,000
拨一个号

1071
00:46:28,000 --> 00:46:30,000
然后把这个电话放在这个基座上

1072
00:46:30,000 --> 00:46:31,000
这样电话

1073
00:46:31,000 --> 00:46:31,000
两个听筒

1074
00:46:31,000 --> 00:46:34,000
一边对着一个麦克风

1075
00:46:34,000 --> 00:46:37,000
就是听筒对着麦克风

1076
00:46:37,000 --> 00:46:39,000
然后电话的听筒呢

1077
00:46:39,000 --> 00:46:41,000
则对着那个小盒子上面的扬声器

1078
00:46:41,000 --> 00:46:45,000
这样小盒子可以把电传达子机的电讯号

1079
00:46:45,000 --> 00:46:47,000
转化为声音信号

1080
00:46:47,000 --> 00:46:48,000
就是如果你用过拨号上

1081
00:46:48,000 --> 00:46:50,000
它就是那种滴滴滴

1082
00:46:50,000 --> 00:46:52,000
那种那种那种声音

1083
00:46:52,000 --> 00:46:55,000
然后这个信号被电话用声音

1084
00:46:55,000 --> 00:46:57,000
用模拟声音信号传到远端

1085
00:46:57,000 --> 00:47:00,000
然后远端再把它转化为二进制信号

1086
00:47:00,000 --> 00:47:01,000
然后这个信号被电话用声音信号

1087
00:47:01,000 --> 00:47:01,000
这么一个过程

1088
00:47:01,000 --> 00:47:05,000
这也是一个非常有意思的东西

1089
00:47:05,000 --> 00:47:07,000
然后这个东西一直使用到

1090
00:47:07,000 --> 00:47:10,000
70 年代初吧

1091
00:47:10,000 --> 00:47:13,000
这个贝尔公司

1092
00:47:13,000 --> 00:47:15,000
就是去除了这个限制

1093
00:47:15,000 --> 00:47:16,000
人们才渐渐的可以

1094
00:47:16,000 --> 00:47:19,000
就不再用这种非常原始古老的

1095
00:47:19,000 --> 00:47:23,000
用声音来传递二进制信息的

1096
00:47:23,000 --> 00:47:25,000
这个叫什么

1097
00:47:25,000 --> 00:47:28,000
Acoustic Coupler

1098
00:47:28,000 --> 00:47:29,000
对

1099
00:47:29,000 --> 00:47:30,000
Acoustic Coupler

1100
00:47:30,000 --> 00:47:30,000
对

1101
00:47:30,000 --> 00:47:30,000
对

1102
00:47:30,000 --> 00:47:30,000
对

1103
00:47:30,000 --> 00:47:30,000
对

1104
00:47:30,000 --> 00:47:30,000
对

1105
00:47:30,000 --> 00:47:30,000
对

1106
00:47:30,000 --> 00:47:30,000
对

1107
00:47:30,000 --> 00:47:30,000
对

1108
00:47:30,000 --> 00:47:30,000
对

1109
00:47:30,000 --> 00:47:30,000
对

1110
00:47:30,000 --> 00:47:30,000
对

1111
00:47:30,000 --> 00:47:31,000
对

1112
00:47:31,000 --> 00:47:31,000
对

1113
00:47:31,000 --> 00:47:31,000
对

1116
00:48:31,000 --> 00:48:31,000
clean

1117
00:48:31,000 --> 00:48:56,000
对

1118
00:48:56,000 --> 00:48:58,000
献出了这个

1119
00:48:58,000 --> 00:48:59,000
这个

1120
00:48:59,000 --> 00:48:59,000
这个

1121
00:48:59,000 --> 00:48:59,000
这个

1122
00:48:59,000 --> 00:48:59,000
这个

1123
00:48:59,000 --> 00:49:00,000
嗯

1124
00:49:00,000 --> 00:49:00,000
感觉

1125
00:49:00,000 --> 00:49:00,000
很帅 understood

1126
00:49:00,000 --> 00:49:01,000
Hua

1127
00:49:01,000 --> 00:49:01,000
太帅了

1128
00:49:01,000 --> 00:49:05,000
然后后来就说

1129
00:49:05,000 --> 00:49:06,000
那可以直接接电了

1130
00:49:06,000 --> 00:49:07,000
意思就是说

1131
00:49:07,000 --> 00:49:09,000
从无线变有线了

1132
00:49:09,000 --> 00:49:10,000
直接插管子

1133
00:49:10,000 --> 00:49:12,000
插线

1134
00:49:12,000 --> 00:49:14,000
后来的调整游戏

1135
00:49:14,000 --> 00:49:16,000
就可以自己去进行拨号

1136
00:49:16,000 --> 00:49:18,000
然后直接把音频信号

1137
00:49:18,000 --> 00:49:19,000
转号为

1138
00:49:19,000 --> 00:49:21,000
直接把电讯号

1139
00:49:21,000 --> 00:49:22,000
转号为音频信号

1140
00:49:22,000 --> 00:49:24,000
所以其实 Acoustic Couple

1141
00:49:24,000 --> 00:49:26,000
和我们理解的 Modem

1142
00:49:26,000 --> 00:49:27,000
其实本质上是

1143
00:49:27,000 --> 00:49:29,000
做同样的事情的

1144
00:49:29,000 --> 00:49:30,000
只是说他们接入方式

1145
00:49:30,000 --> 00:49:31,000
Acoustic Couple 应该是

1146
00:49:31,000 --> 00:49:33,000
Modem 的一个部件

1147
00:49:33,000 --> 00:49:34,000
对对对

1148
00:49:34,000 --> 00:49:37,000
就是代替导线的部件

1149
00:49:37,000 --> 00:49:37,000
对

1150
00:49:37,000 --> 00:49:39,000
后来的 Modem

1151
00:49:39,000 --> 00:49:40,000
可以直接通过一个分线头

1152
00:49:40,000 --> 00:49:41,000
插在电话线上

1153
00:49:41,000 --> 00:49:42,000
Modem 其实本身

1154
00:49:42,000 --> 00:49:44,000
就是电话的线路的一个组件

1155
00:49:44,000 --> 00:49:46,000
RJ 32 这个标准

1156
00:49:46,000 --> 00:49:47,000
RJ 多少

1157
00:49:47,000 --> 00:49:48,000
RJ 45 是网线的

1158
00:49:48,000 --> 00:49:50,000
对 RJ 45 是网线

1159
00:49:50,000 --> 00:49:51,000
RJ 32 是

1160
00:49:51,000 --> 00:49:52,000
应该是 32

1161
00:49:52,000 --> 00:49:53,000
是电话线

1162
00:49:53,000 --> 00:49:54,000
小的那个电话接头

1163
00:49:54,000 --> 00:49:55,000
这叫什么

1164
00:49:55,000 --> 00:49:56,000
查一下

1165
00:49:56,000 --> 00:49:57,000
你查吧

1166
00:49:57,000 --> 00:49:58,000
Telephone line

1167
00:49:58,000 --> 00:49:59,000
水晶头

1168
00:49:59,000 --> 00:50:00,000
对

1169
00:50:00,000 --> 00:50:07,000
RJ 是叫做 Register Jack

1170
00:50:07,000 --> 00:50:09,000
然后 RJ 10

1171
00:50:09,000 --> 00:50:12,000
RJ 11

1172
00:50:12,000 --> 00:50:13,000
对

1173
00:50:13,000 --> 00:50:13,000
RJ 11

1174
00:50:13,000 --> 00:50:15,000
对

1175
00:50:15,000 --> 00:50:16,000
这个是我们就

1176
00:50:16,000 --> 00:50:17,000
那 RJ 32 有这个东西吗

1177
00:50:17,000 --> 00:50:19,000
可能没有

1178
00:50:19,000 --> 00:50:19,000
记错了

1179
00:50:19,000 --> 00:50:21,000
有 RJ 11

1180
00:50:21,000 --> 00:50:23,000
RJ 14

1181
00:50:23,000 --> 00:50:24,000
RJ 25

1182
00:50:24,000 --> 00:50:26,000
然后对

1183
00:50:26,000 --> 00:50:27,000
就这么一些

1184
00:50:27,000 --> 00:50:28,000
然后 RJ 45

1185
00:50:28,000 --> 00:50:29,000
就是我们常说的

1186
00:50:29,000 --> 00:50:29,000
这个双脚线

1187
00:50:29,000 --> 00:50:30,000
就是网线的

1188
00:50:30,000 --> 00:50:31,000
线的标准头了

1189
00:50:31,000 --> 00:50:32,000
嗯

1190
00:50:32,000 --> 00:50:33,000
它会宽一些

1191
00:50:33,000 --> 00:50:35,000
应该是有多少帧来在里面

1192
00:50:35,000 --> 00:50:36,000
四个

1193
00:50:36,000 --> 00:50:37,000
四个

1194
00:50:37,000 --> 00:50:38,000
网线是八个帧

1195
00:50:38,000 --> 00:50:38,000
对

1196
00:50:38,000 --> 00:50:39,000
网线是对嘛

1197
00:50:39,000 --> 00:50:40,000
对

1198
00:50:40,000 --> 00:50:42,000
然后这个应该是四个帧吧

1199
00:50:42,000 --> 00:50:43,000
RJ 11

1200
00:50:43,000 --> 00:50:45,000
具体也不太懂

1201
00:50:45,000 --> 00:50:48,000
其实现在我看也有很多这个

1202
00:50:48,000 --> 00:50:49,000
就是那个 RJ 45

1203
00:50:49,000 --> 00:50:51,000
因为它那个线头多嘛

1204
00:50:51,000 --> 00:50:53,000
它其实可以当电话线用的嘛

1205
00:50:53,000 --> 00:50:55,000
然后还可以留几个来做一个摆照的头

1206
00:50:55,000 --> 00:50:57,000
所以很多这种写字楼啊

1207
00:50:57,000 --> 00:50:59,000
或者是家里装修的时候

1208
00:50:59,000 --> 00:51:00,000
他就说为了方便

1209
00:51:00,000 --> 00:51:02,000
就不单独布这个电话线的槽

1210
00:51:02,000 --> 00:51:04,000
而就直接走一个网线就好了

1211
00:51:04,000 --> 00:51:04,000
对

1212
00:51:04,000 --> 00:51:06,000
但是如果你现在要装修房子

1213
00:51:06,000 --> 00:51:08,000
我强烈不建议这么干

1214
00:51:08,000 --> 00:51:08,000
首先第一个

1215
00:51:08,000 --> 00:51:10,000
你不需要真的需要电话机了

1216
00:51:10,000 --> 00:51:10,000
对吧

1217
00:51:10,000 --> 00:51:12,000
现在都是用手机

1218
00:51:12,000 --> 00:51:13,000
第二个就是如果你那么干了之后

1219
00:51:13,000 --> 00:51:14,000
你那个网线

1220
00:51:14,000 --> 00:51:16,000
哪怕是你说什么超无力的线

1221
00:51:16,000 --> 00:51:20,000
那最后最终也只能跑百兆的这个速度了

1222
00:51:20,000 --> 00:51:21,000
因为我现在租房子就是

1223
00:51:21,000 --> 00:51:24,000
我现在和女朋友租房子就是有那个

1224
00:51:24,000 --> 00:51:29,000
每一间房子里面都有三两个那个网线的借口

1225
00:51:29,000 --> 00:51:29,000
好鸡肋啊

1226
00:51:30,000 --> 00:51:31,000
就一个是电话

1227
00:51:31,000 --> 00:51:32,000
一个是走网

1228
00:51:32,000 --> 00:51:33,000
没有两个都是蓝

1229
00:51:33,000 --> 00:51:38,000
就有一个在储藏室里面有一个装电话线的槽

1230
00:51:38,000 --> 00:51:40,000
然后那个槽上面有一个

1231
00:51:40,000 --> 00:51:43,000
等于房间有自己的一个号

1232
00:51:43,000 --> 00:51:47,000
然后这个号分了八根线到每个屋子

1233
00:51:47,000 --> 00:51:49,000
每个两根

1234
00:51:49,000 --> 00:51:50,000
所以其实并没有什么用

1235
00:51:50,000 --> 00:51:52,000
就是说你还是用了 WiFi 是吧

1236
00:51:52,000 --> 00:51:52,000
对

1237
00:51:52,000 --> 00:51:53,000
没错

1238
00:51:53,000 --> 00:51:54,000
哈哈

1239
00:51:54,000 --> 00:51:54,000
好

1240
00:51:54,000 --> 00:51:55,000
太掉技术

1241
00:51:55,000 --> 00:51:58,000
其实我们现在在在那个装修办公室嘛

1242
00:51:58,000 --> 00:51:59,000
然后

1243
00:51:59,000 --> 00:52:00,000
发现

1244
00:52:00,000 --> 00:52:01,000
一个新的办公室啊

1245
00:52:01,000 --> 00:52:03,000
就是说也是要不限那些

1246
00:52:03,000 --> 00:52:06,000
其实都准备完全不走网线了

1247
00:52:06,000 --> 00:52:07,000
都是走无线

1248
00:52:07,000 --> 00:52:08,000
对纯 WiFi 网络

1249
00:52:08,000 --> 00:52:09,000
嗯

1250
00:52:09,000 --> 00:52:10,000
啊扯远了

1251
00:52:10,000 --> 00:52:12,000
就接着说回到电传打字机啊

1252
00:52:12,000 --> 00:52:15,000
我们一下子越过了 50 年的历史

1253
00:52:15,000 --> 00:52:16,000
好跳啊

1254
00:52:16,000 --> 00:52:17,000
嗯

1255
00:52:17,000 --> 00:52:17,000
对

1256
00:52:17,000 --> 00:52:19,000
总之这个电传打字机的模样

1257
00:52:19,000 --> 00:52:20,000
呃

1258
00:52:20,000 --> 00:52:21,000
非常的 50 年代

1259
00:52:21,000 --> 00:52:26,000
就是欢迎各位听众去点开这个 show notes 里面的链接

1260
00:52:26,000 --> 00:52:28,000
看一看电传打字机到底是一个什么样的

1261
00:52:28,000 --> 00:52:29,000
一个什么样子

1262
00:52:29,000 --> 00:52:33,000
但是最大我们这跟这期节目有关的重点

1263
00:52:33,000 --> 00:52:36,000
就是这个电传打字机通常只会在一行上面工作

1264
00:52:36,000 --> 00:52:38,000
就是不管你输入还是输出

1265
00:52:38,000 --> 00:52:40,000
你得到的结果一般都只有一行

1266
00:52:40,000 --> 00:52:42,000
当然输出有可能有很多行

1267
00:52:42,000 --> 00:52:44,000
但输入基本上就是一行

1268
00:52:44,000 --> 00:52:45,000
你一行是什么意思

1269
00:52:45,000 --> 00:52:49,000
一行就是这个这个这个电传打字机上面

1270
00:52:49,000 --> 00:52:52,000
你最长只能输入固定字符

1271
00:52:52,000 --> 00:52:53,000
一般是 80 个

1272
00:52:53,000 --> 00:52:53,000
对

1273
00:52:53,000 --> 00:52:55,000
然后呃

1274
00:52:55,000 --> 00:52:57,000
如果你输到这还没完的话

1275
00:52:57,000 --> 00:52:59,000
你要么要告诉电传打字机

1276
00:52:59,000 --> 00:53:00,000
呃

1277
00:53:00,000 --> 00:53:02,000
我还要输再输入一行

1278
00:53:02,000 --> 00:53:05,000
然后你要输入一个特别符号

1279
00:53:05,000 --> 00:53:05,000
呃

1280
00:53:05,000 --> 00:53:07,000
这个时候你要你要你要你要按一个什么

1281
00:53:07,000 --> 00:53:09,000
按一个就相当于 backslash 的键

1282
00:53:09,000 --> 00:53:12,000
但是反正是上面一个实体键

1283
00:53:12,000 --> 00:53:13,000
ok

1284
00:53:13,000 --> 00:53:14,000
要不然就是你就得按回车了

1285
00:53:14,000 --> 00:53:18,000
就是回车就是你把这一行当前行的东西输出出去

1286
00:53:18,000 --> 00:53:21,000
但这个时候你是告诉的是电传打字机

1287
00:53:21,000 --> 00:53:23,000
是我要输入多入一行的

1288
00:53:23,000 --> 00:53:25,000
还是说告诉那个告诉那个远端

1289
00:53:25,000 --> 00:53:26,000
你要输出输入多于一行

1290
00:53:26,000 --> 00:53:28,000
是告诉电传打字机

1291
00:53:28,000 --> 00:53:28,000
对就是电传打字机会把你当时的电传打字机输入多于一行的

1292
00:53:28,000 --> 00:53:32,000
就是电传打字机会把你当前整个行就是它有一个 buffer 吧

1293
00:53:32,000 --> 00:53:38,000
你可以理解为他把当前行 buffer 里面的东西呃传输出去

1294
00:53:38,000 --> 00:53:42,000
但是这个 buffer 有多长是 buffer 应该是要比一行的长度长的

1295
00:53:42,000 --> 00:53:43,000
但是不管怎么说

1296
00:53:43,000 --> 00:53:49,000
他在具体表现就是通常大部分情况下你只会输入一行

1297
00:53:49,000 --> 00:53:51,000
东西啊你想想那个场景还是蛮搞笑的

1298
00:53:51,000 --> 00:53:53,000
你打打打打一个 mini 超级好的

1299
00:53:53,000 --> 00:53:54,000
你还说就都吗

1300
00:53:54,000 --> 00:53:58,000
对对对对没错

1301
00:53:58,000 --> 00:54:00,000
就是这个感觉啊

1302
00:54:00,000 --> 00:54:01,000
然后

1303
00:54:02,000 --> 00:54:05,000
这个特征吧

1304
00:54:05,000 --> 00:54:17,000
也就造就了我们接下来六十年的这个计算机历史里面几乎所有人就至少所有需要学写程序的人都会面临的一个问题

1305
00:54:17,000 --> 00:54:22,000
就是什么是命令行就是 common line line

1306
00:54:22,000 --> 00:54:23,000
这个东西就来自于此

1307
00:54:23,000 --> 00:54:24,000
就是因为早思一定

1308
00:54:24,000 --> 00:54:24,000
认为

1309
00:54:24,000 --> 00:54:26,000
打的机场就只允许你

1310
00:54:26,000 --> 00:54:28,000
针对当前行来操作

1311
00:54:28,000 --> 00:54:30,000
所以不是命令行

1312
00:54:30,000 --> 00:54:31,000
是命令一行

1313
00:54:31,000 --> 00:54:31,000
对

1314
00:54:31,000 --> 00:54:33,000
就是一个命令行

1315
00:54:33,000 --> 00:54:34,000
有时候你会好奇说

1316
00:54:34,000 --> 00:54:36,000
为什么写程序

1317
00:54:36,000 --> 00:54:39,000
不能是从屏幕上的任何地方开始

1318
00:54:39,000 --> 00:54:41,000
为什么一定要是在左上角

1319
00:54:41,000 --> 00:54:42,000
或者左下角

1320
00:54:42,000 --> 00:54:44,000
然后输入一行命令

1321
00:54:44,000 --> 00:54:45,000
然后按回车呢

1322
00:54:45,000 --> 00:54:48,000
来自于回车键到底是怎么来的

1323
00:54:48,000 --> 00:54:49,000
为什么会回车键

1324
00:54:49,000 --> 00:54:50,000
而不是一个

1325
00:54:50,000 --> 00:54:52,000
这种东西

1326
00:54:52,000 --> 00:54:53,000
而不是一个什么

1327
00:54:53,000 --> 00:54:54,000
比如说开始输入

1328
00:54:54,000 --> 00:54:56,000
或者开始执行这样的键

1329
00:54:56,000 --> 00:54:59,000
那其实也是从这儿来的

1330
00:54:59,000 --> 00:55:00,000
对

1331
00:55:00,000 --> 00:55:04,000
然后 teletype 这个词

1332
00:55:04,000 --> 00:55:06,000
对于我们一直延续到今天的影响

1333
00:55:06,000 --> 00:55:07,000
还有一个就是 tty

1334
00:55:07,000 --> 00:55:09,000
就是我不知道你

1335
00:55:09,000 --> 00:55:12,000
但是我在开始接触 linux 的时候

1336
00:55:12,000 --> 00:55:13,000
经常会好奇说

1337
00:55:13,000 --> 00:55:15,000
这个 tty 到底是一个什么东西的缩写

1338
00:55:15,000 --> 00:55:17,000
这很难猜出来对吧

1339
00:55:17,000 --> 00:55:19,000
它其实 teletype 的缩写

1340
00:55:19,000 --> 00:55:20,000
一直延续到今天

1341
00:55:20,000 --> 00:55:22,000
包括你面对的这台

1342
00:55:22,000 --> 00:55:23,000
这个

1343
00:55:23,000 --> 00:55:26,000
mac 电脑或者是你手上的 android

1344
00:55:26,000 --> 00:55:28,000
或者是你 iPhone

1345
00:55:28,000 --> 00:55:29,000
其实都有 tty 这个东西对吧

1346
00:55:29,000 --> 00:55:33,000
就是在 device slash tty

1347
00:55:33,000 --> 00:55:35,000
哪怕你打开你的 item

1348
00:55:35,000 --> 00:55:37,000
上面都会显示说

1349
00:55:37,000 --> 00:55:41,000
last login 11 月 11 号 18 点 46 分

1350
00:55:41,000 --> 00:55:43,000
然后 on tty s 000

1351
00:55:43,000 --> 00:55:46,000
所以其实你要解释一下

1352
00:55:46,000 --> 00:55:48,000
这个我们现在 solos 里面

1353
00:55:48,000 --> 00:55:49,000
这个 device tty

1354
00:55:49,000 --> 00:55:51,000
到底是它的一个作用是什么

1355
00:55:51,000 --> 00:55:53,000
slash tty slash tty

1356
00:55:53,000 --> 00:55:55,000
其实是一个

1357
00:55:55,000 --> 00:55:59,000
用软件模拟出来的

1358
00:55:59,000 --> 00:56:00,000
一个电传达子机的终端

1359
00:56:00,000 --> 00:56:01,000
就是你可以

1360
00:56:01,000 --> 00:56:03,000
它应该叫 ptty 对吧

1361
00:56:03,000 --> 00:56:05,000
sudo tty

1362
00:56:05,000 --> 00:56:07,000
就是一个伪终端

1363
00:56:07,000 --> 00:56:09,000
就是它不是一个真正的

1364
00:56:09,000 --> 00:56:10,000
电传达子机的实体

1365
00:56:10,000 --> 00:56:12,000
而是你的计算机

1366
00:56:12,000 --> 00:56:14,000
想象出来的

1367
00:56:14,000 --> 00:56:15,000
它的

1368
00:56:15,000 --> 00:56:17,000
它可以支配的诸多

1369
00:56:17,000 --> 00:56:19,000
电传达子机之一

1370
00:56:19,000 --> 00:56:21,000
但它的作用是

1371
00:56:21,000 --> 00:56:22,000
它的实际作用是什么呢

1372
00:56:22,000 --> 00:56:23,000
它的作用就是输入和输入之后

1373
00:56:23,000 --> 00:56:23,000
它的实际作用是什么呢

1374
00:56:23,000 --> 00:56:24,000
输出

1375
00:56:27,000 --> 00:56:29,000
就是说你打的键盘

1376
00:56:29,000 --> 00:56:31,000
是通过这个 tty 这个设备

1377
00:56:31,000 --> 00:56:32,000
进入到 kernel 的

1378
00:56:32,000 --> 00:56:34,000
然后 kernel 给你 print 回来的东西

1379
00:56:34,000 --> 00:56:36,000
是通过这个 tty 设备传回来的

1380
00:56:36,000 --> 00:56:36,000
是

1381
00:56:36,000 --> 00:56:38,000
就是你可以这么理解

1382
00:56:38,000 --> 00:56:39,000
比如说我是一台 mainframe

1383
00:56:39,000 --> 00:56:42,000
然后我有输入 standout

1384
00:56:42,000 --> 00:56:44,000
standout arrow 和 standout input

1385
00:56:44,000 --> 00:56:45,000
然后与此同时

1386
00:56:45,000 --> 00:56:47,000
我有很多个 tty

1387
00:56:47,000 --> 00:56:49,000
我连接了很多个实体的机械的

1388
00:56:49,000 --> 00:56:51,000
电子的电传达子机

1389
00:56:51,000 --> 00:56:52,000
然后我现在说好

1390
00:56:52,000 --> 00:56:53,000
我要把

1391
00:56:53,000 --> 00:56:57,000
把我的 standout input 连接到 tty 1 上

1392
00:56:57,000 --> 00:57:00,000
那么此时 tty 1 上输入什么

1393
00:57:00,000 --> 00:57:03,000
我就会把它接到我的 standout input 上

1394
00:57:03,000 --> 00:57:05,000
然后我说我的 standout output

1395
00:57:05,000 --> 00:57:08,000
需要输入到 tty 4 上面

1396
00:57:08,000 --> 00:57:11,000
那我比如说 tty 1

1397
00:57:11,000 --> 00:57:12,000
刚才说了几

1398
00:57:12,000 --> 00:57:15,000
tty 1 告诉我说 print hello world

1399
00:57:15,000 --> 00:57:17,000
然后我说 standout output 在 tty 4 上

1400
00:57:17,000 --> 00:57:20,000
那么 tty 4 这天电传达子机上

1401
00:57:20,000 --> 00:57:21,000
就会输出 hello world

1402
00:57:23,000 --> 00:57:26,000
对它就相当于对就相当于一个

1403
00:57:26,000 --> 00:57:28,000
标准的输入输出设备

1404
00:57:28,000 --> 00:57:31,000
然后只不过是用软件来模拟

1405
00:57:31,000 --> 00:57:34,000
然后键盘的世界被操作系统的驱动

1406
00:57:34,000 --> 00:57:38,000
捕捉到也是转化到 tty 的一个输入上面

1407
00:57:38,000 --> 00:57:39,000
去再传给内核

1408
00:57:39,000 --> 00:57:46,000
对如果你要使用 terminal emulator

1409
00:57:46,000 --> 00:57:49,000
如果你使用终端模拟器的话

1410
00:57:49,000 --> 00:57:52,000
但是其他的一些东西不是这样

1411
00:57:52,000 --> 00:57:53,000
比如说游戏肯定不是这样的

1412
00:57:53,000 --> 00:57:59,000
游戏就是直接扫描键盘产生的中断

1413
00:57:59,000 --> 00:58:00,000
或者是 whatever it works

1414
00:58:00,000 --> 00:58:02,000
但是跟 tty 没有关系

1415
00:58:02,000 --> 00:58:04,000
ok 对

1416
00:58:04,000 --> 00:58:09,000
然后到 198 几年的时候

1417
00:58:09,000 --> 00:58:12,000
DEC 全名叫什么来着

1418
00:58:12,000 --> 00:58:15,000
digital equipment corporation

1419
00:58:15,000 --> 00:58:18,000
对数字设备公司

1420
00:58:18,000 --> 00:58:21,000
研发出了这种就是

1421
00:58:21,000 --> 00:58:23,000
用二级设备公司的设备公司

1422
00:58:23,000 --> 00:58:25,000
用一级设限显示管

1423
00:58:25,000 --> 00:58:30,000
做成了所谓的单色显示器的 terminal

1424
00:58:30,000 --> 00:58:32,000
我们才渐渐淘汰了

1425
00:58:32,000 --> 00:58:36,000
人类才渐渐淘汰了 tty 这种东西

1426
00:58:36,000 --> 00:58:40,000
但是就是打到纸袋上的那种 tty

1427
00:58:40,000 --> 00:58:44,000
终于拧了一个就相当于玻璃做的

1428
00:58:44,000 --> 00:58:45,000
这么一个电传打字机

1429
00:58:45,000 --> 00:58:49,000
所以其实他们之前那个还是挺废纸的是吧

1430
00:58:49,000 --> 00:58:50,000
对相当废纸

1431
00:58:50,000 --> 00:58:51,000
嗯

1432
00:58:51,000 --> 00:58:51,000
嗯

1433
00:58:51,000 --> 00:58:51,000
嗯

1434
00:58:51,000 --> 00:58:51,000
嗯

1435
00:58:51,000 --> 00:58:51,000
嗯

1436
00:58:51,000 --> 00:58:51,000
嗯

1437
00:58:51,000 --> 00:58:51,000
嗯

1438
00:58:51,000 --> 00:58:51,000
嗯

1439
00:58:51,000 --> 00:58:51,000
嗯

1440
00:58:51,000 --> 00:58:51,000
嗯

1441
00:58:51,000 --> 00:58:51,000
嗯

1442
00:58:51,000 --> 00:58:52,000
嗯

1443
00:58:52,000 --> 00:58:52,000
嗯

1444
00:58:52,000 --> 00:58:52,000
嗯

1445
00:58:52,000 --> 00:58:53,000
嗯

1446
00:58:53,000 --> 00:58:53,000
嗯

1447
00:58:53,000 --> 00:58:53,000
嗯

1448
00:58:53,000 --> 00:58:53,000
嗯

1449
00:58:53,000 --> 00:58:53,000
flix

1450
00:58:53,000 --> 00:58:57,000
也想到这个我也想说宅男废纸

1451
00:58:58,000 --> 00:58:59,000
那个时代已经过去了

1452
00:58:59,000 --> 00:59:00,000
对

1453
00:59:00,000 --> 00:59:01,000
嗯

1454
00:59:01,000 --> 00:59:01,000
嗯

1455
00:59:02,000 --> 00:59:02,000
对

1456
00:59:02,000 --> 00:59:04,000
然后这个شر construction

1457
00:59:04,000 --> 00:59:08,000
这个玻璃的 tty 其实就简单

1458
00:59:08,000 --> 00:59:08,000
来说

1459
00:59:08,000 --> 00:59:09,000
替代了一个打印机的作用

1460
00:59:09,000 --> 00:59:10,000
是吧

1461
00:59:10,000 --> 00:59:12,000
就替代了

1462
00:59:12,000 --> 00:59:13,000
担当

1463
00:59:13,000 --> 00:59:14,000
那个输出

1464
00:59:14,000 --> 00:59:15,000
然后输入的话

1465
00:59:15,000 --> 00:59:18,000
最大的优点就是你终于可以改智的

1466
00:59:18,000 --> 00:59:19,000
输入

1467
00:59:19,000 --> 00:59:21,000
早期的电池 打的机

1468
00:59:21,000 --> 00:59:22,000
你要打错了一个字符

1469
00:59:22,000 --> 00:59:24,000
你是改不了的

1470
00:59:24,000 --> 00:59:25,000
输错了怎么办

1471
00:59:25,000 --> 00:59:26,000
这也是一个我的问题

1472
00:59:26,000 --> 00:59:27,000
我也不知道

1473
00:59:27,000 --> 00:59:28,000
那个时候输错了

1474
00:59:28,000 --> 00:59:29,000
到底是怎么办

1475
00:59:29,000 --> 00:59:30,000
你也许有一个键

1476
00:59:30,000 --> 00:59:30,000
允许你说

1477
00:59:30,000 --> 00:59:32,000
这行废掉

1478
00:59:32,000 --> 00:59:33,000
你回退到某一个地方

1479
00:59:33,000 --> 00:59:35,000
然后你再重新打

1480
00:59:35,000 --> 00:59:36,000
就是那 Ctrl K

1481
00:59:36,000 --> 00:59:38,000
对

1482
00:59:38,000 --> 00:59:43,000
我相信电传打字机上

1483
00:59:43,000 --> 00:59:44,000
应该还是有 backspace

1484
00:59:44,000 --> 00:59:46,000
backspace 按下去的话

1485
00:59:46,000 --> 00:59:47,000
到底会具体做什么

1486
00:59:47,000 --> 00:59:48,000
它不可能抹掉

1487
00:59:48,000 --> 00:59:50,000
一个已经打好的字符

1488
00:59:50,000 --> 00:59:50,000
对吧

1489
00:59:50,000 --> 00:59:52,000
我觉得应该是把那行

1490
00:59:52,000 --> 00:59:54,000
Kill 掉

1491
00:59:54,000 --> 00:59:56,000
然后在企业行新的重新来过

1492
00:59:56,000 --> 01:00:00,000
这是唯一合理的方式

1493
01:00:00,000 --> 01:00:01,000
对

1494
01:00:01,000 --> 01:00:02,000
anyway

1495
01:00:02,000 --> 01:00:03,000
这也不是重点

1496
01:00:03,000 --> 01:00:07,000
但最大的一个要点

1497
01:00:07,000 --> 01:00:09,000
就是这个玻璃的 terminal

1498
01:00:09,000 --> 01:00:12,000
虽然表面上看

1499
01:00:12,000 --> 01:00:13,000
它是可以改的

1500
01:00:13,000 --> 01:00:15,000
然后可以多行显示的

1501
01:00:15,000 --> 01:00:16,000
但它本质上

1502
01:00:16,000 --> 01:00:18,000
在最底端

1503
01:00:18,000 --> 01:00:20,000
它还是在模拟电传打字机

1504
01:00:20,000 --> 01:00:21,000
和主机交

1505
01:00:21,000 --> 01:00:23,000
交互信息的方式

1506
01:00:23,000 --> 01:00:27,000
也就是说电传打字机连接到的主机

1507
01:00:27,000 --> 01:00:30,000
并不知道它自己连接到的是一个屏幕

1508
01:00:30,000 --> 01:00:31,000
还是一个电传打字机

1509
01:00:31,000 --> 01:00:32,000
对

1510
01:00:32,000 --> 01:00:36,000
然后最广为流行的电传打字机的型号

1511
01:00:36,000 --> 01:00:39,000
叫做 Teletype Model 33

1512
01:00:39,000 --> 01:00:42,000
Teletype Model 33 ASR

1513
01:00:42,000 --> 01:00:44,000
然后我们熟知并且爱大的

1514
01:00:44,000 --> 01:00:47,000
账单大门先生

1515
01:00:47,000 --> 01:00:49,000
账单大门

1516
01:00:49,000 --> 01:00:51,000
就是在这台电脑上的电脑上

1517
01:00:51,000 --> 01:00:55,000
开始了它的第一次编程之旅

1518
01:00:55,000 --> 01:00:57,000
对

1519
01:00:57,000 --> 01:01:01,000
然后第一台电传打字机的

1520
01:01:01,000 --> 01:01:03,000
所使用的

1521
01:01:03,000 --> 01:01:04,000
我们刚才提到

1522
01:01:04,000 --> 01:01:06,000
这个 Aucoustic Coupler 的速率

1523
01:01:06,000 --> 01:01:09,000
是 300 Bits Per Second

1524
01:01:09,000 --> 01:01:12,000
各位可以想象一下这个速度

1525
01:01:12,000 --> 01:01:14,000
300 Bits 除以 8

1526
01:01:14,000 --> 01:01:15,000
我想想

1527
01:01:15,000 --> 01:01:16,000
等一下

1528
01:01:16,000 --> 01:01:16,000
Bits

1529
01:01:16,000 --> 01:01:17,000
Bits

1530
01:01:17,000 --> 01:01:19,000
除以 8 得到 Byte

1531
01:01:19,000 --> 01:01:19,000
对

1532
01:01:19,000 --> 01:01:20,000
那有两

1533
01:01:20,000 --> 01:01:21,000
对

1534
01:01:21,000 --> 01:01:24,000
38240

1535
01:01:24,000 --> 01:01:27,000
算一下

1536
01:01:27,000 --> 01:01:28,000
300 除以 8 需要

1537
01:01:28,000 --> 01:01:31,000
37.5 Byte Per Second

1538
01:01:31,000 --> 01:01:32,000
每秒钟可以打

1539
01:01:32,000 --> 01:01:34,000
30

1540
01:01:34,000 --> 01:01:37,000
差不多 38 字符的速率

1541
01:01:37,000 --> 01:01:39,000
我们今天的 show notes

1542
01:01:39,000 --> 01:01:46,000
如果用 300 Bps 的 modem 来传输的话

1543
01:01:46,000 --> 01:01:46,000
大概

1544
01:01:46,000 --> 01:01:48,000
大概一两小时吧

1545
01:01:48,000 --> 01:01:49,000
没错

1546
01:01:49,000 --> 01:01:51,000
太不可思议了

1547
01:01:51,000 --> 01:01:52,000
对

1548
01:01:52,000 --> 01:01:54,000
这种感觉就像在那个辐射里面

1549
01:01:54,000 --> 01:01:56,000
看那个 Terminal 上一号一号

1550
01:01:56,000 --> 01:01:57,000
会蹦字的感觉

1551
01:01:58,000 --> 01:02:00,000
对这个也是一个

1552
01:02:00,000 --> 01:02:03,000
就是科幻片常用的一个梗

1553
01:02:04,000 --> 01:02:05,000
就是那个字是一行一行

1554
01:02:05,000 --> 01:02:07,000
就是一个一个字出现的嘛

1555
01:02:08,000 --> 01:02:10,000
这个一定是从当年他们那个电传打字机

1556
01:02:10,000 --> 01:02:11,000
获得的灵感

1557
01:02:11,000 --> 01:02:11,000
看着那个字

1558
01:02:12,000 --> 01:02:13,000
一个一个莫名其妙出来

1559
01:02:13,000 --> 01:02:14,000
觉得很有种

1560
01:02:14,000 --> 01:02:15,000
科技感是吧

1561
01:02:15,000 --> 01:02:16,000
其实

1562
01:02:16,000 --> 01:02:18,000
根本就是技术限制

1563
01:02:18,000 --> 01:02:19,000
对

1564
01:02:19,000 --> 01:02:20,000
就像是

1565
01:02:20,000 --> 01:02:21,000
就像是

1566
01:02:21,000 --> 01:02:22,000
下字球这种什么

1567
01:02:23,000 --> 01:02:25,000
这个科幻片再也不要用这种特效了

1568
01:02:25,000 --> 01:02:26,000
实在是太 low 了

1569
01:02:26,000 --> 01:02:28,000
就我的第一台

1570
01:02:28,000 --> 01:02:31,000
猫是我的第一只猫是 28.8 K 的

1571
01:02:33,000 --> 01:02:34,000
28.8 K

1572
01:02:34,000 --> 01:02:35,000
K

1573
01:02:35,000 --> 01:02:35,000
K 啊

1574
01:02:35,000 --> 01:02:36,000
然后这个

1575
01:02:36,000 --> 01:02:37,000
这只用 300

1576
01:02:37,000 --> 01:02:39,000
这一台猫是 0.3 K

1577
01:02:41,000 --> 01:02:42,000
0.3 K

1578
01:02:43,000 --> 01:02:44,000
对

1579
01:02:47,000 --> 01:02:49,000
上 BBS 都显卡

1580
01:02:49,000 --> 01:02:50,000
上 BBS

1581
01:02:50,000 --> 01:02:51,000
那个时候

1582
01:02:51,000 --> 01:02:53,000
真的是 BBS 没有什么

1583
01:02:54,000 --> 01:02:56,000
我相信那个时候的 BBS 根本不存在

1584
01:02:56,000 --> 01:02:57,000
还没网络嘛

1585
01:02:58,000 --> 01:02:59,000
还没网络

1586
01:02:59,000 --> 01:03:01,000
早期的 BBS 根本就是转信站嘛

1587
01:03:02,000 --> 01:03:04,000
就是你在离线的状态下写好信

1588
01:03:04,000 --> 01:03:05,000
读好信

1589
01:03:05,000 --> 01:03:06,000
然后连线

1590
01:03:06,000 --> 01:03:08,000
把所有需要收和发的信

1591
01:03:09,000 --> 01:03:10,000
一次性收和发

1592
01:03:10,000 --> 01:03:11,000
然后再离线

1593
01:03:11,000 --> 01:03:12,000
再读你刚才收到的什么

1594
01:03:13,000 --> 01:03:14,000
然后写你要写的

1595
01:03:15,000 --> 01:03:16,000
其实是

1596
01:03:16,000 --> 01:03:17,000
离散那种状态

1597
01:03:18,000 --> 01:03:18,000
像现在这种

1598
01:03:19,000 --> 01:03:21,000
Instant Messenger 真是不可想象

1599
01:03:21,000 --> 01:03:22,000
对

1600
01:03:25,000 --> 01:03:25,000
Anyway

1601
01:03:25,000 --> 01:03:27,000
然后时光光阴荏染

1602
01:03:27,000 --> 01:03:29,000
我们来到了 UNIX 时代

1603
01:03:29,000 --> 01:03:31,000
在 Bell 实验室

1604
01:03:32,000 --> 01:03:34,000
和 MIT 和这个

1605
01:03:34,000 --> 01:03:36,000
通用电器里面的

1606
01:03:36,000 --> 01:03:38,000
通用电器实验室里面出现了一种操作系统

1607
01:03:38,000 --> 01:03:40,000
叫做 Multics

1608
01:03:42,000 --> 01:03:44,000
Multiple time

1609
01:03:44,000 --> 01:03:47,000
什么多用户分时系统

1610
01:03:48,000 --> 01:03:49,000
然后他的后

1611
01:03:49,000 --> 01:03:50,000
在那个时代还是

1612
01:03:50,000 --> 01:03:52,000
使用这个电池卡子机的

1613
01:03:52,000 --> 01:03:56,000
但是到 UNIX 时代基本上已经全都切换到了这个

1614
01:03:57,000 --> 01:03:58,000
就是带显示器的

1615
01:03:59,000 --> 01:03:59,000
Terminal

1616
01:04:00,000 --> 01:04:02,000
然后在 Terminal 时代呢

1617
01:04:03,000 --> 01:04:04,000
Terminal 出现时代

1618
01:04:05,000 --> 01:04:08,000
人们延续了这个 Multics 里面的一个概念

1619
01:04:08,000 --> 01:04:10,000
就是这个 Shell 的概念

1620
01:04:11,000 --> 01:04:11,000
然后

1621
01:04:13,000 --> 01:04:14,000
要不你来解释一下什么是 Shell

1622
01:04:14,000 --> 01:04:15,000
Shell 跟 Kernel 的关系

1623
01:04:16,000 --> 01:04:18,000
我们节目叫做 Kernel Panic

1624
01:04:18,000 --> 01:04:20,000
但是我们这一期在讲 Shell

1625
01:04:20,000 --> 01:04:21,000
然后聊点关系

1626
01:04:22,000 --> 01:04:22,000
壳

1627
01:04:23,000 --> 01:04:24,000
因为既然有内核

1628
01:04:24,000 --> 01:04:26,000
有壳的话就会有一个壳吧

1629
01:04:26,000 --> 01:04:28,000
壳是执行那些实际的

1630
01:04:29,000 --> 01:04:30,000
程序的

1631
01:04:30,000 --> 01:04:31,000
可以这么说吧

1632
01:04:31,000 --> 01:04:33,000
然后 Shell 其实就是给用户

1633
01:04:33,000 --> 01:04:34,000
用于

1634
01:04:34,000 --> 01:04:38,000
用于用户和这个内核交互的一个工具嘛对吧

1635
01:04:39,000 --> 01:04:39,000
这有点

1636
01:04:39,000 --> 01:04:40,000
然后 Shell 的

1637
01:04:41,000 --> 01:04:41,000
你说

1638
01:04:42,000 --> 01:04:47,000
然后 Shell 的主要的功能就是什么呢就是让用户输入命令

1639
01:04:47,000 --> 01:04:48,000
然后传给这个

1640
01:04:49,000 --> 01:04:50,000
Kernel 去执行

1641
01:04:50,000 --> 01:04:51,000
然后

1642
01:04:51,000 --> 01:04:53,000
再把这个执行的结果

1643
01:04:53,000 --> 01:04:55,000
再展示给用户嘛

1644
01:04:55,000 --> 01:04:56,000
就通过这个 TTY

1645
01:04:56,000 --> 01:04:58,000
这个电传达字机接口

1646
01:04:59,000 --> 01:04:59,000
对

1647
01:05:00,000 --> 01:05:06,000
我觉得 Shell 这个名字其实最开始的时候我接触会觉得它有点迷惑性因为

1648
01:05:07,000 --> 01:05:09,000
Shell 在

1649
01:05:09,000 --> 01:05:10,000
它的

1650
01:05:10,000 --> 01:05:13,000
锁纸上面其实是专门指这个

1651
01:05:13,000 --> 01:05:16,000
跟用户输入输出乃至执行脚本的这个

1652
01:05:17,000 --> 01:05:18,000
这么一个小工具

1653
01:05:18,000 --> 01:05:20,000
然后这个工具它跑起来的时候

1654
01:05:20,000 --> 01:05:22,000
会让你可以通过命令行来

1655
01:05:23,000 --> 01:05:24,000
跟内核打交道

1656
01:05:24,000 --> 01:05:25,000
但实际上

1657
01:05:27,000 --> 01:05:32,000
就如果你去专门追究它这个名字的话那 Kernel 跑在这个核心层

1658
01:05:33,000 --> 01:05:35,000
但并不是所有跑在外层的都是 Shell

1659
01:05:37,000 --> 01:05:39,000
因为还有 User Space

1660
01:05:39,000 --> 01:05:40,000
还有其他一些程序

1661
01:05:40,000 --> 01:05:43,000
这些程序可能不会直接跟你打交道也可能会跟你打交道

1662
01:05:44,000 --> 01:05:46,000
但是他们在跟你打交道的时候并不会被

1663
01:05:47,000 --> 01:05:48,000
被称为 Shell

1664
01:05:49,000 --> 01:05:50,000
如果早期

1665
01:05:50,000 --> 01:05:51,000
是比较迷惑的一件事情

1666
01:05:52,000 --> 01:05:58,000
但是所以 Shell 类比于图形层的话应该是属于哪一层应该是属于这个

1667
01:05:58,000 --> 01:06:00,000
故意的那些

1668
01:06:01,000 --> 01:06:01,000
那些

1669
01:06:01,000 --> 01:06:03,000
这些组件那层应该是

1670
01:06:03,000 --> 01:06:05,000
对应该是

1671
01:06:05,000 --> 01:06:07,000
大致可以这么对应起来

1672
01:06:07,000 --> 01:06:09,000
但是当然这个故意的

1673
01:06:09,000 --> 01:06:15,000
故意的层级乃至于抽象的复杂程度都要比 Shell 要高得多得多

1674
01:06:16,000 --> 01:06:16,000
对

1675
01:06:17,000 --> 01:06:19,000
然后这个早期的 Shell 也是面向行的

1676
01:06:19,000 --> 01:06:26,000
因为 Shell 的一个功用就是让你在 Terminal 上可以跟这个远程机交互

1677
01:06:26,000 --> 01:06:27,000
而所有交互都

1678
01:06:29,000 --> 01:06:32,000
因为早期电池上的影响被限制为一行一行

1679
01:06:32,000 --> 01:06:36,000
所以在早期的 Shell 里面大部分时候你是通过一行来输入命令

1680
01:06:37,000 --> 01:06:40,000
UNIX 早期作者之一就是我们上一期提到的

1681
01:06:40,000 --> 01:06:42,000
大名鼎鼎的 Ken Thomerson

1682
01:06:43,000 --> 01:06:44,000
他在写 UNIX 的时候

1683
01:06:45,000 --> 01:06:47,000
也沿用了这个 Shell 这个称呼

1684
01:06:48,000 --> 01:06:49,000
但是 Ken Thomerson 所写的这个名字是

1685
01:06:50,000 --> 01:06:51,000
Multi-Shell

1686
01:06:52,000 --> 01:06:55,000
要比 Multi-Shell 多很多特征比如说一个最早期的最

1687
01:06:56,000 --> 01:06:58,000
最重要的特征之一就是

1688
01:06:58,000 --> 01:06:59,000
所谓的

1689
01:07:01,000 --> 01:07:02,000
输入输出重定向

1690
01:07:02,000 --> 01:07:08,000
我们不管是 DAO 4 用户还是 Linux 用户一定都很熟悉就如果你

1691
01:07:08,000 --> 01:07:11,000
用命令行的话你一定会知道你可以把一个文件的内容

1692
01:07:12,000 --> 01:07:15,000
当作某一个命令的输入传给这个命令

1693
01:07:15,000 --> 01:07:18,000
或者把这个命令的输出转化为一个文件对吧

1694
01:07:19,000 --> 01:07:19,000
然后这个特色

1695
01:07:20,000 --> 01:07:21,000
这个特征是通过大约号小约号的实现

1696
01:07:21,000 --> 01:07:26,000
然后这个这个功能在最开始的时候就是 Ken Thomerson 所写的第 1 代的

1697
01:07:26,000 --> 01:07:28,000
UNIX Shell 的一个功能

1698
01:07:28,000 --> 01:07:29,000
这是 1971 年的事情

1699
01:07:30,000 --> 01:07:33,000
所以你每次在做输入输出重定向的时候

1700
01:07:33,000 --> 01:07:35,000
你就在使用一个 1971 年

1701
01:07:36,000 --> 01:07:37,000
就有的一个功能

1702
01:07:37,000 --> 01:07:38,000
想想还是挺

1703
01:07:38,000 --> 01:07:39,000
特别的

1704
01:07:42,000 --> 01:07:48,000
然后后期 Ken Thomerson 的 Shell 也多了就是 Pipe 这支功能

1705
01:07:48,000 --> 01:07:49,000
我们今天会

1706
01:07:49,000 --> 01:07:49,000
管道服

1707
01:07:50,000 --> 01:07:54,000
会经常说命令行最强大的功能之一就是管道服

1708
01:07:54,000 --> 01:07:58,000
你可以把一个命令的输出

1709
01:07:59,000 --> 01:07:59,000
也是重新

1710
01:07:59,000 --> 01:08:01,000
通过

1711
01:08:01,000 --> 01:08:03,000
管道服重新向到另外一个

1712
01:08:04,000 --> 01:08:04,000
程序的输入

1713
01:08:05,000 --> 01:08:07,000
然后这个特征也是在 Ken Thomerson

1714
01:08:07,000 --> 01:08:09,000
所写的 Shell 里面就已经出现了

1715
01:08:11,000 --> 01:08:14,000
然后 1979 年的时候 UNIX

1716
01:08:15,000 --> 01:08:16,000
Version 7

1717
01:08:16,000 --> 01:08:17,000
简称 V 7

1718
01:08:18,000 --> 01:08:19,000
发布了然后

1719
01:08:19,000 --> 01:08:19,000
在

1720
01:08:20,000 --> 01:08:22,000
随着 V 7 一同搭载的这个 Shell 叫做

1721
01:08:23,000 --> 01:08:23,000
Born Shell

1722
01:08:24,000 --> 01:08:26,000
作者是

1723
01:08:26,000 --> 01:08:27,000
应该是 Algo 原的

1724
01:08:27,000 --> 01:08:28,000
作者之一

1725
01:08:28,000 --> 01:08:30,000
叫做 Stefan Born

1726
01:08:32,000 --> 01:08:35,000
为什么这个 Shell 没有被叫做 B Shell 呢

1727
01:08:36,000 --> 01:08:41,000
他直接就延续了 Ken Thomerson 所写的 Shell 的名字叫做 SH

1728
01:08:43,000 --> 01:08:44,000
然后

1729
01:08:44,000 --> 01:08:46,000
因为他是向后兼容的嘛

1730
01:08:47,000 --> 01:08:48,000
Bash 也是向后兼容的

1731
01:08:49,000 --> 01:08:53,000
但可能在这个时候这个给 Shell 重新名的风气还没有流行起来

1732
01:08:55,000 --> 01:09:02,000
所以直到今天这个 Born Shell 一直也是世界上最为广泛使用的 Shell 之一

1733
01:09:03,000 --> 01:09:04,000
因为

1734
01:09:04,000 --> 01:09:06,000
System V 7 是一个非常成功的 UNIX 版本

1735
01:09:07,000 --> 01:09:10,000
很多后世的 UNIX 变种也都是以 System V 7 为原栏本

1736
01:09:11,000 --> 01:09:13,000
直到今天包括你的

1737
01:09:14,000 --> 01:09:16,000
包括你手上的 Mac

1738
01:09:17,000 --> 01:09:18,000
你面前的 Mac 你手上的

1739
01:09:19,000 --> 01:09:21,000
iPhone 还有你的 Android

1740
01:09:22,000 --> 01:09:22,000
全都有

1741
01:09:22,000 --> 01:09:24,000
slashbin slashsh 这个东西

1742
01:09:24,000 --> 01:09:27,000
这个东西是从 1979 年开始就已经存在于

1743
01:09:27,000 --> 01:09:29,000
很多很多计算机系统里面

1744
01:09:32,000 --> 01:09:33,000
然后

1745
01:09:35,000 --> 01:09:37,000
从 System V 7 开始

1746
01:09:37,000 --> 01:09:39,000
我们有了这个 Posix

1747
01:09:40,000 --> 01:09:41,000
标准

1748
01:09:41,000 --> 01:09:44,000
Posix 标准也定义说

1749
01:09:44,000 --> 01:09:47,000
Shell 必须存在于 slashbin slashsh 下面

1750
01:09:48,000 --> 01:09:49,000
然后所有符合这个标准的标准

1751
01:09:49,000 --> 01:09:51,000
Shell 也会被叫做 SH

1752
01:09:52,000 --> 01:09:52,000
所以也就是说

1753
01:09:53,000 --> 01:09:54,000
当某人说这个

1754
01:09:54,000 --> 01:09:56,000
这个 Shell 是 SH compatible 的时候

1755
01:09:56,000 --> 01:09:59,000
他所指的意思实际上就是

1756
01:09:59,000 --> 01:10:02,000
跟我们刚才提到的 Central Shell 是

1757
01:10:02,000 --> 01:10:03,000
互相建筑

1758
01:10:03,000 --> 01:10:06,000
但如果你一定要非常精确的说一个 Shell 是

1759
01:10:07,000 --> 01:10:10,000
符合 Posix 的所有标准的话

1760
01:10:10,000 --> 01:10:12,000
你应该说它是 Posix Shell

1761
01:10:15,000 --> 01:10:17,000
然后在 1978 年的时候

1762
01:10:18,000 --> 01:10:18,000
然后在 1978 年的时候

1763
01:10:18,000 --> 01:10:21,000
又开始另外一个 Shell 的研发工作

1764
01:10:22,000 --> 01:10:25,000
这个作者是另外一位

1765
01:10:26,000 --> 01:10:28,000
我们之前也提到过的 Billy Joy

1766
01:10:28,000 --> 01:10:30,000
然后他 Billy Joy 写过什么呢

1767
01:10:30,000 --> 01:10:32,000
快速问他 Billy Joy 写过什么

1768
01:10:34,000 --> 01:10:36,000
其实是 VI

1769
01:10:36,000 --> 01:10:37,000
不是 VII 嘛

1770
01:10:37,000 --> 01:10:38,000
是 VI

1771
01:10:38,000 --> 01:10:39,000
最早期的那个

1772
01:10:39,000 --> 01:10:40,000
V

1773
01:10:42,000 --> 01:10:44,000
编辑器

1774
01:10:44,000 --> 01:10:47,000
他还写了一个 Shell 叫做 Cshell

1775
01:10:47,000 --> 01:10:48,000
然后 Cshell 的一个麦克风

1776
01:10:49,000 --> 01:10:49,000
就是

1777
01:10:50,000 --> 01:10:52,000
Shell 这个东西就是

1778
01:10:52,000 --> 01:10:53,000
我们

1779
01:10:53,000 --> 01:10:55,000
如果你不用 Cshell 的话

1780
01:10:55,000 --> 01:10:58,000
你会感觉到 Shell 的这个语法跟 C 离得很远

1781
01:10:59,000 --> 01:11:00,000
但是在 Cshell

1782
01:11:00,000 --> 01:11:03,000
诞生的那个年代 UNIX 基本上全都是用 C 来写的

1783
01:11:04,000 --> 01:11:05,000
UNIX 不管是

1784
01:11:05,000 --> 01:11:06,000
用户程序还是

1785
01:11:06,000 --> 01:11:08,000
UNIX 本身都是用 C 来写的

1786
01:11:08,000 --> 01:11:12,000
所以 Cshell 的一个设计理念就是希望能够让

1787
01:11:13,000 --> 01:11:16,000
Shell 的语法尽量接近于 C 的语法

1788
01:11:17,000 --> 01:11:18,000
但是我们在今天来看可能

1789
01:11:19,000 --> 01:11:21,000
Cshell 的语法并不那么接近 C

1790
01:11:22,000 --> 01:11:23,000
但是在

1791
01:11:23,000 --> 01:11:27,000
80 年代你会觉得我靠这个东西真的是跟写 C 语言太接近

1792
01:11:28,000 --> 01:11:29,000
但是我

1793
01:11:29,000 --> 01:11:32,000
which was a good thing

1794
01:11:32,000 --> 01:11:36,000
但是今天我会觉得说我靠为什么一个语言一个 shell script

1795
01:11:36,000 --> 01:11:39,000
需要写的跟 C 一样这不是自寻反导

1796
01:11:39,000 --> 01:11:41,000
但在那个时代如果你的电脑上

1797
01:11:42,000 --> 01:11:45,000
只有 C 你也只会你也只学过 C 的话你会觉得

1798
01:11:45,000 --> 01:11:48,000
可以用像写 C 语言的一样来写 shell script

1799
01:11:48,000 --> 01:11:49,000
这种状态的事情

1800
01:11:50,000 --> 01:11:54,000
然后 Cshell 的有很多非常多的创新啊比如说

1801
01:11:54,000 --> 01:11:55,000
history

1802
01:11:56,000 --> 01:11:57,000
就是你现在在

1803
01:11:58,000 --> 01:12:01,000
命令号下面打 history 你会看到自己输入过的所有命令

1804
01:12:02,000 --> 01:12:03,000
以及你比如说你打

1805
01:12:09,000 --> 01:12:10,000
感叹号感叹号你会

1806
01:12:10,000 --> 01:12:11,000
重复前一条命令

1807
01:12:12,000 --> 01:12:16,000
乃至于你打比如说门刀了下滑线会

1808
01:12:16,000 --> 01:12:18,000
刚才上一条命令的那个

1809
01:12:18,000 --> 01:12:20,000
最后一个参数

1810
01:12:20,000 --> 01:12:21,000
argument

1811
01:12:21,000 --> 01:12:22,000
重新用完

1812
01:12:23,000 --> 01:12:25,000
这一切都是源自于 Cshell

1813
01:12:25,000 --> 01:12:28,000
是 Cshell 创造这个 history 这个东西

1814
01:12:28,000 --> 01:12:31,000
然后也是从 Cshell 开始人们有 job control

1815
01:12:31,000 --> 01:12:32,000
就是你在

1816
01:12:33,000 --> 01:12:36,000
DOS 下面可能没有遇到过这种东西就是

1817
01:12:37,000 --> 01:12:38,000
DOS 早期

1818
01:12:38,000 --> 01:12:39,000
不是多任务的吧

1819
01:12:40,000 --> 01:12:41,000
你不可能在 DOS 上面

1820
01:12:41,000 --> 01:12:43,000
整个那个可以把它 suspend

1821
01:12:44,000 --> 01:12:46,000
但是在 unix 下面

1822
01:12:46,000 --> 01:12:48,000
从很早很早的时候就可以开始

1823
01:12:48,000 --> 01:12:48,000
比如说你扔在

1824
01:12:49,000 --> 01:12:53,000
解压缩一个什么东西然后它需要一段时间

1825
01:12:53,000 --> 01:12:56,000
你 ctrl 加 Z 让它进入后台然后用 bg

1826
01:12:56,000 --> 01:12:59,000
让它在后台继续执行然后在前台做一些别的什么东西

1827
01:13:00,000 --> 01:13:01,000
然后你同时

1828
01:13:01,000 --> 01:13:03,000
进行很多这样的工作比如说我现在不用

1829
01:13:04,000 --> 01:13:07,000
vim 那个习惯就是写到一半然后

1830
01:13:07,000 --> 01:13:10,000
Ctrl 加 Z 然后去干点别的然后在 fg 把那个

1831
01:13:11,000 --> 01:13:12,000
vim 弄回来对吧然后这个

1832
01:13:13,000 --> 01:13:16,000
这个这个功能也是在 Cshell 里面被

1833
01:13:16,000 --> 01:13:17,000
VillageRoute 实现的

1834
01:13:18,000 --> 01:13:18,000
我就是有点好奇

1835
01:13:19,000 --> 01:13:19,000
刚才那个场景

1836
01:13:20,000 --> 01:13:24,000
我一般是说在开一个这个窗口

1837
01:13:24,000 --> 01:13:25,000
或者 tab 来实现

1838
01:13:26,000 --> 01:13:27,000
就是用那个

1839
01:13:28,000 --> 01:13:30,000
放入后台这个我还真的挺少用

1840
01:13:30,000 --> 01:13:31,000
我还蛮常用的

1841
01:13:31,000 --> 01:13:32,000
但如果说你的

1842
01:13:32,000 --> 01:13:34,000
你这个系统是一个单

1843
01:13:35,000 --> 01:13:37,000
如果你是一个远程系统的话比如说

1844
01:13:37,000 --> 01:13:38,000
然后你只能

1845
01:13:39,000 --> 01:13:43,000
你再开一个窗口也可以但你再开个 ssh 连接可能会要等一下

1846
01:13:43,000 --> 01:13:45,000
对这个问题的解法其实就是三种

1847
01:13:45,000 --> 01:13:46,000
一多任务

1848
01:13:47,000 --> 01:13:47,000
二 Tmux

1849
01:13:48,000 --> 01:13:48,000
就是所谓的

1850
01:13:48,000 --> 01:13:50,000
Terminal Multiplexing

1851
01:13:50,000 --> 01:13:51,000
就是

1852
01:13:51,000 --> 01:13:52,000
终端复用

1853
01:13:52,000 --> 01:13:55,000
可以在一个终端里面开很多小终端的窗口

1854
01:13:55,000 --> 01:13:55,000
这是一个

1855
01:13:56,000 --> 01:13:57,000
比较重要的奇迹引脚

1856
01:13:58,000 --> 01:13:58,000
一定要学起来

1857
01:13:59,000 --> 01:14:02,000
然后再第 3 个方式就是你再建立一个连接好

1858
01:14:03,000 --> 01:14:03,000
然后

1859
01:14:03,000 --> 01:14:05,000
个人是比较清晰的

1860
01:14:05,000 --> 01:14:06,000
第一种因为

1861
01:14:06,000 --> 01:14:08,000
一个时间只做一件事情嘛

1862
01:14:09,000 --> 01:14:10,000
会比较好一些

1863
01:14:11,000 --> 01:14:13,000
OK 这个看我养成这个习惯会比较

1864
01:14:14,000 --> 01:14:15,000
比较顺畅一些

1865
01:14:15,000 --> 01:14:18,000
而且其实就是早期有很多

1866
01:14:18,000 --> 01:14:20,000
我也曾经试图把 VM 配置成一个 IE

1867
01:14:21,000 --> 01:14:25,000
在 VM 里面就直接执行程序啊或者是什么

1868
01:14:26,000 --> 01:14:26,000
其实这是徒劳

1869
01:14:27,000 --> 01:14:32,000
那你为什么不直接干脆把 VM 挂起来然后在命令行下面做你该做的事情

1870
01:14:32,000 --> 01:14:33,000
然后该回去的时候就回去

1871
01:14:36,000 --> 01:14:37,000
折远了又折远了

1872
01:14:37,000 --> 01:14:40,000
然后回到我们的历史课这次的历史真的要讲好久

1873
01:14:42,000 --> 01:14:43,000
刚才说的 C Shell

1874
01:14:43,000 --> 01:14:45,000
C Shell 还有一些别的一些

1875
01:14:45,000 --> 01:14:48,000
新的创新比如说 Tools Notation

1876
01:14:48,000 --> 01:14:48,000
就是

1877
01:14:49,000 --> 01:14:50,000
你在

1878
01:14:50,000 --> 01:14:51,000
你的 home

1879
01:14:52,000 --> 01:14:53,000
进入加目录

1880
01:14:54,000 --> 01:14:56,000
比如说你的目录是

1881
01:14:56,000 --> 01:14:57,000
slash home slash

1882
01:14:57,000 --> 01:14:58,000
TAW

1883
01:14:58,000 --> 01:14:58,000
然后我可以用

1884
01:14:59,000 --> 01:15:01,000
一个不让号来代替这个目录

1885
01:15:01,000 --> 01:15:04,000
Juice 类的还有什么 Jodding

1886
01:15:04,000 --> 01:15:08,000
就是比如说你要在同一行上面运行两个程序

1887
01:15:08,000 --> 01:15:10,000
你可以用一个分号把他们分开

1888
01:15:10,000 --> 01:15:10,000
运行

1889
01:15:11,000 --> 01:15:12,000
第一个再运行第二个

1890
01:15:12,000 --> 01:15:13,000
或者你可以用两个

1891
01:15:13,000 --> 01:15:14,000
Empercent 把他们连起来

1892
01:15:14,000 --> 01:15:15,000
就是说如果第一个

1893
01:15:16,000 --> 01:15:17,000
成功了才运行第二

1894
01:15:18,000 --> 01:15:19,000
或者你可以用两个

1895
01:15:20,000 --> 01:15:21,000
用一个 pipe

1896
01:15:21,000 --> 01:15:22,000
比如说

1897
01:15:22,000 --> 01:15:25,000
只有第一个失败了才会运行第二之类的

1898
01:15:25,000 --> 01:15:26,000
这些

1899
01:15:26,000 --> 01:15:27,000
代表 or

1900
01:15:27,000 --> 01:15:28,000
这些都是

1901
01:15:29,000 --> 01:15:31,000
在 C Shell 里面发明

1902
01:15:31,000 --> 01:15:32,000
这个跟

1903
01:15:32,000 --> 01:15:33,000
C 很像嘛对吧

1904
01:15:33,000 --> 01:15:35,000
Empercent Emerson 和 pipe pipe

1905
01:15:35,000 --> 01:15:36,000
都是来源于 C

1906
01:15:38,000 --> 01:15:40,000
然后到 1980 年的时候呢我们有了 K Shell

1907
01:15:41,000 --> 01:15:42,000
Corn Shell

1908
01:15:42,000 --> 01:15:43,000
是在

1909
01:15:45,000 --> 01:15:46,000
这个时候应该是

1910
01:15:46,000 --> 01:15:47,000
贝尔实验室在

1911
01:15:48,000 --> 01:15:49,000
专门为 UNIX 发现

1912
01:15:49,000 --> 01:15:51,000
然后这个时候恰逢

1913
01:15:52,000 --> 01:15:55,000
所谓的 UNIX Great War

1914
01:15:55,000 --> 01:15:59,000
是在 UNIX 的史上历史上曾出现过一系列的因为

1915
01:16:00,000 --> 01:16:01,000
版权法和这个

1916
01:16:01,000 --> 01:16:03,000
商业化

1917
01:16:03,000 --> 01:16:05,000
引发了一系列诉讼和

1918
01:16:06,000 --> 01:16:07,000
口水仗

1919
01:16:08,000 --> 01:16:14,000
因此也是因此这个一片形式一片大好的 UNIX 分裂了给了这些什么

1920
01:16:14,000 --> 01:16:18,000
微软这种公司的可乘之机

1921
01:16:18,000 --> 01:16:21,000
在这个时代出现了 K Shell

1922
01:16:22,000 --> 01:16:24,000
就是 Corn Shell

1923
01:16:24,000 --> 01:16:26,000
作者叫什么 Corn

1924
01:16:27,000 --> 01:16:27,000
他是

1925
01:16:28,000 --> 01:16:29,000
David Korn

1926
01:16:29,000 --> 01:16:30,000
Corn 来命名的

1927
01:16:31,000 --> 01:16:36,000
然后 Corn 也有一些新的也有一些创新但是没有 C Shell 那么多

1928
01:16:39,000 --> 01:16:42,000
而且 K Shell 从来没有流行起来只有这个

1929
01:16:42,000 --> 01:16:45,000
UNIX 的一些官方版本还在用

1930
01:16:45,000 --> 01:16:47,000
就是那个时候 BSD 就专门

1931
01:16:47,000 --> 01:16:50,000
避免使用它因为这个 K Shell 的源码当时是

1932
01:16:51,000 --> 01:16:52,000
没有自然发放的

1933
01:16:53,000 --> 01:16:56,000
然后当 Linux 兴起的时候 K Shell 更是没有人理

1934
01:16:56,000 --> 01:16:59,000
他们直接就用了这个 GNU 的 Bash

1935
01:17:00,000 --> 01:17:06,000
对然后当这个 Linux 兴起的时候自由软件基金会专门把

1936
01:17:06,000 --> 01:17:07,000
SH 重新

1937
01:17:07,000 --> 01:17:09,000
开发了一遍可以理解

1938
01:17:09,000 --> 01:17:11,000
然后把它命名为 Born Again Shell

1939
01:17:12,000 --> 01:17:14,000
就专门的凑 Bash 这个词

1940
01:17:15,000 --> 01:17:17,000
Bashden 英语里面是

1941
01:17:18,000 --> 01:17:20,000
撕打

1942
01:17:20,000 --> 01:17:21,000
还是

1943
01:17:21,000 --> 01:17:22,000
之类的一个词

1944
01:17:23,000 --> 01:17:23,000
我是

1945
01:17:24,000 --> 01:17:24,000
也是在

1946
01:17:25,000 --> 01:17:29,000
接受 Bash 很久之后才意识到它居然是一个英语名词而不是一个

1947
01:17:29,000 --> 01:17:32,000
就是一个命令之类的

1948
01:17:33,000 --> 01:17:36,000
我们来看一下他的这个官方诗意是什么

1949
01:17:37,000 --> 01:17:38,000
Bash

1950
01:17:38,000 --> 01:17:41,000
Strike hard and violently

1951
01:17:41,000 --> 01:17:42,000
凶狠的撕打

1952
01:17:43,000 --> 01:17:44,000
凶狠的击打

1953
01:17:45,000 --> 01:17:47,000
有两个字叫暴揍

1954
01:17:47,000 --> 01:17:48,000
OK

1955
01:17:48,000 --> 01:17:52,000
各位使用这个暴揍

1956
01:17:53,000 --> 01:17:53,000
暴揍

1957
01:17:54,000 --> 01:17:56,000
暴揍外科

1958
01:17:57,000 --> 01:17:58,000
暴揍外科是我们

1959
01:17:58,000 --> 01:17:59,000
目前

1960
01:17:59,000 --> 01:18:02,000
计算机世界里面最常见的一个外科

1961
01:18:02,000 --> 01:18:04,000
就是如果你是用

1962
01:18:05,000 --> 01:18:06,000
OS X 的话或者是你

1963
01:18:06,000 --> 01:18:09,000
使用一个 Linux 的话很有可能是在用 Bash

1964
01:18:10,000 --> 01:18:11,000
当然不一定啊

1965
01:18:11,000 --> 01:18:13,000
因为 Ubuntu 在前一阵子吧

1966
01:18:14,000 --> 01:18:16,000
他的默认是要改成了 Dash

1967
01:18:17,000 --> 01:18:19,000
又改回来了吧

1968
01:18:19,000 --> 01:18:20,000
没有是这样的

1969
01:18:20,000 --> 01:18:20,000
不是我帮你

1970
01:18:21,000 --> 01:18:21,000
是 Debian

1971
01:18:21,000 --> 01:18:25,000
Debian 把这个脚本执行的 shell 转化成了 Dash

1972
01:18:26,000 --> 01:18:26,000
但是用户

1973
01:18:27,000 --> 01:18:30,000
就是那个 slashbin slash shell 的实际是 Dash 提供的

1974
01:18:30,000 --> 01:18:31,000
然后对

1975
01:18:31,000 --> 01:18:31,000
但是

1976
01:18:32,000 --> 01:18:34,000
用户所使用这个 login shell 还是 Bash

1977
01:18:35,000 --> 01:18:35,000
应该是这样

1978
01:18:35,000 --> 01:18:36,000
对

1979
01:18:37,000 --> 01:18:40,000
Bash 集中了这个

1980
01:18:40,000 --> 01:18:42,000
原有的

1981
01:18:42,000 --> 01:18:43,000
Bshell

1982
01:18:43,000 --> 01:18:45,000
然后 Cshell 和 Kshell 的优点

1983
01:18:45,000 --> 01:18:47,000
这就是为什么我们刚才提到的

1984
01:18:47,000 --> 01:18:48,000
各家之所长

1985
01:18:48,000 --> 01:18:52,000
这就是为什么我们刚才提到的大部分功能你会说我的 shell 里面也有啊

1986
01:18:52,000 --> 01:18:55,000
就是你不需要使用 Cshell 才有 Drop Control 为什么

1987
01:18:55,000 --> 01:18:57,000
就是因为 Bash 把 Drop Control 也

1988
01:18:58,000 --> 01:19:00,000
也移植过来了

1989
01:19:02,000 --> 01:19:05,000
但是大部分这些 shell 在如果一个脚本

1990
01:19:06,000 --> 01:19:09,000
你写一个 shell 脚本然后在前面写说

1991
01:19:10,000 --> 01:19:12,000
Hashbond slashbin slash

1992
01:19:12,000 --> 01:19:13,000
Async 的话

1993
01:19:14,000 --> 01:19:16,000
他们还是会默认去伪装

1994
01:19:16,000 --> 01:19:18,000
把自己伪装成一个 shell

1995
01:19:19,000 --> 01:19:21,000
然后只提供 shell 能够提供的情况

1996
01:19:22,000 --> 01:19:26,000
基本功能就不提供一些比如说 Bash 的一些特定的语法这样

1997
01:19:26,000 --> 01:19:27,000
对

1998
01:19:27,000 --> 01:19:32,000
然后在这个 System 5 release 4 也是

1999
01:19:32,000 --> 01:19:35,000
Ulix 的历史上一个非常重要的

2000
01:19:35,000 --> 01:19:38,000
版本里面有出现一个叫做

2001
01:19:38,000 --> 01:19:39,000
Armquist shell

2002
01:19:39,000 --> 01:19:40,000
然后它的

2003
01:19:41,000 --> 01:19:42,000
缩写就是 Ash

2004
01:19:43,000 --> 01:19:46,000
它的设计理念是说要把 shell 做的尽量精巧

2005
01:19:46,000 --> 01:19:47,000
简单

2006
01:19:48,000 --> 01:19:51,000
后来这个 Armquist

2007
01:19:52,000 --> 01:19:54,000
Armquist shell 也被

2008
01:19:54,000 --> 01:19:55,000
进一步

2009
01:19:57,000 --> 01:19:57,000
改进

2010
01:19:57,000 --> 01:19:58,000
就形成了 Dash

2011
01:19:59,000 --> 01:20:00,000
我们刚才提到的 Dash 这个东西

2012
01:20:00,000 --> 01:20:01,000
就是它是一个比较

2013
01:20:01,000 --> 01:20:03,000
经典版的 shell 专门拿来

2014
01:20:05,000 --> 01:20:06,000
运行脚本程序吧

2015
01:20:07,000 --> 01:20:09,000
那个 Dash 那个 D 是 debian 吗

2016
01:20:09,000 --> 01:20:11,000
Debian Ash 应该是这么来的

2017
01:20:13,000 --> 01:20:14,000
我记得应该是这样的

2018
01:20:14,000 --> 01:20:15,000
就是前面有那个

2019
01:20:16,000 --> 01:20:16,000
Ash 嘛

2020
01:20:17,000 --> 01:20:18,000
然后是 Dash

2021
01:20:19,000 --> 01:20:20,000
Debian

2022
01:20:20,000 --> 01:20:22,000
Debian Armquist

2023
01:20:23,000 --> 01:20:25,000
它也是为了凑这个

2024
01:20:25,000 --> 01:20:26,000
也是为了凑 Dash 这个

2025
01:20:27,000 --> 01:20:28,000
Dash 是一个

2026
01:20:28,000 --> 01:20:29,000
就是什么呢

2027
01:20:29,000 --> 01:20:31,000
快速前冲

2028
01:20:33,000 --> 01:20:34,000
小跑外壳

2029
01:20:34,000 --> 01:20:35,000
刚才我们介绍了猛击外壳

2030
01:20:35,000 --> 01:20:36,000
然后有小跑外壳

2031
01:20:37,000 --> 01:20:39,000
暴走外壳

2032
01:20:40,000 --> 01:20:40,000
小跑

2033
01:20:42,000 --> 01:20:43,000
小跑外壳

2034
01:20:43,000 --> 01:20:44,000
,ok

2035
01:20:45,000 --> 01:20:49,000
就其实还有一些比较不常见比较诡异的 shell

2036
01:20:50,000 --> 01:20:50,000
提一下可能

2037
01:20:51,000 --> 01:20:53,000
比如说 Psh Pearl Shell

2038
01:20:53,000 --> 01:20:54,000
就是

2039
01:20:54,000 --> 01:20:57,000
你可以在 shell 里面使用 Pearl 这种

2040
01:20:57,000 --> 01:20:58,000
奇怪的语言

2041
01:20:59,000 --> 01:21:02,000
来完成一些普通 sh 做不到的事

2042
01:21:03,000 --> 01:21:03,000
或者是

2043
01:21:04,000 --> 01:21:05,000
Yash

2044
01:21:06,000 --> 01:21:07,000
Yash 跟 Yano

2045
01:21:08,000 --> 01:21:09,000
Yet another shell

2046
01:21:09,000 --> 01:21:11,000
It's a POSIX Component command line shell

2047
01:21:12,000 --> 01:21:13,000
written by

2048
01:21:13,000 --> 01:21:15,000
Watanabe Yuki

2049
01:21:15,000 --> 01:21:15,000
一个日本人

2050
01:21:16,000 --> 01:21:17,000
他的

2051
01:21:17,000 --> 01:21:18,000
实现的初衷是

2052
01:21:18,000 --> 01:21:21,000
教大家用 C 语言来写一个 shell

2053
01:21:22,000 --> 01:21:23,000
本来是一个教学项目

2054
01:21:23,000 --> 01:21:24,000
后来又被

2055
01:21:25,000 --> 01:21:26,000
后来又重新改写了

2056
01:21:27,000 --> 01:21:28,000
目的是要成为

2057
01:21:29,000 --> 01:21:30,000
最 possix 兼容那个 shell

2058
01:21:30,000 --> 01:21:32,000
世界上最 possix compliant

2059
01:21:33,000 --> 01:21:34,000
compliant shell

2060
01:21:34,000 --> 01:21:35,000
in the world

2061
01:21:36,000 --> 01:21:38,000
都不知道这到底是好事还是坏事

2062
01:21:38,000 --> 01:21:38,000
What's the point

2063
01:21:39,000 --> 01:21:41,000
所以这就是为什么没有人用 Yash 的原因

2064
01:21:43,000 --> 01:21:46,000
刚才提到一个重要概念就是

2065
01:21:46,000 --> 01:21:48,000
sh compatible

2066
01:21:50,000 --> 01:21:52,000
你会说兼容 shell

2067
01:21:52,000 --> 01:21:54,000
你会说就是这个 shell 是特指不是

2068
01:21:54,000 --> 01:21:57,000
不是不是一泛指的一个 shell 是特指最开始那个

2069
01:21:58,000 --> 01:21:59,000
那个最早版本那个 shell

2070
01:22:00,000 --> 01:22:02,000
就兼容那个是什么意思

2071
01:22:03,000 --> 01:22:04,000
这也是我们推荐

2072
01:22:04,000 --> 01:22:08,000
在这里我们要推荐这个 stack exchange 的 unix 的

2073
01:22:08,000 --> 01:22:09,000
板块上面的一个答案

2074
01:22:10,000 --> 01:22:10,000
写得非常好

2075
01:22:11,000 --> 01:22:13,000
然后这个答案里面还顺带的介绍了在

2076
01:22:13,000 --> 01:22:16,000
在不同系统里面这个 bin sh 所指向的东西是什么

2077
01:22:17,000 --> 01:22:18,000
比如他说在

2078
01:22:18,000 --> 01:22:20,000
Solaris 10 里面

2079
01:22:20,000 --> 01:22:25,000
可能这个 bin sh 就是默认的 original born shell

2080
01:22:26,000 --> 01:22:28,000
然后你可能在这个

2081
01:22:29,000 --> 01:22:34,000
Linux 里面可能会是 ginobash

2082
01:22:34,000 --> 01:22:36,000
然后你在 openbs 里面可能会

2083
01:22:36,000 --> 01:22:39,000
所使用的是一个 ksh 93

2084
01:22:39,000 --> 01:22:41,000
with possix extensions

2085
01:22:42,000 --> 01:22:43,000
whatever it means

2086
01:22:43,000 --> 01:22:46,000
答案也是推荐大家读一读

2087
01:22:49,000 --> 01:22:53,000
好了大概历史就讲到这然后

2088
01:22:53,000 --> 01:22:55,000
你讲现状了吗

2089
01:22:55,000 --> 01:23:00,000
时光机且快进到 2010 年

2090
01:23:00,000 --> 01:23:03,000
或者说 21 世纪的

2091
01:23:03,000 --> 01:23:04,000
第一个 10 年已经过去了

2092
01:23:05,000 --> 01:23:06,000
我们还是在使用 shell

2093
01:23:06,000 --> 01:23:07,000
只不过今天

2094
01:23:09,000 --> 01:23:12,000
我不知道 real 你但是我所使用 shell

2095
01:23:12,000 --> 01:23:13,000
是什么叫做 zshell

2096
01:23:16,000 --> 01:23:16,000
我也是

2097
01:23:17,000 --> 01:23:22,000
我这里可能要说一下刚才提了各种各样的乱七八糟的 shell 有好几种

2098
01:23:22,000 --> 01:23:24,000
但其实经过这么多年

2099
01:23:24,000 --> 01:23:26,000
这个系统大浪淘沙

2100
01:23:27,000 --> 01:23:30,000
现在剩下来的也就那么几个了一个是

2101
01:23:31,000 --> 01:23:33,000
绝大多数的 Linux 发行版

2102
01:23:34,000 --> 01:23:37,000
和这个像 Western 也是默认使用的这个 bash

2103
01:23:38,000 --> 01:23:42,000
然后有一小撮这个 shell 死忠粉在建设的一个

2104
01:23:42,000 --> 01:23:43,000
ZS

2105
01:23:44,000 --> 01:23:46,000
这怎么念 Zish

2106
01:23:47,000 --> 01:23:52,000
还有就是在一些精简系统上或者是嵌入式系统上

2107
01:23:53,000 --> 01:23:56,000
像一个 bizitbox 里面自带的那个

2108
01:23:56,000 --> 01:23:58,000
那个应该是 ash

2109
01:23:58,000 --> 01:24:00,000
就是在比较简

2110
01:24:00,000 --> 01:24:04,000
普通的或者说功能比较低下的这个不需要经常交互的操作性

2111
01:24:05,000 --> 01:24:07,000
基本上就提供一个 ash 就够了

2112
01:24:07,000 --> 01:24:08,000
复杂度比较

2113
01:24:09,000 --> 01:24:10,000
那个的复杂度也比较低嘛

2114
01:24:11,000 --> 01:24:12,000
适合在那种资源比较有限的系统里面

2115
01:24:12,000 --> 01:24:13,000
系统上实现

2116
01:24:14,000 --> 01:24:18,000
先说这个 Western 吧因为我们这个常用的主机都是这个哈

2117
01:24:18,000 --> 01:24:22,000
Western 现在版本里面起码是自带两个 shell 的

2118
01:24:22,000 --> 01:24:25,000
一个是 bash 一个是这个 Zish

2119
01:24:26,000 --> 01:24:28,000
有一个什么问题呢因为 bash 从

2120
01:24:29,000 --> 01:24:30,000
4.0 开始

2121
01:24:30,000 --> 01:24:31,000
对

2122
01:24:31,000 --> 01:24:32,000
Western 自带的版本

2123
01:24:33,000 --> 01:24:39,000
bash 的版本特别老原因是因为 bash 4.0 开始他们切换到 gpl v 3 吧应该是

2124
01:24:39,000 --> 01:24:41,000
的这个这个授权协议

2125
01:24:42,000 --> 01:24:42,000
然后这个

2126
01:24:42,000 --> 01:24:45,000
跟 Western 这个商业

2127
01:24:45,000 --> 01:24:47,000
不开源产品是有冲突的所以他们

2128
01:24:47,000 --> 01:24:50,000
就是 Western 搭载的这个 bash

2129
01:24:50,000 --> 01:24:52,000
可能永远只能停留在 3.0

2130
01:24:52,000 --> 01:24:57,000
就是大版本号是 3 的这个版本系列没有办法再

2131
01:24:57,000 --> 01:25:00,000
进步到这个 4 了但是

2132
01:25:01,000 --> 01:25:04,000
Western 还自带了一个 Zish 嘛 Zish 应该是 BSD 协议吧

2133
01:25:05,000 --> 01:25:07,000
Zish BSD 协议

2134
01:25:07,000 --> 01:25:08,000
确认一下

2135
01:25:08,000 --> 01:25:11,000
确认一下我记得是 BSD 协议

2136
01:25:12,000 --> 01:25:17,000
对 Zish 是 MIT 协议的

2137
01:25:18,000 --> 01:25:20,000
类 MIT 协议的

2138
01:25:20,000 --> 01:25:22,000
就是他更这个灵灵活一些嘛

2139
01:25:23,000 --> 01:25:25,000
所以就 Western 还是可以

2140
01:25:26,000 --> 01:25:26,000
就是

2141
01:25:26,000 --> 01:25:28,000
继续搭载他最新版本

2142
01:25:28,000 --> 01:25:30,000
就基本上 Western 搭载的最新版本都

2143
01:25:31,000 --> 01:25:31,000
离

2144
01:25:32,000 --> 01:25:33,000
搭载的版本离最新版本基本上就只

2145
01:25:34,000 --> 01:25:36,000
差一两个小版本好

2146
01:25:36,000 --> 01:25:40,000
而且 Zish 也更新不是那么轻吧所以还好

2147
01:25:41,000 --> 01:25:42,000
对最新一版的 Zish 是 5.0

2148
01:25:42,000 --> 01:25:45,000
2015 年 8 月 30

2149
01:25:46,000 --> 01:25:46,000
两个月前了

2150
01:25:47,000 --> 01:25:48,000
所以就还好

2151
01:25:48,000 --> 01:25:50,000
然后如果你还是坚持要用 Bash 的话呢

2152
01:25:51,000 --> 01:25:51,000
基本上

2153
01:25:51,000 --> 01:25:53,000
非常推荐你的一点是

2154
01:25:53,000 --> 01:25:54,000
可以 homebrew 再装

2155
01:25:54,000 --> 01:25:57,000
赶紧用 homebrew 装一个新版的 Bash

2156
01:25:57,000 --> 01:26:01,000
如果你是一个初学者的话然后你可能暂时说我要保守一点先从

2157
01:26:02,000 --> 01:26:03,000
一个

2158
01:26:03,000 --> 01:26:05,000
源流比较古早的东西

2159
01:26:05,000 --> 01:26:06,000
入手的话呢

2160
01:26:07,000 --> 01:26:10,000
因为我相信大部分的 Linux 的这个教程上面也会用

2161
01:26:11,000 --> 01:26:12,000
Bash 作为主要的教学功能

2162
01:26:12,000 --> 01:26:14,000
那你可以

2163
01:26:14,000 --> 01:26:16,000
对因为默认是那个嘛

2164
01:26:16,000 --> 01:26:18,000
所以最好是先升级

2165
01:26:18,000 --> 01:26:20,000
Zish 的来历是怎么样子

2166
01:26:21,000 --> 01:26:24,000
Zish 是 1990 年的时候

2167
01:26:24,000 --> 01:26:27,000
一个叫做 Paul

2168
01:26:27,000 --> 01:26:28,000
Fostard

2169
01:26:31,000 --> 01:26:32,000
Fostard 是那个

2170
01:26:32,000 --> 01:26:34,000
你为什么要笑

2171
01:26:34,000 --> 01:26:37,000
Hero of the Storm 里面那个骑士旧的哥们

2172
01:26:38,000 --> 01:26:41,000
他是在魔术世界里面应该是在

2173
01:26:41,000 --> 01:26:42,000
Hinterland

2174
01:26:42,000 --> 01:26:44,000
的那个

2175
01:26:44,000 --> 01:26:47,000
施救城堡里面的主管

2176
01:26:47,000 --> 01:26:48,000
叫做 Fostard

2177
01:26:49,000 --> 01:26:49,000
Paul Fostard

2178
01:26:50,000 --> 01:26:50,000
写的

2179
01:26:51,000 --> 01:26:55,000
脑中浮现出了一个矮人骑在施救上打在脑子上

2180
01:26:55,000 --> 01:26:59,000
然后他在 1990 年的时候读普林斯顿

2181
01:26:59,000 --> 01:27:00,000
他是一个

2182
01:27:00,000 --> 01:27:01,000
学生

2183
01:27:01,000 --> 01:27:02,000
他是一个学生

2184
01:27:02,000 --> 01:27:04,000
他的导师叫做

2185
01:27:04,000 --> 01:27:04,000
邵忠

2186
01:27:06,000 --> 01:27:08,000
一个华人

2187
01:27:09,000 --> 01:27:10,000
然后邵忠的

2188
01:27:11,000 --> 01:27:12,000
登录名

2189
01:27:12,000 --> 01:27:13,000
叫做 Zish

2190
01:27:14,000 --> 01:27:15,000
是中少嘛对吧

2191
01:27:16,000 --> 01:27:18,000
先名后姓

2192
01:27:18,000 --> 01:27:18,000
然后

2193
01:27:19,000 --> 01:27:20,000
他觉得这个名字很屌

2194
01:27:20,000 --> 01:27:24,000
就用 Zish 来当作自己写这个 shell 的名字

2195
01:27:25,000 --> 01:27:27,000
Zish 来当作自己写这个 shell 的名字

2196
01:27:27,000 --> 01:27:30,000
然后但是 Zish 和 Cshell 也是押韵的

2197
01:27:33,000 --> 01:27:34,000
是这么来的

2198
01:27:34,000 --> 01:27:35,000
然后他

2199
01:27:35,000 --> 01:27:41,000
出于某种原因把他做得非常的复杂又强大我觉得肯定是

2200
01:27:41,000 --> 01:27:43,000
就觉得已经到了 90 年代对吧

2201
01:27:43,000 --> 01:27:44,000
我们应该给这个

2202
01:27:44,000 --> 01:27:45,000
古老的

2203
01:27:45,000 --> 01:27:47,000
与时俱进

2204
01:27:47,000 --> 01:27:50,000
所以做了非常非常多的优化比如说

2205
01:27:50,000 --> 01:27:52,000
他提供了

2206
01:27:53,000 --> 01:27:55,000
extensive 的这个

2207
01:27:56,000 --> 01:27:58,000
输入提示

2208
01:27:58,000 --> 01:27:59,000
就是你在

2209
01:27:59,000 --> 01:28:03,000
输入一个命令的话你在 bash 下面按 tab 你可能只会得到

2210
01:28:06,000 --> 01:28:06,000
tab 呢

2211
01:28:08,000 --> 01:28:11,000
在 bash 下面输入一个命令的一半按 tab

2212
01:28:11,000 --> 01:28:12,000
他会补全到

2213
01:28:13,000 --> 01:28:14,000
什么地方为止

2214
01:28:14,000 --> 01:28:15,000
补全到他能够

2215
01:28:17,000 --> 01:28:20,000
第一个字符吧就是有奇异的第一个字符

2216
01:28:20,000 --> 01:28:22,000
会补全到第一个奇异位置

2217
01:28:22,000 --> 01:28:23,000
然后

2218
01:28:23,000 --> 01:28:26,000
Zshell 则会列出所有可能命令

2219
01:28:26,000 --> 01:28:28,000
在你那个当前行下面

2220
01:28:28,000 --> 01:28:30,000
列出所有可能命令

2221
01:28:30,000 --> 01:28:31,000
然后

2222
01:28:32,000 --> 01:28:32,000
Zshell 还会

2223
01:28:33,000 --> 01:28:35,000
就像那个 Google 一样会问你说

2224
01:28:35,000 --> 01:28:39,000
如果你输出了一个命令的话他会问你说你是不是是想要执行另外一个命令

2225
01:28:39,000 --> 01:28:41,000
有时候这个挺讨厌的

2226
01:28:41,000 --> 01:28:41,000
但是

2227
01:28:42,000 --> 01:28:45,000
就还带那个 auto correction

2228
01:28:45,000 --> 01:28:46,000
但是我们现在都用 fuck 了

2229
01:28:48,000 --> 01:28:50,000
如果我们待会提到 fuck 这个东西

2230
01:28:51,000 --> 01:28:58,000
然后他还可以做一些比较神的事情比如说你要 SCP 到一个远端的服务器上

2231
01:28:59,000 --> 01:29:04,000
在 bash 里面你必须记住远端的服务器的那个

2232
01:29:04,000 --> 01:29:05,000
路径是什么路径

2233
01:29:05,000 --> 01:29:08,000
但是在 Zshell 里面你只要不停的按 tab 他会帮你

2234
01:29:08,000 --> 01:29:11,000
补全远程服务器上的路径

2235
01:29:11,000 --> 01:29:12,000
这也是很屌

2236
01:29:12,000 --> 01:29:13,000
实用又很屌

2237
01:29:13,000 --> 01:29:14,000
非常的黑猫法

2238
01:29:15,000 --> 01:29:19,000
另外就是我个人最喜欢的一点就是他可以在

2239
01:29:19,000 --> 01:29:22,000
屏幕的右侧显示一个 promote

2240
01:29:23,000 --> 01:29:24,000
在右侧有个提示符

2241
01:29:25,000 --> 01:29:30,000
对标准段段下一般都只有在左侧提示因为那个那个那个

2242
01:29:30,000 --> 01:29:32,000
字符串的这个

2243
01:29:33,000 --> 01:29:34,000
补齐的方式是这样子

2244
01:29:34,000 --> 01:29:38,000
然后如果你在右端你要做一些额外的事情要 redraw 之类的对吧

2245
01:29:39,000 --> 01:29:39,000
这个还

2246
01:29:40,000 --> 01:29:44,000
就有时候那么有那些不那么重要的信息你放在右边还是比较有

2247
01:29:45,000 --> 01:29:47,000
比较好就是我现在右边放当前时间

2248
01:29:48,000 --> 01:29:50,000
用户名主机然后是那个

2249
01:29:51,000 --> 01:29:52,000
Python virtual environment 的

2250
01:29:53,000 --> 01:29:54,000
的名称

2251
01:29:55,000 --> 01:29:58,000
然后左边就只放目录和那个

2252
01:29:58,000 --> 01:30:00,000
大约号提示符

2253
01:30:02,000 --> 01:30:02,000
很方便

2254
01:30:03,000 --> 01:30:08,000
所以这里其实要说一点就是说刚才讲的那个 Zshell 的大部分这种高级特性

2255
01:30:09,000 --> 01:30:09,000
其实在后来的

2256
01:30:10,000 --> 01:30:11,000
这个新版本的

2257
01:30:12,000 --> 01:30:12,000
Bash 里面

2258
01:30:13,000 --> 01:30:16,000
也通过各种各种各样的方式能够逐渐实现了

2259
01:30:16,000 --> 01:30:17,000
所以在

2260
01:30:18,000 --> 01:30:18,000
就是 feature

2261
01:30:19,000 --> 01:30:19,000
就是什么

2262
01:30:20,000 --> 01:30:22,000
就是在特性的完成度上

2263
01:30:22,000 --> 01:30:25,000
现代版本的 Zshell 和现在版本的 Bash 是相差不大

2264
01:30:26,000 --> 01:30:27,000
但是在 90 年代

2265
01:30:27,000 --> 01:30:29,000
Zshell 的很多特性是

2266
01:30:30,000 --> 01:30:30,000
现在的

2267
01:30:31,000 --> 01:30:33,000
是那个时候的 Bash 也不可想象

2268
01:30:37,000 --> 01:30:39,000
这就是为什么从 90 年代开始有了一大堆这个

2269
01:30:40,000 --> 01:30:41,000
Zshell 拥堵

2270
01:30:41,000 --> 01:30:49,000
然后一直到今天在大概在 2010 年前后出现了一个叫做 OMYZshell 的项目

2271
01:30:50,000 --> 01:30:56,000
这是一个由社区维护的 Zshell 的配置和插件的一个集合

2272
01:30:56,000 --> 01:31:02,000
就是如果你去装一个 OMYZshell 的话你可以很多很多东西就只需要改一个小小的配置文件

2273
01:31:02,000 --> 01:31:04,000
里面的一行就可以用到

2274
01:31:05,000 --> 01:31:08,000
你就可以有一个很帅很酷的这么一个

2275
01:31:08,000 --> 01:31:09,000
就是密码的提示符号

2276
01:31:09,000 --> 01:31:13,000
比如说它里面提供了几百种那个主题

2277
01:31:14,000 --> 01:31:15,000
随便改一改你会觉得

2278
01:31:15,000 --> 01:31:16,000
你会就会让这个

2279
01:31:17,000 --> 01:31:21,000
不明就里的人看到我靠在搞什么这是这是什么东西看起来好会

2280
01:31:24,000 --> 01:31:27,000
所以我有一个问题问你啊就是为什么你要从 Bash 切换到 Zshell

2281
01:31:28,000 --> 01:31:29,000
其实我

2282
01:31:30,000 --> 01:31:33,000
其实我犹豫过很久就是我这个

2283
01:31:35,000 --> 01:31:37,000
在两者之间反复跳跃了很多次

2284
01:31:38,000 --> 01:31:39,000
OK

2285
01:31:39,000 --> 01:31:43,000
你觉得你最终要去做这个选择的原因是什么

2286
01:31:43,000 --> 01:31:47,000
最终选择的原因还是因为他的心得性太多了

2287
01:31:48,000 --> 01:31:48,000
或者说

2288
01:31:49,000 --> 01:31:50,000
对于我来说他的 Killer

2289
01:31:51,000 --> 01:31:53,000
Feature 就是右边的这个 Promote

2290
01:31:54,000 --> 01:31:58,000
这个好像在 Bash 里面现在为止都还比较难实现

2291
01:31:58,000 --> 01:31:59,000
对在 Bash 里面是不可能做的

2292
01:32:03,000 --> 01:32:07,000
其他的其实也没什么因为我现在的状况其实是我在办公室

2293
01:32:08,000 --> 01:32:08,000
会用 Bash

2294
01:32:08,000 --> 01:32:09,000
在公司会用 Bash

2295
01:32:09,000 --> 01:32:11,000
然后回家用 Zshell

2296
01:32:14,000 --> 01:32:17,000
这两个的语法在大部分情况下是兼容的

2297
01:32:17,000 --> 01:32:22,000
在 99%情况下你是感觉不到差别的只是有时候你在 Zshell 下面会觉得非常方便

2298
01:32:23,000 --> 01:32:24,000
比如说刚才提到这个命令的问题

2299
01:32:24,000 --> 01:32:27,000
在 Bash 下面你可能要 type 很多次然后

2300
01:32:27,000 --> 01:32:29,000
才能找到自己需要找的那个

2301
01:32:29,000 --> 01:32:33,000
但是在 Zshell 下面你可能再 type 一次然后看一看你就知道你要什么

2302
01:32:35,000 --> 01:32:36,000
除此之外其实

2303
01:32:36,000 --> 01:32:37,000
Zshell 的

2304
01:32:38,000 --> 01:32:39,000
带来的改进并没有太多

2305
01:32:39,000 --> 01:32:42,000
应该这么说在公司里面我基本不会

2306
01:32:43,000 --> 01:32:46,000
觉得这里如果我是在用 Zshell 就好了

2307
01:32:46,000 --> 01:32:50,000
这就是为什么后来我曾经很多次切换回 Bash

2308
01:32:51,000 --> 01:32:52,000
在自己的电脑上面

2309
01:32:53,000 --> 01:32:54,000
因为总觉得 Zshell 是一个

2310
01:32:56,000 --> 01:32:58,000
No standard 的东西

2311
01:32:59,000 --> 01:33:00,000
加引号的

2312
01:33:00,000 --> 01:33:02,000
当然也非常常见但是

2313
01:33:03,000 --> 01:33:05,000
没有那么没有像 Bash 那么

2314
01:33:06,000 --> 01:33:07,000
到处都有

2315
01:33:07,000 --> 01:33:09,000
那我为什么要依赖于这种

2316
01:33:10,000 --> 01:33:13,000
其实没有那么多便利的东西

2317
01:33:13,000 --> 01:33:14,000
后来还是觉得

2318
01:33:14,000 --> 01:33:16,000
能方便一点方便一点何必呢

2319
01:33:17,000 --> 01:33:23,000
我从 Bash 切换到 Zshell 的原因比较简单就是我当时做了一个

2320
01:33:24,000 --> 01:33:26,000
Bash 的一个 promote

2321
01:33:26,000 --> 01:33:28,000
小脚本吧就是

2322
01:33:29,000 --> 01:33:30,000
制定

2323
01:33:30,000 --> 01:33:34,000
自己定制化 Bash 的提示符

2324
01:33:34,000 --> 01:33:35,000
然后发现这个 Bash

2325
01:33:36,000 --> 01:33:38,000
就是那个 Bash Power Live

2326
01:33:38,000 --> 01:33:39,000
在 Github 上应该是最

2327
01:33:39,000 --> 01:33:42,000
被新标的最多的一个 repository 吧

2328
01:33:43,000 --> 01:33:44,000
就可以实现比如说

2329
01:33:45,000 --> 01:33:46,000
以一种

2330
01:33:47,000 --> 01:33:48,000
看起来还挺帅的方式

2331
01:33:48,000 --> 01:33:54,000
显示比如说如果你这个目录是有 Git 的话它会显示那个 Git 的这个 branch 的名字

2332
01:33:54,000 --> 01:33:56,000
它会显示说你有多少个 commit

2333
01:33:57,000 --> 01:33:57,000
你有多少个 commit

2334
01:33:58,000 --> 01:33:59,000
就是 ahead 或者是

2335
01:33:59,000 --> 01:34:00,000
behind

2336
01:34:00,000 --> 01:34:01,000
远端

2337
01:34:02,000 --> 01:34:03,000
它可以显示

2338
01:34:03,000 --> 01:34:04,000
根据你上一条 meaning 的

2339
01:34:05,000 --> 01:34:07,000
执行的结果是正常还是异常它会显示是

2340
01:34:08,000 --> 01:34:09,000
绿色或者是红色这样一些

2341
01:34:10,000 --> 01:34:11,000
比较

2342
01:34:11,000 --> 01:34:13,000
花巧的功能版

2343
01:34:14,000 --> 01:34:15,000
然后

2344
01:34:15,000 --> 01:34:19,000
在做的过程中就发现其实那个 Bash 的那些语法是比较坑爹的

2345
01:34:20,000 --> 01:34:21,000
就比较首先

2346
01:34:21,000 --> 01:34:24,000
不是太一致然后也不太好记每次都要去

2347
01:34:24,000 --> 01:34:29,000
折腾半天到底怎么去写去查半天到底怎么去写那个就是它语法比较

2348
01:34:29,000 --> 01:34:30,000
Inconsistent

2349
01:34:30,000 --> 01:34:33,000
然后 Zash 的那个就会好很多

2350
01:34:34,000 --> 01:34:35,000
所以我最后就签了 Zash 上面

2351
01:34:36,000 --> 01:34:37,000
但还有一个很重要的原因就是

2352
01:34:38,000 --> 01:34:39,000
刚才讲那个 Western 自带的 Zash

2353
01:34:40,000 --> 01:34:41,000
版本比较稀嘛

2354
01:34:41,000 --> 01:34:44,000
我现在遵循的那个哲学就是

2355
01:34:44,000 --> 01:34:46,000
能不折腾就折腾

2356
01:34:46,000 --> 01:34:46,000
我不想再

2357
01:34:47,000 --> 01:34:50,000
Homebrew 再装一遍 Bash 的然后再剃掉这样

2358
01:34:50,000 --> 01:34:50,000
对没错

2359
01:34:51,000 --> 01:34:55,000
其实我刚才想说的也是就是 Zash 有很多

2360
01:34:55,000 --> 01:34:58,000
它设立出想要达成的

2361
01:34:58,000 --> 01:34:59,000
目的之一就是

2362
01:35:01,000 --> 01:35:03,000
用 Zash 写的 Salescript

2363
01:35:05,000 --> 01:35:06,000
或者说

2364
01:35:06,000 --> 01:35:08,000
使用了 Zash 的扩展

2365
01:35:08,000 --> 01:35:09,000
而

2366
01:35:10,000 --> 01:35:12,000
而不是纯粹的 Shell

2367
01:35:12,000 --> 01:35:14,000
SH compatible 的

2368
01:35:14,000 --> 01:35:15,000
Shell script

2369
01:35:15,000 --> 01:35:17,000
应该要比 Bash 写的更

2370
01:35:17,000 --> 01:35:21,000
易读更易写而且更

2371
01:35:22,000 --> 01:35:26,000
优雅一点应该可以应该应该应该使用优雅这个词在这

2372
01:35:26,000 --> 01:35:31,000
但是很遗憾这一点并没有铺开来就是这世界上大部分的 Shell script 还是

2373
01:35:31,000 --> 01:35:32,000
要么是 Shell

2374
01:35:32,000 --> 01:35:33,000
要么是 Bash

2375
01:35:34,000 --> 01:35:36,000
还是很少有人在用写

2376
01:35:36,000 --> 01:35:38,000
Zshell ZSH 的 Shell script

2377
01:35:39,000 --> 01:35:46,000
其实如果写 Script 的话其实还是用那个最精简的那个 Shell 的

2378
01:35:46,000 --> 01:35:48,000
语法会通用性会强一点

2379
01:35:48,000 --> 01:35:53,000
但是很多人会觉得说比如说 Bash 的一些扩展

2380
01:35:53,000 --> 01:35:54,000
双

2381
01:35:54,000 --> 01:35:54,000
双的

2382
01:35:55,000 --> 01:35:56,000
双方括号

2383
01:35:57,000 --> 01:35:59,000
要比那个单括号要

2384
01:35:59,000 --> 01:36:02,000
能够表达语意实际上功能多一些对吧

2385
01:36:02,000 --> 01:36:04,000
所以很多人会选择用 Shell

2386
01:36:04,000 --> 01:36:05,000
用 Bash 来写 Shell script

2387
01:36:06,000 --> 01:36:09,000
但是这个数目还是要远远远远多于

2388
01:36:10,000 --> 01:36:13,000
用 Zshell 来写

2389
01:36:13,000 --> 01:36:14,000
这点还是挺遗憾的

2390
01:36:15,000 --> 01:36:16,000
那倒是

2391
01:36:17,000 --> 01:36:23,000
其实除了这些这些比较正统的这个 Shell 之外也有一些比较新的尝试

2392
01:36:23,000 --> 01:36:24,000
最近几年出现的

2393
01:36:24,000 --> 01:36:25,000
就是说

2394
01:36:25,000 --> 01:36:27,000
为什么有那么多的历史包袱

2395
01:36:27,000 --> 01:36:29,000
假设我们不考虑向后兼容性的话

2396
01:36:29,000 --> 01:36:33,000
如果抛开 Posthash-SH compatibility 这个历史包袱的话

2397
01:36:33,000 --> 01:36:35,000
今天的 Shell 真是可以各种各样

2398
01:36:37,000 --> 01:36:39,000
其中比较著名的就是叫 Fish 的吧

2399
01:36:40,000 --> 01:36:41,000
这个鱼壳

2400
01:36:41,000 --> 01:36:43,000
算是用的最多的一个

2401
01:36:45,000 --> 01:36:47,000
Shell 不兼容的

2402
01:36:47,000 --> 01:36:48,000
Shell

2403
01:36:48,000 --> 01:36:49,000
对对对

2404
01:36:50,000 --> 01:36:52,000
所以你有日常在用吗

2405
01:36:53,000 --> 01:36:55,000
我有一段时间

2406
01:36:55,000 --> 01:36:57,000
才把它用当作主力 Shell 来用

2407
01:36:57,000 --> 01:36:58,000
它确实挺方便的

2408
01:36:59,000 --> 01:37:00,000
它很多

2409
01:37:00,000 --> 01:37:01,000
Modern Feature

2410
01:37:01,000 --> 01:37:03,000
很多现代的特性

2411
01:37:03,000 --> 01:37:03,000
比如说

2412
01:37:04,000 --> 01:37:06,000
就是有这个语法高量的命令行

2413
01:37:06,000 --> 01:37:07,000
输入的行

2414
01:37:08,000 --> 01:37:09,000
有时候你会产生一种我在用一个 IDE 嘛

2415
01:37:09,000 --> 01:37:10,000
有时候你会产生错觉

2416
01:37:10,000 --> 01:37:12,000
就是比如说你打一个

2417
01:37:12,000 --> 01:37:14,000
你打个 SLS

2418
01:37:14,000 --> 01:37:15,000
然后它会把

2419
01:37:15,000 --> 01:37:19,000
LS 所能显示的所有参数所能使用的所有参数显示在你当前行动下来

2420
01:37:21,000 --> 01:37:22,000
对

2421
01:37:22,000 --> 01:37:25,000
然后它就是还有一些像那个自动补齐的下拉列表啊

2422
01:37:26,000 --> 01:37:28,000
还有各种各样的这种一些很好的特性

2423
01:37:28,000 --> 01:37:29,000
甚至还有一个

2424
01:37:29,000 --> 01:37:32,000
它好像是一个网页版本的什么东西来的

2425
01:37:32,000 --> 01:37:38,000
它的那个主题是可以通过 CSS 还是什么的一个东西来配置的

2426
01:37:38,000 --> 01:37:39,000
对对对

2427
01:37:39,000 --> 01:37:41,000
配色也是这个很功能

2428
01:37:41,000 --> 01:37:42,000
说到配色要讲

2429
01:37:43,000 --> 01:37:44,000
要讲那个 256 色那些

2430
01:37:44,000 --> 01:37:48,000
其实在需要里面打出有颜色的字这件事来说还是挺麻烦的

2431
01:37:49,000 --> 01:37:52,000
对有时候你可能会觉得说我可现在已经 60 年过去了

2432
01:37:53,000 --> 01:37:54,000
我居然还是不能在

2433
01:37:55,000 --> 01:37:56,000
终端之下

2434
01:37:57,000 --> 01:37:58,000
方便的搞出颜色

2435
01:37:59,000 --> 01:38:02,000
让用户看到我希望能看到的颜色就这么难

2436
01:38:03,000 --> 01:38:03,000
就是

2437
01:38:05,000 --> 01:38:06,000
就是要也要吐槽这一件事

2438
01:38:06,000 --> 01:38:09,000
对就如果你就使用 iTEM 然后你要想让 iTEM

2439
01:38:09,000 --> 01:38:11,000
看起来漂亮一点的话

2440
01:38:11,000 --> 01:38:14,000
你能折腾过这个配色方案这个东西

2441
01:38:14,000 --> 01:38:17,000
但是如果你折腾的话你会觉得我靠这真是一个巨大的坑啊

2442
01:38:18,000 --> 01:38:18,000
就是

2443
01:38:18,000 --> 01:38:21,000
UniX 的

2444
01:38:21,000 --> 01:38:24,000
这个话题我估计这里不能展开了

2445
01:38:24,000 --> 01:38:25,000
我靠为什么

2446
01:38:26,000 --> 01:38:30,000
历史的这个枷锁一直到 60 年代还套在我的头上

2447
01:38:30,000 --> 01:38:30,000
我为什么要

2448
01:38:31,000 --> 01:38:36,000
去去去去在意什么 16 色 256 色之类的东西

2449
01:38:36,000 --> 01:38:36,000
那

2450
01:38:37,000 --> 01:38:37,000
没错

2451
01:38:37,000 --> 01:38:39,000
在 Fish 这边就没有这个问题了

2452
01:38:40,000 --> 01:38:41,000
你想用什么颜色就用什么颜色

2453
01:38:42,000 --> 01:38:43,000
因为他不需要去做兼容性

2454
01:38:46,000 --> 01:38:52,000
当然了除开我们刚刚就刚才讲的以上所有 shell 都是一个叫做类 UniX 系统的

2455
01:38:52,000 --> 01:38:53,000
上面使用的 shell

2456
01:38:54,000 --> 01:38:55,000
但其实还有一些

2457
01:38:56,000 --> 01:38:57,000
大家比较常见的 shell

2458
01:38:59,000 --> 01:39:00,000
dospromote

2459
01:39:00,000 --> 01:39:03,000
其实我们刚才说过但是这个东西

2460
01:39:03,000 --> 01:39:06,000
首先 dospromote 从来不会把自己叫做一个

2461
01:39:06,000 --> 01:39:08,000
把自己称为一个 shell

2462
01:39:08,000 --> 01:39:09,000
叫做 shell

2463
01:39:09,000 --> 01:39:09,000
他叫 promote

2464
01:39:10,000 --> 01:39:16,000
然后在这个东西怎么进在现在的 windows 里面你打开这个开始菜单搜索 cmd

2465
01:39:16,000 --> 01:39:19,000
他也会出来出来一个命令号

2466
01:39:19,000 --> 01:39:20,000
他中文叫什么来的

2467
01:39:21,000 --> 01:39:22,000
这叫道斯命令号

2468
01:39:22,000 --> 01:39:23,000
窗口吧

2469
01:39:23,000 --> 01:39:25,000
中文版的

2470
01:39:26,000 --> 01:39:27,000
是吗 OK

2471
01:39:28,000 --> 01:39:32,000
然后你打开之后会出现一个黑不垃圾的窗口然后进可能里面

2472
01:39:32,000 --> 01:39:35,000
最多人跑的两条命令一个是叫做

2473
01:39:35,000 --> 01:39:36,000
IP config

2474
01:39:37,000 --> 01:39:38,000
看自己的这个 IP 地址

2475
01:39:39,000 --> 01:39:39,000
然后第二就是

2476
01:39:40,000 --> 01:39:41,000
PIN

2477
01:39:41,000 --> 01:39:43,000
第三可能就是那个了

2478
01:39:43,000 --> 01:39:45,000
NS lookup 查那个 DNS 运作

2479
01:39:46,000 --> 01:39:47,000
这些比较常有 DR

2480
01:39:48,000 --> 01:39:49,000
列表的一些作用

2481
01:39:51,000 --> 01:39:53,000
这个可能现在

2482
01:39:53,000 --> 01:39:54,000
用越来越少了

2483
01:39:54,000 --> 01:39:59,000
想想还挺讽刺的你在这样一个时代检测自己能不能

2484
01:39:59,000 --> 01:40:01,000
连接到另外一台

2485
01:40:01,000 --> 01:40:04,000
计算机的最常见的方法居然还是

2486
01:40:04,000 --> 01:40:05,000
就是

2487
01:40:05,000 --> 01:40:09,000
使用一个源自于电传导师机时代的

2488
01:40:10,000 --> 01:40:12,000
一个特征一个命令行

2489
01:40:12,000 --> 01:40:15,000
窗口来输入一台输入一个

2490
01:40:16,000 --> 01:40:17,000
70 年代的

2491
01:40:17,000 --> 01:40:18,000
工具的名字

2492
01:40:19,000 --> 01:40:21,000
历史的包袱还是很沉重

2493
01:40:21,000 --> 01:40:25,000
就是在过去的四五十年里面居然没有一个方法能够替代它

2494
01:40:28,000 --> 01:40:30,000
但也有一些像 Windows 上也有一些比较

2495
01:40:31,000 --> 01:40:33,000
晚进的新鲜的东西了这个叫做

2496
01:40:34,000 --> 01:40:36,000
PowerShell PowerShell 应该是在 Windows

2497
01:40:36,000 --> 01:40:38,000
7 吧还是

2498
01:40:38,000 --> 01:40:39,000
Vista 的时候才引起的

2499
01:40:39,000 --> 01:40:41,000
MNT 时代就已经开始研发了

2500
01:40:43,000 --> 01:40:46,000
我没有用 MNT 我的印象中只有在 Vista 或者 Windows 7 里面

2501
01:40:46,000 --> 01:40:47,000
见过它

2502
01:40:47,000 --> 01:40:50,000
然后 PowerShell 是什么东西呢

2503
01:40:52,000 --> 01:40:54,000
就 Windows 在早期会觉得说我靠这个

2504
01:40:55,000 --> 01:40:58,000
故意难道不是一统天下的东西吗我为什么要去搞命令行这一套

2505
01:40:59,000 --> 01:41:03,000
但是后来他们意识到命令行其实生命命令行就像野草一样

2506
01:41:03,000 --> 01:41:04,000
或者就像

2507
01:41:05,000 --> 01:41:08,000
像底层的命令行还是非常有用的

2508
01:41:08,000 --> 01:41:09,000
像细菌一样会有用

2509
01:41:09,000 --> 01:41:13,000
那他们发现没办法我们也得搞一个

2510
01:41:13,000 --> 01:41:14,000
程序员能用的那个

2511
01:41:15,000 --> 01:41:19,000
对我想起来这个是 Windows NT 的那个服务器的那些延伸过来

2512
01:41:19,000 --> 01:41:21,000
因为当时好像他们提了一个口号是说

2513
01:41:21,000 --> 01:41:23,000
所有能够在

2514
01:41:23,000 --> 01:41:25,000
就所有通过图形界面能做的

2515
01:41:26,000 --> 01:41:29,000
对这个 Windows NT 的操作都可以通过命令行的方式来执行

2516
01:41:30,000 --> 01:41:31,000
然后这个命令行就是 PowerShell

2517
01:41:32,000 --> 01:41:34,000
然后他们就搞出 PowerShell 这个

2518
01:41:34,000 --> 01:41:36,000
这个东西当然跟

2519
01:41:36,000 --> 01:41:37,000
SH 是不兼容的

2520
01:41:38,000 --> 01:41:39,000
好

2521
01:41:39,000 --> 01:41:41,000
怎么可能

2522
01:41:41,000 --> 01:41:43,000
但是这个东西的语法是非常

2523
01:41:45,000 --> 01:41:45,000
就学习

2524
01:41:46,000 --> 01:41:46,000
奇怪

2525
01:41:46,000 --> 01:41:48,000
学习曲线是比较陡峭

2526
01:41:49,000 --> 01:41:50,000
首先区分大小姐

2527
01:41:51,000 --> 01:41:53,000
你把它做成 Visual Basic 多好

2528
01:41:54,000 --> 01:41:55,000
不区分大小姐

2529
01:41:55,000 --> 01:41:56,000
首先区分大小姐

2530
01:41:56,000 --> 01:41:58,000
其次他的很多参数和

2531
01:41:59,000 --> 01:42:01,000
做许多事情的这个

2532
01:42:02,000 --> 01:42:03,000
方法都非常的啰嗦

2533
01:42:04,000 --> 01:42:04,000
他可能

2534
01:42:05,000 --> 01:42:08,000
他希望把很多事情做得很正统

2535
01:42:08,000 --> 01:42:09,000
或者很有体调

2536
01:42:10,000 --> 01:42:11,000
但是

2537
01:42:11,000 --> 01:42:13,000
结果就是如果你有

2538
01:42:15,000 --> 01:42:21,000
这个 unix shell 的背景的话你会觉得这套东西是啰嗦到一个境界

2539
01:42:22,000 --> 01:42:24,000
但是我不知道纯粹的微软程序会怎么下

2540
01:42:24,000 --> 01:42:26,000
可能会感觉会不一样

2541
01:42:27,000 --> 01:42:28,000
不过他这有一个好处

2542
01:42:28,000 --> 01:42:29,000
就刚刚我说了吗

2543
01:42:29,000 --> 01:42:31,000
因为他的设计原则是说

2544
01:42:31,000 --> 01:42:33,000
所有图形界面能做的事情他都能做

2545
01:42:34,000 --> 01:42:35,000
所以他的这个

2546
01:42:35,000 --> 01:42:35,000
就是

2547
01:42:35,000 --> 01:42:37,000
就是 feature completeness

2548
01:42:37,000 --> 01:42:39,000
就是这个功能的完整性

2549
01:42:39,000 --> 01:42:39,000
是所有

2550
01:42:40,000 --> 01:42:42,000
目前所有 shell 里面最强大的

2551
01:42:42,000 --> 01:42:42,000
就是

2552
01:42:43,000 --> 01:42:45,000
你可以完全抛弃这个图形界面

2553
01:42:45,000 --> 01:42:46,000
然后通过这个

2554
01:42:46,000 --> 01:42:51,000
这个 shell 的方式去改变一个 windows nt 的服务器的

2555
01:42:51,000 --> 01:42:53,000
任何一个部分

2556
01:42:53,000 --> 01:42:53,000
对吧

2557
01:42:54,000 --> 01:42:54,000
因为在 unix 里面

2558
01:42:55,000 --> 01:42:56,000
有一个哲学就是

2559
01:42:56,000 --> 01:42:56,000
纯文本

2560
01:42:57,000 --> 01:42:58,000
纯文本至上

2561
01:42:58,000 --> 01:43:00,000
在 unix 里面

2562
01:43:00,000 --> 01:43:03,000
在不同命令之间流淌的纯文本

2563
01:43:03,000 --> 01:43:04,000
流可能是你

2564
01:43:04,000 --> 01:43:05,000
唯一能够依赖的东西

2565
01:43:05,000 --> 01:43:07,000
但是在 windows 的 power shell 里面

2566
01:43:08,000 --> 01:43:09,000
很多东西他已经不再是纯文本

2567
01:43:10,000 --> 01:43:11,000
就是它是

2568
01:43:11,000 --> 01:43:12,000
基于对象

2569
01:43:12,000 --> 01:43:13,000
它是一个 structured

2570
01:43:13,000 --> 01:43:14,000
你可以在两个

2571
01:43:14,000 --> 01:43:15,000
object

2572
01:43:15,000 --> 01:43:17,000
你可以在两个命令之间传递一个 object

2573
01:43:18,000 --> 01:43:18,000
这是在

2574
01:43:18,000 --> 01:43:20,000
在 links 里面是不可想象的

2575
01:43:21,000 --> 01:43:26,000
结构化的数据传输而不是基于文本

2576
01:43:26,000 --> 01:43:27,000
的这个数据传输

2577
01:43:28,000 --> 01:43:28,000
这在

2578
01:43:29,000 --> 01:43:30,000
在 links 里面你

2579
01:43:30,000 --> 01:43:34,000
即便能做到也是要通过一大堆什么 tr 啊什么

2580
01:43:34,000 --> 01:43:34,000
什么

2581
01:43:35,000 --> 01:43:36,000
AUK 之类的

2582
01:43:36,000 --> 01:43:36,000
来实现

2583
01:43:37,000 --> 01:43:38,000
就口号性很差嘛

2584
01:43:38,000 --> 01:43:38,000
简单来讲

2585
01:43:39,000 --> 01:43:39,000
就灵活性很差

2586
01:43:40,000 --> 01:43:41,000
但可靠性很差

2587
01:43:41,000 --> 01:43:43,000
判断各种 edge case

2588
01:43:43,000 --> 01:43:44,000
比较麻烦

2589
01:43:44,000 --> 01:43:46,000
power shell 就完全没有这个问题

2590
01:43:46,000 --> 01:43:46,000
因为它可以

2591
01:43:47,000 --> 01:43:49,000
传达传输一个结构化的对象

2592
01:43:49,000 --> 01:43:53,000
保证不需要经过这个序列化反序列化造成的种种问题

2593
01:43:53,000 --> 01:43:54,000
可以直接去

2594
01:43:55,000 --> 01:43:56,000
直接去 access 里面的某一个

2595
01:43:57,000 --> 01:43:58,000
某一个 property

2596
01:43:58,000 --> 01:44:03,000
而且它的因为它是被自上而下设计出来的这么一个 shell

2597
01:44:03,000 --> 01:44:05,000
它的语法虽然说你可能觉得啰嗦

2598
01:44:05,000 --> 01:44:07,000
但是还好像是比较规整

2599
01:44:07,000 --> 01:44:08,000
就是 regular

2600
01:44:08,000 --> 01:44:09,000
举一反三

2601
01:44:10,000 --> 01:44:11,000
不像 linux

2602
01:44:11,000 --> 01:44:12,000
像德语一样

2603
01:44:13,000 --> 01:44:14,000
不像英语

2604
01:44:14,000 --> 01:44:15,000
不停的去 RTFM

2605
01:44:16,000 --> 01:44:17,000
你不停的去看音标

2606
01:44:18,000 --> 01:44:22,000
你去给他个记住各种特例到底怎么一回事

2607
01:44:22,000 --> 01:44:23,000
会比较痛苦一些

2608
01:44:25,000 --> 01:44:26,000
对

2609
01:44:26,000 --> 01:44:29,000
刚才讲了那么多 shell 的来龙去脉的种种好处

2610
01:44:29,000 --> 01:44:32,000
就是我们有一个核心的要探讨的问题

2611
01:44:32,000 --> 01:44:33,000
为什么要用 shell

2612
01:44:33,000 --> 01:44:34,000
为什么要用命令行

2613
01:44:34,000 --> 01:44:35,000
其实这才是本期的重点

2614
01:44:36,000 --> 01:44:36,000
不过你对

2615
01:44:37,000 --> 01:44:38,000
shell 的

2616
01:44:38,000 --> 01:44:39,000
重点估计只有五分钟

2617
01:44:39,000 --> 01:44:42,000
来龙去脉如果你已经了如指掌的话

2618
01:44:42,000 --> 01:44:44,000
前面的部分真的是

2619
01:44:44,000 --> 01:44:46,000
可以自己去看书可能会比较快一点

2620
01:44:46,000 --> 01:44:49,000
但是我们做了这么多历史的铺垫

2621
01:44:50,000 --> 01:44:51,000
介绍了这么多

2622
01:44:51,000 --> 01:44:52,000
咋去咋办的东西

2623
01:44:52,000 --> 01:44:53,000
只是想要

2624
01:44:53,000 --> 01:44:57,000
强调说命令行的生命力在今天还是非常旺盛

2625
01:44:59,000 --> 01:45:00,000
所以为什么要用命令行

2626
01:45:02,000 --> 01:45:03,000
因为它在哪

2627
01:45:05,000 --> 01:45:07,000
它在哪不一定你要用

2628
01:45:07,000 --> 01:45:08,000
它的魅力在哪里为什么

2629
01:45:09,000 --> 01:45:09,000
首先我觉得命令行是

2630
01:45:10,000 --> 01:45:11,000
非常

2631
01:45:12,000 --> 01:45:13,000
简单的一件事情

2632
01:45:14,000 --> 01:45:15,000
你在

2633
01:45:15,000 --> 01:45:17,000
define 简单

2634
01:45:17,000 --> 01:45:18,000
你在

2635
01:45:19,000 --> 01:45:23,000
你在使用一个 60 年代开始就已经在使用的技术

2636
01:45:23,000 --> 01:45:24,000
非常的

2637
01:45:24,000 --> 01:45:25,000
易于理解

2638
01:45:27,000 --> 01:45:28,000
简单的一个特征比如说你

2639
01:45:30,000 --> 01:45:34,000
在单一时间只能在屏幕的单一地方输入一个字符

2640
01:45:36,000 --> 01:45:36,000
不像

2641
01:45:36,000 --> 01:45:38,000
天生单人物系统

2642
01:45:38,000 --> 01:45:39,000
没错不像你在

2643
01:45:40,000 --> 01:45:41,000
使用一个

2644
01:45:41,000 --> 01:45:42,000
图形界面的时候你

2645
01:45:42,000 --> 01:45:43,000
你有鼠标你会

2646
01:45:44,000 --> 01:45:45,000
会想要说

2647
01:45:45,000 --> 01:45:50,000
你要找一个按钮但是你的目光你在搜索这个按钮的时候你会看到很多其他东西

2648
01:45:51,000 --> 01:45:54,000
命令行不是命令行就是空档的那个东西在那摆着

2649
01:45:54,000 --> 01:45:56,000
然后你要是想不起来的话你都想不起来

2650
01:45:56,000 --> 01:45:58,000
然后你要去找的话你很有可能

2651
01:45:58,000 --> 01:46:01,000
你就你要么找你可以直接找到你要找的东西

2652
01:46:02,000 --> 01:46:04,000
要么你就完全找不到对吧

2653
01:46:05,000 --> 01:46:08,000
所以这个是缺点就是它的可发现性比较差吗

2654
01:46:10,000 --> 01:46:12,000
任何事情都是双人见网

2655
01:46:12,000 --> 01:46:14,000
使用这个

2656
01:46:14,000 --> 01:46:16,000
图形界面的时候我经常会觉得

2657
01:46:17,000 --> 01:46:18,000
distracted

2658
01:46:20,000 --> 01:46:25,000
因为屏幕上太多这种 blingbling 的小广告

2659
01:46:25,000 --> 01:46:29,000
你此时用不到但是你很有可能在下一秒就要用到的东西

2660
01:46:30,000 --> 01:46:35,000
但你又不可能或者说目前还没有一个软件会把所有的

2661
01:46:37,000 --> 01:46:38,000
菜单和

2662
01:46:39,000 --> 01:46:39,000
工具条全都弄出来

2663
01:46:40,000 --> 01:46:40,000
做成

2664
01:46:41,000 --> 01:46:45,000
隐藏式的或者是浮动式因为这个如果那样的话

2665
01:46:45,000 --> 01:46:48,000
你又需要去动一下鼠标才他们才会弹出来

2666
01:46:49,000 --> 01:46:54,000
或者是需要去按一个什么东西反正总所有这些都会让你觉得命令行这个

2667
01:46:55,000 --> 01:46:58,000
图形界面固然方便但是有时候也特别的

2668
01:46:59,000 --> 01:47:00,000
啰嗦

2669
01:47:00,000 --> 01:47:02,000
命令行都不一样你可能

2670
01:47:02,000 --> 01:47:04,000
你所要做的两件事情就是

2671
01:47:04,000 --> 01:47:05,000
敲命令和按回车

2672
01:47:07,000 --> 01:47:09,000
或者说你所要做的两件事情就是输入和输出

2673
01:47:10,000 --> 01:47:10,000
然后

2674
01:47:11,000 --> 01:47:12,000
所有这些东西都是在一个特定的地方

2675
01:47:13,000 --> 01:47:14,000
完成了然后

2676
01:47:15,000 --> 01:47:16,000
需要关注的点也就只有那么一点而已

2677
01:47:19,000 --> 01:47:21,000
再我觉得其实命令行下面的

2678
01:47:22,000 --> 01:47:22,000
工具

2679
01:47:22,000 --> 01:47:23,000
要更

2680
01:47:24,000 --> 01:47:25,000
切重要害一点

2681
01:47:25,000 --> 01:47:26,000
比如说

2682
01:47:26,000 --> 01:47:29,000
比如说 Git 要看 Git 的这个 revision history

2683
01:47:30,000 --> 01:47:31,000
我基本上只会用 Tik

2684
01:47:31,000 --> 01:47:34,000
就我不是没有用过其他的什么 source tray 或者是

2685
01:47:35,000 --> 01:47:39,000
Atlasin 出的那个网页版的工具叫什么来着

2686
01:47:39,000 --> 01:47:40,000
我记得但是

2687
01:47:41,000 --> 01:47:42,000
所有这些看 Git revision 的

2688
01:47:43,000 --> 01:47:45,000
工具感觉都没有 Tik 方便

2689
01:47:46,000 --> 01:47:48,000
而打开 Tik 的

2690
01:47:50,000 --> 01:47:52,000
步骤也就是输入 Tik 按回车而已

2691
01:47:53,000 --> 01:47:53,000
没有什么

2692
01:47:54,000 --> 01:47:57,000
就一步之遥然后你离开也只有一步之遥不需要去

2693
01:47:58,000 --> 01:48:02,000
点一个工具点一个图标然后看它运行然后选入选那个

2694
01:48:03,000 --> 01:48:04,000
Repository 之类的

2695
01:48:05,000 --> 01:48:09,000
就我觉得命令行下面很多工具都比较短小然后切中要害

2696
01:48:09,000 --> 01:48:16,000
所以其实这句话你刚讲的中文翻译成英文其实在 unix

2697
01:48:16,000 --> 01:48:16,000
的这个

2698
01:48:17,000 --> 01:48:19,000
因为大部分是一个命令行驱动的工具

2699
01:48:20,000 --> 01:48:21,000
就是那系统对吧

2700
01:48:21,000 --> 01:48:23,000
他们追求的这么一个

2701
01:48:23,000 --> 01:48:24,000
设计者叫做

2702
01:48:24,000 --> 01:48:26,000
Do one thing and do it well

2703
01:48:27,000 --> 01:48:28,000
一个工具

2704
01:48:29,000 --> 01:48:32,000
只做一件事并且把这件事做到极致

2705
01:48:32,000 --> 01:48:36,000
然后比如说刚才讲的这个 Tik 它可以去浏览这个

2706
01:48:37,000 --> 01:48:39,000
Git 的 repository 的情况

2707
01:48:39,000 --> 01:48:41,000
还有其他各种各样的小工具

2708
01:48:41,000 --> 01:48:44,000
它可以去比如说可以去

2709
01:48:44,000 --> 01:48:49,000
列表一个目录的内容啊或者是在一个文件里面查找东西啊它都是

2710
01:48:49,000 --> 01:48:50,000
很小的一个步骤

2711
01:48:51,000 --> 01:48:51,000
然后呢

2712
01:48:52,000 --> 01:48:54,000
因为有于命令行的这个

2713
01:48:54,000 --> 01:48:55,000
管道的功能

2714
01:48:55,000 --> 01:48:56,000
它可以使得

2715
01:48:57,000 --> 01:48:59,000
两个程序之间配合

2716
01:48:59,000 --> 01:49:01,000
比如说上一个程序的输入输出

2717
01:49:01,000 --> 01:49:03,000
变成下一个程序的输入

2718
01:49:04,000 --> 01:49:05,000
然后这个链条是可以

2719
01:49:05,000 --> 01:49:06,000
扩度无限长的

2720
01:49:07,000 --> 01:49:09,000
它们之间存在一个叫做可组合性

2721
01:49:09,000 --> 01:49:09,000
就是说

2722
01:49:10,000 --> 01:49:10,000
如果你的

2723
01:49:10,000 --> 01:49:11,000
是一个工具箱里面

2724
01:49:12,000 --> 01:49:14,000
有锤子有钉子

2725
01:49:14,000 --> 01:49:17,000
还有把有锤子有扳手这些东西之外

2726
01:49:17,000 --> 01:49:18,000
它还能组合成一些

2727
01:49:19,000 --> 01:49:20,000
一套完整的

2728
01:49:20,000 --> 01:49:21,000
工具链使得

2729
01:49:22,000 --> 01:49:27,000
你可以完成各种各样比较复杂或者更加更加灵活的进行对工作场景

2730
01:49:27,000 --> 01:49:28,000
所以

2731
01:49:28,000 --> 01:49:32,000
就是工具的这个完善性每一个工具的这个小巧可靠

2732
01:49:33,000 --> 01:49:36,000
以及他们之间的相互组合性我觉得这个是命令行

2733
01:49:36,000 --> 01:49:38,000
这个生态最大的

2734
01:49:38,000 --> 01:49:39,000
魅力所在

2735
01:49:39,000 --> 01:49:40,000
没错

2736
01:49:40,000 --> 01:49:44,000
而反过来在这个图形界面之下你就没有这样的

2737
01:49:44,000 --> 01:49:45,000
概念存在

2738
01:49:45,000 --> 01:49:46,000
就是你

2739
01:49:47,000 --> 01:49:53,000
你怎么样才能把一个图形界面的工具的输出转入到另外一个图形界面的工具的输入里面

2740
01:49:53,000 --> 01:49:54,000
copy and paste 吗

2741
01:49:54,000 --> 01:49:55,000
也有

2742
01:49:55,000 --> 01:49:57,000
对 copy and paste 或者叫做 drag and drop

2743
01:49:57,000 --> 01:49:58,000
或者是拖拉

2744
01:49:59,000 --> 01:50:00,000
但这些是没有办法自动化的

2745
01:50:01,000 --> 01:50:01,000
没有办法

2746
01:50:02,000 --> 01:50:03,000
同时说我

2747
01:50:03,000 --> 01:50:04,000
我永远要把

2748
01:50:04,000 --> 01:50:08,000
自动化这些倒不是一个问题我觉得最主要的问题就是说他们

2749
01:50:08,000 --> 01:50:08,000
因为

2750
01:50:09,000 --> 01:50:12,000
因为图形化的这个内容的传递

2751
01:50:12,000 --> 01:50:14,000
之间不存在这个一个叫做

2752
01:50:15,000 --> 01:50:16,000
universal interface

2753
01:50:16,000 --> 01:50:19,000
universal interface 就是统一的接口就是这个文本 text

2754
01:50:20,000 --> 01:50:21,000
就图形化的界面

2755
01:50:21,000 --> 01:50:22,000
它不存在这么一个

2756
01:50:23,000 --> 01:50:24,000
一个通用的一个接口

2757
01:50:25,000 --> 01:50:30,000
使得并不是任意两个程序之间的这个输出都是可以直接 drag and drop

2758
01:50:30,000 --> 01:50:30,000
来

2759
01:50:31,000 --> 01:50:32,000
来组合的嘛

2760
01:50:32,000 --> 01:50:33,000
所以必须说

2761
01:50:34,000 --> 01:50:35,000
你开发了假设

2762
01:50:35,000 --> 01:50:37,000
你在 photoshop 里面编辑了一个图片

2763
01:50:38,000 --> 01:50:39,000
然后你要导入到另外一个工具

2764
01:50:39,000 --> 01:50:40,000
去做一个进一步的处理

2765
01:50:41,000 --> 01:50:42,000
你得把它变成一个

2766
01:50:43,000 --> 01:50:44,000
文件

2767
01:50:44,000 --> 01:50:45,000
然后在

2768
01:50:45,000 --> 01:50:46,000
hopefully

2769
01:50:46,000 --> 01:50:47,000
你的那个下一个

2770
01:50:48,000 --> 01:50:50,000
环节的工具能够打开上一个环节

2771
01:50:51,000 --> 01:50:52,000
这个工具生成的图片

2772
01:50:52,000 --> 01:50:56,000
导入到自己的这个里面然后再做进一步的操作对吧

2773
01:50:56,000 --> 01:50:57,000
所以

2774
01:50:58,000 --> 01:51:01,000
这里就有一个这个

2775
01:51:01,000 --> 01:51:06,000
composability 这个合成性的问题会比稍微差一些

2776
01:51:06,000 --> 01:51:08,000
但这只是一个我们理解通常状况

2777
01:51:08,000 --> 01:51:09,000
但也有很好的

2778
01:51:09,000 --> 01:51:10,000
这个合成性

2779
01:51:11,000 --> 01:51:14,000
相对还不错的这么一个环境比如说在

2780
01:51:14,000 --> 01:51:20,000
现在的 iOS 上面就因为这个他没有文件系统暴露出来也没有命令行暴露出来给你用嘛

2781
01:51:20,000 --> 01:51:21,000
所以这个

2782
01:51:21,000 --> 01:51:22,000
这个上下游的配合

2783
01:51:23,000 --> 01:51:23,000
是

2784
01:51:24,000 --> 01:51:27,000
你必须要考作为这些设计者你必须要考虑的一个问题

2785
01:51:28,000 --> 01:51:28,000
那

2786
01:51:28,000 --> 01:51:31,000
现在就说你可以分享到某一个应用里面去对吧

2787
01:51:32,000 --> 01:51:38,000
你如果那个应用他大高能够接受这么一个图片格式或者文件格式也好他是其实能够

2788
01:51:38,000 --> 01:51:39,000
把这个链条传下去

2789
01:51:39,000 --> 01:51:40,000
只是说

2790
01:51:40,000 --> 01:51:41,000
由于

2791
01:51:42,000 --> 01:51:44,000
还是那个问题吗就不存在这个 text

2792
01:51:44,000 --> 01:51:45,000
as a universal interface

2793
01:51:46,000 --> 01:51:50,000
同时也不存在一个强有机构来要求所有的程序都必须实现一下

2794
01:51:51,000 --> 01:51:51,000
这个

2795
01:51:52,000 --> 01:51:54,000
跟其他程序交互的接口

2796
01:51:54,000 --> 01:51:58,000
所以这个整个还是一样的来说比较难一点

2797
01:51:58,000 --> 01:52:01,000
然后我觉得可能命令行对我来说

2798
01:52:01,000 --> 01:52:03,000
另外一个好处就是他可以表述一些

2799
01:52:04,000 --> 01:52:05,000
比较复杂的一个概念

2800
01:52:06,000 --> 01:52:07,000
比如说因为有这个

2801
01:52:08,000 --> 01:52:08,000
有这个

2802
01:52:08,000 --> 01:52:09,000
语法的

2803
01:52:09,000 --> 01:52:10,000
存在

2804
01:52:10,000 --> 01:52:11,000
他其实是一个

2805
01:52:11,000 --> 01:52:13,000
他是一个叫做 turing complete language

2806
01:52:14,000 --> 01:52:15,000
他是一个完整的编程语言对吧

2807
01:52:16,000 --> 01:52:20,000
所以其实你们可以做一些相对来说很复杂的或者更加抽象的操作

2808
01:52:21,000 --> 01:52:22,000
而这些操作

2809
01:52:22,000 --> 01:52:25,000
通过点点鼠标这种图形化的方式是比较难办到的

2810
01:52:25,000 --> 01:52:26,000
比如说

2811
01:52:26,000 --> 01:52:28,000
很多人都遇到过这个难题

2812
01:52:28,000 --> 01:52:32,000
你一个目录里面就假设考虑文件情况下

2813
01:52:32,000 --> 01:52:35,000
你要批量改一堆文件的文件名

2814
01:52:35,000 --> 01:52:38,000
前面加一个前缀或者去掉一个后缀这种事情

2815
01:52:38,000 --> 01:52:39,000
你不借助一些

2816
01:52:39,000 --> 01:52:40,000
特殊的工具

2817
01:52:40,000 --> 01:52:41,000
在这个

2818
01:52:41,000 --> 01:52:44,000
图形界面里面是很难实现这一点的

2819
01:52:44,000 --> 01:52:46,000
不可能一个一个叠鼠标去改对吧

2820
01:52:46,000 --> 01:52:49,000
但是在命令行下面你其实你因为有这个语法的

2821
01:52:49,000 --> 01:52:50,000
这个一个

2822
01:52:50,000 --> 01:52:51,000
编程语言的存在

2823
01:52:51,000 --> 01:52:52,000
你只是可以对这些

2824
01:52:53,000 --> 01:52:54,000
文本做一些

2825
01:52:55,000 --> 01:52:56,000
很高级的操作

2826
01:52:57,000 --> 01:52:59,000
然后把这些操作变成一个实际可以执行的代码

2827
01:52:59,000 --> 01:53:01,000
这个代码可能就掉有一个

2828
01:53:01,000 --> 01:53:02,000
比如说 move

2829
01:53:02,000 --> 01:53:04,000
修改文件名的这么一个命令

2830
01:53:04,000 --> 01:53:05,000
去执行它

2831
01:53:05,000 --> 01:53:06,000
所以

2832
01:53:06,000 --> 01:53:07,000
这里面也是一个很重要的问题

2833
01:53:08,000 --> 01:53:09,000
但可能现在

2834
01:53:09,000 --> 01:53:14,000
图形界面里面最接近这个的应该是就是像 OS X 自带的那个 automator

2835
01:53:14,000 --> 01:53:17,000
自动化的一个工具

2836
01:53:18,000 --> 01:53:21,000
那个图标是一个机器人白色机器人拿着一个黑色的枪还是什么

2837
01:53:22,000 --> 01:53:23,000
这个管子吧

2838
01:53:24,000 --> 01:53:24,000
不是枪

2839
01:53:24,000 --> 01:53:25,000
管子对

2840
01:53:25,000 --> 01:53:26,000
黑色的管子

2841
01:53:26,000 --> 01:53:27,000
pipe

2842
01:53:27,000 --> 01:53:30,000
你可以做一些组合但是

2843
01:53:30,000 --> 01:53:34,000
一万个卖家会用这个就行

2844
01:53:34,000 --> 01:53:36,000
高阶 OS X 的用法

2845
01:53:36,000 --> 01:53:38,000
用户才会去理解

2846
01:53:38,000 --> 01:53:39,000
或者使用到的这种工具

2847
01:53:39,000 --> 01:53:43,000
我二也会用到然后他们做了一些功能其实也蛮强大的比如说他可以

2848
01:53:44,000 --> 01:53:45,000
批量的从一个

2849
01:53:47,000 --> 01:53:47,000
假设好

2850
01:53:47,000 --> 01:53:50,000
一个 pdf 文件里面抽取出多少页

2851
01:53:50,000 --> 01:53:57,000
他这么这些批量的转化成一个一个图片文件然后再单独出现的某个地方对吧或者是批量的

2852
01:53:57,000 --> 01:54:05,000
去修改一些文件图片文件比如转换格式啊改变文件大小啊再压缩这种他也也可以有

2853
01:54:05,000 --> 01:54:08,000
但是他学习曲线还是比较陡峭的

2854
01:54:08,000 --> 01:54:09,000
没错

2855
01:54:10,000 --> 01:54:13,000
当然了命令行有他自己的缺点了比如刚才讲的这个

2856
01:54:13,000 --> 01:54:15,000
就发现性比较差

2857
01:54:15,000 --> 01:54:16,000
就是如果你不知道

2858
01:54:17,000 --> 01:54:20,000
有一个功能可以用什么方式来使用就是不知道怎么用没有人会告诉你

2859
01:54:20,000 --> 01:54:23,000
不像在图形里面你必须去点到时候点到分是对吧

2860
01:54:24,000 --> 01:54:30,000
对你可以去大概找得到他在哪里如果命令行里面你找不到你不知道他在哪里你真的是你不知道他是什么

2861
01:54:31,000 --> 01:54:32,000
你真的就不知道去哪里找

2862
01:54:32,000 --> 01:54:36,000
一个笨办法就是一个一个去读这个面纽读手册嘛

2863
01:54:37,000 --> 01:54:38,000
但是有些 cash

2864
01:54:39,000 --> 01:54:44,000
有些点子是如果你没有人告诉你的话你就是不知道的对吧比如说

2865
01:54:45,000 --> 01:54:47,000
需要实践需要去累积嘛

2866
01:54:47,000 --> 01:54:49,000
对就你会需要

2867
01:54:49,000 --> 01:54:54,000
真的有一个传承有一个师傅去告诉你这个东西就是这样你得这么用不然就是不行比如说

2868
01:54:55,000 --> 01:54:56,000
从 DOS

2869
01:54:57,000 --> 01:54:59,000
命令行到 Linux

2870
01:54:59,000 --> 01:55:00,000
转换的过程中

2871
01:55:01,000 --> 01:55:04,000
你可能会遇到一个问题就是怎么样改名一个文件对吧

2872
01:55:05,000 --> 01:55:09,000
你会发现 Linux 没有 rename 这个功能你就会说我靠怎么会

2873
01:55:09,000 --> 01:55:12,000
改文件这种东西是做不到的这不可能吧

2874
01:55:12,000 --> 01:55:14,000
但是直到有人告诉你说你要 move

2875
01:55:15,000 --> 01:55:15,000
就是

2876
01:55:16,000 --> 01:55:18,000
你要移动一个文件

2877
01:55:18,000 --> 01:55:21,000
把一个东西从 A 移动到 B 的

2878
01:55:21,000 --> 01:55:25,000
工具也可以完成把一个东西从 A 命名为 B

2879
01:55:25,000 --> 01:55:25,000
这是

2880
01:55:26,000 --> 01:55:26,000
这是一个

2881
01:55:27,000 --> 01:55:28,000
需要有人告诉你这件事情对吧

2882
01:55:30,000 --> 01:55:33,000
类似的例子还有什么比如说你在 DOS 上面你

2883
01:55:33,000 --> 01:55:35,000
我觉得什么 copy

2884
01:55:35,000 --> 01:55:37,000
新点

2885
01:55:38,000 --> 01:55:39,000
新点

2886
01:55:39,000 --> 01:55:40,000
txt

2887
01:55:40,000 --> 01:55:41,000
空格新点 exe

2888
01:55:42,000 --> 01:55:42,000
你可以

2889
01:55:43,000 --> 01:55:44,000
批量的把所有的

2890
01:55:45,000 --> 01:55:45,000
那个

2891
01:55:45,000 --> 01:55:47,000
纯文本文件转换为 exe 文件

2892
01:55:48,000 --> 01:55:50,000
但在 Linux 下面这是做不到的对吧你会说我靠为什么

2893
01:55:51,000 --> 01:55:53,000
就得有一个人跟你解释这个

2894
01:55:54,000 --> 01:55:55,000
Linux 下面的这个所谓

2895
01:55:57,000 --> 01:55:58,000
Shell extension

2896
01:55:59,000 --> 01:56:01,000
这个叫什么来着

2897
01:56:02,000 --> 01:56:04,000
Interpolation

2898
01:56:04,000 --> 01:56:06,000
命令行扩展跟

2899
01:56:06,000 --> 01:56:07,000
DOS 下面的机制是不一样的

2900
01:56:08,000 --> 01:56:09,000
这很多东西

2901
01:56:09,000 --> 01:56:10,000
你都需要自己去弄明白

2902
01:56:13,000 --> 01:56:18,000
所以现在其实有网络也好啊因为如果之前我们当时

2903
01:56:19,000 --> 01:56:25,000
用命令行的时候只能看杂志上面一个小 tips 的区域对吧就非常有限的也没办法搜索的

2904
01:56:25,000 --> 01:56:28,000
现在就有很多这种网站它会

2905
01:56:28,000 --> 01:56:29,000
有那种叫做那种

2906
01:56:30,000 --> 01:56:33,000
这种小摘要的形式去告诉你说有这么一个功能

2907
01:56:33,000 --> 01:56:36,000
你可以用哪几个命令组合可以实现这么一个功能

2908
01:56:37,000 --> 01:56:37,000
比如说叫什么

2909
01:56:37,000 --> 01:56:38,000
Cabin life food

2910
01:56:39,000 --> 01:56:39,000
这个网站

2911
01:56:40,000 --> 01:56:41,000
可以做类似的事

2912
01:56:41,000 --> 01:56:44,000
我觉得那个时候学 Linux 真的是用生命在学

2913
01:56:45,000 --> 01:56:47,000
把自己的那个

2914
01:56:47,000 --> 01:56:50,000
心爱的游戏分区搞丢的危险

2915
01:56:50,000 --> 01:56:51,000
装一个 Linux

2916
01:56:51,000 --> 01:56:54,000
然后要买要从那个

2917
01:56:55,000 --> 01:57:00,000
书店里面买 Linux 的教程然后要看着杂志上面的文章一点点学

2918
01:57:00,000 --> 01:57:04,000
不像现在我开个虚拟机然后另外开个浏览器简直是

2919
01:57:05,000 --> 01:57:09,000
飞扬的一日千里可以学会我们那个时候需要一个月才能学会的东西

2920
01:57:09,000 --> 01:57:09,000
对

2921
01:57:10,000 --> 01:57:16,000
这个节目的最后我们介绍一些

2922
01:57:16,000 --> 01:57:20,000
我们觉得还挺有用的这种小工具吧就可能很多人

2923
01:57:20,000 --> 01:57:22,000
有些可能知道但

2924
01:57:22,000 --> 01:57:26,000
不一定每个你都知道对吧所以讲一下大概有什么好玩的

2925
01:57:26,000 --> 01:57:28,000
先说

2926
01:57:28,000 --> 01:57:34,000
那个就这个我们之前提到过讲在讲包管理器的时候提到过在 OS 上有一个 homebrew 的东西

2927
01:57:34,000 --> 01:57:36,000
可以帮你解决这个

2928
01:57:36,000 --> 01:57:39,000
怎么去新增这种命令工具的一个困惑

2929
01:57:39,000 --> 01:57:41,000
这个是要闭装的

2930
01:57:41,000 --> 01:57:42,000
对

2931
01:57:43,000 --> 01:57:49,000
但这个不属于命令行工具本身的我们就先略过下面开始我们一个人介绍一个

2932
01:57:49,000 --> 01:57:51,000
好我先来一个 LLcat

2933
01:57:52,000 --> 01:57:54,000
就是干嘛的

2934
01:57:54,000 --> 01:57:56,000
Linux 上面有 cat 对吧

2935
01:57:56,000 --> 01:57:58,000
就是没有 dog 但是有 cat

2936
01:57:58,000 --> 01:57:59,000
cat 是

2937
01:57:59,000 --> 01:58:02,000
猫是干嘛用的猫是输出用的

2938
01:58:02,000 --> 01:58:02,000
其实

2939
01:58:03,000 --> 01:58:06,000
猫的作用是说他

2940
01:58:07,000 --> 01:58:09,000
从他的把他的输入

2941
01:58:09,000 --> 01:58:10,000
打到输出里面

2942
01:58:10,000 --> 01:58:15,000
你可以把一个文件的内容输出到 standard out 上

2943
01:58:15,000 --> 01:58:17,000
然后那么 LLcat 是什么呢

2944
01:58:17,000 --> 01:58:18,000
是

2945
01:58:18,000 --> 01:58:19,000
是一个可以

2946
01:58:20,000 --> 01:58:21,000
把你的输出

2947
01:58:21,000 --> 01:58:23,000
用彩虹的颜色

2948
01:58:24,000 --> 01:58:25,000
输出到这个

2949
01:58:25,000 --> 01:58:29,000
把你的输入用彩虹的颜色输出到 standard out 上

2950
01:58:30,000 --> 01:58:33,000
就是在一个支持多彩的这个 shell 里面

2951
01:58:33,000 --> 01:58:36,000
shell emulator 里面

2952
01:58:36,000 --> 01:58:36,000
他可以把

2953
01:58:37,000 --> 01:58:39,000
字符按照这个

2954
01:58:39,000 --> 01:58:41,000
固定的色谱

2955
01:58:43,000 --> 01:58:44,000
用这个红橙黄绿青原子

2956
01:58:44,000 --> 01:58:46,000
就是所有颜色输出出来

2957
01:58:46,000 --> 01:58:51,000
也就是说你可能你不用用普通的 cat 的话你只会输入一个

2958
01:58:51,000 --> 01:58:52,000
单字的东西

2959
01:58:52,000 --> 01:58:54,000
但你用 LLcat 的话

2960
01:58:54,000 --> 01:58:55,000
你的

2961
01:58:55,000 --> 01:58:57,000
整个输出都会显得

2962
01:58:57,000 --> 01:58:58,000
多彩

2963
01:58:59,000 --> 01:59:03,000
所以这是一个有趣而无用的命令工具对吧

2964
01:59:03,000 --> 01:59:05,000
类似我还有很多比如说那个

2965
01:59:06,000 --> 01:59:06,000
SL

2966
01:59:07,000 --> 01:59:09,000
如果你把 ls 打成

2967
01:59:09,000 --> 01:59:11,000
SL 的话他会出一个

2968
01:59:11,000 --> 01:59:12,000
出辆火车还是什么东西

2969
01:59:13,000 --> 01:59:15,000
就是说你又打错了这种感觉

2970
01:59:18,000 --> 01:59:24,000
刚刚也提到这个叫做 Tig 的工具就 git 大家都知道是一个用于做源代码管理的一个命令行工具

2971
01:59:25,000 --> 01:59:27,000
Tig 就是把 git 反过来写

2972
01:59:28,000 --> 01:59:29,000
的话它是一个

2973
01:59:29,000 --> 01:59:31,000
基于 ncurse 的

2974
01:59:31,000 --> 01:59:34,000
显示 revision history 的

2975
01:59:34,000 --> 01:59:35,000
图形界面

2976
01:59:35,000 --> 01:59:36,000
非常有用

2977
01:59:36,000 --> 01:59:37,000
这不止 revision history 它可以显示很多东西

2978
01:59:38,000 --> 01:59:39,000
其实在里面还可以做一些

2979
01:59:39,000 --> 01:59:41,000
这叫常用的操作

2980
01:59:41,000 --> 01:59:41,000
比如什么

2981
01:59:42,000 --> 01:59:45,000
就 git 的大部分功能都可以在 Tig 里面实现

2982
01:59:46,000 --> 01:59:48,000
对所以这是一个挺好用的工具

2983
01:59:48,000 --> 01:59:50,000
有很多人说那个

2984
01:59:50,000 --> 01:59:53,000
可能从那个 svn 迁过来特别是 windows 上面程序

2985
01:59:53,000 --> 01:59:54,000
他可能觉得

2986
01:59:54,000 --> 01:59:55,000
哎呀这个

2987
01:59:55,000 --> 01:59:57,000
git 没有没有很好的这个图形化工具

2988
01:59:58,000 --> 01:59:58,000
怎么办

2989
01:59:58,000 --> 02:00:01,000
其实是有的像那么 source check 刚才提到过了

2990
02:00:01,000 --> 02:00:01,000
但是

2991
02:00:02,000 --> 02:00:05,000
像我们这种死忠的粉还是习惯于说用这种基于命令行的

2992
02:00:06,000 --> 02:00:08,000
一个基于这个文本窗口的那个工具

2993
02:00:08,000 --> 02:00:09,000
然后 Tig 是一个很好用的工具

2994
02:00:09,000 --> 02:00:15,000
我觉得 git 也是一个奇葩到没有办法做出一个好用的命令图形界面的工具

2995
02:00:17,000 --> 02:00:20,000
很多人还是用的挺好的只是说

2996
02:00:20,000 --> 02:00:21,000
很多高级功能

2997
02:00:21,000 --> 02:00:27,000
就好像我说的一样刚才那个为什么选择命令行的原因是一样的

2998
02:00:27,000 --> 02:00:32,000
git 有很多高级功能只可能在通过文本就是命令行的方式表述出来因为用

2999
02:00:32,000 --> 02:00:34,000
图形方式表述实在是太费劲了

3000
02:00:34,000 --> 02:00:36,000
图形界面表示出来就是

3001
02:00:36,000 --> 02:00:38,000
操作 git 数的话

3002
02:00:38,000 --> 02:00:41,000
我其实能够想到最符合直觉的一种方法就是

3003
02:00:42,000 --> 02:00:44,000
你可以直接去拖拽那个

3004
02:00:44,000 --> 02:00:46,000
branch 里面的节点

3005
02:00:46,000 --> 02:00:48,000
然后让他在你想要去的那个地方

3006
02:00:49,000 --> 02:00:50,000
停留下来然后松手

3007
02:00:51,000 --> 02:00:54,000
然后这个图形界面的工具就自动帮你完成

3008
02:00:54,000 --> 02:00:57,000
对应的 git 操作这个才是最符合直觉化的一个实现

3009
02:00:57,000 --> 02:01:02,000
现有的大部分的图形工具只不过是把那些

3010
02:01:02,000 --> 02:01:04,000
命令行的命令封装成一个一个按钮而已

3011
02:01:05,000 --> 02:01:06,000
你还是没有办法直接

3012
02:01:06,000 --> 02:01:07,000
看到

3013
02:01:07,000 --> 02:01:10,000
执行这些命令之后那个 source tree 会变成什么样子

3014
02:01:12,000 --> 02:01:17,000
还有就是那个就是可组合性和这个表达到这个抽象层级的问题

3015
02:01:17,000 --> 02:01:19,000
始终那种可视化的

3016
02:01:19,000 --> 02:01:20,000
抽象层级是

3017
02:01:21,000 --> 02:01:23,000
要相比语言描述的还是要低

3018
02:01:24,000 --> 02:01:24,000
低很多的

3019
02:01:27,000 --> 02:01:28,000
低一个 order

3020
02:01:29,000 --> 02:01:31,000
下一个你有什么介绍的

3021
02:01:32,000 --> 02:01:35,000
我可以介绍 cousei

3022
02:01:36,000 --> 02:01:37,000
又是一个

3023
02:01:37,000 --> 02:01:39,000
有权有什么用

3024
02:01:39,000 --> 02:01:41,000
对 cousei 有一个

3025
02:01:41,000 --> 02:01:42,000
有一个变种叫 cousei

3026
02:01:43,000 --> 02:01:48,000
你 brew install causei 之后你会得到两个命令一个叫 cousei

3027
02:01:49,000 --> 02:01:51,000
然后结果就是他会把你的输出

3028
02:01:52,000 --> 02:01:54,000
包裹到一个漫画的那种

3029
02:01:55,000 --> 02:01:56,000
把你的输入

3030
02:01:56,000 --> 02:01:58,000
包裹到一个漫画的那种

3031
02:01:58,000 --> 02:02:01,000
响或者是说的气泡框里面

3032
02:02:01,000 --> 02:02:03,000
然后下面画一头牛

3033
02:02:04,000 --> 02:02:05,000
这就是这个用途

3034
02:02:05,000 --> 02:02:06,000
就是牛说

3035
02:02:07,000 --> 02:02:09,000
然后另外有一个工具叫做 fortune

3036
02:02:09,000 --> 02:02:10,000
跟你说一句

3037
02:02:11,000 --> 02:02:13,000
其实就是那种中餐馆里面的那个

3038
02:02:14,000 --> 02:02:15,000
小 cookie 里面

3039
02:02:15,000 --> 02:02:16,000
fortune cookie

3040
02:02:16,000 --> 02:02:17,000
一个小纸条大概是那个意思

3041
02:02:18,000 --> 02:02:20,000
然后他会跟你说很多名人名言

3042
02:02:20,000 --> 02:02:21,000
然后你把 fortune

3043
02:02:22,000 --> 02:02:23,000
从名相到 cousei

3044
02:02:24,000 --> 02:02:25,000
他就会把名人名言包裹到一个

3045
02:02:26,000 --> 02:02:28,000
bubble 里面然后让牛说出来

3046
02:02:29,000 --> 02:02:34,000
就是那个中餐馆的小 cookie 这个事情应该是只有在国外的人才会知道这个梗

3047
02:02:34,000 --> 02:02:36,000
在国外的中餐馆

3048
02:02:36,000 --> 02:02:36,000
somehow somehow

3049
02:02:37,000 --> 02:02:38,000
会提供一种非常

3050
02:02:39,000 --> 02:02:40,000
特别的

3051
02:02:40,000 --> 02:02:43,000
在你结账的时候会给你一个小 cookie

3052
02:02:43,000 --> 02:02:45,000
然后 cookie 其实是非常难吃的一种饼干

3053
02:02:46,000 --> 02:02:46,000
只不过这个 cookie

3054
02:02:47,000 --> 02:02:47,000
我觉得还挺好吃的

3055
02:02:48,000 --> 02:02:49,000
What

3056
02:02:49,000 --> 02:02:51,000
我头一次遇到喜欢吃 fortune cookie 的人

3057
02:02:52,000 --> 02:02:55,000
脆脆的嘛挺好吃的

3058
02:02:55,000 --> 02:02:57,000
然后这个 fortune cookie 它是空心的对吧

3059
02:02:58,000 --> 02:03:00,000
空心的然后你把它打开里面有一个小纸条

3060
02:03:01,000 --> 02:03:02,000
上面有句话

3061
02:03:03,000 --> 02:03:04,000
对有时候是

3062
02:03:04,000 --> 02:03:05,000
中英文的

3063
02:03:05,000 --> 02:03:06,000
这种自然的德国人

3064
02:03:06,000 --> 02:03:07,000
学大部分都是中英文的

3065
02:03:07,000 --> 02:03:08,000
英德文的

3066
02:03:09,000 --> 02:03:10,000
一边是英文一边是德文

3067
02:03:10,000 --> 02:03:11,000
对对对对

3068
02:03:11,000 --> 02:03:12,000
北美就是中英文

3069
02:03:13,000 --> 02:03:15,000
对会给你一句小格言

3070
02:03:15,000 --> 02:03:15,000
比如什么

3071
02:03:16,000 --> 02:03:17,000
举个例子

3072
02:03:17,000 --> 02:03:18,000
一时想不起来

3073
02:03:19,000 --> 02:03:20,000
我一时想不起来

3074
02:03:21,000 --> 02:03:21,000
反正就是

3075
02:03:22,000 --> 02:03:24,000
就是有一种

3076
02:03:25,000 --> 02:03:26,000
真言

3077
02:03:26,000 --> 02:03:28,000
不是名言是真言吧那个叫什么

3078
02:03:29,000 --> 02:03:33,000
就是他会讲一个看似很有道理的一句话但是这是没有什么软用

3079
02:03:33,000 --> 02:03:34,000
会讲一句有趣而无用的话

3080
02:03:35,000 --> 02:03:36,000
对差不多这个意思

3081
02:03:36,000 --> 02:03:37,000
对

3082
02:03:37,000 --> 02:03:40,000
然后 fortune 这个软件差不多是干类似的事情

3083
02:03:42,000 --> 02:03:44,000
下面一个

3084
02:03:44,000 --> 02:03:48,000
挺有用的一个命令行工具的 MTR

3085
02:03:49,000 --> 02:03:51,000
这个是干嘛这可能

3086
02:03:51,000 --> 02:03:52,000
做网络或者是

3087
02:03:52,000 --> 02:03:55,000
你对网络状况比这个要

3088
02:03:55,000 --> 02:03:58,000
这个有研究就是互联网计算机网络

3089
02:03:58,000 --> 02:04:01,000
有研究的人会经常用到有两个工具一个叫 trace root

3090
02:04:02,000 --> 02:04:02,000
一个是叫 pin 嘛

3091
02:04:03,000 --> 02:04:06,000
pin 是测这个延迟然后 trace root 是测这个

3092
02:04:06,000 --> 02:04:08,000
你跳转的你从

3093
02:04:08,000 --> 02:04:14,000
你的电脑到另外一个服务器之间要经过哪些这种中间的路由或者是这个网关

3094
02:04:15,000 --> 02:04:15,000
对吧

3095
02:04:16,000 --> 02:04:16,000
然后

3096
02:04:17,000 --> 02:04:22,000
MTR 是把这两个工具的功能合而为一并且一种更加友善和有用的方式

3097
02:04:23,000 --> 02:04:24,000
汇报出来的一个

3098
02:04:24,000 --> 02:04:25,000
这种网络

3099
02:04:26,000 --> 02:04:27,000
诊断工具

3100
02:04:28,000 --> 02:04:28,000
集合

3101
02:04:29,000 --> 02:04:29,000
对

3102
02:04:29,000 --> 02:04:32,000
Math trace root

3103
02:04:32,000 --> 02:04:34,000
Math 的 trace root

3104
02:04:34,000 --> 02:04:36,000
对那个 Math 作者

3105
02:04:36,000 --> 02:04:37,000
对

3106
02:04:37,000 --> 02:04:41,000
那你接下来一个叫做 pray 你介绍一下是什么玩意

3107
02:04:43,000 --> 02:04:46,000
pray 和 ipython 我想放在一起介绍

3108
02:04:47,000 --> 02:04:51,000
python 用户一定要使用 ipython 这个东西而不是使用 python

3109
02:04:51,000 --> 02:04:54,000
默认给你装那个老牙牙的 idle

3110
02:04:54,000 --> 02:04:56,000
ipython 是一个

3111
02:04:57,000 --> 02:05:03,000
既可以在命令行下面跑也可以有一个专属的网页版本或者乃至于一个

3112
02:05:04,000 --> 02:05:06,000
基于 Qt 的图形界面的一个

3113
02:05:06,000 --> 02:05:08,000
全功能 python 笔记本

3114
02:05:08,000 --> 02:05:11,000
你可以在里面运行 python 的程序

3115
02:05:12,000 --> 02:05:14,000
你可以在里面尝试 python 的各种新功能

3116
02:05:15,000 --> 02:05:21,000
而且你的每一次输入和每一次输出都会被记在 in 和 out 两个 array 里面你可以随时去查询

3117
02:05:22,000 --> 02:05:23,000
然后它还内置了很多

3118
02:05:24,000 --> 02:05:26,000
其他的功能比如什么语法高量啊

3119
02:05:28,000 --> 02:05:30,000
那个 trace root

3120
02:05:30,000 --> 02:05:31,000
call stack

3121
02:05:33,000 --> 02:05:34,000
backtrace

3122
02:05:35,000 --> 02:05:35,000
backtrace

3123
02:05:36,000 --> 02:05:39,000
然后 pride 就是

3124
02:05:40,000 --> 02:05:41,000
Ruby 的 ipython

3125
02:05:42,000 --> 02:05:44,000
两个也是非常有用

3126
02:05:45,000 --> 02:05:47,000
刚才讲到那个 ipython 我还推荐一个叫做 bpython

3127
02:05:47,000 --> 02:05:49,000
就是 AB 的 b

3128
02:05:50,000 --> 02:05:52,000
ipython 它也是一个这个

3129
02:05:52,000 --> 02:05:53,000
就是

3130
02:05:53,000 --> 02:05:54,000
python 的一个叫做 repl

3131
02:05:55,000 --> 02:05:55,000
read

3132
02:05:55,000 --> 02:05:56,000
evaluate

3133
02:05:56,000 --> 02:05:57,000
print loop

3134
02:05:57,000 --> 02:05:58,000
这么一个工具

3135
02:05:58,000 --> 02:06:00,000
bpython 是一个替代的 repl

3136
02:06:00,000 --> 02:06:01,000
它的好处是什么呢

3137
02:06:02,000 --> 02:06:02,000
它

3138
02:06:03,000 --> 02:06:04,000
首先它有语法高量

3139
02:06:04,000 --> 02:06:05,000
对 python 语法

3140
02:06:05,000 --> 02:06:06,000
它是你敲的这个

3141
02:06:06,000 --> 02:06:07,000
每一行它是语法高量的

3142
02:06:08,000 --> 02:06:09,000
它的多行模式也

3143
02:06:09,000 --> 02:06:11,000
比较支持比 ipython 好

3144
02:06:11,000 --> 02:06:13,000
然后它觉得最有用的功能它会对

3145
02:06:13,000 --> 02:06:16,000
你打的这个标准库里面的函数它是有这个

3146
02:06:17,000 --> 02:06:21,000
就是那个叫什么类似于一个 ID 它是有提示那个函数的一个签名

3147
02:06:21,000 --> 02:06:22,000
以及每个参数是干什么用的

3148
02:06:23,000 --> 02:06:23,000
OK

3149
02:06:24,000 --> 02:06:25,000
就非常非常好用

3150
02:06:25,000 --> 02:06:26,000
而且它的那个

3151
02:06:26,000 --> 02:06:27,000
没有 ipython 那么

3152
02:06:27,000 --> 02:06:29,000
功能丰富但是一个更加

3153
02:06:30,000 --> 02:06:32,000
轻量级的这么一个 repl

3154
02:06:32,000 --> 02:06:33,000
对

3155
02:06:33,000 --> 02:06:34,000
ipython 我相信

3156
02:06:34,000 --> 02:06:36,000
如果你有是要做一些什么

3157
02:06:36,000 --> 02:06:37,000
或者是计算或者是

3158
02:06:38,000 --> 02:06:39,000
生物

3159
02:06:39,000 --> 02:06:40,000
信息学之类的

3160
02:06:40,000 --> 02:06:41,000
做科研

3161
02:06:41,000 --> 02:06:42,000
基本上是

3162
02:06:42,000 --> 02:06:44,000
对人手必装

3163
02:06:44,000 --> 02:06:45,000
对

3164
02:06:45,000 --> 02:06:48,000
我在介绍一个叫做 iperf 3

3165
02:06:49,000 --> 02:06:52,000
这也是一个做网络性能的测试的一个工具

3166
02:06:52,000 --> 02:06:53,000
就是说假设

3167
02:06:53,000 --> 02:06:54,000
你想测

3168
02:06:54,000 --> 02:06:55,000
比如你们家刚装修房子

3169
02:06:55,000 --> 02:06:56,000
你想测

3170
02:06:56,000 --> 02:07:00,000
这个装修师傅给你装的网线是否达到千兆的一个

3171
02:07:00,000 --> 02:07:03,000
一个速度对吧

3172
02:07:03,000 --> 02:07:03,000
你怎么办

3173
02:07:04,000 --> 02:07:05,000
你找两台电脑都插上网线对吧

3174
02:07:06,000 --> 02:07:08,000
然后在一头运行一个 ipython 3

3175
02:07:08,000 --> 02:07:09,000
的一个 server

3176
02:07:09,000 --> 02:07:12,000
然后在另外一头运行 ipython 3 的一个客户端

3177
02:07:12,000 --> 02:07:13,000
一个 client

3178
02:07:13,000 --> 02:07:14,000
然后把这个 client 指向那个 server

3179
02:07:15,000 --> 02:07:16,000
他就会在这两端

3180
02:07:16,000 --> 02:07:20,000
发起一个连接然后测试这个连接

3181
02:07:21,000 --> 02:07:24,000
能最大以多快的速度传输

3182
02:07:24,000 --> 02:07:24,000
对吧

3183
02:07:25,000 --> 02:07:25,000
OK

3184
02:07:25,000 --> 02:07:28,000
它是一个测试这个网络连通速度的这么一个小工具

3185
02:07:29,000 --> 02:07:32,000
3 是一个最新的版本还有一个 ipyperf

3186
02:07:32,000 --> 02:07:34,000
没有数字就是默认是 2 这个版本

3187
02:07:34,000 --> 02:07:35,000
相对老一点

3188
02:07:35,000 --> 02:07:36,000
就看你的发行本

3189
02:07:36,000 --> 02:07:37,000
的区别

3190
02:07:38,000 --> 02:07:38,000
OK

3191
02:07:38,000 --> 02:07:41,000
那接下来我再介绍一个 Tmux

3192
02:07:41,000 --> 02:07:44,000
就是刚才已经提到了是一个中端附用器

3193
02:07:44,000 --> 02:07:49,000
就是你可能连接到一个远程计算机上或者说你在本地然后你开了一个 terminal 窗口

3194
02:07:50,000 --> 02:07:53,000
你会觉得说我还想做另外一件事情怎么办

3195
02:07:53,000 --> 02:07:56,000
一个选择是再开一个窗口或者再建立一个连接

3196
02:07:56,000 --> 02:07:57,000
而比较

3197
02:07:57,000 --> 02:08:01,000
好的一个方法就是附用你当前已经

3198
02:08:01,000 --> 02:08:02,000
建立的连接

3199
02:08:03,000 --> 02:08:05,000
可以装 Tmux 这个东西它可以

3200
02:08:05,000 --> 02:08:06,000
通过一些

3201
02:08:07,000 --> 02:08:07,000
这个

3202
02:08:07,000 --> 02:08:10,000
组合件让你在一个 terminal 的窗口里面

3203
02:08:11,000 --> 02:08:13,000
开很多个其他 terminal 的窗口

3204
02:08:13,000 --> 02:08:19,000
可能描述比较抽象但如果你去这个 Tmux 的网站上看一下你会很会明白

3205
02:08:19,000 --> 02:08:19,000
这个什么意思

3206
02:08:20,000 --> 02:08:22,000
其实这个有个最大的好处你知道是什么吗

3207
02:08:22,000 --> 02:08:25,000
就是它可以保持你的一个登录状态

3208
02:08:26,000 --> 02:08:28,000
就是你保持成熟的一体状态

3209
02:08:28,000 --> 02:08:30,000
对你可以在意赛机上用 Tmux 来

3210
02:08:30,000 --> 02:08:32,000
执行一个命令然后

3211
02:08:32,000 --> 02:08:34,000
detach from the Tmux

3212
02:08:34,000 --> 02:08:35,000
然后回家

3213
02:08:35,000 --> 02:08:37,000
关掉那个和那个机器的连接

3214
02:08:38,000 --> 02:08:43,000
然后但是这个时候在你刚刚起到那个进程它是不会

3215
02:08:43,000 --> 02:08:47,000
不会退出的因为正常情况下你断掉一个连接之后那个进程就退出了嘛

3216
02:08:47,000 --> 02:08:51,000
除非你之前什么因为很复杂操作

3217
02:08:51,000 --> 02:08:52,000
disowned

3218
02:08:52,000 --> 02:08:53,000
现在

3219
02:08:53,000 --> 02:08:54,000
background

3220
02:08:54,000 --> 02:08:54,000
然后 disowned

3221
02:08:55,000 --> 02:08:56,000
然后你才不会

3222
02:08:57,000 --> 02:08:59,000
在你退出的时候终止这个程序

3223
02:08:59,000 --> 02:09:00,000
但一般人不会那么干嘛

3224
02:09:01,000 --> 02:09:01,000
对

3225
02:09:01,000 --> 02:09:02,000
除非事后想到

3226
02:09:04,000 --> 02:09:04,000
对

3227
02:09:04,000 --> 02:09:09,000
所以你用这个 Tmux 的话它是你退出的时候它是直接断掉和 Tmux

3228
02:09:09,000 --> 02:09:12,000
这个 master 进程的连接

3229
02:09:12,000 --> 02:09:15,000
它还会继续接管你在里面 launch 的那些

3230
02:09:15,000 --> 02:09:16,000
子进程

3231
02:09:16,000 --> 02:09:20,000
等你回家再连上这个时候你可以用那个 Tmux 空格 A

3232
02:09:20,000 --> 02:09:21,000
attach 这个

3233
02:09:22,000 --> 02:09:22,000
参数

3234
02:09:22,000 --> 02:09:26,000
重新连回之前的那个 Tmux 的这个 master 进程

3235
02:09:26,000 --> 02:09:27,000
这个时候你会看到

3236
02:09:28,000 --> 02:09:31,000
和你断开之前一模一样的这么远端登录的建盘

3237
02:09:31,000 --> 02:09:32,000
而你之前在

3238
02:09:32,000 --> 02:09:33,000
执行的那个

3239
02:09:33,000 --> 02:09:35,000
可能那个程序可能时间比较长的话

3240
02:09:36,000 --> 02:09:37,000
它是不会

3241
02:09:37,000 --> 02:09:38,000
受任何影响的

3242
02:09:39,000 --> 02:09:41,000
对然后另外一个用例就是比如说你是一个

3243
02:09:42,000 --> 02:09:46,000
实验室的学生然后你实验室里面有台电脑然后你的工作办公室里面有台电脑

3244
02:09:46,000 --> 02:09:48,000
你需要在实验室里面

3245
02:09:48,000 --> 02:09:50,000
观测一些数据然后输入到电脑上

3246
02:09:50,000 --> 02:09:52,000
然后你要么用远程周辨

3247
02:09:53,000 --> 02:09:54,000
对吧要么就用 Tmux

3248
02:09:54,000 --> 02:09:55,000
然后在

3249
02:09:55,000 --> 02:10:00,000
实验室的电脑上看到的东西会实时显示在你办公室的电脑上

3250
02:10:00,000 --> 02:10:01,000
也挺好

3251
02:10:02,000 --> 02:10:02,000
对

3252
02:10:03,000 --> 02:10:03,000
当然 Tmux

3253
02:10:03,000 --> 02:10:07,000
还有一个兄弟叫做 screen

3254
02:10:07,000 --> 02:10:08,000
就是屏幕那个词的

3255
02:10:08,000 --> 02:10:10,000
早期的这个

3256
02:10:10,000 --> 02:10:11,000
一个一个中端附用

3257
02:10:12,000 --> 02:10:18,000
那 screen 的特性没有 Tmux 的那么强大好用现在就基本上都推荐大家用 Tmux 会好一些了

3258
02:10:18,000 --> 02:10:22,000
Screen 它古老的主要是而且好像不能分

3259
02:10:22,000 --> 02:10:24,000
就是分 type 吧

3260
02:10:24,000 --> 02:10:29,000
可以分 type 它最早的版本是不能分那个左右分屏

3261
02:10:30,000 --> 02:10:32,000
对我就是这个就是不能 split view

3262
02:10:32,000 --> 02:10:33,000
但现在现在

3263
02:10:33,000 --> 02:10:34,000
新版本是可以的了

3264
02:10:35,000 --> 02:10:41,000
但只是因为搭载 screen 一般都是比较老旧的版本嘛所以这个就很难保证就 Tmux 的特性

3265
02:10:41,000 --> 02:10:42,000
大概会好一些

3266
02:10:42,000 --> 02:10:43,000
没错

3267
02:10:43,000 --> 02:10:48,000
Tmux 还有个很高级的功能就一直没有说

3268
02:10:48,000 --> 02:10:50,000
Screen 也有这个功能就是可以做那个

3269
02:10:51,000 --> 02:10:52,000
Pair programming

3270
02:10:53,000 --> 02:10:54,000
对没错

3271
02:10:54,000 --> 02:10:55,000
就是可以两个人连到同一个

3272
02:10:56,000 --> 02:10:56,000
输入对

3273
02:10:56,000 --> 02:11:03,000
对你可以两个人从分别从自己的机器连到同一台服务器然后调用一个 Tmux 的一个

3274
02:11:03,000 --> 02:11:04,000
一个一个终端

3275
02:11:04,000 --> 02:11:09,000
就大家互相可以看见对方在那个里面打什么也可以就是进行一对一的这么一种

3276
02:11:09,000 --> 02:11:11,000
辅导师教学

3277
02:11:12,000 --> 02:11:13,000
只不过容易打架啊

3278
02:11:13,000 --> 02:11:16,000
这个就是你要自己约定好到底是谁教谁学吧

3279
02:11:17,000 --> 02:11:18,000
最好能协同一下

3280
02:11:19,000 --> 02:11:21,000
对就是两个做这种 pair pro

3281
02:11:21,000 --> 02:11:25,000
结对编程对吧 Pair programming 比较有用的一个工具

3282
02:11:26,000 --> 02:11:28,000
我再介绍一个叫做 Tree

3283
02:11:28,000 --> 02:11:32,000
就是树那个那个工具这个是干嘛用的呢就是说

3284
02:11:33,000 --> 02:11:34,000
你在命令行里面你要去

3285
02:11:35,000 --> 02:11:37,000
你要去就是 Navigate file system

3286
02:11:37,000 --> 02:11:42,000
就是你要在文件系统里面去看来看东西到底哪个文件在哪你在哪个结构里面对吧

3287
02:11:43,000 --> 02:11:44,000
经常常用的是 list 嘛

3288
02:11:45,000 --> 02:11:46,000
就是或者

3289
02:11:46,000 --> 02:11:46,000
就是

3290
02:11:47,000 --> 02:11:47,000
就是 list

3291
02:11:48,000 --> 02:11:50,000
就是列表一个目录里面的文件

3292
02:11:50,000 --> 02:11:52,000
但 list 一般只能列一层嘛

3293
02:11:53,000 --> 02:11:56,000
就是你只能看当前或者某个指定目录下面的这个文件列表但是

3294
02:11:57,000 --> 02:11:58,000
你是看不到这个整个

3295
02:11:58,000 --> 02:12:01,000
文件因为文件系统是一个整个是个树状结构嘛你是

3296
02:12:02,000 --> 02:12:03,000
不能用 list 看到整个

3297
02:12:03,000 --> 02:12:04,000
一个树状结构怎么样子的

3298
02:12:04,000 --> 02:12:08,000
然后 Tree 这个这个小工具就可以做这个事

3299
02:12:08,000 --> 02:12:10,000
他会把这个文件系统

3300
02:12:10,000 --> 02:12:12,000
从你指定的层开始

3301
02:12:12,000 --> 02:12:15,000
一个树的形式把它打印到这个

3302
02:12:15,000 --> 02:12:16,000
这个终端窗口上面去

3303
02:12:17,000 --> 02:12:19,000
那你可以比较直观的看到

3304
02:12:19,000 --> 02:12:21,000
你的这个就比如整个这个

3305
02:12:22,000 --> 02:12:23,000
代码的工程目录里面的

3306
02:12:23,000 --> 02:12:24,000
文件结构是怎么样子

3307
02:12:25,000 --> 02:12:26,000
还比较有用

3308
02:12:27,000 --> 02:12:31,000
那我也来顺便推荐一个 Midnight Commander

3309
02:12:31,000 --> 02:12:32,000
OK

3310
02:12:33,000 --> 02:12:36,000
因为这也是从 Tree 想到了就是

3311
02:12:36,000 --> 02:12:41,000
Total Commander 是 DOS 时代乃至 Windows 时代非常受欢迎的一个文件关于工具

3312
02:12:41,000 --> 02:12:45,000
后来有好事者把它移植成了一个

3313
02:12:45,000 --> 02:12:48,000
Command Line Interface 的这么一个东西

3314
02:12:48,000 --> 02:12:50,000
就是你输入 MC

3315
02:12:50,000 --> 02:12:51,000
就会出现一个

3316
02:12:51,000 --> 02:12:54,000
类似于那个 Total Commander 的一个

3317
02:12:54,000 --> 02:12:55,000
一个

3318
02:12:55,000 --> 02:12:56,000
全屏的工具

3319
02:12:56,000 --> 02:12:57,000
也是 Ncurse

3320
02:12:57,000 --> 02:13:01,000
然后里面也有什么比如说列出当前命令数啊

3321
02:13:01,000 --> 02:13:03,000
批量拷贝啊

3322
02:13:03,000 --> 02:13:04,000
批量重用名啊之类的功能

3323
02:13:05,000 --> 02:13:07,000
然后如果你是一个熟练的

3324
02:13:08,000 --> 02:13:09,000
Total Commander 用户的话

3325
02:13:10,000 --> 02:13:12,000
你会发现里面很多很多的操作是一模一样

3326
02:13:14,000 --> 02:13:16,000
而且这个东西最大的一个特征

3327
02:13:16,000 --> 02:13:17,000
它是跨平台的

3328
02:13:17,000 --> 02:13:18,000
就是它在

3329
02:13:19,000 --> 02:13:21,000
Linux 和 DOS 上面都有

3330
02:13:22,000 --> 02:13:23,000
蛮特别的

3331
02:13:25,000 --> 02:13:29,000
我推荐另外一个系统管理用的工具叫做 Htop

3332
02:13:30,000 --> 02:13:32,000
很多系统很多这个 Unix 里面都有一个内容

3333
02:13:33,000 --> 02:13:34,000
内建的命令叫做 Top

3334
02:13:34,000 --> 02:13:37,000
然后它会以一个 Ncurse 的方式列出

3335
02:13:38,000 --> 02:13:41,000
当前系统里面正在活跃的进程

3336
02:13:41,000 --> 02:13:44,000
以及一些系统的状态比如说这个 CPU 的占用啊

3337
02:13:44,000 --> 02:13:46,000
这个就是

3338
02:13:46,000 --> 02:13:49,000
各个用户带内核带各个占用的比例啊

3339
02:13:49,000 --> 02:13:51,000
内存的使用状况啊

3340
02:13:51,000 --> 02:13:54,000
活跃的一些进程的使用资源的情况这些

3341
02:13:54,000 --> 02:13:58,000
但是 Top 的一个主要问题就是它展示的是一个单色而且

3342
02:13:58,000 --> 02:13:59,000
就不

3343
02:13:59,000 --> 02:14:00,000
操作不方便的一个键

3344
02:14:00,000 --> 02:14:01,000
不够好看

3345
02:14:01,000 --> 02:14:02,000
不好看也不好用

3346
02:14:03,000 --> 02:14:05,000
Htop 就是一个 Top 的就是一个

3347
02:14:06,000 --> 02:14:06,000
改良版

3348
02:14:07,000 --> 02:14:12,000
它可以以一种更加直观易懂的方式展现出这个 Top 展现的所有内容

3349
02:14:12,000 --> 02:14:14,000
并且它比如说它会展示在

3350
02:14:14,000 --> 02:14:17,000
Jump 1 的情况下它会展示这个 CPU 它会有一种

3351
02:14:17,000 --> 02:14:18,000
进度调的方式

3352
02:14:19,000 --> 02:14:22,000
去表示这个 CPU 的实际占用比例

3353
02:14:22,000 --> 02:14:23,000
以及这个内存的

3354
02:14:24,000 --> 02:14:25,000
占用情况

3355
02:14:25,000 --> 02:14:32,000
而且它下面的那个那个就是进程列表它也有各种各样的高级功能比如它可以以一个竖状的结构

3356
02:14:32,000 --> 02:14:33,000
展示这个

3357
02:14:33,000 --> 02:14:35,000
进程列表而不是一个单纯的

3358
02:14:35,000 --> 02:14:36,000
对就是

3359
02:14:36,000 --> 02:14:37,000
非常建议大家

3360
02:14:38,000 --> 02:14:41,000
这是我每次装新系统的时候都必装的一个

3361
02:14:42,000 --> 02:14:42,000
一个软件

3362
02:14:43,000 --> 02:14:47,000
大致的作用跟大家看到那个叫 Activity Monitor 在 OS X 这个功能是差不多的

3363
02:14:48,000 --> 02:14:50,000
只不过是在命令行下面

3364
02:14:50,000 --> 02:14:51,000
每次

3365
02:14:52,000 --> 02:14:54,000
然后很多人做他们的那个

3366
02:14:54,000 --> 02:14:57,000
当前命令行的截图都会专门

3367
02:14:58,000 --> 02:14:59,000
找一个窗口开这个

3368
02:15:01,000 --> 02:15:02,000
也算是一个现象

3369
02:15:03,000 --> 02:15:04,000
对

3370
02:15:08,000 --> 02:15:10,000
那我来推荐一个

3371
02:15:11,000 --> 02:15:13,000
我来推荐一个命令嘛叫做 Open

3372
02:15:13,000 --> 02:15:14,000
或者是

3373
02:15:15,000 --> 02:15:20,000
或者说我来推荐一组这个在 OS X 上面

3374
02:15:21,000 --> 02:15:24,000
在命令行下面工作的时候你可能会

3375
02:15:25,000 --> 02:15:29,000
出现一些比如说你要把命令某一个文件内容或者是某些输出

3376
02:15:31,000 --> 02:15:33,000
弄到系统剪贴板上的

3377
02:15:33,000 --> 02:15:39,000
场景或者你需要把系统的剪贴板的内容输入到某一个命令的

3378
02:15:39,000 --> 02:15:40,000
输入里面

3379
02:15:40,000 --> 02:15:45,000
或者你需要利用系统级的一个工具比如说你要打开一个 PDF

3380
02:15:47,000 --> 02:15:47,000
怎么办呢

3381
02:15:48,000 --> 02:15:49,000
你可以用

3382
02:15:49,000 --> 02:15:50,000
首先

3383
02:15:51,000 --> 02:15:56,000
剪贴板的话你可以用 PB copy 和 PB paste 的两个命令

3384
02:15:56,000 --> 02:16:00,000
分别可以把这个剪贴板里面的东西

3385
02:16:00,000 --> 02:16:02,000
拷贝或者是粘贴出来

3386
02:16:03,000 --> 02:16:05,000
如果你想打开某一个文件的话你可以用 Open 这个命令

3387
02:16:05,000 --> 02:16:06,000
比如说

3388
02:16:07,000 --> 02:16:10,000
你想要在 Finder 里面观察当前的目录

3389
02:16:11,000 --> 02:16:12,000
你可以 Open 空格点

3390
02:16:12,000 --> 02:16:15,000
就可以打开就可以在 Finder 里面打开当前目录

3391
02:16:16,000 --> 02:16:19,000
如果你想要打开当前目录下面所有的 PDF 文件

3392
02:16:20,000 --> 02:16:22,000
你可以打 Open 新.pdf

3393
02:16:23,000 --> 02:16:27,000
系统会自动调用 preview 或者是 Adobe reader

3394
02:16:28,000 --> 02:16:30,000
取决于你选择的默认程序是什么

3395
02:16:30,000 --> 02:16:32,000
来打开所有的 PDF 文件

3396
02:16:33,000 --> 02:16:34,000
算是一个小 team

3397
02:16:36,000 --> 02:16:40,000
那个 PB copy 和 PB paste 用法可能还要再解释一下

3398
02:16:43,000 --> 02:16:46,000
就是 PB copy 这个命令的

3399
02:16:46,000 --> 02:16:47,000
输入

3400
02:16:47,000 --> 02:16:49,000
你需要把你的

3401
02:16:49,000 --> 02:16:52,000
程序的输出重定向给 PB copy

3402
02:16:52,000 --> 02:16:53,000
对

3403
02:16:53,000 --> 02:16:59,000
他是只从他的输入复制到系统剪贴板里面嘛

3404
02:17:00,000 --> 02:17:01,000
然后 PB paste 就刚好反过来

3405
02:17:01,000 --> 02:17:02,000
他是把他的

3406
02:17:02,000 --> 02:17:03,000
系统剪贴板

3407
02:17:03,000 --> 02:17:04,000
导到他的输出里面去

3408
02:17:05,000 --> 02:17:07,000
所以用法肯定就是说是

3409
02:17:07,000 --> 02:17:08,000
从 PB 导入

3410
02:17:09,000 --> 02:17:12,000
就是内容导到 PB copy 里面去然后从 PB paste 里面导出

3411
02:17:12,000 --> 02:17:13,000
这么一个

3412
02:17:13,000 --> 02:17:14,000
管道的

3413
02:17:14,000 --> 02:17:16,000
比如说你在网页上选中了一段话

3414
02:17:16,000 --> 02:17:18,000
然后你要把这段话排序

3415
02:17:18,000 --> 02:17:22,000
你可以先选中这段话按 command C

3416
02:17:23,000 --> 02:17:24,000
然后在命令行下面

3417
02:17:24,000 --> 02:17:26,000
打 PB paste pipe

3418
02:17:26,000 --> 02:17:28,000
sort pipe pb copy

3419
02:17:28,000 --> 02:17:30,000
然后你就把这个

3420
02:17:31,000 --> 02:17:32,000
剪贴板里面的内容排序

3421
02:17:33,000 --> 02:17:34,000
大概是这么一步

3422
02:17:35,000 --> 02:17:37,000
行那这个命令就介绍到这里吧

3423
02:17:37,000 --> 02:17:40,000
以上介绍的所有命令都

3424
02:17:40,000 --> 02:17:44,000
除了刚才讲的那个就是 OS X 原生的 PB copy PB paste open 之外

3425
02:17:45,000 --> 02:17:47,000
都希望你额外装

3426
02:17:47,000 --> 02:17:51,000
都不是系统自带的你就需要通过这个比如 homebrew 的方式去自己装

3427
02:17:52,000 --> 02:17:54,000
如果你是其他类 unix 系统的话

3428
02:17:54,000 --> 02:17:58,000
你可以用你自己的包管理器去装这个工具

3429
02:17:58,000 --> 02:17:59,000
对

3430
02:17:59,000 --> 02:18:02,000
我们今天的这个节目就到此为止了

3431
02:18:03,000 --> 02:18:04,000
好真的说了好多

3432
02:18:05,000 --> 02:18:08,000
这真是可以拆成两期的节目

3433
02:18:10,000 --> 02:18:10,000
好吧

3434
02:18:10,000 --> 02:18:11,000
反正

3435
02:18:11,000 --> 02:18:13,000
关于这个命令行的这个

3436
02:18:13,000 --> 02:18:15,000
所谓 command line full

3437
02:18:15,000 --> 02:18:17,000
command line 空付的这个名字的东西

3438
02:18:17,000 --> 02:18:17,000
这是

3439
02:18:18,000 --> 02:18:19,000
说之不尽啊

3440
02:18:19,000 --> 02:18:21,000
不妨推荐大家去这个

3441
02:18:22,000 --> 02:18:24,000
commandline full.com

3442
02:18:24,000 --> 02:18:26,000
这个名是怎么来的呢

3443
02:18:26,000 --> 02:18:27,000
就是外国人

3444
02:18:27,000 --> 02:18:29,000
不明白空付这个词是什么意思

3445
02:18:29,000 --> 02:18:29,000
他们会把

3446
02:18:30,000 --> 02:18:32,000
某些东西的技巧叫做什么什么付

3447
02:18:32,000 --> 02:18:33,000
比如说

3448
02:18:33,000 --> 02:18:35,000
搜 google 的技巧叫做 google full

3449
02:18:36,000 --> 02:18:38,000
然后 command line 的技巧叫做 command line full

3450
02:18:38,000 --> 02:18:41,000
commandlinefu.com

3451
02:18:41,000 --> 02:18:44,000
然后你可以在这里面找到很多很多实用的这个命令行的

3452
02:18:44,000 --> 02:18:45,000
tips

3453
02:18:46,000 --> 02:18:46,000
好吧

3454
02:18:47,000 --> 02:18:52,000
感谢收听 ipnpodcasts 网络旗下 IT 技术主题娱乐节目我们号称

3455
02:18:52,000 --> 02:18:53,000
我们叫内核恐惑

3456
02:18:54,000 --> 02:18:58,000
我们号称 hardcore 但是也没有干货想听不想听就别听

3457
02:18:58,000 --> 02:19:02,000
你可以为本节目捐款捐款地址是 kernelpanic.fm

3458
02:19:02,000 --> 02:19:03,000
slash donate

3459
02:19:03,000 --> 02:19:05,000
捐款结果随意至少是 8 的正式入备就可以了

3460
02:19:06,000 --> 02:19:08,000
捐款不会为你带来什么不捐也不会让你失去什么

3461
02:19:08,000 --> 02:19:09,000
我们的口号是

3462
02:19:09,000 --> 02:19:11,000
no hard feelings

3463
02:19:11,000 --> 02:19:14,000
如果你有任何反馈欢迎发邮件到 kernelpanic

3464
02:19:14,000 --> 02:19:16,000
atipn.li

3465
02:19:16,000 --> 02:19:17,000
同时也欢迎

3466
02:19:17,000 --> 02:19:19,000
收听 ipn 旗下几档节目

3467
02:19:19,000 --> 02:19:20,000
爱听公论

3468
02:19:20,000 --> 02:19:22,000
我也知道太一来了流行通讯

3469
02:19:22,000 --> 02:19:23,000
high story

3470
02:19:23,000 --> 02:19:26,000
阴影像无资源不物质选美

3471
02:19:26,000 --> 02:19:28,000
我们下期节目再会

