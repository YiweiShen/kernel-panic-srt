1
00:00:00,000 --> 00:00:21,000
大家好,今天是 7 月 25 号

2
00:00:21,000 --> 00:00:25,000
现在您听的是自弹自唱的第 52 期

3
00:00:25,000 --> 00:00:28,000
同时也是内核共和国的第 48 期

4
00:00:28,000 --> 00:00:50,000
内核恐慌是 IPM Podcast 网络旗下的 IT 技术主题娱乐节目

5
00:00:50,000 --> 00:00:52,000
我们号称 Hardcore,但是也没有干货

6
00:00:52,000 --> 00:00:54,000
想听人听,不想听人就别听

7
00:00:55,000 --> 00:00:57,000
我是主播吴涛

8
00:00:57,000 --> 00:00:58,000
我是 Rail

9
00:00:58,000 --> 00:01:02,000
你说我们这个节目串台都已经串了第五期了

10
00:01:02,000 --> 00:01:07,000
等到上次五月底才第一次四个人一起在同一个空间见面是吧

11
00:01:07,000 --> 00:01:08,000
历史性的会晤啊

12
00:01:08,000 --> 00:01:10,000
对,我们四个人没有合照

13
00:01:10,000 --> 00:01:14,000
那天活动来了好多播客主播吧

14
00:01:14,000 --> 00:01:16,000
数来应该有差不多小于十个

15
00:01:16,000 --> 00:01:20,000
你们后来就背着我们就直接去喝酒了

16
00:01:20,000 --> 00:01:22,000
你们不是也去喝酒了吗

17
00:01:22,000 --> 00:01:24,000
你们不是还要去打扫场地吗

18
00:01:24,000 --> 00:01:25,000
那没有办法呀

19
00:01:27,000 --> 00:01:29,000
对啊,虽然说是 TIB 十周年活动节目

20
00:01:29,000 --> 00:01:36,000
搞得好像是变成国内 IPM 和各台电台主播的一个小聚会了

21
00:01:36,000 --> 00:01:37,000
小众播客网络

22
00:01:37,000 --> 00:01:42,000
而且其实线下我跟 Eric 在东京见过

23
00:01:42,000 --> 00:01:45,000
然后我跟 Rail 见过很久了

24
00:01:45,000 --> 00:01:50,000
Eric 跟郑宇之前也在上海见过很多次

25
00:01:50,000 --> 00:01:51,000
对

26
00:01:51,000 --> 00:01:52,000
我跟 Rail 也见过一次

27
00:01:52,000 --> 00:01:56,000
然后我跟 Rail 在深圳也见过一两次

28
00:01:57,000 --> 00:01:57,000
两次

29
00:01:57,000 --> 00:01:58,000
对

30
00:01:58,000 --> 00:02:02,000
但真正所有人在一起见这是第一次

31
00:02:02,000 --> 00:02:04,000
还挺难得的

32
00:02:04,000 --> 00:02:08,000
我们可以在 show notes 发一下上次活动的剧本

33
00:02:08,000 --> 00:02:11,000
就是什么四个人都在的照片应该有吧

34
00:02:11,000 --> 00:02:11,000
没有

35
00:02:11,000 --> 00:02:14,000
好像咱们四个没有合影

36
00:02:14,000 --> 00:02:14,000
对

37
00:02:14,000 --> 00:02:16,000
Oh my god

38
00:02:16,000 --> 00:02:17,000
这么惨

39
00:02:17,000 --> 00:02:18,000
把吴涛批上去

40
00:02:18,000 --> 00:02:20,000
不是

41
00:02:20,000 --> 00:02:25,000
那个 Rail 也没有跟其他三个人合过影

42
00:02:25,000 --> 00:02:27,000
就 Rail 也没有跟你们来合影

43
00:02:27,000 --> 00:02:28,000
好像有

44
00:02:28,000 --> 00:02:29,000
走的时候好像有

45
00:02:29,000 --> 00:02:29,000
肯定有照片

46
00:02:29,000 --> 00:02:31,000
同时有我和 Eric 和 Rail 的

47
00:02:31,000 --> 00:02:33,000
我觉得有一张

48
00:02:33,000 --> 00:02:35,000
有一张有各种主播在一起

49
00:02:35,000 --> 00:02:40,000
有一张是你们两个在那个内监

50
00:02:40,000 --> 00:02:42,000
那个是一个节目

51
00:02:42,000 --> 00:02:44,000
然后 Rail 站在外面的照片

52
00:02:44,000 --> 00:02:44,000
对

53
00:02:44,000 --> 00:02:45,000
这个也有

54
00:02:45,000 --> 00:02:47,000
然后活动结束的时候

55
00:02:47,000 --> 00:02:50,000
我跟 Eric 和郑宇都有合影

56
00:02:50,000 --> 00:02:52,000
但是那个时候吴涛不知道去哪去了

57
00:02:52,000 --> 00:02:53,000
我就喝酒

58
00:02:53,000 --> 00:02:54,000
去泡妹子了

59
00:02:54,000 --> 00:02:55,000
吴涛喝花酒去

60
00:02:55,000 --> 00:02:55,000
泡屁

61
00:02:55,000 --> 00:02:55,000
去泡妹子了

62
00:02:55,000 --> 00:02:56,000
去泡妹子了

63
00:02:56,000 --> 00:02:57,000
去泡妹子了

64
00:02:57,000 --> 00:03:02,000
好

65
00:03:02,000 --> 00:03:02,000
首先呢

66
00:03:02,000 --> 00:03:03,000
跟大家讲一讲

67
00:03:03,000 --> 00:03:05,000
其实这也不算广告了

68
00:03:05,000 --> 00:03:06,000
就我们自己那 Type School

69
00:03:06,000 --> 00:03:08,000
七月份的课程已经结束了

70
00:03:08,000 --> 00:03:12,000
七月份这个西文的字体设计课程

71
00:03:12,000 --> 00:03:14,000
大家应该虽然很累

72
00:03:14,000 --> 00:03:15,000
但很辛苦

73
00:03:15,000 --> 00:03:17,000
但是估计大家收获也蛮大的

74
00:03:17,000 --> 00:03:19,000
一共有几天呢

75
00:03:19,000 --> 00:03:21,000
两个礼拜呀

76
00:03:21,000 --> 00:03:24,000
我也过去跟去

77
00:03:24,000 --> 00:03:26,000
就和大家就凑了一会儿热闹

78
00:03:26,000 --> 00:03:31,000
看我们的格尔格老师给大家讲 Greeves

79
00:03:31,000 --> 00:03:31,000
挺有意思的

80
00:03:31,000 --> 00:03:33,000
对了

81
00:03:33,000 --> 00:03:34,000
我一直很好奇

82
00:03:34,000 --> 00:03:36,000
Gilg 他是一个字体设计师吗

83
00:03:36,000 --> 00:03:37,000
对

84
00:03:37,000 --> 00:03:38,000
他字体设计师

85
00:03:38,000 --> 00:03:40,000
他自己设计字体

86
00:03:40,000 --> 00:03:40,000
然后

87
00:03:40,000 --> 00:03:43,000
但是他有一些计算机开发的基础

88
00:03:43,000 --> 00:03:45,000
然后他做出 Greeves

89
00:03:45,000 --> 00:03:46,000
几乎现在就

90
00:03:46,000 --> 00:03:48,000
几乎全职都在做 Greeves

91
00:03:48,000 --> 00:03:49,000
这个软件掉了

92
00:03:49,000 --> 00:03:53,000
所以他应该是一个计算机科学出身的人吧

93
00:03:53,000 --> 00:03:54,000
就是他是一个

94
00:03:54,000 --> 00:03:55,000
他是设计师出身

95
00:03:55,000 --> 00:03:56,000
他是设计师出身

96
00:03:56,000 --> 00:03:58,000
他竟然能写这么复杂的

97
00:03:58,000 --> 00:04:01,000
我觉得 Greeves 已经是一个非常复杂的软件了

98
00:04:01,000 --> 00:04:01,000
对

99
00:04:01,000 --> 00:04:04,000
非常令人惊讶

100
00:04:04,000 --> 00:04:05,000
对

101
00:04:05,000 --> 00:04:06,000
好吧

102
00:04:06,000 --> 00:04:08,000
设计师也需要这样的人才

103
00:04:08,000 --> 00:04:09,000
所以呢

104
00:04:09,000 --> 00:04:12,000
我也希望有更多的设计师来听我们的自弹自串

105
00:04:12,000 --> 00:04:13,000
好吧

106
00:04:13,000 --> 00:04:17,000
然后就有很多朋友问

107
00:04:17,000 --> 00:04:18,000
就是就

108
00:04:18,000 --> 00:04:19,000
因为这次是讲西文嘛

109
00:04:19,000 --> 00:04:22,000
那有没有学中文的字体设计课程

110
00:04:22,000 --> 00:04:23,000
然后其实呢

111
00:04:23,000 --> 00:04:26,000
就是可能大家在微信上面也看到消息了

112
00:04:26,000 --> 00:04:29,000
在 8 月 4 号到 9 号呢

113
00:04:29,000 --> 00:04:30,000
会有这样一个课程

114
00:04:30,000 --> 00:04:31,000
叫 TypeSchool 的中文字体设计课

115
00:04:31,000 --> 00:04:32,000
而且这次呢

116
00:04:32,000 --> 00:04:33,000
不是在上海

117
00:04:33,000 --> 00:04:35,000
是在北京

118
00:04:35,000 --> 00:04:36,000
然后我们请到了老师呢

119
00:04:36,000 --> 00:04:40,000
就有方正字库的思维设计师

120
00:04:40,000 --> 00:04:42,000
包括像球影

121
00:04:42,000 --> 00:04:45,000
球影先生这样经验非常丰富的字体设计

122
00:04:45,000 --> 00:04:46,000
设计过很多中文字体设计师

123
00:04:46,000 --> 00:04:49,000
可能大家都最知道他最著名的字体

124
00:04:49,000 --> 00:04:51,000
就是那个 U 黑嘛

125
00:04:51,000 --> 00:04:51,000
对

126
00:04:51,000 --> 00:04:53,000
然后 TypeSchool 呢

127
00:04:53,000 --> 00:04:55,000
就会教大家如何实现字库

128
00:04:55,000 --> 00:04:56,000
然后因为是做中文

129
00:04:56,000 --> 00:04:57,000
所以呢

130
00:04:57,000 --> 00:04:59,000
可能工程比较浩大

131
00:04:59,000 --> 00:04:59,000
好说

132
00:04:59,000 --> 00:05:01,000
从 12 个字

133
00:05:01,000 --> 00:05:05,000
扩展到 50 个字到 500

134
00:05:05,000 --> 00:05:05,000
5000

135
00:05:05,000 --> 00:05:06,000
5 万对吧

136
00:05:06,000 --> 00:05:10,000
平时大家设计中文的话是没有头绪嘛

137
00:05:10,000 --> 00:05:12,000
不知道怎么用什么方法做

138
00:05:12,000 --> 00:05:13,000
然后做要做多少字

139
00:05:13,000 --> 00:05:14,000
一旦多的话呢

140
00:05:14,000 --> 00:05:15,000
对吧

141
00:05:15,000 --> 00:05:17,000
这个怎么提高效率

142
00:05:17,000 --> 00:05:19,000
然后呢

143
00:05:19,000 --> 00:05:23,000
尽早发现问题

144
00:05:23,000 --> 00:05:24,000
比如说大小不一样啊

145
00:05:24,000 --> 00:05:25,000
怎么处理啊

146
00:05:25,000 --> 00:05:26,000
这些我们都会去讲一下

147
00:05:26,000 --> 00:05:27,000
所以说呢

148
00:05:27,000 --> 00:05:29,000
我们就会在这一段时间里面呢

149
00:05:29,000 --> 00:05:30,000
在 TypeSchool 请老师呢

150
00:05:30,000 --> 00:05:32,000
给大家介绍

151
00:05:32,000 --> 00:05:32,000
对

152
00:05:32,000 --> 00:05:35,000
不过五天时间其实做 12 个字也就差不多

153
00:05:35,000 --> 00:05:38,000
我们这次呢有有一个很好的机会是

154
00:05:38,000 --> 00:05:40,000
优先的学员啊

155
00:05:40,000 --> 00:05:41,000
可以和方正签约

156
00:05:41,000 --> 00:05:42,000
啊

157
00:05:42,000 --> 00:05:43,000
只要

158
00:05:43,000 --> 00:05:45,000
你先做好几百个字

159
00:05:45,000 --> 00:05:46,000
剩下的

160
00:05:46,000 --> 00:05:46,000
成千上万字啊

161
00:05:46,000 --> 00:05:47,000
方正

162
00:05:47,000 --> 00:05:49,000
会把你做

163
00:05:49,000 --> 00:05:49,000
啊

164
00:05:49,000 --> 00:05:50,000
对

165
00:05:50,000 --> 00:05:53,000
这个其实就跟之前的这个字体竞赛很相似啦

166
00:05:53,000 --> 00:05:55,000
就是你提交一份样字的作品

167
00:05:55,000 --> 00:05:56,000
然后如果

168
00:05:56,000 --> 00:05:57,000
字体公司觉得

169
00:05:57,000 --> 00:05:58,000
非常合适

170
00:05:58,000 --> 00:05:59,000
有商业化的价值的话

171
00:06:00,000 --> 00:06:01,000
他会与你签约

172
00:06:01,000 --> 00:06:03,000
然后帮你把它做成一个真正意义上的字库

173
00:06:04,000 --> 00:06:06,000
当然在这样的过程里面呢

174
00:06:06,000 --> 00:06:08,000
大家也会可以接触到 Grips 这样

175
00:06:08,000 --> 00:06:10,000
这样一个什么字体神器

176
00:06:12,000 --> 00:06:12,000
其实

177
00:06:12,000 --> 00:06:15,000
而且这次呢我们 Grips 的开发者

178
00:06:15,000 --> 00:06:16,000
格奥格格来

179
00:06:17,000 --> 00:06:20,000
中国给他切身感到了啊

180
00:06:20,000 --> 00:06:23,000
做方块汉字的一些特殊的要求

181
00:06:23,000 --> 00:06:25,000
那我们有很多新的功能

182
00:06:25,000 --> 00:06:26,000
也会加到

183
00:06:26,000 --> 00:06:28,000
这个 Grips 里面给大家可以试用一下

184
00:06:29,000 --> 00:06:29,000
这次呢

185
00:06:30,000 --> 00:06:33,000
我们还邀请到了德国的 MetaDesign

186
00:06:33,000 --> 00:06:35,000
那 MetaDesign 的

187
00:06:35,000 --> 00:06:37,000
德国的他们那边的

188
00:06:37,000 --> 00:06:39,000
这个公司的他们的设计师也会

189
00:06:40,000 --> 00:06:40,000
参与到活动

190
00:06:41,000 --> 00:06:41,000
里面进来

191
00:06:41,000 --> 00:06:45,000
那对 MetaDesign 感兴趣的朋友们也有机会

192
00:06:45,000 --> 00:06:48,000
所以这是蛮难得的一个机会

193
00:06:50,000 --> 00:06:52,000
8 月份的北京比较热哈

194
00:06:52,000 --> 00:06:53,000
但是呢

195
00:06:53,000 --> 00:06:54,000
我觉得

196
00:06:54,000 --> 00:06:56,000
7 月份的上海也够热的

197
00:06:56,000 --> 00:06:57,000
上海更热吧

198
00:06:58,000 --> 00:07:00,000
我觉得这两天北京比上海凉快多了

199
00:07:00,000 --> 00:07:03,000
北京北京还好是干热嘛

200
00:07:03,000 --> 00:07:04,000
上海主要是湿度比较大

201
00:07:05,000 --> 00:07:05,000
比较难受

202
00:07:05,000 --> 00:07:07,000
上海这周是暴热

203
00:07:07,000 --> 00:07:08,000
已经超过 40 度了

204
00:07:09,000 --> 00:07:10,000
对啊

205
00:07:10,000 --> 00:07:13,000
有这种夏令营的感觉

206
00:07:13,000 --> 00:07:14,000
大家也欢迎大家

207
00:07:14,000 --> 00:07:16,000
来多多的进行

208
00:07:16,000 --> 00:07:17,000
报名

209
00:07:17,000 --> 00:07:19,000
有这样的机会是非常难得的

210
00:07:22,000 --> 00:07:26,000
好了难得我们这次第五次的串台嘛但是还要先

211
00:07:26,000 --> 00:07:27,000
讲一下反馈

212
00:07:28,000 --> 00:07:34,000
那上次呢就是我们的自弹自传的第四期峰回路转换航来呢有一位朋友

213
00:07:35,000 --> 00:07:38,000
说无头重新发明打字机无头重新发明打字机

214
00:07:38,000 --> 00:07:41,000
带回车键的打字机感叹好

215
00:07:42,000 --> 00:07:43,000
所以打字机是没有回车键的对吧

216
00:07:44,000 --> 00:07:45,000
就打字机没有

217
00:07:46,000 --> 00:07:49,000
一个键是你按下去之后它会跳到下一行

218
00:07:50,000 --> 00:07:51,000
好像是有的

219
00:07:51,000 --> 00:07:56,000
但这个这个键并不是回车键就也不是在每一个打字机上都有

220
00:07:56,000 --> 00:08:00,000
然后换行的时候是你拨动那个左边的拨杆

221
00:08:00,000 --> 00:08:02,000
把自车往右拨的过程中

222
00:08:04,000 --> 00:08:06,000
它会自动朝下滚一格

223
00:08:06,000 --> 00:08:10,000
所以换行这个功能实际上是在自车上实现的

224
00:08:10,000 --> 00:08:12,000
这还是把那位

225
00:08:12,000 --> 00:08:14,000
听众的反馈念一下吧

226
00:08:15,000 --> 00:08:15,000
好吧

227
00:08:16,000 --> 00:08:19,000
刚艾瑞克念的是第一行然后接下来念

228
00:08:20,000 --> 00:08:25,000
打字机没有回车键打字机滚筒左端的手柄兼具回车与换行功能

229
00:08:25,000 --> 00:08:30,000
手柄从左向右平推可以将滚轮向右推送

230
00:08:30,000 --> 00:08:31,000
就是回车

231
00:08:31,000 --> 00:08:33,000
手柄从左向右

232
00:08:33,000 --> 00:08:38,000
从左向右搬动同时带点轻微的顺时针扭转可以滚动滚动

233
00:08:39,000 --> 00:08:39,000
就是换行

234
00:08:40,000 --> 00:08:43,000
搬得轻一点可以换半行或 1 1

235
00:08:43,000 --> 00:08:46,000
打字时当滚动行进行到

236
00:08:47,000 --> 00:08:48,000
滚动行

237
00:08:49,000 --> 00:08:50,000
进到

238
00:08:51,000 --> 00:08:55,000
接近航幕位置时会有叮的一声铃铃提示

239
00:08:55,000 --> 00:08:58,000
平推手柄将滚轮推到最右实现回车

240
00:08:59,000 --> 00:09:01,000
顺势继续用手

241
00:09:01,000 --> 00:09:04,000
顺势继续用力手柄会自然向右

242
00:09:04,000 --> 00:09:05,000
板动

243
00:09:06,000 --> 00:09:08,000
转动滚轮

244
00:09:08,000 --> 00:09:10,000
你怎么了你用这种障碍的话全程

245
00:09:12,000 --> 00:09:13,000
实现坏行

246
00:09:13,000 --> 00:09:14,000
OK

247
00:09:14,000 --> 00:09:15,000
大家听懂了吗

248
00:09:16,000 --> 00:09:18,000
没有我是没听懂

249
00:09:18,000 --> 00:09:24,000
我知道他什么意思就是对你在你在敲一行比如说这一行有 80 个字符

250
00:09:24,000 --> 00:09:25,000
然后你敲了大概

251
00:09:26,000 --> 00:09:29,000
75 个时候打字机会叮一声告诉你说没地儿了你赶紧

252
00:09:29,000 --> 00:09:30,000
换行

253
00:09:31,000 --> 00:09:32,000
然后这个时候你

254
00:09:32,000 --> 00:09:34,000
压左侧的那个换行杆

255
00:09:35,000 --> 00:09:37,000
压稍微压一下然后那个

256
00:09:37,000 --> 00:09:39,000
自车就会往上滚一格

257
00:09:40,000 --> 00:09:44,000
然后你继续往下压他就会把整个自车拉到

258
00:09:45,000 --> 00:09:46,000
指的最左边

259
00:09:47,000 --> 00:09:47,000
然后就

260
00:09:47,000 --> 00:09:48,000
就这么一件事

261
00:09:51,000 --> 00:09:54,000
我还是很好奇为什么你们小时候都没有用过打字机呢

262
00:09:54,000 --> 00:09:55,000
哈哈哈哈

263
00:09:56,000 --> 00:09:57,000
对就没有用过习文

264
00:09:58,000 --> 00:10:01,000
我没有用过所以你用过中文的打字机那更屌了

265
00:10:02,000 --> 00:10:03,000
中文打字机是一个

266
00:10:03,000 --> 00:10:05,000
一米乘一米的大台子呀

267
00:10:06,000 --> 00:10:06,000
对

268
00:10:07,000 --> 00:10:09,000
这个我用过就玩过一下

269
00:10:09,000 --> 00:10:15,000
那个真的存在吗就是那个那么多个字是那么大怎么怎么移动呢

270
00:10:16,000 --> 00:10:18,000
是一个是一个笛卡尔

271
00:10:18,000 --> 00:10:19,000
笛卡尔平面

272
00:10:20,000 --> 00:10:21,000
XY

273
00:10:21,000 --> 00:10:22,000
真的

274
00:10:22,000 --> 00:10:25,000
哈哈哈哈

275
00:10:25,000 --> 00:10:27,000
那能有多少个字啊上面字母啊

276
00:10:28,000 --> 00:10:28,000
将近一万个吧

277
00:10:29,000 --> 00:10:33,000
很多很多没有吧没有没有不到一万多吧

278
00:10:33,000 --> 00:10:40,000
那一两千肯定是有因为我印象里面我玩过那台是有 6000

279
00:10:41,000 --> 00:10:44,000
因为中文常用字也就三千三千五吧

280
00:10:45,000 --> 00:10:48,000
就他把常用字放上面然后不够的适用空格然后有三首写

281
00:10:49,000 --> 00:10:51,000
他底下那个可以换的可以替换

282
00:10:52,000 --> 00:10:54,000
我印象里面是个 100 乘 100 的格子你知道吗

283
00:10:54,000 --> 00:10:55,000
嗯

284
00:10:55,000 --> 00:10:58,000
我印象好像有那么多吗

285
00:10:58,000 --> 00:10:58,000
没那么大吧

286
00:10:59,000 --> 00:11:00,000
没有 100 乘 100 吗

287
00:11:01,000 --> 00:11:02,000
记不大清楚了

288
00:11:02,000 --> 00:11:04,000
挺大的对挺大的

289
00:11:04,000 --> 00:11:06,000
对反正是个相当大的模式

290
00:11:06,000 --> 00:11:13,000
我刚给大家发了一个链接那个也是一种那个汉字的打字机这个是日本人做的

291
00:11:13,000 --> 00:11:14,000
然后他是一个

292
00:11:14,000 --> 00:11:15,000
滚筒式的

293
00:11:16,000 --> 00:11:17,000
选字机构

294
00:11:18,000 --> 00:11:21,000
哦 OK 这个比较浓厌

295
00:11:22,000 --> 00:11:23,000
对这个是在

296
00:11:23,000 --> 00:11:25,000
那个京都的汉字博物馆里面

297
00:11:25,000 --> 00:11:26,000
展示了一件展品

298
00:11:27,000 --> 00:11:28,000
其实如果这么多

299
00:11:28,000 --> 00:11:30,000
就怎么记呀

300
00:11:31,000 --> 00:11:34,000
可能熟能生巧吧另外他肯定排字是有规则的

301
00:11:35,000 --> 00:11:36,000
你看他有标了不同的颜色

302
00:11:37,000 --> 00:11:38,000
凯克会给口号这样排吗

303
00:11:39,000 --> 00:11:40,000
不汉字应该不是这样排

304
00:11:42,000 --> 00:11:42,000
OK

305
00:11:42,000 --> 00:11:44,000
应该是按音式排的吧

306
00:11:44,000 --> 00:11:47,000
他有颜色划分嘛应该是按那个所谓的行和列

307
00:11:48,000 --> 00:11:50,000
就是 50 音的行和列的

308
00:11:51,000 --> 00:11:53,000
发音来标音之后再分开

309
00:11:54,000 --> 00:11:55,000
我天怎么记得住啊那个字

310
00:11:56,000 --> 00:11:56,000
在哪个位置

311
00:11:57,000 --> 00:11:57,000
还是要找的

312
00:11:58,000 --> 00:12:00,000
不你想就说他假设只有 3000

313
00:12:01,000 --> 00:12:03,000
3000 个长音字的那个滚筒的话

314
00:12:05,000 --> 00:12:06,000
这打字速度应该很慢吧

315
00:12:07,000 --> 00:12:10,000
嗯就得转转然后找找完以后才打出一个字

316
00:12:10,000 --> 00:12:10,000
就是这样

317
00:12:12,000 --> 00:12:15,000
他这个毕竟还是按拼音排列的我觉得可能还是要比中文打字机那个

318
00:12:16,000 --> 00:12:18,000
按步骤排列的要快一点

319
00:12:18,000 --> 00:12:19,000
对不过

320
00:12:19,000 --> 00:12:23,000
因为日语一个字有很多发音嘛所以你可能

321
00:12:23,000 --> 00:12:25,000
得记住这个字他用的是哪个标音

322
00:12:25,000 --> 00:12:29,000
我以前我以前看的我就是我爸

323
00:12:29,000 --> 00:12:33,000
单位他们那个打字员用的那种打字机的话他底下那个

324
00:12:33,000 --> 00:12:34,000
反那个

325
00:12:34,000 --> 00:12:38,000
刚刚冲的那个刚字的盘是可以换的

326
00:12:38,000 --> 00:12:40,000
虽然他经常会把这比较常用的字

327
00:12:41,000 --> 00:12:42,000
主要的组合

328
00:12:42,000 --> 00:12:44,000
他因为他可以随任意调配吗

329
00:12:44,000 --> 00:12:45,000
然后把常用的

330
00:12:46,000 --> 00:12:46,000
放在一起

331
00:12:46,000 --> 00:12:50,000
比如中华人民共和国他就全部放在嘎嘎嘎嘎嘎就顺下来可以直接打出来

332
00:12:52,000 --> 00:12:52,000
啊

333
00:12:52,000 --> 00:12:55,000
而且我记得就我见到那个中文打字之后

334
00:12:56,000 --> 00:12:59,000
好像他那个字盘不只是一层他有两层的可以抽的

335
00:12:59,000 --> 00:13:00,000
啊对没错

336
00:13:00,000 --> 00:13:02,000
对没错上里有一层

337
00:13:02,000 --> 00:13:04,000
可能是常用的下面还是成次常用

338
00:13:04,000 --> 00:13:07,000
哦对对对对没错对

339
00:13:07,000 --> 00:13:10,000
所以我印象中的中文打字机没那么大

340
00:13:11,000 --> 00:13:12,000
嗯有道理

341
00:13:13,000 --> 00:13:15,000
一百乘一百好像移动出来的挺麻烦

342
00:13:18,000 --> 00:13:19,000
打太极拳都可以

343
00:13:20,000 --> 00:13:23,000
我小时候其实就根本没有见过这些

344
00:13:24,000 --> 00:13:25,000
就纯机械的打字机

345
00:13:26,000 --> 00:13:29,000
我记得我小时候第一次看人打字的时候已经是有那个叫

346
00:13:29,000 --> 00:13:32,000
那个叫什么来的就是字符那个道斯

347
00:13:32,000 --> 00:13:34,000
道斯环境里面有一个中文的系统

348
00:13:35,000 --> 00:13:36,000
WPS

349
00:13:36,000 --> 00:13:38,000
CCED 吧

350
00:13:39,000 --> 00:13:41,000
CCED 是更早的后来 WPS 后出的嘛

351
00:13:42,000 --> 00:13:44,000
后出的时候那个时候已经有那种

352
00:13:44,000 --> 00:13:48,000
就是在那个 WPS 的那个就是字符界面那个版本里面去

353
00:13:48,000 --> 00:13:49,000
海印

354
00:13:49,000 --> 00:13:51,000
然后用那种真实打印机

355
00:13:51,000 --> 00:13:53,000
再把那个打出来嘛

356
00:13:53,000 --> 00:13:54,000
所以这个时候其实已经

357
00:13:55,000 --> 00:13:55,000
没有见过

358
00:13:55,000 --> 00:13:57,000
真的那种传统 1 的打字机了

359
00:13:57,000 --> 00:14:01,000
我高中办校报的时候就是用那个先进 UC 道斯

360
00:14:01,000 --> 00:14:04,000
然后再进那个 WPS

361
00:14:04,000 --> 00:14:10,000
然后呢他那不是一个他是字符编辑界面吧他不是那个所见即所得的吗所以你得

362
00:14:10,000 --> 00:14:15,000
要一些装饰的东西都都用那个符号写进去后来不停不停的预览

363
00:14:15,000 --> 00:14:16,000
然后经常 386 的机器还会死机

364
00:14:18,000 --> 00:14:22,000
那个时候对于所见即所得没什么概念吧就是

365
00:14:22,000 --> 00:14:24,000
你要不停的预览

366
00:14:24,000 --> 00:14:25,000
但是后来

367
00:14:26,000 --> 00:14:27,000
基本上熟悉的人会

368
00:14:28,000 --> 00:14:34,000
对于文章大概会看起来是什么样子有个概念就跟现在手写 HTML

369
00:14:34,000 --> 00:14:34,000
然后

370
00:14:35,000 --> 00:14:35,000
预览的

371
00:14:35,000 --> 00:14:37,000
本质上也是一种 markup 语言嘛那个

372
00:14:37,000 --> 00:14:42,000
是完全就是 markup 的所以你脑子中要想好你所要的是什么东西吗

373
00:14:44,000 --> 00:14:46,000
其实现在我们又回 markdown 又回去了

374
00:14:46,000 --> 00:14:47,000
又回来了对

375
00:14:47,000 --> 00:14:49,000
实际上我觉得

376
00:14:49,000 --> 00:14:53,000
这个所见即所得并不是一个强需求说实话

377
00:14:53,000 --> 00:14:54,000
就

378
00:14:54,000 --> 00:14:55,000
就要看

379
00:14:56,000 --> 00:15:00,000
看他那个门槛放低了以后是可以让更多人进来吗但是对于

380
00:15:01,000 --> 00:15:03,000
专业用户的话可能需求不一样吗

381
00:15:04,000 --> 00:15:05,000
我觉得

382
00:15:05,000 --> 00:15:11,000
所见即所得本身是没有问题的主要问题在于现在就主要是像 word 的那个实现他的

383
00:15:11,000 --> 00:15:13,000
那个实现过程有问题就是

384
00:15:13,000 --> 00:15:14,000
他把

385
00:15:15,000 --> 00:15:16,000
所有的那个

386
00:15:16,000 --> 00:15:17,000
效果都

387
00:15:17,000 --> 00:15:20,000
就直接锁键了你没办法用一个类似于像

388
00:15:20,000 --> 00:15:23,000
模板或者是一种格式的方式

389
00:15:23,000 --> 00:15:25,000
虽然有格式刷好但是那个

390
00:15:26,000 --> 00:15:27,000
就是极其不稳定吗

391
00:15:27,000 --> 00:15:28,000
我觉得这张

392
00:15:28,000 --> 00:15:31,000
他太迁就用户了就是

393
00:15:31,000 --> 00:15:35,000
用户说我这个小标题要

394
00:15:35,000 --> 00:15:38,000
15 帮重加粗

395
00:15:38,000 --> 00:15:42,000
下一个小标题他就弄一个 16 帮重然后清写

396
00:15:42,000 --> 00:15:46,000
然后我这就傻逼了我这说我应该怎么办呢

397
00:15:46,000 --> 00:15:50,000
我应该问用户说不对你上一个小标题用的是这个

398
00:15:50,000 --> 00:15:52,000
然后这小标题你也得用那个

399
00:15:52,000 --> 00:15:54,000
但是这样一来用户可能不爽

400
00:15:54,000 --> 00:15:55,000
那我还是迁就用户再多用户

401
00:15:56,000 --> 00:15:58,000
然后等到

402
00:15:58,000 --> 00:16:01,000
整个整篇文章写完之后发现小标题的 style 可能有

403
00:16:02,000 --> 00:16:03,000
20 种

404
00:16:03,000 --> 00:16:03,000
35 种

405
00:16:04,000 --> 00:16:04,000
对

406
00:16:05,000 --> 00:16:10,000
如果一上来你们从来没有学会过用 word 格式刷这个习惯的话那基本上就

407
00:16:10,000 --> 00:16:11,000
最后只能手动改

408
00:16:12,000 --> 00:16:18,000
关键是那个格式他那个格式刷他也是一个就是事后加的东西我觉得就是他的本质上

409
00:16:18,000 --> 00:16:21,000
他的主理结构是以那个实际看的为准的

410
00:16:22,000 --> 00:16:24,000
这点跟那个苹果那个 pages

411
00:16:24,000 --> 00:16:25,000
就是跟 word 差不多的一个原则

412
00:16:26,000 --> 00:16:27,000
的逻辑是完全不一样的

413
00:16:28,000 --> 00:16:31,000
pages 里面其实你是可以先定义那个文章的结构比如说这个

414
00:16:31,000 --> 00:16:33,000
刚才讲说这个是标题

415
00:16:34,000 --> 00:16:35,000
就一级标题二级标题

416
00:16:35,000 --> 00:16:36,000
正文

417
00:16:36,000 --> 00:16:37,000
这个是这个

418
00:16:37,000 --> 00:16:38,000
表格的内容

419
00:16:39,000 --> 00:16:41,000
定好之后你是可以直接通过改那个

420
00:16:41,000 --> 00:16:45,000
那个那个类型的文本比如说我要改标题都改成一种同样的东西

421
00:16:45,000 --> 00:16:46,000
他可以

422
00:16:46,000 --> 00:16:47,000
直接更新然后让所有的

423
00:16:48,000 --> 00:16:49,000
标题文本都是

424
00:16:49,000 --> 00:16:50,000
长那个样子的

425
00:16:50,000 --> 00:16:52,000
但是在 word 里面这一点实现起来是非常不稳定的

426
00:16:53,000 --> 00:16:54,000
word 也有这个功能

427
00:16:54,000 --> 00:16:55,000
word 也有

428
00:16:55,000 --> 00:16:57,000
对只是用的人非常的少

429
00:16:58,000 --> 00:16:59,000
不是不是他的实践确实是有问题的

430
00:17:00,000 --> 00:17:04,000
就是他不是那么强强调那个结构和统一的这么一个概念

431
00:17:04,000 --> 00:17:05,000
就刚才讲武涛说的嘛

432
00:17:06,000 --> 00:17:10,000
就是用用户觉得这里要改一点那一点改他就他就不去 enforce 这个

433
00:17:10,000 --> 00:17:11,000
一致性的问题

434
00:17:12,000 --> 00:17:18,000
这个其实是专业用户的一个需求不一样的像我当年也曾经用 word

435
00:17:18,000 --> 00:17:20,000
做 40 页的小册子的时候我都是用那个

436
00:17:21,000 --> 00:17:22,000
样那个叫什么 style

437
00:17:23,000 --> 00:17:23,000
样式吧

438
00:17:24,000 --> 00:17:25,000
他专门有个样式小窗口来做

439
00:17:26,000 --> 00:17:26,000
对啊对啊

440
00:17:27,000 --> 00:17:29,000
你做长文档的时候就必须要用那样来做要不然的话

441
00:17:30,000 --> 00:17:31,000
非常复杂

442
00:17:31,000 --> 00:17:36,000
对就是那个实际使用情况下 word 就会出现刚才武涛讲那个问题就是你的那个

443
00:17:36,000 --> 00:17:38,000
格式刷他不是有个选一个列表有多少种格式吗

444
00:17:38,000 --> 00:17:41,000
你可能一边稍微长一个 10 页的文档可能会出现四五十种

445
00:17:42,000 --> 00:17:43,000
那个不同的格式

446
00:17:43,000 --> 00:17:47,000
对就是 word 对于就是你想把 word 用好的话你要有一个非常

447
00:17:47,000 --> 00:17:48,000
好的

448
00:17:49,000 --> 00:17:50,000
怎么说 discipline

449
00:17:50,000 --> 00:17:52,000
就是你必须是一个非常自律的

450
00:17:52,000 --> 00:17:53,000
高度自律的人

451
00:17:54,000 --> 00:17:54,000
对

452
00:17:54,000 --> 00:17:55,000
对

453
00:17:55,000 --> 00:17:58,000
然后忍住那个选中这一行字然后直接往上

454
00:17:58,000 --> 00:18:01,000
改变他的格式的这个

455
00:18:02,000 --> 00:18:04,000
改变他的样式的这个这个冲动然后

456
00:18:05,000 --> 00:18:08,000
人辱负重的去用格式刷来刷这行字

457
00:18:09,000 --> 00:18:10,000
对否则你就乱了

458
00:18:11,000 --> 00:18:15,000
他很容易在那些小细节地方就变掉就是你用格式刷也刷不回来

459
00:18:15,000 --> 00:18:17,000
就有些我不知道你们遇到过

460
00:18:17,000 --> 00:18:20,000
有些比如说两个字之间出现一个东西你无论用格式刷点多少次他都不会变

461
00:18:21,000 --> 00:18:23,000
就是他的内部应该是有一些实现

462
00:18:23,000 --> 00:18:24,000
bug 的

463
00:18:25,000 --> 00:18:27,000
这个东西就是那你要

464
00:18:27,000 --> 00:18:29,000
自律的话看有没有洁癖了对吧

465
00:18:29,000 --> 00:18:33,000
就千万不能用硬回车来称行距对吧

466
00:18:35,000 --> 00:18:40,000
用空格来称字句对吧像这种东西的话本来就是排绑

467
00:18:40,000 --> 00:18:42,000
排绑的首先的这个做法是不一样的

468
00:18:44,000 --> 00:18:45,000
OK

469
00:18:45,000 --> 00:18:47,000
补充一句刚才说的那个中文打字机

470
00:18:48,000 --> 00:18:48,000
我

471
00:18:49,000 --> 00:18:49,000
记得

472
00:18:50,000 --> 00:18:51,000
那个中文打字机

473
00:18:51,000 --> 00:18:53,000
他有一个最大的问题就是他不像英文打字机

474
00:18:54,000 --> 00:18:55,000
英文打字机也有这个问题

475
00:18:55,000 --> 00:18:56,000
但是没那么严重就是

476
00:18:56,000 --> 00:19:01,000
你在用英文打字机的时候你可能按一个键你的力度轻了那个

477
00:19:02,000 --> 00:19:05,000
那个打在纸上的字就会不清楚

478
00:19:05,000 --> 00:19:09,000
中文打字机是如果你力度轻了那字

479
00:19:09,000 --> 00:19:15,000
不清楚也就罢了如果你用力比较重的话那个字那个笔画也比较复杂比如

480
00:19:17,000 --> 00:19:21,000
繁体的什么国家国字啊这种字你打上去那个纸会穿烂的

481
00:19:22,000 --> 00:19:24,000
所以

482
00:19:24,000 --> 00:19:28,000
所以那个时候那个时候不仅打字是一个

483
00:19:28,000 --> 00:19:29,000
要要寻纸

484
00:19:29,000 --> 00:19:31,000
还要控制自己打字的力量

485
00:19:31,000 --> 00:19:32,000
真的是

486
00:19:32,000 --> 00:19:33,000
很累很累

487
00:19:33,000 --> 00:19:35,000
为什么会这样呢

488
00:19:35,000 --> 00:19:40,000
所以他那个他那个按键是不是均匀力度下卷是靠你的那个手的力量来决定的

489
00:19:41,000 --> 00:19:44,000
对其实是把一张纸卷在一个大滚筒上

490
00:19:44,000 --> 00:19:47,000
滚筒是在这个迪卡尔平面上

491
00:19:47,000 --> 00:19:48,000
就

492
00:19:48,000 --> 00:19:49,000
就

493
00:19:49,000 --> 00:19:50,000
就移动了嘛

494
00:19:51,000 --> 00:19:53,000
然后移动的时候你找到一个字

495
00:19:53,000 --> 00:19:54,000
你要把那个

496
00:19:54,000 --> 00:19:57,000
你把那个手里压下去然后我理解是他把那个

497
00:19:58,000 --> 00:19:59,000
签字吸上来

498
00:20:00,000 --> 00:20:01,000
然后

499
00:20:01,000 --> 00:20:02,000
在纸上戳一下

500
00:20:03,000 --> 00:20:05,000
然后这个如果戳的比较狠的话那个纸会破

501
00:20:07,000 --> 00:20:13,000
但我觉得像用键盘的这种打字机他完全是可以用机械设计解决这个问题

502
00:20:13,000 --> 00:20:18,000
对在像 IBM 那种用是用球形的那个打字头打字机他就是

503
00:20:18,000 --> 00:20:20,000
他把输入跟那个

504
00:20:21,000 --> 00:20:23,000
打字的部分分开了就是实际上你是

505
00:20:23,000 --> 00:20:24,000
驱动一个发条

506
00:20:25,000 --> 00:20:28,000
然后那个发条每次会以均匀的力度把那个字打在纸上

507
00:20:28,000 --> 00:20:29,000
对对对

508
00:20:29,000 --> 00:20:30,000
但这个都比较高端了

509
00:20:30,000 --> 00:20:31,000
对这个都比较高端了

510
00:20:32,000 --> 00:20:33,000
就家用的那种就是

511
00:20:33,000 --> 00:20:36,000
尤其是便携的袖针的打字机

512
00:20:36,000 --> 00:20:38,000
都是还是你按你的

513
00:20:38,000 --> 00:20:41,000
手按的力度多大那个字就有多深

514
00:20:42,000 --> 00:20:44,000
怪不得看有些那种那种以前那种

515
00:20:44,000 --> 00:20:47,000
打字机打的文档他有些那个字符的粗细是不一样的

516
00:20:48,000 --> 00:20:48,000
就是因为这个原因是吧

517
00:20:49,000 --> 00:20:49,000
对

518
00:20:49,000 --> 00:20:50,000
就是用力太多

519
00:20:50,000 --> 00:20:51,000
力度的问题

520
00:20:51,000 --> 00:20:52,000
对

521
00:20:52,000 --> 00:20:53,000
OK

522
00:20:53,000 --> 00:20:55,000
这个真的是个手艺化

523
00:20:56,000 --> 00:20:56,000
对

524
00:20:56,000 --> 00:20:57,000
你像那个

525
00:20:57,000 --> 00:20:59,000
那个

526
00:20:59,000 --> 00:21:00,000
IBM 出的打字机里面

527
00:21:01,000 --> 00:21:02,000
Courier

528
00:21:02,000 --> 00:21:03,000
这个字体就是这么来的嘛

529
00:21:04,000 --> 00:21:05,000
就是专门为了他的一个

530
00:21:05,000 --> 00:21:07,000
滚筒式打字机的那个

531
00:21:08,000 --> 00:21:09,000
设计的一套字体

532
00:21:10,000 --> 00:21:11,000
有什么讲究吗

533
00:21:12,000 --> 00:21:16,000
就是等宽嘛那个时候的等宽然后是就有点 slab 的感觉嘛

534
00:21:16,000 --> 00:21:17,000
带一点点衬线量

535
00:21:21,000 --> 00:21:23,000
最近有个新闻可以和大家分享

536
00:21:23,000 --> 00:21:28,000
因为我们前段时间说过那个 emoji 嘛就是表情符号吗刚好 7 月 17 号就是

537
00:21:28,000 --> 00:21:31,000
Emoji 日 7 月 17 号是 emoji 日这个事情你们知道吗

538
00:21:32,000 --> 00:21:32,000
我们提过

539
00:21:33,000 --> 00:21:35,000
我们提过

540
00:21:36,000 --> 00:21:38,000
讲 emoji 那期提过这个事情

541
00:21:39,000 --> 00:21:40,000
为什么是那天我忘了

542
00:21:40,000 --> 00:21:41,000
就是因为那个

543
00:21:42,000 --> 00:21:44,000
Emoji 的那个日历的图标上写的是 7 月 17

544
00:21:45,000 --> 00:21:45,000
对对对

545
00:21:45,000 --> 00:21:48,000
对我相信我那个日历

546
00:21:48,000 --> 00:21:50,000
沿用苹果的那个那个

547
00:21:50,000 --> 00:21:52,000
当时还叫 iCal

548
00:21:52,000 --> 00:21:53,000
的

549
00:21:53,000 --> 00:21:53,000
日子

550
00:21:54,000 --> 00:21:54,000
然后这次

551
00:21:55,000 --> 00:21:57,000
苹果居然在他们官方网站上面

552
00:21:58,000 --> 00:21:58,000
搞一个什么

553
00:21:59,000 --> 00:21:59,000
新闻出来了是吧

554
00:22:00,000 --> 00:22:03,000
预先把今年稍晚推出的那个表情符号跟大家

555
00:22:03,000 --> 00:22:04,000
展示了一下

556
00:22:06,000 --> 00:22:08,000
这是 iOS 11 里面会搭载那套新的

557
00:22:09,000 --> 00:22:12,000
对也就是 6 月份

558
00:22:12,000 --> 00:22:16,000
Unicode 第 10 版里面已经通过的这些

559
00:22:16,000 --> 00:22:19,000
他已经准备好已经画好了嘛

560
00:22:19,000 --> 00:22:20,000
就马上就要

561
00:22:21,000 --> 00:22:22,000
拿出来跟大家用了

562
00:22:23,000 --> 00:22:23,000
那是什么

563
00:22:24,000 --> 00:22:25,000
就是有什么殭尸

564
00:22:25,000 --> 00:22:28,000
有什么带头巾的女人长胡须的人

565
00:22:28,000 --> 00:22:30,000
殭尸和穆斯林是同一个批次的

566
00:22:31,000 --> 00:22:35,000
或者说应该

567
00:22:35,000 --> 00:22:36,000
应该还有什么

568
00:22:36,000 --> 00:22:37,000
饺子和筷子吗不是

569
00:22:38,000 --> 00:22:43,000
我上次在节目我们节目里面说过到底是化成包子还是化成馄饨的那就不知道了

570
00:22:43,000 --> 00:22:45,000
到时候看实现吧

571
00:22:46,000 --> 00:22:50,000
而且现在在那个 iOS 11 的预览那个就是什么

572
00:22:50,000 --> 00:22:52,000
Beta 版你们应该已经可以看得到了吧

573
00:22:53,000 --> 00:22:54,000
你们装的吗

574
00:22:54,000 --> 00:22:55,000
我在 iPad 上装

575
00:22:55,000 --> 00:22:57,000
但还没注意到

576
00:22:57,000 --> 00:22:58,000
看表情

577
00:22:58,000 --> 00:23:00,000
那个 emoji 的变化

578
00:23:00,000 --> 00:23:02,000
好像还没吧

579
00:23:02,000 --> 00:23:03,000
我没装

580
00:23:03,000 --> 00:23:06,000
我也没装

581
00:23:06,000 --> 00:23:06,000
但好像还没上

582
00:23:06,000 --> 00:23:09,000
他上了一个叫做

583
00:23:09,000 --> 00:23:10,000
public beta

584
00:23:10,000 --> 00:23:11,000
上了两次了

585
00:23:11,000 --> 00:23:11,000
对 我知道

586
00:23:11,000 --> 00:23:13,000
但 emoji 好像还没上

587
00:23:13,000 --> 00:23:13,000
巨不稳定

588
00:23:13,000 --> 00:23:15,000
我看好多人都说巨不稳定

589
00:23:15,000 --> 00:23:17,000
我在 iPad 上装的

590
00:23:17,000 --> 00:23:18,000
反正还行

591
00:23:18,000 --> 00:23:19,000
因为这次 iPad 改动比较大

592
00:23:19,000 --> 00:23:20,000
待会我们去看一下

593
00:23:20,000 --> 00:23:22,000
看那个 iPad 上有没有

594
00:23:23,000 --> 00:23:28,000
那现在就可以念

595
00:23:28,000 --> 00:23:31,000
另外一封听众反馈了是吧

596
00:23:31,000 --> 00:23:31,000
可以

597
00:23:31,000 --> 00:23:35,000
好 我来念一下吧

598
00:23:35,000 --> 00:23:38,000
一位没有署名的听众

599
00:23:38,000 --> 00:23:39,000
后来我问了他

600
00:23:39,000 --> 00:23:40,000
我还专门写信

601
00:23:40,000 --> 00:23:41,000
是问了他应该怎么称呼

602
00:23:41,000 --> 00:23:43,000
他说可以称呼他叫 Tiger

603
00:23:43,000 --> 00:23:44,000
老虎

604
00:23:44,000 --> 00:23:47,000
然后这位自称叫老虎的听众

605
00:23:47,000 --> 00:23:48,000
来了一封邮件

606
00:23:48,000 --> 00:23:51,000
说赞美主播并求解两个问题

607
00:23:51,000 --> 00:23:53,000
两位主播好

608
00:23:53,000 --> 00:23:54,000
他是写给自弹自唱的

609
00:23:54,000 --> 00:23:55,000
两位主播好

610
00:23:55,000 --> 00:23:57,000
我是一个通信工程毕业的马农

611
00:23:57,000 --> 00:23:59,000
具体来说是做 iOS 开发的

612
00:23:59,000 --> 00:24:00,000
大概一年前吧

613
00:24:00,000 --> 00:24:02,000
偶然机会发现了你们的播客

614
00:24:02,000 --> 00:24:03,000
一直听到现在

615
00:24:03,000 --> 00:24:05,000
很佩服你们的毅力

616
00:24:05,000 --> 00:24:06,000
能够持续更新

617
00:24:06,000 --> 00:24:07,000
超越了内核恐慌

618
00:24:07,000 --> 00:24:10,000
我是马农

619
00:24:10,000 --> 00:24:12,000
所以最开始听的是内核恐慌

620
00:24:12,000 --> 00:24:13,000
听你们播客过程中

621
00:24:13,000 --> 00:24:14,000
感觉我们很容易超越

622
00:24:14,000 --> 00:24:17,000
我受益匪浅

623
00:24:17,000 --> 00:24:19,000
知道任何东西都不是简简单单的

624
00:24:19,000 --> 00:24:20,000
一个设计作品

625
00:24:20,000 --> 00:24:22,000
或者具体到一个 UI 界面

626
00:24:22,000 --> 00:24:23,000
看起来很舒服

627
00:24:23,000 --> 00:24:25,000
一定是有其背后的道理

628
00:24:25,000 --> 00:24:26,000
我也看了你们推荐的一些书籍

629
00:24:26,000 --> 00:24:27,000
做了一些笔记

630
00:24:27,000 --> 00:24:29,000
这里就不说了

631
00:24:29,000 --> 00:24:30,000
一直以来就想着

632
00:24:30,000 --> 00:24:33,000
就这样被你们任务系无声也挺好的

633
00:24:33,000 --> 00:24:35,000
但是我最近遇到了一些问题

634
00:24:35,000 --> 00:24:37,000
想得到你们的指教

635
00:24:37,000 --> 00:24:39,000
因为有个问题是偏计算机方面

636
00:24:39,000 --> 00:24:40,000
和字体没啥关系

637
00:24:40,000 --> 00:24:42,000
不知道提出来是不是很合适

638
00:24:42,000 --> 00:24:44,000
不过我觉得真语主播一定可以的

639
00:24:44,000 --> 00:24:45,000
其实真语主播不可以

640
00:24:45,000 --> 00:24:46,000
问题

641
00:24:46,000 --> 00:24:50,000
关于中西文混排时的高度

642
00:24:50,000 --> 00:24:53,000
在一个 label 上展示文字时

643
00:24:53,000 --> 00:24:54,000
最终展示的高度如何确定

644
00:24:54,000 --> 00:24:56,000
如果文字只有英文

645
00:24:56,000 --> 00:24:59,000
字号选择是 14 号字

646
00:24:59,000 --> 00:25:01,000
在两倍视网膜屏幕上

647
00:25:01,000 --> 00:25:05,000
那么最后文字的高度不会超过 28 px

648
00:25:05,000 --> 00:25:06,000
虽然他写的是 point

649
00:25:06,000 --> 00:25:07,000
我估计这是个比误

650
00:25:07,000 --> 00:25:09,000
这个高度应该等于

651
00:25:09,000 --> 00:25:11,000
深部线到降部线的高度

652
00:25:11,000 --> 00:25:13,000
如果文字只有中文那么类似

653
00:25:13,000 --> 00:25:16,000
最后文字的高度也不会超过 28 px

654
00:25:16,000 --> 00:25:19,000
虽然中文不一定有深部线和降部线

655
00:25:19,000 --> 00:25:20,000
但是原理是类似的

656
00:25:20,000 --> 00:25:22,000
如果是中英混排

657
00:25:22,000 --> 00:25:22,000
最后文字的高度

658
00:25:22,000 --> 00:25:23,000
会是怎样

659
00:25:23,000 --> 00:25:25,000
我问了我们的设计师

660
00:25:25,000 --> 00:25:28,000
说是会比 28 px 多出一到两个像素

661
00:25:28,000 --> 00:25:30,000
这是什么原因呢

662
00:25:30,000 --> 00:25:31,000
是因为中文和英文的期限

663
00:25:31,000 --> 00:25:32,000
没有对齐吗

664
00:25:32,000 --> 00:25:34,000
希望可以得到主播的解答

665
00:25:34,000 --> 00:25:35,000
问题二

666
00:25:35,000 --> 00:25:37,000
关于多元字不串的

667
00:25:37,000 --> 00:25:39,000
先回答一个再讲吧

668
00:25:39,000 --> 00:25:40,000
这个我给他写了一个邮件

669
00:25:40,000 --> 00:25:43,000
去说明了一下其中一些问题

670
00:25:43,000 --> 00:25:45,000
但是我觉得他对

671
00:25:45,000 --> 00:25:47,000
他们的设计师

672
00:25:47,000 --> 00:25:48,000
对整个渲染机制

673
00:25:48,000 --> 00:25:49,000
可能没有理解

674
00:25:49,000 --> 00:25:51,000
所以说的完全不着调

675
00:25:51,000 --> 00:25:52,000
我还

676
00:25:52,000 --> 00:25:54,000
简单来说一下

677
00:25:54,000 --> 00:25:55,000
首先就是说

678
00:25:55,000 --> 00:25:58,000
iOS 它维护了一套

679
00:25:58,000 --> 00:26:00,000
所谓的逻辑尺寸

680
00:26:00,000 --> 00:26:01,000
就逻辑布局的空间

681
00:26:01,000 --> 00:26:03,000
所以它的这个 point

682
00:26:03,000 --> 00:26:05,000
换算成一个 pixel 的值

683
00:26:05,000 --> 00:26:07,000
并不是一定一比一

684
00:26:07,000 --> 00:26:08,000
一比二一比三

685
00:26:08,000 --> 00:26:10,000
或者是一比几点几的

686
00:26:10,000 --> 00:26:11,000
因为还有像 iPhone plus

687
00:26:11,000 --> 00:26:13,000
这样子奇葩的屏幕分辨率

688
00:26:13,000 --> 00:26:15,000
另外就是用户也可以

689
00:26:15,000 --> 00:26:17,000
调这个屏幕分辨率

690
00:26:17,000 --> 00:26:18,000
就一定成功

691
00:26:18,000 --> 00:26:22,000
就是它可以调这个缩放

692
00:26:22,000 --> 00:26:24,000
比如说你视力不好

693
00:26:24,000 --> 00:26:25,000
对对对

694
00:26:25,000 --> 00:26:27,000
所以你可以调这个

695
00:26:27,000 --> 00:26:29,000
所以这个具体几倍几倍

696
00:26:29,000 --> 00:26:31,000
其实是由操作系统来维护的

697
00:26:31,000 --> 00:26:33,000
那么你只能使用一个逻辑的

698
00:26:33,000 --> 00:26:34,000
这个 point 的这个值

699
00:26:34,000 --> 00:26:37,000
这个值是 iOS 给开发者使用的

700
00:26:37,000 --> 00:26:39,000
所以一个字符

701
00:26:39,000 --> 00:26:40,000
当它被设定成

702
00:26:40,000 --> 00:26:42,000
比如说 14 point 的时候

703
00:26:42,000 --> 00:26:44,000
其实简单来说

704
00:26:44,000 --> 00:26:47,000
我们用一个 typography unit 的概念来说

705
00:26:47,000 --> 00:26:49,000
我们就是将一个 EM 的尺寸

706
00:26:49,000 --> 00:26:51,000
设成了 14 个 point

707
00:26:51,000 --> 00:26:52,000
那么究竟

708
00:26:52,000 --> 00:26:54,000
一个 EM 的 glyph

709
00:26:54,000 --> 00:26:57,000
它的显示的这个尺寸是多少个 point

710
00:26:57,000 --> 00:26:59,000
或者是具体的多少个 pixel

711
00:26:59,000 --> 00:27:01,000
其实完全是由字体来决定的

712
00:27:01,000 --> 00:27:03,000
你可以将一个 EM 的 glyph 设计的

713
00:27:03,000 --> 00:27:04,000
只占一个像素那么大

714
00:27:04,000 --> 00:27:09,000
你也可以设计的超过一个 EM 的方格的空间

715
00:27:09,000 --> 00:27:11,000
这都是没有问题的

716
00:27:11,000 --> 00:27:14,000
所以具体渲染成多少个像素

717
00:27:14,000 --> 00:27:15,000
或者多少个 point

718
00:27:15,000 --> 00:27:17,000
完全是由这个字体来决定的

719
00:27:17,000 --> 00:27:19,000
就跟其他的没有任何关系

720
00:27:19,000 --> 00:27:21,000
就好像是 sub-final

721
00:27:21,000 --> 00:27:22,000
sub-final

722
00:27:22,000 --> 00:27:24,000
你选一个 14 号的 sub-final

723
00:27:24,000 --> 00:27:29,000
最终选出来的一个单词

724
00:27:29,000 --> 00:27:31,000
可能会占 100 乘 200 这么大

725
00:27:31,000 --> 00:27:32,000
这都是有可能的

726
00:27:32,000 --> 00:27:33,000
对

727
00:27:33,000 --> 00:27:35,000
比如说它的 f 就会非常的高

728
00:27:35,000 --> 00:27:36,000
有一个非常长的降步

729
00:27:36,000 --> 00:27:40,000
然后他问那个问题

730
00:27:40,000 --> 00:27:42,000
其实我理解是不是之前也遇到过

731
00:27:42,000 --> 00:27:44,000
就是以前你们记不记得

732
00:27:44,000 --> 00:27:46,000
那个 macOS 的那个 text edit 那个程序

733
00:27:46,000 --> 00:27:48,000
它会跳舞

734
00:27:48,000 --> 00:27:48,000
对

735
00:27:48,000 --> 00:27:50,000
它的那个中英文混排的时候

736
00:27:50,000 --> 00:27:51,000
那个航高是有问题的

737
00:27:51,000 --> 00:27:52,000
它不

738
00:27:52,000 --> 00:27:54,000
它不一致就不稳定

739
00:27:54,000 --> 00:27:55,000
应该是这个问题

740
00:27:55,000 --> 00:27:58,000
这个问题当时好像

741
00:27:58,000 --> 00:27:59,000
我们也讲过好像

742
00:27:59,000 --> 00:28:00,000
对对对

743
00:28:00,000 --> 00:28:01,000
它有个问题就是说

744
00:28:01,000 --> 00:28:02,000
当时的 text edit

745
00:28:02,000 --> 00:28:07,000
好像是以整个文档的第一个字符的那个 font

746
00:28:07,000 --> 00:28:10,000
来决定这个文档的航高是多少的

747
00:28:10,000 --> 00:28:13,000
但是你在这个输入的这个 fly 的过程中

748
00:28:13,000 --> 00:28:15,000
就是这个 input fly 的过程中

749
00:28:15,000 --> 00:28:17,000
它好像又会动态的去调用

750
00:28:17,000 --> 00:28:19,000
当前这个 glyph 的 font

751
00:28:19,000 --> 00:28:22,000
来计算当前这个光标所在位置的航高

752
00:28:22,000 --> 00:28:25,000
所以如果说你是一个多语言

753
00:28:25,000 --> 00:28:26,000
对对对就会有跳动

754
00:28:26,000 --> 00:28:28,000
但现在好像这个问题被改善了

755
00:28:28,000 --> 00:28:30,000
它会预设一个比较大的

756
00:28:30,000 --> 00:28:31,000
因为已经修复

757
00:28:31,000 --> 00:28:33,000
我最近好像没有注意到这个问题了

758
00:28:33,000 --> 00:28:35,000
就暂时出现过了

759
00:28:35,000 --> 00:28:37,000
对已经修复了

760
00:28:37,000 --> 00:28:38,000
嗯

761
00:28:38,000 --> 00:28:41,000
那他问那个就中文和英文这个基线没有对齐

762
00:28:41,000 --> 00:28:42,000
这个事情是可能发生的吗

763
00:28:42,000 --> 00:28:44,000
还是说没有解决这个事

764
00:28:44,000 --> 00:28:46,000
对就是排排眼前来决定的

765
00:28:46,000 --> 00:28:50,000
就中文你可以说是要它的基线来跟

766
00:28:50,000 --> 00:28:51,000
不对

767
00:28:51,000 --> 00:28:52,000
是用中文放

768
00:28:52,000 --> 00:28:57,000
自框的底线和英文的基线对齐

769
00:28:57,000 --> 00:29:03,000
还是用中文线框的底线和英文线框的底线对齐

770
00:29:03,000 --> 00:29:08,000
还是用中文线框的上框上顶端和那个英文的

771
00:29:08,000 --> 00:29:11,000
就是上升部的顶端对齐

772
00:29:11,000 --> 00:29:11,000
这是很多

773
00:29:11,000 --> 00:29:12,000
所以这几种有什么

774
00:29:12,000 --> 00:29:14,000
就是我听出这个区别了

775
00:29:14,000 --> 00:29:16,000
就是说我们日常采取的一半是这种方式

776
00:29:16,000 --> 00:29:19,000
一般是基线对底线吗

777
00:29:19,000 --> 00:29:19,000
我理解

778
00:29:19,000 --> 00:29:21,000
不是一般是基线对支线

779
00:29:22,000 --> 00:29:23,000
对

780
00:29:23,000 --> 00:29:28,000
这就是说在正常的哪怕是中文或者汉字的字体设计里面

781
00:29:28,000 --> 00:29:29,000
现在呢

782
00:29:29,000 --> 00:29:31,000
就是真正的放着门也会画一个基线

783
00:29:31,000 --> 00:29:33,000
虽然说基线也是给西文设计的

784
00:29:33,000 --> 00:29:34,000
但是呢

785
00:29:34,000 --> 00:29:36,000
就是说中文设计首先是有个字框嘛

786
00:29:36,000 --> 00:29:39,000
但是现在的现代字体都会在字框上面再再补一个基线

787
00:29:39,000 --> 00:29:41,000
因为不管怎么样

788
00:29:41,000 --> 00:29:44,000
操作系统的话都是以基线来对齐的

789
00:29:44,000 --> 00:29:47,000
现在无论是放是很多排版引擎

790
00:29:47,000 --> 00:29:49,000
还有很多 web 都是这样

791
00:29:49,000 --> 00:29:52,000
他只他只去调用这个一个

792
00:29:52,000 --> 00:29:54,000
font 里面的基线

793
00:29:54,000 --> 00:29:54,000
所以呢

794
00:29:54,000 --> 00:29:56,000
他就即使是中文字体

795
00:29:56,000 --> 00:29:58,000
他也会设定一个基线

796
00:29:58,000 --> 00:30:03,000
然后在很多的中文日文字体的比如说大家会默认哈

797
00:30:03,000 --> 00:30:07,000
中文的方框是那个字框是一千一千码的一个正方形的话

798
00:30:07,000 --> 00:30:11,000
一般话来讲会把这个极限放在 120 左右

799
00:30:11,000 --> 00:30:16,000
就是底下 120 上面把 880 就是放的这样的一个位置

800
00:30:16,000 --> 00:30:17,000
然后呢

801
00:30:17,000 --> 00:30:18,000
排版引擎的话

802
00:30:18,000 --> 00:30:19,000
不管你是中文还是西文

803
00:30:19,000 --> 00:30:22,000
他都会去调用你这个 font 里面

804
00:30:22,000 --> 00:30:22,000
material

805
00:30:22,000 --> 00:30:25,000
就是 matrix 里面的这个基线的位置

806
00:30:25,000 --> 00:30:27,000
他是按基线对齐的

807
00:30:27,000 --> 00:30:34,000
无论你这个是阿拉伯文还是还是印度的天成文还是中文的汉字

808
00:30:34,000 --> 00:30:36,000
他们都有一个基线的值

809
00:30:36,000 --> 00:30:40,000
所以那个印度天成就是天成文的那个基线在哪

810
00:30:40,000 --> 00:30:43,000
是在靠下的位置还是天成文

811
00:30:43,000 --> 00:30:44,000
他本身的基线

812
00:30:44,000 --> 00:30:45,000
他是汉音

813
00:30:45,000 --> 00:30:46,000
他是挂在上面的

814
00:30:46,000 --> 00:30:47,000
但是呢

815
00:30:47,000 --> 00:30:49,000
他但是他为了混排的话

816
00:30:49,000 --> 00:30:52,000
他也有他在他也在事先设置

817
00:30:52,000 --> 00:30:54,000
自己设计要设一个机械

818
00:30:54,000 --> 00:30:55,000
虽然他不用

819
00:30:55,000 --> 00:30:56,000
名字叫什么

820
00:30:56,000 --> 00:30:57,000
是叫 baseline

821
00:30:57,000 --> 00:30:58,000
就是叫 baseline

822
00:30:58,000 --> 00:30:59,000
就是叫 baseline

823
00:30:59,000 --> 00:31:01,000
然后他本身的那条 hangline 叫什么

824
00:31:01,000 --> 00:31:02,000
叫 hangline 吗

825
00:31:02,000 --> 00:31:05,000
还是那个有天成文他们自己的名字

826
00:31:05,000 --> 00:31:05,000
对

827
00:31:05,000 --> 00:31:06,000
OK

828
00:31:06,000 --> 00:31:07,000
对就是

829
00:31:07,000 --> 00:31:08,000
这个得问了

830
00:31:08,000 --> 00:31:11,000
open type 里面有一个 table 就叫 base

831
00:31:11,000 --> 00:31:20,000
就是 base 这个 table 就是描述的你这条 baseline 的位置在这个原始坐标 00 跟他相对的这个位置在哪里

832
00:31:20,000 --> 00:31:22,000
但其实他默认就在 00 这个位置上了

833
00:31:22,000 --> 00:31:25,000
那么那个你在设一个中文字体的时候呢

834
00:31:25,000 --> 00:31:29,000
你可以将你的这个起点比如说设在零负多少多少

835
00:31:29,000 --> 00:31:32,000
比如说-120 就是 Adobe 常用的一个数字

836
00:31:32,000 --> 00:31:35,000
那么 monotype 可能会有什么-110 之类的

837
00:31:35,000 --> 00:31:39,000
就每个自己厂商他们都会有他自己的 convention 来做这个事情

838
00:31:39,000 --> 00:31:39,000
所以呢

839
00:31:39,000 --> 00:31:42,000
其实这个就是一个普通的字体文件里面

840
00:31:42,000 --> 00:31:48,000
他 metrics 我们叫度量或者量度他的一个设置就自己设计是必须要设置的

841
00:31:48,000 --> 00:31:50,000
然后再由排版引擎去调用

842
00:31:51,000 --> 00:31:51,000
OK

843
00:31:52,000 --> 00:31:55,000
所以就其实不会出现这个中文

844
00:31:55,000 --> 00:31:58,000
因为他问的这个中文和英文极限没对齐的情况

845
00:31:58,000 --> 00:31:58,000
对吧

846
00:31:58,000 --> 00:32:01,000
这个好像还是可以改的吧

847
00:32:01,000 --> 00:32:02,000
就是比如说像我说的

848
00:32:02,000 --> 00:32:04,000
你可以强行说在这个排版的时候

849
00:32:04,000 --> 00:32:10,000
或者说在这个 label 里面让所有字符底端对齐

850
00:32:10,000 --> 00:32:12,000
这个还是可以做到的

851
00:32:12,000 --> 00:32:12,000
可以的

852
00:32:12,000 --> 00:32:15,000
就如果你强行要这么设的话还是可能的

853
00:32:15,000 --> 00:32:20,000
因为像那个 css 里面就是有这个一个这个极限对齐的概念嘛

854
00:32:20,000 --> 00:32:22,000
当然他他他应该没有区分这个多元

855
00:32:22,000 --> 00:32:23,000
本本

856
00:32:23,000 --> 00:32:25,000
他是整个和那个图片的对齐

857
00:32:25,000 --> 00:32:33,000
那想来呃如果一个比较高级的排版引擎应该也可也是可以允许做这种呃比较非标准的操作吧

858
00:32:33,000 --> 00:32:34,000
如果是硬说方面的话

859
00:32:34,000 --> 00:32:38,000
比如说应该在的话呃这个特别尤其是中西文会买的

860
00:32:38,000 --> 00:32:42,000
比如在做复合字体的时候就可以做极限偏移

861
00:32:42,000 --> 00:32:42,000
而且呢

862
00:32:42,000 --> 00:32:46,000
在在更广况呃在广的范围来讲

863
00:32:46,000 --> 00:32:48,000
比如说把一个数字做成上标或者下标

864
00:32:48,000 --> 00:32:51,000
这其实也是一种极限偏移

865
00:32:51,000 --> 00:32:58,000
就是在不同的不同的环境下不同的这个排版引擎啊都是有这样的功能的

866
00:32:58,000 --> 00:33:01,000
嗯那具体在 css 的话是另外的实现吧

867
00:33:01,000 --> 00:33:01,000
对吧

868
00:33:01,000 --> 00:33:03,000
对 css 他是这样的

869
00:33:03,000 --> 00:33:05,000
就是嗯他的机制比较麻烦

870
00:33:05,000 --> 00:33:10,000
他有一个所谓的 linebox 和这个 inlinebox 的概念

871
00:33:10,000 --> 00:33:20,000
所以就是当他都放到核对他会把一个行内的一小段字符串计算他一个很小的一个矩形

872
00:33:20,000 --> 00:33:21,000
然后举行的这个高度

873
00:33:21,000 --> 00:33:22,000
会有一个高度

874
00:33:22,000 --> 00:33:26,000
然后极限会在这个矩形内部的一个相对位置里面

875
00:33:26,000 --> 00:33:35,000
然后这个时候 css 的那个 verticalalign 这个属性这个 property 里面设了几种值就会来决定这个极限之间相互对齐的关系

876
00:33:35,000 --> 00:33:38,000
但这个 verticalalign 的这个属性呃非常的不直观

877
00:33:38,000 --> 00:33:42,000
就这是我觉得这是 css 设计的一个缺陷吧

878
00:33:42,000 --> 00:33:43,000
就是对于入门者来说

879
00:33:43,000 --> 00:33:47,000
你很难很难去直观的感受到你做了哪些对齐

880
00:33:47,000 --> 00:33:49,000
因为你有的时候选 middle 对齐的时候

881
00:33:49,000 --> 00:33:49,000
你发现他其实并不是你预计的一个缺陷吧

882
00:33:49,000 --> 00:33:50,000
你发现他其实并不是你预计的一个缺陷吧

883
00:33:50,000 --> 00:33:52,000
你发现他其实并不是你预计的那种 middle 的方式

884
00:33:52,000 --> 00:33:55,000
他是以他定义的那种 middle 的方式

885
00:33:55,000 --> 00:33:59,000
然后 base line 是默认的一种对齐方式

886
00:33:59,000 --> 00:34:02,000
这个还和字体有关系吧

887
00:34:02,000 --> 00:34:04,000
css 他会比较简单

888
00:34:04,000 --> 00:34:09,000
他会对一段文字使用同一种字体的这个参数来计算

889
00:34:09,000 --> 00:34:14,000
这个这个 linebox 的高度的这样一个属性

890
00:34:14,000 --> 00:34:16,000
对但是这个这个 linebox 的高度

891
00:34:16,000 --> 00:34:18,000
他他算起来就不是很准

892
00:34:18,000 --> 00:34:20,000
他也不是在所有地方都很准的

893
00:34:20,000 --> 00:34:23,000
而且他首先他会调用

894
00:34:23,000 --> 00:34:26,000
就是因为如果你是调用一个中文字体的话

895
00:34:26,000 --> 00:34:28,000
中文字体内部也有西文嘛

896
00:34:28,000 --> 00:34:31,000
就首先他会调用一个字体设计师

897
00:34:31,000 --> 00:34:34,000
他本身设定好的就是中西文的那个机械

898
00:34:34,000 --> 00:34:36,000
就这个因为这个你调用的字体

899
00:34:36,000 --> 00:34:39,000
font 本身是有这个有这个信息的

900
00:34:39,000 --> 00:34:41,000
然后他要拿到这个信息的话

901
00:34:41,000 --> 00:34:43,000
在这个信息再继续调整嘛

902
00:34:43,000 --> 00:34:46,000
对但是 css 有个问题就是说

903
00:34:46,000 --> 00:34:50,000
他在计算一个 linebox 的这个高度的时候

904
00:34:50,000 --> 00:34:54,000
他默认是按 css 设定的那个 lineheight 的那个数值来计算的

905
00:34:54,000 --> 00:34:54,000
啊

906
00:34:54,000 --> 00:35:01,000
对但这个 lineheight 的值未必跟字体设计师定义的那个默认的 lineheight 是一样的

907
00:35:01,000 --> 00:35:03,000
所以这个时候基线应该放在什么位置

908
00:35:03,000 --> 00:35:05,000
其实是有一点问题的

909
00:35:05,000 --> 00:35:07,000
有的时候是会出 bug 的

910
00:35:07,000 --> 00:35:11,000
lineheight 的话就是我们说中文就是航高嘛

911
00:35:11,000 --> 00:35:12,000
对对对

912
00:35:12,000 --> 00:35:14,000
大家也知道 css 里面航高的话

913
00:35:14,000 --> 00:35:18,000
他是要把航间距除以二

914
00:35:18,000 --> 00:35:19,000
一半放上面

915
00:35:20,000 --> 00:35:21,000
一半放下面

916
00:35:21,000 --> 00:35:21,000
对对对

917
00:35:21,000 --> 00:35:23,000
那个盒子的对

918
00:35:23,000 --> 00:35:25,000
所以这个盒子是怎么怎么算的

919
00:35:25,000 --> 00:35:27,000
可是比较麻烦的一件事情

920
00:35:27,000 --> 00:35:31,000
对特别是你多种字体混合组组合的时候

921
00:35:31,000 --> 00:35:32,000
会有些问题

922
00:35:32,000 --> 00:35:33,000
不同字体

923
00:35:33,000 --> 00:35:36,000
而且是不同字号的时候会非常麻烦

924
00:35:36,000 --> 00:35:37,000
啊对

925
00:35:37,000 --> 00:35:42,000
OK 他他问了第二个问题啊

926
00:35:42,000 --> 00:35:44,000
是关于这个多语言字符串

927
00:35:44,000 --> 00:35:47,000
关于多语言字符串的排序和所以

928
00:35:47,000 --> 00:35:48,000
这个要讲吗

929
00:35:49,000 --> 00:35:49,000
这个是我们

930
00:35:49,000 --> 00:35:50,000
这个是我们的问题啊

931
00:35:50,000 --> 00:35:51,000
今天我们要说的有点关系

932
00:35:51,000 --> 00:35:53,000
有点关系或者说

933
00:35:53,000 --> 00:35:57,000
要不我们等到后面专门一起来讲的排序

934
00:35:57,000 --> 00:36:01,000
因为对要不我们就先念一下他这个邮件吧

935
00:36:01,000 --> 00:36:02,000
就答不答再说了

936
00:36:02,000 --> 00:36:05,000
如今是多元国际化的时代

937
00:36:05,000 --> 00:36:08,000
多元字符串排序和所有的规则是什么呢

938
00:36:08,000 --> 00:36:10,000
iPhone 通讯录中姓名的排序规则是什么呢

939
00:36:10,000 --> 00:36:12,000
对于整个问题我自己也做了

940
00:36:12,000 --> 00:36:14,000
我自己也做了一些研究

941
00:36:14,000 --> 00:36:16,000
大致是 unicode 给出了一套规则

942
00:36:16,000 --> 00:36:18,000
根据这个规则来实现就好了

943
00:36:18,000 --> 00:36:19,000
但是 unicode 的文字

944
00:36:19,000 --> 00:36:22,000
党卷纸好凡吗

945
00:36:22,000 --> 00:36:24,000
这是卷纸

946
00:36:24,000 --> 00:36:25,000
我实在无能为力

947
00:36:25,000 --> 00:36:26,000
卷义

948
00:36:26,000 --> 00:36:29,000
这是一字吗

949
00:36:29,000 --> 00:36:30,000
就纸吧

950
00:36:30,000 --> 00:36:32,000
对卷纸

951
00:36:32,000 --> 00:36:35,000
卷纸好凡

952
00:36:35,000 --> 00:36:38,000
各位主播暴露了自己的文化修养

953
00:36:38,000 --> 00:36:38,000
对

954
00:36:38,000 --> 00:36:41,000
我实在无能为力完全搞懂

955
00:36:41,000 --> 00:36:43,000
我自己总结了一点东西

956
00:36:43,000 --> 00:36:44,000
写了三篇文章放在博客上

957
00:36:44,000 --> 00:36:46,000
希望可以得到两位主播的指点

958
00:36:46,000 --> 00:36:49,000
同时我自己也有一点问题没有搞明白

959
00:36:49,000 --> 00:36:49,000
第一

960
00:36:49,000 --> 00:36:49,000
我自己总结了一点东西

961
00:36:49,000 --> 00:36:52,000
所以时指定的排序规则是什么呢

962
00:36:52,000 --> 00:36:53,000
似乎是按照拼音

963
00:36:53,000 --> 00:36:55,000
但是中文和英文交织

964
00:36:55,000 --> 00:36:58,000
并不是中文一定在英文前面或者后面

965
00:36:58,000 --> 00:37:00,000
怎样得到每个汉字的读音呢

966
00:37:00,000 --> 00:37:03,000
在指定汉字顺序的

967
00:37:03,000 --> 00:37:06,000
zh.xml

968
00:37:06,000 --> 00:37:07,000
这是一个文件

969
00:37:07,000 --> 00:37:10,000
汉字读音在

970
00:37:10,000 --> 00:37:13,000
在警号之后似乎是被注释掉了

971
00:37:13,000 --> 00:37:14,000
那么怎么知道汉字的读音呢

972
00:37:14,000 --> 00:37:15,000
具体来说

973
00:37:15,000 --> 00:37:17,000
左边的读音是左边

974
00:37:17,000 --> 00:37:19,000
它写的是一个拼音的左边

975
00:37:19,000 --> 00:37:19,000
所以是一个拼音的左边

976
00:37:19,000 --> 00:37:21,000
是怎么被确定的呢

977
00:37:21,000 --> 00:37:23,000
这个问题和字体排音没啥关系

978
00:37:23,000 --> 00:37:25,000
和你们做的 unicode 串台节目

979
00:37:25,000 --> 00:37:26,000
有那么一点点关系

980
00:37:26,000 --> 00:37:27,000
所以希望可以得到解答

981
00:37:27,000 --> 00:37:30,000
这个问题已经困扰我好久好久了

982
00:37:30,000 --> 00:37:35,000
它应该是拿了一个什么 database 来做这个排序吧

983
00:37:35,000 --> 00:37:38,000
这个事比较复杂

984
00:37:38,000 --> 00:37:39,000
那个 iPhone 的那个通讯

985
00:37:39,000 --> 00:37:40,000
就 iOS 通讯楼上面

986
00:37:40,000 --> 00:37:42,000
它有一个这个机制

987
00:37:42,000 --> 00:37:42,000
就可能很多

988
00:37:42,000 --> 00:37:44,000
iPhone 上我不知道有没有办法添加

989
00:37:44,000 --> 00:37:47,000
在 Mac 上是可以给那个联系人的名字

990
00:37:47,000 --> 00:37:49,000
加一个叫做 phonetic

991
00:37:49,000 --> 00:37:51,000
对 注音

992
00:37:51,000 --> 00:37:52,000
这也是我想说的

993
00:37:52,000 --> 00:37:54,000
它有一个 phonetic

994
00:37:54,000 --> 00:37:56,000
还有一个另外一个注音

995
00:37:56,000 --> 00:37:58,000
就除了 phonetic 之外

996
00:37:58,000 --> 00:37:59,000
还有另外一个注音

997
00:37:59,000 --> 00:38:01,000
我忘了叫什么了暂时

998
00:38:01,000 --> 00:38:06,000
然后这两个可以拿来做排序的依据

999
00:38:06,000 --> 00:38:10,000
但是排序的时候的那个

1000
00:38:10,000 --> 00:38:12,000
比如说你用中文

1001
00:38:12,000 --> 00:38:14,000
就是你把系统设成中文的时候

1002
00:38:14,000 --> 00:38:16,000
排序规则跟设成英文的时候

1003
00:38:16,000 --> 00:38:17,000
排序规则不一样

1004
00:38:17,000 --> 00:38:19,000
那哪怕你用中文的时候

1005
00:38:19,000 --> 00:38:22,000
你设成中文也可以用不同的排序

1006
00:38:22,000 --> 00:38:24,000
比如如果大家用 Mac 的话

1007
00:38:24,000 --> 00:38:27,000
打开那个系统批号设置的语言地区那边

1008
00:38:27,000 --> 00:38:31,000
就专门有一个列表排列顺序的一个设置

1009
00:38:31,000 --> 00:38:34,000
然后中文默认是拼音顺序

1010
00:38:34,000 --> 00:38:36,000
但是中文你也可以用

1011
00:38:36,000 --> 00:38:39,000
比如说你用笔画顺序也可以

1012
00:38:39,000 --> 00:38:42,000
用 GB 的内码的顺序也可以

1013
00:38:42,000 --> 00:38:44,000
对 但是在手机上面有这个设置吗

1014
00:38:44,000 --> 00:38:48,000
跟你的语言环境有关系

1015
00:38:48,000 --> 00:38:49,000
就我的理解是

1016
00:38:49,000 --> 00:38:52,000
你还用那个

1017
00:38:52,000 --> 00:38:55,000
你就比如说你在 Mac 上面可以说

1018
00:38:55,000 --> 00:38:57,000
我的系统语言是英语

1019
00:38:57,000 --> 00:39:01,000
但是我的第三 preferred language 是中文

1020
00:39:01,000 --> 00:39:04,000
与此同时

1021
00:39:04,000 --> 00:39:08,000
我可以把那个 list source order 设成中文的

1022
00:39:08,000 --> 00:39:11,000
比如说笔画排序或者是注音排序

1023
00:39:11,000 --> 00:39:13,000
但是在 iPhone 上是没有这个设定的

1024
00:39:13,000 --> 00:39:16,000
就是你不能说系统语言是中文

1025
00:39:16,000 --> 00:39:17,000
系统语言是英文的同时

1026
00:39:17,000 --> 00:39:19,000
你还可以指定中文的排序方式

1027
00:39:19,000 --> 00:39:22,000
我以前在推上好像是跟金雷

1028
00:39:22,000 --> 00:39:25,000
还是谁去研究过这个问题

1029
00:39:25,000 --> 00:39:30,000
就是他想说手机的系统是英文的同时

1030
00:39:30,000 --> 00:39:35,000
还可以让通讯录按照中文的笔画出去排序

1031
00:39:35,000 --> 00:39:35,000
好像是

1032
00:39:35,000 --> 00:39:38,000
但后来发现这个其实做不到的

1033
00:39:38,000 --> 00:39:41,000
当时我产生的一个状态是

1034
00:39:41,000 --> 00:39:43,000
我先把手机设成中文

1035
00:39:43,000 --> 00:39:49,000
然后发现通讯录被用中文 iOS 的默认通讯录排序

1036
00:39:49,000 --> 00:39:49,000
是中文的通讯录排序

1037
00:39:49,000 --> 00:39:49,000
然后发现通讯录被用中文 iOS 的默认通讯录排序

1038
00:39:49,000 --> 00:39:50,000
是什么来着

1039
00:39:50,000 --> 00:39:51,000
是注音

1040
00:39:51,000 --> 00:39:51,000
拼音吧

1041
00:39:51,000 --> 00:39:53,000
应该是拼音

1042
00:39:53,000 --> 00:39:53,000
OK

1043
00:39:53,000 --> 00:39:57,000
然后当我切换回英文系统的时候

1044
00:39:57,000 --> 00:39:59,000
这个排序是得以保留的

1045
00:39:59,000 --> 00:40:03,000
但是只要我往里面新加一个通讯录的

1046
00:40:03,000 --> 00:40:05,000
只要我往里面新加一个联络人

1047
00:40:05,000 --> 00:40:08,000
整个排序就变成了英文排序

1048
00:40:08,000 --> 00:40:12,000
然后所有的中文会被集中堆在后面

1049
00:40:12,000 --> 00:40:13,000
除非你设定了那个

1050
00:40:13,000 --> 00:40:14,000
Phonetic

1051
00:40:14,000 --> 00:40:16,000
Spelling

1052
00:40:16,000 --> 00:40:17,000
就 Pronunciation

1053
00:40:17,000 --> 00:40:19,000
它才会在英文的部分出现

1054
00:40:19,000 --> 00:40:22,000
我的情况

1055
00:40:22,000 --> 00:40:25,000
我的 iPhone 是设置成日文状态的

1056
00:40:25,000 --> 00:40:26,000
然后呢

1057
00:40:26,000 --> 00:40:29,000
所以打开我的那个通讯录的时候呢

1058
00:40:29,000 --> 00:40:30,000
因为日文状态

1059
00:40:30,000 --> 00:40:32,000
它会默认用那首先日文排序嘛

1060
00:40:32,000 --> 00:40:34,000
首先右边那个 Index

1061
00:40:34,000 --> 00:40:38,000
右边不是有个快速的可以转播那个 Index 吗

1062
00:40:38,000 --> 00:40:39,000
如果是这样的话

1063
00:40:39,000 --> 00:40:40,000
在日文状态的话

1064
00:40:40,000 --> 00:40:42,000
首先它会有日文的 Akasatana 的顺序

1065
00:40:42,000 --> 00:40:44,000
然后后面还有 26 个字母的顺序

1066
00:40:44,000 --> 00:40:45,000
所以呢

1067
00:40:45,000 --> 00:40:46,000
在这样的状态

1068
00:40:46,000 --> 00:40:48,000
日文和英文首先是分开的

1069
00:40:48,000 --> 00:40:49,000
然后呢

1070
00:40:49,000 --> 00:40:49,000
呃

1071
00:40:49,000 --> 00:40:51,000
因为我系统默认是日文

1072
00:40:51,000 --> 00:40:52,000
所以首先呢

1073
00:40:52,000 --> 00:40:54,000
汉字呢是按照那个日文顺序排的

1074
00:40:54,000 --> 00:40:55,000
呃

1075
00:40:55,000 --> 00:40:57,000
然后如果我

1076
00:40:57,000 --> 00:40:58,000
当然我这里面有中国朋友

1077
00:40:58,000 --> 00:41:00,000
我把中国朋友

1078
00:41:00,000 --> 00:41:02,000
如果我不不加注音的话

1079
00:41:02,000 --> 00:41:06,000
他的中文汉字的是所有是堆在底下的

1080
00:41:06,000 --> 00:41:06,000
但是呢

1081
00:41:06,000 --> 00:41:09,000
我如果那个对警号的对

1082
00:41:09,000 --> 00:41:10,000
但是呢

1083
00:41:10,000 --> 00:41:11,000
如果我呃

1084
00:41:11,000 --> 00:41:14,000
因为这个注音这个词在日文是非常常见的

1085
00:41:14,000 --> 00:41:15,000
因为日本人的汉字

1086
00:41:15,000 --> 00:41:16,000
如果你不加读

1087
00:41:16,000 --> 00:41:17,000
根本都不知道他怎么念

1088
00:41:17,000 --> 00:41:18,000
所以在一般来

1089
00:41:18,000 --> 00:41:19,000
对

1090
00:41:19,000 --> 00:41:21,000
他如果是开成日文以后

1091
00:41:21,000 --> 00:41:24,000
他会默认首先把那个注音的那个 field 打开

1092
00:41:24,000 --> 00:41:26,000
他会让你写中文的话

1093
00:41:26,000 --> 00:41:28,000
可能有时候他他默认不打开

1094
00:41:28,000 --> 00:41:30,000
很多人都不知道有这样一个 field

1095
00:41:30,000 --> 00:41:31,000
啊

1096
00:41:31,000 --> 00:41:32,000
在你日文的话

1097
00:41:32,000 --> 00:41:33,000
那个 field 默认是打开的

1098
00:41:33,000 --> 00:41:36,000
你可以往里面填那个你这个词怎么念

1099
00:41:36,000 --> 00:41:36,000
然后呢

1100
00:41:36,000 --> 00:41:40,000
我个人的做法是把这个中文的名字把它拼音写上去

1101
00:41:40,000 --> 00:41:41,000
这样的话呢

1102
00:41:41,000 --> 00:41:45,000
在我的手机方位里面的日本人就在在假名那一堆

1103
00:41:45,000 --> 00:41:49,000
然后中国人就按照拼音放在这个 alphabet 的这这这一堆

1104
00:41:49,000 --> 00:41:50,000
我个人是这样区分的

1105
00:41:50,000 --> 00:41:51,000
哦

1106
00:41:51,000 --> 00:41:51,000
哎

1107
00:41:51,000 --> 00:41:53,000
这样非常好啊

1108
00:41:53,000 --> 00:41:54,000
但是很麻烦啊

1109
00:41:54,000 --> 00:41:56,000
你你要每个人是一个非常淡的事情

1110
00:41:56,000 --> 00:41:58,000
对对

1111
00:41:58,000 --> 00:42:03,000
所以所以在那个麦克上面就是我们的朋友就是江江

1112
00:42:03,000 --> 00:42:10,000
他之前写过一个小软件就是自动给那个通讯录里面的中文名字的人标注他的那个 phone

1113
00:42:10,000 --> 00:42:11,000
nighting names

1114
00:42:11,000 --> 00:42:14,000
就是风天那个的姓和名就叫他

1115
00:42:14,000 --> 00:42:17,000
他就可以在英文环境下啊

1116
00:42:17,000 --> 00:42:18,000
还可以按照那个读音来排序啊

1117
00:42:18,000 --> 00:42:23,000
对这件事情比较适合脚本来做

1118
00:42:23,000 --> 00:42:23,000
对对

1119
00:42:23,000 --> 00:42:26,000
但 iPhone 上好像就这个我不知道有人有没有

1120
00:42:26,000 --> 00:42:27,000
那应该也是可以的

1121
00:42:27,000 --> 00:42:29,000
就是把数据导一下吗

1122
00:42:29,000 --> 00:42:29,000
对对

1123
00:42:29,000 --> 00:42:32,000
因为那个就是通讯录是可以访问的吗

1124
00:42:32,000 --> 00:42:33,000
通过 API

1125
00:42:33,000 --> 00:42:34,000
然后你去对对改一下

1126
00:42:34,000 --> 00:42:37,000
但这里就会牵涉到他问的那个第二个问题

1127
00:42:37,000 --> 00:42:38,000
就怎样得到一个汉字的读音

1128
00:42:38,000 --> 00:42:42,000
因为这个比较简单的我就是有一个有一个那个对照表的

1129
00:42:42,000 --> 00:42:44,000
就是汉字和他的那个拼音的对照表的

1130
00:42:44,000 --> 00:42:47,000
这个是这个是很多系统里面都自带的

1131
00:42:47,000 --> 00:42:48,000
但这个比较 tricky 的

1132
00:42:48,000 --> 00:42:48,000
就是说

1133
00:42:48,000 --> 00:42:51,000
有些是是是那个多音字

1134
00:42:51,000 --> 00:42:53,000
这个时候特别是在那个名字里面

1135
00:42:53,000 --> 00:42:57,000
他有些很多是飞镖没有没有就不去不太具备这个参考意义的

1136
00:42:57,000 --> 00:42:59,000
比如说有些有些字的多音字

1137
00:42:59,000 --> 00:43:03,000
你是可以通过这个上下文的语义来看出他是念哪个的吗

1138
00:43:03,000 --> 00:43:06,000
但是在名字里面其实是一个非常

1139
00:43:06,000 --> 00:43:07,000
up to 的一个事情

1140
00:43:07,000 --> 00:43:11,000
比如说有一个朋友叫叫那个就是草字头

1141
00:43:11,000 --> 00:43:13,000
一个下面东南西北的西字那个字

1142
00:43:13,000 --> 00:43:14,000
他可以念西

1143
00:43:14,000 --> 00:43:15,000
可以念欠对吧

1144
00:43:15,000 --> 00:43:16,000
对对嗯

1145
00:43:16,000 --> 00:43:17,000
在在名字里面

1146
00:43:17,000 --> 00:43:18,000
很多人都是把它

1147
00:43:18,000 --> 00:43:19,000
念欠的对吧

1148
00:43:19,000 --> 00:43:24,000
但其实在他在选择的时候就把它念成念西

1149
00:43:24,000 --> 00:43:25,000
这个时候你说你怎么办

1150
00:43:25,000 --> 00:43:27,000
他你没有办法

1151
00:43:27,000 --> 00:43:28,000
对这点还好

1152
00:43:28,000 --> 00:43:33,000
另外有一个问题就是有些人的这个信的同一个字的写法

1153
00:43:33,000 --> 00:43:35,000
他都是甚至都有不一样的念法

1154
00:43:36,000 --> 00:43:41,000
信的话一般做新的那个音会会比较比较特殊的

1155
00:43:41,000 --> 00:43:44,000
就有一些会有白白白读嘛

1156
00:43:44,000 --> 00:43:47,000
然后这个白读又会被这个当成一种传统

1157
00:43:47,000 --> 00:43:48,000
比如说那个

1158
00:43:48,000 --> 00:43:52,000
最我我印象最深的就是有一个信叫盖嘛

1159
00:43:52,000 --> 00:43:53,000
你知道吗

1160
00:43:53,000 --> 00:43:57,000
就是盖子的盖盖教天有一个经济员嗯对

1161
00:43:57,000 --> 00:44:01,000
但是这个信其实他在念信的时候一个比较规范的话应该念葛

1162
00:44:02,000 --> 00:44:04,000
嗯对

1163
00:44:04,000 --> 00:44:08,000
但是很多人都觉得普数普数这个调数调

1164
00:44:08,000 --> 00:44:10,000
那种调的对对对

1165
00:44:10,000 --> 00:44:12,000
不过他这个韩国人来是小众吧

1166
00:44:12,000 --> 00:44:15,000
他应该是一个艺名之类的小众

1167
00:44:15,000 --> 00:44:18,000
但那个盖和葛的问题就是很多人他都希望自己

1168
00:44:18,000 --> 00:44:20,000
被念成叫盖

1169
00:44:20,000 --> 00:44:22,000
就是不要改成葛这个音

1170
00:44:22,000 --> 00:44:25,000
但是有一些人他可能祖上传下一直都念葛

1171
00:44:25,000 --> 00:44:27,000
所以他又希望这个字念葛

1172
00:44:27,000 --> 00:44:30,000
所以这个字念什么音其实也是不一样的

1173
00:44:30,000 --> 00:44:33,000
就是就是所以就是说这刚才讲那个问题就姓名里面

1174
00:44:33,000 --> 00:44:36,000
这个读音是没有一个规则可以参考

1175
00:44:36,000 --> 00:44:40,000
因为很多是靠他自己自定的一个选择来怎么念的

1176
00:44:40,000 --> 00:44:42,000
这个事情就很非常尴尬

1177
00:44:42,000 --> 00:44:47,000
对而且这个问题其实并不仅仅是中文

1178
00:44:47,000 --> 00:44:48,000
或者是在在

1179
00:44:48,000 --> 00:44:50,000
在表意文字才有的

1180
00:44:50,000 --> 00:44:53,000
就在英文或者说在拉丁语

1181
00:44:53,000 --> 00:44:56,000
拉丁字符世界甚至是拼音字符世界也是有的

1182
00:44:56,000 --> 00:45:02,000
比如说前阵子被韩国被被朝鲜弄死的那个美国人

1183
00:45:02,000 --> 00:45:04,000
他的名字叫做

1184
00:45:04,000 --> 00:45:06,000
Warm Beer

1185
00:45:06,000 --> 00:45:08,000
就是你如果你是一个美国人的话

1186
00:45:08,000 --> 00:45:09,000
你念他的名字

1187
00:45:09,000 --> 00:45:11,000
你会念成 Warm Beer

1188
00:45:11,000 --> 00:45:12,000
然后有一天

1189
00:45:12,000 --> 00:45:14,000
但是 Warm 和 Beer 这两个词

1190
00:45:14,000 --> 00:45:16,000
就是第一道的德语词

1191
00:45:16,000 --> 00:45:18,000
包括这个人的整个的名字

1192
00:45:18,000 --> 00:45:18,000
他的名字叫什么

1193
00:45:18,000 --> 00:45:20,000
Otto Warm Beer

1194
00:45:20,000 --> 00:45:23,000
这一听就是一个德国后裔

1195
00:45:23,000 --> 00:45:24,000
你知道吧

1196
00:45:24,000 --> 00:45:28,000
就是那种感觉就好像就好像这这种感觉很奇怪

1197
00:45:28,000 --> 00:45:30,000
就好像你你是一个华人

1198
00:45:30,000 --> 00:45:32,000
然后现在中国人已经是什么

1199
00:45:32,000 --> 00:45:35,000
跑去我们这一代

1200
00:45:35,000 --> 00:45:38,000
就是很多人都是双字名的

1201
00:45:38,000 --> 00:45:41,000
现在的中国小孩都起什么

1202
00:45:41,000 --> 00:45:43,000
什么义轩呀

1203
00:45:43,000 --> 00:45:44,000
子轩呀

1204
00:45:44,000 --> 00:45:46,000
什么这种非常

1205
00:45:46,000 --> 00:45:47,000
又能

1206
00:45:47,000 --> 00:45:49,000
说不出来奇怪在哪

1207
00:45:49,000 --> 00:45:51,000
但是有点奇怪的名字

1208
00:45:51,000 --> 00:45:55,000
然后后来有一天你发现一个在美国出生的土生土长的华裔

1209
00:45:55,000 --> 00:45:58,000
名字叫曾国藩或者左宗棠

1210
00:45:58,000 --> 00:46:02,000
这种感觉就非常非常古典

1211
00:46:02,000 --> 00:46:04,000
就是对就是 Otto

1212
00:46:04,000 --> 00:46:05,000
他的中名是什么来着

1213
00:46:05,000 --> 00:46:07,000
Friedrich

1214
00:46:07,000 --> 00:46:08,000
对 Otto

1215
00:46:08,000 --> 00:46:10,000
奥托弗雷德里克

1216
00:46:10,000 --> 00:46:13,000
Warm Beer

1217
00:46:13,000 --> 00:46:14,000
这样一个名字

1218
00:46:14,000 --> 00:46:15,000
这个名字

1219
00:46:15,000 --> 00:46:16,000
如果你

1220
00:46:16,000 --> 00:46:17,000
如果他是一个德国人的话

1221
00:46:17,000 --> 00:46:22,000
那么他的名字会变成 Warm Beer

1222
00:46:22,000 --> 00:46:23,000
但如果他是一个美国人的话

1223
00:46:24,000 --> 00:46:25,000
包括德国人念

1224
00:46:25,000 --> 00:46:29,000
他在广播里面念这个人的名字的时候都会念成 Warm Beer

1225
00:46:29,000 --> 00:46:33,000
就是按美语的发音来来来来来念

1226
00:46:33,000 --> 00:46:38,000
所以这就是为什么刚才说到那个在 iPhone 的联系人里面

1227
00:46:38,000 --> 00:46:44,000
你可以给他添加两个额外的项目

1228
00:46:44,000 --> 00:46:45,000
一个叫做 Prononation

1229
00:46:45,000 --> 00:46:46,000
一个叫做 Prononation

1230
00:46:46,000 --> 00:46:47,000
一个叫做 Prononation

1231
00:46:47,000 --> 00:46:49,000
Spelling

1232
00:46:49,000 --> 00:46:51,000
Prononation Name

1233
00:46:51,000 --> 00:46:53,000
另外一个叫做 Phonetic Name

1234
00:46:53,000 --> 00:46:55,000
就是我记得这两个之中

1235
00:46:55,000 --> 00:47:00,000
一个会被 Siri 拿来当作发音的依据

1236
00:47:00,000 --> 00:47:01,000
对

1237
00:47:01,000 --> 00:47:03,000
对就比如说你

1238
00:47:03,000 --> 00:47:05,000
比如说吴涛这两个字

1239
00:47:05,000 --> 00:47:07,000
你可以在

1240
00:47:07,000 --> 00:47:15,000
在 Phonetic Name 里面写 W U T A O

1241
00:47:15,000 --> 00:47:16,000
但是在

1242
00:47:16,000 --> 00:47:24,000
Prononation 里面你可以写 W O O-T A U

1243
00:47:24,000 --> 00:47:25,000
比如说

1244
00:47:25,000 --> 00:47:30,000
然后 Siri 会试着用 Wu Tau 这个方法来念这个名字

1245
00:47:30,000 --> 00:47:34,000
Prononation 就纯粹是给那个语音生成那个合成器用的

1246
00:47:34,000 --> 00:47:36,000
对我是这么理解的

1247
00:47:36,000 --> 00:47:38,000
但当然我我从来没有用过

1248
00:47:38,000 --> 00:47:40,000
但我相信用过的人可以应该可以知道

1249
00:47:40,000 --> 00:47:45,000
比如说你可以让你可以用这个功能来告诉 Siri 说打电话给谁是谁的名字

1250
00:47:45,000 --> 00:47:46,000
比如说你可以让你可以用这个功能来告诉 Siri 说打电话给谁是谁的名字

1251
00:47:46,000 --> 00:47:48,000
实现这样一个功能

1252
00:47:48,000 --> 00:47:49,000
还有一个更直接的办法

1253
00:47:49,000 --> 00:47:51,000
就是 Siri 的话

1254
00:47:51,000 --> 00:47:52,000
你可以直接你直接语音

1255
00:47:52,000 --> 00:47:55,000
教他把这个字念成什么

1256
00:47:55,000 --> 00:47:57,000
对对

1257
00:47:57,000 --> 00:47:58,000
啊

1258
00:47:58,000 --> 00:47:59,000
这样啊

1259
00:47:59,000 --> 00:48:00,000
对所以呢

1260
00:48:00,000 --> 00:48:07,000
就专门有这样的一个 Field 是给语音合成器来教他念读音的这样一个 Field

1261
00:48:07,000 --> 00:48:09,000
这个 Field 好像只有这个 iOS 上才有

1262
00:48:09,000 --> 00:48:10,000
Mac 上是没有这个 Field

1263
00:48:10,000 --> 00:48:12,000
我刚刚有检查了一点

1264
00:48:12,000 --> 00:48:14,000
对因为因为 Mac 上之前没有 Siri 嘛

1265
00:48:14,000 --> 00:48:15,000
所以估计没做

1266
00:48:15,000 --> 00:48:16,000
但现在 Mac 上也有 Siri

1267
00:48:16,000 --> 00:48:17,000
现在有了呀

1268
00:48:17,000 --> 00:48:18,000
怎么办

1269
00:48:18,000 --> 00:48:30,000
但是那个在那个 contact 就是通讯录的那个添加那个那个叫什么来的那个 Field 的那个里面是没有没有那个字端的没有 pronunciation

1270
00:48:30,000 --> 00:48:31,000
只有 phonetic

1271
00:48:31,000 --> 00:48:32,000
对应该只有

1272
00:48:32,000 --> 00:48:32,000
对对

1273
00:48:32,000 --> 00:48:33,000
pronunciation

1274
00:48:33,000 --> 00:48:36,000
还是还没有更新到那里来

1275
00:48:36,000 --> 00:48:36,000
anyway

1276
00:48:36,000 --> 00:48:38,000
这个邮件里面其实还提了一个非常重要的事

1277
00:48:38,000 --> 00:48:43,000
就是说其实我理解就是说在这种多语言的时候怎么排序

1278
00:48:43,000 --> 00:48:46,000
比如刚才我们提到的这个日文环境和这个呃

1279
00:48:46,000 --> 00:48:49,000
这个德语环境的时候他都是有这个区别的

1280
00:48:49,000 --> 00:48:50,000
你没有想过这个问题

1281
00:48:50,000 --> 00:48:52,000
如果一个人他精通多国语言

1282
00:48:52,000 --> 00:48:54,000
比如说他会这个日语

1283
00:48:54,000 --> 00:48:55,000
然后韩语

1284
00:48:55,000 --> 00:48:57,000
然后会这个什么阿拉伯语的

1285
00:48:57,000 --> 00:49:02,000
然后他他还都有讲这种语种的或者是这个名字的这个朋友

1286
00:49:02,000 --> 00:49:03,000
他同学怎么办

1287
00:49:06,000 --> 00:49:12,000
不过我们觉得应该把这个把这件事情啊说呃要分好多呃层次来说

1288
00:49:12,000 --> 00:49:14,000
别这样的乱七八八

1289
00:49:14,000 --> 00:49:16,000
首先是有一个呃

1290
00:49:16,000 --> 00:49:17,000
代码层面的问题

1291
00:49:17,000 --> 00:49:18,000
对不对

1292
00:49:18,000 --> 00:49:21,000
然后呢有一个顺序怎么对

1293
00:49:21,000 --> 00:49:22,000
然后呢

1294
00:49:22,000 --> 00:49:24,000
首先有操作系统层面的问题

1295
00:49:24,000 --> 00:49:27,000
然后还有 app 层面的问题

1296
00:49:28,000 --> 00:49:33,000
对这几个层面的都都会影响到你最后看起来的最后的排序是怎么样的

1297
00:49:33,000 --> 00:49:35,000
对因为后来想一下

1298
00:49:35,000 --> 00:49:44,000
其实这种在多种语种特别是多多语种混合环境下就是还不是说一个一个一个系列比拉丁语系还相对来说可以兼容吗

1299
00:49:44,000 --> 00:49:45,000
像刚才讲的那种情况下

1300
00:49:45,000 --> 00:49:46,000
其实还跟你的这个

1301
00:49:46,000 --> 00:49:49,000
叫做什么来的政治政治政治策略有关

1302
00:49:49,000 --> 00:49:51,000
政治正确对对对

1303
00:49:51,000 --> 00:49:55,000
你说你说要把这个某种语言的这个呃

1304
00:49:55,000 --> 00:49:57,000
虽然说 unicode 里面有一个顺序啊

1305
00:49:57,000 --> 00:50:02,000
但是如果你在某一种呃环境下你把一种语言的名字排在前面

1306
00:50:02,000 --> 00:50:03,000
另一种排在后面

1307
00:50:03,000 --> 00:50:07,000
其实多多少少会有一些这个的考量在里面

1308
00:50:07,000 --> 00:50:09,000
所以其实挺复杂的一个问题的

1309
00:50:10,000 --> 00:50:11,000
那不管怎么样

1310
00:50:11,000 --> 00:50:14,000
我们刚才从呃一个层面来讲的话

1311
00:50:14,000 --> 00:50:15,000
在操作系统层面

1312
00:50:15,000 --> 00:50:16,000
比如说 ios 和 mega

1313
00:50:16,000 --> 00:50:18,000
就不一样对吧

1314
00:50:18,000 --> 00:50:20,000
针对一个语言的话

1315
00:50:20,000 --> 00:50:21,000
嗯

1316
00:50:21,000 --> 00:50:23,000
因为 iOS 它是移动的系统

1317
00:50:23,000 --> 00:50:24,000
所以呢

1318
00:50:24,000 --> 00:50:27,000
它的一个元他只有一个默认的排序

1319
00:50:27,000 --> 00:50:27,000
但是呢

1320
00:50:27,000 --> 00:50:28,000
那个位置上面呢

1321
00:50:28,000 --> 00:50:30,000
真呃你一个元啊

1322
00:50:30,000 --> 00:50:32,000
你可以选好多个排序

1323
00:50:32,000 --> 00:50:34,000
你可以你是可以选的啊

1324
00:50:34,000 --> 00:50:35,000
然后呢

1325
00:50:35,000 --> 00:50:41,000
在操作系统层面像刚才我们说的很最最典型的有很多需要这个通讯录啊

1326
00:50:41,000 --> 00:50:44,000
他是可以在另外加一个费用的啊

1327
00:50:44,000 --> 00:50:45,000
还有一个很典型的是 iTunes 啊

1328
00:50:45,000 --> 00:50:46,000
还有一个很典型的是 iTunes 啊

1329
00:50:46,000 --> 00:50:46,000
还有一个很典型的是 iTunes 啊

1330
00:50:46,000 --> 00:50:46,000
还有一个很典型的是 iTunes 啊

1331
00:50:46,000 --> 00:50:48,000
iTunes 那个各种歌曲的名字

1332
00:50:48,000 --> 00:50:53,000
因为那个曲名有也有各各国的曲名

1333
00:50:53,000 --> 00:50:53,000
对

1334
00:50:53,000 --> 00:50:54,000
然后呢

1335
00:50:54,000 --> 00:51:00,000
他在 MP 3 的或者你在个音乐的那一个就是 metadata 里面

1336
00:51:00,000 --> 00:51:06,000
你可以再继续把这个名像刚才住人的名字呀

1337
00:51:06,000 --> 00:51:09,000
把个歌曲的名字也是给他注音注进去也是可以的

1338
00:51:09,000 --> 00:51:11,000
就是那个比较鸡贼啊

1339
00:51:11,000 --> 00:51:14,000
他其实做的不是注意他直接给了一个选择做 sortorder

1340
00:51:14,000 --> 00:51:16,000
就是排序的这个顺序排序的对

1341
00:51:16,000 --> 00:51:17,000
他完全不管

1342
00:51:17,000 --> 00:51:21,000
对但是他至少就是他有一个 metadata 可以写嘛

1343
00:51:21,000 --> 00:51:23,000
你对你往那里面写的话

1344
00:51:23,000 --> 00:51:26,000
然后 iTunes 就会去读那个费用的嘛

1345
00:51:26,000 --> 00:51:26,000
对吧

1346
00:51:26,000 --> 00:51:29,000
是 iTunes 他给提供的这样的可能嘛

1347
00:51:29,000 --> 00:51:33,000
就专门为了排序他提供的他做了这样一个功能嘛

1348
00:51:33,000 --> 00:51:37,000
所以像这样的功能是 application 层面给他提设计出来

1349
00:51:37,000 --> 00:51:38,000
然后给他做的嘛

1350
00:51:38,000 --> 00:51:39,000
对吧

1351
00:51:39,000 --> 00:51:39,000
对对

1352
00:51:39,000 --> 00:51:42,000
如果你不在那边做的话

1353
00:51:42,000 --> 00:51:46,000
他会默认先先去调用系统的顺序吗

1354
00:51:46,000 --> 00:51:47,000
对吧

1355
00:51:47,000 --> 00:51:48,000
他有个 fallback 的顺序的

1356
00:51:48,000 --> 00:51:50,000
嗯

1357
00:51:50,000 --> 00:51:53,000
所以然后如果系统也没事的话

1358
00:51:53,000 --> 00:51:55,000
他那他直接就去读内码的顺序了

1359
00:51:55,000 --> 00:51:57,000
对吧

1360
00:51:57,000 --> 00:52:01,000
他也有你有你口袋默认的他他那真正的那个内码是什么顺序

1361
00:52:01,000 --> 00:52:06,000
所以看这个现代软件里面多多少复杂性

1362
00:52:06,000 --> 00:52:07,000
就是有这些原因导致

1363
00:52:07,000 --> 00:52:08,000
嗯

1364
00:52:08,000 --> 00:52:12,000
好吧

1365
00:52:12,000 --> 00:52:15,000
那我们今天终于可以再讲正题了吗

1366
00:52:15,000 --> 00:52:16,000
今天很正

1367
00:52:16,000 --> 00:52:20,000
今天我们要讲一个非常 hardcore 的正题

1368
00:52:20,000 --> 00:52:24,000
就是很多人都没有意识到这个问题的存在

1369
00:52:24,000 --> 00:52:29,000
今天我们要讲的是 unicode 的规范化形式叫 normalization

1370
00:52:29,000 --> 00:52:33,000
很多人都讲 normalization 是什么东西

1371
00:52:33,000 --> 00:52:36,000
你来自问自答一下好了

1372
00:52:36,000 --> 00:52:39,000
他有中文的标准义法吗

1373
00:52:39,000 --> 00:52:41,000
或者我们有什么推荐义法

1374
00:52:41,000 --> 00:52:45,000
因为 unicode 他就是国标

1375
00:52:45,000 --> 00:52:46,000
他就是国际标准义法的一种义法

1376
00:52:46,000 --> 00:52:47,000
他就是国际标准义法的一种义法

1377
00:52:47,000 --> 00:52:54,000
那 ISO 他又是各国的都会写到各国的国标国家标准里面

1378
00:52:54,000 --> 00:52:59,000
那么中国的国标就是 ISO 的中国国标是 13000

1379
00:52:59,000 --> 00:53:02,000
然后他对这个 normalization 的翻译是叫规范化

1380
00:53:02,000 --> 00:53:06,000
那我们在今天节目里面就叫规范化吧

1381
00:53:06,000 --> 00:53:09,000
要不然挺乱的

1382
00:53:09,000 --> 00:53:10,000
OK

1383
00:53:10,000 --> 00:53:16,000
然后很多朋友就不知道这还有一个规范化的东西

1384
00:53:16,000 --> 00:53:16,000
其实很简单的就是这个规范化的东西是什么东西

1385
00:53:16,000 --> 00:53:18,000
很简单就是你看到的

1386
00:53:18,000 --> 00:53:21,000
比如说带声调的字符

1387
00:53:21,000 --> 00:53:22,000
比如说拼音

1388
00:53:22,000 --> 00:53:24,000
比如说那个啊

1389
00:53:24,000 --> 00:53:27,000
是字母 A 上面加个所谓的第二声

1390
00:53:27,000 --> 00:53:30,000
你看到的是这样一个字型

1391
00:53:30,000 --> 00:53:35,000
可是它的背后可能是一个编码

1392
00:53:35,000 --> 00:53:37,000
或者它也可能是两个字符

1393
00:53:37,000 --> 00:53:38,000
两个编码

1394
00:53:38,000 --> 00:53:40,000
也就是说一个字母 A 的编码

1395
00:53:40,000 --> 00:53:46,000
加上一个带声调的编码组合而成的一个东西

1396
00:53:46,000 --> 00:53:46,000
所以我们在今天节目里面就讲到这里

1397
00:53:46,000 --> 00:53:46,000
对

1398
00:53:46,000 --> 00:53:50,000
其实就是本质上 unicode 有一个现象

1399
00:53:50,000 --> 00:53:56,000
就是说当我们看到一串 unicode 的马卫的组合的时候

1400
00:53:56,000 --> 00:53:59,000
他们可能在马卫上是不同的

1401
00:53:59,000 --> 00:54:01,000
但他们实际上表示的这个字符

1402
00:54:01,000 --> 00:54:04,000
或者是字符串是相等的

1403
00:54:04,000 --> 00:54:06,000
就 unicode 有这样一个所谓的等

1404
00:54:06,000 --> 00:54:07,000
对有一个等价

1405
00:54:07,000 --> 00:54:11,000
主要还是一个

1406
00:54:11,000 --> 00:54:15,000
本质上还是一个历史的一个问题

1407
00:54:15,000 --> 00:54:16,000
它如果当初

1408
00:54:16,000 --> 00:54:20,000
不是一定要兼容于 ansky 的地位的话

1409
00:54:20,000 --> 00:54:21,000
就不会有这个问题

1410
00:54:21,000 --> 00:54:24,000
我是这么认识的

1411
00:54:24,000 --> 00:54:26,000
而且现在是

1412
00:54:26,000 --> 00:54:27,000
由于 unicode 是多语言的

1413
00:54:27,000 --> 00:54:29,000
各个语言也都会有这样一个问题

1414
00:54:29,000 --> 00:54:31,000
所以这个规范的话就越搞越烦

1415
00:54:31,000 --> 00:54:33,000
然后这个东西的话

1416
00:54:33,000 --> 00:54:36,000
有时候你要给它看成是

1417
00:54:36,000 --> 00:54:37,000
一个字

1418
00:54:37,000 --> 00:54:39,000
因为要看成两个字

1419
00:54:39,000 --> 00:54:41,000
因为有时候必须区别

1420
00:54:41,000 --> 00:54:42,000
就是带声调的和不带声调的

1421
00:54:42,000 --> 00:54:43,000
肯定是两个字

1422
00:54:43,000 --> 00:54:44,000
不一样

1423
00:54:44,000 --> 00:54:45,000
你不能跟它混在一起

1424
00:54:45,000 --> 00:54:46,000
但是呢

1425
00:54:46,000 --> 00:54:47,000
有时候呢

1426
00:54:47,000 --> 00:54:49,000
你要又要给它混在一起

1427
00:54:49,000 --> 00:54:50,000
比如说在搜索的时候

1428
00:54:50,000 --> 00:54:51,000
你要搜索的时候

1429
00:54:51,000 --> 00:54:53,000
你可能希望就是说

1430
00:54:53,000 --> 00:54:55,000
你只打只打一个字母 a

1431
00:54:55,000 --> 00:54:56,000
但是你能顺带

1432
00:54:56,000 --> 00:54:58,000
你能把这些带声调的东西

1433
00:54:58,000 --> 00:55:00,000
能一起搜索到

1434
00:55:00,000 --> 00:55:02,000
就是能在那个候选项能出来

1435
00:55:02,000 --> 00:55:03,000
所以这个时候呢

1436
00:55:03,000 --> 00:55:05,000
你又喜欢模糊的把这些全部带

1437
00:55:05,000 --> 00:55:06,000
所以呢

1438
00:55:06,000 --> 00:55:07,000
这个是有这样的需求的

1439
00:55:07,000 --> 00:55:09,000
就是有时候你需要区别

1440
00:55:09,000 --> 00:55:10,000
有时候呢

1441
00:55:10,000 --> 00:55:12,000
你又不想不区别

1442
00:55:12,000 --> 00:55:14,000
就是这里有个问题

1443
00:55:14,000 --> 00:55:15,000
就是啊

1444
00:55:15,000 --> 00:55:16,000
为什么要

1445
00:55:16,000 --> 00:55:18,000
同一个马尾要对应两个

1446
00:55:18,000 --> 00:55:20,000
就最开始他他产生的原因是什么

1447
00:55:20,000 --> 00:55:21,000
刚才那个吴涛提了一个

1448
00:55:21,000 --> 00:55:22,000
一个解释

1449
00:55:22,000 --> 00:55:23,000
不是是反过来

1450
00:55:23,000 --> 00:55:24,000
是反过来

1451
00:55:24,000 --> 00:55:28,000
是同一个字符会有多个马尾

1452
00:55:28,000 --> 00:55:30,000
而不是同一马尾会对应两个字符

1453
00:55:30,000 --> 00:55:32,000
那就就为什么出现这种情况

1454
00:55:32,000 --> 00:55:34,000
就是他的历史背景是什么

1455
00:55:34,000 --> 00:55:36,000
最简单的一个

1456
00:55:36,000 --> 00:55:39,000
比如说当时欧洲各自都

1457
00:55:39,000 --> 00:55:42,000
都使用很多

1458
00:55:42,000 --> 00:55:46,000
带有那个扩展符号的拉丁字符

1459
00:55:46,000 --> 00:55:46,000
嘛

1460
00:55:46,000 --> 00:55:48,000
所以当时啊

1461
00:55:48,000 --> 00:55:51,000
批的那个高位就被拿来做扩展

1462
00:55:51,000 --> 00:55:53,000
然后最常见的就是

1463
00:55:53,000 --> 00:55:56,000
windows 上那个叫什么 cp 1252

1464
00:55:56,000 --> 00:55:57,000
还是哪一个

1465
00:55:57,000 --> 00:55:59,000
代码页

1466
00:55:59,000 --> 00:56:03,000
对的 windows 直到今天都是在使用代码页

1467
00:56:03,000 --> 00:56:03,000
这套机制

1468
00:56:03,000 --> 00:56:05,000
这套非常坑烈的机制

1469
00:56:05,000 --> 00:56:06,000
所以对

1470
00:56:06,000 --> 00:56:07,000
这是一个

1471
00:56:07,000 --> 00:56:11,000
这是一个就是不能忽视的历史问题

1472
00:56:11,000 --> 00:56:14,000
所以 unicode 一开始在做的时候

1473
00:56:14,000 --> 00:56:14,000
他的

1474
00:56:14,000 --> 00:56:16,000
我记得是第一位

1475
00:56:16,000 --> 00:56:19,000
的呃完全兼容阿斯琪

1476
00:56:19,000 --> 00:56:21,000
然后此时就出现了一个问题

1477
00:56:21,000 --> 00:56:22,000
就比如说呃

1478
00:56:22,000 --> 00:56:24,000
呜 u 上面加两点这个字符

1479
00:56:24,000 --> 00:56:26,000
那他就有可能出现了

1480
00:56:26,000 --> 00:56:30,000
他就等于在 unicode 里面出现了两种组合的可能

1481
00:56:30,000 --> 00:56:32,000
一种是因为 unicode 兼容

1482
00:56:32,000 --> 00:56:35,000
他固有的那个表达方式

1483
00:56:35,000 --> 00:56:37,000
就是呃

1484
00:56:37,000 --> 00:56:39,000
u 这个词符是在哪个马尾上

1485
00:56:39,000 --> 00:56:44,000
然后他会他直接把那个马尾就呃

1486
00:56:44,000 --> 00:56:45,000
做进了 unicode 里面说啊

1487
00:56:45,000 --> 00:56:46,000
在这个马尾上呢

1488
00:56:46,000 --> 00:56:49,000
在这个马尾上面 unicode 这个马尾上面这里就是 u 上加两点

1489
00:56:49,000 --> 00:56:54,000
但与此同时他要给出了单独的一个 u 和单独一个两点

1490
00:56:54,000 --> 00:56:57,000
于是此时你就又可以用说啊

1491
00:56:57,000 --> 00:56:58,000
我要呃一个 u

1492
00:56:58,000 --> 00:57:01,000
然后上面加两点来做出这个子符来

1493
00:57:01,000 --> 00:57:03,000
就这个就是问题嘛

1494
00:57:03,000 --> 00:57:07,000
就是为什么会有这种组合的的需求存在

1495
00:57:07,000 --> 00:57:10,000
如果说我提个比较极端的情况

1496
00:57:10,000 --> 00:57:16,000
就如果说我们把所有的组合都是都是呃就就组合后的字都变成一个独立的马尾

1497
00:57:16,000 --> 00:57:17,000
就不存在这个问题了

1498
00:57:17,000 --> 00:57:18,000
因为呃

1499
00:57:18,000 --> 00:57:22,000
首先一方面这是他比较节省空间

1500
00:57:22,000 --> 00:57:24,000
另外一个就是你如果你要组合的话

1501
00:57:24,000 --> 00:57:26,000
你是组合不穷尽的

1502
00:57:26,000 --> 00:57:31,000
就尤其是比如说有些组合一方面有些组合可能完全没有意义

1503
00:57:31,000 --> 00:57:35,000
另外一方面比如上下越南语就是一个字符上面可能有四五个

1504
00:57:37,000 --> 00:57:38,000
四五个可能太夸张了

1505
00:57:38,000 --> 00:57:43,000
三个应该是有可能三个一个对对三个标音符号

1506
00:57:43,000 --> 00:57:45,000
然后你要把所有的 combinator 能弄出来的话

1507
00:57:45,000 --> 00:57:46,000
这对于空间

1508
00:57:46,000 --> 00:57:47,000
其实是很大的浪费

1509
00:57:48,000 --> 00:57:51,000
给大家一个比较更直观的一个例子哈

1510
00:57:51,000 --> 00:57:55,000
比如说呃呃汉语拼音那个乌上有两点是玉嘛

1511
00:57:55,000 --> 00:57:56,000
对吧

1512
00:57:56,000 --> 00:57:58,000
然后鱼也可以带声调吗

1513
00:57:58,000 --> 00:58:00,000
鱼鱼鱼玉嘛

1514
00:58:00,000 --> 00:58:01,000
对所以呢

1515
00:58:01,000 --> 00:58:03,000
比如说鱼对吧

1516
00:58:03,000 --> 00:58:06,000
那你你就因为单纯你就可以看着

1517
00:58:07,000 --> 00:58:10,000
屋上面加两点再加那个第二声

1518
00:58:10,000 --> 00:58:12,000
这其实是这到底是一个字还是三个字

1519
00:58:12,000 --> 00:58:13,000
哎

1520
00:58:13,000 --> 00:58:14,000
你这个例子举的不对啊

1521
00:58:14,000 --> 00:58:16,000
鱼应该那个

1522
00:58:16,000 --> 00:58:21,000
就是在那个换义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义义买买买买买买买买猜尝 是邦尝

1523
00:58:21,000 --> 00:58:22,000
这样儿

1524
00:58:22,000 --> 00:58:22,000
我说读读

1525
00:58:22,000 --> 00:58:23,000
这个大英姐

1526
00:58:23,000 --> 00:58:24,000
嗯

1527
00:58:24,000 --> 00:58:25,000
我不说那个汉语拼音

1528
00:58:25,000 --> 00:58:25,000
那个英姐情况

1529
00:58:25,000 --> 00:58:27,000
我单单是说这个字符

1530
00:58:27,000 --> 00:58:28,000
啊

1531
00:58:28,000 --> 00:58:28,000
对

1532
00:58:28,000 --> 00:58:29,000
OK

1533
00:58:29,000 --> 00:58:29,000
嗯

1534
00:58:29,000 --> 00:58:30,000
OK

1535
00:58:30,000 --> 00:58:32,000
绿对你加了一个声调

1536
00:58:32,000 --> 00:58:34,000
然后这此时

1537
00:58:34,000 --> 00:58:36,000
这个双点和下降调

1538
00:58:36,000 --> 00:58:37,000
都是存在的

1539
00:58:37,000 --> 00:58:39,000
就是为了这个

1540
00:58:39,000 --> 00:58:42,000
就是我们组合成部件

1541
00:58:42,000 --> 00:58:44,000
然后通过一个固定的方法来组合

1542
00:58:44,000 --> 00:58:46,000
要避免去存多种

1543
00:58:46,000 --> 00:58:47,000
变种了

1544
00:58:47,000 --> 00:58:50,000
一个是这个另外一方面就是比如说像韩语

1545
00:58:50,000 --> 00:58:52,000
韩语那个字母的

1546
00:58:52,000 --> 00:58:54,000
把几个字母

1547
00:58:54,000 --> 00:58:56,000
拼在一起的这一套合成机制

1548
00:58:56,000 --> 00:58:57,000
跟那个

1549
00:58:57,000 --> 00:59:00,000
在字母上面加点的合成机制

1550
00:59:00,000 --> 00:59:01,000
实际上是同一套

1551
00:59:01,000 --> 00:59:04,000
那么你如果你要把

1552
00:59:04,000 --> 00:59:05,000
这一套

1553
00:59:05,000 --> 00:59:07,000
我要完全摒弃这一套

1554
00:59:07,000 --> 00:59:10,000
然后把所有的 combination 全都做出来的话

1555
00:59:10,000 --> 00:59:11,000
那韩语的 combination

1556
00:59:11,000 --> 00:59:13,000
那很合杀数

1557
00:59:13,000 --> 00:59:14,000
一个 play

1558
00:59:14,000 --> 00:59:15,000
曾经就做

1559
00:59:15,000 --> 00:59:20,000
UTF-16 就不够用了

1560
00:59:20,000 --> 00:59:21,000
对

1561
00:59:21,000 --> 00:59:23,000
我觉得微软好像为了这个事情

1562
00:59:23,000 --> 00:59:25,000
就 hack 过这个事情

1563
00:59:25,000 --> 00:59:27,000
还把 unicode 标准给 hack

1564
00:59:27,000 --> 00:59:29,000
所以 unicode

1565
00:59:29,000 --> 00:59:31,000
标准在韩语有坑吗

1566
00:59:31,000 --> 00:59:32,000
还特别乱

1567
00:59:32,000 --> 00:59:33,000
对特别乱

1568
00:59:33,000 --> 00:59:35,000
没有首先是这样子的

1569
00:59:35,000 --> 00:59:37,000
就是说如果大家觉得要省编码的话

1570
00:59:37,000 --> 00:59:40,000
就是说像就不用组合

1571
00:59:40,000 --> 00:59:40,000
对吧

1572
00:59:40,000 --> 00:59:43,000
你就给它当成是一个东西的话

1573
00:59:43,000 --> 00:59:47,000
这会在不同语言里面会有不同的认知

1574
00:59:47,000 --> 00:59:49,000
比如说在德语里面

1575
00:59:49,000 --> 00:59:50,000
乌上加两点

1576
00:59:50,000 --> 00:59:51,000
它就是一个字母

1577
00:59:51,000 --> 00:59:55,000
对于普通的德文的母语者来讲

1578
00:59:55,000 --> 00:59:56,000
它是一个字母

1579
00:59:56,000 --> 00:59:58,000
它没有这种组合的感觉

1580
00:59:58,000 --> 00:59:58,000
就是

1581
00:59:58,000 --> 00:59:59,000
嗯

1589
01:03:29,000 --> 01:03:32,000
这种感觉是一个很细腻的一个语言

1590
01:03:32,000 --> 01:03:33,000
对

1591
01:03:33,000 --> 01:03:36,000
所以这个规范化解决的问题就是说

1592
01:03:36,000 --> 01:03:37,000
看

1593
01:03:37,000 --> 01:03:40,000
就是它是一个可以理解为它是一个

1594
01:03:40,000 --> 01:03:43,000
查找的一个表

1595
01:03:43,000 --> 01:03:48,000
通过这个表可以找到说哪些 unicode 的这种

1596
01:03:48,000 --> 01:03:50,000
一个一个一个因为制服串

1597
01:03:50,000 --> 01:03:52,000
它两个的意义其实是等价的

1598
01:03:52,000 --> 01:03:54,000
它解决这么一个问题

1599
01:03:54,000 --> 01:03:55,000
嗯

1600
01:03:55,000 --> 01:03:56,000
所以大家去看 unicode 的话呢

1601
01:03:56,000 --> 01:03:58,000
就专门它有个标准附录

1602
01:03:58,000 --> 01:03:59,000
那

1603
01:03:59,000 --> 01:04:00,000
normalization 呢

1604
01:04:00,000 --> 01:04:02,000
是在标准附录的第 15 号

1605
01:04:02,000 --> 01:04:03,000
里面呢

1606
01:04:03,000 --> 01:04:06,000
会有就是具体的这个组合是等于什么什么的

1607
01:04:06,000 --> 01:04:09,000
它有这个机制的介绍和各个语言的

1608
01:04:09,000 --> 01:04:14,000
就是所有 unicode 里面带的一个 normalization 的它一个表格 chart 的都有

1609
01:04:14,000 --> 01:04:15,000
嗯

1610
01:04:15,000 --> 01:04:17,000
然后如果大家去看了发现各个语言都有很奇怪的

1611
01:04:17,000 --> 01:04:18,000
就各种等价

1612
01:04:18,000 --> 01:04:19,000
对

1613
01:04:19,000 --> 01:04:20,000
其实呃

1614
01:04:20,000 --> 01:04:24,000
我记得以前前阵的呃 swift 的语言

1615
01:04:24,000 --> 01:04:28,000
当然这个比较这个这个部分可能比较内核恐慌

1616
01:04:28,000 --> 01:04:34,000
就是 swift 的语言在好像在上一版里面又改变了字符串的那个表达方法

1617
01:04:34,000 --> 01:04:36,000
字符串现在又是一个 collection 了

1618
01:04:36,000 --> 01:04:37,000
然后啊

1619
01:04:37,000 --> 01:04:42,000
并且它就是呃支持你直接 compare 两个字符串

1620
01:04:42,000 --> 01:04:43,000
啊

1621
01:04:43,000 --> 01:04:44,000
是否相等

1622
01:04:44,000 --> 01:04:51,000
然后这个相等的依据就是他们的那个在做 unicode 的 normalization 之后是不是相等

1623
01:04:51,000 --> 01:04:57,000
比如说你这两个字符串可能在呃 byte 的层面上是不一样的

1624
01:04:57,000 --> 01:05:03,000
一个是一个的一个的那个一个字符上里面的 u 上面加点

1625
01:05:03,000 --> 01:05:06,000
可能是 asky 的那个把位 220

1626
01:05:06,000 --> 01:05:09,000
另外一个可能是一个 u 加上两个点

1627
01:05:09,000 --> 01:05:13,000
但是如果你问在 swift 里面问这两个字符上是不是相等的话

1628
01:05:13,000 --> 01:05:16,000
所有的会说这两个字符上是相等的

1629
01:05:16,000 --> 01:05:17,000
对

1630
01:05:17,000 --> 01:05:20,000
这所以这有时候我不太喜欢那个 swift 的地方

1631
01:05:20,000 --> 01:05:26,000
他老是把一些本来该交给这个 library 来做的事情放到这个 language 的层面来搞

1632
01:05:26,000 --> 01:05:27,000
就搞得很乱

1633
01:05:27,000 --> 01:05:28,000
对

1634
01:05:28,000 --> 01:05:30,000
他没有某一种选项机制吗

1635
01:05:30,000 --> 01:05:33,000
就是什么情况下我要认为他们是相等的

1636
01:05:33,000 --> 01:05:35,000
什么情况下认为他们是不相等的

1637
01:05:35,000 --> 01:05:44,000
其实现在是有的就是现在的思路就是如果你把它当做一个 string 来处理的话

1638
01:05:44,000 --> 01:05:46,000
那么它默认是个 unicode 的 string

1639
01:05:46,000 --> 01:05:52,000
然后我刚才说的这个就是他们在 normalization 之后成相等就算相等

1640
01:05:52,000 --> 01:05:55,000
而如果你要一定要比较比较他们在 byte 层面上

1641
01:05:55,000 --> 01:05:57,000
在 byte 层面上的大小的话

1642
01:05:57,000 --> 01:06:01,000
你需要取出他们的我想想是 charset 吧

1643
01:06:01,000 --> 01:06:06,000
还是就是你可以把它们转化为另外一种形式来比较

1644
01:06:06,000 --> 01:06:09,000
然后这样的话再比较就就不相等

1645
01:06:12,000 --> 01:06:15,000
好吧那看来这个 normalization 是很必要的

1646
01:06:15,000 --> 01:06:20,000
那我们再就跟大家介绍各种不同的 normalization 规范化

1647
01:06:20,000 --> 01:06:21,000
这是另外一个坑

1648
01:06:21,000 --> 01:06:23,000
就大家都来做规范化就好了吗

1649
01:06:23,000 --> 01:06:25,000
同样规范化就就

1650
01:06:25,000 --> 01:06:28,000
大家都按同样的规范化来做这个事情

1651
01:06:28,000 --> 01:06:30,000
规范化的方法很不一样

1652
01:06:30,000 --> 01:06:32,000
对这个坑哎呀真是的

1653
01:06:32,000 --> 01:06:35,000
我们需要一个 meta normalization

1654
01:06:35,000 --> 01:06:38,000
其实这里有我觉得有两个层面嘛

1655
01:06:38,000 --> 01:06:45,000
就是首先就是我们刚才说了这个规范化它要解决的是两个 unicode 的 tron

1656
01:06:45,000 --> 01:06:47,000
它是不是等价这样一个问题

1657
01:06:47,000 --> 01:06:52,000
那么这个等价其实是有多种意义的或者说有多种用途

1658
01:06:52,000 --> 01:06:56,000
有的时候我们希望这个等价是一个相对来说比较严格的等价

1659
01:06:56,000 --> 01:07:02,000
它们只是我们对一种字符的分解方式或者组合方式的认知不同

1660
01:07:02,000 --> 01:07:05,000
那么有的时候我们可能对这个等价要求是比较宽松的

1661
01:07:05,000 --> 01:07:08,000
它们可能是一种更宽松的语义层面的等价

1662
01:07:08,000 --> 01:07:11,000
因为我们有这个搜索的需求对吧

1663
01:07:11,000 --> 01:07:12,000
嗯

1664
01:07:12,000 --> 01:07:17,000
所以呢等价就是所谓的规范化呢它有两大类

1665
01:07:17,000 --> 01:07:20,000
然后每个大类又有两小类

1666
01:07:20,000 --> 01:07:21,000
所以一共有四种

1667
01:07:21,000 --> 01:07:28,000
两大类就是标准标准等价和这个兼容性的等价

1668
01:07:28,000 --> 01:07:32,000
刚才说了兼容就是为了大家能比如说为了搜索能找到嘛

1669
01:07:32,000 --> 01:07:34,000
所以它有个向后兼容的需求

1670
01:07:34,000 --> 01:07:36,000
那兼容的话它有两种

1671
01:07:36,000 --> 01:07:39,000
那标准的规范化呢有两种

1672
01:07:39,000 --> 01:07:43,000
那一种呢就是叫什么 D 型有 C 型 D 型

1673
01:07:43,000 --> 01:07:50,000
C 型那个叫什么先分解后合成是吧

1674
01:07:50,000 --> 01:07:51,000
对先分解

1675
01:07:51,000 --> 01:07:55,000
先 decomposite 然后再 composite

1676
01:07:55,000 --> 01:07:56,000
嗯

1677
01:07:56,000 --> 01:08:02,000
然后 D 型的话就是就是分解掉这个按的按的分解掉

1678
01:08:02,000 --> 01:08:07,000
然后兼容分解也两小类也是就是兼容的默认是分解的

1679
01:08:07,000 --> 01:08:12,000
或者是兼容性的先分解后后组合

1680
01:08:12,000 --> 01:08:13,000
嗯

1681
01:08:13,000 --> 01:08:20,000
然后很可能一点就是操作系统它又分别又采用采用了不同的方法

1682
01:08:20,000 --> 01:08:22,000
所以呢这又跟操作系统有关系

1683
01:08:22,000 --> 01:08:29,000
那最近呢这个 Normalization 提上话题的话就有一个很有意思的一个时机

1684
01:08:29,000 --> 01:08:31,000
就是因为刚好苹果要改文件系统了

1685
01:08:31,000 --> 01:08:32,000
OK

1686
01:08:32,000 --> 01:08:34,000
上次 WDWDC 出来的消息

1687
01:08:34,000 --> 01:08:36,000
对

1688
01:08:36,000 --> 01:08:38,000
我们好像之前还提过了

1689
01:08:38,000 --> 01:08:39,000
对

1690
01:08:39,000 --> 01:08:44,000
现在我们跑的 iOS 10 点几来的

1691
01:08:44,000 --> 01:08:47,000
现在的 10.3 已经是新的系统了

1692
01:08:47,000 --> 01:08:49,000
对已经是 APFS 了

1693
01:08:49,000 --> 01:08:51,000
对

1694
01:08:51,000 --> 01:08:53,000
就 Apple FireSystem 嘛

1695
01:08:53,000 --> 01:08:56,000
它你们知道为什么明明是 Apple FireSystem

1696
01:08:56,000 --> 01:08:59,000
那为什么要缩写成 APFS 吗

1697
01:08:59,000 --> 01:09:00,000
而不是 AFS 吗

1698
01:09:00,000 --> 01:09:02,000
那是被占了呀

1699
01:09:02,000 --> 01:09:03,000
哈哈哈哈

1700
01:09:03,000 --> 01:09:06,000
对原来因为有一个那个苹果文件系服务嘛

1701
01:09:06,000 --> 01:09:09,000
Apple FireService

1702
01:09:09,000 --> 01:09:14,000
刚说哪个版本的 Sierra 已经是 APFS

1703
01:09:14,000 --> 01:09:17,000
下一个就是 High Sierra 才会是

1704
01:09:17,000 --> 01:09:18,000
High Sierra 才是

1705
01:09:18,000 --> 01:09:19,000
嗯

1706
01:09:19,000 --> 01:09:20,000
iOS 的话更快

1707
01:09:20,000 --> 01:09:27,000
iOS 在 10.3 就已经把这个文件改为了 APFS 了

1708
01:09:27,000 --> 01:09:28,000
嗯哼

1709
01:09:28,000 --> 01:09:29,000
哦

1710
01:09:29,000 --> 01:09:33,000
而在之前也就是说现在的我们的 Mac 呢

1711
01:09:33,000 --> 01:09:37,000
都是 HFS 加这是一个超好老啊

1712
01:09:37,000 --> 01:09:38,000
这个已经十几年了

1713
01:09:38,000 --> 01:09:39,000
多少不多少

1714
01:09:39,000 --> 01:09:41,000
八几年的是八几年的文件系统

1715
01:09:41,000 --> 01:09:42,000
超老的

1716
01:09:42,000 --> 01:09:43,000
对啊

1717
01:09:43,000 --> 01:09:47,000
终于苹果一咬牙一狠心要换把它给它换掉

1718
01:09:47,000 --> 01:09:48,000
那换掉了以后呢

1719
01:09:48,000 --> 01:09:49,000
就是出现了一个问题

1720
01:09:49,000 --> 01:09:54,000
就是在这个新的 APAPFS 里面呢

1721
01:09:54,000 --> 01:09:59,000
它把这个原来的 Normalization 系统默认的 Normalization 换掉了

1722
01:09:59,000 --> 01:10:01,000
因为新的 APFS 呢

1723
01:10:01,000 --> 01:10:04,000
它是叫 Normalization insensitive

1724
01:10:04,000 --> 01:10:06,000
它是不敏感的

1725
01:10:06,000 --> 01:10:08,000
对这个规范法不敏感的

1726
01:10:08,000 --> 01:10:09,000
所以就说

1727
01:10:09,000 --> 01:10:10,000
呃

1728
01:10:10,000 --> 01:10:15,000
无论它可以到时候你就是它都能找到这个文件

1729
01:10:15,000 --> 01:10:16,000
因为刚才说了

1730
01:10:16,000 --> 01:10:17,000
他如果你如果对他不敏感的话呢

1731
01:10:17,000 --> 01:10:20,000
你如果对他不敏感的话搜索就更容易搜索到嘛

1732
01:10:20,000 --> 01:10:23,000
就是无论你是用什么样的规范化来做的话

1733
01:10:23,000 --> 01:10:25,000
他都能指向这个文件

1734
01:10:25,000 --> 01:10:26,000
嗯

1735
01:10:26,000 --> 01:10:27,000
以前呢

1736
01:10:27,000 --> 01:10:29,000
会有坑的问题

1737
01:10:29,000 --> 01:10:32,000
而对于用日语的朋友来讲

1738
01:10:32,000 --> 01:10:33,000
这个是最坑的问题

1739
01:10:33,000 --> 01:10:34,000
我们在我刚才说了

1740
01:10:34,000 --> 01:10:39,000
就因为日文经常要用会涉及到就踩到这个规范化的坑

1741
01:10:39,000 --> 01:10:43,000
是因为日文像刚才说的着音点是经常用的嘛

1742
01:10:43,000 --> 01:10:46,000
然后经常会出现在日文的 Windows 上呢

1743
01:10:46,000 --> 01:10:50,000
日文的 Windows 的文件名考到 Mac 的时候

1744
01:10:50,000 --> 01:10:55,000
刚才说凡是带有那个着音点的字放到 Mac 里面

1745
01:10:55,000 --> 01:10:58,000
就被被被拆成了两个字

1746
01:10:58,000 --> 01:11:01,000
然后因为是两个字

1747
01:11:01,000 --> 01:11:03,000
你还可以一个字这个删除

1748
01:11:03,000 --> 01:11:06,000
所以你可以把那个着音点分别删除

1749
01:11:06,000 --> 01:11:12,000
这是因为在老的 HFS 家的时候呢

1750
01:11:12,000 --> 01:11:14,000
这也就是 Mac 现在用的这个这个系统呢

1751
01:11:14,000 --> 01:11:15,000
这个系统呢

1752
01:11:15,000 --> 01:11:16,000
这个系统呢

1753
01:11:16,000 --> 01:11:18,000
在 HFS 的文件系统里面呢

1754
01:11:18,000 --> 01:11:21,000
它对这个 Normalization 的处理是不一样的

1755
01:11:21,000 --> 01:11:25,000
因为它采用的是就分解优先

1756
01:11:25,000 --> 01:11:28,000
所以它会把这个字拆成认成是两个字

1757
01:11:28,000 --> 01:11:31,000
这里可能要解释一下这个背景

1758
01:11:31,000 --> 01:11:37,000
就是为什么从改来一个文件系统会导致这个 Normalization 的问题

1759
01:11:37,000 --> 01:11:40,000
因为 HFS plus 就是那个旧的那个文件系统

1760
01:11:40,000 --> 01:11:43,000
是对这个有一个默认的一个处理的

1761
01:11:43,000 --> 01:11:44,000
就是那个文件系统

1762
01:11:44,000 --> 01:11:45,000
它其实是知道

1763
01:11:45,000 --> 01:11:47,000
你写进去一个文件名

1764
01:11:47,000 --> 01:11:50,000
它会帮你去自动做一遍这个 Normalization

1765
01:11:50,000 --> 01:11:51,000
是这样

1766
01:11:51,000 --> 01:11:52,000
如果没记错的话

1767
01:11:52,000 --> 01:11:54,000
然后这个 APFS 其实

1768
01:11:54,000 --> 01:11:56,000
之前那个设计其实有点问题的

1769
01:11:56,000 --> 01:12:01,000
因为照理说一个文件系统不应该去参乎这种应用层的事情

1770
01:12:01,000 --> 01:12:02,000
对吧

1771
01:12:02,000 --> 01:12:03,000
嗯

1772
01:12:03,000 --> 01:12:04,000
因为这个

1773
01:12:04,000 --> 01:12:06,000
这是应用层的事情吗

1774
01:12:06,000 --> 01:12:08,000
这显然是应用层的问题

1775
01:12:08,000 --> 01:12:10,000
因为文件系统应该就是

1776
01:12:10,000 --> 01:12:11,000
这可能有一点

1777
01:12:11,000 --> 01:12:13,000
其实这里有个哲学问题

1778
01:12:13,000 --> 01:12:14,000
就是这也是我一个疑问

1779
01:12:14,000 --> 01:12:18,000
就是 Normalization 究竟是应该在这个存储的什么

1780
01:12:18,000 --> 01:12:20,000
存储上发明的对吧

1781
01:12:20,000 --> 01:12:21,000
对

1782
01:12:21,000 --> 01:12:26,000
还是在这个应用调用某一个数据的过程中对它进行实施的处理

1783
01:12:26,000 --> 01:12:28,000
因为本质上你说对于一个文件系统来说

1784
01:12:28,000 --> 01:12:30,000
它并不关心里面存的内容是什么

1785
01:12:30,000 --> 01:12:32,000
就是你给我一堆 bytes 对吧

1786
01:12:32,000 --> 01:12:35,000
然后我把这个 bytes 按照某一种规则存起来

1787
01:12:35,000 --> 01:12:36,000
然后到时候

1788
01:12:36,000 --> 01:12:38,000
到时候你再问我要这堆 bytes 的时候

1789
01:12:38,000 --> 01:12:40,000
我就把这堆 bytes 又还给你

1790
01:12:40,000 --> 01:12:43,000
但是我需要一个 key 找到这个这堆 bytes 嘛

1791
01:12:43,000 --> 01:12:46,000
这个 key 就是这所有的文件名和路径嘛

1792
01:12:46,000 --> 01:12:49,000
那么 APFS 最开始的它的逻辑

1793
01:12:49,000 --> 01:12:51,000
我记得当时他说过

1794
01:12:51,000 --> 01:12:55,000
他说对这个问题他是就是完全不过问这些东西

1795
01:12:55,000 --> 01:12:56,000
你给我什么

1796
01:12:56,000 --> 01:12:57,000
你给我那个文件叫什么

1797
01:12:57,000 --> 01:12:58,000
我就写什么嘛

1798
01:12:58,000 --> 01:13:00,000
但是在 HFS 里面

1799
01:13:00,000 --> 01:13:05,000
它其实是已经它会去解析那个文件名的那个格式和内容的

1800
01:13:05,000 --> 01:13:08,000
规范化这个事情是一个逻辑的概念

1801
01:13:08,000 --> 01:13:09,000
它并不是

1802
01:13:09,000 --> 01:13:13,000
它是我们在做这个叫做 API 的层面解决的问题

1803
01:13:13,000 --> 01:13:17,000
但是最终你写到那个磁盘上的那个东西的时候

1804
01:13:17,000 --> 01:13:19,000
它肯定是一堆 bytes 嘛

1805
01:13:19,000 --> 01:13:24,000
所以就是 APFS 它的设计理念就是

1806
01:13:24,000 --> 01:13:26,000
我作为一个文件系统

1807
01:13:26,000 --> 01:13:28,000
一个非常底层的东西

1808
01:13:28,000 --> 01:13:32,000
我不应该去参考上层逻辑 API 应该去解决的问题

1809
01:13:32,000 --> 01:13:33,000
不是

1810
01:13:33,000 --> 01:13:34,000
Rail 我明白你的意思

1811
01:13:34,000 --> 01:13:35,000
Rail 我明白你的意思

1812
01:13:35,000 --> 01:13:37,000
但是我有一个问题

1813
01:13:37,000 --> 01:13:40,000
比如说你说你说文件系统是一个非常底层的系统

1814
01:13:40,000 --> 01:13:41,000
那么请问

1815
01:13:41,000 --> 01:13:46,000
获得一个文件的路径这件这件事情很底层

1816
01:13:46,000 --> 01:13:47,000
对不对

1817
01:13:47,000 --> 01:13:49,000
那么获得一个文件的路径

1818
01:13:49,000 --> 01:13:55,000
跟这个文件的名字是以什么样的标准化形式写出来的

1819
01:13:55,000 --> 01:13:56,000
有没有关联

1820
01:13:58,000 --> 01:14:00,000
对这个对我肯定有关联

1821
01:14:00,000 --> 01:14:02,000
不但这个不是文件系统

1822
01:14:02,000 --> 01:14:03,000
就对这个文件系统没有关系

1823
01:14:03,000 --> 01:14:05,000
因为文件系统拿了最终都是一堆 bytes 嘛

1824
01:14:05,000 --> 01:14:07,000
它不需要去 concern 这件事情

1825
01:14:08,000 --> 01:14:10,000
其实它做了一次先转

1826
01:14:10,000 --> 01:14:14,000
Rail 的意思是说先规范化再存储这件事情

1827
01:14:14,000 --> 01:14:16,000
不是在文件系统的层面上发生的

1828
01:14:16,000 --> 01:14:20,000
对它是在一个他们叫什么 Foundation

1829
01:14:20,000 --> 01:14:23,000
在操作系统的层面上发生的

1830
01:14:23,000 --> 01:14:26,000
或者说在操作系统和文件系统

1831
01:14:26,000 --> 01:14:29,000
就管理文件系统那一部分的 API 里面产生的

1832
01:14:29,000 --> 01:14:32,000
而不是文件系统本身需要操作的事情

1833
01:14:32,000 --> 01:14:34,000
对但这里就会导致一个问题

1834
01:14:34,000 --> 01:14:36,000
就是它就向后不兼容了

1835
01:14:36,000 --> 01:14:39,000
因为在 HFS 里面它是它是就是文件系统

1836
01:14:39,000 --> 01:14:41,000
就是管了这么一件事情的

1837
01:14:41,000 --> 01:14:43,000
所以操作系统和包括很多应用程序

1838
01:14:43,000 --> 01:14:45,000
它是不需要过度的去考虑这个问题

1839
01:14:45,000 --> 01:14:48,000
你用什么 API 去访问那个文件

1840
01:14:48,000 --> 01:14:49,000
反正你只要给到它

1841
01:14:49,000 --> 01:14:51,000
它都会通过统一的方法规范化

1842
01:14:51,000 --> 01:14:54,000
然后形成统一的一个那个 bytes

1843
01:14:54,000 --> 01:14:55,000
然后再去通过那个 bytes

1844
01:14:55,000 --> 01:14:57,000
在文件系统里面去找嘛

1845
01:14:57,000 --> 01:14:59,000
但就会就变成向后兼容的问题了

1846
01:14:59,000 --> 01:15:02,000
但这个问题之所以在这个 iOS 里面没有暴露出来

1847
01:15:02,000 --> 01:15:04,000
是因为 iOS 并没有

1848
01:15:04,000 --> 01:15:05,000
起码对用户而言啊

1849
01:15:05,000 --> 01:15:07,000
没有没有暴露出一个文件系统嘛

1850
01:15:07,000 --> 01:15:08,000
起码到目前为止

1851
01:15:09,000 --> 01:15:10,000
是没有的对吧

1852
01:15:10,000 --> 01:15:11,000
那么也就不存在

1853
01:15:11,000 --> 01:15:14,000
不就并不会大量存在说

1854
01:15:14,000 --> 01:15:17,000
有很多这个历史文件的名

1855
01:15:17,000 --> 01:15:19,000
它的规范化形式不太对

1856
01:15:19,000 --> 01:15:22,000
导致可能找不回来这个问题

1857
01:15:22,000 --> 01:15:25,000
但是在 Mac 里面就会存在这个问题

1858
01:15:25,000 --> 01:15:26,000
因为 Mac 里面我们现在大量

1859
01:15:26,000 --> 01:15:29,000
还在使用用户直接访问文件系统嘛

1860
01:15:29,000 --> 01:15:30,000
大家还是用 Finder 嘛对吧

1861
01:15:30,000 --> 01:15:34,000
所以就导致这么一个很尴尬的情况

1862
01:15:34,000 --> 01:15:37,000
所以现在就出的都是一些打补丁的方案嘛

1863
01:15:39,000 --> 01:15:42,000
其实你一直用同样一个系统的话

1864
01:15:42,000 --> 01:15:44,000
相对来讲会好一些

1865
01:15:44,000 --> 01:15:47,000
那就主要是像跟和 Windows

1866
01:15:47,000 --> 01:15:48,000
Windows 因为它默认的

1867
01:15:48,000 --> 01:15:51,000
那它规范化的方式不一样嘛

1868
01:15:51,000 --> 01:15:55,000
所以从那边不同规范化方式里

1869
01:15:55,000 --> 01:15:58,000
考过来的东西就会有问题

1870
01:15:58,000 --> 01:16:01,000
你 Mac 一直都用这样一个规范化形式的话

1871
01:16:01,000 --> 01:16:02,000
它其实还相对来讲

1872
01:16:02,000 --> 01:16:05,000
它的那个向后进入性是挺好的呀

1873
01:16:05,000 --> 01:16:06,000
但是有一个问题是这样的

1874
01:16:06,000 --> 01:16:09,000
就说因为 APFS 如果按照最开始的那种

1875
01:16:09,000 --> 01:16:12,000
那个设计理念是不涉及规范化和你怎么

1876
01:16:12,000 --> 01:16:14,000
就你不它不涉及你的文件怎么编码

1877
01:16:14,000 --> 01:16:16,000
你甚至可以不用 UTF-8 编码

1878
01:16:16,000 --> 01:16:18,000
理论上是可以的对吧

1879
01:16:18,000 --> 01:16:22,000
APFS 只接受有效的 UTF-8 的编码的文件名

1880
01:16:22,000 --> 01:16:24,000
不我就说就是说如果它

1881
01:16:24,000 --> 01:16:27,000
就是刚才讲如果它只管是 bytes 的话

1882
01:16:27,000 --> 01:16:29,000
就它只在字节层面上说

1883
01:16:29,000 --> 01:16:31,000
你别握手我就存什么

1884
01:16:31,000 --> 01:16:32,000
对对对存什么

1885
01:16:32,000 --> 01:16:34,000
就文件系统嘛

1886
01:16:34,000 --> 01:16:36,000
对就刚刚那个问题就是说

1887
01:16:36,000 --> 01:16:38,000
假设我们用那个我们就是遵守

1888
01:16:38,000 --> 01:16:39,000
这个 Apple 的一个规范

1889
01:16:39,000 --> 01:16:42,000
用一些 foundation 的这些 library 去

1890
01:16:42,000 --> 01:16:43,000
去命名文件去访问文件

1891
01:16:43,000 --> 01:16:46,000
不是 open file 之类的 API 的话

1892
01:16:46,000 --> 01:16:48,000
那你可能得到的是一个路径对吧

1893
01:16:48,000 --> 01:16:51,000
然后你在那个就是叫什么来的

1894
01:16:51,000 --> 01:16:52,000
那个命令行的界面下

1895
01:16:52,000 --> 01:16:55,000
你用那个 unix 那套 API 去访问

1896
01:16:55,000 --> 01:16:57,000
又会得到另外一个文件的路径

1897
01:16:57,000 --> 01:16:59,000
它两个可能是不一样的

1898
01:16:59,000 --> 01:17:01,000
这个时候就会发现你用那个文件

1899
01:17:01,000 --> 01:17:05,000
你用那个 mac 的那套 API 去存了一个文件

1900
01:17:05,000 --> 01:17:07,000
然后你在 unix 上面那个找不回那个文件了

1901
01:17:07,000 --> 01:17:08,000
就很就很尴尬嘛

1902
01:17:08,000 --> 01:17:10,000
嗯

1903
01:17:10,000 --> 01:17:14,000
这个事情当年也也也存在了

1904
01:17:14,000 --> 01:17:19,000
好像当年就是老 mac 转成 mac os 10 的时候

1905
01:17:19,000 --> 01:17:20,000
它 finder 有改

1906
01:17:20,000 --> 01:17:21,000
就是 mac 还是 9 对吧

1907
01:17:21,000 --> 01:17:23,000
嗯 9 改成真正

1908
01:17:23,000 --> 01:17:24,000
os 10 的时候

1909
01:17:24,000 --> 01:17:26,000
os 10 是真正的 unix 嘛

1910
01:17:26,000 --> 01:17:29,000
但是原来老的 mac 不是嘛

1911
01:17:29,000 --> 01:17:30,000
对

1912
01:17:30,000 --> 01:17:34,000
所以它那个路径的那个标志分割符都不一样嘛

1913
01:17:34,000 --> 01:17:37,000
就是正斜杠房斜杠那个事情

1914
01:17:37,000 --> 01:17:38,000
这个

1915
01:17:38,000 --> 01:17:40,000
那这是操作系统的事情

1916
01:17:40,000 --> 01:17:44,000
这这这和它那个文件系统也也不打别人

1917
01:17:44,000 --> 01:17:50,000
哎那我们其实知道那个 windows 一直以来都是用 nfc 这种形式的对吧

1918
01:17:50,000 --> 01:17:52,000
这点这点应该没错吧

1919
01:17:52,000 --> 01:17:58,000
那么 apple 的话对 apple 的话 hfs plus 它是用哪一种形式的

1920
01:18:00,000 --> 01:18:02,000
是用 nfc 还是用 nfd

1921
01:18:02,000 --> 01:18:04,000
哎这个还真的不知道哎

1922
01:18:04,000 --> 01:18:06,000
对我觉得这可能是第一个问题

1923
01:18:06,000 --> 01:18:07,000
然后第二个问题

1924
01:18:07,000 --> 01:18:09,000
可能就是 real 刚才说的就是啊

1925
01:18:09,000 --> 01:18:12,000
在 hfs plus 的年代里面

1926
01:18:12,000 --> 01:18:16,000
apple 是就是说 mac os 会做一件事情

1927
01:18:16,000 --> 01:18:20,000
它做这件事情就是当你输入一个文件名的时候

1928
01:18:20,000 --> 01:18:23,000
它会帮你转成已经标准化后的形式

1929
01:18:23,000 --> 01:18:26,000
再存储到你的存储介质上对吧

1930
01:18:26,000 --> 01:18:29,000
我理解的没错吧

1931
01:18:29,000 --> 01:18:40,000
应该就是说就是呃刚才呃 real 也说的也是就是说在这个文件系统里面它我们只说它的 normalization 它是 sensitive 还是 insensitive

1932
01:18:40,000 --> 01:18:43,000
对这个规范是是否敏感

1933
01:18:43,000 --> 01:18:46,000
它没有在做的确它只是在存储代码而已

1934
01:18:46,000 --> 01:18:48,000
呃存储这个 byte 而已

1935
01:18:48,000 --> 01:18:51,000
但是呢它是不是对这个 normalization 敏感

1936
01:18:51,000 --> 01:18:55,000
对 hfs 是的确是对 normalization 敏感

1937
01:18:55,000 --> 01:18:58,000
但是 afs 啊 apfs 好像是

1938
01:18:58,000 --> 01:19:00,000
它就它就新的就不敏感了

1939
01:19:00,000 --> 01:19:01,000
它就不敏感了

1940
01:19:01,000 --> 01:19:04,000
对这个和那个大小写也是一样的

1941
01:19:04,000 --> 01:19:11,000
就是呃 sensitive 呃这个就叫什么 case sensitive 和 case insensitive

1942
01:19:11,000 --> 01:19:15,000
呃这里还有个比较坑的一个事情

1943
01:19:15,000 --> 01:19:20,000
就是所谓这个叫做 case preserving 和这个 normalization preserving 的问题

1944
01:19:20,000 --> 01:19:24,000
对嗯它可以保持按照道理保存下来

1945
01:19:24,000 --> 01:19:27,000
但是它对它不敏感就还是当成一样的

1946
01:19:27,000 --> 01:19:28,000
呵呵

1947
01:19:28,000 --> 01:19:31,000
嗯是可保存但是它不敏感

1948
01:19:31,000 --> 01:19:33,000
嗯就是有这样的嗯

1949
01:19:33,000 --> 01:19:36,000
现在的话就是新的 apfs 就是这样

1950
01:19:36,000 --> 01:19:37,000
它可以保存下来

1951
01:19:37,000 --> 01:19:41,000
嗯嗯然后 nfc 它也认得 nfd 它也认得

1952
01:19:41,000 --> 01:19:42,000
但是呢它不敏感

1953
01:19:42,000 --> 01:19:43,000
所以两边都可以

1954
01:19:43,000 --> 01:19:46,000
嗯那么其实呃按我的理解

1955
01:19:46,000 --> 01:19:49,000
apple 并没有改它的这个标准化形式

1956
01:19:49,000 --> 01:19:53,000
它改的只是它对这个标准化形式是不是敏感

1957
01:19:53,000 --> 01:19:54,000
这样一个问题

1958
01:19:54,000 --> 01:19:57,000
嗯就是在这个出呃所以它对这个文件

1959
01:19:57,000 --> 01:20:00,000
文件文件名处理它那个行为变发生变化了吗

1960
01:20:00,000 --> 01:20:07,000
刚刚我查了一下那个 hfsplus 用的是 nfd 的这种标准化形式

1961
01:20:07,000 --> 01:20:11,000
那么这个这个第一个问题就是跟 windows 可能是不一样的

1962
01:20:11,000 --> 01:20:14,000
分解优先对嗯

1963
01:20:14,000 --> 01:20:20,000
哎可能我们刚才把那个带过了就是刚才讲的 nfc nfd 它到底是个什么意思

1964
01:20:20,000 --> 01:20:22,000
可能还要解释一下

1965
01:20:22,000 --> 01:20:23,000
ok

1966
01:20:23,000 --> 01:20:26,000
呃 fc 就是先

1967
01:20:26,000 --> 01:20:29,000
嗯就等于是这这么说吧

1968
01:20:29,000 --> 01:20:30,000
规范化有两个思路

1969
01:20:30,000 --> 01:20:34,000
一个是说什么叫规范化的最终形式

1970
01:20:34,000 --> 01:20:42,000
那嗯呃第一种思路就是规范化的最终形式是所有能够被拆分的东西都已经被拆分了

1971
01:20:42,000 --> 01:20:44,000
嗯然后我存储这个形式

1972
01:20:44,000 --> 01:20:51,000
呃第二种思路是说存储的最终形式应该是所有能够被合成的东西已经被合成了

1973
01:20:51,000 --> 01:20:54,000
而且是按照某一种特定的方式合成

1974
01:20:54,000 --> 01:20:55,000
这是第二种思路

1975
01:20:55,000 --> 01:20:56,000
嗯

1977
01:21:26,000 --> 01:21:28,000
一个是合成一个是两点

1978
01:21:28,000 --> 01:21:29,000
嗯

1979
01:21:29,000 --> 01:21:32,000
然后如果你要分

1980
01:21:32,000 --> 01:21:37,000
如果你说我要把它合成的状态作为最终状态的话

1981
01:21:37,000 --> 01:21:42,000
那刚才这个 u 就是呃就把它合成成一个字符

1982
01:21:42,000 --> 01:21:43,000
这样来说

1983
01:21:43,000 --> 01:21:52,000
嗯嗯然后然后但是由于分解和解分解和合成又分别有所谓标准方式和接触方式

1984
01:21:52,000 --> 01:21:55,000
所以你可以说标准方式分解结束

1985
01:21:55,000 --> 01:21:56,000
还是接触方式分解结束

1986
01:21:56,000 --> 01:22:02,000
还是呃标准方式分解之后再以标准方式合成结束

1987
01:22:02,000 --> 01:22:06,000
还是以标准方式分解之后再以接触方式合成结束

1988
01:22:06,000 --> 01:22:07,000
或者是反过来

1989
01:22:07,000 --> 01:22:09,000
哈哈哈对基本上是一个 com

1990
01:22:09,000 --> 01:22:11,000
com

1991
01:22:11,000 --> 01:22:12,000
对

1992
01:22:12,000 --> 01:22:15,000
我我想问一下为什么要做这么多种

1993
01:22:15,000 --> 01:22:20,000
我们的这个 normalization 的目的不就是为了解决这个标准化的问题吗

1994
01:22:20,000 --> 01:22:23,000
为什么还要再搞四种不一样的方式呢

1995
01:22:23,000 --> 01:22:25,000
就他们之间各有什么或者说应用场景是什么呢

1996
01:22:25,000 --> 01:22:29,000
就比如说以标准方式分解分解到不能再分解了

1997
01:22:29,000 --> 01:22:32,000
这个实际上是非常适合编程的嘛

1998
01:22:32,000 --> 01:22:35,000
对吧嗯就是你最最小单元吗

1999
01:22:35,000 --> 01:22:42,000
就比如说你刚才是我刚才说那个 swift 语言呃判定两个字符上相等的时候

2000
01:22:42,000 --> 01:22:45,000
那你就把他们全都拆成不能再拆的状况

2001
01:22:45,000 --> 01:22:48,000
然后看两个是不是一样然后一个扣碰是一样的话

2002
01:22:48,000 --> 01:22:50,000
那就不管他们原来是怎么样

2003
01:22:50,000 --> 01:22:52,000
对这样就结束了

2004
01:22:52,000 --> 01:22:54,000
但是如果说这个很难解释啊

2005
01:22:54,000 --> 01:22:59,000
就是如果说你要死板了太死板了话就是对啊

2006
01:22:59,000 --> 01:23:05,000
就是你要拆的要先拆拆的这么死了以后要每一个部件都都一样

2007
01:23:05,000 --> 01:23:08,000
他才认判定为是一样对吧

2008
01:23:08,000 --> 01:23:18,000
对但是但是这种方式的时候就是就这种规范化的方式是只适合存储或者比较的

2009
01:23:18,000 --> 01:23:23,000
那如果你要把它嗯就是以节省空间的方式显示出来的话

2010
01:23:23,000 --> 01:23:30,000
那你还是很有可能希望说我要把它最终还是要合成起来

2011
01:23:30,000 --> 01:23:37,000
就刚才那个拆的方式说可能会导致干比如说那个特殊的字符呃就是于在家一个声调的话

2012
01:23:37,000 --> 01:23:43,000
他会从啊理论上他可以从一个呃一个点位变成三个点位吗

2013
01:23:43,000 --> 01:23:48,000
对就是这个他的空间存储空间的要求变成三倍了吗嗯对

2014
01:23:48,000 --> 01:23:54,000
然后那我们如果就全部合到一起有什么不好呢嗯的确没有什么

2015
01:23:54,000 --> 01:24:03,000
就是为了比较比较化就是说就是说呃比如 NFD 的应用场景和 NFC 的应用场景他们各有什么不同就是不能互相替代的地方

2016
01:24:03,000 --> 01:24:08,000
因为 NFD 你要少做一步计算啊就 NFC 你最重要把它合成起来

2017
01:24:08,000 --> 01:24:15,000
而 NFD 的你要你要付出更多的存储空间啊对呀所以这个就是一长一短嘛

2018
01:24:15,000 --> 01:24:18,000
嗯这就是时间这是有时间的

2019
01:24:18,000 --> 01:24:23,000
是空间换空间还是空间换时间的间合吧对对所以这个就是逻辑问题

2020
01:24:23,000 --> 01:24:32,000
然后只是偏好问题而已这个并没有什么对错或者怎么样嗯所以刚刚刚才提的一个叫什么的兼容分解和标准分解有什么不一样

2021
01:24:32,000 --> 01:24:42,000
那个我简单来说一下兼容分解就是呃我不把它说的非常细就兼容分解要解决一个问题就是说呃有一些呃有一些串

2022
01:24:42,000 --> 01:24:46,000
他在这个字符的 byte 的表达层面是不一样的

2023
01:24:46,000 --> 01:24:48,000
然后呃他拆分组合之后呢

2024
01:24:48,000 --> 01:25:05,000
是不一样的但是我们希望认为他们是一样的比如一个场景就是盒子的问题比如 fi 盒子那么 fi 盒子我们可以理解成他是一个 f 和一个 i 的两个字母的合成但他同时又是一个单独的码位就是 unicode 里面有一个码位就是 fi 这个盒子的

2025
01:25:05,000 --> 01:25:16,000
那么我们在搜索的时候呢用户可能输入 fi 盒子是非常复杂的所以我们可能希望用户输入一个 fi 一个 f 和一个 i 我们可以把所有 fi 盒子相关内容也给他匹配起来

2026
01:25:16,000 --> 01:25:21,000
所以这个时候就是这个兼容性分解和合成所需要

2027
01:25:21,000 --> 01:25:23,000
起到作用的这样一个场景

2028
01:25:23,000 --> 01:25:24,000
哎

2029
01:25:24,000 --> 01:25:26,000
等一下这这里我提一个问题

2030
01:25:26,000 --> 01:25:27,000
没好像没有区别啊

2031
01:25:27,000 --> 01:25:28,000
只用分解一次就好了吗

2032
01:25:28,000 --> 01:25:30,000
或者合成一次就好了吗

2033
01:25:30,000 --> 01:25:33,000
就是你你这个时候你这个这个问题是这样子啊

2034
01:25:33,000 --> 01:25:38,000
就是说有一堆文档里面包含这个 fi 的盒子和 fi 分解的两种情况对吧

2035
01:25:38,000 --> 01:25:40,000
我们没有做他做任何处理

2036
01:25:40,000 --> 01:25:48,000
这个时候你用户来了说用户说输入 fi 我们需要把前面的的 fi 盒子和 fi 分开的都收都收出来对吧

2037
01:25:48,000 --> 01:25:49,000
这个时候有两种做法

2038
01:25:49,000 --> 01:25:54,000
第一个是说我们把这个啊我们之前存的文档全部做分解

2039
01:25:54,000 --> 01:25:58,000
就把 fi 的盒子一个一个 code point 分成两个

2040
01:25:58,000 --> 01:26:01,000
然后这个时候我们就可以直接跟那个用户输入的 fi 直接对比了嘛

2041
01:26:01,000 --> 01:26:05,000
另外一个方法就是说我们把用户输入的 fi 弄成一个盒子

2042
01:26:05,000 --> 01:26:10,000
同时把所有我们已有的文档里面的 fi 分开的也弄成一个盒子嘛

2043
01:26:10,000 --> 01:26:12,000
这个时候再搜索也可以了嘛对吧

2044
01:26:12,000 --> 01:26:13,000
就这两种操作方式嘛

2045
01:26:13,000 --> 01:26:14,000
对对对

2046
01:26:14,000 --> 01:26:15,000
OK

2047
01:26:15,000 --> 01:26:18,000
但是因为你在这就是为了为了兼容嘛

2048
01:26:18,000 --> 01:26:22,000
用户并不知道这里面到底用的是盒子还是分开的

2049
01:26:22,000 --> 01:26:29,000
但这里问题就是说这个这个标准分解和和这个兼容分解好像没有区别在这里面

2050
01:26:29,000 --> 01:26:32,000
啊这个区别就在于哪些东西是可以分的

2051
01:26:32,000 --> 01:26:34,000
就是说哪些东西是可以等价的

2052
01:26:34,000 --> 01:26:37,000
其实他们的区别就在于比如说那个 fi 盒子

2053
01:26:37,000 --> 01:26:40,000
它本质上不能完全等同于一个 f 盒子

2054
01:26:40,000 --> 01:26:41,000
或者一个 i

2055
01:26:41,000 --> 01:26:43,000
它们本质上是两种不同的字符

2056
01:26:43,000 --> 01:26:46,000
那么有的时候我们希望它们是等价的

2057
01:26:46,000 --> 01:26:53,000
对这个这个其实不仅仅是说这不纯粹是一个字符层面的问题

2058
01:26:53,000 --> 01:26:55,000
还是一个语言就是语言层面的问题

2059
01:26:55,000 --> 01:26:56,000
比如说在有些语言里面

2060
01:26:56,000 --> 01:26:57,000
它是一个语义的问题

2061
01:26:57,000 --> 01:27:05,000
对在有些语言里面 ch 或者是 sh 是一个是被试成一个试做一个单独的字母

2062
01:27:05,000 --> 01:27:08,000
或者是在比如说像荷兰语里面 ij

2063
01:27:08,000 --> 01:27:09,000
ij

2064
01:27:09,000 --> 01:27:11,000
是一个单独字母

2065
01:27:11,000 --> 01:27:12,000
一个字母

2066
01:27:12,000 --> 01:27:16,000
对因为就是有些语言里面一个字母可能有两种形式

2067
01:27:16,000 --> 01:27:17,000
比如说阿拉伯语

2068
01:27:17,000 --> 01:27:21,000
自首自终自末一个字母是表达形式不一样的

2069
01:27:21,000 --> 01:27:24,000
比如希腊语那个是 sigma

2070
01:27:24,000 --> 01:27:27,000
sigma 在词尾的时候写法和在词中不一样

2071
01:27:27,000 --> 01:27:33,000
又比如说那个英语里面的长 s 就是就是微积分那个符号

2072
01:27:33,000 --> 01:27:36,000
那个 s 它跟普通的 s 也不一样

2073
01:27:36,000 --> 01:27:37,000
在德语里面

2074
01:27:37,000 --> 01:27:39,000
在旧式的德语证则

2075
01:27:39,000 --> 01:27:42,000
如果它如果一个 s 出现在词中的话

2076
01:27:42,000 --> 01:27:44,000
你必须写成长 s

2077
01:27:44,000 --> 01:27:48,000
但是长 s 你用标准分解的话

2078
01:27:48,000 --> 01:27:51,000
你只能最终只能分解出一个长 s

2079
01:27:51,000 --> 01:27:53,000
但是如果你用这样的分解

2080
01:27:53,000 --> 01:27:54,000
因为它本来就是一个字符

2081
01:27:54,000 --> 01:27:57,000
它不管你分开是何它就是一个字符

2082
01:27:57,000 --> 01:27:58,000
而如果你用这样分解的话

2083
01:27:58,000 --> 01:28:02,000
它会说这个 s 谁样是这个长 s 谁样是 s 的一个变种

2084
01:28:02,000 --> 01:28:05,000
所以在匹配的时候我必须把它匹配成一个短 s

2085
01:28:07,000 --> 01:28:08,000
就是说有一些

2086
01:28:08,000 --> 01:28:10,000
你便于搜索到

2087
01:28:10,000 --> 01:28:13,000
就有一些组合在标准分解它是不能分解

2088
01:28:13,000 --> 01:28:15,000
但是为了让大家方便

2089
01:28:15,000 --> 01:28:19,000
这样分解就把它强行拆开了

2090
01:28:19,000 --> 01:28:22,000
是的

2091
01:28:22,000 --> 01:28:23,000
天哪

2092
01:28:23,000 --> 01:28:25,000
对它有它有几种常见的形式

2093
01:28:25,000 --> 01:28:27,000
一种就是一个字母

2094
01:28:27,000 --> 01:28:32,000
它可能有一些字体设计历史原因带来的不一样

2095
01:28:32,000 --> 01:28:33,000
比如说一个拉丁字母

2096
01:28:33,000 --> 01:28:35,000
它可以设计成好几种形式的

2097
01:28:35,000 --> 01:28:38,000
比如说什么有什么双层形之类的

2098
01:28:38,000 --> 01:28:40,000
就这个双层是指这个视觉样式上的

2099
01:28:40,000 --> 01:28:42,000
比如它有一个双勾线的这种形式

2100
01:28:42,000 --> 01:28:46,000
然后另一种形式比如说有一些空白字符

2101
01:28:46,000 --> 01:28:48,000
它们可能都是一个空格

2102
01:28:48,000 --> 01:28:51,000
但是它们可能有我们知道 unicode 有非常多种空格

2103
01:28:51,000 --> 01:28:54,000
但是我们希望它们在搜索的时候

2104
01:28:54,000 --> 01:28:56,000
或者在语义识别的时候认为它们都是空格

2105
01:28:56,000 --> 01:28:57,000
这一种都是 white space

2106
01:28:57,000 --> 01:28:59,000
对然后另外一种就是刚才吴涛说的

2107
01:28:59,000 --> 01:29:01,000
有一些语言里面有一些字母

2108
01:29:01,000 --> 01:29:02,000
它在不同的位置上

2109
01:29:02,000 --> 01:29:04,000
它其实会有不一样的写法

2110
01:29:04,000 --> 01:29:06,000
然后它也有不一样的 unicode 的码位

2111
01:29:06,000 --> 01:29:07,000
对 ok

2112
01:29:07,000 --> 01:29:08,000
对

2113
01:29:08,000 --> 01:29:10,000
然后接下来有一种比如说数字有的是带圈的

2114
01:29:10,000 --> 01:29:11,000
有的是不带圈的

2115
01:29:11,000 --> 01:29:13,000
但它们可能都是同一个数字 1 或者数字 2

2116
01:29:13,000 --> 01:29:15,000
那么它们应该是一样的

2117
01:29:15,000 --> 01:29:17,000
就我们希望它们识别成一样的

2118
01:29:17,000 --> 01:29:21,000
然后日语里面假名有半角和全角的区别

2119
01:29:21,000 --> 01:29:25,000
然后汉语里面标点符号有竖排和横排的区别

2120
01:29:25,000 --> 01:29:28,000
然后还有像数学里面有上标和下标

2121
01:29:28,000 --> 01:29:31,000
和这个非上标下标的这个普通数字的这个区别

2122
01:29:31,000 --> 01:29:33,000
但它们都是同一个数字

2123
01:29:33,000 --> 01:29:36,000
另外日语里面还有一些就是几个字母

2124
01:29:36,000 --> 01:29:37,000
几个字或者几个假名

2125
01:29:37,000 --> 01:29:38,000
它会组合成一起

2126
01:29:38,000 --> 01:29:40,000
比如说这个年号像什么平成

2127
01:29:40,000 --> 01:29:42,000
它可能会组合成一个字符

2128
01:29:42,000 --> 01:29:45,000
但它也可以写成平成这两个字

2129
01:29:45,000 --> 01:29:47,000
诸事会社

2130
01:29:47,000 --> 01:29:48,000
对对对

2131
01:29:48,000 --> 01:29:49,000
一个叠在一起的

2132
01:29:49,000 --> 01:29:50,000
对对对

2133
01:29:50,000 --> 01:29:52,000
那个填字格的方式

2134
01:29:52,000 --> 01:29:53,000
对另外就是下有分数

2135
01:29:53,000 --> 01:29:54,000
比如说 1 1

2136
01:29:54,000 --> 01:29:57,000
它可能有一个单独的码位就是 1 1

2137
01:29:57,000 --> 01:29:59,000
但我们也可以写成 1-2 这样的一种

2138
01:29:59,000 --> 01:30:01,000
对这个例子很好

2139
01:30:01,000 --> 01:30:03,000
我第一次我刚到德国的时候

2140
01:30:03,000 --> 01:30:05,000
最惊艳的一件事情就是

2141
01:30:05,000 --> 01:30:06,000
德语介绍上有 1 3 1

2142
01:30:06,000 --> 01:30:08,000
我说你 3 G 这两个建议

2143
01:30:13,000 --> 01:30:14,000
所以我问一下

2144
01:30:14,000 --> 01:30:16,000
刚刚我们讲的很多都是外文的问题

2145
01:30:16,000 --> 01:30:17,000
中文有这个问题吗

2146
01:30:17,000 --> 01:30:18,000
中文我刚刚说了一个

2147
01:30:18,000 --> 01:30:20,000
就是标点的横竖形

2148
01:30:20,000 --> 01:30:22,000
就是横排和竖排标点

2149
01:30:22,000 --> 01:30:24,000
但这个不涉及拆解的问题吧

2150
01:30:24,000 --> 01:30:26,000
它就是说把哪些

2151
01:30:26,000 --> 01:30:28,000
它本来不在一个码位的标点

2152
01:30:28,000 --> 01:30:30,000
但是因为我们认为它的

2153
01:30:30,000 --> 01:30:32,000
在某一些情况下认为它是等价的

2154
01:30:32,000 --> 01:30:35,000
对所以 normalization 不只是一个拆分的问题

2155
01:30:35,000 --> 01:30:38,000
它有的时候也是单个字符之间相互的等价问题

2156
01:30:38,000 --> 01:30:41,000
中文是没有拆分和组合这个问题吗

2157
01:30:41,000 --> 01:30:43,000
中文基本上没有

2158
01:30:43,000 --> 01:30:45,000
但韩语可能就会有

2159
01:30:45,000 --> 01:30:47,000
那中文那个带圈文字是有这个问题吗

2160
01:30:47,000 --> 01:30:49,000
中文什么

2161
01:30:49,000 --> 01:30:53,000
带圈文字的话就会有刚才那个兼容的问题吗

2162
01:30:53,000 --> 01:30:55,000
就是因为它即使加了一个圈

2163
01:30:55,000 --> 01:30:57,000
但是比如说那个

2164
01:30:57,000 --> 01:30:59,000
圈里面加一圈是吧

2165
01:30:59,000 --> 01:31:02,000
对啊对啊就是圆圈嘛

2166
01:31:02,000 --> 01:31:04,000
有人说要为它升级根本特殊了嘛

2167
01:31:04,000 --> 01:31:05,000
为它升级根本特殊的码位

2168
01:31:05,000 --> 01:31:06,000
这是另外的

2169
01:31:06,000 --> 01:31:07,000
还有比如说像什么

2170
01:31:07,000 --> 01:31:08,000
跨湖 1 对吧

2171
01:31:08,000 --> 01:31:09,000
跨湖 123456789

2172
01:31:09,000 --> 01:31:11,000
汉字的对吧

2173
01:31:11,000 --> 01:31:13,000
像这些都是有那个兼容的

2174
01:31:13,000 --> 01:31:16,000
这样的兼容的话给它拆成三个嘛

2175
01:31:16,000 --> 01:31:19,000
前跨湖汉字 1 后跨湖

2176
01:31:19,000 --> 01:31:21,000
就是它以辞养日嘛

2177
01:31:21,000 --> 01:31:23,000
以便语可以搜索到嘛

2178
01:31:23,000 --> 01:31:25,000
中文其实也有这个问题对吧

2179
01:31:25,000 --> 01:31:27,000
对这些其实都是日本过来

2180
01:31:27,000 --> 01:31:28,000
我觉得

2181
01:31:28,000 --> 01:31:31,000
最早应该都是日本人去申请这些码位

2182
01:31:31,000 --> 01:31:33,000
那我再问一下那是不是说

2183
01:31:33,000 --> 01:31:35,000
现在不是流行那个火星文吗

2184
01:31:35,000 --> 01:31:36,000
啊

2185
01:31:36,000 --> 01:31:39,000
火星不是只有半截是那个正常的字吗

2186
01:31:39,000 --> 01:31:40,000
Oh my God

2187
01:31:40,000 --> 01:31:42,000
不不不都是没有用的是吧

2188
01:31:42,000 --> 01:31:43,000
所以其实

2189
01:31:43,000 --> 01:31:44,000
Oh my God

2190
01:31:44,000 --> 01:31:46,000
按照这个能不能等价是不是

2191
01:31:46,000 --> 01:31:50,000
对啊对啊你你必然就是我们在实际使用的情况下

2192
01:31:50,000 --> 01:31:55,000
火星人火星文必然是等价为某一些这个就是非火星文的文本的吧

2193
01:31:55,000 --> 01:31:58,000
就其实它也是一个这个我觉得这个还是

2194
01:31:58,000 --> 01:32:00,000
你留给人工智能解决了

2195
01:32:00,000 --> 01:32:01,000
我靠

2196
01:32:01,000 --> 01:32:03,000
这个你强强强强

2197
01:32:03,000 --> 01:32:07,000
我一个诺贝赛舍的过程考虑这种情况实在是太强一组了

2198
01:32:07,000 --> 01:32:08,000
因为我就说

2199
01:32:08,000 --> 01:32:11,000
因为这个可能不用不需要在这个就不能写到规范里面去嘛

2200
01:32:11,000 --> 01:32:13,000
但是如果说啊

2201
01:32:13,000 --> 01:32:16,000
比如说这个我们现在在做一个这个啊审查系统对吧

2202
01:32:16,000 --> 01:32:22,000
我们做这个啊这个内容过滤可能要过滤到某一些啊不合时宜的字的时候

2203
01:32:22,000 --> 01:32:25,000
你肯定还是要做这个火星文的拆解

2204
01:32:25,000 --> 01:32:27,000
然后做一个等价替换了啊

2205
01:32:27,000 --> 01:32:30,000
就你说能不能沿用优内扣的这套诺贝赛

2206
01:32:30,000 --> 01:32:32,000
就罗他的罗他的逻辑肯定是一样的嘛

2207
01:32:32,000 --> 01:32:34,000
他就是所谓的兼容分解嘛

2208
01:32:34,000 --> 01:32:35,000
这个不一定

2209
01:32:35,000 --> 01:32:36,000
我觉得不一定

2210
01:32:36,000 --> 01:32:38,000
就要看你能不能设计出这样一套机制

2211
01:32:38,000 --> 01:32:41,000
因为其实 normalization 有一个数学上特性

2212
01:32:41,000 --> 01:32:42,000
他叫密等性嘛

2213
01:32:42,000 --> 01:32:46,000
就是你无论对一个串做多少次这个 normalization 之后

2214
01:32:46,000 --> 01:32:48,000
结果最终是一样的

2215
01:32:48,000 --> 01:32:53,000
对对对就是你要看你的设计的这套拆解和组合机制能不能符合这个密等性

2216
01:32:53,000 --> 01:32:56,000
而且密等要倒回来

2217
01:32:56,000 --> 01:32:58,000
对当然要倒回来

2218
01:32:58,000 --> 01:32:59,000
哈哈哈哈

2219
01:32:59,000 --> 01:33:00,000
哈哈哈哈

2220
01:33:00,000 --> 01:33:01,000
哈哈哈哈

2221
01:33:01,000 --> 01:33:02,000
哈哈哈哈

2222
01:33:02,000 --> 01:33:05,000
倒不回来的话就不是都错了吗

2223
01:33:05,000 --> 01:33:07,000
对所以我觉得火星文可能有问题

2224
01:33:07,000 --> 01:33:08,000
火星文有问题

2225
01:33:08,000 --> 01:33:10,000
但肯定是倒不回来的呀

2226
01:33:10,000 --> 01:33:12,000
比如说比如说他原始的一个

2227
01:33:12,000 --> 01:33:17,000
我们刚才举那个 u 和上面有个有一个 u 撇这个一个情况嘛

2228
01:33:17,000 --> 01:33:20,000
但其实我们想来他应该有好几种组合形式对吧

2229
01:33:20,000 --> 01:33:23,000
他可以说是 u 组合一个 u

2230
01:33:23,000 --> 01:33:26,000
就最差一点三个那点然后拼一起的方式嘛

2231
01:33:26,000 --> 01:33:29,000
他可以说是就是 u 上面有 u

2232
01:33:29,000 --> 01:33:30,000
然后再加一个音调

2233
01:33:30,000 --> 01:33:32,000
就是就两个两个点对吧

2234
01:33:32,000 --> 01:33:35,000
他也可以是 u 有声调再加两个点嘛

2235
01:33:35,000 --> 01:33:38,000
其实你拆解之后你是回不去的

2236
01:33:38,000 --> 01:33:40,000
它是一个单向的过程

2237
01:33:40,000 --> 01:33:42,000
就好像繁体中文转简体中文一样

2238
01:33:42,000 --> 01:33:46,000
你是不能过去又回来的吗

2239
01:33:46,000 --> 01:33:49,000
ok

2240
01:33:49,000 --> 01:33:52,000
他应该不是一个可逆的操作

2241
01:33:52,000 --> 01:33:53,000
为什么

2242
01:33:53,000 --> 01:33:56,000
因为你丢失了你最开始你进去

2243
01:33:56,000 --> 01:33:58,000
你丢失了一开始的信息这是没错的

2244
01:33:58,000 --> 01:34:00,000
你 normalize 过后

2245
01:34:00,000 --> 01:34:03,000
你一开始什么样你就不知道

2246
01:34:03,000 --> 01:34:04,000
对啊

2247
01:34:04,000 --> 01:34:06,000
所以他就都能做到密的

2248
01:34:06,000 --> 01:34:08,000
就是可以不断重复的做一个动物

2249
01:34:08,000 --> 01:34:10,000
而且他得到结果是稳定的

2250
01:34:10,000 --> 01:34:12,000
但是他不能他不能做不能反回

2251
01:34:12,000 --> 01:34:14,000
不能再再逆回就不可逆了

2252
01:34:14,000 --> 01:34:17,000
你就你的意思是你不知道他最初这个 sauce

2253
01:34:17,000 --> 01:34:19,000
究竟是哪一种表达形式

2254
01:34:19,000 --> 01:34:23,000
对对对你不知道是你那么人就就就破坏掉那个信息了嘛

2255
01:34:23,000 --> 01:34:25,000
ok 但是他们永远是相等的

2256
01:34:25,000 --> 01:34:28,000
但是如果你拆这个汉字的话就不一定了

2257
01:34:28,000 --> 01:34:29,000
因为你本质上猜汉字的话就不一定了

2258
01:34:29,000 --> 01:34:33,000
你本质上猜汉字就是把汉字拆成各种偏旁步手

2259
01:34:33,000 --> 01:34:35,000
然后把他们组合起来

2260
01:34:35,000 --> 01:34:37,000
但我们知道汉字这个偏旁步手

2261
01:34:37,000 --> 01:34:41,000
可能前一个字的一个偏旁可以成为后一个字的另一个偏旁

2262
01:34:41,000 --> 01:34:43,000
所以他们的组合方式有很多嘛

2263
01:34:43,000 --> 01:34:46,000
这个时候他们他们就可能不密等了

2264
01:34:46,000 --> 01:34:48,000
就是那个火星文的左右两边

2265
01:34:48,000 --> 01:34:51,000
你可能选出来的那个字是就是一个选的左边那个步手

2266
01:34:51,000 --> 01:34:53,000
一个是选的是六边那个步手对吧

2267
01:34:53,000 --> 01:34:55,000
对对对就有可能会有这种情况

2268
01:34:55,000 --> 01:34:58,000
对这有可能会破坏这个密等性的

2269
01:34:59,000 --> 01:35:01,000
所以还是听课的一个事情

2270
01:35:01,000 --> 01:35:03,000
因为因为那口的为了维持这个密等性

2271
01:35:03,000 --> 01:35:05,000
他其实是做了很多工作的

2272
01:35:05,000 --> 01:35:08,000
包括他定义了这个拆解出来的部件的顺序

2273
01:35:08,000 --> 01:35:10,000
如果你破坏了这个顺序的话

2274
01:35:10,000 --> 01:35:12,000
就有可能破坏这个密等性

2275
01:35:12,000 --> 01:35:15,000
所以他拆解的这个顺序是有确定的顺序的

2276
01:35:15,000 --> 01:35:16,000
比如有一些字母

2277
01:35:16,000 --> 01:35:17,000
他可能上面可以加一个点

2278
01:35:17,000 --> 01:35:18,000
下面也可以加一个点

2279
01:35:18,000 --> 01:35:21,000
那么哪个点是下面这个点在前

2280
01:35:21,000 --> 01:35:22,000
还是上面这个点在前

2281
01:35:22,000 --> 01:35:24,000
他其实是有固定顺序的

2282
01:35:24,000 --> 01:35:26,000
嗯嗯嗯

2283
01:35:26,000 --> 01:35:28,000
本期节目的那个 shownotes

2284
01:35:28,000 --> 01:35:31,000
里面还得注标注一下密等性的一个连接

2285
01:35:31,000 --> 01:35:33,000
到底大家去理解一下

2286
01:35:33,000 --> 01:35:34,000
密等性天哪

2287
01:35:36,000 --> 01:35:38,000
庞家对最后最后肯定

2288
01:35:38,000 --> 01:35:40,000
我相信肯定有读者是连着密等性

2289
01:35:40,000 --> 01:35:43,000
一路点点到什么庞家来什么

2290
01:35:45,000 --> 01:35:46,000
感觉那个数学问题

2291
01:35:46,000 --> 01:35:48,000
对哥德尔不完备地理

2292
01:35:51,000 --> 01:35:52,000
挂了好大一个

2293
01:35:52,000 --> 01:35:54,000
比如说 wikip 的各种链接点点点

2294
01:35:54,000 --> 01:35:56,000
你最后都会点到那这个页面

2295
01:35:56,000 --> 01:35:58,000
对最终肯定会回到哲学

2296
01:35:58,000 --> 01:35:59,000
我给你讲

2297
01:35:59,000 --> 01:36:00,000
我喜欢数学

2298
01:36:00,000 --> 01:36:02,000
哈哈哈哈哈哈

2299
01:36:02,000 --> 01:36:04,000
哈哈哈哈

2300
01:36:04,000 --> 01:36:06,000
哈哈哈哈

2301
01:36:06,000 --> 01:36:08,000
刚才我们讲了这个就是那个浪漫的

2302
01:36:08,000 --> 01:36:10,000
这身的各种方法和他的背后的一些这个机制

2303
01:36:10,000 --> 01:36:11,000
哈

2304
01:36:11,000 --> 01:36:12,000
那就这样

2305
01:36:12,000 --> 01:36:13,000
然后我们回来讲那个 APFS

2306
01:36:13,000 --> 01:36:14,000
他在 macOS 和 iOS 里面到底不一样的地方

2307
01:36:14,000 --> 01:36:15,000
我觉得这个还其实挺挺挺有意思的

2308
01:36:15,000 --> 01:36:16,000
因为照我的理解

2309
01:36:16,000 --> 01:36:17,000
APFS 在 macOS 里面对于我们来说的处理是最近的

2310
01:36:17,000 --> 01:36:18,000
就是在这个时候

2311
01:36:18,000 --> 01:36:19,000
我们在这个时候

2312
01:36:19,000 --> 01:36:20,000
我们在这个时候

2313
01:36:20,000 --> 01:36:21,000
我们在这个时候

2314
01:36:21,000 --> 01:36:22,000
我们在这个时候

2315
01:36:22,000 --> 01:36:23,000
我们在这个时候

2316
01:36:23,000 --> 01:36:24,000
我们在这个时候

2317
01:36:24,000 --> 01:36:25,000
我们在这个时候

2318
01:36:25,000 --> 01:36:26,000
我们在这个时候

2319
01:36:26,000 --> 01:36:27,000
我们在这个时候

2320
01:36:27,000 --> 01:36:28,000
我们在这个时候

2321
01:36:28,000 --> 01:36:29,000
我们在这个时候

2322
01:36:29,000 --> 01:36:30,000
我们在这个时候

2323
01:36:30,000 --> 01:36:31,000
我们在这个时候

2324
01:36:31,000 --> 01:36:32,000
我们在这个时候

2325
01:36:32,000 --> 01:36:33,000
我们才能够处理

2326
01:36:33,000 --> 01:36:34,000
我们才能够处理

2327
01:36:34,000 --> 01:36:35,000
所以我们现在是把这些的处理是最近才决定的

2328
01:36:35,000 --> 01:36:36,000
就其实我们在之前上那个 iOS 的 APFS

2329
01:36:36,000 --> 01:36:37,000
他是没有考虑这个问题的

2330
01:36:37,000 --> 01:36:38,000
嗯

2331
01:36:38,000 --> 01:36:39,000
对

2332
01:36:39,000 --> 01:36:40,000
所以他现在搞了一个什么样的一个哈西的方式

2333
01:36:40,000 --> 01:36:41,000
我还没太明白

2334
01:36:41,000 --> 01:36:42,000
你们谁看

2335
01:36:42,000 --> 01:36:43,000
我也不知道

2336
01:36:43,000 --> 01:36:44,000
嗯

2337
01:36:44,000 --> 01:36:45,000
他

2338
01:36:45,000 --> 01:36:46,000
就

2339
01:36:46,000 --> 01:36:47,000
就是

2340
01:36:47,000 --> 01:36:48,000
就说

2341
01:36:48,000 --> 01:36:49,000
因为他改成 APFS

2342
01:36:49,000 --> 01:36:51,000
就是

2343
01:36:51,000 --> 01:36:52,000
不管 mac 是用 hfs 加还是用 APFS

2344
01:36:52,000 --> 01:36:53,000
他都是这个 normanization insensitive 的

2345
01:36:53,000 --> 01:36:54,000
他就

2346
01:36:54,000 --> 01:36:55,000
就是

2347
01:36:55,000 --> 01:36:56,000
他就是

2348
01:36:56,000 --> 01:36:58,000
它不敏感

2349
01:36:58,000 --> 01:37:01,000
它对你这个规范化形式不敏感

2350
01:37:01,000 --> 01:37:02,000
但是呢

2351
01:37:02,000 --> 01:37:05,000
HFS 它是

2352
01:37:05,000 --> 01:37:09,000
它就直接存在那个磁盘上了

2353
01:37:09,000 --> 01:37:11,000
那 APFS 呢

2354
01:37:11,000 --> 01:37:11,000
它会

2355
01:37:11,000 --> 01:37:13,000
它是先规范化

2356
01:37:13,000 --> 01:37:14,000
然后这个文件名

2357
01:37:14,000 --> 01:37:16,000
它会另外生成一个哈希值

2358
01:37:16,000 --> 01:37:18,000
来指

2359
01:37:18,000 --> 01:37:22,000
来给这个提供那个 normalization 的

2360
01:37:22,000 --> 01:37:25,000
这个就不敏感性

2361
01:37:25,000 --> 01:37:26,000
要不然的话就找不到了嘛

2362
01:37:26,000 --> 01:37:29,000
就是所以它必须再给它附一个

2363
01:37:29,000 --> 01:37:30,000
那个自动附一个哈希值

2364
01:37:30,000 --> 01:37:32,000
OK

2365
01:37:32,000 --> 01:37:36,000
这里面其实还挺麻烦的

2366
01:37:36,000 --> 01:37:37,000
因为有几个问题

2367
01:37:37,000 --> 01:37:38,000
就刚才也讲了

2368
01:37:38,000 --> 01:37:39,000
有几个事情融在了一起

2369
01:37:39,000 --> 01:37:39,000
就是一个说它

2370
01:37:39,000 --> 01:37:41,000
要不要保留那个

2371
01:37:41,000 --> 01:37:43,000
就是你开始的这个

2372
01:37:43,000 --> 01:37:44,000
先说一下

2373
01:37:44,000 --> 01:37:45,000
还有个事情没说刚才

2374
01:37:45,000 --> 01:37:46,000
因为跟这也有关系

2375
01:37:46,000 --> 01:37:49,000
就是 iOS 的那个文件名是

2376
01:37:49,000 --> 01:37:50,000
大小写敏感的

2377
01:37:50,000 --> 01:37:51,000
就是大小写是

2378
01:37:51,000 --> 01:37:53,000
就同样一个文件名

2379
01:37:53,000 --> 01:37:54,000
大小写不一样

2380
01:37:54,000 --> 01:37:55,000
它认为是不一样的

2381
01:37:55,000 --> 01:37:55,000
那个

2382
01:37:55,000 --> 01:37:56,000
那个

2384
01:38:26,000 --> 01:38:27,000
就是你可以选择

2385
01:38:27,000 --> 01:38:29,000
让那个文件系统是做成大小写

2386
01:38:29,000 --> 01:38:29,000
敏感的

2387
01:38:29,000 --> 01:38:31,000
但这个应该用的人不多

2388
01:38:31,000 --> 01:38:33,000
而且在用了就会导致很多兼容性的问题

2389
01:38:33,000 --> 01:38:35,000
就是不太鼓励大家这么做的

2390
01:38:35,000 --> 01:38:37,000
所以这里面如果他是用哈希值的话

2391
01:38:37,000 --> 01:38:38,000
就会牵涉到这个问题了

2392
01:38:38,000 --> 01:38:41,000
就是说如果他是大小写 preserving

2393
01:38:41,000 --> 01:38:43,000
就是 case preserving 的话

2394
01:38:43,000 --> 01:38:47,000
他哈希的那个串是到底是什么

2395
01:38:49,000 --> 01:38:55,000
因为大小写不同的两个同样的字符串的哈希值是不一样的

2396
01:38:55,000 --> 01:38:56,000
对嗯嗯

2397
01:38:56,000 --> 01:38:57,000
这样的话啊

2398
01:38:57,000 --> 01:39:03,000
他的这个他的 case preserving 和他的这个哈希的方式其实是有冲突的

2399
01:39:03,000 --> 01:39:06,000
所以我一直没太搞明白这里是怎么一回事

2400
01:39:06,000 --> 01:39:11,000
我觉得像给自弹自唱的这个听众简单解释一下哈希是个什么样的过程

2401
01:39:13,000 --> 01:39:18,000
哈希你可以理解成为就是我们把一个一个一个字符串吧

2402
01:39:18,000 --> 01:39:25,000
然后通过某种数学的方式把它变成一个固定长度的一个一个一个数字

2403
01:39:25,000 --> 01:39:28,000
这本的可能都是比如说是一百二十二

2404
01:39:28,000 --> 01:39:28,000
不对

2405
01:39:28,000 --> 01:39:30,000
哈希一般十六个字节是多少

2406
01:39:30,000 --> 01:39:33,000
十六个字节是乘以八对吧

2407
01:39:33,000 --> 01:39:34,000
二百五十六个

2408
01:39:34,000 --> 01:39:36,000
呃

2409
01:39:36,000 --> 01:39:38,000
别错了

2410
01:39:38,000 --> 01:39:40,000
二百五十六个字符

2411
01:39:40,000 --> 01:39:44,000
给他一个生成了一个特定的一个码

2412
01:39:44,000 --> 01:39:45,000
一个电号

2413
01:39:45,000 --> 01:39:46,000
对

2414
01:39:46,000 --> 01:39:50,000
定成的会会返回一个比如二百五十六个 bit 的一个数

2415
01:39:50,000 --> 01:39:52,000
或者是五百一十二个 bit 的一个数

2416
01:39:52,000 --> 01:39:55,000
然后因为这个数其实足够大嘛

2417
01:39:55,000 --> 01:39:55,000
你想想

2418
01:39:55,000 --> 01:39:59,000
二的二的二百五十六次方这个数其实非常大的

2419
01:39:59,000 --> 01:40:00,000
那么这个哈希有个什么特性呢

2420
01:40:00,000 --> 01:40:04,000
就是说只要我们这个哈希算法或者这个哈希函数选的少

2421
01:40:04,000 --> 01:40:18,000
我们可以做到在呃一个几乎可以忽略的概率上得到那个数和呃就两个就不太可能得你不太可能拿两个有意义的文本得到两个完全一样的哈希的值

2422
01:40:18,000 --> 01:40:19,000
嗯嗯啊

2423
01:40:19,000 --> 01:40:22,000
这个可能有很多人比较容易费解这个东西

2424
01:40:22,000 --> 01:40:24,000
就因为你想一下这个数在数学上是不可能的嘛

2425
01:40:24,000 --> 01:40:24,000
因为

2426
01:40:24,000 --> 01:40:26,000
它在比较大的一个 Candid 的当中

2427
01:40:26,000 --> 01:40:27,000
你看

2428
01:40:27,000 --> 01:40:27,000
不过

2429
01:40:27,000 --> 01:40:28,000
我们在这里

2430
01:40:28,000 --> 01:40:31,000
那个呼 detection 或者érence 等等

2431
01:40:31,000 --> 01:40:32,000
但是有一个就是 už

2432
01:40:32,000 --> 01:40:33,000
at

2433
01:40:33,000 --> 01:40:33,000
Franci

2434
01:40:33,000 --> 01:40:33,000
这就是那个

2435
01:40:33,000 --> 01:40:34,000
这个

2436
01:40:34,000 --> 01:40:35,000
那是我们解では

2437
01:40:35,000 --> 01:40:35,000
她是 picture

2438
01:40:35,000 --> 01:40:35,000
加拿大

2439
01:40:35,000 --> 01:40:36,000
合成

2440
01:40:36,000 --> 01:40:36,000
还 rank

2441
01:40:36,000 --> 01:40:37,000
或者犯 forbid

2442
01:40:37,000 --> 01:40:37,000
或者这个

2443
01:40:37,000 --> 01:40:38,000
就是有 Nam

2444
01:40:38,000 --> 01:40:41,000
我们来了

2445
01:40:41,000 --> 01:40:41,000
就是这个

2446
01:40:41,000 --> 01:40:41,000
� figur

2447
01:40:41,000 --> 01:40:42,000
这两个ツ

2448
01:40:42,000 --> 01:40:42,000
雕像

2449
01:40:42,000 --> 01:40:45,000
你可以用这句话

2450
01:40:45,000 --> 01:40:46,000
那个

2451
01:40:46,000 --> 01:40:46,000
我取得的

2452
01:40:46,000 --> 01:40:47,000
5000

2453
01:40:47,000 --> 01:40:47,000
一下

2454
01:40:47,000 --> 01:40:48,000
自己

2455
01:40:48,000 --> 01:40:48,000
plus

2456
01:40:48,000 --> 01:40:50,000
p

2457
01:40:50,000 --> 01:40:52,000
大概率上认为是不会出现那种

2458
01:40:52,000 --> 01:40:54,000
两个不同的输入

2459
01:40:54,000 --> 01:40:55,000
得到同一个哈希值的

2460
01:40:55,000 --> 01:40:57,000
然后这个哈希值

2461
01:40:57,000 --> 01:40:58,000
我们可以拿来做很多事情

2462
01:40:58,000 --> 01:40:59,000
比如说我们可以拿来

2463
01:40:59,000 --> 01:41:01,000
把一个东西缩短成一个

2464
01:41:01,000 --> 01:41:02,000
我们认为

2465
01:41:02,000 --> 01:41:03,000
这个它是一个

2466
01:41:03,000 --> 01:41:04,000
类似于指纹的一个概念

2467
01:41:04,000 --> 01:41:05,000
对吧

2468
01:41:05,000 --> 01:41:06,000
我们就说

2469
01:41:06,000 --> 01:41:07,000
这一串哈希值

2470
01:41:07,000 --> 01:41:09,000
可以对应那串原文

2471
01:41:09,000 --> 01:41:10,000
因为我们找不到

2472
01:41:10,000 --> 01:41:11,000
另外一串原文

2473
01:41:11,000 --> 01:41:12,000
跟这个

2474
01:41:12,000 --> 01:41:14,000
可以得到同样的哈希值

2475
01:41:14,000 --> 01:41:16,000
然后 APFS 里面

2476
01:41:16,000 --> 01:41:17,000
它就说

2477
01:41:17,000 --> 01:41:18,000
我是用这个哈希值

2478
01:41:18,000 --> 01:41:19,000
来保存文件的

2479
01:41:19,000 --> 01:41:19,000
对吧

2480
01:41:19,000 --> 01:41:21,000
保存文件名

2481
01:41:21,000 --> 01:41:22,000
对

2482
01:41:22,000 --> 01:41:23,000
但我就不太理解

2483
01:41:23,000 --> 01:41:24,000
就是说这里面

2484
01:41:24,000 --> 01:41:25,000
如果它怎么去解决

2485
01:41:25,000 --> 01:41:25,000
刚才讲的那个

2486
01:41:25,000 --> 01:41:27,000
case preserving 的问题

2487
01:41:27,000 --> 01:41:27,000
就其实我看起来

2488
01:41:27,000 --> 01:41:29,000
还觉得还挺难的

2489
01:41:29,000 --> 01:41:30,000
所以

2490
01:41:30,000 --> 01:41:31,000
就是这有一个历史

2491
01:41:31,000 --> 01:41:33,000
就是在这个

2492
01:41:33,000 --> 01:41:35,000
MacOS Sierra

2493
01:41:35,000 --> 01:41:37,000
去年 6 月份

2494
01:41:37,000 --> 01:41:39,000
它已经

2495
01:41:39,000 --> 01:41:40,000
它有做一个

2496
01:41:40,000 --> 01:41:41,000
APFS 的第一版的

2497
01:41:41,000 --> 01:41:42,000
开发者的预览版

2498
01:41:42,000 --> 01:41:44,000
当时这个预览版里面

2499
01:41:44,000 --> 01:41:46,000
只有 case sensitive 的版本

2500
01:41:46,000 --> 01:41:48,000
就是说明

2501
01:41:48,000 --> 01:41:49,000
那时候苹果还没

2502
01:41:49,000 --> 01:41:50,000
没想好

2503
01:41:50,000 --> 01:41:51,000
就怎么做你知道吧

2504
01:41:51,000 --> 01:41:52,000
所以当时它

2505
01:41:52,000 --> 01:41:54,000
做的第一版的开发者预览版

2506
01:41:54,000 --> 01:41:56,000
只能做 case sensitive

2507
01:41:56,000 --> 01:41:57,000
对大小写

2508
01:41:57,000 --> 01:41:58,000
因为这个是最简单

2509
01:41:58,000 --> 01:41:59,000
对

2510
01:41:59,000 --> 01:42:01,000
然后等到后面

2511
01:42:01,000 --> 01:42:05,000
MacOS 的 10.12.4 了以后

2512
01:42:05,000 --> 01:42:06,000
给这个开发者预览版

2513
01:42:06,000 --> 01:42:08,000
后面它才补加了

2514
01:42:08,000 --> 01:42:10,000
做出来这个 case insensitive 的版本

2515
01:42:10,000 --> 01:42:11,000
因为它这个是

2516
01:42:11,000 --> 01:42:13,000
就是也是因为

2517
01:42:13,000 --> 01:42:15,000
就是为了去填那个历史的坑

2518
01:42:15,000 --> 01:42:16,000
因为过去 HFS

2519
01:42:16,000 --> 01:42:17,000
它是默认是 insensitive

2520
01:42:17,000 --> 01:42:19,000
你就很尴尬

2521
01:42:19,000 --> 01:42:19,000
对

2522
01:42:19,000 --> 01:42:19,000
对

2523
01:42:19,000 --> 01:42:22,000
,所以其实就是它在后面

2524
01:42:22,000 --> 01:42:24,000
具体它在怎么搞

2525
01:42:24,000 --> 01:42:25,000
其实我也不大清楚

2526
01:42:25,000 --> 01:42:26,000
但是就是因为有这个坑

2527
01:42:26,000 --> 01:42:28,000
所以对

2528
01:42:28,000 --> 01:42:29,000
因为有这个坑

2529
01:42:29,000 --> 01:42:31,000
所以它也是花了很长时间在搞

2530
01:42:31,000 --> 01:42:32,000
对

2531
01:42:32,000 --> 01:42:34,000
因为现在那个 APFS

2532
01:42:34,000 --> 01:42:36,000
就那个 HIFS 还没有

2533
01:42:36,000 --> 01:42:37,000
就是正式发布

2534
01:42:37,000 --> 01:42:38,000
现在只是 beta 版

2535
01:42:38,000 --> 01:42:40,000
就说他们还有的有的机会改

2536
01:42:40,000 --> 01:42:43,000
但是如果说到了今年的这个九月份

2537
01:42:43,000 --> 01:42:44,000
也就两个月的时间

2538
01:42:44,000 --> 01:42:46,000
对就会放出来

2539
01:42:46,000 --> 01:42:47,000
放出来之后

2540
01:42:47,000 --> 01:42:49,000
如果没有这个问题没解决好的话

2541
01:42:49,000 --> 01:42:49,000
就会导致

2542
01:42:49,000 --> 01:42:51,000
很多人的软件可能用不了

2543
01:42:51,000 --> 01:42:53,000
或者说是文件主问的情况

2544
01:42:53,000 --> 01:42:55,000
所以他们必须在这段时间

2545
01:42:55,000 --> 01:42:57,000
把这个问题给彻底解决了

2546
01:42:57,000 --> 01:42:57,000
嗯嗯

2547
01:42:57,000 --> 01:42:59,000
用各种方式吧

2548
01:42:59,000 --> 01:43:01,000
就现在我们看到的其实也不是一个

2549
01:43:01,000 --> 01:43:03,000
我觉得应该也不是一个最终的版本

2550
01:43:03,000 --> 01:43:04,000
嗯

2551
01:43:04,000 --> 01:43:06,000
不过反正

2552
01:43:06,000 --> 01:43:08,000
Hicera 是可以定了

2553
01:43:08,000 --> 01:43:10,000
就是肯定要用新的这个 APFS 了

2554
01:43:10,000 --> 01:43:11,000
嗯

2555
01:43:11,000 --> 01:43:12,000
在安安装过程中

2556
01:43:12,000 --> 01:43:13,000
他会默认的

2557
01:43:13,000 --> 01:43:15,000
他会先把你格式化一遍

2558
01:43:15,000 --> 01:43:16,000
你已经知道了吗

2559
01:43:16,000 --> 01:43:17,000
默默的格式化

2560
01:43:17,000 --> 01:43:18,000
没有没有

2561
01:43:18,000 --> 01:43:19,000
就是没抓到

2562
01:43:19,000 --> 01:43:22,000
但是其实在升那个 iOS 10.3 的时候

2563
01:43:22,000 --> 01:43:23,000
就是这样的

2564
01:43:23,000 --> 01:43:25,000
iOS 都说了

2565
01:43:25,000 --> 01:43:26,000
他不存在这个

2566
01:43:26,000 --> 01:43:27,000
他不担心这个问题

2567
01:43:27,000 --> 01:43:28,000
因为 iOS 并没有

2568
01:43:28,000 --> 01:43:28,000
对啊

2569
01:43:28,000 --> 01:43:28,000
没错

2570
01:43:28,000 --> 01:43:29,000
系统

2571
01:43:29,000 --> 01:43:32,000
而且 iOS 还有一个特性

2572
01:43:32,000 --> 01:43:33,000
就是他没有一个

2573
01:43:33,000 --> 01:43:35,000
他只有一套 API 去访问文件

2574
01:43:35,000 --> 01:43:37,000
就是都是用那个 Foundation 的一些库

2575
01:43:37,000 --> 01:43:39,000
他不像那个 Mac 里面

2576
01:43:39,000 --> 01:43:41,000
我们用这个 Terminal 的时候

2577
01:43:41,000 --> 01:43:42,000
其实直接用 Posix

2578
01:43:42,000 --> 01:43:44,000
就 Unix 那套逻辑去访问

2579
01:43:44,000 --> 01:43:48,000
所以他对他考虑的难度

2580
01:43:48,000 --> 01:43:49,000
就是

2581
01:43:49,000 --> 01:43:49,000
比较小很多

2582
01:43:49,000 --> 01:43:51,000
所以我觉得 Mac 其实挺大的一个坑的

2583
01:43:51,000 --> 01:43:52,000
嗯

2584
01:43:52,000 --> 01:43:54,000
而且说实话

2585
01:43:54,000 --> 01:43:55,000
这个东西对于用户来讲

2586
01:43:55,000 --> 01:43:56,000
是完全看不见的嘛

2587
01:43:56,000 --> 01:43:57,000
像我刚才说到

2588
01:43:57,000 --> 01:43:59,000
他这个格式化的过程

2589
01:43:59,000 --> 01:44:02,000
他其实就放到了那个安装进程里面

2590
01:44:02,000 --> 01:44:03,000
就是你开始

2591
01:44:03,000 --> 01:44:06,000
对尤其是对于 iOS

2592
01:44:06,000 --> 01:44:09,000
你在装在更新的时候

2593
01:44:09,000 --> 01:44:10,000
就用户不能做任何事情嘛

2594
01:44:10,000 --> 01:44:13,000
反正你就等着他不要重重新启动两遍

2595
01:44:13,000 --> 01:44:14,000
哦反正就是新的了

2596
01:44:14,000 --> 01:44:15,000
就这样

2597
01:44:15,000 --> 01:44:18,000
而且就是用户几遍知道了这个区域

2598
01:44:18,000 --> 01:44:20,000
这个区别他也改不了

2599
01:44:20,000 --> 01:44:20,000
做不了任何事情

2600
01:44:20,000 --> 01:44:22,000
因为用到这个程序

2601
01:44:22,000 --> 01:44:24,000
如果没有没有更新去支持这个事情的话

2602
01:44:24,000 --> 01:44:26,000
你也是只能抓瞎了

2603
01:44:26,000 --> 01:44:27,000
对

2604
01:44:27,000 --> 01:44:28,000
那对于 Mac 的话呢

2605
01:44:28,000 --> 01:44:31,000
可能就是因为如果万一搞不清楚的话

2606
01:44:31,000 --> 01:44:33,000
就会造成找不到文件了

2607
01:44:33,000 --> 01:44:34,000
对吧

2608
01:44:34,000 --> 01:44:37,000
因为那个 Normalization 不一样

2609
01:44:37,000 --> 01:44:38,000
文件名不一样嘛

2610
01:44:38,000 --> 01:44:39,000
然后就就和你资本

2611
01:44:39,000 --> 01:44:41,000
资本上存的东西不一样

2612
01:44:41,000 --> 01:44:41,000
就找不到了

2613
01:44:41,000 --> 01:44:47,000
就有时候最坑的最最差的结果嘛

2614
01:44:47,000 --> 01:44:48,000
所以所以这个 Normalization 这个事情呢

2615
01:44:48,000 --> 01:44:52,000
就是这个事情会对我们交换在不同系统里面交换文件产生影响嘛

2616
01:44:52,000 --> 01:44:54,000
就是因为现在有很多问题

2617
01:44:54,000 --> 01:45:00,000
比如说我知道你们因为收到 Windows 用户发给你们这种 Zip 这种打包的这种压缩包

2618
01:45:00,000 --> 01:45:02,000
啊经常会乱码的事情

2619
01:45:02,000 --> 01:45:05,000
就经常会解决出来里面的那个文件

2620
01:45:05,000 --> 01:45:07,000
就是那个名字是乱的嘛

2621
01:45:07,000 --> 01:45:08,000
嗯嗯

2622
01:45:08,000 --> 01:45:11,000
但是那个乱码的机制很复杂的

2623
01:45:11,000 --> 01:45:12,000
就是为什么会乱

2624
01:45:14,000 --> 01:45:15,000
哎

2625
01:45:15,000 --> 01:45:16,000
就是简单来说

2626
01:45:16,000 --> 01:45:17,000
哈哈

2627
01:45:17,000 --> 01:45:18,000
那个 Zip 打包的东西

2628
01:45:18,000 --> 01:45:18,000
就是那个 Normalization 的机制很复杂的就是为什么会乱呢

2629
01:45:18,000 --> 01:45:18,000
就是这个 Zip 打包的时候

2630
01:45:18,000 --> 01:45:21,000
他会把那些文件名的信息也装进去嘛

2631
01:45:21,000 --> 01:45:24,000
这个时候他用的那个 Encoding 的方式

2632
01:45:24,000 --> 01:45:25,000
嗯

2633
01:45:25,000 --> 01:45:28,000
就是 Zip 这个格式其实是比较灵活的

2634
01:45:28,000 --> 01:45:31,000
他不会要求说你一定要有什么 Encoding 的方式

2635
01:45:31,000 --> 01:45:33,000
这个时候都是由那个打包程序决定的嘛

2636
01:45:33,000 --> 01:45:37,000
但是解码的程序又如果用的跟那个打包程序

2637
01:45:37,000 --> 01:45:38,000
他用的那个理解是不一样的话

2638
01:45:38,000 --> 01:45:40,000
就会导致这个问题

2639
01:45:40,000 --> 01:45:43,000
经常我们收到一个 Windows 用户发过来打包的

2640
01:45:44,000 --> 01:45:46,000
但是这是编码层次的问题啊

2641
01:45:46,000 --> 01:45:47,000
就是比如说

2642
01:45:47,000 --> 01:45:48,000
他没有用 UTF-4

2643
01:45:48,000 --> 01:45:49,000
UTF-8 之类的

2644
01:45:49,000 --> 01:45:52,000
这是编码和解码的事情啊

2645
01:45:52,000 --> 01:45:53,000
对对对对对

2646
01:45:53,000 --> 01:45:55,000
但是我就说如果是

2647
01:45:55,000 --> 01:45:58,000
哪怕他们都是用了 UTF-8 去编码

2648
01:45:58,000 --> 01:45:59,000
那个 Normalization 不同的话

2649
01:45:59,000 --> 01:46:00,000
解出来后也会导致不懂

2650
01:46:00,000 --> 01:46:01,000
也会不一样

2651
01:46:01,000 --> 01:46:02,000
对

2652
01:46:02,000 --> 01:46:02,000
没错

2653
01:46:02,000 --> 01:46:02,000
是的

2654
01:46:02,000 --> 01:46:04,000
哎

2655
01:46:04,000 --> 01:46:07,000
所以这是一个非常非常深的一个

2656
01:46:07,000 --> 01:46:08,000
对对对

2657
01:46:08,000 --> 01:46:09,000
所以呢

2658
01:46:09,000 --> 01:46:11,000
就刚才说一般遇到乱码问题的话

2659
01:46:11,000 --> 01:46:13,000
是编码层面的问题

2660
01:46:13,000 --> 01:46:15,000
而像我刚才说了

2661
01:46:15,000 --> 01:46:15,000
呃

2662
01:46:15,000 --> 01:46:17,000
在

2663
01:46:17,000 --> 01:46:18,000
日文的 Windows

2664
01:46:18,000 --> 01:46:22,000
拷贝到 Mac 上面就会发现个字

2665
01:46:22,000 --> 01:46:23,000
被拆开来了

2666
01:46:23,000 --> 01:46:25,000
就会会有这样的问题

2667
01:46:25,000 --> 01:46:25,000
就变成一个字

2668
01:46:25,000 --> 01:46:27,000
它变成两个字了是吧

2669
01:46:27,000 --> 01:46:27,000
两个字了

2670
01:46:27,000 --> 01:46:30,000
对对就是你看了已经两个字了

2671
01:46:30,000 --> 01:46:31,000
你看的就已经是两个字

2672
01:46:31,000 --> 01:46:32,000
就是嗯

2673
01:46:32,000 --> 01:46:33,000
就会

2674
01:46:33,000 --> 01:46:34,000
我就完全会被被拆开来

2675
01:46:34,000 --> 01:46:37,000
就是因为他

2676
01:46:37,000 --> 01:46:41,000
已经他从就透到那个操作系统层面上来

2677
01:46:41,000 --> 01:46:42,000
变成 OK

2678
01:46:42,000 --> 01:46:43,000
就又会已经感受到

2679
01:46:43,000 --> 01:46:44,000
因为系统不一样

2680
01:46:44,000 --> 01:46:46,000
那这个时候你们怎么办呢

2681
01:46:46,000 --> 01:46:47,000
没办法呀

2682
01:46:47,000 --> 01:46:50,000
就自己再重新编辑一下文件名

2683
01:46:50,000 --> 01:46:51,000
对呀

2684
01:46:51,000 --> 01:46:52,000
但其实这个

2685
01:46:52,000 --> 01:46:55,000
这件事情并不是发生在

2686
01:46:55,000 --> 01:46:59,000
Normalization 的这个过程中

2687
01:46:59,000 --> 01:46:59,000
我觉得

2688
01:46:59,000 --> 01:47:00,000
对没错

2689
01:47:00,000 --> 01:47:01,000
这不是这个过程的

2690
01:47:01,000 --> 01:47:02,000
嗯

2691
01:47:02,000 --> 01:47:04,000
但是毕竟是因为它 Normalization

2692
01:47:04,000 --> 01:47:07,000
它的采取的原则方式不一样

2693
01:47:07,000 --> 01:47:07,000
然后最后呢

2694
01:47:07,000 --> 01:47:08,000
他

2695
01:47:08,000 --> 01:47:10,000
而且原来刚才也说了嘛

2696
01:47:10,000 --> 01:47:11,000
就 Normalization 这个事情

2697
01:47:11,000 --> 01:47:14,000
它其实是不会被用户所知道的嘛

2698
01:47:14,000 --> 01:47:15,000
嗯

2699
01:47:15,000 --> 01:47:16,000
就其实它是这样的嘛

2700
01:47:16,000 --> 01:47:16,000
就说

2701
01:47:16,000 --> 01:47:19,000
说明 Windows 的某一个用户

2702
01:47:19,000 --> 01:47:20,000
他在输入这个文件名的时候

2703
01:47:20,000 --> 01:47:22,000
他输入的那一串字符

2704
01:47:22,000 --> 01:47:24,000
其实就是一个被拆解的形式

2705
01:47:24,000 --> 01:47:25,000
然后呢

2706
01:47:25,000 --> 01:47:27,000
他就被 Windows 的这个操作系统记录下来

2707
01:47:27,000 --> 01:47:28,000
并且保存下来

2708
01:47:28,000 --> 01:47:31,000
那么他传到这个 OS X 上的时候

2709
01:47:31,000 --> 01:47:33,000
OS X 就觉得

2710
01:47:33,000 --> 01:47:34,000
诶这里其实是两个字符

2711
01:47:34,000 --> 01:47:36,000
那么我就把它们分开进行一个操作

2712
01:47:36,000 --> 01:47:37,000
比如说删除的时候

2713
01:47:37,000 --> 01:47:39,000
你能删除其中的一半

2714
01:47:39,000 --> 01:47:40,000
对吧

2715
01:47:40,000 --> 01:47:41,000
嗯

2716
01:47:41,000 --> 01:47:41,000
对

2717
01:47:41,000 --> 01:47:44,000
但是其实两个操作系统之间

2718
01:47:44,000 --> 01:47:46,000
这里反而体现了 Normalization 的一个

2719
01:47:46,000 --> 01:47:47,000
好处吧

2720
01:47:47,000 --> 01:47:50,000
就虽然他可能输入的这个字符串

2721
01:47:50,000 --> 01:47:52,000
行为是不一样的

2722
01:47:52,000 --> 01:47:54,000
但是至少我们在看的时候

2723
01:47:54,000 --> 01:47:55,000
看起来它们是一样的

2724
01:47:55,000 --> 01:47:57,000
并且我们搜索的时候也能搜索到它

2725
01:47:57,000 --> 01:48:00,000
就是我觉得这个时候反而是 Normalization

2726
01:48:00,000 --> 01:48:02,000
起到了一个保护的作用

2727
01:48:02,000 --> 01:48:05,000
就是它没有让整个文件名

2728
01:48:05,000 --> 01:48:06,000
变得不兼容了

2729
01:48:06,000 --> 01:48:09,000
而还起到了一定的这个最基本的兼容

2730
01:48:09,000 --> 01:48:10,000
嗯哼

2731
01:48:10,000 --> 01:48:10,000
对

2732
01:48:10,000 --> 01:48:12,000
所以 Normalization 是必要的

2733
01:48:12,000 --> 01:48:13,000
就是

2734
01:48:13,000 --> 01:48:14,000
诶

2735
01:48:14,000 --> 01:48:14,000
那我问

2736
01:48:14,000 --> 01:48:16,000
其实你们知道这个中国用户

2737
01:48:16,000 --> 01:48:18,000
怎么解决这个问题吗

2738
01:48:18,000 --> 01:48:22,000
中国用户其实遇到的不算太多吧

2739
01:48:22,000 --> 01:48:23,000
多吗

2740
01:48:23,000 --> 01:48:23,000
对啊

2741
01:48:23,000 --> 01:48:25,000
就为了为了

2742
01:48:25,000 --> 01:48:28,000
就要避免在那个文件里面使用中文嘛

2743
01:48:28,000 --> 01:48:30,000
那就用拼音的锁字母代替就好

2744
01:48:30,000 --> 01:48:31,000
啊

2745
01:48:31,000 --> 01:48:33,000
很多人这么干的吧

2746
01:48:33,000 --> 01:48:34,000
好吧

2747
01:48:34,000 --> 01:48:37,000
但其实这个完全是为了避免编码的问题吧

2748
01:48:37,000 --> 01:48:38,000
呃

2749
01:48:38,000 --> 01:48:41,000
这也为了就打字比较简单嘛

2750
01:48:41,000 --> 01:48:44,000
总比你找字相对来说方便一些吧

2751
01:48:44,000 --> 01:48:45,000
所以我不知道

2752
01:48:45,000 --> 01:48:46,000
这个 Eric

2753
01:48:46,000 --> 01:48:52,000
你可能比较熟悉点就是在日文用户里面会有很多人用日文去命名那个文件名码

2754
01:48:52,000 --> 01:48:53,000
对啊

2755
01:48:53,000 --> 01:48:53,000
那肯定啊

2756
01:48:53,000 --> 01:48:54,000
嗯

2757
01:48:54,000 --> 01:48:54,000
OK

2758
01:48:55,000 --> 01:48:57,000
我其实经常遇到一个问题

2759
01:48:57,000 --> 01:48:59,000
比如说我看一个英文的文档

2760
01:48:59,000 --> 01:49:02,000
然后这个文档可能是排版的比较精细的

2761
01:49:02,000 --> 01:49:05,000
它里面有一些单词就会出现盒子

2762
01:49:05,000 --> 01:49:06,000
对 FI 盒子收不到

2763
01:49:06,000 --> 01:49:07,000
对了

2764
01:49:07,000 --> 01:49:14,000
这个时候我用那个系统的自带的那个比如说呃三指双击可以取词查查字典嘛

2765
01:49:14,000 --> 01:49:16,000
这时候他查到那个字他就会识别不了

2766
01:49:16,000 --> 01:49:18,000
因为他里面带了一个盒子

2767
01:49:18,000 --> 01:49:23,000
我觉得这方面好像至少我现在用的这个 C 还还处理的不是很好

2768
01:49:23,000 --> 01:49:25,000
这 pdf 不会有这个问题吗

2769
01:49:25,000 --> 01:49:25,000
主要是对了

2770
01:49:25,000 --> 01:49:28,000
就 preview 这个 app 他在这方面的处理

2771
01:49:28,000 --> 01:49:29,000
我觉得还不是特别的完善

2772
01:49:29,000 --> 01:49:34,000
他其实理论上他应该是帮你做好这个那么拉的一声再去查字典

2773
01:49:34,000 --> 01:49:37,000
这里面跟那个 pdf 生成好像还有什么关系

2774
01:49:37,000 --> 01:49:40,000
这对我这个对这个这个比较复杂

2775
01:49:40,000 --> 01:49:40,000
这呃

2776
01:49:40,000 --> 01:49:43,000
我不完全是 preview 的错

2777
01:49:43,000 --> 01:49:45,000
对就是业务规范有一定关系

2778
01:49:45,000 --> 01:49:46,000
对

2779
01:49:46,000 --> 01:49:47,000
跟 pdf 有关系

2780
01:49:47,000 --> 01:49:49,000
而且是呃对没错是的

2781
01:49:49,000 --> 01:49:55,000
但其实如果他他用这个兼容方式的那么拉来学生他处理的特别好的话

2782
01:49:55,000 --> 01:49:56,000
他其实可以绕开这个问题

2783
01:49:58,000 --> 01:49:59,000
啊

2784
01:49:59,000 --> 01:50:01,000
他其实没有做这个兼容处理吗

2785
01:50:01,000 --> 01:50:03,000
他只是做了一个标准处理

2786
01:50:03,000 --> 01:50:06,000
可能但基本上如果你在网页上的话

2787
01:50:06,000 --> 01:50:07,000
他应该还是可以正确识别出来吧

2788
01:50:08,000 --> 01:50:09,000
不一定

2789
01:50:09,000 --> 01:50:10,000
我觉得还真不一定

2790
01:50:10,000 --> 01:50:11,000
还不一定啊

2791
01:50:11,000 --> 01:50:12,000
不一定不一定

2792
01:50:12,000 --> 01:50:15,000
因为网页上很多时候你看到了这个雷克车

2793
01:50:15,000 --> 01:50:15,000
可能

2794
01:50:15,000 --> 01:50:18,000
他并不是一个真正的 unicode 的那个车

2795
01:50:18,000 --> 01:50:22,000
他可能只是一个放出来显示出来的那个车

2796
01:50:22,000 --> 01:50:25,000
可能用户输的都是单独的字符

2797
01:50:25,000 --> 01:50:27,000
所以你不不太会遇到这个问题的

2798
01:50:27,000 --> 01:50:32,000
所以说这是你你看到东西其实有一个很多很多层面的东西

2799
01:50:32,000 --> 01:50:34,000
呃你看到是一个字

2800
01:50:34,000 --> 01:50:35,000
他可能是两个字

2801
01:50:35,000 --> 01:50:39,000
但是呃变成一个字的时候可能是系统把你做的

2802
01:50:39,000 --> 01:50:41,000
可能是 application 把你做

2803
01:50:41,000 --> 01:50:42,000
那也可能是 font 把你做的

2804
01:50:42,000 --> 01:50:44,000
就是就中间隔了好多道

2805
01:50:44,000 --> 01:50:45,000
对了对了

2806
01:50:45,000 --> 01:50:48,000
所以人类为什么要给自己找这么多麻烦

2807
01:50:48,000 --> 01:50:51,000
其实说实话

2808
01:50:51,000 --> 01:50:53,000
如果不 unicode 的话

2809
01:50:53,000 --> 01:50:54,000
就各个各个各自做个的

2810
01:50:54,000 --> 01:50:55,000
就就不会有这么多问题

2811
01:50:55,000 --> 01:50:58,000
但是就会有各种就好多好多套规则

2812
01:50:58,000 --> 01:50:58,000
哇

2813
01:50:58,000 --> 01:51:01,000
比较

2814
01:51:01,000 --> 01:51:03,000
所以 unicode 的对啊

2815
01:51:03,000 --> 01:51:05,000
就是这个大熔炉吗

2816
01:51:05,000 --> 01:51:06,000
就什么东西都有吗

2817
01:51:06,000 --> 01:51:10,000
然后就就会发生说以前不曾出现过的问题

2818
01:51:10,000 --> 01:51:10,000
知道吧

2819
01:51:10,000 --> 01:51:11,000
不对啊

2820
01:51:11,000 --> 01:51:13,000
其实你各个各的也会出现这个问题

2821
01:51:13,000 --> 01:51:15,000
你还是要考虑就是说比如说你搜索的时候

2822
01:51:15,000 --> 01:51:17,000
你要考虑说就兼容的问题吗

2823
01:51:17,000 --> 01:51:20,000
无非就是说有有各个应用程序自己去搞

2824
01:51:20,000 --> 01:51:23,000
还是说交给 unicode 这个组织来统一搞一套

2825
01:51:23,000 --> 01:51:25,000
大家都遵守这个标准来搞就好了

2826
01:51:25,000 --> 01:51:26,000
虽然很复杂

2827
01:51:26,000 --> 01:51:28,000
可能各有各的问题更多吧

2828
01:51:28,000 --> 01:51:31,000
可能搜都搜不到

2829
01:51:31,000 --> 01:51:36,000
对你一个汉字可能在这个 big 5 里和在 gb 里面完全是不一样的内码

2830
01:51:36,000 --> 01:51:37,000
这个搜都搜不到

2831
01:51:37,000 --> 01:51:38,000
嗯

2832
01:51:38,000 --> 01:51:39,000
嗯

2833
01:51:39,000 --> 01:51:42,000
但是还好人类在这这一个时机的话

2834
01:51:42,000 --> 01:51:44,000
又发现必须要做 unicode 的

2835
01:51:44,000 --> 01:51:46,000
然后现在大家走上了 unicode 的阳光大道了

2836
01:51:46,000 --> 01:51:49,000
才发现还要做很多很多的向后兼容

2837
01:51:49,000 --> 01:51:50,000
嗯

2838
01:51:50,000 --> 01:51:51,000
嗯

2839
01:51:51,000 --> 01:51:51,000
嗯

2840
01:51:51,000 --> 01:51:57,000
但非常不幸的是还有很多国内的网站还是用 gb 这个 2312 的

2841
01:51:57,000 --> 01:51:58,000
哎

2842
01:51:58,000 --> 01:51:59,000
台湾有很多

2843
01:52:00,000 --> 01:52:03,000
就在用 big 5 然后可能打开就会变成乱吧

2844
01:52:03,000 --> 01:52:05,000
对对对

2845
01:52:05,000 --> 01:52:09,000
声明又又很不正确的就是对吧

2846
01:52:09,000 --> 01:52:11,000
那个 htm 声明

2847
01:52:11,000 --> 01:52:11,000
对

2848
01:52:11,000 --> 01:52:14,000
我记得台湾教育部好像还有一个网站是用 big 5

2849
01:52:14,000 --> 01:52:16,000
然后他那个网页不知道是出什么问题

2850
01:52:16,000 --> 01:52:19,000
用 safari 打开资本都会是乱嘛

2851
01:52:19,000 --> 01:52:20,000
就默认就是乱的

2852
01:52:20,000 --> 01:52:21,000
对对

2853
01:52:21,000 --> 01:52:23,000
你要用手动去调

2854
01:52:23,000 --> 01:52:24,000
对对

2855
01:52:24,000 --> 01:52:29,000
浏览器的那个那个就启发式判断的方法都已经失效了

2856
01:52:29,000 --> 01:52:30,000
嗯

2857
01:52:30,000 --> 01:52:31,000
特别坑

2858
01:52:32,000 --> 01:52:32,000
好吧

2859
01:52:32,000 --> 01:52:34,000
今天差不多讲到这里了

2860
01:52:35,000 --> 01:52:38,000
我其实想经通过这样一个节目呢

2861
01:52:38,000 --> 01:52:40,000
就是告诉我们的听众朋友就说

2862
01:52:40,000 --> 01:52:40,000
平时大家说你不懂什么话呢

2863
01:52:40,000 --> 01:52:40,000
就是告诉我们的听众朋友就说平时大家说你不懂什么话呢

2864
01:52:40,000 --> 01:52:41,000
就是告诉我们的听众朋友就说平时大家说你不懂什么话呢

2865
01:52:41,000 --> 01:52:42,000
其实在 unicode 的啊

2866
01:52:42,000 --> 01:52:44,000
就感觉就是就是就编码嘛

2867
01:52:44,000 --> 01:52:44,000
对吧

2868
01:52:44,000 --> 01:52:45,000
就是就是马尾啊

2869
01:52:45,000 --> 01:52:46,000
什么什么这些东西

2870
01:52:46,000 --> 01:52:51,000
其实 unicode 除了就给字符编码的以外

2871
01:52:51,000 --> 01:52:54,000
它还有很多就是在 unicode 这个叫 standard annex

2872
01:52:54,000 --> 01:52:56,000
就是 annexes

2873
01:52:56,000 --> 01:52:58,000
就是它这个标准的附录

2874
01:52:58,000 --> 01:53:05,000
然后这附录里面其实有很多就是文文字处理方面的一些技术信息

2875
01:53:05,000 --> 01:53:08,000
比如说像今天我们说的这个 normalization

2876
01:53:08,000 --> 01:53:10,000
其实这是一个很复杂的一个技术环节的问题

2877
01:53:10,000 --> 01:53:11,000
其实这是一个很复杂的一个技术环节的问题

2878
01:53:11,000 --> 01:53:11,000
其实这是一个很复杂的一个技术环节的问题

2879
01:53:11,000 --> 01:53:15,000
这其实也是 unicode 标准的其中之一

2880
01:53:15,000 --> 01:53:18,000
是而且对作为 unicode 它是必要的

2881
01:53:18,000 --> 01:53:21,000
然后像比如说我们上上次在节目也提到

2882
01:53:21,000 --> 01:53:25,000
就比如这次 10.0 里面增加了一个就是 unicode 的标准附录

2883
01:53:25,000 --> 01:53:29,000
就是 unicode 的竖排文本啊

2884
01:53:29,000 --> 01:53:31,000
这这这其实也是必要的嘛

2885
01:53:31,000 --> 01:53:34,000
就说在横排和竖排之间是有什么样的关系

2886
01:53:34,000 --> 01:53:37,000
要给给它提升到这样一个标准附录里面

2887
01:53:37,000 --> 01:53:40,000
这话能给这个

2888
01:53:40,000 --> 01:53:42,000
它首先有个 core specification

2889
01:53:42,000 --> 01:53:46,000
就核心的这个标准的一个规范

2890
01:53:46,000 --> 01:53:48,000
然后呢还周边有这么多标准的附录

2891
01:53:48,000 --> 01:53:54,000
这样组合起来才是一个整体的 unicode 的这样一个

2892
01:53:54,000 --> 01:53:56,000
应该可以说是一个系统了对吧

2893
01:53:56,000 --> 01:54:02,000
那其实我们在自弹自串的这个专题里面

2894
01:54:02,000 --> 01:54:06,000
其实我们还可以再讲很多很多关于这样的事情

2895
01:54:06,000 --> 01:54:10,000
对那关于这个 normalization 的应用层面的问题

2896
01:54:10,000 --> 01:54:12,000
就是第一个我想问的问题是

2897
01:54:12,000 --> 01:54:15,000
作为一个软件的开发者来说

2898
01:54:15,000 --> 01:54:19,000
它多大程度上会遇到说我要去主动解决这个问题

2899
01:54:19,000 --> 01:54:23,000
Rio 你有没有遇到过要去解决这个问题

2900
01:54:23,000 --> 01:54:25,000
比较少其实

2901
01:54:25,000 --> 01:54:31,000
因为特别是特别操作系统和它的那个系统库都提供了这个标准的流程

2902
01:54:31,000 --> 01:54:33,000
给你去去调用的时候

2903
01:54:33,000 --> 01:54:34,000
你肯定不要自己去搞

2904
01:54:34,000 --> 01:54:37,000
因为这样你自己去搞的话有可能和系统的不兼容嘛

2905
01:54:37,000 --> 01:54:38,000
嗯

2906
01:54:38,000 --> 01:54:40,000
但是但是你就有刚才提到那个

2907
01:54:40,000 --> 01:54:40,000
嗯

2908
01:54:40,000 --> 01:54:41,000
难题嘛

2909
01:54:41,000 --> 01:54:45,000
就是说比如说在 macOS 这种比较特殊的系统上面

2910
01:54:45,000 --> 01:54:48,000
它有多套 API 的时候

2911
01:54:48,000 --> 01:54:49,000
你就很你就比较尴尬了

2912
01:54:49,000 --> 01:54:54,000
因为它有这种就是 unix 那套比较底层的 API

2913
01:54:54,000 --> 01:54:57,000
和相对上 foundation API 那些比较高层的 API 的时候

2914
01:54:57,000 --> 01:54:57,000
那你怎么办

2915
01:54:57,000 --> 01:55:01,000
就这个时候你可能要把这两个的就是哪些是支持

2916
01:55:01,000 --> 01:55:06,000
什么样的这个 normalization 的规范的

2917
01:55:06,000 --> 01:55:07,000
可能要搞清楚

2918
01:55:07,000 --> 01:55:09,000
然后具体说怎么实现

2919
01:55:09,000 --> 01:55:10,000
其实你是不用去太

2920
01:55:10,000 --> 01:55:11,000
多考虑的

2921
01:55:11,000 --> 01:55:14,000
反正那些都是有有标准函数去去调用的嘛

2922
01:55:14,000 --> 01:55:17,000
对对对这个规范化的转换转换算法

2923
01:55:17,000 --> 01:55:20,000
其实已经有一些非常标准的方式来实现

2924
01:55:20,000 --> 01:55:22,000
唯一作为开发者

2925
01:55:22,000 --> 01:55:23,000
你需要的知道的就是说

2926
01:55:23,000 --> 01:55:27,000
你知道在什么时候用什么样的 API 去调用

2927
01:55:27,000 --> 01:55:28,000
什么样的结果

2928
01:55:28,000 --> 01:55:29,000
嗯

2929
01:55:29,000 --> 01:55:30,000
这个是比较重要的

2930
01:55:31,000 --> 01:55:31,000
嗯

2931
01:55:31,000 --> 01:55:33,000
所以去查文档的话

2932
01:55:33,000 --> 01:55:34,000
其实他肯定也就是说

2933
01:55:34,000 --> 01:55:37,000
呃为了防防止发生这个 normalization 错误的话

2934
01:55:37,000 --> 01:55:40,000
就是去调用官方的 API

2935
01:55:40,000 --> 01:55:41,000
就完了

2936
01:55:41,000 --> 01:55:43,000
对这样对啊

2937
01:55:43,000 --> 01:55:45,000
另外还有个事情跟我们今天讲的有点关系

2938
01:55:45,000 --> 01:55:48,000
是 real 上次提到的那个 IDN 的一个

2939
01:55:48,000 --> 01:55:51,000
一个伪装攻击的问题是吗

2940
01:55:51,000 --> 01:55:54,000
就一个网址的一个漏洞

2941
01:55:54,000 --> 01:55:56,000
就 punicode 的那个的问题嘛

2942
01:55:56,000 --> 01:55:56,000
嗯

2943
01:55:56,000 --> 01:55:57,000
啊

2944
01:55:57,000 --> 01:56:00,000
这个是一个就也是 unicode 的一个坑吧

2945
01:56:00,000 --> 01:56:05,000
我们可以这里作为这个节目的就是事后的环节哈

2946
01:56:05,000 --> 01:56:07,000
所以随便顺顺便涂个小草

2947
01:56:07,000 --> 01:56:10,000
就是我们现在知道很多这个网站

2948
01:56:10,000 --> 01:56:11,000
他有种叫做什么

2949
01:56:11,000 --> 01:56:12,000
就钓鱼网站了

2950
01:56:12,000 --> 01:56:13,000
就他骗你

2951
01:56:13,000 --> 01:56:15,000
他说他是这个呃这个银行

2952
01:56:15,000 --> 01:56:17,000
某你的那个银行的网站

2953
01:56:17,000 --> 01:56:19,000
然后让你输入你的这个卡号密码

2954
01:56:19,000 --> 01:56:21,000
然后让你去转你的钱嘛

2955
01:56:21,000 --> 01:56:22,000
对吧

2956
01:56:22,000 --> 01:56:23,000
那但可能银行这个例子不太好

2957
01:56:23,000 --> 01:56:24,000
现在银行都有这个两步认证了

2958
01:56:24,000 --> 01:56:27,000
可能也不太那么容易去做

2959
01:56:27,000 --> 01:56:28,000
但是呃逻辑是这样的

2960
01:56:28,000 --> 01:56:35,000
就是那我们传统的在浏览器里面去判定一个网站是不是你访问的那个网站的时候

2961
01:56:35,000 --> 01:56:37,000
你是看他的那个域名吗

2962
01:56:37,000 --> 01:56:37,000
嗯对吧

2963
01:56:37,000 --> 01:56:41,000
域名其实就是一个字符串构成的东西吗

2964
01:56:41,000 --> 01:56:47,000
那坑就坑在于呃因为优内扣的里面也不叫这也不是用力扣的坑

2965
01:56:47,000 --> 01:56:50,000
就是这个人类的人类的问题吧

2966
01:56:50,000 --> 01:56:52,000
就是在某一些不同的语言里面

2967
01:56:52,000 --> 01:56:55,000
他的两个完全不同的字符

2968
01:56:55,000 --> 01:56:56,000
他看起来是一模一样的

2969
01:56:58,000 --> 01:56:59,000
嗯

2970
01:56:59,000 --> 01:57:02,000
比如说英文的第一个字母叫 a 对吧

2971
01:57:02,000 --> 01:57:04,000
但是希腊文的第一个字母叫 alpha

2972
01:57:04,000 --> 01:57:05,000
但是希腊文的第一个字母叫 alpha

2973
01:57:05,000 --> 01:57:07,000
就是两个大写字母长得一模一样

2974
01:57:07,000 --> 01:57:10,000
对在在过去不存在这个问题

2975
01:57:10,000 --> 01:57:11,000
因为在过去的话

2976
01:57:11,000 --> 01:57:14,000
那个域名系系统其实是一个非常简单的系统

2977
01:57:14,000 --> 01:57:15,000
他就只有 asky

2978
01:57:15,000 --> 01:57:17,000
就是他他只能用啊

2979
01:57:17,000 --> 01:57:21,000
就是就是我们讲域名那个部分只能用哪几个呃字符

2980
01:57:21,000 --> 01:57:24,000
26 个英文字母不区分大小写啊

2981
01:57:24,000 --> 01:57:26,000
10 个阿拉伯数字

2982
01:57:26,000 --> 01:57:28,000
然后再加一个那个很短横线

2983
01:57:28,000 --> 01:57:29,000
对吧

2984
01:57:29,000 --> 01:57:29,000
嗯嗯嗯

2985
01:57:29,000 --> 01:57:31,000
然后在这个这个点呢

2986
01:57:31,000 --> 01:57:32,000
肯定没得说了

2987
01:57:32,000 --> 01:57:33,000
就是 a 就是 a 点

2988
01:57:33,000 --> 01:57:34,000
b 这个是可以知道的

2989
01:57:34,000 --> 01:57:37,000
然后后来呢

2990
01:57:37,000 --> 01:57:40,000
为了支持所谓的多语言的这个域名嘛

2991
01:57:40,000 --> 01:57:41,000
啊

2992
01:57:41,000 --> 01:57:43,000
我们中国之前搞过啊

2993
01:57:43,000 --> 01:57:44,000
cns 搞过所谓的中文域名

2994
01:57:44,000 --> 01:57:45,000
对不对

2995
01:57:45,000 --> 01:57:47,000
就是汉字域名

2996
01:57:47,000 --> 01:57:49,000
对汉字域名什么什么点中国很傻的

2997
01:57:49,000 --> 01:57:53,000
之前应该是 90 年代末的时候流行过

2998
01:57:53,000 --> 01:57:54,000
然后之后

2999
01:57:54,000 --> 01:57:56,000
就是谢天谢地终于没有流行起来

3000
01:57:56,000 --> 01:57:58,000
对吧

3001
01:57:58,000 --> 01:57:58,000
啊

3002
01:57:58,000 --> 01:58:01,000
然后刚才讲的那个希腊文的那个 a 和英文的那个 a 就问题

3003
01:58:01,000 --> 01:58:03,000
比如说你都想访问 apple.com

3004
01:58:03,000 --> 01:58:04,000
就苹果的官网

3005
01:58:04,000 --> 01:58:05,000
对吧

3006
01:58:05,000 --> 01:58:06,000
那你看的是 apple.com

3007
01:58:06,000 --> 01:58:10,000
但其实人家把那个 a 给换成的那个希腊语的那个 a

3008
01:58:10,000 --> 01:58:11,000
然后你看起来也是 apple.com

3009
01:58:11,000 --> 01:58:13,000
但是你是访问的是一个完全不同的网站

3010
01:58:13,000 --> 01:58:14,000
这个时候

3011
01:58:14,000 --> 01:58:15,000
呃

3012
01:58:15,000 --> 01:58:21,000
这个这个假的这个 apple.com 这个网站让你输入你的这个 iCloud 的这个账号密码

3013
01:58:21,000 --> 01:58:21,000
你输不输呢

3014
01:58:21,000 --> 01:58:25,000
对吧

3015
01:58:25,000 --> 01:58:29,000
所以我觉得就是在域名这个呃

3016
01:58:29,000 --> 01:58:33,000
这个比较关乎安全的这种领域里面

3017
01:58:33,000 --> 01:58:33,000
呃

3018
01:58:33,000 --> 01:58:33,000
呃

3019
01:58:33,000 --> 01:58:33,000
呃

3020
01:58:33,000 --> 01:58:33,000
呃

3021
01:58:33,000 --> 01:58:33,000
呃

3022
01:58:33,000 --> 01:58:33,000
呃

3023
01:58:33,000 --> 01:58:33,000
呃

3024
01:58:33,000 --> 01:58:33,000
呃

3025
01:58:33,000 --> 01:58:37,000
其实挺反对去加入这种多语言支持的

3026
01:58:37,000 --> 01:58:38,000
虽然说听起来政治不正确

3027
01:58:38,000 --> 01:58:41,000
凭什么域名一定要是一个英文的一个东西

3028
01:58:41,000 --> 01:58:42,000
或者说就是对吧

3029
01:58:42,000 --> 01:58:43,000
或者说

3030
01:58:43,000 --> 01:58:44,000
呃

3031
01:58:44,000 --> 01:58:46,000
其实也就拉低文的东西嘛

3032
01:58:46,000 --> 01:58:48,000
为什么韩国人不能用韩语做域名

3033
01:58:48,000 --> 01:58:50,000
中国人不能用中国人做域名

3034
01:58:50,000 --> 01:58:51,000
日本人不能用日语做域名呢

3035
01:58:51,000 --> 01:58:56,000
但是你用了之后就会出现这种不可知的结果吧

3036
01:58:56,000 --> 01:58:57,000
这个时候就比较尴尬了

3037
01:58:57,000 --> 01:59:02,000
另外我还有个问题

3038
01:59:02,000 --> 01:59:03,000
其实就是呃

3039
01:59:03,000 --> 01:59:04,000
如果我们输入两个

3040
01:59:04,000 --> 01:59:06,000
两个在这个

3041
01:59:06,000 --> 01:59:10,000
标准化之后是相等的

3042
01:59:10,000 --> 01:59:11,000
unicode 字符串

3043
01:59:11,000 --> 01:59:12,000
那么浏览器会认为

3044
01:59:12,000 --> 01:59:13,000
他们是同一个域名吗

3045
01:59:13,000 --> 01:59:17,000
但是他们实际上是不一样的

3046
01:59:17,000 --> 01:59:21,000
这里面好像那个域名有一个

3047
01:59:21,000 --> 01:59:21,000
那个 punicode

3048
01:59:21,000 --> 01:59:22,000
它是有一个规范的

3049
01:59:22,000 --> 01:59:25,000
但是这里要扯一个很很很坑爹的事情

3050
01:59:25,000 --> 01:59:28,000
punicode 的规范是早于 unicode 的

3051
01:59:28,000 --> 01:59:30,000
是的

3052
01:59:30,000 --> 01:59:33,000
这会有一个转换的问题

3053
01:59:33,000 --> 01:59:34,000
对

3054
01:59:34,000 --> 01:59:35,000
所以比如说我们刚才

3055
01:59:35,000 --> 01:59:36,000
我们刚才说

3056
01:59:36,000 --> 01:59:37,000
比如说有一些字母

3057
01:59:37,000 --> 01:59:38,000
比如说像 Omega

3058
01:59:38,000 --> 01:59:40,000
它就是两个完全一模一样的字符

3059
01:59:40,000 --> 01:59:42,000
在形式上

3060
01:59:42,000 --> 01:59:44,000
在这个语义的来源上也是一样

3061
01:59:44,000 --> 01:59:47,000
但它就是分裂成两个字符了

3062
01:59:47,000 --> 01:59:49,000
一个是用来表示这个物理单位的

3063
01:59:49,000 --> 01:59:50,000
一个是 Omega 这个字符本身

3064
01:59:50,000 --> 01:59:52,000
对

3065
01:59:52,000 --> 01:59:53,000
这个我没有去查过

3066
01:59:53,000 --> 01:59:55,000
但是照我的理解

3067
01:59:55,000 --> 01:59:58,000
应该是要先做那个 unicode 的规范化

3068
01:59:58,000 --> 01:59:59,000
然后再转成那个 punicode

3069
01:59:59,000 --> 02:00:02,000
才能拿到一个最终的一个结果

3070
02:00:02,000 --> 02:00:03,000
这个

3071
02:00:03,000 --> 02:00:05,000
这个时候应该是是一个唯一的一个一个

3072
02:00:05,000 --> 02:00:07,000
所以他们其实应该是一样的

3073
02:00:07,000 --> 02:00:08,000
是吧

3074
02:00:08,000 --> 02:00:09,000
我的理解应该是一样

3075
02:00:09,000 --> 02:00:11,000
不然的话就会出现刚才我说的另外一个问题

3076
02:00:11,000 --> 02:00:15,000
就是你看见的两个完全一模一样的

3077
02:00:15,000 --> 02:00:17,000
而且你用 unicode 的看都是一模一样的

3078
02:00:17,000 --> 02:00:19,000
或者 unicode 都是等价的两个域名

3079
02:00:19,000 --> 02:00:20,000
但是它其实反而两个不同的网站

3080
02:00:20,000 --> 02:00:22,000
这个时候你就你就非常坑爹了

3081
02:00:22,000 --> 02:00:23,000
对不对

3082
02:00:23,000 --> 02:00:25,000
嗯

3083
02:00:25,000 --> 02:00:26,000
当然了

3084
02:00:26,000 --> 02:00:30,000
这个事情可能可能也会越来越不是一个事了吧

3085
02:00:30,000 --> 02:00:33,000
就是其实我们现在看很多这个移动网站上

3086
02:00:33,000 --> 02:00:34,000
你根本就不知道那个网址是什么了

3087
02:00:34,000 --> 02:00:34,000
对不对

3088
02:00:34,000 --> 02:00:37,000
比如说你在这个微信的浏览器里面打开一个网站

3089
02:00:37,000 --> 02:00:40,000
你都看不见那个那个 url 了

3090
02:00:40,000 --> 02:00:41,000
对

3091
02:00:41,000 --> 02:00:44,000
所以最终你可能还是得靠一些证书之类的东西

3092
02:00:44,000 --> 02:00:47,000
就其他的一些工具来验证这个网站是不是你想要

3093
02:00:47,000 --> 02:00:48,000
对啊

3094
02:00:48,000 --> 02:00:48,000
对啊

3095
02:00:48,000 --> 02:00:49,000
对啊

3096
02:00:49,000 --> 02:00:50,000
对啊

3097
02:00:50,000 --> 02:00:51,000
但你会

3098
02:00:51,000 --> 02:00:54,000
你任一个人总是不能看名字呀

3099
02:00:54,000 --> 02:00:57,000
这也就会变得另外一个很好

3100
02:00:57,000 --> 02:00:58,000
很好玩的事情

3101
02:00:58,000 --> 02:01:00,000
这个跟 emoji 有关了哈

3102
02:01:00,000 --> 02:01:03,000
就是之前前几天在那个推特上转发了一条文章

3103
02:01:03,000 --> 02:01:05,000
这个事情就是现在那个浏览器

3104
02:01:05,000 --> 02:01:09,000
它不是前面靠那个地址的左边有一个那个小锁了

3105
02:01:09,000 --> 02:01:11,000
那个图标来表示这是一个加密链接吗

3106
02:01:11,000 --> 02:01:12,000
嗯

3107
02:01:12,000 --> 02:01:13,000
对啊

3108
02:01:13,000 --> 02:01:15,000
然后觉得你常常觉得很安全吗

3109
02:01:15,000 --> 02:01:18,000
然后你知道那个 emoji 里面是有一个锁的图标的吗

3110
02:01:18,000 --> 02:01:19,000
啊

3111
02:01:19,000 --> 02:01:20,000
嗯

3112
02:01:20,000 --> 02:01:27,000
然后然后然后那个有些那个有些那个域名的那个有些顶级域名是支持 emoji 域名的

3113
02:01:27,000 --> 02:01:28,000
就刚刚我们讲 unicode

3114
02:01:28,000 --> 02:01:30,000
punicode 的域名之外

3115
02:01:30,000 --> 02:01:31,000
它还支持 emoji 的域名

3116
02:01:31,000 --> 02:01:33,000
这个时候有人就说

3117
02:01:33,000 --> 02:01:34,000
他自己画了一个

3118
02:01:34,000 --> 02:01:37,000
他做了一个他的那个域名的第一个就是一个锁啊

3119
02:01:37,000 --> 02:01:37,000
你知道吗

3120
02:01:37,000 --> 02:01:40,000
然后后面假设假设它是一个锁

3121
02:01:40,000 --> 02:01:44,000
然后然后然后 https 然后再两点写杠写杠

3122
02:01:44,000 --> 02:01:47,000
然后是那个希腊字母的 a

3123
02:01:47,000 --> 02:01:49,000
那个 appl.com

3124
02:01:49,000 --> 02:01:52,000
这个时候你你你敢不敢访问这个网站

3125
02:01:53,000 --> 02:01:54,000
哈哈哈

3126
02:01:54,000 --> 02:01:55,000
对吧

3127
02:01:55,000 --> 02:02:01,000
所以所以我觉得就是就是这怎么这可能有点不太正确啊

3128
02:02:01,000 --> 02:02:03,000
但是我觉得这个事情是是

3129
02:02:03,000 --> 02:02:06,000
是有有得有的有所有些事情你是不能做的

3130
02:02:06,000 --> 02:02:09,000
这样我就你不能在域名里面去加以 moji

3131
02:02:09,000 --> 02:02:11,000
你不能在域里面去加这个 unicode 的东西

3132
02:02:11,000 --> 02:02:14,000
这真的会把事情搞得无比复杂

3133
02:02:14,000 --> 02:02:17,000
就是本来大家只用考虑大概讲啊

3134
02:02:17,000 --> 02:02:20,000
26 个字母加 10 个数字再加一个横线

3135
02:02:20,000 --> 02:02:23,000
钱才多少才 37 个对吧

3136
02:02:23,000 --> 02:02:26,000
的一个一个这个一个这个 space 的一个问题

3137
02:02:26,000 --> 02:02:29,000
现在突然你变成一个整个 unicode 的那个 space 都在那里

3138
02:02:29,000 --> 02:02:32,000
那是多少倍的一个复杂度的扩张

3139
02:02:32,000 --> 02:02:34,000
对于用户的认知理解来说

3140
02:02:34,000 --> 02:02:35,000
你是没有办法去做这个教育的

3141
02:02:36,000 --> 02:02:38,000
嗯嗯

3142
02:02:38,000 --> 02:02:41,000
所以你看中国用户大家还是比较乖的

3143
02:02:41,000 --> 02:02:43,000
大家干脆都用数字语名就不会穿这种情况了

3144
02:02:43,000 --> 02:02:44,000
对吧

3145
02:02:44,000 --> 02:02:46,000
嗯嗯嗯

3146
02:02:46,000 --> 02:02:46,000
163 点

3147
02:02:46,000 --> 02:02:50,000
看数字应该不会有这个长得一样的数字

3148
02:02:50,000 --> 02:02:51,000
但是不一样的点位吧

3149
02:02:54,000 --> 02:02:55,000
有也有吗

3150
02:02:57,000 --> 02:02:59,000
数字的 nomenization 不是很多吗

3151
02:03:00,000 --> 02:03:00,000
天呐

3152
02:03:01,000 --> 02:03:02,000
啊对

3153
02:03:02,000 --> 02:03:02,000
有那个什么

3154
02:03:02,000 --> 02:03:04,000
蛋糕的这种数字对不对

3155
02:03:04,000 --> 02:03:07,000
还有那个叫什么来的那个啊

3156
02:03:07,000 --> 02:03:10,000
另外罗马数那是罗马数字吗

3157
02:03:10,000 --> 02:03:14,000
就是罗马数字也是有罗马数字自己的马也可以对

3158
02:03:14,000 --> 02:03:18,000
但我们一般都是用拉丁字母来写他们就用什么 iv 啊之类的字

3159
02:03:18,000 --> 02:03:19,000
所以我就觉得嘛

3160
02:03:19,000 --> 02:03:25,000
就是有些事情其实是都是一些政治的因素让我们把这个事情变得非常复杂

3161
02:03:25,000 --> 02:03:28,000
本来技术是可以做的非常简单可靠稳定的

3162
02:03:28,000 --> 02:03:32,000
但是一会儿过来一个 pm 那会儿过来一个 pm 都在提这个需求

3163
02:03:32,000 --> 02:03:35,000
这个时候你就爆炸了

3164
02:03:35,000 --> 02:03:37,000
对其实说到这个 url

3165
02:03:37,000 --> 02:03:42,000
我想想就是其实 w 3 c 也是有一套自己的这个 nomenization 的机制的

3166
02:03:44,000 --> 02:03:44,000
天呐

3167
02:03:45,000 --> 02:03:54,000
对就是当然它其实是基于 unicode 的就是它当然它首先推荐的是 nfc 的这种标准化的形式规范化的形式

3168
02:03:54,000 --> 02:04:01,000
那么同时我们知道因为 w 3 c 在网页上它其实有一个特殊的字符串形式叫 character reference

3169
02:04:01,000 --> 02:04:05,000
就是以一个这个 absent 和仅号键开头的

3170
02:04:05,000 --> 02:04:07,000
然后后面加一个数字的试列

3171
02:04:07,000 --> 02:04:15,000
然后加一个加一个分号这样一个可以用来引用引用到任何一个 unicode 的字符上的这样一个试列

3172
02:04:15,000 --> 02:04:19,000
那么这个试列如果你在网页上在 html 里面输入的话

3173
02:04:19,000 --> 02:04:25,000
它其实要被这个 nomenalize 成为另外一个真正的实意的字符的

3174
02:04:25,000 --> 02:04:27,000
而不是直接保留这个东西

3175
02:04:27,000 --> 02:04:28,000
ok

3176
02:04:28,000 --> 02:04:33,000
那么这个就就其实是在 unicode 的基础上扩展了一下

3177
02:04:33,000 --> 02:04:35,000
应该说不就是那个 punicode 的吗

3178
02:04:38,000 --> 02:04:39,000
可以这么说吧

3179
02:04:39,000 --> 02:04:41,000
可以就机制是类似的

3180
02:04:41,000 --> 02:04:43,000
可能是但他们的表达形式不太一样

3181
02:04:47,000 --> 02:04:49,000
这是一个挺沉重的事情

3182
02:04:49,000 --> 02:04:52,000
我觉得就反正我在我的那个理解里面我是不介意

3183
02:04:52,000 --> 02:04:55,000
就是我是反对吧

3184
02:04:55,000 --> 02:04:58,000
把一些就是其实你说一定有那么强的必要

3185
02:04:58,000 --> 02:05:00,000
要用一个中文或者日文的语言吗

3186
02:05:00,000 --> 02:05:01,000
其实也没有对不对

3187
02:05:01,000 --> 02:05:02,000
大家不也过得很好吗

3188
02:05:02,000 --> 02:05:05,000
就为什么要认为把这个事情搞那么复杂

3189
02:05:05,000 --> 02:05:12,000
就是太多的 downside 没有很好的这个 upside

3190
02:05:12,000 --> 02:05:16,000
但是对于这个网页来说

3191
02:05:16,000 --> 02:05:17,000
其实它有这些需求

3192
02:05:17,000 --> 02:05:20,000
比如你输入一些不可见字符的时候

3193
02:05:20,000 --> 02:05:21,000
你在 html 里面

3194
02:05:21,000 --> 02:05:25,000
你可能输入这个 character reference 就变成可见了

3195
02:05:25,000 --> 02:05:26,000
那么对于程序员来说

3196
02:05:26,000 --> 02:05:28,000
这个是比较友好的一种形式

3197
02:05:28,000 --> 02:05:34,000
不就是说你不要在网页里面做这个不要在那个那个域名和网址里面做这个事情吗

3198
02:05:34,000 --> 02:05:36,000
对对对在域名里面做的话

3199
02:05:36,000 --> 02:05:38,000
就是要得有所节制

3200
02:05:38,000 --> 02:05:38,000
你知道吗

3201
02:05:38,000 --> 02:05:42,000
就是现在很多很多这个忍不住啊

3202
02:05:42,000 --> 02:05:44,000
对技术技术产品之所以如此复杂

3203
02:05:44,000 --> 02:05:48,000
就是因为上面提产提需求的人就是你就是对吧

3204
02:05:50,000 --> 02:05:51,000
不考虑后果

3205
02:05:54,000 --> 02:05:55,000
好吧

3206
02:05:55,000 --> 02:05:58,000
今天我们就聊到这里对

3207
02:05:58,000 --> 02:06:03,000
对了

3208
02:06:03,000 --> 02:06:05,000
我们这次要抽

3209
02:06:05,000 --> 02:06:07,000
我们这次就不抽奖了是吧

3210
02:06:07,000 --> 02:06:08,000
对对对

3211
02:06:08,000 --> 02:06:11,000
但是我们其实上一次抽奖的结果已经出来了

3212
02:06:11,000 --> 02:06:13,000
但是有一位听众联系不到

3213
02:06:13,000 --> 02:06:19,000
所以其实那个我们可以借这次节目先做一个这个通知吧

3214
02:06:19,000 --> 02:06:20,000
那你说吧

3215
02:06:20,000 --> 02:06:23,000
对就是之前的那个我们在第第十

3216
02:06:23,000 --> 02:06:25,000
就上期应该是第五十一期吧

3217
02:06:25,000 --> 02:06:27,000
我们公布了一个抽奖的通知

3218
02:06:27,000 --> 02:06:28,000
然后呢

3219
02:06:28,000 --> 02:06:28,000
然后呢

3220
02:06:28,000 --> 02:06:28,000
然后呢

3221
02:06:28,000 --> 02:06:28,000
然后呢

3222
02:06:28,000 --> 02:06:28,000
然后呢

3223
02:06:28,000 --> 02:06:28,000
然后呢

3224
02:06:28,000 --> 02:06:28,000
然后呢

3225
02:06:28,000 --> 02:06:28,000
然后呢

3226
02:06:28,000 --> 02:06:30,000
接下来的一周之后呢

3227
02:06:30,000 --> 02:06:32,000
我们这个抽奖的结果其实已经出来了

3228
02:06:32,000 --> 02:06:34,000
那么我们这次抽到的两位听众呢

3229
02:06:34,000 --> 02:06:36,000
都是来自支付宝捐赠的听众

3230
02:06:36,000 --> 02:06:38,000
第一位听众他的署名是灰

3231
02:06:38,000 --> 02:06:40,000
一个辉煌的灰这个单字

3232
02:06:40,000 --> 02:06:42,000
第二位听众署名是 Friend

3233
02:06:42,000 --> 02:06:44,000
那第二位听众呢

3234
02:06:44,000 --> 02:06:45,000
我已经联系上他了

3235
02:06:45,000 --> 02:06:46,000
那么他应该也已经收到了我们的奖品

3236
02:06:46,000 --> 02:06:49,000
但是第一位听众我没法联系到他

3237
02:06:49,000 --> 02:06:50,000
所以如果你听到这期节目呢

3238
02:06:50,000 --> 02:06:52,000
也可以直接给我们发邮件

3239
02:06:52,000 --> 02:06:54,000
发到 podcastatthetype.com

3240
02:06:54,000 --> 02:06:55,000
来跟我们联络

3241
02:06:55,000 --> 02:06:57,000
然后我们会跟你进一步沟通

3242
02:06:57,000 --> 02:06:58,000
然后把奖品发到我们的购物中

3243
02:06:58,000 --> 02:06:59,000
发给你

3244
02:06:59,000 --> 02:07:02,000
好

3245
02:07:02,000 --> 02:07:03,000
感谢大家的捐赠

3246
02:07:03,000 --> 02:07:04,000
那别忘记了

3247
02:07:04,000 --> 02:07:05,000
和我们的联系的方法呢

3248
02:07:05,000 --> 02:07:08,000
是 podcastatthetype.com

3249
02:07:08,000 --> 02:07:11,000
有捐赠也就有机会参加我们的抽奖

3250
02:07:11,000 --> 02:07:12,000
我也今天

3251
02:07:12,000 --> 02:07:15,000
我给大家准备了新的礼物

3252
02:07:15,000 --> 02:07:16,000
那等我们下次再说吧

3253
02:07:16,000 --> 02:07:17,000
好吧

3254
02:07:17,000 --> 02:07:18,000
好

3255
02:07:18,000 --> 02:07:20,000
那感谢大家收听今天的节目

3256
02:07:20,000 --> 02:07:23,000
如果大家喜欢我们的节目的话

3257
02:07:23,000 --> 02:07:24,000
喜欢自弹自唱的话

3258
02:07:24,000 --> 02:07:25,000
就可以给我们捐赠

3259
02:07:25,000 --> 02:07:26,000
我们的捐赠渠道呢

3260
02:07:26,000 --> 02:07:28,000
跟我们的邮箱地址是一样的

3261
02:07:28,000 --> 02:07:28,000
都是

3262
02:07:28,000 --> 02:07:30,000
podcastatthetype.com

3263
02:07:30,000 --> 02:07:35,000
podcastatthetype.com

3264
02:07:35,000 --> 02:07:35,000
同时呢

3265
02:07:35,000 --> 02:07:37,000
大家也可以在社交网站上

3266
02:07:37,000 --> 02:07:38,000
关注我们

3267
02:07:38,000 --> 02:07:39,000
在新浪微博

3268
02:07:39,000 --> 02:07:40,000
在推特

3269
02:07:40,000 --> 02:07:42,000
在微信上面

3270
02:07:42,000 --> 02:07:44,000
我们的 ID 都是 thetype

3271
02:07:44,000 --> 02:07:48,000
那么在 Facebook 上搜索

3272
02:07:48,000 --> 02:07:49,000
typeisbeautiful

3273
02:07:49,000 --> 02:07:50,000
也可以关注到我们

3274
02:07:50,000 --> 02:07:50,000
同时呢

3275
02:07:50,000 --> 02:07:51,000
我们在知乎专栏上

3276
02:07:51,000 --> 02:07:53,000
也会同步的发布

3277
02:07:53,000 --> 02:07:56,000
每一次节目的这个节目简介

3278
02:07:56,000 --> 02:07:57,000
同时呢

3279
02:07:57,000 --> 02:07:58,000
也欢迎大家关注

3280
02:07:58,000 --> 02:07:58,000
我们的频道

3281
02:07:58,000 --> 02:08:00,000
typeisbeautiful 的网站

3282
02:08:00,000 --> 02:08:01,000
typeisbeautiful.com

3283
02:08:01,000 --> 02:08:05,000
感谢收听 IPN Podcast

3284
02:08:05,000 --> 02:08:08,000
网络旗下的 IT 技术主题娱乐节目

3285
02:08:08,000 --> 02:08:08,000
内核恐慌

3286
02:08:08,000 --> 02:08:10,000
我们号称 hardcore

3287
02:08:10,000 --> 02:08:10,000
但是也没有干货

3288
02:08:10,000 --> 02:08:11,000
想听人听

3289
02:08:11,000 --> 02:08:12,000
想听人就别听

3290
02:08:12,000 --> 02:08:14,000
您可以为本节目捐款

3291
02:08:14,000 --> 02:08:15,000
地址是

3292
02:08:15,000 --> 02:08:16,000
coronapanic.fm

3293
02:08:16,000 --> 02:08:17,000
slash donate

3294
02:08:17,000 --> 02:08:18,000
捐款金额随意

3295
02:08:18,000 --> 02:08:19,000
只要是 8 的正式入备就可以了

3296
02:08:19,000 --> 02:08:21,000
捐款不会给你带来什么

3297
02:08:21,000 --> 02:08:23,000
不捐也不会让你失去什么

3298
02:08:23,000 --> 02:08:23,000
我们的口号是

3299
02:08:23,000 --> 02:08:25,000
no hard feelings

3300
02:08:25,000 --> 02:08:26,000
如果你有任何反馈

3301
02:08:26,000 --> 02:08:27,000
也可以发邮件到

3302
02:08:27,000 --> 02:08:28,000
coronapanic.fm

3303
02:08:28,000 --> 02:08:29,000
可以发电子邮件到

3304
02:08:29,000 --> 02:08:31,000
coronapanic.fm

3305
02:08:31,000 --> 02:08:34,000
同时也欢迎你收听

3306
02:08:34,000 --> 02:08:35,000
Rio 主持的凤头圈

3307
02:08:35,000 --> 02:08:37,000
凤头圈现在好像改成收费节目

3308
02:08:37,000 --> 02:08:39,000
对

3309
02:08:39,000 --> 02:08:40,000
OK

3310
02:08:40,000 --> 02:08:41,000
我还加了会员

3311
02:08:41,000 --> 02:08:43,000
其他的其他几档节目

3312
02:08:43,000 --> 02:08:45,000
未知到太一来了

3313
02:08:45,000 --> 02:08:45,000
流行通信

3314
02:08:45,000 --> 02:08:46,000
high story

3315
02:08:46,000 --> 02:08:47,000
印影像

3316
02:08:47,000 --> 02:08:47,000
无资源

3317
02:08:47,000 --> 02:08:48,000
博物志

3318
02:08:48,000 --> 02:08:48,000
选美

3319
02:08:48,000 --> 02:08:49,000
陛下观

3320
02:08:49,000 --> 02:08:49,000
一天世界

3321
02:08:49,000 --> 02:08:50,000
时尚怪物

3322
02:08:50,000 --> 02:08:51,000
我们下期节目再会

3323
02:08:51,000 --> 02:08:52,000
OK

3324
02:08:52,000 --> 02:08:52,000
拜拜

3325
02:08:52,000 --> 02:08:53,000
拜拜

3326
02:08:53,000 --> 02:08:54,000
拜拜

3327
02:08:54,000 --> 02:08:54,000
拜拜

3328
02:08:58,000 --> 02:08:59,000
拜拜

