1
00:00:00,000 --> 00:00:02,000
大家好 欢迎收听第十七的内核恐慌

2
00:00:02,000 --> 00:00:03,000
我是 Rio

3
00:00:03,000 --> 00:00:04,000
我是吴涛

4
00:00:04,000 --> 00:00:07,000
今天我们请到了一位嘉宾

5
00:00:07,000 --> 00:00:09,000
他叫 Willow

6
00:00:09,000 --> 00:00:10,000
我来跟大家打招呼吧

7
00:00:10,000 --> 00:00:12,000
大家好 我是 Willow

8
00:00:12,000 --> 00:00:17,000
又可以跟 Rio 和吴涛插科打混

9
00:00:17,000 --> 00:00:17,000
非常开心

10
00:00:17,000 --> 00:00:20,000
为什么要说 Yo 呢

11
00:00:20,000 --> 00:00:24,000
就是如果大家听过我主持的另外一档节目

12
00:00:24,000 --> 00:00:25,000
IT 公论的话就知道

13
00:00:25,000 --> 00:00:27,000
Willow 已经在那边做过两三次的嘉宾了

14
00:00:27,000 --> 00:00:29,000
可是我好像没有

15
00:00:29,000 --> 00:00:31,000
和 Willow 直接上过

16
00:00:31,000 --> 00:00:33,000
对

17
00:00:33,000 --> 00:00:35,000
对 我们没有上过

18
00:00:35,000 --> 00:00:37,000
你们没有上过

19
00:00:37,000 --> 00:00:40,000
不要一开始就没了

20
00:00:40,000 --> 00:00:42,000
不过其实这是我们

21
00:00:42,000 --> 00:00:44,000
就是内核恐慌这期节目

22
00:00:44,000 --> 00:00:45,000
第一次邀请嘉宾吧

23
00:00:45,000 --> 00:00:45,000
对

24
00:00:45,000 --> 00:00:48,000
之前曾经邀请过一位嘉宾

25
00:00:48,000 --> 00:00:49,000
后来被 IT 公论抢走了

26
00:00:49,000 --> 00:00:51,000
没错 就是王超年

27
00:00:51,000 --> 00:00:54,000
所以 Willow 也是我们的处女嘉宾

28
00:00:54,000 --> 00:00:55,000
非常荣幸

29
00:00:55,000 --> 00:00:55,000
非常

30
00:00:55,000 --> 00:00:56,000
不知道

31
00:00:56,000 --> 00:00:58,000
I don't know about the 处女

32
00:00:58,000 --> 00:00:59,000
但是

33
00:00:59,000 --> 00:01:03,000
今天请 Willow 来呢

34
00:01:03,000 --> 00:01:07,000
是要聊一件跟前端开发有关的事情

35
00:01:07,000 --> 00:01:08,000
因为刚好 Willow 最近

36
00:01:08,000 --> 00:01:10,000
应该是前天吧

37
00:01:10,000 --> 00:01:11,000
前天和上前天对吧

38
00:01:11,000 --> 00:01:12,000
上个先天

39
00:01:12,000 --> 00:01:13,000
28 号 29 号

40
00:01:13,000 --> 00:01:13,000
应该是

41
00:01:13,000 --> 00:01:14,000
对对

42
00:01:14,000 --> 00:01:17,000
然后去参加了这个 Facebook 搞的

43
00:01:17,000 --> 00:01:18,000
现在已经不算 Facebook

44
00:01:18,000 --> 00:01:19,000
他们已经独立出来了吗

45
00:01:19,000 --> 00:01:20,000
还是怎么样

46
00:01:20,000 --> 00:01:20,000
还是 Facebook

47
00:01:20,000 --> 00:01:22,000
还是 Facebook

48
00:01:22,000 --> 00:01:22,000
OK

49
00:01:22,000 --> 00:01:26,000
就是 Facebook 他们有一个开发者的小型的一个会议吧

50
00:01:26,000 --> 00:01:28,000
是讲一个叫做 React

51
00:01:28,000 --> 00:01:30,000
这么一个这个前端开发的技术

52
00:01:30,000 --> 00:01:33,000
然后刚好 Willow 去了现场参加了两天的会议呢

53
00:01:33,000 --> 00:01:35,000
然后我们就趁着打铁

54
00:01:35,000 --> 00:01:38,000
邀请他来跟我们分享一下他所见所闻吧

55
00:01:38,000 --> 00:01:38,000
对

56
00:01:38,000 --> 00:01:41,000
其实 Willow 你是为什么可以去参加

57
00:01:41,000 --> 00:01:45,000
或者说你是出于什么样的动机去参加 React.js 的 conference 呢

58
00:01:45,000 --> 00:01:46,000
嗯

59
00:01:46,000 --> 00:01:50,000
如果你看前端开发的发展的话

60
00:01:50,000 --> 00:01:54,000
你会发现去年和前年是非常激动的两年

61
00:01:54,000 --> 00:02:00,000
因为我们最开始大家写 PUJavaScript

62
00:02:00,000 --> 00:02:02,000
然后后来又写 JQuery

63
00:02:02,000 --> 00:02:07,000
然后再到 Backbone 引进了比较具体的 structure

64
00:02:07,000 --> 00:02:11,000
前端的开发好像到那里就有一点停滞

65
00:02:11,000 --> 00:02:14,000
但是在这个时候呢出现了 Angular

66
00:02:14,000 --> 00:02:16,000
然后去年又出现了 React

67
00:02:16,000 --> 00:02:19,000
实际上对于全端开发者来说

68
00:02:19,000 --> 00:02:22,000
整个前端世界是发生了巨变的

69
00:02:22,000 --> 00:02:27,000
而 React 是促使这些巨变的一个代表之一

70
00:02:27,000 --> 00:02:34,000
我们去年我们自己公司去年在考虑新的技术的时候呢

71
00:02:34,000 --> 00:02:38,000
把 React 纳入了我们想要使用的范围

72
00:02:38,000 --> 00:02:48,000
在过去的六到八个月我们都有在积极的把以前的东西给转移到 React 上

73
00:02:48,000 --> 00:02:51,000
我们之前是有写的一个 backbone app

74
00:02:51,000 --> 00:02:56,000
然后我们现在在 migrate 它去 react

75
00:02:56,000 --> 00:02:59,000
作为一个 react 开发者本身

76
00:02:59,000 --> 00:03:02,000
然后再作为一个这个技术的一个爱好者

77
00:03:02,000 --> 00:03:06,000
我也觉得非常荣幸有机会去 react.com 去

78
00:03:06,000 --> 00:03:11,000
这个 community 看最新的东西

79
00:03:11,000 --> 00:03:14,000
然后从其他人身上学到一些东西

80
00:03:14,000 --> 00:03:20,000
OK 那你刚才提到说整个 app 要从 backbone 迁移到 react 上面

81
00:03:20,000 --> 00:03:25,000
那待会我们也可以讲一下整个迁移过程是不是的痛苦程度有多少

82
00:03:25,000 --> 00:03:26,000
没问题

83
00:03:26,000 --> 00:03:29,000
其实是一个非常有意思的一个过程

84
00:03:29,000 --> 00:03:34,000
相对于像 angular 这样的庞大的 framework 来说

85
00:03:34,000 --> 00:03:36,000
react 实际上非常的轻巧

86
00:03:36,000 --> 00:03:42,000
然后正是因此这个 migration 没有很多人想象了会那么痛苦

87
00:03:42,000 --> 00:03:45,000
我们非常非常享受这个过程

88
00:03:45,000 --> 00:03:46,000
我忘了介绍了

89
00:03:46,000 --> 00:03:48,000
我们自己都很熟悉了

90
00:03:48,000 --> 00:03:50,000
但是忘了给有些听众朋友可能还

91
00:03:50,000 --> 00:03:53,000
就第一次听到 Vilo 的声音的话

92
00:03:53,000 --> 00:03:55,000
Vilo 你还要先介绍一下自己

93
00:03:55,000 --> 00:03:59,000
你是在 one tree 的做前面开发对吧

94
00:03:59,000 --> 00:04:00,000
OK

95
00:04:00,000 --> 00:04:05,000
我在 IT 工作的时候也没有介绍自己

96
00:04:05,000 --> 00:04:07,000
对啊

97
00:04:07,000 --> 00:04:12,000
我觉得不知道 Vilo 是谁的听众们可以回去听 IT 工作

98
00:04:12,000 --> 00:04:14,000
第一期是有介绍的

99
00:04:14,000 --> 00:04:20,000
我在湾区生活了三年

100
00:04:20,000 --> 00:04:23,000
然后我一直在这家叫做 backbone 的

101
00:04:23,000 --> 00:04:23,000
sorry

102
00:04:23,000 --> 00:04:26,000
我在湾区生活了三年

103
00:04:26,000 --> 00:04:31,000
然后一直在一家叫做 backplane 的公司做 soft engineer

104
00:04:31,000 --> 00:04:35,000
我很 focus 在前端开发上

105
00:04:35,000 --> 00:04:40,000
然后我要给你们公司做什么负面宣传的

106
00:04:40,000 --> 00:04:41,000
打赢啊

107
00:04:41,000 --> 00:04:42,000
就是 backplane 这家

108
00:04:42,000 --> 00:04:45,000
可能在外界最知名的就是什么他的投资人

109
00:04:45,000 --> 00:04:46,000
对吧

110
00:04:46,000 --> 00:04:47,000
well whatever

111
00:04:47,000 --> 00:04:49,000
let's save that for later

112
00:04:49,000 --> 00:04:52,000
what do we do recently is very exciting

113
00:04:52,000 --> 00:04:53,000
I'm just saying

114
00:04:53,000 --> 00:04:54,000
投资人是谁

115
00:04:54,000 --> 00:04:55,000
lady gaga

116
00:04:55,000 --> 00:04:56,000
还是

117
00:04:56,000 --> 00:04:57,000
对对对

118
00:04:57,000 --> 00:04:58,000
对没错

119
00:04:58,000 --> 00:05:01,000
可以帮我要一个签名吗

120
00:05:01,000 --> 00:05:03,000
他只是小

121
00:05:03,000 --> 00:05:05,000
小股东嘛

122
00:05:05,000 --> 00:05:06,000
签名

123
00:05:06,000 --> 00:05:08,000
他签我脸上了

124
00:05:08,000 --> 00:05:09,000
他亲了我

125
00:05:09,000 --> 00:05:13,000
好下次你来亲我一下

126
00:05:13,000 --> 00:05:16,000
应该是你下次他来你亲他一下

127
00:05:16,000 --> 00:05:18,000
这样你就和 lady gaga 亲上了

128
00:05:18,000 --> 00:05:19,000
OK

129
00:05:19,000 --> 00:05:21,000
看多机智的一个方法

130
00:05:21,000 --> 00:05:24,000
对所以说回来

131
00:05:24,000 --> 00:05:24,000
球员

132
00:05:24,000 --> 00:05:29,000
所以 villow 是一个在湾区工作的这个软件开发者

133
00:05:29,000 --> 00:05:29,000
对

134
00:05:29,000 --> 00:05:32,000
然后 villow 最有名的一个作品是

135
00:05:32,000 --> 00:05:38,000
或者说如果你跟 villow 的曾经产生过什么交集的话

136
00:05:38,000 --> 00:05:40,000
也许是你用过他写的一个插件

137
00:05:40,000 --> 00:05:42,000
叫做 what forms

138
00:05:42,000 --> 00:05:47,000
就是用来检测网页上某一部分被显示出来的文字

139
00:05:47,000 --> 00:05:50,000
所实际采用的字体的插件

140
00:05:50,000 --> 00:05:55,000
我们之前有一期 IT 公论探讨完那个产品

141
00:05:55,000 --> 00:05:58,000
如果大家有兴趣的话可以回头听那个 podcast

142
00:05:58,000 --> 00:06:03,000
这个产品已经已经已经在上线很多年了

143
00:06:03,000 --> 00:06:03,000
所以说

144
00:06:03,000 --> 00:06:08,000
所以说我也我也很期待能够有新的作品拿出来给大家

145
00:06:08,000 --> 00:06:11,000
然后我也在积极的积极的积极的做这方面的工作

146
00:06:11,000 --> 00:06:13,000
嗯很好

147
00:06:13,000 --> 00:06:19,000
所以你看 villow 在湾区就有比较方便的这种机会去参加到各种各样

148
00:06:19,000 --> 00:06:22,000
比较高大上的技术会议

149
00:06:22,000 --> 00:06:23,000
这种的话不在湾区真的蛮难的

150
00:06:23,000 --> 00:06:34,000
是就像欧洲很多 conference 都是在各个城市晃来晃去很少会有这种

151
00:06:34,000 --> 00:06:35,000
因为

152
00:06:35,000 --> 00:06:36,000
加堆的想象

153
00:06:36,000 --> 00:06:46,000
对比如说 react.js europeconference 将在 7 月份举行在欧洲巴黎

154
00:06:46,000 --> 00:06:50,000
然后 pycon europe 这个更是每一年都要换一个城市

155
00:06:50,000 --> 00:06:52,000
然后去年应该是在阿姆斯特丹吧

156
00:06:52,000 --> 00:06:53,000
我没记错

157
00:06:53,000 --> 00:06:54,000
然后

158
00:06:54,000 --> 00:06:56,000
还好啊欧洲交通方便

159
00:06:56,000 --> 00:06:57,000
我不觉得

160
00:06:57,000 --> 00:06:59,000
是吗

161
00:06:59,000 --> 00:07:00,000
我觉得还可以

162
00:07:00,000 --> 00:07:03,000
不管去哪都要订机票

163
00:07:03,000 --> 00:07:09,000
然后可能要去上那个国家的网站买护车票什么的就很麻烦

164
00:07:09,000 --> 00:07:10,000
不想

165
00:07:10,000 --> 00:07:13,000
那离欧洲大一同的离想还比较远

166
00:07:13,000 --> 00:07:19,000
之所以 react.conf 在欧洲会在巴黎是因为

167
00:07:19,000 --> 00:07:24,000
那个主开发者之一那个人叫什么 Christopher

168
00:07:24,000 --> 00:07:26,000
yeah Christopher 他是法国人吗

169
00:07:26,000 --> 00:07:27,000
right exactly

170
00:07:27,000 --> 00:07:32,000
对他讲他讲英语的时候有非常强的那个法国口音

171
00:07:32,000 --> 00:07:33,000
right

172
00:07:33,000 --> 00:07:34,000
我还专门去查了他是哪个人

173
00:07:34,000 --> 00:07:36,000
我没有黑色的

174
00:07:36,000 --> 00:07:39,000
他 last name is Chateau

175
00:07:39,000 --> 00:07:40,000
这个很明显了

176
00:07:40,000 --> 00:07:44,000
那挺好的就是我这也反映一个很大家很开放才对吧

177
00:07:44,000 --> 00:07:46,000
其实我说英语也有口音啊

178
00:07:46,000 --> 00:07:48,000
但是这个并不会成为

179
00:07:48,000 --> 00:07:50,000
不影响工作的

180
00:07:50,000 --> 00:07:51,000
对 exactly

181
00:07:51,000 --> 00:07:56,000
所以我也很看到他能够 host 这个 conference

182
00:07:56,000 --> 00:07:57,000
也是 validate

183
00:07:57,000 --> 00:08:00,000
大家都能这个英语这个事情不是那么重要吗

184
00:08:00,000 --> 00:08:01,000
所以是个很好的事情

185
00:08:02,000 --> 00:08:03,000
嗯哼

186
00:08:03,000 --> 00:08:06,000
其实 Vlo 在我们三个人里面已经是最美口音的一个了

187
00:08:06,000 --> 00:08:07,000
我觉得

188
00:08:07,000 --> 00:08:08,000
对啊

189
00:08:09,000 --> 00:08:11,000
摸爬滚打到最久的

190
00:08:11,000 --> 00:08:12,000
anyway

191
00:08:12,000 --> 00:08:13,000
车软了

192
00:08:13,000 --> 00:08:14,000
还是回到回到回到

193
00:08:14,000 --> 00:08:15,000
回到这个正题吧

194
00:08:15,000 --> 00:08:16,000
就说

195
00:08:16,000 --> 00:08:19,000
其实我们可以先回顾一下在 react 之前的那些框架

196
00:08:19,000 --> 00:08:21,000
会有一些什么样的

197
00:08:21,000 --> 00:08:23,000
就有些什么样的选择

198
00:08:23,000 --> 00:08:24,000
会有什么样的问题吧

199
00:08:24,000 --> 00:08:25,000
就是 Vlo

200
00:08:25,000 --> 00:08:26,000
你们之前是用这个 backbund 对吧

201
00:08:26,000 --> 00:08:27,000
对

202
00:08:27,000 --> 00:08:28,000
没错

203
00:08:28,000 --> 00:08:30,000
呃你们在实际使用中的话

204
00:08:30,000 --> 00:08:33,000
就是说刚才你也提到你们在往这个 react 迁移嘛

205
00:08:33,000 --> 00:08:37,000
那么就那你们就说在 backbund 的实际使用中遇到一些什么样的问题

206
00:08:37,000 --> 00:08:40,000
然后迁移到 react 会比较好的解决呢

207
00:08:40,000 --> 00:08:41,000
嗯

208
00:08:42,000 --> 00:08:43,000
有两方面的问题

209
00:08:43,000 --> 00:08:45,000
一方面是在

210
00:08:45,000 --> 00:08:48,000
人在 engineering 方面会问到一些遇到一些问题

211
00:08:48,000 --> 00:08:51,000
然后你在 production 上会遇到一些问题

212
00:08:51,000 --> 00:08:55,000
production 上的问题其实蛮简单的就是 performance

213
00:08:55,000 --> 00:09:00,000
啊这个一个 framework 它到底能有多快渲染的多快

214
00:09:00,000 --> 00:09:04,000
啊交互能力这些东西是非常好客观评价的

215
00:09:04,000 --> 00:09:12,000
然后啊如果上网搜的话会看到很多负面的关于 backbund 的一些评测

216
00:09:12,000 --> 00:09:15,000
然后我们自己在 production 上也遇到这些问题

217
00:09:15,000 --> 00:09:17,000
我们网站并不算快啊

218
00:09:17,000 --> 00:09:18,000
嗯嗯嗯

219
00:09:18,000 --> 00:09:21,000
然后在 memory 上也非常难啊管理

220
00:09:21,000 --> 00:09:24,000
这个 memory 呢实际上是很跨了这个 production and engineering

221
00:09:24,000 --> 00:09:34,000
因为啊 backbund 的啊 memory management 就好像你在原来做 iOS 开发是那个你要 manually return things

222
00:09:34,000 --> 00:09:36,000
you know like you knowmanually manage

223
00:09:36,000 --> 00:09:37,000
手工管理那一层

224
00:09:37,000 --> 00:09:41,000
所以所以啊非常容易出现 memory leak

225
00:09:41,000 --> 00:09:47,000
那整个程序记在 render 上会卖然后在 memory 上会 leak 的话

226
00:09:47,000 --> 00:09:50,000
那你的 performance 就就非常不乐观是不是

227
00:09:50,000 --> 00:09:52,000
就是 production 上的问题

228
00:09:52,000 --> 00:09:54,000
而且 need 上的问题呢在于啊

229
00:09:54,000 --> 00:09:59,000
关键对于我们来说是代码的可重用性和可管理性啊

230
00:09:59,000 --> 00:10:06,000
在重用性上的问题主要来说就是 view 的重用性

231
00:10:06,000 --> 00:10:10,000
实际上要重用一个 view 在 backbund 中还其实蛮蠻複雜的

232
00:10:10,000 --> 00:10:18,000
因为啊你要在那个啊 view 里面在在你的 template 里面给这个 subview

233
00:10:18,000 --> 00:10:24,000
腾出一个空间选一个 container 然后在你的 render function 中要 initialize 那个啊

234
00:10:24,000 --> 00:10:34,000
就是这个啊啊啊是不是 subview 然后把 subview 切进来这这这这这这这这这这这过程对于开发就来说还是一个蛮蛮蛮头痛的事情

235
00:10:34,000 --> 00:10:40,000
所以正因爲如此,你會看到很多人不會去重用。

236
00:10:40,000 --> 00:10:55,000
在代碼的可管理下的關鍵是,其實 view 它本身並不管理它所有的 state,很大一部分程度上 state 是在 dom 裡頭的。

237
00:10:55,000 --> 00:11:04,000
你知道我們有時候用到 class,用到 data,props,這樣的動的 elements 去管理你 view 的 state,

238
00:11:04,000 --> 00:11:13,000
就導致在大家看這個 view 的時候並看不到全貌,不知道這個 view 到底能夠做什麼事情,會做什麼事情。

239
00:11:13,000 --> 00:11:24,000
其實你在看那個 view 的時候是很難看出來的,就在多人合作的項目上,或者是說你返回到你多年之前寫的 app 的時候,

240
00:11:24,000 --> 00:11:26,000
就會是一個很大的問題。

241
00:11:26,000 --> 00:11:34,000
這是我們用 backbone 兩三年的時間裡所遇到兩個方面的問題。

242
00:11:34,000 --> 00:11:43,000
我覺得這可能跟 backbone 的設計理念有關系,backbone 畢竟它強調的是它所提供的功能,

243
00:11:43,000 --> 00:11:48,000
只是最基本,最 backbone 的那一部分。

244
00:11:48,000 --> 00:12:01,000
所以你可能不得不在很多地方要顯示的去宣告一些東西,然後你需要顯示的把邏輯寫出來。

245
00:12:01,000 --> 00:12:06,000
而如果你需要顯示的寫出來的話,每個人寫的邏輯可能會不一樣。

246
00:12:06,000 --> 00:12:10,000
這確是一方面的問題。

247
00:12:10,000 --> 00:12:14,000
對,你說你無法直接看到 view 想要幹什麼呢?

248
00:12:14,000 --> 00:12:25,000
其實原因之一也就是它沒有一個 default 的 behavior 可以讓你去一眼,讓你猜到它要幹什麼。

249
00:12:25,000 --> 00:12:33,000
嗯嗯,backbone 既好又導致這個問題的一方面就是它不是很 opinionated。

250
00:12:33,000 --> 00:12:45,000
我們確實在總結我們的 backbone 的經驗的時候有提到這點,在一個團隊寫作的範圍中,不 opinionated 實際上是一個很麻煩的事情。

251
00:12:45,000 --> 00:12:58,000
因為大家可能寫東西會用不同的方式,也不是說各種方式哪個好哪個壞,關鍵是協作上來說有相同的 mental model 會更方便一點。

252
00:12:58,000 --> 00:13:05,000
不管好壞只要一樣的話,能維護起來的成本可能,也不是維護起來的成本,就是溝通起來的成本會小一些。

253
00:13:05,000 --> 00:13:21,000
就是如果你用 embre.js 或者是 angular 之類的,比較有自己的一套使用哲學的框架的話,你會比較有一個大致的概念,就是這件事情怎樣做才是符合這個框架的理念的。

254
00:13:21,000 --> 00:13:30,000
但是 backbone 則比較平淡,或者說比較給了你太多自由權,然後就會導致會有溝通上面的問題,我是覺得。

255
00:13:30,000 --> 00:13:42,000
確實有這樣的因素在,可是當我們在看像 embre 這樣的 framework 的時候,它相對於 backbone 是一個比較小的地徑對我們來說,

256
00:13:42,000 --> 00:13:51,000
確實它在 backbone 的每一個方面,backbone 所設計的每一個方面,不管是 router 還是 view,templating,它都有相當大的進步。

257
00:13:51,000 --> 00:13:58,000
但是它所 fundamentally,他們的框架的理念,mvc 的理念是完全一致的。

258
00:13:58,000 --> 00:14:07,000
這也是為什麼我們在考慮更新我們的 framework 的時候,對 embre 並沒有做太多的考慮。

259
00:14:07,000 --> 00:14:12,000
因為如果你計算時間的,對,exactly。

260
00:14:12,000 --> 00:14:20,000
對,你只是從一種 mvc 換到另一種 mvc,只不過另外一個 mvc 更重量級一點,更 opinion 的一點。

261
00:14:20,000 --> 00:14:21,000
沒錯。

262
00:14:21,000 --> 00:14:22,000
OK。

263
00:14:22,000 --> 00:14:31,000
所以剛才為了你講到,像 backbone 你們做的時候,我根據你的描述,我感覺出來有幾個比較核心的問題。

264
00:14:31,000 --> 00:14:36,000
一個是說,這個叫什麼封裝的層級不夠,就說它封得太散了。

265
00:14:36,000 --> 00:14:43,000
比如說你很多,有些那個數據是在 dome 裡面的,有些數據可能是在這個 javascript 的那個數據結構裡面的,對吧。

266
00:14:43,000 --> 00:14:48,000
這可能是一個,還有你說那個 view 不能在同一個地方一眼看出來它的相關的那一部分是怎麼樣。

267
00:14:48,000 --> 00:14:56,000
這個其實是在你們在工程上的話,就是沒有把這些相關的部分很好的,就是 encapiculate 起來嘛。

268
00:14:56,000 --> 00:15:03,000
沒錯,因為這個主要是因為 dome 這個事情就太他媽操蛋了,你知道就是這樣。

269
00:15:03,000 --> 00:15:17,000
大家都明白為什麼這麼說,因為 dome 的問題,首先 API 很爛嘛,這個 jQuery kind of resolved that problem,kind of。

270
00:15:17,000 --> 00:15:25,000
然後關鍵的因素在於說 performance 太爛,因為這是歷史因素。

271
00:15:25,000 --> 00:15:31,000
因為 dome 的,你跟 dome 交互的話肯定就是有這個 overhead 比較高嘛。

272
00:15:31,000 --> 00:15:42,000
對,實際上如果你真正去 compare backbone 跟 react 的話,最關鍵就是他們怎麼去處理這個 dome,怎麼去處理 dome 這個事情上不一樣。

273
00:15:42,000 --> 00:15:50,000
在 backbone 裡頭,如果你要追求 performance,如果說你不 care performance,那 totally different story。

274
00:15:50,000 --> 00:15:57,000
但是如果你就是在意真正可用的東西,還不是好用是可用的話,你一定要在意 performance。

275
00:15:57,000 --> 00:16:05,000
然後就導致說你的 dome 的操作都要很小,非常小。

276
00:16:05,000 --> 00:16:15,000
比方說如果我要寫一個選項的那個列表,一個用戶去點一個選項,然後那個選項要變成紅色。

277
00:16:15,000 --> 00:16:32,000
這麼一個小小的功能,在你的 backbone view 中,你一定是會 manually 把這個 class 給從其他的 element 上移除出去,然後加在這個 target 的 element 上的。

278
00:16:32,000 --> 00:16:34,000
就這麼小小的一點。

279
00:16:34,000 --> 00:16:35,000
對,操作。

280
00:16:35,000 --> 00:16:36,000
你要便利一遍。

281
00:16:36,000 --> 00:16:46,000
就導致你的那個 state 就從 view 上 loose 掉了,因為你那個 state,整個 state 是在那個 dom 的那個 active class 這個因素上的。

282
00:16:46,000 --> 00:16:52,000
但是你又不可能說每次都把這個列表重新給 render 一下。

283
00:16:52,000 --> 00:16:55,000
這就回到我們說的 for performance 上面。

284
00:16:55,000 --> 00:17:06,000
對於用對於那個開發者來說,如果你不需要去擔心這麼小小的這種細節操作,而是描述清楚你到底這個 view end result 是怎麼樣。

285
00:17:06,000 --> 00:17:08,000
那你的 code 會清楚很多。

286
00:17:08,000 --> 00:17:18,000
可是因為 performance 的因素,你必須得到這麼到那個細節的小的程度去操作它,就導致你不能夠每次都 re-render。

287
00:17:18,000 --> 00:17:21,000
就是 backbone 的時代就是這樣子的。

288
00:17:21,000 --> 00:17:27,000
然後這就是 react 的 magic happens,where it happens,magic happens。

289
00:17:27,000 --> 00:17:43,000
在 react 的 conf 裡頭,Tom,who is the product manager,有提到 Facebook 內部去做這個,去 initialize 這個 project 的動機。

290
00:17:43,000 --> 00:17:56,000
就有提到說他們很想要把這種細小的 dom 操作隔離出來,ubstract out,就像剛剛 reel 說的 encapsulate。

291
00:17:56,000 --> 00:18:00,000
但是他們擔心 performance,所以他們做了 performance 的測試。

292
00:18:00,000 --> 00:18:06,000
其實像 performance 的測試結果,比我們所要預想的都樂觀很多。

293
00:18:06,000 --> 00:18:13,000
其實都沒有那麼爛,他們的原話是,我都記得是 IE 9 還是 IE 10 才會非常爛。

294
00:18:13,000 --> 00:18:15,000
well,we all know that,like that's not a surprise.

295
00:18:15,000 --> 00:18:22,000
but,這是一個,對,這是瀏覽器相關的毫無疑問。

296
00:18:22,000 --> 00:18:31,000
對,所以,但是在比方說 modern Chrome 中,如果你就是不停的 re-render 的話,實際上也沒有那麼爛。

297
00:18:31,000 --> 00:18:35,000
可是,of course,we want better performance,right?

298
00:18:35,000 --> 00:18:45,000
所以他們又腦洞大開的想把這個 dom 這個事情整個給 encapsulate,整個給 virtualize。

299
00:18:45,000 --> 00:19:06,000
所以開發者就完全不去操作這個 dom,然後通過 re-act 本身的一套算法,re-act 會試圖發現兩個 state 之間的區別,幫你自動的去 update 真正的瀏覽器的 dom。

300
00:19:06,000 --> 00:19:23,000
這就移除了這個 performance 的問題,從而回過頭來,enable 了開發者去寫更 descriptive,更 declarative 的 code,而不是直接告訴瀏覽器去做什麼。

301
00:19:23,000 --> 00:19:36,000
對,這裡就提到有一個 re-act,它這個新的前端的,它也比較有框架吧,這個工具,它最核心的一點就是說,它本身是和瀏覽器的 dom 是脫節的。

302
00:19:36,000 --> 00:19:39,000
就是它沒有一個很,就所謂的 type coupling 在裡面嘛。

303
00:19:39,000 --> 00:19:45,000
就是它 render 出來的結果並不是得到的一個真正的瀏覽器的 dom,而是一個所謂他們講的一個虛擬的 dom。

304
00:19:45,000 --> 00:20:02,000
對,virtualdom。然後他們再有做了這麼一個 diff 這一層,然後再去說,怎麼用最小的代價使得瀏覽器裡面現在有的那個真實的 dom,能夠變成你 virtualdom 需要的形狀。

305
00:20:02,000 --> 00:20:07,000
這樣的話就可以盡量減少這個 dom 那邊的交互的開銷嘛。

306
00:20:07,000 --> 00:20:14,000
對,當然這個的前提假設就是說,你跟真實的瀏覽器真實的 dom 的交互是一個比較高成本的。

307
00:20:14,000 --> 00:20:23,000
但是在一個現代瀏覽器,現代的 javascript 的解析器的情況下,它的那個 javascript 內部的執行和解析的速度是非常快的。

308
00:20:23,000 --> 00:20:28,000
所以要解決這兩個之間的差異的話,它就通過這種做 diff 的方法來實現了。

309
00:20:28,000 --> 00:20:43,000
對,沒錯。很有意思的是呢,David Nolan 是那些叫做,David Nolan 是 closure script 的作者,然後他們有把 react 給寫了一個 closure script,

310
00:20:43,000 --> 00:20:52,000
closure script 的 react 叫做 om,他給了一個 presentation,然後他不把 virtualdom 叫做 virtualdom,他把 virtualdom 叫做 dom virtualmachine。

311
00:20:52,000 --> 00:21:02,000
這是一個非常小的差異,但是我想他想要說的是說,這個 virtualdom 實際上是非常 powerful。

312
00:21:02,000 --> 00:21:20,000
然後這個 react 它的可能在思維哲學上我覺得有一點很大的不同,就是說傳統上我們像用這個 backbone 之類的,其實是你是在,你是把 dom 當成一個巨大的 state,然後你是在手工的去管理那些 state,對吧。

313
00:21:20,000 --> 00:21:22,000
嗯哼。

314
00:21:22,000 --> 00:21:32,000
然後這可能就很多的操作就是,可能要手動去添加什麼這個這個 event handler 啊,然後他發生什麼事情,你要又記得把它取掉,然後要做一些相應的修改。

315
00:21:32,000 --> 00:21:45,000
就是整個來看這個交互的流程和這個這個這個你的這個 view,就是混雜在比較比較,嗯,就是什麼,怎麼那個叫什麼,捲牙交錯,對吧。

316
00:21:45,000 --> 00:21:49,000
終於想起這個,男人以後這麼複雜的程度。

317
00:21:49,000 --> 00:22:11,000
但是像 react 這種思路的話,他用那 virtualdom 的思路,其實剛才 villow,villow 已經解釋過一下,就是說他其實是放棄了這一條,就是說我們不要去手工去去改那個,一個瀏覽器裡面 dom 的每一個小細節,而是說我們你只要告訴我,你需要讓他達到什麼樣的狀態。

318
00:22:11,000 --> 00:22:13,000
這個需要讓你說你是一次性的描述性的狀態嗎?

319
00:22:13,000 --> 00:22:14,000
對。

320
00:22:14,000 --> 00:22:23,000
然後這樣的話,我就只需要說,哎,那我不需要考慮怎麼去變到那個狀態,我只需要聲明我最後要達到什麼樣的狀態就可以了。

321
00:22:23,000 --> 00:22:34,000
嗯,其實這個讓我想起 Backbone 的一個,一句宣傳口號就是,Get the truth out from your dome。

322
00:22:34,000 --> 00:22:51,000
但實際上,他的這個口號所指的是要把,其實就是很簡單的,要把 Dome 所要呈現的那層那些數據,作為你的 model 從 Dome 裡面抽稀出來。

323
00:22:51,000 --> 00:23:14,000
但如果沿著這一句,宣傳口號更進一步研發的話,會,我覺得可能最終結果就是像 React 這樣,就是將 Dome 作為某種,就像 ScreenBuffer 一樣,就是計算出最終需要的 Dome,然後去更新它與實際的 Dome 所差異的這一部分。

324
00:23:14,000 --> 00:23:21,000
這樣可能更,就是更多的 Truth 被從 Dome 裡面抽稀出來。

325
00:23:21,000 --> 00:23:33,000
其實他這個思想也不是說原創性的,就是在很多年前做遊戲的大家都已經發現有這麼一個,就做那種就是電腦遊戲的人都已經有這麼一個概念了。

326
00:23:33,000 --> 00:23:40,000
過去遊戲有一個叫做,就是繪製圖形的話,有一個所謂的叫做 immediate mode,就是立即模式嘛。

327
00:23:40,000 --> 00:23:44,000
就是你畫什麼就在圖像,就在那個屏幕上出現什麼嘛。

328
00:23:44,000 --> 00:23:50,000
然後後來發現其實這樣的話,對那個,叫什麼,對性能其實是不好的。

329
00:23:50,000 --> 00:23:57,000
後來他們發現用那個什麼 retain mode 的話,你其實可以再讓這個遊戲引擎去做一些優化。

330
00:23:57,000 --> 00:24:05,000
對,你先告訴他下一針應該顯示什麼,讓他計算出兩者的差異。

331
00:24:05,000 --> 00:24:12,000
其實在 react.com 上沒有人提到跟遊戲上的差異。

332
00:24:12,000 --> 00:24:19,000
所以我有點就是自己在想,在好奇說到底這個是一個殊途同歸呢?

333
00:24:19,000 --> 00:24:25,000
還是他們有真正的在那個遊戲開發者身上提取靈感。

334
00:24:25,000 --> 00:24:29,000
但我更傾向於是相信是一個殊途同歸的結果。

335
00:24:29,000 --> 00:24:37,000
對,對,我也覺得那個 pete hunt,他在去年的那個介紹 react 的那個會議上面,他就講了嘛。

336
00:24:37,000 --> 00:24:42,000
就是說他們做完發現,他們那個做成了 3 D 遊戲的人好像也是用了同樣一套思路。

337
00:24:42,000 --> 00:24:43,000
沒錯。

338
00:24:43,000 --> 00:24:46,000
就是其實確實是一個殊途同歸的一個結果吧。

339
00:24:46,000 --> 00:24:58,000
對,其實我相信現在的 webapp 領域的很多技術可能在就是古早的 3 D 技術發展的道路上都已經討論過了。

340
00:24:58,000 --> 00:25:05,000
嗯嗯,然後有些經驗可能也是會需要被 backport 過來的。

341
00:25:05,000 --> 00:25:10,000
嗯,或者說其實我們把這個領域放得更寬廣一點。

342
00:25:10,000 --> 00:25:15,000
就是說前端如果不僅限於這個網頁或者是一個客戶端的 app 的話,

343
00:25:15,000 --> 00:25:20,000
其實遊戲從你從某種意義傳來講也是在做一個前端的東西嗎?

344
00:25:20,000 --> 00:25:29,000
嗯,我覺得遊戲可能最大的差別是它和它的前端和後端之間的差異。

345
00:25:29,000 --> 00:25:35,000
而它的前端和後端之間沒有中間隔著這麼巨大的一個互聯網的鴻溝。

346
00:25:35,000 --> 00:25:44,000
就是它它中間的通訊沒有這麼大的一個延遲,或者說有這麼大的一個協議站擺在那邊。

347
00:25:44,000 --> 00:25:48,000
但現在你很多遊戲也是我所說的網絡的 Network game,

348
00:25:48,000 --> 00:25:50,000
所以其實還是有很大相似點。

349
00:25:50,000 --> 00:25:54,000
但那一部分僅僅是用來交互遊戲數據的。

350
00:25:54,000 --> 00:26:02,000
你的表現層的數據仍然就是在本地生成,

351
00:26:02,000 --> 00:26:04,000
除非你是在做 Streaming,

352
00:26:04,000 --> 00:26:06,000
但是 Streaming 又是另外一個話題了。

353
00:26:06,000 --> 00:26:08,000
嗯,對,這也是一個問題吧。

354
00:26:08,000 --> 00:26:16,000
React 其實還有一點,就是它是更傾向於你使用所謂的這個 immutable data structure,

355
00:26:16,000 --> 00:26:19,000
就是不可修改的數據結構。

356
00:26:19,000 --> 00:26:22,000
這一點上我們在 Count 上有提到,

357
00:26:22,000 --> 00:26:26,000
然後順帶說我非常喜歡,

358
00:26:26,000 --> 00:26:29,000
我在這個 ReactCount 上我真的非常高興非常激動,

359
00:26:29,000 --> 00:26:35,000
因為傳統上來說前端不是一個很 hardcoreCS 的東西對吧?

360
00:26:35,000 --> 00:26:40,000
你說大家一般看前端看法者都有一點小比式的意思。

361
00:26:40,000 --> 00:26:45,000
對,更加工程導向而不是理論導向。

362
00:26:45,000 --> 00:26:48,000
更加 25 歲以下的導向。

363
00:26:48,000 --> 00:26:49,000
不要這麼誇張。

364
00:26:49,000 --> 00:26:52,000
不,我又想起來那個。

365
00:26:52,000 --> 00:26:56,000
所以正是在這個 conference 上,

366
00:26:56,000 --> 00:26:58,000
我們有聽到很多很有意思的東西,

367
00:26:58,000 --> 00:27:00,000
其中有一個是 immutable data。

368
00:27:00,000 --> 00:27:05,000
對,我們有一個演講是李巴隆給的演講,

369
00:27:05,000 --> 00:27:08,000
在專門說 immutable data,

370
00:27:08,000 --> 00:27:11,000
就是 Facebook 的 immutable data,

371
00:27:11,000 --> 00:27:13,000
JavaScript 實現。

372
00:27:13,000 --> 00:27:17,000
他有講到很多這個 immutable data 到底是什麼東西,

373
00:27:17,000 --> 00:27:21,000
怎麼在 JavaScript 上實現的,非常好。

374
00:27:21,000 --> 00:27:25,000
但是 back 到這個 react 上來說的話,

375
00:27:25,000 --> 00:27:28,000
之所以 immutable data 是 preferred,

376
00:27:28,000 --> 00:27:29,000
not required,

377
00:27:29,000 --> 00:27:31,000
but preferred 是因為,

378
00:27:31,000 --> 00:27:33,000
正因為 react 它的設計方式,

379
00:27:33,000 --> 00:27:36,000
整個的 render 的過程,整個的 component,

380
00:27:36,000 --> 00:27:42,000
實際上就是 props plusstate equal to something。

381
00:27:42,000 --> 00:27:43,000
嗯哼。

382
00:27:43,000 --> 00:27:45,000
這個 equal 是 render function 所做的事情。

383
00:27:45,000 --> 00:27:49,000
所以如果你的 props 跟你的 state 不變化的話,

384
00:27:49,000 --> 00:27:54,000
你的 render result 總是一致的,總會是一樣的。

385
00:27:54,000 --> 00:27:55,000
對。

386
00:27:55,000 --> 00:27:59,000
雖然說 virtual DOM 會幫助你不去 update 那個 dom,

387
00:27:59,000 --> 00:28:06,000
但是如果你在連 render 都連連 render function 都不用去 run 的話,

388
00:28:06,000 --> 00:28:10,000
那你就實現了更好的 performance,

389
00:28:10,000 --> 00:28:12,000
然後省下更多的時間,

390
00:28:12,000 --> 00:28:15,000
特別是在大型的 application 上。

391
00:28:15,000 --> 00:28:20,000
但是怎麼去判斷這個 props 跟 state 有沒有改變,

392
00:28:20,000 --> 00:28:22,000
就變成了一個很大的問題。

393
00:28:22,000 --> 00:28:23,000
傳統的 mute data 的話,

394
00:28:23,000 --> 00:28:26,000
就至少是個 on 的操作對不對?

395
00:28:26,000 --> 00:28:27,000
你必須得,

396
00:28:27,000 --> 00:28:29,000
對,你必須得逐個去比較。

397
00:28:29,000 --> 00:28:31,000
必須得把整個 object 給變立了,

398
00:28:31,000 --> 00:28:34,000
然後如果你要做 deep comparison 的話,

399
00:28:34,000 --> 00:28:36,000
就更大了,是一個數狀結構。

400
00:28:36,000 --> 00:28:37,000
嗯,

401
00:28:37,000 --> 00:28:38,000
嗯,

402
00:28:38,000 --> 00:28:39,000
嗯,

403
00:28:39,000 --> 00:28:40,000
嗯,

404
00:28:40,000 --> 00:28:41,000
嗯,

405
00:28:41,000 --> 00:28:42,000
嗯,

406
00:28:42,000 --> 00:28:43,000
嗯,

407
00:28:43,000 --> 00:28:44,000
嗯,

408
00:28:44,000 --> 00:28:45,000
嗯,

409
00:28:45,000 --> 00:28:46,000
嗯,

410
00:28:46,000 --> 00:28:47,000
嗯,

411
00:28:47,000 --> 00:28:48,000
嗯,

412
00:28:48,000 --> 00:28:49,000
嗯,

413
00:28:49,000 --> 00:28:50,000
嗯,

414
00:28:50,000 --> 00:28:51,000
嗯,

415
00:28:51,000 --> 00:28:52,000
嗯,

416
00:28:52,000 --> 00:28:53,000
嗯,

417
00:28:53,000 --> 00:28:54,000
嗯,

418
00:28:54,000 --> 00:28:55,000
嗯,

419
00:28:55,000 --> 00:28:56,000
嗯,

420
00:28:56,000 --> 00:28:57,000
嗯,

421
00:28:57,000 --> 00:28:58,000
嗯,

422
00:28:58,000 --> 00:28:59,000
嗯,

423
00:28:59,000 --> 00:29:00,000
嗯,

424
00:29:00,000 --> 00:29:01,000
嗯,

425
00:29:01,000 --> 00:29:02,000
嗯,

426
00:29:02,000 --> 00:29:03,000
嗯,

427
00:29:03,000 --> 00:29:04,000
嗯,

428
00:29:04,000 --> 00:29:05,000
嗯,

429
00:29:05,000 --> 00:29:07,000
嗯,

430
00:29:07,000 --> 00:29:08,000
嗯,

431
00:29:08,000 --> 00:29:09,000
嗯,

432
00:29:09,000 --> 00:29:10,000
嗯,

433
00:29:10,000 --> 00:29:11,000
嗯,

434
00:29:11,000 --> 00:29:12,000
嗯,

435
00:29:12,000 --> 00:29:13,000
嗯,

436
00:29:13,000 --> 00:29:14,000
嗯,

437
00:29:14,000 --> 00:29:15,000
啊,

438
00:29:15,000 --> 00:29:18,000
所以 immutable data 这个事情非常有意思

439
00:29:18,000 --> 00:29:19,000
就不是一个传统以上

440
00:29:19,000 --> 00:29:21,000
JavaScript 的人 care 的东西

441
00:29:22,000 --> 00:29:29,000
正因为对于 immutable data 的喜好

442
00:29:30,000 --> 00:29:32,000
才导致了 closure script

443
00:29:32,000 --> 00:29:34,000
也加入 react 的行列

444
00:29:34,000 --> 00:29:36,000
因为 closure 它所有的

445
00:29:36,000 --> 00:29:37,000
本来就是 immutable

446
00:29:37,000 --> 00:29:38,000
它是 function language

447
00:29:38,000 --> 00:29:38,000
然后它所有的

448
00:29:38,000 --> 00:29:39,000
都是 immutable 的

449
00:29:40,000 --> 00:29:42,000
所以就很 naturally

450
00:29:42,000 --> 00:29:45,000
它的 framework 就很好的利用了

451
00:29:45,000 --> 00:29:46,000
这样一个特性

452
00:29:48,000 --> 00:29:49,000
对上次我看了一个

453
00:29:49,000 --> 00:29:51,000
那个 ohm 就是 clear script 写的

454
00:29:51,000 --> 00:29:52,000
react 的实现

455
00:29:52,000 --> 00:29:55,000
它们的性能确实非常了不得多

456
00:29:55,000 --> 00:29:56,000
因为刚才讲了

457
00:29:56,000 --> 00:29:58,000
你只要因为在 ohm 里面

458
00:29:58,000 --> 00:30:00,000
整个大部分的 data structure

459
00:30:00,000 --> 00:30:02,000
都是这个所谓的 immutable 的话

460
00:30:02,000 --> 00:30:04,000
它们在渲染的时候

461
00:30:04,000 --> 00:30:07,000
真的就逐个走那个树状结构

462
00:30:07,000 --> 00:30:10,000
然后判断那个根结点的指针就好了

463
00:30:10,000 --> 00:30:13,000
这是非常快速的一个过程

464
00:30:13,000 --> 00:30:13,000
对

465
00:30:13,000 --> 00:30:17,000
顺带说在整个 conference 中

466
00:30:17,000 --> 00:30:20,000
我们有提到非常多的 performance 的 trick

467
00:30:20,000 --> 00:30:22,000
怎么样实现更好的 performance

468
00:30:22,000 --> 00:30:23,000
immutable 是其中之一

469
00:30:23,000 --> 00:30:25,000
我们有提到很多其他的东西

470
00:30:25,000 --> 00:30:28,000
如果观众听众朋友们有兴趣的话

471
00:30:28,000 --> 00:30:30,000
可以找到这些 keynote

472
00:30:30,000 --> 00:30:31,000
也可以写信问我

473
00:30:31,000 --> 00:30:33,000
或者告诉 real

474
00:30:33,000 --> 00:30:37,000
我们说明下期可以做更多关于 react 的

475
00:30:37,000 --> 00:30:39,000
更细节更优化的东西

476
00:30:39,000 --> 00:30:41,000
对

477
00:30:41,000 --> 00:30:45,000
不过他们看那个现场那个视频

478
00:30:45,000 --> 00:30:46,000
现在跟他说一下

479
00:30:46,000 --> 00:30:49,000
这个这次的 reactconf 2015 的所有的视频

480
00:30:49,000 --> 00:30:52,000
都在 youtube 上面有的

481
00:30:52,000 --> 00:30:56,000
但是因为现在国内 VPN 也打击的比较严重

482
00:30:56,000 --> 00:30:58,000
能不能看到就不好说了

483
00:30:58,000 --> 00:30:59,000
个人有个人的方法

484
00:30:59,000 --> 00:31:00,000
他不是所有都在吧

485
00:31:00,000 --> 00:31:01,000
好像可以吧

486
00:31:01,000 --> 00:31:02,000
就是我在看

487
00:31:02,000 --> 00:31:04,000
就因为 youtube 上有个频道叫做 Facebook

488
00:31:04,000 --> 00:31:07,000
developer 的频道

489
00:31:07,000 --> 00:31:10,000
然后这个 channel 上基本上

490
00:31:10,000 --> 00:31:12,000
应该你需要的都可以看到

491
00:31:12,000 --> 00:31:14,000
不 我就说国内的

492
00:31:14,000 --> 00:31:15,000
就是我们听说很多人在国内

493
00:31:15,000 --> 00:31:18,000
他们没有办法去上这个 youtube

494
00:31:18,000 --> 00:31:21,000
我觉得我们要 fact check 一下

495
00:31:21,000 --> 00:31:24,000
我好像只有他只有三个吧

496
00:31:24,000 --> 00:31:25,000
只有 relay

497
00:31:25,000 --> 00:31:26,000
他有那一 mute without jss 的那

498
00:31:26,000 --> 00:31:27,000
听到吗

499
00:31:27,000 --> 00:31:29,000
他现在他在逐渐放

500
00:31:29,000 --> 00:31:30,000
他已经放了九个了

501
00:31:30,000 --> 00:31:33,000
我觉得他应该可能还是在做一些剪辑之类的工作

502
00:31:33,000 --> 00:31:35,000
他对中是要他要全部放上去

503
00:31:35,000 --> 00:31:37,000
他没有理由不放出来

504
00:31:37,000 --> 00:31:40,000
因为对对

505
00:31:40,000 --> 00:31:42,000
反正一共是有多少个

506
00:31:42,000 --> 00:31:43,000
一共是多少个 talk 来的

507
00:31:43,000 --> 00:31:46,000
有两天是 12 个还是 9 个

508
00:31:46,000 --> 00:31:46,000
anyways

509
00:31:46,000 --> 00:31:50,000
就是就讲 fact check 一下

510
00:31:50,000 --> 00:31:51,000
没有起来一次

511
00:31:51,000 --> 00:31:53,000
有的有的

512
00:31:53,000 --> 00:31:54,000
这个不用担心

513
00:31:54,000 --> 00:31:59,000
然后其实说 relay

514
00:31:59,000 --> 00:32:01,000
这个他我们传统上一般认为

515
00:32:01,000 --> 00:32:05,000
他是在 mvc 里面做的那个 v 的那个角色

516
00:32:05,000 --> 00:32:05,000
对吧

517
00:32:05,000 --> 00:32:05,000
对

518
00:32:05,000 --> 00:32:08,000
但是我们传统一个 mvc 的话

519
00:32:08,000 --> 00:32:11,000
那个像 m 和 c 那部分怎么解决

520
00:32:11,000 --> 00:32:14,000
其实在相当长的时间内

521
00:32:14,000 --> 00:32:15,000
还是没有很好的一个方案吧

522
00:32:15,000 --> 00:32:18,000
但是去年年末的时候

523
00:32:18,000 --> 00:32:22,000
他们公开了一个叫做这个 flux 的这么一个架构吧

524
00:32:22,000 --> 00:32:25,000
也不算是一个就是一个指导方针

525
00:32:25,000 --> 00:32:26,000
只能说是

526
00:32:26,000 --> 00:32:31,000
就是你怎么去用 relay 的方式去构建一个传统的 mvc 的实现的时候

527
00:32:31,000 --> 00:32:32,000
你要注意一下什么样的问题

528
00:32:32,000 --> 00:32:37,000
这个 flux 我觉得也是一个非常具有什么

529
00:32:37,000 --> 00:32:40,000
划时代意义的一个方式

530
00:32:40,000 --> 00:32:40,000
就刚刚讲那个

531
00:32:40,000 --> 00:32:41,000
真的吗

532
00:32:41,000 --> 00:32:43,000
我怎么记得就是 flux 出来的时候

533
00:32:43,000 --> 00:32:43,000
黑客入社

534
00:32:43,000 --> 00:32:47,000
有人黑说他们 rediscover 了一个非常古老的 idea

535
00:32:47,000 --> 00:32:50,000
然后把它重新包装了一遍

536
00:32:50,000 --> 00:32:52,000
然后改名叫 flux

537
00:32:52,000 --> 00:32:54,000
但其实在起码在那个前端开发明

538
00:32:54,000 --> 00:32:56,000
它确实是一个挺好的事情我觉得

539
00:32:56,000 --> 00:33:00,000
其实这一点上我跟吴涛所说的有一点类似

540
00:33:00,000 --> 00:33:05,000
我至今呢也觉得 flux 的 idea 实际

541
00:33:05,000 --> 00:33:08,000
怎么说我们如果看历史的话

542
00:33:08,000 --> 00:33:09,000
你如果有看

543
00:33:09,000 --> 00:33:11,000
我有看所有的 flux 的 video 这些东西

544
00:33:11,000 --> 00:33:12,000
你看的话

545
00:33:12,000 --> 00:33:15,000
他们最初 flux 要解决的问题

546
00:33:15,000 --> 00:33:18,000
并不是真正的 mvc

547
00:33:18,000 --> 00:33:23,000
我觉得他们在最初在 inventing flux 的时候

548
00:33:23,000 --> 00:33:26,000
他们所使用的那个做事情的方式呢

549
00:33:26,000 --> 00:33:28,000
并不是真正的 mvc

550
00:33:28,000 --> 00:33:31,000
但是这并不是说就 flux 就不好

551
00:33:31,000 --> 00:33:35,000
不是因此 flux 这个框架就不对

552
00:33:35,000 --> 00:33:40,000
很有意思的是在 react.com 上

553
00:33:40,000 --> 00:33:43,000
那些 speakers 反复的提到

554
00:33:43,000 --> 00:33:47,000
他们最初发布 react 的时候大家的反应

555
00:33:47,000 --> 00:33:49,000
最初发布 react 是在

556
00:33:49,000 --> 00:33:54,000
在 JSConf 的 2013 年的 JSConf 上

557
00:33:54,000 --> 00:33:56,000
他的反应都非常 negative

558
00:33:56,000 --> 00:33:58,000
假如说 reinvented the view

559
00:33:58,000 --> 00:34:00,000
what the fuck

560
00:34:00,000 --> 00:34:01,000
reinventing the wheel

561
00:34:01,000 --> 00:34:03,000
reinventing the best practices

562
00:34:03,000 --> 00:34:12,000
后来 pete hong 甚至给了一个 rethinking best practice 的一个 speech

563
00:34:12,000 --> 00:34:17,000
所以上完这个会呢

564
00:34:17,000 --> 00:34:20,000
我也是觉得大家还是保持一个开放的心态

565
00:34:20,000 --> 00:34:21,000
也不需要去 hate 他或者怎么样

566
00:34:21,000 --> 00:34:25,000
毕竟说我们也不能够就是怎么说

567
00:34:25,000 --> 00:34:27,000
就是没守成规

568
00:34:27,000 --> 00:34:29,000
一定说之前东西就是好的

569
00:34:29,000 --> 00:34:31,000
如果 flux 能够解决你所要解决的问题

570
00:34:31,000 --> 00:34:34,000
如果 flux 能够解决 Facebook 所要解决的问题

571
00:34:34,000 --> 00:34:36,000
你清楚你的问题是什么

572
00:34:36,000 --> 00:34:37,000
我觉得这才是最重要对不对

573
00:34:37,000 --> 00:34:40,000
所以 back 到 flux 上面来说

574
00:34:40,000 --> 00:34:42,000
它实际上跟传统音乐上的 MVC

575
00:34:42,000 --> 00:34:43,000
有非常多的相似的地方

576
00:34:43,000 --> 00:34:46,000
它整个 dispatcher mode

577
00:34:46,000 --> 00:34:50,000
整个的 event 的流程

578
00:34:50,000 --> 00:34:53,000
单向的信息的流动

579
00:34:53,000 --> 00:34:57,000
实际上跟传统音乐上的 MVC 是非常类似的

580
00:34:57,000 --> 00:34:59,000
但它有细节上的差异

581
00:34:59,000 --> 00:35:01,000
比方说 action 是 global 的

582
00:35:01,000 --> 00:35:03,000
dispatcher 是 global 的

583
00:35:03,000 --> 00:35:08,000
比方说在一个信息没有流完的情况下

584
00:35:08,000 --> 00:35:11,000
你不能够 initialize 另外一个信息

585
00:35:11,000 --> 00:35:12,000
像这样的细节的差异

586
00:35:12,000 --> 00:35:18,000
实际上就意味着 flux 跟传统音乐的 MVC 不一样

587
00:35:18,000 --> 00:35:20,000
特别是在

588
00:35:20,000 --> 00:35:20,000
对

589
00:35:20,000 --> 00:35:22,000
你知道比方说如果我们用 backflon

590
00:35:22,000 --> 00:35:27,000
如果 model 触发一个 change event

591
00:35:27,000 --> 00:35:29,000
这个 change event 的 event handler

592
00:35:29,000 --> 00:35:31,000
是可以再去改变 model

593
00:35:31,000 --> 00:35:34,000
然后从而就产生另外一个 change event

594
00:35:34,000 --> 00:35:38,000
它有 cascading 的效果在

595
00:35:38,000 --> 00:35:38,000
对

596
00:35:38,000 --> 00:35:44,000
flux 的它的发明跟 cascading 非常有关系

597
00:35:44,000 --> 00:35:46,000
一个重点的原因

598
00:35:46,000 --> 00:35:49,000
要他们去发明 flux 就是不想要 cascading

599
00:35:49,000 --> 00:35:51,000
应该像细小的一些

600
00:35:51,000 --> 00:35:52,000
因为太难管理了

601
00:35:52,000 --> 00:35:54,000
you don't know what will happen

602
00:35:54,000 --> 00:35:56,000
like you don't know exactly what will happen

603
00:35:56,000 --> 00:36:07,000
就好像 react 它本身就想要把 code 更 declare

604
00:36:07,000 --> 00:36:10,000
的话 flux 也有这样的目的

605
00:36:10,000 --> 00:36:11,000
就是让 flow 更清晰

606
00:36:11,000 --> 00:36:15,000
每次的 action 都是导致同一个结果

607
00:36:15,000 --> 00:36:16,000
同一个方向流动

608
00:36:16,000 --> 00:36:20,000
然后你不会触发另外一个

609
00:36:20,000 --> 00:36:22,000
你所没有预料到的结果

610
00:36:22,000 --> 00:36:25,000
这点上如果你真正去用 flux

611
00:36:25,000 --> 00:36:27,000
会发现实际上是非常有帮助的

612
00:36:27,000 --> 00:36:31,000
对你管理你的程序的复杂度

613
00:36:31,000 --> 00:36:32,000
对

614
00:36:32,000 --> 00:36:35,000
我个人感觉就是我之前是在做一些

615
00:36:35,000 --> 00:36:39,000
小的 project 去尝试用 flux 架构

616
00:36:39,000 --> 00:36:42,000
但是我具体用的是一个叫做 reflux 的实现

617
00:36:42,000 --> 00:36:45,000
但是它在逻辑上是大同小异的

618
00:36:45,000 --> 00:36:48,000
就是有些细微的组件上有点不一样

619
00:36:48,000 --> 00:36:50,000
我感觉就是有很明显的区别

620
00:36:50,000 --> 00:36:53,000
就是说采用了这个 flux 架构之后

621
00:36:53,000 --> 00:36:59,000
整个前端应用的逻辑变得非常有条理和清晰

622
00:36:59,000 --> 00:37:00,000
就知道边界在哪里

623
00:37:00,000 --> 00:37:02,000
然后哪些数据在哪里管理

624
00:37:02,000 --> 00:37:05,000
就最开始的时候你提到像用 backbound 的时候

625
00:37:05,000 --> 00:37:07,000
有些数据是混在这个 dome 里面的对吧

626
00:37:07,000 --> 00:37:09,000
这样其实这如果你用 flux 的方式

627
00:37:09,000 --> 00:37:12,000
就其实是完全分离开了

628
00:37:12,000 --> 00:37:14,000
它有所谓的 store 的概念

629
00:37:14,000 --> 00:37:18,000
就大约略等同于以前 mvc 里面那个 model

630
00:37:18,000 --> 00:37:20,000
但是说它的 store 里面

631
00:37:20,000 --> 00:37:22,000
它有一些具体的限制

632
00:37:22,000 --> 00:37:24,000
刚才比如说你不能说 store

633
00:37:24,000 --> 00:37:27,000
触发就是 cascading 的东西出来

634
00:37:27,000 --> 00:37:31,000
这样其实然后就可以保证你这个信息的流向是单向的

635
00:37:31,000 --> 00:37:35,000
对这样的话就可以让你很方便的去把这个

636
00:37:35,000 --> 00:37:37,000
所谓的 separation of concern

637
00:37:37,000 --> 00:37:40,000
就是把那些需要关注的点心分隔开来做

638
00:37:40,000 --> 00:37:44,000
对这个整个架构是很有帮助的一个工具

639
00:37:44,000 --> 00:37:49,000
然后 flux 其实从 facebook 的角度来说的话实际上只是一个 idea

640
00:37:49,000 --> 00:37:52,000
它对你到底说你的 dispatch 是什么

641
00:37:52,000 --> 00:37:53,000
你的 action 是什么

642
00:37:53,000 --> 00:37:55,000
你的 storage 是怎么实现的

643
00:37:55,000 --> 00:37:58,000
并没有很严格意义上的就是管理

644
00:37:58,000 --> 00:38:04,000
就是因为如此像我们在做这个从 react

645
00:38:04,000 --> 00:38:07,000
从 back 到 react 的一个迁移嘛

646
00:38:07,000 --> 00:38:11,000
从一定程度上来说我可以用传统的 backbone model

647
00:38:11,000 --> 00:38:14,000
backbone collection 来实现 flux

648
00:38:14,000 --> 00:38:16,000
这是可能的这是完全可能的

649
00:38:16,000 --> 00:38:18,000
对

650
00:38:18,000 --> 00:38:26,000
所以就是 again 不要拘泥于书本上的概念去想一想想要解决的问题

651
00:38:26,000 --> 00:38:30,000
然后去看一看这个 architecture 到底能不能解决这个问题

652
00:38:30,000 --> 00:38:32,000
才是最重要的

653
00:38:32,000 --> 00:38:38,000
而且 flux 可能在一定程度上来说只有对大型的 application 才有意义

654
00:38:38,000 --> 00:38:41,000
你要想 facebook 所要解决的问题是 massive skill

655
00:38:41,000 --> 00:38:42,000
对不对

656
00:38:42,000 --> 00:38:44,000
他们有 hundreds of engineers

657
00:38:44,000 --> 00:38:47,000
如果你只有一两个人在一个程序上工作的话

658
00:38:47,000 --> 00:38:54,000
那或许有更轻巧更便宜的架构你能够选择

659
00:38:54,000 --> 00:38:56,000
你能够选择

660
00:38:56,000 --> 00:38:58,000
对可能用不上用使用这种就所谓大规模山山性武器

661
00:38:58,000 --> 00:39:00,000
对

662
00:39:00,000 --> 00:39:04,000
react 还有一个好处

663
00:39:04,000 --> 00:39:10,000
就是说这个所谓构建这个 isomorphic 的 javascript 应用的情况是比较好的

664
00:39:10,000 --> 00:39:12,000
因为它可以同样的一个 react 的组件

665
00:39:12,000 --> 00:39:16,000
只要你构建的方式稍微注意一点点

666
00:39:16,000 --> 00:39:22,000
它是可以在客户端渲染或者是在服务端渲染

667
00:39:22,000 --> 00:39:24,000
然后在服务端渲染它有一个什么好处呢

668
00:39:24,000 --> 00:39:28,000
它可以在服务端渲染从最初的那个页面那个结构之后

669
00:39:28,000 --> 00:39:30,000
你把这个送给浏览器

670
00:39:30,000 --> 00:39:34,000
然后在浏览器再接着服务端渲染那个部分开始

671
00:39:34,000 --> 00:39:37,000
在完成后面的后续的工作

672
00:39:37,000 --> 00:39:38,000
这个我不太清楚

673
00:39:38,000 --> 00:39:42,000
就是之前有其他类型的框架实现过这种功能没

674
00:39:42,000 --> 00:39:46,000
但是我第一次看到这个时候觉得还是蛮惊奇的

675
00:39:46,000 --> 00:39:47,000
as far as i know

676
00:39:47,000 --> 00:39:50,000
如果你小心翼翼的写你的 app 的话

677
00:39:50,000 --> 00:39:54,000
是有可能用其他的框架加上 fantum

678
00:39:54,000 --> 00:39:57,000
这种 headless webkit 来实现相同的功能

679
00:39:57,000 --> 00:39:59,000
我觉得理论上是有可能的

680
00:39:59,000 --> 00:40:03,000
但是在这个太棒了

681
00:40:03,000 --> 00:40:04,000
对 exactly

682
00:40:04,000 --> 00:40:06,000
就性能上的话还会损失很多

683
00:40:06,000 --> 00:40:10,000
因为你毕竟要让一个 webkit 在你的 servic 上

684
00:40:10,000 --> 00:40:14,000
well FuntumJS 发展到现在实际上也解决了非常多的问题

685
00:40:14,000 --> 00:40:15,000
它变成了一个 server

686
00:40:15,000 --> 00:40:19,000
而不是你每次要附那个 overhead 去 run

687
00:40:19,000 --> 00:40:21,000
run 这个 webkit 在里头

688
00:40:21,000 --> 00:40:24,000
当然 react 有更大的可能性

689
00:40:24,000 --> 00:40:27,000
因为毕竟那个 DOM 是 virtualized

690
00:40:27,000 --> 00:40:28,000
所以

691
00:40:28,000 --> 00:40:31,000
对它不需要去 load 一个真正的 webkit 的引擎

692
00:40:31,000 --> 00:40:36,000
它只需要在 javascript 内部去虚构一个这么一个 DOM 结构就好

693
00:40:36,000 --> 00:40:41,000
这一次我们在 conference 上有听到很多公司谈到这个他们的应用

694
00:40:41,000 --> 00:40:44,000
大部分的原因也不是因为性能

695
00:40:44,000 --> 00:40:46,000
而是因为 ACO

696
00:40:46,000 --> 00:40:48,000
很多公司很 concern 于 ACO

697
00:40:48,000 --> 00:40:50,000
然后现在 javascript

698
00:40:50,000 --> 00:40:51,000
ACO

699
00:40:51,000 --> 00:40:54,000
还是一个没能解决的问题

700
00:40:54,000 --> 00:40:55,000
surprise to me

701
00:40:55,000 --> 00:40:58,000
过去中国年了仍旧是一个冷却的问题

702
00:40:58,000 --> 00:40:59,000
crazy

703
00:40:59,000 --> 00:41:03,000
所以有公司提到说

704
00:41:03,000 --> 00:41:08,000
你知道 Google 有一个 convention

705
00:41:08,000 --> 00:41:12,000
就是如果你的 URL 是一个特别的什么结构的话

706
00:41:12,000 --> 00:41:17,000
它会尝试去 fetch 另外一个 URL

707
00:41:17,000 --> 00:41:19,000
which is supposed to be a static page

708
00:41:19,000 --> 00:41:23,000
但是 according to some other companies

709
00:41:23,000 --> 00:41:25,000
这个功能非常

710
00:41:25,000 --> 00:41:27,000
就是 Google 不怎么在意这个功能

711
00:41:27,000 --> 00:41:28,000
然后经常就坏掉

712
00:41:28,000 --> 00:41:30,000
所以他们经常就是

713
00:41:30,000 --> 00:41:34,000
就是那个 fetch rate 到 drop 到零你知道吗

714
00:41:34,000 --> 00:41:36,000
这是对于公司来说就是 disaster

715
00:41:36,000 --> 00:41:40,000
他们的很多公司都是很靠 Google 流量

716
00:41:40,000 --> 00:41:42,000
如果说有这样一个问题的话

717
00:41:42,000 --> 00:41:44,000
对他们的 business 是 critical

718
00:41:44,000 --> 00:41:48,000
所以他们就很电打西客

719
00:41:48,000 --> 00:41:52,000
非常在意这个 asomorphic 的可能性

720
00:41:52,000 --> 00:41:55,000
对而且之前之前说那个 Google 说

721
00:41:55,000 --> 00:41:59,000
他说干一种是一种方式通过一种特殊的 URL 结构去说

722
00:41:59,000 --> 00:42:01,000
告知 Google 的爬虫

723
00:42:01,000 --> 00:42:04,000
我这个动态网页你可以在另外一个地址找到它的静态版本

724
00:42:04,000 --> 00:42:07,000
这是一个比较传统的解决方案

725
00:42:07,000 --> 00:42:10,000
然后 Google 是应该是去年年末的时候

726
00:42:10,000 --> 00:42:14,000
他是说他们也会渲染 JavaScript 的这个页面

727
00:42:14,000 --> 00:42:23,000
就是他会当把自己模拟成一个浏览器的引擎去解析那个页面的 JavaScript 引擎

728
00:42:23,000 --> 00:42:26,000
但是现在问题就是说他没有办法去判断哪些东西是可以点的

729
00:42:26,000 --> 00:42:32,000
因为你知道浏览器就是 JavaScript 里面的很多可以点击可以 navigate 的项目

730
00:42:32,000 --> 00:42:38,000
它并不像说网页上你是一个 A 的那种这个 anchor 的 tag 可以去很明显的发现了对吧

731
00:42:38,000 --> 00:42:40,000
对所以其实对他们来讲

732
00:42:40,000 --> 00:42:44,000
缩了引擎去发现这些动态的内容始终是有问题的嘛

733
00:42:44,000 --> 00:42:49,000
所以在这种情况下那种 isomorphic 还是不可避免

734
00:42:49,000 --> 00:42:54,000
然后我的感觉就是说用 react 这种方式来实现 isomorphic 的话

735
00:42:54,000 --> 00:42:58,000
它的难度是相就极大的被降低了吧

736
00:42:58,000 --> 00:43:03,000
就是相对于你之前手工的去要么用 fantan.js 去做一个这个什么 render farm

737
00:43:03,000 --> 00:43:06,000
手工的去渲染一下因为这个比较高成本吧

738
00:43:06,000 --> 00:43:09,000
然后另外就是说他可以实现那个所谓的无缝迁移

739
00:43:09,000 --> 00:43:12,000
就是你可以随意决定哪一部分是在服务端渲染

740
00:43:12,000 --> 00:43:15,000
然后哪一部分是在这个客户端渲染嘛

741
00:43:15,000 --> 00:43:18,000
这个是非常不错的一个工程

742
00:43:18,000 --> 00:43:20,000
刚刚 reo 做了一个非常好的总结

743
00:43:20,000 --> 00:43:26,000
在实际的应用中 react 可能是最好的 balance

744
00:43:26,000 --> 00:43:29,000
就是性能跟可管理性最好的 balance

745
00:43:29,000 --> 00:43:35,000
如果你的应用场景是你要需要非常好的 performance 的话

746
00:43:35,000 --> 00:43:39,000
那或许你应该去看其他的一些选项

747
00:43:39,000 --> 00:43:44,000
比方说用共用 template 而不是共用 java-series logic

748
00:43:44,000 --> 00:43:48,000
然后在服务器端用服务器的 native language whatever

749
00:43:48,000 --> 00:43:50,000
whatever you know php 或 java

750
00:43:50,000 --> 00:43:54,000
来写这个 template 的 render function

751
00:43:54,000 --> 00:43:58,000
这样的话你要写两个 rendering 的 application

752
00:43:58,000 --> 00:44:03,000
在你的工程上是更麻烦

753
00:44:03,000 --> 00:44:05,000
但是如果你要追求性能的话

754
00:44:05,000 --> 00:44:06,000
那是更好的选项

755
00:44:06,000 --> 00:44:12,000
react 现在的问题是在于说即使你在服务器端渲染

756
00:44:12,000 --> 00:44:17,000
react 还是会给你做很多不必要的 dom 的操作

757
00:44:17,000 --> 00:44:19,000
或者是模拟

758
00:44:19,000 --> 00:44:23,000
有什么具体的情况

759
00:44:23,000 --> 00:44:27,000
as a result 有公司做了测试

760
00:44:27,000 --> 00:44:32,000
然后 as a result 相对于说就是我刚刚说的用 php

761
00:44:32,000 --> 00:44:42,000
来 rendering 这个 template 的话它的输出只有 template 的大概 25%

762
00:44:42,000 --> 00:44:44,000
有差这么多吗

763
00:44:44,000 --> 00:44:45,000
但是这个是非常可以优化的

764
00:44:45,000 --> 00:44:48,000
因为有很多 dom 的就是比方说 event hammer

765
00:44:48,000 --> 00:44:50,000
比如说 event handling 这些东西

766
00:44:50,000 --> 00:44:53,000
在服务器端都没有必要去关联了对吧

767
00:44:53,000 --> 00:44:55,000
因为你最终只需要一个静态的验名

768
00:44:55,000 --> 00:44:57,000
你只需要静态的结果

769
00:44:57,000 --> 00:45:02,000
但是这就是一个 open source project 很有趣的地方了

770
00:45:02,000 --> 00:45:05,000
facebook 本身对这个没有太大的兴趣

771
00:45:05,000 --> 00:45:07,000
因为他们没有太大的需求

772
00:45:07,000 --> 00:45:10,000
但是如果其他公司或者是你

773
00:45:10,000 --> 00:45:12,000
我们听众对此有需求的话

774
00:45:12,000 --> 00:45:14,000
可以去看他们 sourcode

775
00:45:14,000 --> 00:45:17,000
然后对 virtualdom 做出一些修改

776
00:45:17,000 --> 00:45:21,000
来实现更好的在 server 上 rendering 的功能

777
00:45:21,000 --> 00:45:23,000
我想这个潜力是非常大的

778
00:45:23,000 --> 00:45:26,000
因为它现在是基本上是没有任何优化的

779
00:45:26,000 --> 00:45:27,000
对对对对

780
00:45:27,000 --> 00:45:29,000
在这种情况下还是挺好我觉得

781
00:45:29,000 --> 00:45:33,000
说到 react 在实际使用的时候

782
00:45:33,000 --> 00:45:36,000
就会牵涉到一个很有意思的它的写法

783
00:45:36,000 --> 00:45:38,000
或者一个语言叫做 gsx

784
00:45:38,000 --> 00:45:40,000
就是什么概念呢

785
00:45:40,000 --> 00:45:44,000
就是说因为我们是在传统上我们写一个前端应用的时候

786
00:45:44,000 --> 00:45:49,000
我们是把这个模板和这个数据或者逻辑完全分离开来的嘛

787
00:45:49,000 --> 00:45:55,000
就模板可能会用什么什么 moustache 之类的一些东西来用 html 来写一个模板

788
00:45:55,000 --> 00:45:56,000
然后留些空

789
00:45:56,000 --> 00:46:00,000
然后当这个 javascript 去把模板这个 load 的进来

790
00:46:00,000 --> 00:46:01,000
然后把那个空填上

791
00:46:01,000 --> 00:46:03,000
就 rendor 出一个进他的页面

792
00:46:03,000 --> 00:46:05,000
再发给出去填到页面里面去

793
00:46:05,000 --> 00:46:09,000
但是在 react 里面去他们推荐的方式是说

794
00:46:09,000 --> 00:46:12,000
不要区分这个模板和这个数据和逻辑

795
00:46:12,000 --> 00:46:13,000
你是做一个前端应用

796
00:46:13,000 --> 00:46:17,000
你的这个模板就是你的这个要核心要考虑的一部分

797
00:46:17,000 --> 00:46:22,000
我觉得这是 react 的 rethink best practice 的一部分吧

798
00:46:22,000 --> 00:46:27,000
理论上来说我们之前做 Holo 的那个 best practice 是说把模板分离开来

799
00:46:27,000 --> 00:46:30,000
这样的话你有更好的重用性

800
00:46:30,000 --> 00:46:32,000
因为你那个模板是可以被重用的对吧

801
00:46:32,000 --> 00:46:33,000
对

802
00:46:33,000 --> 00:46:35,000
可是如果你看这个 gsx 的话

803
00:46:35,000 --> 00:46:36,000
它实际上不是一个模板

804
00:46:36,000 --> 00:46:37,000
它完全不是一个模板

805
00:46:37,000 --> 00:46:39,000
你其实就是写 javascript code

806
00:46:39,000 --> 00:46:40,000
你所写的

807
00:46:40,000 --> 00:46:45,000
你只不过是用一种类似于写模板的语法去描述数据吧

808
00:46:45,000 --> 00:46:47,000
对 exactly

809
00:46:47,000 --> 00:46:53,000
就是他你对你在你用一种写模板的方式去写你的 data model

810
00:46:53,000 --> 00:46:54,000
这其实是一种进步

811
00:46:54,000 --> 00:46:57,000
而不是就是某种抨击的

812
00:46:57,000 --> 00:47:00,000
某些人抨击的那样是一种历史的倒退

813
00:47:00,000 --> 00:47:01,000
我觉得可能

814
00:47:01,000 --> 00:47:03,000
对这个事情就其实挺好玩

815
00:47:03,000 --> 00:47:07,000
因为刚那个就是 react 去年刚发布正式对外发布的时候

816
00:47:07,000 --> 00:47:09,000
很多人就是吐槽这一点

817
00:47:09,000 --> 00:47:11,000
因为大家都可能被这个教条

818
00:47:11,000 --> 00:47:12,000
教条惯了

819
00:47:12,000 --> 00:47:14,000
就说这个模板和数据要分离

820
00:47:14,000 --> 00:47:18,000
但其实我觉得当时那个 pete hung 他有一个话说的很好

821
00:47:18,000 --> 00:47:23,000
就是说这个模板它分的那个就 separationconcer 分错了

822
00:47:23,000 --> 00:47:26,000
它把两个不应该分开的东西强行分开了

823
00:47:26,000 --> 00:47:28,000
但其实没有太多的好处嘛

824
00:47:28,000 --> 00:47:30,000
所以通过这上那个 react

825
00:47:30,000 --> 00:47:31,000
这种 jsx 方式

826
00:47:31,000 --> 00:47:35,000
其实把这两个本来就应该紧密联系在一起的

827
00:47:35,000 --> 00:47:37,000
两个部分放在一个地方

828
00:47:37,000 --> 00:47:38,000
然后大家可以一眼看到

829
00:47:38,000 --> 00:47:47,000
就好像那个 vilo 之前抱怨的说那个 backbone 里面写很多这种 subview 的时候不方便说在一个文件里面就看出他在干什么

830
00:47:47,000 --> 00:47:52,000
然后用这种 jsx 的方式你可以一眼看出啊我这个是在做一个模板

831
00:47:52,000 --> 00:47:55,000
我在这个模板里面填充了这么一个数据

832
00:47:55,000 --> 00:47:58,000
然后这个数据是从这个对象哪个地方来的

833
00:47:58,000 --> 00:48:02,000
然后这个我要添加哪些这个 event handler 都在同一个地方完成这个东西

834
00:48:02,000 --> 00:48:06,000
这个才是一个好的所谓的这个 encapsulation

835
00:48:06,000 --> 00:48:10,000
我要再一次提醒大家就是你需要考虑自己的实际问题

836
00:48:10,000 --> 00:48:11,000
然后选择正确的啊

837
00:48:11,000 --> 00:48:13,000
你懂 framework 或者 convention

838
00:48:13,000 --> 00:48:14,000
adopt

839
00:48:14,000 --> 00:48:15,000
嗯哼

840
00:48:15,000 --> 00:48:17,000
我们刚刚说那个 asomorphic 对不对

841
00:48:17,000 --> 00:48:21,000
在那种情况下实际上你如果你分离出模板来的话是有好处的

842
00:48:21,000 --> 00:48:23,000
因为你如果你要在啊

843
00:48:23,000 --> 00:48:28,000
在你的你的后端用另外一种语言来写你的 render logic

844
00:48:28,000 --> 00:48:31,000
的话那个共用模板是可以共用的

845
00:48:31,000 --> 00:48:33,000
但你得看在你的实际上使用过程中

846
00:48:33,000 --> 00:48:34,000
对对对

847
00:48:34,000 --> 00:48:36,000
我们是没有这么做的

848
00:48:36,000 --> 00:48:39,000
然后我们所有的模板是没有任何重用性的

849
00:48:39,000 --> 00:48:41,000
就是也不是没有任何重用性

850
00:48:41,000 --> 00:48:42,000
而是没有

851
00:48:42,000 --> 00:48:44,000
呃它是有很强的重用性

852
00:48:44,000 --> 00:48:48,000
因为因为它它它它在另外一个就是单独的自己的那个文件中的话

853
00:48:48,000 --> 00:48:50,000
但是我们从来没有重用过它

854
00:48:50,000 --> 00:48:52,000
从来没有重用过它

855
00:48:52,000 --> 00:48:54,000
在三年的写这个程序的过程中

856
00:48:54,000 --> 00:48:57,000
那那到底做这个事情是为了什么

857
00:48:57,000 --> 00:48:59,000
我们其实也不是很清楚

858
00:48:59,000 --> 00:49:00,000
对

859
00:49:00,000 --> 00:49:01,000
没想明白

860
00:49:01,000 --> 00:49:03,000
所以在在特定的应用场景下

861
00:49:03,000 --> 00:49:05,000
特定的 best practice 是有道理的

862
00:49:05,000 --> 00:49:06,000
比方说我们刚刚说那个

863
00:49:06,000 --> 00:49:09,000
你如果一个重一个模板要在不同的语言中被 render 的话

864
00:49:09,000 --> 00:49:11,000
那实际上是非常好的一个设计

865
00:49:11,000 --> 00:49:13,000
但如果你仅仅是在加工手中

866
00:49:13,000 --> 00:49:15,000
那可能真的你得重新考虑这个事情

867
00:49:15,000 --> 00:49:16,000
到底是不是有意义的

868
00:49:16,000 --> 00:49:18,000
何况你用 react 的时候

869
00:49:18,000 --> 00:49:20,000
这就真的不是模板了

870
00:49:20,000 --> 00:49:22,000
这个模板这个东西不存在的

871
00:49:22,000 --> 00:49:24,000
它所有东西都是 javascript

872
00:49:24,000 --> 00:49:26,000
有没有称为主要的

873
00:49:26,000 --> 00:49:28,000
这个念头你得转过弯来

874
00:49:28,000 --> 00:49:29,000
对

875
00:49:29,000 --> 00:49:30,000
你写这

876
00:49:30,000 --> 00:49:32,000
它只是看起来像而已

877
00:49:32,000 --> 00:49:33,000
但完全不是

878
00:49:33,000 --> 00:49:34,000
好处在于说

879
00:49:34,000 --> 00:49:35,000
对

880
00:49:35,000 --> 00:49:37,000
刚刚我们说

881
00:49:37,000 --> 00:49:39,000
把 subview 的问题

882
00:49:39,000 --> 00:49:40,000
在 backbone 里头

883
00:49:40,000 --> 00:49:43,000
你得在模板里头给它留空间

884
00:49:43,000 --> 00:49:46,000
然后再 manually insert 进去

885
00:49:46,000 --> 00:49:48,000
在 react 中就不是问题了

886
00:49:48,000 --> 00:49:50,000
你直接 import 一下

887
00:49:50,000 --> 00:49:52,000
然后 import 那个 subcomponent

888
00:49:52,000 --> 00:49:55,000
然后直接把这个 tag 写上去就好了

889
00:49:55,000 --> 00:49:58,000
这是一个非常好的

890
00:50:00,000 --> 00:50:02,000
重用性的进步

891
00:50:02,000 --> 00:50:03,000
对

892
00:50:03,000 --> 00:50:07,000
而且实际上也大量减轻了开发者的

893
00:50:08,000 --> 00:50:10,000
mental model

894
00:50:10,000 --> 00:50:14,000
就是在维护一个 mental model 的负担

895
00:50:14,000 --> 00:50:16,000
就是你不用总是在

896
00:50:16,000 --> 00:50:18,000
我现在在写一个 template

897
00:50:18,000 --> 00:50:19,000
我现在在写 model

898
00:50:19,000 --> 00:50:21,000
你不用在维护不停的 context

899
00:50:21,000 --> 00:50:23,000
context switch 的成本上

900
00:50:23,000 --> 00:50:25,000
还有必须得提到的是

901
00:50:25,000 --> 00:50:28,000
GSX 并不是一个全新的东西

902
00:50:28,000 --> 00:50:30,000
在 facebook 内部

903
00:50:30,000 --> 00:50:32,000
这是一个开源的项目

904
00:50:32,000 --> 00:50:33,000
已经是

905
00:50:33,000 --> 00:50:35,000
他们一直在用类似的产品

906
00:50:35,000 --> 00:50:37,000
叫做 XHP

907
00:50:37,000 --> 00:50:39,000
是 PHP 的版本

908
00:50:39,000 --> 00:50:41,000
所以他们很长时间

909
00:50:41,000 --> 00:50:43,000
已经在 PHP 里写

910
00:50:43,000 --> 00:50:45,000
所谓 HDMIntag

911
00:50:45,000 --> 00:50:47,000
所以在这点上

912
00:50:47,000 --> 00:50:49,000
也是对这个 concept 的一个 validation

913
00:50:49,000 --> 00:50:50,000
因为毕竟 facebook

914
00:50:50,000 --> 00:50:53,000
毕竟 facebook 有用相同的概念

915
00:50:53,000 --> 00:50:54,000
用了很久了

916
00:50:54,000 --> 00:50:57,000
所以我觉得他们先人一步

917
00:50:57,000 --> 00:50:59,000
已经 accept 的这个概念了

918
00:50:59,000 --> 00:51:00,000
所以对他们来说

919
00:51:00,000 --> 00:51:03,000
就不是一个事你知道吗

920
00:51:05,000 --> 00:51:06,000
对

921
00:51:06,000 --> 00:51:08,000
我大概也是就是前年去湾区的时候

922
00:51:08,000 --> 00:51:11,000
然后看到他们就是在 Facebook 内部

923
00:51:11,000 --> 00:51:14,000
是怎么用这个叫做 XHP 的这么个语言

924
00:51:14,000 --> 00:51:18,000
去写这个他们的服务端的软件

925
00:51:18,000 --> 00:51:20,000
当时我就震撼到了

926
00:51:20,000 --> 00:51:23,000
我说哇这个就因为他们那个等于是可以任意构建一种

927
00:51:23,000 --> 00:51:25,000
就传统上我们写这个模板的时候

928
00:51:25,000 --> 00:51:28,000
你是只能用一个抽象程度很低的方式

929
00:51:28,000 --> 00:51:29,000
因为你模板的话

930
00:51:29,000 --> 00:51:31,000
你要么就在模板层别上

931
00:51:31,000 --> 00:51:32,000
你可以构建一些东西出来

932
00:51:32,000 --> 00:51:33,000
或者是说

933
00:51:33,000 --> 00:51:34,000
你

934
00:51:34,000 --> 00:51:36,000
就你在写那些 Netflix 标签的时候

935
00:51:36,000 --> 00:51:38,000
你还是要用那些标准的标签

936
00:51:38,000 --> 00:51:40,000
但是他们在用那个 XHP 的时候

937
00:51:40,000 --> 00:51:42,000
其实是可以定义自己的一个标签的

938
00:51:42,000 --> 00:51:47,000
然后这个标签可以包含很多很复杂的这种行为和数据

939
00:51:47,000 --> 00:51:48,000
包括内部的结构在里面

940
00:51:48,000 --> 00:51:51,000
而这个对这个标签的调用方来讲

941
00:51:51,000 --> 00:51:54,000
完全可以不用关心里面到底是如何实现

942
00:51:54,000 --> 00:51:59,000
对其实就有点像一个 AngularJS 所做出来的新的 HML Tag

943
00:51:59,000 --> 00:52:02,000
只不过这一切全都是在 PHP 里面

944
00:52:02,000 --> 00:52:04,000
他们应该也是叫做 Component

945
00:52:04,000 --> 00:52:05,000
那个时候

946
00:52:05,000 --> 00:52:08,000
就所谓这个组件化的时候

947
00:52:08,000 --> 00:52:09,000
就组件化的时候

948
00:52:09,000 --> 00:52:12,000
就一个什么一个要达到一个什么样的场景

949
00:52:12,000 --> 00:52:14,000
就是说我只要构建好我这个组件

950
00:52:14,000 --> 00:52:17,000
我这个组件对外部来说是一个完全封闭的

951
00:52:17,000 --> 00:52:21,000
你只要外部提供给我需要的这个数据和我需要的

952
00:52:21,000 --> 00:52:23,000
包括一些回调函数的话

953
00:52:23,000 --> 00:52:25,000
我这个组件就能完成你需要的工作

954
00:52:25,000 --> 00:52:28,000
就不再需要去每个人都去看到这个组件

955
00:52:28,000 --> 00:52:30,000
那一部是有多少个什么多少个 A Tag

956
00:52:30,000 --> 00:52:33,000
多少个 Div 这种层层包起来这么一个东西

957
00:52:33,000 --> 00:52:37,000
这一点我觉得是一个在抽象层级上是一个划时代的进步

958
00:52:37,000 --> 00:52:39,000
我觉得是

959
00:52:39,000 --> 00:52:44,000
然后当时那个就是我看到 Facebook 他们那一部在用这个

960
00:52:44,000 --> 00:52:46,000
最后这么好我觉得哇这个真是

961
00:52:46,000 --> 00:52:50,000
因为我没有在其他地方看到有类似的产品或者是语言吧

962
00:52:50,000 --> 00:52:52,000
在做类似的事情

963
00:52:52,000 --> 00:52:56,000
真的是感觉走在什么时代的前列的那种

964
00:52:56,000 --> 00:52:59,000
跟我们不跟其他的人确实差的

965
00:52:59,000 --> 00:53:01,000
就领先的蛮远的

966
00:53:01,000 --> 00:53:02,000
那我们下面讲那个

967
00:53:02,000 --> 00:53:05,000
那个 React Native 吧

968
00:53:05,000 --> 00:53:07,000
E 6

969
00:53:07,000 --> 00:53:08,000
我讲吧

970
00:53:08,000 --> 00:53:09,000
那个

971
00:53:09,000 --> 00:53:11,000
那其实不是很重要我觉得

972
00:53:11,000 --> 00:53:12,000
OK 这个是

973
00:53:12,000 --> 00:53:13,000
为了为了你觉得呢

974
00:53:13,000 --> 00:53:15,000
说到 E 6 呢

975
00:53:15,000 --> 00:53:17,000
我觉得 Angular 跟

976
00:53:17,000 --> 00:53:20,000
就主要是 Angular 跟 React 区别之一吧

977
00:53:20,000 --> 00:53:21,000
因为

978
00:53:21,000 --> 00:53:23,000
就是 React 似乎在

979
00:53:23,000 --> 00:53:26,000
它的发展过程中考虑了更多的

980
00:53:26,000 --> 00:53:28,000
JavaScript Native 的东西

981
00:53:28,000 --> 00:53:32,000
WhileAngular 好像在创造一个自己的小世界

982
00:53:32,000 --> 00:53:35,000
我们有一个 panel 上

983
00:53:35,000 --> 00:53:36,000
有那个 Sebastian

984
00:53:36,000 --> 00:53:40,000
是 React 的主要的维护者之一

985
00:53:40,000 --> 00:53:43,000
然后他实际上他本身是在那个

986
00:53:43,000 --> 00:53:46,000
E 6 的委员会上的

987
00:53:46,000 --> 00:53:48,000
所以他有提到说

988
00:53:48,000 --> 00:53:53,000
React 是非常非常 aggressive 的在推 E 6 的支持

989
00:53:53,000 --> 00:53:56,000
他甚至把那个 mixing 的支持给去掉了

990
00:53:56,000 --> 00:53:57,000
在最新的版本

991
00:53:57,000 --> 00:53:58,000
拿掉了吗

992
00:53:58,000 --> 00:53:59,000
他的解释呢

993
00:53:59,000 --> 00:54:03,000
是因为 E 6 的 mixing 支持

994
00:54:03,000 --> 00:54:05,000
在那个

995
00:54:05,000 --> 00:54:06,000
不是比较糟糕

996
00:54:06,000 --> 00:54:08,000
而是在那个 standard 中被去掉了

997
00:54:08,000 --> 00:54:11,000
就是 E 6 现在的那个标准

998
00:54:11,000 --> 00:54:13,000
就是在这一版中的话是不

999
00:54:13,000 --> 00:54:14,000
没有 mixing 的

1000
00:54:14,000 --> 00:54:15,000
没有提到 mixing 的

1001
00:54:15,000 --> 00:54:18,000
他们在 E 7 中才会去支持 mixing

1002
00:54:18,000 --> 00:54:20,000
或者说才会把这个事情再提上益存

1003
00:54:20,000 --> 00:54:22,000
所以正因为如此呢

1004
00:54:22,000 --> 00:54:25,000
在那个 native 的 class support 中

1005
00:54:25,000 --> 00:54:27,000
React 把那个 mixing 给去掉了

1006
00:54:27,000 --> 00:54:30,000
当然这件事情都是 ongoing events

1007
00:54:30,000 --> 00:54:33,000
所以还有可能有其他的变化

1008
00:54:33,000 --> 00:54:36,000
不过我觉得至少在我看来的话

1009
00:54:36,000 --> 00:54:40,000
React 是非常在积极的推动和

1010
00:54:40,000 --> 00:54:46,000
就是实现这个 E 6 的标准

1011
00:54:46,000 --> 00:54:52,000
其实为了你对这个 ES 6 就是

1012
00:54:52,000 --> 00:54:54,000
JavaScript 下一个版本的这个语言

1013
00:54:54,000 --> 00:54:56,000
你是什么样的态度

1014
00:54:56,000 --> 00:54:59,000
老实说我不是很熟悉

1015
00:54:59,000 --> 00:55:01,000
所以我们把这段剪辑掉吧

1016
00:55:01,000 --> 00:55:04,000
我没有用

1017
00:55:04,000 --> 00:55:06,000
我们在座有谁比较熟悉吗

1018
00:55:06,000 --> 00:55:08,000
有人紧跟着 E 7 Mixing

1019
00:55:08,000 --> 00:55:10,000
我有在跟这个

1020
00:55:10,000 --> 00:55:11,000
你在跟啊

1021
00:55:11,000 --> 00:55:12,000
对你现在在搞这个

1022
00:55:12,000 --> 00:55:13,000
没有没有

1023
00:55:13,000 --> 00:55:14,000
我也有在用它嘛

1024
00:55:14,000 --> 00:55:17,000
就是在就尝试去使用它

1025
00:55:17,000 --> 00:55:19,000
现在我把说我昨天还在转

1026
00:55:19,000 --> 00:55:21,000
就是那个那个 IPM 背后不是一个

1027
00:55:21,000 --> 00:55:23,000
我自己写的 CMS 嘛

1028
00:55:23,000 --> 00:55:24,000
嗯哼

1029
00:55:24,000 --> 00:55:25,000
那它有一个管理后台

1030
00:55:25,000 --> 00:55:27,000
那个其实是用 React 写的

1031
00:55:27,000 --> 00:55:28,000
嗯

1032
00:55:28,000 --> 00:55:29,000
那哎那我想想

1033
00:55:29,000 --> 00:55:30,000
那我们是先讲 relay 呢

1034
00:55:30,000 --> 00:55:32,000
还是先讲这个 react

1035
00:55:32,000 --> 00:55:34,000
因为 native 实际上是个非常非常非常

1036
00:55:34,000 --> 00:55:35,000
非常自然的过渡

1037
00:55:35,000 --> 00:55:36,000
因为啊

1038
00:55:36,000 --> 00:55:40,000
在 react 中你的最最初的版本中

1039
00:55:40,000 --> 00:55:42,000
你的那个 rendertarget 是 virtual DOM

1040
00:55:42,000 --> 00:55:44,000
对不对啊

1041
00:55:44,000 --> 00:55:47,000
但是为什么一定要 rendert 到 DOM 上来

1042
00:55:47,000 --> 00:55:48,000
反正已经 virtualize 了

1043
00:55:48,000 --> 00:55:51,000
你就好像你用那个虚拟机一样

1044
00:55:51,000 --> 00:55:54,000
你到底那个虚拟机是在 Windows 上 run

1045
00:55:54,000 --> 00:55:55,000
是在 Mac 上 run

1046
00:55:55,000 --> 00:55:57,000
是在你用 like

1047
00:55:57,000 --> 00:55:59,000
like uh always choose and run

1048
00:55:59,000 --> 00:56:00,000
不

1049
00:56:00,000 --> 00:56:01,000
并不重要嘛

1050
00:56:01,000 --> 00:56:02,000
对吧

1051
00:56:02,000 --> 00:56:03,000
所以

1052
00:56:03,000 --> 00:56:04,000
对对

1053
00:56:04,000 --> 00:56:06,000
就等于它提供一层新的抽象

1054
00:56:06,000 --> 00:56:08,000
然后借入这层新的抽象

1055
00:56:08,000 --> 00:56:09,000
你就有了新的自由

1056
00:56:09,000 --> 00:56:10,000
你可以把它

1057
00:56:10,000 --> 00:56:11,000
你可以把呃

1058
00:56:11,000 --> 00:56:12,000
它的底层

1059
00:56:12,000 --> 00:56:14,000
迁移到其他的 platform 上面

1060
00:56:14,000 --> 00:56:15,000
没错

1061
00:56:15,000 --> 00:56:17,000
对我我忘了是那个是 Tom

1062
00:56:17,000 --> 00:56:18,000
还是那个 Christopher 说的

1063
00:56:18,000 --> 00:56:21,000
就是说他说我们他们之前做那个 virtual DOM 的时候

1064
00:56:21,000 --> 00:56:27,000
这最终目的并不是说要把这个 DOM virtualize 这件事情本身

1065
00:56:27,000 --> 00:56:28,000
而是说要完全去掉这个 DOM

1066
00:56:28,000 --> 00:56:32,000
就是要把 react 跟这个 DOM 的依赖直接切掉

1067
00:56:32,000 --> 00:56:33,000
就没完全没有关系

1068
00:56:33,000 --> 00:56:34,000
我可以不依赖一个 DOM

1069
00:56:34,000 --> 00:56:36,000
然后最终的结果就是我们现在看到的

1070
00:56:36,000 --> 00:56:38,000
他这次发布了一个重量级的产品

1071
00:56:38,000 --> 00:56:39,000
叫做 react

1072
00:56:39,000 --> 00:56:40,000
一个工具吧

1073
00:56:40,000 --> 00:56:41,000
叫做 react native

1074
00:56:41,000 --> 00:56:42,000
呃什么意思呢

1075
00:56:42,000 --> 00:56:43,000
简单描述一下

1076
00:56:43,000 --> 00:56:46,000
就是说我还是用 java script 写我的应用

1077
00:56:46,000 --> 00:56:52,000
但是呃相比在网页上我是是是把它渲染成一个网页的那些呃

1078
00:56:52,000 --> 00:56:54,000
HTML 的这种嗯 tag 标签的话

1079
00:56:54,000 --> 00:56:59,000
我是直接用呃这个某一个平台原生的 UI 组件

1080
00:56:59,000 --> 00:57:02,000
比如说在 iOS 面就是一个原生的比如说这个列表

1081
00:57:02,000 --> 00:57:05,000
那个可以滚动的那种有带重力

1082
00:57:05,000 --> 00:57:09,000
不叫带什么加速度的惯性的那种呃滚动窗口

1083
00:57:09,000 --> 00:57:14,000
或者说是我用一个原生的这个地图这个组件来实现我的这个功能

1084
00:57:14,000 --> 00:57:18,000
那但是我的这个这个程序的实际的后台的所有的这个 model 啊

1085
00:57:18,000 --> 00:57:19,000
还有所有的数据啊

1086
00:57:19,000 --> 00:57:20,000
还有包括一些逻辑啊

1087
00:57:20,000 --> 00:57:22,000
都其实是在 java script 里面运行的

1088
00:57:22,000 --> 00:57:23,000
对

1089
00:57:23,000 --> 00:57:25,000
那这个我觉得是非常了不了不得的一个事情啊

1090
00:57:25,000 --> 00:57:26,000
就是说呃

1091
00:57:26,000 --> 00:57:29,000
我就知道很多这个 iOS 或者是安卓开发都在吐槽

1092
00:57:29,000 --> 00:57:31,000
这个开就在

1093
00:57:31,000 --> 00:57:35,000
其实哪怕是现在应该开发一个 iOS 应用或者安卓应用

1094
00:57:35,000 --> 00:57:37,000
都还不是那么爽的一件事情啊

1095
00:57:37,000 --> 00:57:39,000
它有点像那个在 backbond 时代的

1096
00:57:39,000 --> 00:57:43,000
有一点像在 backbond 时代的开发 web app 的感觉

1097
00:57:43,000 --> 00:57:49,000
对我觉得对我来讲最重要的概念在 react 的 native 中最重要的概念是

1098
00:57:49,000 --> 00:57:51,000
啊 what Tom said

1099
00:57:51,000 --> 00:57:52,000
啊

1100
00:57:52,000 --> 00:57:55,000
learn once write everywhere

1101
00:57:55,000 --> 00:57:59,000
react 的 native 它并不是要你 write once run everywhere

1102
00:57:59,000 --> 00:58:01,000
它没有它没有

1103
00:58:01,000 --> 00:58:07,000
react 的 native 本身它没有 merge the gap between android and ios

1104
00:58:07,000 --> 00:58:09,000
android 还是要写 android app

1105
00:58:09,000 --> 00:58:11,000
iOS 还是要写 iOS app

1106
00:58:11,000 --> 00:58:15,000
但是你写程序的方式发生了根本的变化

1107
00:58:15,000 --> 00:58:19,000
不管是写 web app 好还是写 android app 好还是写 iOS app 好

1108
00:58:19,000 --> 00:58:23,000
你会用 exactly the same way

1109
00:58:23,000 --> 00:58:25,000
来写这三个不同的啊

1110
00:58:25,000 --> 00:58:27,000
环境下的 application

1111
00:58:27,000 --> 00:58:31,000
只是你你你会用这个这个环境的对

1112
00:58:31,000 --> 00:58:33,000
不同的组件嘛

1113
00:58:33,000 --> 00:58:35,000
这这一点上是非常非常有意义的啊

1114
00:58:35,000 --> 00:58:39,000
我本人对自己是深有感触

1115
00:58:39,000 --> 00:58:43,000
因为啊我之前有写一个 iOS app 啊

1116
00:58:43,000 --> 00:58:45,000
我不是 word font

1117
00:58:45,000 --> 00:58:49,000
我现在还在写另外一个小小的小小的说一下

1118
00:58:49,000 --> 00:58:51,000
我又在写另外一个 iOS app

1119
00:58:51,000 --> 00:58:53,000
然后其中有很多的 layouting

1120
00:58:53,000 --> 00:58:54,000
嗯

1121
00:58:54,000 --> 00:58:56,000
其实上是一个逻辑上来讲是一个比较简单的 app

1122
00:58:56,000 --> 00:58:57,000
但是有很多 layouting

1123
00:58:57,000 --> 00:58:59,000
啊我有一个 UI label

1124
00:58:59,000 --> 00:59:02,000
这个 UI label 是可变的长度

1125
00:59:02,000 --> 00:59:03,000
然后这个 UI label 呢

1126
00:59:03,000 --> 00:59:04,000
又在那个啊

1127
00:59:04,000 --> 00:59:08,000
一个可变长度的 UI table sale 中

1128
00:59:08,000 --> 00:59:10,000
啊就是实际上

1129
00:59:10,000 --> 00:59:12,000
如果你想用 auto layout

1130
00:59:12,000 --> 00:59:14,000
的话就是一个非常非常麻烦的事情

1131
00:59:14,000 --> 00:59:16,000
因为在 UI label

1132
00:59:16,000 --> 00:59:17,000
第一次 render 的时候

1133
00:59:17,000 --> 00:59:19,000
它并不知道它的宽度

1134
00:59:19,000 --> 00:59:20,000
它如果它不知道它的宽度呢

1135
00:59:20,000 --> 00:59:22,000
它就不知道它的高度

1136
00:59:22,000 --> 00:59:23,000
它不知道它的高度呢

1137
00:59:23,000 --> 00:59:24,000
它就乱 render

1138
00:59:24,000 --> 00:59:26,000
啊你就得啊

1139
00:59:26,000 --> 00:59:27,000
啊

1140
00:59:27,000 --> 00:59:29,000
out the layout 呢是你的 all about constraints

1141
00:59:29,000 --> 00:59:30,000
对不对

1142
00:59:30,000 --> 00:59:32,000
所以你需要设计一系列的 constraint

1143
00:59:32,000 --> 00:59:33,000
然后这个啊

1144
00:59:33,000 --> 00:59:34,000
layout engine

1145
00:59:34,000 --> 00:59:36,000
会来猜测怎么样的结果

1146
00:59:36,000 --> 00:59:39,000
能够满足你所有的 constraint

1147
00:59:39,000 --> 00:59:40,000
或者尽量满足你的 constraint

1148
00:59:40,000 --> 00:59:42,000
这是个非常 non-tunative 的 way

1149
00:59:42,000 --> 00:59:45,000
然后从 web 的角度来说的话

1150
00:59:45,000 --> 00:59:47,000
box model 多多简单啊

1151
00:59:47,000 --> 00:59:49,000
虽然说 box model 有时候不工作

1152
00:59:49,000 --> 00:59:50,000
但是多简单啊你知道

1153
00:59:50,000 --> 00:59:51,000
就是所有的东西就是 box model

1154
00:59:51,000 --> 00:59:53,000
就是所有的东西就是 box top box box

1155
00:59:53,000 --> 00:59:54,000
box 在 box 之上

1156
00:59:54,000 --> 00:59:56,000
然后你有 margin

1157
00:59:56,000 --> 00:59:57,000
你有 padding

1158
00:59:57,000 --> 00:59:58,000
你有 border

1159
00:59:58,000 --> 01:00:00,000
这个非常非常容易理解

1160
01:00:00,000 --> 01:00:05,000
非常直观的直观的一种模式

1161
01:00:05,000 --> 01:00:07,000
反观叫 iOS

1162
01:00:07,000 --> 01:00:09,000
如果你不用 out-allel

1163
01:00:09,000 --> 01:00:10,000
就是 constraint 非常难以理解

1164
01:00:10,000 --> 01:00:13,000
然后你那个结果也不 intuitive

1165
01:00:13,000 --> 01:00:15,000
你如果只给我一系列的 constraint

1166
01:00:15,000 --> 01:00:18,000
如果你不告诉我结果的话

1167
01:00:18,000 --> 01:00:21,000
我很难说我很有信心说这些 constraint

1168
01:00:21,000 --> 01:00:22,000
会得到我想要的结果

1169
01:00:24,000 --> 01:00:28,000
我觉得可能最重大的一个差别就是 constraint based layout

1170
01:00:28,000 --> 01:00:35,000
要求你能够在头脑中维护一个最终视觉效果的模型

1171
01:00:35,000 --> 01:00:41,000
而 box model 对此要求就低一点或者低很多吧应该说

1172
01:00:41,000 --> 01:00:43,000
如果你不用 out-layout 的话呢

1173
01:00:43,000 --> 01:00:47,000
你又得就是 manually 去做很多的 math

1174
01:00:47,000 --> 01:00:50,000
如果你看那个 Christopher 的 slides

1175
01:00:50,000 --> 01:00:53,000
他有一张全都是 math math math

1176
01:00:53,000 --> 01:00:54,000
exactly right right

1177
01:00:54,000 --> 01:00:57,000
但倒也不是说有多难多容易

1178
01:00:57,000 --> 01:00:59,000
很多那个 IOS cover 就跟我说那不难

1179
01:00:59,000 --> 01:01:01,000
但是那 ugly 啊多丑陋啊我靠

1180
01:01:01,000 --> 01:01:05,000
然后你想要改一点什么东西的话

1181
01:01:05,000 --> 01:01:06,000
又回头得去算

1182
01:01:06,000 --> 01:01:09,000
然后哦妈呀真的是真可怕

1183
01:01:09,000 --> 01:01:10,000
对吧

1184
01:01:11,000 --> 01:01:12,000
react native

1185
01:01:13,000 --> 01:01:16,000
所以我觉得其实他们这次做的那个就是他们发布的 react native

1186
01:01:16,000 --> 01:01:17,000
他们也解决了这个问题

1187
01:01:17,000 --> 01:01:24,000
他们用 javascript 实现了一套那个 css 最新的那个叫做 flexbox 的 box model

1188
01:01:25,000 --> 01:01:26,000
对

1189
01:01:26,000 --> 01:01:30,000
然后他们用那个模型就去解决了这个在去怎么去布局那些原生的

1190
01:01:30,000 --> 01:01:32,000
那些原生的 UI 组件的问题

1191
01:01:32,000 --> 01:01:34,000
这个我觉得就刚才那个 Villow 也已经

1192
01:01:34,000 --> 01:01:35,000
大家相信已经听出来

1193
01:01:35,000 --> 01:01:38,000
Villow 对这个什么 constrained layout

1194
01:01:38,000 --> 01:01:39,000
auto layout 这东西已经吐槽很久了

1195
01:01:39,000 --> 01:01:42,000
其实就从某一个音箱上讲

1196
01:01:42,000 --> 01:01:44,000
那个什么 constrained based layout 的话

1197
01:01:44,000 --> 01:01:47,000
其实它是要你在你头脑中构建一个这个

1198
01:01:47,000 --> 01:01:49,000
就是这个就是什么动态规划机

1199
01:01:50,000 --> 01:01:53,000
对吧你得自己在头脑中随时解那个方程

1200
01:01:53,000 --> 01:01:55,000
解完之后才说这个会出现在那里

1201
01:01:55,000 --> 01:01:56,000
这个会出现在那里

1202
01:01:56,000 --> 01:01:58,000
嗯嗯就不像那个 box model

1203
01:01:58,000 --> 01:02:01,000
它的更加反映出是一个比较直观的话

1204
01:02:01,000 --> 01:02:02,000
这个应该是多大

1205
01:02:02,000 --> 01:02:03,000
它应该有多宽

1206
01:02:03,000 --> 01:02:05,000
然后它多到一个一个一个边框

1207
01:02:05,000 --> 01:02:07,000
是就那个什么 margin

1208
01:02:07,000 --> 01:02:08,000
东西叫什么来的

1209
01:02:08,000 --> 01:02:09,000
留白对吧

1210
01:02:09,000 --> 01:02:10,000
留白要多少

1211
01:02:10,000 --> 01:02:12,000
或者是跟其他的东西间距要多少

1212
01:02:12,000 --> 01:02:14,000
我这个确实是 css

1213
01:02:14,000 --> 01:02:17,000
就是这个比较好的解决的一个地方

1214
01:02:17,000 --> 01:02:18,000
就我很好奇

1215
01:02:18,000 --> 01:02:20,000
为什么像 iOS

1216
01:02:20,000 --> 01:02:24,000
Android 之前它没有用到这种同样的模型去做这个事情

1217
01:02:25,000 --> 01:02:26,000
这是一个很好问题

1218
01:02:26,000 --> 01:02:30,000
其实这个可以将来专门找一期谈这个

1219
01:02:30,000 --> 01:02:35,000
就是为什么 box model 这种看起来如此简单一行

1220
01:02:35,000 --> 01:02:41,000
又有大量解放生产力的布局

1221
01:02:41,000 --> 01:02:43,000
仅仅在 web 领域独树一帜

1222
01:02:43,000 --> 01:02:48,000
就甚至很多比如说排版软件都完全不去考虑这种

1223
01:02:48,000 --> 01:02:49,000
这种

1224
01:02:49,000 --> 01:02:50,000
嗯

1225
01:02:50,000 --> 01:02:52,000
但我觉得可能还是惯性在里面吧

1226
01:02:52,000 --> 01:02:53,000
对

1227
01:02:53,000 --> 01:02:55,000
这个是挺挺奇怪的

1228
01:02:55,000 --> 01:02:57,000
比如说你说 iOS 为什么不用它

1229
01:02:57,000 --> 01:02:59,000
iOS 不用它是因为 OS 10 不用它

1230
01:02:59,000 --> 01:03:00,000
嗯

1231
01:03:00,000 --> 01:03:01,000
嗯

1232
01:03:01,000 --> 01:03:04,000
iOS 毕竟一开始只是 OS 10 一个改版嘛

1233
01:03:04,000 --> 01:03:05,000
就

1234
01:03:05,000 --> 01:03:07,000
就 Mac 上的 app 不可能

1235
01:03:07,000 --> 01:03:10,000
从来没有用过 box layout

1236
01:03:10,000 --> 01:03:11,000
所以

1237
01:03:11,000 --> 01:03:12,000
对

1238
01:03:12,000 --> 01:03:13,000
iOS 上面也就不用了

1239
01:03:14,000 --> 01:03:16,000
就这次这个 react native 它发布

1240
01:03:16,000 --> 01:03:17,000
我觉得还有一点

1241
01:03:17,000 --> 01:03:19,000
我觉得特别特别特别

1242
01:03:19,000 --> 01:03:20,000
就是说

1243
01:03:20,000 --> 01:03:23,000
就令人觉得比较惊奇的一点

1244
01:03:23,000 --> 01:03:27,000
就是它因为那个整个这个程序的逻辑和这些

1245
01:03:27,000 --> 01:03:30,000
呃程序的逻辑和这些啊

1246
01:03:30,000 --> 01:03:31,000
包括这个呃

1247
01:03:31,000 --> 01:03:32,000
model 啊

1248
01:03:32,000 --> 01:03:34,000
都是在 javascript 里面实现的嘛

1249
01:03:34,000 --> 01:03:36,000
然后这个 javascript 它是依赖于一个

1250
01:03:36,000 --> 01:03:38,000
就所谓解析器或者是 javascript 引擎的嘛

1251
01:03:38,000 --> 01:03:39,000
对

1252
01:03:39,000 --> 01:03:42,000
然后这个引擎可以不用跑在那个手机上面

1253
01:03:42,000 --> 01:03:45,000
它可以跑在他们在现场 demo 的时候

1254
01:03:45,000 --> 01:03:47,000
它那个解析器是跑在浏览器里面的

1255
01:03:47,000 --> 01:03:52,000
然后它可以在就是在 chrome 里面去改那个浏览器

1256
01:03:52,000 --> 01:03:54,000
然后基石从刷新一下

1257
01:03:54,000 --> 01:03:56,000
然后这个在那个 iOS 的 iPhone

1258
01:03:56,000 --> 01:03:58,000
就是 iPhone 模拟器里面

1259
01:03:58,000 --> 01:04:03,000
那个对应的一个原生的 UI 的那个那个界面

1260
01:04:03,000 --> 01:04:04,000
就随之发生改变了

1261
01:04:04,000 --> 01:04:05,000
我觉得这个非常非常了不得

1262
01:04:05,000 --> 01:04:10,000
这个在实际的 production 中是不可能就是很难实现的

1263
01:04:10,000 --> 01:04:11,000
啊

1264
01:04:11,000 --> 01:04:14,000
但是这反映了就是说啊

1265
01:04:14,000 --> 01:04:16,000
react 它 native 到底是怎么样实现

1266
01:04:16,000 --> 01:04:19,000
从 javascript 到 native 的这个转换啊

1267
01:04:19,000 --> 01:04:20,000
嗯

1268
01:04:20,000 --> 01:04:23,000
react native 不想要成为一个性能瓶颈

1269
01:04:23,000 --> 01:04:25,000
of course not right

1270
01:04:25,000 --> 01:04:26,000
所以它的实现方式就是在啊

1271
01:04:26,000 --> 01:04:28,000
所以它的实现方式就是在啊

1272
01:04:28,000 --> 01:04:32,000
把 javascript 这个引擎放到单独的啊

1273
01:04:32,000 --> 01:04:36,000
background thread 中一个一个单独它自己一个单独的线程中啊

1274
01:04:36,000 --> 01:04:38,000
然后在这个线程中有一个啊

1275
01:04:38,000 --> 01:04:40,000
javascript 的引擎在啊不断的啊

1276
01:04:40,000 --> 01:04:42,000
啊

1277
01:04:42,000 --> 01:04:43,000
啊

1278
01:04:43,000 --> 01:04:44,000
啊

1279
01:04:44,000 --> 01:04:45,000
渲染

1280
01:04:45,000 --> 01:04:46,000
然后得到结果

1281
01:04:46,000 --> 01:04:48,000
再通过 channel 的方式

1282
01:04:48,000 --> 01:04:49,000
把这个呃

1283
01:04:49,000 --> 01:04:53,000
渲染结果发回到那个你的主线程中

1284
01:04:53,000 --> 01:04:55,000
所以你的主线程是没有被 block

1285
01:04:55,000 --> 01:04:56,000
你随时

1286
01:04:56,000 --> 01:05:00,000
这个结果就是说你的主线程总是很 smooth

1287
01:05:00,000 --> 01:05:01,000
反观

1288
01:05:01,000 --> 01:05:03,000
如果你用一个 webview 的啊

1289
01:05:03,000 --> 01:05:04,000
啊

1290
01:05:04,000 --> 01:05:07,000
一个一个解决方式到先不说就是你你不能够用 native component

1291
01:05:07,000 --> 01:05:10,000
这种这种极大的问题啊

1292
01:05:10,000 --> 01:05:11,000
啊

1293
01:05:11,000 --> 01:05:14,000
关键是说你的 javascript 是会 block 你的主线程的

1294
01:05:14,000 --> 01:05:16,000
所以说如果你 javascript 在做一些啊

1295
01:05:16,000 --> 01:05:18,000
大量的运算的时候

1296
01:05:18,000 --> 01:05:19,000
那个啊

1297
01:05:19,000 --> 01:05:21,000
用户如果在比方说在在在在在

1298
01:05:21,000 --> 01:05:23,000
向下滑那个页面

1299
01:05:23,000 --> 01:05:24,000
那个页面就会不动吗

1300
01:05:24,000 --> 01:05:26,000
就所以那个页面就不 smooth 吗

1301
01:05:26,000 --> 01:05:31,000
你整个的那个体验就就很不易就就很不乐观了

1302
01:05:31,000 --> 01:05:33,000
所以 react

1303
01:05:33,000 --> 01:05:35,000
既让你 react native

1304
01:05:35,000 --> 01:05:38,000
就让你使用 native component

1305
01:05:38,000 --> 01:05:40,000
有 native 的 experience

1306
01:05:40,000 --> 01:05:43,000
也从性能上帮助你啊

1307
01:05:43,000 --> 01:05:44,000
呃

1308
01:05:44,000 --> 01:05:45,000
呃

1309
01:05:45,000 --> 01:05:46,000
不要啊

1310
01:05:46,000 --> 01:05:48,000
就是提供不好的体验

1311
01:05:48,000 --> 01:05:50,000
就他把这个啊

1312
01:05:50,000 --> 01:05:51,000
啊

1313
01:05:51,000 --> 01:05:52,000
这个啊

1314
01:05:52,000 --> 01:05:53,000
UI 的渲染和这个逻辑的

1315
01:05:53,000 --> 01:05:56,000
就是这业务逻辑的执行是完全隔裂开了

1316
01:05:56,000 --> 01:05:59,000
通过异部的方式进行通讯同步的嘛

1317
01:05:59,000 --> 01:06:00,000
啊

1318
01:06:00,000 --> 01:06:02,000
这个是我觉得非常非常好的一件事情啊

1319
01:06:02,000 --> 01:06:05,000
但是这就牵涉到另外一个问题了

1320
01:06:05,000 --> 01:06:07,000
就他这样的话对这个后台的那个执行

1321
01:06:07,000 --> 01:06:11,000
JavaScript 解析器的那个进程的性能会有要求吗

1322
01:06:11,000 --> 01:06:12,000
比如说据我所知

1323
01:06:12,000 --> 01:06:13,000
比如说据我所知

1324
01:06:13,000 --> 01:06:14,000
在呃

1325
01:06:14,000 --> 01:06:15,000
IOS 上面这个

1326
01:06:15,000 --> 01:06:19,000
这个你单独自己跑一个 JavaScript 的这个解析器的话

1327
01:06:19,000 --> 01:06:21,000
是没有那个他们那个叫什么来的

1328
01:06:21,000 --> 01:06:22,000
那个啊

1329
01:06:22,000 --> 01:06:23,000
JIT 的优化

1330
01:06:23,000 --> 01:06:24,000
呃

1331
01:06:24,000 --> 01:06:29,000
这一点上我并不是特别清楚他们主要实现方式

1332
01:06:29,000 --> 01:06:31,000
但是有一点很重要的是

1333
01:06:31,000 --> 01:06:32,000
嗯

1334
01:06:32,000 --> 01:06:33,000
你刚刚说的那个问题

1335
01:06:33,000 --> 01:06:36,000
只只有在你直接使用呃

1336
01:06:36,000 --> 01:06:39,000
webview 的情况下才会出现

1337
01:06:39,000 --> 01:06:40,000
嗯

1338
01:06:40,000 --> 01:06:41,000
为什么

1339
01:06:41,000 --> 01:06:43,000
因为那个 engine 是在那个 webview 里头啊

1340
01:06:43,000 --> 01:06:46,000
但是他们的那个 react 的实现方式是

1341
01:06:46,000 --> 01:06:48,000
并不代表说他一定要用那个呃

1342
01:06:48,000 --> 01:06:49,000
JavaScript engine

1343
01:06:49,000 --> 01:06:52,000
他可以自己包装一个其他的呃

1344
01:06:52,000 --> 01:06:54,000
呃 JS engine 在里头

1345
01:06:54,000 --> 01:06:58,000
就是他可以说我不用苹果那个 IOS 自带的那个

1346
01:06:58,000 --> 01:06:59,000
那个 JavaScript engine

1347
01:06:59,000 --> 01:07:02,000
然后就是然后我自己包一个带 JIT 的这个

1348
01:07:02,000 --> 01:07:04,000
这个 JS 解析器进去这样执行吗

1349
01:07:04,000 --> 01:07:05,000
没错

1350
01:07:05,000 --> 01:07:06,000
OK

1351
01:07:06,000 --> 01:07:10,000
那这样不会就会撞到那个 app store 的审核条例的

1352
01:07:10,000 --> 01:07:13,000
那某一条说不能自带解析器吗

1353
01:07:13,000 --> 01:07:14,000
真的吗

1354
01:07:14,000 --> 01:07:15,000
嗯

1355
01:07:15,000 --> 01:07:16,000
有这么一条的曾经

1356
01:07:16,000 --> 01:07:18,000
我记得后来就

1357
01:07:18,000 --> 01:07:21,000
那条苹果条例我记得我还写过 blog

1358
01:07:21,000 --> 01:07:24,000
就说他只能用规定的其中语言来写

1359
01:07:24,000 --> 01:07:27,000
但好像没有说不能自带虚拟机吧

1360
01:07:27,000 --> 01:07:31,000
不然那些什么带络瓦的东西是怎么被生了通过

1361
01:07:31,000 --> 01:07:33,000
对这就是一个挺模糊的一点

1362
01:07:33,000 --> 01:07:34,000
就是后来因为很多游戏

1363
01:07:34,000 --> 01:07:37,000
他需要用那个录尔解析器做一些辅助的事情嘛

1364
01:07:37,000 --> 01:07:39,000
所以他就后来又通过

1365
01:07:39,000 --> 01:07:42,000
现在我要不太清楚苹果在对这件事情的这个

1366
01:07:42,000 --> 01:07:44,000
呃的立场是什么

1367
01:07:44,000 --> 01:07:47,000
但是这个只能在在意了吧

1368
01:07:47,000 --> 01:07:49,000
我可以 fact check 一下

1369
01:07:49,000 --> 01:07:50,000
因为我有那个啊

1370
01:07:50,000 --> 01:07:53,000
他们把那个呃

1371
01:07:53,000 --> 01:07:57,000
就是他的那个演示代码给所有的语会者都分享了一份

1372
01:07:57,000 --> 01:08:00,000
所以我是可以 fact check 去看他们到底有什么应勤的

1373
01:08:00,000 --> 01:08:05,000
OK 你可以看一下他用的是苹果原生的还是

1374
01:08:05,000 --> 01:08:07,000
就是那个叫什么 JavaScript Core 的

1375
01:08:07,000 --> 01:08:09,000
对对对 JavaScript Core

1376
01:08:09,000 --> 01:08:10,000
我理解应该是吧

1377
01:08:10,000 --> 01:08:13,000
今天这个是个成本比较低的方案嘛

1378
01:08:13,000 --> 01:08:14,000
你不用自己做任何事情

1379
01:08:15,000 --> 01:08:19,000
而且如果每个应用都要自己带一个 JavaScript 解析器的话

1380
01:08:19,000 --> 01:08:21,000
那个应用的尺寸也会比较大

1381
01:08:21,000 --> 01:08:22,000
嗯

1382
01:08:22,000 --> 01:08:24,000
这是一个问题我觉得

1383
01:08:24,000 --> 01:08:25,000
好

1384
01:08:25,000 --> 01:08:26,000
啊

1385
01:08:26,000 --> 01:08:28,000
就是其实现在用那个 react native

1386
01:08:28,000 --> 01:08:31,000
其实有已经有一个 app 的一个典范

1387
01:08:31,000 --> 01:08:34,000
就在 iOS 这个 app store 里面

1388
01:08:34,000 --> 01:08:36,000
Facebook 一个叫做新的应用叫做 groups

1389
01:08:36,000 --> 01:08:39,000
就是 Facebook 群组的这个这个单独的一个应用

1390
01:08:39,000 --> 01:08:42,000
它其实是在很大程度上用的这个 react native 写的

1391
01:08:42,000 --> 01:08:43,000
嗯

1392
01:08:43,000 --> 01:08:47,000
然后我之前我在知道它是用 react native 之前

1393
01:08:47,000 --> 01:08:49,000
我就已经下载用过它

1394
01:08:49,000 --> 01:08:52,000
当时我完全没有感觉到它不是一个 native 的软件

1395
01:08:52,000 --> 01:08:55,000
就是非常就整个体验是非常好的

1396
01:08:55,000 --> 01:09:00,000
问题是我们并不是很清楚说它到底哪一部分是 UI 的那个

1397
01:09:00,000 --> 01:09:02,000
就是多少比例是用的

1398
01:09:02,000 --> 01:09:05,000
对或许正是这个好处所在

1399
01:09:05,000 --> 01:09:07,000
你知道用户如果说他他都他都会用的

1400
01:09:07,000 --> 01:09:11,000
你不知道哪一部分的他都感受不出来

1401
01:09:11,000 --> 01:09:13,000
那就证明这个东西说不定就成功了

1402
01:09:13,000 --> 01:09:14,000
对

1403
01:09:14,000 --> 01:09:15,000
对

1404
01:09:15,000 --> 01:09:19,000
我们所拿就是与会者所拿到的这个版本

1405
01:09:19,000 --> 01:09:23,000
跟 Facebook 他所用的版本实际上是不同步的

1406
01:09:23,000 --> 01:09:28,000
Facebook 他还在做很多的工作来把这个东西给完善

1407
01:09:28,000 --> 01:09:32,000
然后才会正式的向大众发布

1408
01:09:32,000 --> 01:09:35,000
目前来说的话我们所看到的版本都是一个

1409
01:09:35,000 --> 01:09:37,000
就是一个就是一个

1410
01:09:37,000 --> 01:09:39,000
啊 tech preview kind of thing

1411
01:09:41,000 --> 01:09:43,000
啊 ok 明白

1412
01:09:43,000 --> 01:09:44,000
嗯

1413
01:09:44,000 --> 01:09:47,000
就是说原来那些刚才你也提到他们的口号是叫做

1414
01:09:47,000 --> 01:09:49,000
Learn once write everywhere

1415
01:09:49,000 --> 01:09:51,000
然后我其实我也在想

1416
01:09:51,000 --> 01:09:53,000
如果你按这种方式去构建你的 app 之后

1417
01:09:53,000 --> 01:09:59,000
其实还是可以有蛮多部件是可以在各平台间重用的哈

1418
01:09:59,000 --> 01:10:03,000
比如说之前啊我应该是在前期还是上前期的时候

1419
01:10:03,000 --> 01:10:07,000
我们在讨论过啊那个 google 不是做的那个叫 inbox 那个 app 吗

1420
01:10:07,000 --> 01:10:11,000
就是新的它是有安卓版有 is 版

1421
01:10:11,000 --> 01:10:15,000
然后还有一个这个 chrome 只有 chrome 的软件可以用的 web 版嘛

1422
01:10:15,000 --> 01:10:19,000
然后他们后来发了一篇博客文章去讲他们怎么去做这么一件事

1423
01:10:19,000 --> 01:10:22,000
就是他们把这个假设你把这个整个应用分成两部分

1424
01:10:22,000 --> 01:10:25,000
一对是前端就跟那个用户交后的那部分

1425
01:10:25,000 --> 01:10:28,000
那么这部分就是说在 lsm 就是 objectc 写的

1426
01:10:28,000 --> 01:10:31,000
然后在安卓上就是用那个 java 写的

1427
01:10:31,000 --> 01:10:35,000
然后在这个 web 上就是 javascript 写的

1428
01:10:35,000 --> 01:10:37,000
但是他们其实都是用 java 写的

1429
01:10:37,000 --> 01:10:39,000
然后通过 gwt 转化成 javascript

1430
01:10:39,000 --> 01:10:44,000
然后通过一个叫做 j 2 objectc 的一个工具转化成 objectc 代码来做

1431
01:10:44,000 --> 01:10:50,000
不做那个逻辑的那一部分就是跟原生界面无关

1432
01:10:50,000 --> 01:10:53,000
但是是跟这个后台的事物逻辑相关的

1433
01:10:53,000 --> 01:10:54,000
就是同一套语言

1434
01:10:54,000 --> 01:10:57,000
然后再转化成不同的同用 java 写

1435
01:10:57,000 --> 01:11:00,000
然后通过这两种工具转化成对应的 javascript

1436
01:11:00,000 --> 01:11:01,000
或者 objectc

1437
01:11:01,000 --> 01:11:03,000
但如果我们用这个 reignative 来写的话

1438
01:11:03,000 --> 01:11:05,000
其实就这一步都可以省去了

1439
01:11:05,000 --> 01:11:11,000
我直接把所有的事物和逻辑都写成 javascript 就好了

1440
01:11:11,000 --> 01:11:13,000
对其实这让我想起那个

1441
01:11:13,000 --> 01:11:18,000
AppsEllerator 出的 Titanium

1442
01:11:18,000 --> 01:11:22,000
他也是用 javascript 来写整个所有的事物逻辑

1443
01:11:22,000 --> 01:11:28,000
但是其使用的那个 UI widget 全都是原生的

1444
01:11:28,000 --> 01:11:30,000
他那个体验怎么样呢

1445
01:11:30,000 --> 01:11:32,000
不是特别好

1446
01:11:32,000 --> 01:11:36,000
就因为前公司在做 web

1447
01:11:36,000 --> 01:11:40,000
在做 mobile app 的时候考虑过用 Titanium

1448
01:11:40,000 --> 01:11:43,000
可能当时最大的一个问题就是

1449
01:11:43,000 --> 01:11:47,000
首先那个时候正好是 iOS 6 升到 7 的过程中

1450
01:11:47,000 --> 01:11:53,000
然后他们大概是比 7 落后了可能 3 到 5 个月的时间

1451
01:11:53,000 --> 01:11:55,000
就是我觉得这个是不可忍受的

1452
01:11:55,000 --> 01:11:57,000
就新的 iOS 版本已经在那边了

1453
01:11:57,000 --> 01:11:59,000
然后你如果你用 Titanium 的话

1454
01:11:59,000 --> 01:12:01,000
你用不到新的那些 widgets

1455
01:12:01,000 --> 01:12:02,000
对

1456
01:12:02,000 --> 01:12:10,000
然后他们的那一套东西据说其实是非常优秀的

1457
01:12:10,000 --> 01:12:14,000
但是没有什么文档主要是

1458
01:12:14,000 --> 01:12:16,000
对

1459
01:12:16,000 --> 01:12:20,000
可能是用任何第三方平台或者这框架都会遇到的问题吧

1460
01:12:20,000 --> 01:12:21,000
对

1461
01:12:21,000 --> 01:12:23,000
据说 AppSelerator 还在搞

1462
01:12:23,000 --> 01:12:25,000
现在还在搞一些新的什么东西

1463
01:12:25,000 --> 01:12:27,000
但我一时也想不起来名字了

1464
01:12:28,000 --> 01:12:34,000
其大概的走向可能和 react 有点异曲同工的地方

1465
01:12:34,000 --> 01:12:35,000
我还要看一下

1466
01:12:36,000 --> 01:12:37,000
OK

1467
01:12:37,000 --> 01:12:39,000
那说回 react native 的这种方式

1468
01:12:39,000 --> 01:12:41,000
其实我还不是特别赞同他们说

1469
01:12:41,000 --> 01:12:44,000
完全不在乎 react once run anywhere

1470
01:12:44,000 --> 01:12:45,000
这么一个口号的话

1471
01:12:45,000 --> 01:12:49,000
就说起码你假设你看到像这些后台的逻辑

1472
01:12:49,000 --> 01:12:52,000
还有这些数据这些模型都可以用 JavaScript 构建

1473
01:12:52,000 --> 01:12:54,000
这一块是完全可以在各平台间重用

1474
01:12:54,000 --> 01:12:55,000
没错

1475
01:12:55,000 --> 01:13:00,000
而且我可以预见到肯定会有人做一个中间层

1476
01:13:00,000 --> 01:13:02,000
然后说用这些组件的话

1477
01:13:02,000 --> 01:13:06,000
这些组件可以就变成那个 environmental sensitive

1478
01:13:06,000 --> 01:13:09,000
然后他们会根据 environmental 来

1479
01:13:09,000 --> 01:13:11,000
就原生的组件

1480
01:13:11,000 --> 01:13:13,000
你可以用这个组件的 tab view

1481
01:13:13,000 --> 01:13:17,000
然后这个 tab view 背后的实现会根据

1482
01:13:17,000 --> 01:13:19,000
你的 target 是 Android 或 target

1483
01:13:19,000 --> 01:13:20,000
或 iOS

1484
01:13:20,000 --> 01:13:24,000
来自动选择相应平台的 tab view

1485
01:13:24,000 --> 01:13:28,000
这并不是 react native 自己本身的一个设计理念

1486
01:13:28,000 --> 01:13:35,000
react native 非常鼓励你去根据各种平台本身的特性

1487
01:13:35,000 --> 01:13:37,000
来设计不一样的 UI

1488
01:13:37,000 --> 01:13:40,000
来用不一样的 component

1489
01:13:40,000 --> 01:13:43,000
而不是像这样的简单的替换的逻辑

1490
01:13:43,000 --> 01:13:48,000
但是我想我们肯定会看到第三方的一些 solution 出来的

1491
01:13:50,000 --> 01:13:54,000
对我觉得这个就是很多像什么企业之软件可能会采取这种方式

1492
01:13:54,000 --> 01:14:00,000
因为他没有那么多的资源或者说是人手去优化每一个平台的细节的体验

1493
01:14:00,000 --> 01:14:03,000
那么更加就是节省成本的

1494
01:14:03,000 --> 01:14:07,000
节省开发时间的一个方式就是通过这种什么中间层去转换一下

1495
01:14:07,000 --> 01:14:08,000
我觉得

1496
01:14:08,000 --> 01:14:09,000
嗯

1497
01:14:09,000 --> 01:14:12,000
就虽然体验不是太好但是起码成本下去了

1498
01:14:12,000 --> 01:14:15,000
我觉得这个对很多企业软件来讲就是这样的一个一个诉求

1499
01:14:15,000 --> 01:14:16,000
没错

1500
01:14:16,000 --> 01:14:17,000
嗯

1501
01:14:17,000 --> 01:14:29,000
就我们现在等于说如果 react native 这一套能够吸引到一部分人去把它炒起来的话

1502
01:14:29,000 --> 01:14:35,000
那可以说企业集跨平台应用开发又多了一个新的选择

1503
01:14:35,000 --> 01:14:37,000
对啊

1504
01:14:37,000 --> 01:14:38,000
从 java 变成 javascript

1505
01:14:38,000 --> 01:14:42,000
我有跟我们的 developer 所讨论这个问题

1506
01:14:42,000 --> 01:14:49,000
他并不单是在 solution 上就是 tech solution 上有改变你的组织架构

1507
01:14:49,000 --> 01:14:55,000
而关键是说如果你想这个如果你真的实现 learn once write everywhere 的话

1508
01:14:55,000 --> 01:15:03,000
那所谓 web developer 跟 mobile developer 之间的界线就变得更模糊了

1509
01:15:03,000 --> 01:15:06,000
我觉得对于可能是二合一

1510
01:15:06,000 --> 01:15:12,000
对这个资源的对这个企业资源的一个运用实际上是一个非常有意思的事情

1511
01:15:12,000 --> 01:15:18,000
就要所以你知道我们的比方说如果现在 web application 不需要太多维护的话

1512
01:15:18,000 --> 01:15:23,000
那这时你就可以去写那个 android app 去写 iOS app 对不对

1513
01:15:23,000 --> 01:15:26,000
所以这一点上对于企业来说肯定是一个非常重要的事情

1514
01:15:26,000 --> 01:15:35,000
所以我也有跟我们的 web developer 开玩笑说那你现在得赶紧去学 HML CSS

1515
01:15:35,000 --> 01:15:37,000
对赶紧去赶紧开始学哦

1516
01:15:37,000 --> 01:15:45,000
他现在那个 react native 这个是还是在什么 alpha 阶段

1517
01:15:45,000 --> 01:15:50,000
可能是 pre alpha 阶段他们现在是说有一个私有的 github 的 reposter

1518
01:15:50,000 --> 01:15:52,000
你们可以访问就与会者可以访问吗

1519
01:15:52,000 --> 01:15:54,000
外界还没有公开

1520
01:15:54,000 --> 01:15:56,000
我不知道你看了多少

1521
01:15:56,000 --> 01:16:00,000
但是我就比较好奇他怎么去实现他这个就是

1522
01:16:00,000 --> 01:16:07,000
Gyroscript 那部分的业务代码业务逻辑怎么去和原生的那些进行交互那块

1523
01:16:07,000 --> 01:16:12,000
我没有还来还没有来得及对这个代码本身做很多的研究

1524
01:16:12,000 --> 01:16:15,000
但是对 developer 来说的话

1525
01:16:15,000 --> 01:16:20,000
你所做的事情真的跟以前写那个 web application 没有太大的区别

1526
01:16:20,000 --> 01:16:21,000
我可以把流程说一下

1527
01:16:21,000 --> 01:16:26,000
就是说从那个纯粹的开发者的这个角度来说的话

1528
01:16:26,000 --> 01:16:28,000
你 clone 这个 repository

1529
01:16:28,000 --> 01:16:32,000
然后你做 npm install

1530
01:16:32,000 --> 01:16:34,000
在就是就是传统的 javascript

1531
01:16:34,000 --> 01:16:38,000
你知道大家都对然后你是说 npm start

1532
01:16:38,000 --> 01:16:45,000
oknpm start 的理由原因是现在是在一个 dev environment 里头

1533
01:16:45,000 --> 01:16:51,000
你这些 javascript 的文件需要 serve 到那个 simulator 里头去对不对

1534
01:16:51,000 --> 01:16:53,000
那个 iOS simulator 里头去

1535
01:16:53,000 --> 01:17:00,000
所以这个 npm start 就会启动一个这样的 server

1536
01:17:00,000 --> 01:17:02,000
然后 watch 你的那些文件

1537
01:17:02,000 --> 01:17:05,000
然后你如果去看那些文件的话呢

1538
01:17:05,000 --> 01:17:12,000
实际上跟你写 react 的那个 web 方 web 的那个 application

1539
01:17:12,000 --> 01:17:13,000
并没有太大的区别

1540
01:17:13,000 --> 01:17:18,000
如果真的要说最大的区别可能就是说你没有 css file 了

1541
01:17:18,000 --> 01:17:20,000
你所有的 file 都是 inline

1542
01:17:20,000 --> 01:17:21,000
所有的 style 都是 inline

1543
01:17:21,000 --> 01:17:22,000
这是最大的区别了

1544
01:17:22,000 --> 01:17:24,000
其他的东西都看起来非常的相似

1545
01:17:24,000 --> 01:17:25,000
对对对

1546
01:17:25,000 --> 01:17:28,000
然后你写的是真的是纯就是 common js 那种组件

1547
01:17:28,000 --> 01:17:38,000
最神奇的地方在于如果你看到那个 video 的话有这一点就是把这个在那个比方说如果你改变一下 css

1548
01:17:38,000 --> 01:17:43,000
那个 iOS 的 simulator 是直接可以得到这个结果的

1549
01:17:43,000 --> 01:17:45,000
你是不需要去 recompile 的

1550
01:17:45,000 --> 01:17:47,000
对对对对

1551
01:17:47,000 --> 01:17:54,000
他们有一个说法就是说要实现你在这边就是编辑器里面改一行代码

1552
01:17:54,000 --> 01:18:00,000
然后在 iOS 那个模拟器里面实现就是出现改动只需要不到一秒

1553
01:18:00,000 --> 01:18:05,000
对这个我觉得对开发效率非常大的提升

1554
01:18:05,000 --> 01:18:07,000
Library load 的时间级别

1555
01:18:07,000 --> 01:18:08,000
对对对对

1556
01:18:08,000 --> 01:18:13,000
Java 世界里面有个叫 Jrebo 也做类似的事情

1557
01:18:13,000 --> 01:18:18,000
这个我觉得看那个 demo 真的是挺酷炫的

1558
01:18:18,000 --> 01:18:24,000
不过你们觉得这样的话那不变成 JavaScript 变成一个什么通用能力

1559
01:18:24,000 --> 01:18:26,000
这已经是现实了

1560
01:18:26,000 --> 01:18:28,000
对啊

1561
01:18:28,000 --> 01:18:30,000
浏览器

1562
01:18:30,000 --> 01:18:31,000
你们觉得这是好事吗

1563
01:18:31,000 --> 01:18:35,000
已经有点是这个电脑上面的另一层电脑

1564
01:18:35,000 --> 01:18:39,000
对对这个浏览器那边我们就毫无疑问 JavaScript 已经是一个

1565
01:18:39,000 --> 01:18:41,000
如果它不是同样语言它至少是一个构建的基石

1566
01:18:41,000 --> 01:18:44,000
因为很多语言可以所谓 compile to JavaScript

1567
01:18:44,000 --> 01:18:47,000
对我觉得 JavaScript 其实就是现在的 c

1568
01:18:47,000 --> 01:18:49,000
就现在的浏览器

1569
01:18:49,000 --> 01:18:52,000
现在的浏览器就是当初的 pdp 11 之类的

1570
01:18:52,000 --> 01:18:59,000
然后 c 语言本来是多设计的多么粗糙的一个语言

1571
01:18:59,000 --> 01:19:04,000
但就是因为时事造英雄把它推的推到了现在的霸主地位

1572
01:19:04,000 --> 01:19:06,000
我觉得 JavaScript 基本上就是另外一个司意

1573
01:19:06,000 --> 01:19:07,000
对啊

1574
01:19:07,000 --> 01:19:09,000
但是现在 RealityNative 它要做的事情就是说

1575
01:19:09,000 --> 01:19:12,000
把这件事情再往这个就是 mobile

1576
01:19:12,000 --> 01:19:13,000
就移动端再推

1577
01:19:13,000 --> 01:19:15,000
因为之前移动端大家还是在

1578
01:19:15,000 --> 01:19:20,000
就至少我们是鼓励或者消费者也愿意使用所谓的原生的应用

1579
01:19:20,000 --> 01:19:24,000
但这个原生打引号就可能说说你要用这个平台自己的那种工具

1580
01:19:24,000 --> 01:19:25,000
要自己的语言来写

1581
01:19:25,000 --> 01:19:30,000
但现在你来看 RealityNative 它能够把这个整个效果做的这么跟原生

1582
01:19:30,000 --> 01:19:32,000
就是说以假乱真至少是

1583
01:19:32,000 --> 01:19:36,000
那就完全没有必要再用平台原生的语言来写了

1584
01:19:36,000 --> 01:19:39,000
就好像说我是现在是一个 web developer

1585
01:19:39,000 --> 01:19:41,000
那我也可以做 iOS 应用

1586
01:19:41,000 --> 01:19:43,000
不需要学这么 object c 或者 swift

1587
01:19:43,000 --> 01:19:44,000
对啊

1588
01:19:44,000 --> 01:19:48,000
这就好像把 c 语言移植到不同的架构的处理器上了

1589
01:19:48,000 --> 01:19:55,000
我觉得吴涛刚刚说的很好就是这怎么说就是既定事实

1590
01:19:55,000 --> 01:19:59,000
JavaScript 的应用就是既定事实

1591
01:19:59,000 --> 01:20:01,000
所以我很期待 ES 6 和 ES 7

1592
01:20:01,000 --> 01:20:06,000
因为这个语言本身还是有非常非常多的问题的

1593
01:20:06,000 --> 01:20:09,000
特别是它的 prototype 这样一个架构

1594
01:20:09,000 --> 01:20:11,000
而不是 class based

1595
01:20:11,000 --> 01:20:12,000
嗯

1596
01:20:12,000 --> 01:20:13,000
I'm here's 6 is 7

1597
01:20:13,000 --> 01:20:15,000
我很期待他们把这些问题解决好

1598
01:20:15,000 --> 01:20:19,000
这样的话对于我们这些语言的使用者来说是一个非常好的事情

1599
01:20:19,000 --> 01:20:20,000
因为啊

1600
01:20:21,000 --> 01:20:24,000
啊作为一个 web dev 你经常不喜欢 prototype based

1601
01:20:24,000 --> 01:20:34,000
而是说啊在真正的应用上面我们很多时候都是在啊用 prototype 去 simulate class

1602
01:20:34,000 --> 01:20:36,000
因为没有 native class support 嘛

1603
01:20:36,000 --> 01:20:38,000
这是我所不喜欢的一点

1604
01:20:38,000 --> 01:20:42,000
不是说 prototype 本身啊在 ES 6 加入真正的 class support

1605
01:20:42,000 --> 01:20:47,000
这是我所期待的啊 prototype 当然有 prototype 的好处和应用啊

1606
01:20:47,000 --> 01:20:52,000
但是实际的应用中的话如果我们要用 class 的话那我还是希望能有真正的 class

1607
01:20:52,000 --> 01:20:54,000
对

1608
01:20:54,000 --> 01:21:00,000
我觉得 class 出现其实是比较如果有比较合理 class 的支持的话

1609
01:21:00,000 --> 01:21:04,000
那对于构建大型程序实际上是更加有利的

1610
01:21:04,000 --> 01:21:13,000
因为 prototype based object orientation 它的优点我觉得就在于你做原型开发非常的快

1611
01:21:13,000 --> 01:21:21,000
你不需要去考虑那个模板和实际的 instance 之间的抽象的问题

1612
01:21:21,000 --> 01:21:26,000
但当你要做大一些的东西的时候这个抽象其实还是相当必要

1613
01:21:26,000 --> 01:21:27,000
ok

1614
01:21:27,000 --> 01:21:29,000
对我不知道啊

1615
01:21:29,000 --> 01:21:33,000
因为我对这种所谓就传统的经典的基于 class 的这种

1616
01:21:33,000 --> 01:21:37,000
OO 的话我其实并没有太特别的偏好

1617
01:21:37,000 --> 01:21:39,000
所以我觉得就两种都还好了

1618
01:21:39,000 --> 01:21:43,000
没有没有那么就是 class base 没有那么好

1619
01:21:43,000 --> 01:21:45,000
就 prototype base 没有那么差我觉得是这样

1620
01:21:45,000 --> 01:21:48,000
go 也是没有 class 对吧

1621
01:21:48,000 --> 01:21:50,000
go 根本就没有连 prototype 都没有

1622
01:21:50,000 --> 01:21:53,000
它是基于 interface 的完全更不一样

1623
01:21:53,000 --> 01:21:56,000
我觉得其实用直接用起来我觉得那种是更灵活的

1624
01:21:56,000 --> 01:21:59,000
所以我觉得你其实就是一个你比你比较不喜欢

1625
01:21:59,000 --> 01:22:00,000
这个 class

1626
01:22:00,000 --> 01:22:03,000
经典的 class 对对对没错

1627
01:22:03,000 --> 01:22:06,000
java 看太多

1628
01:22:06,000 --> 01:22:09,000
我觉得你可以去看一看 IO 就是 EO 这个语言

1629
01:22:09,000 --> 01:22:10,000
我不知道怎么念的

1630
01:22:10,000 --> 01:22:13,000
它其实也是 prototype base

1631
01:22:13,000 --> 01:22:16,000
然后这个说来其实还蛮奇怪的

1632
01:22:16,000 --> 01:22:19,000
那个 object c 算是一个经典的基于 class 的

1633
01:22:19,000 --> 01:22:21,000
既成的 O 语言也不算吧

1634
01:22:21,000 --> 01:22:24,000
它是类似于 small talk 那种方式

1635
01:22:24,000 --> 01:22:27,000
它是在 c 上面加了一层 small talk

1636
01:22:27,000 --> 01:22:31,000
然后用一个最近看到的句话来说

1637
01:22:31,000 --> 01:22:36,000
object c 就是过去 25 年计算机语言发展史的缩影

1638
01:22:36,000 --> 01:22:38,000
你在看里面不同的语言特性的时候

1639
01:22:38,000 --> 01:22:41,000
你会如果你从一个计算机历史学家

1640
01:22:41,000 --> 01:22:43,000
加引号的角度来看的话

1641
01:22:43,000 --> 01:22:47,000
就你会看到这个特征来自于那个时代的一个思潮

1642
01:22:47,000 --> 01:22:49,000
考古语言

1643
01:22:49,000 --> 01:22:51,000
对所以其实我觉得就很好奇

1644
01:22:51,000 --> 01:22:54,000
就是就是起码 object c 也已经证明了

1645
01:22:54,000 --> 01:22:57,000
就是说你没有一个大规模的

1646
01:22:57,000 --> 01:23:03,000
就没有 class 的支持的一个 O 语言也可以做得很好

1647
01:23:03,000 --> 01:23:06,000
就是是不是不能证明这一点

1648
01:23:06,000 --> 01:23:09,000
我觉得不能不太能证明吧

1649
01:23:09,000 --> 01:23:11,000
不过这算了

1650
01:23:11,000 --> 01:23:14,000
我们可以留待以后就好乐

1651
01:23:14,000 --> 01:23:16,000
做能讲这个变成语言的一切

1652
01:23:16,000 --> 01:23:20,000
我们刚刚说到就是 java screen 应用这么广泛

1653
01:23:20,000 --> 01:23:26,000
实际上在这个 talk 中我们有一个 Netflix 的那个 speaker

1654
01:23:26,000 --> 01:23:32,000
然后他有说到说就是我们现在有很多智能电视嘛

1655
01:23:32,000 --> 01:23:35,000
智能电视上有很多可以看 Netflix

1656
01:23:35,000 --> 01:23:38,000
然后他们都是用 java screen 来写这个东西的

1657
01:23:38,000 --> 01:23:47,000
他们都是 shipping 一个那个 webkit 的封装给那个电视厂上

1658
01:23:47,000 --> 01:23:50,000
然后就其中有他们的 Netflix 的 application

1659
01:23:50,000 --> 01:23:54,000
对你知道那个 Apple TV 是这种方式实现的吗

1660
01:23:54,000 --> 01:23:56,000
Oh interesting

1661
01:23:56,000 --> 01:24:00,000
Netflix 的 Netflix

1662
01:24:00,000 --> 01:24:04,000
Nextflix 他们实际上现在是用 react 来写那个 TV app

1663
01:24:04,000 --> 01:24:06,000
就好像 react native 一样

1664
01:24:06,000 --> 01:24:08,000
他们是 react tv

1665
01:24:08,000 --> 01:24:09,000
you know

1666
01:24:09,000 --> 01:24:10,000
yeah 那个不是开源程序

1667
01:24:10,000 --> 01:24:13,000
但是但是他有介绍说就是怎么样实现的

1668
01:24:13,000 --> 01:24:15,000
嗯哼嗯哼

1669
01:24:15,000 --> 01:24:17,000
之前我也在玩那个

1670
01:24:17,000 --> 01:24:20,000
你有那个就什么 chromecast 那个那个小棒子吗

1671
01:24:20,000 --> 01:24:23,000
我在公司有但是我没有很正常学习

1672
01:24:23,000 --> 01:24:26,000
我自己有一个然后我之前玩过一段时间

1673
01:24:26,000 --> 01:24:28,000
就他也是那种方式就是他整个就是

1674
01:24:28,000 --> 01:24:29,000
其实就是一个浏览器窗口了

1675
01:24:29,000 --> 01:24:31,000
他你可以电视上的

1676
01:24:31,000 --> 01:24:34,000
然后里面也可以做类似的事情

1677
01:24:34,000 --> 01:24:36,000
就是你可以把这个整个 react

1678
01:24:36,000 --> 01:24:38,000
组件丢过去然后做一些很好玩的事

1679
01:24:38,000 --> 01:24:40,000
诶我插问你去

1680
01:24:40,000 --> 01:24:46,000
Chromecast 那个小棒子他要求有外界的 Wi-Fi 在是吧

1681
01:24:46,000 --> 01:24:48,000
对他只能通过 Wi-Fi 和外界的

1682
01:24:48,000 --> 01:24:51,000
他自己不能提供一个热点

1683
01:24:51,000 --> 01:24:53,000
他自己不他只是一个 Wi-Fi 接受器而已

1684
01:24:53,000 --> 01:24:57,000
当然你你把它 hack 掉应该也可能做一个热点出来

1685
01:24:57,000 --> 01:24:58,000
但你为什么你会想的

1686
01:24:58,000 --> 01:24:59,000
因为他会是一个 Wi-Fi 的热点

1687
01:24:59,000 --> 01:25:02,000
如果他能够自己成为一个 Wi-Fi 接点的话

1688
01:25:02,000 --> 01:25:07,000
我出去在酒店里面用酒店的电视

1689
01:25:07,000 --> 01:25:13,000
看在 iPad 上面预先漏的好的视频

1690
01:25:13,000 --> 01:25:15,000
其实你想发送过去是吧

1691
01:25:15,000 --> 01:25:17,000
不首先你要有两点是有问题的

1692
01:25:17,000 --> 01:25:20,000
第一个他只能是一个 Wi-Fi 的 client

1693
01:25:20,000 --> 01:25:22,000
他不是一个 AP

1694
01:25:22,000 --> 01:25:23,000
但估计你 hack 一下应该也行

1695
01:25:23,000 --> 01:25:24,000
但第二个问题就是说

1696
01:25:24,000 --> 01:25:28,000
Chromecast 的整个的一个 API

1697
01:25:28,000 --> 01:25:34,000
包括认证机制是不允许你随意播放你本机的视频文件的

1698
01:25:34,000 --> 01:25:35,000
OK

1699
01:25:35,000 --> 01:25:37,000
就比较麻烦你可以做但是比较麻烦

1700
01:25:37,000 --> 01:25:40,000
就能私人做没有那种比较现成的 APP 来搞这种

1701
01:25:40,000 --> 01:25:42,000
好吧

1702
01:25:42,000 --> 01:25:46,000
不过不影响现在很多手机都可以建一个热点

1703
01:25:46,000 --> 01:25:48,000
然后你可以用那个手机的

1704
01:25:48,000 --> 01:25:51,000
有很多安卓的 APP 可以让你做到这件事情

1705
01:25:51,000 --> 01:25:52,000
OK

1706
01:25:52,000 --> 01:25:55,000
iOS 就暂时没有解决方案

1707
01:25:55,000 --> 01:25:57,000
Apple TV 都没有没有办法

1708
01:25:57,000 --> 01:25:58,000
好大日差

1709
01:25:58,000 --> 01:26:01,000
那我们接下来讲

1710
01:26:01,000 --> 01:26:03,000
react native 还有什么要补充的吗

1711
01:26:03,000 --> 01:26:04,000
我现在差不多我想想

1712
01:26:04,000 --> 01:26:06,000
我觉得差不多了吧

1713
01:26:06,000 --> 01:26:07,000
那讲

1714
01:26:07,000 --> 01:26:12,000
其实有一个问题就是 react native 可以用来写游戏吗

1715
01:26:16,000 --> 01:26:18,000
那种什么 light game 应该是可以的吧我觉得

1716
01:26:18,000 --> 01:26:19,000
对就是

1717
01:26:19,000 --> 01:26:20,000
嗯

1718
01:26:20,000 --> 01:26:25,000
哎不过也不一定有人用那个什么 webGL 来写那种很复杂的设计游戏

1719
01:26:25,000 --> 01:26:29,000
可是在 react native

1720
01:26:29,000 --> 01:26:34,000
react native 所能操纵的原生组件到底到一个什么层级呢

1721
01:26:34,000 --> 01:26:38,000
比如说那个 iOS 上面的 spread kit

1722
01:26:38,000 --> 01:26:40,000
它可以用吗

1723
01:26:40,000 --> 01:26:42,000
这个就只有威乐才能回答

1724
01:26:42,000 --> 01:26:46,000
有人问过类似的问题但不是直接问游戏

1725
01:26:46,000 --> 01:26:48,000
而是说到底它可以

1726
01:26:48,000 --> 01:26:50,000
哪些组件是可以用是吧

1727
01:26:50,000 --> 01:26:51,000
对

1728
01:26:51,000 --> 01:26:53,000
然后所得到的答案是说

1729
01:26:53,000 --> 01:26:56,000
我的理解啊不是括弄括弄

1730
01:26:56,000 --> 01:26:59,000
是说所有的组件都是可以用的

1731
01:26:59,000 --> 01:27:02,000
但可能有些组件你得自己手工把它包装一下

1732
01:27:02,000 --> 01:27:04,000
ok

1733
01:27:04,000 --> 01:27:05,000
对

1734
01:27:05,000 --> 01:27:06,000
就以什么方式包装呢

1735
01:27:06,000 --> 01:27:08,000
是说我必须再用 swift

1736
01:27:08,000 --> 01:27:10,000
或者是 object c

1737
01:27:10,000 --> 01:27:11,000
写一个 wrapper

1738
01:27:11,000 --> 01:27:12,000
然后可以调用

1739
01:27:12,000 --> 01:27:13,000
不是

1740
01:27:13,000 --> 01:27:15,000
是在 java script 端写一个 wrapper

1741
01:27:15,000 --> 01:27:17,000
你这样想

1742
01:27:17,000 --> 01:27:18,000
你这样想

1743
01:27:18,000 --> 01:27:19,000
你这样想

1744
01:27:19,000 --> 01:27:21,000
不考虑 react native

1745
01:27:21,000 --> 01:27:24,000
就考虑 react 的 js

1746
01:27:24,000 --> 01:27:26,000
你可以用 div

1747
01:27:26,000 --> 01:27:27,000
你可以用 div

1748
01:27:27,000 --> 01:27:30,000
你可以用 almost anyhtml component

1749
01:27:30,000 --> 01:27:32,000
但是 div 本身

1750
01:27:32,000 --> 01:27:39,000
它有一个中间层是 react 已经提供给你的 react 已经写了 div component

1751
01:27:39,000 --> 01:27:40,000
对不对

1752
01:27:40,000 --> 01:27:43,000
就 virtual DOM 里面会有一个 div 的对应的一个对象吧

1753
01:27:43,000 --> 01:27:47,000
然后这个东西是 java script

1754
01:27:47,000 --> 01:27:52,000
是在 java script 里头有一个组件来告诉 virtual DOM 说我自己要做什么

1755
01:27:52,000 --> 01:27:53,000
我能够做什么

1756
01:27:53,000 --> 01:27:56,000
如果我的 state change 我应该怎么变化

1757
01:27:56,000 --> 01:27:58,000
这个是在 java script 的 definition 里头的

1758
01:27:58,000 --> 01:28:00,000
同样的

1759
01:28:00,000 --> 01:28:03,000
如果说你现在 html 出现了一个新的东西

1760
01:28:03,000 --> 01:28:04,000
出现了一个新的 tag

1761
01:28:04,000 --> 01:28:06,000
然后你想用这个 tag

1762
01:28:06,000 --> 01:28:07,000
by the way

1763
01:28:07,000 --> 01:28:12,000
那个 react 还有一些 svg 所相关的 tag 它没有实现

1764
01:28:12,000 --> 01:28:14,000
如果大家有兴趣的话可以去 contribute

1765
01:28:14,000 --> 01:28:16,000
嗯嗯

1766
01:28:16,000 --> 01:28:17,000
就现在要加入这个

1767
01:28:17,000 --> 01:28:20,000
对这些新的原生 tag 的实现的话呢

1768
01:28:20,000 --> 01:28:24,000
那你也写一个 react 的 component 来实现它

1769
01:28:24,000 --> 01:28:25,000
对不对

1770
01:28:25,000 --> 01:28:28,000
所以转换成 react 的 native 的逻辑呢

1771
01:28:28,000 --> 01:28:34,000
如果你用一个原生的 native 的 component 你要使用的话

1772
01:28:34,000 --> 01:28:39,000
你只需要在 java script 端写一个 adapter 来说

1773
01:28:39,000 --> 01:28:41,000
这个东西是个什么东西

1774
01:28:41,000 --> 01:28:43,000
怎么样 initialize 它

1775
01:28:43,000 --> 01:28:46,000
它能够提供什么样的操作

1776
01:28:46,000 --> 01:28:52,000
然后 react 的引擎肯定有一个 protocol 来说

1777
01:28:52,000 --> 01:28:55,000
你要怎么写这个文件在 java script

1778
01:28:55,000 --> 01:28:58,000
然后你按照它一胡乱画条把它写出来之后

1779
01:28:58,000 --> 01:29:00,000
那你就可以用这个原生组件了

1780
01:29:00,000 --> 01:29:02,000
但我觉得可能无套的问题就是说

1781
01:29:02,000 --> 01:29:06,000
那是就是说是 react native 这个 library 提供

1782
01:29:06,000 --> 01:29:12,000
javascript 到这个 iOS 的那些原生组件这一个桥吗

1783
01:29:12,000 --> 01:29:13,000
还是怎么样

1784
01:29:13,000 --> 01:29:16,000
是 react native 自己本身实现那一个

1785
01:29:16,000 --> 01:29:21,000
那这会不会有像类似于这个叫什么 titania 那种同样的问题

1786
01:29:21,000 --> 01:29:27,000
就是说你要等 react native 这个 library 提供了对应的这个

1787
01:29:27,000 --> 01:29:32,000
比如说 iOS 的一些原生的组件的这个桥了之后

1788
01:29:32,000 --> 01:29:33,000
你才可以用的

1789
01:29:33,000 --> 01:29:34,000
而不是说我自己可以

1790
01:29:34,000 --> 01:29:35,000
比如假设苹果 iOS 9

1791
01:29:35,000 --> 01:29:37,000
他又出了一些新的原生组件

1792
01:29:37,000 --> 01:29:38,000
那我作为开发者

1793
01:29:38,000 --> 01:29:39,000
我可以自己包一下就可以用

1794
01:29:39,000 --> 01:29:43,000
而不是说要等到这个 react native 发布一个新版支持说

1795
01:29:43,000 --> 01:29:47,000
就是说 expose 那些原生的组件出来才可以用了

1796
01:29:47,000 --> 01:29:52,000
根据在那个会上的 Q&A 的答案的话

1797
01:29:52,000 --> 01:29:55,000
我相信是你可以自己来做这个事情的

1798
01:29:55,000 --> 01:29:57,000
就他们做了一个通用的桥

1799
01:29:57,000 --> 01:29:58,000
这个非常好

1800
01:29:58,000 --> 01:29:59,000
这个就很厉害了

1801
01:29:59,000 --> 01:30:00,000
就不用考虑

1802
01:30:00,000 --> 01:30:02,000
就不会遇到之前那个 titania 那种问题了

1803
01:30:02,000 --> 01:30:03,000
对

1804
01:30:03,000 --> 01:30:05,000
这个真的不这个了不得

1805
01:30:05,000 --> 01:30:08,000
我看那这样那么 sweep 不就挂了

1806
01:30:08,000 --> 01:30:11,000
javascript 多简单

1807
01:30:11,000 --> 01:30:14,000
你知道这个技术的发展

1808
01:30:14,000 --> 01:30:15,000
总是有很多不确定性的

1809
01:30:15,000 --> 01:30:18,000
所以大家不要把鸡蛋放在同一个篮子里头

1810
01:30:18,000 --> 01:30:20,000
这是没错

1811
01:30:20,000 --> 01:30:22,000
还好我已经不做前端了

1812
01:30:22,000 --> 01:30:24,000
不这也是一个问题

1813
01:30:24,000 --> 01:30:26,000
前端就是变化好快

1814
01:30:26,000 --> 01:30:29,000
对其实这也是我在那个提纲里面写的

1815
01:30:29,000 --> 01:30:33,000
就是我觉得现在前端真的是没有人知道风会往里面吹

1816
01:30:33,000 --> 01:30:36,000
就是什么三天一小便七天一大便

1817
01:30:36,000 --> 01:30:38,000
对就是 frontend technology

1818
01:30:38,000 --> 01:30:44,000
可能你这个网站你所用的东西跟另外一个网站所用的东西 completely different

1819
01:30:44,000 --> 01:30:46,000
没有任何一点点交集

1820
01:30:46,000 --> 01:30:50,000
然后两个人都觉得自己做的才是前途

1821
01:30:50,000 --> 01:30:53,000
或者反过来两个人都觉得对方做的才是正确的

1822
01:30:53,000 --> 01:30:56,000
这个是非常让人疑惑的一件事情

1823
01:30:56,000 --> 01:30:58,000
其实你这个都是高端了

1824
01:30:58,000 --> 01:31:00,000
你像遇到那种比较低端的

1825
01:31:00,000 --> 01:31:02,000
那他就说我们不是都是用 jcurry 吗

1826
01:31:02,000 --> 01:31:08,000
你知道就是所谓最好的时代也是最坏的时代

1827
01:31:08,000 --> 01:31:09,000
对

1828
01:31:09,000 --> 01:31:11,000
看你自己所处的位置是怎么样

1829
01:31:11,000 --> 01:31:13,000
对

1830
01:31:13,000 --> 01:31:19,000
我觉得这也可能就是前端技术比较让人有兴趣的一部分

1831
01:31:19,000 --> 01:31:22,000
就你总是可以看到一些新的

1832
01:31:22,000 --> 01:31:24,000
然后看到一些有趣的东西

1833
01:31:24,000 --> 01:31:25,000
看到年轻人的活力

1834
01:31:26,000 --> 01:31:27,000
对

1835
01:31:27,000 --> 01:31:29,000
这从一定程度上来讲的话

1836
01:31:29,000 --> 01:31:33,000
它也是有就是技术也有很固定的时候

1837
01:31:33,000 --> 01:31:36,000
比方说算是阶段性发展

1838
01:31:36,000 --> 01:31:40,000
你知道就 jcurry 有 jcurry 的一段时间大家都用 jcurry

1839
01:31:40,000 --> 01:31:42,000
然后 backbone 有段时间大家都用 backbone

1840
01:31:42,000 --> 01:31:43,000
然后我觉得我们可能

1841
01:31:43,000 --> 01:31:45,000
之所以这么就是现在这么精彩

1842
01:31:45,000 --> 01:31:47,000
是因为我们在进入一个新的阶段

1843
01:31:47,000 --> 01:31:53,000
从我的角度来说的话我觉得 react 是最 promising 的一个 solution

1844
01:31:53,000 --> 01:31:55,000
因为 angler can shoot itself in the flute

1845
01:31:55,000 --> 01:31:56,000
对不对

1846
01:31:56,000 --> 01:31:58,000
没办法

1847
01:31:58,000 --> 01:31:59,000
这个对

1848
01:31:59,000 --> 01:32:00,000
对

1849
01:32:00,000 --> 01:32:01,000
太复杂了他们

1850
01:32:01,000 --> 01:32:02,000
所以

1851
01:32:02,000 --> 01:32:05,000
而且他那个 2.0 跟 1.0 又不匹配

1852
01:32:05,000 --> 01:32:08,000
然后 2.0 又在又需要那么长时间来开发

1853
01:32:08,000 --> 01:32:12,000
所以 angler 有点就是自身的可能

1854
01:32:12,000 --> 01:32:13,000
即将做死

1855
01:32:13,000 --> 01:32:15,000
真的有点这个意思

1856
01:32:16,000 --> 01:32:21,000
所以 react 很可能就是下一个阶段的一个主力了

1857
01:32:22,000 --> 01:32:28,000
所以我不管你对 react 自己本身怎么想做一个前端的开发者的话

1858
01:32:28,000 --> 01:32:30,000
真的应该去了解他

1859
01:32:30,000 --> 01:32:32,000
至少知道他为什么好

1860
01:32:32,000 --> 01:32:34,000
或者他哪里好

1861
01:32:36,000 --> 01:32:39,000
而且从公司的支持来说的话

1862
01:32:39,000 --> 01:32:43,000
Facebook 对 react 是非常非常强烈的

1863
01:32:43,000 --> 01:32:49,000
你可以看到他最初是最初最初的模型是那个 Facebook aids group

1864
01:32:49,000 --> 01:32:52,000
就是 Ads group 来做出来的

1865
01:32:52,000 --> 01:32:57,000
然后现在后来到 chat 到大部分的前端他们所现在写的都是 adopt 这个 react 的

1866
01:32:57,000 --> 01:33:01,000
到你知道 group 现在又用那个 react native 的写

1867
01:33:01,000 --> 01:33:04,000
所以 react 背后有非常多 Facebook 的支持

1868
01:33:04,000 --> 01:33:07,000
反观 angler 反倒是在 Google 里头

1869
01:33:07,000 --> 01:33:08,000
他自己都不怎么用吗

1870
01:33:08,000 --> 01:33:11,000
对我们并不知道特别多的 angler 所写的应用

1871
01:33:11,000 --> 01:33:15,000
那个 inbox 倒是一个 angler 的案例

1872
01:33:15,000 --> 01:33:22,000
inbox 是不是上次 react 是 gwc 写的

1873
01:33:22,000 --> 01:33:24,000
然后我成功的破碎的这个谣言

1874
01:33:24,000 --> 01:33:26,000
对他是这样

1875
01:33:26,000 --> 01:33:27,000
他是两部分

1876
01:33:27,000 --> 01:33:29,000
他的前端那部分不知道没有说

1877
01:33:29,000 --> 01:33:32,000
但是后就是那个业务逻辑那边他是 java 转过去的

1878
01:33:32,000 --> 01:33:33,000
对 ok

1879
01:33:33,000 --> 01:33:34,000
ok

1880
01:33:34,000 --> 01:33:43,000
对很有可能就是他他的 inbox 的网页版的前端可能是用 angler.js 写的

1881
01:33:43,000 --> 01:33:47,000
对他或许有很多 internal tool 用 angler 写的

1882
01:33:47,000 --> 01:33:49,000
但是我们并没有看到很多直接的支持

1883
01:33:49,000 --> 01:33:55,000
我觉得这一点上对于技术本身的发展是不是特别好

1884
01:33:55,000 --> 01:33:57,000
因为没有干爹支持

1885
01:33:57,000 --> 01:33:58,000
对

1886
01:33:58,000 --> 01:34:02,000
这个是个很大的问题

1887
01:34:02,000 --> 01:34:03,000
嗯

1888
01:34:03,000 --> 01:34:05,000
看看看选技术技术选谁的

1889
01:34:05,000 --> 01:34:07,000
而且先看爹嘛对吧

1890
01:34:07,000 --> 01:34:08,000
你还选了 Go

1891
01:34:08,000 --> 01:34:09,000
真的是这样子

1892
01:34:09,000 --> 01:34:13,000
那我们接下来说一下那个 relay 吧

1893
01:34:13,000 --> 01:34:16,000
这个还是要留在下期还是怎么样

1894
01:34:16,000 --> 01:34:18,000
还是一次过把它讲完好了

1895
01:34:18,000 --> 01:34:24,000
他们这次这个 react 大会上面除了发布这个令人激动人心什么

1896
01:34:24,000 --> 01:34:29,000
令这个 web app 可以秒杀这个 iOS 或者 angler

1897
01:34:29,000 --> 01:34:30,000
groundbreaking

1898
01:34:30,000 --> 01:34:35,000
就直接直接就秒秒视了的这么一个什么对

1899
01:34:35,000 --> 01:34:36,000
groundbreaking 的技术之外

1900
01:34:36,000 --> 01:34:37,000
还发布了一个

1901
01:34:37,000 --> 01:34:39,000
其实作为一个前端开发

1902
01:34:39,000 --> 01:34:41,000
半个前端开发者的我来讲

1903
01:34:41,000 --> 01:34:43,000
这个还是非常令我低动的

1904
01:34:43,000 --> 01:34:45,000
叫做一个 relay 的这么一个技术啊

1905
01:34:45,000 --> 01:34:50,000
这个事情跟之前讲的那个 flux 是有或多或少的关系的

1906
01:34:50,000 --> 01:34:53,000
因为他们在去年发布那个 flux 架构的时候

1907
01:34:53,000 --> 01:34:55,000
并没有说 influx 他只是一个 idea

1908
01:34:55,000 --> 01:34:56,000
刚才威乐也讲了

1909
01:34:56,000 --> 01:35:00,000
他并没有说告诉你一些具体的执行的措施是怎么样子的

1910
01:35:00,000 --> 01:35:05,000
然后其中有一个很一个就是任何一个 web app 都逃不掉的问题

1911
01:35:05,000 --> 01:35:07,000
就是你怎么去从服务端获取数据嘛

1912
01:35:07,000 --> 01:35:08,000
对

1913
01:35:08,000 --> 01:35:10,000
然后在这个传动的方式下

1914
01:35:10,000 --> 01:35:12,000
那可能最简单的

1915
01:35:12,000 --> 01:35:13,000
我就用 jquery 写一个

1916
01:35:13,000 --> 01:35:14,000
或者是用那个什么

1917
01:35:14,000 --> 01:35:15,000
xmlhtprequest

1918
01:35:15,000 --> 01:35:16,000
发一个请求

1919
01:35:16,000 --> 01:35:19,000
然后回来用什么一个 callback

1920
01:35:19,000 --> 01:35:20,000
就更新了一下这个 dome

1921
01:35:20,000 --> 01:35:23,000
这个可能是最最原始的一个从服务端取数据

1922
01:35:23,000 --> 01:35:25,000
然后在一个 web app 那边展示的方法

1923
01:35:25,000 --> 01:35:27,000
但是到了一定层级之后

1924
01:35:27,000 --> 01:35:29,000
这种方式就是完全是不可以管理的嘛

1925
01:35:29,000 --> 01:35:31,000
有很多很多奇奇怪怪的问题要解决

1926
01:35:31,000 --> 01:35:32,000
对不对

1927
01:35:32,000 --> 01:35:34,000
然后他们这次发布的这个 relay 呢

1928
01:35:34,000 --> 01:35:36,000
其实就是要解决这么一个问题

1929
01:35:36,000 --> 01:35:44,000
我不知道为了你们在之前的时候是怎么去做这个从服务端获取数据这么一个过程

1930
01:35:46,000 --> 01:35:51,000
因为我们都之前都是在用那个传统意义上的 mvc 的 model

1931
01:35:51,000 --> 01:35:55,000
我们还没有到我们并没有使用 storage 的概念

1932
01:35:55,000 --> 01:35:59,000
但是我觉得 store 的概念可能跟那个 model 是可以 map 的

1933
01:35:59,000 --> 01:36:03,000
所以然后我们的后台是一个 restful API

1934
01:36:03,000 --> 01:36:04,000
ok

1935
01:36:04,000 --> 01:36:06,000
在前端我们有 model

1936
01:36:06,000 --> 01:36:10,000
然后这个 model 它可以去跟那个后台去 sync

1937
01:36:10,000 --> 01:36:14,000
这个 sync 是一个 restful 的 httb request

1938
01:36:14,000 --> 01:36:19,000
然后那个 server 会把你所获取的需要获取的信息给发送回来

1939
01:36:19,000 --> 01:36:23,000
然后这样 model 就得到了这个所有需要的信息

1940
01:36:23,000 --> 01:36:25,000
那么这里就有一个问题

1941
01:36:25,000 --> 01:36:29,000
就是说刚刚我们那个可能要介入这么一个新的这个一个概念

1942
01:36:29,000 --> 01:36:34,000
也比较显得说你说前端开发肯定会遇到就是 rest 的这么一个一个 API

1943
01:36:34,000 --> 01:36:35,000
那什么意思呢

1944
01:36:35,000 --> 01:36:39,000
就是说它起码它就说把我把这个我后台我能够提供的所有的资源

1945
01:36:39,000 --> 01:36:42,000
一个 resource 通过一个这个 url 的这么一个节点暴露出来

1946
01:36:42,000 --> 01:36:47,000
然后你通过像什么标准的什么什么 put delete post get

1947
01:36:47,000 --> 01:36:50,000
这个方法去获取这些资源嘛

1948
01:36:50,000 --> 01:36:54,000
但是这有一个问题就是说我不知道你们那边是不是怎么样子

1949
01:36:54,000 --> 01:36:56,000
就是我看到的大部分的这个 rest API

1950
01:36:56,000 --> 01:36:58,000
都有一个共同的问题

1951
01:36:58,000 --> 01:37:00,000
就是它有太多的这个所谓 end point 太多的节点了

1952
01:37:00,000 --> 01:37:02,000
因为每一个资源就要对应一个节点嘛

1953
01:37:02,000 --> 01:37:03,000
没错

1954
01:37:03,000 --> 01:37:05,000
然后包括如果为了你讲的那种情况

1955
01:37:05,000 --> 01:37:06,000
如果我理解来没有错的话

1956
01:37:06,000 --> 01:37:10,000
你们也是说每一个 model 应该是对应一个 resource 一个资源

1957
01:37:10,000 --> 01:37:18,000
然后每个 model 去负责去那个节点的那个资源对应的 rest 的节点去访问它对吧

1958
01:37:18,000 --> 01:37:22,000
但是我觉得其实这样管理和编写起来都不是很方便

1959
01:37:22,000 --> 01:37:24,000
而且在使用起来我就有很多问题

1960
01:37:24,000 --> 01:37:27,000
就我先讲讲我的体验怎么样子感觉

1961
01:37:27,000 --> 01:37:28,000
就是一个刚才讲那个节点太多

1962
01:37:28,000 --> 01:37:31,000
你要为每一个资源增就增加一个节点

1963
01:37:31,000 --> 01:37:35,000
然后你要考虑每个资源它能够支持的这些所谓的这些动词 verb

1964
01:37:35,000 --> 01:37:38,000
它对应的一些所谓的这个语义是什么

1965
01:37:38,000 --> 01:37:42,000
比如说我有一个 user 如果我 put 的 user 是一个什么意思对吧

1966
01:37:42,000 --> 01:37:44,000
然后我 post 的 user 又是一个什么意思

1967
01:37:44,000 --> 01:37:46,000
然后 delete 当然可能更好理解一点

1968
01:37:46,000 --> 01:37:48,000
但是因为会牵涉到资源的种类又不一样

1969
01:37:48,000 --> 01:37:50,000
有所谓的什么 collection

1970
01:37:50,000 --> 01:37:52,000
有所谓的 individual 这种 resource

1971
01:37:52,000 --> 01:37:55,000
其实很多事情还是不是那么清晰的

1972
01:37:55,000 --> 01:37:58,000
而且这个 res 的本身的定义

1973
01:37:58,000 --> 01:37:59,000
就是很多人有很不同的理解嘛

1974
01:37:59,000 --> 01:38:04,000
虽然最开始那篇博士论文里面有把这个概念阐述都很详细

1975
01:38:04,000 --> 01:38:08,000
但是我可以确信绝大部分做 res 的人都是没有

1976
01:38:08,000 --> 01:38:10,000
看过那篇模式论文的

1977
01:38:10,000 --> 01:38:16,000
然后 res 我觉得还有一个问题就是说它的那个这个就约束太多了

1978
01:38:16,000 --> 01:38:20,000
首先一个一个就是说假设你要就要暴露出来一个 user

1979
01:38:20,000 --> 01:38:22,000
这么一个节点这个这么一个资源

1980
01:38:22,000 --> 01:38:26,000
可能代表是一某一个一个账号体系的一个用户对吧

1981
01:38:26,000 --> 01:38:30,000
它返回给你的数据肯定是固定结构的就是你取一个 user

1982
01:38:30,000 --> 01:38:32,000
就是你取一个 user 你就取到他所有的信息

1983
01:38:32,000 --> 01:38:34,000
比如说你要取他的这个用户名

1984
01:38:34,000 --> 01:38:38,000
这个 email 他会把那个所有的详细的信息都返给你

1985
01:38:38,000 --> 01:38:42,000
哪怕你只是需要用他的这个所谓的一个用户名来显示出

1986
01:38:42,000 --> 01:38:46,000
或者一个头像显示出一个一个什么的一个头像框而已对吧

1987
01:38:46,000 --> 01:38:48,000
对你没有他对于他的更为精细的控制

1988
01:38:48,000 --> 01:38:50,000
对对每对每一个资源来讲

1989
01:38:50,000 --> 01:38:54,000
你比较难去说你你在做一些更精细的要求

1990
01:38:54,000 --> 01:38:58,000
而且就是他所谓的这个可组合性也比较低

1991
01:38:58,000 --> 01:39:00,000
比如说就是最举个最简单的例子

1992
01:39:00,000 --> 01:39:02,000
我有一个 user 这么一个节点

1993
01:39:02,000 --> 01:39:04,000
然后有一个像一个 post

1994
01:39:04,000 --> 01:39:06,000
一个文章或者帖子这么一个节点

1995
01:39:06,000 --> 01:39:12,000
我想在取到说这个用户发过的那个文章的时候

1996
01:39:12,000 --> 01:39:14,000
你会牵涉到一个很麻烦的问题

1997
01:39:14,000 --> 01:39:16,000
就是说你把这个对应的请求

1998
01:39:16,000 --> 01:39:19,000
它显然不是完全归属于用户那个节点

1999
01:39:19,000 --> 01:39:22,000
它也不是完全归属于这个 post 那个节点

2000
01:39:22,000 --> 01:39:26,000
对吧就有一些这种很不正交的东西出现在里面

2001
01:39:26,000 --> 01:39:29,000
而且你有办法很方便的在同一个请求里面

2002
01:39:29,000 --> 01:39:31,000
去同时取这两个不同的东西

2003
01:39:31,000 --> 01:39:34,000
就他们的这个可组合性我觉得是比较低的

2004
01:39:34,000 --> 01:39:35,000
没错

2005
01:39:35,000 --> 01:39:37,000
然后最后一个就是说我实际用的体验中

2006
01:39:37,000 --> 01:39:40,000
就是因为这个大部分的 rest API

2007
01:39:40,000 --> 01:39:42,000
是通过 http 的这种方法去访问的

2008
01:39:42,000 --> 01:39:45,000
然后我们现在用的 http 所谓的 1.0 1.1 这个版本

2009
01:39:45,000 --> 01:39:50,000
有一个问题就是说它有一个很严酷的就是 request response

2010
01:39:50,000 --> 01:39:54,000
就是请求答复请求答复这么一个流程

2011
01:39:54,000 --> 01:39:56,000
你不可能说我发 5 个请求出去

2012
01:39:56,000 --> 01:39:58,000
然后等 5 个回复出来对吧

2013
01:39:58,000 --> 01:40:01,000
这种这种一个有效率的问题

2014
01:40:01,000 --> 01:40:03,000
那么很多人就为了解决这个效率问题

2015
01:40:03,000 --> 01:40:05,000
他要去考虑说我把这个请求所谓打包

2016
01:40:05,000 --> 01:40:06,000
就是 batching

2017
01:40:06,000 --> 01:40:08,000
比如我要请求 5 个用户

2018
01:40:08,000 --> 01:40:10,000
或者说请求 5 个用户 3 个文章

2019
01:40:10,000 --> 01:40:12,000
我要把这几个请求包在一起

2020
01:40:12,000 --> 01:40:13,000
然后发一个请求过去

2021
01:40:13,000 --> 01:40:16,000
这个时候你用 rest API 的话就不是非常好做了

2022
01:40:16,000 --> 01:40:17,000
没错

2023
01:40:17,000 --> 01:40:21,000
所以总体来讲我觉得 rest 在它的逻辑是很好的

2024
01:40:21,000 --> 01:40:23,000
就是说整个概念是非常方便

2025
01:40:23,000 --> 01:40:29,000
但是我觉得它始终是更适用于那种所谓面向文档的那种类型的应用是比较好的

2026
01:40:29,000 --> 01:40:34,000
但是在我们目前在做的很多这种面向一些什么社交网络也好

2027
01:40:34,000 --> 01:40:36,000
还有其他一些更新型态的应用的时候

2028
01:40:36,000 --> 01:40:40,000
用 rest 的这种 API 其实我觉得并不是一个特别好的选择

2029
01:40:40,000 --> 01:40:49,000
我吃饱了一讲我觉得我们所看到 relay 它的确在解决另外一 set 的 problem

2030
01:40:49,000 --> 01:40:55,000
但是而且是非常有意义的一个解决方案

2031
01:40:55,000 --> 01:41:07,000
还有我总归是觉得 relay 它的意义更在于是帮助像 facebook 这样大型的公司来管理它的复杂度

2032
01:41:07,000 --> 01:41:12,000
因为只有在规模上你才会在意那么小级别

2033
01:41:12,000 --> 01:41:18,000
就是说到底是哪个 view 得到哪个 field 来减少哪个带宽的需求

2034
01:41:18,000 --> 01:41:24,000
然后同时有更好的封装和保护不同的数据

2035
01:41:24,000 --> 01:41:25,000
这是非常有意义的事情

2036
01:41:25,000 --> 01:41:28,000
但是我觉得还是跟规模是相关的

2037
01:41:28,000 --> 01:41:31,000
小公司其实是不需要这种复杂的需求的吗

2038
01:41:31,000 --> 01:41:35,000
对从很大程度来说我觉得是这样子

2039
01:41:35,000 --> 01:41:40,000
但是这就是跟你一个你所要解决的问题

2040
01:41:40,000 --> 01:41:44,000
所的那个 available 的方案是有相关的

2041
01:41:44,000 --> 01:41:46,000
而且从一定程度上来讲

2042
01:41:46,000 --> 01:41:52,000
如果你在 Restful API 的基础上加上一些控制的变量

2043
01:41:52,000 --> 01:41:57,000
比方说 facebook 自己本身的 graph API 有一个叫 fields 的概念

2044
01:41:57,000 --> 01:42:04,000
就是你 fields 会帮助你控制它所返回的 attributes

2045
01:42:04,000 --> 01:42:06,000
到底是哪些 fields

2046
01:42:06,000 --> 01:42:09,000
这跟 relay 中的一些概念是非常相似的

2047
01:42:09,000 --> 01:42:10,000
非常 map 的

2048
01:42:10,000 --> 01:42:14,000
我也可以预见就是在 relay 真正的发布的时候

2049
01:42:14,000 --> 01:42:19,000
会有人给传统的 resful API 写一些 adapter

2050
01:42:19,000 --> 01:42:25,000
然后从而到传统的 resful API 也支持 relay 的实现方式

2051
01:42:25,000 --> 01:42:29,000
因为刚好昨天那个因为 relay 现在还没有

2052
01:42:29,000 --> 01:42:30,000
他只是发布了这个概念

2053
01:42:30,000 --> 01:42:32,000
他并没有公布他后面的一些产品

2054
01:42:32,000 --> 01:42:34,000
然后昨天在那个 hacker news 上面

2055
01:42:34,000 --> 01:42:36,000
facebook 上面有一个叫做

2056
01:42:36,000 --> 01:42:39,000
Wincent 不是 Wincent

2057
01:42:39,000 --> 01:42:40,000
是 Wincent 这么一个人

2058
01:42:40,000 --> 01:42:43,000
他不是在吉他上写了一个 relay 的这个 FAQ 吗

2059
01:42:43,000 --> 01:42:45,000
常见问题解答

2060
01:42:45,000 --> 01:42:48,000
然后他上面我就问了他们他们这么一个问题

2061
01:42:48,000 --> 01:42:51,000
就是说 relay 它很依赖一个核心的组件

2062
01:42:51,000 --> 01:42:52,000
就是那个什么 graphql

2063
01:42:52,000 --> 01:42:54,000
就是这个图查询语言

2064
01:42:54,000 --> 01:42:58,000
这个是跟 facebook 他们后台有一个叫做 tl

2065
01:42:58,000 --> 01:43:01,000
的一个图数据库紧密相关的

2066
01:43:01,000 --> 01:43:03,000
但我不太清楚就是说

2067
01:43:03,000 --> 01:43:06,000
对于一个第三方就是作为一个 facebook 以外的人

2068
01:43:06,000 --> 01:43:08,000
或者是中小开发者或中小网站

2069
01:43:08,000 --> 01:43:13,000
你没有一个基于这么一个图的结构的后台的话

2070
01:43:13,000 --> 01:43:17,000
你怎么去适应这种 graphql 的要求

2071
01:43:17,000 --> 01:43:18,000
去做到 relay 这种效果

2072
01:43:18,000 --> 01:43:20,000
就还是很很大的一个疑惑

2073
01:43:20,000 --> 01:43:21,000
OK

2074
01:43:21,000 --> 01:43:22,000
这是一个机会啊

2075
01:43:22,000 --> 01:43:23,000
这是一个空白

2076
01:43:23,000 --> 01:43:24,000
市场现在是空白的

2077
01:43:24,000 --> 01:43:25,000
对不对

2078
01:43:25,000 --> 01:43:26,000
对

2079
01:43:26,000 --> 01:43:29,000
如果如果我们有听众

2080
01:43:29,000 --> 01:43:35,000
你然后想要再借此机会来写一个什么 open source library

2081
01:43:35,000 --> 01:43:36,000
或者是甚至开一个东西了

2082
01:43:36,000 --> 01:43:38,000
我觉得这个机会是有可能存在的

2083
01:43:38,000 --> 01:43:42,000
你要知道这个 graphql

2084
01:43:42,000 --> 01:43:44,000
它最终

2085
01:43:44,000 --> 01:43:48,000
最终即使是 open source 了

2086
01:43:48,000 --> 01:43:50,000
不是即使就是最终它会 open source

2087
01:43:50,000 --> 01:43:52,000
但是我们需要等一段时间

2088
01:43:52,000 --> 01:43:53,000
它在 open source 之后呢

2089
01:43:53,000 --> 01:43:56,000
它也更多的是作为一个 protocol 的存在

2090
01:43:56,000 --> 01:43:57,000
就像 flux 那样

2091
01:43:57,000 --> 01:43:58,000
对

2092
01:43:58,000 --> 01:43:59,000
对对

2093
01:43:59,000 --> 01:44:00,000
真正实现的是需要

2094
01:44:00,000 --> 01:44:01,000
你自己去做的

2095
01:44:01,000 --> 01:44:06,000
根据它所用的那个软件来实现的

2096
01:44:06,000 --> 01:44:08,000
对我觉得它有点像一个像 sql

2097
01:44:08,000 --> 01:44:11,000
你可以做一个 graphql database

2098
01:44:11,000 --> 01:44:16,000
然后或者说类 database 的 graphql server

2099
01:44:16,000 --> 01:44:21,000
然后这个 server 可能会说一种 graphql 的 dialect

2100
01:44:21,000 --> 01:44:25,000
然后带某种扩展就和 sql 一模一样

2101
01:44:25,000 --> 01:44:26,000
对没错

2102
01:44:26,000 --> 01:44:28,000
他们就算 relay 以后发布的时候

2103
01:44:28,000 --> 01:44:31,000
它也只会包含首先第一个是客户端的 graphql

2104
01:44:31,000 --> 01:44:32,000
那些组件嘛

2105
01:44:32,000 --> 01:44:35,000
比如说它可以在每一个 react

2106
01:44:35,000 --> 01:44:37,000
它可以在每一个 react 组件里面声明

2107
01:44:37,000 --> 01:44:40,000
你那个组件需要哪一个哪一种类型的数据

2108
01:44:40,000 --> 01:44:42,000
然后它可以通过这个 relate 的这个 library

2109
01:44:42,000 --> 01:44:46,000
去把这些需求都一次抽出来

2110
01:44:46,000 --> 01:44:49,000
然后往服务端发一个请求就可以解决

2111
01:44:49,000 --> 01:44:51,000
包括它会帮你去做好刚刚讲的那个 batching 啊

2112
01:44:51,000 --> 01:44:54,000
就是这个就是请求打包

2113
01:44:54,000 --> 01:44:57,000
包括哪些是可以重用的请求就可以不用发送嘛

2114
01:44:57,000 --> 01:45:00,000
包括那个本地的这个缓存它都给你解决了

2115
01:45:00,000 --> 01:45:04,000
但是我觉得始终是在反而就问题在服务端那边

2116
01:45:04,000 --> 01:45:05,000
在服务端那边你是没有办法的

2117
01:45:05,000 --> 01:45:08,000
因为它最终它只会给你一个 graphql 的这个

2118
01:45:08,000 --> 01:45:10,000
那个叫什么 parser

2119
01:45:10,000 --> 01:45:12,000
然后它会给你一个语法术

2120
01:45:12,000 --> 01:45:16,000
但你怎么去满足它每一个 graphql 写的这么一个查询

2121
01:45:16,000 --> 01:45:18,000
你还是要挺费脑筋的

2122
01:45:18,000 --> 01:45:24,000
而且我觉得这不是一个小企业或者是个人能够很轻易做得到的事情吧

2123
01:45:24,000 --> 01:45:26,000
对

2124
01:45:26,000 --> 01:45:29,000
我很期待看到有人做一个 risk for API 的 adapter

2125
01:45:29,000 --> 01:45:34,000
因为虽然说虽然说他们两者的那个概念上有区别

2126
01:45:34,000 --> 01:45:40,000
但是实际上最终啊 graphql 和 resfer 都是访问数据的一个方式嘛

2127
01:45:40,000 --> 01:45:44,000
所以说他们两个之间是有可以 map 的地方的

2128
01:45:44,000 --> 01:45:47,000
所以如果说有人能做一个 adapter

2129
01:45:47,000 --> 01:45:49,000
比如说 reels

2130
01:45:49,000 --> 01:45:52,000
reels apps 肯定可以有人做一个 reels

2131
01:45:52,000 --> 01:45:55,000
graphql 然后一个 gene

2132
01:45:55,000 --> 01:45:57,000
你把这个加上之后它的那个 risk for API

2133
01:45:57,000 --> 01:46:01,000
就可以通过这个 adapter 来实现 graphql

2134
01:46:01,000 --> 01:46:05,000
我觉得这个可能在性能上会有些损失

2135
01:46:05,000 --> 01:46:07,000
然后也不是说直接你实现了 graphql

2136
01:46:07,000 --> 01:46:09,000
但是对推广这个技术

2137
01:46:09,000 --> 01:46:12,000
你应用这个技术是非常好处

2138
01:46:12,000 --> 01:46:13,000
作为一个过渡方案

2139
01:46:13,000 --> 01:46:15,000
对作为一个过渡方案应该是挺好的

2140
01:46:15,000 --> 01:46:16,000
对吧

2141
01:46:16,000 --> 01:46:17,000
所以我就还是在想

2142
01:46:17,000 --> 01:46:18,000
因为之前在知乎的时候

2143
01:46:18,000 --> 01:46:25,000
我的很大的一部分工作就是在琢磨这些五七八糟的有的没的图的结构嘛

2144
01:46:25,000 --> 01:46:29,000
那其实我后来的一个体验就是说其实真的是蛮难的

2145
01:46:29,000 --> 01:46:31,000
就是作为一个普通的团队

2146
01:46:31,000 --> 01:46:33,000
然后你像很多这种所有的 web 应用

2147
01:46:33,000 --> 01:46:36,000
它都是一个什么 mysicle 一个后台

2148
01:46:36,000 --> 01:46:39,000
然后前面加封一个 rest 的一个 api 层

2149
01:46:39,000 --> 01:46:44,000
然后再加几个 redis 的这种叫什么就是缓冲层嘛

2150
01:46:44,000 --> 01:46:48,000
然后就可以它就可以满足一个中型网站的应用了嘛

2151
01:46:48,000 --> 01:46:53,000
但是你要实现像那个 graphq 那么灵活多遍的查询

2152
01:46:53,000 --> 01:46:56,000
而且要达到那种那种那种好用程度

2153
01:46:56,000 --> 01:46:59,000
你真的是要后台要做很多工作

2154
01:46:59,000 --> 01:47:01,000
他能够实现这个 graph 的结构的

2155
01:47:01,000 --> 01:47:08,000
就这个 graphq 出现我发现就是其实这一个抽象层级的需求是非常明显的

2156
01:47:08,000 --> 01:47:12,000
但是在他做出来在 graphq 而出现之前好像没有人去讨论他

2157
01:47:12,000 --> 01:47:15,000
是有的就是但是就说因为

2158
01:47:15,000 --> 01:47:18,000
无声无声无声大因为他不是 facebook 没有吸引到足够的眼球是吧

2159
01:47:18,000 --> 01:47:21,000
我觉得主要是因为现在的主流就是

2160
01:47:21,000 --> 01:47:30,000
就除了像 facebook 这种巨头能够有精力或者有这个资源去把它的后端做成一个这种类这种解构的方式去查询的话

2161
01:47:30,000 --> 01:47:32,000
其他那些中小企业真的是还蛮难

2162
01:47:32,000 --> 01:47:39,000
因为没有一个现成的或者说被像 mysicle 这种级别能被大众广泛接受有好用的图数据库嘛

2163
01:47:39,000 --> 01:47:42,000
有几个例子像什么

2164
01:47:42,000 --> 01:47:43,000
Neo 4 J

2165
01:47:43,000 --> 01:47:45,000
那个什么 ORNDB 之类的

2166
01:47:45,000 --> 01:47:49,000
他们但是就是你可以看到就成功案例很少

2167
01:47:49,000 --> 01:47:52,000
就是你首先一个熟悉程度也就是他的成熟程度本身也不够

2168
01:47:52,000 --> 01:47:54,000
然后就是大家也不太敢用

2169
01:47:54,000 --> 01:47:59,000
然后这样的话就会反而导致这一块其实在市场上是很弱的

2170
01:47:59,000 --> 01:48:05,000
我倒是希望说这个 relay 或者是 graphql 正式开源出来之后

2171
01:48:05,000 --> 01:48:13,000
大家会意识到这个的好处以及对这个包括前端开发的这个难度的降低

2172
01:48:13,000 --> 01:48:15,000
然后包括后端的开发的成本的降低

2173
01:48:15,000 --> 01:48:19,000
然后能够使得大家更多去思考那我要不要用一下这种图

2174
01:48:19,000 --> 01:48:23,000
就是以图为主要结构的这种数据后台

2175
01:48:23,000 --> 01:48:29,000
对这算是 Facebook 对于整个 tech stack 做出的一个贡献吗

2176
01:48:29,000 --> 01:48:34,000
其实那个 Rail you mentioned

2177
01:48:34,000 --> 01:48:37,000
那图结构的 database

2178
01:48:37,000 --> 01:48:41,000
我其实我就是 honest question

2179
01:48:41,000 --> 01:48:48,000
我并不清楚这个东西它那个命名是一个出于一个 branding 的考虑

2180
01:48:48,000 --> 01:48:50,000
还是它真的就是所谓图

2181
01:48:50,000 --> 01:48:54,000
我没有听说过图 database 就是 honest 没有听说过

2182
01:48:54,000 --> 01:48:59,000
对这个是一个相对于没有那么大众的一个应用

2183
01:48:59,000 --> 01:49:02,000
其实图书书书书书书书的问题也是蛮简单的

2184
01:49:02,000 --> 01:49:05,000
你可以想象一个普通的是一个社交网络

2185
01:49:05,000 --> 01:49:08,000
只有一种类型的节点我们就考虑最简单的一个情况

2186
01:49:08,000 --> 01:49:11,000
我们又有有用户就是 user

2187
01:49:11,000 --> 01:49:13,000
你和我然后吴湯我们三个人

2188
01:49:13,000 --> 01:49:15,000
然后图书书书书书书什么

2189
01:49:15,000 --> 01:49:16,000
就是从头节点

2190
01:49:16,000 --> 01:49:18,000
我们这个本身节点有些是有些什么样的属性

2191
01:49:18,000 --> 01:49:21,000
比如说我作为一个人

2192
01:49:21,000 --> 01:49:23,000
这个 user 这么一个节点有什么名字

2193
01:49:23,000 --> 01:49:27,000
性别年龄出生日期之类的一些 attributes

2194
01:49:27,000 --> 01:49:28,000
对吧

2195
01:49:29,000 --> 01:49:31,000
这个是这个是跟传统的包括这种

2196
01:49:31,000 --> 01:49:33,000
我们像 Mexico 这种就是 rdb

2197
01:49:33,000 --> 01:49:34,000
relational database

2198
01:49:34,000 --> 01:49:35,000
其实是没有太大区别的

2199
01:49:35,000 --> 01:49:38,000
无非就是说每一个节点

2200
01:49:38,000 --> 01:49:40,000
对应 relation database 里面的一个行

2201
01:49:40,000 --> 01:49:41,000
一个 role

2202
01:49:41,000 --> 01:49:43,000
然后每一个 attribute

2203
01:49:43,000 --> 01:49:47,000
对应它的传统的 relation database 的

2204
01:49:47,000 --> 01:49:48,000
一个 column

2205
01:49:48,000 --> 01:49:49,000
对吧

2206
01:49:49,000 --> 01:49:49,000
对

2207
01:49:49,000 --> 01:49:53,000
然后但是一个图书

2208
01:49:53,000 --> 01:49:55,000
就更加重要的一点

2209
01:49:55,000 --> 01:49:57,000
其实是存储这个节点

2210
01:49:57,000 --> 01:49:58,000
也节点之间的关系

2211
01:49:58,000 --> 01:49:59,000
比如好像说我可以说

2212
01:49:59,000 --> 01:50:00,000
我可以 friend 你们两个

2213
01:50:00,000 --> 01:50:02,000
你们可以两个之间互相 friend

2214
01:50:02,000 --> 01:50:03,000
那我可以

2215
01:50:03,000 --> 01:50:05,000
然后你可以和别的人

2216
01:50:05,000 --> 01:50:06,000
也就是互相 friend

2217
01:50:06,000 --> 01:50:07,000
这个时候的话

2218
01:50:07,000 --> 01:50:09,000
这个时候它表现出来的结构

2219
01:50:09,000 --> 01:50:11,000
如果我们在传统的一个 relation database

2220
01:50:11,000 --> 01:50:12,000
里面去实现会怎么样

2221
01:50:12,000 --> 01:50:13,000
会通过一个

2222
01:50:13,000 --> 01:50:17,000
因为一张表来做一个连接

2223
01:50:17,000 --> 01:50:19,000
对另外一张表的时候

2224
01:50:19,000 --> 01:50:20,000
叫做关注的

2225
01:50:20,000 --> 01:50:20,000
对

2226
01:50:20,000 --> 01:50:21,000
sorry

2227
01:50:21,000 --> 01:50:22,000
cut it off

2228
01:50:22,000 --> 01:50:25,000
我只是做一个 check 而已

2229
01:50:25,000 --> 01:50:26,000
所以谢谢你的解释

2230
01:50:26,000 --> 01:50:28,000
但是我们还是不忘了

2231
01:50:28,000 --> 01:50:30,000
我觉得这段就不用在 podcast

2232
01:50:30,000 --> 01:50:30,000
没啥

2233
01:50:30,000 --> 01:50:32,000
可以放进来接着解释完

2234
01:50:32,000 --> 01:50:33,000
很多人不理解

2235
01:50:33,000 --> 01:50:36,000
就听众里面可能不是很熟悉这个概念

2236
01:50:36,000 --> 01:50:37,000
因为这个确实在工业中

2237
01:50:37,000 --> 01:50:38,000
我也用的不多了

2238
01:50:38,000 --> 01:50:40,000
对因为对我来讲的话

2239
01:50:40,000 --> 01:50:41,000
我觉得就是说

2240
01:50:41,000 --> 01:50:42,000
那个 graphql

2241
01:50:42,000 --> 01:50:44,000
所谓 graph 只是一个 branding 而已

2242
01:50:44,000 --> 01:50:46,000
并不是真正在说

2243
01:50:46,000 --> 01:50:47,000
不它真的是

2244
01:50:47,000 --> 01:50:49,000
就是说 graphql 本身

2245
01:50:49,000 --> 01:50:51,000
它真的是要有这么一种

2246
01:50:51,000 --> 01:50:54,000
对后端实施是有很大要求的

2247
01:50:54,000 --> 01:50:56,000
你才可以做到它那么灵活的查询

2248
01:50:56,000 --> 01:50:57,000
不然的话你可以做

2249
01:50:57,000 --> 01:51:00,000
你可以去用什么像 adaptor 的方式

2250
01:51:00,000 --> 01:51:02,000
去把 graphql 的查询

2251
01:51:02,000 --> 01:51:04,000
转换成对应的这个 rest 的查询

2252
01:51:04,000 --> 01:51:05,000
但是这样的效率非常低

2253
01:51:05,000 --> 01:51:07,000
因为这个整个你的

2254
01:51:07,000 --> 01:51:09,000
这个后台的数据库的组织的结构

2255
01:51:09,000 --> 01:51:13,000
就不是按照一个那种图的查询的方式

2256
01:51:13,000 --> 01:51:13,000
来查询的

2257
01:51:13,000 --> 01:51:15,000
因为图里面查询的最常见的什么

2258
01:51:15,000 --> 01:51:17,000
就是便利

2259
01:51:17,000 --> 01:51:17,000
节点便利

2260
01:51:17,000 --> 01:51:18,000
对吧

2261
01:51:18,000 --> 01:51:20,000
这个在你的 RDB

2262
01:51:20,000 --> 01:51:21,000
这个这么在

2263
01:51:21,000 --> 01:51:23,000
如果在一个传达 relation database 里面

2264
01:51:23,000 --> 01:51:25,000
这个性能是作死的

2265
01:51:25,000 --> 01:51:28,000
你想一下你要假设你在一个

2266
01:51:28,000 --> 01:51:29,000
社交网状那个图里面

2267
01:51:29,000 --> 01:51:31,000
你要从某个节点为中心

2268
01:51:31,000 --> 01:51:32,000
查询它的好友的话

2269
01:51:32,000 --> 01:51:33,000
你在一个传统的

2270
01:51:33,000 --> 01:51:35,000
这个 relation database 里面

2271
01:51:35,000 --> 01:51:37,000
你要去要查好多张表

2272
01:51:37,000 --> 01:51:39,000
你要不要

2273
01:51:39,000 --> 01:51:40,000
你要查三个维度的好友

2274
01:51:40,000 --> 01:51:42,000
就是三度分割的好友的话

2275
01:51:42,000 --> 01:51:44,000
你要用那个传统的 relation database

2276
01:51:44,000 --> 01:51:45,000
查询的话

2277
01:51:45,000 --> 01:51:46,000
这是非常困难的

2278
01:51:46,000 --> 01:51:48,000
所以我就是在想

2279
01:51:48,000 --> 01:51:49,000
就是说

2280
01:51:49,000 --> 01:51:52,000
其实现在有这么多的

2281
01:51:52,000 --> 01:51:53,000
社交场合的应用

2282
01:51:53,000 --> 01:51:56,000
反而是没有一个基于

2283
01:51:56,000 --> 01:51:58,000
能够很好满足社交查询的

2284
01:51:58,000 --> 01:52:00,000
这么一种数据存储的引擎

2285
01:52:00,000 --> 01:52:02,000
能够大规模的方便的使用

2286
01:52:02,000 --> 01:52:03,000
其实是蛮悲哀的一个现状

2287
01:52:03,000 --> 01:52:06,000
其实也是挺奇怪的

2288
01:52:06,000 --> 01:52:07,000
因为很难

2289
01:52:07,000 --> 01:52:10,000
这确实挺难的

2290
01:52:10,000 --> 01:52:13,000
就不是说我们传统的作业

2291
01:52:13,000 --> 01:52:14,000
比如那边是你可以性能不够

2292
01:52:14,000 --> 01:52:15,000
你可以做简单的

2293
01:52:15,000 --> 01:52:16,000
就是 sharding

2294
01:52:16,000 --> 01:52:17,000
就分割

2295
01:52:17,000 --> 01:52:18,000
按照这个

2296
01:52:18,000 --> 01:52:21,000
按照这个 key 的范围来分割

2297
01:52:21,000 --> 01:52:23,000
但是你怎么去分割一个图呢

2298
01:52:23,000 --> 01:52:24,000
就很难的一件事情

2299
01:52:24,000 --> 01:52:25,000
对

2300
01:52:25,000 --> 01:52:27,000
所以就里面还是有很多这种

2301
01:52:27,000 --> 01:52:29,000
非常 hardcore 的

2302
01:52:29,000 --> 01:52:30,000
computer science 的东西

2303
01:52:30,000 --> 01:52:31,000
在里面要解决

2304
01:52:31,000 --> 01:52:34,000
而市面上现有的解决方案

2305
01:52:34,000 --> 01:52:36,000
都给人一种信心不足的感觉

2306
01:52:36,000 --> 01:52:38,000
对

2307
01:52:38,000 --> 01:52:41,000
其实这段

2308
01:52:41,000 --> 01:52:42,000
我觉得是蛮担忧的

2309
01:52:42,000 --> 01:52:43,000
就是说

2310
01:52:43,000 --> 01:52:44,000
如果这个解决不好

2311
01:52:44,000 --> 01:52:45,000
那个 graphcare 这种东西

2312
01:52:45,000 --> 01:52:46,000
就真的是只能

2313
01:52:46,000 --> 01:52:47,000
局限于像 Facebook

2314
01:52:47,000 --> 01:52:48,000
像 Google

2315
01:52:48,000 --> 01:52:50,000
这种庞大的企业

2316
01:52:50,000 --> 01:52:51,000
它能够有这个资源

2317
01:52:51,000 --> 01:52:53,000
或者这个能力去实现自己的

2318
01:52:53,000 --> 01:52:54,000
或者维护自己的

2319
01:52:54,000 --> 01:52:56,000
这么一套基于图的

2320
01:52:56,000 --> 01:52:58,000
或者是以图结构为导向的

2321
01:52:58,000 --> 01:53:00,000
这么一个后台系统

2322
01:53:00,000 --> 01:53:02,000
否则其他人还是只能

2323
01:53:02,000 --> 01:53:03,000
很乐呵呵的继续用的 rest

2324
01:53:03,000 --> 01:53:05,000
对

2325
01:53:05,000 --> 01:53:07,000
对

2326
01:53:07,000 --> 01:53:09,000
那为了你说一下

2327
01:53:09,000 --> 01:53:10,000
就整个

2328
01:53:10,000 --> 01:53:10,000
就是说

2329
01:53:10,000 --> 01:53:12,000
刚才我们讲的 react 相关

2330
01:53:12,000 --> 01:53:14,000
包括你在会上看到一些东西

2331
01:53:14,000 --> 01:53:15,000
但是你说

2332
01:53:15,000 --> 01:53:16,000
整个来讲

2333
01:53:16,000 --> 01:53:18,000
你对这个会本身是什么样的一个感受

2334
01:53:21,000 --> 01:53:24,000
这是我所去过的比较好的一个会之一了

2335
01:53:24,000 --> 01:53:28,000
因为整个的所有的 speech 都非常的有意义

2336
01:53:28,000 --> 01:53:31,000
非常能觉得从中能够学到东西都不是在

2337
01:53:31,000 --> 01:53:34,000
也都非常有意义

2338
01:53:34,000 --> 01:53:35,000
非常 hardcore CS

2339
01:53:35,000 --> 01:53:37,000
我觉得这一点是非常难得的

2340
01:53:37,000 --> 01:53:43,000
那个会的组织肯定做了很好的工作来选取这些

2341
01:53:43,000 --> 01:53:46,000
这些演讲者和演讲本身

2342
01:53:46,000 --> 01:53:46,000
嗯

2343
01:53:46,000 --> 01:53:47,000
嗯

2344
01:53:47,000 --> 01:53:50,000
我们有非常多的那个 social 的机会

2345
01:53:50,000 --> 01:53:52,000
在其中也遇到了非常非常多的人

2346
01:53:52,000 --> 01:53:53,000
然后 react 呢

2347
01:53:53,000 --> 01:53:55,000
真的是被应用到各种各方各面

2348
01:53:55,000 --> 01:54:01,000
很多你想不到的一些 application 都在使用 react

2349
01:54:01,000 --> 01:54:03,000
都在或者在考虑使用 react

2350
01:54:03,000 --> 01:54:04,000
嗯嗯

2351
01:54:04,000 --> 01:54:08,000
非常的激动人心的就是可能我看到这么多实际的应用

2352
01:54:08,000 --> 01:54:13,000
这么多积极主动来参与这个社区的人

2353
01:54:13,000 --> 01:54:19,000
所以整整整体来说我觉得是个非常非常非常好的一个气氛

2354
01:54:19,000 --> 01:54:23,000
大家都非常的对这个 react 的前景都非常乐观

2355
01:54:23,000 --> 01:54:33,000
嗯我也很高兴看到 facebook 对整个会议的支持跟对整个这个 react 的技术的支持

2356
01:54:33,000 --> 01:54:39,000
After all 我也觉得非常开心能够得到这个 react native 的一个 preview

2357
01:54:39,000 --> 01:54:41,000
我有给我的同事演示

2358
01:54:41,000 --> 01:54:47,000
这对我们做接下来的一些 technology 选项都是非常有帮助的

2359
01:54:47,000 --> 01:54:51,000
所以贵公司也是要出一个 mobile 领域的客户端的吗

2360
01:54:51,000 --> 01:54:55,000
我们一直有 mobile 的客户端

2361
01:54:55,000 --> 01:54:57,000
我们有 iOS 跟 Android 的客户端

2362
01:54:57,000 --> 01:55:02,000
然后 well foreseeable future 肯定不是 react native 对不对

2363
01:55:02,000 --> 01:55:06,000
但是对于那个技术的选行观察这个技术的发展来说的话

2364
01:55:06,000 --> 01:55:10,000
我们肯定现在是把它是摆在一个比较重要的位置了

2365
01:55:10,000 --> 01:55:11,000
ok

2366
01:55:11,000 --> 01:55:12,000
对对没错

2367
01:55:12,000 --> 01:55:14,000
ok 那行吧

2368
01:55:14,000 --> 01:55:20,000
今天我们非常高兴邀请到 Vilo 来给我们讨论这个 react 的一系列相关的东西

2369
01:55:20,000 --> 01:55:24,000
然后那今天的节目就到此为止吧

2370
01:55:24,000 --> 01:55:25,000
谢谢大家

2371
01:55:25,000 --> 01:55:26,000
谢谢大家的收听

2372
01:55:26,000 --> 01:55:28,000
谢谢大家

2373
01:55:28,000 --> 01:55:30,000
我们下期再见

2374
01:55:30,000 --> 01:55:32,000
我还要念那个吗

2375
01:55:32,000 --> 01:55:33,000
你念吧

2376
01:55:33,000 --> 01:55:34,000
ok

2377
01:55:34,000 --> 01:55:36,000
感谢大家收听《内核恐慌》

2378
01:55:36,000 --> 01:55:40,000
也欢迎大家收听 IPN 旗下的其他五档 podcast

2379
01:55:40,000 --> 01:55:42,000
包括技术主题节目

2380
01:55:42,000 --> 01:55:45,000
IT 公论医疗主题节目太一来了

2381
01:55:45,000 --> 01:55:47,000
美食节目未知道

2382
01:55:47,000 --> 01:55:49,000
以及艺术类节目流行通信

2383
01:55:49,000 --> 01:55:53,000
最后还有不知道是在播什么的五主题节目五不次元

2384
01:55:53,000 --> 01:55:54,000
感谢大家的收听

2385
01:55:54,000 --> 01:55:56,000
感谢大家收听

2386
01:55:56,000 --> 01:55:57,000
感谢大家收听

2387
01:55:57,000 --> 01:55:58,000
感谢大家收听

2388
01:55:58,000 --> 01:55:59,000
感谢大家收听

