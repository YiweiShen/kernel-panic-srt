1
00:00:00,000 --> 00:00:01,000
您正在收听的是

2
00:00:01,000 --> 00:00:03,000
IPN Podcast 的网络旗下的

3
00:00:03,000 --> 00:00:05,000
IT 技术主义节目

4
00:00:05,000 --> 00:00:06,000
内核恐慌

5
00:00:06,000 --> 00:00:07,000
我们号称 Hardcore

6
00:00:07,000 --> 00:00:09,000
但是也没有干货

7
00:00:09,000 --> 00:00:10,000
想听的人听

8
00:00:10,000 --> 00:00:11,000
不想听的人就别听

9
00:00:11,000 --> 00:00:13,000
内核恐慌的网址是

10
00:00:13,000 --> 00:00:15,000
kernelpanic.fm

11
00:00:15,000 --> 00:00:16,000
我们推荐大家

12
00:00:16,000 --> 00:00:19,000
使用泛用型 Podcast 客户端

13
00:00:19,000 --> 00:00:20,000
订阅我们的节目

14
00:00:20,000 --> 00:00:21,000
如果您不知道

15
00:00:21,000 --> 00:00:22,000
什么是客户端

16
00:00:22,000 --> 00:00:23,000
请访问

17
00:00:23,000 --> 00:00:25,000
ipn.li

18
00:00:25,000 --> 00:00:27,000
slashfaq

19
00:00:27,000 --> 00:00:29,000
欢迎你为我们的节目捐款

20
00:00:29,000 --> 00:00:30,000
捐款地址是

21
00:00:30,000 --> 00:00:31,000
ipn.li

22
00:00:31,000 --> 00:00:33,000
slashkernelpanic

23
00:00:33,000 --> 00:00:34,000
slashdonate

24
00:00:34,000 --> 00:00:37,000
捐款金额随意

25
00:00:37,000 --> 00:00:39,000
捐款不会为你带来什么

26
00:00:39,000 --> 00:00:41,000
不捐也不会让你失去什么

27
00:00:41,000 --> 00:00:43,000
OK

28
00:00:43,000 --> 00:00:46,000
今天是我们的第 18 期节目

29
00:00:46,000 --> 00:00:48,000
不过 Rail 因为非常忙

30
00:00:48,000 --> 00:00:51,000
不能参加本期节目的录音了

31
00:00:51,000 --> 00:00:52,000
不过

32
00:00:52,000 --> 00:00:55,000
他一定会参加明天的 IT 公论录音

33
00:00:55,000 --> 00:00:55,000
所以各位

34
00:00:55,000 --> 00:00:58,000
有些会员们

35
00:00:58,000 --> 00:01:00,000
可以送一口气

36
00:01:00,000 --> 00:01:03,000
另外单纯因为迷恋

37
00:01:03,000 --> 00:01:06,000
Rail 的声音的朋友

38
00:01:06,000 --> 00:01:08,000
听到这里

39
00:01:08,000 --> 00:01:09,000
其实就可以转台了

40
00:01:09,000 --> 00:01:10,000
因为

41
00:01:10,000 --> 00:01:12,000
必须说

42
00:01:12,000 --> 00:01:14,000
有台的节目更好听

43
00:01:14,000 --> 00:01:16,000
尤其推荐上一期

44
00:01:16,000 --> 00:01:17,000
太一来了

45
00:01:17,000 --> 00:01:19,000
主题是情趣用品

46
00:01:19,000 --> 00:01:22,000
请在家长缺席一下

47
00:01:22,000 --> 00:01:26,000
所以仍旧坚守着

48
00:01:26,000 --> 00:01:26,000
内恨恐慌的朋友

49
00:01:26,000 --> 00:01:27,000
没你们好

50
00:01:27,000 --> 00:01:28,000
本期没有 Rail

51
00:01:28,000 --> 00:01:30,000
但是也没有嘉宾

52
00:01:30,000 --> 00:01:32,000
只有我一个人在这边

53
00:01:32,000 --> 00:01:34,000
孤独的坚守着阵地

54
00:01:34,000 --> 00:01:38,000
当然这是你听起来的错觉

55
00:01:38,000 --> 00:01:39,000
因为实际情况是

56
00:01:39,000 --> 00:01:41,000
我的女朋友此刻正坐在旁边

57
00:01:41,000 --> 00:01:42,000
为我端茶到水

58
00:01:42,000 --> 00:01:43,000
山风垂背

59
00:01:43,000 --> 00:01:46,000
所以本期的主题就是

60
00:01:46,000 --> 00:01:47,000
程序员怎么样

61
00:01:47,000 --> 00:01:49,000
才能找到一个女朋友

62
00:01:49,000 --> 00:01:51,000
但是

63
00:01:51,000 --> 00:01:53,000
在进入主题之前

64
00:01:53,000 --> 00:01:55,000
我们先来念几封读者来信

65
00:01:55,000 --> 00:01:59,000
首先是一位叫做

66
00:01:59,000 --> 00:02:00,000
营火的朋友

67
00:02:00,000 --> 00:02:02,000
他说

68
00:02:02,000 --> 00:02:06,000
第 17 期的后面提到

69
00:02:06,000 --> 00:02:07,000
武涛说

70
00:02:07,000 --> 00:02:09,000
不知道 DLL 的图标

71
00:02:09,000 --> 00:02:10,000
是什么意思

72
00:02:10,000 --> 00:02:12,000
所以不知道可不可以删

73
00:02:12,000 --> 00:02:14,000
而我小时候呢

74
00:02:14,000 --> 00:02:15,000
试过将系统的

75
00:02:15,000 --> 00:02:17,000
DLL 文件删除了

76
00:02:17,000 --> 00:02:18,000
那个时候玩

77
00:02:18,000 --> 00:02:19,000
表哥家的电脑

78
00:02:19,000 --> 00:02:20,000
他们出去了

79
00:02:20,000 --> 00:02:21,000
剩我一个人在玩

80
00:02:21,000 --> 00:02:21,000
核心弹头

81
00:02:21,000 --> 00:02:23,000
玩了一会觉得无聊

82
00:02:23,000 --> 00:02:24,000
就用鼠标乱点

83
00:02:24,000 --> 00:02:25,000
黄花绿的图标

84
00:02:25,000 --> 00:02:26,000
可以点开

85
00:02:26,000 --> 00:02:27,000
有齿轮的图标

86
00:02:27,000 --> 00:02:27,000
都点不开

87
00:02:27,000 --> 00:02:29,000
我就理所当然认为

88
00:02:29,000 --> 00:02:30,000
点不开是没有用的

89
00:02:30,000 --> 00:02:31,000
没有用的就应该被删掉

90
00:02:31,000 --> 00:02:33,000
所以我将

91
00:02:33,000 --> 00:02:34,000
所有能看到的

92
00:02:34,000 --> 00:02:35,000
点不开的文件

93
00:02:35,000 --> 00:02:36,000
都删除了

94
00:02:36,000 --> 00:02:37,000
后面要吃饭

95
00:02:37,000 --> 00:02:38,000
就先把一堆关了机

96
00:02:38,000 --> 00:02:40,000
到晚上表哥回来

97
00:02:40,000 --> 00:02:41,000
发现电脑启动不了

98
00:02:41,000 --> 00:02:42,000
我以为弄烂的电脑

99
00:02:42,000 --> 00:02:43,000
很害怕

100
00:02:43,000 --> 00:02:44,000
因为那个时候

101
00:02:44,000 --> 00:02:45,000
电脑比电视机

102
00:02:45,000 --> 00:02:46,000
和摩托车都贵

103
00:02:46,000 --> 00:02:47,000
赔不起

104
00:02:47,000 --> 00:02:50,000
后来表哥打电话

105
00:02:50,000 --> 00:02:51,000
叫了个同学过来

106
00:02:51,000 --> 00:02:52,000
那个同学在一个

107
00:02:52,000 --> 00:02:53,000
黑乎乎的窗口里面打字

108
00:02:53,000 --> 00:02:55,000
折腾了半个钟头

109
00:02:55,000 --> 00:02:56,000
电脑重新可以用

110
00:02:56,000 --> 00:02:57,000
小小的

111
00:02:57,000 --> 00:02:58,000
我觉得那个人

112
00:02:58,000 --> 00:02:59,000
是大大的高手

113
00:02:59,000 --> 00:03:00,000
很久以后

114
00:03:00,000 --> 00:03:01,000
我才醒不过来

115
00:03:01,000 --> 00:03:02,000
那个时候删掉的文件

116
00:03:02,000 --> 00:03:03,000
是 DLL

117
00:03:03,000 --> 00:03:05,000
那个高手所做的

118
00:03:05,000 --> 00:03:07,000
叫做重装系统

119
00:03:07,000 --> 00:03:07,000
完了

120
00:03:07,000 --> 00:03:10,000
这让我想起

121
00:03:10,000 --> 00:03:11,000
DOS 时代

122
00:03:11,000 --> 00:03:13,000
好像没有这样的疑惑

123
00:03:13,000 --> 00:03:14,000
因为 DOS 时代

124
00:03:14,000 --> 00:03:17,000
如果你不区分

125
00:03:17,000 --> 00:03:18,000
可执行文件和

126
00:03:18,000 --> 00:03:19,000
不可执行文件的话

127
00:03:19,000 --> 00:03:21,000
是很难知道

128
00:03:21,000 --> 00:03:22,000
哪个文件有用

129
00:03:22,000 --> 00:03:23,000
哪个文件没有用的

130
00:03:23,000 --> 00:03:25,000
你只能看扩展明

131
00:03:25,000 --> 00:03:26,000
而如果你不懂

132
00:03:26,000 --> 00:03:27,000
扩展明的意义的话

133
00:03:27,000 --> 00:03:28,000
你是不会

134
00:03:28,000 --> 00:03:29,000
莫名其妙

135
00:03:29,000 --> 00:03:30,000
就删它的

136
00:03:30,000 --> 00:03:33,000
这可能是另外一个

137
00:03:33,000 --> 00:03:34,000
命令行

138
00:03:34,000 --> 00:03:36,000
比较安全的因素

139
00:03:36,000 --> 00:03:39,000
或者说早期的图形化界面

140
00:03:39,000 --> 00:03:41,000
没有默认用户

141
00:03:41,000 --> 00:03:42,000
有可能不知道

142
00:03:42,000 --> 00:03:43,000
自己在干什么

143
00:03:43,000 --> 00:03:45,000
现在的操作性能

144
00:03:45,000 --> 00:03:45,000
都做得很好

145
00:03:45,000 --> 00:03:48,000
把比较容易弄坏的部分

146
00:03:48,000 --> 00:03:50,000
都隐藏了起来

147
00:03:50,000 --> 00:03:52,000
这也让我消息

148
00:03:52,000 --> 00:03:53,000
DOS 时代

149
00:03:53,000 --> 00:03:53,000
重装系统

150
00:03:53,000 --> 00:03:54,000
好像只需要

151
00:03:54,000 --> 00:03:56,000
格式化一下系统盘

152
00:03:56,000 --> 00:03:56,000
就可以了

153
00:03:56,000 --> 00:03:57,000
然后一条命令

154
00:03:57,000 --> 00:03:58,000
Sys

155
00:03:58,000 --> 00:03:59,000
还是什么

156
00:03:59,000 --> 00:04:00,000
还是斜杠

157
00:04:00,000 --> 00:04:01,000
Sys

158
00:04:01,000 --> 00:04:02,000
就可以把 DOS

159
00:04:02,000 --> 00:04:03,000
传播到一个

160
00:04:03,000 --> 00:04:06,000
软盘或者硬盘

161
00:04:06,000 --> 00:04:06,000
让它变成

162
00:04:06,000 --> 00:04:07,000
可以 boot

163
00:04:07,000 --> 00:04:08,000
对

164
00:04:08,000 --> 00:04:10,000
如果各位 90 后听众

165
00:04:10,000 --> 00:04:11,000
没有经历过

166
00:04:11,000 --> 00:04:11,000
那个时代的话

167
00:04:11,000 --> 00:04:13,000
那个时代重装系统

168
00:04:13,000 --> 00:04:14,000
没有光盘可以用

169
00:04:14,000 --> 00:04:16,000
当然更可能

170
00:04:16,000 --> 00:04:17,000
有网络可以用

171
00:04:17,000 --> 00:04:18,000
基本上就是

172
00:04:18,000 --> 00:04:20,000
你有 10 张软盘

173
00:04:20,000 --> 00:04:21,000
甚至更多

174
00:04:21,000 --> 00:04:22,000
我现在已经不记得

175
00:04:22,000 --> 00:04:23,000
那个时候

176
00:04:23,000 --> 00:04:25,000
第一版 Windows 3.2

177
00:04:25,000 --> 00:04:25,000
或者是

178
00:04:25,000 --> 00:04:27,000
我相信 Windows 95

179
00:04:27,000 --> 00:04:28,000
又出过软盘

180
00:04:28,000 --> 00:04:30,000
对

181
00:04:30,000 --> 00:04:30,000
你要把一张

182
00:04:30,000 --> 00:04:31,000
一张软盘

183
00:04:31,000 --> 00:04:33,000
依次插入

184
00:04:33,000 --> 00:04:35,000
软盘吹动器

185
00:04:35,000 --> 00:04:36,000
天哪

186
00:04:36,000 --> 00:04:36,000
软盘吹动器

187
00:04:36,000 --> 00:04:37,000
或者多久

188
00:04:37,000 --> 00:04:38,000
没收过这次

189
00:04:38,000 --> 00:04:38,000
然后

190
00:04:38,000 --> 00:04:40,000
每一张软盘

191
00:04:40,000 --> 00:04:41,000
可能能装给

192
00:04:41,000 --> 00:04:41,000
完整 10%

193
00:04:41,000 --> 00:04:42,000
5%左右

194
00:04:42,000 --> 00:04:43,000
然后

195
00:04:43,000 --> 00:04:45,000
你要耐心的

196
00:04:45,000 --> 00:04:46,000
在那坐着

197
00:04:46,000 --> 00:04:46,000
一张一张

198
00:04:46,000 --> 00:04:48,000
手动的去换软盘

199
00:04:48,000 --> 00:04:48,000
那像现在

200
00:04:48,000 --> 00:04:50,000
科技昌明

201
00:04:50,000 --> 00:04:51,000
只要

202
00:04:51,000 --> 00:04:52,000
写一个文本

203
00:04:52,000 --> 00:04:53,000
文件告诉

204
00:04:53,000 --> 00:04:54,000
电脑

205
00:04:54,000 --> 00:04:54,000
你需要一台

206
00:04:54,000 --> 00:04:55,000
什么样的虚拟机

207
00:04:55,000 --> 00:04:56,000
电脑

208
00:04:56,000 --> 00:04:56,000
很快就可以

209
00:04:56,000 --> 00:04:57,000
在一瞬间

210
00:04:57,000 --> 00:04:59,000
帮你竖起来一台

211
00:04:59,000 --> 00:05:00,000
具有完整的

212
00:05:00,000 --> 00:05:01,000
桑络系统和

213
00:05:01,000 --> 00:05:03,000
程序开发环境的

214
00:05:03,000 --> 00:05:04,000
虚拟机

215
00:05:04,000 --> 00:05:06,000
哎呀

216
00:05:06,000 --> 00:05:07,000
我真是老了

217
00:05:07,000 --> 00:05:08,000
不过

218
00:05:08,000 --> 00:05:09,000
其实我从

219
00:05:09,000 --> 00:05:10,000
很小的时候

220
00:05:10,000 --> 00:05:11,000
就建立起一个信念

221
00:05:11,000 --> 00:05:13,000
只要你不去拆机箱

222
00:05:13,000 --> 00:05:14,000
电脑就是弄不坏

223
00:05:14,000 --> 00:05:16,000
我不知道

224
00:05:16,000 --> 00:05:17,000
现在学编程的朋友们

225
00:05:17,000 --> 00:05:18,000
是不是还有这个

226
00:05:18,000 --> 00:05:19,000
疑惑

227
00:05:19,000 --> 00:05:20,000
就是

228
00:05:20,000 --> 00:05:21,000
有时候会

229
00:05:21,000 --> 00:05:22,000
很担心

230
00:05:22,000 --> 00:05:22,000
把电脑弄坏

231
00:05:22,000 --> 00:05:23,000
但

232
00:05:23,000 --> 00:05:24,000
实际情况就是

233
00:05:24,000 --> 00:05:25,000
只要你好好

234
00:05:25,000 --> 00:05:26,000
做备份

235
00:05:26,000 --> 00:05:28,000
数据别弄丢

236
00:05:28,000 --> 00:05:31,000
操作系统本身

237
00:05:31,000 --> 00:05:32,000
基本上是

238
00:05:32,000 --> 00:05:33,000
非常

239
00:05:33,000 --> 00:05:35,000
耐操的

240
00:05:35,000 --> 00:05:36,000
哪怕你删掉

241
00:05:36,000 --> 00:05:37,000
所有的 DL

242
00:05:37,000 --> 00:05:38,000
且不论你

243
00:05:38,000 --> 00:05:39,000
现在你是否

244
00:05:39,000 --> 00:05:40,000
能够安全的

245
00:05:40,000 --> 00:05:41,000
删除一堆 DL

246
00:05:41,000 --> 00:05:43,000
而不被电脑发现

247
00:05:43,000 --> 00:05:43,000
或者被电脑

248
00:05:43,000 --> 00:05:44,000
补救回来

249
00:05:44,000 --> 00:05:46,000
即便你删掉了

250
00:05:46,000 --> 00:05:47,000
电脑也是

251
00:05:47,000 --> 00:05:48,000
永远可以恢复的

252
00:05:48,000 --> 00:05:49,000
只要你不拆机箱

253
00:05:49,000 --> 00:05:50,000
OK

254
00:05:50,000 --> 00:05:51,000
接下来念下一封

255
00:05:51,000 --> 00:05:51,000
读者来信

256
00:05:51,000 --> 00:05:53,000
一位叫做

257
00:05:53,000 --> 00:05:54,000
淘气红的朋友

258
00:05:54,000 --> 00:05:55,000
说

259
00:05:55,000 --> 00:05:57,000
第 17 期提到

260
00:05:57,000 --> 00:05:59,000
飞机重启的时候

261
00:05:59,000 --> 00:06:00,000
要是听到的

262
00:06:00,000 --> 00:06:01,000
提示音是

263
00:06:01,000 --> 00:06:02,000
小霸王

264
00:06:02,000 --> 00:06:03,000
骑得不穷啊

265
00:06:03,000 --> 00:06:04,000
那才是

266
00:06:04,000 --> 00:06:05,000
整个人都不好

267
00:06:05,000 --> 00:06:10,000
来自马来西亚的

268
00:06:10,000 --> 00:06:10,000
听众

269
00:06:10,000 --> 00:06:11,000
李先生

270
00:06:11,000 --> 00:06:12,000
写了一封

271
00:06:12,000 --> 00:06:13,000
读者来信说

272
00:06:13,000 --> 00:06:15,000
你们说了

273
00:06:15,000 --> 00:06:16,000
在 Windows 平台上

274
00:06:16,000 --> 00:06:17,000
现在可以开发

275
00:06:17,000 --> 00:06:19,000
Object-C 的事情

276
00:06:19,000 --> 00:06:20,000
虽然我还没有

277
00:06:20,000 --> 00:06:21,000
用过微软

278
00:06:21,000 --> 00:06:22,000
这款新的开发工具

279
00:06:22,000 --> 00:06:23,000
但是我是

280
00:06:23,000 --> 00:06:24,000
这样理解的

281
00:06:24,000 --> 00:06:25,000
微软的 Visual Studio

282
00:06:25,000 --> 00:06:27,000
是主要让您编译

283
00:06:27,000 --> 00:06:29,000
Object-C 的原代码

284
00:06:29,000 --> 00:06:31,000
但并不会生成

285
00:06:31,000 --> 00:06:33,000
iOS OS X 平台上的

286
00:06:33,000 --> 00:06:34,000
Binary Code

287
00:06:34,000 --> 00:06:35,000
而是生成

288
00:06:35,000 --> 00:06:36,000
Windows 平台的

289
00:06:36,000 --> 00:06:37,000
Universal Binary Code

290
00:06:37,000 --> 00:06:39,000
所以并不存在

291
00:06:39,000 --> 00:06:40,000
你们所说的

292
00:06:40,000 --> 00:06:42,000
如何在 Windows 上

293
00:06:42,000 --> 00:06:42,000
提交

294
00:06:42,000 --> 00:06:43,000
iOS App

295
00:06:43,000 --> 00:06:44,000
到 App Store 的问题

296
00:06:44,000 --> 00:06:46,000
因为微软并没有

297
00:06:46,000 --> 00:06:47,000
想要以 Visual Studio

298
00:06:47,000 --> 00:06:48,000
取代

299
00:06:48,000 --> 00:06:49,000
Xcode 的想法

300
00:06:49,000 --> 00:06:50,000
括号

301
00:06:50,000 --> 00:06:51,000
差个话题

302
00:06:51,000 --> 00:06:52,000
无套还是瑞

303
00:06:52,000 --> 00:06:53,000
我有提到说

304
00:06:53,000 --> 00:06:54,000
Xcode

305
00:06:54,000 --> 00:06:54,000
的 Alternative

306
00:06:54,000 --> 00:06:55,000
开发工具

307
00:06:55,000 --> 00:06:56,000
那应该是

308
00:06:56,000 --> 00:06:57,000
Jetbrain

309
00:06:57,000 --> 00:06:57,000
的 App Code

310
00:06:57,000 --> 00:07:00,000
不过这款工具

311
00:07:00,000 --> 00:07:01,000
是用你们讨厌的

312
00:07:01,000 --> 00:07:02,000
Java 所开发的

313
00:07:02,000 --> 00:07:03,000
笑脸

314
00:07:03,000 --> 00:07:04,000
括号完毕

315
00:07:04,000 --> 00:07:05,000
这边插一句

316
00:07:05,000 --> 00:07:06,000
就是后来

317
00:07:06,000 --> 00:07:07,000
我也想起来

318
00:07:07,000 --> 00:07:08,000
Jetbrain

319
00:07:08,000 --> 00:07:08,000
的 App Code

320
00:07:08,000 --> 00:07:10,000
对

321
00:07:10,000 --> 00:07:10,000
Jetbrain

322
00:07:10,000 --> 00:07:11,000
的 App Code

323
00:07:11,000 --> 00:07:11,000
都是用 Jetbrain

324
00:07:11,000 --> 00:07:12,000
的

325
00:07:12,000 --> 00:07:13,000
不过这并不妨碍

326
00:07:13,000 --> 00:07:14,000
它是一款

327
00:07:14,000 --> 00:07:15,000
优秀的 ID

328
00:07:15,000 --> 00:07:18,000
Jetbrain

329
00:07:18,000 --> 00:07:18,000
是可以做出

330
00:07:18,000 --> 00:07:19,000
好东西的

331
00:07:19,000 --> 00:07:20,000
这个我从来

332
00:07:20,000 --> 00:07:21,000
没有否认过

333
00:07:21,000 --> 00:07:23,000
但是只是你用 Jetbrain

334
00:07:23,000 --> 00:07:24,000
做东西的过程

335
00:07:24,000 --> 00:07:25,000
比较淡疼

336
00:07:25,000 --> 00:07:26,000
取决于你是

337
00:07:26,000 --> 00:07:27,000
比较注重结果

338
00:07:27,000 --> 00:07:29,000
还是比较注重过程

339
00:07:29,000 --> 00:07:30,000
我觉得过程

340
00:07:30,000 --> 00:07:32,000
还是挺重要的

341
00:07:32,000 --> 00:07:35,000
回到李先生的来信

342
00:07:35,000 --> 00:07:37,000
他接着说

343
00:07:37,000 --> 00:07:39,000
微软主要想要

344
00:07:39,000 --> 00:07:40,000
借此新版的 Visual Studio

345
00:07:40,000 --> 00:07:42,000
来让许多只为

346
00:07:42,000 --> 00:07:43,000
Apple 开发软件的开发者

347
00:07:43,000 --> 00:07:46,000
提供一个快速从 iOS

348
00:07:46,000 --> 00:07:47,000
移植到 Windows 的工具

349
00:07:47,000 --> 00:07:49,000
我认为这是一个

350
00:07:49,000 --> 00:07:49,000
比较聪明的手段

351
00:07:49,000 --> 00:07:51,000
来拉拢 iOS 和 Android 的开发者

352
00:07:51,000 --> 00:07:54,000
Apple 早期在推出 OS 10 的时候

353
00:07:54,000 --> 00:07:55,000
也用过这一招

354
00:07:55,000 --> 00:07:58,000
他们当时使用 Rosetta 来

355
00:07:58,000 --> 00:08:01,000
这位朋友这边可能写错了

356
00:08:01,000 --> 00:08:02,000
我记得那个东西叫做 Rosetta

357
00:08:02,000 --> 00:08:04,000
就是罗塞塔石碑的那次

358
00:08:04,000 --> 00:08:07,000
来帮助开发者过渡

359
00:08:07,000 --> 00:08:10,000
从 OS 9 到 OS 10

360
00:08:10,000 --> 00:08:14,000
同时也在 Xcode 里面提供了多元的编译

361
00:08:14,000 --> 00:08:15,000
比如说 Object C

362
00:08:15,000 --> 00:08:17,000
C 和 C++

363
00:08:17,000 --> 00:08:22,000
来以这种方式让 Adobe 或者微软

364
00:08:22,000 --> 00:08:24,000
这些用 C 或者 C++的

365
00:08:24,000 --> 00:08:26,000
开发软件的公司

366
00:08:26,000 --> 00:08:27,000
也可以顺利的将 Photoshop

367
00:08:27,000 --> 00:08:29,000
Office 等旗舰级别的软件

368
00:08:29,000 --> 00:08:31,000
顺利一直到 OS 10

369
00:08:31,000 --> 00:08:36,000
如果您有兴趣知道详情

370
00:08:36,000 --> 00:08:38,000
以下的视频是 VeroStudio Compiler Team

371
00:08:38,000 --> 00:08:40,000
在 Build 大会上的展示

372
00:08:40,000 --> 00:08:42,000
请从 27 分 20 秒开始看

373
00:08:42,000 --> 00:08:45,000
然后给了一个 Channel 9 的 link

374
00:08:45,000 --> 00:08:48,000
这个 link 我们会贴在 show notes 里面

375
00:08:48,000 --> 00:08:50,000
我会贴在 show notes 里面

376
00:08:50,000 --> 00:08:51,000
我怎么停不了说我们呢

377
00:08:51,000 --> 00:08:53,000
哎呀好孤单

378
00:08:53,000 --> 00:08:57,000
这里简述视频里的一些重点

379
00:08:59,000 --> 00:09:01,000
编辑器采用 C-Long

380
00:09:01,000 --> 00:09:05,000
也就是 C++ object C 的编辑器的 frontend

381
00:09:05,000 --> 00:09:10,000
和 C 2 也就是微软编辑器的 backend

382
00:09:10,000 --> 00:09:14,000
在 VeroStudio 里面可以使用

383
00:09:14,000 --> 00:09:18,000
object C 直接调用 Windows API

384
00:09:18,000 --> 00:09:22,000
然后编辑后的代码

385
00:09:22,000 --> 00:09:23,000
并不是在 emulator 上的疫情

386
00:09:23,000 --> 00:09:26,000
而是 Windows Universal 的原生代码

387
00:09:26,000 --> 00:09:30,000
微软实现了 iOS 上的一部分 API

388
00:09:30,000 --> 00:09:33,000
他们称之为 subset of iOS API

389
00:09:33,000 --> 00:09:36,000
计划实现的 API 包括 OpenGL

390
00:09:36,000 --> 00:09:37,000
OpenAL

391
00:09:37,000 --> 00:09:37,000
Sensor

392
00:09:37,000 --> 00:09:39,000
UIKit

393
00:09:39,000 --> 00:09:40,000
CoreAnimation

394
00:09:40,000 --> 00:09:40,000
等等

395
00:09:40,000 --> 00:09:43,000
最后视频里面有个小花絮

396
00:09:43,000 --> 00:09:46,000
当台上微软产品经理

397
00:09:46,000 --> 00:09:48,000
问台下有多少人在为 Apple 开发产品的时候

398
00:09:49,000 --> 00:09:50,000
台下来有一半人举手

399
00:09:50,000 --> 00:09:54,000
好 非常感谢这位李先生的来信

400
00:09:54,000 --> 00:09:56,000
干活相当多

401
00:09:56,000 --> 00:10:01,000
他提到了这个 Apple 早期在推出 OS 10 的时候

402
00:10:01,000 --> 00:10:05,000
使用 Rosetta 来帮助开发者从 OS 9 过渡到 OS 10

403
00:10:05,000 --> 00:10:09,000
我记得那个时候给 Apple 开发程序是要用

404
00:10:09,000 --> 00:10:13,000
除了 S Code 还有一个东西叫什么

405
00:10:13,000 --> 00:10:14,000
Cold Warrior

406
00:10:14,000 --> 00:10:16,000
还是 Borland 公司出的

407
00:10:16,000 --> 00:10:20,000
我好像有信口开发了

408
00:10:20,000 --> 00:10:21,000
就是没有做调查

409
00:10:21,000 --> 00:10:21,000
就是这样

410
00:10:21,000 --> 00:10:25,000
如果 Cold Warrior 不是 Borland 做的话

411
00:10:25,000 --> 00:10:27,000
那是谁做的

412
00:10:27,000 --> 00:10:29,000
这不重要

413
00:10:29,000 --> 00:10:34,000
总之那个时候为 OS 9 开发程序是要用到 C

414
00:10:34,000 --> 00:10:36,000
那时候还没有 OS 10

415
00:10:36,000 --> 00:10:37,000
天哪

416
00:10:37,000 --> 00:10:39,000
那是一个多么洪荒的时代

417
00:10:39,000 --> 00:10:45,000
不过那个时候好像也是可以用 Java 为 OS 9 开发程序的吧

418
00:10:45,000 --> 00:10:46,000
我没有记错了

419
00:10:46,000 --> 00:10:49,000
我还是比较年轻的没有经历过那个时代

420
00:10:49,000 --> 00:10:52,000
如果我们听众也没有经历过那个时代的话

421
00:10:52,000 --> 00:10:55,000
就是怎样 OS 9 或者 OS

422
00:10:55,000 --> 00:11:00,000
乃至 OS 8 开发程序的听众的话

423
00:11:00,000 --> 00:11:03,000
也欢迎你来信提供一下这个经验

424
00:11:03,000 --> 00:11:09,000
就那个时代的苹果电脑是怎样开发程序的

425
00:11:09,000 --> 00:11:15,000
因为虽然目前我们都是已经归一苹果教的贴盖国粉

426
00:11:15,000 --> 00:11:21,000
但是早期我们开发程序的经历就真的只有 Windows

427
00:11:21,000 --> 00:11:22,000
乃至 Linux

428
00:11:22,000 --> 00:11:27,000
好像我跟 Rio 都没有做过 S 9 时代的

429
00:11:27,000 --> 00:11:31,000
至少是给图形界面编程的经历

430
00:11:31,000 --> 00:11:33,000
对欢迎各位提供宝贵今天

431
00:11:33,000 --> 00:11:37,000
然后他提到说

432
00:11:37,000 --> 00:11:40,000
在 Virginal Studio 里面可以直接以

433
00:11:40,000 --> 00:11:42,000
Object C 调用 Windows API

434
00:11:42,000 --> 00:11:43,000
这个听起来非常的

435
00:11:43,000 --> 00:11:45,000
不公开奇

436
00:11:45,000 --> 00:11:45,000
就是

437
00:11:45,000 --> 00:11:47,000
所以

438
00:11:47,000 --> 00:11:48,000
言下之一就是

439
00:11:48,000 --> 00:11:50,000
我可以用 Object C 在 Windows 上面写

440
00:11:50,000 --> 00:11:52,000
写 Windows 程序了

441
00:11:52,000 --> 00:11:54,000
嗯

442
00:11:54,000 --> 00:11:55,000
有意思

443
00:11:55,000 --> 00:11:57,000
什么想到今天呢

444
00:11:57,000 --> 00:12:01,000
接下来是一位叫做

445
00:12:01,000 --> 00:12:02,000
YPolyDiary 朋友

446
00:12:02,000 --> 00:12:05,000
那朋友给我们寄来的听众来信

447
00:12:05,000 --> 00:12:06,000
他说

448
00:12:06,000 --> 00:12:07,000
Rio 吴涛你们好

449
00:12:07,000 --> 00:12:08,000
嗯

450
00:12:08,000 --> 00:12:10,000
还是给两位发一个邮件吧

451
00:12:10,000 --> 00:12:11,000
之前总是在微博留言

452
00:12:11,000 --> 00:12:14,000
担心写信会写的太长

453
00:12:14,000 --> 00:12:16,000
浪费两位的时间

454
00:12:16,000 --> 00:12:18,000
关于 VR 的问题

455
00:12:18,000 --> 00:12:19,000
我就不多说了

456
00:12:19,000 --> 00:12:21,000
两位只是偶尔谈到

457
00:12:21,000 --> 00:12:24,000
并没有把它当做一个正式的题目来讲

458
00:12:24,000 --> 00:12:26,000
而我也是仅仅怀有热情

459
00:12:26,000 --> 00:12:28,000
并不是相关项目的参与者

460
00:12:28,000 --> 00:12:32,000
所以我今天反馈是关于很早的一期

461
00:12:32,000 --> 00:12:34,000
关于机械键盘的

462
00:12:34,000 --> 00:12:37,000
那是我们的第二期吧

463
00:12:37,000 --> 00:12:39,000
好像迄今也是

464
00:12:39,000 --> 00:12:41,000
人气最高的一期

465
00:12:41,000 --> 00:12:42,000
当然

466
00:12:42,000 --> 00:12:44,000
我相信木瑶和消极姐的那两期

467
00:12:44,000 --> 00:12:46,000
早晚会超过这一期

468
00:12:46,000 --> 00:12:46,000
不过

469
00:12:46,000 --> 00:12:47,000
目前来看

470
00:12:47,000 --> 00:12:51,000
键盘这一期的下载量是非常高

471
00:12:51,000 --> 00:12:55,000
我是从那一期开始

472
00:12:55,000 --> 00:12:56,000
才知道机械键盘是怎么回事

473
00:12:56,000 --> 00:12:58,000
然后就多了解了一些

474
00:12:58,000 --> 00:13:00,000
但是有一个很大的遗憾就是

475
00:13:00,000 --> 00:13:02,000
没有人谈到

476
00:13:02,000 --> 00:13:05,000
机械键盘压力特数的问题

477
00:13:05,000 --> 00:13:07,000
而我觉得这是一个很大的问题

478
00:13:07,000 --> 00:13:08,000
我的意思是

479
00:13:08,000 --> 00:13:11,000
没有把机械键盘的压力曲线

480
00:13:11,000 --> 00:13:12,000
和薄膜键盘的压力曲线

481
00:13:12,000 --> 00:13:14,000
进行计算比较

482
00:13:14,000 --> 00:13:16,000
这个问题重要吗

483
00:13:16,000 --> 00:13:16,000
我觉得很重要

484
00:13:16,000 --> 00:13:17,000
请看后面

485
00:13:17,000 --> 00:13:20,000
我这里就不画图了

486
00:13:20,000 --> 00:13:21,000
简单的说一下就是

487
00:13:21,000 --> 00:13:24,000
机械键盘的弹力结构是弹簧

488
00:13:24,000 --> 00:13:26,000
暂时没有见到其他结构

489
00:13:26,000 --> 00:13:27,000
弹簧的压力曲线

490
00:13:27,000 --> 00:13:28,000
是从小到大

491
00:13:28,000 --> 00:13:32,000
而且压力曲线基本上是平直的

492
00:13:32,000 --> 00:13:33,000
这就导致了一个问题

493
00:13:33,000 --> 00:13:36,000
就是按压的过程中要不断的施加压力

494
00:13:36,000 --> 00:13:40,000
而薄膜键盘的弹力结构是橡胶碗

495
00:13:40,000 --> 00:13:42,000
这种结构出使压力比较大

496
00:13:42,000 --> 00:13:44,000
但是一旦突破之后就很轻松了

497
00:13:44,000 --> 00:13:48,000
实际表现出来的结果就是

498
00:13:48,000 --> 00:13:50,000
机械键盘要保持按压状态

499
00:13:50,000 --> 00:13:51,000
需要一直用力按住

500
00:13:51,000 --> 00:13:55,000
这里先不谈各种轴格差异影响

501
00:13:55,000 --> 00:13:57,000
而薄膜键盘一旦按下之后

502
00:13:57,000 --> 00:13:59,000
就很容易保持按压的状态

503
00:13:59,000 --> 00:14:00,000
不需要很大的力

504
00:14:00,000 --> 00:14:01,000
还有就是

505
00:14:01,000 --> 00:14:03,000
每次按压所需要付出的力

506
00:14:03,000 --> 00:14:05,000
机械键盘也要比薄膜键盘大

507
00:14:05,000 --> 00:14:09,000
关于力的多少可以通过计算压力取向获得

508
00:14:09,000 --> 00:14:11,000
我没有专业的工具没法测量计算

509
00:14:11,000 --> 00:14:14,000
但是参考对弓箭势能的计算方式

510
00:14:14,000 --> 00:14:17,000
可以知道压力取向越平直

511
00:14:17,000 --> 00:14:18,000
收集的能量就越大

512
00:14:18,000 --> 00:14:21,000
其实我能想到这个问题

513
00:14:21,000 --> 00:14:23,000
是因为我的弓箭感兴趣

514
00:14:23,000 --> 00:14:24,000
之前看过一些研究资料

515
00:14:24,000 --> 00:14:26,000
比如反曲工为什么效能更高

516
00:14:26,000 --> 00:14:29,000
当然为了验证我的猜想

517
00:14:29,000 --> 00:14:31,000
我专门订了一个机械键盘试用一下

518
00:14:31,000 --> 00:14:33,000
我只是为了体验一下就退货

519
00:14:33,000 --> 00:14:34,000
有点不到的

520
00:14:34,000 --> 00:14:36,000
我试用的是查轴

521
00:14:36,000 --> 00:14:38,000
因为听你们说查轴比较轻

522
00:14:38,000 --> 00:14:40,000
体验的结果就是

523
00:14:40,000 --> 00:14:42,000
在 Counter Strike 这种

524
00:14:42,000 --> 00:14:46,000
需要长时间按住几个键的游戏里面

525
00:14:46,000 --> 00:14:47,000
非常的累

526
00:14:47,000 --> 00:14:51,000
打字的话也感觉要比我用的薄膜键盘要累一点

527
00:14:51,000 --> 00:14:53,000
机械键盘的初始压力很小

528
00:14:53,000 --> 00:14:55,000
给人一个很轻的错觉

529
00:14:55,000 --> 00:14:57,000
但是实际上通过前面的计算就知道

530
00:14:57,000 --> 00:15:00,000
每次按压需要的力实际上很大

531
00:15:00,000 --> 00:15:02,000
这也许从理论上说明了

532
00:15:02,000 --> 00:15:04,000
机械键盘不适合长时间操作

533
00:15:04,000 --> 00:15:09,000
当然我只是想说明压力曲线这一个问题

534
00:15:09,000 --> 00:15:11,000
不涉及对机械键盘优劣的评论

535
00:15:11,000 --> 00:15:12,000
好吧

536
00:15:12,000 --> 00:15:16,000
其实有点担心让喜欢机械键盘的两位大声反感

537
00:15:16,000 --> 00:15:20,000
另外我个人因为身体原因对轻动比较敏感

538
00:15:20,000 --> 00:15:23,000
所以我的感受可能不代表大多数人

539
00:15:23,000 --> 00:15:26,000
我只是用的是明基海贝键盘

540
00:15:26,000 --> 00:15:27,000
是薄膜键盘

541
00:15:27,000 --> 00:15:31,000
但是支撑组件是笔记本的 X 型结构

542
00:15:31,000 --> 00:15:34,000
手感介于笔记本和普通电脑之间

543
00:15:34,000 --> 00:15:35,000
这是我用的第二个键盘

544
00:15:35,000 --> 00:15:37,000
不好意思

545
00:15:37,000 --> 00:15:38,000
这一期又写长了

546
00:15:38,000 --> 00:15:41,000
好不容易找到一个自己能谈的话题

547
00:15:41,000 --> 00:15:42,000
OK

548
00:15:42,000 --> 00:15:45,000
这位听众的来信就已经完了

549
00:15:45,000 --> 00:15:48,000
怎么说呢

550
00:15:48,000 --> 00:15:51,000
就是首先前面他说

551
00:15:51,000 --> 00:15:55,000
机械键盘压力恪数的问题

552
00:15:55,000 --> 00:16:00,000
他认为机械键盘的弹力结构是弹簧

553
00:16:00,000 --> 00:16:05,000
而弹簧的压力曲线是线性的

554
00:16:05,000 --> 00:16:08,000
按压过程中需要不断的施的压力等等

555
00:16:08,000 --> 00:16:10,000
这个怎么说呢

556
00:16:10,000 --> 00:16:13,000
就是地安力曲线每一个轴

557
00:16:13,000 --> 00:16:16,000
就如果你用 Cherry 的轴来判断的话

558
00:16:16,000 --> 00:16:17,000
每个轴其实不一样的

559
00:16:17,000 --> 00:16:21,000
有些轴是的确是线性的

560
00:16:21,000 --> 00:16:22,000
但是另外一些轴是

561
00:16:22,000 --> 00:16:23,000
你按到一半的时候

562
00:16:23,000 --> 00:16:24,000
它会有一个出发点

563
00:16:24,000 --> 00:16:27,000
你只需要把键按到这个出发点之后

564
00:16:27,000 --> 00:16:29,000
就可以松开

565
00:16:29,000 --> 00:16:32,000
就这位朋友提到的一个用力场景

566
00:16:32,000 --> 00:16:34,000
就是 Counter Strike

567
00:16:34,000 --> 00:16:37,000
其实我个人觉得打 Counter Strike 的话

568
00:16:37,000 --> 00:16:39,000
还是无键盘比较好

569
00:16:39,000 --> 00:16:41,000
原因倒不是伯公务盘显得比较好

570
00:16:41,000 --> 00:16:43,000
而是因为怎么说呢

571
00:16:43,000 --> 00:16:46,000
就伯公务盘比较便宜吧

572
00:16:46,000 --> 00:16:48,000
就是打 Counter Strike 是非常

573
00:16:48,000 --> 00:16:50,000
对键盘非常凌虐的一种方式

574
00:16:50,000 --> 00:16:54,000
我个人还是会

575
00:16:54,000 --> 00:16:55,000
只会用机械文打字

576
00:16:55,000 --> 00:16:56,000
我也不知道

577
00:16:56,000 --> 00:16:59,000
反正现在我大部分时候打这个

578
00:16:59,000 --> 00:17:01,000
比如说暴雪的风暴英雄

579
00:17:01,000 --> 00:17:03,000
或者是 WAR Thunder

580
00:17:03,000 --> 00:17:06,000
就是一个二战的坦克防震游戏

581
00:17:06,000 --> 00:17:08,000
的时候基本上都是单用

582
00:17:08,000 --> 00:17:10,000
笔记本的薄膜键盘在打

583
00:17:10,000 --> 00:17:16,000
手感这个东西是非常主观的一件事情

584
00:17:16,000 --> 00:17:21,000
其实如果你单纯的从手感上来说的话

585
00:17:21,000 --> 00:17:23,000
机械键盘里面很多东西都是选选

586
00:17:23,000 --> 00:17:27,000
但是打字比较累

587
00:17:27,000 --> 00:17:29,000
这个可能是可能的确是这样

588
00:17:29,000 --> 00:17:31,000
有时候我现在也会觉得

589
00:17:31,000 --> 00:17:34,000
用机械键盘打字会稍微累一点

590
00:17:34,000 --> 00:17:35,000
怎么说呢

591
00:17:35,000 --> 00:17:38,000
就是打字累的这么一点点

592
00:17:38,000 --> 00:17:42,000
可能跟你每天多走几步路的能量消耗都差不多

593
00:17:42,000 --> 00:17:44,000
基本上可以忽略不计的

594
00:17:44,000 --> 00:17:46,000
各位想靠打字减肥的朋友们

595
00:17:46,000 --> 00:17:48,000
就可以醒醒了

596
00:17:48,000 --> 00:17:51,000
最后一封都是来信

597
00:17:51,000 --> 00:17:55,000
一位来自叫做肖志伯

598
00:17:55,000 --> 00:17:56,000
我不知道你能念对了没有

599
00:17:56,000 --> 00:17:58,000
德博士先生

600
00:17:58,000 --> 00:18:01,000
对他的 email 里面就有 doctor 头衔

601
00:18:01,000 --> 00:18:02,000
这个跟德国很像

602
00:18:02,000 --> 00:18:05,000
德国人都喜欢把自己的 doctor 头衔写出来

603
00:18:05,000 --> 00:18:07,000
嗨两位主播好

604
00:18:07,000 --> 00:18:09,000
听了第 15 期的 Crono Panic

605
00:18:09,000 --> 00:18:13,000
听众来信中有人讨论了 data science

606
00:18:13,000 --> 00:18:14,000
我又坐不住了

607
00:18:14,000 --> 00:18:16,000
之前我买了本书的 data science handbook

608
00:18:16,000 --> 00:18:20,000
是 Cura 的 data scientist William Chen

609
00:18:20,000 --> 00:18:23,000
联合一众 data scientist

610
00:18:23,000 --> 00:18:25,000
做了回馈大众的一件大好事

611
00:18:25,000 --> 00:18:27,000
我觉得大家都可以买来看一下

612
00:18:27,000 --> 00:18:29,000
虽然现在还没有看完

613
00:18:29,000 --> 00:18:30,000
不过写的真的挺好的

614
00:18:30,000 --> 00:18:33,000
对于想要入行 data science

615
00:18:33,000 --> 00:18:35,000
以及已经在这个行业中的同学

616
00:18:35,000 --> 00:18:36,000
都会有所帮助

617
00:18:36,000 --> 00:18:39,000
来信中的那位同学说

618
00:18:39,000 --> 00:18:43,000
现在 Azer 和 Amazon 这样的大公司

619
00:18:43,000 --> 00:18:46,000
把机器学习算法当成服务推出来了

620
00:18:46,000 --> 00:18:49,000
可以让大家不用编程就能用起来

621
00:18:49,000 --> 00:18:50,000
这的确是好事

622
00:18:50,000 --> 00:18:53,000
不过说到自然语言处理

623
00:18:53,000 --> 00:18:56,000
其实还是有很多很难的事情要做的

624
00:18:56,000 --> 00:18:59,000
而其实这些很难的工作

625
00:18:59,000 --> 00:19:01,000
都是人可以轻而易举的做到的

626
00:19:01,000 --> 00:19:04,000
比如说从一个句子里面

627
00:19:04,000 --> 00:19:06,000
准确的识别出日期和时间

628
00:19:06,000 --> 00:19:08,000
这个听起来非常简单

629
00:19:08,000 --> 00:19:12,000
现有的 Stanford NLP

630
00:19:12,000 --> 00:19:17,000
也就是斯坦福的自然语言处理技术

631
00:19:17,000 --> 00:19:21,000
用基于 conditional random field 的实体命名算法

632
00:19:21,000 --> 00:19:22,000
也可以用

633
00:19:22,000 --> 00:19:24,000
但是达到非常精确的效果

634
00:19:24,000 --> 00:19:26,000
还是有很长的路要走

635
00:19:26,000 --> 00:19:27,000
再说另一个

636
00:19:27,000 --> 00:19:32,000
从数据集中让算法自动识别出变量的值

637
00:19:32,000 --> 00:19:33,000
是连续型的

638
00:19:33,000 --> 00:19:35,000
还是离散型的都很难

639
00:19:35,000 --> 00:19:40,000
剑桥大学的 Zobin-Gaharamani 教授

640
00:19:40,000 --> 00:19:43,000
在 2014 年的 NIPS

641
00:19:43,000 --> 00:19:50,000
这是一个 Neuro Information Processing System

642
00:19:50,000 --> 00:19:52,000
它是一个年会应该是

643
00:19:52,000 --> 00:19:52,000
对

644
00:19:52,000 --> 00:19:56,000
跟这个神经信息处理性有关

645
00:19:56,000 --> 00:19:58,000
这个

646
00:19:58,000 --> 00:20:03,000
这位教授在 2014 年的 NIPS 会议上面

647
00:20:03,000 --> 00:20:05,000
就这个问题发表了一篇论文

648
00:20:05,000 --> 00:20:08,000
然后顺便再推一下另外一个 podcast

649
00:20:08,000 --> 00:20:09,000
Talking Machine

650
00:20:09,000 --> 00:20:17,000
网者是 htpwww.thetalkingmachines.com

651
00:20:17,000 --> 00:20:20,000
然后其中一主持人就是哈佛大学的

652
00:20:20,000 --> 00:20:24,000
Ray M.Proscott Adams 教授

653
00:20:24,000 --> 00:20:26,000
他利用他的关系

654
00:20:26,000 --> 00:20:28,000
几乎在每一期都请来了

655
00:20:28,000 --> 00:20:30,000
一听名字就让我心跳加速的嘉宾

656
00:20:30,000 --> 00:20:35,000
不过 Adams 教授在节目里面的一个保留项目

657
00:20:35,000 --> 00:20:38,000
就是用人类可以听懂的非常简单的语言

658
00:20:38,000 --> 00:20:40,000
解释非常复杂的算法

659
00:20:40,000 --> 00:20:43,000
比如推荐系统里面的

660
00:20:43,000 --> 00:20:45,000
Collaborative Filtering

661
00:20:45,000 --> 00:20:47,000
怎么反应

662
00:20:47,000 --> 00:20:48,000
协同过滤

663
00:20:48,000 --> 00:20:53,000
在比如非参数贝叶斯推断中的

664
00:20:53,000 --> 00:20:56,000
非常难的 Chinese Restaurant Process

665
00:20:56,000 --> 00:20:59,000
中餐馆过程

666
00:20:59,000 --> 00:20:59,000
有意思

667
00:20:59,000 --> 00:21:02,000
我查了一下这个中餐馆过程是

668
00:21:02,000 --> 00:21:05,000
模拟一个有无限张圆桌

669
00:21:05,000 --> 00:21:08,000
每张圆桌能做无限个人的中餐馆里面

670
00:21:08,000 --> 00:21:09,000
做客人的随机过程

671
00:21:09,000 --> 00:21:11,000
为什么叫这个名字

672
00:21:11,000 --> 00:21:13,000
大概是在洋人员里面

673
00:21:13,000 --> 00:21:16,000
只有中餐馆才会有圆桌吧

674
00:21:16,000 --> 00:21:18,000
以上是这位听众所推荐的

675
00:21:18,000 --> 00:21:21,000
应该是关于自然语言处理的一个 podcast

676
00:21:21,000 --> 00:21:24,000
有兴趣的听众们不妨去听听

677
00:21:24,000 --> 00:21:26,000
最后他说 PS

678
00:21:26,000 --> 00:21:28,000
虽然吴涛说了不让再推荐嘉宾了

679
00:21:28,000 --> 00:21:30,000
但是 please please

680
00:21:30,000 --> 00:21:32,000
能试试请一下 Cura 的 William Chen 吗

681
00:21:32,000 --> 00:21:35,000
我想如果是要做一期有关 Data Science 的话题

682
00:21:35,000 --> 00:21:39,000
请来这样一个 Data Science 才好吧

683
00:21:39,000 --> 00:21:43,000
我也知道请一个陌生人上节目还是挺难的

684
00:21:43,000 --> 00:21:44,000
anyway

685
00:21:44,000 --> 00:21:47,000
please keep up the good work

686
00:21:47,000 --> 00:21:49,000
感谢这位听众

687
00:21:49,000 --> 00:21:52,000
对我们的确是想要请一位

688
00:21:52,000 --> 00:21:54,000
货真价实的 Data Scientist

689
00:21:54,000 --> 00:21:57,000
来聊 Data Science 的话题

690
00:21:57,000 --> 00:22:01,000
不过目前还没有合适的人选

691
00:22:01,000 --> 00:22:04,000
我去看一下这位 William Chen

692
00:22:04,000 --> 00:22:04,000
是不是

693
00:22:04,000 --> 00:22:08,000
首先是不是一个适合接近的人

694
00:22:08,000 --> 00:22:10,000
感谢这位听众

695
00:22:10,000 --> 00:22:14,000
接下来我想要提到的一些新闻

696
00:22:14,000 --> 00:22:17,000
其实就是有一条

697
00:22:17,000 --> 00:22:18,000
就是 Google I.O

698
00:22:18,000 --> 00:22:23,000
我不知道明天的 IT 功能会怎样聊这个话题

699
00:22:23,000 --> 00:22:25,000
我希望他们会聊这个话题

700
00:22:25,000 --> 00:22:27,000
但是从卡巴尔专门上来说

701
00:22:27,000 --> 00:22:28,000
这一次 Google I.O

702
00:22:28,000 --> 00:22:33,000
大会让我印象比较深的

703
00:22:33,000 --> 00:22:34,000
当然我没有完全看这个大会

704
00:22:34,000 --> 00:22:37,000
我只是事后去看一下

705
00:22:37,000 --> 00:22:38,000
Summary

706
00:22:38,000 --> 00:22:40,000
因为要上班

707
00:22:40,000 --> 00:22:41,000
就这次 Google I.O

708
00:22:41,000 --> 00:22:44,000
在我看来的亮点就是

709
00:22:44,000 --> 00:22:46,000
首先是 Android 的 Studio IDE

710
00:22:46,000 --> 00:22:49,000
应该是 1.3 版吧

711
00:22:49,000 --> 00:22:51,000
增加了 NDK 的支持

712
00:22:51,000 --> 00:22:55,000
就是 Native Developer Kit

713
00:22:55,000 --> 00:22:56,000
你可以在

714
00:22:56,000 --> 00:23:00,000
它应该是使用了 Jetbrains 的 C-Line

715
00:23:00,000 --> 00:23:05,000
来支持用 C++写 Android App

716
00:23:05,000 --> 00:23:07,000
其次就是 Google I.O

717
00:23:07,000 --> 00:23:11,000
此次出现了一个专门为 Internet of Things

718
00:23:11,000 --> 00:23:13,000
所开发的操作系统

719
00:23:13,000 --> 00:23:14,000
叫做 Bretel

720
00:23:14,000 --> 00:23:16,000
名字有点奇怪

721
00:23:16,000 --> 00:23:18,000
Bretel 就是一个

722
00:23:18,000 --> 00:23:19,000
怎么说呢

723
00:23:19,000 --> 00:23:23,000
是一个比较被 strip down 的 Android 系统

724
00:23:23,000 --> 00:23:26,000
然后你可以把它装在一些智能家电上

725
00:23:26,000 --> 00:23:27,000
甚至都不一定是家电

726
00:23:27,000 --> 00:23:28,000
就是一些电器

727
00:23:28,000 --> 00:23:29,000
比如说电灯啊

728
00:23:29,000 --> 00:23:30,000
电扇啊之类的东西

729
00:23:30,000 --> 00:23:33,000
烟火软器啊之类的

730
00:23:33,000 --> 00:23:35,000
你在上面插一个芯片

731
00:23:35,000 --> 00:23:36,000
然后装上这个烙碎筒

732
00:23:36,000 --> 00:23:37,000
然后

733
00:23:37,000 --> 00:23:39,000
Automatically

734
00:23:39,000 --> 00:23:41,000
这个东西就变成了一个智能家电

735
00:23:41,000 --> 00:23:42,000
你可以用你的

736
00:23:42,000 --> 00:23:46,000
Android 设备去操纵它

737
00:23:46,000 --> 00:23:50,000
然后配套推出的

738
00:23:50,000 --> 00:23:52,000
也就是这个

739
00:23:52,000 --> 00:23:57,000
这种小芯片互相通信的一种

740
00:23:57,000 --> 00:23:59,000
怎么说呢

741
00:23:59,000 --> 00:24:00,000
Communication Layer

742
00:24:00,000 --> 00:24:02,000
应该叫做 Communication Layer

743
00:24:02,000 --> 00:24:04,000
就是一个通信层

744
00:24:04,000 --> 00:24:05,000
它的名字叫做 V

745
00:24:05,000 --> 00:24:09,000
也就是 W-E-A-V-E

746
00:24:09,000 --> 00:24:13,000
这让我想起那个 Google Wave

747
00:24:13,000 --> 00:24:18,000
就是那个已经正式开死附中

748
00:24:18,000 --> 00:24:20,000
理念超前

749
00:24:20,000 --> 00:24:21,000
Hap 无比

750
00:24:21,000 --> 00:24:22,000
但是最后

751
00:24:22,000 --> 00:24:23,000
对

752
00:24:23,000 --> 00:24:26,000
就这么默默地消失掉了 Google Wave

753
00:24:26,000 --> 00:24:28,000
我其实我希望

754
00:24:28,000 --> 00:24:32,000
Brillo 和 Wave 可以早一点推广开来

755
00:24:32,000 --> 00:24:33,000
因为这样的话可能

756
00:24:33,000 --> 00:24:38,000
智能家电会比较提前进入我们生活

757
00:24:38,000 --> 00:24:39,000
对

758
00:24:39,000 --> 00:24:41,000
我其实已经妄想过智能家电

759
00:24:41,000 --> 00:24:43,000
无处不在的场景了

760
00:24:43,000 --> 00:24:46,000
未来怎么还不到

761
00:24:46,000 --> 00:24:48,000
有一部电影叫做

762
00:24:48,000 --> 00:24:50,000
《回到未来》

763
00:24:50,000 --> 00:24:51,000
Back to the future

764
00:24:51,000 --> 00:24:54,000
应该是拍摄于 85 年

765
00:24:54,000 --> 00:24:56,000
即之后的三部

766
00:24:56,000 --> 00:24:59,000
关于时空旅行的电影

767
00:24:59,000 --> 00:25:00,000
其中

768
00:25:00,000 --> 00:25:04,000
主角在 1985 年所

769
00:25:04,000 --> 00:25:06,000
前进 30 年

770
00:25:06,000 --> 00:25:07,000
去到了那个

771
00:25:07,000 --> 00:25:09,000
2015 年

772
00:25:09,000 --> 00:25:10,000
也就是今年

773
00:25:10,000 --> 00:25:12,000
incidentally

774
00:25:12,000 --> 00:25:16,000
的 10 月 15 号吧

775
00:25:16,000 --> 00:25:17,000
还是 20 号

776
00:25:17,000 --> 00:25:18,000
没字错的话

777
00:25:18,000 --> 00:25:20,000
那一天

778
00:25:20,000 --> 00:25:21,000
离我们

779
00:25:21,000 --> 00:25:22,000
离我录剪工的今天

780
00:25:22,000 --> 00:25:25,000
大概也只有 150 天左右

781
00:25:25,000 --> 00:25:29,000
然后电影里面的那个 2015 年

782
00:25:29,000 --> 00:25:34,000
在有些地方是不如现在的 2015 年

783
00:25:34,000 --> 00:25:38,000
但是在很多其他地方是远远超越今天的科技水准的

784
00:25:38,000 --> 00:25:41,000
就是智能家电就不说了

785
00:25:41,000 --> 00:25:45,000
就比如说它里面有个叫做 Mr. Fusion 的能源装置

786
00:25:45,000 --> 00:25:47,000
可以装在车上

787
00:25:47,000 --> 00:25:49,000
然后你只要往里面扔一些垃圾

788
00:25:49,000 --> 00:25:53,000
它就可以通过聚变来产生非常非常多的能量

789
00:25:53,000 --> 00:25:57,000
这能量足以支持让一辆车产生时空旅行

790
00:25:57,000 --> 00:25:59,000
然后还有一些非常神奇的其他样东西

791
00:25:59,000 --> 00:26:01,000
比如说

792
00:26:01,000 --> 00:26:03,000
漂浮滑板

793
00:26:03,000 --> 00:26:03,000
对

794
00:26:03,000 --> 00:26:07,000
漂浮滑板这个东西在我们的 2015 年还是没有被实现出来

795
00:26:07,000 --> 00:26:09,000
对

796
00:26:09,000 --> 00:26:11,000
最重要的点是里面的车都是能飞的

797
00:26:11,000 --> 00:26:14,000
我觉得前一阵子在知乎上有个问题

798
00:26:14,000 --> 00:26:19,000
就是为什么说我们在 40 年前想要的是飞车

799
00:26:19,000 --> 00:26:21,000
而现在我们得到的只是 140 个字

800
00:26:21,000 --> 00:26:29,000
当然说这个话的人是没记错的话是 Tesla 的投资人之一吧

801
00:26:29,000 --> 00:26:30,000
不是 Elon Musk 他自己

802
00:26:30,000 --> 00:26:35,000
但是这个人也是一个科技界的推手人士了

803
00:26:35,000 --> 00:26:37,000
他说这些话的人其实本质上是励志

804
00:26:37,000 --> 00:26:41,000
但是当然有些人把它当成一句吐槽来看

805
00:26:41,000 --> 00:26:45,000
重点就是我们对于未来的想象

806
00:26:45,000 --> 00:26:48,000
很有可能是偏差非常大的

807
00:26:48,000 --> 00:26:51,000
但是这并不应该妨碍我们去想象

808
00:26:51,000 --> 00:26:52,000
对

809
00:26:52,000 --> 00:26:54,000
我就是希望智能家具可以早一天铺点

810
00:26:54,000 --> 00:26:58,000
铺开来应用

811
00:26:58,000 --> 00:27:02,000
让我们的今天能够在某种程度上

812
00:27:02,000 --> 00:27:07,000
在比较方便的部分

813
00:27:07,000 --> 00:27:10,000
能够超越那个时候对于未来的想象

814
00:27:10,000 --> 00:27:12,000
嗯

815
00:27:12,000 --> 00:27:16,000
关于飞车这个东西

816
00:27:16,000 --> 00:27:21,000
我觉得就是我之前在知乎上看到这个问题的时候

817
00:27:21,000 --> 00:27:22,000
里面有人说

818
00:27:22,000 --> 00:27:25,000
里面有人通过各种例子来论证了

819
00:27:25,000 --> 00:27:28,000
为什么 140 个字符比飞车更重要

820
00:27:28,000 --> 00:27:35,000
说如果你可以更便捷的和离你很远的人通讯

821
00:27:35,000 --> 00:27:38,000
那你就不需要去到那个人身边了

822
00:27:38,000 --> 00:27:41,000
如果你可以开 Teleconference 的话

823
00:27:41,000 --> 00:27:44,000
那你就不需要亲自跑到那个地方去了

824
00:27:44,000 --> 00:27:45,000
嗯

825
00:27:45,000 --> 00:27:49,000
所以有 140 个字符的便捷的交流方式

826
00:27:49,000 --> 00:27:50,000
其实是要比飞车重要的

827
00:27:50,000 --> 00:27:52,000
我承认它有一定的道理啊

828
00:27:52,000 --> 00:27:57,000
但是我总觉得如果飞车这个东西真的可以出现的话

829
00:27:57,000 --> 00:27:59,000
哦

830
00:27:59,000 --> 00:28:00,000
或者说一个比较

831
00:28:00,000 --> 00:28:02,000
我对飞车其实已经出现了

832
00:28:02,000 --> 00:28:03,000
就是呃

833
00:28:03,000 --> 00:28:05,000
现在已经有可以飞起来的汽车

834
00:28:05,000 --> 00:28:08,000
但是最大的问题是这个这个汽车

835
00:28:08,000 --> 00:28:09,000
它首先它需要专门的跑道

836
00:28:09,000 --> 00:28:11,000
第二它呃

837
00:28:11,000 --> 00:28:14,000
飞的时候其实不是非常的灵活

838
00:28:14,000 --> 00:28:16,000
呃

839
00:28:16,000 --> 00:28:18,000
第三就是能耗非常高

840
00:28:18,000 --> 00:28:20,000
但是如果有 Mr.Fusion 出现的话

841
00:28:20,000 --> 00:28:22,000
能耗不是问题

842
00:28:22,000 --> 00:28:22,000
呃

843
00:28:22,000 --> 00:28:52,000
呃

844
00:28:52,000 --> 00:28:54,000
就是里面他们里面设想说

845
00:28:54,000 --> 00:28:58,000
整个美洲乃至于跨洲的这个航路

846
00:28:58,000 --> 00:29:01,000
就有点像呃

847
00:29:01,000 --> 00:29:02,000
高速公路一样是

848
00:29:02,000 --> 00:29:04,000
已经预先化好了

849
00:29:04,000 --> 00:29:06,000
比如说如果你想从中国到美国的话

850
00:29:06,000 --> 00:29:08,000
你只需要呃

851
00:29:08,000 --> 00:29:09,000
开上自己的飞车

852
00:29:09,000 --> 00:29:11,000
从自己家的门前出发

853
00:29:11,000 --> 00:29:13,000
然后飞到高速公路上

854
00:29:13,000 --> 00:29:15,000
然后就沿着自速

855
00:29:15,000 --> 00:29:16,000
我相信一定有什么导航技术

856
00:29:16,000 --> 00:29:18,000
就是你只需要坐在车里面

857
00:29:18,000 --> 00:29:19,000
然后等

858
00:29:19,000 --> 00:29:20,000
这个车就会把你带到

859
00:29:20,000 --> 00:29:23,000
你在美国要去的那个地方的路旁

860
00:29:23,000 --> 00:29:25,000
这是一个非常点对点的服务

861
00:29:25,000 --> 00:29:26,000
就是

862
00:29:26,000 --> 00:29:30,000
你不像现在我们需要先从家里面坐车到机场

863
00:29:30,000 --> 00:29:31,000
然后拖跃行李

864
00:29:31,000 --> 00:29:31,000
然后 check in

865
00:29:31,000 --> 00:29:32,000
然后过安检

866
00:29:32,000 --> 00:29:33,000
然后不拉不拉不拉

867
00:29:33,000 --> 00:29:36,000
跟几百个不知道是不是恐怖分子的人坐在一起

868
00:29:36,000 --> 00:29:39,000
然后把自己的生命交在机场手里

869
00:29:39,000 --> 00:29:41,000
如果有飞车的话

870
00:29:41,000 --> 00:29:42,000
这一切都不需要了

871
00:29:42,000 --> 00:29:44,000
就我们可以单独的

872
00:29:44,000 --> 00:29:45,000
呃

873
00:29:45,000 --> 00:29:46,000
坐在属于自己一样

874
00:29:46,000 --> 00:29:49,000
一个一个封闭空间里面

875
00:29:49,000 --> 00:29:49,000
呃

876
00:29:49,000 --> 00:29:50,000
自己想带什么就带什么

877
00:29:50,000 --> 00:29:52,000
想带多少带多少

878
00:29:52,000 --> 00:29:53,000
只要能

879
00:29:53,000 --> 00:29:54,000
如果有

880
00:29:54,000 --> 00:29:54,000
again

881
00:29:54,000 --> 00:29:55,000
如果有 mrfusion 的话

882
00:29:55,000 --> 00:29:57,000
那能源不是问题

883
00:29:57,000 --> 00:29:59,000
就这样的技术

884
00:29:59,000 --> 00:30:00,000
带给我们的自由度

885
00:30:00,000 --> 00:30:02,000
其实是要远远高于飞机

886
00:30:02,000 --> 00:30:05,000
或者是现有的任何角度工具

887
00:30:05,000 --> 00:30:06,000
对

888
00:30:06,000 --> 00:30:09,000
所以我觉得飞车仍旧是一个非常重要值得梦想的事情

889
00:30:09,000 --> 00:30:10,000
不过

890
00:30:10,000 --> 00:30:12,000
有生之年应该是看不到了

891
00:30:12,000 --> 00:30:12,000
我觉得

892
00:30:12,000 --> 00:30:15,000
而且更不用提

893
00:30:15,000 --> 00:30:17,000
在 back to the future 里面

894
00:30:17,000 --> 00:30:17,000
呃

895
00:30:17,000 --> 00:30:18,000
主角其实

896
00:30:18,000 --> 00:30:19,000
不是主角

897
00:30:19,000 --> 00:30:20,000
就是未来 2015 年

898
00:30:20,000 --> 00:30:21,000
其实根本就没有

899
00:30:21,000 --> 00:30:23,000
不需要飞车

900
00:30:23,000 --> 00:30:23,000
而是

901
00:30:23,000 --> 00:30:25,000
所谓的飞车改装服务

902
00:30:25,000 --> 00:30:27,000
就是你只需要装四个轮子

903
00:30:27,000 --> 00:30:29,000
就可以让自己的车飞起来

904
00:30:29,000 --> 00:30:32,000
就永远不是像现在这样

905
00:30:32,000 --> 00:30:32,000
嗯

906
00:30:32,000 --> 00:30:35,000
你需要把整个汽车的构造都改了

907
00:30:35,000 --> 00:30:36,000
嗯

908
00:30:36,000 --> 00:30:37,000
OK

909
00:30:37,000 --> 00:30:39,000
在进入主题之前呢

910
00:30:39,000 --> 00:30:41,000
为了填充节目时间

911
00:30:41,000 --> 00:30:43,000
我们先来讨论一下

912
00:30:43,000 --> 00:30:44,000
呃

913
00:30:44,000 --> 00:30:45,000
计算机的编码

914
00:30:45,000 --> 00:30:46,000
这是一个

915
00:30:46,000 --> 00:30:48,000
压箱底的话题

916
00:30:48,000 --> 00:30:48,000
对

917
00:30:48,000 --> 00:30:50,000
就是为了专门应付今天这种

918
00:30:50,000 --> 00:30:51,000
呃

919
00:30:51,000 --> 00:30:53,000
为了保证节目不断档

920
00:30:53,000 --> 00:30:54,000
但是

921
00:30:54,000 --> 00:30:55,000
又有可能

922
00:30:55,000 --> 00:30:56,000
呃

923
00:30:56,000 --> 00:30:58,000
有人缺席的情况准备

924
00:30:58,000 --> 00:30:59,000
编码

925
00:30:59,000 --> 00:31:00,000
或者说 encoding

926
00:31:00,000 --> 00:31:02,000
是一个非常常见的时候

927
00:31:02,000 --> 00:31:03,000
非常复杂的概念

928
00:31:03,000 --> 00:31:04,000
首先

929
00:31:04,000 --> 00:31:06,000
encoding 和 coding 是不一样的

930
00:31:06,000 --> 00:31:08,000
就我们口语里面应该会用

931
00:31:08,000 --> 00:31:09,000
写

932
00:31:09,000 --> 00:31:10,000
写代码

933
00:31:10,000 --> 00:31:11,000
来

934
00:31:11,000 --> 00:31:12,000
指代写程序这件事

935
00:31:12,000 --> 00:31:14,000
但是有时候人们也会

936
00:31:14,000 --> 00:31:17,000
口误或者说无心的

937
00:31:17,000 --> 00:31:18,000
说编码

938
00:31:18,000 --> 00:31:19,000
来

939
00:31:19,000 --> 00:31:21,000
用编码这个词来指代写程序

940
00:31:21,000 --> 00:31:24,000
但是像编码在比较

941
00:31:24,000 --> 00:31:24,000
呃

942
00:31:24,000 --> 00:31:27,000
当你比较严格的区分自己的措辞的时候

943
00:31:27,000 --> 00:31:28,000
编码指的是 encoding

944
00:31:28,000 --> 00:31:31,000
encoding 是一个非常常见的时候

945
00:31:31,000 --> 00:31:32,000
非常复杂的概念

946
00:31:32,000 --> 00:31:33,000
常见是因为

947
00:31:33,000 --> 00:31:36,000
每时每刻我们每时每刻都在接触

948
00:31:36,000 --> 00:31:37,000
尤其是如果要

949
00:31:37,000 --> 00:31:39,000
coding 的话

950
00:31:39,000 --> 00:31:42,000
几乎完全是绕不开 encoding 的

951
00:31:42,000 --> 00:31:45,000
尤其是如果你不是一个专职的程序员

952
00:31:45,000 --> 00:31:46,000
你可以不懂算法

953
00:31:46,000 --> 00:31:47,000
可以不懂数据结构

954
00:31:47,000 --> 00:31:49,000
你你比如说你是一个搞 web 的

955
00:31:49,000 --> 00:31:50,000
你可能

956
00:31:50,000 --> 00:31:51,000
sorry

957
00:31:51,000 --> 00:31:52,000
我又黑 web

958
00:31:52,000 --> 00:31:54,000
你是给搞 web 前端的

959
00:31:54,000 --> 00:31:55,000
呃

960
00:31:55,000 --> 00:31:57,000
你可能完全不需要去接触算法

961
00:31:57,000 --> 00:31:58,000
或者数据结构

962
00:31:58,000 --> 00:31:59,000
你照样也可以活得很好

963
00:31:59,000 --> 00:32:01,000
但是 encoding 这个问题

964
00:32:01,000 --> 00:32:02,000
你是不有

965
00:32:02,000 --> 00:32:03,000
没有可能绕开

966
00:32:03,000 --> 00:32:03,000
如果

967
00:32:03,000 --> 00:32:06,000
如果你像回避算法

968
00:32:06,000 --> 00:32:06,000
数据结构一样

969
00:32:06,000 --> 00:32:07,000
去回避 encoding

970
00:32:07,000 --> 00:32:08,000
有很有可能会

971
00:32:08,000 --> 00:32:09,000
摔得很惨

972
00:32:09,000 --> 00:32:11,000
呃

973
00:32:11,000 --> 00:32:14,000
而即便是不写程序的人

974
00:32:14,000 --> 00:32:15,000
懂一些 encoding 也是一个

975
00:32:15,000 --> 00:32:17,000
也是一件非常有

976
00:32:17,000 --> 00:32:18,000
有有有意义的事情

977
00:32:18,000 --> 00:32:19,000
比如说

978
00:32:19,000 --> 00:32:21,000
我记得很久以前

979
00:32:21,000 --> 00:32:22,000
大概是

980
00:32:22,000 --> 00:32:23,000
天哪

981
00:32:23,000 --> 00:32:25,000
那个时候我还在读一件就是

982
00:32:25,000 --> 00:32:26,000
呃

983
00:32:26,000 --> 00:32:28,000
那时候有一个网站叫做

984
00:32:28,000 --> 00:32:29,000
现在也有这个网站

985
00:32:29,000 --> 00:32:30,000
叫做 Daily What the Fuck

986
00:32:30,000 --> 00:32:31,000
Daily WTF

987
00:32:31,000 --> 00:32:33,000
当然它的官方名字叫做

988
00:32:33,000 --> 00:32:35,000
Daily Worst Than Failure

989
00:32:35,000 --> 00:32:37,000
但是我们都知道 WTF 是什么意思

990
00:32:37,000 --> 00:32:38,000
然后在这个网站上面

991
00:32:38,000 --> 00:32:39,000
有这样一则

992
00:32:39,000 --> 00:32:41,000
当时应该是

993
00:32:41,000 --> 00:32:44,000
一堆图片新闻里面的一条

994
00:32:44,000 --> 00:32:44,000
我记得是

995
00:32:44,000 --> 00:32:47,000
有人拍了一个包裹单

996
00:32:47,000 --> 00:32:49,000
这个包裹单是贴在一个包裹上面的

997
00:32:49,000 --> 00:32:51,000
然后这个包裹是寄在寄给德国某个地址的

998
00:32:51,000 --> 00:32:52,000
这个地址里面有一个

999
00:32:52,000 --> 00:32:55,000
有一个地方被寄件人

1000
00:32:55,000 --> 00:32:55,000
呃

1001
00:32:55,000 --> 00:32:57,000
画成了一个方块

1002
00:32:57,000 --> 00:32:58,000
就是比如说

1003
00:32:58,000 --> 00:33:00,000
有一个德国的地址叫做

1004
00:33:00,000 --> 00:33:00,000
GR

1005
00:33:00,000 --> 00:33:02,000
方块

1006
00:33:02,000 --> 00:33:03,000
然后

1007
00:33:03,000 --> 00:33:04,000
blahblah

1008
00:33:04,000 --> 00:33:05,000
STR

1009
00:33:05,000 --> 00:33:06,000
然后多少号

1010
00:33:06,000 --> 00:33:07,000
就是

1011
00:33:07,000 --> 00:33:08,000
原因是什么呢

1012
00:33:08,000 --> 00:33:09,000
就是这个人

1013
00:33:09,000 --> 00:33:10,000
他显然在

1014
00:33:10,000 --> 00:33:12,000
显示这个德国的地址的时候

1015
00:33:12,000 --> 00:33:14,000
没能正确的把

1016
00:33:14,000 --> 00:33:16,000
O 上面加两点

1017
00:33:16,000 --> 00:33:18,000
就是 Oumlaut

1018
00:33:18,000 --> 00:33:20,000
这个字母显示出来

1019
00:33:20,000 --> 00:33:23,000
他的寄算机系统就把那个地方显示成了一个方块

1020
00:33:23,000 --> 00:33:26,000
然后他就非常忠诚的在那个地方画了一个方块

1021
00:33:26,000 --> 00:33:28,000
如果这位寄件人懂一眼

1022
00:33:28,000 --> 00:33:29,000
encoling 的知识的话

1023
00:33:29,000 --> 00:33:30,000
这样的

1024
00:33:30,000 --> 00:33:31,000
这样的

1025
00:33:31,000 --> 00:33:32,000
笑话就不会发生了

1026
00:33:32,000 --> 00:33:35,000
另外比如说有时候

1027
00:33:35,000 --> 00:33:38,000
各位在看网页的时候会发现网页上面有问号

1028
00:33:38,000 --> 00:33:39,000
或者是

1029
00:33:39,000 --> 00:33:40,000
嗯

1030
00:33:40,000 --> 00:33:42,000
莫名其妙的一些符号

1031
00:33:42,000 --> 00:33:43,000
我们会说这个时候有乱码

1032
00:33:43,000 --> 00:33:46,000
那这个时候应该怎么解决呢

1033
00:33:46,000 --> 00:33:48,000
知道的人可能会去

1034
00:33:48,000 --> 00:33:49,000
去

1035
00:33:49,000 --> 00:33:49,000
嗯

1036
00:33:49,000 --> 00:33:51,000
我忘了 Chrome 不是在哪

1037
00:33:51,000 --> 00:33:53,000
Chrome 好像是在 Tools 里面

1038
00:33:53,000 --> 00:33:53,000
对

1039
00:33:53,000 --> 00:33:54,000
你要去一地方

1040
00:33:54,000 --> 00:33:55,000
选了说

1041
00:33:55,000 --> 00:33:59,000
这个网页是用什么样的 encoding 来

1042
00:33:59,000 --> 00:34:01,000
encoding 的

1043
00:34:01,000 --> 00:34:02,000
来

1044
00:34:02,000 --> 00:34:06,000
这个网页是用什么标准来 encoding 的

1045
00:34:06,000 --> 00:34:07,000
你选对了一个标准

1046
00:34:07,000 --> 00:34:10,000
然后你就可以看到正确

1047
00:34:10,000 --> 00:34:10,000
准确有误的信息

1048
00:34:10,000 --> 00:34:12,000
嗯

1049
00:34:12,000 --> 00:34:12,000
又比如

1050
00:34:12,000 --> 00:34:15,000
以前我们玩一些

1051
00:34:15,000 --> 00:34:17,000
很有意思的日文游戏的时候

1052
00:34:17,000 --> 00:34:20,000
为什么在简体中文操作训练员

1053
00:34:20,000 --> 00:34:21,000
跑起来是乱码

1054
00:34:21,000 --> 00:34:22,000
对

1055
00:34:22,000 --> 00:34:23,000
嗯

1056
00:34:23,000 --> 00:34:26,000
这一切的原因

1057
00:34:26,000 --> 00:34:27,000
其实都是因为 encoding

1058
00:34:27,000 --> 00:34:28,000
那

1059
00:34:28,000 --> 00:34:31,000
为什么会有 encoding 的问题呢

1060
00:34:31,000 --> 00:34:33,000
答案是因为二进制

1061
00:34:33,000 --> 00:34:33,000
也就是

1062
00:34:33,000 --> 00:34:35,000
所谓

1063
00:34:35,000 --> 00:34:37,000
计算机是一个二进制的

1064
00:34:37,000 --> 00:34:38,000
东西

1065
00:34:38,000 --> 00:34:39,000
这句话

1066
00:34:39,000 --> 00:34:40,000
我们多多少少都听过

1067
00:34:40,000 --> 00:34:41,000
但是

1068
00:34:41,000 --> 00:34:43,000
就比如说

1069
00:34:43,000 --> 00:34:44,000
呃

1070
00:34:44,000 --> 00:34:44,000
我们都明白

1071
00:34:44,000 --> 00:34:46,000
计算机在内部只懂得零和一

1072
00:34:46,000 --> 00:34:47,000
呃

1073
00:34:47,000 --> 00:34:48,000
据实在说就是

1074
00:34:48,000 --> 00:34:49,000
芯片上面

1075
00:34:49,000 --> 00:34:50,000
有一个地方是高电平

1076
00:34:50,000 --> 00:34:51,000
它就是一

1077
00:34:51,000 --> 00:34:52,000
低电平就是零

1078
00:34:52,000 --> 00:34:53,000
然后

1079
00:34:53,000 --> 00:34:54,000
磁盘上面

1080
00:34:54,000 --> 00:34:55,000
有一个地方

1081
00:34:55,000 --> 00:34:56,000
比如说它的

1082
00:34:56,000 --> 00:34:57,000
北磁级朝上就是一

1083
00:34:57,000 --> 00:34:58,000
呃

1084
00:34:58,000 --> 00:34:59,000
北磁级朝下就是零

1085
00:34:59,000 --> 00:35:01,000
我不确定这个说法正不正确

1086
00:35:01,000 --> 00:35:02,000
是代磁是一

1087
00:35:02,000 --> 00:35:03,000
不代磁是零

1088
00:35:03,000 --> 00:35:04,000
还是北磁级是一

1089
00:35:04,000 --> 00:35:06,000
南磁级是零

1090
00:35:06,000 --> 00:35:07,000
对

1091
00:35:07,000 --> 00:35:07,000
呃

1092
00:35:07,000 --> 00:35:08,000
欢迎大家指证

1093
00:35:08,000 --> 00:35:10,000
然后比如说光盘上面

1094
00:35:10,000 --> 00:35:11,000
呃

1095
00:35:11,000 --> 00:35:11,000
有坑就是一

1096
00:35:11,000 --> 00:35:12,000
没坑就是零

1097
00:35:12,000 --> 00:35:13,000
诸如此类

1098
00:35:13,000 --> 00:35:16,000
然后呃

1099
00:35:16,000 --> 00:35:19,000
反过来平时使用电脑的时候

1100
00:35:19,000 --> 00:35:22,000
你跟我却明明没有直接在跟零和一打交道

1101
00:35:22,000 --> 00:35:23,000
不是吗

1102
00:35:23,000 --> 00:35:24,000
我们能比如说我们能看到文字

1103
00:35:24,000 --> 00:35:25,000
呃

1104
00:35:25,000 --> 00:35:26,000
我们能听到声音

1105
00:35:26,000 --> 00:35:28,000
比如说各位现在在听的 podcast

1106
00:35:28,000 --> 00:35:29,000
呃

1107
00:35:29,000 --> 00:35:31,000
我们能看到图片

1108
00:35:31,000 --> 00:35:32,000
以及一些呃

1109
00:35:32,000 --> 00:35:34,000
高雅的小电影

1110
00:35:34,000 --> 00:35:35,000
呃

1111
00:35:35,000 --> 00:35:37,000
这些东西都不是零和一

1112
00:35:37,000 --> 00:35:38,000
不是吗

1113
00:35:38,000 --> 00:35:39,000
就是在我们观感来说

1114
00:35:39,000 --> 00:35:43,000
这些东西都是切切实实的

1115
00:35:43,000 --> 00:35:44,000
一些模拟信号

1116
00:35:44,000 --> 00:35:45,000
不是

1117
00:35:45,000 --> 00:35:46,000
那么具体来讲

1118
00:35:46,000 --> 00:35:47,000
那些零和一在哪呢

1119
00:35:47,000 --> 00:35:50,000
呃

1120
00:35:50,000 --> 00:35:53,000
这个就要扯到比较

1121
00:35:53,000 --> 00:35:55,000
古早的历史

1122
00:35:55,000 --> 00:35:58,000
才能让大家有一个比较

1123
00:35:58,000 --> 00:36:00,000
清晰的认识

1124
00:36:00,000 --> 00:36:02,000
那这包括程序本身

1125
00:36:02,000 --> 00:36:03,000
其实也都是零和一

1126
00:36:03,000 --> 00:36:05,000
但是呃

1127
00:36:05,000 --> 00:36:06,000
写过程序的各位都知道

1128
00:36:06,000 --> 00:36:08,000
我们写程序的时候

1129
00:36:08,000 --> 00:36:09,000
并不是直接写下零和一

1130
00:36:09,000 --> 00:36:10,000
呃

1131
00:36:10,000 --> 00:36:12,000
以下内容部分摘字

1132
00:36:12,000 --> 00:36:13,000
我在知乎上的一个答案

1133
00:36:13,000 --> 00:36:13,000
所以

1134
00:36:13,000 --> 00:36:15,000
如果各位读过的话

1135
00:36:15,000 --> 00:36:17,000
基本上就可以跳过了

1136
00:36:17,000 --> 00:36:18,000
就可以直接拉到最后

1137
00:36:18,000 --> 00:36:20,000
来听这个本期的主题

1138
00:36:20,000 --> 00:36:20,000
就是

1139
00:36:20,000 --> 00:36:22,000
程序员怎样

1140
00:36:22,000 --> 00:36:23,000
泡的女朋友

1141
00:36:23,000 --> 00:36:24,000
啊

1142
00:36:24,000 --> 00:36:26,000
用泡这词是不太正确的

1143
00:36:26,000 --> 00:36:28,000
首先要泡气泡这个概念

1144
00:36:28,000 --> 00:36:28,000
anyway

1145
00:36:28,000 --> 00:36:31,000
在计算机还都是一些

1146
00:36:31,000 --> 00:36:32,000
旁边大物的实际时代

1147
00:36:32,000 --> 00:36:34,000
我们写程序是靠机器语言

1148
00:36:34,000 --> 00:36:35,000
嗯

1149
00:36:35,000 --> 00:36:39,000
虽然名字叫做机器语言

1150
00:36:39,000 --> 00:36:41,000
但实际上用到的只有两个数字而已

1151
00:36:41,000 --> 00:36:42,000
就是零和一

1152
00:36:42,000 --> 00:36:43,000
呃

1153
00:36:43,000 --> 00:36:46,000
当然前提是你不去考虑三进制计算机

1154
00:36:46,000 --> 00:36:47,000
对

1155
00:36:47,000 --> 00:36:51,000
三进制计算机实际上是一个非常有意思的话题

1156
00:36:51,000 --> 00:36:51,000
呃

1157
00:36:51,000 --> 00:36:54,000
整句来说是平衡三进制计算机

1158
00:36:54,000 --> 00:36:55,000
就是

1159
00:36:55,000 --> 00:36:56,000
嗯

1160
00:36:56,000 --> 00:37:00,000
各位应该可以比较容易的想象

1161
00:37:00,000 --> 00:37:01,000
什么是三进制

1162
00:37:01,000 --> 00:37:02,000
就是纯粹的三进制

1163
00:37:02,000 --> 00:37:05,000
就是只用 012 这三个数字

1164
00:37:05,000 --> 00:37:05,000
呃

1165
00:37:05,000 --> 00:37:06,000
0 是 0

1166
00:37:06,000 --> 00:37:07,000
1 是 1

1167
00:37:07,000 --> 00:37:07,000
22

1168
00:37:07,000 --> 00:37:09,000
3 是 10

1169
00:37:09,000 --> 00:37:09,000
对吧

1170
00:37:09,000 --> 00:37:12,000
那么什么是平衡三进制的

1171
00:37:12,000 --> 00:37:13,000
平衡三进制是说

1172
00:37:13,000 --> 00:37:15,000
用

1173
00:37:15,000 --> 00:37:16,000
10

1174
00:37:16,000 --> 00:37:18,000
和负 1

1175
00:37:18,000 --> 00:37:22,000
这三个数字来代表一切其他

1176
00:37:22,000 --> 00:37:23,000
来代表一切数字

1177
00:37:23,000 --> 00:37:25,000
来组合成为一切数字

1178
00:37:25,000 --> 00:37:26,000
呃

1179
00:37:26,000 --> 00:37:26,000
也就是说在每一个

1180
00:37:26,000 --> 00:37:28,000
在比如说在个位上是 0

1181
00:37:28,000 --> 00:37:29,000
就是 0

1182
00:37:29,000 --> 00:37:30,000
然后在个位上是 1

1183
00:37:30,000 --> 00:37:31,000
就是 1

1184
00:37:31,000 --> 00:37:33,000
在个位上是负 1

1185
00:37:33,000 --> 00:37:34,000
就是负 1

1186
00:37:34,000 --> 00:37:36,000
那么 2 怎么表示呢

1187
00:37:36,000 --> 00:37:36,000
很有意思

1188
00:37:36,000 --> 00:37:37,000
因为

1189
00:37:37,000 --> 00:37:38,000
10 的话

1190
00:37:38,000 --> 00:37:39,000
在三进

1191
00:37:39,000 --> 00:37:41,000
在平衡三进制里面是

1192
00:37:41,000 --> 00:37:42,000
代表

1193
00:37:42,000 --> 00:37:44,000
呃

1194
00:37:44,000 --> 00:37:44,000
3

1195
00:37:44,000 --> 00:37:46,000
所以如果你要

1196
00:37:46,000 --> 00:37:48,000
想要凑出一个 2 来的话

1197
00:37:48,000 --> 00:37:50,000
你必须先在

1198
00:37:50,000 --> 00:37:50,000
呃

1199
00:37:50,000 --> 00:37:52,000
个位上面

1200
00:37:52,000 --> 00:37:53,000
写上一个负 1

1201
00:37:53,000 --> 00:37:54,000
也就是

1202
00:37:54,000 --> 00:37:55,000
三进制

1203
00:37:55,000 --> 00:37:57,000
平衡三进制的 0 是 0

1204
00:37:57,000 --> 00:37:58,000
1 是 1

1205
00:37:58,000 --> 00:37:59,000
2 则是

1206
00:37:59,000 --> 00:38:01,000
1 负 1

1207
00:38:01,000 --> 00:38:02,000
就是

1208
00:38:02,000 --> 00:38:03,000
平衡三进制里面

1209
00:38:03,000 --> 00:38:04,000
通常会把负 1

1210
00:38:04,000 --> 00:38:05,000
这个数字写成 t

1211
00:38:05,000 --> 00:38:06,000
也就是

1212
00:38:06,000 --> 00:38:08,000
2 会变成 1 t

1213
00:38:08,000 --> 00:38:09,000
呃

1214
00:38:09,000 --> 00:38:11,000
写成 t 是因为负号

1215
00:38:11,000 --> 00:38:12,000
如果你把负号放在 1 上面的话

1216
00:38:12,000 --> 00:38:13,000
它就看着像一个 t

1217
00:38:13,000 --> 00:38:15,000
对

1218
00:38:15,000 --> 00:38:16,000
这是一个

1219
00:38:16,000 --> 00:38:17,000
这是一个非常

1220
00:38:17,000 --> 00:38:18,000
特别

1221
00:38:18,000 --> 00:38:19,000
但是

1222
00:38:19,000 --> 00:38:21,000
对于计算机来说

1223
00:38:21,000 --> 00:38:22,000
比较好实现的一种

1224
00:38:22,000 --> 00:38:22,000
一种

1225
00:38:22,000 --> 00:38:24,000
进制方法

1226
00:38:24,000 --> 00:38:24,000
就是

1227
00:38:24,000 --> 00:38:25,000
呃

1228
00:38:25,000 --> 00:38:27,000
如果你维持一个中等电位的话

1229
00:38:27,000 --> 00:38:27,000
它是 0

1230
00:38:27,000 --> 00:38:29,000
一个比较高的电位的话

1231
00:38:29,000 --> 00:38:30,000
是 1

1232
00:38:30,000 --> 00:38:32,000
然后一个比较低的电位的话

1233
00:38:32,000 --> 00:38:33,000
是负 1

1234
00:38:33,000 --> 00:38:34,000
平衡三进制

1235
00:38:34,000 --> 00:38:36,000
有一些比较特别的

1236
00:38:36,000 --> 00:38:37,000
呃

1237
00:38:37,000 --> 00:38:38,000
数学特性

1238
00:38:38,000 --> 00:38:38,000
比如说

1239
00:38:38,000 --> 00:38:40,000
在平衡三进制里面

1240
00:38:40,000 --> 00:38:42,000
有时候一些数字的表示方法

1241
00:38:42,000 --> 00:38:43,000
有两个

1242
00:38:43,000 --> 00:38:44,000
比如说

1243
00:38:44,000 --> 00:38:46,000
二分之一可以表示为

1244
00:38:46,000 --> 00:38:48,000
0.11 无限循环

1245
00:38:48,000 --> 00:38:49,000
或者是

1246
00:38:49,000 --> 00:38:50,000
1.

1247
00:38:50,000 --> 00:38:51,000
负 1 无限循环

1248
00:38:51,000 --> 00:38:52,000
然后有时候

1249
00:38:52,000 --> 00:38:53,000
也会有一些比较

1250
00:38:53,000 --> 00:38:55,000
特别的

1251
00:38:55,000 --> 00:38:56,000
呃

1252
00:38:56,000 --> 00:38:57,000
特性

1253
00:38:57,000 --> 00:38:58,000
比如说在乘法的时候

1254
00:38:58,000 --> 00:38:59,000
有时候你会

1255
00:38:59,000 --> 00:39:01,000
明明是两个多位数相乘

1256
00:39:01,000 --> 00:39:03,000
最后你得出的结果的

1257
00:39:03,000 --> 00:39:04,000
位数

1258
00:39:04,000 --> 00:39:05,000
反而要比两个

1259
00:39:05,000 --> 00:39:06,000
两个

1260
00:39:06,000 --> 00:39:07,000
要比两个

1261
00:39:07,000 --> 00:39:10,000
原来你用来乘的两个数字的位数要短

1262
00:39:10,000 --> 00:39:11,000
呃

1263
00:39:11,000 --> 00:39:12,000
呃

1264
00:39:12,000 --> 00:39:13,000
对

1265
00:39:13,000 --> 00:39:13,000
但是

1266
00:39:13,000 --> 00:39:16,000
三进制机算机最终是没有能成器

1267
00:39:16,000 --> 00:39:18,000
我相信如果

1268
00:39:18,000 --> 00:39:19,000
呃

1269
00:39:19,000 --> 00:39:20,000
三体人

1270
00:39:20,000 --> 00:39:21,000
或者是

1271
00:39:21,000 --> 00:39:24,000
比较正儿八经的科幻里面

1272
00:39:24,000 --> 00:39:25,000
就呃

1273
00:39:25,000 --> 00:39:26,000
有一部科幻叫做与拉马相会

1274
00:39:26,000 --> 00:39:28,000
如果各位没有看过的话

1275
00:39:28,000 --> 00:39:29,000
非常欢迎去看一看

1276
00:39:29,000 --> 00:39:29,000
要比

1277
00:39:29,000 --> 00:39:32,000
三体不知道高到哪里去了

1278
00:39:32,000 --> 00:39:34,000
呃

1279
00:39:34,000 --> 00:39:36,000
也许三体人会使用三进制机算机

1280
00:39:36,000 --> 00:39:38,000
呃

1281
00:39:38,000 --> 00:39:39,000
但是呢

1282
00:39:39,000 --> 00:39:40,000
在我们地球上面

1283
00:39:40,000 --> 00:39:41,000
目前

1284
00:39:41,000 --> 00:39:43,000
占主流的

1285
00:39:43,000 --> 00:39:44,000
绝对主流的

1286
00:39:44,000 --> 00:39:45,000
压倒性主流的

1287
00:39:45,000 --> 00:39:47,000
是二进制机算机

1288
00:39:47,000 --> 00:39:48,000
所以

1289
00:39:48,000 --> 00:39:49,000
呃

1290
00:39:49,000 --> 00:39:51,000
早期的写程序

1291
00:39:51,000 --> 00:39:54,000
也就是使用特定的二进制的组合

1292
00:39:54,000 --> 00:39:56,000
呃

1293
00:39:56,000 --> 00:39:57,000
来给自相机下命令

1294
00:39:57,000 --> 00:40:00,000
因为一些特定的数字组合

1295
00:40:00,000 --> 00:40:01,000
对于计算机来说有特定的意义

1296
00:40:01,000 --> 00:40:05,000
会让计算机做出一些特定的动作

1297
00:40:05,000 --> 00:40:05,000
呃

1298
00:40:05,000 --> 00:40:10,000
其实我们甚至不应该教这些二进制的数字

1299
00:40:10,000 --> 00:40:11,000
数字

1300
00:40:11,000 --> 00:40:13,000
因为他们其实并不代表任何数量

1301
00:40:13,000 --> 00:40:16,000
他们所代表的只是一种一种模式

1302
00:40:16,000 --> 00:40:17,000
对

1303
00:40:17,000 --> 00:40:18,000
这是一个什么概念呢

1304
00:40:18,000 --> 00:40:19,000
呃

1305
00:40:19,000 --> 00:40:20,000
各位可以想象一台钢琴

1306
00:40:20,000 --> 00:40:23,000
假设那些钢琴上所有的键都被拉平了

1307
00:40:23,000 --> 00:40:27,000
就是他的黑键不是欠在白键之间

1308
00:40:27,000 --> 00:40:28,000
呃

1309
00:40:28,000 --> 00:40:29,000
而是

1310
00:40:29,000 --> 00:40:30,000
就这么很简单的

1311
00:40:30,000 --> 00:40:33,000
导人咪发萨拉西道加上中间所有的半音

1312
00:40:33,000 --> 00:40:35,000
这样拉在一个直线上

1313
00:40:35,000 --> 00:40:36,000
呃

1314
00:40:36,000 --> 00:40:38,000
我们可以这样描述怎样弹钢琴

1315
00:40:38,000 --> 00:40:39,000
就是

1316
00:40:39,000 --> 00:40:42,000
每次把按下去的钢琴记作一

1317
00:40:42,000 --> 00:40:42,000
呃

1318
00:40:42,000 --> 00:40:43,000
没有按下去的

1319
00:40:43,000 --> 00:40:44,000
呃

1320
00:40:44,000 --> 00:40:45,000
钢琴记作零

1321
00:40:45,000 --> 00:40:46,000
然后我们可以

1322
00:40:46,000 --> 00:40:50,000
在每一个时刻得到一系列的一和零

1323
00:40:50,000 --> 00:40:50,000
呃

1324
00:40:50,000 --> 00:40:51,000
呃

1325
00:40:51,000 --> 00:40:53,000
这些一和零

1326
00:40:53,000 --> 00:40:56,000
你可以把它换算成一个实际值的数字

1327
00:40:56,000 --> 00:40:58,000
但是本质上它只是一种

1328
00:40:58,000 --> 00:41:03,000
它只是代表这个按下钢琴的状态

1329
00:41:03,000 --> 00:41:05,000
我们在使用 CPU 的时候

1330
00:41:05,000 --> 00:41:06,000
呃

1331
00:41:06,000 --> 00:41:10,000
情况跟这个钢琴是类似的

1332
00:41:10,000 --> 00:41:10,000
就是

1333
00:41:10,000 --> 00:41:15,000
我们把一个 01010101 这样的指令

1334
00:41:15,000 --> 00:41:16,000
输入一口

1335
00:41:16,000 --> 00:41:17,000
一小块芯片的时候

1336
00:41:17,000 --> 00:41:19,000
真实做的事情

1337
00:41:19,000 --> 00:41:22,000
其实是在这个芯片上面的不同引脚上面

1338
00:41:22,000 --> 00:41:24,000
输入高或者低的电压

1339
00:41:24,000 --> 00:41:26,000
然后芯片里面会有

1340
00:41:26,000 --> 00:41:27,000
呃

1341
00:41:27,000 --> 00:41:29,000
很多坨这个

1342
00:41:29,000 --> 00:41:32,000
小小的晶体管组成小装置

1343
00:41:32,000 --> 00:41:34,000
被我们按下了

1344
00:41:34,000 --> 00:41:37,000
然后这个组合呢

1345
00:41:37,000 --> 00:41:39,000
它会借而引发更多的

1346
00:41:39,000 --> 00:41:40,000
由芯片工程师

1347
00:41:40,000 --> 00:41:43,000
预先设计的一系列的连锁反应

1348
00:41:43,000 --> 00:41:48,000
然后无数这样的模式数字

1349
00:41:48,000 --> 00:41:50,000
一个接一个被输入芯片里面

1350
00:41:50,000 --> 00:41:53,000
最终你的屏幕上就会出现一些

1351
00:41:53,000 --> 00:41:54,000
能够被人理解的图案

1352
00:41:54,000 --> 00:41:58,000
然后给计算机输入这种相当于命令的数字

1353
00:41:58,000 --> 00:41:59,000
呃

1354
00:41:59,000 --> 00:42:00,000
称作指令

1355
00:42:00,000 --> 00:42:02,000
的东西

1356
00:42:02,000 --> 00:42:03,000
让它来做一些事情

1357
00:42:03,000 --> 00:42:04,000
呃

1358
00:42:04,000 --> 00:42:07,000
包括但不限于处理

1359
00:42:07,000 --> 00:42:08,000
其他那些数字

1360
00:42:08,000 --> 00:42:11,000
其实就是编程的本质活动

1361
00:42:11,000 --> 00:42:13,000
比如说有台古早的计算机

1362
00:42:13,000 --> 00:42:15,000
叫做 Cosmic Elf

1363
00:42:15,000 --> 00:42:16,000
呃

1364
00:42:16,000 --> 00:42:18,000
它的面板上有一排开关

1365
00:42:18,000 --> 00:42:19,000
呃

1366
00:42:19,000 --> 00:42:21,000
应该是有八个还是十个开关

1367
00:42:21,000 --> 00:42:23,000
这些开关可以拨上或者拨下

1368
00:42:23,000 --> 00:42:27,000
那给这台计算机编程的方法就是

1369
00:42:27,000 --> 00:42:29,000
把你想要输入的数字

1370
00:42:29,000 --> 00:42:30,000
或者说把你想要

1371
00:42:30,000 --> 00:42:32,000
按一下的琴键

1372
00:42:32,000 --> 00:42:33,000
呃

1373
00:42:33,000 --> 00:42:37,000
在这排开关上面搬好

1374
00:42:37,000 --> 00:42:39,000
比如说搬上去就是上

1375
00:42:39,000 --> 00:42:40,000
呃

1376
00:42:40,000 --> 00:42:40,000
搬上去就是一

1377
00:42:40,000 --> 00:42:42,000
搬下去就是零

1378
00:42:42,000 --> 00:42:43,000
搬好一排之后

1379
00:42:43,000 --> 00:42:44,000
你按一下右上角

1380
00:42:44,000 --> 00:42:45,000
它有一张按钮

1381
00:42:45,000 --> 00:42:46,000
呃

1382
00:42:46,000 --> 00:42:48,000
你就可以输入下一条指令

1383
00:42:48,000 --> 00:42:49,000
对

1384
00:42:49,000 --> 00:42:50,000
这就好像你在

1385
00:42:50,000 --> 00:42:51,000
怎么说呢

1386
00:42:51,000 --> 00:42:54,000
有那种早期的打孔钢琴

1387
00:42:54,000 --> 00:42:55,000
呃

1388
00:42:55,000 --> 00:42:59,000
你输入一条这个上面布满了小鸭的纸带

1389
00:42:59,000 --> 00:43:00,000
呃

1390
00:43:00,000 --> 00:43:05,000
每一个鸭都代表这个地方应该有个琴键被按下去

1391
00:43:05,000 --> 00:43:05,000
那

1392
00:43:05,000 --> 00:43:10,000
给这台计算机编程的过程就有点像你在手工去钻一个纸带

1393
00:43:10,000 --> 00:43:11,000
对

1394
00:43:11,000 --> 00:43:14,000
或者你在你在手工做一个八音盒

1395
00:43:14,000 --> 00:43:16,000
如果你看过八音盒是怎么工作的话

1396
00:43:16,000 --> 00:43:18,000
你一定明白我的什么意思

1397
00:43:18,000 --> 00:43:23,000
问题在于就是你在这一台计算机上面输入一系列零和一

1398
00:43:23,000 --> 00:43:26,000
和在那台计算机上面输入一系列零和一

1399
00:43:26,000 --> 00:43:28,000
你得到的反应可能是完全不一样的

1400
00:43:28,000 --> 00:43:29,000
呃

1401
00:43:29,000 --> 00:43:35,000
这是从最开始就有一个差异的呃

1402
00:43:35,000 --> 00:43:36,000
问题

1403
00:43:36,000 --> 00:43:37,000
对

1404
00:43:37,000 --> 00:43:40,000
因为各个各家计算机厂商会自己去研发自己的芯片

1405
00:43:40,000 --> 00:43:42,000
呃

1406
00:43:42,000 --> 00:43:45,000
同样那种数字对于不同型号的计算机来说

1407
00:43:45,000 --> 00:43:47,000
有可能是完全代表不同的指令的

1408
00:43:47,000 --> 00:43:49,000
而这一点直到今天都没有改变

1409
00:43:49,000 --> 00:43:50,000
嗯

1410
00:43:50,000 --> 00:43:50,000
嗯

1411
00:43:50,000 --> 00:43:54,000
那些通过金属引脚受到零和一输入的 CPU

1412
00:43:54,000 --> 00:43:57,000
所谓有这样一个指令级的概念

1413
00:43:57,000 --> 00:43:57,000
呃

1414
00:43:57,000 --> 00:44:02,000
本质上指令级其实就是由芯片制造厂商给出的数字组合的定义

1415
00:44:02,000 --> 00:44:03,000
对

1416
00:44:03,000 --> 00:44:06,000
如果你去查什么 AMD 或者是 Intel 的手册的话

1417
00:44:06,000 --> 00:44:07,000
呃

1418
00:44:07,000 --> 00:44:08,000
你会发现他们的

1419
00:44:08,000 --> 00:44:11,000
指令级里面

1420
00:44:11,000 --> 00:44:12,000
会

1421
00:44:12,000 --> 00:44:14,000
给出一组数字

1422
00:44:14,000 --> 00:44:16,000
这组数字其实上其实就是

1423
00:44:16,000 --> 00:44:22,000
真正的 CPU 所会接触到的那些高低电屏组

1424
00:44:22,000 --> 00:44:22,000
对

1425
00:44:22,000 --> 00:44:24,000
嗯

1426
00:44:24,000 --> 00:44:27,000
由于芯片设计结构不同

1427
00:44:27,000 --> 00:44:28,000
每种芯片的指令机也就不同

1428
00:44:28,000 --> 00:44:32,000
比如常见于台式计算机的 Intel 芯片的指令机

1429
00:44:32,000 --> 00:44:35,000
就与常见于手持设备的 ARM 芯片的指令机不一样

1430
00:44:35,000 --> 00:44:37,000
嗯

1431
00:44:37,000 --> 00:44:39,000
计算机语言在这个层面开始

1432
00:44:39,000 --> 00:44:42,000
就已经产生了区别

1433
00:44:42,000 --> 00:44:49,000
不过用纯数字计算机语言编程的难度可想而知

1434
00:44:49,000 --> 00:44:52,000
所以从数字到注记符号的转译

1435
00:44:52,000 --> 00:44:54,000
很快就随之出现了

1436
00:44:54,000 --> 00:44:56,000
我们把这个东西叫做汇编语言

1437
00:44:56,000 --> 00:44:57,000
比如说

1438
00:44:57,000 --> 00:44:58,000
呃

1439
00:44:58,000 --> 00:45:04,000
一组数字 0010000 可以让芯片把内部的一个存储单位

1440
00:45:04,000 --> 00:45:05,000
呃

1441
00:45:05,000 --> 00:45:07,000
我们叫它存储器

1442
00:45:07,000 --> 00:45:08,000
寄存器 X

1443
00:45:08,000 --> 00:45:09,000
加上一个值 Y

1444
00:45:09,000 --> 00:45:14,000
那么不妨就把这组数字和注记符 add 对应起来

1445
00:45:14,000 --> 00:45:16,000
比如说上面的指令就可以写成

1446
00:45:16,000 --> 00:45:17,000
add x 斗号 y

1447
00:45:17,000 --> 00:45:18,000
这样

1448
00:45:18,000 --> 00:45:20,000
一条条类似的指令写成一串

1449
00:45:20,000 --> 00:45:22,000
就是一个对于程序的描述

1450
00:45:22,000 --> 00:45:23,000
对吧

1451
00:45:23,000 --> 00:45:24,000
呃

1452
00:45:24,000 --> 00:45:25,000
相对于纯数字来说

1453
00:45:25,000 --> 00:45:27,000
这也是一个质的飞跃

1454
00:45:27,000 --> 00:45:27,000
因为

1455
00:45:27,000 --> 00:45:28,000
你

1456
00:45:28,000 --> 00:45:31,000
终于不用去手动扳那个开关了

1457
00:45:31,000 --> 00:45:32,000
不是吗

1458
00:45:32,000 --> 00:45:32,000
对

1459
00:45:32,000 --> 00:45:34,000
然后这样的一串数

1460
00:45:34,000 --> 00:45:36,000
这样的一串字符呢

1461
00:45:36,000 --> 00:45:37,000
就是这些

1462
00:45:37,000 --> 00:45:37,000
add

1463
00:45:37,000 --> 00:45:38,000
xy

1464
00:45:38,000 --> 00:45:42,000
或者是 move

1465
00:45:42,000 --> 00:45:43,000
呃

1466
00:45:43,000 --> 00:45:43,000
xy

1467
00:45:43,000 --> 00:45:44,000
这样的

1468
00:45:44,000 --> 00:45:46,000
字符串

1469
00:45:46,000 --> 00:45:51,000
可以由专门的小程序来翻译成那些 0101 的二级纸代码

1470
00:45:51,000 --> 00:45:54,000
也就是真正可以被输入处理器

1471
00:45:54,000 --> 00:45:56,000
去按下那些晶体管的

1472
00:45:56,000 --> 00:45:57,000
呃

1473
00:45:57,000 --> 00:45:58,000
开关的

1474
00:45:58,000 --> 00:46:00,000
电子信号

1475
00:46:00,000 --> 00:46:03,000
当然每一种处理器的汇变语言中就是不一样

1476
00:46:03,000 --> 00:46:04,000
嗯

1477
00:46:04,000 --> 00:46:07,000
机器语言或者说汇变语言的优点是呢

1478
00:46:07,000 --> 00:46:11,000
每一条指令几乎都对应于芯片能做的一件事情

1479
00:46:11,000 --> 00:46:16,000
比如说有一条指令可以把一个数字从内存里面转到计存器里面

1480
00:46:16,000 --> 00:46:16,000
呃

1481
00:46:16,000 --> 00:46:21,000
另一条指令呢可以把这个被转入计存器的值加上 1

1482
00:46:21,000 --> 00:46:21,000
呃

1483
00:46:21,000 --> 00:46:24,000
第三条指令又把它放回内存去

1484
00:46:24,000 --> 00:46:25,000
嗯

1485
00:46:25,000 --> 00:46:28,000
直接对一块芯片下命令效率非常高

1486
00:46:28,000 --> 00:46:33,000
但是对应的缺点就是如果你只是想要把一个数字加上 1 的话

1487
00:46:33,000 --> 00:46:36,000
每次都要写三条指令

1488
00:46:36,000 --> 00:46:38,000
时间一长是非常痛苦的一件事

1489
00:46:38,000 --> 00:46:40,000
而且还有一个问题就是呃

1490
00:46:40,000 --> 00:46:44,000
因为不同的芯片所支持的指令机是不一样的

1491
00:46:44,000 --> 00:46:44,000
呃

1492
00:46:44,000 --> 00:46:48,000
也就意味着你在这一块芯片上需要三条指令能完成的事情

1493
00:46:48,000 --> 00:46:51,000
在另外一块芯片上可能需要五条指令

1494
00:46:51,000 --> 00:46:53,000
呃

1495
00:46:53,000 --> 00:47:00,000
所以如果我们能够将一部分固定出现的操作像连续计一样一次性释放

1496
00:47:00,000 --> 00:47:02,000
每次只要打一个指令

1497
00:47:02,000 --> 00:47:07,000
却能够在不同结构的芯片上都做同样的事情该有多好

1498
00:47:07,000 --> 00:47:08,000
换句话说

1499
00:47:08,000 --> 00:47:12,000
如果能有一种更倾向于描述那些需要解决的问题

1500
00:47:12,000 --> 00:47:14,000
比如说给一个数字加上 1

1501
00:47:14,000 --> 00:47:17,000
而不是手把手的告诉计算机说啊

1502
00:47:17,000 --> 00:47:21,000
你读一个数字加上一个数字再写一个数字

1503
00:47:21,000 --> 00:47:24,000
有这样一种比较高级的语言

1504
00:47:24,000 --> 00:47:28,000
来封周那些比较不需要我们去操心的细节

1505
00:47:28,000 --> 00:47:29,000
呃

1506
00:47:29,000 --> 00:47:31,000
该有多好

1507
00:47:31,000 --> 00:47:33,000
对吧

1508
00:47:33,000 --> 00:47:35,000
然后所谓的高级语言

1509
00:47:35,000 --> 00:47:38,000
也就是各位学缘程的时候学到的那种语言

1510
00:47:38,000 --> 00:47:39,000
就是做这件事

1511
00:47:39,000 --> 00:47:42,000
比如说最古老的高级语言有 Fortune

1512
00:47:42,000 --> 00:47:43,000
有 Algo

1513
00:47:43,000 --> 00:47:44,000
Cobo

1514
00:47:44,000 --> 00:47:46,000
呃

1515
00:47:46,000 --> 00:47:49,000
乃至于比较同样古老

1516
00:47:49,000 --> 00:47:50,000
但是来源迥异的 List

1517
00:47:50,000 --> 00:47:53,000
我觉得我们应该专门找一期来说 List

1518
00:47:53,000 --> 00:47:55,000
所有这些语言呢

1519
00:47:55,000 --> 00:47:59,000
他们都会最终被转化为二进制的形式

1520
00:47:59,000 --> 00:48:00,000
嗯

1521
00:48:00,000 --> 00:48:03,000
包括现在大家比较喜欢的动态语言

1522
00:48:03,000 --> 00:48:04,000
比如说

1523
00:48:04,000 --> 00:48:05,000
嗯

1524
00:48:05,000 --> 00:48:06,000
Python 啊

1525
00:48:06,000 --> 00:48:08,000
Ruby 啊

1526
00:48:08,000 --> 00:48:08,000
Lua 啊

1527
00:48:08,000 --> 00:48:11,000
他们归根结底都是会

1528
00:48:11,000 --> 00:48:14,000
被转化为二进制代码

1529
00:48:14,000 --> 00:48:16,000
输入到 CPU 之行

1530
00:48:16,000 --> 00:48:19,000
他们和这个比较低端的

1531
00:48:19,000 --> 00:48:21,000
或者说比较原始的语言

1532
00:48:21,000 --> 00:48:23,000
比如说 C 或者是 Fortune 的区别就在于

1533
00:48:23,000 --> 00:48:24,000
他们呃

1534
00:48:24,000 --> 00:48:27,000
单一一条指令里面

1535
00:48:27,000 --> 00:48:28,000
所

1536
00:48:28,000 --> 00:48:29,000
包括

1537
00:48:29,000 --> 00:48:33,000
所涵盖的一些二进制指令要多很多

1538
00:48:33,000 --> 00:48:34,000
嗯

1539
00:48:34,000 --> 00:48:36,000
然后他们完成这件

1540
00:48:36,000 --> 00:48:39,000
这个特点的手段就是

1541
00:48:39,000 --> 00:48:42,000
他们的底层

1542
00:48:42,000 --> 00:48:45,000
其实又是利用你的实体 CPU

1543
00:48:45,000 --> 00:48:47,000
去模拟一个

1544
00:48:47,000 --> 00:48:47,000
嗯

1545
00:48:47,000 --> 00:48:51,000
只在逻辑意义上存在的

1546
00:48:51,000 --> 00:48:52,000
虚拟的 CPU

1547
00:48:52,000 --> 00:48:53,000
嗯

1548
00:48:53,000 --> 00:48:54,000
对

1549
00:48:54,000 --> 00:48:56,000
这个就不展开讲了

1550
00:48:56,000 --> 00:48:56,000
就

1551
00:48:56,000 --> 00:48:59,000
有进去的同学可以自己去找一些

1552
00:48:59,000 --> 00:49:01,000
这个方面的书看

1553
00:49:01,000 --> 00:49:02,000
我会推荐一本

1554
00:49:02,000 --> 00:49:03,000
Code

1555
00:49:03,000 --> 00:49:05,000
我相信之前我已经 Code 过了

1556
00:49:05,000 --> 00:49:06,000
我已经推荐过了

1557
00:49:06,000 --> 00:49:07,000
Sorry

1558
00:49:07,000 --> 00:49:08,000
嗯

1559
00:49:08,000 --> 00:49:10,000
可能是在某一期的 IT 工作上面

1560
00:49:10,000 --> 00:49:12,000
我说这本书是奇运书

1561
00:49:12,000 --> 00:49:12,000
对

1562
00:49:12,000 --> 00:49:13,000
推荐拿着去看看

1563
00:49:13,000 --> 00:49:14,000
嗯

1564
00:49:14,000 --> 00:49:18,000
以上大概讲了这个

1565
00:49:18,000 --> 00:49:20,000
编程语言是怎么样

1566
00:49:20,000 --> 00:49:22,000
利用

1567
00:49:22,000 --> 00:49:23,000
零和一

1568
00:49:23,000 --> 00:49:25,000
或者说编程语言是怎样

1569
00:49:25,000 --> 00:49:26,000
抓换零和一

1570
00:49:26,000 --> 00:49:29,000
但是真正就没有解释

1571
00:49:29,000 --> 00:49:30,000
我们一开始提出的一个问题

1572
00:49:30,000 --> 00:49:30,000
就是

1573
00:49:30,000 --> 00:49:32,000
我们看到的图像

1574
00:49:32,000 --> 00:49:34,000
看到的文字

1575
00:49:34,000 --> 00:49:36,000
是怎样转换零和一的

1576
00:49:36,000 --> 00:49:37,000
嗯

1577
00:49:37,000 --> 00:49:39,000
其实道理是类似的

1578
00:49:39,000 --> 00:49:40,000
就是

1579
00:49:40,000 --> 00:49:42,000
我们约定说

1580
00:49:42,000 --> 00:49:44,000
在计算机里面

1581
00:49:44,000 --> 00:49:46,000
某一些特定的零和一的组合

1582
00:49:46,000 --> 00:49:48,000
代表一个特定的数字

1583
00:49:48,000 --> 00:49:51,000
或者代表一个特定的字符

1584
00:49:51,000 --> 00:49:53,000
或者代表一个特定的图像

1585
00:49:53,000 --> 00:49:54,000
嗯

1586
00:49:54,000 --> 00:49:56,000
以我们最常见的

1587
00:49:56,000 --> 00:49:57,000
ASCII 嘛

1588
00:49:57,000 --> 00:49:58,000
就是国家

1589
00:49:58,000 --> 00:50:00,000
美国国家为准局的代码

1590
00:50:00,000 --> 00:50:02,000
ASCII 代码来看的话

1591
00:50:02,000 --> 00:50:05,000
它的方法是挑出一个

1592
00:50:05,000 --> 00:50:06,000
七位的

1593
00:50:06,000 --> 00:50:08,000
注意是七位的

1594
00:50:08,000 --> 00:50:08,000
二进制数字

1595
00:50:08,000 --> 00:50:10,000
把第一位标成一

1596
00:50:10,000 --> 00:50:12,000
最后一位标成一

1597
00:50:12,000 --> 00:50:13,000
也就是

1598
00:50:13,000 --> 00:50:17,000
100001

1599
00:50:17,000 --> 00:50:19,000
这样的数字

1600
00:50:19,000 --> 00:50:21,000
让它来代表

1601
00:50:21,000 --> 00:50:22,000
大写字母 A

1602
00:50:22,000 --> 00:50:23,000
对

1603
00:50:23,000 --> 00:50:26,000
然后这个数字被转化成

1604
00:50:26,000 --> 00:50:27,000
实进制就是 65

1605
00:50:27,000 --> 00:50:29,000
然后 65 就代表 A

1606
00:50:29,000 --> 00:50:32,000
所以如果你从实进制的角度

1607
00:50:32,000 --> 00:50:34,000
去看这个数字的话

1608
00:50:34,000 --> 00:50:34,000
你会觉得很奇怪

1609
00:50:34,000 --> 00:50:36,000
为什么要用 65 来代表 A 呢

1610
00:50:36,000 --> 00:50:38,000
但是当你把 65

1611
00:50:38,000 --> 00:50:39,000
转化成一个

1612
00:50:39,000 --> 00:50:41,000
七位的二进制数字的时候

1613
00:50:41,000 --> 00:50:43,000
就会发现

1614
00:50:43,000 --> 00:50:44,000
它其实是一个

1615
00:50:44,000 --> 00:50:45,000
相对来说

1616
00:50:45,000 --> 00:50:46,000
比较有规律的码点

1617
00:50:46,000 --> 00:50:48,000
比较有意义的码点

1618
00:50:48,000 --> 00:50:50,000
所以码点就是

1619
00:50:50,000 --> 00:50:53,000
一个字符相对应于

1620
00:50:53,000 --> 00:50:56,000
它的二进制数字

1621
00:50:56,000 --> 00:50:57,000
所在的位置

1622
00:50:57,000 --> 00:50:59,000
叫做码点

1623
00:50:59,000 --> 00:51:01,000
那么在 65

1624
00:51:01,000 --> 00:51:03,000
这个码点上面是 A

1625
00:51:03,000 --> 00:51:05,000
那么符合逻辑的方式

1626
00:51:05,000 --> 00:51:07,000
就是把 B 放在 66 上

1627
00:51:07,000 --> 00:51:08,000
然后一侧一推

1628
00:51:08,000 --> 00:51:09,000
对吧

1629
00:51:09,000 --> 00:51:11,000
大写字母完之后

1630
00:51:11,000 --> 00:51:12,000
是一对标点符号

1631
00:51:12,000 --> 00:51:13,000
然后是小写字母

1632
00:51:13,000 --> 00:51:17,000
那有一个问题就是

1633
00:51:17,000 --> 00:51:20,000
七位的二进制数字

1634
00:51:20,000 --> 00:51:24,000
可以表示 127 个字符

1635
00:51:24,000 --> 00:51:27,000
对于英语来说是够的

1636
00:51:27,000 --> 00:51:28,000
甚至可以表示大写

1637
00:51:28,000 --> 00:51:29,000
小写

1638
00:51:29,000 --> 00:51:30,000
加上数字等等

1639
00:51:30,000 --> 00:51:32,000
那么为什么要选用

1640
00:51:32,000 --> 00:51:33,000
七位这个数字

1641
00:51:33,000 --> 00:51:34,000
也是因为

1642
00:51:34,000 --> 00:51:36,000
如果你把第八位

1643
00:51:36,000 --> 00:51:37,000
也用上的话

1644
00:51:37,000 --> 00:51:38,000
就可以让其他人

1645
00:51:38,000 --> 00:51:40,000
去定义一些比较

1646
00:51:40,000 --> 00:51:42,000
额外的东西

1647
00:51:42,000 --> 00:51:44,000
比如说西欧语言

1648
00:51:44,000 --> 00:51:46,000
会用到各种各样的 diatric

1649
00:51:46,000 --> 00:51:48,000
那就是在字母上面

1650
00:51:48,000 --> 00:51:49,000
加点啊

1651
00:51:49,000 --> 00:51:50,000
打撇啊

1652
00:51:50,000 --> 00:51:51,000
等等诸如此类

1653
00:51:51,000 --> 00:51:52,000
非常愚蠢的事情

1654
00:51:52,000 --> 00:51:55,000
那么他们所使用的方法

1655
00:51:55,000 --> 00:51:59,000
就是把这个七位数字

1656
00:51:59,000 --> 00:52:00,000
扩展到八位

1657
00:52:00,000 --> 00:52:02,000
或者说利用这个

1658
00:52:02,000 --> 00:52:03,000
ASCII 编码标准

1659
00:52:03,000 --> 00:52:05,000
刻意将第八位

1660
00:52:05,000 --> 00:52:07,000
永远设为零的特点

1661
00:52:07,000 --> 00:52:09,000
规定了

1662
00:52:09,000 --> 00:52:10,000
当第八位变成一的时候

1663
00:52:10,000 --> 00:52:12,000
多出来的呢

1664
00:52:12,000 --> 00:52:13,000
127 个码点

1665
00:52:13,000 --> 00:52:15,000
应该具体代表什么

1666
00:52:15,000 --> 00:52:16,000
那么在这个标准上

1667
00:52:16,000 --> 00:52:18,000
西欧多了很多

1668
00:52:18,000 --> 00:52:19,000
自己的字符标准

1669
00:52:19,000 --> 00:52:21,000
每个国家都不一样

1670
00:52:21,000 --> 00:52:22,000
然后

1671
00:52:22,000 --> 00:52:25,000
我记得 CGK 也是

1672
00:52:25,000 --> 00:52:25,000
sorry

1673
00:52:25,000 --> 00:52:27,000
在日本也是

1674
00:52:27,000 --> 00:52:28,000
他们利用着

1675
00:52:28,000 --> 00:52:29,000
多出来的 127 个码点

1676
00:52:29,000 --> 00:52:31,000
加入了评价名

1677
00:52:31,000 --> 00:52:31,000
骗价名等等

1678
00:52:31,000 --> 00:52:35,000
所以有了日本的一套

1679
00:52:35,000 --> 00:52:35,000
自己的规则

1680
00:52:35,000 --> 00:52:36,000
但是那个时候

1681
00:52:36,000 --> 00:52:38,000
这个编码只能表示假名

1682
00:52:38,000 --> 00:52:39,000
但是

1683
00:52:39,000 --> 00:52:41,000
我们都知道

1684
00:52:41,000 --> 00:52:41,000
这个

1685
00:52:41,000 --> 00:52:43,000
汉字的数量

1686
00:52:43,000 --> 00:52:43,000
凡多

1687
00:52:43,000 --> 00:52:46,000
256 个显示是不够用的

1688
00:52:46,000 --> 00:52:46,000
那

1689
00:52:46,000 --> 00:52:48,000
早期的一个解决方案

1690
00:52:48,000 --> 00:52:50,000
就是用两个

1691
00:52:50,000 --> 00:52:53,000
二进制的八位数

1692
00:52:53,000 --> 00:52:54,000
来代表一个汉字

1693
00:52:54,000 --> 00:52:56,000
所以你就有

1694
00:52:56,000 --> 00:52:57,000
256 乘 256

1695
00:52:57,000 --> 00:52:59,000
256 乘 256

1696
00:52:59,000 --> 00:53:00,000
这种可能性

1697
00:53:00,000 --> 00:53:03,000
问题在于

1698
00:53:03,000 --> 00:53:04,000
由于政治原因

1699
00:53:04,000 --> 00:53:05,000
早期的中国

1700
00:53:05,000 --> 00:53:07,000
台湾和香港

1701
00:53:07,000 --> 00:53:09,000
对于汉字的编码

1702
00:53:09,000 --> 00:53:11,000
规定是不一样的

1703
00:53:11,000 --> 00:53:12,000
日本还有一套

1704
00:53:12,000 --> 00:53:13,000
自己的体系

1705
00:53:13,000 --> 00:53:14,000
不过好在后来

1706
00:53:14,000 --> 00:53:15,000
出现了一种

1707
00:53:15,000 --> 00:53:16,000
叫做 unicle 的东西

1708
00:53:16,000 --> 00:53:17,000
unicle 首先

1709
00:53:17,000 --> 00:53:18,000
它规定了一个序列

1710
00:53:18,000 --> 00:53:20,000
在这个序列里面

1711
00:53:20,000 --> 00:53:20,000
就是一

1712
00:53:20,000 --> 00:53:21,000
怎么说的

1713
00:53:21,000 --> 00:53:23,000
就是一系列的码点

1714
00:53:23,000 --> 00:53:24,000
在每个码点上

1715
00:53:24,000 --> 00:53:25,000
规定了这个码点

1716
00:53:25,000 --> 00:53:26,000
对应哪个汉字

1717
00:53:26,000 --> 00:53:29,000
不管这个汉字是

1718
00:53:29,000 --> 00:53:31,000
参入什么样的字型

1719
00:53:31,000 --> 00:53:33,000
来自于哪个国家

1720
00:53:33,000 --> 00:53:37,000
全都会归在

1721
00:53:37,000 --> 00:53:39,000
这个 unicle 的序列里面

1722
00:53:39,000 --> 00:53:41,000
然后 unicle 指定了

1723
00:53:41,000 --> 00:53:43,000
一个编码的方法

1724
00:53:43,000 --> 00:53:43,000
也就是

1725
00:53:43,000 --> 00:53:45,000
在某一个特定

1726
00:53:45,000 --> 00:53:46,000
码点上的汉字

1727
00:53:46,000 --> 00:53:47,000
比如说

1728
00:53:47,000 --> 00:53:51,000
3002

1729
00:53:51,000 --> 00:53:53,000
码点上面的汉字

1730
00:53:53,000 --> 00:53:54,000
是甲乙饼跟甲

1731
00:53:54,000 --> 00:53:56,000
它规定说

1732
00:53:56,000 --> 00:53:58,000
当你把这个甲字

1733
00:53:58,000 --> 00:54:01,000
以二进制形式表示的时候

1734
00:54:01,000 --> 00:54:03,000
你有很多种选择

1735
00:54:03,000 --> 00:54:05,000
最常见的一种选择

1736
00:54:05,000 --> 00:54:07,000
我们现在叫做 UTF 8

1737
00:54:07,000 --> 00:54:08,000
UTF 8

1738
00:54:08,000 --> 00:54:12,000
在 UTF 8 的表示之下

1739
00:54:12,000 --> 00:54:16,000
位于码点 3002 的甲

1740
00:54:16,000 --> 00:54:18,000
这个字

1741
00:54:18,000 --> 00:54:19,000
会不会转化为

1742
00:54:19,000 --> 00:54:20,000
有点长了

1743
00:54:20,000 --> 00:54:21,000
是一个 3

1744
00:54:21,000 --> 00:54:24,000
乘 8

1745
00:54:24,000 --> 00:54:25,000
位的 RG

1746
00:54:25,000 --> 00:54:28,000
是 10011

1747
00:54:28,000 --> 00:54:30,000
10010

1748
00:54:30,000 --> 00:54:31,000
1010

1749
00:54:31,000 --> 00:54:32,000
1011

1750
00:54:32,000 --> 00:54:33,000
0010

1751
00:54:33,000 --> 00:54:36,000
我是这个世界上

1752
00:54:36,000 --> 00:54:37,000
唯一一个把

1753
00:54:37,000 --> 00:54:38,000
假的汉字

1754
00:54:38,000 --> 00:54:39,000
转化为

1755
00:54:39,000 --> 00:54:41,000
语音形式的 RG

1756
00:54:41,000 --> 00:54:41,000
代码

1757
00:54:41,000 --> 00:54:42,000
什么

1758
00:54:42,000 --> 00:54:43,000
太搞笑了

1759
00:54:43,000 --> 00:54:46,000
本质上来讲

1760
00:54:46,000 --> 00:54:46,000
或者说

1761
00:54:46,000 --> 00:54:47,000
对于计算机来讲

1762
00:54:47,000 --> 00:54:49,000
你告诉他

1763
00:54:49,000 --> 00:54:53,000
10001001

1764
00:54:53,000 --> 00:54:54,000
也好

1765
00:54:54,000 --> 00:54:55,000
还是你告诉他

1766
00:54:55,000 --> 00:54:57,000
我刚才说的是 24 个

1767
00:54:57,000 --> 00:54:58,000
RG

1768
00:54:58,000 --> 00:54:59,000
的数字

1769
00:54:59,000 --> 00:54:59,000
也好

1770
00:54:59,000 --> 00:55:00,000
在他看来

1771
00:55:00,000 --> 00:55:01,000
都是一样的

1772
00:55:01,000 --> 00:55:01,000
但是

1773
00:55:01,000 --> 00:55:04,000
对于人类来说

1774
00:55:04,000 --> 00:55:05,000
其解读方式

1775
00:55:05,000 --> 00:55:05,000
是不一样

1776
00:55:05,000 --> 00:55:06,000
那么

1777
00:55:06,000 --> 00:55:07,000
无论音频文件

1778
00:55:07,000 --> 00:55:09,000
还是视频文件

1779
00:55:09,000 --> 00:55:11,000
规源解体

1780
00:55:11,000 --> 00:55:12,000
基本上都可以

1781
00:55:12,000 --> 00:55:12,000
这样类推

1782
00:55:12,000 --> 00:55:13,000
只不过里面还

1783
00:55:13,000 --> 00:55:14,000
包含了更多

1784
00:55:14,000 --> 00:55:15,000
其他的因素

1785
00:55:15,000 --> 00:55:15,000
比如说

1786
00:55:15,000 --> 00:55:17,000
你可以把一个

1787
00:55:17,000 --> 00:55:18,000
点上面的颜色

1788
00:55:18,000 --> 00:55:22,000
划分为

1789
00:55:22,000 --> 00:55:24,000
红绿蓝

1790
00:55:24,000 --> 00:55:25,000
三个

1791
00:55:25,000 --> 00:55:26,000
分量

1792
00:55:26,000 --> 00:55:27,000
然后每个分量

1793
00:55:27,000 --> 00:55:29,000
用一个

1794
00:55:29,000 --> 00:55:31,000
0 到 256 的数字

1795
00:55:31,000 --> 00:55:31,000
表示

1796
00:55:31,000 --> 00:55:33,000
0 到 255 的数字

1797
00:55:33,000 --> 00:55:33,000
表示

1798
00:55:33,000 --> 00:55:34,000
那么你就可以

1799
00:55:34,000 --> 00:55:35,000
规定每个

1800
00:55:35,000 --> 00:55:36,000
你就可以得到

1801
00:55:36,000 --> 00:55:37,000
每个点上的

1802
00:55:37,000 --> 00:55:38,000
学名有了 RGB 的值

1803
00:55:38,000 --> 00:55:39,000
但是

1804
00:55:39,000 --> 00:55:41,000
如果你要记载

1805
00:55:41,000 --> 00:55:42,000
每一

1806
00:55:42,000 --> 00:55:43,000
如果你要记载

1807
00:55:43,000 --> 00:55:44,000
一部电影里面的

1808
00:55:44,000 --> 00:55:45,000
每一帧的

1809
00:55:45,000 --> 00:55:47,000
每一个点上的

1810
00:55:47,000 --> 00:55:48,000
这个数字

1811
00:55:48,000 --> 00:55:49,000
其代价

1812
00:55:49,000 --> 00:55:50,000
会是非常高昂的

1813
00:55:50,000 --> 00:55:52,000
因为我们目前的

1814
00:55:52,000 --> 00:55:53,000
科技手段

1815
00:55:53,000 --> 00:55:54,000
还没有办法保证

1816
00:55:54,000 --> 00:55:57,000
说能够完全不去考虑

1817
00:55:57,000 --> 00:55:59,000
存储

1818
00:55:59,000 --> 00:56:00,000
或者说传输

1819
00:56:00,000 --> 00:56:02,000
过程之中的空间

1820
00:56:02,000 --> 00:56:04,000
乃至于时间的损耗

1821
00:56:04,000 --> 00:56:06,000
所以人们又想出的

1822
00:56:06,000 --> 00:56:07,000
另外一方法

1823
00:56:07,000 --> 00:56:07,000
就是

1824
00:56:07,000 --> 00:56:10,000
找出所有这些

1825
00:56:10,000 --> 00:56:11,000
数字里面的

1826
00:56:11,000 --> 00:56:12,000
重复部分

1827
00:56:12,000 --> 00:56:14,000
用一个更短的

1828
00:56:14,000 --> 00:56:14,000
数字去代替

1829
00:56:14,000 --> 00:56:15,000
对

1830
00:56:15,000 --> 00:56:16,000
这就是压缩的本质

1831
00:56:16,000 --> 00:56:17,000
所以我们可以

1832
00:56:17,000 --> 00:56:18,000
把它理解为

1833
00:56:18,000 --> 00:56:20,000
对于编码的

1834
00:56:20,000 --> 00:56:22,000
再编码

1835
00:56:22,000 --> 00:56:23,000
这就是另外一层

1836
00:56:23,000 --> 00:56:24,000
的考虑

1837
00:56:24,000 --> 00:56:29,000
对

1838
00:56:29,000 --> 00:56:31,000
其实这期的提章里面

1839
00:56:31,000 --> 00:56:32,000
还数了一些其他话

1840
00:56:32,000 --> 00:56:34,000
包括 Unical 的

1841
00:56:34,000 --> 00:56:35,000
本来都是打算

1842
00:56:35,000 --> 00:56:36,000
在展开讲

1843
00:56:36,000 --> 00:56:39,000
还有很多历史之类的

1844
00:56:39,000 --> 00:56:40,000
但是

1845
00:56:40,000 --> 00:56:42,000
目前的状况是

1846
00:56:42,000 --> 00:56:44,000
我这边录音的时间

1847
00:56:44,000 --> 00:56:45,000
刚刚突破了

1848
00:56:45,000 --> 00:56:46,000
一个小时的 Mark

1849
00:56:46,000 --> 00:56:48,000
当然最后剪出来

1850
00:56:48,000 --> 00:56:49,000
可能没有一个小时

1851
00:56:49,000 --> 00:56:49,000
不过

1852
00:56:49,000 --> 00:56:51,000
此时的我已经觉得

1853
00:56:51,000 --> 00:56:52,000
嗓子非常疼了

1854
00:56:52,000 --> 00:56:55,000
而且很不幸

1855
00:56:55,000 --> 00:56:56,000
过敏性鼻炎

1856
00:56:56,000 --> 00:56:57,000
又开始犯了

1857
00:56:57,000 --> 00:56:57,000
所以

1858
00:56:57,000 --> 00:56:59,000
这一期只能

1859
00:56:59,000 --> 00:57:01,000
我们还没有

1860
00:57:01,000 --> 00:57:02,000
进入正题是吧

1861
00:57:02,000 --> 00:57:02,000
OK

1862
00:57:02,000 --> 00:57:04,000
那么来赶紧

1863
00:57:04,000 --> 00:57:04,000
进入一下正题

1864
00:57:04,000 --> 00:57:05,000
好了

1865
00:57:05,000 --> 00:57:07,000
正题就是

1866
00:57:07,000 --> 00:57:08,000
程序员怎样

1867
00:57:08,000 --> 00:57:09,000
才能找到女朋友呢

1868
00:57:09,000 --> 00:57:10,000
问好

1869
00:57:10,000 --> 00:57:12,000
答案很简单

1870
00:57:12,000 --> 00:57:13,000
就是

1871
00:57:13,000 --> 00:57:14,000
除非你的女朋友

1872
00:57:14,000 --> 00:57:14,000
候选人

1873
00:57:14,000 --> 00:57:15,000
就是耗这一口

1874
00:57:15,000 --> 00:57:16,000
那么

1875
00:57:16,000 --> 00:57:18,000
单纯以程序员的身份

1876
00:57:18,000 --> 00:57:20,000
对于找到女朋友

1877
00:57:20,000 --> 00:57:21,000
来说没有任何意义

1878
00:57:21,000 --> 00:57:23,000
true story

1879
00:57:23,000 --> 00:57:25,000
只有抛开

1880
00:57:25,000 --> 00:57:26,000
我是程序员

1881
00:57:26,000 --> 00:57:26,000
这一个字

1882
00:57:26,000 --> 00:57:28,000
我认同之后

1883
00:57:28,000 --> 00:57:28,000
找女朋友

1884
00:57:28,000 --> 00:57:30,000
才会变得比较容易

1885
00:57:30,000 --> 00:57:33,000
比如你要弄明白

1886
00:57:33,000 --> 00:57:33,000
人和人之间

1887
00:57:33,000 --> 00:57:34,000
沟通的编码

1888
00:57:34,000 --> 00:57:36,000
这个编码体系

1889
00:57:36,000 --> 00:57:38,000
一方面要比

1890
00:57:38,000 --> 00:57:39,000
计算机系统

1891
00:57:39,000 --> 00:57:40,000
我们刚才所说的

1892
00:57:40,000 --> 00:57:41,000
一些编码

1893
00:57:41,000 --> 00:57:41,000
简单的多

1894
00:57:41,000 --> 00:57:43,000
另一方面

1895
00:57:43,000 --> 00:57:44,000
要比它复杂的多

1896
00:57:44,000 --> 00:57:45,000
你要去

1897
00:57:45,000 --> 00:57:46,000
学会理解

1898
00:57:46,000 --> 00:57:49,000
不同性别之间的

1899
00:57:49,000 --> 00:57:49,000
心理差异

1900
00:57:49,000 --> 00:57:51,000
不管这种差异

1901
00:57:51,000 --> 00:57:52,000
是怎么来的

1902
00:57:52,000 --> 00:57:54,000
你都必须了解它

1903
00:57:54,000 --> 00:57:57,000
你要去了解

1904
00:57:57,000 --> 00:57:58,000
什么是嫌爱之音

1905
00:57:58,000 --> 00:58:00,000
你要弄明白

1906
00:58:00,000 --> 00:58:01,000
女孩子说话

1907
00:58:01,000 --> 00:58:02,000
有时候是

1908
00:58:02,000 --> 00:58:03,000
话里有话的

1909
00:58:03,000 --> 00:58:04,000
对吧

1910
00:58:04,000 --> 00:58:07,000
我女朋友在点头

1911
00:58:07,000 --> 00:58:09,000
好吧

1912
00:58:09,000 --> 00:58:11,000
您正在

1913
00:58:11,000 --> 00:58:12,000
您刚刚收听完的是

1914
00:58:12,000 --> 00:58:13,000
IPM Podcast

1915
00:58:13,000 --> 00:58:14,000
网络旗下的

1916
00:58:14,000 --> 00:58:15,000
IT 技术节目

1917
00:58:15,000 --> 00:58:16,000
内核恐慌

1918
00:58:16,000 --> 00:58:18,000
也欢迎你收听

1919
00:58:18,000 --> 00:58:18,000
IPM 旗下的

1920
00:58:18,000 --> 00:58:20,000
其他六档 Podcast

1921
00:58:20,000 --> 00:58:20,000
包括

1922
00:58:20,000 --> 00:58:23,000
同样是

1923
00:58:23,000 --> 00:58:24,000
技术主题节目

1924
00:58:24,000 --> 00:58:24,000
IT 公问

1925
00:58:24,000 --> 00:58:26,000
医疗主题节目

1926
00:58:26,000 --> 00:58:27,000
太一来了

1927
00:58:27,000 --> 00:58:28,000
美食主题节目

1928
00:58:28,000 --> 00:58:29,000
未知道

1929
00:58:29,000 --> 00:58:30,000
艺术主题节目

1930
00:58:30,000 --> 00:58:30,000
流行通信

1931
00:58:30,000 --> 00:58:32,000
无主题节目

1932
00:58:32,000 --> 00:58:32,000
无次元

1933
00:58:32,000 --> 00:58:34,000
故事主题节目

1934
00:58:34,000 --> 00:58:34,000
HiStory

1935
00:58:34,000 --> 00:58:35,000
以及

1936
00:58:35,000 --> 00:58:37,000
影像主题节目

1937
00:58:37,000 --> 00:58:38,000
硬影像

1938
00:58:38,000 --> 00:58:40,000
感谢大家的收听

1939
00:58:40,000 --> 00:58:45,000
的

1940
00:58:45,000 --> 00:58:46,000
台幻念

1941
00:58:46,000 --> 00:58:47,000
Who

1942
00:58:47,000 --> 00:58:48,000
都

1943
00:58:48,000 --> 00:58:49,000
拜拜

1944
00:58:49,000 --> 00:58:49,000
这个

1945
00:58:49,000 --> 00:58:50,000
可以

1946
00:58:50,000 --> 00:58:54,000
和

1947
00:58:54,000 --> 00:58:57,000
子

1948
00:58:57,000 --> 00:58:58,000
又

1949
00:58:58,000 --> 00:58:58,000
土

1950
00:58:58,000 --> 00:58:58,000
呀

1951
00:58:58,000 --> 00:58:59,000
� sequence

1952
00:58:59,000 --> 00:59:04,000
Bra

1953
00:59:04,000 --> 00:59:05,000
给

1954
00:59:05,000 --> 00:59:05,000
词

