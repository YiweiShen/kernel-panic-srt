1
00:00:00,000 --> 00:00:01,000
欢迎收听 IPN Podcast

2
00:00:01,000 --> 00:00:04,000
网络旗下的 IT 技术主题娱乐节目

3
00:00:04,000 --> 00:00:05,000
内核恐慌

4
00:00:05,000 --> 00:00:06,000
我们号称 Hardcore

5
00:00:06,000 --> 00:00:08,000
但是也没有什么干货

6
00:00:08,000 --> 00:00:09,000
想听的人听

7
00:00:09,000 --> 00:00:10,000
不想听的人就别听

8
00:00:10,000 --> 00:00:12,000
本节目的网址是

9
00:00:12,000 --> 00:00:16,000
ipn.li.colpanic

10
00:00:16,000 --> 00:00:19,000
我们推荐大家使用 Podcast 客户端订阅节目

11
00:00:19,000 --> 00:00:21,000
详情请访问

12
00:00:21,000 --> 00:00:23,000
ipn.li.faq

13
00:00:23,000 --> 00:00:26,000
欢迎你为本节目捐款

14
00:00:26,000 --> 00:00:26,000
捐款的只是

15
00:00:26,000 --> 00:00:30,000
ipn.li.colpanic.donate

16
00:00:30,000 --> 00:00:32,000
捐款金额随意

17
00:00:32,000 --> 00:00:33,000
只要是能被扒

18
00:00:33,000 --> 00:00:35,000
除的正整数就可以

19
00:00:35,000 --> 00:00:37,000
捐款不会给你带来什么

20
00:00:37,000 --> 00:00:39,000
不捐也不会让你失去什么

21
00:00:39,000 --> 00:00:40,000
我们的口号是

22
00:00:40,000 --> 00:00:42,000
hyper is hyper awesome

23
00:00:42,000 --> 00:00:44,000
今天我们特别荣幸

24
00:00:44,000 --> 00:00:45,000
请到一位嘉宾

25
00:00:45,000 --> 00:00:47,000
Simon 薛磊

26
00:00:47,000 --> 00:00:49,000
薛磊也给大家介绍一下自己吧

27
00:00:49,000 --> 00:00:50,000
Hello 大家好

28
00:00:50,000 --> 00:00:51,000
我叫 Simon

29
00:00:51,000 --> 00:00:55,000
然后我现在从事的是一项基于

30
00:00:55,000 --> 00:00:59,000
容器的一个创业项目

31
00:00:59,000 --> 00:01:00,000
然后目前呢

32
00:01:00,000 --> 00:01:01,000
是处于初创阶段

33
00:01:01,000 --> 00:01:03,000
之前我从事的是

34
00:01:03,000 --> 00:01:05,000
主要是内核相关的工作

35
00:01:05,000 --> 00:01:08,000
之前也非常热衷的关注于

36
00:01:08,000 --> 00:01:09,000
内核相关的所有的一个

37
00:01:09,000 --> 00:01:12,000
创业的相关的项目

38
00:01:12,000 --> 00:01:15,000
然后包括最近特别火的一个容器

39
00:01:15,000 --> 00:01:18,000
所以呢也加入了这个以容器

40
00:01:18,000 --> 00:01:21,000
或者说以 hypervisor 为主题的一个创业项目

41
00:01:21,000 --> 00:01:23,000
非常荣幸的能参加

42
00:01:23,000 --> 00:01:26,000
内核恐慌这个节目

43
00:01:26,000 --> 00:01:28,000
之前也很关注

44
00:01:28,000 --> 00:01:29,000
非常谦虚啊

45
00:01:29,000 --> 00:01:32,000
因为那个 Simon 的自我介绍很低调

46
00:01:32,000 --> 00:01:35,000
其实 Simon 你之前是在这个 Song

47
00:01:35,000 --> 00:01:38,000
就是那后来你家卖给 Oracle 的公司

48
00:01:38,000 --> 00:01:40,000
也就是 Java 的诞生地对吧

49
00:01:40,000 --> 00:01:40,000
对对对

50
00:01:40,000 --> 00:01:43,000
其实说到 Song 其实有

51
00:01:43,000 --> 00:01:46,000
更多的人其实只知道是 Java

52
00:01:46,000 --> 00:01:48,000
但是除了 Java 之外

53
00:01:48,000 --> 00:01:52,000
它有非常非常多的优秀的项目

54
00:01:52,000 --> 00:01:53,000
比如说 Solos

55
00:01:53,000 --> 00:01:55,000
就是 UNIX 的一个变种

56
00:01:55,000 --> 00:01:57,000
可能目前很多 Linux 内核

57
00:01:57,000 --> 00:02:02,000
以及 Linux 分化版本上面的软件

58
00:02:02,000 --> 00:02:04,000
以及内核的模块

59
00:02:04,000 --> 00:02:05,000
都是来自于 Solos

60
00:02:05,000 --> 00:02:08,000
比如特别著名的 ZFS

61
00:02:08,000 --> 00:02:10,000
当然可能做存储的人

62
00:02:10,000 --> 00:02:14,000
都知道 ZFS 它的一个特别强大的工程

63
00:02:14,000 --> 00:02:17,000
以及调试内核的时候

64
00:02:17,000 --> 00:02:19,000
所用到的一些工具

65
00:02:19,000 --> 00:02:21,000
比如说 MDB

66
00:02:21,000 --> 00:02:24,000
Linux 上类似的就是 GDB

67
00:02:24,000 --> 00:02:28,000
然后一种追踪内核的

68
00:02:28,000 --> 00:02:31,000
不极限于内核

69
00:02:31,000 --> 00:02:33,000
除了内核还有应用程序

70
00:02:33,000 --> 00:02:35,000
都可以追踪 Dtrace

71
00:02:35,000 --> 00:02:39,000
就像目前的 System Type

72
00:02:39,000 --> 00:02:40,000
以及 K Type

73
00:02:40,000 --> 00:02:43,000
以及类似这种 Trace 工具

74
00:02:43,000 --> 00:02:49,000
应该说大多数都来自于 Dtrace 的设计理念

75
00:02:49,000 --> 00:02:50,000
非常酷

76
00:02:50,000 --> 00:02:50,000
非常酷

77
00:02:50,000 --> 00:02:52,000
那个 Sam

78
00:02:52,000 --> 00:02:53,000
你之前在 Song 的话

79
00:02:53,000 --> 00:02:54,000
具体是做哪一块工作呢

80
00:02:54,000 --> 00:02:57,000
我之前在 Song 的时候

81
00:02:57,000 --> 00:02:59,000
是北京研发中心

82
00:02:59,000 --> 00:03:01,000
北京研发中心这边主要的一大块

83
00:03:01,000 --> 00:03:04,000
是大概一个 20 多人的一个团队

84
00:03:04,000 --> 00:03:08,000
主要是从事的是 Solos 的一个存储

85
00:03:08,000 --> 00:03:10,000
存储协议的一个研发

86
00:03:10,000 --> 00:03:12,000
主要集中在 Skaz 协议

87
00:03:12,000 --> 00:03:13,000
这个可能比较底层吧

88
00:03:13,000 --> 00:03:16,000
可能不做内核的人不太清楚

89
00:03:16,000 --> 00:03:17,000
这一块东西

90
00:03:17,000 --> 00:03:21,000
这就是一个相当于一个标准的网络存储协议

91
00:03:21,000 --> 00:03:25,000
比如就现在咱们说的硬盘

92
00:03:25,000 --> 00:03:26,000
就 Skaz 硬盘

93
00:03:26,000 --> 00:03:28,000
像什么 Sata 硬盘等等等等

94
00:03:28,000 --> 00:03:30,000
都是走的 Skaz 协议

95
00:03:30,000 --> 00:03:34,000
所以我们其实在这一条线上去做开发

96
00:03:34,000 --> 00:03:38,000
可能就是也比较偏存储一点

97
00:03:38,000 --> 00:03:40,000
也比较偏内核一点

98
00:03:40,000 --> 00:03:44,000
Skaz 当年还是跟那个什么 IDE

99
00:03:44,000 --> 00:03:46,000
那些是叫 IDE 吧

100
00:03:46,000 --> 00:03:46,000
对对对

101
00:03:46,000 --> 00:03:48,000
对应那个时候

102
00:03:48,000 --> 00:03:49,000
现在后来是发展成了

103
00:03:49,000 --> 00:03:52,000
是 Sata 对 SaaS 对吧

104
00:03:52,000 --> 00:03:54,000
SaaS 两个协议

105
00:03:54,000 --> 00:03:56,000
然后 Skaz 也是 SaaS 的前身

106
00:03:56,000 --> 00:03:57,000
如果我理解没错的话

107
00:03:57,000 --> 00:03:58,000
对 是的

108
00:03:58,000 --> 00:03:59,000
OK

109
00:03:59,000 --> 00:04:00,000
所以你之前的主要工作

110
00:04:00,000 --> 00:04:02,000
是在做存储协议这一块

111
00:04:02,000 --> 00:04:02,000
对 是

112
00:04:02,000 --> 00:04:04,000
所以也是非常一个 hardcore 的人

113
00:04:04,000 --> 00:04:06,000
特别适合我们节目的主题

114
00:04:06,000 --> 00:04:12,000
所以我最开始关注疯狂的节目的时候

115
00:04:12,000 --> 00:04:16,000
就因为自己从事这个行业嘛

116
00:04:16,000 --> 00:04:19,000
所以就是也关注这个发现还是挺有意思的

117
00:04:19,000 --> 00:04:23,000
虽然我们节目一直都号称自己非常水

118
00:04:23,000 --> 00:04:26,000
然后这一期终于有一个够硬的干货

119
00:04:26,000 --> 00:04:27,000
也满足大家的要求了

120
00:04:27,000 --> 00:04:28,000
OK

121
00:04:28,000 --> 00:04:30,000
那个 Simon 刚才你提到

122
00:04:30,000 --> 00:04:32,000
你现在在做一个跟这个容器相关的

123
00:04:32,000 --> 00:04:36,000
当然我们节目在之前的某一期里面也提到过

124
00:04:36,000 --> 00:04:39,000
这个概念叫做 container

125
00:04:39,000 --> 00:04:40,000
对对对

126
00:04:40,000 --> 00:04:45,000
然后但是当时毕竟我跟吴涛两个人都属于这个东西的一个叫什么

127
00:04:45,000 --> 00:04:47,000
用户或者说是门外汉

128
00:04:47,000 --> 00:04:49,000
但是你其实是在做这块相关的开发的

129
00:04:49,000 --> 00:04:50,000
所以本期呢

130
00:04:50,000 --> 00:04:54,000
我们可能会就这个问题进入一些更加深热探讨

131
00:04:54,000 --> 00:04:54,000
OK

132
00:04:54,000 --> 00:04:57,000
所以你现在做这间公司这个项目叫什么

133
00:04:57,000 --> 00:05:00,000
其实这个项目就叫 Hyper

134
00:05:00,000 --> 00:05:03,000
然后 Hyper 这个我们的这个公司呢

135
00:05:03,000 --> 00:05:04,000
就叫 Hyper HQ

136
00:05:04,000 --> 00:05:08,000
然后主要为什么取这个名字呢

137
00:05:08,000 --> 00:05:15,000
其实也是想针对国外的用户或者一些企业或者 partner 来去做

138
00:05:15,000 --> 00:05:19,000
所以这个中文的名字不太好听

139
00:05:19,000 --> 00:05:20,000
所以大家也就忽悔吧

140
00:05:20,000 --> 00:05:23,000
大家更多关注可以关注我们的那个英文的网站

141
00:05:23,000 --> 00:05:26,000
然后可能我们的中文网站还在做

142
00:05:26,000 --> 00:05:30,000
也没有特别的一个进展

143
00:05:30,000 --> 00:05:32,000
但是所以就是我们的一个定位吧

144
00:05:32,000 --> 00:05:36,000
可能跟之前的国内的一个创业团队不太一样

145
00:05:36,000 --> 00:05:39,000
我们还是希望能够做得足够精致吧

146
00:05:39,000 --> 00:05:40,000
所以

147
00:05:40,000 --> 00:05:40,000
OK

148
00:05:40,000 --> 00:05:43,000
对这个事情说来就非常巧

149
00:05:43,000 --> 00:05:46,000
其实我跟三文的认识还是一个机缘巧合

150
00:05:46,000 --> 00:05:49,000
就有一天我收到了一封这个邮件

151
00:05:49,000 --> 00:05:54,000
然后发给我的地址是对应到我的那个 GitHub 的账号的那个邮箱的

152
00:05:54,000 --> 00:05:56,000
然后是三文给我来的一封信

153
00:05:56,000 --> 00:05:58,000
然后他是问我说能不能

154
00:05:58,000 --> 00:06:01,000
因为我当时在 GitHub 上面有一个项目是

155
00:06:01,000 --> 00:06:05,000
是用这个命令行控制通过这个 VirtualBox 的命令行工具去控制它

156
00:06:05,000 --> 00:06:09,000
启动这个虚拟机啊创建虚拟机这种基本的小工具

157
00:06:09,000 --> 00:06:12,000
是一个勾烂的一个库吧

158
00:06:12,000 --> 00:06:15,000
然后当时三文给我来了一封邮件说能不能用这个

159
00:06:15,000 --> 00:06:20,000
因为当时我在那个 GitHub 上面那个 Repository 里面没有写这个授权协议

160
00:06:20,000 --> 00:06:22,000
这点我还是当时我就非常感动

161
00:06:22,000 --> 00:06:26,000
因为你知道很多这个大家都是直接拿来主意嘛

162
00:06:26,000 --> 00:06:26,000
对吧

163
00:06:26,000 --> 00:06:26,000
对

164
00:06:26,000 --> 00:06:28,000
我们也不会问这种事情的

165
00:06:28,000 --> 00:06:31,000
所以在这方面我觉得像三文啊还有 Hyper 这个团队

166
00:06:31,000 --> 00:06:35,000
对这个版权意识还是非常非常这个看重的

167
00:06:35,000 --> 00:06:36,000
这点我觉得非常非常难得

168
00:06:36,000 --> 00:06:37,000
对对对

169
00:06:37,000 --> 00:06:40,000
就是因为我们其实我们这个项目

170
00:06:40,000 --> 00:06:46,000
就据我们所知因为国内很少有这种创业团队去做开源项目

171
00:06:46,000 --> 00:06:48,000
而我们这个 Hyper 其实是一个开源项目

172
00:06:48,000 --> 00:06:52,000
既然开源项目的话我们也是希望能够融入足够多的社区

173
00:06:52,000 --> 00:06:53,000
足够大的社区

174
00:06:53,000 --> 00:06:56,000
然后吸引更多的开发者

175
00:06:56,000 --> 00:07:02,000
然后所以在这方面其实也是尽自己微薄之力

176
00:07:02,000 --> 00:07:11,000
然后能尽量的改善一下国人在开发者在这全球的开发者的这种印象吧

177
00:07:11,000 --> 00:07:14,000
因为可能更多的提到可能国内的工程师

178
00:07:14,000 --> 00:07:17,000
当然只能是少少数吧

179
00:07:17,000 --> 00:07:19,000
他就拿开主意

180
00:07:19,000 --> 00:07:22,000
让让让让就直接毁坏了这个圈子的名声啊

181
00:07:22,000 --> 00:07:24,000
嗯嗯对对对

182
00:07:24,000 --> 00:07:27,000
刚才我们聊了一堆这个周边的情况啊

183
00:07:27,000 --> 00:07:29,000
最后才回到这个 Hyper 这个本质上

184
00:07:29,000 --> 00:07:33,000
在这个说之前我们先把这个网址亮出来吧

185
00:07:33,000 --> 00:07:36,000
这个网址是非常酷的一个域名叫做 Hyper.sh

186
00:07:36,000 --> 00:07:36,000
对

187
00:07:36,000 --> 00:07:39,000
当时你们怎么想的会启用这个一个

188
00:07:39,000 --> 00:07:41,000
这么一个域名

189
00:07:41,000 --> 00:07:44,000
因为毕竟其实我们的

190
00:07:44,000 --> 00:07:50,000
就是到达 sh 还是偏技术或者偏 hack 一点

191
00:07:50,000 --> 00:07:54,000
因为 sh 是你可以认为是 by 是啊

192
00:07:54,000 --> 00:07:57,000
或者是认为是其他的一些那个 share

193
00:07:57,000 --> 00:07:58,000
对对对

194
00:07:58,000 --> 00:08:02,000
所以我们当时也是用了这种

195
00:08:02,000 --> 00:08:07,000
当然也是追求足够精简短一体

196
00:08:07,000 --> 00:08:09,000
然后就选用了这个域名

197
00:08:09,000 --> 00:08:11,000
然后当时我们之前参加

198
00:08:11,000 --> 00:08:13,000
挺有意思的一个事情

199
00:08:13,000 --> 00:08:15,000
就是我们之前参加一个云计算的大会

200
00:08:15,000 --> 00:08:17,000
然后很多人过来说

201
00:08:17,000 --> 00:08:20,000
你们这家公司成立在上海是吗

202
00:08:20,000 --> 00:08:22,000
对

203
00:08:22,000 --> 00:08:26,000
但其实.sh 是哪个国家的这个国家顶级域来着

204
00:08:26,000 --> 00:08:29,000
这我还真真忘了

205
00:08:29,000 --> 00:08:30,000
OK

206
00:08:30,000 --> 00:08:31,000
这个我们回头查一下

207
00:08:31,000 --> 00:08:31,000
对对对

208
00:08:31,000 --> 00:08:34,000
但是一般我们会把这个一些 share 的工具啊

209
00:08:34,000 --> 00:08:38,000
会用这个.sh 这个顶级域来做

210
00:08:38,000 --> 00:08:38,000
对

211
00:08:38,000 --> 00:08:40,000
然后这个网站

212
00:08:40,000 --> 00:08:42,000
当时那个 SAMON 给我来信的时候

213
00:08:42,000 --> 00:08:44,000
我就问到这个项目网站的时候

214
00:08:44,000 --> 00:08:44,000
我就看了一下

215
00:08:44,000 --> 00:08:47,000
就是令我非常惊艳啊

216
00:08:47,000 --> 00:08:49,000
因为这确实不像是一个国内的团队

217
00:08:49,000 --> 00:08:50,000
做出来那种风格

218
00:08:50,000 --> 00:08:53,000
因为整个就是很美国的那种

219
00:08:53,000 --> 00:08:57,000
很酷很嘻哈的那种创业团队做出来的那种

220
00:08:57,000 --> 00:08:58,000
技术展示的页面

221
00:08:58,000 --> 00:09:00,000
非常精美非常漂亮

222
00:09:01,000 --> 00:09:02,000
所以说了这么多

223
00:09:02,000 --> 00:09:03,000
我们还没有介绍

224
00:09:03,000 --> 00:09:05,000
hyper 到底是个什么样东西

225
00:09:05,000 --> 00:09:07,000
SAMON 你能够用这个一句简单的话

226
00:09:07,000 --> 00:09:11,000
介绍一下 hyper 是一个就给我们不太熟悉这个东西的听众哈

227
00:09:11,000 --> 00:09:13,000
介绍一下 hyper 到底是个什么样的工具吗

228
00:09:13,000 --> 00:09:14,000
呃

229
00:09:14,000 --> 00:09:18,000
其实我觉得如果先介绍 hyper 之前应该先

230
00:09:18,000 --> 00:09:18,000
呃

231
00:09:18,000 --> 00:09:21,000
在介绍 hyper 之前最好先介绍一下刀客

232
00:09:21,000 --> 00:09:24,000
因为可能很多人没有了解过呃

233
00:09:24,000 --> 00:09:25,000
呃这个领域

234
00:09:25,000 --> 00:09:25,000
呃

235
00:09:25,000 --> 00:09:26,000
呃

236
00:09:26,000 --> 00:09:28,000
如果大家知道刀客的话

237
00:09:28,000 --> 00:09:31,000
那么说 hyper 的话就就很简单

238
00:09:31,000 --> 00:09:33,000
一句话就可以说说说明白了

239
00:09:33,000 --> 00:09:34,000
ok

240
00:09:34,000 --> 00:09:36,000
咱们咱们先说刀客慢慢来

241
00:09:36,000 --> 00:09:37,000
ok

242
00:09:37,000 --> 00:09:38,000
刀客呢

243
00:09:38,000 --> 00:09:40,000
它其实呃

244
00:09:40,000 --> 00:09:41,000
属于一个新兴的项目

245
00:09:41,000 --> 00:09:45,000
大概也存在了两到三年的发展速度相当相当惊人

246
00:09:45,000 --> 00:09:49,000
大概现在刀客的公司大概在估值十亿美金吧

247
00:09:49,000 --> 00:09:50,000
十亿美金超过十亿美金了

248
00:09:50,000 --> 00:09:51,000
嗯

249
00:09:51,000 --> 00:09:51,000
嗯

250
00:09:51,000 --> 00:09:55,000
然后它其实本质上是基于容器

251
00:09:55,000 --> 00:09:56,000
就是呃

252
00:09:56,000 --> 00:09:57,000
做的一组管理工具

253
00:09:57,000 --> 00:09:59,000
我我我是这么这么这么理解

254
00:09:59,000 --> 00:10:00,000
然后

255
00:10:00,000 --> 00:10:00,000
嗯

256
00:10:00,000 --> 00:10:02,000
它将一些

257
00:10:02,000 --> 00:10:03,000
镜像文件

258
00:10:03,000 --> 00:10:04,000
比如呃

259
00:10:04,000 --> 00:10:04,000
呃

260
00:10:04,000 --> 00:10:05,000
无望图啊

261
00:10:05,000 --> 00:10:06,000
各种 LegendSphere 版本都可以

262
00:10:06,000 --> 00:10:07,000
然后呃

263
00:10:07,000 --> 00:10:09,000
作为一个运行式环境

264
00:10:09,000 --> 00:10:11,000
然后装到呃

265
00:10:11,000 --> 00:10:12,000
呃容器里面

266
00:10:12,000 --> 00:10:14,000
然后去增加网络

267
00:10:14,000 --> 00:10:15,000
增加存储

268
00:10:15,000 --> 00:10:16,000
这这些所有的那个组件

269
00:10:16,000 --> 00:10:18,000
component

270
00:10:18,000 --> 00:10:18,000
然后

271
00:10:18,000 --> 00:10:20,000
使之呃

272
00:10:20,000 --> 00:10:24,000
作为一个轻量级的虚拟化工具来去运行

273
00:10:24,000 --> 00:10:27,000
然后这样的话就相当于在同一台机器上

274
00:10:27,000 --> 00:10:28,000
我可以虚拟出来

275
00:10:28,000 --> 00:10:30,000
多个单独的容器

276
00:10:30,000 --> 00:10:31,000
然后这样

277
00:10:31,000 --> 00:10:34,000
去运行不同的 APP

278
00:10:34,000 --> 00:10:35,000
嗯

279
00:10:35,000 --> 00:10:37,000
Dopper 一个其中一个理念就是

280
00:10:37,000 --> 00:10:39,000
或者说容器的一个理念就是一个容器里面

281
00:10:39,000 --> 00:10:41,000
只运行一个

282
00:10:41,000 --> 00:10:42,000
呃

283
00:10:42,000 --> 00:10:42,000
APP

284
00:10:42,000 --> 00:10:48,000
就是相当于我只运行一个 tomkine 或者说类似那个

285
00:10:48,000 --> 00:10:49,000
呃

286
00:10:49,000 --> 00:10:50,000
那个软件

287
00:10:50,000 --> 00:10:51,000
然后这样的话呢

288
00:10:51,000 --> 00:10:53,000
来做到使每个容器尽量的精简

289
00:10:53,000 --> 00:10:55,000
然后更便于管理

290
00:10:55,000 --> 00:10:57,000
他

291
00:10:57,000 --> 00:10:59,000
他他其实是为了呃

292
00:10:59,000 --> 00:11:00,000
呃

293
00:11:00,000 --> 00:11:01,000
为为这些呃

294
00:11:01,000 --> 00:11:02,000
呃

295
00:11:02,000 --> 00:11:04,000
运行或者说为这些开发测试

296
00:11:04,000 --> 00:11:06,000
呃

297
00:11:06,000 --> 00:11:07,000
呃

298
00:11:07,000 --> 00:11:09,000
比较一致的一个运行式环境

299
00:11:09,000 --> 00:11:10,000
然后这样的话就是

300
00:11:10,000 --> 00:11:13,000
你可以自己提交你自己的 contender 的镜像

301
00:11:13,000 --> 00:11:14,000
嗯

302
00:11:14,000 --> 00:11:17,000
然后直接提交过去之后任何人都可以下载

303
00:11:17,000 --> 00:11:21,000
这样的话就保证了一个非常一致的运行式环境

304
00:11:21,000 --> 00:11:22,000
就像呃

305
00:11:22,000 --> 00:11:23,000
就呃

306
00:11:23,000 --> 00:11:24,000
呃

307
00:11:24,000 --> 00:11:28,000
解决了一些像咱们几年前开发软件就是呃

308
00:11:28,000 --> 00:11:29,000
呃

309
00:11:29,000 --> 00:11:32,000
各种配置环境变量各种各种那个参数配置等等

310
00:11:32,000 --> 00:11:36,000
这这这些问题就迎人而解我直接下载一个镜像

311
00:11:36,000 --> 00:11:39,000
直接运行就可以跟呃呃

312
00:11:39,000 --> 00:11:40,000
呃

313
00:11:40,000 --> 00:11:43,000
就比如我是一个测试人员就可以跟开发人员的运行式环

314
00:11:43,000 --> 00:11:46,000
呃那个开发开发环境保持一致

315
00:11:46,000 --> 00:11:49,000
就解决了很多就环境相关的问题吧

316
00:11:49,000 --> 00:11:50,000
嗯

317
00:11:50,000 --> 00:11:51,000
嗯

318
00:11:51,000 --> 00:11:54,000
呃然后说到了容器容器它是呃

319
00:11:54,000 --> 00:11:55,000
呃

320
00:11:55,000 --> 00:11:57,000
刀客用用到个容器作为运行式环境

321
00:11:57,000 --> 00:12:01,000
然后容器的这个概念呢就是相当于呃

322
00:12:01,000 --> 00:12:06,000
将一个 house 的主机分成多个子的容器来呃

323
00:12:06,000 --> 00:12:07,000
呃

324
00:12:07,000 --> 00:12:09,000
来来来去运行 APP

325
00:12:09,000 --> 00:12:10,000
呃

326
00:12:10,000 --> 00:12:13,000
它这属于轻量级轻量级的另外一个一个好

327
00:12:13,000 --> 00:12:15,000
一个好数呢就是速度速度快

328
00:12:15,000 --> 00:12:19,000
然后但是它一个弊端的就是它因为它是 share 的客户

329
00:12:19,000 --> 00:12:21,000
在一个内核上面去运行

330
00:12:21,000 --> 00:12:25,000
所以它也造成了一个安全性的隐患吧

331
00:12:25,000 --> 00:12:29,000
所以所以所以所以这这就提到了我们存在的意义

332
00:12:29,000 --> 00:12:32,000
就是呃解决这个安全性的问题

333
00:12:32,000 --> 00:12:35,000
就是因为呃这个容器它是 share 的客户

334
00:12:35,000 --> 00:12:37,000
ok 我们不用 share 的客户

335
00:12:37,000 --> 00:12:40,000
而是用 hypriser 就是用 VM 来呃

336
00:12:40,000 --> 00:12:41,000
嗯

337
00:12:41,000 --> 00:12:45,000
代替容器来去运行呃呃呃呃

338
00:12:45,000 --> 00:12:46,000
呃呃呃呃呃的 image

339
00:12:46,000 --> 00:12:50,000
然后这样的话呢就是解决了呃呃呃呃呃呃

340
00:12:50,000 --> 00:12:51,000
呃呃的一个安全性问题

341
00:12:51,000 --> 00:12:55,000
但是因为呃呃众所说是大家用过 VMware

342
00:12:55,000 --> 00:12:59,000
用过 Watchbox 都知道它的起动速度可能呃就是可能会比较慢

343
00:12:59,000 --> 00:13:02,000
即使在你的非常好的高端的服务器上面

344
00:13:02,000 --> 00:13:07,000
大概也要在一两分钟或者是两三分钟吧

345
00:13:07,000 --> 00:13:08,000
没错

346
00:13:08,000 --> 00:13:12,000
对所以我们也是极致的优化

347
00:13:12,000 --> 00:13:16,000
让它的启动速度大概在毫秒级别

348
00:13:16,000 --> 00:13:17,000
毫秒级别

349
00:13:17,000 --> 00:13:18,000
对对对

350
00:13:18,000 --> 00:13:21,000
所以刚才是从这个一两分钟

351
00:13:21,000 --> 00:13:22,000
至少就是 100 秒一级别

352
00:13:22,000 --> 00:13:24,000
我们现在已经到毫秒级别

353
00:13:24,000 --> 00:13:24,000
对对对

354
00:13:24,000 --> 00:13:26,000
有四个数量级的提升

355
00:13:26,000 --> 00:13:27,000
对对对

356
00:13:27,000 --> 00:13:31,000
所以大概我们的测试的比较好的机器上

357
00:13:31,000 --> 00:13:32,000
大概在 300 毫秒

358
00:13:32,000 --> 00:13:33,000
OK

359
00:13:33,000 --> 00:13:35,000
0.3 秒左右

360
00:13:35,000 --> 00:13:36,000
对对对

361
00:13:36,000 --> 00:13:40,000
所以这个相对于容器的运行的启动速度来说

362
00:13:40,000 --> 00:13:43,000
已经算是差距不大了

363
00:13:43,000 --> 00:13:47,000
而且它的安全性有很大的提升

364
00:13:47,000 --> 00:13:51,000
这样的话也就是成为我们一个核心的竞争力

365
00:13:51,000 --> 00:13:52,000
或者说一个存在的

366
00:13:52,000 --> 00:13:57,000
基于这个目的来去做的这个东西

367
00:13:57,000 --> 00:14:04,000
所以就是说这个 Hyper 是一个可以快速启动的这个虚拟机可以这么理解吗

368
00:14:04,000 --> 00:14:05,000
对

369
00:14:05,000 --> 00:14:12,000
然后它在虚拟机的基础上可以很快的将 Docker 的 image 运行起来

370
00:14:12,000 --> 00:14:13,000
OK

371
00:14:13,000 --> 00:14:14,000
对

372
00:14:14,000 --> 00:14:20,000
然后这个 Hyper 起的虚拟机里面是就只跑一个 Docker 的镜像呢

373
00:14:20,000 --> 00:14:22,000
还是说它里面可以跑多个 Docker 的镜像

374
00:14:22,000 --> 00:14:25,000
可以跑多个 Docker 的镜像

375
00:14:25,000 --> 00:14:30,000
而我们这个一个虚拟机其实相当于是一个工作的单元

376
00:14:30,000 --> 00:14:32,000
这个工作单元呢

377
00:14:32,000 --> 00:14:37,000
其实这个 idea 是来自于 Cubernetes 里边的一个 POD 的概念

378
00:14:37,000 --> 00:14:41,000
就是一组 contender 的一个集合

379
00:14:41,000 --> 00:14:43,000
而这一组 contender 呢是有关系的

380
00:14:43,000 --> 00:14:45,000
它是为了运行一个

381
00:14:45,000 --> 00:14:48,000
比如我运行一个网站

382
00:14:48,000 --> 00:14:50,000
肯定要一个 Nidix

383
00:14:50,000 --> 00:14:51,000
我买 Secure

384
00:14:51,000 --> 00:14:53,000
然后等等这类似的东西

385
00:14:53,000 --> 00:14:53,000
所以

386
00:14:53,000 --> 00:14:54,000
对

387
00:14:54,000 --> 00:14:56,000
所以我买 Secure 一个 contender

388
00:14:56,000 --> 00:14:58,000
我 Nidix 一个 contender

389
00:14:58,000 --> 00:15:03,000
然后这样的话就组成一个 POD

390
00:15:03,000 --> 00:15:06,000
这个 POD 概念就包含了两个 contender

391
00:15:06,000 --> 00:15:07,000
OK

392
00:15:07,000 --> 00:15:09,000
所以可以这么理解吗

393
00:15:09,000 --> 00:15:13,000
就是说一个 Hyper 的虚拟就是对应一个就是这个 POD

394
00:15:13,000 --> 00:15:13,000
对

395
00:15:13,000 --> 00:15:14,000
这个盒子

396
00:15:14,000 --> 00:15:20,000
然后这个 POD 里面是包含了多个 Docker 的 contender

397
00:15:20,000 --> 00:15:20,000
contender

398
00:15:20,000 --> 00:15:21,000
对

399
00:15:21,000 --> 00:15:23,000
然后每个 contender 里面只运行单一的一个应用

400
00:15:23,000 --> 00:15:25,000
它可能是一个数据库

401
00:15:25,000 --> 00:15:25,000
像 MySQL

402
00:15:25,000 --> 00:15:27,000
可能是一个这个 web 服务器

403
00:15:27,000 --> 00:15:28,000
像 Nidix

404
00:15:28,000 --> 00:15:28,000
对对

405
00:15:28,000 --> 00:15:31,000
还有一个就是像这个一个应用服务器

406
00:15:31,000 --> 00:15:32,000
比如说一个 Tomcat

407
00:15:32,000 --> 00:15:34,000
或者其他一些什么像 Python

408
00:15:34,000 --> 00:15:36,000
或者 Ruby 写的一个应用进程

409
00:15:36,000 --> 00:15:36,000
对对对对

410
00:15:36,000 --> 00:15:40,000
所以它用这种 POD 的概念来管理一组 service

411
00:15:40,000 --> 00:15:43,000
所以这个相比

412
00:15:43,000 --> 00:15:44,000
这里听起来

413
00:15:44,000 --> 00:15:46,000
就是做这件事情的时候

414
00:15:46,000 --> 00:15:49,000
Hyper 相对一些已有的工具

415
00:15:49,000 --> 00:15:52,000
它们的主要的区别在哪里呢

416
00:15:52,000 --> 00:15:55,000
比如说可能像过去也有像基于这个 KVM

417
00:15:55,000 --> 00:15:56,000
Limax 上面的 KVM

418
00:15:56,000 --> 00:16:00,000
也可以运行一些轻量级快速启动的这个

419
00:16:00,000 --> 00:16:03,000
当然这个肯定需要定制那个你跑的那个叫做 Guest

420
00:16:03,000 --> 00:16:05,000
就是 Guest OS

421
00:16:05,000 --> 00:16:06,000
对对对

422
00:16:06,000 --> 00:16:06,000
就宾客系统

423
00:16:06,000 --> 00:16:11,000
还有一些像过去基于这种传统的这个 Hypervisor 的一些工具

424
00:16:11,000 --> 00:16:12,000
像 Zen

425
00:16:12,000 --> 00:16:14,000
海面也可以做一些事情

426
00:16:14,000 --> 00:16:15,000
那么从这个角度出发的话

427
00:16:15,000 --> 00:16:17,000
Hyper 和它们的区别

428
00:16:17,000 --> 00:16:18,000
刚才提到这个 KVM 和 Zen

429
00:16:18,000 --> 00:16:20,000
它们的区别主要在哪里

430
00:16:20,000 --> 00:16:23,000
其实我们底层也是用了 KVM

431
00:16:23,000 --> 00:16:26,000
Zen 以及 Wordbox 这些 Hypervisor

432
00:16:26,000 --> 00:16:29,000
但是呢我们跟他们的一个优势

433
00:16:29,000 --> 00:16:31,000
或者说我们做什么东西

434
00:16:31,000 --> 00:16:34,000
就是我们将 Guest OS

435
00:16:34,000 --> 00:16:38,000
我们实现一个经济最最简单的一个 Guest OS

436
00:16:38,000 --> 00:16:43,000
主要是用于跑 Docker 的里面之

437
00:16:43,000 --> 00:16:46,000
然后形成 container 这一系列工作

438
00:16:46,000 --> 00:16:46,000
另外呢

439
00:16:46,000 --> 00:16:49,000
我们外边提供了一整套管理工具

440
00:16:49,000 --> 00:16:51,000
然后可以管理这些 Hypervisor

441
00:16:51,000 --> 00:16:57,000
然后让它能够以炮的为单位去运行 Docker 的里面之

442
00:16:57,000 --> 00:17:01,000
然后并且提供了很多监控的工具

443
00:17:01,000 --> 00:17:04,000
这样的话方面用户运行 Docker image

444
00:17:04,000 --> 00:17:07,000
并有更好的安全性

445
00:17:07,000 --> 00:17:08,000
OK

446
00:17:08,000 --> 00:17:12,000
所以实际上 Hyper 是分两部分

447
00:17:12,000 --> 00:17:14,000
一个是说管理像传统的像 KVM

448
00:17:14,000 --> 00:17:16,000
Zen 这些 Hypervisor 的工具

449
00:17:16,000 --> 00:17:16,000
对

450
00:17:16,000 --> 00:17:18,000
然后另一方面它是说是包含一个

451
00:17:18,000 --> 00:17:23,000
你们定制过的极度精简的一个 Guest OS 的一个内核

452
00:17:23,000 --> 00:17:23,000
对

453
00:17:23,000 --> 00:17:24,000
是的

454
00:17:24,000 --> 00:17:24,000
可以这么理解吗

455
00:17:24,000 --> 00:17:24,000
对

456
00:17:24,000 --> 00:17:26,000
OK

457
00:17:26,000 --> 00:17:29,000
那这里就牵涉到两方面的问题了

458
00:17:29,000 --> 00:17:31,000
就是说在这个管理工具这一块

459
00:17:31,000 --> 00:17:32,000
Hypervisor

460
00:17:32,000 --> 00:17:36,000
Hyper 和 Docker 他们之间的界限是什么

461
00:17:36,000 --> 00:17:40,000
你指哪方面的界限

462
00:17:40,000 --> 00:17:43,000
就比如说你刚才提到 Hyper 里面

463
00:17:43,000 --> 00:17:45,000
它 Guest OS 里面包含哪些的东西

464
00:17:45,000 --> 00:17:47,000
就只有一个基础的内核吗

465
00:17:47,000 --> 00:17:47,000
对

466
00:17:47,000 --> 00:17:51,000
这个 Guest OS 里面除了内核之外还有什么东西

467
00:17:51,000 --> 00:17:52,000
没有别的了

468
00:17:52,000 --> 00:17:56,000
它只是跟外边的 Hyperdemon 去一个交互

469
00:17:56,000 --> 00:17:56,000
的作用

470
00:17:56,000 --> 00:17:58,000
然后我们会把

471
00:17:58,000 --> 00:18:01,000
因为 Hyperdemon 会把 Docker 的 Image

472
00:18:01,000 --> 00:18:03,000
从 Docker Hub 上面下载下载下来

473
00:18:03,000 --> 00:18:07,000
然后作为一个博好 device 或者是一个

474
00:18:07,000 --> 00:18:11,000
Wattio 9 P 的一个文件

475
00:18:11,000 --> 00:18:14,000
它也是给这个 Hypervisor

476
00:18:14,000 --> 00:18:18,000
然后 Guest OS 拿到这些信息之后

477
00:18:18,000 --> 00:18:22,000
就会做给用户生成一些运行式环境

478
00:18:22,000 --> 00:18:26,000
是整个这样的一个大概的一丝目

479
00:18:26,000 --> 00:18:26,000
OK

480
00:18:26,000 --> 00:18:30,000
然后你刚才提到那个 Hyper 还有一部分是管理像传统的

481
00:18:30,000 --> 00:18:31,000
像 KVM 啊

482
00:18:31,000 --> 00:18:32,000
Zene 这种 Hypervisor 的工具

483
00:18:32,000 --> 00:18:33,000
这一部分的话

484
00:18:33,000 --> 00:18:37,000
它又主要包含哪些组件或者是一些功能模块呢

485
00:18:37,000 --> 00:18:39,000
它主要是

486
00:18:39,000 --> 00:18:43,000
我想用过 Docker 的人都会有一些印象

487
00:18:43,000 --> 00:18:47,000
比如它可以直接用 Docker 的 Docker Logs

488
00:18:47,000 --> 00:18:50,000
然后或者说 Docker 那个 ESEC

489
00:18:50,000 --> 00:18:54,000
或者是 Docker 类似于 TTY 的这种环境

490
00:18:54,000 --> 00:18:56,000
其实我们也提供了这种工具

491
00:18:56,000 --> 00:18:57,000
就是可以

492
00:18:57,000 --> 00:19:05,000
因为如果要一个用户要想看 Hypervisor 里边的信息的话

493
00:19:05,000 --> 00:19:08,000
那么或者说它的 Log 的话

494
00:19:08,000 --> 00:19:12,000
就必须要登录或者 SSH 进去

495
00:19:12,000 --> 00:19:15,000
所以呢我们其实是将这些

496
00:19:15,000 --> 00:19:17,000
这些操作全都简化

497
00:19:17,000 --> 00:19:20,000
然后直接通过客户端

498
00:19:20,000 --> 00:19:22,000
或者说通过 API

499
00:19:22,000 --> 00:19:26,000
就可以让用户能够简单的访问

500
00:19:26,000 --> 00:19:30,000
到底 Hypervisor 里面运行的 contentor 到底

501
00:19:30,000 --> 00:19:31,000
运行的到底怎么样啊

502
00:19:31,000 --> 00:19:35,000
然后以及它的是否发生错误等等等等

503
00:19:35,000 --> 00:19:38,000
就这些全部达到一个监控的效果

504
00:19:38,000 --> 00:19:41,000
当然你也可以完全

505
00:19:41,000 --> 00:19:44,000
当这个 contentor 一运行的时候

506
00:19:44,000 --> 00:19:46,000
你就可以监控这个 contentor 所有状态

507
00:19:46,000 --> 00:19:48,000
将告个全部收集起来

508
00:19:48,000 --> 00:19:49,000
然后再去分析

509
00:19:49,000 --> 00:19:51,000
这个其实一个很方便的

510
00:19:51,000 --> 00:19:54,000
有很方便的 API 方便用户再次开发

511
00:19:54,000 --> 00:19:56,000
OK

512
00:19:56,000 --> 00:20:00,000
所以如果我们画一个层次结构图的话

513
00:20:00,000 --> 00:20:03,000
最底层可能是 host 的操作系统

514
00:20:03,000 --> 00:20:07,000
然后它上面会跑着像诸如 KVM

515
00:20:07,000 --> 00:20:09,000
Zen 这样的一些 hypervisor 工具

516
00:20:09,000 --> 00:20:11,000
然后再次上就是 hyper 这一层

517
00:20:11,000 --> 00:20:14,000
去管理 KVM 和 Zen 这样一个工具

518
00:20:14,000 --> 00:20:18,000
然后再在 hyper 管理的这些 guest VM 里面

519
00:20:18,000 --> 00:20:20,000
会跑一个 docker 的一个镜像

520
00:20:20,000 --> 00:20:23,000
然后再在镜像里面去运行

521
00:20:23,000 --> 00:20:25,000
我们最终的应用程序

522
00:20:25,000 --> 00:20:25,000
没错吧

523
00:20:25,000 --> 00:20:28,000
那个概念上有点不太一样

524
00:20:28,000 --> 00:20:34,000
因为刚才你说的可能就是更多的人去想到的这种方式

525
00:20:34,000 --> 00:20:38,000
其实这种方式就是目前的 boot to docker

526
00:20:38,000 --> 00:20:43,000
它就是将 docker 的 demon 放在一个 VM 里面去运行

527
00:20:43,000 --> 00:20:47,000
而我们其实是将 hyperdemon

528
00:20:47,000 --> 00:20:49,000
其实我们这里就没有 docker 的 demon

529
00:20:49,000 --> 00:20:51,000
因为我最开始其实是依赖于 dockerdemon

530
00:20:51,000 --> 00:20:52,000
但现在没有了

531
00:20:52,000 --> 00:20:53,000
就是对

532
00:20:53,000 --> 00:20:55,000
所以我们取消了 docker 的依赖

533
00:20:55,000 --> 00:20:59,000
然后将 hyperdemon 放在 houseOS 里面去运行

534
00:20:59,000 --> 00:21:04,000
然而 docker 的 image 下载下来

535
00:21:04,000 --> 00:21:08,000
是直接把这些文件全部传进 VM

536
00:21:08,000 --> 00:21:14,000
然后 guestOS 再去用这些文件来去起 container

537
00:21:14,000 --> 00:21:17,000
然后去运行这些文件

538
00:21:17,000 --> 00:21:20,000
所以其实你们是这个

539
00:21:20,000 --> 00:21:23,000
就 hyper 是完全替代掉了 docker 的管理的功能

540
00:21:23,000 --> 00:21:23,000
对

541
00:21:23,000 --> 00:21:27,000
你们只是附用了 docker 的已经制作好的

542
00:21:27,000 --> 00:21:31,000
它本来是为 docker 管理工具制作好的 container image

543
00:21:31,000 --> 00:21:31,000
对

544
00:21:31,000 --> 00:21:35,000
这个还和我之前解的有一点点出入

545
00:21:35,000 --> 00:21:37,000
这个话其实就还蛮酷的

546
00:21:37,000 --> 00:21:40,000
就是说如果理论上来讲

547
00:21:40,000 --> 00:21:44,000
如果你们因为 hyper 管理的 VM 的虚拟机

548
00:21:44,000 --> 00:21:45,000
也非常轻量

549
00:21:45,000 --> 00:21:45,000
其实也很快

550
00:21:45,000 --> 00:21:48,000
同时它又具备传统的

551
00:21:48,000 --> 00:21:52,000
像 docker 无法提供的内核级别的隔离的安全性

552
00:21:52,000 --> 00:21:52,000
对

553
00:21:52,000 --> 00:21:55,000
所以其实是在安全性和性能上

554
00:21:55,000 --> 00:22:01,000
是完全可以替代甚至超越 docker 的 demon 本身的

555
00:22:01,000 --> 00:22:01,000
对

556
00:22:01,000 --> 00:22:03,000
OK 明白明白

557
00:22:03,000 --> 00:22:04,000
非常好的解释

558
00:22:04,000 --> 00:22:11,000
所以现在刚才提到一个最主要的核心要点就是说安全性

559
00:22:11,000 --> 00:22:15,000
可能很多不是做内核相关的朋友

560
00:22:15,000 --> 00:22:17,000
可能也其实也是现在很多使用 docker container 的一个新手

561
00:22:17,000 --> 00:22:19,000
可能一个困惑

562
00:22:19,000 --> 00:22:25,000
就是说因为确实你想一个 docker image 给人感觉用起来很像一个虚拟机

563
00:22:25,000 --> 00:22:27,000
但它其实并不是一个虚拟机

564
00:22:27,000 --> 00:22:28,000
对

565
00:22:28,000 --> 00:22:29,000
对

566
00:22:29,000 --> 00:22:32,000
就是一个一个叫做我们叫做集装箱或者叫一个容器这么一个概念

567
00:22:32,000 --> 00:22:32,000
对

568
00:22:32,000 --> 00:22:36,000
所以 Simon 肯定这里要给这些我们这些新手啊

569
00:22:36,000 --> 00:22:38,000
还有也不太熟悉这个使用 docker 的要普及一下

570
00:22:38,000 --> 00:22:40,000
为什么说 docker 呢

571
00:22:40,000 --> 00:22:44,000
不能提供像传统的这个虚拟机那样的这么一个安全性呢

572
00:22:44,000 --> 00:22:49,000
其实这个的话就是从 docker 本身用的技术上面就要来讨问

573
00:22:49,000 --> 00:22:56,000
因为 docker 其实它并没就是可能说说的有点有点太直白了

574
00:22:56,000 --> 00:23:00,000
就是 docker 其实并没有发明任何新的技术

575
00:23:00,000 --> 00:23:01,000
OK

576
00:23:01,000 --> 00:23:02,000
对

577
00:23:02,000 --> 00:23:04,000
这个其实很多人对 docker 的一个指责

578
00:23:04,000 --> 00:23:08,000
就是说因为这个所有的像 container 这些概念可能是十年前就已经有了

579
00:23:08,000 --> 00:23:08,000
对

580
00:23:08,000 --> 00:23:13,000
然后很多人都说这个 docker 其实只是把一些叫什么新品装旧旧嘛

581
00:23:13,000 --> 00:23:13,000
对

582
00:23:13,000 --> 00:23:14,000
对

583
00:23:14,000 --> 00:23:18,000
这个这样也没什么就是这个从技术角度上确实是这样子的

584
00:23:18,000 --> 00:23:22,000
就我的理解可能 docker 的主要的价值还是说它提出了这么一套这个理念

585
00:23:22,000 --> 00:23:29,000
让大家可以说就更好的去从这个开发到测试到实际部署这么一套流程工具流程吧

586
00:23:29,000 --> 00:23:29,000
对

587
00:23:29,000 --> 00:23:30,000
对

588
00:23:30,000 --> 00:23:33,000
那么刚才那个安全性的问题呢

589
00:23:33,000 --> 00:23:38,000
就是说为什么说这个 docker 就我们这些小白们会觉得这个 container 之间是有隔离的

590
00:23:38,000 --> 00:23:40,000
但其实并没有想象的那么好

591
00:23:40,000 --> 00:23:41,000
对

592
00:23:41,000 --> 00:23:46,000
就是因为因为这些 container 之间的它的一个同样的实验方式它是基于内部 space

593
00:23:46,000 --> 00:23:50,000
或者说更底层的一点它是通过 siggroups

594
00:23:50,000 --> 00:23:52,000
siggroups 就是一个内核的一个 module

595
00:23:52,000 --> 00:23:58,000
然后它所做一个隔离性呢就是相当于用户可以配置

596
00:23:58,000 --> 00:24:03,000
然后 siggroups 在内核里面去限制某一个模块

597
00:24:03,000 --> 00:24:04,000
比如内存

598
00:24:04,000 --> 00:24:05,000
比如 cpu

599
00:24:05,000 --> 00:24:08,000
每个线程可以用多少

600
00:24:08,000 --> 00:24:14,000
但是这样的话它所有的全都是基于一个 houseOS 的 kernel 去做的

601
00:24:14,000 --> 00:24:22,000
然后如果一个 container 里面的一个 process 获取了一些更高级的权限

602
00:24:22,000 --> 00:24:24,000
它就可以控制这个内核

603
00:24:24,000 --> 00:24:29,000
而可能这个就是特别细特别细怎么 hack 去这个事情

604
00:24:29,000 --> 00:24:35,000
但是本身你 share 的 kernel 它其实就是有这种问题的

605
00:24:35,000 --> 00:24:44,000
因为你如果一个 container 出个问题导致 cernel panic 的话就会导致整个所有的 container 不可用

606
00:24:44,000 --> 00:24:48,000
看来 B 节目的名字还是很有示范意义的

607
00:24:48,000 --> 00:24:48,000
对

608
00:24:48,000 --> 00:24:49,000
对

609
00:24:49,000 --> 00:24:52,000
所以刚才你提到一个很重要的概念

610
00:24:52,000 --> 00:24:55,000
就是如果在传统的一个 docker 的部署里面

611
00:24:55,000 --> 00:25:03,000
如果你在一个虚拟机或者同一个内核里面部署了多个来历不明的这么一个 image 在跑

612
00:25:03,000 --> 00:25:09,000
然后假设某一个因为这个内核它不可能是完美的一个程序

613
00:25:09,000 --> 00:25:09,000
对吧

614
00:25:09,000 --> 00:25:12,000
所以假设一个内核的一个漏洞

615
00:25:12,000 --> 00:25:14,000
或者说你没有及时打上一些补丁

616
00:25:14,000 --> 00:25:15,000
使得一个恶意的程序

617
00:25:15,000 --> 00:25:16,000
抓住这个漏洞

618
00:25:16,000 --> 00:25:20,000
它其实是可以越全拿到这个最高级的权限

619
00:25:20,000 --> 00:25:25,000
从而影响或者控制其他在就其他的 container 里面的东西

620
00:25:25,000 --> 00:25:25,000
对

621
00:25:25,000 --> 00:25:26,000
OK

622
00:25:26,000 --> 00:25:28,000
所以从这个方面来讲

623
00:25:28,000 --> 00:25:31,000
我们必须采用像传统的这个虚拟机

624
00:25:31,000 --> 00:25:33,000
就是独立 kernel 的这种虚拟机

625
00:25:33,000 --> 00:25:34,000
对

626
00:25:34,000 --> 00:25:35,000
对

627
00:25:35,000 --> 00:25:36,000
对

628
00:25:36,000 --> 00:25:37,000
对

629
00:25:37,000 --> 00:25:38,000
OK

630
00:25:38,000 --> 00:25:40,000
那么这里就会有一个自然而然的问题了

631
00:25:40,000 --> 00:25:41,000
就说这样的话

632
00:25:41,000 --> 00:25:44,000
毕竟还是多了一个虚拟机多了一个内核层面的在跑

633
00:25:44,000 --> 00:25:48,000
那么它的这个相对于这种 docker 本身没有一个

634
00:25:48,000 --> 00:25:50,000
它是一个共享内核的情况

635
00:25:50,000 --> 00:25:53,000
它的这个额外的开销会是怎么样的一个情况

636
00:25:53,000 --> 00:25:54,000
对

637
00:25:54,000 --> 00:25:57,000
所以这个也就是我们之前一直在关注的一个点

638
00:25:57,000 --> 00:25:58,000
就是它的性能问题

639
00:25:58,000 --> 00:25:59,000
性能问题

640
00:25:59,000 --> 00:26:01,000
性能问题的话就是我们做了很多的测试

641
00:26:01,000 --> 00:26:04,000
其实我们并没有说更改或者说修改那个 hypervisor 的代码

642
00:26:04,000 --> 00:26:05,000
然后让它达到一个非常非常优化的一个

643
00:26:05,000 --> 00:26:23,000
但是我们目前还是希望能够用更加通用的手段来解决用户的问题

644
00:26:23,000 --> 00:26:32,000
然后就刚才说的一个启动一个 container 的所给动时间大概在 300 毫秒

645
00:26:32,000 --> 00:26:35,000
这个跟 docker 相比呢

646
00:26:35,000 --> 00:26:38,000
基本上没差太多

647
00:26:38,000 --> 00:26:41,000
然后性能上面这是这点

648
00:26:41,000 --> 00:26:45,000
然后另外就是 CPU 用域上面基本相似

649
00:26:45,000 --> 00:26:54,000
可能很大的一个问题就是在网络 IO 以及 Storage 的 IO 上面可能会有

650
00:26:54,000 --> 00:26:57,000
会受限于 hypervisor 它的性能

651
00:26:57,000 --> 00:27:01,000
因为你像 9 P 或者是像直接的 Blog device

652
00:27:01,000 --> 00:27:04,000
它都毕竟要经过多层的传递

653
00:27:04,000 --> 00:27:05,000
对

654
00:27:05,000 --> 00:27:07,000
然后可能会达不到很好的效果

655
00:27:07,000 --> 00:27:11,000
但是我们其实也在目前也在解决这个问题

656
00:27:11,000 --> 00:27:18,000
就是用因为 Blog device 它其实还是传的那个 Storage 的协议

657
00:27:18,000 --> 00:27:22,000
比如 Skart 协议直接 Skart 协议怎么能够传递

658
00:27:22,000 --> 00:27:26,000
或者怎么能够更减少它的矿跃的层次

659
00:27:26,000 --> 00:27:29,000
就是一些客装 bypass 的技术吧

660
00:27:29,000 --> 00:27:30,000
OK

661
00:27:30,000 --> 00:27:31,000
所以总结一下

662
00:27:31,000 --> 00:27:34,000
就是说因为 hyper 还是一个基于虚拟机的一个技术

663
00:27:34,000 --> 00:27:35,000
对

664
00:27:35,000 --> 00:27:37,000
所以传统的虚拟机的一些缺陷

665
00:27:37,000 --> 00:27:40,000
那可能还是就是起码在现阶段还是免不了的

666
00:27:40,000 --> 00:27:43,000
刚才提到了几个问题就是说它可能

667
00:27:43,000 --> 00:27:46,000
但就是我们现在在现代 CPU

668
00:27:46,000 --> 00:27:48,000
特别是像英特尔的一些服务器的 CPU

669
00:27:48,000 --> 00:27:51,000
它对这个硬件虚拟化的一些支持是非常好的

670
00:27:51,000 --> 00:27:54,000
所以在运算这一块的这个损耗

671
00:27:54,000 --> 00:27:56,000
其实可以几乎可以忽略不计吧我觉得

672
00:27:56,000 --> 00:27:57,000
对

673
00:27:57,000 --> 00:27:58,000
对

674
00:27:58,000 --> 00:27:59,000
然后但是像这个 IO 层面

675
00:27:59,000 --> 00:28:02,000
因为它还是就需要依赖于这个硬件的支持

676
00:28:02,000 --> 00:28:04,000
和那个内核的支持

677
00:28:04,000 --> 00:28:07,000
可能还做不到说一个比较好的一个状态

678
00:28:07,000 --> 00:28:10,000
那么我可以大概问一下就直观来讲

679
00:28:10,000 --> 00:28:13,000
比如说我网络吧

680
00:28:13,000 --> 00:28:17,000
我 1 GB 的这个物理网卡的这么一个吞吐量

681
00:28:17,000 --> 00:28:20,000
传到这个 hyper 虚拟机里面之后

682
00:28:20,000 --> 00:28:22,000
大概会损耗到多少

683
00:28:22,000 --> 00:28:26,000
这个我们之前确实是做过调查

684
00:28:26,000 --> 00:28:30,000
但是我现在没有没有手头没有没有这种资料

685
00:28:30,000 --> 00:28:31,000
OK

686
00:28:31,000 --> 00:28:35,000
那这个是就是说你刚才提到最主要问题就是 IO 的损耗是最快的

687
00:28:35,000 --> 00:28:36,000
对对对

688
00:28:36,000 --> 00:28:39,000
但如果说如果你有资料的话我们可以补到这个 show notes 里面

689
00:28:39,000 --> 00:28:40,000
对

690
00:28:40,000 --> 00:28:44,000
然后就是这个在我们的官网上其实是有更详细的资料

691
00:28:44,000 --> 00:28:45,000
然后 OK

692
00:28:45,000 --> 00:28:47,000
对因为这个这部分我没有参与测试

693
00:28:47,000 --> 00:28:50,000
所以具体细节不是特别清楚

694
00:28:50,000 --> 00:28:52,000
OK 没问题没问题

695
00:28:52,000 --> 00:28:56,000
所以这个也说到这个 IO 这一块所以我顺便插划问一句

696
00:28:56,000 --> 00:28:59,000
刚才你也提到有些叫做就是能够绕过

697
00:28:59,000 --> 00:29:02,000
因为 IO 最麻烦的问题是因为是虚拟就是这样

698
00:29:02,000 --> 00:29:07,000
guestOS 和 hostOS 它是要互相复制数据对吧

699
00:29:07,000 --> 00:29:10,000
这个是导致性能损耗最主要的一个原因

700
00:29:10,000 --> 00:29:13,000
那么你刚才也提到一些一些就是 bypass

701
00:29:13,000 --> 00:29:16,000
就是能够绕过这个复制的一些机制

702
00:29:16,000 --> 00:29:19,000
可以大概介绍一下你们目前在考虑的

703
00:29:19,000 --> 00:29:23,000
或者说以后可能会采用的一些方法是什么呢

704
00:29:23,000 --> 00:29:29,000
其实我们目前已经采用了 WaterIO Nite 的一个模块

705
00:29:29,000 --> 00:29:34,000
然后它其实就是将网络的 IO bypass

706
00:29:34,000 --> 00:29:41,000
相当于跨过 hypervisor 底层的一个数据传输

707
00:29:41,000 --> 00:29:46,000
但是 houseOS 它的一个 TCIP 协议站是没办法跨越的

708
00:29:46,000 --> 00:29:49,000
所以这个技术应该是跨越

709
00:29:49,000 --> 00:29:51,000
hypervisor 的一个 TCIP 协议站

710
00:29:51,000 --> 00:29:53,000
它就是减少了它的层数

711
00:29:53,000 --> 00:29:57,000
然后另外呢其实我们也在基于 block device

712
00:29:57,000 --> 00:29:59,000
去做一些操作

713
00:29:59,000 --> 00:30:01,000
因为 block device 的话

714
00:30:01,000 --> 00:30:09,000
它毕竟还是块设备的传输更偏向于它的 IO 协议本身

715
00:30:09,000 --> 00:30:13,000
所以这样的话能比网络层的优化

716
00:30:13,000 --> 00:30:18,000
能够比文件系统级的优化效果会更好

717
00:30:18,000 --> 00:30:20,000
我们也在关注这些点

718
00:30:20,000 --> 00:30:21,000
OK

719
00:30:21,000 --> 00:30:23,000
刚才你提到两个用力

720
00:30:23,000 --> 00:30:27,000
一个就是对一个经典的网络层的传输的优化

721
00:30:27,000 --> 00:30:31,000
还有一个是对文件系统传输层的优化

722
00:30:31,000 --> 00:30:36,000
我们提一个就是就着刚才那个网络层的这个情况来讲

723
00:30:36,000 --> 00:30:39,000
因为大家可能最常用的还是用来部署一个这个

724
00:30:39,000 --> 00:30:42,000
基于 web 的一个 server 或者有服务器之类的应用

725
00:30:42,000 --> 00:30:43,000
对对对

726
00:30:43,000 --> 00:30:44,000
所以举一个例子

727
00:30:44,000 --> 00:30:47,000
比如说在一个经典的这个 hyper 的部署情况下

728
00:30:47,000 --> 00:30:51,000
就是说底下有个 hostOS 上面跑一个假设 KVM

729
00:30:51,000 --> 00:30:56,000
然后在 hyper 在管理一个 VM 里面再跑一个 DockerImage 的这种情况下

730
00:30:56,000 --> 00:31:02,000
一个数据包从这个最里面的这个

731
00:31:02,000 --> 00:31:05,000
假设是一个 Nginx 的服务器里面传出来

732
00:31:05,000 --> 00:31:10,000
一直传到这个 hostOS 硬件的网卡之间

733
00:31:10,000 --> 00:31:12,000
大概需要经过哪些步骤可以给我们描述一下

734
00:31:12,000 --> 00:31:15,000
目前的话咱们先说正常的话

735
00:31:15,000 --> 00:31:20,000
它肯定是经过 Hypervisor 的 TTIP 协议站

736
00:31:20,000 --> 00:31:24,000
然后经过 Hypervisor 它的一个

737
00:31:24,000 --> 00:31:28,000
但是这个就要分它是硬件模拟还是

738
00:31:28,000 --> 00:31:32,000
就是全虚拟化还是半虚拟化

739
00:31:32,000 --> 00:31:36,000
这个的话就涉及到 Cumular 的一些知识

740
00:31:36,000 --> 00:31:37,000
就是因为 Cumular 的话

741
00:31:37,000 --> 00:31:41,000
如果是 Cumular 全虚拟化的话

742
00:31:41,000 --> 00:31:44,000
它就是相对于完全硬件虚拟化

743
00:31:44,000 --> 00:31:46,000
就是它就是

744
00:31:46,000 --> 00:31:48,000
网卡都是虚拟出来的

745
00:31:48,000 --> 00:31:51,000
所以它走的路是跟 Hypervisor

746
00:31:51,000 --> 00:31:53,000
是跟 hostOS 是完全一致的

747
00:31:53,000 --> 00:31:55,000
大家也可以查一下资料

748
00:31:55,000 --> 00:31:57,000
就可能走 TTIP 协议站

749
00:31:57,000 --> 00:31:59,000
然后再走那个 Driver

750
00:31:59,000 --> 00:32:01,000
再走 NIC 的 Driver

751
00:32:01,000 --> 00:32:03,000
然后再往下走 FORMWARE

752
00:32:03,000 --> 00:32:05,000
这些东西

753
00:32:05,000 --> 00:32:08,000
然后如果要是半虚拟化的话

754
00:32:08,000 --> 00:32:11,000
它就可以用

755
00:32:11,000 --> 00:32:13,000
WaterIO Net

756
00:32:13,000 --> 00:32:15,000
反正就是相对于 Network

757
00:32:15,000 --> 00:32:17,000
可能 Bypass 的一个技术

758
00:32:17,000 --> 00:32:19,000
就是将 Hypervisor 里面的

759
00:32:19,000 --> 00:32:21,000
那个网络包的数据

760
00:32:21,000 --> 00:32:23,000
直接给到 NIC 的 Driver

761
00:32:23,000 --> 00:32:25,000
然后用 NIC 的 Driver

762
00:32:25,000 --> 00:32:27,000
然后调一些 AutoGo 命令

763
00:32:27,000 --> 00:32:31,000
直接让 Auto 包直接发送出去

764
00:32:31,000 --> 00:32:33,000
然后交给 Hass 的 OS

765
00:32:33,000 --> 00:32:35,000
然后它其实在这个过程中

766
00:32:35,000 --> 00:32:37,000
我如果没记错的话

767
00:32:37,000 --> 00:32:41,000
应该是 Hypervisor 里面的

768
00:32:41,000 --> 00:32:43,000
这个 NIC 的一个虚拟地址

769
00:32:43,000 --> 00:32:47,000
其实是和 HassOS 里面的

770
00:32:47,000 --> 00:32:49,000
这个网卡的地址

771
00:32:49,000 --> 00:32:51,000
其实映射到一起

772
00:32:51,000 --> 00:32:53,000
然后这样的话能够缩减很多层

773
00:32:53,000 --> 00:32:55,000
就不用复制那么多次

774
00:32:55,000 --> 00:32:56,000
对对对对

775
00:32:56,000 --> 00:32:58,000
其实在网络传输过程中

776
00:32:58,000 --> 00:33:00,000
用户台和内核台之间的

777
00:33:00,000 --> 00:33:02,000
网络包的复制过程

778
00:33:02,000 --> 00:33:04,000
还是比较耗时的

779
00:33:04,000 --> 00:33:05,000
对对对对

780
00:33:05,000 --> 00:33:08,000
然后另外一个就是它的

781
00:33:08,000 --> 00:33:10,000
相对于用户台和内核台

782
00:33:10,000 --> 00:33:11,000
一个切换过程

783
00:33:11,000 --> 00:33:13,000
但是这个的话

784
00:33:13,000 --> 00:33:15,000
其实没有特别好的办法

785
00:33:15,000 --> 00:33:16,000
因为你要保证实时性

786
00:33:16,000 --> 00:33:18,000
要保证能够

787
00:33:18,000 --> 00:33:21,000
它的能把这些包全都传送出去

788
00:33:21,000 --> 00:33:24,000
所以必须用一些机制来触发

789
00:33:24,000 --> 00:33:25,000
所以可能

790
00:33:25,000 --> 00:33:28,000
用 Altoco 或者是用其他方式去触发吧

791
00:33:28,000 --> 00:33:29,000
但是这个东西

792
00:33:29,000 --> 00:33:32,000
我们目前也是用过现有的机制

793
00:33:32,000 --> 00:33:34,000
没有特别

794
00:33:34,000 --> 00:33:37,000
目前还没有设立这方面的

795
00:33:37,000 --> 00:33:39,000
这方面的动作

796
00:33:39,000 --> 00:33:41,000
OK 明白

797
00:33:41,000 --> 00:33:44,000
就是 Hyper 那套工具讲

798
00:33:44,000 --> 00:33:45,000
你也提到了

799
00:33:45,000 --> 00:33:47,000
就是 Hyper 它会提供一个非常轻量级的

800
00:33:47,000 --> 00:33:49,000
GastOS 的 VM

801
00:33:49,000 --> 00:33:52,000
在那里去运行里面的 Docker image

802
00:33:52,000 --> 00:33:55,000
然后这点就可能要跟现有的一些其他的

803
00:33:55,000 --> 00:33:58,000
想做同类事情的工具相比了哈

804
00:33:58,000 --> 00:33:59,000
比如说比较著名的

805
00:33:59,000 --> 00:34:02,000
现在比较火的像那个 CoreOS

806
00:34:02,000 --> 00:34:04,000
还有像一个上次

807
00:34:04,000 --> 00:34:05,000
好像英特尔也出了一个吧

808
00:34:05,000 --> 00:34:07,000
是专门跑这个 Docker image 的

809
00:34:07,000 --> 00:34:09,000
这么一个极度精简的

810
00:34:09,000 --> 00:34:11,000
这个 Linux 的 OS

811
00:34:11,000 --> 00:34:13,000
就是相比起来就是你们

812
00:34:13,000 --> 00:34:15,000
比它们的区别在哪里

813
00:34:15,000 --> 00:34:17,000
就是经解了什么东西

814
00:34:17,000 --> 00:34:18,000
是这样

815
00:34:18,000 --> 00:34:21,000
就是英特尔出的那个叫 Coreal Ginegas

816
00:34:21,000 --> 00:34:24,000
它的出现对我们来说还是

817
00:34:24,000 --> 00:34:26,000
很震惊的

818
00:34:26,000 --> 00:34:30,000
但是其实也是验证了我们的方向是正确的

819
00:34:30,000 --> 00:34:33,000
因为大厂都跟进这些事情了

820
00:34:33,000 --> 00:34:36,000
对所以我们既兴奋又担心

821
00:34:36,000 --> 00:34:39,000
又担心还有点惊讶

822
00:34:39,000 --> 00:34:40,000
OK

823
00:34:40,000 --> 00:34:42,000
然后它和 CoreOS

824
00:34:42,000 --> 00:34:46,000
其实应该是属于类似的东西

825
00:34:46,000 --> 00:34:48,000
但是它们的目的可能不太严

826
00:34:48,000 --> 00:34:50,000
就是我们自己的分析

827
00:34:50,000 --> 00:34:52,000
因为 Coreal Ginegas

828
00:34:52,000 --> 00:34:54,000
它的一个

829
00:34:54,000 --> 00:34:58,000
它其实是为了验证英特尔的硬件

830
00:34:58,000 --> 00:34:59,000
因为英特尔嘛

831
00:34:59,000 --> 00:35:01,000
它虽然说是开源技术中心做出来的

832
00:35:01,000 --> 00:35:04,000
但也不能说一帮人

833
00:35:04,000 --> 00:35:06,000
没什么意义去做这个东西

834
00:35:06,000 --> 00:35:09,000
因为我们分析它应该是

835
00:35:09,000 --> 00:35:12,000
为了体现它们的硬件足够的快

836
00:35:12,000 --> 00:35:16,000
可以达到启动一个 Nginx 的 GasOS

837
00:35:16,000 --> 00:35:19,000
能够非常非常非常快

838
00:35:19,000 --> 00:35:20,000
其实好秒级的

839
00:35:20,000 --> 00:35:26,000
然后当然也有很多人基于这个东西去做了很多的

840
00:35:26,000 --> 00:35:29,000
因为 Docker 目前的形势非常火

841
00:35:29,000 --> 00:35:31,000
所以很多人基于 Coreal Ginegas

842
00:35:31,000 --> 00:35:34,000
去做了一些贡献吧

843
00:35:34,000 --> 00:35:36,000
然后就是把它改造了一下

844
00:35:36,000 --> 00:35:37,000
之前还有一个 PR

845
00:35:37,000 --> 00:35:39,000
专门给 Docker 的

846
00:35:39,000 --> 00:35:43,000
相当于 Docker 的那个 Upstream

847
00:35:43,000 --> 00:35:44,000
然后去提了一个 PR

848
00:35:44,000 --> 00:35:48,000
就是像希望能够用这个 Coreal Ginegas

849
00:35:48,000 --> 00:35:51,000
来运行 Docker 的 Image

850
00:35:51,000 --> 00:35:54,000
但是这个没有被接手

851
00:35:54,000 --> 00:35:57,000
因为可能觉得做的不太好吧

852
00:35:57,000 --> 00:36:03,000
或者说它的性能或者说整体的一个运动方式

853
00:36:03,000 --> 00:36:05,000
跟 Docker 的不太一样

854
00:36:05,000 --> 00:36:06,000
对

855
00:36:06,000 --> 00:36:11,000
所以我们也关注过它很长时间

856
00:36:11,000 --> 00:36:13,000
它目前也在不断的维护吧

857
00:36:13,000 --> 00:36:16,000
然后它跟 Coreal Ginegas

858
00:36:16,000 --> 00:36:18,000
就是就提到 Coreal Ginegas

859
00:36:18,000 --> 00:36:19,000
Coreal Ginegas

860
00:36:19,000 --> 00:36:21,000
其实它是在 Coreal Ginegas 里面

861
00:36:21,000 --> 00:36:24,000
它给你做了足够多的配置

862
00:36:24,000 --> 00:36:27,000
然后让你直接去运行一个 Docker 的 Demon

863
00:36:27,000 --> 00:36:29,000
或者说 Docker 的 Contender

864
00:36:29,000 --> 00:36:32,000
然后你直接 Coreal Ginegas

865
00:36:32,000 --> 00:36:37,000
是不可以装在一个 BireMental 的一个机器上面

866
00:36:37,000 --> 00:36:39,000
而 Coreal Ginegas 是可以的

867
00:36:39,000 --> 00:36:41,000
它可以装在那个 BireMental 的机器上

868
00:36:41,000 --> 00:36:43,000
然后这样的话配置到一个机房

869
00:36:43,000 --> 00:36:45,000
就可以运行

870
00:36:45,000 --> 00:36:47,000
就可以直接你装一个 OS

871
00:36:47,000 --> 00:36:49,000
你可以直接运行 Docker 的 Demon

872
00:36:49,000 --> 00:36:51,000
Docker 的任何命令你都可以去直接运行

873
00:36:51,000 --> 00:36:53,000
而且它可以优化了

874
00:36:53,000 --> 00:36:56,000
所以它可能的场景不太一样

875
00:36:56,000 --> 00:36:58,000
所以说我们的 Hyper

876
00:36:58,000 --> 00:37:02,000
其实跟他们其实不是特别一样

877
00:37:02,000 --> 00:37:05,000
因为我们其实虽然说也提供一个 GesOS

878
00:37:05,000 --> 00:37:07,000
但是我们这一个 GesOS

879
00:37:07,000 --> 00:37:10,000
它其实是为了在

880
00:37:10,000 --> 00:37:14,000
在 VM 里面跟外边的 Hyper Demon 去配合

881
00:37:14,000 --> 00:37:18,000
然后去运行 Docker 的 Image

882
00:37:18,000 --> 00:37:20,000
其实我们是一个整套的一个环境

883
00:37:20,000 --> 00:37:26,000
其实就是跟 Docker 平行的另外一套的环境

884
00:37:26,000 --> 00:37:28,000
所以如果我这样理解

885
00:37:28,000 --> 00:37:32,000
没错的话就是 CoreOS 和这个 Inter 出的这个 Clear Linux

886
00:37:32,000 --> 00:37:34,000
它们还是依赖于这个 Docker 的 Demon 本身

887
00:37:34,000 --> 00:37:36,000
对是的

888
00:37:36,000 --> 00:37:38,000
而这个 Hyper 是可以完全替代它

889
00:37:38,000 --> 00:37:39,000
对对是

890
00:37:39,000 --> 00:37:41,000
那所以其实从我个人角度来讲

891
00:37:41,000 --> 00:37:44,000
肯定是少一层比多一层简单

892
00:37:44,000 --> 00:37:45,000
简单

893
00:37:45,000 --> 00:37:46,000
对对对对

894
00:37:46,000 --> 00:37:48,000
这个也是看大家应用场景吧

895
00:37:48,000 --> 00:37:50,000
可能关注点不太一样

896
00:37:50,000 --> 00:37:54,000
也不能太推销我们的东西

897
00:37:54,000 --> 00:37:56,000
哎没错

898
00:37:56,000 --> 00:37:58,000
这里就提到这个应用场景这个 Clear

899
00:37:58,000 --> 00:37:59,000
非常非常重要好

900
00:37:59,000 --> 00:38:01,000
所以在你们的这个定位里面

901
00:38:01,000 --> 00:38:03,000
这个是在什么场景下

902
00:38:03,000 --> 00:38:04,000
适用于比较

903
00:38:04,000 --> 00:38:06,000
就是适用用这个 Hyper 会比较好

904
00:38:06,000 --> 00:38:09,000
其实我们是希望

905
00:38:09,000 --> 00:38:13,000
是我们的一个做这个 Hyper 这个目的呢

906
00:38:13,000 --> 00:38:18,000
是希望有想法用 Docker

907
00:38:18,000 --> 00:38:23,000
做构建一个公有云的一个厂商

908
00:38:23,000 --> 00:38:26,000
就当然可能目前已经有了

909
00:38:26,000 --> 00:38:29,000
就比如到什么 Docker Out

910
00:38:29,000 --> 00:38:30,000
Docker Out

911
00:38:30,000 --> 00:38:36,000
他们其实就是声称是用 Docker

912
00:38:36,000 --> 00:38:39,000
作为一个去构建的一个公有云

913
00:38:39,000 --> 00:38:43,000
但是我不确定他们内部是怎么搭建的

914
00:38:43,000 --> 00:38:45,000
来保证用户的安全性

915
00:38:45,000 --> 00:38:47,000
OK 这个就涉及到刚才我们讲的那个问题

916
00:38:47,000 --> 00:38:50,000
如果说因为你没有内核隔离的话

917
00:38:50,000 --> 00:38:53,000
其实是 Docker 本身的那个 container 隔离

918
00:38:53,000 --> 00:38:55,000
是无法保证安全性的

919
00:38:55,000 --> 00:38:57,000
然后如果你跑的是一个公有云

920
00:38:57,000 --> 00:38:58,000
就所谓公有云

921
00:38:58,000 --> 00:39:00,000
就是说你的这个两个客户之间是

922
00:39:00,000 --> 00:39:03,000
可能不是一家或者一个人

923
00:39:03,000 --> 00:39:06,000
然后你也没法保证你运行的应用的

924
00:39:06,000 --> 00:39:11,000
这个性质或者是它是不是一个恶意程序

925
00:39:11,000 --> 00:39:12,000
你是无法保证的

926
00:39:12,000 --> 00:39:15,000
就是可能是公有云和私有云最大的区别

927
00:39:15,000 --> 00:39:18,000
所以这种情况下是必须采用 VM 隔离

928
00:39:18,000 --> 00:39:21,000
才可以实现我们可以接受的安全性

929
00:39:21,000 --> 00:39:23,000
对因为目前就我们所知

930
00:39:23,000 --> 00:39:25,000
一般的公有云厂商

931
00:39:25,000 --> 00:39:27,000
一般都是用这种方式

932
00:39:27,000 --> 00:39:30,000
就是第一层还是用 Hypervisor 去

933
00:39:30,000 --> 00:39:32,000
或者说 VM 去做隔离

934
00:39:32,000 --> 00:39:37,000
对然后可能没有用容器直接去做隔离

935
00:39:37,000 --> 00:39:39,000
不太靠谱吧

936
00:39:39,000 --> 00:39:44,000
所以 Hyper 的一个主要应用场景就是说

937
00:39:44,000 --> 00:39:47,000
给那些有志于提供这个公有云的厂商

938
00:39:47,000 --> 00:39:49,000
这么一套基础的工具

939
00:39:49,000 --> 00:39:52,000
使得他们可以比较快速的这个启动

940
00:39:52,000 --> 00:39:55,000
或者是关闭一个这个虚拟机

941
00:39:55,000 --> 00:39:57,000
然后这个虚拟机上是可以

942
00:39:57,000 --> 00:39:59,000
但是它面向就暴露给这个用户的

943
00:39:59,000 --> 00:40:02,000
它确实确实一个叫什么来着

944
00:40:02,000 --> 00:40:05,000
是类似于 container 那种的 API

945
00:40:05,000 --> 00:40:06,000
对吧

946
00:40:06,000 --> 00:40:07,000
对

947
00:40:07,000 --> 00:40:08,000
OK

948
00:40:08,000 --> 00:40:09,000
所以这个就是牵涉到另外一个问题了

949
00:40:09,000 --> 00:40:11,000
就是说因为我们现在大部分的

950
00:40:11,000 --> 00:40:13,000
像 Linode 也好

951
00:40:13,000 --> 00:40:14,000
AWS 也好

952
00:40:14,000 --> 00:40:16,000
还有现在比较火的 Digital Cloud 也好

953
00:40:16,000 --> 00:40:19,000
他们都是采用传统的虚拟机

954
00:40:19,000 --> 00:40:21,000
这种暴露出传统虚拟机这么一个单元

955
00:40:21,000 --> 00:40:27,000
然后由用户再去管理其中的这个是否跑 Docker

956
00:40:27,000 --> 00:40:29,000
是否跑什么

957
00:40:29,000 --> 00:40:31,000
跑什么这个 GuestOS 的事情

958
00:40:31,000 --> 00:40:32,000
那么刚才我们讲的

959
00:40:32,000 --> 00:40:35,000
你直接暴露给用户一套基于 container 的 API 的好处

960
00:40:35,000 --> 00:40:40,000
相比于现在这个暴露给用户一个基于 VM 的 API 的好处是什么呢

961
00:40:40,000 --> 00:40:45,000
其实我觉得还是另外一

962
00:40:45,000 --> 00:40:48,000
从一个应用场景上面来分析吧

963
00:40:48,000 --> 00:40:50,000
就是如果要是

964
00:40:50,000 --> 00:40:58,000
就是比如说用户他想他已经在本地他一个开发环境

965
00:40:58,000 --> 00:41:02,000
他本地的话他可以配置任何 Docker 的一个 image

966
00:41:02,000 --> 00:41:07,000
然后去上传到自己的 private 或者是 PubKate 的一个 hub 上面

967
00:41:07,000 --> 00:41:10,000
然后他再去运行

968
00:41:10,000 --> 00:41:15,000
然后如果他要是像直接拿到一个 VM 的一个环境的话

969
00:41:15,000 --> 00:41:17,000
那他完全他要在自己搭 Docker

970
00:41:17,000 --> 00:41:22,000
然后再给你去直接再部署下来再下来再去运行

971
00:41:22,000 --> 00:41:23,000
或者是对

972
00:41:23,000 --> 00:41:25,000
然后但是我们这种方式呢

973
00:41:25,000 --> 00:41:29,000
你直接可以将你的 Docker 的 image 直接下来下来

974
00:41:29,000 --> 00:41:35,000
你只要填一些你所想要的东西直接全都给你部署在后端了

975
00:41:35,000 --> 00:41:37,000
就是不需要你去做任何的配置

976
00:41:37,000 --> 00:41:38,000
你只要填

977
00:41:38,000 --> 00:41:44,000
我们这有一个叫就是输入文件就是 Json file

978
00:41:44,000 --> 00:41:48,000
Json file 里面可以定义你的所有的这个上面运行的东西

979
00:41:48,000 --> 00:41:50,000
比如 contender 运行那个 contender

980
00:41:50,000 --> 00:41:52,000
从哪运行从哪下载

981
00:41:52,000 --> 00:41:56,000
然后以及那个 Port 那端口营射

982
00:41:56,000 --> 00:41:59,000
然后以及 Sorage 等等等等

983
00:41:59,000 --> 00:42:01,000
你都可以去自己去配置

984
00:42:01,000 --> 00:42:04,000
然后所以就是简化用户操作吧

985
00:42:04,000 --> 00:42:05,000
我觉得

986
00:42:05,000 --> 00:42:06,000
OK

987
00:42:06,000 --> 00:42:10,000
所以这个其实还是挺切中我的这个个人的一个痛点

988
00:42:10,000 --> 00:42:13,000
比如说我自己在运营这个 IPN 的这个服务

989
00:42:13,000 --> 00:42:15,000
还有一些帮朋友管的一些其他的一些服务

990
00:42:15,000 --> 00:42:19,000
然后他们就是每次要新增一个服务或者管

991
00:42:19,000 --> 00:42:21,000
对特别是新增的时候会有一个问题

992
00:42:21,000 --> 00:42:23,000
就是说给我的这个虚拟机

993
00:42:23,000 --> 00:42:25,000
新开的一个虚拟机是空白的

994
00:42:25,000 --> 00:42:26,000
我得到重新搭一套

995
00:42:26,000 --> 00:42:29,000
比如说建管理对应的这个账号

996
00:42:29,000 --> 00:42:30,000
对吧

997
00:42:30,000 --> 00:42:32,000
对应的这个要安装对应的软件

998
00:42:32,000 --> 00:42:34,000
但这个可能有一部分是可以通过 Docker 本

999
00:42:34,000 --> 00:42:37,000
那个 Image 本身打包来实现的

1000
00:42:37,000 --> 00:42:38,000
但是刚才你提到一个很重要点

1001
00:42:38,000 --> 00:42:40,000
就是 Docker 这个 Demon

1002
00:42:40,000 --> 00:42:42,000
这个守护精神本身还是需要配置和安装的

1003
00:42:42,000 --> 00:42:43,000
对对对

1004
00:42:43,000 --> 00:42:47,000
所以其实我觉得还是一个就是抽象层次的一个飞跃吧

1005
00:42:47,000 --> 00:42:51,000
你们其实是通过 Hyper 这套基于 container 的 API

1006
00:42:51,000 --> 00:42:56,000
同时再加上这个 VM 的安全性

1007
00:42:56,000 --> 00:43:00,000
使得我们不用再去操心我当面这个 container

1008
00:43:00,000 --> 00:43:04,000
我其实我是可以在逻辑上按照 container 来做这个部署了

1009
00:43:04,000 --> 00:43:06,000
只是说我不用再操心

1010
00:43:06,000 --> 00:43:11,000
像传统 Docker 这种 container 之间无法内核及隔离的不安全的隐患

1011
00:43:11,000 --> 00:43:12,000
对对没错

1012
00:43:12,000 --> 00:43:13,000
对

1013
00:43:13,000 --> 00:43:18,000
然后我们下面就要进入到一个很关键的一个问题的讨论

1014
00:43:18,000 --> 00:43:22,000
就是说因为基于因为 Docker 其实本身到我觉得到目前为止

1015
00:43:22,000 --> 00:43:24,000
也没有并没有很好的解决这个问题

1016
00:43:24,000 --> 00:43:27,000
就是这个存储空间的问题

1017
00:43:27,000 --> 00:43:30,000
因为过去的话就照我的理解它 Docker 的

1018
00:43:30,000 --> 00:43:35,000
因为它是提倡的叫做应用是那个 Imagecontainer 是不可变的

1019
00:43:35,000 --> 00:43:36,000
就 immutable 的 container

1020
00:43:36,000 --> 00:43:40,000
那么比如说你作为一个应用层应用服务器本身

1021
00:43:40,000 --> 00:43:41,000
可能这个倒也没什么

1022
00:43:41,000 --> 00:43:45,000
你多起几个应用就可以提高你的这个并发数

1023
00:43:45,000 --> 00:43:46,000
对吧

1024
00:43:46,000 --> 00:43:47,000
那当然是好的

1025
00:43:47,000 --> 00:43:50,000
但是我们做大部分的这个网站也好

1026
00:43:50,000 --> 00:43:51,000
还是这个什么服务也好

1027
00:43:51,000 --> 00:43:54,000
它还是必须要考虑这个数据持久化的问题

1028
00:43:54,000 --> 00:43:57,000
就是说这个你从这个客户那里拿到了这个数据

1029
00:43:57,000 --> 00:43:58,000
那你存到哪里

1030
00:43:58,000 --> 00:44:02,000
过去 Docker 的一个提倡的一个概念就是说

1031
00:44:02,000 --> 00:44:04,000
那你再建一个就单纯拿来做这个存储的一个

1032
00:44:04,000 --> 00:44:07,000
一个 image 来做这件事情

1033
00:44:07,000 --> 00:44:11,000
所以我不知道这件事情在 hyper 里面是一个什么样的

1034
00:44:11,000 --> 00:44:14,000
一个值得就是什么样的做法是值得鼓励的

1035
00:44:14,000 --> 00:44:21,000
我们目前是有一个单独的 Volgum 的一个模块

1036
00:44:21,000 --> 00:44:30,000
然后它是你可以在针对某个 container 或者说针对几个 container 去配置

1037
00:44:30,000 --> 00:44:37,000
然后你可以自己添加你想加入的 Volgum

1038
00:44:37,000 --> 00:44:40,000
这个 Volgum 可以是文件或者是目标

1039
00:44:40,000 --> 00:44:43,000
然后也可以是博高的 device

1040
00:44:43,000 --> 00:44:46,000
博高的 device 就是支持非常多的形式

1041
00:44:46,000 --> 00:44:47,000
或者就是

1042
00:44:48,000 --> 00:44:50,000
然后用户可以自由配置

1043
00:44:50,000 --> 00:44:54,000
然后你可以把这个多大多少你都可以自己配置

1044
00:44:54,000 --> 00:44:57,000
然后指定给哪个用户都可以自己配置

1045
00:44:57,000 --> 00:44:58,000
然后这样的话呢

1046
00:44:58,000 --> 00:45:00,000
你加入到一个 container 里面

1047
00:45:00,000 --> 00:45:05,000
你可能运行的时候你可以指定我将数据存到这个

1048
00:45:05,000 --> 00:45:06,000
这个

1049
00:45:06,000 --> 00:45:07,000
那个

1050
00:45:07,000 --> 00:45:08,000
那个

1051
00:45:08,000 --> 00:45:09,000
那个

1052
00:45:09,000 --> 00:45:10,000
包括 device 或者说是

1053
00:45:10,000 --> 00:45:12,000
或者说你用 isgazzy

1054
00:45:12,000 --> 00:45:25,000
当然也可能直接配 storage server 都可以

1055
00:45:25,000 --> 00:45:26,000
ok

1056
00:45:26,000 --> 00:45:29,000
所以我理解一下这个大概的一个做法

1057
00:45:29,000 --> 00:45:36,000
就是说我把就是这个 hyper 它会允许我虚拟出一块这个 block device

1058
00:45:36,000 --> 00:45:38,000
就是一个快存储器

1059
00:45:38,000 --> 00:45:39,000
对

1060
00:45:39,000 --> 00:45:43,000
然后这个快存储器我可以直接挂载进我的某一个这个 hyper 的虚拟机里面

1061
00:45:43,000 --> 00:45:45,000
成为一个文件系统也好

1062
00:45:45,000 --> 00:45:46,000
一个什么目录也好

1063
00:45:46,000 --> 00:45:47,000
然后

1064
00:45:47,000 --> 00:45:52,000
但这样的话就是这个 hyper 这个虚拟机里面本身跑的应用

1065
00:45:52,000 --> 00:45:54,000
它还是一个 immutable 就是不可变的

1066
00:45:54,000 --> 00:45:55,000
对

1067
00:45:55,000 --> 00:45:59,000
然后它这写入的数据也是通过这个刚才挂载进去的这个 block device

1068
00:45:59,000 --> 00:46:00,000
持久化到其他地方的对吧

1069
00:46:00,000 --> 00:46:01,000
对

1070
00:46:01,000 --> 00:46:05,000
然后这个持久化是要么你可以在本机就是同一台这个 host 的机器上

1071
00:46:05,000 --> 00:46:12,000
或者是通过这个 isqus 这种网络的这个存储的协议写到另外一台这个一个文件

1072
00:46:12,000 --> 00:46:14,000
比如说一个文件服务器上

1073
00:46:14,000 --> 00:46:15,000
对

1074
00:46:15,000 --> 00:46:16,000
没错

1075
00:46:16,000 --> 00:46:17,000
是这样了

1076
00:46:17,000 --> 00:46:18,000
ok

1077
00:46:18,000 --> 00:46:20,000
所以那这里就牵涉到一个一个一个效率的问题了

1078
00:46:20,000 --> 00:46:22,000
刚才我们也在前面也提到了

1079
00:46:22,000 --> 00:46:26,000
就是说通过这种方式挂载进去的这个就是 disk IO 的这个效率

1080
00:46:26,000 --> 00:46:29,000
会有很大的这个损耗吗

1081
00:46:29,000 --> 00:46:31,000
还是说什么一个什么样的情况

1082
00:46:31,000 --> 00:46:33,000
呃其实这个主要还是说

1083
00:46:33,000 --> 00:46:35,000
呃

1084
00:46:35,000 --> 00:46:36,000
hyperizer 本身的嘛

1085
00:46:36,000 --> 00:46:40,000
就是因为我们我们如果你要是挂本机的呃呃

1086
00:46:40,000 --> 00:46:41,000
呃

1087
00:46:41,000 --> 00:46:42,000
包括 device 的话

1088
00:46:42,000 --> 00:46:44,000
那么它其实还是涉及到一个呃

1089
00:46:44,000 --> 00:46:45,000
呃

1090
00:46:45,000 --> 00:46:47,000
Io 命令的一个传递的一个转换

1091
00:46:47,000 --> 00:46:49,000
然后这个的话呃

1092
00:46:49,000 --> 00:46:50,000
消耗应该不大

1093
00:46:50,000 --> 00:46:53,000
但是如果你要是文件级别就蒙古尔的话

1094
00:46:53,000 --> 00:46:54,000
蒙古尔的话

1095
00:46:54,000 --> 00:46:56,000
它其实是走的呃

1096
00:46:56,000 --> 00:46:57,000
呃

1097
00:46:57,000 --> 00:47:01,000
它是通过 hyperizer 的 share 的 share file

1098
00:47:01,000 --> 00:47:02,000
来来来

1099
00:47:02,000 --> 00:47:04,000
share 或者 share directory 来做的

1100
00:47:04,000 --> 00:47:06,000
所以这个过程呢

1101
00:47:06,000 --> 00:47:07,000
就我们之前测过

1102
00:47:07,000 --> 00:47:12,000
就是不管是 vmware 或者说 waterbox 或者是 cumel

1103
00:47:12,000 --> 00:47:17,000
它的就 share 的目标的性能都不是特别好

1104
00:47:17,000 --> 00:47:21,000
所以我们特别建议用那个 blog device 级别的去操作

1105
00:47:21,000 --> 00:47:24,000
另外就像刚才另外一种方式

1106
00:47:24,000 --> 00:47:25,000
呃第三种方式

1107
00:47:25,000 --> 00:47:29,000
就比如我要是远远端的或者说 sore server 的话

1108
00:47:29,000 --> 00:47:30,000
那这个的话

1109
00:47:30,000 --> 00:47:32,000
它因为可以是呃

1110
00:47:32,000 --> 00:47:33,000
呃报告给呃

1111
00:47:33,000 --> 00:47:35,000
hyperizer 一个 blog device

1112
00:47:35,000 --> 00:47:36,000
嗯

1113
00:47:36,000 --> 00:47:38,000
所以它这个的性能可能是

1114
00:47:38,000 --> 00:47:41,000
除了依换于 hyperizerblog device 的支持

1115
00:47:41,000 --> 00:47:46,000
还有的话就是呃这个用的第三方工具的性能了

1116
00:47:46,000 --> 00:47:47,000
啊

1117
00:47:47,000 --> 00:47:48,000
对

1118
00:47:48,000 --> 00:47:51,000
所以呃 share 的目标的话

1119
00:47:51,000 --> 00:47:52,000
这个呃

1120
00:47:52,000 --> 00:47:55,000
这确实是一个硬上没有特别好的办法

1121
00:47:55,000 --> 00:47:59,000
因为 hyperizer 本身它他们做的也不太好

1122
00:47:59,000 --> 00:48:06,000
因为它是想达到更加用户就是说呃普通用户级别的使用

1123
00:48:06,000 --> 00:48:07,000
嗯

1124
00:48:07,000 --> 00:48:12,000
而不是说我用这个来做企业级别或者说做工业级别的应用

1125
00:48:12,000 --> 00:48:13,000
可能不太一样

1126
00:48:13,000 --> 00:48:14,000
嗯 ok

1127
00:48:14,000 --> 00:48:16,000
所以那么就牵涉到一个问题了哈

1128
00:48:16,000 --> 00:48:18,000
就是说在实际大规模部署的时候

1129
00:48:18,000 --> 00:48:23,000
这种比如说类似于呃 Google 或者是 Amazon 这种级别的用户

1130
00:48:23,000 --> 00:48:30,000
他们会一般会采用什么样的方式去部署这个呃这种这个这个这个存储的这个方案呢

1131
00:48:30,000 --> 00:48:33,000
呃呃啊

1132
00:48:33,000 --> 00:48:38,000
存储的方案呃这这我还真不确定他们怎么部署的

1133
00:48:38,000 --> 00:48:39,000
嗯 ok

1134
00:48:39,000 --> 00:48:40,000
嗯没关系

1135
00:48:40,000 --> 00:48:42,000
那我们进入这个下一个话题啊

1136
00:48:42,000 --> 00:48:46,000
就是说刚才也提到这个文件存储可能是效率上是一个硬伤

1137
00:48:46,000 --> 00:48:52,000
嗯这个呃这个确实在目前的技术条件下好像没有特别好的解决的方案啊

1138
00:48:52,000 --> 00:48:53,000
对对

1139
00:48:53,000 --> 00:48:57,000
然后刚才之前我们也提到了这个网络这块因为也涉及到 IO 嘛

1140
00:48:57,000 --> 00:48:59,000
嗯也是一个比较尴尬的一个状态

1141
00:48:59,000 --> 00:49:06,000
这个其实这个都说的是在呃呃刚才我们大概假设的一个场景都是说在一个 Linux 的 hostOS 上跑

1142
00:49:06,000 --> 00:49:09,000
呃这个一个应用的场景

1143
00:49:09,000 --> 00:49:14,000
但是我现在就问一下如果在开发者在就是想让他听众朋友们对这个 hyper 比较感兴趣

1144
00:49:14,000 --> 00:49:20,000
他想去试一下他在哪些其他系统上可以呃去去玩这个 hyper 呢

1145
00:49:20,000 --> 00:49:27,000
哦因为我们像那个 docker 他可以通过这个一些虚拟机的方式在像 OS 10 上也可以跑 hyper 呢

1146
00:49:27,000 --> 00:49:31,000
呃 hyper 呃当然也也支持 macOS

1147
00:49:31,000 --> 00:49:33,000
然后这个东西

1148
00:49:33,000 --> 00:49:36,000
这个这个这个这个呃呃

1149
00:49:36,000 --> 00:49:42,000
对于于 hyper 对于 macOS 的支持大概是在这个月应该是这个这个这个月月初完成的

1150
00:49:42,000 --> 00:49:44,000
然后我们也在不断的去完善

1151
00:49:44,000 --> 00:49:46,000
然后呃目前呢

1152
00:49:46,000 --> 00:49:56,000
那个在 hyper 呃在 macOS 上面的呃的 hyper 只能用 waterbox 一种 hyperizer

1153
00:49:56,000 --> 00:50:02,000
ok 然后如果你要是在 linux 上面那你可以用呃 Qmkvm

1154
00:50:02,000 --> 00:50:06,000
呃 Zen 以及 waterbox 都可以用

1155
00:50:06,000 --> 00:50:17,000
但是但是因为呃 macOS 上面呃没有说 Qmkvm 或者说 Zen 的这些虚拟化工具

1156
00:50:17,000 --> 00:50:19,000
所以就没有特别好的办法

1157
00:50:19,000 --> 00:50:25,000
ok 因为 virtualbox 的其实从这个它的稳定可靠性

1158
00:50:25,000 --> 00:50:27,000
还有它的这个性能来讲

1159
00:50:27,000 --> 00:50:29,000
其实不算特别好

1160
00:50:29,000 --> 00:50:33,000
特别是在呃这个呃就是 OS 10 上面

1161
00:50:33,000 --> 00:50:38,000
而今天会遇到什么用开了它然后就死机的一个情况也是有发生

1162
00:50:38,000 --> 00:50:47,000
对对对呃呃呃就其实最近那个我们知道好像是从那个 OS 10 是 10.9 还是 10.10 开始

1163
00:50:47,000 --> 00:50:54,000
它有一个呃就苹果开发了一套这个 firm mark 叫做 hypervisor.firm mark

1164
00:50:54,000 --> 00:50:59,000
对这套其实它可以在 OS 10 上实现类似于 kvm 的功能

1165
00:50:59,000 --> 00:51:03,000
嗯所以我不知道你们后续有什么计划会用到它吗

1166
00:51:03,000 --> 00:51:06,000
呃呃其实我们也在非常关注这个这个点

1167
00:51:06,000 --> 00:51:10,000
然后目前呢有一个开源的工具就是 XI 就是

1168
00:51:10,000 --> 00:51:17,000
嗯对对对我应该也关注过这个非常就是之前在 hackernews 上面发出来过非常火

1169
00:51:17,000 --> 00:51:18,000
然后对

1170
00:51:18,000 --> 00:51:19,000
关注度也非常高

1171
00:51:19,000 --> 00:51:20,000
嗯

1172
00:51:20,000 --> 00:51:24,000
就它那个的历史还是要追踪到那个 Solaris 上面去对吧

1173
00:51:24,000 --> 00:51:28,000
因为它的前身是一个它是基于它是一个 beehive 的 port

1174
00:51:28,000 --> 00:51:29,000
对然后

1175
00:51:29,000 --> 00:51:31,000
嘿 beehive 是在 Solaris 还是上 bsd

1176
00:51:31,000 --> 00:51:32,000
呃 freebsd

1177
00:51:32,000 --> 00:51:33,000
freebsd

1178
00:51:33,000 --> 00:51:34,000
freebsd

1179
00:51:34,000 --> 00:51:36,000
对对对对所以上上面应该是没有的

1180
00:51:36,000 --> 00:51:37,000
OK

1181
00:51:37,000 --> 00:51:44,000
所以这个目前来说就是我们还是跟那个像就是那个 Docker 的方案一样

1182
00:51:44,000 --> 00:51:50,000
在 OS 10 上测试开发的时候是通过这个 virtualbox 这个虚拟机啊

1183
00:51:50,000 --> 00:51:55,000
呃里面直接在跑一些呃是跑的这个是 hyper 的虚拟机了对吧

1184
00:51:55,000 --> 00:52:01,000
呃这个就是我们的一个费个好多好多心思去做的这个这个东西就是我们这个

1185
00:52:01,000 --> 00:52:07,000
这个 hyper 在 Mac 上面的运行和 boot 2 Docker 的运行是不太一样的

1186
00:52:07,000 --> 00:52:11,000
boot 2 Docker 呢它其实就是一个 Docker 的可按端

1187
00:52:11,000 --> 00:52:19,000
然后呃它把它的 Demon 设成了 VM 的呃 waterbox 的呃地址

1188
00:52:19,000 --> 00:52:23,000
然后这个在 waterbox 里面去运行 DockerDemon

1189
00:52:23,000 --> 00:52:24,000
嗯

1190
00:52:24,000 --> 00:52:32,000
然后它其实相当于通过网络然后将这个数据全部显示给 Docker 可按的用户以为它这个是本地运行的

1191
00:52:32,000 --> 00:52:37,000
其实是在所有的东西在那那 Virtualbox 的那个虚拟机里面运行

1192
00:52:37,000 --> 00:52:39,000
对对对是的而对

1193
00:52:39,000 --> 00:52:41,000
OK 那你们的方案是怎么样

1194
00:52:41,000 --> 00:52:46,000
我们的方面我们的方案其实是跟 Linux 它的设计机制是完全一致的

1195
00:52:46,000 --> 00:52:50,000
就是相当于我们的 hyperdemon 是在 MacOS 上面

1196
00:52:50,000 --> 00:52:54,000
然后呃我们的 hyper 可按的也在 MacOS 上面

1197
00:52:54,000 --> 00:53:01,000
而运行的呃 Docker 的 image 是在 waterbox 里面去运行的

1198
00:53:01,000 --> 00:53:06,000
它它它整个的一个设计丝目是完全和啊

1199
00:53:06,000 --> 00:53:09,000
Linux 上面的 hyper 设计丝目是一致的

1200
00:53:09,000 --> 00:53:19,000
所以其实我理解哈就是说在这种情况下我比如说我在 OS 10 上跑了一个这个这个这个这个这个 hyper 之后

1201
00:53:19,000 --> 00:53:23,000
它的这个管理层是管理层的命令行工具都是在 OS 10 的原生的东西

1202
00:53:23,000 --> 00:53:29,000
然后它是控制 Virtualbox 这个 hypervisor 去里面新建一个虚拟机

1203
00:53:29,000 --> 00:53:34,000
然后虚拟机内核跑的是你们这个 hyper 定制的这个轻量级的这个 guestOS

1204
00:53:34,000 --> 00:53:35,000
对对对

1205
00:53:35,000 --> 00:53:38,000
然后里面再跑的一个或者是多个这个 Docker 的 image

1206
00:53:38,000 --> 00:53:40,000
对对对是的

1207
00:53:40,000 --> 00:53:44,000
OK 外面这个还真的和那个 Boot to Docker 的方式非常不一样

1208
00:53:44,000 --> 00:53:47,000
对因为 Boot to Docker 你创建一个 container

1209
00:53:47,000 --> 00:53:50,000
它是一个 Washab 是一个 VM

1210
00:53:50,000 --> 00:53:53,000
然后你创建两个它也是创建三个它也是

1211
00:53:53,000 --> 00:53:56,000
它创建的 container 都是在 VM 里面

1212
00:53:56,000 --> 00:53:59,000
而我们这种方式呢就是你创建一个 container

1213
00:53:59,000 --> 00:54:00,000
或者说

1214
00:54:00,000 --> 00:54:01,000
就多一个 VM

1215
00:54:01,000 --> 00:54:02,000
对对对多一个 VM

1216
00:54:02,000 --> 00:54:06,000
这个可能会受限于开发者的一个机器的一个环境配置

1217
00:54:06,000 --> 00:54:10,000
因为你多个 VM 它毕竟要占 CPU 占 memory

1218
00:54:10,000 --> 00:54:12,000
这个这个是一个这个

1219
00:54:12,000 --> 00:54:15,000
但是它做很好的一个隔离性

1220
00:54:15,000 --> 00:54:16,000
对吧

1221
00:54:16,000 --> 00:54:17,000
OK

1222
00:54:17,000 --> 00:54:22,000
所以这里我要问一个很好很好玩的问题

1223
00:54:22,000 --> 00:54:27,000
就是说那你们为了实现这个采了多少 VirtualBox 的坑

1224
00:54:27,000 --> 00:54:34,000
这个我我想你应该也会知道 Washab 的坑就是太多太多

1225
00:54:34,000 --> 00:54:38,000
就是它的 API 很难在 Mac 上面

1226
00:54:38,000 --> 00:54:40,000
因为我们是用 Go 开发的嘛

1227
00:54:40,000 --> 00:54:43,000
所以它的 Washab 的 API 很难跟 Go 去结合到一起

1228
00:54:43,000 --> 00:54:45,000
所以没办法只能调命的行

1229
00:54:45,000 --> 00:54:46,000
多命的行

1230
00:54:46,000 --> 00:54:47,000
多命的行

1231
00:54:47,000 --> 00:54:51,000
那一个另外一个问题就是没办法监测它的一个输出的一个结果

1232
00:54:51,000 --> 00:54:58,000
所以就是用一些很很很无奈的办法去直接接它的输出

1233
00:54:58,000 --> 00:55:00,000
这些办法

1234
00:55:00,000 --> 00:55:05,000
另外呢就是不局限于 Washab 的问题

1235
00:55:05,000 --> 00:55:08,000
还有就是麦格瓦斯的问题

1236
00:55:08,000 --> 00:55:10,000
因为因为众所周知

1237
00:55:10,000 --> 00:55:14,000
因为 Docker 它的它用了 Layer 的 FS

1238
00:55:14,000 --> 00:55:18,000
对然后它用这个来做 Layer 的 Image

1239
00:55:18,000 --> 00:55:22,000
然后对来保证足够的快

1240
00:55:22,000 --> 00:55:24,000
然后不至于说直接的拷贝

1241
00:55:24,000 --> 00:55:28,000
然后造成很很大的一个时间

1242
00:55:28,000 --> 00:55:31,000
然后呢我们在麦格瓦斯上面

1243
00:55:31,000 --> 00:55:33,000
其实也想了很多很多办法

1244
00:55:33,000 --> 00:55:38,000
就怎么能够达到 Layer 这种效果

1245
00:55:38,000 --> 00:55:40,000
所以居然让我们找到了 Washabox

1246
00:55:40,000 --> 00:55:42,000
居然能有这种机制

1247
00:55:42,000 --> 00:55:44,000
就是 Washabox

1248
00:55:44,000 --> 00:55:48,000
其实是可以做 Layer 的 Disk

1249
00:55:48,000 --> 00:55:52,000
就是它是通过那个 Snapshot 那个机制吗

1250
00:55:52,000 --> 00:55:54,000
其实它不太一样

1251
00:55:54,000 --> 00:55:56,000
但是也差不多类似实验机制

1252
00:55:56,000 --> 00:55:59,000
它是通过 Parent Disk

1253
00:55:59,000 --> 00:56:01,000
其实就是 Snapshot 我觉得

1254
00:56:01,000 --> 00:56:02,000
OK

1255
00:56:02,000 --> 00:56:03,000
然后呢通过这种方式

1256
00:56:03,000 --> 00:56:07,000
就可以实现用 Layer 的 Disk

1257
00:56:07,000 --> 00:56:09,000
你们是这么做的

1258
00:56:09,000 --> 00:56:11,000
好机智啊这个办法

1259
00:56:11,000 --> 00:56:15,000
那出来的实际的执行效率怎么样

1260
00:56:15,000 --> 00:56:17,000
因为这个可能其实

1261
00:56:17,000 --> 00:56:18,000
除非你部署吧

1262
00:56:18,000 --> 00:56:19,000
其实大部分开发者

1263
00:56:19,000 --> 00:56:21,000
可能还是在像这个 OS 10 里面

1264
00:56:21,000 --> 00:56:23,000
用 VirtualBox 的方式来开发

1265
00:56:23,000 --> 00:56:24,000
对

1266
00:56:24,000 --> 00:56:25,000
然后我们目前这种方式的话

1267
00:56:25,000 --> 00:56:29,000
大概在运行一个

1268
00:56:29,000 --> 00:56:32,000
Ubong 2 的 DockerImage

1269
00:56:32,000 --> 00:56:33,000
就整个下载

1270
00:56:33,000 --> 00:56:35,000
然后你下载之后

1271
00:56:35,000 --> 00:56:39,000
运行大概在两分钟

1272
00:56:39,000 --> 00:56:42,000
就是从那个 VirtualBox

1273
00:56:42,000 --> 00:56:44,000
去创建到开始起到

1274
00:56:44,000 --> 00:56:46,000
就直接你可以直接操作

1275
00:56:46,000 --> 00:56:48,000
两分钟不到两分钟

1276
00:56:48,000 --> 00:56:49,000
不到两分钟

1277
00:56:49,000 --> 00:56:52,000
对 1900 多毫秒吧

1278
00:56:52,000 --> 00:56:53,000
OK

1279
00:56:53,000 --> 00:56:54,000
那如果这个中间两分钟的

1280
00:56:54,000 --> 00:56:56,000
主要的花在哪里

1281
00:56:56,000 --> 00:56:57,000
主要花在了

1282
00:56:57,000 --> 00:56:59,000
其实一部分是

1283
00:56:59,000 --> 00:57:03,000
Waterbox 本身的设备的一个虚拟化

1284
00:57:03,000 --> 00:57:05,000
就是它的硬件的

1285
00:57:05,000 --> 00:57:06,000
device 的一个虚拟化

1286
00:57:06,000 --> 00:57:07,000
因为它

1287
00:57:07,000 --> 00:57:10,000
就叫配置一个 VirtualBox 的虚拟机出来

1288
00:57:10,000 --> 00:57:11,000
对

1289
00:57:11,000 --> 00:57:12,000
它这是一部分

1290
00:57:12,000 --> 00:57:13,000
然后另外一部分

1291
00:57:13,000 --> 00:57:14,000
它就是一些硬件的虚拟化

1292
00:57:14,000 --> 00:57:17,000
就是比如我要是创建 SATA 的盘

1293
00:57:17,000 --> 00:57:20,000
那我只能创建 SATA 的 device

1294
00:57:20,000 --> 00:57:24,000
而且 Waterbox 只能是用 SATA

1295
00:57:24,000 --> 00:57:27,000
作为 Hotplug 的 Disk

1296
00:57:27,000 --> 00:57:28,000
而呢

1297
00:57:28,000 --> 00:57:32,000
用 SATA 作为 Hotplug 的 Disk 的话

1298
00:57:32,000 --> 00:57:34,000
就创建

1299
00:57:34,000 --> 00:57:35,000
时间会比较漫长

1300
00:57:35,000 --> 00:57:38,000
就稍微比 SATA 的要

1301
00:57:38,000 --> 00:57:41,000
就是因为 SATA 它不支持 Hotplug

1302
00:57:41,000 --> 00:57:43,000
所以它的机制可能会简单好多

1303
00:57:44,000 --> 00:57:49,000
对所以就损耗在这些方面就比较不耐

1304
00:57:49,000 --> 00:57:51,000
然后另外一个就是

1305
00:57:51,000 --> 00:57:55,000
当然也是有 GasOS 去运行

1306
00:57:55,000 --> 00:57:56,000
但是这个时间没办法

1307
00:57:56,000 --> 00:57:58,000
就我们已经极致的去优化了

1308
00:57:58,000 --> 00:58:02,000
但是相比这个还是会短短一些

1309
00:58:02,000 --> 00:58:03,000
OK

1310
00:58:03,000 --> 00:58:07,000
所以其实就是说如果是在 OS 10 上开发的话

1311
00:58:07,000 --> 00:58:11,000
用 Hyper 最主要的开销就是在创建那一块

1312
00:58:11,000 --> 00:58:14,000
然后创建好了之后的启动

1313
00:58:14,000 --> 00:58:17,000
某一个 Hyper 的虚拟机

1314
00:58:17,000 --> 00:58:19,000
还是要比在就是实际上原生

1315
00:58:19,000 --> 00:58:21,000
就部署的时候那个效能

1316
00:58:21,000 --> 00:58:22,000
比如 0.3 秒要慢一些

1317
00:58:22,000 --> 00:58:23,000
对对对

1318
00:58:23,000 --> 00:58:24,000
是这样吗

1319
00:58:24,000 --> 00:58:29,000
因为它本身的 Waterboss 的机制没办法

1320
00:58:29,000 --> 00:58:30,000
OK

1321
00:58:30,000 --> 00:58:33,000
所以这个真的要可能要逼得你们去研究

1322
00:58:33,000 --> 00:58:35,000
那个新的 Hypervisor Framework

1323
00:58:35,000 --> 00:58:36,000
去解决这个问题

1324
00:58:36,000 --> 00:58:39,000
对我们也在时刻关注这个东西

1325
00:58:39,000 --> 00:58:40,000
因为这个东西

1326
00:58:40,000 --> 00:58:43,000
就最近的观察来看

1327
00:58:43,000 --> 00:58:46,000
就是原作者可能我在忙别的

1328
00:58:46,000 --> 00:58:47,000
然后不太开放

1329
00:58:47,000 --> 00:58:50,000
不太不太上心这件事情了

1330
00:58:50,000 --> 00:58:57,000
然后我们也在去关注希望能够去做一些贡献

1331
00:58:57,000 --> 00:58:58,000
然后但是

1332
00:58:58,000 --> 00:59:00,000
你是说 X-Hyper 的原作者

1333
00:59:00,000 --> 00:59:05,000
所以现在我们大概就了解了这个 Hyper 的一个整个它是什么

1334
00:59:05,000 --> 00:59:12,000
然后它相对于一些我们就是已经熟知的一些工具的这么一个技术对比

1335
00:59:12,000 --> 00:59:14,000
它的优劣是在哪里了

1336
00:59:14,000 --> 00:59:18,000
就是说我们其实可能就还在回到一个最关键的问题

1337
00:59:18,000 --> 00:59:24,000
就是说为什么我作为一个网络管理员或者机房的一个公有云的运营者

1338
00:59:24,000 --> 00:59:25,000
我要选择 Hyper

1339
00:59:25,000 --> 00:59:31,000
对所以你刚才说的一点非常关键的一点就是作为公有云的管理者

1340
00:59:31,000 --> 00:59:37,000
但是作为一个相当于说我就内部一个运营或者说测试环境

1341
00:59:37,000 --> 00:59:39,000
我用 Docker 一点问题没有啊

1342
00:59:39,000 --> 00:59:41,000
但是你要是用公有云的话

1343
00:59:41,000 --> 00:59:43,000
你必须要考虑它的安全性问题

1344
00:59:43,000 --> 00:59:44,000
对

1345
00:59:44,000 --> 00:59:48,000
然后所以就是因为考虑到安全性的问题呢

1346
00:59:48,000 --> 00:59:53,000
你就必须要考虑 Docker 它是否能

1347
00:59:53,000 --> 00:59:56,000
怎么能够跟 VM 去结合

1348
00:59:56,000 --> 00:59:59,000
能够最大效率的去利用 BearMental 的机制

1349
00:59:59,000 --> 01:00:03,000
所以为什么不去尝试 Hyper 呢

1350
01:00:03,000 --> 01:00:10,000
Hyper 其实就是为你为个这种公有云的运营商天上去解决这个问题

1351
01:00:10,000 --> 01:00:15,000
你又想用 Docker 又想提供这种基于 container 的一个管理方式

1352
01:00:15,000 --> 01:00:17,000
那个租户的管理方式

1353
01:00:17,000 --> 01:00:19,000
然后再可以用 Docker image

1354
01:00:19,000 --> 01:00:23,000
然后跟 Docker 的使用完全没有异样

1355
01:00:23,000 --> 01:00:26,000
但是它的安全性会非常非常好

1356
01:00:26,000 --> 01:00:30,000
那么所以这个就是一个很很好的一个机会

1357
01:00:30,000 --> 01:00:31,000
然后去尝试

1358
01:00:31,000 --> 01:00:32,000
OK

1359
01:00:32,000 --> 01:00:33,000
所以有 Hyper

1360
01:00:33,000 --> 01:00:35,000
其实我们就可以达到一个安全的

1361
01:00:35,000 --> 01:00:36,000
共有的

1362
01:00:36,000 --> 01:00:38,000
其实一个 CAS

1363
01:00:38,000 --> 01:00:41,000
CAS 就是 container as a service

1364
01:00:41,000 --> 01:00:44,000
所以我们目前也在提这个概念

1365
01:00:44,000 --> 01:00:45,000
OK

1366
01:00:45,000 --> 01:00:49,000
所以这里就很自然的构渡到我们的下一个话题

1367
01:00:49,000 --> 01:00:51,000
就是说你们的主要的客户

1368
01:00:51,000 --> 01:00:52,000
其实并不是说

1369
01:00:52,000 --> 01:00:55,000
当然你说这个要大家熟悉的方式 API

1370
01:00:55,000 --> 01:00:57,000
肯定还是要教育用户的

1371
01:00:57,000 --> 01:00:59,000
但是说从你们这个 customer

1372
01:00:59,000 --> 01:01:01,000
就是谁为你们付钱这件事情来讲

1373
01:01:01,000 --> 01:01:04,000
可能还是一些这个刚才讲的这个公用云的管理者

1374
01:01:04,000 --> 01:01:05,000
对

1375
01:01:05,000 --> 01:01:08,000
那这就牵涉到这个所谓的商业模式的问题了

1376
01:01:08,000 --> 01:01:10,000
就是说你们这个 Hyper 这个项目

1377
01:01:10,000 --> 01:01:13,000
你们目前打算是怎么去盈利呢

1378
01:01:13,000 --> 01:01:16,000
我们目前其实 Hyper 这个项目主

1379
01:01:16,000 --> 01:01:19,000
还是作为开源项目为主

1380
01:01:19,000 --> 01:01:24,000
这样的话也是希望吸引能够吸引更多的 hacker

1381
01:01:24,000 --> 01:01:28,000
或者说一些 contributor 来参与到我们的项目

1382
01:01:28,000 --> 01:01:31,000
来共同打造一个基于 container 的一个

1383
01:01:31,000 --> 01:01:34,000
或者是基于 POD 的一个社区

1384
01:01:34,000 --> 01:01:45,000
然后我们也是希望能够跟一些机房或者说一些类似于这种的厂商去合作

1385
01:01:45,000 --> 01:01:48,000
希望能够帮助他们去听更好的解决方案

1386
01:01:48,000 --> 01:01:53,000
也就是目前我们成立大概半年多的时间

1387
01:01:53,000 --> 01:01:58,000
其实像国外一个比较著名的一个也是创业公司吧

1388
01:01:58,000 --> 01:01:59,000
叫 Packet

1389
01:01:59,000 --> 01:02:04,000
然后它其实就是已经推出了基于 Hyper 的一个产品

1390
01:02:04,000 --> 01:02:05,000
对

1391
01:02:05,000 --> 01:02:07,000
现在已经出过大家也可以去体验

1392
01:02:07,000 --> 01:02:09,000
当然可能要绑定性卡

1393
01:02:09,000 --> 01:02:11,000
就比较麻烦

1394
01:02:12,000 --> 01:02:13,000
对

1395
01:02:13,000 --> 01:02:17,000
相信对于这个我们这个有足够这个尝鲜精神的开发者来说

1396
01:02:17,000 --> 01:02:19,000
这不是一个特别大的难题

1397
01:02:19,000 --> 01:02:22,000
当然你可以自己在自己的

1398
01:02:22,000 --> 01:02:26,000
平台上面去部署或者是去体验

1399
01:02:26,000 --> 01:02:27,000
当然也可以

1400
01:02:27,000 --> 01:02:28,000
然后除此之外

1401
01:02:28,000 --> 01:02:32,000
就是跟这种这种厂商去合作之外

1402
01:02:32,000 --> 01:02:36,000
我们也在自己也在做基于容器的公有运

1403
01:02:36,000 --> 01:02:37,000
就刚才说的 CaaS

1404
01:02:38,000 --> 01:02:40,000
就你们自己要运营一个公有运

1405
01:02:40,000 --> 01:02:41,000
对

1406
01:02:41,000 --> 01:02:43,000
其实我们这个目前提的一个方式

1407
01:02:43,000 --> 01:02:44,000
就叫 HyperStack

1408
01:02:45,000 --> 01:02:46,000
对

1409
01:02:46,000 --> 01:02:47,000
HyperStack

1410
01:02:47,000 --> 01:02:51,000
它其实是构建于 Hyper 的基础上

1411
01:02:51,000 --> 01:02:54,000
然后结合目前非常流行的 Cubernetes

1412
01:02:54,000 --> 01:02:57,000
然后 OpenStack 里面的一些组件

1413
01:02:57,000 --> 01:02:59,000
比如像 Cinder

1414
01:02:59,000 --> 01:03:00,000
Nutrient 以及 Kistone

1415
01:03:00,000 --> 01:03:06,000
然后将这几个组件结合到一起

1416
01:03:06,000 --> 01:03:08,000
然后形成一个自己的 Stack

1417
01:03:08,000 --> 01:03:14,000
也是希望能够达到整个生态链

1418
01:03:14,000 --> 01:03:16,000
然后我们已经提了这个 Proposal

1419
01:03:16,000 --> 01:03:20,000
然后目前也在去组织人手去打造

1420
01:03:20,000 --> 01:03:21,000
OK

1421
01:03:21,000 --> 01:03:23,000
那这里就涉及到最开始的一个问题

1422
01:03:23,000 --> 01:03:24,000
就是说

1423
01:03:24,000 --> 01:03:27,000
因为当时我看你们 Hyper.sh 的网站上

1424
01:03:27,000 --> 01:03:30,000
也有只有一个英文的介绍

1425
01:03:30,000 --> 01:03:32,000
并没有中文的任何介绍

1426
01:03:32,000 --> 01:03:36,000
这跟你们这个商业模型和客户选择有关系

1427
01:03:36,000 --> 01:03:37,000
对对对

1428
01:03:37,000 --> 01:03:45,000
我们目前的一个打算就是希望能够吸引更多国外的厂商

1429
01:03:45,000 --> 01:03:50,000
然后去跟他们去竞争或者说去合作

1430
01:03:50,000 --> 01:03:57,000
然后之前的一个考虑就是国内对于开源项目的支持

1431
01:03:57,000 --> 01:04:02,000
或者说合作不是特别大胆或者不是特别明显

1432
01:04:02,000 --> 01:04:06,000
所以也考虑到这些问题

1433
01:04:06,000 --> 01:04:09,000
就是在前期作为一个创业公司

1434
01:04:09,000 --> 01:04:15,000
可能用一种最保险或者说最妥占的办法

1435
01:04:15,000 --> 01:04:17,000
OK

1436
01:04:17,000 --> 01:04:19,000
所以就是其实就很面临

1437
01:04:19,000 --> 01:04:21,000
刚才我们这个一个很尴尬的一个情况

1438
01:04:21,000 --> 01:04:23,000
就是中国这个网络技术设施

1439
01:04:23,000 --> 01:04:25,000
其实并不如美国好

1440
01:04:25,000 --> 01:04:28,000
就是从这个就是这个

1441
01:04:28,000 --> 01:04:29,000
机房啊

1442
01:04:29,000 --> 01:04:31,000
云的建设这一块是比较落后的

1443
01:04:31,000 --> 01:04:34,000
那同时在我们能够数得出来的

1444
01:04:34,000 --> 01:04:36,000
国内的一些公共云的运营者

1445
01:04:36,000 --> 01:04:37,000
也就那么几家

1446
01:04:37,000 --> 01:04:39,000
像什么阿里云

1447
01:04:39,000 --> 01:04:40,000
腾讯云

1448
01:04:40,000 --> 01:04:41,000
还有什么

1449
01:04:41,000 --> 01:04:42,000
美团

1450
01:04:42,000 --> 01:04:43,000
清云

1451
01:04:43,000 --> 01:04:44,000
美团清云以前还有

1452
01:04:44,000 --> 01:04:45,000
那京东云好像也有

1453
01:04:45,000 --> 01:04:46,000
现在还在吗

1454
01:04:46,000 --> 01:04:47,000
现在好像关闭了

1455
01:04:47,000 --> 01:04:48,000
关掉了

1456
01:04:48,000 --> 01:04:49,000
对对对好现了

1457
01:04:49,000 --> 01:04:51,000
然后他们其实并没有说

1458
01:04:51,000 --> 01:04:53,000
到了那个足够大板尝试

1459
01:04:53,000 --> 01:04:54,000
这种新技术的时候

1460
01:04:54,000 --> 01:04:55,000
对

1461
01:04:55,000 --> 01:04:56,000
OK

1462
01:04:56,000 --> 01:04:59,000
所以你们选择先去开拓这个海外市场

1463
01:04:59,000 --> 01:05:00,000
对

1464
01:05:00,000 --> 01:05:01,000
然后等这个在这个

1465
01:05:01,000 --> 01:05:04,000
验证好这个模式和这个技术成数之后

1466
01:05:04,000 --> 01:05:06,000
再想办法能不能够国内的这些

1467
01:05:06,000 --> 01:05:07,000
云场商也能够

1468
01:05:07,000 --> 01:05:12,000
或者说出一些新的这个小的云场商也能够采用这个 hyper 的这个技术

1469
01:05:12,000 --> 01:05:13,000
对对对

1470
01:05:13,000 --> 01:05:14,000
对

1471
01:05:14,000 --> 01:05:15,000
没错

1472
01:05:15,000 --> 01:05:19,000
所以你们在海外的目前的一些合作伙伴就刚才提到除了那个 packet

1473
01:05:19,000 --> 01:05:24,000
一个这个也是一个比较新和比较酷的这个公共云的运营商之外

1474
01:05:24,000 --> 01:05:27,000
还有哪些是你们在目前是在有这个深度合作的

1475
01:05:27,000 --> 01:05:28,000
嗯

1476
01:05:28,000 --> 01:05:30,000
我们现在比较合作的比较多的像圣

1477
01:05:30,000 --> 01:05:31,000
圣的圣的

1478
01:05:31,000 --> 01:05:36,000
圣的圣的圣的圣和 developer 我们都有非常多的接触

1479
01:05:36,000 --> 01:05:39,000
然后之前参加了圣的 developer summit

1480
01:05:39,000 --> 01:05:41,000
然后去跟他们去交流

1481
01:05:41,000 --> 01:05:42,000
呃

1482
01:05:42,000 --> 01:05:44,000
他们也非常支持

1483
01:05:44,000 --> 01:05:46,000
hyper 对圣的一个支持

1484
01:05:46,000 --> 01:05:47,000
呃

1485
01:05:47,000 --> 01:05:49,000
希望能够去呃

1486
01:05:49,000 --> 01:05:52,000
共同探讨能够把这个性能啊

1487
01:05:52,000 --> 01:05:54,000
或者说呃

1488
01:05:54,000 --> 01:05:56,000
体验做到足够的好

1489
01:05:56,000 --> 01:06:01,000
所以 Zen 还是说是是是我们一个非常非常重要的一个 partner

1490
01:06:01,000 --> 01:06:05,000
然后他们对我们在底层技术上面的一个

1491
01:06:05,000 --> 01:06:08,000
或者说在 hypervisor 上面的支持还是挺多的

1492
01:06:08,000 --> 01:06:09,000
啊 OK

1493
01:06:09,000 --> 01:06:10,000
对

1494
01:06:10,000 --> 01:06:11,000
明白

1495
01:06:11,000 --> 01:06:15,000
所以就还是一个非常值得让人让人激动的一个合作

1496
01:06:15,000 --> 01:06:16,000
对对对

1497
01:06:16,000 --> 01:06:21,000
因为 Zen 是我们一个很非常传统的这个虚拟器的这个 hypervisor

1498
01:06:21,000 --> 01:06:24,000
好我记得好像 AWS 就是基于 Zen 做的

1499
01:06:24,000 --> 01:06:25,000
对

1500
01:06:25,000 --> 01:06:28,000
好现在是一个也是非常好的技术

1501
01:06:28,000 --> 01:06:29,000
对对对对

1502
01:06:29,000 --> 01:06:30,000
ok

1503
01:06:30,000 --> 01:06:32,000
啊刚刚我们讲完了这个 hyper 这个产品

1504
01:06:32,000 --> 01:06:33,000
好包括你们的商业模式啊

1505
01:06:33,000 --> 01:06:34,000
其实现在我们聊到最

1506
01:06:34,000 --> 01:06:37,000
其实我这些我个人来说最关心的方

1507
01:06:37,000 --> 01:06:39,000
这个一个领域就是这个团队

1508
01:06:39,000 --> 01:06:40,000
嗯

1509
01:06:40,000 --> 01:06:41,000
呃那个 Simon 你可以大概介绍一下

1510
01:06:41,000 --> 01:06:44,000
你们现在做这个 hyper 这个 team 大概什么样情况吧

1511
01:06:44,000 --> 01:06:47,000
呃我们现在的开发者是五个人

1512
01:06:47,000 --> 01:06:49,000
然后五个人五个人这么小

1513
01:06:49,000 --> 01:06:50,000
嗯

1514
01:06:50,000 --> 01:06:53,000
所以就是每天还是挺忙碌的

1515
01:06:53,000 --> 01:06:54,000
OK

1516
01:06:54,000 --> 01:06:57,000
然后呃一个人主要负责 hyper-stack 相关的东西

1517
01:06:57,000 --> 01:07:01,000
然后另外就是主要集中在 hyper 的这个核心产品

1518
01:07:01,000 --> 01:07:04,000
然后足够就是嗯

1519
01:07:04,000 --> 01:07:07,000
嗯新的 feature 的开发以及 fix 一些 bug

1520
01:07:07,000 --> 01:07:13,000
然后因为毕竟开源代码也是希望能够让代码质量足够的优质

1521
01:07:13,000 --> 01:07:14,000
嗯哼

1522
01:07:14,000 --> 01:07:19,000
对然后 gameby 有呃有三个人主要是负责 bd 相关的东西

1523
01:07:19,000 --> 01:07:23,000
然后呃做一些因为毕竟是海外市场

1524
01:07:23,000 --> 01:07:26,000
所以我们有一些呃国外的朋友

1525
01:07:26,000 --> 01:07:29,000
然后去去帮忙退或者支持这些东西

1526
01:07:30,000 --> 01:07:33,000
啊所以整个团队其实加起来也不超过 10 个人吧

1527
01:07:33,000 --> 01:07:34,000
对对对

1528
01:07:34,000 --> 01:07:37,000
非常非常小然后金汉的一个团队啊

1529
01:07:37,000 --> 01:07:42,000
但是我们的团队还是对战斗力还是挺强的

1530
01:07:42,000 --> 01:07:43,000
对 OK

1531
01:07:43,000 --> 01:07:47,000
所以当初你是怎么加入到这个团队里面去

1532
01:07:47,000 --> 01:07:51,000
呃因为当时其实还是到过来还是挺火的

1533
01:07:51,000 --> 01:07:54,000
我也对呃虚拟化

1534
01:07:54,000 --> 01:07:56,000
因为我我毕竟之前是做存储的

1535
01:07:56,000 --> 01:07:59,000
但是我对虚拟化的这块还是比较感兴趣

1536
01:07:59,000 --> 01:08:04,000
所以希望能够呃进入到这个领域吧

1537
01:08:04,000 --> 01:08:08,000
然后嗯看到呃网上有一个招聘吧

1538
01:08:08,000 --> 01:08:13,000
然后大概可能一个想做一个基于虚拟化

1539
01:08:13,000 --> 01:08:16,000
或者基于一个容器的一个 OS

1540
01:08:16,000 --> 01:08:19,000
然后也想深入的去了解一下

1541
01:08:19,000 --> 01:08:21,000
大概就后来就认识了

1542
01:08:21,000 --> 01:08:23,000
然后就就聊聊聊

1543
01:08:23,000 --> 01:08:27,000
当然随着随着随着随着随着社区的变化

1544
01:08:27,000 --> 01:08:29,000
或者说现在的变化

1545
01:08:29,000 --> 01:08:31,000
可能当时的想法慢慢在调整

1546
01:08:31,000 --> 01:08:35,000
然后也做出了现在的产品

1547
01:08:35,000 --> 01:08:36,000
对

1548
01:08:36,000 --> 01:08:39,000
所以你是在哪里看到他们的招聘广告的

1549
01:08:39,000 --> 01:08:41,000
是在 V 2 EX

1550
01:08:41,000 --> 01:08:42,000
啊

1551
01:08:42,000 --> 01:08:43,000
ok

1552
01:08:43,000 --> 01:08:44,000
啊

1553
01:08:44,000 --> 01:08:47,000
V 2 EX 跟我们节目的关系还是挺密切的

1554
01:08:47,000 --> 01:08:51,000
因为我们每次节目都会上面发我们的这个节目介绍和连接

1555
01:08:51,000 --> 01:09:01,000
然后这个 V 2 EX 的这个 LIVIT 也非常呃很 nice 的给我免费在那个 podcast 那个分类里面加了一个测栏的广告啊

1556
01:09:01,000 --> 01:09:02,000
也非常感谢他们

1557
01:09:02,000 --> 01:09:03,000
对

1558
01:09:03,000 --> 01:09:04,000
对

1559
01:09:04,000 --> 01:09:08,000
那这个也是就国内一个比较好的这个程序

1560
01:09:08,000 --> 01:09:09,000
对对对

1561
01:09:09,000 --> 01:09:10,000
开发者的一个社区嘛

1562
01:09:10,000 --> 01:09:11,000
对对对

1563
01:09:11,000 --> 01:09:15,000
其实你在上面能能找到他们也是其实也是意料之内吧

1564
01:09:15,000 --> 01:09:18,000
然后其实之前就一直在关注

1565
01:09:18,000 --> 01:09:21,000
没想到没想到就在那去节远了

1566
01:09:22,000 --> 01:09:23,000
哈哈哈哈

1567
01:09:23,000 --> 01:09:25,000
这个还是挺节远巧合的事

1568
01:09:25,000 --> 01:09:26,000
对对对

1569
01:09:26,000 --> 01:09:28,000
大家是多混这个社区会比较好哈

1570
01:09:28,000 --> 01:09:30,000
对其实这圈子还是挺小的

1571
01:09:30,000 --> 01:09:31,000
ok

1572
01:09:31,000 --> 01:09:34,000
所以你们现在这么一个小五个人的这个开发团队啊

1573
01:09:34,000 --> 01:09:36,000
你们这个工作模式大概是怎么样子呢

1574
01:09:36,000 --> 01:09:37,000
呃

1575
01:09:37,000 --> 01:09:43,000
我们现在的工作模式大概就是相当于我们五个人五个开发

1576
01:09:43,000 --> 01:09:48,000
五个 developer 然后分布在南京上海北京

1577
01:09:48,000 --> 01:09:52,000
然后其实是一个相当于 remote work 的一个工作方式

1578
01:09:52,000 --> 01:09:58,000
大家平常沟通就是 tagram 以及 train of 的一个一种方式

1579
01:09:58,000 --> 01:10:01,000
啊所以其实你们五个人并不是在一个地方的

1580
01:10:01,000 --> 01:10:03,000
对不是在一个地方

1581
01:10:03,000 --> 01:10:05,000
然后你们都是在那那你们会在家里工作吗

1582
01:10:05,000 --> 01:10:07,000
还是去到哪里办公

1583
01:10:07,000 --> 01:10:08,000
主要还是在家里办公

1584
01:10:08,000 --> 01:10:13,000
然后这样的话节省一些交通上的成那时间的成本吧

1585
01:10:13,000 --> 01:10:15,000
啊对对对这个好爽的

1586
01:10:15,000 --> 01:10:18,000
因为就是我都知道每个人的可能最高效的时段是不一样的

1587
01:10:18,000 --> 01:10:22,000
然后浪费在交通上真的是一件非常不爽的事情

1588
01:10:22,000 --> 01:10:26,000
对对对尤其像我在北京这种城市这么大

1589
01:10:26,000 --> 01:10:31,000
然后人及人的这种真是有点难受

1590
01:10:31,000 --> 01:10:36,000
所有的这个写代码的灵感和激情都磨灭在了公交车上

1591
01:10:36,000 --> 01:10:38,000
对对对对所以呃

1592
01:10:38,000 --> 01:10:43,000
呃当然远程办公其实是当然也是比较吸引我的一种方式

1593
01:10:43,000 --> 01:10:47,000
大家希望能够更更高效的去利用时间吧

1594
01:10:47,000 --> 01:10:51,000
ok 那所以你们五个人在这个远程工作中

1595
01:10:51,000 --> 01:10:54,000
你刚才提到了有这个 telegram 这个用来实施

1596
01:10:54,000 --> 01:10:56,000
这个是群组聊天对吧对

1597
01:10:56,000 --> 01:10:59,000
然后还有一样那个是哎是用那个什么工具来干

1598
01:10:59,000 --> 01:11:01,000
呃 trylo

1599
01:11:01,000 --> 01:11:04,000
trylo 做那个协作

1600
01:11:04,000 --> 01:11:07,000
对协作对所以呢你们像代码管理啊

1601
01:11:07,000 --> 01:11:09,000
还有其他一些工具大概是会用到哪些呢

1602
01:11:09,000 --> 01:11:12,000
呃代码管理的话就是 github

1603
01:11:12,000 --> 01:11:13,000
ok

1604
01:11:13,000 --> 01:11:17,000
对然后我们之前是呃发布之前是 private 的 repo

1605
01:11:17,000 --> 01:11:22,000
然后现在是公开了大家也可以去我们的官网上

1606
01:11:22,000 --> 01:11:26,000
以及去 github 的网页上面去关注我们的项目多多点赞

1607
01:11:26,000 --> 01:11:28,000
okok 那个那个项目的项目是什么工具

1608
01:11:28,000 --> 01:11:31,000
那个那个项目的地址还包括 github 的地址

1609
01:11:31,000 --> 01:11:34,000
我们会稍后放到这个 show notes 里面大家就可以看好

1610
01:11:34,000 --> 01:11:40,000
嗯这里可以其实可以接着聊一下就是你们这个这个在 github 上面协作的模式

1611
01:11:40,000 --> 01:11:43,000
你们是一个会说一个大概是一种什么样的过程呢

1612
01:11:43,000 --> 01:11:44,000
可以大概描述一下吗

1613
01:11:44,000 --> 01:11:51,000
呃呃目前的过程呢就是相当于已经过了之前的蜂蜜开发的一个过程

1614
01:11:51,000 --> 01:11:57,000
所以现在的呃进进进派持的模式呢还是跟呃比较比较正

1615
01:11:57,000 --> 01:11:59,000
比较比较正就比较正规吧

1616
01:11:59,000 --> 01:12:00,000
嗯

1617
01:12:00,000 --> 01:12:02,000
有了派持的话是 tpr

1618
01:12:02,000 --> 01:12:09,000
然后呃呃一到两个人去旅游如果没问题的话才可以磨制

1619
01:12:09,000 --> 01:12:13,000
这样的话就保证了质量以及呃效率

1620
01:12:13,000 --> 01:12:19,000
然后会有一些第三方的工具呃就是就是我们会写也写了一些脚本

1621
01:12:19,000 --> 01:12:30,000
当然没有也也在不断的完善过程中希望能够在呃有 pr 的时候呃出发一些正常化的检测等等一些工具

1622
01:12:30,000 --> 01:12:35,000
OK 所以就大致来说就还是一个标准的一个 github 开源项目的流程

1623
01:12:35,000 --> 01:12:39,000
对喔

1624
01:12:39,000 --> 01:12:43,000
通过 pr 驱动这个这个 dancedrout

1625
01:12:43,000 --> 01:12:44,000
还有ободfax

1626
01:12:45,000 --> 01:12:46,000
欸呃呃导

1627
01:12:46,000 --> 01:12:48,000
就比 akatrout

1628
01:12:48,000 --> 01:12:53,000
这个 field

1629
01:12:53,000 --> 01:12:54,000
咱看你的时候你们去还没有做完全自动化的 qa 是吧

1630
01:12:54,000 --> 01:12:55,000
对

1631
01:12:55,000 --> 01:12:57,000
都会做这是标配

1632
01:12:57,000 --> 01:13:00,000
然后因为 Go 本身做过

1633
01:13:00,000 --> 01:13:01,000
它有 Unitas

1634
01:13:01,000 --> 01:13:02,000
所以这个的话

1635
01:13:02,000 --> 01:13:04,000
因为当时开发时间比较紧

1636
01:13:04,000 --> 01:13:05,000
然后我们这个

1637
01:13:05,000 --> 01:13:08,000
有的一些 component

1638
01:13:08,000 --> 01:13:09,000
可能没有太完善

1639
01:13:09,000 --> 01:13:11,000
所以这个也在不断完善

1640
01:13:11,000 --> 01:13:13,000
就这个可能需要

1641
01:13:13,000 --> 01:13:14,000
就你们一个一方面

1642
01:13:14,000 --> 01:13:15,000
你们自己努力

1643
01:13:15,000 --> 01:13:16,000
另一方面就是看

1644
01:13:16,000 --> 01:13:17,000
能不能开完社区

1645
01:13:17,000 --> 01:13:18,000
能贡献一些了

1646
01:13:18,000 --> 01:13:19,000
对对对

1647
01:13:19,000 --> 01:13:21,000
因为我们的人手实在是太少

1648
01:13:21,000 --> 01:13:23,000
有意思

1649
01:13:23,000 --> 01:13:25,000
这里刚才你也提到了

1650
01:13:25,000 --> 01:13:27,000
这个 Hyper 跟 Docker 一样

1651
01:13:27,000 --> 01:13:29,000
都是基于用够语言开发的

1652
01:13:29,000 --> 01:13:30,000
就是当初你们

1653
01:13:30,000 --> 01:13:32,000
为什么选择用够语言呢

1654
01:13:32,000 --> 01:13:34,000
我们之前选择的够语言

1655
01:13:34,000 --> 01:13:38,000
其实也是考虑到了

1656
01:13:38,000 --> 01:13:41,000
跟 Docker 的一个关系

1657
01:13:41,000 --> 01:13:45,000
因为就抛开够语言

1658
01:13:45,000 --> 01:13:45,000
本身的一些特性

1659
01:13:45,000 --> 01:13:46,000
比如并发

1660
01:13:46,000 --> 01:13:48,000
它的高效的开发

1661
01:13:48,000 --> 01:13:49,000
等等一些特性

1662
01:13:49,000 --> 01:13:50,000
另外一方面就是

1663
01:13:50,000 --> 01:13:53,000
我们其实最开始的版本

1664
01:13:53,000 --> 01:13:55,000
是基于 DockerDemon 来做的

1665
01:13:55,000 --> 01:13:58,000
然后因为 DockerDemon 会

1666
01:13:58,000 --> 01:14:02,000
因为我们用到 DockerDemon 去

1667
01:14:02,000 --> 01:14:05,000
曝他的 Docker 的 image

1668
01:14:05,000 --> 01:14:07,000
曝下来

1669
01:14:07,000 --> 01:14:10,000
然后去把这个文件

1670
01:14:10,000 --> 01:14:12,000
全部传给 Hypervisor

1671
01:14:12,000 --> 01:14:13,000
然后这个过程中的

1672
01:14:13,000 --> 01:14:14,000
可能用够语言

1673
01:14:14,000 --> 01:14:16,000
直接跟 DockerDemon 去交互

1674
01:14:16,000 --> 01:14:18,000
这样的话是更省事

1675
01:14:18,000 --> 01:14:18,000
更简单

1676
01:14:18,000 --> 01:14:20,000
对

1677
01:14:20,000 --> 01:14:25,000
但是随着后来我们移除了 Docker 的 Demon

1678
01:14:25,000 --> 01:14:26,000
的一个依赖

1679
01:14:26,000 --> 01:14:28,000
其实用其他语言

1680
01:14:28,000 --> 01:14:29,000
当然也可以

1681
01:14:29,000 --> 01:14:32,000
就是可能也历史原因问题

1682
01:14:32,000 --> 01:14:34,000
就是我们继续沿用了这个 Go 语言

1683
01:14:34,000 --> 01:14:35,000
OK

1684
01:14:35,000 --> 01:14:38,000
那所以其实你们在这个使用 Go

1685
01:14:38,000 --> 01:14:40,000
写这个 Hyper 过程中

1686
01:14:40,000 --> 01:14:41,000
你们遇到了什么样的问题

1687
01:14:41,000 --> 01:14:43,000
或者有什么心得可以分享吗

1688
01:14:43,000 --> 01:14:46,000
其实 Go 语言还是

1689
01:14:46,000 --> 01:14:48,000
从语法上还是有些坑的

1690
01:14:48,000 --> 01:14:50,000
然后比如说呢

1691
01:14:50,000 --> 01:14:53,000
比如说写 Go 写时间长

1692
01:14:53,000 --> 01:14:55,000
写 C 都不加分号

1693
01:14:55,000 --> 01:14:58,000
这个是好事

1694
01:14:58,000 --> 01:15:00,000
好吧

1695
01:15:00,000 --> 01:15:04,000
然后另外一些可能就是

1696
01:15:04,000 --> 01:15:05,000
本身够远

1697
01:15:05,000 --> 01:15:09,000
因为它最近刚发布的是 1.6 吧

1698
01:15:09,000 --> 01:15:09,000
还是之前是

1699
01:15:09,000 --> 01:15:11,000
1.5 应该是

1700
01:15:11,000 --> 01:15:12,000
对 1.5

1701
01:15:12,000 --> 01:15:13,000
然后 1.5 的一个版本

1702
01:15:13,000 --> 01:15:15,000
它其实有一些东西

1703
01:15:15,000 --> 01:15:17,000
还是做的不够完善的

1704
01:15:17,000 --> 01:15:19,000
然后我们这过程中

1705
01:15:19,000 --> 01:15:21,000
也是踩了不少坑

1706
01:15:21,000 --> 01:15:23,000
然后用其他方式去转换

1707
01:15:23,000 --> 01:15:24,000
但是可能下轨上面

1708
01:15:24,000 --> 01:15:26,000
不如那个有优势

1709
01:15:26,000 --> 01:15:27,000
但是这个可能就是

1710
01:15:27,000 --> 01:15:28,000
OS 相关的东西

1711
01:15:28,000 --> 01:15:30,000
比如在 Mac 上面的一些

1712
01:15:30,000 --> 01:15:31,000
特性它够远

1713
01:15:31,000 --> 01:15:33,000
是调用内核的一些东西

1714
01:15:33,000 --> 01:15:34,000
还是什么

1715
01:15:34,000 --> 01:15:36,000
Cisco 的东西

1716
01:15:36,000 --> 01:15:37,000
OK

1717
01:15:37,000 --> 01:15:39,000
支持的不够完整

1718
01:15:39,000 --> 01:15:39,000
OK

1719
01:15:39,000 --> 01:15:41,000
然后所以就必须用

1720
01:15:41,000 --> 01:15:42,000
其他一种更加

1721
01:15:42,000 --> 01:15:45,000
tricky 的方式去做

1722
01:15:45,000 --> 01:15:46,000
啊

1723
01:15:46,000 --> 01:15:47,000
明白明白

1724
01:15:47,000 --> 01:15:48,000
对对对

1725
01:15:48,000 --> 01:15:49,000
所以其实像 Hyper

1726
01:15:49,000 --> 01:15:51,000
除了用 Go 语言写大部分之外

1727
01:15:51,000 --> 01:15:52,000
你们还用到其他语言

1728
01:15:52,000 --> 01:15:54,000
去编写其他一些

1729
01:15:54,000 --> 01:15:55,000
小部分的功能吗

1730
01:15:55,000 --> 01:15:56,000
还是说是一个

1731
01:15:56,000 --> 01:15:57,000
纯 Go 的一个项目

1732
01:15:57,000 --> 01:16:00,000
我们在 GasOS 里面是

1733
01:16:00,000 --> 01:16:02,000
C 的东西

1734
01:16:02,000 --> 01:16:02,000
哦

1735
01:16:02,000 --> 01:16:03,000
那部分是

1736
01:16:03,000 --> 01:16:05,000
就需要做哪些工作

1737
01:16:05,000 --> 01:16:06,000
是要用 C 来

1738
01:16:06,000 --> 01:16:07,000
必须要用 C 来完成的

1739
01:16:07,000 --> 01:16:08,000
呃

1740
01:16:08,000 --> 01:16:09,000
其实也不是说

1741
01:16:09,000 --> 01:16:10,000
必须要用 C 来完成

1742
01:16:10,000 --> 01:16:11,000
只不过用 C

1743
01:16:11,000 --> 01:16:12,000
可能效率更快一点

1744
01:16:12,000 --> 01:16:13,000
GasOS 里面

1745
01:16:13,000 --> 01:16:14,000
它其实就是一个

1746
01:16:14,000 --> 01:16:16,000
嗯

1747
01:16:16,000 --> 01:16:17,000
增

1748
01:16:17,000 --> 01:16:17,000
就是

1749
01:16:17,000 --> 01:16:19,000
呃

1750
01:16:19,000 --> 01:16:20,000
相当于修改过的

1751
01:16:20,000 --> 01:16:20,000
Unit

1752
01:16:20,000 --> 01:16:21,000
Unit

1753
01:16:21,000 --> 01:16:21,000
Unit

1754
01:16:21,000 --> 01:16:21,000
Unit

1755
01:16:21,000 --> 01:16:21,000
程序

1756
01:16:21,000 --> 01:16:24,000
然后它它是可以解析

1757
01:16:24,000 --> 01:16:25,000
Json 格式

1758
01:16:25,000 --> 01:16:25,000
因为它这样

1759
01:16:25,000 --> 01:16:27,000
这样的话是通过

1760
01:16:27,000 --> 01:16:30,000
Json 的那个信消息来跟

1761
01:16:30,000 --> 01:16:31,000
呃

1762
01:16:31,000 --> 01:16:32,000
Hyperdemon 去交互

1763
01:16:32,000 --> 01:16:33,000
哦

1764
01:16:33,000 --> 01:16:35,000
达到一个传输数据

1765
01:16:35,000 --> 01:16:37,000
或者是通信的效果

1766
01:16:37,000 --> 01:16:37,000
哎

1767
01:16:37,000 --> 01:16:38,000
这个有点意思啊

1768
01:16:38,000 --> 01:16:39,000
就是你们这个

1769
01:16:39,000 --> 01:16:40,000
GasOS 里面还有一个

1770
01:16:40,000 --> 01:16:42,000
自己定义的 Unit 程序

1771
01:16:42,000 --> 01:16:44,000
这个好像现在啊

1772
01:16:44,000 --> 01:16:46,000
好像比较常见的就是那个 System

1773
01:16:46,000 --> 01:16:47,000
System 低对吧

1774
01:16:47,000 --> 01:16:48,000
所以比较重吗

1775
01:16:48,000 --> 01:16:49,000
什么原因

1776
01:16:49,000 --> 01:16:50,000
呃

1777
01:16:50,000 --> 01:16:50,000
对

1778
01:16:50,000 --> 01:16:52,000
可能速度比较快吧

1779
01:16:52,000 --> 01:16:53,000
对对对对

1780
01:16:53,000 --> 01:16:55,000
速度比那个就比较重

1781
01:16:55,000 --> 01:16:56,000
然后我们这儿

1782
01:16:56,000 --> 01:16:58,000
用启动速度会很很慢

1783
01:16:58,000 --> 01:16:59,000
然后

1784
01:16:59,000 --> 01:16:59,000
OK

1785
01:16:59,000 --> 01:17:00,000
呃

1786
01:17:00,000 --> 01:17:00,000
呃

1787
01:17:00,000 --> 01:17:02,000
我们当时测的时候

1788
01:17:02,000 --> 01:17:04,000
大概十几兆或

1789
01:17:04,000 --> 01:17:06,000
二应该是二十几兆的那个空

1790
01:17:06,000 --> 01:17:08,000
的 memory 就够了

1791
01:17:08,000 --> 01:17:09,000
OK

1792
01:17:09,000 --> 01:17:09,000
对

1793
01:17:09,000 --> 01:17:11,000
所以就足够的精简

1794
01:17:11,000 --> 01:17:12,000
足够的小

1795
01:17:12,000 --> 01:17:14,000
就是现在一个 Hyper 的 GasVM

1796
01:17:14,000 --> 01:17:16,000
用你们自定义这套东西

1797
01:17:16,000 --> 01:17:17,000
就一二十兆就可以起一个了

1798
01:17:17,000 --> 01:17:18,000
对吧

1799
01:17:18,000 --> 01:17:19,000
对应该是二十多兆

1800
01:17:19,000 --> 01:17:19,000
二十多兆

1801
01:17:19,000 --> 01:17:21,000
是一兆是不够的

1802
01:17:21,000 --> 01:17:22,000
对相对于很多这个什么

1803
01:17:22,000 --> 01:17:23,000
特别是他跑

1804
01:17:23,000 --> 01:17:24,000
他们 Tomcat 啊

1805
01:17:24,000 --> 01:17:25,000
这些家伙应有

1806
01:17:25,000 --> 01:17:27,000
一上来都一两个机的那层站

1807
01:17:27,000 --> 01:17:27,000
对

1808
01:17:27,000 --> 01:17:28,000
这个当然我们说

1809
01:17:28,000 --> 01:17:30,000
它是一个最最最简模式

1810
01:17:30,000 --> 01:17:31,000
对对对

1811
01:17:31,000 --> 01:17:31,000
如果

1812
01:17:31,000 --> 01:17:33,000
这是一个就是说

1813
01:17:33,000 --> 01:17:34,000
就我就说这种一二十兆的开销

1814
01:17:34,000 --> 01:17:35,000
基本上可以

1815
01:17:35,000 --> 01:17:37,000
在现代机上可以忽略了吧

1816
01:17:37,000 --> 01:17:38,000
对对对

1817
01:17:38,000 --> 01:17:39,000
那还是挺好的

1818
01:17:39,000 --> 01:17:39,000
挺好的

1819
01:17:39,000 --> 01:17:39,000
嗯

1820
01:17:39,000 --> 01:17:41,000
最最后补充的就是希望

1821
01:17:41,000 --> 01:17:44,000
大家有志于加入我们 Hyper 项目的

1822
01:17:44,000 --> 01:17:48,000
能够多多为我们提 PR

1823
01:17:48,000 --> 01:17:50,000
我们也会非常也会非常积极的反馈

1824
01:17:50,000 --> 01:17:53,000
如果有同学提 PR

1825
01:17:53,000 --> 01:17:55,000
或者说被我们接受的话

1826
01:17:55,000 --> 01:18:01,000
我们在初期前一百人应该会提供 T 恤作为奖励

1827
01:18:01,000 --> 01:18:03,000
就是我就是之前

1828
01:18:03,000 --> 01:18:06,000
Rio 之前在推特上面穿过的那个 T 恤

1829
01:18:06,000 --> 01:18:07,000
哈哈哈哈

1830
01:18:07,000 --> 01:18:12,000
对那个之前我在北京跟跟 Simon

1831
01:18:12,000 --> 01:18:13,000
就是见面面聊过哈

1832
01:18:13,000 --> 01:18:16,000
然后非常厚颜无耻的要了一件

1833
01:18:16,000 --> 01:18:17,000
没没没

1834
01:18:17,000 --> 01:18:22,000
这个这个也也是感谢 Rio 帮我们去大力的宣传

1835
01:18:22,000 --> 01:18:26,000
然后也是希望能更多的开发者去接触到开源社区

1836
01:18:26,000 --> 01:18:27,000
接触到开源项目

1837
01:18:27,000 --> 01:18:31,000
然后更多更更就是怎么说呢

1838
01:18:31,000 --> 01:18:34,000
就是一个提升一个自身素质

1839
01:18:34,000 --> 01:18:38,000
加一个写代码功益的一个水平吧

1840
01:18:38,000 --> 01:18:39,000
啊对对非常感谢

1841
01:18:39,000 --> 01:18:43,000
就是其实因为这次我邀请三人来做这节目

1842
01:18:43,000 --> 01:18:45,000
也是因为我觉得 Hyper 是我见过的

1843
01:18:45,000 --> 01:18:48,000
就是国人做的这个开源项目里面

1844
01:18:48,000 --> 01:18:50,000
还比较让我惊艳的一个嘛

1845
01:18:50,000 --> 01:18:52,000
所以我也希望借这个机会

1846
01:18:52,000 --> 01:18:53,000
让邀请到

1847
01:18:53,000 --> 01:18:55,000
就是让他让更多人了解他

1848
01:18:55,000 --> 01:18:56,000
知道他

1849
01:18:56,000 --> 01:18:57,000
然后能够去参与到这个开发

1850
01:18:57,000 --> 01:18:59,000
让我们这个中国的开源项目

1851
01:18:59,000 --> 01:19:02,000
能够有一个好的这个一个

1852
01:19:02,000 --> 01:19:05,000
这个上涨的趋势吧

1853
01:19:05,000 --> 01:19:07,000
对然后另外一点

1854
01:19:07,000 --> 01:19:11,000
如果大家不不觉得 TPR 不爽的话

1855
01:19:11,000 --> 01:19:14,000
也是非常希望大家能够加入到我们的团队

1856
01:19:14,000 --> 01:19:18,000
我们团队也是拥有非常多的牛人

1857
01:19:18,000 --> 01:19:21,000
然后多年的 Colonel 的工程师

1858
01:19:21,000 --> 01:19:24,000
以及特别资深的 Consultant

1859
01:19:24,000 --> 01:19:27,000
都都都在我们团队

1860
01:19:27,000 --> 01:19:30,000
所以如果大家有一技之长

1861
01:19:30,000 --> 01:19:34,000
或者说呃有志于做 Hyper Stack

1862
01:19:34,000 --> 01:19:38,000
Hyper 项目的希望大家能够积极给我们提

1863
01:19:38,000 --> 01:19:41,000
呃 TPR 或者是发简历

1864
01:19:41,000 --> 01:19:41,000
谢谢

1865
01:19:41,000 --> 01:19:44,000
想不到 B 节目还做了一个猎头的工作

1866
01:19:44,000 --> 01:19:48,000
非常非常好玩

1867
01:19:48,000 --> 01:19:51,000
OK 今天的节目就先到这里

1868
01:19:51,000 --> 01:19:53,000
感谢收听 IPN Podcast

1869
01:19:53,000 --> 01:19:55,000
网络之下的 IT 技术主题娱乐节目

1870
01:19:55,000 --> 01:19:56,000
内核恐慌

1871
01:19:56,000 --> 01:19:58,000
我们号称 Hardcore

1872
01:19:58,000 --> 01:19:59,000
但也没有干货

1873
01:19:59,000 --> 01:20:00,000
但是这期干货还是满满的

1874
01:20:00,000 --> 01:20:02,000
想听的人听

1875
01:20:02,000 --> 01:20:03,000
不想听的人就别听

1876
01:20:03,000 --> 01:20:05,000
你可以问本节目捐款

1877
01:20:05,000 --> 01:20:07,000
捐款地址是 ipn.li

1878
01:20:07,000 --> 01:20:09,000
slashkernalpanicslashdonate

1879
01:20:09,000 --> 01:20:11,000
捐款金额随意

1880
01:20:11,000 --> 01:20:13,000
只要是能备 8 整出的正整数就可以

1881
01:20:13,000 --> 01:20:15,000
捐款不会给你带来什么

1882
01:20:15,000 --> 01:20:17,000
不捐也不会让你失去什么

1883
01:20:17,000 --> 01:20:19,000
我们的口号是 Hyper is Hyper Awesome

1884
01:20:19,000 --> 01:20:21,000
如果你有任何反馈

1885
01:20:21,000 --> 01:20:22,000
可以发电子邮件到

1886
01:20:22,000 --> 01:20:25,000
kernalpanic at ipn.li

1887
01:20:25,000 --> 01:20:28,000
同时也欢迎你收听 IPN 旗下

1888
01:20:28,000 --> 01:20:29,000
其他几档节目

1889
01:20:29,000 --> 01:20:30,000
IT 公论

1890
01:20:30,000 --> 01:20:31,000
未知到

1891
01:20:31,000 --> 01:20:32,000
太一来了

1892
01:20:32,000 --> 01:20:33,000
流行通信

1893
01:20:33,000 --> 01:20:34,000
HiStory

1894
01:20:34,000 --> 01:20:35,000
博物质

1895
01:20:35,000 --> 01:20:36,000
选美

1896
01:20:36,000 --> 01:20:37,000
我们下期再会

1897
01:20:37,000 --> 01:20:39,000
agare

1898
01:20:43,000 --> 01:20:44,000
快扶了

1899
01:20:44,000 --> 01:20:45,000
你

