1
00:00:00,000 --> 00:00:04,000
欢迎收听 IPN Podcast 的网络旗下的 IT 技术主题娱乐节目

2
00:00:04,000 --> 00:00:05,000
内核恐慌

3
00:00:05,000 --> 00:00:06,000
我们号称 hardcore 啊

4
00:00:06,000 --> 00:00:07,000
但是也没有干货

5
00:00:07,000 --> 00:00:08,000
想听人听

6
00:00:08,000 --> 00:00:10,000
不想听的人就别听

7
00:00:10,000 --> 00:00:13,000
内核恐慌的网址是 ipn.li.com

8
00:00:13,000 --> 00:00:18,000
我们推荐大家使用 Podcast 客户端订阅节目

9
00:00:18,000 --> 00:00:20,000
如果您不知道该使用哪种客户端

10
00:00:20,000 --> 00:00:22,000
欢迎访问 ipn.li.com

11
00:00:22,000 --> 00:00:26,000
也同样欢迎你为我们的节目捐款

12
00:00:26,000 --> 00:00:28,000
捐款地址是 ipn.li.com

13
00:00:28,000 --> 00:00:30,000
cernelpanic.com

14
00:00:30,000 --> 00:00:33,000
捐款金额随意

15
00:00:33,000 --> 00:00:35,000
只要是能被 8 整出的正正数就可以

16
00:00:35,000 --> 00:00:37,000
捐款不会为你带来什么

17
00:00:37,000 --> 00:00:39,000
不捐也不会让你失去什么

18
00:00:39,000 --> 00:00:42,000
我们的口号是 no hot feelings

19
00:00:42,000 --> 00:00:47,000
所以我们今天是第 20 期

20
00:00:47,000 --> 00:00:49,000
居然都已经 20 期了

21
00:00:49,000 --> 00:00:52,000
一晃已经过去 40 周了

22
00:00:52,000 --> 00:00:53,000
小半年

23
00:00:53,000 --> 00:00:54,000
不对大半年

24
00:00:54,000 --> 00:00:55,000
快一年

25
00:00:55,000 --> 00:00:56,000
对

26
00:00:56,000 --> 00:01:00,000
还是做一些简单的 follow up 吧

27
00:01:00,000 --> 00:01:01,000
对我们今天

28
00:01:01,000 --> 00:01:03,000
我们两个人今天

29
00:01:03,000 --> 00:01:04,000
状态都不太好

30
00:01:04,000 --> 00:01:06,000
状况都不太正常

31
00:01:06,000 --> 00:01:08,000
一个是不停地打分离

32
00:01:08,000 --> 00:01:09,000
另一个得奄言

33
00:01:09,000 --> 00:01:11,000
基本上说话一块就会咳嗽

34
00:01:11,000 --> 00:01:16,000
所以我们今天可能就不会讲太多的话

35
00:01:16,000 --> 00:01:22,000
但应该会跳过新闻单元吧

36
00:01:22,000 --> 00:01:24,000
所以对就从 follow up 开始

37
00:01:24,000 --> 00:01:26,000
对

38
00:01:26,000 --> 00:01:26,000
对

39
00:01:26,000 --> 00:01:27,000
在 follow up 之前

40
00:01:27,000 --> 00:01:29,000
先说一下

41
00:01:29,000 --> 00:01:34,000
上周我们找听众帮我们去排查

42
00:01:34,000 --> 00:01:36,000
为什么下载会出错那个问题吗

43
00:01:36,000 --> 00:01:37,000
你还记得

44
00:01:37,000 --> 00:01:37,000
对

45
00:01:37,000 --> 00:01:38,000
对

46
00:01:38,000 --> 00:01:41,000
我们现在终于找到了一个鲜活的案例

47
00:01:41,000 --> 00:01:45,000
对有一位非常热心的听众

48
00:01:45,000 --> 00:01:51,000
极端及时的校门爆出了 bug 的味的

49
00:01:51,000 --> 00:01:53,000
怎么说呢

50
00:01:53,000 --> 00:01:55,000
这位同学遇到了这个 bug

51
00:01:55,000 --> 00:01:57,000
然后及时给我们写了邮件

52
00:01:57,000 --> 00:02:00,000
并且我们趁这个 bug 还鲜活的时候

53
00:02:00,000 --> 00:02:02,000
给它捉住了

54
00:02:02,000 --> 00:02:02,000
对

55
00:02:02,000 --> 00:02:04,000
从他那里

56
00:02:04,000 --> 00:02:07,000
issue 了一个 CURL 的命令

57
00:02:07,000 --> 00:02:10,000
然后及时发现了这个 bug 的一个所在

58
00:02:10,000 --> 00:02:13,000
所以要解释一下成因吗

59
00:02:13,000 --> 00:02:15,000
对我这个肯定要解释一下

60
00:02:15,000 --> 00:02:18,000
好不容易捉住一个虫子是吧

61
00:02:18,000 --> 00:02:20,000
简单来讲是这样

62
00:02:20,000 --> 00:02:23,000
就是国内的部分运营商

63
00:02:23,000 --> 00:02:27,000
当然这里部分运营商主要是以长城宽带这种

64
00:02:27,000 --> 00:02:30,000
这种叫什么来着

65
00:02:30,000 --> 00:02:33,000
二道贩子运营商为主

66
00:02:33,000 --> 00:02:35,000
然后他们

67
00:02:35,000 --> 00:02:36,000
supcontract

68
00:02:36,000 --> 00:02:37,000
对

69
00:02:37,000 --> 00:02:41,000
他们这个为了减缓他们网络的压力

70
00:02:41,000 --> 00:02:42,000
因为他买的贷款有限

71
00:02:42,000 --> 00:02:45,000
然后他们自己在内部做了一个缓存

72
00:02:45,000 --> 00:02:47,000
比如说凡是你下载一些比较

73
00:02:47,000 --> 00:02:50,000
通过 HTCP 协议下载了一些比较大型的文件

74
00:02:50,000 --> 00:02:51,000
他们会

75
00:02:51,000 --> 00:02:56,000
在他们内部的一个服务器上缓存下来

76
00:02:56,000 --> 00:02:56,000
这样的话

77
00:02:56,000 --> 00:02:59,000
如果假设有 100 个长宽的用户

78
00:02:59,000 --> 00:03:01,000
都去请求那一个文件的话

79
00:03:01,000 --> 00:03:06,000
他只有第一个人的时候会去下载

80
00:03:06,000 --> 00:03:08,000
从原那里拿那个文件

81
00:03:08,000 --> 00:03:09,000
然后后面的 99 个人

82
00:03:09,000 --> 00:03:11,000
都是从长宽自己的服务器走了

83
00:03:11,000 --> 00:03:12,000
这样的话

84
00:03:12,000 --> 00:03:16,000
因为长宽内部到他自己客户的这边网络的

85
00:03:16,000 --> 00:03:18,000
这个贷款是比较充足的

86
00:03:18,000 --> 00:03:21,000
但长宽去到别的网络的贷款是比较下

87
00:03:21,000 --> 00:03:22,000
比较拥堵的嘛

88
00:03:22,000 --> 00:03:25,000
所以通过这种缓存的方法

89
00:03:25,000 --> 00:03:28,000
他们可以用一个比较小的

90
00:03:28,000 --> 00:03:30,000
就比较便宜的

91
00:03:30,000 --> 00:03:33,000
就去外面贷款去支撑足够多的用户

92
00:03:33,000 --> 00:03:35,000
从而降低他们的这个成本嘛

93
00:03:35,000 --> 00:03:38,000
这个做法本来倒也没什么

94
00:03:38,000 --> 00:03:40,000
很多公司啊

95
00:03:40,000 --> 00:03:41,000
也是这么干的

96
00:03:41,000 --> 00:03:43,000
之前我在知乎的时候

97
00:03:43,000 --> 00:03:44,000
我们也是这么用的

98
00:03:44,000 --> 00:03:48,000
就是在网关上会做这么一个透明缓存

99
00:03:48,000 --> 00:03:51,000
然后到时候那些下载过的文件大家可以共享

100
00:03:51,000 --> 00:03:54,000
就特别是因为最主要痛点是每年一次

101
00:03:54,000 --> 00:03:55,000
那个 90 月份

102
00:03:55,000 --> 00:03:58,000
苹果发布新的 OS 10 或者 iOS 的时候

103
00:03:58,000 --> 00:04:03,000
会把那个公司的出口贷款给撑爆嘛

104
00:04:03,000 --> 00:04:05,000
做了这个之后大家觉得

105
00:04:05,000 --> 00:04:06,000
好下载好快啊

106
00:04:06,000 --> 00:04:09,000
而且公司出口贷款也不怎么受影响

107
00:04:09,000 --> 00:04:14,000
那这个就是说一个在公司级别和长宽中

108
00:04:14,000 --> 00:04:15,000
在运营商级别是做同样的事情

109
00:04:15,000 --> 00:04:16,000
对吧

110
00:04:16,000 --> 00:04:17,000
对

111
00:04:17,000 --> 00:04:19,000
问题在哪呢

112
00:04:19,000 --> 00:04:21,000
实现的太二了

113
00:04:21,000 --> 00:04:25,000
他们的这个这个缓存系统都是我真是无力吐槽了

114
00:04:25,000 --> 00:04:34,000
简单来讲我们缓存的一个 URL 一个是文件应该说是你一个 URL 对应的一个文件可能就是这么一个

115
00:04:34,000 --> 00:04:37,000
就是它的唯一标识符是一个完整的 URL 对吧

116
00:04:37,000 --> 00:04:43,000
比如说我们的那个存放的那个路径可能是这个 IPN.LI 斜杠

117
00:04:43,000 --> 00:04:46,000
然后什么假设目录是 CernalPanic

118
00:04:46,000 --> 00:04:50,000
然后又斜杠文件名是 EP 假设是就是 27 吧

119
00:04:50,000 --> 00:04:53,000
EP 20.MP 3 这么一个文件对吧

120
00:04:53,000 --> 00:04:53,000
对

121
00:04:53,000 --> 00:04:56,000
那你做缓存的时候是不是应该说啊

122
00:04:56,000 --> 00:05:00,000
我把这个 URL 完整的就是复制

123
00:05:00,000 --> 00:05:04,000
就是作为这个文件在这个缓存系统里面的一个标识符对吧

124
00:05:04,000 --> 00:05:07,000
就包括我们的这个域名 IPN.LI

125
00:05:07,000 --> 00:05:11,000
包括它的这个路径 CernalPanic

126
00:05:11,000 --> 00:05:16,000
包括它文件名 EP 20.MP 3 对吧

127
00:05:16,000 --> 00:05:18,000
对一个正常人类会这样实现

128
00:05:18,000 --> 00:05:19,000
对正常人类

129
00:05:19,000 --> 00:05:22,000
不然的话你说如果正常的是这么想的没问题

130
00:05:22,000 --> 00:05:25,000
但是我们发现就根据我们这个常

131
00:05:25,000 --> 00:05:29,000
我们帮助这个帮助我们热心出虫的

132
00:05:29,000 --> 00:05:31,000
这位听众给我反馈来看

133
00:05:31,000 --> 00:05:35,000
长宽的那个缓存系统完全不是这么弄的

134
00:05:35,000 --> 00:05:37,000
他只选择了两个信息

135
00:05:37,000 --> 00:05:37,000
文件名

136
00:05:37,000 --> 00:05:38,000
一个是域名

137
00:05:38,000 --> 00:05:39,000
一个是文件名

138
00:05:39,000 --> 00:05:43,000
他把中间的那个文件路径给漏掉了

139
00:05:43,000 --> 00:05:43,000
对

140
00:05:43,000 --> 00:05:47,000
他假设美台服务器上所有的文件都是独一无二的

141
00:05:47,000 --> 00:05:49,000
所有的文件名都是独一无二的

142
00:05:49,000 --> 00:05:50,000
不管它处在哪个路径之下

143
00:05:50,000 --> 00:05:51,000
对

144
00:05:51,000 --> 00:05:53,000
然后碰巧呢

145
00:05:53,000 --> 00:05:57,000
我们这个节目的文件名名都比较一致对吧

146
00:05:57,000 --> 00:05:59,000
我们就说 Carnal Panic

147
00:05:59,000 --> 00:06:01,000
谁干 EP 20.mp 3

148
00:06:01,000 --> 00:06:03,000
是这个我们这一期节目的

149
00:06:03,000 --> 00:06:05,000
但是同样的对于这个假设 IT 公论

150
00:06:05,000 --> 00:06:07,000
它也有第二十期啊

151
00:06:07,000 --> 00:06:09,000
那是 IT 公论谁干 EP 20.mp 3

152
00:06:09,000 --> 00:06:11,000
然后碰巧呢

153
00:06:11,000 --> 00:06:13,000
我们又是同一个域名下面的吧

154
00:06:13,000 --> 00:06:15,000
IPn.li 下面的对吧

155
00:06:15,000 --> 00:06:18,000
在长宽的这个缓存代理

156
00:06:18,000 --> 00:06:19,000
这么一过呢

157
00:06:19,000 --> 00:06:20,000
就会发现

158
00:06:20,000 --> 00:06:24,000
都是 EP 20.mp 3 这个文件哦

159
00:06:24,000 --> 00:06:25,000
他们肯定应该是一个吧

160
00:06:25,000 --> 00:06:27,000
然后他就默默的

161
00:06:27,000 --> 00:06:32,000
把 IT 公论的这个第二十期的那个音频文件

162
00:06:32,000 --> 00:06:36,000
当做了 Carnal Panic 的二十期文件

163
00:06:36,000 --> 00:06:38,000
给发回给你的那个那个叫什么

164
00:06:38,000 --> 00:06:41,000
你的那个浏览器或者是你的播客户端了

165
00:06:41,000 --> 00:06:45,000
于是就会出现我们之前很多人遇到的这个所谓的串台的现象

166
00:06:45,000 --> 00:06:48,000
就是明明下的是怎么听着太一怎么变成了未知道

167
00:06:48,000 --> 00:06:50,000
或者是听着什么流行通讯

168
00:06:50,000 --> 00:06:52,000
怎么变成了其他的什么节目

169
00:06:52,000 --> 00:06:54,000
对就这种诡异的事情

170
00:06:54,000 --> 00:06:58,000
我已经无理吐槽

171
00:06:58,000 --> 00:06:59,000
吴涛你接着说

172
00:06:59,000 --> 00:07:01,000
其实我在想说

173
00:07:01,000 --> 00:07:07,000
如果每一次串台的都可以找到一个相同之处

174
00:07:07,000 --> 00:07:13,000
就是每一期的怎么说番号是一样的的话

175
00:07:13,000 --> 00:07:18,000
我们也许早一点就可以猜想出这个故障的原因来了

176
00:07:18,000 --> 00:07:23,000
但是之前的故障回报里面好像从来没有人提起

177
00:07:23,000 --> 00:07:26,000
如果说比如说流行通信第 18 期

178
00:07:26,000 --> 00:07:28,000
串到那广望的第 18 期

179
00:07:28,000 --> 00:07:30,000
都会是第 18 期

180
00:07:30,000 --> 00:07:34,000
我想可能一部分原因也是因为大部分人发现串台了

181
00:07:34,000 --> 00:07:36,000
就不会再仔细听说

182
00:07:36,000 --> 00:07:38,000
是多少期对吧

183
00:07:38,000 --> 00:07:42,000
而且也不是每一个主播都会念说这一次是多少期

184
00:07:42,000 --> 00:07:46,000
对我们很多节目都不会讲就是多递多少期

185
00:07:46,000 --> 00:07:49,000
因为有可能比如说他可能预先录制了两三期这样

186
00:07:49,000 --> 00:07:53,000
然后发布的时候其实是在 Lawrence 在决定

187
00:07:53,000 --> 00:07:56,000
按发布的时间线号时就去排这个序号码

188
00:07:56,000 --> 00:07:56,000
对

189
00:07:56,000 --> 00:07:59,000
对所以这种情况下没有办法

190
00:08:00,000 --> 00:08:02,000
你只是无意中透露了一个商业精

191
00:08:02,000 --> 00:08:03,000
什么商业精

192
00:08:03,000 --> 00:08:05,000
批量生产

193
00:08:05,000 --> 00:08:08,000
然后分批分开几期播放

194
00:08:08,000 --> 00:08:09,000
还是比较少

195
00:08:09,000 --> 00:08:14,000
但是确实以前有做过这种就所谓的备用方案

196
00:08:14,000 --> 00:08:18,000
对反正找到这个东西的原因了

197
00:08:18,000 --> 00:08:22,000
我们的这个什么消灭它的方法也比较简单

198
00:08:22,000 --> 00:08:25,000
我们直接在这个文件名前面再加钱坠

199
00:08:25,000 --> 00:08:30,000
因为既然那个什么长宽的这种 2 B 缓存系统

200
00:08:30,000 --> 00:08:35,000
竟然能不顾路径直接管文件名

201
00:08:35,000 --> 00:08:38,000
就认为是就同样文件名的文件认为是一样了

202
00:08:38,000 --> 00:08:40,000
那我们把文件名改成不一样

203
00:08:40,000 --> 00:08:42,000
比如说每个节目的前

204
00:08:42,000 --> 00:08:42,000
加到个前缀

205
00:08:42,000 --> 00:08:44,000
比如是 Colonel Panic

206
00:08:44,000 --> 00:08:47,000
然后横杠 EP 20.mp 3

207
00:08:47,000 --> 00:08:49,000
然后另外那个是 ActiGona

208
00:08:49,000 --> 00:08:51,000
横杠 EP 20.mp 3

209
00:08:51,000 --> 00:08:56,000
希望这样就可以绕过那个长宽的这个有 bug

210
00:08:56,000 --> 00:09:00,000
就是无力吐槽的 bug 的航程系统吧

211
00:09:00,000 --> 00:09:00,000
对

212
00:09:00,000 --> 00:09:03,000
然后这让我想到说

213
00:09:03,000 --> 00:09:05,000
其实这个 bug 也许会造成更大的伤害

214
00:09:05,000 --> 00:09:09,000
因为我们的节目其实只是一个 podcast 而已

215
00:09:09,000 --> 00:09:11,000
你最多只不过串个台而已

216
00:09:11,000 --> 00:09:11,000
对吧

217
00:09:11,000 --> 00:09:17,000
但是如果相同 bug 发生在一些比较 mission critical 的软件上面

218
00:09:17,000 --> 00:09:17,000
那可能

219
00:09:17,000 --> 00:09:19,000
这不用可能

220
00:09:19,000 --> 00:09:20,000
这个事情已经切切实在发生了

221
00:09:20,000 --> 00:09:23,000
应该是从在造成一定的

222
00:09:23,000 --> 00:09:27,000
已经是出于这种商业恶意的行为在做了

223
00:09:27,000 --> 00:09:29,000
很简单的一个原因

224
00:09:29,000 --> 00:09:30,000
就是

225
00:09:30,000 --> 00:09:32,000
你知道安卓那些这个应用 bots

226
00:09:32,000 --> 00:09:34,000
可以通过一种软件下载的

227
00:09:34,000 --> 00:09:36,000
APK 的形式去安装的吗

228
00:09:36,000 --> 00:09:38,000
然后国内有很多

229
00:09:38,000 --> 00:09:41,000
国内有很多应用商店是这么搞的

230
00:09:41,000 --> 00:09:42,000
然后呢

231
00:09:42,000 --> 00:09:43,000
就有运营商

232
00:09:43,000 --> 00:09:44,000
我不说哪一家

233
00:09:44,000 --> 00:09:45,000
大家自己去猜

234
00:09:45,000 --> 00:09:47,000
但也不是一个普遍现象

235
00:09:47,000 --> 00:09:48,000
可能个别地区吧

236
00:09:48,000 --> 00:09:54,000
它就直接在你下载 APK 这个过程中给你劫持了

237
00:09:54,000 --> 00:09:57,000
你本来要下一个 A 的这个应用

238
00:09:57,000 --> 00:09:59,000
它可以劫持成同类的 B 的

239
00:09:59,000 --> 00:10:04,000
然后你作为一个这个消费者

240
00:10:04,000 --> 00:10:04,000
你下载会看

241
00:10:04,000 --> 00:10:05,000
咦

242
00:10:05,000 --> 00:10:06,000
怎么有事

243
00:10:06,000 --> 00:10:09,000
我下的是本来是 A 应用的变成了 B 应用的东西

244
00:10:09,000 --> 00:10:11,000
那你觉得是哪里的问题呢

245
00:10:11,000 --> 00:10:12,000
对

246
00:10:12,000 --> 00:10:15,000
如果你不具备这种基础的网络知识

247
00:10:15,000 --> 00:10:17,000
你不具备像上次我们这个热心

248
00:10:17,000 --> 00:10:20,000
听众这种桃根问底的这种精神

249
00:10:20,000 --> 00:10:21,000
你想

250
00:10:21,000 --> 00:10:24,000
可能是不是你这个应用商店有问题啊

251
00:10:24,000 --> 00:10:25,000
还是怎么样

252
00:10:25,000 --> 00:10:25,000
对吧

253
00:10:25,000 --> 00:10:26,000
对

254
00:10:26,000 --> 00:10:27,000
所以呢

255
00:10:27,000 --> 00:10:29,000
这件事情说到底

256
00:10:29,000 --> 00:10:31,000
技术的解决方法也是有的

257
00:10:31,000 --> 00:10:33,000
那就是全面启用那个 HTTPS

258
00:10:33,000 --> 00:10:35,000
就是加密的连接嘛

259
00:10:35,000 --> 00:10:37,000
加密连接的好处就是中间那个缓程

260
00:10:37,000 --> 00:10:39,000
它是没有办法去做手脚的

261
00:10:39,000 --> 00:10:41,000
因为一做手脚就会被那个报错

262
00:10:41,000 --> 00:10:43,000
至少我希望如此

263
00:10:43,000 --> 00:10:47,000
但是呢

264
00:10:47,000 --> 00:10:49,000
这就会有一点点问题

265
00:10:49,000 --> 00:10:50,000
就假设比如说

266
00:10:50,000 --> 00:10:52,000
因为如果用加密连接的话

267
00:10:52,000 --> 00:10:55,000
就长宽那种代理缓存就没办法用了嘛

268
00:10:55,000 --> 00:10:57,000
那假设你是长宽的用户

269
00:10:57,000 --> 00:10:59,000
你那刚假设你有一百个长宽的用户

270
00:10:59,000 --> 00:11:02,000
这一百个人每次都要从长宽呢

271
00:11:02,000 --> 00:11:03,000
不是

272
00:11:03,000 --> 00:11:06,000
就这一百个用户都要从这个原始的出处那里下载

273
00:11:06,000 --> 00:11:08,000
这么一个比较大的文件

274
00:11:08,000 --> 00:11:11,000
那么如果大家的碰巧是在同一个时间下载的话

275
00:11:11,000 --> 00:11:15,000
可能就会把长宽的那个出处大家给撑爆

276
00:11:15,000 --> 00:11:18,000
所以其实你发现说到这里

277
00:11:18,000 --> 00:11:25,000
就是在安全隐私和这个效率上面之间是有一些矛盾的

278
00:11:25,000 --> 00:11:26,000
怎么去取舍

279
00:11:26,000 --> 00:11:31,000
我觉得过去我们通常觉得说效率先嘛

280
00:11:31,000 --> 00:11:32,000
那安全隐私那些

281
00:11:32,000 --> 00:11:35,000
反正我又不在乎有什么问题呢

282
00:11:35,000 --> 00:11:38,000
但是其实今天以今天这种情况来看

283
00:11:38,000 --> 00:11:41,000
就什么运营商劫持啊

284
00:11:41,000 --> 00:11:42,000
还有各个神仙

285
00:11:42,000 --> 00:11:48,000
在搞那种灰色甚至黑色的利益的勾当的时候

286
00:11:48,000 --> 00:11:53,000
我们甚至我们可能是不是就不得不牺牲一些效率

287
00:11:53,000 --> 00:11:55,000
下载慢去选择

288
00:11:55,000 --> 00:11:57,000
那我至少保证下载后来是可靠的

289
00:11:57,000 --> 00:11:57,000
对吧

290
00:11:57,000 --> 00:11:58,000
对

291
00:11:58,000 --> 00:12:02,000
是反正最无论如何

292
00:12:02,000 --> 00:12:04,000
我们还是要在这边感谢这个

293
00:12:04,000 --> 00:12:07,000
这位帮我们找到这个 bug 的听众

294
00:12:07,000 --> 00:12:09,000
他叫做 Lin Z

295
00:12:09,000 --> 00:12:12,000
非常感谢

296
00:12:12,000 --> 00:12:13,000
对

297
00:12:13,000 --> 00:12:16,000
还有感谢另外一位是在那个

298
00:12:16,000 --> 00:12:17,000
V 2 EX 上面

299
00:12:17,000 --> 00:12:19,000
我们每期节目的那个文章上面

300
00:12:19,000 --> 00:12:22,000
他也另外那位朋友也帮我们做了

301
00:12:22,000 --> 00:12:23,000
这个同样的事情

302
00:12:23,000 --> 00:12:24,000
非常感谢大家

303
00:12:24,000 --> 00:12:25,000
是的

304
00:12:25,000 --> 00:12:29,000
接下来一条 follow up

305
00:12:29,000 --> 00:12:35,000
就是我上一期节目里面提到的那个莫尔斯玛的 app

306
00:12:35,000 --> 00:12:37,000
这个如果大家忘记了

307
00:12:37,000 --> 00:12:38,000
我们这里先描述一下

308
00:12:38,000 --> 00:12:46,000
我上次让吴涛去捣鼓一下一个在 Apple Watch 上跑的原生的

309
00:12:46,000 --> 00:12:49,000
通过莫尔斯玛来发送信息的一个应用

310
00:12:49,000 --> 00:12:51,000
所以后来怎么样了

311
00:12:51,000 --> 00:13:00,000
其实原因也就是即便在新发布的 watchOS 上面

312
00:13:00,000 --> 00:13:06,000
苹果提供的这一堆空间还是有

313
00:13:06,000 --> 00:13:09,000
还是只支持非常简单的实践模型

314
00:13:09,000 --> 00:13:13,000
就是比如说你可以在里面放一个 button

315
00:13:13,000 --> 00:13:24,000
但是你放了 button 之后你对他做的事情就仅有探测他被按下一次这个 action

316
00:13:24,000 --> 00:13:25,000
这个 event

317
00:13:25,000 --> 00:13:30,000
而没有说我的手指碰到了 button 按下去了

318
00:13:30,000 --> 00:13:31,000
这是一个 event

319
00:13:31,000 --> 00:13:36,000
或者是我的手指提起来从 button 上面移开了这个 event

320
00:13:36,000 --> 00:13:42,000
就是相当于如果你搞过 iOS 变成的话

321
00:13:42,000 --> 00:13:49,000
就相当于 touchstart 和 touchend 这两个时间

322
00:13:49,000 --> 00:13:53,000
还是 touchleaveinside 这两个时间

323
00:13:53,000 --> 00:13:55,000
他唯一能做的就是这个按钮被按下了一次

324
00:13:55,000 --> 00:13:58,000
但是没有办法判断这个按钮发现了长短

325
00:13:58,000 --> 00:14:10,000
所以这样一来你想要像那些比较熟练一点的电报员那样

326
00:14:10,000 --> 00:14:16,000
通过快速敲击表盘来发点和滑的希望的泡汤

327
00:14:16,000 --> 00:14:21,000
因为每一个按键被按下去的过程实际上是非常缓慢的

328
00:14:21,000 --> 00:14:24,000
而且我相信苹果为了防止说

329
00:14:24,000 --> 00:14:32,000
一个人误触一个案件两次

330
00:14:32,000 --> 00:14:34,000
在短时间之内误触个案件两次

331
00:14:34,000 --> 00:14:38,000
他故意放了一段怎么说僵直期在那边

332
00:14:38,000 --> 00:14:41,000
我可能想说不应期

333
00:14:41,000 --> 00:14:45,000
所以在这段时间之内

334
00:14:45,000 --> 00:14:47,000
你怎么按这个键都没有反应

335
00:14:47,000 --> 00:14:51,000
所以从这个角度讲

336
00:14:51,000 --> 00:14:54,000
原本的设想是就已经做不到

337
00:14:54,000 --> 00:14:58,000
然后我现在临时的方案是放两个按键的上面

338
00:14:58,000 --> 00:14:59,000
一个代表点一个代表滑

339
00:14:59,000 --> 00:15:02,000
但是最大按钮就是明显

340
00:15:02,000 --> 00:15:04,000
对这样不酷

341
00:15:04,000 --> 00:15:07,000
而且仍旧是比较慢

342
00:15:07,000 --> 00:15:10,000
我打个岔问一个事

343
00:15:10,000 --> 00:15:13,000
就是他那个表上不是还有两个物理的东西吗

344
00:15:13,000 --> 00:15:15,000
一个是那个叫做数字表冠的东西

345
00:15:15,000 --> 00:15:18,000
还有一个就是旁边有个数字表冠下面有个按钮

346
00:15:18,000 --> 00:15:21,000
那两个是可以通过 API 访问的到的

347
00:15:21,000 --> 00:15:23,000
它的操作的吗

348
00:15:23,000 --> 00:15:26,000
并不直接访问

349
00:15:26,000 --> 00:15:27,000
并不能直接访问到

350
00:15:27,000 --> 00:15:28,000
首先朋友的那个键

351
00:15:28,000 --> 00:15:31,000
那键的官方名字叫什么

352
00:15:31,000 --> 00:15:32,000
Frankey

353
00:15:32,000 --> 00:15:35,000
我让那个官方反正

354
00:15:35,000 --> 00:15:38,000
反正我知道上面那个叫 Digital Chrome

355
00:15:38,000 --> 00:15:39,000
下面那个叫

356
00:15:39,000 --> 00:15:41,000
下面的可能就叫 side button

357
00:15:41,000 --> 00:15:42,000
如果没记错

358
00:15:42,000 --> 00:15:43,000
反正就是按钮

359
00:15:43,000 --> 00:15:43,000
对

360
00:15:43,000 --> 00:15:45,000
这个按钮的按点

361
00:15:45,000 --> 00:15:48,000
就是按一下是可以在你的应用里面探测的到的

362
00:15:48,000 --> 00:15:49,000
对

363
00:15:49,000 --> 00:15:54,000
然后这两件 side button 是没有办法直接编程获得的

364
00:15:54,000 --> 00:15:57,000
然后 Digital Chrome 也不能直接编程说

365
00:15:57,000 --> 00:16:01,000
此时发生了一个 Digital Chrome 被转动的事件

366
00:16:01,000 --> 00:16:04,000
而只能通过一个叫做

367
00:16:04,000 --> 00:16:05,000
如果没记错的话

368
00:16:05,000 --> 00:16:14,000
应该叫做 Interface Picker 的空间来获取它

369
00:16:14,000 --> 00:16:17,000
就是哪怕是在这个所谓 WatchOS 2 也是这样吗

370
00:16:17,000 --> 00:16:18,000
对

371
00:16:18,000 --> 00:16:20,000
哪怕在 WatchOS 2 里面也是这样

372
00:16:20,000 --> 00:16:25,000
而且好像是只有在 WatchOS 2 里面才可以使用这个空间

373
00:16:25,000 --> 00:16:29,000
也就是说之前在目前的版本的 Xcode 6 里面

374
00:16:29,000 --> 00:16:32,000
是没有办法去以任何方法获得

375
00:16:32,000 --> 00:16:36,000
这个 Digital Chrome 被转动的事件

376
00:16:36,000 --> 00:16:40,000
然后在 WatchOS 2 里面你可以放一个 Picker

377
00:16:40,000 --> 00:16:44,000
然后这个 Picker 的外观

378
00:16:44,000 --> 00:16:45,000
其实就像

379
00:16:45,000 --> 00:16:51,000
比如说那个监测你的 Activity 的那个 App 里面

380
00:16:51,000 --> 00:16:57,000
你可以通过指头在表盘上下滑动

381
00:16:57,000 --> 00:17:00,000
或者是通过 Digital Chrome 来转动

382
00:17:00,000 --> 00:17:02,000
去选择一个列表之中的某一下

383
00:17:02,000 --> 00:17:07,000
然后这个 Picker 会发生一个

384
00:17:07,000 --> 00:17:11,000
Selected Item Changed 这样一个 Event

385
00:17:11,000 --> 00:17:14,000
所以你可以通过这个以后来间接的判断说

386
00:17:14,000 --> 00:17:17,000
Oh Chrome 现在被转动

387
00:17:17,000 --> 00:17:18,000
但也仅此而已

388
00:17:18,000 --> 00:17:18,000
对

389
00:17:18,000 --> 00:17:22,000
还有一个就是我提的一个建议

390
00:17:22,000 --> 00:17:23,000
后来好像证明也是不行的

391
00:17:23,000 --> 00:17:29,000
就是说它那个表的那个触屏不是可以探测压杆吗

392
00:17:29,000 --> 00:17:32,000
就可以通过什么 Force Touch

393
00:17:32,000 --> 00:17:35,000
就是用力的压和不用力的压区分 0 和 1

394
00:17:35,000 --> 00:17:37,000
这个后来是一个什么样的情况

395
00:17:37,000 --> 00:17:38,000
事实上也是不行的

396
00:17:38,000 --> 00:17:45,000
因为 Fast Touch 这个动作被 SDK 限制为

397
00:17:45,000 --> 00:17:49,000
呼出快捷菜单这么一个

398
00:17:49,000 --> 00:17:52,000
呼出 Context Menu 这么一个动作

399
00:17:52,000 --> 00:17:56,000
所以如果你要处理这个事件的话

400
00:17:56,000 --> 00:18:00,000
那你唯一能做的就是把它连到一个菜单上面

401
00:18:00,000 --> 00:18:02,000
别的不能做了

402
00:18:02,000 --> 00:18:07,000
然后这个菜单出来比如说上面有一个唯一一个按键

403
00:18:07,000 --> 00:18:10,000
就是点一下就输入 1 不可以吗

404
00:18:10,000 --> 00:18:15,000
我觉得这个操作还是非常的奇怪

405
00:18:15,000 --> 00:18:17,000
不够帅是吧

406
00:18:17,000 --> 00:18:17,000
对

407
00:18:17,000 --> 00:18:20,000
那其实还不如放两个按键

408
00:18:20,000 --> 00:18:23,000
因为你无论如何在长按之下还要点一下

409
00:18:23,000 --> 00:18:23,000
就非常的

410
00:18:23,000 --> 00:18:28,000
关键是我觉得它那个 Force Touch 的那个力度很不好控制

411
00:18:28,000 --> 00:18:30,000
没错

412
00:18:30,000 --> 00:18:36,000
而且我觉得苹果有点对于上下滚动太敏感了

413
00:18:36,000 --> 00:18:38,000
苹果表对于上下滚动太敏感了

414
00:18:38,000 --> 00:18:40,000
就是我不知道你有没有这个感觉

415
00:18:40,000 --> 00:18:41,000
但是你在走路的时候

416
00:18:41,000 --> 00:18:45,000
如果你试图按一个按键

417
00:18:45,000 --> 00:18:50,000
你会发现这个表会更倾向于转动它的

418
00:18:50,000 --> 00:18:53,000
上下滑动它的屏幕

419
00:18:53,000 --> 00:18:54,000
而不是让你把这个按键按下去

420
00:18:54,000 --> 00:18:56,000
尤其是这个屏幕可以滑动的时候

421
00:18:56,000 --> 00:18:58,000
比如说回复一个人的短信

422
00:18:58,000 --> 00:19:02,000
好你一边走路一边抬起手腕来看到一个人的短信

423
00:19:02,000 --> 00:19:05,000
然后你想要回复它

424
00:19:05,000 --> 00:19:07,000
回复那一下就很难点了

425
00:19:07,000 --> 00:19:07,000
因为

426
00:19:07,000 --> 00:19:08,000
对

427
00:19:08,000 --> 00:19:09,000
这里有一个问题

428
00:19:09,000 --> 00:19:11,000
就刚才你说的两个事件

429
00:19:11,000 --> 00:19:13,000
一个 Touch Start 和 Touch End

430
00:19:13,000 --> 00:19:16,000
它们之间是有一个间隙的

431
00:19:16,000 --> 00:19:17,000
然后你在运动中

432
00:19:17,000 --> 00:19:20,000
你这个肯定是会发生胃移的

433
00:19:20,000 --> 00:19:21,000
那个触摸的手指

434
00:19:21,000 --> 00:19:22,000
对

435
00:19:22,000 --> 00:19:24,000
然后这样一来你在

436
00:19:24,000 --> 00:19:25,000
对

437
00:19:25,000 --> 00:19:27,000
这样一来你在

438
00:19:27,000 --> 00:19:31,000
选择回复的时候就已经很吃力了

439
00:19:31,000 --> 00:19:35,000
你可能需要把食指按在手腕上

440
00:19:35,000 --> 00:19:38,000
然后用中指去点那个回复键

441
00:19:38,000 --> 00:19:40,000
因为这样可以减少两只手之间的相对移动

442
00:19:40,000 --> 00:19:49,000
然后等你呼出了那个一堆短暂的快捷回复内容的时候

443
00:19:49,000 --> 00:19:54,000
可能你又要很小心的去按其中的某一个

444
00:19:54,000 --> 00:19:56,000
不然它又会处理会滑动

445
00:19:56,000 --> 00:19:57,000
对

446
00:19:57,000 --> 00:19:59,000
这个是挺糟糕的一件事情

447
00:19:59,000 --> 00:20:01,000
可能他们还得再微调一下

448
00:20:01,000 --> 00:20:09,000
因为毕竟这么小的表盘上的这种触摸的操作和手机大屏幕的触摸到的情况

449
00:20:09,000 --> 00:20:11,000
还是有点不同的

450
00:20:11,000 --> 00:20:14,000
怎么去制定一些边界的条件

451
00:20:14,000 --> 00:20:14,000
我觉得还是挺

452
00:20:14,000 --> 00:20:16,000
怎么说呢

453
00:20:16,000 --> 00:20:17,000
挺麻烦一个事

454
00:20:17,000 --> 00:20:18,000
对

455
00:20:18,000 --> 00:20:21,000
然后我希望在接下来的几大 IOS

456
00:20:21,000 --> 00:20:25,000
WatchOS 里面可以提供更多的事件

457
00:20:25,000 --> 00:20:27,000
以及更多的 API 支持

458
00:20:27,000 --> 00:20:37,000
比如说现在好像没有办法去检测它的那个陀螺仪或者是血压剂都没有办法

459
00:20:37,000 --> 00:20:39,000
就只能做一些非常简单的功能

460
00:20:39,000 --> 00:20:44,000
然后所有动画都必须通过图片来实现

461
00:20:44,000 --> 00:20:47,000
就是如果你想要显示一个动画

462
00:20:47,000 --> 00:20:51,000
你得预先把每一帧都存成一幅照片

463
00:20:51,000 --> 00:20:55,000
然后连着放那个幻灯片

464
00:20:55,000 --> 00:20:55,000
对

465
00:20:55,000 --> 00:20:57,000
然后连着放幻灯片

466
00:20:57,000 --> 00:21:05,000
然后苹果的这次 WWDC 上面还劝告开发者说注意图片的尺寸

467
00:21:05,000 --> 00:21:10,000
因为在 IOS 在 WattroOS 一代里面

468
00:21:10,000 --> 00:21:13,000
图片每一次都要传到手表上

469
00:21:13,000 --> 00:21:14,000
而在 WattroOS

470
00:21:14,000 --> 00:21:15,000
对

471
00:21:15,000 --> 00:21:17,000
而在 WattroOS 2 上面

472
00:21:17,000 --> 00:21:20,000
至少在第一次安装的时候

473
00:21:20,000 --> 00:21:23,000
这个传输过程也是比较耗时的

474
00:21:23,000 --> 00:21:26,000
并且如果你图片太大的话

475
00:21:26,000 --> 00:21:28,000
它存在手表上也是很占地吧

476
00:21:28,000 --> 00:21:29,000
对

477
00:21:29,000 --> 00:21:33,000
好像手表有个内置有个什么 8 GB 的存置空间吧

478
00:21:33,000 --> 00:21:34,000
总共

479
00:21:34,000 --> 00:21:34,000
对

480
00:21:34,000 --> 00:21:39,000
然后其中大概有三分之一被操作组用了

481
00:21:39,000 --> 00:21:40,000
嗯

482
00:21:40,000 --> 00:21:42,000
嗯

483
00:21:42,000 --> 00:21:48,000
所以其实为这个这个鸡肋玩意儿开发东西还是挺挺难的

484
00:21:48,000 --> 00:21:49,000
没错

485
00:21:49,000 --> 00:21:52,000
但怎么说呢

486
00:21:52,000 --> 00:21:53,000
毕竟是第一代产品

487
00:21:53,000 --> 00:21:54,000
希望以后会有得好

488
00:21:54,000 --> 00:21:59,000
也许以后会有摄像机出现在手表上

489
00:21:59,000 --> 00:22:01,000
摄像机

490
00:22:01,000 --> 00:22:02,000
对啊

491
00:22:02,000 --> 00:22:04,000
就是有一个摄像头

492
00:22:04,000 --> 00:22:09,000
装摄像头在人手表上还是挺实用的

493
00:22:09,000 --> 00:22:10,000
我有点担心

494
00:22:10,000 --> 00:22:14,000
然后那个就会布那个 Google Glass 的后程

495
00:22:14,000 --> 00:22:17,000
你干嘛用你的手表对着我

496
00:22:17,000 --> 00:22:18,000
你是不是在录像

497
00:22:18,000 --> 00:22:19,000
没错啊

498
00:22:19,000 --> 00:22:21,000
你那么隐蔽的一个摄像装置

499
00:22:21,000 --> 00:22:22,000
谁知道你没有在拍人家群体

500
00:22:22,000 --> 00:22:23,000
嗯

501
00:22:23,000 --> 00:22:26,000
特别是在日本这种国家的吧

502
00:22:26,000 --> 00:22:27,000
就挺麻烦的

503
00:22:27,000 --> 00:22:27,000
我觉得

504
00:22:27,000 --> 00:22:31,000
其实在目前的手表上可以遥控

505
00:22:31,000 --> 00:22:35,000
手机上的相机已经有一点

506
00:22:35,000 --> 00:22:37,000
就是可以用它来做一些不那么

507
00:22:37,000 --> 00:22:40,000
道德的事情的嫌疑了

508
00:22:40,000 --> 00:22:43,000
目前还没有看到对此的批评

509
00:22:43,000 --> 00:22:46,000
他如果遥控手机的话

510
00:22:46,000 --> 00:22:48,000
反正比如说你在日本购买的合法的

511
00:22:48,000 --> 00:22:51,000
这个 iPhone 的那个拍照的时候

512
00:22:51,000 --> 00:22:52,000
那个咔嚓声是关不掉的吗

513
00:22:52,000 --> 00:22:55,000
你知道这事吗

514
00:22:55,000 --> 00:22:56,000
我不知道

515
00:22:56,000 --> 00:22:58,000
好像只有日本

516
00:22:58,000 --> 00:23:01,000
就是日版的 iPhone 是有这个限制

517
00:23:01,000 --> 00:23:03,000
就是说你中国

518
00:23:03,000 --> 00:23:06,000
比如欧版或者是中国大陆的买的那个

519
00:23:06,000 --> 00:23:08,000
iPhone 手机的那个

520
00:23:08,000 --> 00:23:11,000
你调成这个震动模式之后

521
00:23:11,000 --> 00:23:11,000
你用拍照

522
00:23:11,000 --> 00:23:13,000
它是不会发出任何声音的

523
00:23:13,000 --> 00:23:15,000
拍了就拍了

524
00:23:15,000 --> 00:23:18,000
但是你在日本买的就会咔嚓

525
00:23:18,000 --> 00:23:20,000
哪怕是在震动模式也会有这个

526
00:23:20,000 --> 00:23:26,000
是指在照片 APP 这个层级上限制呢

527
00:23:26,000 --> 00:23:27,000
还是在所有的 APP

528
00:23:27,000 --> 00:23:29,000
API 的层级上限制

529
00:23:29,000 --> 00:23:31,000
只要有拍照这个功能都会发出声音

530
00:23:31,000 --> 00:23:32,000
Holy fuck

531
00:23:32,000 --> 00:23:35,000
我当时知道这个消息的时候

532
00:23:35,000 --> 00:23:37,000
我也是震惊了

533
00:23:37,000 --> 00:23:39,000
不可思议

534
00:23:39,000 --> 00:23:41,000
有国情嘛

535
00:23:41,000 --> 00:23:42,000
有国情

536
00:23:42,000 --> 00:23:44,000
好吧

537
00:23:44,000 --> 00:23:48,000
那个我们下面念几封这个听众来信

538
00:23:48,000 --> 00:23:48,000
好吧

539
00:23:48,000 --> 00:23:49,000
对

540
00:23:49,000 --> 00:23:54,000
上一期的节目在微博上面没有太多人评论

541
00:23:54,000 --> 00:24:00,000
但是我们却收到了好几封又长又热情读者来信

542
00:24:00,000 --> 00:24:03,000
先念第一位吧

543
00:24:03,000 --> 00:24:06,000
这个是叫陈一鸣

544
00:24:06,000 --> 00:24:08,000
这只拼音不知道怎么写啊

545
00:24:08,000 --> 00:24:10,000
陈一鸣的来信

546
00:24:10,000 --> 00:24:11,000
对

547
00:24:11,000 --> 00:24:12,000
Rail 吴涛你们好

548
00:24:12,000 --> 00:24:14,000
听了你们这期内核恐慌

549
00:24:14,000 --> 00:24:17,000
我也想发表一下自己对测试的看法

550
00:24:17,000 --> 00:24:20,000
第一次接触测试

551
00:24:20,000 --> 00:24:22,000
可以说是在高中算法竞赛的时候

552
00:24:22,000 --> 00:24:23,000
哇

553
00:24:23,000 --> 00:24:23,000
好厉害

554
00:24:23,000 --> 00:24:24,000
高中就算法竞赛

555
00:24:24,000 --> 00:24:29,000
当时老师特地请了 ACM 大牛来学校指导我们

556
00:24:29,000 --> 00:24:35,000
在休息的时候就顺便教我们如何写对拍程序

557
00:24:35,000 --> 00:24:36,000
什么是对拍程序

558
00:24:36,000 --> 00:24:38,000
对拍程序就是

559
00:24:38,000 --> 00:24:44,000
就像一个节奏器吧

560
00:24:44,000 --> 00:24:44,000
我可以理解

561
00:24:44,000 --> 00:24:48,000
就是你要和他对你的拍子

562
00:24:48,000 --> 00:24:49,000
OK

563
00:24:49,000 --> 00:24:52,000
这接触测试里有三个步骤

564
00:24:52,000 --> 00:24:56,000
第一步是先写一个低效的程序

565
00:24:56,000 --> 00:24:57,000
保证这个程序的正确性

566
00:24:57,000 --> 00:25:01,000
然后第二步是再写一个随机生成输入数据的程序

567
00:25:01,000 --> 00:25:04,000
并保证生成各种边界条件

568
00:25:04,000 --> 00:25:08,000
第三就是最后写自己打算提下的最终代码

569
00:25:08,000 --> 00:25:11,000
并用以上两个程序来保证该代码的正确性

570
00:25:11,000 --> 00:25:16,000
当时还是在 Windows 下用命令行提示符写脚本

571
00:25:16,000 --> 00:25:17,000
对输出进行对比

572
00:25:17,000 --> 00:25:19,000
因此印象深刻

573
00:25:19,000 --> 00:25:20,000
但学了之后

574
00:25:20,000 --> 00:25:22,000
在比赛中真正用到的人很少

575
00:25:22,000 --> 00:25:25,000
又或者是我没有进到审计上的比赛

576
00:25:25,000 --> 00:25:26,000
没接触到

577
00:25:26,000 --> 00:25:27,000
这是括号里面的一句话

578
00:25:27,000 --> 00:25:31,000
现在看来当时学的测试方法已经很标准有效了

579
00:25:31,000 --> 00:25:33,000
然而实践起来却难上架了

580
00:25:33,000 --> 00:25:34,000
难

581
00:25:34,000 --> 00:25:36,000
写最终代码都来不及了

582
00:25:36,000 --> 00:25:40,000
哪还有时间写低效程序和更麻烦的数据生成脚本

583
00:25:40,000 --> 00:25:44,000
也因此我对测试并没有什么好印象

584
00:25:44,000 --> 00:25:48,000
但是这学期我在一个课程的这个 project

585
00:25:48,000 --> 00:25:50,000
用的是 Python 的 Django 中

586
00:25:50,000 --> 00:25:52,000
第一次尝试了 TDD

587
00:25:52,000 --> 00:25:54,000
就上次怎么讲的 Test Driven Development

588
00:25:54,000 --> 00:25:56,000
测试驱动的开发

589
00:25:56,000 --> 00:25:59,000
对测试大大改观

590
00:25:59,000 --> 00:26:02,000
发现测试并没有之前想象的那么无用

591
00:26:02,000 --> 00:26:05,000
也比二位在节目中说的重要的多

592
00:26:05,000 --> 00:26:06,000
测试

593
00:26:06,000 --> 00:26:09,000
我在节目中没有说它不重要

594
00:26:09,000 --> 00:26:11,000
我只是不喜欢它

595
00:26:11,000 --> 00:26:12,000
但从来没有说过它不重要

596
00:26:12,000 --> 00:26:13,000
对

597
00:26:13,000 --> 00:26:15,000
我们都一致认可测试的重要性

598
00:26:15,000 --> 00:26:16,000
有总是并没有好的

599
00:26:16,000 --> 00:26:18,000
只是我们都不太喜欢写测试

600
00:26:18,000 --> 00:26:21,000
他说这个接着讲

601
00:26:21,000 --> 00:26:23,000
他说测试最重要是帮助我们写出

602
00:26:23,000 --> 00:26:26,000
异于测试的代码

603
00:26:26,000 --> 00:26:30,000
单元测试的定义决定的程序的每一个小功能

604
00:26:30,000 --> 00:26:31,000
都要有一个接口

605
00:26:31,000 --> 00:26:33,000
供测试代码调用

606
00:26:33,000 --> 00:26:34,000
而先写单元测试

607
00:26:34,000 --> 00:26:37,000
这让我们先对这个接口有一个设想

608
00:26:37,000 --> 00:26:40,000
帮助我们降低项目的吻合度

609
00:26:40,000 --> 00:26:41,000
提高内聚性

610
00:26:41,000 --> 00:26:44,000
当然有一个架构的过程也能办到

611
00:26:44,000 --> 00:26:48,000
但一个小团队或者一个需要快速开发的项目

612
00:26:48,000 --> 00:26:50,000
往往没有那么多时间去架构

613
00:26:50,000 --> 00:26:52,000
测试能在架构上提供帮助

614
00:26:52,000 --> 00:26:55,000
这一点我觉得有点意思

615
00:26:55,000 --> 00:26:56,000
就是说

616
00:26:56,000 --> 00:27:00,000
其单元测试能够帮助我们所谓做一个

617
00:27:00,000 --> 00:27:03,000
就是最小颗粒度的独立运行的一段代码

618
00:27:03,000 --> 00:27:04,000
对吧

619
00:27:04,000 --> 00:27:05,000
对

620
00:27:05,000 --> 00:27:09,000
这样的话就可以至少说我们不会写一个

621
00:27:09,000 --> 00:27:13,000
翻五页都翻不完的单一函数

622
00:27:13,000 --> 00:27:14,000
对吧

623
00:27:14,000 --> 00:27:15,000
这样就没法测了

624
00:27:15,000 --> 00:27:19,000
所以从这点到我觉得还是有一定好处

625
00:27:19,000 --> 00:27:23,000
就起码在对你代码的组织上是有一定帮助的

626
00:27:23,000 --> 00:27:24,000
对

627
00:27:24,000 --> 00:27:28,000
每一测试其实就是一个对于你真正的 API 的考验

628
00:27:28,000 --> 00:27:29,000
对

629
00:27:29,000 --> 00:27:33,000
很多考验是如果你没有用过的话

630
00:27:33,000 --> 00:27:37,000
完全不知道自己没有办法通过这个考验

631
00:27:37,000 --> 00:27:40,000
所以如果一开始能把这个考验就先写出来的话

632
00:27:40,000 --> 00:27:44,000
那设计 API 的时候其实会方便很多

633
00:27:44,000 --> 00:27:45,000
对

634
00:27:45,000 --> 00:27:48,000
然后接着念他这个来信

635
00:27:48,000 --> 00:27:49,000
然后他这里马上举了一个反例

636
00:27:49,000 --> 00:27:52,000
就是这学期我做的另一个项目

637
00:27:52,000 --> 00:27:54,000
PYQT 5

638
00:27:54,000 --> 00:27:55,000
完全没有测试

639
00:27:55,000 --> 00:27:57,000
写出来就杂乱无章

640
00:27:57,000 --> 00:27:58,000
偶合的过紧

641
00:27:58,000 --> 00:28:00,000
以至于最后自己都不想再写下去了

642
00:28:00,000 --> 00:28:04,000
当然主要是我们做好前期架构的工作

643
00:28:04,000 --> 00:28:04,000
对吧

644
00:28:04,000 --> 00:28:06,000
其实就是有这么一个

645
00:28:06,000 --> 00:28:10,000
叫什么没有纪律性的程序员

646
00:28:10,000 --> 00:28:14,000
要需要这个通过测试这种一种外部的手段

647
00:28:14,000 --> 00:28:19,000
强制你把这个代码的这个颗粒度缩的比较小

648
00:28:19,000 --> 00:28:21,000
然后每个是可以有独立逻辑

649
00:28:21,000 --> 00:28:22,000
可以独立运作了

650
00:28:22,000 --> 00:28:24,000
我不知道你写代码是怎么样子

651
00:28:24,000 --> 00:28:25,000
但我写代码的时候

652
00:28:25,000 --> 00:28:29,000
我不喜欢那种非常长的一段函数

653
00:28:29,000 --> 00:28:33,000
就是有这么这种洁癖

654
00:28:33,000 --> 00:28:36,000
就是凡是都要抽象出来成一个函数

655
00:28:36,000 --> 00:28:38,000
是吧

656
00:28:38,000 --> 00:28:42,000
我记得很早以前就在那本书上看到我

657
00:28:42,000 --> 00:28:44,000
是 pragmatical

658
00:28:44,000 --> 00:28:46,000
pragmatical 上面说了

659
00:28:46,000 --> 00:28:50,000
每一个函数最好长度不要超过一屏

660
00:28:50,000 --> 00:28:52,000
这样你不用矫动屏幕

661
00:28:52,000 --> 00:28:54,000
就可以看明白它是在干嘛

662
00:28:54,000 --> 00:28:55,000
没错

663
00:28:55,000 --> 00:28:57,000
基本上我也是这个习惯

664
00:28:57,000 --> 00:29:01,000
当然你字号要足够大才行

665
00:29:01,000 --> 00:29:02,000
不然就是做

666
00:29:02,000 --> 00:29:05,000
开六号字

667
00:29:05,000 --> 00:29:07,000
一屏还是数屏的你怎么办

668
00:29:07,000 --> 00:29:08,000
没有

669
00:29:08,000 --> 00:29:10,000
这挺痛苦的

670
00:29:10,000 --> 00:29:10,000
对

671
00:29:10,000 --> 00:29:13,000
接着念这个

672
00:29:13,000 --> 00:29:14,000
其次是在

673
00:29:14,000 --> 00:29:17,000
是保证在重构时不犯错

674
00:29:17,000 --> 00:29:20,000
在我的项目开发的过程短短几天时间里

675
00:29:20,000 --> 00:29:23,000
我就有好几次对大片的代码进行重构

676
00:29:23,000 --> 00:29:24,000
或者是优化

677
00:29:24,000 --> 00:29:26,000
如果没有测试做保障

678
00:29:26,000 --> 00:29:29,000
无法想象能在短时间内一个人完成这些工作

679
00:29:29,000 --> 00:29:34,000
使用 TDD 的感受就是对代码的每一次更改都很安心

680
00:29:34,000 --> 00:29:38,000
因为有 test 在代码凸凸的第一时间帮我指出

681
00:29:38,000 --> 00:29:42,000
而重构不放出的另一个好处是让它维护更加方便

682
00:29:42,000 --> 00:29:43,000
只要通过测试就可以了

683
00:29:43,000 --> 00:29:46,000
这个其实怎么说呢

684
00:29:46,000 --> 00:29:50,000
这个确实是有好处的

685
00:29:50,000 --> 00:29:51,000
对

686
00:29:51,000 --> 00:29:52,000
回归测试就是做这个

687
00:29:52,000 --> 00:29:59,000
就是保证你在引入新特性或者重新架构你的程序的时候

688
00:29:59,000 --> 00:30:02,000
可以保证既有的正确的东西不会被改变

689
00:30:02,000 --> 00:30:05,000
这个基本上只有测试可以做到

690
00:30:05,000 --> 00:30:05,000
没有办法

691
00:30:05,000 --> 00:30:09,000
用其他任何办法来试图达到这个目的

692
00:30:09,000 --> 00:30:12,000
都是事倍功半的

693
00:30:12,000 --> 00:30:15,000
但主要是有一点我觉得比较好奇的是

694
00:30:15,000 --> 00:30:17,000
如果它对大片代码进行了重构

695
00:30:17,000 --> 00:30:20,000
那与之对应的单元测试不要重写

696
00:30:20,000 --> 00:30:27,000
那其实这是一个集生单单生机的问题

697
00:30:27,000 --> 00:30:32,000
就如果一开始的单元测试写的就让你没有那么好重构的话

698
00:30:32,000 --> 00:30:34,000
那重构权也是困难中处

699
00:30:34,000 --> 00:30:37,000
但如果你一开始单元测试写的颗粒足够小

700
00:30:37,000 --> 00:30:41,000
然后你的接口也保证的比较好

701
00:30:41,000 --> 00:30:45,000
那基本上单元测试是在很大一部分程度上

702
00:30:45,000 --> 00:30:49,000
可以怎么说沿流下来沿用

703
00:30:49,000 --> 00:30:53,000
但这本还是要回到一开始

704
00:30:53,000 --> 00:30:56,000
就是你得一开始做一定的架构

705
00:30:56,000 --> 00:30:59,000
你不能完全依赖于自己的单元测试写

706
00:30:59,000 --> 00:31:02,000
所以其实我理解在这么一个重构的

707
00:31:02,000 --> 00:31:03,000
还是有一定的

708
00:31:03,000 --> 00:31:08,000
就两个不同的层次

709
00:31:08,000 --> 00:31:11,000
就是说一些比如说你对某一个函数的内部实现

710
00:31:11,000 --> 00:31:14,000
或者某一个就不改变接口情况下

711
00:31:14,000 --> 00:31:17,000
内部实现的重构是完全没有问题

712
00:31:17,000 --> 00:31:18,000
这个做起来也非常爽

713
00:31:18,000 --> 00:31:20,000
你只要确保那些

714
00:31:20,000 --> 00:31:21,000
因为测试是按照接口

715
00:31:21,000 --> 00:31:23,000
单元测试是按接口来做的

716
00:31:23,000 --> 00:31:26,000
你把那些边界条件都弄出来

717
00:31:26,000 --> 00:31:27,000
然后看一下能不能跑通

718
00:31:27,000 --> 00:31:30,000
大致上你也有什么八九不离十的信心

719
00:31:30,000 --> 00:31:34,000
但是如果你是连这个接口都发生了比较大的改变的重构的话

720
00:31:34,000 --> 00:31:38,000
我觉得你在过程中也不会爽到哪里去

721
00:31:38,000 --> 00:31:39,000
因为毕竟还是要写很多

722
00:31:39,000 --> 00:31:42,000
要重写很多单元测试的

723
00:31:42,000 --> 00:31:42,000
因为接口变了

724
00:31:42,000 --> 00:31:43,000
对

725
00:31:43,000 --> 00:31:46,000
接着念下面一个

726
00:31:46,000 --> 00:31:50,000
测试还是形式证明

727
00:31:50,000 --> 00:31:52,000
这个选择题

728
00:31:52,000 --> 00:31:54,000
节目中 Rio 提到对代码的可靠性

729
00:31:54,000 --> 00:31:57,000
进行形式证明更靠谱

730
00:31:57,000 --> 00:31:59,000
我认为这理论上没错

731
00:31:59,000 --> 00:32:01,000
但对于一个现代工程来说

732
00:32:01,000 --> 00:32:04,000
对项目的正确性进行形式证明几乎是不可能的

733
00:32:04,000 --> 00:32:08,000
因为一个大项目很少从框架都自己搭起

734
00:32:08,000 --> 00:32:11,000
那么就无法保证使用框架的正确性

735
00:32:11,000 --> 00:32:17,000
比如万一 Jango 项目本身出了 bug 或者升级后 API 变动导致程序出错

736
00:32:17,000 --> 00:32:20,000
可能我形式证明过我写的部分是对的

737
00:32:20,000 --> 00:32:23,000
但由于这些基础项目是超出我的能力范围外的

738
00:32:23,000 --> 00:32:26,000
那只能用测试来保证代码的正确性

739
00:32:26,000 --> 00:32:28,000
这怎么说呢

740
00:32:28,000 --> 00:32:29,000
没错

741
00:32:29,000 --> 00:32:31,000
形式证明是一个很好东西

742
00:32:31,000 --> 00:32:38,000
但是我们通常你不会在非学院学术研究的领域以外看到它

743
00:32:38,000 --> 00:32:40,000
不当然也有一个有实践的例子

744
00:32:40,000 --> 00:32:47,000
我记得 Windows 上不是有个虚拟机的 hypervisor 叫什么来的

745
00:32:47,000 --> 00:32:50,000
名字我忘了

746
00:32:50,000 --> 00:32:55,000
据说就是微软研究院是对 hypervisor 代码进行的形式证明的

747
00:32:55,000 --> 00:32:57,000
但至于覆盖度多少我不太清楚

748
00:32:57,000 --> 00:32:59,000
但这不还是蛮吃惊

749
00:32:59,000 --> 00:33:01,000
因为那个代码量还是比较大

750
00:33:01,000 --> 00:33:05,000
微软研究院不差人不差钱

751
00:33:05,000 --> 00:33:13,000
对他们有时间有的是有的是人有的是时间多少个博士生砸进去在搞这种事情

752
00:33:13,000 --> 00:33:15,000
但怎么说呢

753
00:33:15,000 --> 00:33:17,000
我觉得现在事情这样子

754
00:33:17,000 --> 00:33:22,000
就是说需要形式证明可靠性的东西可能是要求比较高的

755
00:33:22,000 --> 00:33:26,000
一个是刚刚我讲的虚拟机的 hypervisor

756
00:33:26,000 --> 00:33:30,000
另外一些就是之前我们提到的就是 mission critical 的东西

757
00:33:30,000 --> 00:33:34,000
什么 NASA 的发火箭的代码

758
00:33:34,000 --> 00:33:37,000
什么 Tesla 的控制汽车行驶的代码

759
00:33:37,000 --> 00:33:39,000
对那些是需要经过这个东西来做的

760
00:33:39,000 --> 00:33:43,000
还有一些事情是我们觉得过去觉得可能无关紧

761
00:33:43,000 --> 00:33:47,000
但是其实是急需要形式证明去证明它是安全可靠的

762
00:33:47,000 --> 00:33:49,000
就是我们现在互联网底层的一些

763
00:33:49,000 --> 00:33:53,000
包括一些不是互联网底层

764
00:33:53,000 --> 00:33:56,000
就是我们现在计算机硬件底层一些涉及到安全相关的东西

765
00:33:56,000 --> 00:33:57,000
对吧

766
00:33:57,000 --> 00:33:57,000
前段时间

767
00:33:57,000 --> 00:34:02,000
去年和今年连续爆出来的多个重大的安全漏洞

768
00:34:02,000 --> 00:34:07,000
都是都不是因为测试可以简单的覆盖得到的

769
00:34:07,000 --> 00:34:09,000
我觉得不是靠测试可以解决的

770
00:34:09,000 --> 00:34:11,000
没错没错

771
00:34:11,000 --> 00:34:15,000
就你真的是要去证明它每一行代码是进那去推敲的

772
00:34:15,000 --> 00:34:18,000
因为那么有那些 bug 非常非常隐晦

773
00:34:18,000 --> 00:34:22,000
因为通常的课程你根本想不到会是那么一种方式去出错

774
00:34:22,000 --> 00:34:27,000
所以我觉得看这个东西的重要性吧

775
00:34:27,000 --> 00:34:29,000
我觉得如果是足够重要的话

776
00:34:29,000 --> 00:34:32,000
还是要通过形式证明的方式来来它更好

777
00:34:32,000 --> 00:34:34,000
但是我觉得确实没错

778
00:34:34,000 --> 00:34:36,000
对绝大多数这种商业性的项目来讲

779
00:34:36,000 --> 00:34:40,000
你能给的写测试都已经不错了

780
00:34:40,000 --> 00:34:41,000
你还要求什么形式证明

781
00:34:41,000 --> 00:34:42,000
这不是痴人说梦

782
00:34:42,000 --> 00:34:44,000
对

783
00:34:44,000 --> 00:34:48,000
接下来的一篇

784
00:34:48,000 --> 00:34:52,000
刚才你这个还没念完

785
00:34:52,000 --> 00:34:53,000
你把这个结尾念完

786
00:34:53,000 --> 00:34:54,000
对

787
00:34:54,000 --> 00:34:57,000
然后他在结尾说了一个事情

788
00:34:57,000 --> 00:34:57,000
就是说

789
00:34:57,000 --> 00:35:00,000
现在再回过头来看当初的竞赛测试

790
00:35:00,000 --> 00:35:03,000
也许按那个一二三步的流程来

791
00:35:03,000 --> 00:35:04,000
能更好的完成比赛

792
00:35:04,000 --> 00:35:06,000
低效程序保证了正确性

793
00:35:06,000 --> 00:35:09,000
数据生成帮助思考编解条件

794
00:35:09,000 --> 00:35:12,000
最终程序来优化拿高分

795
00:35:12,000 --> 00:35:14,000
总之测试最大的价值

796
00:35:14,000 --> 00:35:16,000
可能不在于它本身

797
00:35:16,000 --> 00:35:17,000
而在于它给我们带来的

798
00:35:17,000 --> 00:35:19,000
对代码更加深入的理解

799
00:35:19,000 --> 00:35:21,000
这个其实我挺认可的

800
00:35:21,000 --> 00:35:22,000
但他刚才我忘了说

801
00:35:22,000 --> 00:35:23,000
刚才他讲那个一二三步的步骤

802
00:35:23,000 --> 00:35:25,000
为什么会有这个东西

803
00:35:25,000 --> 00:35:27,000
因为在各种各样的这种什么

804
00:35:27,000 --> 00:35:28,000
程序竞赛

805
00:35:28,000 --> 00:35:29,000
ACM 这种比赛

806
00:35:29,000 --> 00:35:32,000
他们他的逻辑一般的是这么给的

807
00:35:32,000 --> 00:35:34,000
他先给你一个所谓的

808
00:35:34,000 --> 00:35:35,000
一个提本的描述

809
00:35:35,000 --> 00:35:35,000
让你做一件事

810
00:35:35,000 --> 00:35:37,000
然后他会给你一个 sample

811
00:35:37,000 --> 00:35:40,000
其实就是一个测试的样本

812
00:35:40,000 --> 00:35:42,000
然后你要用你的程序去跑

813
00:35:42,000 --> 00:35:44,000
这个三口看大致对不对

814
00:35:44,000 --> 00:35:45,000
你就大致对了

815
00:35:45,000 --> 00:35:46,000
你就把你的程序提交到

816
00:35:46,000 --> 00:35:49,000
他们那个平台上面去

817
00:35:49,000 --> 00:35:50,000
平台再用这个东西

818
00:35:50,000 --> 00:35:52,000
跑一个更大的样本

819
00:35:52,000 --> 00:35:53,000
去看你这个代码

820
00:35:53,000 --> 00:35:54,000
是否得到的结果

821
00:35:54,000 --> 00:35:56,000
是否如预期所料

822
00:35:56,000 --> 00:35:56,000
对吧

823
00:35:56,000 --> 00:35:57,000
对

824
00:35:57,000 --> 00:35:58,000
如果全都正确的话

825
00:35:58,000 --> 00:35:59,000
就说意思

826
00:35:59,000 --> 00:36:00,000
对

827
00:36:00,000 --> 00:36:02,000
其实就是有点黑合的意思

828
00:36:02,000 --> 00:36:03,000
就是他给你一个

829
00:36:03,000 --> 00:36:07,000
一小组数据上你去验证你的程序代码怎么样

830
00:36:07,000 --> 00:36:10,000
所以他在这种用力的场合下

831
00:36:10,000 --> 00:36:13,000
用那个就是他那个 123

832
00:36:13,000 --> 00:36:14,000
刚才那个步骤来讲

833
00:36:14,000 --> 00:36:15,000
其实还蛮好的

834
00:36:15,000 --> 00:36:17,000
但是我不太清楚在实际工程中

835
00:36:17,000 --> 00:36:21,000
有多少人会遵循这么一种方式去做

836
00:36:21,000 --> 00:36:23,000
对

837
00:36:23,000 --> 00:36:29,000
我之前在 Coursera 上上了一门课

838
00:36:29,000 --> 00:36:34,000
也是基本上也是以 TDD 的方式来查你的作业

839
00:36:34,000 --> 00:36:36,000
就是给你闹题

840
00:36:36,000 --> 00:36:39,000
然后让你把程序传上去

841
00:36:39,000 --> 00:36:41,000
他其实本质上就是在后台跑

842
00:36:41,000 --> 00:36:45,000
跑这个大堆 DocTest

843
00:36:45,000 --> 00:36:47,000
就是 PythonDocTest

844
00:36:47,000 --> 00:36:49,000
然后最后来告诉你是不是证据

845
00:36:49,000 --> 00:36:52,000
但在实际生产之中

846
00:36:52,000 --> 00:36:54,000
我能想到的基本上就是

847
00:36:54,000 --> 00:36:56,000
每天你写完的程序

848
00:36:56,000 --> 00:37:00,000
他会把所有的单元测试自动跑一遍

849
00:37:00,000 --> 00:37:03,000
然后告诉你今天写的这些东西

850
00:37:03,000 --> 00:37:05,000
质量怎么样

851
00:37:05,000 --> 00:37:07,000
然后也会告诉你说

852
00:37:07,000 --> 00:37:13,000
比如有个叫 Sona 的软件

853
00:37:13,000 --> 00:37:14,000
可以告诉你说你写的代码

854
00:37:14,000 --> 00:37:17,000
没有多少被测试覆盖到

855
00:37:17,000 --> 00:37:18,000
OK

856
00:37:18,000 --> 00:37:21,000
然后如果你今天写的代码很多

857
00:37:21,000 --> 00:37:23,000
但是覆盖率却降低了的话

858
00:37:23,000 --> 00:37:24,000
你基本上可以知道

859
00:37:24,000 --> 00:37:29,000
你做的东西出来可能不是特别的可靠

860
00:37:29,000 --> 00:37:33,000
这不觉得其实挺悲剧的吗

861
00:37:33,000 --> 00:37:35,000
我觉得如果你写一段代码

862
00:37:35,000 --> 00:37:40,000
你都不能自己在不经过机器测试的情况下

863
00:37:40,000 --> 00:37:42,000
对自己写出来代码的质量有足够的信心

864
00:37:42,000 --> 00:37:48,000
我觉得反正我是不太喜欢这种心态的至少

865
00:37:48,000 --> 00:37:51,000
就一切靠测试去给你增加你的自信

866
00:37:51,000 --> 00:37:54,000
我觉得是这样的吧

867
00:37:54,000 --> 00:37:57,000
就这里面有一个信心积累的过程

868
00:37:57,000 --> 00:38:02,000
你那些 AT&T 早期的黑客们肯定也不是用 TDD 的

869
00:38:02,000 --> 00:38:08,000
但是你要在一个比较大的公司里面工作

870
00:38:08,000 --> 00:38:15,000
然后你也没有办法保证你和你的所有的同事们都能够写出来同样高质量的代码

871
00:38:15,000 --> 00:38:18,000
然后你也没有办法保证

872
00:38:18,000 --> 00:38:26,000
你的同事自信满满的写出来的代码就像他希望的那样高质量

873
00:38:26,000 --> 00:38:32,000
那在这个情况下怎么样来维护一道准绳

874
00:38:32,000 --> 00:38:43,000
那其实单元测试覆盖率和单元测试的存在本身就已经是一种保护

875
00:38:43,000 --> 00:38:44,000
一种保障

876
00:38:44,000 --> 00:38:48,000
所以你这么说的潜台词我这么理解

877
00:38:48,000 --> 00:38:58,000
就是说这是一个保障若干平庸的证据员能够写出质量还测合过得去的一个管理手段

878
00:38:58,000 --> 00:39:03,000
我觉得 TDD 在很大程度上就像我说的很印度

879
00:39:03,000 --> 00:39:04,000
其实就是这个意思

880
00:39:04,000 --> 00:39:11,000
它是工程就是人类转建工程的规模逐渐大起来

881
00:39:11,000 --> 00:39:15,000
所不得不采用的一种相关的手段

882
00:39:15,000 --> 00:39:18,000
对啊

883
00:39:18,000 --> 00:39:25,000
其实没有太值得去去吃它的事情

884
00:39:25,000 --> 00:39:29,000
因为你没有更好的方法

885
00:39:29,000 --> 00:39:34,000
不然你找一个怎么样的方法来判断一个代码是不是好了

886
00:39:34,000 --> 00:39:35,000
没错

887
00:39:35,000 --> 00:39:43,000
但是其实这里还可以扯到一个就是我们上期节目里面没有提到的测试覆盖率这个指标

888
00:39:43,000 --> 00:39:45,000
你觉得理想的测试覆盖率是多少

889
00:39:45,000 --> 00:39:48,000
其实一个比较幼稚的代码就少

890
00:39:48,000 --> 00:39:49,000
百分之百覆盖

891
00:39:49,000 --> 00:39:51,000
其实非常非常难的

892
00:39:51,000 --> 00:39:56,000
而且如果真的要写到百分之百测试的测试覆盖率的话

893
00:39:56,000 --> 00:39:59,000
可能时间成本是

894
00:39:59,000 --> 00:40:03,000
时间成本非常惊人的

895
00:40:03,000 --> 00:40:06,000
而且有一些东西是根本没有办法测试的

896
00:40:06,000 --> 00:40:08,000
比如说你 CSS 你要怎么测试

897
00:40:08,000 --> 00:40:15,000
所以一个比较理想的测试覆盖率其实是在 50%左右

898
00:40:15,000 --> 00:40:18,000
然后如果你能达到 85%的话

899
00:40:18,000 --> 00:40:21,000
基本上就是极端高质量的代码

900
00:40:21,000 --> 00:40:23,000
等等

901
00:40:23,000 --> 00:40:26,000
代码的质量为什么会和测试覆盖率所长关系

902
00:40:26,000 --> 00:40:29,000
就是极端可靠的代码

903
00:40:29,000 --> 00:40:31,000
这个意思明白明白

904
00:40:31,000 --> 00:40:32,000
不是高质量

905
00:40:32,000 --> 00:40:33,000
不一定高质量

906
00:40:33,000 --> 00:40:34,000
但至少是可靠

907
00:40:34,000 --> 00:40:35,000
好吧

908
00:40:35,000 --> 00:40:38,000
我们进入到下一份读的来信

909
00:40:38,000 --> 00:40:41,000
这位朋友的名字叫做张浩忠

910
00:40:41,000 --> 00:40:42,000
应该是

911
00:40:42,000 --> 00:40:44,000
嗨 吴涛和瑞

912
00:40:44,000 --> 00:40:46,000
我非常喜欢你们主持的 podcast 节目

913
00:40:46,000 --> 00:40:47,000
内核恐慌

914
00:40:47,000 --> 00:40:51,000
限于一个理工科学生语文有限的表达能力

915
00:40:51,000 --> 00:40:53,000
此处省略一美之词一万词

916
00:40:53,000 --> 00:40:56,000
非常感谢

917
00:40:56,000 --> 00:40:58,000
这压缩率好高啊

918
00:40:58,000 --> 00:41:04,000
比金军没压缩率

919
00:41:04,000 --> 00:41:09,000
作为一个研究方向为 formal verification 的老博士

920
00:41:09,000 --> 00:41:12,000
我想评论一下第十九期之中

921
00:41:12,000 --> 00:41:14,000
归于 formal verification 的部分内容

922
00:41:14,000 --> 00:41:16,000
终于来了专业人士

923
00:41:16,000 --> 00:41:16,000
我好激动

924
00:41:16,000 --> 00:41:20,000
首先如两位主播所言

925
00:41:20,000 --> 00:41:22,000
formal verification 的中文翻译

926
00:41:22,000 --> 00:41:24,000
通常为形式化验证

927
00:41:24,000 --> 00:41:28,000
这里仅讨论对软件的 formal verification

928
00:41:28,000 --> 00:41:33,000
其实 formal verification 和测试都在试图解决相同的问题

929
00:41:33,000 --> 00:41:38,000
也就是给定人们对一个程序的行为的预期

930
00:41:38,000 --> 00:41:40,000
例如给什么样的输出

931
00:41:40,000 --> 00:41:41,000
有什么样的输入

932
00:41:41,000 --> 00:41:43,000
给什么样的输出

933
00:41:43,000 --> 00:41:44,000
有什么样的输出

934
00:41:44,000 --> 00:41:48,000
给什么样的输入

935
00:41:48,000 --> 00:41:49,000
有什么样的输出

936
00:41:49,000 --> 00:41:51,000
运行的时间效率

937
00:41:51,000 --> 00:41:53,000
甚至程序的功耗等等

938
00:41:53,000 --> 00:41:58,000
以及这个程序本身构建一个 witness

939
00:41:58,000 --> 00:42:02,000
以表明这个程序的确能够提供预期的行为

940
00:42:02,000 --> 00:42:06,000
通常我们称这些预期行为为程序的规范

941
00:42:06,000 --> 00:42:08,000
也就是 specification

942
00:42:08,000 --> 00:42:13,000
而称这个程序本身为这个 specification 的一个实现

943
00:42:13,000 --> 00:42:15,000
也就是 implementation

944
00:42:15,000 --> 00:42:21,000
formal verification 和测试使用不同的手段来试图构造这样一个 witness

945
00:42:21,000 --> 00:42:24,000
对于 formal verification 来说

946
00:42:24,000 --> 00:42:29,000
它使用数学和逻辑语言表示 specification 和 implementation

947
00:42:29,000 --> 00:42:33,000
并通过数学和逻辑严格证明 implementation

948
00:42:33,000 --> 00:42:39,000
在任何可能的情况下都能够满足 specification

949
00:42:39,000 --> 00:42:41,000
而对于测试

950
00:42:41,000 --> 00:42:42,000
在很多情况之下

951
00:42:42,000 --> 00:42:47,000
specification 使用和 implementation 一样的语言表

952
00:42:47,000 --> 00:42:49,000
也就是一个一个的测试用力

953
00:42:49,000 --> 00:42:53,000
测试保证如果一个测试用力被执行到

954
00:42:53,000 --> 00:42:57,000
那么可以通过这个测试用力的执行结果

955
00:42:57,000 --> 00:42:59,000
来检查 implementation 的正确与否

956
00:42:59,000 --> 00:43:03,000
但是如果一个测试用力没有被执行到

957
00:43:03,000 --> 00:43:07,000
或者测试用力没有覆盖到程序的所有可能执行路径

958
00:43:07,000 --> 00:43:09,000
那么测试就无能为力

959
00:43:09,000 --> 00:43:15,000
似乎这样看来 formal verification 可以提供比测试更严格和有效的

960
00:43:15,000 --> 00:43:20,000
对于程序正确性的保证

961
00:43:20,000 --> 00:43:22,000
工业界得到更为广泛的应用

962
00:43:22,000 --> 00:43:24,000
但是目前而言

963
00:43:24,000 --> 00:43:26,000
formal verification 的性价比太低

964
00:43:26,000 --> 00:43:27,000
并且对于使用的

965
00:43:27,000 --> 00:43:30,000
使用者的要求也太高了

966
00:43:30,000 --> 00:43:33,000
一方面平均验证一行员程序

967
00:43:33,000 --> 00:43:37,000
大概需要几百行甚至更多的形式化证明代码

968
00:43:37,000 --> 00:43:38,000
口号

969
00:43:38,000 --> 00:43:38,000
是的

970
00:43:38,000 --> 00:43:42,000
我们有专门用于形式化证明的程序语言

971
00:43:42,000 --> 00:43:44,000
口号结束

972
00:43:44,000 --> 00:43:46,000
而且在很多情况之下

973
00:43:46,000 --> 00:43:48,000
这些证明没有办法自动生成

974
00:43:48,000 --> 00:43:51,000
并且要耗费大量的时间去创造

975
00:43:51,000 --> 00:43:53,000
另一方面

976
00:43:53,000 --> 00:43:56,000
对于能够进行 formal verification 的人

977
00:43:56,000 --> 00:44:01,000
他既要对验证的对象有着深刻的理解

978
00:44:01,000 --> 00:44:06,000
比如我为了验证一个 hypervisor 中很小的一部分功能

979
00:44:06,000 --> 00:44:11,000
从零开始写了一个能够实际工作在 X 86 机器上的

980
00:44:11,000 --> 00:44:15,000
可以同时运行多个 Linux 虚拟机的实验性的 hypervisor

981
00:44:15,000 --> 00:44:16,000
口号完毕

982
00:44:16,000 --> 00:44:23,000
又要有足够和复杂的数学与逻辑学知识

983
00:44:23,000 --> 00:44:25,000
口号各种抽象代数

984
00:44:25,000 --> 00:44:26,000
数理逻辑

985
00:44:26,000 --> 00:44:27,000
集合论

986
00:44:27,000 --> 00:44:28,000
范畴论什么的

987
00:44:28,000 --> 00:44:29,000
口号结束

988
00:44:29,000 --> 00:44:30,000
相对而言

989
00:44:30,000 --> 00:44:35,000
目前的测试则可以在相对可控的成本之下提供不完美

990
00:44:35,000 --> 00:44:39,000
但是在多数情况下足够好和易于实现的解决方案

991
00:44:39,000 --> 00:44:49,000
其次我要吐槽一下节目中所说到的对于非确定性的程序很难验证只好测试的观点

992
00:44:49,000 --> 00:44:51,000
这还是我说的吧

993
00:44:51,000 --> 00:44:55,000
恰恰相反对于非确定性程序

994
00:44:55,000 --> 00:45:00,000
特别是并发程序和操作系统内核之中设计中断的代码

995
00:45:00,000 --> 00:45:05,000
formal verification 可以非常简洁和严格的表达并证明它们的正确性

996
00:45:05,000 --> 00:45:09,000
而测试此时更多是向在碰运气

997
00:45:09,000 --> 00:45:13,000
以操作系统的内核中可以被中断的代码片段为例

998
00:45:13,000 --> 00:45:18,000
在这个淡码片段的每一条指令的直行可能被中断打断

999
00:45:18,000 --> 00:45:21,000
也就是说每一条指令的直行有可能有二条路径

1000
00:45:21,000 --> 00:45:26,000
所以一个包含 N 条路径的 N 条指令的代码段

1001
00:45:26,000 --> 00:45:31,000
可能有 2 REST POWER OF N 个直行路径

1002
00:45:31,000 --> 00:45:35,000
因为在实际的机器上中断的发生是不确定的

1003
00:45:35,000 --> 00:45:41,000
所以测试很难保证在短时间内能够覆盖到所有的直行路径

1004
00:45:41,000 --> 00:45:45,000
相对的在 formal verification 之中举个例子

1005
00:45:45,000 --> 00:45:50,000
我们可以把每条指令的直行化形式表示成

1006
00:45:50,000 --> 00:45:52,000
这应该怎么念

1007
00:45:52,000 --> 00:45:55,000
你真的想念

1008
00:45:55,000 --> 00:45:57,000
P C Q

1009
00:45:57,000 --> 00:46:00,000
其中 C 是这条指令

1010
00:46:00,000 --> 00:46:01,000
P 称为前条件

1011
00:46:01,000 --> 00:46:03,000
也就是 precondition

1012
00:46:03,000 --> 00:46:07,000
它描述了 C 执行之前机器的状态

1013
00:46:07,000 --> 00:46:10,000
例如某个计存器的直是什么

1014
00:46:10,000 --> 00:46:12,000
某个内存单元的直是什么

1015
00:46:12,000 --> 00:46:15,000
通常不需要覆盖所有的计存器的内存单元

1016
00:46:15,000 --> 00:46:20,000
仅需要根据验证的

1017
00:46:20,000 --> 00:46:22,000
specification 选取我们说关系的

1018
00:46:22,000 --> 00:46:24,000
Q 称为后条件

1019
00:46:24,000 --> 00:46:25,000
也就是 post condition

1020
00:46:25,000 --> 00:46:29,000
它描述了 C 执行之后的机器状态

1021
00:46:29,000 --> 00:46:29,000
注意

1022
00:46:29,000 --> 00:46:32,000
这里的 Q 同时描述

1023
00:46:32,000 --> 00:46:34,000
同时描述了 C 被中断

1024
00:46:34,000 --> 00:46:37,000
和不被中断的执行之后的机器状态

1025
00:46:37,000 --> 00:46:39,000
非形式化的

1026
00:46:39,000 --> 00:46:41,000
P C Q

1027
00:46:41,000 --> 00:46:43,000
表示在满足前条件

1028
00:46:43,000 --> 00:46:46,000
P 的机器上执行 C 之后

1029
00:46:46,000 --> 00:46:49,000
得到的机器状态满足后条件 Q

1030
00:46:49,000 --> 00:46:50,000
这样一来

1031
00:46:50,000 --> 00:46:52,000
对于上述的一个态表边段

1032
00:46:52,000 --> 00:46:53,000
C 1 C 2

1033
00:46:53,000 --> 00:46:55,000
一直到 CN

1034
00:46:55,000 --> 00:46:58,000
我们有 P 下标 1

1035
00:46:58,000 --> 00:46:59,000
C 下标 1

1036
00:46:59,000 --> 00:47:01,000
Q 下标 1

1037
00:47:01,000 --> 00:47:02,000
P 下标 2

1038
00:47:02,000 --> 00:47:03,000
C 下标 2

1039
00:47:03,000 --> 00:47:04,000
Q 下标 2

1040
00:47:04,000 --> 00:47:06,000
一直到 P 下标 N

1041
00:47:06,000 --> 00:47:07,000
C 下标 N

1042
00:47:07,000 --> 00:47:08,000
Q 下标 N

1043
00:47:08,000 --> 00:47:09,000
然后我们可以证明

1044
00:47:09,000 --> 00:47:10,000
Q 下标 1

1045
00:47:10,000 --> 00:47:13,000
这应该怎么念呢

1046
00:47:13,000 --> 00:47:15,000
推导出

1047
00:47:15,000 --> 00:47:18,000
implies

1048
00:47:18,000 --> 00:47:20,000
应该是 implies

1049
00:47:20,000 --> 00:47:22,000
然后我们可以证明出

1050
00:47:22,000 --> 00:47:23,000
如果有 Q 1

1051
00:47:23,000 --> 00:47:24,000
那么一定有 P 2

1052
00:47:24,000 --> 00:47:29,000
不对

1053
00:47:29,000 --> 00:47:30,000
这个是

1054
00:47:30,000 --> 00:47:31,000
然后我们可以证明

1055
00:47:31,000 --> 00:47:32,000
Q 下标 1

1056
00:47:32,000 --> 00:47:33,000
可以推导出

1057
00:47:33,000 --> 00:47:34,000
P 下标 2

1058
00:47:34,000 --> 00:47:36,000
一直到 Q 下标 N

1059
00:47:36,000 --> 00:47:36,000
减 1

1060
00:47:36,000 --> 00:47:38,000
可以推导出

1061
00:47:38,000 --> 00:47:39,000
P 下标 N

1062
00:47:39,000 --> 00:47:41,000
从而可以证明

1063
00:47:41,000 --> 00:47:43,000
P 下标 1

1064
00:47:43,000 --> 00:47:44,000
C 下标 1

1065
00:47:44,000 --> 00:47:45,000
C 下标 2

1066
00:47:45,000 --> 00:47:46,000
一直到

1067
00:47:46,000 --> 00:47:48,000
C 下标 N

1068
00:47:48,000 --> 00:47:49,000
Q 下标 N

1069
00:47:49,000 --> 00:47:50,000
同样的

1070
00:47:50,000 --> 00:47:52,000
如果在这个代码片段的

1071
00:47:52,000 --> 00:47:52,000
specification

1072
00:47:52,000 --> 00:47:53,000
可以写成

1073
00:47:53,000 --> 00:47:54,000
例如

1074
00:47:54,000 --> 00:47:55,000
P

1075
00:47:55,000 --> 00:47:56,000
C 下标 1

1076
00:47:56,000 --> 00:47:57,000
C 下标 2

1077
00:47:57,000 --> 00:48:00,000
一直到

1078
00:48:00,000 --> 00:48:01,000
C 下标 N

1079
00:48:01,000 --> 00:48:01,000
Q

1080
00:48:01,000 --> 00:48:03,000
我们只需要再证明

1081
00:48:03,000 --> 00:48:03,000
P

1082
00:48:03,000 --> 00:48:05,000
可以推导出

1083
00:48:05,000 --> 00:48:06,000
P 下标 1

1084
00:48:06,000 --> 00:48:07,000
和 Q 下标 N

1085
00:48:07,000 --> 00:48:08,000
可以推导出

1086
00:48:08,000 --> 00:48:08,000
Q

1087
00:48:08,000 --> 00:48:09,000
也就是

1088
00:48:09,000 --> 00:48:11,000
也就可以证明

1089
00:48:11,000 --> 00:48:12,000
这个代码片段

1090
00:48:12,000 --> 00:48:14,000
的确满足了

1091
00:48:14,000 --> 00:48:15,000
给定的 specification

1092
00:48:15,000 --> 00:48:16,000
因为这里的

1093
00:48:16,000 --> 00:48:17,000
P

1094
00:48:17,000 --> 00:48:17,000
Q

1095
00:48:17,000 --> 00:48:18,000
P 下标 I

1096
00:48:18,000 --> 00:48:19,000
Q 下标 I

1097
00:48:19,000 --> 00:48:19,000
等等

1098
00:48:19,000 --> 00:48:20,000
描述了所有的

1099
00:48:20,000 --> 00:48:21,000
可能状况

1100
00:48:21,000 --> 00:48:23,000
并且只需要描述

1101
00:48:23,000 --> 00:48:23,000
specification

1102
00:48:23,000 --> 00:48:24,000
关心的部分

1103
00:48:24,000 --> 00:48:26,000
所以这里的 formal application

1104
00:48:26,000 --> 00:48:28,000
比测试更加完备和简洁

1105
00:48:28,000 --> 00:48:29,000
在实际工作中

1106
00:48:29,000 --> 00:48:31,000
我们往往会针对

1107
00:48:31,000 --> 00:48:33,000
验证的所有程序的特点

1108
00:48:33,000 --> 00:48:35,000
设定特定的逻辑系统

1109
00:48:35,000 --> 00:48:38,000
以进一步降低证明的难度和复杂度

1110
00:48:38,000 --> 00:48:41,000
我念

1111
00:48:41,000 --> 00:48:43,000
我在读这段文章的时候

1112
00:48:43,000 --> 00:48:45,000
大概明白他在说什么

1113
00:48:45,000 --> 00:48:46,000
但是我念出来之后

1114
00:48:46,000 --> 00:48:47,000
发现自己根本不明白他在说什么

1115
00:48:47,000 --> 00:48:49,000
其实很简单

1116
00:48:49,000 --> 00:48:50,000
刚才那一段话

1117
00:48:50,000 --> 00:48:53,000
你听众肯定是没听明白

1118
00:48:53,000 --> 00:48:54,000
你也没有看见那个东西

1119
00:48:54,000 --> 00:48:56,000
我觉得这一段还是比较

1120
00:48:56,000 --> 00:48:58,000
把它 po 出来比较好

1121
00:48:58,000 --> 00:49:00,000
其实那句话

1122
00:49:00,000 --> 00:49:02,000
其实有个比较直白的解释

1123
00:49:02,000 --> 00:49:03,000
就是说

1124
00:49:03,000 --> 00:49:04,000
你有一串代码

1125
00:49:04,000 --> 00:49:09,000
每一步都会有一个所谓的前条件

1126
00:49:09,000 --> 00:49:10,000
就是所谓前因后果

1127
00:49:10,000 --> 00:49:12,000
你执行在这一个步骤之前

1128
00:49:12,000 --> 00:49:14,000
是一个什么样的状况

1129
00:49:14,000 --> 00:49:14,000
执行之后

1130
00:49:14,000 --> 00:49:16,000
你预期它是什么样的状况

1131
00:49:16,000 --> 00:49:17,000
然后如果你能够把

1132
00:49:17,000 --> 00:49:20,000
前面一条代码的结果

1133
00:49:20,000 --> 00:49:21,000
推到那个状况

1134
00:49:21,000 --> 00:49:23,000
推到后面一个

1135
00:49:23,000 --> 00:49:26,000
一行代码的

1136
00:49:26,000 --> 00:49:27,000
这个叫做前因

1137
00:49:27,000 --> 00:49:29,000
你能把东西连续的串起来

1138
00:49:29,000 --> 00:49:30,000
你只能证明这个东西

1139
00:49:30,000 --> 00:49:32,000
整个这个代码片段的

1140
00:49:32,000 --> 00:49:33,000
这个可靠性

1141
00:49:33,000 --> 00:49:36,000
这个是我上学的时候

1142
00:49:36,000 --> 00:49:39,000
不提醒作业要做的一个

1143
00:49:39,000 --> 00:49:40,000
一部分

1144
00:49:40,000 --> 00:49:41,000
现在看来就是

1145
00:49:41,000 --> 00:49:42,000
好痛苦啊

1146
00:49:42,000 --> 00:49:43,000
OK

1147
00:49:43,000 --> 00:49:45,000
所以其实它就是一个状态机

1148
00:49:45,000 --> 00:49:46,000
然后如果你能证明

1149
00:49:46,000 --> 00:49:47,000
这个状态机的每一步

1150
00:49:47,000 --> 00:49:49,000
都是可以达到的

1151
00:49:49,000 --> 00:49:50,000
或者说每一步

1152
00:49:50,000 --> 00:49:52,000
状态机的每一个状态

1153
00:49:52,000 --> 00:49:53,000
都是彼此相连的

1154
00:49:53,000 --> 00:49:55,000
那整个状态机的可靠性

1155
00:49:55,000 --> 00:49:56,000
就是可以被验证

1156
00:49:56,000 --> 00:49:57,000
大概是这个意思吧

1157
00:49:57,000 --> 00:49:59,000
有点那个意思

1158
00:49:59,000 --> 00:49:59,000
对

1159
00:49:59,000 --> 00:50:00,000
OK

1160
00:50:00,000 --> 00:50:01,000
我没有学过这种东西

1161
00:50:01,000 --> 00:50:04,000
我们通讯就是不学这种

1162
00:50:04,000 --> 00:50:04,000
让人头大的

1163
00:50:04,000 --> 00:50:09,000
其实它不算难

1164
00:50:09,000 --> 00:50:11,000
但是非常繁琐

1165
00:50:12,000 --> 00:50:13,000
感觉像截九连环

1166
00:50:13,000 --> 00:50:14,000
对

1167
00:50:14,000 --> 00:50:14,000
对

1168
00:50:14,000 --> 00:50:14,000
对

1169
00:50:14,000 --> 00:50:15,000
非常

1170
00:50:15,000 --> 00:50:16,000
给出下面一步

1171
00:50:16,000 --> 00:50:18,000
你需要达到前面那一步

1172
00:50:18,000 --> 00:50:18,000
对

1173
00:50:18,000 --> 00:50:20,000
你要一步去弄那个东西

1174
00:50:20,000 --> 00:50:21,000
其实所以

1175
00:50:21,000 --> 00:50:22,000
为什么讲

1176
00:50:22,000 --> 00:50:24,000
要有专门的这个程序

1177
00:50:24,000 --> 00:50:24,000
去那个

1178
00:50:24,000 --> 00:50:26,000
那种语言

1179
00:50:26,000 --> 00:50:27,000
去基于各种

1180
00:50:27,000 --> 00:50:29,000
各样的 logic 的方法

1181
00:50:29,000 --> 00:50:31,000
去证明那东西

1182
00:50:31,000 --> 00:50:33,000
就是想把这个繁琐的东西

1183
00:50:33,000 --> 00:50:34,000
机械化

1184
00:50:34,000 --> 00:50:35,000
让机械去做

1185
00:50:35,000 --> 00:50:36,000
我们人只用把那个

1186
00:50:36,000 --> 00:50:38,000
specification 给好就可以了

1187
00:50:38,000 --> 00:50:39,000
但是其实你在

1188
00:50:39,000 --> 00:50:40,000
真正在做的时候

1189
00:50:40,000 --> 00:50:41,000
就正如

1190
00:50:41,000 --> 00:50:42,000
那个

1191
00:50:42,000 --> 00:50:43,000
就是什么

1192
00:50:43,000 --> 00:50:44,000
张博士所言

1193
00:50:44,000 --> 00:50:46,000
你为了验证一行代码的

1194
00:50:46,000 --> 00:50:47,000
这个可靠性

1195
00:50:47,000 --> 00:50:48,000
然后去证明

1196
00:50:48,000 --> 00:50:49,000
它是否符合

1197
00:50:49,000 --> 00:50:50,000
这个某个 spec

1198
00:50:50,000 --> 00:50:52,000
你可能要再写

1199
00:50:52,000 --> 00:50:53,000
好多好多遍的代码

1200
00:50:53,000 --> 00:50:55,000
对

1201
00:50:55,000 --> 00:50:56,000
没错

1202
00:50:56,000 --> 00:50:58,000
接着你来这封信

1203
00:50:58,000 --> 00:50:59,000
另一个体现

1204
00:50:59,000 --> 00:51:00,000
formal verification

1205
00:51:00,000 --> 00:51:01,000
比测试强大的地方

1206
00:51:01,000 --> 00:51:02,000
是对于各种

1207
00:51:02,000 --> 00:51:04,000
lockless algorithm 的

1208
00:51:04,000 --> 00:51:05,000
实现的正确性的验证

1209
00:51:05,000 --> 00:51:08,000
也就是无所的算法的

1210
00:51:08,000 --> 00:51:10,000
实现的正确性的验证

1211
00:51:10,000 --> 00:51:11,000
这是一个非常大

1212
00:51:11,000 --> 00:51:12,000
和复杂的话题

1213
00:51:12,000 --> 00:51:14,000
这里就不展开了

1214
00:51:14,000 --> 00:51:15,000
另外

1215
00:51:15,000 --> 00:51:16,000
学术界一直以来

1216
00:51:16,000 --> 00:51:17,000
都试图将

1217
00:51:17,000 --> 00:51:18,000
formal verification 的应用

1218
00:51:18,000 --> 00:51:21,000
应用到实际的软件

1219
00:51:21,000 --> 00:51:21,000
开发之中

1220
00:51:21,000 --> 00:51:22,000
目前两个

1221
00:51:22,000 --> 00:51:24,000
最为瞩目的结果是

1222
00:51:24,000 --> 00:51:25,000
cell 4

1223
00:51:25,000 --> 00:51:28,000
它是对一个

1224
00:51:28,000 --> 00:51:30,000
微内核操作系统的

1225
00:51:30,000 --> 00:51:32,000
完整的形式化验证

1226
00:51:32,000 --> 00:51:34,000
它的网址都很酷

1227
00:51:34,000 --> 00:51:35,000
叫做

1228
00:51:35,000 --> 00:51:36,000
htps

1229
00:51:36,000 --> 00:51:37,000
slash

1230
00:51:37,000 --> 00:51:38,000
slash

1231
00:51:38,000 --> 00:51:39,000
sell

1232
00:51:39,000 --> 00:51:40,000
slash

1233
00:51:40,000 --> 00:51:41,000
sl 4

1234
00:51:41,000 --> 00:51:41,000
dot

1235
00:51:41,000 --> 00:51:42,000
systems

1236
00:51:42,000 --> 00:51:45,000
所以

1237
00:51:45,000 --> 00:51:46,000
dot

1238
00:51:46,000 --> 00:51:47,000
systems 是一个顶级域名吗

1239
00:51:47,000 --> 00:51:49,000
你不知道吗

1240
00:51:49,000 --> 00:51:50,000
现在有一批各种各样

1241
00:51:50,000 --> 00:51:52,000
其实怪怪的新的顶级

1242
00:51:52,000 --> 00:51:52,000
冒出来

1243
00:51:52,000 --> 00:51:53,000
我知道

1244
00:51:53,000 --> 00:51:54,000
xxx

1245
00:51:54,000 --> 00:51:56,000
但是好像没有听说的 systems

1246
00:51:56,000 --> 00:51:56,000
有多啦

1247
00:51:56,000 --> 00:51:57,000
有

1248
00:51:57,000 --> 00:51:57,000
dot

1249
00:51:57,000 --> 00:51:58,000
systems

1250
00:51:58,000 --> 00:51:58,000
还有各种

1251
00:51:58,000 --> 00:51:59,000
好像有

1252
00:51:59,000 --> 00:51:59,000
dot

1253
00:51:59,000 --> 00:52:00,000
beer 吧

1254
00:52:00,000 --> 00:52:01,000
OK

1255
00:52:01,000 --> 00:52:03,000
你可以注册一个

1256
00:52:03,000 --> 00:52:07,000
然后还有一个叫做 compcert

1257
00:52:07,000 --> 00:52:08,000
是法国

1258
00:52:08,000 --> 00:52:10,000
inria

1259
00:52:10,000 --> 00:52:13,000
实现的一个验证过的 C 语言编译器

1260
00:52:13,000 --> 00:52:18,000
曾经用在 Airbus 空客的记载软件的开发之中

1261
00:52:18,000 --> 00:52:19,000
这个很

1262
00:52:19,000 --> 00:52:20,000
这个很屌

1263
00:52:20,000 --> 00:52:20,000
真的很牛

1264
00:52:20,000 --> 00:52:22,000
网址是 htp.slash

1265
00:52:22,000 --> 00:52:23,000
slash

1266
00:52:23,000 --> 00:52:24,000
compcert

1267
00:52:24,000 --> 00:52:26,000
C-O-M-P-C-E-R-T

1268
00:52:26,000 --> 00:52:27,000
dot

1269
00:52:27,000 --> 00:52:30,000
I-N-R-I-A

1270
00:52:30,000 --> 00:52:30,000
dot

1271
00:52:30,000 --> 00:52:31,000
F-R

1272
00:52:31,000 --> 00:52:32,000
最后

1273
00:52:32,000 --> 00:52:35,000
既然节目中提到了 TDD 和 BDD

1274
00:52:35,000 --> 00:52:42,000
那么我就不得不提到 formal verification 之中对应的叫做 program synthesis 的东西

1275
00:52:42,000 --> 00:52:46,000
程序合成的东西

1276
00:52:46,000 --> 00:52:48,000
简单来说就是软件开发之后

1277
00:52:48,000 --> 00:52:50,000
开发要先写 specification

1278
00:52:50,000 --> 00:52:53,000
和程序满足 specification 的数学证明

1279
00:52:53,000 --> 00:52:58,000
然后从这些证明自动生成满足 specification 的程序

1280
00:52:58,000 --> 00:53:00,000
前面提到的 compcert

1281
00:53:00,000 --> 00:53:02,000
主要就是用这种方法开发出来

1282
00:53:02,000 --> 00:53:03,000
简单来说

1283
00:53:03,000 --> 00:53:07,000
这个东西基于这样一个已经被证明的数学理论基础

1284
00:53:07,000 --> 00:53:10,000
计算和证明是等价的

1285
00:53:10,000 --> 00:53:12,000
当然

1286
00:53:12,000 --> 00:53:13,000
这么牛逼闪闪的东西

1287
00:53:13,000 --> 00:53:17,000
目前还有大量的理论和工程方面的问题需要解决

1288
00:53:17,000 --> 00:53:21,000
所以广大程序员在有生之年无需失业

1289
00:53:21,000 --> 00:53:24,000
而我在有生之年也不太靠这个东西发家之父

1290
00:53:24,000 --> 00:53:26,000
大概就是这些

1291
00:53:26,000 --> 00:53:29,000
刚才读到这些

1292
00:53:29,000 --> 00:53:31,000
就读到这部分的时候

1293
00:53:31,000 --> 00:53:32,000
我心里一领

1294
00:53:32,000 --> 00:53:33,000
就想说

1295
00:53:33,000 --> 00:53:34,000
卧靠

1296
00:53:34,000 --> 00:53:37,000
要是被这帮 freak 们搞出来

1297
00:53:37,000 --> 00:53:38,000
那我们这些

1298
00:53:38,000 --> 00:53:39,000
就下岗了

1299
00:53:39,000 --> 00:53:40,000
对

1300
00:53:40,000 --> 00:53:42,000
吃程序饭的人该怎么办呢

1301
00:53:42,000 --> 00:53:43,000
结果他说

1302
00:53:43,000 --> 00:53:45,000
有生之年无需担心事业

1303
00:53:45,000 --> 00:53:47,000
我心里的一颗大石头就放了

1304
00:53:47,000 --> 00:53:48,000
对

1305
00:53:48,000 --> 00:53:50,000
因为现在你说什么

1306
00:53:50,000 --> 00:53:53,000
就是蓝领的工种

1307
00:53:53,000 --> 00:53:54,000
被各种各样的机械化

1308
00:53:54,000 --> 00:53:55,000
自动化的东西

1309
00:53:55,000 --> 00:53:56,000
气带掉了

1310
00:53:56,000 --> 00:53:57,000
是吧

1311
00:53:57,000 --> 00:53:58,000
反正我觉得

1312
00:53:58,000 --> 00:54:01,000
是否在我们挂掉之前还不用担心

1313
00:54:01,000 --> 00:54:03,000
这个程序员这个工种被自动化掉

1314
00:54:03,000 --> 00:54:07,000
但是他提到这件事

1315
00:54:07,000 --> 00:54:10,000
就是计算和证明是等价的

1316
00:54:10,000 --> 00:54:16,000
所以一切可计算的东西都是可以证明的

1317
00:54:16,000 --> 00:54:17,000
这不是跟那个 P 等

1318
00:54:17,000 --> 00:54:20,000
是否等于 NP 那个东西是一个原理吗

1319
00:54:20,000 --> 00:54:22,000
哎呦

1320
00:54:22,000 --> 00:54:22,000
数

1321
00:54:22,000 --> 00:54:23,000
对

1322
00:54:23,000 --> 00:54:24,000
对吧

1323
00:54:24,000 --> 00:54:26,000
P 和 NP 是验证和可计算

1324
00:54:26,000 --> 00:54:29,000
这样我想到一件事情就是

1325
00:54:29,000 --> 00:54:33,000
我们在《请来默瑶》那一期的时候提到说

1326
00:54:33,000 --> 00:54:36,000
如果计算机能够做数学题的话

1327
00:54:36,000 --> 00:54:38,000
那它能不能证明数学题呢

1328
00:54:38,000 --> 00:54:43,000
就我记得当时在《默瑶》Blog 里面提到说

1329
00:54:43,000 --> 00:54:46,000
如果一个一台计算机可以证明一件东西的话

1330
00:54:46,000 --> 00:54:50,000
那将会是非常了不起的一件事

1331
00:54:50,000 --> 00:54:54,000
但是很遗憾的就是我们人类都有时候不太清楚

1332
00:54:54,000 --> 00:54:57,000
自己证明一个东西到底是怎样的一个过程

1333
00:54:57,000 --> 00:55:03,000
就我觉得如果脑洞大台有了这个

1334
00:55:03,000 --> 00:55:07,000
你告诉计算机说我要一个什么样的程序

1335
00:55:07,000 --> 00:55:11,000
就是给出这样一个程序的 specification

1336
00:55:11,000 --> 00:55:17,000
你还是要用自己的脑力来证明这个 specification

1337
00:55:17,000 --> 00:55:20,000
是可以为算出来的

1338
00:55:20,000 --> 00:55:23,000
这个过程终究还是不能用计算机来提的

1339
00:55:23,000 --> 00:55:27,000
所以也许将来的程序员们不一定需要自己去写程序

1340
00:55:27,000 --> 00:55:29,000
但他们仍旧需要自己去想出来

1341
00:55:29,000 --> 00:55:32,000
这个程序为什么可以为写出来

1342
00:55:32,000 --> 00:55:35,000
感觉又难了一些了

1343
00:55:35,000 --> 00:55:38,000
生活又艰辛了一点点

1344
00:55:38,000 --> 00:55:46,000
对将来就不是将来写程序这个职业就不再是一个仅仅受过中学教育

1345
00:55:46,000 --> 00:55:50,000
和一定培训的人就可以胜任的工作了

1346
00:55:50,000 --> 00:55:51,000
不像现在

1347
00:55:51,000 --> 00:55:53,000
你的意思是说蓝祥要关门了

1348
00:55:53,000 --> 00:55:57,000
其实我觉得是一件好事吧

1349
00:55:57,000 --> 00:56:02,000
就是现在你看我这样的人都可以来转行写程序

1350
00:56:02,000 --> 00:56:05,000
这自黑的漂亮

1351
00:56:05,000 --> 00:56:10,000
三号三号三号让程序的光环变得

1352
00:56:10,000 --> 00:56:12,000
没有那么圣洁了是不是

1353
00:56:12,000 --> 00:56:13,000
对

1354
00:56:13,000 --> 00:56:15,000
是一个邪恶光环

1355
00:56:15,000 --> 00:56:18,000
OK

1356
00:56:18,000 --> 00:56:19,000
好了

1357
00:56:19,000 --> 00:56:23,000
接下来是一个非常重头的反馈

1358
00:56:23,000 --> 00:56:27,000
这位听众网友不但写了一封很长什么信

1359
00:56:27,000 --> 00:56:33,000
最后还录了一个将近一个小时的视频来向我们展示这个 TDD

1360
00:56:33,000 --> 00:56:36,000
你来见吧

1361
00:56:36,000 --> 00:56:37,000
怎么办

1362
00:56:37,000 --> 00:56:38,000
来吧

1363
00:56:38,000 --> 00:56:38,000
我来吧

1364
00:56:38,000 --> 00:56:40,000
嗨

1365
00:56:40,000 --> 00:56:40,000
吴涛侯瑞

1366
00:56:40,000 --> 00:56:44,000
首先非常喜欢听你们的节目

1367
00:56:44,000 --> 00:56:45,000
已经从头追了一遍

1368
00:56:45,000 --> 00:56:46,000
受益匪浅

1369
00:56:46,000 --> 00:56:48,000
也是这反馈一次

1370
00:56:48,000 --> 00:56:55,000
作为一个已经被成功安利的 TDD 和 Pair Programming

1371
00:56:55,000 --> 00:56:55,000
这叫什么

1372
00:56:55,000 --> 00:56:57,000
结对编程是吧

1373
00:56:57,000 --> 00:56:57,000
对

1374
00:56:57,000 --> 00:56:57,000
对

1375
00:56:57,000 --> 00:56:59,000
两个人一块见他

1376
00:56:59,000 --> 00:57:00,000
对

1377
00:57:00,000 --> 00:57:00,000
的

1378
00:57:00,000 --> 00:57:01,000
践心者

1379
00:57:01,000 --> 00:57:02,000
那个践

1380
00:57:02,000 --> 00:57:09,000
最近四年的代码几乎都是被测试驱动出来的

1381
00:57:09,000 --> 00:57:09,000
可见中毒之声

1382
00:57:09,000 --> 00:57:12,000
我想反馈一些我自己的体会

1383
00:57:12,000 --> 00:57:15,000
我个人理解当然测试有两种作用

1384
00:57:15,000 --> 00:57:17,000
一个是保障作用

1385
00:57:17,000 --> 00:57:20,000
保障代码还是在按预期交付业务价值

1386
00:57:20,000 --> 00:57:21,000
这个就不提

1387
00:57:21,000 --> 00:57:22,000
另外一个是驱动作用

1388
00:57:22,000 --> 00:57:24,000
就是 TDD 中间那个 driven

1389
00:57:24,000 --> 00:57:26,000
大家谈论 TDD 的时候

1390
00:57:26,000 --> 00:57:28,000
经常忽略的也就是这个 driven

1391
00:57:28,000 --> 00:57:29,000
而关注在 test 的时候

1392
00:57:29,000 --> 00:57:32,000
当 test 起 driven 作用的时候

1393
00:57:32,000 --> 00:57:34,000
一旦 driven 作用完成

1394
00:57:34,000 --> 00:57:37,000
也就是实践被 driven 出来后

1395
00:57:37,000 --> 00:57:40,000
理论就可以被删除

1396
00:57:40,000 --> 00:57:43,000
这叫怎么没读通顺呢

1397
00:57:43,000 --> 00:57:47,000
他的意思就是当 test 起追问作用的时候

1398
00:57:47,000 --> 00:57:53,000
也就是说这个 test 在驱使你写 test 的时候

1399
00:57:53,000 --> 00:57:57,000
它只是一个动力

1400
00:57:57,000 --> 00:57:59,000
或者说它只是一个刺激源

1401
00:57:59,000 --> 00:58:00,000
它刺激你说

1402
00:58:00,000 --> 00:58:02,000
我把这些 test 都满足了

1403
00:58:02,000 --> 00:58:04,000
然后我的代码也就写出来了

1404
00:58:04,000 --> 00:58:05,000
OK

1405
00:58:05,000 --> 00:58:06,000
这么理解

1406
00:58:06,000 --> 00:58:08,000
但写都写了

1407
00:58:08,000 --> 00:58:11,000
稍微需求解决就可以留着继续发挥余热

1408
00:58:11,000 --> 00:58:15,000
转化为可以起到保障作用的单元测试

1409
00:58:15,000 --> 00:58:16,000
何乐而不为呢

1410
00:58:16,000 --> 00:58:17,000
那追问的作用

1411
00:58:17,000 --> 00:58:19,000
我再查一句

1412
00:58:19,000 --> 00:58:20,000
他的意思就是

1413
00:58:20,000 --> 00:58:21,000
你要修一栋楼

1414
00:58:21,000 --> 00:58:24,000
你修个脚手架

1415
00:58:24,000 --> 00:58:26,000
然后再盖这个楼

1416
00:58:26,000 --> 00:58:29,000
理论上楼盖好之后脚手架就应该拆除了

1417
00:58:29,000 --> 00:58:29,000
对吧

1418
00:58:29,000 --> 00:58:32,000
但是在软件的世界里面

1419
00:58:32,000 --> 00:58:34,000
做这样的比喻实际上是不恰当的

1420
00:58:34,000 --> 00:58:36,000
在软件的世界里面

1421
00:58:36,000 --> 00:58:39,000
这个楼可能是要继续生长和变化的

1422
00:58:39,000 --> 00:58:42,000
此时如果你一开始搭了脚手架

1423
00:58:42,000 --> 00:58:44,000
那你搭可以留着脚手架

1424
00:58:44,000 --> 00:58:47,000
如果这个变化是在预期之外的话

1425
00:58:47,000 --> 00:58:50,000
这个脚手架可能就会被撞到

1426
00:58:50,000 --> 00:58:53,000
然后你就知道这个东西已经在你的

1427
00:58:53,000 --> 00:58:57,000
就是你这一部分的更改已经变更了

1428
00:58:57,000 --> 00:58:59,000
你一开始对于这个建筑的预期

1429
00:58:59,000 --> 00:58:59,000
大概是这样一个

1430
00:58:59,000 --> 00:59:01,000
我想能想到一个比较合适的

1431
00:59:01,000 --> 00:59:02,000
比喻大概是

1432
00:59:02,000 --> 00:59:05,000
接着说

1433
00:59:05,000 --> 00:59:09,000
那 driven 的作用是如何被体现的呢

1434
00:59:09,000 --> 00:59:12,000
我们习惯的开发思路可以理解是

1435
00:59:12,000 --> 00:59:13,000
自上而下的

1436
00:59:13,000 --> 00:59:14,000
top down approach

1437
00:59:14,000 --> 00:59:14,000
对吧

1438
00:59:14,000 --> 00:59:16,000
就碰到一个问题或需求

1439
00:59:16,000 --> 00:59:18,000
先做完备的设计

1440
00:59:18,000 --> 00:59:19,000
再来实现

1441
00:59:19,000 --> 00:59:22,000
而 TDD 所体现的

1442
00:59:22,000 --> 00:59:23,000
就是一个相反的

1443
00:59:23,000 --> 00:59:25,000
自下而上的这么一个模式

1444
00:59:25,000 --> 00:59:27,000
就是说程序的设计和算法

1445
00:59:27,000 --> 00:59:29,000
不是说在你开始写之前

1446
00:59:29,000 --> 00:59:31,000
人家想清楚的所有细节

1447
00:59:31,000 --> 00:59:34,000
而是可以基于对目标的任务进行分解

1448
00:59:34,000 --> 00:59:37,000
以及实现的逐步演进

1449
00:59:37,000 --> 00:59:41,000
并通过每次红绿 cycle 后的重构

1450
00:59:41,000 --> 00:59:42,000
被驱动出来

1451
00:59:42,000 --> 00:59:43,000
哇

1452
00:59:43,000 --> 00:59:44,000
好多数

1453
00:59:44,000 --> 00:59:45,000
好处

1454
00:59:45,000 --> 00:59:47,000
就是一开始没通过

1455
00:59:47,000 --> 00:59:48,000
然后你写好了

1456
00:59:48,000 --> 00:59:49,000
他通过

1457
00:59:49,000 --> 00:59:50,000
老是挂是吧

1458
00:59:50,000 --> 00:59:51,000
各种测试

1459
00:59:51,000 --> 00:59:51,000
老是挂

1460
00:59:51,000 --> 00:59:52,000
然后绿了一下

1461
00:59:52,000 --> 00:59:53,000
又红了

1462
00:59:53,000 --> 00:59:54,000
接着改

1463
00:59:54,000 --> 00:59:54,000
又绿了

1464
00:59:54,000 --> 00:59:58,000
好处恰恰就是 real 所吐槽的那种

1465
00:59:58,000 --> 01:00:00,000
外包公司所能达到的

1466
01:00:00,000 --> 01:00:02,000
刚刚好满足需求的实现

1467
01:00:02,000 --> 01:00:04,000
不过我觉得满足

1468
01:00:04,000 --> 01:00:06,000
在满足所有业务需求的前提下

1469
01:00:06,000 --> 01:00:08,000
刚刚好不一定就是坏事

1470
01:00:08,000 --> 01:00:11,000
正好契合当今精益的思想

1471
01:00:11,000 --> 01:00:13,000
这个我不反对

1472
01:00:13,000 --> 01:00:14,000
我觉得这确实是很好的

1473
01:00:14,000 --> 01:00:17,000
前提是有重构的保证

1474
01:00:17,000 --> 01:00:18,000
这种刚刚好的实现

1475
01:00:18,000 --> 01:00:20,000
也是已经消除了

1476
01:00:20,000 --> 01:00:23,000
识别出的 bad smell

1477
01:00:23,000 --> 01:00:23,000
就是

1478
01:00:23,000 --> 01:00:25,000
坏味道

1479
01:00:25,000 --> 01:00:26,000
对

1480
01:00:26,000 --> 01:00:26,000
坏味道

1481
01:00:26,000 --> 01:00:27,000
例如代码重复

1482
01:00:27,000 --> 01:00:29,000
各种 switch

1483
01:00:29,000 --> 01:00:30,000
还有非常常的方法

1484
01:00:30,000 --> 01:00:31,000
或者函数的

1485
01:00:31,000 --> 01:00:36,000
比较干净的实现

1486
01:00:36,000 --> 01:00:38,000
我靠这怎么念

1487
01:00:38,000 --> 01:00:40,000
这种刚刚好的实现

1488
01:00:40,000 --> 01:00:42,000
也就是已经消除了

1489
01:00:42,000 --> 01:00:43,000
识别出的 bad smell

1490
01:00:43,000 --> 01:00:44,000
之后比较 clean 的实现

1491
01:00:44,000 --> 01:00:45,000
对

1492
01:00:45,000 --> 01:00:46,000
没错

1493
01:00:46,000 --> 01:00:48,000
而这两种开放模式

1494
01:00:48,000 --> 01:00:50,000
也没有好坏之分

1495
01:00:50,000 --> 01:00:50,000
只是

1496
01:00:50,000 --> 01:00:51,000
这两种开放模式

1497
01:00:51,000 --> 01:00:52,000
一个是自顶向上

1498
01:00:52,000 --> 01:00:54,000
还是自下而上的

1499
01:00:54,000 --> 01:00:55,000
两种区分方式

1500
01:00:55,000 --> 01:00:57,000
只是思考的问题

1501
01:00:57,000 --> 01:00:58,000
和方向的问题

1502
01:00:58,000 --> 01:00:59,000
可能最终的结果

1503
01:00:59,000 --> 01:01:01,000
是一致的

1504
01:01:01,000 --> 01:01:02,000
对吧

1505
01:01:02,000 --> 01:01:05,000
其实这怎么说呢

1506
01:01:05,000 --> 01:01:06,000
就这种

1507
01:01:06,000 --> 01:01:08,000
这种大概念性的

1508
01:01:08,000 --> 01:01:09,000
这个争吵

1509
01:01:09,000 --> 01:01:09,000
其实也没有什么

1510
01:01:09,000 --> 01:01:10,000
太大的用处

1511
01:01:10,000 --> 01:01:12,000
就是有些人习惯

1512
01:01:12,000 --> 01:01:14,000
先有一个大的

1513
01:01:14,000 --> 01:01:15,000
跟写作文一样

1514
01:01:15,000 --> 01:01:16,000
有些人习惯说

1515
01:01:16,000 --> 01:01:18,000
先来把七纲写出来

1516
01:01:18,000 --> 01:01:18,000
对吧

1517
01:01:18,000 --> 01:01:18,000
然后再来听

1518
01:01:18,000 --> 01:01:20,000
天气之摸眼

1519
01:01:20,000 --> 01:01:21,000
有人喜欢写伞文

1520
01:01:21,000 --> 01:01:23,000
他一定要边写边弄

1521
01:01:23,000 --> 01:01:25,000
然后再拼出来看

1522
01:01:25,000 --> 01:01:26,000
写出了这么个东西

1523
01:01:26,000 --> 01:01:27,000
对

1524
01:01:27,000 --> 01:01:30,000
我小时候会经常写一些

1525
01:01:30,000 --> 01:01:33,000
很没有上下文的片段

1526
01:01:33,000 --> 01:01:33,000
然后最后

1527
01:01:33,000 --> 01:01:34,000
拼在一起

1528
01:01:34,000 --> 01:01:35,000
是吧

1529
01:01:35,000 --> 01:01:36,000
最后写作文的时候

1530
01:01:36,000 --> 01:01:38,000
可以想起来一个段子

1531
01:01:38,000 --> 01:01:39,000
然后拼进去

1532
01:01:39,000 --> 01:01:40,000
嗯

1533
01:01:40,000 --> 01:01:43,000
他有一个什么

1534
01:01:43,000 --> 01:01:44,000
TDD 实施的三个步骤

1535
01:01:44,000 --> 01:01:45,000
用他自己的理解

1536
01:01:45,000 --> 01:01:46,000
就是说先写一个测试

1537
01:01:46,000 --> 01:01:48,000
然后让边写通过

1538
01:01:48,000 --> 01:01:48,000
这个上次

1539
01:01:48,000 --> 01:01:49,000
我们已经提到过

1540
01:01:49,000 --> 01:01:50,000
就是只让

1541
01:01:50,000 --> 01:01:51,000
你已经解释过一次

1542
01:01:51,000 --> 01:01:53,000
就是只边写能恰好

1543
01:01:53,000 --> 01:01:55,000
让所有测试通过的代码

1544
01:01:55,000 --> 01:01:56,000
然后不断的重构

1545
01:01:56,000 --> 01:01:58,000
然后去反复这个过程

1546
01:01:58,000 --> 01:01:59,000
然后消灭掉所有的

1547
01:01:59,000 --> 01:02:00,000
Batsmail

1548
01:02:00,000 --> 01:02:02,000
但就我们那期节目中

1549
01:02:02,000 --> 01:02:04,000
他说本期节目中

1550
01:02:04,000 --> 01:02:04,000
没有提到重构

1551
01:02:04,000 --> 01:02:06,000
这也是人们在谈论

1552
01:02:06,000 --> 01:02:08,000
TDD 中经常忽略的

1553
01:02:08,000 --> 01:02:09,000
如果没有重构

1554
01:02:09,000 --> 01:02:10,000
这个步骤的话

1555
01:02:10,000 --> 01:02:11,000
理论上

1556
01:02:11,000 --> 01:02:12,000
确实所有的逻辑

1557
01:02:12,000 --> 01:02:13,000
都可以通过

1558
01:02:13,000 --> 01:02:14,000
无数的 EVE 重举

1559
01:02:14,000 --> 01:02:17,000
输入与输出的映射来实现

1560
01:02:17,000 --> 01:02:18,000
虽然说挺寒熟悉

1561
01:02:18,000 --> 01:02:20,000
这其实也有可能是

1562
01:02:20,000 --> 01:02:21,000
将来计算机

1563
01:02:21,000 --> 01:02:23,000
写程序的一种方法

1564
01:02:23,000 --> 01:02:24,000
暴力的

1565
01:02:24,000 --> 01:02:26,000
把你所有可能需要的

1566
01:02:26,000 --> 01:02:28,000
场景全都自动生成语

1567
01:02:28,000 --> 01:02:29,000
然后程序写出来

1568
01:02:29,000 --> 01:02:30,000
对

1569
01:02:30,000 --> 01:02:32,000
我们都知道这样是不对的

1570
01:02:32,000 --> 01:02:35,000
代码将很快陷入腐化

1571
01:02:35,000 --> 01:02:36,000
我想这也是为什么

1572
01:02:36,000 --> 01:02:38,000
节目中说可以调试的代码

1573
01:02:38,000 --> 01:02:40,000
都是啰嗦的代码的原因之一

1574
01:02:40,000 --> 01:02:42,000
总之我个人认为

1575
01:02:42,000 --> 01:02:44,000
没有重构的 TDD 都是耍流氓

1576
01:02:44,000 --> 01:02:47,000
如果说前两步保证

1577
01:02:47,000 --> 01:02:49,000
我们的代码实现了业务价值

1578
01:02:49,000 --> 01:02:50,000
那重构就保证

1579
01:02:50,000 --> 01:02:52,000
我们代码本身的质量和设计

1580
01:02:52,000 --> 01:02:54,000
从而避免代码的快速腐化

1581
01:02:54,000 --> 01:02:55,000
只有这样才能体现

1582
01:02:55,000 --> 01:02:57,000
TDD 的价值和好处

1583
01:02:57,000 --> 01:02:59,000
但一个重要的前提是

1584
01:02:59,000 --> 01:03:00,000
测试要写对

1585
01:03:00,000 --> 01:03:02,000
否则很容易适得起反

1586
01:03:02,000 --> 01:03:05,000
严重影响重构以及变化

1587
01:03:05,000 --> 01:03:06,000
最简单的

1588
01:03:06,000 --> 01:03:07,000
就是重构的时候

1589
01:03:07,000 --> 01:03:08,000
需要修改测试

1590
01:03:08,000 --> 01:03:10,000
刚才我们已经提到这个问题了

1591
01:03:10,000 --> 01:03:12,000
就是你重构的过程中

1592
01:03:12,000 --> 01:03:15,000
导致接口变了

1593
01:03:15,000 --> 01:03:16,000
那么你测试就要重写

1594
01:03:16,000 --> 01:03:19,000
这就是其实在他看来

1595
01:03:19,000 --> 01:03:22,000
这个是测试写的不好的

1596
01:03:22,000 --> 01:03:23,000
一个典范

1597
01:03:23,000 --> 01:03:23,000
对

1598
01:03:23,000 --> 01:03:24,000
对

1599
01:03:24,000 --> 01:03:27,000
一种常见的问题就是测试 Target

1600
01:03:27,000 --> 01:03:30,000
不是业务价值

1601
01:03:30,000 --> 01:03:32,000
我来念吧

1602
01:03:32,000 --> 01:03:33,000
这一段应该是

1603
01:03:33,000 --> 01:03:37,000
一种常见的问题就是测试的目标

1604
01:03:37,000 --> 01:03:38,000
不是业务价值

1605
01:03:38,000 --> 01:03:42,000
比如罗马数字与阿拉伯数字的转化的

1606
01:03:42,000 --> 01:03:43,000
结果是否正确

1607
01:03:43,000 --> 01:03:46,000
而是实现本身

1608
01:03:46,000 --> 01:03:49,000
也就是他写的这个测试

1609
01:03:49,000 --> 01:03:52,000
测的是是否采用了某种算法

1610
01:03:52,000 --> 01:03:55,000
来处理罗马数字与阿拉伯数字的转化

1611
01:03:55,000 --> 01:03:57,000
在这种情况之下

1612
01:03:57,000 --> 01:03:58,000
如果你要换算法的话

1613
01:03:58,000 --> 01:03:59,000
你就得修改测试

1614
01:03:59,000 --> 01:04:01,000
应该是这个意思

1615
01:04:01,000 --> 01:04:02,000
OK

1616
01:04:02,000 --> 01:04:05,000
然后他说

1617
01:04:05,000 --> 01:04:06,000
如果测试写的不对

1618
01:04:06,000 --> 01:04:08,000
那么测试的稳定性及价值

1619
01:04:08,000 --> 01:04:09,000
就会大打折扣

1620
01:04:09,000 --> 01:04:13,000
而且测试回复测试的成本也会大大增加

1621
01:04:13,000 --> 01:04:14,000
这正好说明了

1622
01:04:14,000 --> 01:04:16,000
为什么大多数人不爱写测试

1623
01:04:16,000 --> 01:04:18,000
其实写好

1624
01:04:18,000 --> 01:04:19,000
或者写的对的测试

1625
01:04:19,000 --> 01:04:21,000
确实挺难的

1626
01:04:21,000 --> 01:04:23,000
有时候要比写好

1627
01:04:23,000 --> 01:04:25,000
或者写对的这个实现还要难很多

1628
01:04:25,000 --> 01:04:28,000
这也应证刚才张博士的说法

1629
01:04:28,000 --> 01:04:30,000
你这个什么形式证明也是很难的

1630
01:04:30,000 --> 01:04:32,000
测试也没有简单的能力去

1631
01:04:32,000 --> 01:04:33,000
没错

1632
01:04:33,000 --> 01:04:36,000
其实你能写测试

1633
01:04:36,000 --> 01:04:39,000
已经意味着你对写程序这件事情

1634
01:04:39,000 --> 01:04:41,000
有相当的了解了

1635
01:04:41,000 --> 01:04:43,000
写测试有点像

1636
01:04:43,000 --> 01:04:45,000
你要教一个人

1637
01:04:45,000 --> 01:04:48,000
就是你要教一个人武功

1638
01:04:48,000 --> 01:04:49,000
你自己得先会武功

1639
01:04:49,000 --> 01:04:51,000
就你的武功得比他强

1640
01:04:51,000 --> 01:04:53,000
你才能跟他对拆

1641
01:04:53,000 --> 01:04:56,000
然后告诉他哪里打错了

1642
01:04:56,000 --> 01:04:59,000
写测试也其实是这样

1643
01:04:59,000 --> 01:05:01,000
如果你能写出一个好的测试

1644
01:05:01,000 --> 01:05:02,000
基本上也就意味着你是一个

1645
01:05:02,000 --> 01:05:06,000
比能够写出好的代码更好的程序

1646
01:05:06,000 --> 01:05:07,000
对

1647
01:05:07,000 --> 01:05:08,000
起码你对整个这个接口

1648
01:05:08,000 --> 01:05:10,000
它哪些地方可能会出错

1649
01:05:10,000 --> 01:05:13,000
你会有一个比较完备的理解

1650
01:05:13,000 --> 01:05:17,000
你才能做到测试写出来是足够覆盖度的

1651
01:05:17,000 --> 01:05:20,000
然后有足够多的一种所谓边界条件

1652
01:05:20,000 --> 01:05:23,000
去验证那些东西的会不会出问题

1653
01:05:23,000 --> 01:05:24,000
没错

1654
01:05:24,000 --> 01:05:27,000
他又说

1655
01:05:27,000 --> 01:05:29,000
关于 TDD 很硬度

1656
01:05:29,000 --> 01:05:29,000
就是你说的

1657
01:05:29,000 --> 01:05:34,000
将测试作为详细设计说明书的可运行版本

1658
01:05:34,000 --> 01:05:36,000
来实现分工和流程化

1659
01:05:36,000 --> 01:05:40,000
因为他们就是他在工作那个地方

1660
01:05:40,000 --> 01:05:42,000
没有严格的分工和分级

1661
01:05:42,000 --> 01:05:44,000
也没有架构师设计师之类的角色

1662
01:05:44,000 --> 01:05:45,000
所以他感觉不到

1663
01:05:45,000 --> 01:05:47,000
他们只有这个 BA

1664
01:05:47,000 --> 01:05:49,000
就是什么 business analyst

1665
01:05:49,000 --> 01:05:50,000
是吧

1666
01:05:50,000 --> 01:05:52,000
QA quality assurance

1667
01:05:52,000 --> 01:05:54,000
然后 Dev 就是开发和 UX

1668
01:05:54,000 --> 01:05:58,000
就是用物体验这些角色

1669
01:05:58,000 --> 01:06:04,000
开发自己要负责一个 story 的需求建设与反馈

1670
01:06:04,000 --> 01:06:06,000
他们的好多术语

1671
01:06:06,000 --> 01:06:09,000
任务拆分

1672
01:06:09,000 --> 01:06:11,000
然后开发前端

1673
01:06:11,000 --> 01:06:13,000
还要甚至给客户去 showcase

1674
01:06:13,000 --> 01:06:14,000
应该是 demo 这类的东西

1675
01:06:14,000 --> 01:06:15,000
对

1676
01:06:15,000 --> 01:06:17,000
所以这块我们还好

1677
01:06:17,000 --> 01:06:17,000
没有感觉任何

1678
01:06:17,000 --> 01:06:21,000
就没有觉得自己很像你吴涛说的

1679
01:06:21,000 --> 01:06:21,000
那么很硬度

1680
01:06:21,000 --> 01:06:23,000
他们还是很开心的

1681
01:06:23,000 --> 01:06:24,000
在做这个 DD 的践行的

1682
01:06:24,000 --> 01:06:26,000
反而在保障测试

1683
01:06:26,000 --> 01:06:28,000
反而在测试的保障下

1684
01:06:28,000 --> 01:06:30,000
我们可以灵活的修改实现和设计

1685
01:06:30,000 --> 01:06:32,000
甚至灵活的响应需求的变化

1686
01:06:32,000 --> 01:06:35,000
他们现在这个项目就有四多个人开发

1687
01:06:35,000 --> 01:06:38,000
是基于一个.net 的 Web API

1688
01:06:38,000 --> 01:06:41,000
加前端是 reangular.js

1689
01:06:41,000 --> 01:06:43,000
现在也在换 react.js

1690
01:06:43,000 --> 01:06:46,000
然后基于这个微服务的方法来做的

1691
01:06:46,000 --> 01:06:49,000
然后用的也是吴涛最爱的 C-sharp

1692
01:06:49,000 --> 01:06:50,000
都做了五年了

1693
01:06:50,000 --> 01:06:54,000
然后目前还可以做到相对灵活的

1694
01:06:54,000 --> 01:06:57,000
详细区变化以及代码实现的眼镜

1695
01:06:57,000 --> 01:06:59,000
甚至工具框架的眼镜

1696
01:06:59,000 --> 01:07:01,000
可以说 TDD 也是功不可梦

1697
01:07:01,000 --> 01:07:02,000
这确实挺难得的

1698
01:07:02,000 --> 01:07:03,000
一个五年的项目

1699
01:07:03,000 --> 01:07:05,000
没有积攒出那么多的 craft

1700
01:07:05,000 --> 01:07:06,000
反而还能在这个

1701
01:07:06,000 --> 01:07:08,000
做一套整个业务

1702
01:07:08,000 --> 01:07:11,000
业务思想的这么指导下

1703
01:07:11,000 --> 01:07:13,000
能够保持敏捷性

1704
01:07:13,000 --> 01:07:14,000
这确实非常不容

1705
01:07:14,000 --> 01:07:15,000
对

1706
01:07:15,000 --> 01:07:18,000
他说到这个 TDD 很印度

1707
01:07:18,000 --> 01:07:23,000
我觉得还是有必要解释一下

1708
01:07:23,000 --> 01:07:23,000
什么叫印度

1709
01:07:23,000 --> 01:07:24,000
印度就是

1710
01:07:24,000 --> 01:07:27,000
印度人有一个特点

1711
01:07:27,000 --> 01:07:30,000
就是他只做你告诉他该做的事情

1712
01:07:30,000 --> 01:07:32,000
然后他

1713
01:07:32,000 --> 01:07:33,000
你告诉他该做的事情

1714
01:07:33,000 --> 01:07:34,000
他不一定能做好

1715
01:07:34,000 --> 01:07:38,000
所以印度人为了管理印度人

1716
01:07:38,000 --> 01:07:40,000
我这里没有地域歧视

1717
01:07:40,000 --> 01:07:41,000
或者种族歧视的意思

1718
01:07:41,000 --> 01:07:43,000
但是如果你听出来了

1719
01:07:43,000 --> 01:07:43,000
我有这个意思

1720
01:07:43,000 --> 01:07:44,000
我也没有

1721
01:07:44,000 --> 01:07:45,000
我也没有什么可以解释

1722
01:07:45,000 --> 01:07:47,000
就是印度人想出来

1723
01:07:47,000 --> 01:07:48,000
管理印度人的方法

1724
01:07:48,000 --> 01:07:53,000
就是有一个高高在上的

1725
01:07:53,000 --> 01:07:55,000
拿着鞭子的人

1726
01:07:55,000 --> 01:07:59,000
告诉你每一步应该做什么

1727
01:07:59,000 --> 01:08:00,000
然后反复来检查你

1728
01:08:00,000 --> 01:08:04,000
我的印度只能是这个意思

1729
01:08:04,000 --> 01:08:05,000
而他所说的

1730
01:08:05,000 --> 01:08:06,000
他们在公司里面

1731
01:08:06,000 --> 01:08:08,000
没有严格的分工和分级

1732
01:08:08,000 --> 01:08:10,000
这本身就已经非常不印度

1733
01:08:10,000 --> 01:08:13,000
然后说没有架构师

1734
01:08:13,000 --> 01:08:15,000
没有设计师之类的角色

1735
01:08:15,000 --> 01:08:17,000
其实一个公司里面

1736
01:08:17,000 --> 01:08:18,000
没有架构师

1737
01:08:18,000 --> 01:08:19,000
没有设计师

1738
01:08:19,000 --> 01:08:20,000
并不意味着这个公司

1739
01:08:20,000 --> 01:08:21,000
就不需要做架构

1740
01:08:21,000 --> 01:08:22,000
不需要做设计

1741
01:08:22,000 --> 01:08:25,000
只不过这个架构和设计的

1742
01:08:25,000 --> 01:08:27,000
职责分担到了

1743
01:08:27,000 --> 01:08:28,000
每一个 DAV 身上

1744
01:08:28,000 --> 01:08:31,000
这个对于开发者的要求

1745
01:08:31,000 --> 01:08:32,000
其实是比较高的

1746
01:08:32,000 --> 01:08:33,000
但是反过来也会对

1747
01:08:33,000 --> 01:08:35,000
也会让开发者

1748
01:08:35,000 --> 01:08:36,000
有这样一种感觉

1749
01:08:36,000 --> 01:08:38,000
就是我做的东西

1750
01:08:38,000 --> 01:08:40,000
是我自己亲手设计出来的

1751
01:08:40,000 --> 01:08:41,000
我做的东西

1752
01:08:41,000 --> 01:08:42,000
是我想要做的

1753
01:08:42,000 --> 01:08:44,000
然后你在主观能动性上

1754
01:08:44,000 --> 01:08:44,000
会高一点

1755
01:08:44,000 --> 01:08:45,000
但是

1756
01:08:45,000 --> 01:08:48,000
这本身是

1757
01:08:48,000 --> 01:08:51,000
我觉得是这种制度

1758
01:08:51,000 --> 01:08:52,000
保证了你没有那么印度

1759
01:08:52,000 --> 01:08:53,000
它并不意味着

1760
01:08:53,000 --> 01:08:54,000
好吧

1761
01:08:54,000 --> 01:08:56,000
我也不要一定要说

1762
01:08:56,000 --> 01:08:59,000
TDD 就是一定非常适合

1763
01:08:59,000 --> 01:09:02,000
印度的开发方法

1764
01:09:02,000 --> 01:09:03,000
我只是说

1765
01:09:03,000 --> 01:09:07,000
TDD 很容易被拿来在

1766
01:09:07,000 --> 01:09:08,000
这种刚才我说的

1767
01:09:08,000 --> 01:09:10,000
这种抽象式的

1768
01:09:10,000 --> 01:09:11,000
符号化的

1769
01:09:11,000 --> 01:09:12,000
印度式的管理上

1770
01:09:12,000 --> 01:09:12,000
嗯

1771
01:09:12,000 --> 01:09:13,000
嗯

1772
01:09:13,000 --> 01:09:13,000
嗯

1773
01:09:13,000 --> 01:09:14,000
OK

1774
01:09:14,000 --> 01:09:19,000
然后下一则你来念吧

1775
01:09:19,000 --> 01:09:20,000
对

1776
01:09:20,000 --> 01:09:21,000
然后这位朋友

1777
01:09:21,000 --> 01:09:25,000
说他在公司推荐了我们的节目

1778
01:09:25,000 --> 01:09:28,000
然后自己也会一边开车

1779
01:09:28,000 --> 01:09:29,000
听节目的时候

1780
01:09:29,000 --> 01:09:29,000
一边偷笑

1781
01:09:29,000 --> 01:09:32,000
而且会认为说

1782
01:09:32,000 --> 01:09:34,000
他的同事们

1783
01:09:34,000 --> 01:09:35,000
这群被 TDD

1784
01:09:35,000 --> 01:09:37,000
安利喜文老的家伙伴们

1785
01:09:37,000 --> 01:09:38,000
肯定会听到

1786
01:09:38,000 --> 01:09:39,000
我们的这期节目

1787
01:09:39,000 --> 01:09:40,000
产生各种不适

1788
01:09:40,000 --> 01:09:41,000
嗯

1789
01:09:41,000 --> 01:09:43,000
不过

1790
01:09:43,000 --> 01:09:45,000
他们的同事

1791
01:09:45,000 --> 01:09:46,000
也比较崇尚

1792
01:09:46,000 --> 01:09:47,000
合而不同的环境

1793
01:09:47,000 --> 01:09:49,000
互通有物也没什么不好

1794
01:09:49,000 --> 01:09:49,000
嗯

1795
01:09:49,000 --> 01:09:50,000
嗯

1796
01:09:50,000 --> 01:09:51,000
对

1797
01:09:51,000 --> 01:09:52,000
其实

1798
01:09:52,000 --> 01:09:55,000
我觉得这位

1799
01:09:55,000 --> 01:09:56,000
呃

1800
01:09:56,000 --> 01:09:58,000
先生的工作环境

1801
01:09:58,000 --> 01:10:00,000
是非常理想的一个环境

1802
01:10:00,000 --> 01:10:01,000
这位叫做

1803
01:10:01,000 --> 01:10:02,000
王健的朋友

1804
01:10:02,000 --> 01:10:04,000
呃

1805
01:10:04,000 --> 01:10:05,000
如果你们招人的话

1806
01:10:05,000 --> 01:10:06,000
可以

1807
01:10:06,000 --> 01:10:08,000
我们可以给你们打个广告

1808
01:10:08,000 --> 01:10:09,000
然后最

1809
01:10:09,000 --> 01:10:11,000
最牛逼的是

1810
01:10:11,000 --> 01:10:12,000
他在最后

1811
01:10:12,000 --> 01:10:12,000
呃

1812
01:10:12,000 --> 01:10:13,000
录了一段

1813
01:10:13,000 --> 01:10:14,000
TDD 写我这个

1814
01:10:14,000 --> 01:10:16,000
写我在节目里面提到的

1815
01:10:16,000 --> 01:10:17,000
这个罗马数字

1816
01:10:17,000 --> 01:10:18,000
转换为

1817
01:10:18,000 --> 01:10:19,000
阿拉伯数字

1818
01:10:19,000 --> 01:10:20,000
转换为罗马数字的

1819
01:10:20,000 --> 01:10:22,000
程序

1820
01:10:22,000 --> 01:10:22,000
嗯

1821
01:10:22,000 --> 01:10:23,000
呃

1822
01:10:23,000 --> 01:10:24,000
就是严格按照

1823
01:10:24,000 --> 01:10:25,000
相对严格的按照

1824
01:10:25,000 --> 01:10:26,000
这个 TDD 的

1825
01:10:26,000 --> 01:10:28,000
先写一个测试

1826
01:10:28,000 --> 01:10:29,000
然后再写一段程序

1827
01:10:29,000 --> 01:10:30,000
再写一点测试

1828
01:10:30,000 --> 01:10:31,000
再写一点程序

1829
01:10:31,000 --> 01:10:32,000
这样步骤来的

1830
01:10:32,000 --> 01:10:33,000
嗯

1831
01:10:33,000 --> 01:10:33,000
然后他把

1832
01:10:33,000 --> 01:10:35,000
视频传到的 YouTube 和

1833
01:10:35,000 --> 01:10:36,000
嗯

1834
01:10:36,000 --> 01:10:37,000
那是优酷上面吗

1835
01:10:37,000 --> 01:10:39,000
我只看到 YouTube 版本

1836
01:10:39,000 --> 01:10:39,000
嗯

1837
01:10:39,000 --> 01:10:41,000
我们会把这个链接放在

1838
01:10:41,000 --> 01:10:42,000
呃

1839
01:10:42,000 --> 01:10:43,000
节目的末尾

1840
01:10:43,000 --> 01:10:44,000
所以如果你没有

1841
01:10:44,000 --> 01:10:46,000
你从来没有见过 TDD 是什么样子的话

1842
01:10:46,000 --> 01:10:47,000
你可以看到一位

1843
01:10:47,000 --> 01:10:48,000
呃

1844
01:10:48,000 --> 01:10:49,000
活生生的例子

1845
01:10:49,000 --> 01:10:50,000
对

1846
01:10:50,000 --> 01:10:51,000
活生生的大牛

1847
01:10:51,000 --> 01:10:52,000
给你用

1848
01:10:52,000 --> 01:10:53,000
呃

1849
01:10:53,000 --> 01:10:54,000
世界上最好用的

1850
01:10:54,000 --> 01:10:55,000
编辑器

1851
01:10:55,000 --> 01:10:56,000
呃

1852
01:10:56,000 --> 01:10:57,000
编译环境

1853
01:10:57,000 --> 01:10:57,000
VeroStudio

1854
01:10:57,000 --> 01:10:58,000
呃

1855
01:10:58,000 --> 01:11:00,000
以及世界上最好的语言

1856
01:11:00,000 --> 01:11:00,000
呃

1857
01:11:00,000 --> 01:11:01,000
呃

1858
01:11:01,000 --> 01:11:02,000
C-Shop

1859
01:11:02,000 --> 01:11:02,000
哈哈

1860
01:11:02,000 --> 01:11:06,000
为你执行整个 TDD 过程

1861
01:11:06,000 --> 01:11:06,000
嗯

1862
01:11:06,000 --> 01:11:07,000
呃

1863
01:11:07,000 --> 01:11:09,000
呃

1864
01:11:09,000 --> 01:11:10,000
接下来我来念两封比较短的读者回馈

1865
01:11:10,000 --> 01:11:11,000
呃

1866
01:11:11,000 --> 01:11:17,000
一封是一位来自于石霞星的朋友

1867
01:11:17,000 --> 01:11:17,000
呃

1868
01:11:17,000 --> 01:11:18,000
呃

1869
01:11:18,000 --> 01:11:21,000
他的他的署名是 Star Samurai

1870
01:11:21,000 --> 01:11:22,000
他来自于

1871
01:11:22,000 --> 01:11:24,000
来自于法国

1872
01:11:24,000 --> 01:11:25,000
我们经常

1873
01:11:25,000 --> 01:11:26,000
黑法国

1874
01:11:26,000 --> 01:11:28,000
是 Star Samurai

1875
01:11:28,000 --> 01:11:29,000
啊

1876
01:11:29,000 --> 01:11:31,000
Star Samurai

1877
01:11:31,000 --> 01:11:32,000
OK

1878
01:11:32,000 --> 01:11:32,000
sorry

1879
01:11:32,000 --> 01:11:34,000
呃

1880
01:11:34,000 --> 01:11:37,000
他来自于法国南特矿业学院

1881
01:11:37,000 --> 01:11:38,000
也是一个

1882
01:11:38,000 --> 01:11:40,000
名字听起来非常的

1883
01:11:40,000 --> 01:11:41,000
那个

1884
01:11:41,000 --> 01:11:44,000
但实际上在欧洲也是非常好的学校

1885
01:11:44,000 --> 01:11:44,000
呃

1886
01:11:44,000 --> 01:11:45,000
他说

1887
01:11:45,000 --> 01:11:46,000
嗨的

1888
01:11:46,000 --> 01:11:47,000
很喜欢你们的节目

1889
01:11:47,000 --> 01:11:47,000
呃

1890
01:11:47,000 --> 01:11:49,000
这里是关于 197 测试的一点反馈

1891
01:11:49,000 --> 01:11:50,000
然后

1892
01:11:50,000 --> 01:11:53,000
Dijavu 的读音是

1893
01:11:53,000 --> 01:11:54,000
Dijavu

1894
01:11:54,000 --> 01:11:59,000
不过 Dijavu 已经被美国人读太多

1895
01:11:59,000 --> 01:12:01,000
也能算是英文式的发音了吧

1896
01:12:01,000 --> 01:12:02,000
在这里看一下

1897
01:12:02,000 --> 01:12:04,000
乌韬总是黑我们法国

1898
01:12:04,000 --> 01:12:06,000
哈哈哈哈

1899
01:12:06,000 --> 01:12:08,000
对不起

1900
01:12:08,000 --> 01:12:08,000
对不起

1901
01:12:08,000 --> 01:12:09,000
我

1902
01:12:09,000 --> 01:12:09,000
我

1903
01:12:09,000 --> 01:12:10,000
我是故意的

1904
01:12:10,000 --> 01:12:15,000
然后关于女生选择做测试这一点

1905
01:12:15,000 --> 01:12:17,000
根据我们的学姐说

1906
01:12:17,000 --> 01:12:18,000
就是比较轻松

1907
01:12:18,000 --> 01:12:18,000
也不需要加班

1908
01:12:18,000 --> 01:12:21,000
不论是需求改了

1909
01:12:21,000 --> 01:12:22,000
还是上线之后出问题了

1910
01:12:22,000 --> 01:12:24,000
测试团队都不用被紧急召集

1911
01:12:24,000 --> 01:12:25,000
诶

1912
01:12:25,000 --> 01:12:26,000
上线出问题

1913
01:12:26,000 --> 01:12:28,000
这个 QA 会不会抓回来

1914
01:12:28,000 --> 01:12:29,000
他都上线了

1915
01:12:29,000 --> 01:12:31,000
你找测试团队来有什么用

1916
01:12:31,000 --> 01:12:33,000
好像也已经太晚了

1917
01:12:33,000 --> 01:12:36,000
你就拿那个 productive 的环境来当测试环境

1918
01:12:36,000 --> 01:12:37,000
然后测

1919
01:12:37,000 --> 01:12:39,000
然后改到能用为止

1920
01:12:39,000 --> 01:12:40,000
还能怎么办

1921
01:12:40,000 --> 01:12:45,000
第二篇回馈是一位叫做李建宏的朋友

1922
01:12:45,000 --> 01:12:47,000
问我们一款在

1923
01:12:47,000 --> 01:12:48,000
那个什么

1924
01:12:48,000 --> 01:12:50,000
那个 trackpad 的那个事情要说一下

1925
01:12:50,000 --> 01:12:52,000
对

1926
01:12:52,000 --> 01:12:57,000
然后听众还问我们说

1927
01:12:57,000 --> 01:13:01,000
一天下来手指会不会因为 trackpad 用多了

1928
01:13:01,000 --> 01:13:02,000
而关节疼

1929
01:13:02,000 --> 01:13:04,000
他最近实习下班了

1930
01:13:04,000 --> 01:13:06,000
总是中指关节微微发疼

1931
01:13:06,000 --> 01:13:08,000
中指是 tap 的主力手指

1932
01:13:08,000 --> 01:13:10,000
两位有合适的解决方法

1933
01:13:10,000 --> 01:13:11,000
你有这个问题吗

1934
01:13:11,000 --> 01:13:14,000
我的解决方法是换鼠标

1935
01:13:14,000 --> 01:13:18,000
其实我也是

1936
01:13:18,000 --> 01:13:20,000
其实我现在在家里面

1937
01:13:20,000 --> 01:13:21,000
偶尔也会用一下手指

1938
01:13:21,000 --> 01:13:24,000
主要是最近打游戏比较多

1939
01:13:24,000 --> 01:13:28,000
其实我觉得那个什么 trackpad

1940
01:13:28,000 --> 01:13:31,000
这种特别是 Mac 上面那个多点触碰的 trackpad

1941
01:13:31,000 --> 01:13:33,000
一个最严重的问题

1942
01:13:33,000 --> 01:13:34,000
倒不是说这个关节痛

1943
01:13:34,000 --> 01:13:36,000
而是会变成蓝花指

1944
01:13:36,000 --> 01:13:39,000
是有点

1945
01:13:39,000 --> 01:13:40,000
因为你用的时候

1946
01:13:40,000 --> 01:13:42,000
总会把小指翘起来一面

1947
01:13:42,000 --> 01:13:46,000
久而久之就凉了

1948
01:13:46,000 --> 01:13:51,000
其实我有个解决方法

1949
01:13:51,000 --> 01:13:52,000
就是用中指和

1950
01:13:52,000 --> 01:13:54,000
用食指和无名指

1951
01:13:54,000 --> 01:13:56,000
食指和无名指

1952
01:13:56,000 --> 01:13:57,000
对

1953
01:13:57,000 --> 01:13:59,000
这是没有握法

1954
01:13:59,000 --> 01:14:00,000
那中指不用吗

1955
01:14:00,000 --> 01:14:02,000
就是中指不用

1956
01:14:02,000 --> 01:14:05,000
中指始终保持一个 screw 的状态

1957
01:14:05,000 --> 01:14:06,000
就是一直翘

1958
01:14:06,000 --> 01:14:08,000
这是一个很硬朗的做法

1959
01:14:08,000 --> 01:14:09,000
对

1960
01:14:09,000 --> 01:14:12,000
总之我有三个建议

1961
01:14:12,000 --> 01:14:16,000
一个是关掉那个触摸板的 click

1962
01:14:16,000 --> 01:14:17,000
按下的

1963
01:14:17,000 --> 01:14:18,000
就是你不要按下去

1964
01:14:18,000 --> 01:14:19,000
你只用轻触

1965
01:14:19,000 --> 01:14:19,000
这样

1966
01:14:19,000 --> 01:14:21,000
对

1967
01:14:21,000 --> 01:14:22,000
只用 tap 来代替 click

1968
01:14:22,000 --> 01:14:25,000
然后这样会对手指的劳损小人

1969
01:14:25,000 --> 01:14:27,000
第二个就是可以用那个

1970
01:14:27,000 --> 01:14:31,000
Star Trek 里面的那个

1971
01:14:31,000 --> 01:14:33,000
Live Long and Prosper 的手势

1972
01:14:33,000 --> 01:14:36,000
用把你的食指和中指并在一起

1973
01:14:36,000 --> 01:14:39,000
把无名指和小指并在一起

1974
01:14:39,000 --> 01:14:41,000
大部分手也

1975
01:14:41,000 --> 01:14:45,000
这样可以增强那个手指的力度

1976
01:14:45,000 --> 01:14:48,000
或者说增强手指的依赖

1977
01:14:48,000 --> 01:14:49,000
第三就是经常在这个

1978
01:14:49,000 --> 01:14:54,000
我刚才说的只用食指和无名指的手势

1979
01:14:54,000 --> 01:14:57,000
以及这个 Star Trek 手势之间切换

1980
01:14:57,000 --> 01:15:02,000
这样可以比较有效的减少手指的劳损

1981
01:15:02,000 --> 01:15:04,000
当然还有一个 tip 就是经常用左手

1982
01:15:04,000 --> 01:15:05,000
我觉得也挺好

1983
01:15:06,000 --> 01:15:15,000
下一篇反馈是一位来自李建宏的朋友

1984
01:15:15,000 --> 01:15:16,000
李建宏的朋友

1985
01:15:16,000 --> 01:15:22,000
问我们在 Kickstar 上看到的一款众筹的键盘怎么样

1986
01:15:22,000 --> 01:15:24,000
我就看了一下

1987
01:15:24,000 --> 01:15:25,000
你看了吗

1988
01:15:25,000 --> 01:15:26,000
我看了

1989
01:15:26,000 --> 01:15:30,000
之前我推荐那款叫什么

1990
01:15:30,000 --> 01:15:32,000
True Learonomic Keyboard 的

1991
01:15:32,000 --> 01:15:34,000
长相有点接近的

1992
01:15:34,000 --> 01:15:34,000
跟它差不多

1993
01:15:34,000 --> 01:15:37,000
只不过它更极端一点

1994
01:15:37,000 --> 01:15:38,000
就是它把

1995
01:15:38,000 --> 01:15:43,000
首先它把键盘做成一个木顶

1996
01:15:43,000 --> 01:15:46,000
就是下面那个东西是木头做的

1997
01:15:46,000 --> 01:15:48,000
看起来比较

1998
01:15:48,000 --> 01:15:50,000
我很难说它是漂亮

1999
01:15:50,000 --> 01:15:51,000
但有一种不一样的

2000
01:15:51,000 --> 01:15:54,000
然后上面的键

2001
01:15:54,000 --> 01:15:56,000
它做成了一个

2002
01:15:56,000 --> 01:15:58,000
它一个比较重大的设计

2003
01:15:58,000 --> 01:16:00,000
就是首先两个键盘

2004
01:16:00,000 --> 01:16:02,000
键盘它的左右部分是可以分开的

2005
01:16:02,000 --> 01:16:06,000
其次拇指会承担很多工作

2006
01:16:06,000 --> 01:16:10,000
比如说空格键被减少了一个键

2007
01:16:10,000 --> 01:16:14,000
然后你在拇指的最下面的指关节

2008
01:16:14,000 --> 01:16:16,000
就是最大的指关节的部分

2009
01:16:16,000 --> 01:16:18,000
也有一个按键

2010
01:16:18,000 --> 01:16:20,000
然后拇指的上半部分

2011
01:16:20,000 --> 01:16:22,000
还要分别控制四个键

2012
01:16:22,000 --> 01:16:26,000
我理解就是它的设计

2013
01:16:26,000 --> 01:16:28,000
可以让你保证说

2014
01:16:28,000 --> 01:16:30,000
你的手指基本上不会移动

2015
01:16:30,000 --> 01:16:32,000
你的手腕基本上不会移动

2016
01:16:32,000 --> 01:16:33,000
你的手放在那

2017
01:16:33,000 --> 01:16:34,000
就可以按到所有按键

2018
01:16:34,000 --> 01:16:35,000
而且那个放了一次

2019
01:16:35,000 --> 01:16:38,000
是一个就是手掌和这个手

2020
01:16:38,000 --> 01:16:40,000
叫什么钱臂

2021
01:16:40,000 --> 01:16:41,000
对吧

2022
01:16:41,000 --> 01:16:43,000
它是在一条直线上的

2023
01:16:43,000 --> 01:16:44,000
而不是说那种一个弯

2024
01:16:44,000 --> 01:16:45,000
就是一个斜角

2025
01:16:45,000 --> 01:16:46,000
这样长期的会导致

2026
01:16:46,000 --> 01:16:47,000
叫什么来的

2027
01:16:47,000 --> 01:16:50,000
万管综合证

2028
01:16:50,000 --> 01:16:51,000
卖管综合证

2029
01:16:51,000 --> 01:16:52,000
到底哪个来的

2030
01:16:52,000 --> 01:16:52,000
万管综合证

2031
01:16:52,000 --> 01:16:54,000
万管综合证

2032
01:16:54,000 --> 01:16:55,000
对

2033
01:16:55,000 --> 01:16:57,000
我这样一直在说卖管综合证

2034
01:16:57,000 --> 01:16:57,000
对

2035
01:16:57,000 --> 01:17:00,000
然后被初阳老师说了

2036
01:17:00,000 --> 01:17:03,000
好吧

2037
01:17:03,000 --> 01:17:06,000
我们今天就不讲

2038
01:17:06,000 --> 01:17:08,000
其实那个键盘

2039
01:17:08,000 --> 01:17:09,000
我补充一个

2040
01:17:09,000 --> 01:17:11,000
最主要的这种异形的键盘

2041
01:17:11,000 --> 01:17:13,000
打字都是其实挺好

2042
01:17:13,000 --> 01:17:14,000
挺容易适应的

2043
01:17:14,000 --> 01:17:15,000
可能打个三五分钟

2044
01:17:15,000 --> 01:17:17,000
或者最慢一点的一两天

2045
01:17:17,000 --> 01:17:18,000
咱们也适应过来了

2046
01:17:18,000 --> 01:17:19,000
对吧

2047
01:17:19,000 --> 01:17:20,000
最难适应的是

2048
01:17:20,000 --> 01:17:22,000
各种快捷键的组合

2049
01:17:22,000 --> 01:17:23,000
完全不一样

2050
01:17:23,000 --> 01:17:24,000
对没错

2051
01:17:24,000 --> 01:17:26,000
当然我对这个键盘

2052
01:17:26,000 --> 01:17:27,000
也不能说完全

2053
01:17:27,000 --> 01:17:32,000
怎么说

2054
01:17:32,000 --> 01:17:36,000
完全买它的主意

2055
01:17:36,000 --> 01:17:37,000
它有个问题

2056
01:17:37,000 --> 01:17:40,000
就是你要把手挪开键盘之后

2057
01:17:40,000 --> 01:17:41,000
再放回去的过程

2058
01:17:41,000 --> 01:17:43,000
可能会比较痛苦

2059
01:17:43,000 --> 01:17:45,000
因为一般的键盘

2060
01:17:45,000 --> 01:17:46,000
它没有考虑人体空血的话

2061
01:17:46,000 --> 01:17:49,000
你把手挪出去

2062
01:17:49,000 --> 01:17:50,000
再挪回来

2063
01:17:50,000 --> 01:17:52,000
你不用特别在意说

2064
01:17:52,000 --> 01:17:54,000
我要把手放到一个特定的位置

2065
01:17:54,000 --> 01:17:57,000
但是如果你用这个蝴蝶键盘的话

2066
01:17:57,000 --> 01:17:58,000
你每次把手放回来

2067
01:17:58,000 --> 01:18:01,000
你都要小心的调整手掌

2068
01:18:01,000 --> 01:18:03,000
让手掌落到最完美的位置

2069
01:18:04,000 --> 01:18:09,000
这上我想到一个广告

2070
01:18:09,000 --> 01:18:11,000
就是上面是一把德国刀

2071
01:18:11,000 --> 01:18:13,000
德国的双利人的

2072
01:18:13,000 --> 01:18:14,000
还是 WF 的锄刀

2073
01:18:14,000 --> 01:18:19,000
然后下面是一把日本的菜刀

2074
01:18:19,000 --> 01:18:22,000
然后德国的锄刀

2075
01:18:22,000 --> 01:18:24,000
非常符合人体工学

2076
01:18:24,000 --> 01:18:26,000
而日本的锄刀

2077
01:18:26,000 --> 01:18:30,000
刀柄就是一个平直的木头

2078
01:18:30,000 --> 01:18:32,000
然后下面的注释就说

2079
01:18:32,000 --> 01:18:36,000
德国的刀只有一种最完美的握法

2080
01:18:36,000 --> 01:18:38,000
而日本的刀

2081
01:18:38,000 --> 01:18:39,000
你想怎么握都可以

2082
01:18:39,000 --> 01:18:41,000
然后基本上也就是

2083
01:18:41,000 --> 01:18:43,000
我觉得我比较喜欢的这种审美

2084
01:18:43,000 --> 01:18:45,000
就是日式的

2085
01:18:45,000 --> 01:18:47,000
就是你可以把这个键盘

2086
01:18:47,000 --> 01:18:50,000
这键盘本身并不去会贴合你

2087
01:18:50,000 --> 01:18:52,000
但是你要去贴合这个键盘

2088
01:18:52,000 --> 01:18:53,000
但同时也就

2089
01:18:53,000 --> 01:18:56,000
也就意味着你有更多的自由

2090
01:18:56,000 --> 01:18:59,000
对

2091
01:18:59,000 --> 01:19:01,000
就其实你说这种

2092
01:19:01,000 --> 01:19:02,000
什么 ergonomic

2093
01:19:02,000 --> 01:19:04,000
这种人体工学键盘

2094
01:19:04,000 --> 01:19:06,000
其实我一直在想

2095
01:19:06,000 --> 01:19:08,000
所谓真正的人体工学

2096
01:19:08,000 --> 01:19:09,000
好歹也是要

2097
01:19:09,000 --> 01:19:11,000
是不是每个人还是要不同的

2098
01:19:11,000 --> 01:19:12,000
对吧

2099
01:19:12,000 --> 01:19:14,000
人和人之间是有差异的

2100
01:19:14,000 --> 01:19:16,000
就是你要真的要做到好的

2101
01:19:16,000 --> 01:19:17,000
人体工学

2102
01:19:17,000 --> 01:19:20,000
得可能按人的量下来定制

2103
01:19:20,000 --> 01:19:20,000
对吧

2104
01:19:20,000 --> 01:19:21,000
其实做不到

2105
01:19:21,000 --> 01:19:22,000
那不如什么

2106
01:19:22,000 --> 01:19:22,000
对

2107
01:19:22,000 --> 01:19:26,000
那除非只有在是这个传说中的工业 4.0

2108
01:19:26,000 --> 01:19:28,000
或者工业 4.5

2109
01:19:28,000 --> 01:19:29,000
3 D 打印一块是吧

2110
01:19:29,000 --> 01:19:30,000
你对

2111
01:19:30,000 --> 01:19:32,000
你先把你的手放到一个扫把云下面

2112
01:19:32,000 --> 01:19:33,000
扫一下

2113
01:19:33,000 --> 01:19:34,000
看那个尺寸

2114
01:19:34,000 --> 01:19:36,000
然后打印出一个

2115
01:19:36,000 --> 01:19:39,000
只有你用着最舒服的键盘出来

2116
01:19:39,000 --> 01:19:40,000
那才是真正的

2117
01:19:40,000 --> 01:19:41,000
就别人用各种

2118
01:19:41,000 --> 01:19:42,000
别扭

2119
01:19:42,000 --> 01:19:43,000
就你用的爽

2120
01:19:43,000 --> 01:19:44,000
对

2121
01:19:44,000 --> 01:19:45,000
所以从这个小说讲

2122
01:19:45,000 --> 01:19:46,000
那工业 4.0

2123
01:19:46,000 --> 01:19:48,000
这是一个生意

2124
01:19:48,000 --> 01:19:48,000
我们就可以做

2125
01:19:48,000 --> 01:19:50,000
bespoke keyboard

2126
01:19:50,000 --> 01:19:54,000
也许我懂我老了

2127
01:19:54,000 --> 01:19:56,000
其实我在想说

2128
01:19:56,000 --> 01:19:57,000
这个工业 4.0

2129
01:19:57,000 --> 01:19:58,000
其实有点

2130
01:19:58,000 --> 01:20:00,000
有点朝这个

2131
01:20:00,000 --> 01:20:04,000
mass production 的反方向跑

2132
01:20:04,000 --> 01:20:07,000
因为人类近代史上最伟大的发明之一

2133
01:20:07,000 --> 01:20:08,000
就是流水线

2134
01:20:08,000 --> 01:20:11,000
或者所谓 massive production

2135
01:20:11,000 --> 01:20:14,000
可以批量化生产

2136
01:20:14,000 --> 01:20:18,000
我记得我之前在看一本经济学书里面讲说

2137
01:20:18,000 --> 01:20:19,000
亚当斯密的时代

2138
01:20:19,000 --> 01:20:20,000
一个人

2139
01:20:20,000 --> 01:20:21,000
一个工人

2140
01:20:21,000 --> 01:20:22,000
一个熟练的工人

2141
01:20:22,000 --> 01:20:24,000
一个小时可能只能造十几根针

2142
01:20:24,000 --> 01:20:25,000
大头针

2143
01:20:25,000 --> 01:20:26,000
而我们这个时代

2144
01:20:26,000 --> 01:20:29,000
一个工人在平均的小时之内

2145
01:20:29,000 --> 01:20:32,000
可以造出几万枚大头针了

2146
01:20:32,000 --> 01:20:35,000
但是工业 4.0 时代

2147
01:20:35,000 --> 01:20:41,000
也许就意味着朝这个潮流的逆向走

2148
01:20:41,000 --> 01:20:41,000
就是一开始

2149
01:20:41,000 --> 01:20:47,000
当然基础材料还是 mass production 出来的

2150
01:20:47,000 --> 01:20:48,000
打印机的粉末

2151
01:20:48,000 --> 01:20:50,000
但是最终的成品却是

2152
01:20:50,000 --> 01:20:52,000
只有在你需要的时候

2153
01:20:52,000 --> 01:20:54,000
才在你需要的那个地方

2154
01:20:54,000 --> 01:20:56,000
被你自己生产出来

2155
01:20:56,000 --> 01:20:57,000
对嘛

2156
01:20:57,000 --> 01:21:00,000
这个就是他们之前两年还是流行过的一个

2157
01:21:00,000 --> 01:21:01,000
就是 mass

2158
01:21:01,000 --> 01:21:03,000
你看讲是 mass production

2159
01:21:03,000 --> 01:21:04,000
大规模生产

2160
01:21:04,000 --> 01:21:05,000
就是什么大规模定制

2161
01:21:05,000 --> 01:21:07,000
mass customization

2162
01:21:07,000 --> 01:21:08,000
对

2163
01:21:08,000 --> 01:21:10,000
就差不多做

2164
01:21:10,000 --> 01:21:12,000
其实这两个东西本质是有矛盾的

2165
01:21:12,000 --> 01:21:16,000
但得益于现在有什么各种各样的机器人技术

2166
01:21:16,000 --> 01:21:17,000
这种 3 D 打印技术

2167
01:21:17,000 --> 01:21:23,000
可以很快速的根据图纸切换出不同的模型出来

2168
01:21:23,000 --> 01:21:29,000
在定制化的基础上又能同时满足生产的效率

2169
01:21:29,000 --> 01:21:33,000
这个还是非常了不得的一个工业史上的一个创新

2170
01:21:33,000 --> 01:21:35,000
没错

2171
01:21:35,000 --> 01:21:37,000
说到刚才快捷键的问题

2172
01:21:37,000 --> 01:21:40,000
这两天也是为什么我一直老觉得很别扭

2173
01:21:40,000 --> 01:21:46,000
就是在那个 HHKB 上的那些键位和这个 mass

2174
01:21:46,000 --> 01:21:48,000
键盘的键位有些那种功能键不太一样

2175
01:21:48,000 --> 01:21:53,000
就那个主键区字母键数字那些都非常容易适应的

2176
01:21:53,000 --> 01:21:56,000
但就是功能键那个就非常难改

2177
01:21:56,000 --> 01:22:00,000
然后你要用那种更加人体工学的键盘

2178
01:22:00,000 --> 01:22:04,000
他会考虑把那些功能键做到一个

2179
01:22:04,000 --> 01:22:07,000
通常我们是用什么小指来按那些左边的功能键

2180
01:22:07,000 --> 01:22:08,000
或者右边的功能键

2181
01:22:08,000 --> 01:22:12,000
但是你在这种完全人体工学的键盘上

2182
01:22:12,000 --> 01:22:14,000
反而是要用实指来按

2183
01:22:14,000 --> 01:22:15,000
到时候你会发现

2184
01:22:15,000 --> 01:22:18,000
那我要按一个 Ctrl G 怎么办

2185
01:22:18,000 --> 01:22:20,000
就会很多纠结

2186
01:22:20,000 --> 01:22:24,000
就关键是在很多这种软件设计者

2187
01:22:24,000 --> 01:22:26,000
他在制定默认的快捷键的时候

2188
01:22:26,000 --> 01:22:29,000
他会假设是一个正常布局的普通键盘

2189
01:22:29,000 --> 01:22:31,000
来去这么设计

2190
01:22:31,000 --> 01:22:34,000
他说比如说复制粘贴

2191
01:22:34,000 --> 01:22:35,000
这个功能比较常用

2192
01:22:35,000 --> 01:22:36,000
我们做快捷键吧

2193
01:22:36,000 --> 01:22:38,000
看哪个快捷键比较顺手按

2194
01:22:38,000 --> 01:22:39,000
然后大家记得住

2195
01:22:39,000 --> 01:22:42,000
发现 Ctrl Ctrl V 不错

2196
01:22:42,000 --> 01:22:45,000
或者在 Mac 上就是 Command C Command V

2197
01:22:45,000 --> 01:22:49,000
但是如果你换一下这种异形的键盘

2198
01:22:49,000 --> 01:22:51,000
你发现好像不是那么顺手

2199
01:22:51,000 --> 01:22:56,000
所以这里面就是你要做的改动还是蛮多的

2200
01:22:56,000 --> 01:22:58,000
你得自己定义出一套

2201
01:22:58,000 --> 01:23:02,000
假设你那个软件是可以更改自己快捷键的话

2202
01:23:02,000 --> 01:23:04,000
有很多人你其实是不支持的

2203
01:23:04,000 --> 01:23:05,000
就是你要去想

2204
01:23:05,000 --> 01:23:07,000
我怎么去在这个键盘上

2205
01:23:07,000 --> 01:23:08,000
不许上去找一套

2206
01:23:08,000 --> 01:23:10,000
我觉得还不错

2207
01:23:10,000 --> 01:23:12,000
能够为自己能记得住的

2208
01:23:12,000 --> 01:23:14,000
一套快捷键的组合

2209
01:23:14,000 --> 01:23:17,000
不是一个两个是整套整套的缓

2210
01:23:17,000 --> 01:23:18,000
对

2211
01:23:18,000 --> 01:23:20,000
其实挺辛苦的

2212
01:23:20,000 --> 01:23:21,000
是

2213
01:23:21,000 --> 01:23:23,000
OK

2214
01:23:23,000 --> 01:23:26,000
现在我们进入今天的主题是

2215
01:23:26,000 --> 01:23:29,000
Design Pattern

2216
01:23:29,000 --> 01:23:30,000
设计模式

2217
01:23:30,000 --> 01:23:33,000
又是一期比较

2218
01:23:33,000 --> 01:23:36,000
水可能也不一定

2219
01:23:36,000 --> 01:23:38,000
但是会比较

2220
01:23:38,000 --> 01:23:38,000
感

2221
01:23:38,000 --> 01:23:40,000
玄学的东西

2222
01:23:40,000 --> 01:23:43,000
我知道

2223
01:23:43,000 --> 01:23:47,000
就我所感受到的一种

2224
01:23:47,000 --> 01:23:50,000
一种心态

2225
01:23:50,000 --> 01:23:51,000
或者说一种思潮

2226
01:23:51,000 --> 01:23:57,000
就是一切和架构和设计有关的东西都非常的虚

2227
01:23:57,000 --> 01:23:59,000
一切和

2228
01:23:59,000 --> 01:24:02,000
一切比较接近于底层实现

2229
01:24:02,000 --> 01:24:07,000
或者是比较接近于理论和概念性的东西

2230
01:24:07,000 --> 01:24:11,000
才是真正值得人花精力去研究的内功心法

2231
01:24:11,000 --> 01:24:16,000
我不能说这样想不对吧

2232
01:24:16,000 --> 01:24:26,000
但是我总觉得在现代软件越来越大规模的工业化的时代

2233
01:24:26,000 --> 01:24:32,000
学一点设计模式还是有相当必要

2234
01:24:32,000 --> 01:24:34,000
因为怎么说呢

2235
01:24:34,000 --> 01:24:37,000
虽然最近几年随着这个

2236
01:24:37,000 --> 01:24:40,000
为什么开游灯打关枪的感觉

2237
01:24:40,000 --> 01:24:44,000
就是最近几年开源运动非常的火

2238
01:24:44,000 --> 01:24:46,000
同时也推行了一大批

2239
01:24:46,000 --> 01:24:48,000
比较黑客

2240
01:24:48,000 --> 01:24:55,000
比较走酷炫流派的程序员的思潮

2241
01:24:55,000 --> 01:24:59,000
你是想说 Ruby on Reels 吗

2242
01:24:59,000 --> 01:25:04,000
我没有特别针对某一个

2243
01:25:04,000 --> 01:25:06,000
Ruby on Reels

2244
01:25:06,000 --> 01:25:07,000
没有针对某一个语言

2245
01:25:07,000 --> 01:25:09,000
或者针对某一个 framework

2246
01:25:09,000 --> 01:25:11,000
但是我想说的一件事情就是

2247
01:25:11,000 --> 01:25:14,000
比如说有些时候

2248
01:25:14,000 --> 01:25:16,000
我不知道你怎么样

2249
01:25:16,000 --> 01:25:17,000
但是现在我有时候会觉得

2250
01:25:17,000 --> 01:25:21,000
自己判断一个人是不是牛人的标准

2251
01:25:21,000 --> 01:25:26,000
是看他有没有打过出一个知名的工具来

2252
01:25:26,000 --> 01:25:31,000
会看他 Github 上面的 repository 怎么样

2253
01:25:31,000 --> 01:25:39,000
我想说这些指标的确可以反映出一个人的编程能力

2254
01:25:39,000 --> 01:25:43,000
但是反过来

2255
01:25:43,000 --> 01:25:45,000
另外有一些编程能力是

2256
01:25:45,000 --> 01:25:48,000
没有办法通过一个 Github repository

2257
01:25:48,000 --> 01:25:52,000
通过一套算法面试题

2258
01:25:52,000 --> 01:25:56,000
或者是通过一篇解释某一个

2259
01:25:56,000 --> 01:26:00,000
比较晦涩的编程概念能够体现出来的

2260
01:26:00,000 --> 01:26:06,000
而这种能力却恰恰很有可能是在

2261
01:26:06,000 --> 01:26:11,000
构建大型程序的时候非常需要的

2262
01:26:11,000 --> 01:26:14,000
那我觉得这种能力的体现

2263
01:26:14,000 --> 01:26:18,000
其实就在于对于比如像设计模式

2264
01:26:18,000 --> 01:26:24,000
这样一些听起来比较大而无当的概念的掌握程度上

2265
01:26:24,000 --> 01:26:26,000
其实我啰嗦这么一大堆想说什么

2266
01:26:26,000 --> 01:26:30,000
我想说的就是最开始提出设计模式的四个

2267
01:26:30,000 --> 01:26:33,000
或者说最开始让设计模式这四个

2268
01:26:33,000 --> 01:26:36,000
自深入人心的这四个人

2269
01:26:36,000 --> 01:26:38,000
Eric

2270
01:26:38,000 --> 01:26:39,000
Eric

2271
01:26:39,000 --> 01:26:42,000
他是一个瑞士人

2272
01:26:42,000 --> 01:26:42,000
所以是

2273
01:26:42,000 --> 01:26:44,000
Eric Gamma

2274
01:26:44,000 --> 01:26:46,000
Richard Helm

2275
01:26:46,000 --> 01:26:47,000
Ralph Johnson

2276
01:26:47,000 --> 01:26:49,000
还有 John

2277
01:26:49,000 --> 01:26:51,000
Vlicidas

2278
01:26:51,000 --> 01:26:53,000
这四个人

2279
01:26:53,000 --> 01:26:57,000
他们其实都没有什么说出来特别了不起的成绩

2280
01:26:57,000 --> 01:27:00,000
当然 Eric Gamma

2281
01:27:00,000 --> 01:27:03,000
是一个比较重要的人物

2282
01:27:03,000 --> 01:27:07,000
他现在在应该是现在应该是在 Microsoft 工作

2283
01:27:07,000 --> 01:27:15,000
这四个人都没有什么能够单独摆出来说这个人就是做了那件事的那个人

2284
01:27:15,000 --> 01:27:21,000
但是他们四个人毫无疑问都是在工业在比较大的软件界

2285
01:27:21,000 --> 01:27:26,000
比较大的软件工程项目之中摸拍滚打了很多年的人

2286
01:27:26,000 --> 01:27:33,000
才可以写出这样一些比较重要的设计模式

2287
01:27:33,000 --> 01:27:35,000
然后

2288
01:27:35,000 --> 01:27:35,000
然后

2289
01:27:35,000 --> 01:27:38,000
展现给大家

2290
01:27:38,000 --> 01:27:44,000
如果你去搜他们四人的资料的话

2291
01:27:44,000 --> 01:27:48,000
其实就找不到什么

2292
01:27:48,000 --> 01:27:49,000
但是

2293
01:27:49,000 --> 01:27:56,000
并不意味着他们就没有能够交给别人的东西

2294
01:27:56,000 --> 01:27:58,000
所以 Ril 你是什么时候接触设计模式

2295
01:27:58,000 --> 01:28:00,000
或者说你根本接触过设计模式

2296
01:28:00,000 --> 01:28:02,000
你使用过设计模式

2297
01:28:02,000 --> 01:28:03,000
没有啊

2298
01:28:03,000 --> 01:28:06,000
因为其实在我的理解里面

2299
01:28:06,000 --> 01:28:08,000
设计模式这种一般是属于这种

2300
01:28:08,000 --> 01:28:12,000
学这个 soft engineering 的专业的人才会去

2301
01:28:12,000 --> 01:28:14,000
去关注的

2302
01:28:14,000 --> 01:28:17,000
甚至是连就是这个通常意义上 CS

2303
01:28:17,000 --> 01:28:18,000
就是可能是 science

2304
01:28:18,000 --> 01:28:19,000
他对这个东西

2305
01:28:19,000 --> 01:28:21,000
就没有那么关注

2306
01:28:21,000 --> 01:28:25,000
因为它是一个非常工业化的需求

2307
01:28:25,000 --> 01:28:25,000
对吧

2308
01:28:25,000 --> 01:28:28,000
并不是一个学院化的东西

2309
01:28:28,000 --> 01:28:29,000
对

2310
01:28:29,000 --> 01:28:29,000
所以

2311
01:28:29,000 --> 01:28:32,000
如果打一个不太恰论的比例的话

2312
01:28:32,000 --> 01:28:33,000
比方的话

2313
01:28:33,000 --> 01:28:37,000
那就是 design pattern 所描述的是

2314
01:28:37,000 --> 01:28:40,000
你应该盖什么样的房子

2315
01:28:40,000 --> 01:28:42,000
或者说你应该怎样盖房子

2316
01:28:42,000 --> 01:28:45,000
而我们日常在

2317
01:28:45,000 --> 01:28:47,000
至少在学校里面

2318
01:28:47,000 --> 01:28:48,000
所学到的更多的是

2319
01:28:48,000 --> 01:28:50,000
比如像结构力学啊

2320
01:28:50,000 --> 01:28:51,000
或者是

2321
01:28:51,000 --> 01:28:55,000
房屋造价核算啊

2322
01:28:55,000 --> 01:28:56,000
这样的一些东西

2323
01:28:56,000 --> 01:28:57,000
对

2324
01:28:57,000 --> 01:28:59,000
这基本上是一个

2325
01:28:59,000 --> 01:29:01,000
艺术和科学之间的分野

2326
01:29:01,000 --> 01:29:03,000
就如果你要

2327
01:29:03,000 --> 01:29:05,000
一定要把它往高达上的方向说的话

2328
01:29:05,000 --> 01:29:06,000
设计模式

2329
01:29:06,000 --> 01:29:08,000
其实这样的东西

2330
01:29:08,000 --> 01:29:08,000
然后

2331
01:29:08,000 --> 01:29:11,000
我看的设计模式已经是

2332
01:29:11,000 --> 01:29:14,000
十年前的事了

2333
01:29:14,000 --> 01:29:14,000
至少

2334
01:29:14,000 --> 01:29:17,000
所以我为了准备这期节目

2335
01:29:17,000 --> 01:29:19,000
也没有把它找出来重新看一遍

2336
01:29:19,000 --> 01:29:21,000
我只记得

2337
01:29:21,000 --> 01:29:23,000
那本书的封面是埃什尔的画

2338
01:29:23,000 --> 01:29:26,000
埃什尔是一个荷兰画家

2339
01:29:26,000 --> 01:29:27,000
他的画非常有意思

2340
01:29:27,000 --> 01:29:30,000
然后我对他唯一的印象就是

2341
01:29:30,000 --> 01:29:31,000
他封面是那幅画

2342
01:29:31,000 --> 01:29:35,000
然后这四个人合起来的叫做四人帮

2343
01:29:35,000 --> 01:29:37,000
Done for 这个名字其实是

2344
01:29:37,000 --> 01:29:40,000
这本书出来的时候

2345
01:29:40,000 --> 01:29:42,000
中国的这个文化大革命的

2346
01:29:42,000 --> 01:29:45,000
四人帮这个概念刚刚传到

2347
01:29:45,000 --> 01:29:47,000
国外不久

2348
01:29:47,000 --> 01:29:48,000
所以他们就把这个四人帮的

2349
01:29:48,000 --> 01:29:52,000
称呼拿过来套在了这四人身上

2350
01:29:52,000 --> 01:29:53,000
太倒霉了

2351
01:29:53,000 --> 01:29:55,000
对

2352
01:29:55,000 --> 01:29:56,000
这不是说小时

2353
01:29:56,000 --> 01:29:56,000
真的是这样

2354
01:29:56,000 --> 01:29:57,000
我知道

2355
01:29:57,000 --> 01:29:58,000
他们太倒霉了

2356
01:29:58,000 --> 01:30:04,000
我觉得可能英语世界的人

2357
01:30:04,000 --> 01:30:05,000
不太能够理解

2358
01:30:05,000 --> 01:30:10,000
四人帮在至少在中国的语境之下

2359
01:30:10,000 --> 01:30:14,000
说出来是一个多么负面和恐怖的词

2360
01:30:14,000 --> 01:30:17,000
但也觉得他们看来

2361
01:30:17,000 --> 01:30:18,000
真的就是一个杠而已

2362
01:30:18,000 --> 01:30:22,000
然后我记得如果没记错的话

2363
01:30:22,000 --> 01:30:26,000
他们在前言里面提到了一本书

2364
01:30:26,000 --> 01:30:29,000
这本书是来自于建筑专业的

2365
01:30:29,000 --> 01:30:32,000
一本讲述

2366
01:30:32,000 --> 01:30:34,000
怎么说呢

2367
01:30:34,000 --> 01:30:36,000
建筑方法论那本书

2368
01:30:36,000 --> 01:30:38,000
这本书叫做建筑的永恒之道

2369
01:30:38,000 --> 01:30:41,000
Timeless way of building

2370
01:30:41,000 --> 01:30:45,000
之后在一个很机缘巧合场景下

2371
01:30:45,000 --> 01:30:47,000
我拿了这本书的中文版

2372
01:30:47,000 --> 01:30:49,000
翻译一下觉得没有

2373
01:30:49,000 --> 01:30:53,000
这个没有设定模式这本书里面

2374
01:30:54,000 --> 01:30:56,000
吹加引号的那么神奇

2375
01:30:56,000 --> 01:31:01,000
而且我也不是很推荐大家去看

2376
01:31:01,000 --> 01:31:03,000
因为如果你不结合

2377
01:31:03,000 --> 01:31:09,000
这本书的当时的 context 的话

2378
01:31:09,000 --> 01:31:11,000
是挺难理解的

2379
01:31:11,000 --> 01:31:13,000
这本书出版于 1979 年

2380
01:31:13,000 --> 01:31:17,000
就比 90 年代的面向模式

2381
01:31:17,000 --> 01:31:22,000
设计模式还要早上

2382
01:31:22,000 --> 01:31:29,000
总的来说建筑的永恒之道

2383
01:31:29,000 --> 01:31:31,000
这本书里面所试图表达的一个观点

2384
01:31:31,000 --> 01:31:34,000
就是你在造建筑的时候

2385
01:31:34,000 --> 01:31:38,000
你必须想方设法的去达到一种

2386
01:31:38,000 --> 01:31:42,000
没有办法定义的 quality

2387
01:31:42,000 --> 01:31:49,000
有点像神棍书就是蝉与摩托车维护的艺术里面

2388
01:31:49,000 --> 01:31:51,000
所提到的所谓两指

2389
01:31:51,000 --> 01:31:56,000
就是你要使你的建筑能够体现出这样一种

2390
01:31:56,000 --> 01:31:58,000
你说它是煤也好

2391
01:31:58,000 --> 01:31:59,000
说它是道也好

2392
01:31:59,000 --> 01:32:01,000
这样一种质量

2393
01:32:01,000 --> 01:32:05,000
而为了达成这种质量

2394
01:32:05,000 --> 01:32:07,000
你必须遵循一些特定的模式

2395
01:32:07,000 --> 01:32:09,000
然后这个概念

2396
01:32:09,000 --> 01:32:11,000
这个 design pattern 的概念

2397
01:32:11,000 --> 01:32:13,000
就源自于这本书

2398
01:32:13,000 --> 01:32:16,000
然后 1994 年

2399
01:32:16,000 --> 01:32:19,000
思维作者所写的设计模式

2400
01:32:19,000 --> 01:32:22,000
或者说全称叫做

2401
01:32:22,000 --> 01:32:27,000
如何构建更好的面向对象的程序

2402
01:32:27,000 --> 01:32:30,000
也就借用这个概念

2403
01:32:30,000 --> 01:32:32,000
是想要总结出一些

2404
01:32:32,000 --> 01:32:35,000
在使用面向对象的技术来写程序的时候

2405
01:32:35,000 --> 01:32:40,000
人们应该遵循那些比较常见的技巧和方法

2406
01:32:40,000 --> 01:32:46,000
这基本上就是一个对于摄影模式

2407
01:32:46,000 --> 01:32:49,000
不那么教科书式的介绍

2408
01:32:49,000 --> 01:32:52,000
大概就是我的理解

2409
01:32:52,000 --> 01:32:57,000
所以其实如果我们接着拿建筑例子来做对比的话

2410
01:32:57,000 --> 01:32:59,000
所谓设计模式

2411
01:32:59,000 --> 01:33:02,000
会就是说有一堆老师傅告诉你说

2412
01:33:02,000 --> 01:33:03,000
你看我刚才你说

2413
01:33:03,000 --> 01:33:08,000
你这个墙得这么弃

2414
01:33:08,000 --> 01:33:10,000
它才会稳固才会倒

2415
01:33:10,000 --> 01:33:12,000
你要按你那个方法弃也可以

2416
01:33:12,000 --> 01:33:15,000
但是可能就是不太结实

2417
01:33:15,000 --> 01:33:16,000
一推就倒了

2418
01:33:16,000 --> 01:33:22,000
就做的是一个把过往的经验抽象出来

2419
01:33:22,000 --> 01:33:24,000
叫怎么来的

2420
01:33:24,000 --> 01:33:30,000
就是成为一个可以被后人学习的这么一个东西

2421
01:33:30,000 --> 01:33:32,000
对可以这么说

2422
01:33:32,000 --> 01:33:34,000
但我要强调的一点就是

2423
01:33:34,000 --> 01:33:36,000
摄影模式是一个比较

2424
01:33:36,000 --> 01:33:40,000
在更高的抽象层级上工作的这样一种技巧

2425
01:33:40,000 --> 01:33:43,000
就是你说的器墙

2426
01:33:43,000 --> 01:33:46,000
我觉得可能更合适的比喻是

2427
01:33:46,000 --> 01:33:48,000
比如说 Hacker's Delight

2428
01:33:48,000 --> 01:33:52,000
或者是 Program Pro

2429
01:33:52,000 --> 01:33:53,000
就是编程珠基

2430
01:33:53,000 --> 01:33:57,000
这本书里面所讲的那些技巧

2431
01:33:57,000 --> 01:34:04,000
就是在一些比较颗粒度比较小的级别上面

2432
01:34:04,000 --> 01:34:07,000
告诉你怎样写出质量更好的代码

2433
01:34:07,000 --> 01:34:12,000
而设计模式则更多的是在比较高级的层面上

2434
01:34:12,000 --> 01:34:14,000
比如说沿用建筑的比方的话

2435
01:34:14,000 --> 01:34:15,000
那可能建筑模式

2436
01:34:15,000 --> 01:34:16,000
设计模式

2437
01:34:16,000 --> 01:34:17,000
所以要表达的是

2438
01:34:17,000 --> 01:34:19,000
比如说你要怎样用两个

2439
01:34:19,000 --> 01:34:24,000
怎样用一个长廊连接两个屋子

2440
01:34:24,000 --> 01:34:26,000
然后你把屋子摆成这样

2441
01:34:26,000 --> 01:34:28,000
会给人一种什么样的

2442
01:34:28,000 --> 01:34:31,000
给人一种什么样的印象

2443
01:34:31,000 --> 01:34:35,000
让人让这个起居者会有怎样的动线

2444
01:34:35,000 --> 01:34:37,000
乃至于你写的

2445
01:34:37,000 --> 01:34:42,000
你造的这个屋子要怎样才能跟周围的环境融合起来

2446
01:34:42,000 --> 01:34:45,000
怎样才能保证说你要符合当地的

2447
01:34:45,000 --> 01:34:47,000
比如说风水

2448
01:34:47,000 --> 01:34:48,000
或者是要比如

2449
01:34:48,000 --> 01:34:52,000
要怎样才能不去破坏周围的植被

2450
01:34:52,000 --> 01:34:55,000
乃至于怎样故意的让你的建筑

2451
01:34:55,000 --> 01:34:57,000
和周围的建筑产生一定的反差

2452
01:34:57,000 --> 01:35:00,000
比如说那个北京的叫什么

2453
01:35:00,000 --> 01:35:04,000
大剧院或者是杜一鸣做的那个

2454
01:35:04,000 --> 01:35:05,000
卢浮宫的入口

2455
01:35:05,000 --> 01:35:07,000
诸如此类的东西

2456
01:35:07,000 --> 01:35:09,000
设计模式讨论的是这样一种东西

2457
01:35:09,000 --> 01:35:11,000
就是更接近于艺术性的东西

2458
01:35:11,000 --> 01:35:14,000
但是与此同时

2459
01:35:14,000 --> 01:35:16,000
它又没有那么的

2460
01:35:16,000 --> 01:35:17,000
瞟瞟

2461
01:35:17,000 --> 01:35:19,000
就我有时候我觉得

2462
01:35:19,000 --> 01:35:23,000
当然我对建筑只是比较奇怪的

2463
01:35:23,000 --> 01:35:25,000
有比较奇怪的兴趣

2464
01:35:25,000 --> 01:35:29,000
但是有时候我会觉得建筑里面的模式是非常难以总结和复用的

2465
01:35:29,000 --> 01:35:31,000
而且建筑的艺术性太强了

2466
01:35:31,000 --> 01:35:39,000
建筑师会倾向于用比较有个性化的方法去诠释所谓的设计模式

2467
01:35:39,000 --> 01:35:42,000
但是在软件工程的设计模式里面

2468
01:35:42,000 --> 01:35:47,000
基本上每一个模式都是不那么风格化的

2469
01:35:47,000 --> 01:35:49,000
就是比如说

2470
01:35:49,000 --> 01:35:52,000
你也写 visitor pattern

2471
01:35:52,000 --> 01:35:54,000
我也写 visitor pattern

2472
01:35:54,000 --> 01:35:54,000
都一样

2473
01:35:54,000 --> 01:35:56,000
你哪怕起另外一个名字

2474
01:35:56,000 --> 01:35:58,000
玫瑰

2475
01:35:58,000 --> 01:35:58,000
一千种名字

2476
01:35:58,000 --> 01:36:01,000
它还是那样一个东西

2477
01:36:01,000 --> 01:36:02,000
就是如果你能

2478
01:36:02,000 --> 01:36:04,000
如果你接触这个模式的话

2479
01:36:04,000 --> 01:36:06,000
别人哪怕换一个名字来写

2480
01:36:06,000 --> 01:36:08,000
你还是可以意识到那就是那个模式本身

2481
01:36:08,000 --> 01:36:11,000
它没有那么多的艺术价值

2482
01:36:11,000 --> 01:36:12,000
所以总结来说

2483
01:36:12,000 --> 01:36:20,000
设计模式基本上就是比较高层次的被总结出来的凝固的 best practice

2484
01:36:20,000 --> 01:36:24,000
然后它的意义就是可以在帮助你

2485
01:36:24,000 --> 01:36:30,000
在告诉你在各种情况之下怎样能比较好的建构

2486
01:36:30,000 --> 01:36:31,000
构建你的代码

2487
01:36:31,000 --> 01:36:34,000
然后让你的代码之间解药

2488
01:36:34,000 --> 01:36:39,000
因为设计模式的两大要素就是

2489
01:36:39,000 --> 01:36:43,000
一个是要 program to interface

2490
01:36:43,000 --> 01:36:44,000
not implementation

2491
01:36:44,000 --> 01:36:47,000
另一个就是 prefer

2492
01:36:47,000 --> 01:36:51,000
favor object composition over inheritance

2493
01:36:51,000 --> 01:36:58,000
就是你要针对这个界面而非实现来编程

2494
01:36:58,000 --> 01:37:02,000
另外一方面你要更多的使用 object composition

2495
01:37:02,000 --> 01:37:06,000
就是你要让一个 object 去包含另外一个 object

2496
01:37:06,000 --> 01:37:10,000
而不是让一个 object 继承自另外一个 object

2497
01:37:10,000 --> 01:37:14,000
我觉得这两点其实算是过了这么久

2498
01:37:14,000 --> 01:37:17,000
一直颠扑不迫的两个真理

2499
01:37:17,000 --> 01:37:23,000
而且你如果从这个角度去反观很多设计的话

2500
01:37:23,000 --> 01:37:25,000
你会觉得很多设计都是有问题

2501
01:37:25,000 --> 01:37:28,000
我不知道你怎么看

2502
01:37:28,000 --> 01:37:32,000
但至少 object composition over inheritance

2503
01:37:32,000 --> 01:37:37,000
这一点在 objective-c 里面体现的非常明显

2504
01:37:37,000 --> 01:37:41,000
应该不应该怎么说

2505
01:37:41,000 --> 01:37:43,000
应该说 objective-c 的一个库

2506
01:37:43,000 --> 01:37:46,000
也就是苹果用的 coco cool 里面

2507
01:37:46,000 --> 01:37:47,000
这一点体现的比较明显

2508
01:37:47,000 --> 01:37:51,000
coco 的所有的用力

2509
01:37:51,000 --> 01:37:54,000
基本上都在推荐你使用 composition

2510
01:37:54,000 --> 01:37:57,000
很少会说你来继承一下

2511
01:37:57,000 --> 01:38:02,000
我的这样一个积累

2512
01:38:02,000 --> 01:38:06,000
然后通过继承的方法来实现你自己的一些影响逻辑

2513
01:38:06,000 --> 01:38:09,000
可是反过来在我又黑这儿

2514
01:38:09,000 --> 01:38:13,000
在 java 世界里面你会发现很多人

2515
01:38:13,000 --> 01:38:15,000
尤其在 j 2 e 的世界里面有很多很多东西

2516
01:38:15,000 --> 01:38:19,000
很多很多时候你都是被逼着使用 inheritance

2517
01:38:19,000 --> 01:38:23,000
然后你会大量的去找说目前这个类

2518
01:38:23,000 --> 01:38:26,000
它的 inheritance 的 tree 是怎么样的

2519
01:38:26,000 --> 01:38:27,000
它上面继承了谁

2520
01:38:27,000 --> 01:38:29,000
下面又被谁继承了

2521
01:38:29,000 --> 01:38:32,000
然后导致你牵一发而动绝身

2522
01:38:32,000 --> 01:38:34,000
然后这个时候你再回头来看

2523
01:38:34,000 --> 01:38:37,000
Design Pattern 这本书里面

2524
01:38:37,000 --> 01:38:39,000
所强调的 object conversation over inheritance

2525
01:38:39,000 --> 01:38:43,000
你会觉得何苦

2526
01:38:43,000 --> 01:38:44,000
真的是

2527
01:38:44,000 --> 01:38:46,000
对这个可能也是

2528
01:38:46,000 --> 01:38:50,000
就为什么大家一直在黑 java 的一个重要的原因

2529
01:38:50,000 --> 01:38:52,000
就是你总感

2530
01:38:52,000 --> 01:38:54,000
我总有一种感觉就是

2531
01:38:54,000 --> 01:38:56,000
java 的本身还是挺好的

2532
01:38:56,000 --> 01:39:03,000
但是被一堆被 OOP 邪教迷惑了的人在那里

2533
01:39:03,000 --> 01:39:09,000
在 java 评价写一些东西出来搞得非常臃肿不堪

2534
01:39:09,000 --> 01:39:10,000
然后也不是很迷惑

2535
01:39:10,000 --> 01:39:17,000
对我前一天在 hack news 上看了一个 news group 里面的八卦

2536
01:39:17,000 --> 01:39:23,000
就是那个 java 设计员的设计者的第二设计者

2537
01:39:23,000 --> 01:39:30,000
就是起到了一些语法方面的决策作用的一个人叫

2538
01:39:30,000 --> 01:39:31,000
叫什么人

2539
01:39:31,000 --> 01:39:32,000
Norton

2540
01:39:32,000 --> 01:39:33,000
他应该姓 Norton

2541
01:39:33,000 --> 01:39:34,000
他是一个

2542
01:39:34,000 --> 01:39:36,000
之所以会记住这个名字

2543
01:39:36,000 --> 01:39:39,000
是因为他在 90 年代末期有过一桩非常有名的恋童案件

2544
01:39:39,000 --> 01:39:40,000
他去

2545
01:39:40,000 --> 01:39:45,000
他坐着私人的喷嚏机去迪斯尼

2546
01:39:45,000 --> 01:39:48,000
会一个 13 岁的小女孩

2547
01:39:48,000 --> 01:39:49,000
并且要求

2548
01:39:49,000 --> 01:39:51,000
并且要求这个小女孩

2549
01:39:51,000 --> 01:39:54,000
跳脱衣舞

2550
01:39:54,000 --> 01:39:55,000
还是

2551
01:39:55,000 --> 01:39:58,000
做一些别的什么事情

2552
01:39:58,000 --> 01:40:02,000
然后后来这个小女孩其实是 FBI 的一个侦探

2553
01:40:02,000 --> 01:40:05,000
看起来比较小

2554
01:40:05,000 --> 01:40:07,000
然后隐藏了自己真是年龄

2555
01:40:07,000 --> 01:40:09,000
然后这个人被告到法律上

2556
01:40:09,000 --> 01:40:09,000
最后

2557
01:40:09,000 --> 01:40:12,000
最后的处罚好像挺荒诞的

2558
01:40:12,000 --> 01:40:16,000
是让他免费为 FBI 工作一年

2559
01:40:16,000 --> 01:40:18,000
之类的这么一个处罚

2560
01:40:18,000 --> 01:40:19,000
然后

2561
01:40:19,000 --> 01:40:20,000
对打个岔

2562
01:40:20,000 --> 01:40:23,000
这个人他是 java 的语言的发明者

2563
01:40:23,000 --> 01:40:23,000
然后他在

2564
01:40:23,000 --> 01:40:24,000
之一

2565
01:40:24,000 --> 01:40:25,000
对

2566
01:40:25,000 --> 01:40:27,000
他在 news group 里面提到说

2567
01:40:27,000 --> 01:40:29,000
java 其实受到了

2568
01:40:29,000 --> 01:40:34,000
非常严重的 objective-c 的影响

2569
01:40:34,000 --> 01:40:36,000
但是这种影响

2570
01:40:36,000 --> 01:40:40,000
很显然仅仅局限在这个语言的特性上

2571
01:40:40,000 --> 01:40:44,000
就是比如说他有很多动态的机制

2572
01:40:44,000 --> 01:40:47,000
每个方法都是存储在

2573
01:40:47,000 --> 01:40:51,000
class 内部的一个 field 之类

2574
01:40:51,000 --> 01:40:56,000
但是这样一种语言所衍生出来的两个酷

2575
01:40:56,000 --> 01:40:57,000
确实大相竞性了

2576
01:40:57,000 --> 01:41:03,000
比如说在 java 的整个类裤里面

2577
01:41:03,000 --> 01:41:09,000
在很多时候都是和这个 objective-c 所衍生出来的

2578
01:41:09,000 --> 01:41:10,000
最广泛使用的类裤

2579
01:41:10,000 --> 01:41:15,000
完全不相像的一些设计哲学的起作

2580
01:41:15,000 --> 01:41:19,000
其实这也是我之前在用那个 scala 的时候的

2581
01:41:19,000 --> 01:41:20,000
遇到的一个问题

2582
01:41:20,000 --> 01:41:23,000
就是 newscala 是也跑在 jvm

2583
01:41:23,000 --> 01:41:27,000
他也是比较能够方便调用 java 的那些

2584
01:41:27,000 --> 01:41:29,000
用 java 写的那些包

2585
01:41:29,000 --> 01:41:31,000
对目前的

2586
01:41:31,000 --> 01:41:32,000
然后你会发现

2587
01:41:32,000 --> 01:41:34,000
他一旦到了

2588
01:41:34,000 --> 01:41:38,000
你用别人一个针对 java 写的这么一个包的时候

2589
01:41:38,000 --> 01:41:39,000
他的一些接口

2590
01:41:39,000 --> 01:41:43,000
整个设计哲学就完全是一种纯 OOP 的思维

2591
01:41:43,000 --> 01:41:48,000
然后 scala 它是一个 OOP 加 FP 混合的

2592
01:41:48,000 --> 01:41:49,000
这么一种范式的语言了

2593
01:41:49,000 --> 01:41:52,000
就用起来非常非常便宜

2594
01:41:52,000 --> 01:41:55,000
你需要在两种思维范式之间切换吗

2595
01:41:55,000 --> 01:41:55,000
对

2596
01:41:55,000 --> 01:41:57,000
有时候你会看到

2597
01:41:57,000 --> 01:41:59,000
为什么 java 这不是傻逼吗

2598
01:41:59,000 --> 01:41:59,000
为什么这么设计

2599
01:41:59,000 --> 01:42:01,000
但其实也主要的原因就是说

2600
01:42:01,000 --> 01:42:04,000
java 语言本身有一些特殊的限制

2601
01:42:04,000 --> 01:42:05,000
导致不那么写

2602
01:42:05,000 --> 01:42:10,000
反而可能重用和这个叫什么来的

2603
01:42:10,000 --> 01:42:12,000
代码的构建没有那么灵活

2604
01:42:12,000 --> 01:42:17,000
但是你到一个更加灵活的语言里面去看

2605
01:42:17,000 --> 01:42:19,000
然后加上那种设计

2606
01:42:19,000 --> 01:42:21,000
那种限制导致出来的接口的设计

2607
01:42:21,000 --> 01:42:24,000
其实是非常笨拙的

2608
01:42:24,000 --> 01:42:25,000
是

2609
01:42:25,000 --> 01:42:28,000
其实我最近在写 Swift 的时候

2610
01:42:28,000 --> 01:42:28,000
也有种感觉

2611
01:42:28,000 --> 01:42:32,000
就是因为 Swift 目前的状态还是有

2612
01:42:32,000 --> 01:42:35,000
虽然在之间减少

2613
01:42:35,000 --> 01:42:38,000
但还是有一部分东西是要跟 Coco

2614
01:42:38,000 --> 01:42:43,000
或者跟底层的 Object-C 的代码视线相交互的

2615
01:42:43,000 --> 01:42:45,000
然后这个时候你就会发现

2616
01:42:45,000 --> 01:42:47,000
你会感觉到一种

2617
01:42:47,000 --> 01:42:50,000
从文法上面

2618
01:42:50,000 --> 01:42:52,000
不是文法

2619
01:42:52,000 --> 01:42:58,000
是从 literacy 上面就可以感受到两者的冲撞

2620
01:42:58,000 --> 01:43:02,000
Swift 的很多东西都是非常简洁的

2621
01:43:02,000 --> 01:43:04,000
比如说 Function 这个词都不愿意拼好

2622
01:43:04,000 --> 01:43:05,000
写个 Funk

2623
01:43:05,000 --> 01:43:08,000
然后或者有很多 shortcut

2624
01:43:08,000 --> 01:43:13,000
比如说最新的什么 forX in Y where Z

2625
01:43:13,000 --> 01:43:15,000
然后你可以少写一个

2626
01:43:15,000 --> 01:43:24,000
你可以通过这个 filter 直接在 loop 体的外面

2627
01:43:24,000 --> 01:43:25,000
就把一些边界条件过去掉

2628
01:43:25,000 --> 01:43:28,000
但是当你采用这样一种简洁的写法

2629
01:43:28,000 --> 01:43:30,000
写成正爽的时候

2630
01:43:30,000 --> 01:43:32,000
忽然跳到一个地方

2631
01:43:32,000 --> 01:43:33,000
你需要呼叫一个 object

2632
01:43:33,000 --> 01:43:35,000
一看就是 Object-C

2633
01:43:35,000 --> 01:43:36,000
使在留下

2634
01:43:36,000 --> 01:43:38,000
一留下的 API 的时候

2635
01:43:38,000 --> 01:43:39,000
对

2636
01:43:39,000 --> 01:43:40,000
这个 API 的名字是怒长

2637
01:43:40,000 --> 01:43:43,000
觉得很另类

2638
01:43:43,000 --> 01:43:43,000
对

2639
01:43:43,000 --> 01:43:45,000
String by Appendant

2640
01:43:45,000 --> 01:43:46,000
Another string with Format

2641
01:43:46,000 --> 01:43:47,000
之类的这样一个

2642
01:43:47,000 --> 01:43:49,000
这样一个非常长的

2643
01:43:49,000 --> 01:43:52,000
如果没有这自动提示

2644
01:43:52,000 --> 01:43:53,000
真的是

2645
01:43:53,000 --> 01:43:55,000
杀了我们心

2646
01:43:55,000 --> 01:43:55,000
怎么换了

2647
01:43:55,000 --> 01:43:58,000
这样一个函数名出来

2648
01:43:58,000 --> 01:43:59,000
你就可以明显的感觉到

2649
01:43:59,000 --> 01:44:00,000
这两种

2650
01:44:00,000 --> 01:44:04,000
编程思维在冲撞

2651
01:44:04,000 --> 01:44:07,000
但是索性目前看来

2652
01:44:07,000 --> 01:44:09,000
SWIFT 的更新速度还是比较快的

2653
01:44:09,000 --> 01:44:10,000
也许在

2654
01:44:10,000 --> 01:44:13,000
比较足够进的将来

2655
01:44:13,000 --> 01:44:15,000
我们就可以使用一些比较

2656
01:44:15,000 --> 01:44:16,000
更

2657
01:44:16,000 --> 01:44:20,000
有更多的 SWIFTness 在里面的 API

2658
01:44:20,000 --> 01:44:30,000
可以像现在不是上次 WC 说的时候是他们也逐渐把那些 Coco 啊那些底层的裤要叫做 SWIFT 化了吗

2659
01:44:30,000 --> 01:44:31,000
对

2660
01:44:31,000 --> 01:44:35,000
就是按照 SWIFT 方法给一个这种新的接口

2661
01:44:35,000 --> 01:44:36,000
就不要用那种原油

2662
01:44:36,000 --> 01:44:37,000
你确实很

2663
01:44:37,000 --> 01:44:39,000
用起来真的很别扭

2664
01:44:39,000 --> 01:44:40,000
对

2665
01:44:40,000 --> 01:44:45,000
我乐观估计这个大概需要三到五年的时间

2666
01:44:45,000 --> 01:44:48,000
果然很乐观

2667
01:44:48,000 --> 01:44:50,000
不是五到十年吗

2668
01:44:50,000 --> 01:44:53,000
我觉得三到五年应该差不多

2669
01:44:53,000 --> 01:44:53,000
对

2670
01:44:53,000 --> 01:44:54,000
因为

2671
01:44:54,000 --> 01:44:56,000
看他们决心怎么样

2672
01:44:56,000 --> 01:45:00,000
我觉得还是要看他们对于新产品的投入

2673
01:45:00,000 --> 01:45:01,000
以及对于改这个

2674
01:45:01,000 --> 01:45:07,000
偿还这个技术债务的投入之间找到了平衡

2675
01:45:07,000 --> 01:45:08,000
怎么样

2676
01:45:08,000 --> 01:45:09,000
但也像你说

2677
01:45:09,000 --> 01:45:13,000
你说目前他采用这个叫什么 TikTak 的策略

2678
01:45:13,000 --> 01:45:17,000
一年发布新产品

2679
01:45:17,000 --> 01:45:19,000
一次发布新产品

2680
01:45:19,000 --> 01:45:26,000
另一次就是做维护做升级修复既有产品的账量

2681
01:45:26,000 --> 01:45:27,000
缺陷

2682
01:45:27,000 --> 01:45:28,000
我觉得这个策略还是挺好

2683
01:45:28,000 --> 01:45:30,000
但就看他保持的怎么样

2684
01:45:30,000 --> 01:45:30,000
对

2685
01:45:30,000 --> 01:45:34,000
说回这个设计模式

2686
01:45:34,000 --> 01:45:36,000
其实有一点我一直有点疑惑

2687
01:45:36,000 --> 01:45:40,000
其实我也是看很多人对这个设计模式的批评

2688
01:45:40,000 --> 01:45:40,000
就是说

2689
01:45:40,000 --> 01:45:44,000
就是至少在那本书里面的很多设计模式

2690
01:45:44,000 --> 01:45:45,000
其实很

2691
01:45:45,000 --> 01:45:46,000
它的存在的意义

2692
01:45:46,000 --> 01:45:51,000
仅仅是因为 Java 这个语言本身的一些限制所导致的

2693
01:45:51,000 --> 01:45:51,000
它不够

2694
01:45:51,000 --> 01:45:53,000
是怎么是

2695
01:45:53,000 --> 01:45:55,000
写出来的时候其实是被 CZ 加险

2696
01:45:55,000 --> 01:45:56,000
OK

2697
01:45:56,000 --> 01:45:58,000
就之类的

2698
01:45:58,000 --> 01:45:58,000
就是两个东西

2699
01:45:58,000 --> 01:45:58,000
对

2700
01:45:58,000 --> 01:46:00,000
所谓静态语言

2701
01:46:00,000 --> 01:46:04,000
然后有一些所谓动态语言

2702
01:46:04,000 --> 01:46:05,000
鼓吹着就说

2703
01:46:05,000 --> 01:46:09,000
你费劲搞那么多各种各样的 pattern

2704
01:46:09,000 --> 01:46:10,000
你看我动态语言里面

2705
01:46:10,000 --> 01:46:12,000
根本不用操心这个问题

2706
01:46:12,000 --> 01:46:12,000
我一个列表

2707
01:46:12,000 --> 01:46:15,000
我就是可以装多种不同类型的元素

2708
01:46:15,000 --> 01:46:16,000
你把我咋递

2709
01:46:16,000 --> 01:46:16,000
对吧

2710
01:46:16,000 --> 01:46:17,000
对

2711
01:46:17,000 --> 01:46:18,000
对

2712
01:46:18,000 --> 01:46:19,000
其实这也是一个正确的

2713
01:46:19,000 --> 01:46:21,000
一种正确的理解

2714
01:46:21,000 --> 01:46:22,000
就是编程

2715
01:46:22,000 --> 01:46:23,000
编程里面的设计模式

2716
01:46:23,000 --> 01:46:25,000
在很多时候

2717
01:46:25,000 --> 01:46:27,000
与其说是一种

2718
01:46:27,000 --> 01:46:31,000
做事情方法

2719
01:46:31,000 --> 01:46:32,000
倒不如说是因为语言

2720
01:46:32,000 --> 01:46:34,000
没有办法让你

2721
01:46:34,000 --> 01:46:35,000
欢快

2722
01:46:35,000 --> 01:46:36,000
快乐的做某事

2723
01:46:36,000 --> 01:46:48,000
你不得不先以一种比较约定组成的一种比较经过考验的 best practice 把这件事情做出来

2724
01:46:48,000 --> 01:46:49,000
没错

2725
01:46:49,000 --> 01:46:52,000
美其名预设计模式

2726
01:46:52,000 --> 01:46:53,000
但其实它只是一个

2727
01:46:53,000 --> 01:46:55,000
就是前人

2728
01:46:55,000 --> 01:46:57,000
前人在

2729
01:46:57,000 --> 01:46:59,000
这条路上躺过了

2730
01:46:59,000 --> 01:46:59,000
才楼数个坑

2731
01:46:59,000 --> 01:47:03,000
发现这个坑的副作用是最小的

2732
01:47:03,000 --> 01:47:04,000
我告诉后人说

2733
01:47:04,000 --> 01:47:04,000
来

2734
01:47:04,000 --> 01:47:06,000
我插个小旗在这里

2735
01:47:06,000 --> 01:47:07,000
别走那边那几个坑

2736
01:47:07,000 --> 01:47:08,000
四处有雷

2737
01:47:08,000 --> 01:47:08,000
对

2738
01:47:08,000 --> 01:47:10,000
请这样绕行

2739
01:47:10,000 --> 01:47:10,000
对

2740
01:47:10,000 --> 01:47:11,000
给人画了一条

2741
01:47:11,000 --> 01:47:13,000
我们现在抽象出脑子

2742
01:47:13,000 --> 01:47:14,000
这边是一条路

2743
01:47:14,000 --> 01:47:17,000
你要从这个地图的左下角

2744
01:47:17,000 --> 01:47:18,000
窜到右上角去

2745
01:47:18,000 --> 01:47:19,000
但是雷区遍地

2746
01:47:19,000 --> 01:47:20,000
你不知道吗

2747
01:47:20,000 --> 01:47:22,000
新人你可能跟踩起来就死了

2748
01:47:22,000 --> 01:47:26,000
所以前人在踏着堆堆白骨的基础上

2749
01:47:26,000 --> 01:47:29,000
总结出一条非常曲折绕的方法

2750
01:47:29,000 --> 01:47:31,000
可以到达

2751
01:47:31,000 --> 01:47:33,000
带你顺利到达这个目的地

2752
01:47:33,000 --> 01:47:34,000
对吧

2753
01:47:34,000 --> 01:47:35,000
这就是我们所谓的设计模式

2754
01:47:35,000 --> 01:47:40,000
但是其实我就很多对这个设计模式的批评者来看

2755
01:47:40,000 --> 01:47:41,000
就是说

2756
01:47:41,000 --> 01:47:43,000
那你费那么多精力搞这个

2757
01:47:43,000 --> 01:47:44,000
尽管是因为你语言不够好

2758
01:47:44,000 --> 01:47:46,000
你画一个好一点语言

2759
01:47:46,000 --> 01:47:47,000
不就没这么多事了吗

2760
01:47:47,000 --> 01:47:48,000
对

2761
01:47:48,000 --> 01:47:49,000
就像在

2762
01:47:49,000 --> 01:47:51,000
沿用这个比方的话

2763
01:47:51,000 --> 01:47:53,000
就是你要从 A 点到来 B 点

2764
01:47:53,000 --> 01:47:54,000
在你发展

2765
01:47:54,000 --> 01:47:55,000
干嘛不飞过去呢

2766
01:47:55,000 --> 01:47:56,000
对

2767
01:47:56,000 --> 01:47:58,000
你发展出隧道绝境技术之前

2768
01:47:58,000 --> 01:48:00,000
你不得不在山上绕一圈

2769
01:48:00,000 --> 01:48:00,000
可是

2770
01:48:00,000 --> 01:48:02,000
如果你能挖条隧道的话

2771
01:48:02,000 --> 01:48:03,000
那就不用个分点的事

2772
01:48:03,000 --> 01:48:05,000
比如说

2773
01:48:05,000 --> 01:48:08,000
我觉得这个地方其实可以举起个例子

2774
01:48:08,000 --> 01:48:10,000
你刚才说的动态语言

2775
01:48:10,000 --> 01:48:12,000
比相对来说

2776
01:48:12,000 --> 01:48:16,000
更为强大的容器类型是一个好的例子

2777
01:48:16,000 --> 01:48:17,000
但另外一方面

2778
01:48:17,000 --> 01:48:18,000
比如说

2779
01:48:18,000 --> 01:48:24,000
原始的设计模式里面有个叫做 Observer 的模式

2780
01:48:24,000 --> 01:48:26,000
就是一个人做

2781
01:48:26,000 --> 01:48:31,000
一个类作为 Observer 的注册者

2782
01:48:31,000 --> 01:48:34,000
它来生产一定的消息

2783
01:48:34,000 --> 01:48:36,000
然后另外一些

2784
01:48:36,000 --> 01:48:36,000
这个

2785
01:48:36,000 --> 01:48:40,000
Objects

2786
01:48:40,000 --> 01:48:43,000
作为这个 Observer

2787
01:48:43,000 --> 01:48:44,000
来去注册这个

2788
01:48:44,000 --> 01:48:46,000
注册

2789
01:48:46,000 --> 01:48:48,000
向这个对象注册说

2790
01:48:48,000 --> 01:48:50,000
我对你的某一些消息感兴趣

2791
01:48:50,000 --> 01:48:51,000
如果你这个消息

2792
01:48:51,000 --> 01:48:52,000
请通知我们

2793
01:48:52,000 --> 01:48:54,000
在 Java 里面

2794
01:48:54,000 --> 01:48:55,000
这一边是当作

2795
01:48:55,000 --> 01:48:55,000
或者说

2796
01:48:55,000 --> 01:48:58,000
CJava 里面是当作一个模式来用的

2797
01:48:58,000 --> 01:48:59,000
但是到了 CShop 这一步

2798
01:48:59,000 --> 01:49:01,000
我们都知道

2799
01:49:01,000 --> 01:49:03,000
CShop 脱胎于 Java

2800
01:49:03,000 --> 01:49:04,000
或者说

2801
01:49:04,000 --> 01:49:06,000
它汲取了 Java 的优点

2802
01:49:06,000 --> 01:49:08,000
如果 Java 有什么优点的话

2803
01:49:08,000 --> 01:49:11,000
CShop 内置有

2804
01:49:11,000 --> 01:49:13,000
所谓 Delegate Event

2805
01:49:13,000 --> 01:49:14,000
这两个

2806
01:49:14,000 --> 01:49:17,000
在语言层面上实现的

2807
01:49:17,000 --> 01:49:19,000
怎么说呢

2808
01:49:19,000 --> 01:49:20,000
抽象概念

2809
01:49:20,000 --> 01:49:23,000
有了这个语言结构

2810
01:49:23,000 --> 01:49:24,000
传言概念

2811
01:49:24,000 --> 01:49:25,000
Observer 模式就没有用了

2812
01:49:25,000 --> 01:49:27,000
因为你自己不需要去构建

2813
01:49:27,000 --> 01:49:28,000
这个 Observer 模式

2814
01:49:28,000 --> 01:49:29,000
你只需要直接使用

2815
01:49:29,000 --> 01:49:30,000
CShop 内部的

2816
01:49:30,000 --> 01:49:32,000
这两个

2817
01:49:32,000 --> 01:49:33,000
怎么说的

2818
01:49:33,000 --> 01:49:34,000
语法堂

2819
01:49:34,000 --> 01:49:34,000
就可以

2820
01:49:34,000 --> 01:49:35,000
对

2821
01:49:35,000 --> 01:49:38,000
你还能想到一个别的

2822
01:49:38,000 --> 01:49:40,000
其实这个事情顺着说下去

2823
01:49:40,000 --> 01:49:41,000
因为这种

2824
01:49:41,000 --> 01:49:42,000
经常在这种

2825
01:49:42,000 --> 01:49:44,000
设计 UI 界面的情况

2826
01:49:44,000 --> 01:49:46,000
用的非常多

2827
01:49:46,000 --> 01:49:47,000
现在就

2828
01:49:47,000 --> 01:49:49,000
这新的思潮是什么来的

2829
01:49:49,000 --> 01:49:49,000
就是什么

2830
01:49:49,000 --> 01:49:51,000
FRP

2831
01:49:51,000 --> 01:49:53,000
Functional Reactive Programming

2832
01:49:53,000 --> 01:49:54,000
它连这种

2833
01:49:54,000 --> 01:49:55,000
这种叫什么来的

2834
01:49:55,000 --> 01:49:57,000
这种

2835
01:49:57,000 --> 01:49:59,000
就是交互式的观察者

2836
01:49:59,000 --> 01:50:00,000
还有是被观察者

2837
01:50:00,000 --> 01:50:01,000
就是注册

2838
01:50:01,000 --> 01:50:03,000
这种事情都直接就免了

2839
01:50:03,000 --> 01:50:04,000
我们全部单向流

2840
01:50:04,000 --> 01:50:08,000
就完全是不同的一种思路

2841
01:50:08,000 --> 01:50:10,000
在做这个事情

2842
01:50:10,000 --> 01:50:10,000
你会发现

2843
01:50:10,000 --> 01:50:11,000
其实有些

2844
01:50:11,000 --> 01:50:12,000
设计模式

2845
01:50:12,000 --> 01:50:14,000
其实也是非常

2846
01:50:14,000 --> 01:50:14,000
在观念上

2847
01:50:14,000 --> 01:50:17,000
还是比较成就的一个东西

2848
01:50:17,000 --> 01:50:18,000
当然

2849
01:50:18,000 --> 01:50:20,000
我们现在总是站在一种

2850
01:50:20,000 --> 01:50:21,000
马虎炮的

2851
01:50:21,000 --> 01:50:23,000
这个角度去

2852
01:50:23,000 --> 01:50:26,000
说设计模式里面有些模式

2853
01:50:26,000 --> 01:50:28,000
其实根本就是在修语言

2854
01:50:28,000 --> 01:50:29,000
或者是

2855
01:50:29,000 --> 01:50:31,000
有些模式根本就过时了

2856
01:50:31,000 --> 01:50:33,000
但是在 90 年代的时候

2857
01:50:33,000 --> 01:50:36,000
这本书还是影响了整整

2858
01:50:36,000 --> 01:50:37,000
一代人

2859
01:50:37,000 --> 01:50:38,000
必须说

2860
01:50:38,000 --> 01:50:40,000
而且在这本书之后

2861
01:50:40,000 --> 01:50:43,000
也其实出现了很多其他的

2862
01:50:43,000 --> 01:50:44,000
模式

2863
01:50:44,000 --> 01:50:44,000
比如说

2864
01:50:44,000 --> 01:50:46,000
这本书一上来

2865
01:50:46,000 --> 01:50:48,000
就提到了 MVC 模式

2866
01:50:48,000 --> 01:50:50,000
在接下来的很多年里面

2867
01:50:50,000 --> 01:50:52,000
首先它有很多种不同的解读

2868
01:50:52,000 --> 01:50:53,000
基本上每一个

2869
01:50:53,000 --> 01:50:56,000
每两个程序员

2870
01:50:56,000 --> 01:50:57,000
对于 MVC 的解读

2871
01:50:57,000 --> 01:50:58,000
都是不一样的

2872
01:50:58,000 --> 01:51:02,000
甚至后来也衍生

2873
01:51:02,000 --> 01:51:03,000
由 MVC 衍生出来

2874
01:51:03,000 --> 01:51:04,000
比如什么 MVVM

2875
01:51:04,000 --> 01:51:05,000
或者是

2876
01:51:05,000 --> 01:51:09,000
很多其他莫名其妙

2877
01:51:09,000 --> 01:51:10,000
我现在已经想起来的缩写

2878
01:51:10,000 --> 01:51:12,000
都是脱胎原文

2879
01:51:12,000 --> 01:51:15,000
MVC 这样一种模式的

2880
01:51:15,000 --> 01:51:15,000
对

2881
01:51:15,000 --> 01:51:19,000
以至于很多语言本身

2882
01:51:19,000 --> 01:51:20,000
也会说

2883
01:51:20,000 --> 01:51:22,000
在使用这种语言的时候

2884
01:51:22,000 --> 01:51:23,000
我会有一个特定的模式

2885
01:51:23,000 --> 01:51:23,000
比如说

2886
01:51:23,000 --> 01:51:25,000
我记得以前看过

2887
01:51:25,000 --> 01:51:28,000
一个 Python Patterns

2888
01:51:28,000 --> 01:51:32,000
总结了使用 Python 编程的时候

2889
01:51:32,000 --> 01:51:35,000
能够经常使用到这些 Patterns

2890
01:51:35,000 --> 01:51:36,000
我印象很深的是

2891
01:51:36,000 --> 01:51:40,000
里面有个叫做 Cyborg 的 Patterns

2892
01:51:40,000 --> 01:51:43,000
Cyborg 就是星际迷航

2893
01:51:43,000 --> 01:51:45,000
Star Trek 里面有一个种族

2894
01:51:45,000 --> 01:51:46,000
叫 Cyborg

2895
01:51:46,000 --> 01:51:50,000
他们的个体

2896
01:51:50,000 --> 01:51:51,000
没有个体的意识

2897
01:51:51,000 --> 01:51:56,000
然后他们战斗力非常强

2898
01:51:56,000 --> 01:51:57,000
然后他们每征服一个种族

2899
01:51:57,000 --> 01:51:59,000
就把种族里面的每个个体

2900
01:51:59,000 --> 01:52:04,000
融合到他们的一个 mastermind

2901
01:52:04,000 --> 01:52:06,000
就是他们只有一个集体意识

2902
01:52:06,000 --> 01:52:09,000
然后个体服从一集体

2903
01:52:09,000 --> 01:52:11,000
然后 Cyborg 这个名字

2904
01:52:11,000 --> 01:52:13,000
就被借用来描述这样一种

2905
01:52:13,000 --> 01:52:17,000
Python 的设计模式

2906
01:52:17,000 --> 01:52:20,000
就是很多 objects

2907
01:52:20,000 --> 01:52:24,000
共享一个 global 的 state

2908
01:52:24,000 --> 01:52:29,000
然后还有比如说

2909
01:52:29,000 --> 01:52:32,000
我前年吧

2910
01:52:32,000 --> 01:52:34,000
看了一本 Coco Patterns

2911
01:52:34,000 --> 01:52:36,000
Coco Design Patterns

2912
01:52:36,000 --> 01:52:37,000
也是讲这个

2913
01:52:37,000 --> 01:52:40,000
在 Coco 里面经常被用到的一些模式

2914
01:52:40,000 --> 01:52:44,000
比如说 Observer 模式

2915
01:52:44,000 --> 01:52:45,000
不是 Observer

2916
01:52:45,000 --> 01:52:46,000
Coco 做什么

2917
01:52:46,000 --> 01:52:47,000
Delegation 模式

2918
01:52:47,000 --> 01:52:54,000
乃至于在 Coco 下面的 MVC 模式

2919
01:52:54,000 --> 01:52:56,000
以及比如说

2920
01:52:56,000 --> 01:53:00,000
在写 objectsC 的时候

2921
01:53:00,000 --> 01:53:03,000
经常会用到一个就是 selector

2922
01:53:03,000 --> 01:53:04,000
然后你会说

2923
01:53:04,000 --> 01:53:08,000
我需要延迟一段时间来执行 selector

2924
01:53:08,000 --> 01:53:10,000
出此来这样一些模式

2925
01:53:10,000 --> 01:53:12,000
在这本书里面介绍了

2926
01:53:12,000 --> 01:53:15,000
可以说从设置模式这本书开始之后

2927
01:53:15,000 --> 01:53:20,000
陆陆续续人们才开始着眼于总结出

2928
01:53:20,000 --> 01:53:23,000
使用某一种特定工具的时候

2929
01:53:23,000 --> 01:53:27,000
所以应该使用的一些最佳实践

2930
01:53:27,000 --> 01:53:28,000
然后把它们总结下来

2931
01:53:28,000 --> 01:53:30,000
把它们汇总出来

2932
01:53:30,000 --> 01:53:35,000
起上某某 domain 之下的设计模式

2933
01:53:35,000 --> 01:53:36,000
这样一个意思

2934
01:53:36,000 --> 01:53:37,000
OK

2935
01:53:37,000 --> 01:53:40,000
所以其实我有一点很疑惑的

2936
01:53:40,000 --> 01:53:41,000
就是说

2937
01:53:41,000 --> 01:53:44,000
你觉得对于一个某一个

2938
01:53:44,000 --> 01:53:46,000
某一个工具也好

2939
01:53:46,000 --> 01:53:47,000
某一个语言也好的

2940
01:53:47,000 --> 01:53:48,000
新手来说

2941
01:53:48,000 --> 01:53:50,000
设计模式这个东西有多大的意义

2942
01:53:50,000 --> 01:53:53,000
因为我一直是抱着这么一种想法

2943
01:53:53,000 --> 01:53:55,000
刚刚我们说

2944
01:53:55,000 --> 01:53:56,000
这个是一个

2945
01:53:56,000 --> 01:53:58,000
在一个布满雷区的地图上

2946
01:53:58,000 --> 01:54:00,000
给你画了条线这么一个功能

2947
01:54:00,000 --> 01:54:01,000
对吧

2948
01:54:01,000 --> 01:54:02,000
但是其实对于很多新手来讲

2949
01:54:02,000 --> 01:54:04,000
你不让他去犯那些错误

2950
01:54:04,000 --> 01:54:06,000
他是永远都不知道为什么会这样

2951
01:54:06,000 --> 01:54:08,000
为什么会有另外一种方式来做

2952
01:54:08,000 --> 01:54:09,000
会更好

2953
01:54:09,000 --> 01:54:10,000
看起来可能更曲折

2954
01:54:10,000 --> 01:54:12,000
但结果可能会更加好

2955
01:54:12,000 --> 01:54:14,000
就是没有这么一个学习的过程

2956
01:54:14,000 --> 01:54:17,000
就是我们强行给他灌了一碗鸡汤

2957
01:54:17,000 --> 01:54:19,000
说喝这个对你有意

2958
01:54:19,000 --> 01:54:20,000
别问为什么

2959
01:54:20,000 --> 01:54:22,000
但是他心里一定有无数个为什么

2960
01:54:22,000 --> 01:54:23,000
没错

2961
01:54:23,000 --> 01:54:25,000
就是如果你没有踩过雷的话

2962
01:54:25,000 --> 01:54:27,000
是不知道被雷炸死有多疼

2963
01:54:27,000 --> 01:54:28,000
对

2964
01:54:29,000 --> 01:54:32,000
而设计模式其实并不是一个适合

2965
01:54:32,000 --> 01:54:35,000
你刚刚学会编程的时候就看的东西

2966
01:54:35,000 --> 01:54:40,000
因为我觉得我自己可能也是看设计模式的时候

2967
01:54:40,000 --> 01:54:42,000
比较倒性还不够深

2968
01:54:42,000 --> 01:54:43,000
当然我现在倒性也不深

2969
01:54:43,000 --> 01:54:47,000
但那个时候这更是会觉得这些设计模式里面

2970
01:54:47,000 --> 01:54:50,000
很多地方就是脱了裤子放屁

2971
01:54:50,000 --> 01:54:53,000
就是我明明可以直接一步就做到了

2972
01:54:53,000 --> 01:54:58,000
为什么一定要通过这么周章的大飞周章的方式来实现它呢

2973
01:54:58,000 --> 01:55:01,000
但是只有你在

2974
01:55:01,000 --> 01:55:07,000
官方话叫做长期的工作时间中

2975
01:55:07,000 --> 01:55:10,000
对大飞周章是长期的工作时间

2976
01:55:10,000 --> 01:55:15,000
只有你在经历过

2977
01:55:15,000 --> 01:55:19,000
因为自己的代码越来越大

2978
01:55:19,000 --> 01:55:27,000
让你每次开始写它都会产生一种恐惧和恶心的情绪的时候

2979
01:55:27,000 --> 01:55:32,000
当你因为每天心不在焉被你的女朋友说

2980
01:55:32,000 --> 01:55:35,000
你是不是不爱我

2981
01:55:35,000 --> 01:55:39,000
然后你所能做出的回答只是

2982
01:55:39,000 --> 01:55:42,000
my code doesn't work 的时候

2983
01:55:42,000 --> 01:55:48,000
你才会体会到摄影模式其实是一种多么伟大的存在

2984
01:55:48,000 --> 01:55:49,000
对

2985
01:55:49,000 --> 01:55:52,000
我觉得其实一个比较合适的切入点是

2986
01:55:52,000 --> 01:55:55,000
你可以写一些程序

2987
01:55:55,000 --> 01:55:58,000
然后总结出你自己觉得

2988
01:55:58,000 --> 01:56:03,000
看起来是个不错的模式加引号的时候

2989
01:56:03,000 --> 01:56:05,000
再去回头去看一些

2990
01:56:05,000 --> 01:56:07,000
去回头去看

2991
01:56:07,000 --> 01:56:09,000
比如说摄影模式这本书

2992
01:56:09,000 --> 01:56:11,000
乃至于在这本书出版之后

2993
01:56:11,000 --> 01:56:12,000
有很多很多其他的

2994
01:56:12,000 --> 01:56:13,000
比如说

2995
01:56:13,000 --> 01:56:16,000
Design Patterns in C-Shop

2996
01:56:16,000 --> 01:56:19,000
或者是 Design Patterns Implement in JavaScript

2997
01:56:19,000 --> 01:56:20,000
这类书

2998
01:56:20,000 --> 01:56:25,000
你才会切身领悟到这些设计模式真正的意义和在

2999
01:56:25,000 --> 01:56:26,000
对

3000
01:56:26,000 --> 01:56:29,000
所以其实最合适的阅读这种设计模式

3001
01:56:29,000 --> 01:56:30,000
这种思想

3002
01:56:30,000 --> 01:56:34,000
这种比较玄学的书也好

3003
01:56:34,000 --> 01:56:36,000
还是文章也好的时候

3004
01:56:36,000 --> 01:56:38,000
其实是在你有一定的工作积累

3005
01:56:38,000 --> 01:56:39,000
踩过不少雷

3006
01:56:39,000 --> 01:56:41,000
被炸死过好多次之后

3007
01:56:41,000 --> 01:56:45,000
然后又想进一步提高自己的水平

3008
01:56:45,000 --> 01:56:46,000
又遇到这个瓶颈

3009
01:56:46,000 --> 01:56:48,000
不知道该下一步该怎么走的时候

3010
01:56:48,000 --> 01:56:51,000
来看这个可能有一种那种醍醐灌顶的感觉

3011
01:56:53,000 --> 01:56:54,000
对

3012
01:56:56,000 --> 01:57:01,000
然后在应该是前年的时候

3013
01:57:01,000 --> 01:57:03,000
有这样一篇报道

3014
01:57:03,000 --> 01:57:06,000
就是他们请到了 FH Gamma

3015
01:57:06,000 --> 01:57:08,000
Richard Helm

3016
01:57:08,000 --> 01:57:09,000
还有 Ralph Johnson

3017
01:57:09,000 --> 01:57:10,000
就是四人帮里面三个人

3018
01:57:10,000 --> 01:57:14,000
来在这本书出版了 15 年之后

3019
01:57:14,000 --> 01:57:20,000
重新讨论设计模式的利与弊

3020
01:57:20,000 --> 01:57:22,000
大概是名意思

3021
01:57:22,000 --> 01:57:23,000
有这样一篇报道

3022
01:57:23,000 --> 01:57:24,000
反思会是吧

3023
01:57:25,000 --> 01:57:26,000
嗯

3024
01:57:26,000 --> 01:57:27,000
反思会吧

3025
01:57:28,000 --> 01:57:29,000
算吧

3026
01:57:29,000 --> 01:57:30,000
算是一个对

3027
01:57:30,000 --> 01:57:31,000
算是一个对

3028
01:57:31,000 --> 01:57:33,000
老兵俱乐部的这种感觉

3029
01:57:35,000 --> 01:57:37,000
然后在那边

3030
01:57:37,000 --> 01:57:39,000
在这个访谈里面有这样一句话说

3031
01:57:39,000 --> 01:57:40,000
那边没有这样一句话说

3032
01:57:40,000 --> 01:57:41,000
啊

3033
01:57:41,000 --> 01:57:42,000
啊

3034
01:57:42,000 --> 01:57:43,000
高 level

3035
01:57:43,000 --> 01:57:45,000
vocabulary

3036
01:57:45,000 --> 01:57:49,000
simplifies communication between software practitioners

3037
01:57:49,000 --> 01:57:51,000
and enables

3038
01:57:51,000 --> 01:57:54,000
concise description of higher level concepts

3039
01:57:55,000 --> 01:57:58,000
我觉得这也是设计模式比较重要的一点

3040
01:57:59,000 --> 01:58:01,000
就是有了设计模式之后

3041
01:58:01,000 --> 01:58:04,000
你可以用很短的句子

3042
01:58:05,000 --> 01:58:08,000
跟别人交流一些比较浓缩的概念

3043
01:58:08,000 --> 01:58:09,000
比如说

3044
01:58:09,000 --> 01:58:10,000
啊

3045
01:58:10,000 --> 01:58:11,000
你不用跟别人说啊

3046
01:58:11,000 --> 01:58:12,000
我在这里想到一个方法

3047
01:58:12,000 --> 01:58:13,000
啊

3048
01:58:13,000 --> 01:58:16,000
这个方法的作用就是根据

3049
01:58:16,000 --> 01:58:21,000
实际的类型需求来生产出不同类型的

3050
01:58:21,000 --> 01:58:22,000
啊

3051
01:58:22,000 --> 01:58:23,000
啊

3052
01:58:23,000 --> 01:58:24,000
object

3053
01:58:24,000 --> 01:58:25,000
你可以直接跟他说这边是一个

3054
01:58:25,000 --> 01:58:26,000
啊

3055
01:58:26,000 --> 01:58:27,000
factory

3056
01:58:27,000 --> 01:58:28,000
工厂

3057
01:58:28,000 --> 01:58:29,000
工厂

3058
01:58:29,000 --> 01:58:30,000
工厂

3059
01:58:30,000 --> 01:58:31,000
工厂方法

3060
01:58:31,000 --> 01:58:32,000
这里是一个工厂方法

3061
01:58:32,000 --> 01:58:33,000
然后

3062
01:58:33,000 --> 01:58:34,000
呃

3063
01:58:34,000 --> 01:58:36,000
你甚至可以说这里是一个

3064
01:58:36,000 --> 01:58:37,000
这是一个

3065
01:58:37,000 --> 01:58:38,000
那个叫 meta factory

3066
01:58:38,000 --> 01:58:39,000
不对

3067
01:58:39,000 --> 01:58:40,000
叫什么

3068
01:58:40,000 --> 01:58:41,000
abstract factory

3069
01:58:41,000 --> 01:58:42,000
对

3070
01:58:42,000 --> 01:58:43,000
这是一个生产工厂的工厂

3071
01:58:43,000 --> 01:58:44,000
哈哈

3072
01:58:44,000 --> 01:58:46,000
应该用非常简单的句子表达

3073
01:58:46,000 --> 01:58:48,000
相对来说更加复杂的概念

3074
01:58:48,000 --> 01:58:49,000
嗯

3075
01:58:49,000 --> 01:58:50,000
然后这样

3076
01:58:50,000 --> 01:58:51,000
呃

3077
01:58:51,000 --> 01:58:52,000
这个从这个层面来说

3078
01:58:52,000 --> 01:58:53,000
你懂一些设理模式之后

3079
01:58:53,000 --> 01:58:54,000
你也可以

3080
01:58:54,000 --> 01:58:55,000
呃

3081
01:58:55,000 --> 01:58:56,000
更加

3082
01:58:57,000 --> 01:58:58,000
方便的去

3083
01:58:58,000 --> 01:58:59,000
表达

3084
01:58:59,000 --> 01:59:02,000
哪去理解别人通过一大片代码

3085
01:59:02,000 --> 01:59:03,000
或者是

3086
01:59:03,000 --> 01:59:06,000
一些很简单的句子想要表达的意思

3087
01:59:06,000 --> 01:59:07,000
嗯

3088
01:59:07,000 --> 01:59:08,000
对

3089
01:59:08,000 --> 01:59:10,000
然后这边呃

3090
01:59:10,000 --> 01:59:12,000
访谈里面还提到说就是呃

3091
01:59:12,000 --> 01:59:14,000
访谈的主持人说

3092
01:59:14,000 --> 01:59:15,000
访谈的主持人也就是那个

3093
01:59:15,000 --> 01:59:16,000
那个叫什么

3094
01:59:16,000 --> 01:59:17,000
但也不重要

3095
01:59:17,000 --> 01:59:19,000
主持人问是说呃

3096
01:59:19,000 --> 01:59:20,000
呃

3097
01:59:20,000 --> 01:59:22,000
在现在这个时代呃

3098
01:59:22,000 --> 01:59:23,000
呃

3099
01:59:23,000 --> 01:59:26,000
我们只需要写一行这个

3100
01:59:26,000 --> 01:59:28,000
php 代码就可以呃

3101
01:59:29,000 --> 01:59:32,000
做出一个网站来写着 hello world

3102
01:59:32,000 --> 01:59:33,000
the time is

3103
01:59:33,000 --> 01:59:34,000
呃

3104
01:59:34,000 --> 01:59:35,000
the time is dollar time

3105
01:59:35,000 --> 01:59:36,000
这样一个网站出来

3106
01:59:36,000 --> 01:59:37,000
嗯

3107
01:59:37,000 --> 01:59:39,000
那么在这样一个时代里面呃

3108
01:59:39,000 --> 01:59:40,000
呃

3109
01:59:40,000 --> 01:59:41,000
摄像是 MV 呢

3110
01:59:41,000 --> 01:59:42,000
呃

3111
01:59:42,000 --> 01:59:43,000
呃

3112
01:59:43,000 --> 01:59:44,000
这个

3113
01:59:44,000 --> 01:59:45,000
这个

3114
01:59:45,000 --> 01:59:46,000
richard 说

3115
01:59:46,000 --> 01:59:47,000
嗯

3116
01:59:47,000 --> 01:59:49,000
i think there has been a

3117
01:59:49,000 --> 01:59:51,000
evolution level of sophistication

3118
01:59:51,000 --> 01:59:52,000
呃

3119
01:59:52,000 --> 01:59:53,000
也就是说在

3120
01:59:53,000 --> 01:59:55,000
复杂度的层级上面

3121
01:59:55,000 --> 01:59:57,000
在过去的这 15 年里面

3122
01:59:57,000 --> 02:00:00,000
软件有一个非常大的

3123
02:00:00,000 --> 02:00:01,000
嗯

3124
02:00:01,000 --> 02:00:02,000
进化

3125
02:00:02,000 --> 02:00:03,000
呃

3126
02:00:03,000 --> 02:00:04,000
呃

3127
02:00:04,000 --> 02:00:05,000
可以复用的软件

3128
02:00:05,000 --> 02:00:07,000
已经被移植到了比较

3129
02:00:07,000 --> 02:00:08,000
呃

3130
02:00:08,000 --> 02:00:09,000
呃

3131
02:00:09,000 --> 02:00:10,000
就是接近于底层的位置

3132
02:00:10,000 --> 02:00:11,000
比如说一个 toolkit

3133
02:00:11,000 --> 02:00:12,000
或者一个 framework

3134
02:00:12,000 --> 02:00:13,000
嗯

3135
02:00:13,000 --> 02:00:14,000
然后呃

3136
02:00:14,000 --> 02:00:15,000
呃

3137
02:00:15,000 --> 02:00:20,000
这个东西的设计应该更多的被 be left to the experts

3138
02:00:20,000 --> 02:00:24,000
也就是说现在大部分写出序的人都不是 experts

3139
02:00:24,000 --> 02:00:28,000
他们只是在沿用这些个组合一些

3140
02:00:28,000 --> 02:00:33,000
他们所做的工作只是把一些这个 framework 里面的东西组合起来

3141
02:00:33,000 --> 02:00:34,000
嗯

3142
02:00:34,000 --> 02:00:37,000
然后脱脱通空间写写业务逻辑然后就被用了

3143
02:00:37,000 --> 02:00:38,000
呃

3144
02:00:38,000 --> 02:00:39,000
呃

3145
02:00:39,000 --> 02:00:40,000
那么在这种情况之下

3146
02:00:40,000 --> 02:00:41,000
嗯

3147
02:00:41,000 --> 02:00:42,000
嗯

3148
02:00:42,000 --> 02:00:43,000
嗯

3149
02:00:43,000 --> 02:00:44,000
嗯

3150
02:00:44,000 --> 02:00:45,000
也就是说嗯

3151
02:00:45,000 --> 02:00:48,000
即便在这种情况之下

3152
02:00:48,000 --> 02:00:51,000
你虽然不直接参与一个框架或者是一个呃

3153
02:00:51,000 --> 02:00:52,000
呃

3154
02:00:52,000 --> 02:00:53,000
呃

3155
02:00:53,000 --> 02:00:54,000
呃

3156
02:00:54,000 --> 02:00:55,000
呃

3157
02:00:55,000 --> 02:00:56,000
呃

3158
02:00:56,000 --> 02:00:57,000
呃

3159
02:00:57,000 --> 02:00:58,000
呃

3160
02:00:58,000 --> 02:00:59,000
呃

3161
02:00:59,000 --> 02:01:00,000
呃

3162
02:01:00,000 --> 02:01:01,000
呃

3163
02:01:01,000 --> 02:01:02,000
呃

3164
02:01:02,000 --> 02:01:03,000
呃

3165
02:01:03,000 --> 02:01:04,000
呃

3166
02:01:04,000 --> 02:01:05,000
呃

3167
02:01:05,000 --> 02:01:06,000
呃

3168
02:01:06,000 --> 02:01:07,000
呃

3169
02:01:07,000 --> 02:01:08,000
呃

3170
02:01:08,000 --> 02:01:09,000
呃

3171
02:01:09,000 --> 02:01:10,000
呃

3172
02:01:10,000 --> 02:01:11,000
这些决定啊

3173
02:01:11,000 --> 02:01:14,000
这些决定也就是我们刚才的读者来信里面也提到了

3174
02:01:14,000 --> 02:01:16,000
在很大程度上它是一种重构

3175
02:01:16,000 --> 02:01:20,000
然后你在做重构的时候你就会发现呃

3176
02:01:20,000 --> 02:01:22,000
设定模式其实是有大用处的呃

3177
02:01:22,000 --> 02:01:23,000
呃

3178
02:01:23,000 --> 02:01:27,000
你在重构的时候你会去看到说呃

3179
02:01:27,000 --> 02:01:29,000
目前的这块代码呃

3180
02:01:29,000 --> 02:01:32,000
尤其是在比较敏捷的状况下写出来的代码

3181
02:01:32,000 --> 02:01:34,000
它内部可能存在一些什么样的问题

3182
02:01:34,000 --> 02:01:38,000
而设定模式则可以为你提供一些解决这些问题的问题

3183
02:01:38,000 --> 02:01:48,000
我觉得这也是设定模式即便在很多很多年之后我们大部分从业者都不是那么 expert 的情况下

3184
02:01:48,000 --> 02:01:51,000
仍有用的一个一个一个例子

3185
02:01:51,000 --> 02:01:52,000
嗯哼

3186
02:01:52,000 --> 02:01:53,000
没错

3187
02:01:53,000 --> 02:01:55,000
呃

3188
02:01:55,000 --> 02:01:56,000
呃

3189
02:01:56,000 --> 02:02:01,000
那节目的最后我们讲一个跟设计模式相关的它的蓝身兄弟

3190
02:02:01,000 --> 02:02:03,000
anti pattern

3191
02:02:03,000 --> 02:02:04,000
对

3192
02:02:04,000 --> 02:02:06,000
这叫这翻译成中文怎么翻

3193
02:02:06,000 --> 02:02:07,000
反模式

3194
02:02:07,000 --> 02:02:09,000
逆模式吧还是反模式

3195
02:02:09,000 --> 02:02:10,000
反模式

3196
02:02:10,000 --> 02:02:11,000
逆模式反模式

3197
02:02:11,000 --> 02:02:12,000
它是啥呢

3198
02:02:12,000 --> 02:02:13,000
对

3199
02:02:13,000 --> 02:02:16,000
anti pattern 就是那些所有呃

3200
02:02:16,000 --> 02:02:17,000
容易掉进的坑吧

3201
02:02:17,000 --> 02:02:18,000
我觉得可以这么说

3202
02:02:18,000 --> 02:02:20,000
就是有些

3203
02:02:20,000 --> 02:02:22,000
有些坑是呃

3204
02:02:22,000 --> 02:02:23,000
人人避开的

3205
02:02:23,000 --> 02:02:24,000
人人避开的

3206
02:02:24,000 --> 02:02:26,000
而有些坑是人人避开的

3207
02:02:26,000 --> 02:02:28,000
而有些坑是人人都会掉进去

3208
02:02:28,000 --> 02:02:29,000
嗯

3209
02:02:29,000 --> 02:02:30,000
我相信

3210
02:02:30,000 --> 02:02:31,000
anti pattern

3211
02:02:31,000 --> 02:02:33,000
我相信 anti pattern

3212
02:02:33,000 --> 02:02:35,000
的数量是要远远远远多于 design pattern

3213
02:02:35,000 --> 02:02:38,000
不知道这么这个这个假设是不是正确

3214
02:02:38,000 --> 02:02:39,000
嗯

3215
02:02:39,000 --> 02:02:40,000
至少你去搜

3216
02:02:40,000 --> 02:02:42,000
如果你去搜 anti pattern 的话

3217
02:02:42,000 --> 02:02:44,000
你可以找到一些汇总的页面

3218
02:02:44,000 --> 02:02:45,000
汇总的页面

3219
02:02:45,000 --> 02:02:47,000
这些页面上列出的那个 pattern

3220
02:02:47,000 --> 02:02:51,000
可能远远远远超于超过这个四人帮

3221
02:02:51,000 --> 02:02:55,000
这个四人帮的所以开始给出那 23 个比较好的 design pattern

3222
02:02:55,000 --> 02:02:56,000
嗯

3223
02:02:56,000 --> 02:02:57,000
嗯

3224
02:02:57,000 --> 02:02:59,000
举几个例子吧

3225
02:02:59,000 --> 02:03:00,000
第一个例子就是

3226
02:03:00,000 --> 02:03:02,000
我能想到的就是

3227
02:03:02,000 --> 02:03:03,000
God object

3228
02:03:03,000 --> 02:03:04,000
这是一个对

3229
02:03:04,000 --> 02:03:05,000
对

3230
02:03:05,000 --> 02:03:06,000
anti pattern 其实也是有名字的

3231
02:03:06,000 --> 02:03:07,000
嗯

3232
02:03:07,000 --> 02:03:08,000
我能想到的第一个就是

3233
02:03:08,000 --> 02:03:09,000
God object

3234
02:03:09,000 --> 02:03:10,000
嗯

3235
02:03:10,000 --> 02:03:12,000
我不知道各位有没有这样一个阶段

3236
02:03:12,000 --> 02:03:13,000
就是如果你写过很多程序的话

3237
02:03:13,000 --> 02:03:15,000
你的程序如果大了一个境界

3238
02:03:15,000 --> 02:03:16,000
你会

3239
02:03:16,000 --> 02:03:18,000
嗯

3240
02:03:18,000 --> 02:03:20,000
下意识的

3241
02:03:20,000 --> 02:03:22,000
把那些

3242
02:03:22,000 --> 02:03:24,000
不知道归类

3243
02:03:24,000 --> 02:03:25,000
哪

3244
02:03:25,000 --> 02:03:26,000
不知道归给谁的东西

3245
02:03:26,000 --> 02:03:28,000
归到同一个东西下面

3246
02:03:28,000 --> 02:03:29,000
嗯

3247
02:03:29,000 --> 02:03:33,000
最常见的就是你会写一个叫做 toolkit

3248
02:03:33,000 --> 02:03:35,000
或者是 utility

3249
02:03:35,000 --> 02:03:36,000
或者是

3250
02:03:36,000 --> 02:03:38,000
base

3251
02:03:38,000 --> 02:03:39,000
这样一个 object

3252
02:03:39,000 --> 02:03:40,000
然后里面放了一大堆

3253
02:03:40,000 --> 02:03:41,000
common 之类的

3254
02:03:41,000 --> 02:03:42,000
对

3255
02:03:42,000 --> 02:03:43,000
common 点

3256
02:03:43,000 --> 02:03:44,000
什么什么

3257
02:03:44,000 --> 02:03:45,000
一大堆根本就不知道

3258
02:03:45,000 --> 02:03:46,000
你不知道该往哪放的

3259
02:03:46,000 --> 02:03:47,000
可以全都放在那

3260
02:03:47,000 --> 02:03:49,000
比如说这个 utilities 里面可能有

3261
02:03:49,000 --> 02:03:50,000
啊

3262
02:03:50,000 --> 02:03:51,000
一个绘图函数

3263
02:03:51,000 --> 02:03:52,000
然后一个

3264
02:03:52,000 --> 02:03:53,000
一个打开文件的函数

3265
02:03:53,000 --> 02:03:54,000
对

3266
02:03:54,000 --> 02:03:55,000
呃

3267
02:03:55,000 --> 02:03:57,000
一个做网络通信的函数

3268
02:03:57,000 --> 02:03:58,000
然后一个

3269
02:03:58,000 --> 02:04:00,000
一个帮你存密码函数

3270
02:04:00,000 --> 02:04:01,000
然后或者是什么

3271
02:04:01,000 --> 02:04:02,000
一个帮你烧水的函数

3272
02:04:02,000 --> 02:04:03,000
全都放在里面

3273
02:04:03,000 --> 02:04:06,000
其实这就是一个非常非常知名的

3274
02:04:06,000 --> 02:04:07,000
antipattern

3275
02:04:07,000 --> 02:04:08,000
叫做 god object

3276
02:04:08,000 --> 02:04:10,000
就是这个 object 无所不能

3277
02:04:10,000 --> 02:04:11,000
全知全能

3278
02:04:11,000 --> 02:04:12,000
全知全能

3279
02:04:12,000 --> 02:04:14,000
有非常多的

3280
02:04:14,000 --> 02:04:15,000
对

3281
02:04:15,000 --> 02:04:16,000
其实这个 pattern 在

3282
02:04:16,000 --> 02:04:20,000
命令式编程里面也会出现

3283
02:04:20,000 --> 02:04:22,000
就是你如果你放了太多的全知变量的话

3284
02:04:22,000 --> 02:04:23,000
嗯

3285
02:04:23,000 --> 02:04:24,000
那其实也是一个比较

3286
02:04:24,000 --> 02:04:25,000
比较明显的

3287
02:04:25,000 --> 02:04:26,000
god object

3288
02:04:26,000 --> 02:04:28,000
呃

3289
02:04:28,000 --> 02:04:30,000
它违反了一个原则就是

3290
02:04:30,000 --> 02:04:33,000
你应该提供尽量清晰的接口

3291
02:04:33,000 --> 02:04:34,000
呃

3292
02:04:34,000 --> 02:04:35,000
呃

3293
02:04:35,000 --> 02:04:39,000
你应该尽量让每一个 object 的职额清晰化

3294
02:04:39,000 --> 02:04:43,000
但是在 god object 这里这一切都都被你坏了

3295
02:04:43,000 --> 02:04:46,000
就是你这个你会发现这个 god object 实际是无处不在

3296
02:04:46,000 --> 02:04:47,000
就是个大杂烩

3297
02:04:47,000 --> 02:04:48,000
对

3298
02:04:48,000 --> 02:04:49,000
然后你会发现呃

3299
02:04:49,000 --> 02:04:51,000
重构变得非常艰难

3300
02:04:51,000 --> 02:04:53,000
因为你根本就不知道哪些业务逻辑

3301
02:04:53,000 --> 02:04:56,000
可以从这个 object 里面提取出来

3302
02:04:56,000 --> 02:04:57,000
嗯

3303
02:04:57,000 --> 02:04:58,000
这是一个比较

3304
02:04:58,000 --> 02:05:00,000
这是一个我能想到的第一个比较著名的

3305
02:05:00,000 --> 02:05:01,000
antipattern

3306
02:05:01,000 --> 02:05:02,000
嗯

3307
02:05:02,000 --> 02:05:03,000
嗯

3308
02:05:03,000 --> 02:05:04,000
嗯

3309
02:05:04,000 --> 02:05:06,000
还有什么

3310
02:05:08,000 --> 02:05:09,000
golden hammer

3311
02:05:09,000 --> 02:05:12,000
对 golden hammer 是一个比较也是一个比较啊

3312
02:05:12,000 --> 02:05:14,000
知名的 antipattern

3313
02:05:14,000 --> 02:05:15,000
就是

3314
02:05:15,000 --> 02:05:19,000
有这样的俗话说我有一把锤子

3315
02:05:19,000 --> 02:05:21,000
而我我看什么都像钉子

3316
02:05:21,000 --> 02:05:22,000
嗯

3317
02:05:23,000 --> 02:05:26,000
这在如果要把它总结成一个 pattern 的话

3318
02:05:26,000 --> 02:05:27,000
那就是嗯

3319
02:05:27,000 --> 02:05:28,000
你会了一门语言

3320
02:05:28,000 --> 02:05:29,000
嗯

3321
02:05:29,000 --> 02:05:30,000
或者是你掌握了一个 cool

3322
02:05:30,000 --> 02:05:32,000
你会觉得说

3323
02:05:32,000 --> 02:05:35,000
甚至不一定是一个个人

3324
02:05:35,000 --> 02:05:38,000
可能在一个团队上也会体现出这样一种倾向来

3325
02:05:38,000 --> 02:05:40,000
就是说我要用这个工具解决一切的问题

3326
02:05:41,000 --> 02:05:43,000
所有的问题都应该转化到这个工具上来解决

3327
02:05:43,000 --> 02:05:45,000
或者说所有的

3328
02:05:45,000 --> 02:05:47,000
嗯

3329
02:05:47,000 --> 02:05:48,000
嗯

3330
02:05:48,000 --> 02:05:51,000
你你你自己的 oop 本身就是一个 golden hammer 是吧

3331
02:05:51,000 --> 02:05:52,000
对啊

3332
02:05:52,000 --> 02:05:53,000
也有道理

3333
02:05:53,000 --> 02:05:57,000
你其实你现在看很多那种都上总是在哪里

3334
02:05:57,000 --> 02:05:58,000
直播上写过这么一段话吗

3335
02:05:58,000 --> 02:06:03,000
就是说为什么说你觉得 oop 的这条路已经走得太远了

3336
02:06:03,000 --> 02:06:04,000
你看到这种语句

3337
02:06:04,000 --> 02:06:08,000
叫做 executor.execute

3338
02:06:08,000 --> 02:06:09,000
呃

3339
02:06:09,000 --> 02:06:10,000
快号

3340
02:06:10,000 --> 02:06:12,000
开快号关

3341
02:06:12,000 --> 02:06:13,000
对

3342
02:06:13,000 --> 02:06:14,000
对

3343
02:06:14,000 --> 02:06:15,000
是你那个

3344
02:06:15,000 --> 02:06:16,000
呃

3345
02:06:16,000 --> 02:06:18,000
其实我能想到的就是

3346
02:06:18,000 --> 02:06:19,000
有些面试题

3347
02:06:19,000 --> 02:06:20,000
比如说 feesbus

3348
02:06:20,000 --> 02:06:21,000
呃

3349
02:06:21,000 --> 02:06:24,000
这样面试题呃

3350
02:06:24,000 --> 02:06:28,000
你明明写一个函数就可以解决的问题

3351
02:06:28,000 --> 02:06:29,000
是你不用写函数

3352
02:06:29,000 --> 02:06:31,000
你写一个 follow 就可以解决的问题

3353
02:06:31,000 --> 02:06:33,000
有些人要先

3354
02:06:33,000 --> 02:06:34,000
呃

3355
02:06:34,000 --> 02:06:35,000
因为他只学过面对

3356
02:06:35,000 --> 02:06:37,000
他因为他只学过面相对象

3357
02:06:37,000 --> 02:06:39,000
所以他情不自信的一上来要写个泪

3358
02:06:39,000 --> 02:06:41,000
不这个也是 java 害的

3359
02:06:41,000 --> 02:06:43,000
因为 java 没有不是泪的东西

3360
02:06:43,000 --> 02:06:45,000
你没有泪没有没有办法直行的

3361
02:06:45,000 --> 02:06:46,000
对

3362
02:06:46,000 --> 02:06:49,000
java 连一个程序的入口点都要放在一个泪里面

3363
02:06:49,000 --> 02:06:50,000
这是何苦

3364
02:06:50,000 --> 02:06:51,000
嗯

3365
02:06:51,000 --> 02:06:52,000
程序为何

3366
02:06:52,000 --> 02:06:53,000
程序何苦美单程序

3367
02:06:53,000 --> 02:06:55,000
哈哈哈哈

3368
02:06:55,000 --> 02:06:56,000
对

3369
02:06:56,000 --> 02:06:57,000
呃

3370
02:06:57,000 --> 02:06:58,000
呃

3371
02:06:58,000 --> 02:07:01,000
以 goltenhammer 相对的也有一个 silver bullet

3372
02:07:01,000 --> 02:07:02,000
这也是一个

3373
02:07:02,000 --> 02:07:03,000
银蛋

3374
02:07:03,000 --> 02:07:04,000
对

3375
02:07:04,000 --> 02:07:05,000
其实 silver bullet

3376
02:07:05,000 --> 02:07:07,000
后来我查了一下它是有一个来历的

3377
02:07:07,000 --> 02:07:09,000
只不过这个来历是如此的久远

3378
02:07:09,000 --> 02:07:11,000
以至于我们新生代的这个

3379
02:07:11,000 --> 02:07:13,000
我们已经是步入中远了

3380
02:07:13,000 --> 02:07:14,000
但我们

3381
02:07:14,000 --> 02:07:16,000
在此中就可以自豪的说一声

3382
02:07:16,000 --> 02:07:20,000
我们新生代的程序员不知道这个梗的来历是挺有可能的

3383
02:07:20,000 --> 02:07:22,000
就是在 30 年代

3384
02:07:22,000 --> 02:07:24,000
呃

3385
02:07:24,000 --> 02:07:26,000
有有这样一些故事讲述一个叫做

3386
02:07:26,000 --> 02:07:28,000
The long ranger

3387
02:07:28,000 --> 02:07:30,000
呃

3388
02:07:30,000 --> 02:07:33,000
的西部

3389
02:07:33,000 --> 02:07:34,000
牛仔

3390
02:07:34,000 --> 02:07:35,000
不

3391
02:07:35,000 --> 02:07:36,000
他不是牛仔

3392
02:07:36,000 --> 02:07:38,000
他应该是西部的一个检察官

3393
02:07:38,000 --> 02:07:42,000
后来变成了一个匡扶正义的侠客的这么一个形象

3394
02:07:42,000 --> 02:07:44,000
他有把枪

3395
02:07:44,000 --> 02:07:46,000
呃

3396
02:07:46,000 --> 02:07:48,000
呃

3397
02:07:48,000 --> 02:07:49,000
呃

3398
02:07:49,000 --> 02:07:50,000
呃

3399
02:07:50,000 --> 02:07:51,000
呃

3400
02:07:51,000 --> 02:07:52,000
呃

3401
02:07:52,000 --> 02:07:53,000
呃

3402
02:07:53,000 --> 02:07:54,000
呃

3403
02:07:54,000 --> 02:07:55,000
呃

3404
02:07:55,000 --> 02:07:56,000
呃

3405
02:07:56,000 --> 02:07:57,000
游骑兵嘛应该说

3406
02:07:57,000 --> 02:07:58,000
啊

3407
02:07:58,000 --> 02:07:59,000
对对对对

3408
02:07:59,000 --> 02:08:00,000
但这不重要

3409
02:08:00,000 --> 02:08:06,000
但反正他这个形象最大的绝杀就是他有一个他有把很长的枪

3410
02:08:06,000 --> 02:08:08,000
然后一枪可以射出 siver bullet

3411
02:08:08,000 --> 02:08:10,000
siver bullet

3412
02:08:10,000 --> 02:08:12,000
siver bullet 每一次击中什么东西都是

3413
02:08:12,000 --> 02:08:14,000
首先他是个神枪手

3414
02:08:14,000 --> 02:08:17,000
然后他可以做到比如说这个人快被吊死了

3415
02:08:17,000 --> 02:08:22,000
他的两三百米开外打一颗银弹打个 siver bullet

3416
02:08:22,000 --> 02:08:26,000
把那个人的把这个人把吊这个人的绳子射断

3417
02:08:26,000 --> 02:08:30,000
然后或者是呃

3418
02:08:30,000 --> 02:08:32,000
一枪打爆一个锁

3419
02:08:32,000 --> 02:08:34,000
然后这个锁偏桥就可以弹开

3420
02:08:34,000 --> 02:08:38,000
然后可以让门打开这样这样一种呃

3421
02:08:38,000 --> 02:08:41,000
呃非常奇迹引巧的呃技术啊

3422
02:08:41,000 --> 02:08:47,000
嗯好像最近应该是前年这个这个的 long ranger 这个故事还重新被搬上荧幕

3423
02:08:47,000 --> 02:08:49,000
而且搬上那个

3424
02:08:49,000 --> 02:08:50,000
对啊

3425
02:08:50,000 --> 02:08:51,000
Johnny Depp

3426
02:08:51,000 --> 02:08:52,000
对

3427
02:08:52,000 --> 02:08:56,000
对这个这个 siver bullet 实际上来自于这样一个稿

3428
02:08:56,000 --> 02:09:02,000
然后 siver bullet 的特点就是相信有这样一种技术能够可以呃

3429
02:09:02,000 --> 02:09:04,000
呃一劳永逸的解决

3430
02:09:04,000 --> 02:09:05,000
所以我

3431
02:09:05,000 --> 02:09:09,000
一些对无视其呃呃

3432
02:09:09,000 --> 02:09:12,000
无视其边界条件的难题

3433
02:09:12,000 --> 02:09:13,000
嗯嗯

3434
02:09:13,000 --> 02:09:14,000
嗯

3435
02:09:14,000 --> 02:09:18,000
然后这个 siver bullet 也是通过人乐神话这本书被啊

3436
02:09:18,000 --> 02:09:19,000
发言光大

3437
02:09:19,000 --> 02:09:20,000
以至于现在很多

3438
02:09:20,000 --> 02:09:23,000
就相信他本成员都应该听过这个名词

3439
02:09:23,000 --> 02:09:25,000
但是不太清楚他是怎么排的

3440
02:09:25,000 --> 02:09:30,000
但实际上 siver bullet 也是一个比较比较著名的 anti pattern

3441
02:09:30,000 --> 02:09:31,000
嗯

3442
02:09:31,000 --> 02:09:33,000
嗯

3443
02:09:33,000 --> 02:09:35,000
这个翻译成中文应该叫什么来的

3444
02:09:35,000 --> 02:09:37,000
万金油

3445
02:09:37,000 --> 02:09:38,000
对

3446
02:09:38,000 --> 02:09:39,000
siver bullet

3447
02:09:39,000 --> 02:09:40,000
万金油模式

3448
02:09:40,000 --> 02:09:41,000
嗯

3449
02:09:41,000 --> 02:09:43,000
这 goltenhamer 其实也是一个万金油

3450
02:09:43,000 --> 02:09:44,000
也有点万金油的意思

3451
02:09:44,000 --> 02:09:46,000
但是 siver bullet

3452
02:09:46,000 --> 02:09:47,000
siver bullet 强调的还是

3453
02:09:47,000 --> 02:09:49,000
强调的是这种

3454
02:09:49,000 --> 02:09:51,000
这种解决方案的魔法性

3455
02:09:51,000 --> 02:09:57,000
就是这个解决方案真的是要到病除一劳永逸

3456
02:09:57,000 --> 02:10:00,000
而 goltenhamer 则更强调的是这样一种方法

3457
02:10:00,000 --> 02:10:02,000
这样某一个方法的普世性

3458
02:10:02,000 --> 02:10:04,000
就是拿它来干什么都可以

3459
02:10:04,000 --> 02:10:07,000
所以应该是 goltenhamer 等价于万金油

3460
02:10:07,000 --> 02:10:10,000
然后 siver bullet 是叫什么来的

3461
02:10:10,000 --> 02:10:11,000
嗯

3462
02:10:11,000 --> 02:10:12,000
灵丹妙药是不是

3463
02:10:12,000 --> 02:10:13,000
对灵丹妙药

3464
02:10:13,000 --> 02:10:14,000
反应不错

3465
02:10:14,000 --> 02:10:16,000
以后我们可以试着吧

3466
02:10:16,000 --> 02:10:18,000
所有的 anti pattern 都给一个本土化的中文名

3467
02:10:18,000 --> 02:10:21,000
哈哈哈哈

3468
02:10:21,000 --> 02:10:23,000
读起来也是很酸爽的

3469
02:10:23,000 --> 02:10:24,000
哈哈哈哈

3470
02:10:24,000 --> 02:10:31,000
感谢你收听本期 IPN Podcast 的网络旗下的 IT 技术主题娱乐节目内容很慌

3471
02:10:31,000 --> 02:10:32,000
我们号称 hardcore

3472
02:10:32,000 --> 02:10:33,000
但是也没有干货

3473
02:10:33,000 --> 02:10:34,000
想念的人听

3474
02:10:34,000 --> 02:10:35,000
不想念的人就别听

3475
02:10:35,000 --> 02:10:37,000
您可以为本节目捐款

3476
02:10:37,000 --> 02:10:39,000
捐款的地址是 ipn.li

3477
02:10:39,000 --> 02:10:41,000
slashkernelpanicslashdonate

3478
02:10:41,000 --> 02:10:42,000
捐款结合随意

3479
02:10:42,000 --> 02:10:44,000
只要是能为 8 整出的正常数就可以

3480
02:10:44,000 --> 02:10:46,000
捐款不会为你带来什么

3481
02:10:46,000 --> 02:10:47,000
不捐也不会让你吃什么

3482
02:10:47,000 --> 02:10:49,000
我们的口号是 no hot feelings

3483
02:10:49,000 --> 02:10:50,000
如果你有了什么反馈

3484
02:10:50,000 --> 02:10:54,000
欢迎你发邮件到 kernelpanicatipn.li

3485
02:10:54,000 --> 02:10:59,000
如果写的足够长的话我们一定会念出来

3486
02:10:59,000 --> 02:11:04,000
同时也欢迎你收听 IPN 旗下的其他几档节目

3487
02:11:04,000 --> 02:11:06,000
ID 公论

3488
02:11:06,000 --> 02:11:07,000
未知到太医来了

3489
02:11:07,000 --> 02:11:08,000
流行通信

3490
02:11:08,000 --> 02:11:09,000
high story

3491
02:11:09,000 --> 02:11:10,000
以及应影像

3492
02:11:10,000 --> 02:11:12,000
我们下期节目再会

3493
02:11:12,000 --> 02:11:15,000
各位听众大家好

3494
02:11:15,000 --> 02:11:16,000
我是 Nin

3495
02:11:16,000 --> 02:11:17,000
主播无套

3496
02:11:17,000 --> 02:11:21,000
因为得了炎炎

3497
02:11:21,000 --> 02:11:24,000
所以上一期的节目录得非常痛苦

3498
02:11:24,000 --> 02:11:25,000
才录完节目之后

3499
02:11:25,000 --> 02:11:27,000
我现在仿然变成这个样子了

3500
02:11:27,000 --> 02:11:32,000
我也不知道自己要为什么录这段音

3501
02:11:32,000 --> 02:11:33,000
只是想要

3502
02:11:33,000 --> 02:11:36,000
因为我好像过去的时间里面没有一次

3503
02:11:36,000 --> 02:11:38,000
像是可以烂成这个样子

3504
02:11:38,000 --> 02:11:39,000
所以呢

3505
02:11:40,000 --> 02:11:41,000
那一定我不知道去的

3506
02:11:41,000 --> 02:11:41,000
aligned

