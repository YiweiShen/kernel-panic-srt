1
00:00:00,000 --> 00:00:21,000
大家好,今天是 7 月 25 号

2
00:00:21,000 --> 00:00:25,000
现在您听的是自谈自唱的第 52 期

3
00:00:25,000 --> 00:00:28,000
同时也是内核共荒的第 48 期

4
00:00:28,000 --> 00:00:34,000
这也是我们自谈自唱和内核恐慌创台的自谈自创节目的第 5 期

5
00:00:34,000 --> 00:00:39,000
我们自谈自唱是全球首家用华语制作的字体盘译主题播客节目

6
00:00:39,000 --> 00:00:41,000
我是主播文川西班动音局 Eric

7
00:00:41,000 --> 00:00:44,000
我是主播黄浦江铭新阵语钱真语

8
00:00:44,000 --> 00:00:50,000
内核恐慌是 IPM Podcast 网络旗下的 IT 技术主题娱乐节目

9
00:00:50,000 --> 00:00:52,000
我们号称 Hardcore 但是也没有干货

10
00:00:52,000 --> 00:00:54,000
想听的人听不想听的人就别听

11
00:00:54,000 --> 00:00:57,000
我是主播吴涛

12
00:00:57,000 --> 00:00:58,000
我是 Rail

13
00:00:58,000 --> 00:01:02,000
你说我们这个节目创台都已经创了第 5 期了

14
00:01:02,000 --> 00:01:07,000
等到上次 5 月底才第一次四个人一起在同一个空间见面是吧

15
00:01:07,000 --> 00:01:08,000
历史性的会晤

16
00:01:08,000 --> 00:01:10,000
对我们四个人没有合照

17
00:01:10,000 --> 00:01:13,000
那天活动来了好多播客主播吧

18
00:01:13,000 --> 00:01:16,000
数来应该有差不多小 10 个

19
00:01:16,000 --> 00:01:20,000
你们后来就背着我们就直接去喝酒了

20
00:01:20,000 --> 00:01:22,000
你们不是也去喝酒了吗

21
00:01:22,000 --> 00:01:24,000
你们不是要去打扫场地吗

22
00:01:24,000 --> 00:01:25,000
那没有办法呀

23
00:01:25,000 --> 00:01:27,000
对啊

24
00:01:27,000 --> 00:01:29,000
虽然说是 TIB 10 周年活动节目

25
00:01:29,000 --> 00:01:36,000
搞得好像是变成国内 IPM 和各台那个电台主播的一个小聚会了

26
00:01:36,000 --> 00:01:37,000
小众播客网络

27
00:01:37,000 --> 00:01:42,000
而且其实线下我跟 Eric 在东京见过

28
00:01:42,000 --> 00:01:45,000
然后我跟 Rail 见过很久了

29
00:01:45,000 --> 00:01:50,000
Eric 跟蒸宇之前也在上海见过很多次

30
00:01:50,000 --> 00:01:51,000
对

31
00:01:51,000 --> 00:01:52,000
对我跟 Rail 也见过一次

32
00:01:52,000 --> 00:01:56,000
然后我跟 Rail 在深圳也见过一两次

33
00:01:56,000 --> 00:01:57,000
两次

34
00:01:57,000 --> 00:01:58,000
对

35
00:01:58,000 --> 00:02:02,000
但真正所有人在一起见这是第一次

36
00:02:02,000 --> 00:02:04,000
还挺难得的

37
00:02:04,000 --> 00:02:08,000
我们可以在那个 show notes 发一下这个上次活动的剧

38
00:02:08,000 --> 00:02:11,000
剧本就是什么四个人都在的照片应该有吧

39
00:02:11,000 --> 00:02:11,000
没有

40
00:02:11,000 --> 00:02:14,000
好像咱们四个没有合影

41
00:02:14,000 --> 00:02:14,000
对

42
00:02:14,000 --> 00:02:16,000
Oh my god

43
00:02:16,000 --> 00:02:17,000
这么惨

44
00:02:17,000 --> 00:02:18,000
把吴涛披上去

45
00:02:18,000 --> 00:02:20,000
不是

46
00:02:20,000 --> 00:02:25,000
那个 Rail 也没有跟其他三个人合过影

47
00:02:25,000 --> 00:02:27,000
就 Rail 也没有跟你们两个合过影

48
00:02:27,000 --> 00:02:28,000
好像有

49
00:02:28,000 --> 00:02:28,000
总的说好像有

50
00:02:28,000 --> 00:02:29,000
肯定有照片

51
00:02:29,000 --> 00:02:31,000
同时有我和 Eric 和 Rail 的

52
00:02:31,000 --> 00:02:33,000
我记得有一张

53
00:02:33,000 --> 00:02:35,000
有一张有各种主播在一起

54
00:02:35,000 --> 00:02:39,000
有一张是你们两个在那个内间

55
00:02:39,000 --> 00:02:42,000
那个是一个

56
00:02:42,000 --> 00:02:43,000
然后 Rail 站在外面的照片

57
00:02:43,000 --> 00:02:44,000
对

58
00:02:44,000 --> 00:02:44,000
对

59
00:02:44,000 --> 00:02:45,000
这个也有

60
00:02:45,000 --> 00:02:47,000
然后活动结束的时候

61
00:02:47,000 --> 00:02:50,000
我跟 Eric 和和蒸宇都有合影

62
00:02:50,000 --> 00:02:52,000
但是那个时候吴涛不知道去哪去了

63
00:02:52,000 --> 00:02:52,000
我就喝酒

64
00:02:52,000 --> 00:02:53,000
对啊

65
00:02:53,000 --> 00:02:53,000
就泡妹子了

66
00:02:53,000 --> 00:02:55,000
吴涛喝花酒

67
00:02:55,000 --> 00:02:55,000
泡屁

68
00:02:55,000 --> 00:02:57,000
好

69
00:02:57,000 --> 00:03:02,000
首先呢

70
00:03:02,000 --> 00:03:03,000
跟大家讲一讲

71
00:03:03,000 --> 00:03:05,000
其实这也不算广告了

72
00:03:05,000 --> 00:03:06,000
就我们自己

73
00:03:06,000 --> 00:03:07,000
Type School

74
00:03:07,000 --> 00:03:08,000
七月份的课程已经结束了

75
00:03:08,000 --> 00:03:12,000
七月份这个西文的字体设计课程

76
00:03:12,000 --> 00:03:13,000
大家应该

77
00:03:13,000 --> 00:03:14,000
虽然很累啊

78
00:03:14,000 --> 00:03:15,000
但很辛苦

79
00:03:15,000 --> 00:03:17,000
但是估计大家收获也蛮大的

80
00:03:17,000 --> 00:03:19,000
一共有几天了

81
00:03:19,000 --> 00:03:21,000
两个礼拜啊

82
00:03:21,000 --> 00:03:23,000
我也过去跟去

83
00:03:23,000 --> 00:03:27,000
就和大家就凑了一会热闹啊

84
00:03:27,000 --> 00:03:31,000
看我们的格尔格老师给大家讲 Glyphs

85
00:03:31,000 --> 00:03:32,000
挺有意思的

86
00:03:32,000 --> 00:03:33,000
对了

87
00:03:33,000 --> 00:03:34,000
我一直很好奇

88
00:03:34,000 --> 00:03:36,000
Galke 他是一个字体设计师吗

89
00:03:36,000 --> 00:03:37,000
对

90
00:03:37,000 --> 00:03:38,000
他自己设计师

91
00:03:38,000 --> 00:03:40,000
他自己设计字体

92
00:03:40,000 --> 00:03:43,000
然后但是他有一些计算机开发的基础

93
00:03:43,000 --> 00:03:45,000
然后他做出了 Glyphs

94
00:03:45,000 --> 00:03:46,000
几乎现在就

95
00:03:46,000 --> 00:03:48,000
几乎全职都在做 Glyphs

96
00:03:48,000 --> 00:03:49,000
这个软件掉了

97
00:03:49,000 --> 00:03:49,000
变成

98
00:03:49,000 --> 00:03:53,000
所以他应该是一个计算机科学出身的人吧

99
00:03:53,000 --> 00:03:54,000
就是他是一个

100
00:03:54,000 --> 00:03:56,000
他是设计师出身

101
00:03:56,000 --> 00:03:58,000
那他既然能写这么复杂的

102
00:03:58,000 --> 00:04:00,000
我觉得 Glyphs 已经是一个非常复杂的软件

103
00:04:00,000 --> 00:04:01,000
对

104
00:04:01,000 --> 00:04:04,000
非常令人惊讶

105
00:04:04,000 --> 00:04:05,000
对

106
00:04:05,000 --> 00:04:06,000
好吧

107
00:04:06,000 --> 00:04:08,000
设计器需要这样的人才

108
00:04:08,000 --> 00:04:09,000
所以呢

109
00:04:09,000 --> 00:04:12,000
我也希望有更多的设计师来听我们的字谈字串

110
00:04:12,000 --> 00:04:13,000
好吧

111
00:04:13,000 --> 00:04:17,000
然后就有很多朋友问

112
00:04:17,000 --> 00:04:17,000
就是

113
00:04:17,000 --> 00:04:19,000
因为这次是讲西文

114
00:04:19,000 --> 00:04:22,000
那有没有学中文的字体设计课程

115
00:04:22,000 --> 00:04:23,000
然后其实呢

116
00:04:23,000 --> 00:04:26,000
就是可能大家在微信上面也看到消息了

117
00:04:26,000 --> 00:04:28,000
我们在 8 月 4 号到 9 号呢

118
00:04:28,000 --> 00:04:30,000
会有这样一个课程

119
00:04:30,000 --> 00:04:31,000
叫 Type School 的中文字体设计课

120
00:04:31,000 --> 00:04:32,000
而且这次呢

121
00:04:32,000 --> 00:04:33,000
不是在上海

122
00:04:33,000 --> 00:04:34,000
是在北京

123
00:04:34,000 --> 00:04:35,000
嗯

124
00:04:35,000 --> 00:04:36,000
然后我们请到了老师呢

125
00:04:36,000 --> 00:04:39,000
就有翻证字库的思维设计师

126
00:04:39,000 --> 00:04:41,000
包括像球影

127
00:04:41,000 --> 00:04:46,000
球影先生这样经验非常丰富的字体设计过很多中文字体设计师

128
00:04:46,000 --> 00:04:50,000
可能大家都最知道他最著名的字体就是那个油黑嘛

129
00:04:50,000 --> 00:04:51,000
对

130
00:04:51,000 --> 00:04:54,000
然后 Type School 呢就会教大家如何实现字库

131
00:04:54,000 --> 00:04:56,000
然后因为是做中文

132
00:04:56,000 --> 00:04:59,000
所以呢可能工程比较浩大

133
00:04:59,000 --> 00:05:00,000
好说从 12 个字

134
00:05:00,000 --> 00:05:01,000
嗯

135
00:05:01,000 --> 00:05:01,000
嗯

136
00:05:01,000 --> 00:05:06,000
扩展到 50 个字到 50050005 万对吧

137
00:05:06,000 --> 00:05:09,000
平时大家设计中文就中文的话是没有头绪吗

138
00:05:09,000 --> 00:05:11,000
不知道怎么用什么方法做

139
00:05:11,000 --> 00:05:13,000
然后做要做多少次

140
00:05:13,000 --> 00:05:14,000
然后一旦多的话呢

141
00:05:14,000 --> 00:05:15,000
对吧

142
00:05:15,000 --> 00:05:17,000
这个怎么提高效率

143
00:05:17,000 --> 00:05:18,000
然后呢

144
00:05:18,000 --> 00:05:20,000
尽早提

145
00:05:20,000 --> 00:05:21,000
嗯

146
00:05:21,000 --> 00:05:22,000
发现问题

147
00:05:22,000 --> 00:05:23,000
对啊

148
00:05:23,000 --> 00:05:24,000
比如说大小不一样啊

149
00:05:24,000 --> 00:05:25,000
怎么处理啊

150
00:05:25,000 --> 00:05:28,000
这些我们都会具体的在 Type School 请老师呢

151
00:05:28,000 --> 00:05:30,000
给大家呃

152
00:05:30,000 --> 00:05:31,000
介绍

153
00:05:31,000 --> 00:05:34,000
对不过五天时间其实做 12 个字也就差不多

154
00:05:34,000 --> 00:05:35,000
我们这次呢

155
00:05:35,000 --> 00:05:37,000
有有一个很好的机会是

156
00:05:37,000 --> 00:05:38,000
优系的学员啊

157
00:05:38,000 --> 00:05:40,000
可以和方正签约

158
00:05:40,000 --> 00:05:40,000
啊

159
00:05:40,000 --> 00:05:44,000
只要你先做几做好几百个字

160
00:05:44,000 --> 00:05:45,000
剩下的成千上万字啊

161
00:05:45,000 --> 00:05:47,000
方正会把你做

162
00:05:47,000 --> 00:05:48,000
啊

163
00:05:48,000 --> 00:05:52,000
对这个其实就跟之前的这个字体竞赛很相似啊

164
00:05:52,000 --> 00:05:55,000
就是你提交一份样字的作品

165
00:05:55,000 --> 00:05:56,000
然后如果啊

166
00:05:56,000 --> 00:05:58,000
自体公司觉得非常合适

167
00:05:58,000 --> 00:05:59,000
有商业化的价值的话

168
00:05:59,000 --> 00:06:01,000
他会与你签约

169
00:06:01,000 --> 00:06:03,000
然后帮你把它做成一个真正意义这样的字库

170
00:06:03,000 --> 00:06:04,000
嗯

171
00:06:04,000 --> 00:06:06,000
当然在这样的课程里面呢

172
00:06:06,000 --> 00:06:08,000
大家也会可以接触到 Grips

173
00:06:08,000 --> 00:06:10,000
这样这样一个什么字体神迹啊

174
00:06:10,000 --> 00:06:11,000
呃

175
00:06:11,000 --> 00:06:13,000
其实而且这次呢

176
00:06:13,000 --> 00:06:15,000
我们 Grips 开发者

177
00:06:15,000 --> 00:06:15,000
呃

178
00:06:15,000 --> 00:06:18,000
而哥哥哥来中国人给大家

179
00:06:18,000 --> 00:06:20,000
他切身赶到了啊

180
00:06:20,000 --> 00:06:23,000
做方块汉字的一些特殊的要求

181
00:06:23,000 --> 00:06:25,000
那我们有很多新的功能

182
00:06:25,000 --> 00:06:27,000
也会加到这个 Gryphs 里面

183
00:06:27,000 --> 00:06:28,000
大家可以试用一下

184
00:06:28,000 --> 00:06:29,000
这次呢

185
00:06:29,000 --> 00:06:33,000
我们还邀请到了德国的 Meta Design

186
00:06:33,000 --> 00:06:35,000
那 Meta Design 的

187
00:06:35,000 --> 00:06:37,000
德国的他们那边的

188
00:06:37,000 --> 00:06:39,000
这个公司的他们的设计师

189
00:06:39,000 --> 00:06:41,000
也会参与到活动里面进来

190
00:06:41,000 --> 00:06:44,000
那对 Meta Design 感兴趣的朋友们

191
00:06:44,000 --> 00:06:45,000
也有机会

192
00:06:45,000 --> 00:06:48,000
所以这也是蛮难得的一个机会

193
00:06:48,000 --> 00:06:48,000
嗯

194
00:06:48,000 --> 00:06:51,000
8 月份的北京比较热哈

195
00:06:51,000 --> 00:06:53,000
但是呢

196
00:06:53,000 --> 00:06:56,000
我觉得 7 月份的上海也够热的

197
00:06:56,000 --> 00:06:58,000
上海更热吧

198
00:06:58,000 --> 00:07:00,000
我觉得这两天北京比上海凉快多了

199
00:07:00,000 --> 00:07:03,000
北京还好是干热嘛

200
00:07:03,000 --> 00:07:05,000
上海主要是湿度比较大

201
00:07:05,000 --> 00:07:05,000
比较难受

202
00:07:05,000 --> 00:07:07,000
上海这周是爆热

203
00:07:07,000 --> 00:07:09,000
已经超过 40 度了

204
00:07:09,000 --> 00:07:10,000
对啊

205
00:07:10,000 --> 00:07:12,000
有这种夏令营的感觉

206
00:07:12,000 --> 00:07:13,000
那大家呢

207
00:07:13,000 --> 00:07:17,000
也欢迎大家来多多的进行报名

208
00:07:17,000 --> 00:07:20,000
其实有这样的机会是非常难得的

209
00:07:20,000 --> 00:07:20,000
对

210
00:07:20,000 --> 00:07:22,000
好了

211
00:07:22,000 --> 00:07:25,000
难得我们这次第五次的串台嘛

212
00:07:25,000 --> 00:07:26,000
但是还要先

213
00:07:26,000 --> 00:07:27,000
呃

214
00:07:27,000 --> 00:07:27,000
讲一下反馈

215
00:07:27,000 --> 00:07:29,000
那上次呢

216
00:07:29,000 --> 00:07:31,000
就是我们的自弹自串的第四期

217
00:07:31,000 --> 00:07:33,000
峰回路转换航来呢

218
00:07:33,000 --> 00:07:34,000
有一位朋友

219
00:07:34,000 --> 00:07:37,000
说吴涛重新发明打字机

220
00:07:37,000 --> 00:07:38,000
吴涛重新发明打字机

221
00:07:38,000 --> 00:07:40,000
带回车键的打字机

222
00:07:40,000 --> 00:07:41,000
感叹好

223
00:07:41,000 --> 00:07:43,000
所以打字机是没有回车键的

224
00:07:43,000 --> 00:07:44,000
对吧

225
00:07:44,000 --> 00:07:45,000
就打字机没有

226
00:07:45,000 --> 00:07:47,000
一个键是你按下去之后

227
00:07:47,000 --> 00:07:49,000
它会跳到下一行

228
00:07:49,000 --> 00:07:49,000
哎

229
00:07:49,000 --> 00:07:50,000
我一直在跟

230
00:07:50,000 --> 00:07:51,000
好像是有的

231
00:07:51,000 --> 00:07:54,000
但这个这个键并不是回车键

232
00:07:54,000 --> 00:07:56,000
就也不是在每一个打字机上都有

233
00:07:56,000 --> 00:07:58,000
然后换航的时候

234
00:07:58,000 --> 00:08:00,000
是你拨动那个左边的拨杆

235
00:08:00,000 --> 00:08:02,000
把自车往右拨的过程中

236
00:08:02,000 --> 00:08:03,000
呃

237
00:08:03,000 --> 00:08:06,000
它会自动朝下滚一格

238
00:08:06,000 --> 00:08:08,000
所以所以换航这个功能

239
00:08:08,000 --> 00:08:09,000
实际上是在自车上实现

240
00:08:09,000 --> 00:08:11,000
正如还是把那位

241
00:08:11,000 --> 00:08:12,000
呃

242
00:08:12,000 --> 00:08:14,000
听众的反馈念一下吧

243
00:08:14,000 --> 00:08:15,000
好吧

244
00:08:15,000 --> 00:08:17,000
刚 Eric 念的是第一行

245
00:08:17,000 --> 00:08:19,000
然后接下来念

246
00:08:19,000 --> 00:08:19,000
他说

247
00:08:19,000 --> 00:08:21,000
打字机没有回车键

248
00:08:21,000 --> 00:08:23,000
打字机滚筒左端的手柄

249
00:08:23,000 --> 00:08:25,000
兼具回车与换航功能

250
00:08:25,000 --> 00:08:28,000
手柄从左向右平推

251
00:08:28,000 --> 00:08:30,000
可以将滚轮向右推

252
00:08:30,000 --> 00:08:31,000
推送就是回车

253
00:08:31,000 --> 00:08:33,000
手柄从右向左

254
00:08:33,000 --> 00:08:34,000
从左向右搬动

255
00:08:34,000 --> 00:08:37,000
同时带点轻微的顺时针扭转

256
00:08:37,000 --> 00:08:38,000
可以滚动滚动

257
00:08:38,000 --> 00:08:39,000
就是换航

258
00:08:39,000 --> 00:08:41,000
搬得轻一点

259
00:08:41,000 --> 00:08:43,000
可以换半航或四分之一航

260
00:08:43,000 --> 00:08:44,000
打字时

261
00:08:44,000 --> 00:08:46,000
当滚动航进行到

262
00:08:46,000 --> 00:08:48,000
滚动航

263
00:08:48,000 --> 00:08:50,000
进到

264
00:08:50,000 --> 00:08:53,000
接近航末位置时

265
00:08:53,000 --> 00:08:55,000
会有钉的一声零音提示

266
00:08:55,000 --> 00:08:58,000
平推手柄将滚轮推到最右

267
00:08:58,000 --> 00:08:59,000
实现回车

268
00:08:59,000 --> 00:09:01,000
顺势继续用手

269
00:09:01,000 --> 00:09:02,000
顺势继续用力

270
00:09:02,000 --> 00:09:04,000
手柄会自然向右

271
00:09:04,000 --> 00:09:05,000
板动

272
00:09:05,000 --> 00:09:07,000
转动滚轮

273
00:09:07,000 --> 00:09:08,000
这好拗口

274
00:09:08,000 --> 00:09:09,000
你怎么了

275
00:09:09,000 --> 00:09:10,000
你用这一航上来的吗

276
00:09:10,000 --> 00:09:10,000
全这位

277
00:09:10,000 --> 00:09:12,000
这好拗口

278
00:09:12,000 --> 00:09:13,000
实现坏行

279
00:09:13,000 --> 00:09:14,000
OK

280
00:09:14,000 --> 00:09:15,000
大家听懂了吗

281
00:09:15,000 --> 00:09:16,000
没有

282
00:09:16,000 --> 00:09:17,000
我是没听懂

283
00:09:17,000 --> 00:09:20,000
我真猜的什么意思

284
00:09:20,000 --> 00:09:20,000
就是

285
00:09:20,000 --> 00:09:21,000
对

286
00:09:21,000 --> 00:09:22,000
你在敲一行

287
00:09:22,000 --> 00:09:24,000
比如说这一行有 80 个字符

288
00:09:24,000 --> 00:09:26,000
然后你敲到大概 75 个的时候

289
00:09:26,000 --> 00:09:27,000
打字机会钉一声

290
00:09:27,000 --> 00:09:29,000
告诉你说没地儿的

291
00:09:29,000 --> 00:09:30,000
赶紧换行

292
00:09:30,000 --> 00:09:34,000
然后这个时候你压左侧的换行杆

293
00:09:34,000 --> 00:09:36,000
稍微压一下

294
00:09:36,000 --> 00:09:39,000
然后字车就会往上滚一个

295
00:09:39,000 --> 00:09:41,000
然后你继续往下压

296
00:09:41,000 --> 00:09:46,000
它就会把整个字车拉到指的最左边

297
00:09:46,000 --> 00:09:47,000
然后就

298
00:09:47,000 --> 00:09:48,000
就是这么一件事

299
00:09:48,000 --> 00:09:52,000
我还是很好奇

300
00:09:52,000 --> 00:09:53,000
为什么你们小时候都没有用过打字机

301
00:09:53,000 --> 00:09:56,000
对

302
00:09:56,000 --> 00:09:57,000
就没有用过习文

303
00:09:57,000 --> 00:09:59,000
没有用过

304
00:09:59,000 --> 00:10:00,000
所以你用过中文的打字机

305
00:10:00,000 --> 00:10:02,000
那更凉了

306
00:10:02,000 --> 00:10:03,000
中文打字机是一个

307
00:10:03,000 --> 00:10:05,000
一米乘一米的大台子

308
00:10:05,000 --> 00:10:06,000
对

309
00:10:06,000 --> 00:10:08,000
这个我用过

310
00:10:08,000 --> 00:10:10,000
就玩过一下

311
00:10:10,000 --> 00:10:12,000
所以那个真的存在吗

312
00:10:12,000 --> 00:10:14,000
就是那么多个字是那么大

313
00:10:14,000 --> 00:10:15,000
怎么移动呢

314
00:10:15,000 --> 00:10:19,000
是一个迪卡尔平面

315
00:10:19,000 --> 00:10:20,000
你要 XY

316
00:10:20,000 --> 00:10:22,000
真的

317
00:10:22,000 --> 00:10:27,000
那能有多少个字在上面

318
00:10:27,000 --> 00:10:27,000
字模

319
00:10:27,000 --> 00:10:28,000
将近一万个吧

320
00:10:28,000 --> 00:10:30,000
很多很多

321
00:10:30,000 --> 00:10:30,000
没有吧

322
00:10:30,000 --> 00:10:32,000
不到一万多吧

323
00:10:32,000 --> 00:10:35,000
一两千肯定是有

324
00:10:35,000 --> 00:10:35,000
因为

325
00:10:35,000 --> 00:10:37,000
我的印象里面

326
00:10:37,000 --> 00:10:38,000
我的印象里面

327
00:10:38,000 --> 00:10:40,000
我玩过的那台是有六千字

328
00:10:40,000 --> 00:10:44,000
因为中文常用字也就三千五吧

329
00:10:44,000 --> 00:10:46,000
就他把长用字放在上面

330
00:10:46,000 --> 00:10:47,000
然后不够的适用空格

331
00:10:47,000 --> 00:10:48,000
然后又塞手写

332
00:10:48,000 --> 00:10:50,000
他底下那个可以换的

333
00:10:50,000 --> 00:10:51,000
可以替换

334
00:10:51,000 --> 00:10:53,000
我印象里面是个 100 乘 100 的格子

335
00:10:53,000 --> 00:10:54,000
你知道吗

336
00:10:54,000 --> 00:10:56,000
我印象好像

337
00:10:56,000 --> 00:10:58,000
有那么多吗

338
00:10:58,000 --> 00:10:59,000
没那么大吧

339
00:10:59,000 --> 00:11:00,000
没有 100 乘 100 吗

340
00:11:00,000 --> 00:11:02,000
记不大清楚了

341
00:11:02,000 --> 00:11:03,000
挺大的

342
00:11:03,000 --> 00:11:03,000
对

343
00:11:03,000 --> 00:11:03,000
挺大的

344
00:11:03,000 --> 00:11:04,000
对

345
00:11:04,000 --> 00:11:06,000
反正是个相当大的东西

346
00:11:06,000 --> 00:11:08,000
我刚给大家发了一个链接

347
00:11:08,000 --> 00:11:09,000
那个也是一种

348
00:11:09,000 --> 00:11:11,000
那个汉字的打字机

349
00:11:11,000 --> 00:11:13,000
这个是日本人做的

350
00:11:13,000 --> 00:11:17,000
然后它是一个滚筒式的选字机构

351
00:11:17,000 --> 00:11:19,000
哦

352
00:11:19,000 --> 00:11:20,000
OK

353
00:11:20,000 --> 00:11:21,000
这个比较浓烈

354
00:11:21,000 --> 00:11:22,000
对

355
00:11:22,000 --> 00:11:22,000
这个是在

356
00:11:22,000 --> 00:11:25,000
那个京都的汉字博物馆里面

357
00:11:25,000 --> 00:11:27,000
展示的一件展品

358
00:11:27,000 --> 00:11:28,000
其实如果这么多

359
00:11:28,000 --> 00:11:29,000
就怎么记啊

360
00:11:30,000 --> 00:11:33,000
可能熟能生巧吧

361
00:11:33,000 --> 00:11:35,000
另外它肯定牌子是有规则的

362
00:11:35,000 --> 00:11:36,000
你看它有标了不同的颜色

363
00:11:36,000 --> 00:11:38,000
凯克会给扣了这样牌吗

364
00:11:38,000 --> 00:11:39,000
不

365
00:11:39,000 --> 00:11:41,000
汉字应该不是这样牌的

366
00:11:41,000 --> 00:11:42,000
OK

367
00:11:42,000 --> 00:11:44,000
应该是按音式牌的吧

368
00:11:44,000 --> 00:11:46,000
它而且有颜色划分嘛

369
00:11:46,000 --> 00:11:47,000
应该是按那个所谓的航和列

370
00:11:47,000 --> 00:11:51,000
就是 50 音的航和列的

371
00:11:51,000 --> 00:11:53,000
发音来标音之后再分开

372
00:11:53,000 --> 00:11:55,000
天哪怎么记得住啊

373
00:11:55,000 --> 00:11:56,000
哪个字在哪个位置

374
00:11:56,000 --> 00:11:58,000
还是要找的

375
00:11:58,000 --> 00:11:59,000
不你想

376
00:11:59,000 --> 00:11:59,000
就是说

377
00:11:59,000 --> 00:12:01,000
假设只有 3000 个

378
00:12:01,000 --> 00:12:03,000
常用字的那个滚筒的话

379
00:12:03,000 --> 00:12:04,000
那

380
00:12:04,000 --> 00:12:06,000
这打字速度应该很慢吧

381
00:12:06,000 --> 00:12:07,000
嗯

382
00:12:07,000 --> 00:12:08,000
就得转转

383
00:12:08,000 --> 00:12:09,000
然后转

384
00:12:09,000 --> 00:12:10,000
转完以后才打出一个字

385
00:12:10,000 --> 00:12:11,000
就是这样

386
00:12:11,000 --> 00:12:11,000
嗯

387
00:12:11,000 --> 00:12:13,000
它这个毕竟还是按拼音排列的

388
00:12:13,000 --> 00:12:15,000
我觉得可能还是要比中文打字机

389
00:12:15,000 --> 00:12:17,000
那个按部首排列的

390
00:12:17,000 --> 00:12:18,000
要快一点

391
00:12:18,000 --> 00:12:18,000
我觉得

392
00:12:18,000 --> 00:12:19,000
对

393
00:12:19,000 --> 00:12:19,000
不过

394
00:12:19,000 --> 00:12:20,000
因为日语

395
00:12:20,000 --> 00:12:22,000
一个字有很多发音嘛

396
00:12:22,000 --> 00:12:24,000
所以你可能得记住这个字

397
00:12:24,000 --> 00:12:25,000
它用的是哪个标音

398
00:12:25,000 --> 00:12:27,000
像我以前

399
00:12:27,000 --> 00:12:28,000
我以前看到我

400
00:12:28,000 --> 00:12:29,000
就是我爸

401
00:12:29,000 --> 00:12:31,000
单位他们那个打字员

402
00:12:31,000 --> 00:12:32,000
用那种打字机的话

403
00:12:32,000 --> 00:12:33,000
它底下那个

404
00:12:33,000 --> 00:12:34,000
反

405
00:12:34,000 --> 00:12:35,000
那个刚

406
00:12:35,000 --> 00:12:36,000
刚冲的那个

407
00:12:36,000 --> 00:12:38,000
刚字的盘是可以换的

408
00:12:38,000 --> 00:12:39,000
所以他经常会把

409
00:12:39,000 --> 00:12:40,000
这比如常用的字

410
00:12:40,000 --> 00:12:41,000
的组合

411
00:12:41,000 --> 00:12:42,000
他

412
00:12:42,000 --> 00:12:43,000
因为他可以随

413
00:12:43,000 --> 00:12:44,000
任意调配嘛

414
00:12:44,000 --> 00:12:46,000
然后把常用的放在一起

415
00:12:46,000 --> 00:12:48,000
比如中华人民共和国

416
00:12:48,000 --> 00:12:48,000
他就全部放进

417
00:12:48,000 --> 00:12:49,000
嘎嘎嘎嘎嘎

418
00:12:49,000 --> 00:12:50,000
他就顺下来

419
00:12:50,000 --> 00:12:51,000
可以直接打出来就可以

420
00:12:51,000 --> 00:12:52,000
嗯

421
00:12:52,000 --> 00:12:53,000
而且我记得

422
00:12:53,000 --> 00:12:55,000
就我见到那个中文打字机

423
00:12:55,000 --> 00:12:56,000
好像他那个字盘

424
00:12:56,000 --> 00:12:57,000
不只是一层

425
00:12:57,000 --> 00:12:59,000
他有两层的

426
00:12:59,000 --> 00:12:59,000
可以抽的

427
00:12:59,000 --> 00:13:00,000
对

428
00:13:00,000 --> 00:13:00,000
没错

429
00:13:00,000 --> 00:13:01,000
对没错

430
00:13:01,000 --> 00:13:01,000
上面有一层

431
00:13:01,000 --> 00:13:03,000
可能是常用的

432
00:13:03,000 --> 00:13:04,000
下面还是次常用的

433
00:13:04,000 --> 00:13:04,000
哦

434
00:13:04,000 --> 00:13:06,000
对对对

435
00:13:06,000 --> 00:13:06,000
没错

436
00:13:06,000 --> 00:13:09,000
所以我印象中的中文打字机

437
00:13:09,000 --> 00:13:10,000
没那么大

438
00:13:10,000 --> 00:13:12,000
嗯

439
00:13:12,000 --> 00:13:12,000
有道理

440
00:13:12,000 --> 00:13:13,000
对

441
00:13:13,000 --> 00:13:15,000
100 乘 100 好像移动出来

442
00:13:15,000 --> 00:13:16,000
挺麻烦的

443
00:13:16,000 --> 00:13:16,000
哈哈

444
00:13:16,000 --> 00:13:19,000
打太极拳都可以

445
00:13:19,000 --> 00:13:21,000
因为我小时候

446
00:13:21,000 --> 00:13:23,000
其实就根本没有见过这些

447
00:13:23,000 --> 00:13:25,000
就纯机械的打字机

448
00:13:25,000 --> 00:13:26,000
因为我记得我小时候

449
00:13:26,000 --> 00:13:28,000
第一次看人打字的时候

450
00:13:28,000 --> 00:13:29,000
已经是有那个叫

451
00:13:29,000 --> 00:13:30,000
那叫什么来的

452
00:13:30,000 --> 00:13:31,000
就是字符

453
00:13:31,000 --> 00:13:31,000
那个 DOS

454
00:13:31,000 --> 00:13:34,000
DOS 环境下面有一个中文的系统

455
00:13:34,000 --> 00:13:36,000
WPS

456
00:13:36,000 --> 00:13:38,000
CCED 吧

457
00:13:38,000 --> 00:13:39,000
对

458
00:13:39,000 --> 00:13:40,000
CCED 是更早的

459
00:13:40,000 --> 00:13:41,000
后来 WPS 后出的嘛

460
00:13:41,000 --> 00:13:42,000
然后后出的时候

461
00:13:42,000 --> 00:13:44,000
那个时候已经有那种

462
00:13:44,000 --> 00:13:46,000
就是在那个 WPS 的那个

463
00:13:46,000 --> 00:13:48,000
就是字符界面那个版本里面

464
00:13:48,000 --> 00:13:49,000
去排印

465
00:13:49,000 --> 00:13:51,000
然后用那种真实打印机

466
00:13:51,000 --> 00:13:53,000
再把那个打出来嘛

467
00:13:53,000 --> 00:13:54,000
所以这个时候其实已经

468
00:13:54,000 --> 00:13:57,000
没有见过真的那种传统一的打字机了

469
00:13:57,000 --> 00:13:59,000
我高中办校报的时候

470
00:13:59,000 --> 00:14:01,000
就是用那个先进 UCDOS

471
00:14:01,000 --> 00:14:04,000
然后再进那个 WPS

472
00:14:04,000 --> 00:14:05,000
然后呢

473
00:14:05,000 --> 00:14:06,000
它那不是一个

474
00:14:06,000 --> 00:14:08,000
它是字符编辑界面吧

475
00:14:08,000 --> 00:14:10,000
它不是那个所见即所得的嘛

476
00:14:10,000 --> 00:14:12,000
所以你得要一些装饰的东西

477
00:14:12,000 --> 00:14:13,000
都用那个符号写进去

478
00:14:13,000 --> 00:14:15,000
后来不停不停的预览

479
00:14:15,000 --> 00:14:17,000
然后经常 386 的机械还会死去

480
00:14:17,000 --> 00:14:19,000
对

481
00:14:19,000 --> 00:14:20,000
那个时候对于所见即所得

482
00:14:20,000 --> 00:14:21,000
没什么概念嘛

483
00:14:21,000 --> 00:14:21,000
就是

484
00:14:21,000 --> 00:14:22,000
对

485
00:14:22,000 --> 00:14:24,000
就是你要不停的预览

486
00:14:24,000 --> 00:14:25,000
但是后来

487
00:14:25,000 --> 00:14:27,000
基本上熟悦一点的人会

488
00:14:27,000 --> 00:14:29,000
对于文章

489
00:14:29,000 --> 00:14:31,000
大概会看起来是什么样子

490
00:14:31,000 --> 00:14:32,000
有个概念

491
00:14:32,000 --> 00:14:34,000
就跟现在手写 HTML 一样

492
00:14:34,000 --> 00:14:35,000
然后预览

493
00:14:35,000 --> 00:14:37,000
本质上也是一种 mark up 的语言嘛

494
00:14:37,000 --> 00:14:37,000
那个

495
00:14:37,000 --> 00:14:38,000
是

496
00:14:38,000 --> 00:14:39,000
那完全就是 mark up

497
00:14:39,000 --> 00:14:41,000
所以你脑子中要想好

498
00:14:41,000 --> 00:14:42,000
你所要的是什么东西嘛

499
00:14:42,000 --> 00:14:42,000
嗯

500
00:14:42,000 --> 00:14:43,000
对

501
00:14:43,000 --> 00:14:45,000
其实现在我们又回 mark down

502
00:14:45,000 --> 00:14:46,000
又回去了是吧

503
00:14:46,000 --> 00:14:47,000
又回来了

504
00:14:47,000 --> 00:14:47,000
对

505
00:14:47,000 --> 00:14:49,000
实际上我觉得

506
00:14:49,000 --> 00:14:51,000
这个所见即所得

507
00:14:51,000 --> 00:14:52,000
并不是一个强需求

508
00:14:52,000 --> 00:14:53,000
我说实话

509
00:14:53,000 --> 00:14:53,000
就

510
00:14:53,000 --> 00:14:58,000
就要看他那个门槛放低了以后

511
00:14:58,000 --> 00:14:59,000
是可以让更多人进来嘛

512
00:14:59,000 --> 00:15:01,000
但是对于呃

513
00:15:01,000 --> 00:15:01,000
专业用户的话

514
00:15:01,000 --> 00:15:02,000
可能需求不一样嘛

515
00:15:02,000 --> 00:15:03,000
对

516
00:15:03,000 --> 00:15:04,000
就我觉得

517
00:15:04,000 --> 00:15:06,000
所见的

518
00:15:06,000 --> 00:15:07,000
本身是没有问题的

519
00:15:07,000 --> 00:15:08,000
主要问题在于

520
00:15:08,000 --> 00:15:09,000
现在就主要

521
00:15:09,000 --> 00:15:10,000
就是像 word 的那个实现

522
00:15:10,000 --> 00:15:13,000
他的那个实现过程有问题

523
00:15:13,000 --> 00:15:17,000
就是他把所有的那个效果都

524
00:15:17,000 --> 00:15:18,000
就直接锁件了

525
00:15:18,000 --> 00:15:20,000
你没有办法用一个类似于像

526
00:15:20,000 --> 00:15:20,000
呃

527
00:15:20,000 --> 00:15:23,000
模板或者是一种格式的方式

528
00:15:23,000 --> 00:15:25,000
现在虽然有格式耍好

529
00:15:25,000 --> 00:15:27,000
但是那个就是极其不稳定嘛

530
00:15:27,000 --> 00:15:27,000
我

531
00:15:27,000 --> 00:15:28,000
我觉得这家问题

532
00:15:28,000 --> 00:15:28,000
他太

533
00:15:28,000 --> 00:15:30,000
他太迁就用户了

534
00:15:30,000 --> 00:15:30,000
就是

535
00:15:30,000 --> 00:15:31,000
对

536
00:15:31,000 --> 00:15:32,000
用户说啊

537
00:15:32,000 --> 00:15:34,000
我这个小标题要

538
00:15:34,000 --> 00:15:35,000
五万

539
00:15:35,000 --> 00:15:37,000
十五帮重

540
00:15:37,000 --> 00:15:38,000
加粗

541
00:15:38,000 --> 00:15:39,000
下一个小标题

542
00:15:39,000 --> 00:15:40,000
他就弄了一个十六帮重

543
00:15:40,000 --> 00:15:42,000
然后倾斜

544
00:15:42,000 --> 00:15:43,000
然后握着就

545
00:15:43,000 --> 00:15:44,000
握着就傻逼了

546
00:15:44,000 --> 00:15:44,000
握着说

547
00:15:44,000 --> 00:15:45,000
哎呦

548
00:15:45,000 --> 00:15:46,000
我应该怎么办呢

549
00:15:46,000 --> 00:15:47,000
我应该问用户说

550
00:15:47,000 --> 00:15:48,000
不对

551
00:15:48,000 --> 00:15:50,000
你上一个小标题用的是这个

552
00:15:50,000 --> 00:15:51,000
然后这小标题

553
00:15:51,000 --> 00:15:52,000
你也得用那个

554
00:15:52,000 --> 00:15:54,000
但是这样一台用户可能不爽

555
00:15:54,000 --> 00:15:55,000
那我还是迁就用户

556
00:15:55,000 --> 00:15:56,000
再多分出来一个小标题吧

557
00:15:56,000 --> 00:15:57,000
然后等到

558
00:15:57,000 --> 00:15:58,000
整个

559
00:15:58,000 --> 00:16:00,000
整篇文章写完之后

560
00:16:00,000 --> 00:16:01,000
发现小标题的 style

561
00:16:01,000 --> 00:16:03,000
可能有 20 种

562
00:16:03,000 --> 00:16:03,000
35 种

563
00:16:03,000 --> 00:16:04,000
对

564
00:16:04,000 --> 00:16:05,000
如果一上来

565
00:16:05,000 --> 00:16:06,000
你们从来没有学会过

566
00:16:06,000 --> 00:16:08,000
用博士刷这个习惯的话

567
00:16:08,000 --> 00:16:10,000
那基本上就

568
00:16:10,000 --> 00:16:11,000
就最后只能手动改

569
00:16:11,000 --> 00:16:13,000
关键是那个格式

570
00:16:13,000 --> 00:16:14,000
他那个格式刷

571
00:16:14,000 --> 00:16:15,000
他也是一个

572
00:16:15,000 --> 00:16:17,000
就是事后家的东西

573
00:16:17,000 --> 00:16:17,000
我觉得

574
00:16:17,000 --> 00:16:18,000
就是他的本质上

575
00:16:18,000 --> 00:16:19,000
他的主理结构

576
00:16:19,000 --> 00:16:21,000
是以那个实际看的为准的

577
00:16:21,000 --> 00:16:23,000
这点跟那个苹果

578
00:16:23,000 --> 00:16:23,000
那个 pages

579
00:16:23,000 --> 00:16:24,000
就是跟博士

580
00:16:24,000 --> 00:16:26,000
差不多的一个软件

581
00:16:26,000 --> 00:16:28,000
的逻辑是完全不一样的

582
00:16:28,000 --> 00:16:28,000
pages 里面

583
00:16:28,000 --> 00:16:29,000
其实你是可以先定义

584
00:16:29,000 --> 00:16:30,000
那个文章的结构

585
00:16:30,000 --> 00:16:31,000
比如说这个

586
00:16:31,000 --> 00:16:32,000
刚才讲说

587
00:16:32,000 --> 00:16:33,000
这个是标题

588
00:16:33,000 --> 00:16:34,000
就一级标题

589
00:16:34,000 --> 00:16:35,000
二级标题

590
00:16:35,000 --> 00:16:36,000
然后是正文

591
00:16:36,000 --> 00:16:38,000
这个是这个表格的内容

592
00:16:38,000 --> 00:16:39,000
然后定好之后

593
00:16:39,000 --> 00:16:40,000
你是可以直接通过

594
00:16:40,000 --> 00:16:41,000
改那个

595
00:16:41,000 --> 00:16:42,000
那个

596
00:16:42,000 --> 00:16:43,000
那个类型的文本

597
00:16:43,000 --> 00:16:43,000
比如说

598
00:16:43,000 --> 00:16:43,000
对吧

599
00:16:43,000 --> 00:16:45,000
改标题都改成一种

600
00:16:45,000 --> 00:16:45,000
同样的东西

601
00:16:45,000 --> 00:16:47,000
他可以直接更新

602
00:16:47,000 --> 00:16:48,000
然后让所有的标题文本

603
00:16:48,000 --> 00:16:50,000
都是长那个样子的

604
00:16:50,000 --> 00:16:51,000
但是在 word 里面

605
00:16:51,000 --> 00:16:52,000
这一点实现起来

606
00:16:52,000 --> 00:16:53,000
是非常不稳定的

607
00:16:53,000 --> 00:16:54,000
word 也有这个功能

608
00:16:54,000 --> 00:16:55,000
word 也有

609
00:16:55,000 --> 00:16:56,000
对

610
00:16:56,000 --> 00:16:57,000
只是用的非常的少

611
00:16:57,000 --> 00:16:58,000
不是不是

612
00:16:58,000 --> 00:17:00,000
他的实现确实是有问题的

613
00:17:00,000 --> 00:17:01,000
就是他不是那么强

614
00:17:01,000 --> 00:17:03,000
强调那个结构和统一的

615
00:17:03,000 --> 00:17:04,000
这么一个概念

616
00:17:04,000 --> 00:17:05,000
就刚才讲

617
00:17:05,000 --> 00:17:05,000
吴涛说的嘛

618
00:17:05,000 --> 00:17:07,000
就是用户觉得

619
00:17:07,000 --> 00:17:08,000
这里要改一点

620
00:17:08,000 --> 00:17:08,000
那一点

621
00:17:08,000 --> 00:17:09,000
他就不去 enforce

622
00:17:09,000 --> 00:17:10,000
这个对象

623
00:17:10,000 --> 00:17:11,000
一致性的问题

624
00:17:11,000 --> 00:17:13,000
这个其实是

625
00:17:13,000 --> 00:17:14,000
专业用户的一个

626
00:17:14,000 --> 00:17:16,000
需求不一样的

627
00:17:16,000 --> 00:17:18,000
像我当年也曾经用 word

628
00:17:18,000 --> 00:17:20,000
做 40 页的小册子的时候

629
00:17:20,000 --> 00:17:21,000
我都是用那个样

630
00:17:21,000 --> 00:17:22,000
那个叫什么

631
00:17:22,000 --> 00:17:23,000
style 样式吧

632
00:17:23,000 --> 00:17:24,000
他专门有个样式

633
00:17:24,000 --> 00:17:26,000
小窗口来做

634
00:17:26,000 --> 00:17:27,000
对的

635
00:17:27,000 --> 00:17:28,000
你做长文档的时候

636
00:17:28,000 --> 00:17:29,000
就必须要用那样来做

637
00:17:29,000 --> 00:17:29,000
要不然的话

638
00:17:29,000 --> 00:17:31,000
非常复杂

639
00:17:31,000 --> 00:17:31,000
对

640
00:17:31,000 --> 00:17:32,000
就是那个实际的

641
00:17:32,000 --> 00:17:33,000
使用的情况下

642
00:17:33,000 --> 00:17:34,000
word 就会出现

643
00:17:34,000 --> 00:17:35,000
刚才我才讲的那个问题

644
00:17:35,000 --> 00:17:36,000
就是你的那个

645
00:17:36,000 --> 00:17:36,000
格式刷

646
00:17:36,000 --> 00:17:37,000
它不是一个列表

647
00:17:37,000 --> 00:17:38,000
有多少种格式吗

648
00:17:38,000 --> 00:17:40,000
你可能一边稍微长

649
00:17:40,000 --> 00:17:40,000
10 页的文档

650
00:17:40,000 --> 00:17:41,000
可能会出现

651
00:17:41,000 --> 00:17:42,000
4050 种

652
00:17:42,000 --> 00:17:42,000
那个不同

653
00:17:42,000 --> 00:17:43,000
就是 word 对于

654
00:17:43,000 --> 00:17:45,000
就是你想把 word 用好的话

655
00:17:45,000 --> 00:17:46,000
你要有一个

656
00:17:46,000 --> 00:17:48,000
你要有一个非常好的

657
00:17:48,000 --> 00:17:49,000
怎么说

658
00:17:49,000 --> 00:17:50,000
discipline

659
00:17:50,000 --> 00:17:51,000
就是你必须是一个

660
00:17:51,000 --> 00:17:52,000
非常自律

661
00:17:52,000 --> 00:17:53,000
高度自律的人

662
00:17:53,000 --> 00:17:54,000
对

663
00:17:54,000 --> 00:17:55,000
你一定要忍住

664
00:17:55,000 --> 00:17:57,000
选中这一行字

665
00:17:57,000 --> 00:17:58,000
然后直接往上

666
00:17:58,000 --> 00:18:00,000
改变它的格式的

667
00:18:00,000 --> 00:18:03,000
改变它的样式的

668
00:18:03,000 --> 00:18:04,000
这个冲动

669
00:18:04,000 --> 00:18:06,000
然后忍辱负重的

670
00:18:06,000 --> 00:18:07,000
去用格式刷

671
00:18:07,000 --> 00:18:08,000
来刷这行字

672
00:18:08,000 --> 00:18:09,000
对

673
00:18:09,000 --> 00:18:10,000
否则你就乱了

674
00:18:10,000 --> 00:18:11,000
它很容易

675
00:18:11,000 --> 00:18:13,000
在那些小细节的地方

676
00:18:13,000 --> 00:18:13,000
就变掉

677
00:18:13,000 --> 00:18:14,000
就是你用格式刷

678
00:18:14,000 --> 00:18:15,000
也刷不回来

679
00:18:15,000 --> 00:18:15,000
就有些

680
00:18:15,000 --> 00:18:17,000
我不在你们遇到过

681
00:18:17,000 --> 00:18:17,000
有些比如说

682
00:18:17,000 --> 00:18:19,000
两个字之间出现一个东西

683
00:18:19,000 --> 00:18:19,000
你无论用格式刷

684
00:18:19,000 --> 00:18:20,000
点多少次

685
00:18:20,000 --> 00:18:21,000
它都不会变的

686
00:18:21,000 --> 00:18:22,000
就是它的内部

687
00:18:22,000 --> 00:18:24,000
应该是有一些实现的 bug 的

688
00:18:24,000 --> 00:18:25,000
对

689
00:18:25,000 --> 00:18:26,000
这个东西就是

690
00:18:26,000 --> 00:18:27,000
那你要

691
00:18:27,000 --> 00:18:28,000
自律的话

692
00:18:28,000 --> 00:18:29,000
看有没有洁癖了

693
00:18:29,000 --> 00:18:29,000
对吧

694
00:18:29,000 --> 00:18:31,000
就千万不能用

695
00:18:31,000 --> 00:18:32,000
硬回车来称行句

696
00:18:32,000 --> 00:18:33,000
对吧

697
00:18:33,000 --> 00:18:37,000
用空格来称字句

698
00:18:37,000 --> 00:18:37,000
对吧

699
00:18:37,000 --> 00:18:38,000
像这种东西的话

700
00:18:38,000 --> 00:18:40,000
本来就是排榜

701
00:18:40,000 --> 00:18:40,000
排榜的

702
00:18:40,000 --> 00:18:41,000
首先的

703
00:18:41,000 --> 00:18:43,000
这个做法是不一样的

704
00:18:43,000 --> 00:18:44,000
对啊

705
00:18:44,000 --> 00:18:44,000
OK

706
00:18:44,000 --> 00:18:46,000
补充去

707
00:18:46,000 --> 00:18:46,000
刚才说的

708
00:18:46,000 --> 00:18:47,000
那个中文打字机

709
00:18:47,000 --> 00:18:49,000
我记得

710
00:18:49,000 --> 00:18:50,000
那个中文打字机

711
00:18:50,000 --> 00:18:52,000
它有一个最大问题

712
00:18:52,000 --> 00:18:53,000
就是它不像英文打字机

713
00:18:53,000 --> 00:18:54,000
英文打字机

714
00:18:54,000 --> 00:18:55,000
也有这个问题

715
00:18:55,000 --> 00:18:55,000
但是没那么严重

716
00:18:55,000 --> 00:18:56,000
就是

717
00:18:56,000 --> 00:18:58,000
你在用英文打字机的时候

718
00:18:58,000 --> 00:18:59,000
你可能按一个键

719
00:18:59,000 --> 00:19:01,000
你的力度轻了

720
00:19:01,000 --> 00:19:01,000
那个

721
00:19:01,000 --> 00:19:04,000
那个打在纸上的字

722
00:19:04,000 --> 00:19:05,000
就会不清楚

723
00:19:05,000 --> 00:19:07,000
而中文打字机是

724
00:19:07,000 --> 00:19:08,000
如果你力度轻了

725
00:19:08,000 --> 00:19:10,000
那字不清楚也就罢了

726
00:19:10,000 --> 00:19:12,000
如果你用力比较重的话

727
00:19:12,000 --> 00:19:12,000
那个字

728
00:19:12,000 --> 00:19:14,000
那个笔画也比较复杂

729
00:19:14,000 --> 00:19:14,000
比如

730
00:19:14,000 --> 00:19:18,000
繁体的什么国家

731
00:19:18,000 --> 00:19:19,000
国字啊

732
00:19:19,000 --> 00:19:19,000
这种字

733
00:19:19,000 --> 00:19:20,000
你一打上去

734
00:19:20,000 --> 00:19:21,000
那个纸会不会穿烂的

735
00:19:21,000 --> 00:19:21,000
我印象

736
00:19:21,000 --> 00:19:24,000
所以

737
00:19:24,000 --> 00:19:25,000
所以那个时候

738
00:19:25,000 --> 00:19:28,000
那个时候不仅打字是一个

739
00:19:28,000 --> 00:19:29,000
要寻止

740
00:19:29,000 --> 00:19:31,000
还要控制自己打字的力量

741
00:19:31,000 --> 00:19:32,000
真的是

742
00:19:32,000 --> 00:19:33,000
很累很累

743
00:19:33,000 --> 00:19:35,000
为什么会这样呢

744
00:19:35,000 --> 00:19:35,000
所以它那个

745
00:19:35,000 --> 00:19:36,000
它那个案件

746
00:19:36,000 --> 00:19:38,000
是不是均匀力度下去

747
00:19:38,000 --> 00:19:41,000
是靠你的那个手的力量来决定的

748
00:19:41,000 --> 00:19:41,000
对

749
00:19:41,000 --> 00:19:42,000
其实它是把一张纸

750
00:19:42,000 --> 00:19:44,000
卷在一个大滚筒上

751
00:19:44,000 --> 00:19:45,000
那滚筒是在这个

752
00:19:45,000 --> 00:19:47,000
提卡尔平面上面

753
00:19:47,000 --> 00:19:50,000
就移动的嘛

754
00:19:50,000 --> 00:19:52,000
然后移动的时候

755
00:19:52,000 --> 00:19:53,000
你找到一个字

756
00:19:53,000 --> 00:19:54,000
你要把那个压

757
00:19:54,000 --> 00:19:56,000
把那个手柄压下去

758
00:19:56,000 --> 00:19:57,000
然后我理解是

759
00:19:57,000 --> 00:19:59,000
它把那个签字吸上来

760
00:19:59,000 --> 00:20:02,000
然后在纸上戳一下

761
00:20:02,000 --> 00:20:04,000
然后这个如果戳得比较狠的话

762
00:20:04,000 --> 00:20:05,000
那个纸会破

763
00:20:05,000 --> 00:20:06,000
对

764
00:20:06,000 --> 00:20:10,000
但我觉得像用键盘的这种打字机

765
00:20:10,000 --> 00:20:13,000
它完全是可以用机械设计解决这个问题

766
00:20:13,000 --> 00:20:13,000
对

767
00:20:13,000 --> 00:20:15,000
像 IBM 那种

768
00:20:15,000 --> 00:20:17,000
又是用球形的那个打字头打字机

769
00:20:17,000 --> 00:20:18,000
它就是

770
00:20:18,000 --> 00:20:22,000
它把输入跟那个打字的部分分开了

771
00:20:22,000 --> 00:20:24,000
就是实际上你是驱动一个发条

772
00:20:24,000 --> 00:20:27,000
然后那个发条每次会以均匀的力度

773
00:20:27,000 --> 00:20:28,000
把那个字打在纸上

774
00:20:28,000 --> 00:20:28,000
对

775
00:20:28,000 --> 00:20:30,000
但这个都比较高端了

776
00:20:30,000 --> 00:20:31,000
对

777
00:20:31,000 --> 00:20:32,000
这个都比较高端了

778
00:20:32,000 --> 00:20:33,000
就家用的那种

779
00:20:33,000 --> 00:20:33,000
就是变

780
00:20:33,000 --> 00:20:36,000
尤其是便携的袖针的打字机

781
00:20:36,000 --> 00:20:37,000
都是还是你按

782
00:20:37,000 --> 00:20:40,000
你的手按的力度多大

783
00:20:40,000 --> 00:20:41,000
那个字就有多深

784
00:20:41,000 --> 00:20:43,000
怪不得看有些那种

785
00:20:43,000 --> 00:20:44,000
那种以前那种

786
00:20:44,000 --> 00:20:45,000
打字机打的文档

787
00:20:45,000 --> 00:20:48,000
它有些那个字符的粗细是不一样的

788
00:20:48,000 --> 00:20:49,000
就是因为这个原因是吧

789
00:20:49,000 --> 00:20:49,000
对

790
00:20:49,000 --> 00:20:50,000
就是用力太

791
00:20:50,000 --> 00:20:51,000
力度的问题

792
00:20:51,000 --> 00:20:52,000
对

793
00:20:52,000 --> 00:20:52,000
OK

794
00:20:52,000 --> 00:20:55,000
这个真的是个手艺话

795
00:20:55,000 --> 00:20:56,000
对

796
00:20:56,000 --> 00:20:57,000
你像那个

797
00:20:57,000 --> 00:21:01,000
那个 IBM 出的打字机里面

798
00:21:01,000 --> 00:21:02,000
Courier

799
00:21:02,000 --> 00:21:03,000
这个字体就这么来了

800
00:21:03,000 --> 00:21:04,000
就是专门为了

801
00:21:04,000 --> 00:21:07,000
它的一个滚筒式打字机的

802
00:21:07,000 --> 00:21:09,000
那个设计的一套字体

803
00:21:09,000 --> 00:21:10,000
就 Courier

804
00:21:10,000 --> 00:21:11,000
有什么讲究吗

805
00:21:11,000 --> 00:21:13,000
就是等宽嘛

806
00:21:13,000 --> 00:21:14,000
那个时候的等宽

807
00:21:14,000 --> 00:21:16,000
然后是就有点 slab 的感觉嘛

808
00:21:16,000 --> 00:21:17,000
就是带一点点衬线

809
00:21:17,000 --> 00:21:18,000
OK

810
00:21:18,000 --> 00:21:22,000
最近有个新闻

811
00:21:22,000 --> 00:21:23,000
可以和大家分享一下

812
00:21:23,000 --> 00:21:24,000
因为我们前段时间

813
00:21:24,000 --> 00:21:25,000
说过那个 emoji 嘛

814
00:21:25,000 --> 00:21:26,000
就是表情符号嘛

815
00:21:26,000 --> 00:21:27,000
刚好 7 月 17 号

816
00:21:27,000 --> 00:21:29,000
就是 emoji 日

817
00:21:29,000 --> 00:21:30,000
7 月 17 号是 emoji 日

818
00:21:30,000 --> 00:21:31,000
这个事情

819
00:21:31,000 --> 00:21:32,000
你们知道吗

820
00:21:32,000 --> 00:21:32,000
我们提过

821
00:21:32,000 --> 00:21:33,000
我还真的不知道

822
00:21:33,000 --> 00:21:33,000
我们提过

823
00:21:33,000 --> 00:21:35,000
emoji 还有自己的节日了

824
00:21:35,000 --> 00:21:35,000
已经

825
00:21:35,000 --> 00:21:38,000
我们讲 emoji 那期提过这个事情

826
00:21:38,000 --> 00:21:40,000
为什么是那天我忘了

827
00:21:40,000 --> 00:21:41,000
就是因为那个

828
00:21:41,000 --> 00:21:43,000
emoji 的那个日历的图标上

829
00:21:43,000 --> 00:21:45,000
写的是 7 月 17 号

830
00:21:45,000 --> 00:21:45,000
对对对

831
00:21:45,000 --> 00:21:46,000
对

832
00:21:46,000 --> 00:21:47,000
我想想

833
00:21:47,000 --> 00:21:48,000
苹果那个日历的

834
00:21:48,000 --> 00:21:50,000
沿用苹果的那个

835
00:21:50,000 --> 00:21:50,000
那个

836
00:21:50,000 --> 00:21:52,000
当时还叫 iCal 嘛

837
00:21:52,000 --> 00:21:53,000
的日子

838
00:21:53,000 --> 00:21:54,000
对

839
00:21:54,000 --> 00:21:54,000
然后这次

840
00:21:54,000 --> 00:21:57,000
苹果居然在他们官方网站上面

841
00:21:57,000 --> 00:21:58,000
搞一个什么

842
00:21:58,000 --> 00:22:00,000
新闻出来了是吧

843
00:22:00,000 --> 00:22:02,000
预先把今年稍晚推出的

844
00:22:02,000 --> 00:22:02,000
那个表情符号

845
00:22:02,000 --> 00:22:04,000
跟大家展示了一下

846
00:22:04,000 --> 00:22:06,000
嗯哼

847
00:22:06,000 --> 00:22:07,000
这是 iOS 11 里面

848
00:22:07,000 --> 00:22:08,000
会搭载那套新的

849
00:22:08,000 --> 00:22:10,000
对

850
00:22:10,000 --> 00:22:12,000
也就是 6 月份

851
00:22:12,000 --> 00:22:15,000
I Unicode 第 10 版里面

852
00:22:15,000 --> 00:22:16,000
已经通过的这些

853
00:22:16,000 --> 00:22:18,000
它已经准备好

854
00:22:18,000 --> 00:22:19,000
已经画好了嘛

855
00:22:19,000 --> 00:22:20,000
就马上就要

856
00:22:20,000 --> 00:22:22,000
拿出来跟大家用了

857
00:22:22,000 --> 00:22:24,000
比如说有什么僵尸

858
00:22:24,000 --> 00:22:27,000
有什么戴头巾的女人

859
00:22:27,000 --> 00:22:28,000
长胡须的人

860
00:22:28,000 --> 00:22:30,000
僵尸和穆斯年是同一个批次的

861
00:22:30,000 --> 00:22:30,000
是不是

862
00:22:30,000 --> 00:22:34,000
或者说应该

863
00:22:34,000 --> 00:22:36,000
应该还有什么

864
00:22:36,000 --> 00:22:37,000
饺子和筷子吗

865
00:22:37,000 --> 00:22:37,000
不是

866
00:22:37,000 --> 00:22:38,000
我上次在节目

867
00:22:38,000 --> 00:22:40,000
我在我们节目里面说过

868
00:22:40,000 --> 00:22:42,000
到底是画成包子

869
00:22:42,000 --> 00:22:43,000
还是画成馄饨的

870
00:22:43,000 --> 00:22:43,000
那就不知道了

871
00:22:43,000 --> 00:22:45,000
到时候看实现吧

872
00:22:45,000 --> 00:22:47,000
所以现在在那个

873
00:22:47,000 --> 00:22:49,000
iOS 11 的预览

874
00:22:49,000 --> 00:22:50,000
那个就是什么

875
00:22:50,000 --> 00:22:51,000
Beta 版里面

876
00:22:51,000 --> 00:22:52,000
应该已经可以看得到了吧

877
00:22:52,000 --> 00:22:54,000
你们装了吗

878
00:22:54,000 --> 00:22:55,000
我在 iPad 上装了

879
00:22:55,000 --> 00:22:56,000
但还没注意到

880
00:22:56,000 --> 00:22:58,000
看那个表情

881
00:22:58,000 --> 00:23:00,000
那个 emoji 的变化

882
00:23:00,000 --> 00:23:02,000
好像还没吧

883
00:23:02,000 --> 00:23:03,000
我没装

884
00:23:03,000 --> 00:23:04,000
我没装

885
00:23:04,000 --> 00:23:05,000
我也没装

886
00:23:05,000 --> 00:23:07,000
但好像还没上吧

887
00:23:07,000 --> 00:23:09,000
它上了一个叫做

888
00:23:09,000 --> 00:23:10,000
Public Beta

889
00:23:10,000 --> 00:23:11,000
上了两次了

890
00:23:11,000 --> 00:23:11,000
对不是

891
00:23:11,000 --> 00:23:13,000
但 emoji 好像还没上

892
00:23:13,000 --> 00:23:13,000
巨不稳定

893
00:23:13,000 --> 00:23:15,000
我看好多人都说巨不稳定

894
00:23:15,000 --> 00:23:17,000
我在那个 iPad 上装的

895
00:23:17,000 --> 00:23:18,000
反正还行

896
00:23:18,000 --> 00:23:19,000
因为这次 iPad 感动比较大

897
00:23:19,000 --> 00:23:20,000
待会我们去看一下

898
00:23:20,000 --> 00:23:22,000
看那个 iPad 上有没有

899
00:23:22,000 --> 00:23:28,000
那现在就可以念

900
00:23:28,000 --> 00:23:31,000
另外一封听众反馈了是吧

901
00:23:31,000 --> 00:23:31,000
可以

902
00:23:31,000 --> 00:23:32,000
好

903
00:23:32,000 --> 00:23:34,000
我来念一下吧

904
00:23:34,000 --> 00:23:38,000
一位没有署名的听众

905
00:23:38,000 --> 00:23:39,000
后来我问了他

906
00:23:39,000 --> 00:23:40,000
我还专门写信

907
00:23:40,000 --> 00:23:41,000
所以问了他应该怎么称呼

908
00:23:41,000 --> 00:23:42,000
然后他说可以称呼

909
00:23:42,000 --> 00:23:43,000
他叫 Tiger

910
00:23:43,000 --> 00:23:44,000
老虎

911
00:23:44,000 --> 00:23:47,000
然后这位自称叫老虎的听众

912
00:23:47,000 --> 00:23:48,000
来了一封邮件

913
00:23:48,000 --> 00:23:51,000
说赞美主播并求解两个问题

914
00:23:51,000 --> 00:23:53,000
两位主播好

915
00:23:53,000 --> 00:23:54,000
他是写给自弹自唱的

916
00:23:54,000 --> 00:23:55,000
两位主播好

917
00:23:55,000 --> 00:23:57,000
我是一个通信工程毕业的马农

918
00:23:57,000 --> 00:23:59,000
具体来说是做 iOS 开发的

919
00:23:59,000 --> 00:24:00,000
大概一年前吧

920
00:24:00,000 --> 00:24:02,000
偶然机会发现了你们的播客

921
00:24:02,000 --> 00:24:03,000
一直听到现在

922
00:24:03,000 --> 00:24:05,000
很佩服你们的毅力

923
00:24:05,000 --> 00:24:06,000
能够持续更新

924
00:24:06,000 --> 00:24:07,000
超越了内核恐慌

925
00:24:07,000 --> 00:24:10,000
我是马农

926
00:24:10,000 --> 00:24:12,000
所以最开始听的是内核恐慌

927
00:24:12,000 --> 00:24:13,000
听你们播客过程中

928
00:24:13,000 --> 00:24:14,000
感觉我们很容易超越

929
00:24:14,000 --> 00:24:17,000
我受益匪浅

930
00:24:17,000 --> 00:24:19,000
知道任何东西都不是简简单单的

931
00:24:19,000 --> 00:24:20,000
一个设计作品

932
00:24:20,000 --> 00:24:22,000
或者具体到一个 UI 界面

933
00:24:22,000 --> 00:24:23,000
看起来很舒服

934
00:24:23,000 --> 00:24:25,000
一定是有其背后的道理

935
00:24:25,000 --> 00:24:26,000
我也看你们推荐的一些书籍

936
00:24:26,000 --> 00:24:27,000
做了一些笔记

937
00:24:27,000 --> 00:24:29,000
这里就不说了

938
00:24:29,000 --> 00:24:30,000
一直以来就想着

939
00:24:30,000 --> 00:24:33,000
就这样被你们润物细无声也挺好的

940
00:24:33,000 --> 00:24:35,000
但是我最近遇到了一些问题

941
00:24:35,000 --> 00:24:37,000
想得到你们的指教

942
00:24:37,000 --> 00:24:39,000
因为有个问题是偏计算机方面

943
00:24:39,000 --> 00:24:40,000
和字体没啥关系

944
00:24:40,000 --> 00:24:42,000
不知道提出来是不是很合适

945
00:24:42,000 --> 00:24:44,000
不过我觉得真与主播一定可以的

946
00:24:44,000 --> 00:24:45,000
其实真与主播不可以

947
00:24:45,000 --> 00:24:50,000
问题关于中西文混排时的高度

948
00:24:50,000 --> 00:24:53,000
在一个 label 上展示文字时

949
00:24:53,000 --> 00:24:54,000
最终展示的高度如何确定

950
00:24:54,000 --> 00:24:56,000
如果文字只有英文

951
00:24:56,000 --> 00:24:59,000
字号选择是 14 号字

952
00:24:59,000 --> 00:25:01,000
在两倍视网膜屏幕上

953
00:25:01,000 --> 00:25:02,000
那么最后文字的高度

954
00:25:02,000 --> 00:25:05,000
不会超过 28 pixel

955
00:25:05,000 --> 00:25:06,000
虽然它写的是 point

956
00:25:06,000 --> 00:25:07,000
我估计它是个比误

957
00:25:07,000 --> 00:25:09,000
这个高度应该等于

958
00:25:09,000 --> 00:25:11,000
深部线到降部线的高度

959
00:25:11,000 --> 00:25:13,000
如果文字只有中文

960
00:25:13,000 --> 00:25:13,000
那么类似

961
00:25:13,000 --> 00:25:16,000
最后文字的高度也不会超过 28 pixel

962
00:25:16,000 --> 00:25:19,000
虽然中文不一定有深部线和降部线

963
00:25:19,000 --> 00:25:20,000
但是原理是类似的

964
00:25:20,000 --> 00:25:22,000
如果是中英混排

965
00:25:22,000 --> 00:25:23,000
最后文字的高度会是怎样呢

966
00:25:23,000 --> 00:25:25,000
我问了我们的设计师

967
00:25:25,000 --> 00:25:28,000
说是会比 28 pixel 多出一到两个像素

968
00:25:28,000 --> 00:25:30,000
这是什么原因呢

969
00:25:30,000 --> 00:25:31,000
是因为中文和英文的基线

970
00:25:31,000 --> 00:25:32,000
没有对齐吗

971
00:25:32,000 --> 00:25:34,000
希望可以得到主播的解答

972
00:25:34,000 --> 00:25:35,000
问题二

973
00:25:35,000 --> 00:25:37,000
关于多元字不串的

974
00:25:37,000 --> 00:25:38,000
先回答一个再讲吧

975
00:25:38,000 --> 00:25:40,000
这个我给他写了一个邮件去

976
00:25:40,000 --> 00:25:43,000
说明了一下其中一些问题

977
00:25:43,000 --> 00:25:45,000
但是我觉得他对

978
00:25:45,000 --> 00:25:48,000
他们的设计师对整个渲染机制

979
00:25:48,000 --> 00:25:49,000
可能没有理解

980
00:25:49,000 --> 00:25:51,000
所以说的完全不着调

981
00:25:51,000 --> 00:25:54,000
我还简单来说一下

982
00:25:54,000 --> 00:25:55,000
首先就是说

983
00:25:55,000 --> 00:26:00,000
iOS 它维护了一套所谓的逻辑尺寸

984
00:26:00,000 --> 00:26:01,000
就逻辑布局的空间

985
00:26:01,000 --> 00:26:03,000
所以它的这个 point

986
00:26:03,000 --> 00:26:05,000
换算成一个 pixel 的值

987
00:26:05,000 --> 00:26:07,000
并不是一定 1 比 1

988
00:26:07,000 --> 00:26:07,000
1 比 2

989
00:26:07,000 --> 00:26:08,000
1 比 3

990
00:26:08,000 --> 00:26:10,000
或者是 1 比几点几的

991
00:26:10,000 --> 00:26:12,000
因为还有像 iPhone Plus 这样子

992
00:26:12,000 --> 00:26:13,000
奇葩的屏幕分辨率

993
00:26:13,000 --> 00:26:17,000
另外就是用户也可以调这个屏幕分辨率

994
00:26:17,000 --> 00:26:18,000
就一定成功

995
00:26:18,000 --> 00:26:19,000
叫那个什么 dynamic type

996
00:26:19,000 --> 00:26:22,000
就是它可以调这个缩放

997
00:26:22,000 --> 00:26:24,000
比如说你视力不好

998
00:26:24,000 --> 00:26:25,000
对对对

999
00:26:25,000 --> 00:26:27,000
所以你可以调这个

1000
00:26:27,000 --> 00:26:29,000
所以这个具体几倍几倍

1001
00:26:29,000 --> 00:26:31,000
其实是由操作系统来维护的

1002
00:26:31,000 --> 00:26:33,000
那么你只能使用一个逻辑的

1003
00:26:33,000 --> 00:26:34,000
这个 point 的这个值

1004
00:26:34,000 --> 00:26:37,000
这个值是 iOS 给开发者使用的

1005
00:26:37,000 --> 00:26:39,000
所以一个字符

1006
00:26:39,000 --> 00:26:40,000
当它被那个设定成

1007
00:26:40,000 --> 00:26:42,000
比如说 14 point 的时候

1008
00:26:42,000 --> 00:26:44,000
其实简单来说

1009
00:26:44,000 --> 00:26:47,000
我们用一个 typography unit 的概念来说

1010
00:26:47,000 --> 00:26:49,000
我们就是将一个 em 的尺寸

1011
00:26:49,000 --> 00:26:51,000
设成了 14 个 point

1012
00:26:51,000 --> 00:26:54,000
那么究竟一个 em 的 glyph

1013
00:26:54,000 --> 00:26:57,000
它的显示的这个尺寸是多少个 point

1014
00:26:57,000 --> 00:26:59,000
或者是具体的多少个 pixel

1015
00:26:59,000 --> 00:27:01,000
其实完全是由字体来决定的

1016
00:27:01,000 --> 00:27:02,000
你可以将一个 em 的 glyph

1017
00:27:02,000 --> 00:27:04,000
设计的只占一个像素那么大

1018
00:27:04,000 --> 00:27:09,000
你也可以设计的超过一个 em 的方格的空间

1019
00:27:09,000 --> 00:27:11,000
这都是没有问题的

1020
00:27:11,000 --> 00:27:14,000
所以具体渲染存多少个像素

1021
00:27:14,000 --> 00:27:15,000
或者多少个 point

1022
00:27:15,000 --> 00:27:17,000
完全是由这个字体来决定的

1023
00:27:17,000 --> 00:27:19,000
就跟其他的没有任何关系

1024
00:27:19,000 --> 00:27:21,000
就像你选 Zapfino

1025
00:27:21,000 --> 00:27:22,000
Zapfino

1026
00:27:22,000 --> 00:27:24,000
你选一个 14 号的 Zapfino

1027
00:27:24,000 --> 00:27:29,000
最终渲染出来的一个单词

1028
00:27:29,000 --> 00:27:31,000
可能会占 100 x 200 这么大

1029
00:27:31,000 --> 00:27:33,000
这都是有可能的

1030
00:27:33,000 --> 00:27:35,000
对比如说它的 f 就会非常的高

1031
00:27:35,000 --> 00:27:36,000
有一个非常长的降步

1032
00:27:36,000 --> 00:27:40,000
然后他问那个问题

1033
00:27:40,000 --> 00:27:42,000
其实我理解是不是之前也遇到过

1034
00:27:42,000 --> 00:27:44,000
就是以前你们记不记得

1035
00:27:44,000 --> 00:27:46,000
那个 macOS 的那个 text edit 那个程序

1036
00:27:46,000 --> 00:27:48,000
它会跳舞

1037
00:27:48,000 --> 00:27:50,000
对它的那个中英文混排的时候

1038
00:27:50,000 --> 00:27:51,000
那个航高是有问题的

1039
00:27:51,000 --> 00:27:54,000
它不一致就不稳定

1040
00:27:54,000 --> 00:27:55,000
应该是这个问题

1041
00:27:55,000 --> 00:27:58,000
这个问题当时好像

1042
00:27:58,000 --> 00:27:59,000
我们也讲过好像

1043
00:27:59,000 --> 00:28:00,000
对对对

1044
00:28:00,000 --> 00:28:01,000
它有个问题就是说

1045
00:28:01,000 --> 00:28:02,000
当时的 text edit

1046
00:28:02,000 --> 00:28:04,000
好像是以整个文档的

1047
00:28:04,000 --> 00:28:06,000
第一个字符的那个

1048
00:28:06,000 --> 00:28:08,000
font 来决定

1049
00:28:08,000 --> 00:28:10,000
这个文档的航高是多少的

1050
00:28:10,000 --> 00:28:11,000
但是你在这个输入的

1051
00:28:11,000 --> 00:28:13,000
这个 fly 的过程中

1052
00:28:13,000 --> 00:28:15,000
就是这个 input fly 的过程中

1053
00:28:15,000 --> 00:28:17,000
它好像又会动态的去调用

1054
00:28:17,000 --> 00:28:20,000
当前这个 glyph 的 font 来计算

1055
00:28:20,000 --> 00:28:22,000
当前这个光标所在位置的航高

1056
00:28:22,000 --> 00:28:25,000
所以如果说你是一个多语言

1057
00:28:25,000 --> 00:28:26,000
对对对就会有条件

1058
00:28:26,000 --> 00:28:28,000
但现在好像这个问题被改善了吧

1059
00:28:28,000 --> 00:28:30,000
它会预设一个比较大的

1060
00:28:30,000 --> 00:28:31,000
现在已经修复吧

1061
00:28:31,000 --> 00:28:33,000
我最近好像没有注意到这个问题了

1062
00:28:33,000 --> 00:28:34,000
就再没出现过了

1063
00:28:34,000 --> 00:28:37,000
对已经修复了

1064
00:28:37,000 --> 00:28:39,000
那他问那个

1065
00:28:39,000 --> 00:28:40,000
就中文和英文这个基线

1066
00:28:40,000 --> 00:28:41,000
没有对齐

1067
00:28:41,000 --> 00:28:42,000
这个事情是可能发生的吗

1068
00:28:42,000 --> 00:28:44,000
还是说没有这个事

1069
00:28:44,000 --> 00:28:45,000
对

1070
00:28:45,000 --> 00:28:46,000
这是排排眼前来决定的

1071
00:28:46,000 --> 00:28:50,000
就中文你可以说是要它的基线来跟

1072
00:28:50,000 --> 00:28:51,000
不对

1073
00:28:51,000 --> 00:28:57,000
是用中文字框的底线和英文的基线对齐

1074
00:28:57,000 --> 00:29:03,000
还是用中文现框的底线和英文现框的底线对齐

1075
00:29:03,000 --> 00:29:11,000
还是用中文现框的上顶端和英文的上升部的顶端对齐

1076
00:29:11,000 --> 00:29:11,000
这是很多

1077
00:29:11,000 --> 00:29:12,000
所以这其中有什么

1078
00:29:12,000 --> 00:29:14,000
就是我听出这个区别了

1079
00:29:14,000 --> 00:29:17,000
就是说我们日常采取的一般是这种方式呢

1080
00:29:17,000 --> 00:29:19,000
一般是基线对底下

1081
00:29:19,000 --> 00:29:19,000
我理解

1082
00:29:19,000 --> 00:29:20,000
不是

1083
00:29:20,000 --> 00:29:22,000
一般是基线对基线

1084
00:29:22,000 --> 00:29:23,000
对

1085
00:29:23,000 --> 00:29:25,000
就是说在正常的

1086
00:29:25,000 --> 00:29:28,000
哪怕是中文或者汉字的字体设计里面

1087
00:29:28,000 --> 00:29:29,000
现在呢

1088
00:29:29,000 --> 00:29:31,000
就是真正的 Font 也会画一个基线

1089
00:29:31,000 --> 00:29:33,000
虽然说基线也是给西文设计的

1090
00:29:33,000 --> 00:29:34,000
但是呢

1091
00:29:34,000 --> 00:29:36,000
就是说中文设计首先是有个字框嘛

1092
00:29:36,000 --> 00:29:39,000
但是现在的现代字体都会在字框上面再补一个基线

1093
00:29:39,000 --> 00:29:41,000
因为不管怎么样

1094
00:29:41,000 --> 00:29:44,000
操作系统的话都是以基线来对齐的

1095
00:29:44,000 --> 00:29:45,000
像无论是 Font

1096
00:29:45,000 --> 00:29:47,000
是很多排版引擎

1097
00:29:47,000 --> 00:29:49,000
还有很多 Web 都是这样

1098
00:29:49,000 --> 00:29:53,000
它只去调用这个一个 Font 里面的基线

1099
00:29:53,000 --> 00:29:54,000
所以呢

1100
00:29:54,000 --> 00:29:56,000
它即使是中文字体

1101
00:29:56,000 --> 00:29:57,000
它也会设成一个基线

1102
00:29:57,000 --> 00:30:00,000
然后在很多的中文日文字体

1103
00:30:00,000 --> 00:30:01,000
比如说大家会默认

1104
00:30:01,000 --> 00:30:04,000
中文的方框是

1105
00:30:04,000 --> 00:30:05,000
那个字框是 10001000 嘛

1106
00:30:05,000 --> 00:30:07,000
的一个正方形的话

1107
00:30:07,000 --> 00:30:11,000
一般来讲会把这个基线放在 120 左右

1108
00:30:11,000 --> 00:30:14,000
就是底下 120 上面 880

1109
00:30:14,000 --> 00:30:16,000
就是放在这样一个位置

1110
00:30:16,000 --> 00:30:17,000
然后呢

1111
00:30:17,000 --> 00:30:18,000
排版引擎的话

1112
00:30:18,000 --> 00:30:19,000
不管你是中文还是西文

1113
00:30:19,000 --> 00:30:22,000
它都会去调用你这个 Font 里面

1114
00:30:22,000 --> 00:30:25,000
Matrix 里面的这个基线的位置

1115
00:30:25,000 --> 00:30:27,000
它是按基线对积的

1116
00:30:27,000 --> 00:30:28,000
无论你这个是阿拉伯文

1117
00:30:28,000 --> 00:30:31,000
还是印度的天成文

1118
00:30:31,000 --> 00:30:33,000
还是中文的汉字

1119
00:30:33,000 --> 00:30:35,000
它们都有一个基线的值

1120
00:30:35,000 --> 00:30:37,000
所以那个印度天成文

1121
00:30:37,000 --> 00:30:39,000
就是天成文的那个基线在哪

1122
00:30:39,000 --> 00:30:41,000
是在靠下的位置还是

1123
00:30:41,000 --> 00:30:44,000
天成文它本身的基线

1124
00:30:44,000 --> 00:30:44,000
它是憨音

1125
00:30:44,000 --> 00:30:46,000
它是挂在上面的

1126
00:30:46,000 --> 00:30:47,000
但是呢

1127
00:30:47,000 --> 00:30:49,000
但是它为了混排的话

1128
00:30:49,000 --> 00:30:49,000
它也有

1129
00:30:49,000 --> 00:30:51,000
它也在事先

1130
00:30:51,000 --> 00:30:54,000
自己设计是要设一个基线

1131
00:30:54,000 --> 00:30:55,000
虽然它不用

1132
00:30:55,000 --> 00:30:56,000
名字叫什么呢

1133
00:30:56,000 --> 00:30:57,000
是叫 baseline

1134
00:30:57,000 --> 00:30:58,000
就是叫 baseline

1135
00:30:58,000 --> 00:30:58,000
就是叫 baseline

1136
00:30:58,000 --> 00:31:00,000
然后那它本身的那条 hung line

1137
00:31:00,000 --> 00:31:01,000
叫什么

1138
00:31:01,000 --> 00:31:02,000
叫叫 hung line

1139
00:31:02,000 --> 00:31:02,000
还是

1140
00:31:02,000 --> 00:31:04,000
那个有听成文

1141
00:31:04,000 --> 00:31:05,000
他们自己的名字

1142
00:31:05,000 --> 00:31:05,000
对

1143
00:31:05,000 --> 00:31:06,000
OK

1144
00:31:06,000 --> 00:31:06,000
就是

1145
00:31:06,000 --> 00:31:09,000
Open Type 里面

1146
00:31:09,000 --> 00:31:10,000
有一个 table 就叫 base

1147
00:31:10,000 --> 00:31:12,000
就是 base 这个 table

1148
00:31:12,000 --> 00:31:13,000
就是描述的

1149
00:31:13,000 --> 00:31:15,000
你这条 baseline 的位置

1150
00:31:15,000 --> 00:31:17,000
在这个原始坐标 00

1151
00:31:17,000 --> 00:31:19,000
跟它相对的这个位置在哪里

1152
00:31:19,000 --> 00:31:22,000
其实它默认就在 00 这个位置上了

1153
00:31:22,000 --> 00:31:25,000
那么那个你在设一个中文字体的时候呢

1154
00:31:25,000 --> 00:31:27,000
你可以将你的这个起点

1155
00:31:27,000 --> 00:31:29,000
比如说设在零负多少多少

1156
00:31:29,000 --> 00:31:30,000
比如说负 120

1157
00:31:30,000 --> 00:31:32,000
这个是 Adobe 常用的一个数字

1158
00:31:32,000 --> 00:31:34,000
那么 monotype 可能会有什么负 110 之类的

1159
00:31:34,000 --> 00:31:35,000
就每个自己厂商

1160
00:31:35,000 --> 00:31:38,000
他们都会有他自己的 convention 来做这个事情

1161
00:31:38,000 --> 00:31:39,000
所以呢

1162
00:31:39,000 --> 00:31:42,000
其实这个就是一个普通的字体文件里面

1163
00:31:42,000 --> 00:31:43,000
它 metrics

1164
00:31:43,000 --> 00:31:44,000
我们叫度量或者量度

1165
00:31:44,000 --> 00:31:45,000
它的一个设置

1166
00:31:45,000 --> 00:31:47,000
就自己设计是必须要设置的

1167
00:31:47,000 --> 00:31:50,000
然后再由排版引擎去调用

1168
00:31:50,000 --> 00:31:51,000
OK

1169
00:31:51,000 --> 00:31:55,000
所以就其实不会出现这个中文英文

1170
00:31:55,000 --> 00:31:57,000
他问的这个中文和英文基线

1171
00:31:57,000 --> 00:31:58,000
没对齐的情况对吧

1172
00:31:58,000 --> 00:32:01,000
这个好像还是可以改的吧

1173
00:32:01,000 --> 00:32:02,000
就是比如是像我说的

1174
00:32:02,000 --> 00:32:04,000
你可以强行说在这个排版的时候

1175
00:32:04,000 --> 00:32:07,000
或者说在这个 label 里面

1176
00:32:07,000 --> 00:32:10,000
让所有字符底端对齐

1177
00:32:10,000 --> 00:32:11,000
这个还是可以做到的

1178
00:32:11,000 --> 00:32:12,000
可以的

1179
00:32:12,000 --> 00:32:13,000
如果你强行要这么设的话

1180
00:32:13,000 --> 00:32:14,000
还是可能的

1181
00:32:14,000 --> 00:32:17,000
因为像那个 CSS 里面

1182
00:32:17,000 --> 00:32:18,000
就是有这个一个

1183
00:32:18,000 --> 00:32:20,000
这个基线对齐的概念

1184
00:32:20,000 --> 00:32:22,000
当然它应该没有区分这个多元文本

1185
00:32:22,000 --> 00:32:25,000
它是整个和那个图片的对齐

1186
00:32:25,000 --> 00:32:25,000
那想来

1187
00:32:25,000 --> 00:32:28,000
如果一个比较高级的排版引擎

1188
00:32:28,000 --> 00:32:30,000
应该也是可以允许做这种

1189
00:32:30,000 --> 00:32:32,000
比较非标准的操作吧

1190
00:32:32,000 --> 00:32:34,000
如果是印刷方面的话

1191
00:32:34,000 --> 00:32:35,000
比如说 indesign 的话

1192
00:32:35,000 --> 00:32:37,000
这个特别

1193
00:32:37,000 --> 00:32:38,000
尤其是中西文混白

1194
00:32:38,000 --> 00:32:40,000
比如在做复合字体的时候

1195
00:32:40,000 --> 00:32:41,000
就可以做基线偏移

1196
00:32:41,000 --> 00:32:42,000
而且呢

1197
00:32:42,000 --> 00:32:45,000
在更以广的范围来讲

1198
00:32:45,000 --> 00:32:47,000
比如说把一个数字

1199
00:32:47,000 --> 00:32:48,000
做成上标或者下标

1200
00:32:48,000 --> 00:32:51,000
这其实也是一种基线偏移

1201
00:32:51,000 --> 00:32:54,000
就是在不同的环境下

1202
00:32:54,000 --> 00:32:56,000
不同的排版引擎

1203
00:32:56,000 --> 00:32:57,000
都是有这样的功能的

1204
00:32:57,000 --> 00:32:59,000
那具体在 CSS 的话

1205
00:32:59,000 --> 00:33:00,000
是另外的实现吧

1206
00:33:00,000 --> 00:33:01,000
对吧

1207
00:33:01,000 --> 00:33:03,000
对 CSS 它是这样的

1208
00:33:03,000 --> 00:33:05,000
就是它的机制比较麻烦

1209
00:33:05,000 --> 00:33:10,000
它有一个所谓的 linebox 和 inlinebox 的概念

1210
00:33:10,000 --> 00:33:12,000
所以就是当它放在盒子里面

1211
00:33:12,000 --> 00:33:17,000
对它会把一个行内的一小段字符串

1212
00:33:17,000 --> 00:33:20,000
计算它一个很小的一个矩形

1213
00:33:20,000 --> 00:33:22,000
然后矩形的这个高度会有一个高度

1214
00:33:22,000 --> 00:33:24,000
然后基线会在这个矩形内部的

1215
00:33:24,000 --> 00:33:25,000
一个相对位置里面

1216
00:33:25,000 --> 00:33:28,000
然后这个时候 CSS 的那个

1217
00:33:28,000 --> 00:33:30,000
vertical align 这个属性

1218
00:33:30,000 --> 00:33:32,000
这个 property 里面设了几种值

1219
00:33:32,000 --> 00:33:34,000
就会来决定这个基线之间

1220
00:33:34,000 --> 00:33:35,000
相互对齐的关系

1221
00:33:35,000 --> 00:33:37,000
但这个 vertical align 的这个属性

1222
00:33:37,000 --> 00:33:38,000
非常的不直观

1223
00:33:38,000 --> 00:33:39,000
就这是

1224
00:33:39,000 --> 00:33:41,000
我觉得这是 CSS 设计的一个缺陷吧

1225
00:33:41,000 --> 00:33:43,000
就是对于入门者来说

1226
00:33:43,000 --> 00:33:44,000
你很难

1227
00:33:44,000 --> 00:33:45,000
很难去直观的感受到

1228
00:33:45,000 --> 00:33:47,000
你做了哪些对齐

1229
00:33:47,000 --> 00:33:48,000
因为你有的时候

1230
00:33:48,000 --> 00:33:49,000
选 middle 对齐的时候

1231
00:33:49,000 --> 00:33:50,000
你发现

1232
00:33:50,000 --> 00:33:52,000
它其实并不是你预期的那种 middle 的方式

1233
00:33:52,000 --> 00:33:55,000
它是以它定义的那种 middle 的方式

1234
00:33:55,000 --> 00:33:58,000
然后 baseline 是默认的一种对齐方式

1235
00:33:58,000 --> 00:33:59,000
对

1236
00:33:59,000 --> 00:34:01,000
这个还和字体有关系吧

1237
00:34:01,000 --> 00:34:03,000
CSS 它会比较简单

1238
00:34:03,000 --> 00:34:08,000
它会对一段文字使用同一种字体的这个参数

1239
00:34:08,000 --> 00:34:09,000
来计算这个

1240
00:34:09,000 --> 00:34:14,000
这个 linebox 的高度的这样一个属性

1241
00:34:14,000 --> 00:34:14,000
对

1242
00:34:14,000 --> 00:34:16,000
但是这个 linebox 的高度

1243
00:34:16,000 --> 00:34:18,000
它算起来就不是很准

1244
00:34:18,000 --> 00:34:20,000
它也不是在所有地方都很准的

1245
00:34:20,000 --> 00:34:23,000
而且它首先它会调用

1246
00:34:23,000 --> 00:34:26,000
就是因为如果你是调用一个中文字体的话

1247
00:34:26,000 --> 00:34:28,000
中文字体内部也有西文嘛

1248
00:34:28,000 --> 00:34:31,000
就首先它会调用一个字体设计师

1249
00:34:31,000 --> 00:34:34,000
它本身设定好的就是中西文的那个机械

1250
00:34:34,000 --> 00:34:36,000
就这个因为这个你调用的字体

1251
00:34:36,000 --> 00:34:39,000
本身是有这个有这个信息的

1252
00:34:39,000 --> 00:34:41,000
然后它要拿到这个信息以后

1253
00:34:41,000 --> 00:34:43,000
在这个信息再继续调整吗

1254
00:34:43,000 --> 00:34:44,000
对

1255
00:34:44,000 --> 00:34:46,000
但 CSS 有个问题

1256
00:34:46,000 --> 00:34:50,000
就是说它在计算一个 linebox 的这个高度的时候

1257
00:34:50,000 --> 00:34:54,000
它默认是按 CSS 设定的那个 lineheight 的那个数值来计算的

1258
00:34:54,000 --> 00:34:55,000
对

1259
00:34:55,000 --> 00:34:59,000
但这个 lineheight 的值未必跟字体设计师定义的那个

1260
00:34:59,000 --> 00:35:01,000
默认的 lineheight 是一样的

1261
00:35:01,000 --> 00:35:03,000
所以这个时候机械应该放在什么位置

1262
00:35:03,000 --> 00:35:05,000
其实是有一点问题的

1263
00:35:05,000 --> 00:35:06,000
有的时候社会出 bug 的

1264
00:35:06,000 --> 00:35:11,000
lineheight 的话就是我们说中文就是行高嘛

1265
00:35:11,000 --> 00:35:12,000
对

1266
00:35:12,000 --> 00:35:14,000
那大家也知道 CSS 里面行高的话

1267
00:35:14,000 --> 00:35:18,000
它是要把行间距除以二

1268
00:35:18,000 --> 00:35:21,000
一半放上面一半放下面

1269
00:35:21,000 --> 00:35:21,000
对对对

1270
00:35:21,000 --> 00:35:22,000
那个盒子的

1271
00:35:22,000 --> 00:35:25,000
对所以这个盒子是怎么怎么算的

1272
00:35:25,000 --> 00:35:27,000
可是比较麻烦的一件事

1273
00:35:27,000 --> 00:35:31,000
对特别是你多种字体混合组合的时候

1274
00:35:31,000 --> 00:35:32,000
会有些问题

1275
00:35:32,000 --> 00:35:33,000
不同字体

1276
00:35:33,000 --> 00:35:35,000
而且是不同字号的时候会非常麻烦

1277
00:35:35,000 --> 00:35:37,000
对

1278
00:35:37,000 --> 00:35:39,000
OK

1279
00:35:39,000 --> 00:35:42,000
他他问了第二个问题啊

1280
00:35:42,000 --> 00:35:44,000
是关于这个多语言字符串

1281
00:35:44,000 --> 00:35:47,000
关于多语言字符串的排序和所以

1282
00:35:47,000 --> 00:35:48,000
这个要讲吗

1283
00:35:48,000 --> 00:35:51,000
这个是不是跟今天我们要说的有点关系

1284
00:35:51,000 --> 00:35:52,000
有点关系

1285
00:35:52,000 --> 00:35:53,000
或者说

1286
00:35:53,000 --> 00:35:57,000
要不我们等到后面专门一起来讲的排序

1287
00:35:57,000 --> 00:35:58,000
因为

1288
00:35:58,000 --> 00:36:00,000
对要不我们就先念一下他这个邮件吧

1289
00:36:00,000 --> 00:36:02,000
就答不答再说了

1290
00:36:02,000 --> 00:36:05,000
如今是多元国际化的时代

1291
00:36:05,000 --> 00:36:07,000
多元字符串排序和索引的规则是什么呢

1292
00:36:07,000 --> 00:36:10,000
iPhone 通讯录中姓名的排序规则是什么呢

1293
00:36:10,000 --> 00:36:11,000
对于整个问题

1294
00:36:11,000 --> 00:36:13,000
我自己也做了一些研究

1295
00:36:13,000 --> 00:36:16,000
大致是 Unical 给出了一套规则

1296
00:36:16,000 --> 00:36:18,000
根据这个规则来实现就好了

1297
00:36:18,000 --> 00:36:20,000
但是 Unical 的文档

1298
00:36:20,000 --> 00:36:22,000
卷纸好凡吗

1299
00:36:22,000 --> 00:36:24,000
这是卷纸

1300
00:36:24,000 --> 00:36:25,000
我实在无能够

1301
00:36:25,000 --> 00:36:26,000
卷一

1302
00:36:26,000 --> 00:36:29,000
这是卷纸字吗

1303
00:36:29,000 --> 00:36:30,000
就纸吧

1304
00:36:30,000 --> 00:36:31,000
纸

1305
00:36:31,000 --> 00:36:31,000
对

1306
00:36:31,000 --> 00:36:32,000
卷纸

1307
00:36:32,000 --> 00:36:33,000
卷纸

1308
00:36:33,000 --> 00:36:33,000
卷纸

1309
00:36:33,000 --> 00:36:34,000
卷纸

1310
00:36:34,000 --> 00:36:34,000
卷纸

1311
00:36:34,000 --> 00:36:35,000
卷纸

1312
00:36:35,000 --> 00:36:38,000
各位主播暴露了自己的文化修养

1313
00:36:38,000 --> 00:36:38,000
对

1314
00:36:38,000 --> 00:36:39,000
深调念错了

1315
00:36:39,000 --> 00:36:41,000
我实在无能为力完全搞懂

1316
00:36:41,000 --> 00:36:43,000
我自己总结了一点东西

1317
00:36:43,000 --> 00:36:44,000
写了三篇文章放在博客上

1318
00:36:44,000 --> 00:36:46,000
希望可以得到两位主播的指点

1319
00:36:46,000 --> 00:36:49,000
同时我自己也有一点问题没有搞明白

1320
00:36:49,000 --> 00:36:49,000
第一

1321
00:36:49,000 --> 00:36:52,000
索引识指定的排序规则是什么呢

1322
00:36:52,000 --> 00:36:53,000
似乎是按照平音

1323
00:36:53,000 --> 00:36:55,000
但是中文和英文交织

1324
00:36:55,000 --> 00:36:56,000
并不一定中文

1325
00:36:56,000 --> 00:36:58,000
并不是中文一定在英文前面或者后面

1326
00:36:58,000 --> 00:37:00,000
怎样得到每一个汉字的读音呢

1327
00:37:00,000 --> 00:37:03,000
在指定汉字顺势的

1328
00:37:03,000 --> 00:37:06,000
zh.xml

1329
00:37:06,000 --> 00:37:07,000
这是一个文件

1330
00:37:07,000 --> 00:37:10,000
汉字读音在

1331
00:37:10,000 --> 00:37:11,000
在警号之后

1332
00:37:11,000 --> 00:37:13,000
似乎是被注视掉了

1333
00:37:13,000 --> 00:37:14,000
那么怎么知道汉字的读音呢

1334
00:37:14,000 --> 00:37:15,000
具体来说

1335
00:37:15,000 --> 00:37:16,000
左边的读音是

1336
00:37:16,000 --> 00:37:17,000
左边

1337
00:37:17,000 --> 00:37:19,000
它写的是一个拼音的左边

1338
00:37:19,000 --> 00:37:21,000
是怎么被确定的呢

1339
00:37:21,000 --> 00:37:23,000
这个问题和字体排音没啥关系

1340
00:37:23,000 --> 00:37:26,000
和你们做的 unicode 串台节目有那么一点点关系

1341
00:37:26,000 --> 00:37:27,000
所以希望可以得到解答

1342
00:37:27,000 --> 00:37:30,000
这个问题已经困扰我好久好久了

1343
00:37:30,000 --> 00:37:31,000
呃

1344
00:37:31,000 --> 00:37:35,000
他应该是拿了一个什么 database 来做这个排序吧

1345
00:37:35,000 --> 00:37:36,000
不

1346
00:37:36,000 --> 00:37:38,000
这个事比较复杂

1347
00:37:38,000 --> 00:37:39,000
那个 iPhone 的那个通讯

1348
00:37:39,000 --> 00:37:40,000
就 iOS 通讯路上面

1349
00:37:40,000 --> 00:37:42,000
它有一个这个机制

1350
00:37:42,000 --> 00:37:42,000
就可能很多

1351
00:37:42,000 --> 00:37:44,000
iPhone 上我不知道有没有办法添加

1352
00:37:44,000 --> 00:37:47,000
在 Mac 上是可以给那个联系人的名字

1353
00:37:47,000 --> 00:37:49,000
叫加一个叫做 Fonetic

1354
00:37:49,000 --> 00:37:50,000
对

1355
00:37:50,000 --> 00:37:50,000
对

1356
00:37:50,000 --> 00:37:50,000
对

1357
00:37:50,000 --> 00:37:52,000
这也是我想说的

1358
00:37:52,000 --> 00:37:52,000
对

1359
00:37:52,000 --> 00:37:54,000
他除了他有一个 Fonetic

1360
00:37:54,000 --> 00:37:56,000
还有一个另外一个注音

1361
00:37:56,000 --> 00:37:58,000
就除了 Fonetic 之外

1362
00:37:58,000 --> 00:37:59,000
还有另外一个注音

1363
00:37:59,000 --> 00:38:00,000
我忘了叫什么了

1364
00:38:00,000 --> 00:38:01,000
暂时

1365
00:38:01,000 --> 00:38:02,000
嗯

1366
00:38:02,000 --> 00:38:02,000
嗯

1367
00:38:02,000 --> 00:38:03,000
然后这两个可以

1368
00:38:03,000 --> 00:38:06,000
这两个可以拿来做排序的依据

1369
00:38:06,000 --> 00:38:07,000
但是

1370
00:38:07,000 --> 00:38:10,000
排序的时候的那个

1371
00:38:10,000 --> 00:38:12,000
比如说你用中文

1372
00:38:12,000 --> 00:38:14,000
就是你把系统设成中文的时候

1373
00:38:14,000 --> 00:38:16,000
排序规则跟设成英文的时候

1374
00:38:16,000 --> 00:38:17,000
排序规则是不一样的

1375
00:38:17,000 --> 00:38:18,000
嗯

1376
00:38:18,000 --> 00:38:20,000
那哪怕你设成中文

1377
00:38:20,000 --> 00:38:22,000
也可以用不同的排序

1378
00:38:22,000 --> 00:38:24,000
比如如果大家用 Mac 的话

1379
00:38:24,000 --> 00:38:24,000
这个放

1380
00:38:24,000 --> 00:38:26,000
打开那个系统批号设置呢

1381
00:38:26,000 --> 00:38:28,000
语言的语言地区那边

1382
00:38:28,000 --> 00:38:31,000
就专门有一个列表排列顺序的一个设置

1383
00:38:31,000 --> 00:38:34,000
然后中文默认是拼音顺序

1384
00:38:34,000 --> 00:38:36,000
但是中文中文你也可以用

1385
00:38:36,000 --> 00:38:37,000
比如说你用呃

1386
00:38:37,000 --> 00:38:39,000
笔画顺序也可以

1387
00:38:39,000 --> 00:38:42,000
用 Gb 的那个那个内码的顺序也可以

1388
00:38:42,000 --> 00:38:42,000
对

1389
00:38:42,000 --> 00:38:45,000
但是在在手机上面有这个设置吗

1390
00:38:45,000 --> 00:38:46,000
呃

1391
00:38:46,000 --> 00:38:48,000
跟你的语言环境有也有关系

1392
00:38:48,000 --> 00:38:51,000
就我的理解是在用那个

1393
00:38:51,000 --> 00:38:53,000
你就比如说你在

1394
00:38:53,000 --> 00:38:56,000
Mac 上面可以说我的系统语言是英语

1395
00:38:56,000 --> 00:38:58,000
但是呃

1396
00:38:58,000 --> 00:39:00,000
我的第三 prefered language 是中文

1397
00:39:00,000 --> 00:39:02,000
与此同时呃

1398
00:39:02,000 --> 00:39:02,000
呃

1399
00:39:02,000 --> 00:39:04,000
那个我要我可以把那个

1400
00:39:04,000 --> 00:39:07,000
那个 list source order 设成中文的

1401
00:39:07,000 --> 00:39:10,000
比如说笔画排序或者是注音排序

1402
00:39:10,000 --> 00:39:11,000
但是在 iPhone 上

1403
00:39:11,000 --> 00:39:13,000
iPhone 上是没有这个设定的

1404
00:39:13,000 --> 00:39:15,000
就是你不能说系统语言是中文

1405
00:39:15,000 --> 00:39:17,000
系统语言是英文同时

1406
00:39:17,000 --> 00:39:19,000
你还可以指定中文的排序方式

1407
00:39:19,000 --> 00:39:22,000
就是我以前在推上跟

1408
00:39:22,000 --> 00:39:23,000
好像是跟经纬啊

1409
00:39:23,000 --> 00:39:25,000
还是谁去去研究过这个问题

1410
00:39:25,000 --> 00:39:28,000
就是他想说呃

1411
00:39:28,000 --> 00:39:30,000
手机的系统是英文的同时

1412
00:39:30,000 --> 00:39:33,000
还可以让呃通讯录按照中文的

1413
00:39:33,000 --> 00:39:35,000
笔画数去排序好像是

1414
00:39:35,000 --> 00:39:38,000
但后来发现这个其实做不到的

1415
00:39:38,000 --> 00:39:39,000
就是呃

1416
00:39:39,000 --> 00:39:41,000
当时我产生的一个状态是

1417
00:39:41,000 --> 00:39:43,000
我先把手机设成中文

1418
00:39:43,000 --> 00:39:45,000
然后发现通讯录被用

1419
00:39:45,000 --> 00:39:50,000
中文 iOS 的默认通讯录排序是什么来着

1420
00:39:50,000 --> 00:39:51,000
是注音

1421
00:39:51,000 --> 00:39:51,000
拼音吧

1422
00:39:51,000 --> 00:39:53,000
拼音应该是拼音

1423
00:39:53,000 --> 00:39:53,000
OK

1424
00:39:53,000 --> 00:39:57,000
然后然后当我切换回英文系统的时候

1425
00:39:57,000 --> 00:39:59,000
这个排序是得以保留的

1426
00:39:59,000 --> 00:40:00,000
但是嗯

1427
00:40:00,000 --> 00:40:03,000
只要我们往里面新加一个通讯录的

1428
00:40:03,000 --> 00:40:05,000
只要我们往里面新加一个通讯录的

1429
00:40:05,000 --> 00:40:08,000
整个排序就又变成了呃

1430
00:40:08,000 --> 00:40:08,000
英文排序

1431
00:40:08,000 --> 00:40:12,000
然后所有的中文会被集中堆在后面

1432
00:40:12,000 --> 00:40:13,000
除非你设定了那个

1433
00:40:13,000 --> 00:40:14,000
啊

1434
00:40:14,000 --> 00:40:15,000
呃

1435
00:40:15,000 --> 00:40:15,000
呃

1436
00:40:15,000 --> 00:40:16,000
词呃

1437
00:40:16,000 --> 00:40:17,000
呃

1438
00:40:17,000 --> 00:40:17,000
呃

1439
00:40:17,000 --> 00:40:17,000
呃

1440
00:40:17,000 --> 00:40:18,000
呃

1441
00:40:18,000 --> 00:40:19,000
呃

1442
00:40:19,000 --> 00:40:20,000
呃

1443
00:40:20,000 --> 00:40:21,000
呃

1444
00:40:21,000 --> 00:40:21,000
呃

1445
00:40:21,000 --> 00:40:22,000
我的情况哈

1446
00:40:22,000 --> 00:40:25,000
我的 iPhone 是设置成日文状态的

1447
00:40:25,000 --> 00:40:26,000
然后呢

1448
00:40:26,000 --> 00:40:29,000
所以我打开我的那个通讯录的时候呢

1449
00:40:29,000 --> 00:40:32,000
因为日文状态它会默认用那首先日文排序嘛

1450
00:40:32,000 --> 00:40:33,000
呃

1451
00:40:33,000 --> 00:40:33,000
呃

1452
00:40:33,000 --> 00:40:34,000
首先右边那个 index

1453
00:40:34,000 --> 00:40:38,000
右边不是一个快速的可以转播那个 index 吗

1454
00:40:38,000 --> 00:40:39,000
如果是这样的话

1455
00:40:39,000 --> 00:40:40,000
在日文状态的话

1456
00:40:40,000 --> 00:40:42,000
首先它会有日文的阿卡萨塔纳的顺序

1457
00:40:42,000 --> 00:40:44,000
然后后面还有 26 个字母的顺序

1458
00:40:44,000 --> 00:40:45,000
所以呢

1459
00:40:45,000 --> 00:40:46,000
在这样的状态

1460
00:40:46,000 --> 00:40:48,000
日文和那个英文首先是分开的

1461
00:40:48,000 --> 00:40:49,000
然后呢

1462
00:40:49,000 --> 00:40:50,000
呃

1463
00:40:50,000 --> 00:40:51,000
因为我系统默认是日文

1464
00:40:51,000 --> 00:40:52,000
所以首先呢

1465
00:40:52,000 --> 00:40:53,000
汉字呢

1466
00:40:53,000 --> 00:40:54,000
是按照那个日文顺序排的

1467
00:40:54,000 --> 00:40:56,000
呃

1468
00:40:56,000 --> 00:40:57,000
然后如果我

1469
00:40:57,000 --> 00:40:58,000
当然我这里面有中国朋友

1470
00:40:58,000 --> 00:41:02,000
我把中国朋友如果我不不加注音的话

1471
00:41:02,000 --> 00:41:06,000
它的中文汉字的是所有是堆在底下的

1472
00:41:06,000 --> 00:41:06,000
但是呢

1473
00:41:06,000 --> 00:41:07,000
如果

1474
00:41:07,000 --> 00:41:08,000
警号的那个

1475
00:41:08,000 --> 00:41:08,000
对

1476
00:41:08,000 --> 00:41:09,000
警号的

1477
00:41:09,000 --> 00:41:09,000
对

1478
00:41:09,000 --> 00:41:10,000
但是呢

1479
00:41:10,000 --> 00:41:11,000
如果我呃

1480
00:41:11,000 --> 00:41:14,000
因为这个注音这个字在日文是非常常见的

1481
00:41:14,000 --> 00:41:15,000
因为日本人的汉字

1482
00:41:15,000 --> 00:41:16,000
如果你不加读音

1483
00:41:16,000 --> 00:41:17,000
根本都不知道它怎么念

1484
00:41:17,000 --> 00:41:18,000
所以在一般来

1485
00:41:18,000 --> 00:41:19,000
对

1486
00:41:19,000 --> 00:41:21,000
它如果是开成日文以后

1487
00:41:21,000 --> 00:41:24,000
它会默认首先把那个注音的那个 field 打开

1488
00:41:24,000 --> 00:41:25,000
它会让你写

1489
00:41:25,000 --> 00:41:26,000
中文的话可能有时候

1490
00:41:26,000 --> 00:41:28,000
它它默认不打开

1491
00:41:28,000 --> 00:41:30,000
很多人都不知道有这样一个 field

1492
00:41:30,000 --> 00:41:30,000
啊

1493
00:41:30,000 --> 00:41:32,000
在你日文的话

1494
00:41:32,000 --> 00:41:33,000
那个 field 的默认是打开的

1495
00:41:33,000 --> 00:41:34,000
你可以往里面填那个

1496
00:41:34,000 --> 00:41:35,000
你这个词怎么念

1497
00:41:35,000 --> 00:41:36,000
然后呢

1498
00:41:36,000 --> 00:41:40,000
我个人的做法是把这个中文的名字把它拼音写上去

1499
00:41:40,000 --> 00:41:41,000
这样的话呢

1500
00:41:41,000 --> 00:41:43,000
在我的手机范围里面

1501
00:41:43,000 --> 00:41:45,000
日本人就在在假名那一堆

1502
00:41:45,000 --> 00:41:48,000
然后中国人就按照拼音放在这个 alphabet

1503
00:41:48,000 --> 00:41:49,000
这一堆

1504
00:41:49,000 --> 00:41:50,000
我个人是这样去分的

1505
00:41:50,000 --> 00:41:50,000
哦

1506
00:41:50,000 --> 00:41:52,000
还是这样非常好啊

1507
00:41:52,000 --> 00:41:54,000
但是很麻烦啊

1508
00:41:54,000 --> 00:41:55,000
你要每一个人

1509
00:41:55,000 --> 00:41:56,000
这是一个非常淡等的事情

1510
00:41:56,000 --> 00:41:57,000
对

1511
00:41:57,000 --> 00:41:58,000
对

1512
00:41:58,000 --> 00:42:00,000
所以在那个 Mac 上面

1513
00:42:00,000 --> 00:42:02,000
就是我们的朋友

1514
00:42:02,000 --> 00:42:03,000
就是江江

1515
00:42:03,000 --> 00:42:05,000
他之前写过一个小软件

1516
00:42:05,000 --> 00:42:11,000
就是自动给那个通讯录里面的中文名字的人标注他的那个 phonetic names

1517
00:42:11,000 --> 00:42:13,000
就是 phonetic 的信和名

1518
00:42:13,000 --> 00:42:15,000
就这样他就可以在应用环境下

1519
00:42:15,000 --> 00:42:19,000
还可以按照那个读音来排序

1520
00:42:20,000 --> 00:42:20,000
对

1521
00:42:20,000 --> 00:42:22,000
这件事情比较适合脚本来做

1522
00:42:22,000 --> 00:42:23,000
对

1523
00:42:23,000 --> 00:42:25,000
但 iPhone 上好像就这个我不知道有人

1524
00:42:25,000 --> 00:42:27,000
应该也是可以的

1525
00:42:27,000 --> 00:42:28,000
就是把数据导一下

1526
00:42:28,000 --> 00:42:29,000
对

1527
00:42:29,000 --> 00:42:32,000
因为那个就是通讯录是可以访问的

1528
00:42:32,000 --> 00:42:33,000
通过 API

1529
00:42:33,000 --> 00:42:34,000
然后你去看看改一下

1530
00:42:34,000 --> 00:42:36,000
但这里就会牵涉到他问的那个第二个问题

1531
00:42:36,000 --> 00:42:38,000
就怎样得到一个汉子的读音

1532
00:42:38,000 --> 00:42:42,000
因为这个比较简单的我就是有一个有一个那个对照表的

1533
00:42:42,000 --> 00:42:44,000
就是汉字和他的那个拼音的对照表的

1534
00:42:44,000 --> 00:42:46,000
这个是这个是很多些人里面都自带的

1535
00:42:46,000 --> 00:42:50,000
但这个比较 tricky 的就是说有些是是那个多音字

1536
00:42:50,000 --> 00:42:51,000
嗯

1537
00:42:51,000 --> 00:42:53,000
这个时候特别是在那个名字里面

1538
00:42:53,000 --> 00:42:55,000
他有些是很多是非标

1539
00:42:55,000 --> 00:42:57,000
没有没有就不去不太具备这个参考意义的

1540
00:42:57,000 --> 00:42:59,000
比如说有些有些字的多音字

1541
00:42:59,000 --> 00:43:03,000
你是可以通过这个上下文的语意来看出他是念哪个的吗

1542
00:43:03,000 --> 00:43:05,000
但是在名字里面其实是一个非常

1543
00:43:05,000 --> 00:43:07,000
arbitrary 的一个事情

1544
00:43:07,000 --> 00:43:13,000
比如说有一个朋友叫叫那个就是草字头一个下面东南西北的西字那个字

1545
00:43:13,000 --> 00:43:15,000
他可以念西也可以念茜对吧

1546
00:43:15,000 --> 00:43:15,000
对对

1547
00:43:15,000 --> 00:43:19,000
在在名字里面很多人都是把它念茜的对吧

1548
00:43:19,000 --> 00:43:23,000
但其实在他在选择的时候就把它念成念西

1549
00:43:23,000 --> 00:43:25,000
这个时候你说你怎么办

1550
00:43:25,000 --> 00:43:26,000
你没有办法

1551
00:43:26,000 --> 00:43:28,000
对这点还好

1552
00:43:28,000 --> 00:43:33,000
另外有一个问题就是有些人的这个信的同一个字的写法

1553
00:43:33,000 --> 00:43:35,000
他他甚至都有不一样的念法

1554
00:43:35,000 --> 00:43:36,000
信的话

1555
00:43:36,000 --> 00:43:41,000
一般做信的那个音会会比较比较特殊的

1556
00:43:41,000 --> 00:43:44,000
就有一些会有白白白毒嘛

1557
00:43:44,000 --> 00:43:47,000
然后这个白毒又会被这个当成一种传统

1558
00:43:47,000 --> 00:43:48,000
比如说那个最

1559
00:43:48,000 --> 00:43:52,000
我印象最深的就是有一个信叫盖嘛

1560
00:43:52,000 --> 00:43:53,000
你知道吗

1561
00:43:53,000 --> 00:43:54,000
就是盖子的盖

1562
00:43:54,000 --> 00:43:56,000
盖叫天有一个经济元

1563
00:43:56,000 --> 00:43:59,000
对但是这个信其实他在念信的时候

1564
00:43:59,000 --> 00:44:01,000
一个比较规范的话应该念葛

1565
00:44:01,000 --> 00:44:05,000
对但是很多人都觉得

1566
00:44:05,000 --> 00:44:06,000
普术嘛

1567
00:44:06,000 --> 00:44:07,000
普术这个朴

1568
00:44:07,000 --> 00:44:08,000
朴术

1569
00:44:08,000 --> 00:44:08,000
朴术

1570
00:44:08,000 --> 00:44:09,000
朴术术

1571
00:44:09,000 --> 00:44:10,000
朴术术

1572
00:44:10,000 --> 00:44:10,000
对

1573
00:44:10,000 --> 00:44:12,000
不过他这个应该是小众吧

1574
00:44:12,000 --> 00:44:14,000
他应该是一个艺名之类的小众

1575
00:44:14,000 --> 00:44:16,000
但那个盖和葛的问题就是

1576
00:44:16,000 --> 00:44:20,000
很多人他都希望自己被念成叫盖

1577
00:44:20,000 --> 00:44:22,000
就是不要改成葛这个音

1578
00:44:22,000 --> 00:44:25,000
但是有一些人他可能祖上传下一直都念葛

1579
00:44:25,000 --> 00:44:27,000
所以他又希望这个字念葛

1580
00:44:27,000 --> 00:44:30,000
所以这个字念什么音其实也是不一样的

1581
00:44:30,000 --> 00:44:32,000
就是就是说刚才讲那个问题

1582
00:44:32,000 --> 00:44:36,000
就信名里面这个读音是没有一个规则可以参考

1583
00:44:36,000 --> 00:44:40,000
因为很多是靠他自己自定的一个选择来怎么念的

1584
00:44:40,000 --> 00:44:42,000
这个事情就很非常尴尬

1585
00:44:42,000 --> 00:44:42,000
对而且

1586
00:44:42,000 --> 00:44:47,000
而且这个问题其实并不仅仅是中文

1587
00:44:47,000 --> 00:44:50,000
或者是在在在表意文字才有

1588
00:44:50,000 --> 00:44:53,000
就在英文或者说在拉丁语

1589
00:44:53,000 --> 00:44:56,000
拉丁字符世界甚至是拼音字符世界也是有的

1590
00:44:56,000 --> 00:45:02,000
比如说前阵子被韩国被朝鲜弄死的那个美国人

1591
00:45:02,000 --> 00:45:06,000
他的名字叫做 warm beer

1592
00:45:06,000 --> 00:45:08,000
就是你如果你是一个美国人的话

1593
00:45:08,000 --> 00:45:09,000
你念他的名字

1594
00:45:09,000 --> 00:45:11,000
你会念成 warm beer

1595
00:45:11,000 --> 00:45:12,000
然后有一天

1596
00:45:12,000 --> 00:45:14,000
但是 warm 和 beer 这两个词息

1597
00:45:14,000 --> 00:45:16,000
就是地道的德语词

1598
00:45:16,000 --> 00:45:18,000
包括这个人的整个的名字

1599
00:45:18,000 --> 00:45:19,000
他的名字叫什么来着

1600
00:45:19,000 --> 00:45:20,000
autowambi

1601
00:45:20,000 --> 00:45:24,000
这一听就是一个德国后裔你知道吧

1602
00:45:24,000 --> 00:45:25,000
就是那种感觉就好像

1603
00:45:25,000 --> 00:45:28,000
就好像这种感觉很奇怪

1604
00:45:28,000 --> 00:45:30,000
就好像你是一个华人

1605
00:45:30,000 --> 00:45:32,000
然后现在中国人已经是什么

1606
00:45:32,000 --> 00:45:35,000
跑去我们这一代

1607
00:45:35,000 --> 00:45:38,000
就是很多人都是双字名的

1608
00:45:38,000 --> 00:45:41,000
现在的中国小孩都起什么

1609
00:45:41,000 --> 00:45:44,000
什么义轩呀紫轩呀

1610
00:45:44,000 --> 00:45:47,000
什么这种非常 you know

1611
00:45:47,000 --> 00:45:49,000
说不出来奇怪在哪

1612
00:45:49,000 --> 00:45:50,000
但是有点奇怪的名字

1613
00:45:50,000 --> 00:45:51,000
然后后来有一天

1614
00:45:51,000 --> 00:45:53,000
你发现一个在美国出生的

1615
00:45:53,000 --> 00:45:54,000
土生出长的华裔

1616
00:45:54,000 --> 00:45:57,000
名字叫曾国潘

1617
00:45:57,000 --> 00:45:59,000
或者左宗潘这种感觉

1618
00:45:59,000 --> 00:46:02,000
就非常古典

1619
00:46:02,000 --> 00:46:03,000
对就是 autow

1620
00:46:03,000 --> 00:46:05,000
他的中名是什么

1621
00:46:05,000 --> 00:46:07,000
Frederick

1622
00:46:07,000 --> 00:46:10,000
奥托弗雷德里克

1623
00:46:10,000 --> 00:46:12,000
Vambi

1624
00:46:12,000 --> 00:46:13,000
对这样一个名字

1625
00:46:13,000 --> 00:46:14,000
这个名字

1626
00:46:14,000 --> 00:46:16,000
如果你

1627
00:46:16,000 --> 00:46:17,000
如果他是一个德国人的话

1628
00:46:17,000 --> 00:46:21,000
那么他的名字会变成 Vambi

1629
00:46:21,000 --> 00:46:23,000
但如果他是一个美国人的话

1630
00:46:23,000 --> 00:46:25,000
包括德国人念他

1631
00:46:25,000 --> 00:46:28,000
在广播里面念这个人的名字的时候

1632
00:46:28,000 --> 00:46:29,000
都会念成 Vambi

1633
00:46:29,000 --> 00:46:31,000
就是按美语的发音

1634
00:46:31,000 --> 00:46:33,000
来念

1635
00:46:33,000 --> 00:46:34,000
所以这就是为什么

1636
00:46:34,000 --> 00:46:36,000
刚才说到的那个

1637
00:46:36,000 --> 00:46:38,000
在 iPhone 的联系人里面

1638
00:46:38,000 --> 00:46:40,000
你可以给他添加两个

1639
00:46:40,000 --> 00:46:44,000
额外的项目

1640
00:46:44,000 --> 00:46:46,000
一个叫做 Pronunciation

1641
00:46:46,000 --> 00:46:49,000
Spelling

1642
00:46:49,000 --> 00:46:51,000
Pronunciation name

1643
00:46:51,000 --> 00:46:53,000
另外一个叫做 Phonetic name

1644
00:46:53,000 --> 00:46:55,000
就是我记得这两个之中

1645
00:46:55,000 --> 00:47:00,000
一个会被 Siri 拿来当作发音的依据

1646
00:47:00,000 --> 00:47:01,000
对

1647
00:47:01,000 --> 00:47:02,000
对

1648
00:47:02,000 --> 00:47:03,000
就比如说你

1649
00:47:03,000 --> 00:47:05,000
比如说吴涛这两个字

1650
00:47:05,000 --> 00:47:05,000
你可以

1651
00:47:05,000 --> 00:47:07,000
在

1652
00:47:07,000 --> 00:47:15,000
在 Phonetic name 里面写 W-U-T-A-O

1653
00:47:15,000 --> 00:47:18,000
但是在 Pronunciation 里面

1654
00:47:18,000 --> 00:47:24,000
你可以写 W-O-O-T-A-U

1655
00:47:24,000 --> 00:47:24,000
比如说

1656
00:47:24,000 --> 00:47:28,000
然后 Siri 会试着用 W-T-A-O

1657
00:47:28,000 --> 00:47:30,000
这个方法来念这个

1658
00:47:30,000 --> 00:47:32,000
Pronunciation 就纯粹是给

1659
00:47:32,000 --> 00:47:33,000
那个语音生成

1660
00:47:33,000 --> 00:47:34,000
那个合成器用的

1661
00:47:34,000 --> 00:47:35,000
对

1662
00:47:35,000 --> 00:47:36,000
我是这么理解的

1663
00:47:36,000 --> 00:47:37,000
但当然我

1664
00:47:37,000 --> 00:47:38,000
我说他没有用过

1665
00:47:38,000 --> 00:47:38,000
但

1666
00:47:38,000 --> 00:47:39,000
我相信英国人

1667
00:47:39,000 --> 00:47:40,000
应该可以知道

1668
00:47:40,000 --> 00:47:40,000
比如说你可以

1669
00:47:40,000 --> 00:47:41,000
你可以

1670
00:47:41,000 --> 00:47:44,000
用这个功能来告诉 Siri

1671
00:47:44,000 --> 00:47:46,000
说打电话给谁

1672
00:47:46,000 --> 00:47:47,000
是谁

1673
00:47:47,000 --> 00:47:48,000
实现这样一个功能

1674
00:47:48,000 --> 00:47:49,000
还有一个更直接的办法

1675
00:47:49,000 --> 00:47:51,000
就是 Siri 的话

1676
00:47:51,000 --> 00:47:51,000
你可以直接

1677
00:47:51,000 --> 00:47:52,000
你直接语音

1678
00:47:52,000 --> 00:47:54,000
把这个字念成

1679
00:47:54,000 --> 00:47:55,000
你可以教它

1680
00:47:55,000 --> 00:47:55,000
念成什么

1681
00:47:55,000 --> 00:47:56,000
对

1682
00:47:56,000 --> 00:47:56,000
对

1683
00:47:56,000 --> 00:47:57,000
对

1684
00:47:57,000 --> 00:47:59,000
对

1685
00:47:59,000 --> 00:48:00,000
所以呢

1686
00:48:00,000 --> 00:48:02,000
就专门有这样的一个 Field

1687
00:48:02,000 --> 00:48:04,000
是给语音合成器来

1688
00:48:04,000 --> 00:48:06,000
教它念读音的这样一个 Field

1689
00:48:06,000 --> 00:48:07,000
对

1690
00:48:07,000 --> 00:48:07,000
这个 Field 好像

1691
00:48:07,000 --> 00:48:09,000
只有这个 IOS 上才有

1692
00:48:09,000 --> 00:48:10,000
Mac 上是没有这个 Field

1693
00:48:10,000 --> 00:48:11,000
我刚才有检查了一点

1694
00:48:11,000 --> 00:48:12,000
对

1695
00:48:12,000 --> 00:48:14,000
因为 Mac 上之前没有 Siri

1696
00:48:14,000 --> 00:48:15,000
所以估计没做

1697
00:48:15,000 --> 00:48:16,000
但现在 Mac 上也有 Siri

1698
00:48:16,000 --> 00:48:17,000
现在有了呀

1699
00:48:17,000 --> 00:48:18,000
怎么办

1700
00:48:18,000 --> 00:48:20,000
但是在那个 Contact

1701
00:48:20,000 --> 00:48:22,000
就是通讯录的那个添加

1702
00:48:22,000 --> 00:48:23,000
那个

1703
00:48:23,000 --> 00:48:25,000
那个叫什么来的

1704
00:48:25,000 --> 00:48:26,000
那个 Field

1705
00:48:26,000 --> 00:48:27,000
那个里面是没有

1706
00:48:27,000 --> 00:48:28,000
没有那个字端的

1707
00:48:28,000 --> 00:48:29,000
没有 Pronunciation

1708
00:48:29,000 --> 00:48:31,000
只有 Fonetic

1709
00:48:31,000 --> 00:48:31,000
对

1710
00:48:31,000 --> 00:48:32,000
应该是只有 Fonetic

1711
00:48:32,000 --> 00:48:33,000
Pronunciation

1712
00:48:33,000 --> 00:48:34,000
还是没有更新到哪里来

1713
00:48:34,000 --> 00:48:36,000
Anyway

1714
00:48:36,000 --> 00:48:37,000
这个邮件里面

1715
00:48:37,000 --> 00:48:38,000
其实还提了个非常重要的

1716
00:48:38,000 --> 00:48:39,000
是就是说

1717
00:48:39,000 --> 00:48:40,000
其实我理解

1718
00:48:40,000 --> 00:48:41,000
就是说在这种

1719
00:48:41,000 --> 00:48:42,000
多语言的时候

1720
00:48:42,000 --> 00:48:43,000
怎么排序

1721
00:48:43,000 --> 00:48:44,000
比如刚才我们提到的

1722
00:48:44,000 --> 00:48:45,000
这个日文环境

1723
00:48:45,000 --> 00:48:45,000
和这个

1724
00:48:45,000 --> 00:48:47,000
这个德语环境的时候

1725
00:48:47,000 --> 00:48:49,000
它都是有这个区别的

1726
00:48:49,000 --> 00:48:50,000
你没有想过这个问题

1727
00:48:50,000 --> 00:48:51,000
如果一个人

1728
00:48:51,000 --> 00:48:52,000
他精通多国语言

1729
00:48:52,000 --> 00:48:54,000
比如说他会这个日语

1730
00:48:54,000 --> 00:48:55,000
然后韩语

1731
00:48:55,000 --> 00:48:56,000
然后会这个什么

1732
00:48:56,000 --> 00:48:57,000
阿拉伯语

1733
00:48:57,000 --> 00:48:58,000
然后他大概都有

1734
00:48:58,000 --> 00:48:59,000
讲这种语种的

1735
00:48:59,000 --> 00:49:01,000
或者是这个名字的

1736
00:49:01,000 --> 00:49:01,000
这个朋友

1737
00:49:01,000 --> 00:49:03,000
他同学的时候怎么办

1738
00:49:03,000 --> 00:49:07,000
不过我们觉得

1739
00:49:07,000 --> 00:49:08,000
应该把这个

1740
00:49:08,000 --> 00:49:09,000
把这件事情啊

1741
00:49:09,000 --> 00:49:09,000
说

1742
00:49:09,000 --> 00:49:12,000
要分好多层次来说

1743
00:49:12,000 --> 00:49:13,000
别这样乱起吧

1744
00:49:13,000 --> 00:49:15,000
首先是有一个

1745
00:49:15,000 --> 00:49:16,000
呃

1746
00:49:16,000 --> 00:49:17,000
代码层面的问题

1747
00:49:17,000 --> 00:49:18,000
对不对

1748
00:49:18,000 --> 00:49:19,000
然后呢

1749
00:49:19,000 --> 00:49:19,000
有一个

1750
00:49:19,000 --> 00:49:20,000
对

1751
00:49:20,000 --> 00:49:21,000
对

1752
00:49:21,000 --> 00:49:22,000
然后呢

1753
00:49:22,000 --> 00:49:24,000
首先有操作系统层面的问题

1754
00:49:24,000 --> 00:49:26,000
然后还有 app 层面的问题

1755
00:49:26,000 --> 00:49:29,000
对这几个层

1756
00:49:29,000 --> 00:49:31,000
都都会影响到你最后

1757
00:49:31,000 --> 00:49:32,000
看起来的最后的排序

1758
00:49:32,000 --> 00:49:33,000
是怎么样的

1759
00:49:33,000 --> 00:49:33,000
对

1760
00:49:33,000 --> 00:49:35,000
因为后来想一下

1761
00:49:35,000 --> 00:49:36,000
其实这种

1762
00:49:36,000 --> 00:49:37,000
在多种语种

1763
00:49:37,000 --> 00:49:38,000
特别是多语种

1764
00:49:38,000 --> 00:49:39,000
混合环境下

1765
00:49:39,000 --> 00:49:40,000
就是还不是说

1766
00:49:40,000 --> 00:49:41,000
一个一个系列

1767
00:49:41,000 --> 00:49:42,000
比如拉丁语系

1768
00:49:42,000 --> 00:49:42,000
还相对来说

1769
00:49:42,000 --> 00:49:43,000
可以兼容吗

1770
00:49:43,000 --> 00:49:45,000
像刚才讲的那种情况下

1771
00:49:45,000 --> 00:49:46,000
其实还跟你的这个

1772
00:49:46,000 --> 00:49:47,000
叫做什么来的

1773
00:49:47,000 --> 00:49:50,000
政治策略有关系

1774
00:49:50,000 --> 00:49:50,000
政治正确

1775
00:49:50,000 --> 00:49:50,000
对

1776
00:49:50,000 --> 00:49:51,000
对

1777
00:49:51,000 --> 00:49:54,000
你说你说要把这个某种语言的这个

1778
00:49:54,000 --> 00:49:55,000
呃

1779
00:49:55,000 --> 00:49:57,000
虽然说 unicode 里面有个顺序

1780
00:49:57,000 --> 00:49:58,000
但是如果你在某一种

1781
00:49:58,000 --> 00:49:59,000
呃

1782
00:49:59,000 --> 00:49:59,000
环境下

1783
00:49:59,000 --> 00:50:02,000
你把一种语言的名字排在前面

1784
00:50:02,000 --> 00:50:03,000
另一种排在后面

1785
00:50:03,000 --> 00:50:05,000
其实多多少少会有一些这个的考量

1786
00:50:05,000 --> 00:50:06,000
在里面

1787
00:50:06,000 --> 00:50:09,000
所以其实挺复杂的一个问题的

1788
00:50:09,000 --> 00:50:11,000
那不管怎么样

1789
00:50:11,000 --> 00:50:12,000
我们刚才从呃

1790
00:50:12,000 --> 00:50:14,000
这个层面来讲的话

1791
00:50:14,000 --> 00:50:15,000
在操作系统层面

1792
00:50:15,000 --> 00:50:17,000
比如说 iOS 和 macOS 就不一样

1793
00:50:17,000 --> 00:50:18,000
对吧

1794
00:50:18,000 --> 00:50:20,000
针对一个语言的话

1795
00:50:20,000 --> 00:50:20,000
呃

1796
00:50:20,000 --> 00:50:21,000
因为

1797
00:50:21,000 --> 00:50:23,000
iOS 它是移动的系统

1798
00:50:23,000 --> 00:50:24,000
所以呢

1799
00:50:24,000 --> 00:50:25,000
它一个语言

1800
00:50:25,000 --> 00:50:26,000
它只有一个默认的排序

1801
00:50:26,000 --> 00:50:28,000
但是 macOS 上面呢

1802
00:50:28,000 --> 00:50:29,000
真呃

1803
00:50:29,000 --> 00:50:30,000
你一个语言

1804
00:50:30,000 --> 00:50:32,000
你可以选好多个排序

1805
00:50:32,000 --> 00:50:33,000
你可以你是可以选的

1806
00:50:33,000 --> 00:50:34,000
啊

1807
00:50:34,000 --> 00:50:35,000
然后呢

1808
00:50:35,000 --> 00:50:37,000
在操作系统层面

1809
00:50:37,000 --> 00:50:39,000
像刚才我们说的很最最典型的

1810
00:50:39,000 --> 00:50:41,000
有很多需要这个通讯录啊

1811
00:50:41,000 --> 00:50:44,000
它是可以再另外加一个 field 的啊

1812
00:50:44,000 --> 00:50:46,000
还有一个很典型的是 iTunes

1813
00:50:46,000 --> 00:50:47,000
iTunes

1814
00:50:47,000 --> 00:50:48,000
它是各种歌词的名字

1815
00:50:48,000 --> 00:50:50,000
因为那个曲名有

1816
00:50:50,000 --> 00:50:52,000
也有各国的曲名

1817
00:50:52,000 --> 00:50:53,000
对

1818
00:50:53,000 --> 00:50:54,000
然后呢

1819
00:50:54,000 --> 00:50:56,000
它在 mp 3 的

1820
00:50:56,000 --> 00:50:58,000
或者你在这个音乐的那一个

1821
00:50:58,000 --> 00:51:00,000
就是 metadata 里面

1822
00:51:00,000 --> 00:51:03,000
你可以再继续把这个名字

1823
00:51:03,000 --> 00:51:06,000
像刚才注人的名字呀

1824
00:51:06,000 --> 00:51:08,000
把个歌曲的名字也是给它注音注进去

1825
00:51:08,000 --> 00:51:09,000
也是可以的

1826
00:51:09,000 --> 00:51:11,000
iTunes 这个比较机贼呀

1827
00:51:11,000 --> 00:51:12,000
它其实做的不是注音

1828
00:51:12,000 --> 00:51:13,000
它直接给了一个选择

1829
00:51:13,000 --> 00:51:14,000
叫做 sort order 嘛

1830
00:51:14,000 --> 00:51:15,000
就是排序的这个顺序

1831
00:51:15,000 --> 00:51:16,000
排序的对

1832
00:51:16,000 --> 00:51:17,000
它完全不管

1833
00:51:17,000 --> 00:51:18,000
嗯

1834
00:51:18,000 --> 00:51:18,000
对

1835
00:51:18,000 --> 00:51:19,000
但是它至少就是

1836
00:51:19,000 --> 00:51:21,000
它有一个 metadata 可以写嘛

1837
00:51:21,000 --> 00:51:23,000
你往那里面写的话

1838
00:51:23,000 --> 00:51:26,000
然后 iTunes 就会去读那个 field 嘛

1839
00:51:26,000 --> 00:51:26,000
对吧

1840
00:51:26,000 --> 00:51:27,000
是 iTunes

1841
00:51:27,000 --> 00:51:29,000
它给提供的这样的可能嘛

1842
00:51:29,000 --> 00:51:30,000
嗯

1843
00:51:30,000 --> 00:51:31,000
就专门为了排序

1844
00:51:31,000 --> 00:51:32,000
它提供的

1845
00:51:32,000 --> 00:51:33,000
它做了这样一个功能嘛

1846
00:51:33,000 --> 00:51:36,000
所以像这样的功能是 application 层面给它提

1847
00:51:36,000 --> 00:51:37,000
设计出来

1848
00:51:37,000 --> 00:51:38,000
然后给它做的嘛

1849
00:51:38,000 --> 00:51:38,000
对吧

1850
00:51:38,000 --> 00:51:39,000
对

1851
00:51:39,000 --> 00:51:40,000
嗯

1852
00:51:40,000 --> 00:51:43,000
如果你不在那边做的话

1853
00:51:43,000 --> 00:51:46,000
它会默认先去调用系统的顺序嘛

1854
00:51:46,000 --> 00:51:47,000
对吧

1855
00:51:47,000 --> 00:51:48,000
它有个 fallback 的顺序

1856
00:51:48,000 --> 00:51:49,000
嗯

1857
00:51:49,000 --> 00:51:50,000
嗯

1858
00:51:50,000 --> 00:51:51,000
所以

1859
00:51:51,000 --> 00:51:52,000
然后如果系统也没事的话

1860
00:51:52,000 --> 00:51:55,000
那它直接就去读内码的顺序了

1861
00:51:55,000 --> 00:51:56,000
对吧

1862
00:51:56,000 --> 00:52:01,000
但是 unicode 它默认了它真正的那个内码是什么顺序

1863
00:52:01,000 --> 00:52:06,000
所以你看这个现代软件里面多多少复杂性

1864
00:52:06,000 --> 00:52:07,000
就是有这些原因导致

1865
00:52:07,000 --> 00:52:08,000
嗯

1866
00:52:08,000 --> 00:52:12,000
好吧

1867
00:52:12,000 --> 00:52:15,000
那我们今天终于可以再讲正题了吗

1868
00:52:15,000 --> 00:52:15,000
今天正题

1869
00:52:15,000 --> 00:52:21,000
今天我们要讲一个最长的 hardcore 的正题

1870
00:52:21,000 --> 00:52:24,000
就是很多人都没有意识到这个问题的存在

1871
00:52:24,000 --> 00:52:29,000
今天我们要讲的是 unicode 的规范化形式叫 normalization

1872
00:52:29,000 --> 00:52:32,000
很多人都讲 normalization 是什么东西

1873
00:52:34,000 --> 00:52:36,000
你来自文自答一下好了

1874
00:52:36,000 --> 00:52:39,000
它有中文的标准译法吗

1875
00:52:39,000 --> 00:52:41,000
或者我们有什么推荐意义法

1876
00:52:41,000 --> 00:52:42,000
呃

1877
00:52:42,000 --> 00:52:45,000
因为 unicode 它就是国标

1878
00:52:45,000 --> 00:52:47,000
它就是国际标准 ISO 嘛

1879
00:52:47,000 --> 00:52:52,000
那 ISO 它又是各国的都会写到各国的国标

1880
00:52:52,000 --> 00:52:54,000
国家标准里面

1881
00:52:54,000 --> 00:52:55,000
那么中国的国标

1882
00:52:55,000 --> 00:52:59,000
就是 ISO 的能够中国国标是 13000

1883
00:52:59,000 --> 00:53:02,000
然后它对这个 normalization 的翻译是叫规范化

1884
00:53:02,000 --> 00:53:06,000
那我们在今天节目里面就叫规范化吧

1885
00:53:06,000 --> 00:53:09,000
要不然挺乱的

1886
00:53:09,000 --> 00:53:10,000
OK

1887
00:53:10,000 --> 00:53:13,000
然后很多朋友就不知道

1888
00:53:13,000 --> 00:53:16,000
还有一个规范化的东西

1889
00:53:16,000 --> 00:53:18,000
其实很简单就是你看到的

1890
00:53:18,000 --> 00:53:21,000
比如说带声调的字符

1891
00:53:21,000 --> 00:53:22,000
比如说拼音

1892
00:53:22,000 --> 00:53:22,000
啊啊啊啊啊

1893
00:53:22,000 --> 00:53:24,000
那个比如说那个啊

1894
00:53:24,000 --> 00:53:25,000
对吧

1895
00:53:25,000 --> 00:53:27,000
是字母 A 上面加个所谓的第二声

1896
00:53:27,000 --> 00:53:28,000
对吧

1897
00:53:28,000 --> 00:53:30,000
你看到你看到的是这样一个字形

1898
00:53:30,000 --> 00:53:35,000
可是它的背后可能是一个编码

1899
00:53:35,000 --> 00:53:37,000
或者它也可能是两个字符

1900
00:53:37,000 --> 00:53:38,000
两个编码

1901
00:53:38,000 --> 00:53:46,000
也就是说一个字母 A 的编码加上一个带声调的这个编码组合而成的一个东西

1902
00:53:46,000 --> 00:53:46,000
对

1903
00:53:46,000 --> 00:53:50,000
其实就是本质上 unicode 有一个现象

1904
00:53:50,000 --> 00:53:56,000
就是说当我们看到一串 unicode 的码位的组合的时候

1905
00:53:56,000 --> 00:53:59,000
他们可能在码位上是不同的

1906
00:53:59,000 --> 00:54:04,000
但他们实际上表示的这个字符或者是字符串是相等的

1907
00:54:04,000 --> 00:54:06,000
就 unicode 有这样一个所谓的等

1908
00:54:06,000 --> 00:54:08,000
对有一个等价字符的这样的问题

1909
00:54:08,000 --> 00:54:09,000
对

1910
00:54:09,000 --> 00:54:11,000
主要是这主要还是一个

1911
00:54:11,000 --> 00:54:15,000
本质上还是一个历史的有问题

1912
00:54:15,000 --> 00:54:21,000
他如果当初不要一不是一定要兼容了一串 anski 的低位的话就不会有这个问题

1913
00:54:21,000 --> 00:54:22,000
我是这么一个

1914
00:54:22,000 --> 00:54:28,000
但是而且而且现在是由于 unicode 是多语言的嘛

1915
00:54:28,000 --> 00:54:29,000
那各个语言也都会有这样一个问题

1916
00:54:29,000 --> 00:54:31,000
所以这个规范化就越搞越烦

1917
00:54:31,000 --> 00:54:33,000
然后这个东西的话

1918
00:54:33,000 --> 00:54:37,000
有时候呢你要给它看成是一个字

1919
00:54:37,000 --> 00:54:39,000
因为比如要看成两个字

1920
00:54:39,000 --> 00:54:41,000
因为就有时候必须区别嘛

1921
00:54:41,000 --> 00:54:44,000
就是带声调的和不带声调的肯定是两个字嘛

1922
00:54:44,000 --> 00:54:45,000
不一样就不能给它混在一起

1923
00:54:45,000 --> 00:54:49,000
但是呢有时候呢你又要给它混在一起

1924
00:54:49,000 --> 00:54:50,000
比如说在搜索的时候

1925
00:54:50,000 --> 00:54:51,000
你要搜索的时候

1926
00:54:51,000 --> 00:54:55,000
你可能希望就是说你只打一个字母 A

1927
00:54:55,000 --> 00:55:00,000
但是你能顺带你把这些带声调的东西能一起搜索到

1928
00:55:00,000 --> 00:55:02,000
就是能在那个候选项能出来

1929
00:55:02,000 --> 00:55:05,000
所以这个时候呢你又喜欢模糊的把这些全部带

1930
00:55:05,000 --> 00:55:07,000
所以呢这个是有这样的需求的

1931
00:55:07,000 --> 00:55:09,000
就是有时候你需要区别

1932
00:55:09,000 --> 00:55:12,000
有时候呢你又不想不区别

1933
00:55:12,000 --> 00:55:14,000
就是这里有个问题就是

1934
00:55:14,000 --> 00:55:18,000
为什么要同一个马位要对应两个

1935
00:55:18,000 --> 00:55:20,000
就最开始它它产生的原因是什么

1936
00:55:20,000 --> 00:55:22,000
刚才那个吴涛提了一个解释

1937
00:55:22,000 --> 00:55:23,000
不是是反过来

1938
00:55:23,000 --> 00:55:28,000
是同一个字符会有多个马位

1939
00:55:28,000 --> 00:55:30,000
而不是同一个马位会对应两个字符

1940
00:55:30,000 --> 00:55:32,000
那就是为什么出现这种情况

1941
00:55:32,000 --> 00:55:34,000
就是它的历史背景是什么

1942
00:55:34,000 --> 00:55:36,000
最简单的一个比如说

1943
00:55:36,000 --> 00:55:46,000
当时欧洲各自都使用很多带有那个扩展符号的拉宁字符

1944
00:55:46,000 --> 00:55:51,000
所以当时 ASCII 的那个高位就被拿来做扩展

1945
00:55:51,000 --> 00:55:56,000
然后最常见的就是 Windows 上那个叫什么 CP 1252

1946
00:55:56,000 --> 00:55:57,000
还是哪一个

1947
00:55:57,000 --> 00:55:59,000
代码页

1948
00:55:59,000 --> 00:56:00,000
对

1949
00:56:00,000 --> 00:56:03,000
Windows 直到今天都是在使用代码页这套机制

1950
00:56:03,000 --> 00:56:05,000
这套非常坑捏的机制

1951
00:56:05,000 --> 00:56:05,000
所以

1952
00:56:05,000 --> 00:56:06,000
对

1953
00:56:06,000 --> 00:56:07,000
这是一个

1954
00:56:07,000 --> 00:56:11,000
这是一个就是不能忽视的历史问题

1955
00:56:11,000 --> 00:56:14,000
所以 UNICO 一开始在做的时候

1956
00:56:14,000 --> 00:56:14,000
它的

1957
00:56:14,000 --> 00:56:17,000
我记得是第一位的

1958
00:56:17,000 --> 00:56:19,000
完全兼容 ASCII

1959
00:56:19,000 --> 00:56:21,000
然后此时就出现了一个问题

1960
00:56:21,000 --> 00:56:21,000
就是比如说

1961
00:56:21,000 --> 00:56:24,000
U 上面加两点这个字符

1962
00:56:24,000 --> 00:56:25,000
那它就有可能出现

1963
00:56:25,000 --> 00:56:30,000
它就等于在 UNICO 里面出现了两种组合的可能

1964
00:56:30,000 --> 00:56:32,000
一种是因为 UNICO 的兼容

1965
00:56:32,000 --> 00:56:34,000
它固有的那个表达方式

1966
00:56:34,000 --> 00:56:39,000
就是 U 这个字符是在哪一个码位上

1967
00:56:39,000 --> 00:56:39,000
然后它会

1968
00:56:39,000 --> 00:56:42,000
它直接把那个码位就

1969
00:56:42,000 --> 00:56:45,000
坐进了 UNICO 里面

1970
00:56:45,000 --> 00:56:46,000
说在这个码位上面

1971
00:56:46,000 --> 00:56:47,000
UNICO 在这个码位上面

1972
00:56:47,000 --> 00:56:49,000
这里就是 U 上个加两点

1973
00:56:49,000 --> 00:56:50,000
但与此同时

1974
00:56:50,000 --> 00:56:54,000
它又给出了单独的一个 U 和单独的一个两点

1975
00:56:54,000 --> 00:56:56,000
于是此时你就又可以用说

1976
00:56:56,000 --> 00:56:58,000
我要一个 U

1977
00:56:58,000 --> 00:57:01,000
然后上面加两点来做出这个字符来

1978
00:57:01,000 --> 00:57:03,000
这个就是问题

1979
00:57:03,000 --> 00:57:04,000
就是为什么会有这种

1980
00:57:04,000 --> 00:57:07,000
组合的需求存在

1981
00:57:07,000 --> 00:57:08,000
如果说

1982
00:57:08,000 --> 00:57:09,000
我提个比较极端的情况

1983
00:57:09,000 --> 00:57:11,000
如果说我们把所有的组合都是

1984
00:57:11,000 --> 00:57:16,000
组合后的字都变成一个独立的码位

1985
00:57:16,000 --> 00:57:17,000
就不存在这个问题了

1986
00:57:17,000 --> 00:57:19,000
因为首先一方面

1987
00:57:19,000 --> 00:57:22,000
就是它比较节省空间

1988
00:57:22,000 --> 00:57:23,000
另外一个就是

1989
00:57:23,000 --> 00:57:24,000
如果你要组合的话

1990
00:57:24,000 --> 00:57:26,000
你是组合不穷尽的

1991
00:57:26,000 --> 00:57:29,000
尤其是比如说有些组合

1992
00:57:29,000 --> 00:57:31,000
一方面有些组合可能完全没有意义

1993
00:57:31,000 --> 00:57:32,000
另外一方面

1994
00:57:32,000 --> 00:57:33,000
比如像越南语

1995
00:57:33,000 --> 00:57:35,000
就是一个字符上面可能有四五个

1996
00:57:35,000 --> 00:57:38,000
四五个可能太过程了

1997
00:57:38,000 --> 00:57:40,000
三个应该是有可能

1998
00:57:40,000 --> 00:57:40,000
三个也可能

1999
00:57:40,000 --> 00:57:41,000
对

2000
00:57:41,000 --> 00:57:43,000
三个标音符号

2001
00:57:43,000 --> 00:57:45,000
然后你要把所有的 combination 都弄出来的话

2002
00:57:45,000 --> 00:57:47,000
这对于空间其实是很大的浪费

2003
00:57:47,000 --> 00:57:50,000
给大家一个比较更直观的一个例子

2004
00:57:50,000 --> 00:57:51,000
比如说

2005
00:57:51,000 --> 00:57:55,000
汉语拼音那个乌上有两点是员

2006
00:57:55,000 --> 00:57:56,000
对吧

2007
00:57:56,000 --> 00:57:58,000
然后员也可以带声调

2008
00:57:58,000 --> 00:57:58,000
员

2009
00:57:58,000 --> 00:57:59,000
对

2010
00:57:59,000 --> 00:58:01,000
所以呢

2011
00:58:01,000 --> 00:58:01,000
比如说

2012
00:58:01,000 --> 00:58:02,000
员

2013
00:58:02,000 --> 00:58:03,000
对吧

2014
00:58:03,000 --> 00:58:03,000
那你

2015
00:58:03,000 --> 00:58:04,000
因为

2016
00:58:04,000 --> 00:58:06,000
单纯你就可以看出

2017
00:58:06,000 --> 00:58:07,000
员

2018
00:58:07,000 --> 00:58:09,000
上面加两点

2019
00:58:09,000 --> 00:58:10,000
再加那个第二声

2020
00:58:10,000 --> 00:58:11,000
这其实是

2021
00:58:11,000 --> 00:58:12,000
这到底是一个字还是三个字

2022
00:58:12,000 --> 00:58:14,000
你这个例子举的不对

2023
00:58:14,000 --> 00:58:15,000
鱼应该那个

2024
00:58:15,000 --> 00:58:17,000
YU 的时候

2025
00:58:17,000 --> 00:58:20,000
我不说那个大音节

2026
00:58:20,000 --> 00:58:20,000
对

2027
00:58:20,000 --> 00:58:22,000
我不说大音节的情况

2028
00:58:22,000 --> 00:58:25,000
我不说那个汉语拼音那个音节情况

2029
00:58:25,000 --> 00:58:26,000
我单单是说这个字符

2030
00:58:26,000 --> 00:58:27,000
对

2031
00:58:27,000 --> 00:58:28,000
OK

2032
00:58:28,000 --> 00:58:30,000
比如说绿色的绿

2033
00:58:30,000 --> 00:58:30,000
对

2034
00:58:30,000 --> 00:58:32,000
你加了一个声道

2035
00:58:32,000 --> 00:58:32,000
对

2036
00:58:32,000 --> 00:58:33,000
然后

2037
00:58:33,000 --> 00:58:37,000
此时这个双点和下降调都是存在的

2038
00:58:37,000 --> 00:58:39,000
就是为了这个

2039
00:58:39,000 --> 00:58:42,000
就是我们组合成部件

2040
00:58:42,000 --> 00:58:44,000
然后通过一个固定的方法来组合

2041
00:58:44,000 --> 00:58:46,000
避免去存多种变种

2042
00:58:46,000 --> 00:58:47,000
对

2043
00:58:47,000 --> 00:58:48,000
一个是这个

2044
00:58:48,000 --> 00:58:50,000
另外一方面就是比如说像韩语

2045
00:58:50,000 --> 00:58:52,000
韩语那个字母的

2046
00:58:52,000 --> 00:58:56,000
把几个字母拼在一起的这一套合成机制

2047
00:58:56,000 --> 00:58:57,000
跟那个

2048
00:58:57,000 --> 00:59:00,000
在字母上面加点的合成机制

2049
00:59:00,000 --> 00:59:01,000
实际上是同一套

2050
00:59:01,000 --> 00:59:03,000
那么你

2051
00:59:03,000 --> 00:59:05,000
如果你要把这一套

2052
00:59:05,000 --> 00:59:07,000
比如说我要完全摒弃这一套

2053
00:59:07,000 --> 00:59:10,000
然后把所有的 combination 全都做出来的话

2054
00:59:10,000 --> 00:59:11,000
那韩语的 combination

2055
00:59:11,000 --> 00:59:13,000
那就横河杀术

2056
00:59:13,000 --> 00:59:14,000
一个 play

2057
00:59:14,000 --> 00:59:15,000
你不要这样

2058
00:59:15,000 --> 00:59:16,000
那曾经就见过

2059
00:59:16,000 --> 00:59:18,000
这可能导致什么 UTF 18

2060
00:59:18,000 --> 00:59:20,000
UTF 16 就不够用了

2061
00:59:20,000 --> 00:59:20,000
对

2062
00:59:20,000 --> 00:59:23,000
我觉得微软好像为了这个事情

2063
00:59:23,000 --> 00:59:25,000
就 hack 过这个事情

2064
00:59:25,000 --> 00:59:27,000
还把 unicode 标准给 hack 了

2065
00:59:27,000 --> 00:59:31,000
所以 unicode 标准在韩语有坑吗

2066
00:59:31,000 --> 00:59:32,000
还特别乱

2067
00:59:32,000 --> 00:59:33,000
对特别乱

2068
00:59:33,000 --> 00:59:34,000
没有

2069
00:59:34,000 --> 00:59:35,000
首先是这样子的

2070
00:59:35,000 --> 00:59:35,000
就是说

2071
00:59:35,000 --> 00:59:37,000
如果大家觉得要审编码的话

2072
00:59:37,000 --> 00:59:40,000
就是说像就不用组合

2073
00:59:40,000 --> 00:59:40,000
对吧

2074
00:59:40,000 --> 00:59:41,000
就给它当

2075
00:59:41,000 --> 00:59:43,000
你就给它当成是一个东西的话

2076
00:59:43,000 --> 00:59:45,000
这会在不同语言里面

2077
00:59:45,000 --> 00:59:47,000
会有不同的这个认知

2078
00:59:47,000 --> 00:59:49,000
比如说在德语里面

2079
00:59:49,000 --> 00:59:50,000
乌上加两点

2080
00:59:50,000 --> 00:59:51,000
它就是一个字母

2081
00:59:51,000 --> 00:59:55,000
它对于普通的德文的母语者来讲

2082
00:59:55,000 --> 00:59:56,000
它是一个字母

2083
00:59:56,000 --> 00:59:57,000
它没有这种组合的感觉

2084
00:59:57,000 --> 01:00:01,000
就是像比如说在法语里面

2085
01:00:01,000 --> 01:00:02,000
它底下有个 C

2086
01:00:02,000 --> 01:00:04,000
底下可以加个软音符

2087
01:00:04,000 --> 01:00:07,000
然后像这样的

2088
01:00:07,000 --> 01:00:08,000
对于说法语的人来讲

2089
01:00:08,000 --> 01:00:09,000
这是一个字母

2090
01:00:09,000 --> 01:00:10,000
而不会说是什么

2091
01:00:10,000 --> 01:00:12,000
C 加一个符号

2092
01:00:12,000 --> 01:00:12,000
对

2093
01:00:12,000 --> 01:00:14,000
所以在历史上

2094
01:00:14,000 --> 01:00:15,000
而且在历史上

2095
01:00:15,000 --> 01:00:17,000
就各国因为它自行的

2096
01:00:17,000 --> 01:00:18,000
对 ASC 进行扩充

2097
01:00:18,000 --> 01:00:19,000
所以在它也有个

2098
01:00:19,000 --> 01:00:21,000
向后兼容的一个需要

2099
01:00:21,000 --> 01:00:22,000
所以它必须有这样

2100
01:00:22,000 --> 01:00:24,000
就当成一个字母的

2101
01:00:24,000 --> 01:00:26,000
这样的一个需求

2102
01:00:26,000 --> 01:00:29,000
然后又有想分开的需求

2103
01:00:29,000 --> 01:00:31,000
就是因为你有时候会加的

2104
01:00:31,000 --> 01:00:32,000
无穷尽

2105
01:00:32,000 --> 01:00:35,000
但还是说有这种单独

2106
01:00:35,000 --> 01:00:38,000
就第二声的这样的一个东西

2107
01:00:38,000 --> 01:00:40,000
或者两点这样的东西

2108
01:00:40,000 --> 01:00:41,000
这样的你可以自由的

2109
01:00:41,000 --> 01:00:43,000
往其他的字母上面加

2110
01:00:43,000 --> 01:00:45,000
这样明显是更灵活的

2111
01:00:45,000 --> 01:00:47,000
虽然很灵活

2112
01:00:47,000 --> 01:00:48,000
但是你就浪费了马位

2113
01:00:48,000 --> 01:00:50,000
就变成原来一个字符

2114
01:00:50,000 --> 01:00:52,000
就可以搞定的东西

2115
01:00:52,000 --> 01:00:53,000
现在就变成两个字符了

2116
01:00:53,000 --> 01:00:57,000
然后现在的历史结果就变成

2117
01:00:57,000 --> 01:00:59,000
有的时候要一个字符

2118
01:00:59,000 --> 01:01:00,000
有时候要两个字符

2119
01:01:00,000 --> 01:01:01,000
然后又有向后兼容性

2120
01:01:01,000 --> 01:01:02,000
那没有办法

2121
01:01:02,000 --> 01:01:05,000
那就大家统一起来

2122
01:01:05,000 --> 01:01:07,000
unicode 就搞得这样出一个

2123
01:01:07,000 --> 01:01:09,000
这样一个 normalization

2124
01:01:09,000 --> 01:01:11,000
就是所谓的规范化的一个形式

2125
01:01:11,000 --> 01:01:12,000
对

2126
01:01:12,000 --> 01:01:14,000
而且其实我们刚刚一直在讲

2127
01:01:14,000 --> 01:01:15,000
这个组合的问题

2128
01:01:15,000 --> 01:01:18,000
然后事实上 unicode 的这个

2129
01:01:18,000 --> 01:01:19,000
等价性问题

2130
01:01:19,000 --> 01:01:20,000
或者说 normalization 问题

2131
01:01:20,000 --> 01:01:22,000
它不仅仅要解决组合的问题

2132
01:01:22,000 --> 01:01:24,000
它要解决的是

2133
01:01:24,000 --> 01:01:27,000
两个字符之间

2134
01:01:27,000 --> 01:01:28,000
它们虽然马位是不同的

2135
01:01:28,000 --> 01:01:30,000
它们各自也只有一个马位的时候

2136
01:01:30,000 --> 01:01:32,000
它们也有可能是等价的

2137
01:01:32,000 --> 01:01:32,000
比如举一个例子

2138
01:01:32,000 --> 01:01:36,000
就是 omega 和这个单位欧姆之间

2139
01:01:36,000 --> 01:01:37,000
它们其实各有一个马位

2140
01:01:37,000 --> 01:01:40,000
但它们其实本质上是完全是同一个字符

2141
01:01:40,000 --> 01:01:43,000
那么它们有的时候也需要一种等价的处理方式

2142
01:01:43,000 --> 01:01:45,000
对

2143
01:01:45,000 --> 01:01:48,000
这就是那个认知的问题

2144
01:01:48,000 --> 01:01:49,000
就是我们人类在说

2145
01:01:49,000 --> 01:01:51,000
我看见这个符号的时候

2146
01:01:51,000 --> 01:01:53,000
我想的是哪个东西

2147
01:01:53,000 --> 01:01:54,000
对对对

2148
01:01:54,000 --> 01:01:56,000
另外还有像日语的一些遗留问题

2149
01:01:56,000 --> 01:01:59,000
比如说日语有半角和拳角的问题

2150
01:01:59,000 --> 01:02:00,000
这样子

2151
01:02:00,000 --> 01:02:00,000
对

2152
01:02:00,000 --> 01:02:03,000
日语就坑多了

2153
01:02:03,000 --> 01:02:04,000
因为大家也知道

2154
01:02:04,000 --> 01:02:06,000
比如说像日文普通的五十音图里面

2155
01:02:06,000 --> 01:02:10,000
加上两点就会变成拙音

2156
01:02:10,000 --> 01:02:11,000
就变成 ga gigu ge go ma

2157
01:02:11,000 --> 01:02:12,000
所以呢

2158
01:02:12,000 --> 01:02:14,000
首先它就会有这种

2159
01:02:14,000 --> 01:02:17,000
就所谓的加点这种组合的问题

2160
01:02:17,000 --> 01:02:19,000
比如说 ka

2161
01:02:19,000 --> 01:02:20,000
如果是 ga 的话

2162
01:02:20,000 --> 01:02:22,000
它可能是一个字 ga

2163
01:02:22,000 --> 01:02:26,000
也可能是 ka 加上两点变成的 ga

2164
01:02:26,000 --> 01:02:29,000
首先这是有刚才说的这个组合问题

2165
01:02:29,000 --> 01:02:29,000
然后呢

2166
01:02:29,000 --> 01:02:31,000
也有刚才一个字形不同的问题

2167
01:02:31,000 --> 01:02:34,000
就因为要有那个等价关系

2168
01:02:34,000 --> 01:02:35,000
一个 ka 的话

2169
01:02:35,000 --> 01:02:37,000
它可能可以是半角的

2170
01:02:37,000 --> 01:02:40,000
也可以是拳角的

2171
01:02:40,000 --> 01:02:40,000
嗯

2172
01:02:40,000 --> 01:02:41,000
半角拳

2173
01:02:41,000 --> 01:02:43,000
半角的拼甲名是

2174
01:02:43,000 --> 01:02:45,000
也是因为历史上

2175
01:02:45,000 --> 01:02:47,000
有这个 ASCII

2176
01:02:47,000 --> 01:02:49,000
日本人自己扩展的问题

2177
01:02:49,000 --> 01:02:51,000
所以它必须有个向后金融性

2178
01:02:51,000 --> 01:02:54,000
它要保持这个半角拼甲名

2179
01:02:54,000 --> 01:02:55,000
就以前发电报时候用的

2180
01:02:55,000 --> 01:02:57,000
所以这也是一个向后金融

2181
01:02:57,000 --> 01:02:59,000
留下来的一个坑

2182
01:02:59,000 --> 01:02:59,000
对

2183
01:02:59,000 --> 01:03:00,000
基本上就是当年

2184
01:03:00,000 --> 01:03:03,000
跑步进入新西时代的这些国家

2185
01:03:03,000 --> 01:03:04,000
各自为战

2186
01:03:04,000 --> 01:03:04,000
然后

2187
01:03:04,000 --> 01:03:07,000
才导致的今天

2188
01:03:07,000 --> 01:03:11,000
才导致的今天有什么 ISO 8859

2189
01:03:11,000 --> 01:03:14,000
或者是 JIS 的 standard

2190
01:03:14,000 --> 01:03:15,000
然后 UNIQ 不得不

2191
01:03:15,000 --> 01:03:18,000
捏着鼻子把这些历史的问题

2192
01:03:18,000 --> 01:03:19,000
全都收进来

2193
01:03:19,000 --> 01:03:20,000
所以才会有这样的问题

2194
01:03:20,000 --> 01:03:21,000
就如果我们今天能够把

2195
01:03:21,000 --> 01:03:23,000
人类社会推导重来

2196
01:03:23,000 --> 01:03:24,000
然后把信息技术

2197
01:03:24,000 --> 01:03:25,000
从头再来的话

2198
01:03:25,000 --> 01:03:27,000
那很多东西都会不一样

2199
01:03:27,000 --> 01:03:28,000
ASCII 也是

2200
01:03:28,000 --> 01:03:30,000
就是编码也是

2201
01:03:30,000 --> 01:03:31,000
也是里面的一个

2202
01:03:31,000 --> 01:03:36,000
所以这个规范化解决的问题

2203
01:03:36,000 --> 01:03:37,000
其实就是说看

2204
01:03:37,000 --> 01:03:38,000
就是

2205
01:03:38,000 --> 01:03:39,000
它是一个

2206
01:03:39,000 --> 01:03:41,000
可以理解为它是一个

2207
01:03:41,000 --> 01:03:43,000
查找到一个表

2208
01:03:43,000 --> 01:03:46,000
通过这个表可以找到说

2209
01:03:46,000 --> 01:03:48,000
哪些 UNIQ 的这种

2210
01:03:48,000 --> 01:03:51,000
一个 UNIQ 字符串

2211
01:03:51,000 --> 01:03:53,000
它两个的意义其实是等价的

2212
01:03:53,000 --> 01:03:53,000
它解决这么一个问题

2213
01:03:53,000 --> 01:03:57,000
所以大家去看 UNIQ 的的话

2214
01:03:57,000 --> 01:03:59,000
就专门它有个标准复录

2215
01:03:59,000 --> 01:04:02,000
那 Normalization 是在标准复录的

2216
01:04:02,000 --> 01:04:04,000
第 15 号里面会有

2217
01:04:04,000 --> 01:04:05,000
就是具体的

2218
01:04:05,000 --> 01:04:07,000
这个组合是等于什么什么的

2219
01:04:07,000 --> 01:04:08,000
它有这个机制的介绍

2220
01:04:08,000 --> 01:04:10,000
和各个语言

2221
01:04:10,000 --> 01:04:12,000
所有 UNIQ 里面带的

2222
01:04:12,000 --> 01:04:12,000
一个 Normalization

2223
01:04:12,000 --> 01:04:13,000
它有一个表格

2224
01:04:13,000 --> 01:04:14,000
刷的都有

2225
01:04:14,000 --> 01:04:16,000
然后如果大家去看

2226
01:04:16,000 --> 01:04:17,000
发现各个语言都有

2227
01:04:17,000 --> 01:04:18,000
很奇怪的

2228
01:04:18,000 --> 01:04:19,000
就各种等价

2229
01:04:19,000 --> 01:04:19,000
对

2230
01:04:19,000 --> 01:04:22,000
其实我记得以前

2231
01:04:22,000 --> 01:04:24,000
前这个 Swift 的语言

2232
01:04:24,000 --> 01:04:25,000
当然这个比较

2233
01:04:25,000 --> 01:04:27,000
这个部分

2234
01:04:27,000 --> 01:04:28,000
可能比较内核恐慌

2235
01:04:28,000 --> 01:04:29,000
就是 Swift 的语言

2236
01:04:29,000 --> 01:04:31,000
好像在上一版里面

2237
01:04:31,000 --> 01:04:33,000
又改变了字符串的

2238
01:04:33,000 --> 01:04:34,000
那个表达方法

2239
01:04:34,000 --> 01:04:36,000
字符串现在又是一个 collection

2240
01:04:36,000 --> 01:04:39,000
然后并且它就是

2241
01:04:39,000 --> 01:04:41,000
支持你直接 compare

2242
01:04:41,000 --> 01:04:42,000
两个字符串

2243
01:04:42,000 --> 01:04:45,000
是否相等

2244
01:04:45,000 --> 01:04:46,000
然后这个相等依据

2245
01:04:46,000 --> 01:04:47,000
就是他们的

2246
01:04:47,000 --> 01:04:51,000
在做 UNIQ 的 Normalization 之后

2247
01:04:51,000 --> 01:04:51,000
是不是相等

2248
01:04:51,000 --> 01:04:52,000
比如说你

2249
01:04:52,000 --> 01:04:53,000
这两个字符串

2250
01:04:53,000 --> 01:04:54,000
可能在

2251
01:04:54,000 --> 01:04:58,000
byte 层面上是不一样的

2252
01:04:58,000 --> 01:04:58,000
一个是

2253
01:04:58,000 --> 01:05:00,000
一个的

2254
01:05:00,000 --> 01:05:01,000
一个字符串

2255
01:05:01,000 --> 01:05:02,000
里面的 U

2256
01:05:02,000 --> 01:05:03,000
上面加点

2257
01:05:03,000 --> 01:05:04,000
可能是 ASCII 的

2258
01:05:04,000 --> 01:05:06,000
那个 MARWEI 220

2259
01:05:06,000 --> 01:05:07,000
另外一个可能是

2260
01:05:07,000 --> 01:05:09,000
一个 U 加上两个点

2261
01:05:09,000 --> 01:05:11,000
但是如果你问

2262
01:05:11,000 --> 01:05:12,000
在 Swift 里面

2263
01:05:12,000 --> 01:05:13,000
问这两个字符串

2264
01:05:13,000 --> 01:05:14,000
是不是相等的话

2265
01:05:14,000 --> 01:05:15,000
Swift 会说

2266
01:05:15,000 --> 01:05:17,000
这两个字符上是相等的

2267
01:05:17,000 --> 01:05:17,000
对

2268
01:05:17,000 --> 01:05:18,000
所以

2269
01:05:18,000 --> 01:05:20,000
这有时候不太喜欢

2270
01:05:20,000 --> 01:05:21,000
那个 Swift 的地方

2271
01:05:21,000 --> 01:05:22,000
他老是把一些

2272
01:05:22,000 --> 01:05:23,000
本来该交给

2273
01:05:23,000 --> 01:05:24,000
这个 Library 来做的事情

2274
01:05:24,000 --> 01:05:26,000
放到这个 Language

2275
01:05:26,000 --> 01:05:27,000
在此面来搞

2276
01:05:27,000 --> 01:05:27,000
就搞得很乱

2277
01:05:27,000 --> 01:05:28,000
对

2278
01:05:28,000 --> 01:05:30,000
他没有某一种

2279
01:05:30,000 --> 01:05:31,000
选项机制吗

2280
01:05:31,000 --> 01:05:33,000
就是什么情况下

2281
01:05:33,000 --> 01:05:33,000
我要认为

2282
01:05:33,000 --> 01:05:34,000
他们是相等

2283
01:05:34,000 --> 01:05:35,000
什么情况下

2284
01:05:35,000 --> 01:05:36,000
认为通常是不相等

2285
01:05:36,000 --> 01:05:37,000
其实现在是有的

2286
01:05:37,000 --> 01:05:37,000
就是

2287
01:05:37,000 --> 01:05:38,000
现在的

2288
01:05:38,000 --> 01:05:40,000
思路就是

2289
01:05:40,000 --> 01:05:41,000
如果你把它

2290
01:05:41,000 --> 01:05:42,000
当做一个

2291
01:05:42,000 --> 01:05:45,000
String 来处理的话

2292
01:05:45,000 --> 01:05:46,000
那么他默认是

2293
01:05:46,000 --> 01:05:47,000
一个 Unical 的 String

2294
01:05:47,000 --> 01:05:48,000
然后我刚才说的

2295
01:05:48,000 --> 01:05:50,000
就是他们在 Normalization 之后

2296
01:05:50,000 --> 01:05:51,000
相等

2297
01:05:51,000 --> 01:05:52,000
就算相等

2298
01:05:52,000 --> 01:05:53,000
而如果你要

2299
01:05:53,000 --> 01:05:54,000
一定要比较

2300
01:05:54,000 --> 01:05:56,000
比较他们在

2301
01:05:56,000 --> 01:05:57,000
Byte 层面上的

2302
01:05:57,000 --> 01:05:58,000
大小的话

2303
01:05:58,000 --> 01:05:58,000
你需要

2304
01:05:58,000 --> 01:06:00,000
取出他们的

2305
01:06:00,000 --> 01:06:01,000
我想想

2306
01:06:01,000 --> 01:06:02,000
是 Charset 吧

2307
01:06:02,000 --> 01:06:02,000
还是

2308
01:06:02,000 --> 01:06:04,000
就是你可以

2309
01:06:04,000 --> 01:06:04,000
把它们

2310
01:06:04,000 --> 01:06:06,000
转化为另外一种形式

2311
01:06:06,000 --> 01:06:07,000
来比较

2312
01:06:07,000 --> 01:06:08,000
然后这样的话

2313
01:06:08,000 --> 01:06:08,000
再比较

2314
01:06:08,000 --> 01:06:10,000
就不相当

2315
01:06:10,000 --> 01:06:13,000
好吧

2316
01:06:13,000 --> 01:06:15,000
那看来这个 Normalization

2317
01:06:15,000 --> 01:06:16,000
是很必要的

2318
01:06:16,000 --> 01:06:18,000
那我们在就跟大家介绍

2319
01:06:18,000 --> 01:06:20,000
各种不同的 Normalization

2320
01:06:20,000 --> 01:06:21,000
规范化

2321
01:06:21,000 --> 01:06:22,000
这是另外一个坑

2322
01:06:22,000 --> 01:06:23,000
就大家都来做

2323
01:06:23,000 --> 01:06:24,000
规范化就好了吗

2324
01:06:24,000 --> 01:06:25,000
同样规范化就

2325
01:06:25,000 --> 01:06:26,000
大家都按同样的

2326
01:06:26,000 --> 01:06:27,000
规范化来做

2327
01:06:27,000 --> 01:06:28,000
这个事情

2328
01:06:28,000 --> 01:06:29,000
规范化的方法不一样

2329
01:06:29,000 --> 01:06:31,000
对

2330
01:06:31,000 --> 01:06:32,000
这个坑

2331
01:06:32,000 --> 01:06:33,000
哎呀真是的

2332
01:06:33,000 --> 01:06:34,000
我们需要一个

2333
01:06:34,000 --> 01:06:35,000
Meta Normalization

2334
01:06:35,000 --> 01:06:38,000
其实这里有

2335
01:06:38,000 --> 01:06:39,000
我觉得有两个层面

2336
01:06:39,000 --> 01:06:39,000
就是

2337
01:06:39,000 --> 01:06:41,000
首先就是我们刚才说了

2338
01:06:41,000 --> 01:06:42,000
这个规范化

2339
01:06:42,000 --> 01:06:43,000
它解决的是

2340
01:06:43,000 --> 01:06:45,000
两个 Unical 的 Tron

2341
01:06:45,000 --> 01:06:47,000
它是不是等价

2342
01:06:47,000 --> 01:06:48,000
这样一个问题

2343
01:06:48,000 --> 01:06:49,000
那么这个等价

2344
01:06:49,000 --> 01:06:51,000
其实是有多种意义的

2345
01:06:51,000 --> 01:06:52,000
或者说有多种用途

2346
01:06:52,000 --> 01:06:53,000
有的时候

2347
01:06:53,000 --> 01:06:54,000
我们希望这个等价

2348
01:06:54,000 --> 01:06:55,000
是一个相对来说

2349
01:06:55,000 --> 01:06:57,000
比较严格的等价

2350
01:06:57,000 --> 01:06:57,000
他们只是

2351
01:06:57,000 --> 01:06:59,000
我们对一种字符的

2352
01:06:59,000 --> 01:07:00,000
分解方式

2353
01:07:00,000 --> 01:07:02,000
或者组合方式的认知不同

2354
01:07:02,000 --> 01:07:03,000
那么有的时候

2355
01:07:03,000 --> 01:07:04,000
我们可能对这个等价

2356
01:07:04,000 --> 01:07:06,000
要求是比较宽松的

2357
01:07:06,000 --> 01:07:07,000
他们可能是一种

2358
01:07:07,000 --> 01:07:08,000
更宽松的

2359
01:07:08,000 --> 01:07:09,000
语义层面的等价

2360
01:07:09,000 --> 01:07:10,000
因为我们有这个搜索的需求

2361
01:07:10,000 --> 01:07:11,000
对吧

2362
01:07:11,000 --> 01:07:13,000
所以呢

2363
01:07:13,000 --> 01:07:14,000
等价

2364
01:07:14,000 --> 01:07:14,000
就是

2365
01:07:14,000 --> 01:07:16,000
所谓的规范化呢

2366
01:07:16,000 --> 01:07:17,000
它有两大类

2367
01:07:17,000 --> 01:07:19,000
然后每个大类

2368
01:07:19,000 --> 01:07:21,000
又有两小类

2369
01:07:21,000 --> 01:07:22,000
所以一共有四种

2370
01:07:22,000 --> 01:07:26,000
两大类就是标准

2371
01:07:26,000 --> 01:07:27,000
标准等价

2372
01:07:27,000 --> 01:07:29,000
和这个兼容性的等价

2373
01:07:29,000 --> 01:07:29,000
刚才说了

2374
01:07:29,000 --> 01:07:30,000
兼容就是为了

2375
01:07:30,000 --> 01:07:31,000
大家能

2376
01:07:31,000 --> 01:07:33,000
比如为了搜索能找到

2377
01:07:33,000 --> 01:07:33,000
所以它有个

2378
01:07:33,000 --> 01:07:34,000
向后兼容的需求

2379
01:07:34,000 --> 01:07:35,000
那兼容的话

2380
01:07:35,000 --> 01:07:36,000
它有两种

2381
01:07:36,000 --> 01:07:37,000
那标准

2382
01:07:37,000 --> 01:07:39,000
标准的规范化呢

2383
01:07:39,000 --> 01:07:39,000
有两种

2384
01:07:39,000 --> 01:07:41,000
那一种呢就是叫什么

2385
01:07:41,000 --> 01:07:42,000
D 型

2386
01:07:42,000 --> 01:07:43,000
有 C 型

2387
01:07:43,000 --> 01:07:43,000
D 型

2388
01:07:43,000 --> 01:07:45,000
C 型那个叫什么

2389
01:07:45,000 --> 01:07:48,000
先分解

2390
01:07:48,000 --> 01:07:49,000
后

2391
01:07:49,000 --> 01:07:50,000
后合成

2392
01:07:50,000 --> 01:07:51,000
是吧

2393
01:07:51,000 --> 01:07:51,000
对

2394
01:07:51,000 --> 01:07:53,000
先 decomposate

2395
01:07:53,000 --> 01:07:55,000
然后再 composate

2396
01:07:55,000 --> 01:07:56,000
然后

2397
01:07:56,000 --> 01:07:58,000
D 型的话就是

2398
01:07:58,000 --> 01:08:00,000
就是分解掉

2399
01:08:00,000 --> 01:08:01,000
这个按照

2400
01:08:01,000 --> 01:08:02,000
按照分解掉

2401
01:08:02,000 --> 01:08:04,000
然后兼容分解

2402
01:08:04,000 --> 01:08:05,000
也两小类也是

2403
01:08:05,000 --> 01:08:06,000
就是兼容的

2404
01:08:06,000 --> 01:08:07,000
默认是分解的

2405
01:08:07,000 --> 01:08:09,000
或者是兼容性的

2406
01:08:09,000 --> 01:08:10,000
先分解

2407
01:08:10,000 --> 01:08:10,000
后

2408
01:08:10,000 --> 01:08:12,000
后组合

2409
01:08:12,000 --> 01:08:12,000
嗯

2410
01:08:12,000 --> 01:08:14,000
然后

2411
01:08:14,000 --> 01:08:15,000
很坑了一点

2412
01:08:15,000 --> 01:08:16,000
就是操作系统

2413
01:08:16,000 --> 01:08:17,000
它又分别

2414
01:08:17,000 --> 01:08:18,000
又采用了

2415
01:08:18,000 --> 01:08:19,000
不同的方法

2416
01:08:19,000 --> 01:08:20,000
所以呢

2417
01:08:20,000 --> 01:08:22,000
这又跟操纵系统

2418
01:08:22,000 --> 01:08:22,000
有关系

2419
01:08:22,000 --> 01:08:24,000
那最近呢

2420
01:08:24,000 --> 01:08:24,000
这个

2421
01:08:24,000 --> 01:08:25,000
Normalization

2422
01:08:25,000 --> 01:08:26,000
提上话题的话

2423
01:08:26,000 --> 01:08:27,000
就有一个

2424
01:08:27,000 --> 01:08:28,000
很有意思的

2425
01:08:28,000 --> 01:08:29,000
一个时机

2426
01:08:29,000 --> 01:08:29,000
就是因为

2427
01:08:29,000 --> 01:08:30,000
刚好苹果

2428
01:08:30,000 --> 01:08:32,000
要改文件系统了

2429
01:08:32,000 --> 01:08:32,000
OK

2430
01:08:32,000 --> 01:08:33,000
上次

2431
01:08:33,000 --> 01:08:34,000
WDC

2432
01:08:34,000 --> 01:08:35,000
出来了消息

2433
01:08:35,000 --> 01:08:36,000
对

2434
01:08:36,000 --> 01:08:37,000
我们好像之前

2435
01:08:37,000 --> 01:08:39,000
还提过了

2436
01:08:39,000 --> 01:08:39,000
对

2437
01:08:39,000 --> 01:08:41,000
现在我们跑的

2438
01:08:41,000 --> 01:08:41,000
iOS

2439
01:08:41,000 --> 01:08:43,000
10 点

2440
01:08:43,000 --> 01:08:44,000
几来

2441
01:08:44,000 --> 01:08:44,000
3

2442
01:08:44,000 --> 01:08:46,000
现在的 10.3

2443
01:08:46,000 --> 01:08:48,000
已经是新的系统了

2444
01:08:48,000 --> 01:08:48,000
对

2445
01:08:48,000 --> 01:08:50,000
已经是 APFS 了

2446
01:08:50,000 --> 01:08:50,000
对

2447
01:08:50,000 --> 01:08:53,000
就 Apple File System

2448
01:08:53,000 --> 01:08:54,000
你们知道

2449
01:08:54,000 --> 01:08:55,000
为什么

2450
01:08:55,000 --> 01:08:57,000
明明是 Apple File System

2451
01:08:57,000 --> 01:08:58,000
那为什么要缩写

2452
01:08:58,000 --> 01:08:59,000
APFS

2453
01:08:59,000 --> 01:09:00,000
而不是 AFS

2454
01:09:00,000 --> 01:09:02,000
应该不是被占了呀

2455
01:09:02,000 --> 01:09:04,000
对

2456
01:09:04,000 --> 01:09:07,000
原来因为有一个那个苹果文件系服务嘛

2457
01:09:07,000 --> 01:09:09,000
Apple File System

2458
01:09:09,000 --> 01:09:10,000
对

2459
01:09:10,000 --> 01:09:12,000
刚说哪个版本的 Sierra

2460
01:09:12,000 --> 01:09:14,000
已经是 APFS

2461
01:09:14,000 --> 01:09:15,000
下一个就是

2462
01:09:15,000 --> 01:09:16,000
HiSierra

2463
01:09:16,000 --> 01:09:17,000
才会是

2464
01:09:17,000 --> 01:09:18,000
HiSierra

2465
01:09:18,000 --> 01:09:18,000
才是

2466
01:09:18,000 --> 01:09:19,000
对

2467
01:09:19,000 --> 01:09:20,000
iOS 的话更快

2468
01:09:20,000 --> 01:09:22,000
iOS 在 10.3

2469
01:09:22,000 --> 01:09:23,000
就已经

2470
01:09:23,000 --> 01:09:24,000
把这个文件

2471
01:09:24,000 --> 01:09:27,000
改为了 APFS 了

2472
01:09:27,000 --> 01:09:28,000
嗯哼

2473
01:09:28,000 --> 01:09:29,000
而在

2474
01:09:29,000 --> 01:09:30,000
在之前

2475
01:09:30,000 --> 01:09:31,000
也就是说

2476
01:09:31,000 --> 01:09:31,000
现在的

2477
01:09:31,000 --> 01:09:32,000
呃

2478
01:09:32,000 --> 01:09:33,000
我们的 Mac 呢

2479
01:09:33,000 --> 01:09:34,000
都是 HFS

2480
01:09:34,000 --> 01:09:35,000
加

2481
01:09:35,000 --> 01:09:36,000
这是一个超

2482
01:09:36,000 --> 01:09:37,000
好老啊

2483
01:09:37,000 --> 01:09:38,000
这个已经十几年

2484
01:09:38,000 --> 01:09:39,000
多少

2485
01:09:39,000 --> 01:09:39,000
不

2486
01:09:39,000 --> 01:09:40,000
八几年的

2487
01:09:40,000 --> 01:09:41,000
八几年的文件系统

2488
01:09:41,000 --> 01:09:42,000
超老

2489
01:09:42,000 --> 01:09:43,000
嗯

2490
01:09:43,000 --> 01:09:43,000
对啊

2491
01:09:43,000 --> 01:09:44,000
终于

2492
01:09:44,000 --> 01:09:45,000
嗯

2493
01:09:45,000 --> 01:09:46,000
要苹果一咬牙

2494
01:09:46,000 --> 01:09:46,000
也狠心

2495
01:09:46,000 --> 01:09:47,000
要换

2496
01:09:47,000 --> 01:09:48,000
把它给它换掉

2497
01:09:48,000 --> 01:09:49,000
那换掉了以后呢

2498
01:09:49,000 --> 01:09:50,000
就是出现了一个问题

2499
01:09:50,000 --> 01:09:50,000
就是

2500
01:09:50,000 --> 01:09:52,000
在这个新的

2501
01:09:52,000 --> 01:09:53,000
APFS

2502
01:09:53,000 --> 01:09:54,000
里面呢

2503
01:09:54,000 --> 01:09:55,000
它

2504
01:09:55,000 --> 01:09:56,000
把这个

2505
01:09:56,000 --> 01:09:57,000
原来的

2506
01:09:57,000 --> 01:09:57,000
Normalization

2507
01:09:57,000 --> 01:09:58,000
系统默认的

2508
01:09:58,000 --> 01:09:58,000
Normalization

2509
01:09:58,000 --> 01:09:59,000
换掉了

2510
01:09:59,000 --> 01:10:02,000
因为新的 APFS 呢

2511
01:10:02,000 --> 01:10:03,000
它是叫

2512
01:10:03,000 --> 01:10:04,000
Normalization 的

2513
01:10:04,000 --> 01:10:05,000
Insensitive

2514
01:10:05,000 --> 01:10:06,000
它是不敏感的

2515
01:10:06,000 --> 01:10:07,000
对这个规范化

2516
01:10:07,000 --> 01:10:09,000
不敏感的

2517
01:10:09,000 --> 01:10:09,000
啊

2518
01:10:09,000 --> 01:10:10,000
所以就说

2519
01:10:10,000 --> 01:10:11,000
呃

2520
01:10:11,000 --> 01:10:12,000
无论

2521
01:10:12,000 --> 01:10:13,000
它可以

2522
01:10:13,000 --> 01:10:13,000
呃

2523
01:10:13,000 --> 01:10:14,000
到时候你就是

2524
01:10:14,000 --> 01:10:15,000
它都能找到

2525
01:10:15,000 --> 01:10:16,000
这个文件

2526
01:10:16,000 --> 01:10:17,000
因为刚才说了

2527
01:10:17,000 --> 01:10:17,000
它如果你

2528
01:10:17,000 --> 01:10:19,000
如果对它不敏感的话

2529
01:10:19,000 --> 01:10:19,000
搜索

2530
01:10:19,000 --> 01:10:20,000
就更容易搜索到嘛

2531
01:10:20,000 --> 01:10:22,000
就是无论你是用

2532
01:10:22,000 --> 01:10:23,000
什么样的规范化

2533
01:10:23,000 --> 01:10:24,000
来做的话

2534
01:10:24,000 --> 01:10:25,000
它都能指向

2535
01:10:25,000 --> 01:10:25,000
这个文件

2536
01:10:25,000 --> 01:10:26,000
嗯

2537
01:10:26,000 --> 01:10:28,000
以前呢

2538
01:10:28,000 --> 01:10:29,000
会有

2539
01:10:29,000 --> 01:10:30,000
坑的问题

2540
01:10:30,000 --> 01:10:31,000
而对于

2541
01:10:31,000 --> 01:10:32,000
用日语的朋友来讲

2542
01:10:32,000 --> 01:10:33,000
这个是最坑的问题

2543
01:10:33,000 --> 01:10:34,000
我们在

2544
01:10:34,000 --> 01:10:35,000
我刚才说了

2545
01:10:35,000 --> 01:10:36,000
就因为日文

2546
01:10:36,000 --> 01:10:37,000
经常要用

2547
01:10:37,000 --> 01:10:38,000
会涉及到

2548
01:10:38,000 --> 01:10:39,000
就采到这个

2549
01:10:39,000 --> 01:10:40,000
规范化的坑

2550
01:10:40,000 --> 01:10:41,000
是因为日文

2551
01:10:41,000 --> 01:10:42,000
像刚才说的

2552
01:10:42,000 --> 01:10:43,000
卓音点是经常用的嘛

2553
01:10:43,000 --> 01:10:44,000
然后

2554
01:10:44,000 --> 01:10:46,000
经常会出现在

2555
01:10:46,000 --> 01:10:49,000
日文的 Windows 的文件名

2556
01:10:49,000 --> 01:10:50,000
考到 Mac 的时候

2557
01:10:50,000 --> 01:10:52,000
刚才说

2558
01:10:52,000 --> 01:10:53,000
凡是带有

2559
01:10:53,000 --> 01:10:54,000
那个卓音点的字

2560
01:10:54,000 --> 01:10:56,000
放到 Mac 里面

2561
01:10:56,000 --> 01:10:58,000
就被拆成了两个字

2562
01:10:58,000 --> 01:11:00,000
然后

2563
01:11:00,000 --> 01:11:01,000
因为是两个字

2564
01:11:01,000 --> 01:11:02,000
你还可以一个字

2565
01:11:02,000 --> 01:11:03,000
一个字

2566
01:11:03,000 --> 01:11:03,000
删除

2567
01:11:03,000 --> 01:11:04,000
所以你可以把

2568
01:11:04,000 --> 01:11:05,000
那个卓音点

2569
01:11:05,000 --> 01:11:06,000
分别删除

2570
01:11:06,000 --> 01:11:09,000
这是因为

2571
01:11:09,000 --> 01:11:12,000
在老的 HFS 家的时候呢

2572
01:11:12,000 --> 01:11:14,000
这也就是 Mac

2573
01:11:14,000 --> 01:11:15,000
现在用的这个

2574
01:11:15,000 --> 01:11:17,000
这个系统里面呢

2575
01:11:17,000 --> 01:11:18,000
它对这个

2576
01:11:18,000 --> 01:11:19,000
Normalization 的处理

2577
01:11:19,000 --> 01:11:20,000
是不一样的

2578
01:11:20,000 --> 01:11:22,000
因为它采用的是

2579
01:11:22,000 --> 01:11:24,000
就分解优先

2580
01:11:24,000 --> 01:11:24,000
所以它

2581
01:11:24,000 --> 01:11:26,000
它会把这个字

2582
01:11:26,000 --> 01:11:26,000
拆成

2583
01:11:26,000 --> 01:11:27,000
认成是两个字

2584
01:11:27,000 --> 01:11:30,000
这里可能要解释一下

2585
01:11:30,000 --> 01:11:31,000
这个背景

2586
01:11:31,000 --> 01:11:31,000
就是为什么

2587
01:11:31,000 --> 01:11:32,000
从改了一个文件系统

2588
01:11:32,000 --> 01:11:33,000
会导致

2589
01:11:33,000 --> 01:11:34,000
这个

2590
01:11:34,000 --> 01:11:35,000
这个

2591
01:11:35,000 --> 01:11:36,000
Normalization 的问题

2592
01:11:36,000 --> 01:11:37,000
因为

2593
01:11:37,000 --> 01:11:38,000
HFS Plus

2594
01:11:38,000 --> 01:11:39,000
就是那个

2595
01:11:39,000 --> 01:11:40,000
旧的那个文件系统

2596
01:11:40,000 --> 01:11:40,000
是对这个

2597
01:11:40,000 --> 01:11:42,000
有一个默认的

2598
01:11:42,000 --> 01:11:43,000
一个处理的

2599
01:11:43,000 --> 01:11:44,000
就是那个文件系统

2600
01:11:44,000 --> 01:11:45,000
它其实是知道

2601
01:11:45,000 --> 01:11:46,000
你写进去

2602
01:11:46,000 --> 01:11:47,000
一个文件名

2603
01:11:47,000 --> 01:11:48,000
它会帮你

2604
01:11:48,000 --> 01:11:48,000
去自动

2605
01:11:48,000 --> 01:11:49,000
做一遍

2606
01:11:49,000 --> 01:11:50,000
这个 Normalization

2607
01:11:50,000 --> 01:11:50,000
是这样

2608
01:11:50,000 --> 01:11:51,000
如果没记错的话

2609
01:11:51,000 --> 01:11:53,000
然后这个

2610
01:11:53,000 --> 01:11:54,000
APFS

2611
01:11:54,000 --> 01:11:54,000
其实

2612
01:11:54,000 --> 01:11:55,000
之前那个设计

2613
01:11:55,000 --> 01:11:56,000
其实是有点问题的

2614
01:11:56,000 --> 01:11:57,000
因为照理说

2615
01:11:57,000 --> 01:11:58,000
一个文件系统

2616
01:11:58,000 --> 01:11:59,000
不应该去

2617
01:11:59,000 --> 01:11:59,000
参呼

2618
01:11:59,000 --> 01:12:01,000
这种应用层的事情

2619
01:12:01,000 --> 01:12:01,000
对吧

2620
01:12:01,000 --> 01:12:04,000
因为这个

2621
01:12:04,000 --> 01:12:06,000
这是应用层的事情吗

2622
01:12:06,000 --> 01:12:08,000
这显然是应用层的问题

2623
01:12:08,000 --> 01:12:09,000
因为文件系统

2624
01:12:09,000 --> 01:12:09,000
应该

2625
01:12:09,000 --> 01:12:10,000
就是

2626
01:12:10,000 --> 01:12:11,000
这可能有一点

2627
01:12:11,000 --> 01:12:12,000
其实

2628
01:12:12,000 --> 01:12:13,000
其实这里有个哲学问题

2629
01:12:13,000 --> 01:12:14,000
就是这也是我一个疑问

2630
01:12:14,000 --> 01:12:16,000
就是 Normalization

2631
01:12:16,000 --> 01:12:17,000
究竟是应该在

2632
01:12:17,000 --> 01:12:18,000
这个存储的

2633
01:12:18,000 --> 01:12:21,000
层级上发明的

2634
01:12:21,000 --> 01:12:21,000
对

2635
01:12:21,000 --> 01:12:23,000
还是在这个应用

2636
01:12:23,000 --> 01:12:25,000
调用某一个数据的过程中

2637
01:12:25,000 --> 01:12:26,000
对它进行实施的出

2638
01:12:26,000 --> 01:12:27,000
因为本质上

2639
01:12:27,000 --> 01:12:28,000
你说

2640
01:12:28,000 --> 01:12:29,000
对于一个文件系统来说

2641
01:12:29,000 --> 01:12:30,000
它并不关心

2642
01:12:30,000 --> 01:12:31,000
里面存的内容是什么

2643
01:12:31,000 --> 01:12:32,000
就是你给我一堆 bytes

2644
01:12:32,000 --> 01:12:33,000
对吧

2645
01:12:33,000 --> 01:12:34,000
然后我把这个 bytes

2646
01:12:34,000 --> 01:12:35,000
按照某一种规则

2647
01:12:35,000 --> 01:12:36,000
存起来

2648
01:12:36,000 --> 01:12:37,000
然后到时候

2649
01:12:37,000 --> 01:12:38,000
到时候你在问我要

2650
01:12:38,000 --> 01:12:39,000
这堆 bytes 的时候

2651
01:12:39,000 --> 01:12:40,000
我就把这堆 bytes

2652
01:12:40,000 --> 01:12:40,000
就还给你

2653
01:12:40,000 --> 01:12:42,000
但是我需要一个

2654
01:12:42,000 --> 01:12:42,000
一个 key

2655
01:12:42,000 --> 01:12:44,000
找到这堆 bytes

2656
01:12:44,000 --> 01:12:45,000
这个 key 就是

2657
01:12:45,000 --> 01:12:46,000
所有的文件名和路径

2658
01:12:46,000 --> 01:12:47,000
那么

2659
01:12:47,000 --> 01:12:49,000
APFS 最开始的

2660
01:12:49,000 --> 01:12:50,000
它的逻辑

2661
01:12:50,000 --> 01:12:51,000
我记得当时

2662
01:12:51,000 --> 01:12:51,000
他说过

2663
01:12:51,000 --> 01:12:52,000
他说对这个问题

2664
01:12:52,000 --> 01:12:53,000
他是完全

2665
01:12:53,000 --> 01:12:55,000
不过问这些东西

2666
01:12:55,000 --> 01:12:56,000
你给我什么

2667
01:12:56,000 --> 01:12:57,000
你给我那个文件叫什么

2668
01:12:57,000 --> 01:12:58,000
我就写什么

2669
01:12:58,000 --> 01:12:59,000
但是在

2670
01:12:59,000 --> 01:13:00,000
HFS 里面

2671
01:13:00,000 --> 01:13:01,000
他其实是

2672
01:13:01,000 --> 01:13:01,000
已经

2673
01:13:01,000 --> 01:13:03,000
他会去解析

2674
01:13:03,000 --> 01:13:04,000
那个文件名的

2675
01:13:04,000 --> 01:13:05,000
那个格式和内容的

2676
01:13:05,000 --> 01:13:07,000
规范化这个事情

2677
01:13:07,000 --> 01:13:09,000
是一个逻辑的概念

2678
01:13:09,000 --> 01:13:09,000
它并不是

2679
01:13:09,000 --> 01:13:11,000
它是我们在

2680
01:13:11,000 --> 01:13:12,000
做这个叫做

2681
01:13:12,000 --> 01:13:13,000
API 的层面

2682
01:13:13,000 --> 01:13:13,000
解决的问题

2683
01:13:13,000 --> 01:13:14,000
但是最终你写到

2684
01:13:14,000 --> 01:13:16,000
那个词盘上的

2685
01:13:16,000 --> 01:13:16,000
那个

2686
01:13:16,000 --> 01:13:18,000
那个东西的时候

2687
01:13:18,000 --> 01:13:18,000
它肯定是一堆

2688
01:13:18,000 --> 01:13:19,000
一堆 bytes 嘛

2689
01:13:19,000 --> 01:13:20,000
嗯

2690
01:13:20,000 --> 01:13:22,000
所以就是

2691
01:13:22,000 --> 01:13:23,000
就是 APFS

2692
01:13:23,000 --> 01:13:25,000
它的这个设计理念

2693
01:13:25,000 --> 01:13:25,000
就是我

2694
01:13:25,000 --> 01:13:27,000
我作为一个文件系统

2695
01:13:27,000 --> 01:13:28,000
一个非常底层的东西

2696
01:13:28,000 --> 01:13:29,000
我不应该去

2697
01:13:29,000 --> 01:13:30,000
猜忽上层逻辑

2698
01:13:30,000 --> 01:13:31,000
API 应该

2699
01:13:31,000 --> 01:13:32,000
应该去解决的问题

2700
01:13:32,000 --> 01:13:33,000
不是

2701
01:13:33,000 --> 01:13:34,000
Rail

2702
01:13:34,000 --> 01:13:35,000
我明白你的意思

2703
01:13:35,000 --> 01:13:35,000
Rail

2704
01:13:35,000 --> 01:13:36,000
我明白你的意思

2705
01:13:36,000 --> 01:13:36,000
但是

2706
01:13:36,000 --> 01:13:37,000
我有个问题

2707
01:13:37,000 --> 01:13:38,000
比如说你说

2708
01:13:38,000 --> 01:13:39,000
你说文件系统

2709
01:13:39,000 --> 01:13:41,000
是一个非常底层的系统

2710
01:13:41,000 --> 01:13:41,000
那么请问

2711
01:13:41,000 --> 01:13:44,000
获得一个文件的路径

2712
01:13:44,000 --> 01:13:46,000
这件事情很底层

2713
01:13:46,000 --> 01:13:47,000
对不对

2714
01:13:47,000 --> 01:13:47,000
那么

2715
01:13:47,000 --> 01:13:49,000
获得一个文件的路径

2716
01:13:49,000 --> 01:13:52,000
跟这个文件的名字

2717
01:13:52,000 --> 01:13:55,000
是以什么样的标准化形式

2718
01:13:55,000 --> 01:13:55,000
写出来的

2719
01:13:55,000 --> 01:13:57,000
有没有关联

2720
01:13:57,000 --> 01:13:59,000
这个对文件系统

2721
01:13:59,000 --> 01:14:00,000
肯定有关联

2722
01:14:00,000 --> 01:14:02,000
但这个不是文件系统

2723
01:14:02,000 --> 01:14:03,000
就对这个文件系统

2724
01:14:03,000 --> 01:14:04,000
没有关系

2725
01:14:04,000 --> 01:14:04,000
因为文件系统拿了

2726
01:14:04,000 --> 01:14:05,000
最终都是一堆 bytes

2727
01:14:05,000 --> 01:14:07,000
它不需要去 concler 这件事情

2728
01:14:07,000 --> 01:14:10,000
其实它做了一次

2729
01:14:10,000 --> 01:14:12,000
Rail 的意思是说

2730
01:14:12,000 --> 01:14:14,000
先规范化再存储这件事情

2731
01:14:14,000 --> 01:14:17,000
不是在文件系统的层面上发生的

2732
01:14:17,000 --> 01:14:18,000
对

2733
01:14:18,000 --> 01:14:19,000
它是在一个

2734
01:14:19,000 --> 01:14:20,000
他们叫做 Foundation

2735
01:14:20,000 --> 01:14:21,000
对

2736
01:14:21,000 --> 01:14:23,000
在操作系统的层面上发生的

2737
01:14:23,000 --> 01:14:25,000
或者是在操作系统

2738
01:14:25,000 --> 01:14:26,000
和文件系统

2739
01:14:26,000 --> 01:14:27,000
就管理文件系统

2740
01:14:27,000 --> 01:14:30,000
那一部分的 API 里面产生的

2741
01:14:30,000 --> 01:14:31,000
而不是文件系统

2742
01:14:31,000 --> 01:14:32,000
本身需要操作这件事情

2743
01:14:32,000 --> 01:14:33,000
对

2744
01:14:33,000 --> 01:14:34,000
但这里就会导致一个问题

2745
01:14:34,000 --> 01:14:37,000
就是它就向后不兼容了

2746
01:14:37,000 --> 01:14:38,000
因为在 HFS 里面

2747
01:14:38,000 --> 01:14:39,000
它是

2748
01:14:39,000 --> 01:14:40,000
就是文件系统

2749
01:14:40,000 --> 01:14:41,000
确实管了这么一件事情

2750
01:14:41,000 --> 01:14:42,000
所以操作系统和包括

2751
01:14:42,000 --> 01:14:44,000
很多应用程序

2752
01:14:44,000 --> 01:14:46,000
它是不需要过度的去考虑这个问题

2753
01:14:46,000 --> 01:14:47,000
你用什么 API

2754
01:14:47,000 --> 01:14:48,000
去访问那个文件

2755
01:14:48,000 --> 01:14:50,000
反正你只要给到它

2756
01:14:50,000 --> 01:14:51,000
它都会通过统一的方法

2757
01:14:51,000 --> 01:14:52,000
规范化

2758
01:14:52,000 --> 01:14:54,000
然后形成统一的一个 bytes

2759
01:14:54,000 --> 01:14:55,000
然后再去通过那个 bytes

2760
01:14:55,000 --> 01:14:57,000
在文件系统里面去找

2761
01:14:57,000 --> 01:15:00,000
就会变成向后兼容的问题了

2762
01:15:00,000 --> 01:15:02,000
但这个问题之所以在 iOS 里面

2763
01:15:02,000 --> 01:15:05,000
没有暴露出来是因为 iOS 并没有

2764
01:15:05,000 --> 01:15:06,000
起码对用户而言没有

2765
01:15:06,000 --> 01:15:08,000
没有暴露出一个文件系统

2766
01:15:08,000 --> 01:15:10,000
起码到目前为止是没有的

2767
01:15:10,000 --> 01:15:10,000
对吧

2768
01:15:10,000 --> 01:15:12,000
那么也就不存在

2769
01:15:12,000 --> 01:15:15,000
就并不会大量存在说

2770
01:15:15,000 --> 01:15:18,000
有很多这个历史文件的名

2771
01:15:18,000 --> 01:15:20,000
它的规范化形式不太对

2772
01:15:20,000 --> 01:15:23,000
导致可能找不回来的一个问题

2773
01:15:23,000 --> 01:15:24,000
但是在 Mac 里面

2774
01:15:24,000 --> 01:15:25,000
就会存在这个问题

2775
01:15:25,000 --> 01:15:27,000
因为 Mac 里面我们现在大量还在使用

2776
01:15:27,000 --> 01:15:29,000
用户直接访问文件系统

2777
01:15:29,000 --> 01:15:30,000
大家还是用 Finder

2778
01:15:30,000 --> 01:15:31,000
对吧

2779
01:15:31,000 --> 01:15:34,000
所以就导致这么一个很尴尬的情况

2780
01:15:34,000 --> 01:15:37,000
所以现在就出的都是一些打补丁的方案

2781
01:15:37,000 --> 01:15:43,000
其实你一直用同样一个系统的话

2782
01:15:43,000 --> 01:15:44,000
相对来讲会好一些

2783
01:15:44,000 --> 01:15:47,000
那就只要是像和 Windows

2784
01:15:47,000 --> 01:15:49,000
像 Windows 因为它默认的

2785
01:15:49,000 --> 01:15:50,000
它规范化的方式不一样

2786
01:15:50,000 --> 01:15:55,000
所以从那边不同规范化的方式

2787
01:15:55,000 --> 01:15:57,000
考过来的东西就会有问题

2788
01:15:57,000 --> 01:16:02,000
你 Mac 一直都用这样一个规范化形式的话

2789
01:16:02,000 --> 01:16:03,000
它其实还相对来讲

2790
01:16:03,000 --> 01:16:05,000
它的那个向后金融线是挺好的

2791
01:16:05,000 --> 01:16:07,000
但是有一个问题是这样的

2792
01:16:07,000 --> 01:16:10,000
就是说因为 APFS 如果按照最开始的设计理念

2793
01:16:10,000 --> 01:16:12,000
是不涉及规范化和你怎么

2794
01:16:12,000 --> 01:16:15,000
就是它不涉及你的文件怎么编码

2795
01:16:15,000 --> 01:16:17,000
你甚至可以不用 UTF 8 编码

2796
01:16:17,000 --> 01:16:18,000
理论是可以的对吧

2797
01:16:18,000 --> 01:16:22,000
APFS 只接受有效的 UTF 8 编码的文件名

2798
01:16:23,000 --> 01:16:24,000
我就说就是说如果它

2799
01:16:24,000 --> 01:16:27,000
就是刚才讲如果它只管是 by 次的话

2800
01:16:27,000 --> 01:16:30,000
它只在字节层面上说你别弱什么

2801
01:16:30,000 --> 01:16:31,000
我就存什么

2802
01:16:31,000 --> 01:16:32,000
对对对

2803
01:16:32,000 --> 01:16:32,000
存什么

2804
01:16:32,000 --> 01:16:34,000
就会有文件系统

2805
01:16:34,000 --> 01:16:36,000
对就昨天刚刚那个问题就是说

2806
01:16:36,000 --> 01:16:37,000
假设我们用那个

2807
01:16:37,000 --> 01:16:40,000
我们就是遵守这个 Apple 的一个规范

2808
01:16:40,000 --> 01:16:42,000
用那些 foundation 的这些 library

2809
01:16:42,000 --> 01:16:44,000
去命名文件去访问文件

2810
01:16:44,000 --> 01:16:46,000
或者 open file 之类的 API 的话

2811
01:16:46,000 --> 01:16:48,000
那你可能得到的是一个路径

2812
01:16:48,000 --> 01:16:48,000
对吧

2813
01:16:48,000 --> 01:16:51,000
然后你在那个就是叫什么来的

2814
01:16:51,000 --> 01:16:53,000
那个命令行的界面下

2815
01:16:53,000 --> 01:16:56,000
你用那个 unix 那套 API 去访问

2816
01:16:56,000 --> 01:16:58,000
又会得到另外一个文件的路径

2817
01:16:58,000 --> 01:16:59,000
它两个可能是不一样的

2818
01:16:59,000 --> 01:17:00,000
这个时候就会发现

2819
01:17:00,000 --> 01:17:02,000
你用那个文件

2820
01:17:02,000 --> 01:17:05,000
你用那个 Mac 的那套 API 去存了一个文件

2821
01:17:05,000 --> 01:17:06,000
然后你在 unix 那边

2822
01:17:06,000 --> 01:17:07,000
那个找不回那个文件了

2823
01:17:07,000 --> 01:17:08,000
就很尴尬

2824
01:17:08,000 --> 01:17:14,000
这个事情当年也存在了

2825
01:17:14,000 --> 01:17:19,000
像当年就是老 Mac 转成 Mac OS X 的时候

2826
01:17:19,000 --> 01:17:21,000
它 Finder 有改

2827
01:17:21,000 --> 01:17:22,000
就是 Mac 开始 9 对吧

2828
01:17:22,000 --> 01:17:23,000
9 改成真正

2829
01:17:23,000 --> 01:17:24,000
O OS X 的时候

2830
01:17:24,000 --> 01:17:26,000
O OS X 是真正的 unix

2831
01:17:26,000 --> 01:17:29,000
但是原来老的 Mac 不是

2832
01:17:29,000 --> 01:17:30,000
对

2833
01:17:30,000 --> 01:17:35,000
所以它那个路径的那个标志分割服都不一样

2834
01:17:35,000 --> 01:17:37,000
就是正写干方写的那个事情

2835
01:17:37,000 --> 01:17:40,000
这个那就是操作系统的事情

2836
01:17:40,000 --> 01:17:44,000
这和它那个文件系统也不搭别人

2837
01:17:44,000 --> 01:17:47,000
那我们其实知道那个 Windows 一直以来

2838
01:17:47,000 --> 01:17:49,000
都是用 NFC 这种形式的

2839
01:17:49,000 --> 01:17:50,000
对吧

2840
01:17:50,000 --> 01:17:52,000
这点这点应该没错吧

2841
01:17:52,000 --> 01:17:54,000
那么 Apple 的话

2842
01:17:54,000 --> 01:17:55,000
对 Apple 的话

2843
01:17:55,000 --> 01:17:58,000
HFS Plus 它是用哪一种形式的

2844
01:17:58,000 --> 01:18:02,000
是用 NFC 还是用 NFD

2845
01:18:02,000 --> 01:18:04,000
这个还真的不知道

2846
01:18:04,000 --> 01:18:04,000
不知道

2847
01:18:04,000 --> 01:18:06,000
我觉得这可能是第一个问题

2848
01:18:06,000 --> 01:18:07,000
然后第二个问题

2849
01:18:07,000 --> 01:18:09,000
可能就是 Rail 刚才说的

2850
01:18:09,000 --> 01:18:13,000
就是在 HFS Plus 的年代里面

2851
01:18:13,000 --> 01:18:14,000
Apple 是

2852
01:18:14,000 --> 01:18:16,000
就是说 MacOS 会做一件事情

2853
01:18:16,000 --> 01:18:18,000
它做这件事情

2854
01:18:18,000 --> 01:18:20,000
就是当你输入一个文件名的时候

2855
01:18:20,000 --> 01:18:24,000
它会帮你转成已经标准化后的形式

2856
01:18:24,000 --> 01:18:26,000
再存储到你的存储戒指上

2857
01:18:26,000 --> 01:18:26,000
对吧

2858
01:18:26,000 --> 01:18:30,000
我理解了没错吧

2859
01:18:30,000 --> 01:18:31,000
应该就是说

2860
01:18:31,000 --> 01:18:33,000
就是刚才 Rail 也说的

2861
01:18:33,000 --> 01:18:36,000
也是就是说在这个文件系统里面

2862
01:18:36,000 --> 01:18:38,000
它我们只说它的 normalization

2863
01:18:38,000 --> 01:18:40,000
它是 sensitive as insensitive

2864
01:18:40,000 --> 01:18:43,000
对这个规范是否敏感

2865
01:18:43,000 --> 01:18:44,000
它没有在做

2866
01:18:44,000 --> 01:18:46,000
的确它只是在存储代码而已

2867
01:18:46,000 --> 01:18:48,000
存储这个 byte 而已

2868
01:18:48,000 --> 01:18:49,000
但是呢

2869
01:18:49,000 --> 01:18:51,000
它是不是对这个 normalization 敏感

2870
01:18:51,000 --> 01:18:52,000
对

2871
01:18:52,000 --> 01:18:53,000
HFS 是

2872
01:18:53,000 --> 01:18:54,000
的确是对了

2873
01:18:54,000 --> 01:18:55,000
normalization 敏感

2874
01:18:55,000 --> 01:18:56,000
但是

2875
01:18:56,000 --> 01:18:58,000
AFS

2876
01:18:58,000 --> 01:18:59,000
AFS

2877
01:18:59,000 --> 01:19:01,000
它就新的就不敏感了

2878
01:19:01,000 --> 01:19:02,000
它就不敏感了

2879
01:19:02,000 --> 01:19:02,000
对

2880
01:19:02,000 --> 01:19:05,000
这个和那个大小写也是一样的

2881
01:19:05,000 --> 01:19:05,000
就是

2882
01:19:05,000 --> 01:19:07,000
sensitive

2883
01:19:07,000 --> 01:19:08,000
这个

2884
01:19:08,000 --> 01:19:09,000
就叫什么

2885
01:19:09,000 --> 01:19:10,000
case sensitive

2886
01:19:10,000 --> 01:19:11,000
和 case insensitive

2887
01:19:11,000 --> 01:19:16,000
这里还有个比较根的一个事情

2888
01:19:16,000 --> 01:19:19,000
就是所谓这个叫做 case preserving

2889
01:19:19,000 --> 01:19:21,000
和这个 normalization preserving 的问题

2890
01:19:21,000 --> 01:19:21,000
对

2891
01:19:21,000 --> 01:19:22,000
嗯

2892
01:19:22,000 --> 01:19:24,000
它可以保持按照道理

2893
01:19:24,000 --> 01:19:25,000
保存下来

2894
01:19:25,000 --> 01:19:26,000
但是它对它不敏感

2895
01:19:26,000 --> 01:19:28,000
就还是当成一样的

2896
01:19:28,000 --> 01:19:29,000
嗯

2897
01:19:29,000 --> 01:19:30,000
是可保存

2898
01:19:30,000 --> 01:19:32,000
但是它不敏感

2899
01:19:32,000 --> 01:19:32,000
嗯

2900
01:19:32,000 --> 01:19:33,000
就是有这样的

2901
01:19:33,000 --> 01:19:34,000
嗯

2902
01:19:34,000 --> 01:19:36,000
现在的话就是新的 APFS

2903
01:19:36,000 --> 01:19:36,000
就是这样

2904
01:19:36,000 --> 01:19:38,000
它可以保存下来

2905
01:19:38,000 --> 01:19:38,000
嗯

2906
01:19:38,000 --> 01:19:38,000
嗯

2907
01:19:38,000 --> 01:19:39,000
然后 NFC

2908
01:19:39,000 --> 01:19:40,000
它也认得

2909
01:19:40,000 --> 01:19:40,000
NFD

2910
01:19:40,000 --> 01:19:41,000
它也认得

2911
01:19:41,000 --> 01:19:42,000
但是呢

2912
01:19:42,000 --> 01:19:42,000
它不敏感

2913
01:19:42,000 --> 01:19:44,000
所以两边都可以

2914
01:19:44,000 --> 01:19:44,000
嗯

2915
01:19:44,000 --> 01:19:45,000
那么其实

2916
01:19:45,000 --> 01:19:47,000
按我的理解

2917
01:19:47,000 --> 01:19:48,000
Apple 并没有改

2918
01:19:48,000 --> 01:19:50,000
它的这个标准化形式

2919
01:19:50,000 --> 01:19:50,000
它改的只是

2920
01:19:50,000 --> 01:19:53,000
它对这个标准化形式

2921
01:19:53,000 --> 01:19:54,000
是不是敏感

2922
01:19:54,000 --> 01:19:54,000
这样一个问题

2923
01:19:54,000 --> 01:19:55,000
嗯

2924
01:19:55,000 --> 01:19:56,000
就是在这个

2925
01:19:56,000 --> 01:19:58,000
所以它对这个文件

2926
01:19:58,000 --> 01:19:59,000
文件名处理

2927
01:19:59,000 --> 01:20:00,000
它的行为

2928
01:20:00,000 --> 01:20:00,000
变

2929
01:20:00,000 --> 01:20:01,000
发生变化了吗

2930
01:20:01,000 --> 01:20:02,000
刚刚我查了一下

2931
01:20:02,000 --> 01:20:04,000
那个 HFS

2932
01:20:04,000 --> 01:20:05,000
plus 用的是

2933
01:20:05,000 --> 01:20:06,000
NFD 的这种

2934
01:20:06,000 --> 01:20:08,000
标准化形式

2935
01:20:08,000 --> 01:20:09,000
那么这个

2936
01:20:09,000 --> 01:20:10,000
这个第一个问题

2937
01:20:10,000 --> 01:20:11,000
就是跟 Windows

2938
01:20:11,000 --> 01:20:12,000
可能是不一样的

2939
01:20:12,000 --> 01:20:13,000
分解优先

2940
01:20:13,000 --> 01:20:13,000
对

2941
01:20:13,000 --> 01:20:14,000
嗯

2942
01:20:14,000 --> 01:20:17,000
可能我们刚才

2943
01:20:17,000 --> 01:20:18,000
把那个带过了

2944
01:20:18,000 --> 01:20:19,000
就是刚才讲的 NFC

2945
01:20:19,000 --> 01:20:20,000
NFD

2946
01:20:20,000 --> 01:20:21,000
它到底是个什么意思

2947
01:20:21,000 --> 01:20:22,000
可能还要解释一下

2948
01:20:22,000 --> 01:20:23,000
OK

2949
01:20:23,000 --> 01:20:24,000
呃

2950
01:20:24,000 --> 01:20:26,000
NFC 就是先

2951
01:20:26,000 --> 01:20:28,000
就等于是

2952
01:20:28,000 --> 01:20:29,000
这么说吧

2953
01:20:29,000 --> 01:20:30,000
规范化有两个思路

2954
01:20:30,000 --> 01:20:31,000
一个是说

2955
01:20:31,000 --> 01:20:34,000
什么叫规范化的最终形式

2956
01:20:34,000 --> 01:20:34,000
那

2957
01:20:34,000 --> 01:20:35,000
嗯

2958
01:20:35,000 --> 01:20:37,000
第一种思路就是

2959
01:20:37,000 --> 01:20:38,000
规范化的最终形式

2960
01:20:38,000 --> 01:20:40,000
是所有能够被拆分的东西

2961
01:20:40,000 --> 01:20:41,000
都已经被拆分了

2962
01:20:41,000 --> 01:20:42,000
嗯

2963
01:20:42,000 --> 01:20:44,000
然后我存储这个形式

2964
01:20:44,000 --> 01:20:45,000
呃

2965
01:20:45,000 --> 01:20:47,000
第二种思路是说

2966
01:20:47,000 --> 01:20:48,000
存储的最终形式

2967
01:20:48,000 --> 01:20:50,000
应该是所有能够被合成的东西

2968
01:20:50,000 --> 01:20:52,000
已经被合成了

2969
01:20:52,000 --> 01:20:53,000
而且是按照某一种特定的方式

2970
01:20:53,000 --> 01:20:53,000
合成

2971
01:20:53,000 --> 01:20:55,000
这是第二种思路

2972
01:20:55,000 --> 01:20:56,000
呃

2973
01:20:56,000 --> 01:20:57,000
所以

2974
01:20:57,000 --> 01:20:58,000
就是

2975
01:20:58,000 --> 01:20:59,000
比如说

2976
01:20:59,000 --> 01:21:00,000
第一型规范化

2977
01:21:00,000 --> 01:21:02,000
就是 NFD 的话

2978
01:21:02,000 --> 01:21:02,000
那就是

2979
01:21:02,000 --> 01:21:04,000
说以标准方式分解

2980
01:21:04,000 --> 01:21:06,000
分解到不能再分解了

2981
01:21:06,000 --> 01:21:08,000
那我的规范化的完成

2982
01:21:08,000 --> 01:21:09,000
过程就

2983
01:21:09,000 --> 01:21:10,000
就就就就结

2984
01:21:10,000 --> 01:21:11,000
就结束了

2985
01:21:11,000 --> 01:21:13,000
比如说刚才那个

2986
01:21:13,000 --> 01:21:14,000
那个鱼的话的话

2987
01:21:14,000 --> 01:21:15,000
它就分成三

2988
01:21:15,000 --> 01:21:17,000
就分成三个了

2989
01:21:17,000 --> 01:21:18,000
两点

2990
01:21:18,000 --> 01:21:19,000
然后

2991
01:21:19,000 --> 01:21:19,000
对

2992
01:21:19,000 --> 01:21:19,000
升掉

2993
01:21:19,000 --> 01:21:21,000
它能分就尽量分

2994
01:21:21,000 --> 01:21:21,000
所以它

2995
01:21:21,000 --> 01:21:23,000
我们看到是一个字

2996
01:21:23,000 --> 01:21:24,000
但是它背面

2997
01:21:24,000 --> 01:21:25,000
它分成了三个码

2998
01:21:25,000 --> 01:21:25,000
对

2999
01:21:25,000 --> 01:21:26,000
一个是 U

3000
01:21:26,000 --> 01:21:27,000
一个是合成

3001
01:21:27,000 --> 01:21:28,000
一个是两点

3002
01:21:28,000 --> 01:21:30,000
呃

3003
01:21:30,000 --> 01:21:32,000
然后如果你要分

3004
01:21:32,000 --> 01:21:36,000
如果你说我要把它合成的状态

3005
01:21:36,000 --> 01:21:37,000
作为最终状态的话

3006
01:21:37,000 --> 01:21:40,000
那刚才这个 U 就是呃

3007
01:21:40,000 --> 01:21:42,000
就把它合成成一个字符

3008
01:21:42,000 --> 01:21:43,000
这样来说

3009
01:21:43,000 --> 01:21:43,000
嗯

3010
01:21:43,000 --> 01:21:44,000
嗯

3011
01:21:44,000 --> 01:21:45,000
然后

3012
01:21:45,000 --> 01:21:48,000
然后但是由于分解和结

3013
01:21:48,000 --> 01:21:52,000
分解和合成又分别有所谓标准方式和接种方式

3014
01:21:52,000 --> 01:21:54,000
所以你可以说标准方式分解

3015
01:21:54,000 --> 01:21:55,000
结束

3016
01:21:55,000 --> 01:21:57,000
还是接种方式分解

3017
01:21:57,000 --> 01:21:57,000
结束

3018
01:21:57,000 --> 01:21:59,000
还是呃

3019
01:21:59,000 --> 01:22:02,000
标准方式分解之后再以标准方式合成

3020
01:22:02,000 --> 01:22:03,000
结束

3021
01:22:03,000 --> 01:22:06,000
还是以标准方式分解之后再以接种方式合成

3022
01:22:06,000 --> 01:22:06,000
结束

3023
01:22:06,000 --> 01:22:07,000
或者是反过

3024
01:22:07,000 --> 01:22:08,000
对

3025
01:22:08,000 --> 01:22:11,000
基本上是一个 combination 来的

3026
01:22:11,000 --> 01:22:11,000
对

3027
01:22:11,000 --> 01:22:13,000
我

3028
01:22:13,000 --> 01:22:14,000
我想问一下

3029
01:22:14,000 --> 01:22:15,000
为什么要做这么多种

3030
01:22:15,000 --> 01:22:16,000
我们的这个

3031
01:22:16,000 --> 01:22:20,000
normalization 的目的不就是为了解决这个标准化的问题吗

3032
01:22:20,000 --> 01:22:24,000
为什么还要再搞四种不一样的方式呢

3033
01:22:24,000 --> 01:22:25,000
就他们之间各有什么

3034
01:22:25,000 --> 01:22:26,000
或者说应用场景是什么

3035
01:22:26,000 --> 01:22:30,000
就比如说你标准方式分解分解到不能再分解了

3036
01:22:30,000 --> 01:22:33,000
这个实际上是非常适合编程的嘛

3037
01:22:33,000 --> 01:22:34,000
对吧

3038
01:22:34,000 --> 01:22:35,000
就是你

3039
01:22:35,000 --> 01:22:36,000
最小单元吗

3040
01:22:36,000 --> 01:22:40,000
就比如说你刚才是我刚才说那个 swift 的语言

3041
01:22:40,000 --> 01:22:43,000
判定两个字符上相等的时候

3042
01:22:43,000 --> 01:22:46,000
那你就把他们全都拆成不能再拆的状况

3043
01:22:46,000 --> 01:22:47,000
然后看两个是不是一样

3044
01:22:47,000 --> 01:22:48,000
然后一个 couple

3045
01:22:48,000 --> 01:22:49,000
如果是一样的话

3046
01:22:49,000 --> 01:22:50,000
那就不管他们原来是怎么样

3047
01:22:50,000 --> 01:22:51,000
对

3048
01:22:51,000 --> 01:22:53,000
这样就结束了

3049
01:22:53,000 --> 01:22:54,000
但是

3050
01:22:54,000 --> 01:22:55,000
如果说你要

3051
01:22:55,000 --> 01:22:56,000
这个好死板呢

3052
01:22:56,000 --> 01:22:58,000
太死板了

3053
01:22:58,000 --> 01:22:59,000
的话就是

3054
01:22:59,000 --> 01:23:00,000
对啊

3055
01:23:00,000 --> 01:23:01,000
就是你要拆的

3056
01:23:01,000 --> 01:23:03,000
要先拆拆的这么细了以后

3057
01:23:03,000 --> 01:23:05,000
要每一个部件都都一样

3058
01:23:05,000 --> 01:23:07,000
他才认判定为是一样

3059
01:23:07,000 --> 01:23:07,000
对吧

3060
01:23:07,000 --> 01:23:09,000
对

3061
01:23:09,000 --> 01:23:10,000
但是

3062
01:23:10,000 --> 01:23:12,000
但是这种方式的时候

3063
01:23:12,000 --> 01:23:12,000
就是

3064
01:23:12,000 --> 01:23:16,000
就这种规范化的方式是只适合

3065
01:23:16,000 --> 01:23:17,000
呃

3066
01:23:17,000 --> 01:23:18,000
存储或者比较的

3067
01:23:18,000 --> 01:23:19,000
那如果你要把它

3068
01:23:19,000 --> 01:23:20,000
呃

3069
01:23:20,000 --> 01:23:23,000
就是以节省空间的方式显示出来的话

3070
01:23:23,000 --> 01:23:25,000
那你还是很有可能

3071
01:23:25,000 --> 01:23:26,000
希望说

3072
01:23:26,000 --> 01:23:27,000
我要

3073
01:23:27,000 --> 01:23:28,000
把它

3074
01:23:28,000 --> 01:23:30,000
最终还是要合成起来

3075
01:23:30,000 --> 01:23:32,000
就刚才那个拆的方式说

3076
01:23:32,000 --> 01:23:33,000
可能会导致

3077
01:23:33,000 --> 01:23:35,000
刚比如说那个特殊的字符

3078
01:23:35,000 --> 01:23:35,000
呃

3079
01:23:35,000 --> 01:23:35,000
就是

3080
01:23:35,000 --> 01:23:37,000
于在加一个声调的话

3081
01:23:37,000 --> 01:23:38,000
他会从

3082
01:23:38,000 --> 01:23:39,000
呃

3083
01:23:39,000 --> 01:23:41,000
理论上他可以从一个

3084
01:23:41,000 --> 01:23:42,000
呃

3085
01:23:42,000 --> 01:23:43,000
一个点位变成三个点位嘛

3086
01:23:43,000 --> 01:23:44,000
对

3087
01:23:44,000 --> 01:23:45,000
就是那个

3088
01:23:45,000 --> 01:23:46,000
他的空间

3089
01:23:46,000 --> 01:23:48,000
存储空间的要求变成三倍了嘛

3090
01:23:48,000 --> 01:23:48,000
嗯

3091
01:23:48,000 --> 01:23:49,000
对

3092
01:23:49,000 --> 01:23:49,000
然后

3093
01:23:49,000 --> 01:23:51,000
那我们就如果就全部合到一起

3094
01:23:51,000 --> 01:23:52,000
有什么不好呢

3095
01:23:52,000 --> 01:23:53,000
嗯

3096
01:23:53,000 --> 01:23:55,000
的确有什么

3097
01:23:55,000 --> 01:23:55,000
就是为了

3098
01:23:55,000 --> 01:23:56,000
比较

3099
01:23:56,000 --> 01:23:56,000
比较化

3100
01:23:56,000 --> 01:23:57,000
就是说

3101
01:23:57,000 --> 01:23:57,000
就是说

3102
01:23:57,000 --> 01:23:58,000
呃

3103
01:23:58,000 --> 01:24:00,000
比如 NFD 的应用场景

3104
01:24:00,000 --> 01:24:01,000
和 NFC 的应用场景

3105
01:24:01,000 --> 01:24:02,000
他们各有什么不同

3106
01:24:02,000 --> 01:24:04,000
就是不能互相替代的地方

3107
01:24:04,000 --> 01:24:06,000
NFD 你要少做一步计算

3108
01:24:06,000 --> 01:24:07,000
就 NFC

3109
01:24:07,000 --> 01:24:08,000
你最重要把它合成起来

3110
01:24:08,000 --> 01:24:10,000
但是 NFD 的

3111
01:24:10,000 --> 01:24:12,000
你要你要付出更多的存置空间

3112
01:24:12,000 --> 01:24:14,000
对呀

3113
01:24:14,000 --> 01:24:15,000
所以这个就是一长一短嘛

3114
01:24:15,000 --> 01:24:16,000
呃

3115
01:24:16,000 --> 01:24:17,000
这就是时间

3116
01:24:17,000 --> 01:24:19,000
就是有时间换空间

3117
01:24:19,000 --> 01:24:21,000
还是空间换时间的建核吧

3118
01:24:21,000 --> 01:24:21,000
对

3119
01:24:21,000 --> 01:24:21,000
对

3120
01:24:21,000 --> 01:24:23,000
所以这个就是逻辑问题

3121
01:24:23,000 --> 01:24:25,000
然后只是偏好问题而已

3122
01:24:25,000 --> 01:24:26,000
这个并没有什么对错

3123
01:24:26,000 --> 01:24:27,000
或者怎么样

3124
01:24:27,000 --> 01:24:28,000
嗯

3125
01:24:28,000 --> 01:24:30,000
所以刚才提的一个叫做

3126
01:24:30,000 --> 01:24:31,000
这个兼容分解和标准分解

3127
01:24:31,000 --> 01:24:32,000
有什么不一样

3128
01:24:32,000 --> 01:24:34,000
那个我简单来说一下

3129
01:24:34,000 --> 01:24:35,000
兼容分解

3130
01:24:35,000 --> 01:24:36,000
就是呃

3131
01:24:36,000 --> 01:24:37,000
我不把它说的非常细

3132
01:24:37,000 --> 01:24:38,000
就兼容分解

3133
01:24:38,000 --> 01:24:39,000
它解决一个问题

3134
01:24:39,000 --> 01:24:40,000
就是说呃

3135
01:24:40,000 --> 01:24:41,000
有一些呃

3136
01:24:41,000 --> 01:24:42,000
有一些串

3137
01:24:42,000 --> 01:24:44,000
它在这个字符的

3138
01:24:44,000 --> 01:24:45,000
byte 的表达层面

3139
01:24:45,000 --> 01:24:46,000
是不一样的

3140
01:24:46,000 --> 01:24:47,000
然后呃

3141
01:24:47,000 --> 01:24:48,000
它拆分组合之后呢

3142
01:24:48,000 --> 01:24:49,000
也是不一样的

3143
01:24:49,000 --> 01:24:50,000
但是我们希望认为

3144
01:24:50,000 --> 01:24:51,000
它们是一样的

3145
01:24:51,000 --> 01:24:52,000
比如一个场景

3146
01:24:52,000 --> 01:24:53,000
就是说合字的问题

3147
01:24:53,000 --> 01:24:54,000
比如 fi 合字

3148
01:24:54,000 --> 01:24:56,000
那么 fi 合字

3149
01:24:56,000 --> 01:24:57,000
我们可以理解成

3150
01:24:57,000 --> 01:24:58,000
它是一个 f 和一个 i 的

3151
01:24:58,000 --> 01:25:00,000
两个字母的合成

3152
01:25:00,000 --> 01:25:02,000
但它同时又是一个单独的码位

3153
01:25:02,000 --> 01:25:03,000
就是 unicode 里面

3154
01:25:03,000 --> 01:25:04,000
有一个码位

3155
01:25:04,000 --> 01:25:05,000
就是 fi 这个合字的

3156
01:25:05,000 --> 01:25:07,000
那么我们在搜索的时候呢

3157
01:25:07,000 --> 01:25:08,000
用户可能输入 fi 合字

3158
01:25:08,000 --> 01:25:09,000
是非常复杂的

3159
01:25:09,000 --> 01:25:11,000
所以我们可能希望用户

3160
01:25:11,000 --> 01:25:12,000
输入一个 fi

3161
01:25:12,000 --> 01:25:13,000
一个 f 和一个 i

3162
01:25:13,000 --> 01:25:15,000
我们可以把所有 fi 合字

3163
01:25:15,000 --> 01:25:16,000
相关内容

3164
01:25:16,000 --> 01:25:17,000
也给它匹配起来

3165
01:25:17,000 --> 01:25:18,000
所以这个时候

3166
01:25:18,000 --> 01:25:20,000
就是这个兼容性分解和合成

3167
01:25:20,000 --> 01:25:23,000
所需要起到作用的

3168
01:25:23,000 --> 01:25:24,000
这样一个场景

3169
01:25:24,000 --> 01:25:25,000
等一下

3170
01:25:25,000 --> 01:25:26,000
这里我提一个问题

3171
01:25:26,000 --> 01:25:27,000
好像没有区别

3172
01:25:27,000 --> 01:25:29,000
只用分解一次就好了吗

3173
01:25:29,000 --> 01:25:30,000
或者合成一次就好了吗

3174
01:25:30,000 --> 01:25:32,000
就是你这个时候

3175
01:25:32,000 --> 01:25:34,000
这个问题是这样子

3176
01:25:34,000 --> 01:25:35,000
就是说有一堆文档

3177
01:25:35,000 --> 01:25:37,000
里面包含这个 fi 的合字

3178
01:25:37,000 --> 01:25:39,000
和 fi 分解的两种情况

3179
01:25:39,000 --> 01:25:39,000
对吧

3180
01:25:39,000 --> 01:25:40,000
我们没有做

3181
01:25:40,000 --> 01:25:40,000
它做任何处理

3182
01:25:40,000 --> 01:25:42,000
这个时候你用户来了

3183
01:25:42,000 --> 01:25:44,000
说用户说输入 fi

3184
01:25:44,000 --> 01:25:46,000
我们需要把前面的 fi 合字

3185
01:25:46,000 --> 01:25:47,000
和 fi 分开的

3186
01:25:47,000 --> 01:25:48,000
都收出来

3187
01:25:48,000 --> 01:25:49,000
对吧

3188
01:25:49,000 --> 01:25:49,000
这个时候有两种做法

3189
01:25:49,000 --> 01:25:50,000
第一个是说

3190
01:25:50,000 --> 01:25:52,000
我们把这个

3191
01:25:52,000 --> 01:25:54,000
我们之前存的一些文档

3192
01:25:54,000 --> 01:25:55,000
全部做分解

3193
01:25:55,000 --> 01:25:57,000
就把 fi 的合字

3194
01:25:57,000 --> 01:25:58,000
一个 code point

3195
01:25:58,000 --> 01:25:58,000
分成两个

3196
01:25:58,000 --> 01:25:59,000
然后这个时候

3197
01:25:59,000 --> 01:26:00,000
我们就可以直接跟那个

3198
01:26:00,000 --> 01:26:01,000
用户输入的 fi

3199
01:26:01,000 --> 01:26:02,000
直接对比了吗

3200
01:26:02,000 --> 01:26:03,000
另一个方法

3201
01:26:03,000 --> 01:26:05,000
就是说我们把用户输入的 fi

3202
01:26:05,000 --> 01:26:06,000
弄成一个盒子

3203
01:26:06,000 --> 01:26:07,000
同时把所有的

3204
01:26:07,000 --> 01:26:09,000
我们已有的文档里面的 fi

3205
01:26:09,000 --> 01:26:10,000
分开的也弄成一个盒子

3206
01:26:10,000 --> 01:26:12,000
这个时候再搜索也可以了

3207
01:26:12,000 --> 01:26:12,000
对吧

3208
01:26:12,000 --> 01:26:13,000
就这两种操作方式

3209
01:26:13,000 --> 01:26:15,000
对对对

3210
01:26:15,000 --> 01:26:15,000
OK

3211
01:26:15,000 --> 01:26:17,000
但是因为你

3212
01:26:17,000 --> 01:26:18,000
这就是为了

3213
01:26:18,000 --> 01:26:19,000
为了兼容

3214
01:26:19,000 --> 01:26:20,000
用户并不知道

3215
01:26:20,000 --> 01:26:22,000
这里面到底用的是盒子

3216
01:26:22,000 --> 01:26:23,000
还是分开的

3217
01:26:23,000 --> 01:26:24,000
但这里的问题

3218
01:26:24,000 --> 01:26:25,000
就是说这个标准分解

3219
01:26:25,000 --> 01:26:27,000
和和这个

3220
01:26:27,000 --> 01:26:28,000
兼容分解

3221
01:26:28,000 --> 01:26:28,000
好像没有区别

3222
01:26:28,000 --> 01:26:29,000
在这里面

3223
01:26:29,000 --> 01:26:31,000
这个区别就在于

3224
01:26:31,000 --> 01:26:33,000
哪些东西是可以分的

3225
01:26:33,000 --> 01:26:33,000
就是说

3226
01:26:33,000 --> 01:26:35,000
哪些东西是可以等价的

3227
01:26:35,000 --> 01:26:36,000
其实他们的区别就在于

3228
01:26:36,000 --> 01:26:37,000
比如说那个 fi 合字

3229
01:26:37,000 --> 01:26:38,000
它本质上

3230
01:26:38,000 --> 01:26:40,000
不能完全等同于

3231
01:26:40,000 --> 01:26:41,000
一个 f 和一个 i

3232
01:26:41,000 --> 01:26:44,000
他们本质上是两种不同的字符

3233
01:26:44,000 --> 01:26:44,000
那么有的时候

3234
01:26:44,000 --> 01:26:46,000
我们希望他们是等价的

3235
01:26:46,000 --> 01:26:47,000
对

3236
01:26:47,000 --> 01:26:47,000
这个

3237
01:26:47,000 --> 01:26:48,000
这个

3238
01:26:48,000 --> 01:26:49,000
其实不仅仅是说

3239
01:26:49,000 --> 01:26:51,000
这不纯粹是一个

3240
01:26:51,000 --> 01:26:52,000
呃

3241
01:26:52,000 --> 01:26:53,000
字符层面的问题

3242
01:26:53,000 --> 01:26:54,000
还是一个原

3243
01:26:54,000 --> 01:26:55,000
就是语言层面的问题

3244
01:26:55,000 --> 01:26:56,000
比如说在有些语言

3245
01:26:56,000 --> 01:26:57,000
它是一个语意的问题

3246
01:26:57,000 --> 01:26:57,000
对

3247
01:26:57,000 --> 01:26:58,000
在有些语言

3248
01:26:58,000 --> 01:27:00,000
CH 或者是

3249
01:27:00,000 --> 01:27:01,000
呃

3250
01:27:01,000 --> 01:27:02,000
SH

3251
01:27:02,000 --> 01:27:02,000
是一个

3252
01:27:02,000 --> 01:27:04,000
是被试成一个

3253
01:27:04,000 --> 01:27:05,000
试作一个单独的字母

3254
01:27:05,000 --> 01:27:06,000
或者是

3255
01:27:06,000 --> 01:27:06,000
在

3256
01:27:06,000 --> 01:27:08,000
比如说像荷兰语言

3257
01:27:08,000 --> 01:27:08,000
IJ

3258
01:27:08,000 --> 01:27:09,000
经常是

3259
01:27:09,000 --> 01:27:11,000
是一个单独的字母

3260
01:27:11,000 --> 01:27:12,000
因为就是

3261
01:27:12,000 --> 01:27:13,000
对

3262
01:27:13,000 --> 01:27:13,000
因为就是

3263
01:27:13,000 --> 01:27:15,000
有些语言里面

3264
01:27:15,000 --> 01:27:16,000
一个字母可能有两种形式

3265
01:27:16,000 --> 01:27:17,000
比如说阿拉伯语

3266
01:27:17,000 --> 01:27:18,000
呃

3267
01:27:18,000 --> 01:27:18,000
自

3268
01:27:18,000 --> 01:27:18,000
自首

3269
01:27:18,000 --> 01:27:19,000
自中

3270
01:27:19,000 --> 01:27:19,000
自末

3271
01:27:19,000 --> 01:27:22,000
一个字母是表达形式不一样的

3272
01:27:22,000 --> 01:27:22,000
呃

3273
01:27:22,000 --> 01:27:23,000
比如希腊语

3274
01:27:23,000 --> 01:27:23,000
那个

3275
01:27:23,000 --> 01:27:24,000
是 Sigma

3276
01:27:24,000 --> 01:27:26,000
Sigma 在词尾的时候

3277
01:27:26,000 --> 01:27:28,000
写法和在词中不一样

3278
01:27:28,000 --> 01:27:29,000
又比如说那个

3279
01:27:29,000 --> 01:27:29,000
英语里面的

3280
01:27:29,000 --> 01:27:30,000
长 S

3281
01:27:30,000 --> 01:27:31,000
就是

3282
01:27:31,000 --> 01:27:31,000
嗯

3283
01:27:31,000 --> 01:27:33,000
就是微基分那个符号

3284
01:27:33,000 --> 01:27:33,000
那个

3285
01:27:33,000 --> 01:27:34,000
S

3286
01:27:34,000 --> 01:27:36,000
它跟普通的 S

3287
01:27:36,000 --> 01:27:36,000
也不一样

3288
01:27:36,000 --> 01:27:38,000
在德语里面

3289
01:27:38,000 --> 01:27:40,000
在旧式的德语证的法案里面

3290
01:27:40,000 --> 01:27:40,000
如果他

3291
01:27:40,000 --> 01:27:41,000
呃

3292
01:27:41,000 --> 01:27:43,000
如果一个 S 出现在词中的话

3293
01:27:43,000 --> 01:27:44,000
你必须写成长 S

3294
01:27:44,000 --> 01:27:45,000
但是

3295
01:27:45,000 --> 01:27:46,000
嗯

3296
01:27:46,000 --> 01:27:47,000
长 S 你用

3297
01:27:47,000 --> 01:27:48,000
呃

3298
01:27:48,000 --> 01:27:49,000
标准分解的话

3299
01:27:49,000 --> 01:27:50,000
你只能

3300
01:27:50,000 --> 01:27:52,000
最终只能分解出一个长 S

3301
01:27:52,000 --> 01:27:53,000
但是如果你用

3302
01:27:53,000 --> 01:27:54,000
因为它本来就是一个字符

3303
01:27:54,000 --> 01:27:55,000
对

3304
01:27:55,000 --> 01:27:56,000
不管你分开任何

3305
01:27:56,000 --> 01:27:57,000
它就是一个字符

3306
01:27:57,000 --> 01:27:57,000
对

3307
01:27:57,000 --> 01:27:58,000
而如果你用

3308
01:27:58,000 --> 01:27:59,000
坚重分解的话

3309
01:27:59,000 --> 01:28:00,000
他会说

3310
01:28:00,000 --> 01:28:00,000
哦

3311
01:28:00,000 --> 01:28:01,000
这个 S 实际上

3312
01:28:01,000 --> 01:28:02,000
这个长 S 实际上是 S 的一个变种

3313
01:28:02,000 --> 01:28:03,000
所以在匹配的时候

3314
01:28:03,000 --> 01:28:05,000
我必须把它匹配成一个短 S

3315
01:28:05,000 --> 01:28:09,000
就是说有一些

3316
01:28:09,000 --> 01:28:10,000
编于搜索到

3317
01:28:10,000 --> 01:28:13,000
就有一些组合在标准分解

3318
01:28:13,000 --> 01:28:14,000
它是不能分解

3319
01:28:14,000 --> 01:28:16,000
但是为了让大家方便

3320
01:28:16,000 --> 01:28:17,000
会让它

3321
01:28:17,000 --> 01:28:18,000
就把它拆

3322
01:28:18,000 --> 01:28:19,000
就强行拆开

3323
01:28:19,000 --> 01:28:20,000
对

3324
01:28:20,000 --> 01:28:21,000
对

3325
01:28:21,000 --> 01:28:21,000
是的

3326
01:28:21,000 --> 01:28:22,000
嗯

3327
01:28:22,000 --> 01:28:23,000
哇

3328
01:28:23,000 --> 01:28:23,000
天哪

3329
01:28:23,000 --> 01:28:23,000
这个

3330
01:28:23,000 --> 01:28:24,000
对

3331
01:28:24,000 --> 01:28:26,000
它有它有几种常见的形式

3332
01:28:26,000 --> 01:28:27,000
一种就是一个字母

3333
01:28:27,000 --> 01:28:28,000
它可能有一些

3334
01:28:28,000 --> 01:28:29,000
呃

3335
01:28:29,000 --> 01:28:30,000
字体设计

3336
01:28:30,000 --> 01:28:32,000
这个历史原因带来的不一样

3337
01:28:32,000 --> 01:28:33,000
比如说一个拉丁字母

3338
01:28:33,000 --> 01:28:35,000
它可以设计成好几种形式的

3339
01:28:35,000 --> 01:28:36,000
比如说什么

3340
01:28:36,000 --> 01:28:38,000
有什么双层形的之类的

3341
01:28:38,000 --> 01:28:40,000
就这个双层是指这个视觉样式上的

3342
01:28:40,000 --> 01:28:42,000
比如它有一个双勾线的这种形式

3343
01:28:42,000 --> 01:28:44,000
然后另一种形式呢

3344
01:28:44,000 --> 01:28:46,000
比如说有一些空白字符

3345
01:28:46,000 --> 01:28:49,000
它们可能都是一个空格

3346
01:28:49,000 --> 01:28:50,000
但是它们可能有

3347
01:28:50,000 --> 01:28:52,000
我们在 UNICAL 有非常多种空格

3348
01:28:52,000 --> 01:28:54,000
但是我们希望它们在搜索的时候

3349
01:28:54,000 --> 01:28:55,000
或者在语意识别的时候

3350
01:28:55,000 --> 01:28:57,000
认为它们都是空格这一种

3351
01:28:57,000 --> 01:28:58,000
都是 Widespace

3352
01:28:58,000 --> 01:28:58,000
对

3353
01:28:58,000 --> 01:29:00,000
然后另外一种就是刚才吴涛说的

3354
01:29:00,000 --> 01:29:01,000
有一些语言里面有一些字母

3355
01:29:01,000 --> 01:29:03,000
它在不同的位置上

3356
01:29:03,000 --> 01:29:04,000
它其实会有不一样的写法

3357
01:29:04,000 --> 01:29:06,000
然后它也有不一样的 UNICAL 的码位

3358
01:29:06,000 --> 01:29:07,000
对

3359
01:29:07,000 --> 01:29:09,000
然后接下来有一种

3360
01:29:09,000 --> 01:29:10,000
比如说数字

3361
01:29:10,000 --> 01:29:11,000
有的是带圈的

3362
01:29:11,000 --> 01:29:11,000
有的是不带圈的

3363
01:29:11,000 --> 01:29:13,000
但它们可能都是同一个数字

3364
01:29:13,000 --> 01:29:14,000
一或者数字二

3365
01:29:14,000 --> 01:29:16,000
那么它们应该是一样的

3366
01:29:16,000 --> 01:29:17,000
就我们希望它们识别成一样的

3367
01:29:17,000 --> 01:29:19,000
然后日语里面甲铭有

3368
01:29:19,000 --> 01:29:21,000
半角和拳角的区别

3369
01:29:21,000 --> 01:29:23,000
然后汉语里面标点符号

3370
01:29:23,000 --> 01:29:25,000
有竖排和横排的区别

3371
01:29:25,000 --> 01:29:28,000
然后还有像数学里面有上标和下标

3372
01:29:28,000 --> 01:29:30,000
和这个非上标下标的

3373
01:29:30,000 --> 01:29:31,000
这个普通数字的这个区别

3374
01:29:31,000 --> 01:29:33,000
但它们都是同一个数字

3375
01:29:33,000 --> 01:29:34,000
另外日语里面还有一些

3376
01:29:34,000 --> 01:29:37,000
就是几个字母

3377
01:29:37,000 --> 01:29:38,000
几个字或者几个假名

3378
01:29:38,000 --> 01:29:39,000
它会组合成一起

3379
01:29:39,000 --> 01:29:40,000
比如说这个年号

3380
01:29:40,000 --> 01:29:41,000
像什么平成

3381
01:29:41,000 --> 01:29:43,000
它可能会组合成一个字符

3382
01:29:43,000 --> 01:29:45,000
但它也可以写成平成这两个字

3383
01:29:45,000 --> 01:29:47,000
诸事会社

3384
01:29:47,000 --> 01:29:48,000
对

3385
01:29:48,000 --> 01:29:49,000
诸事会社

3386
01:29:49,000 --> 01:29:50,000
叠在一起的

3387
01:29:50,000 --> 01:29:50,000
对

3388
01:29:50,000 --> 01:29:52,000
填字格的方式

3389
01:29:52,000 --> 01:29:53,000
对

3390
01:29:53,000 --> 01:29:54,000
另外就是下有分数

3391
01:29:54,000 --> 01:29:55,000
比如说二分之一

3392
01:29:55,000 --> 01:29:57,000
它可能有一个单独的马位

3393
01:29:57,000 --> 01:29:58,000
就是二分之一

3394
01:29:58,000 --> 01:29:59,000
但我们也可以写成

3395
01:29:59,000 --> 01:30:00,000
一斜杠二这样的一种

3396
01:30:00,000 --> 01:30:01,000
对

3397
01:30:01,000 --> 01:30:02,000
这个例子很好

3398
01:30:02,000 --> 01:30:03,000
我第一次

3399
01:30:03,000 --> 01:30:04,000
我刚到德国的时候

3400
01:30:04,000 --> 01:30:05,000
最惊艳的一件事情

3401
01:30:05,000 --> 01:30:06,000
就是德国界

3402
01:30:06,000 --> 01:30:07,000
有二分之一

3403
01:30:07,000 --> 01:30:07,000
三分之一

3404
01:30:07,000 --> 01:30:08,000
这两个界限

3405
01:30:08,000 --> 01:30:14,000
所以我问一下

3406
01:30:14,000 --> 01:30:15,000
刚刚我们讲的很多都是

3407
01:30:15,000 --> 01:30:17,000
这个外文的问题

3408
01:30:17,000 --> 01:30:18,000
中文有这个问题吗

3409
01:30:18,000 --> 01:30:19,000
中文我刚说了一个

3410
01:30:19,000 --> 01:30:20,000
就是标点的横竖形

3411
01:30:20,000 --> 01:30:22,000
就是横排和竖排标点

3412
01:30:22,000 --> 01:30:24,000
但这个不涉及拆解的问题吧

3413
01:30:24,000 --> 01:30:26,000
他就是说把哪些

3414
01:30:26,000 --> 01:30:27,000
对

3415
01:30:27,000 --> 01:30:28,000
他本来不在一个马位的标点

3416
01:30:28,000 --> 01:30:30,000
但是因为我们认为他的

3417
01:30:30,000 --> 01:30:31,000
在某一些情况下认为

3418
01:30:31,000 --> 01:30:32,000
他是等价的嘛

3419
01:30:32,000 --> 01:30:33,000
对

3420
01:30:33,000 --> 01:30:34,000
所以 normalization

3421
01:30:34,000 --> 01:30:36,000
不只是一个拆分的问题

3422
01:30:36,000 --> 01:30:37,000
他有的时候也是单个字符

3423
01:30:37,000 --> 01:30:39,000
之间相互的等价问题

3424
01:30:39,000 --> 01:30:39,000
对

3425
01:30:39,000 --> 01:30:39,000
中文

3426
01:30:39,000 --> 01:30:41,000
中文是没有拆分和组合

3427
01:30:41,000 --> 01:30:42,000
这个问题吗

3428
01:30:42,000 --> 01:30:43,000
中文基本上没有

3429
01:30:43,000 --> 01:30:45,000
但韩语可能就会有

3430
01:30:45,000 --> 01:30:47,000
那中文那个带圈文字

3431
01:30:47,000 --> 01:30:48,000
是有这个问题吗

3432
01:30:48,000 --> 01:30:49,000
中文什么

3433
01:30:49,000 --> 01:30:52,000
带圈文字的话就会

3434
01:30:52,000 --> 01:30:54,000
就会有刚才那个兼容的问题吗

3435
01:30:54,000 --> 01:30:55,000
就是因为你

3436
01:30:55,000 --> 01:30:56,000
他即使加了一个圈

3437
01:30:56,000 --> 01:30:57,000
但是比如说那个

3438
01:30:57,000 --> 01:30:58,000
圈

3439
01:30:58,000 --> 01:30:59,000
加一个拆是吧

3440
01:30:59,000 --> 01:31:02,000
对啊

3441
01:31:02,000 --> 01:31:02,000
对啊

3442
01:31:02,000 --> 01:31:03,000
就是圆圈嘛

3443
01:31:03,000 --> 01:31:05,000
有人说要为他生起

3444
01:31:05,000 --> 01:31:06,000
一个特殊的马位

3445
01:31:06,000 --> 01:31:06,000
这是另外的

3446
01:31:06,000 --> 01:31:08,000
还有比如说像什么

3447
01:31:08,000 --> 01:31:08,000
框胡 1

3448
01:31:08,000 --> 01:31:09,000
对吧

3449
01:31:09,000 --> 01:31:10,000
框胡 123456789

3450
01:31:10,000 --> 01:31:11,000
汉字

3451
01:31:11,000 --> 01:31:11,000
对吧

3452
01:31:11,000 --> 01:31:14,000
像这些都是有那个兼容的

3453
01:31:14,000 --> 01:31:14,000
这样的

3454
01:31:14,000 --> 01:31:16,000
兼容的话给他拆成三个嘛

3455
01:31:16,000 --> 01:31:17,000
前

3456
01:31:17,000 --> 01:31:20,000
前框胡汉字一后框胡

3457
01:31:20,000 --> 01:31:21,000
就是他以要

3458
01:31:21,000 --> 01:31:22,000
这样认吗

3459
01:31:22,000 --> 01:31:23,000
以便于可以搜索到吗

3460
01:31:23,000 --> 01:31:25,000
就中文其实也有这个问题

3461
01:31:25,000 --> 01:31:25,000
对吧

3462
01:31:25,000 --> 01:31:26,000
对

3463
01:31:26,000 --> 01:31:27,000
这些其实都是日本过来

3464
01:31:27,000 --> 01:31:27,000
我觉得

3465
01:31:27,000 --> 01:31:30,000
最早应该都是日本人去申请

3466
01:31:30,000 --> 01:31:31,000
这些马位

3467
01:31:31,000 --> 01:31:32,000
那我再问一下

3468
01:31:32,000 --> 01:31:33,000
那是不是说

3469
01:31:33,000 --> 01:31:35,000
现在不是流行那个火新闻吗

3470
01:31:35,000 --> 01:31:36,000
啊

3471
01:31:36,000 --> 01:31:38,000
火新闻不是只有半截式

3472
01:31:38,000 --> 01:31:39,000
那个正常的字吗

3473
01:31:39,000 --> 01:31:40,000
Oh my God

3474
01:31:40,000 --> 01:31:42,000
部首都是没有用的是吧

3475
01:31:42,000 --> 01:31:43,000
所以其实

3476
01:31:43,000 --> 01:31:43,000
Oh my God

3477
01:31:43,000 --> 01:31:46,000
火新闻能不能等假是不是

3478
01:31:46,000 --> 01:31:47,000
对啊对啊

3479
01:31:47,000 --> 01:31:47,000
你必然

3480
01:31:47,000 --> 01:31:50,000
就是我们在实际使用的情况下

3481
01:31:50,000 --> 01:31:52,000
火新闻必然是等假为某一些这个

3482
01:31:52,000 --> 01:31:54,000
就是非火新闻的文本的吧

3483
01:31:54,000 --> 01:31:56,000
就其实他也是一个

3484
01:31:56,000 --> 01:31:57,000
这个我觉得

3485
01:31:57,000 --> 01:31:58,000
这个还是

3486
01:31:58,000 --> 01:32:00,000
留给人工智能解决

3487
01:32:00,000 --> 01:32:01,000
这个

3488
01:32:01,000 --> 01:32:02,000
你强

3489
01:32:02,000 --> 01:32:03,000
强

3490
01:32:03,000 --> 01:32:03,000
强

3491
01:32:03,000 --> 01:32:04,000
要一个

3492
01:32:04,000 --> 01:32:05,000
normalization 的过程

3493
01:32:05,000 --> 01:32:06,000
考虑这种情况

3494
01:32:06,000 --> 01:32:08,000
实在是太强一阻达了

3495
01:32:08,000 --> 01:32:08,000
因为

3496
01:32:08,000 --> 01:32:08,000
我就说

3497
01:32:08,000 --> 01:32:10,000
因为这个可能不需要在这个

3498
01:32:10,000 --> 01:32:12,000
就不能写到规范里面去嘛

3499
01:32:12,000 --> 01:32:13,000
但是如果说

3500
01:32:13,000 --> 01:32:15,000
比如说这个我们现在在做一个这个

3501
01:32:15,000 --> 01:32:17,000
审查系统

3502
01:32:17,000 --> 01:32:17,000
对吧

3503
01:32:17,000 --> 01:32:18,000
我们做这个

3504
01:32:18,000 --> 01:32:19,000
这个内容过滤

3505
01:32:19,000 --> 01:32:21,000
可能要过滤到某一些

3506
01:32:21,000 --> 01:32:23,000
不合时宜的字的时候

3507
01:32:23,000 --> 01:32:26,000
你肯定还是要做这个火新闻的拆解

3508
01:32:26,000 --> 01:32:27,000
然后做一个等价替换嘛

3509
01:32:27,000 --> 01:32:27,000
啊

3510
01:32:27,000 --> 01:32:30,000
就你说能不能沿用 unicode 的这套

3511
01:32:30,000 --> 01:32:31,000
normalization 的机制

3512
01:32:31,000 --> 01:32:33,000
它的逻辑肯定是一样的嘛

3513
01:32:33,000 --> 01:32:33,000
逻辑

3514
01:32:33,000 --> 01:32:34,000
对

3515
01:32:34,000 --> 01:32:35,000
它就是所谓的兼容分解嘛

3516
01:32:35,000 --> 01:32:36,000
所谓的

3517
01:32:36,000 --> 01:32:37,000
这个不一定

3518
01:32:37,000 --> 01:32:38,000
我觉得不一定

3519
01:32:38,000 --> 01:32:40,000
就要看你能不能设计出这样一套机制

3520
01:32:40,000 --> 01:32:43,000
因为其实 normalization 有一个数学上特性

3521
01:32:43,000 --> 01:32:44,000
它叫密等性嘛

3522
01:32:44,000 --> 01:32:46,000
就是你无论对一个串

3523
01:32:46,000 --> 01:32:49,000
做多少次这个 normalization 之后

3524
01:32:49,000 --> 01:32:50,000
结果最终是一样的

3525
01:32:50,000 --> 01:32:51,000
对对对

3526
01:32:51,000 --> 01:32:54,000
就是你要看你的设计的这套拆解和组合机制

3527
01:32:54,000 --> 01:32:56,000
能不能符合这个密等性

3528
01:32:56,000 --> 01:32:59,000
而且逆等要倒回来

3529
01:32:59,000 --> 01:32:59,000
对

3530
01:32:59,000 --> 01:33:01,000
当然要能倒回来

3531
01:33:01,000 --> 01:33:05,000
倒不回来的话就不都错了吗

3532
01:33:05,000 --> 01:33:05,000
对

3533
01:33:05,000 --> 01:33:07,000
所以我觉得火新闻可能有问题

3534
01:33:07,000 --> 01:33:08,000
火新闻有问题

3535
01:33:08,000 --> 01:33:10,000
那肯定是倒不回来的呀

3536
01:33:10,000 --> 01:33:10,000
比如说

3537
01:33:10,000 --> 01:33:13,000
比如说它原始的一个

3538
01:33:13,000 --> 01:33:14,000
我们刚才举那个

3539
01:33:14,000 --> 01:33:16,000
于和上面有一个

3540
01:33:16,000 --> 01:33:17,000
有一个撇这个一个情况嘛

3541
01:33:17,000 --> 01:33:18,000
那其实我们想来

3542
01:33:18,000 --> 01:33:20,000
它应该有好几种组合形式

3543
01:33:20,000 --> 01:33:20,000
对吧

3544
01:33:20,000 --> 01:33:21,000
它可以说是

3545
01:33:21,000 --> 01:33:23,000
于组合一个于

3546
01:33:23,000 --> 01:33:24,000
就最拆解三个

3547
01:33:24,000 --> 01:33:26,000
没点然后拼一几的方式嘛

3548
01:33:26,000 --> 01:33:28,000
它可以说是就是于

3549
01:33:28,000 --> 01:33:29,000
上面有于

3550
01:33:29,000 --> 01:33:30,000
然后再加一个音调

3551
01:33:30,000 --> 01:33:31,000
这是就两个

3552
01:33:31,000 --> 01:33:32,000
两个点对吧

3553
01:33:32,000 --> 01:33:34,000
它也可以是于有声调

3554
01:33:34,000 --> 01:33:35,000
再加两个点嘛

3555
01:33:35,000 --> 01:33:37,000
那其实你拆解之后

3556
01:33:37,000 --> 01:33:38,000
你是回不去的

3557
01:33:38,000 --> 01:33:40,000
它这个是一个单向的过程

3558
01:33:40,000 --> 01:33:40,000
就好像那个

3559
01:33:40,000 --> 01:33:42,000
繁体中文转

3560
01:33:42,000 --> 01:33:43,000
简体中文一样

3561
01:33:43,000 --> 01:33:43,000
你是不能

3562
01:33:43,000 --> 01:33:46,000
就是过去又回来的吗

3563
01:33:46,000 --> 01:33:49,000
OK

3564
01:33:49,000 --> 01:33:51,000
就是它应该不是

3565
01:33:51,000 --> 01:33:53,000
一个可逆的操作

3566
01:33:53,000 --> 01:33:53,000
为什么

3567
01:33:53,000 --> 01:33:54,000
对

3568
01:33:54,000 --> 01:33:55,000
因为你丢失了

3569
01:33:55,000 --> 01:33:56,000
你最开始

3570
01:33:56,000 --> 01:33:57,000
你丢失了一开始的信息

3571
01:33:57,000 --> 01:33:58,000
这是没错的

3572
01:33:58,000 --> 01:33:59,000
就是你

3573
01:33:59,000 --> 01:34:01,000
你 normalize 过后

3574
01:34:01,000 --> 01:34:02,000
你一开始什么样

3575
01:34:02,000 --> 01:34:03,000
你就不知道

3576
01:34:03,000 --> 01:34:05,000
对啊

3577
01:34:05,000 --> 01:34:06,000
所以它最多能做到密的

3578
01:34:06,000 --> 01:34:08,000
就是可以不断重复的做一个

3579
01:34:08,000 --> 01:34:08,000
隆重的

3580
01:34:08,000 --> 01:34:09,000
它得到结果是稳定的

3581
01:34:09,000 --> 01:34:10,000
但是它不能

3582
01:34:10,000 --> 01:34:11,000
它不能做

3583
01:34:11,000 --> 01:34:12,000
不能反

3584
01:34:12,000 --> 01:34:13,000
不能再逆回

3585
01:34:13,000 --> 01:34:14,000
就不可逆了

3586
01:34:14,000 --> 01:34:14,000
你就

3587
01:34:14,000 --> 01:34:15,000
你的意思是

3588
01:34:15,000 --> 01:34:16,000
你不知道

3589
01:34:16,000 --> 01:34:17,000
它最初这个 source

3590
01:34:17,000 --> 01:34:19,000
究竟是哪一种表达形式

3591
01:34:19,000 --> 01:34:19,000
对

3592
01:34:19,000 --> 01:34:20,000
你不知道

3593
01:34:20,000 --> 01:34:20,000
是

3594
01:34:20,000 --> 01:34:21,000
你弄了人一种

3595
01:34:21,000 --> 01:34:23,000
就破坏掉那个信息了

3596
01:34:23,000 --> 01:34:23,000
对

3597
01:34:23,000 --> 01:34:23,000
OK

3598
01:34:23,000 --> 01:34:25,000
但是它们永远是相等的

3599
01:34:25,000 --> 01:34:28,000
但是如果你拆这个汉字的话

3600
01:34:28,000 --> 01:34:29,000
就不一定了

3601
01:34:29,000 --> 01:34:30,000
因为你本质上拆汉字

3602
01:34:30,000 --> 01:34:33,000
就是把汉字拆成各种偏旁部首

3603
01:34:33,000 --> 01:34:35,000
然后把它们组合一下

3604
01:34:35,000 --> 01:34:37,000
但我们知道汉字的这个偏旁部首

3605
01:34:37,000 --> 01:34:39,000
可能前一个字的一个偏旁

3606
01:34:39,000 --> 01:34:42,000
可以成为后一个字的另一个偏旁

3607
01:34:42,000 --> 01:34:43,000
所以它们的组合方式有很多

3608
01:34:43,000 --> 01:34:44,000
这个时候

3609
01:34:44,000 --> 01:34:46,000
它们就可能不密等了

3610
01:34:46,000 --> 01:34:48,000
就是那个火星文的左右两边

3611
01:34:48,000 --> 01:34:50,000
你可能选出来的那个字是

3612
01:34:50,000 --> 01:34:52,000
就是一个选的左边那个部首

3613
01:34:52,000 --> 01:34:53,000
一个是选的是六边那个部首

3614
01:34:53,000 --> 01:34:54,000
对吧

3615
01:34:54,000 --> 01:34:54,000
对对对

3616
01:34:54,000 --> 01:34:56,000
就有可能会有这种情况

3617
01:34:56,000 --> 01:34:56,000
对

3618
01:34:56,000 --> 01:34:58,000
这有可能会破坏这个密等性的

3619
01:34:58,000 --> 01:35:02,000
所以还是听可能一个事情

3620
01:35:02,000 --> 01:35:02,000
对

3621
01:35:02,000 --> 01:35:04,000
因为 Unical 为了维持这个密等性

3622
01:35:04,000 --> 01:35:06,000
它其实是做了很多工作的

3623
01:35:06,000 --> 01:35:09,000
包括它定义了这个拆解出来的部件的顺序

3624
01:35:09,000 --> 01:35:11,000
如果你破坏了这个顺序的话

3625
01:35:11,000 --> 01:35:12,000
就有可能破坏了这个密等性

3626
01:35:12,000 --> 01:35:14,000
所以它拆解的这个顺序

3627
01:35:14,000 --> 01:35:15,000
是有确定的顺序的

3628
01:35:15,000 --> 01:35:16,000
比如有一些字母

3629
01:35:16,000 --> 01:35:18,000
它可能上面可以加一个点

3630
01:35:18,000 --> 01:35:19,000
下面也可以加一个点

3631
01:35:19,000 --> 01:35:20,000
那么哪个点

3632
01:35:20,000 --> 01:35:22,000
是下面这个点在前

3633
01:35:22,000 --> 01:35:23,000
还是上面这个点在前

3634
01:35:23,000 --> 01:35:24,000
它其实是有固定顺序的

3635
01:35:24,000 --> 01:35:25,000
嗯

3636
01:35:25,000 --> 01:35:29,000
本期节目的那个 show notes 里面

3637
01:35:29,000 --> 01:35:32,000
还得标注一下密等性的一个连接

3638
01:35:32,000 --> 01:35:33,000
到底大家去理解一下

3639
01:35:33,000 --> 01:35:33,000
密等性

3640
01:35:33,000 --> 01:35:37,000
庞家

3641
01:35:37,000 --> 01:35:39,000
最后肯定

3642
01:35:39,000 --> 01:35:40,000
我相信肯定有读者

3643
01:35:40,000 --> 01:35:41,000
连着密等性

3644
01:35:41,000 --> 01:35:41,000
一路点

3645
01:35:41,000 --> 01:35:42,000
点到什么

3646
01:35:42,000 --> 01:35:43,000
庞家来

3647
01:35:43,000 --> 01:35:43,000
什么

3648
01:35:43,000 --> 01:35:45,000
对

3649
01:35:45,000 --> 01:35:45,000
对

3650
01:35:45,000 --> 01:35:46,000
对

3651
01:35:46,000 --> 01:35:46,000
那个数学问题

3652
01:35:46,000 --> 01:35:47,000
对

3653
01:35:47,000 --> 01:35:48,000
哥德尔不完美定理

3654
01:35:48,000 --> 01:35:48,000
这样

3655
01:35:48,000 --> 01:35:52,000
滑了好大一个

3656
01:35:52,000 --> 01:35:53,000
所以说 wikipedia

3657
01:35:53,000 --> 01:35:54,000
各种链接点点

3658
01:35:54,000 --> 01:35:56,000
你最后都会点到那几个页面

3659
01:35:56,000 --> 01:35:57,000
对

3660
01:35:57,000 --> 01:35:58,000
最终肯定会回到哲学

3661
01:35:58,000 --> 01:35:59,000
我跟你讲

3662
01:35:59,000 --> 01:36:00,000
哲学和数学

3663
01:36:00,000 --> 01:36:09,000
刚才我们讲了这个

3664
01:36:09,000 --> 01:36:13,000
就是那个 normalization 的各种方法和它的背后的一些这个机制

3665
01:36:13,000 --> 01:36:14,000
那就

3666
01:36:14,000 --> 01:36:17,000
然后我们回来讲那个 apfs

3667
01:36:17,000 --> 01:36:20,000
它在 macOS 和 iOS 里面到底不一样的地方

3668
01:36:20,000 --> 01:36:22,000
我觉得这个还其实挺挺挺有意思的

3669
01:36:22,000 --> 01:36:24,000
因为照我的理解

3670
01:36:24,000 --> 01:36:29,000
apfs 在 macOS 里面对于我们能力的处理是最近才决定的

3671
01:36:29,000 --> 01:36:33,000
就其实我们在之前上那个 iOS 的 apfs

3672
01:36:33,000 --> 01:36:35,000
它是没有考虑这个问题的

3673
01:36:35,000 --> 01:36:36,000
对

3674
01:36:36,000 --> 01:36:40,000
所以它现在搞了一个什么样的一个 hash 的方式

3675
01:36:40,000 --> 01:36:40,000
我还没太明白

3676
01:36:40,000 --> 01:36:41,000
你们谁看

3677
01:36:41,000 --> 01:36:44,000
我也不知道

3678
01:36:44,000 --> 01:36:47,000
他就是说因为他改能 apfs

3679
01:36:47,000 --> 01:36:52,000
就是不管 mac 是用 hfs 加还是用 apfs

3680
01:36:52,000 --> 01:36:56,000
它都是这个 normalization insensitive 的

3681
01:36:56,000 --> 01:36:56,000
它就

3682
01:36:56,000 --> 01:36:58,000
它不敏感

3683
01:36:58,000 --> 01:37:01,000
它对你这个规范化形式不敏感

3684
01:37:01,000 --> 01:37:02,000
但是呢

3685
01:37:02,000 --> 01:37:05,000
hfs 它是

3686
01:37:05,000 --> 01:37:09,000
它就直接存在那个词盘上了

3687
01:37:09,000 --> 01:37:11,000
那 apfs 呢

3688
01:37:11,000 --> 01:37:11,000
它会

3689
01:37:11,000 --> 01:37:13,000
它是先规范化

3690
01:37:13,000 --> 01:37:14,000
然后这个文静明

3691
01:37:14,000 --> 01:37:14,000
它会

3692
01:37:14,000 --> 01:37:16,000
它会另外生成一个哈希值

3693
01:37:16,000 --> 01:37:18,000
来指

3694
01:37:18,000 --> 01:37:20,000
来给这个

3695
01:37:20,000 --> 01:37:22,000
提供那个 normalization 的

3696
01:37:22,000 --> 01:37:23,000
这个

3697
01:37:23,000 --> 01:37:25,000
就不敏感性

3698
01:37:25,000 --> 01:37:25,000
要不然的话

3699
01:37:25,000 --> 01:37:26,000
就找不到了嘛

3700
01:37:26,000 --> 01:37:26,000
就是

3701
01:37:26,000 --> 01:37:29,000
所以他必须再给他付一个

3702
01:37:29,000 --> 01:37:30,000
那个自动付一个哈希值

3703
01:37:30,000 --> 01:37:32,000
OK

3704
01:37:32,000 --> 01:37:36,000
这里面其实还挺麻烦的

3705
01:37:36,000 --> 01:37:37,000
因为有几个问题啊

3706
01:37:37,000 --> 01:37:38,000
就是刚才也讲了

3707
01:37:38,000 --> 01:37:39,000
有几个事情融在了一起

3708
01:37:39,000 --> 01:37:39,000
就是一个说

3709
01:37:39,000 --> 01:37:41,000
它要不要保留

3710
01:37:41,000 --> 01:37:42,000
那个就是你开始的

3711
01:37:42,000 --> 01:37:43,000
这个

3712
01:37:43,000 --> 01:37:44,000
先说一下

3713
01:37:44,000 --> 01:37:44,000
还有个事情没说

3714
01:37:44,000 --> 01:37:45,000
刚才

3715
01:37:45,000 --> 01:37:46,000
因为跟着也有关系

3716
01:37:46,000 --> 01:37:46,000
就是

3717
01:37:46,000 --> 01:37:48,000
iOS 的那个文件系统

3718
01:37:48,000 --> 01:37:50,000
是大小写敏感的

3719
01:37:50,000 --> 01:37:51,000
就是大小写

3720
01:37:51,000 --> 01:37:53,000
是同样一个文件

3721
01:37:53,000 --> 01:37:54,000
名大小写不一样

3722
01:37:54,000 --> 01:37:55,000
它认为是不一样的

3723
01:37:55,000 --> 01:37:55,000
的那个

3724
01:37:55,000 --> 01:37:56,000
那个

3725
01:37:56,000 --> 01:37:57,000
文件

3726
01:37:57,000 --> 01:37:59,000
在 macOS 里面

3727
01:37:59,000 --> 01:38:00,000
也是

3728
01:38:00,000 --> 01:38:03,000
它不管是过去的

3729
01:38:03,000 --> 01:38:03,000
HFS

3730
01:38:03,000 --> 01:38:04,000
还是现在 APFS

3731
01:38:04,000 --> 01:38:05,000
它默认的都是

3732
01:38:05,000 --> 01:38:06,000
大小写不敏感

3733
01:38:06,000 --> 01:38:07,000
就是它认为

3734
01:38:07,000 --> 01:38:08,000
但是它是

3735
01:38:08,000 --> 01:38:10,000
它是大小写

3736
01:38:10,000 --> 01:38:11,000
可保存

3737
01:38:11,000 --> 01:38:12,000
但是不敏感

3738
01:38:12,000 --> 01:38:13,000
对

3739
01:38:13,000 --> 01:38:13,000
它会把

3740
01:38:13,000 --> 01:38:14,000
那个

3741
01:38:14,000 --> 01:38:15,000
你开始原始的

3742
01:38:15,000 --> 01:38:16,000
那个大小写

3743
01:38:16,000 --> 01:38:17,000
保留下来

3744
01:38:17,000 --> 01:38:18,000
但是就是说

3745
01:38:18,000 --> 01:38:18,000
它不会

3746
01:38:18,000 --> 01:38:20,000
它不会说

3747
01:38:20,000 --> 01:38:21,000
它会去区分这个事情

3748
01:38:21,000 --> 01:38:22,000
但是

3749
01:38:22,000 --> 01:38:23,000
当然也可以就是说

3750
01:38:23,000 --> 01:38:25,000
你在那个 macOS 里面

3751
01:38:25,000 --> 01:38:25,000
你在格式化

3752
01:38:25,000 --> 01:38:26,000
一个资盘的时候

3753
01:38:26,000 --> 01:38:27,000
你可以选择

3754
01:38:27,000 --> 01:38:28,000
让那个文件系统

3755
01:38:28,000 --> 01:38:29,000
是做成大小写敏感的

3756
01:38:29,000 --> 01:38:30,000
但这个应该用的人不符

3757
01:38:30,000 --> 01:38:31,000
而且

3758
01:38:31,000 --> 01:38:32,000
这用了就会导致很多

3759
01:38:32,000 --> 01:38:33,000
兼容性的问题

3760
01:38:33,000 --> 01:38:34,000
就是不太鼓励

3761
01:38:34,000 --> 01:38:35,000
大家这么做的

3762
01:38:35,000 --> 01:38:36,000
所以这里面

3763
01:38:36,000 --> 01:38:37,000
如果它是用哈希值的话

3764
01:38:37,000 --> 01:38:38,000
就会牵涉到这个问题了

3765
01:38:38,000 --> 01:38:39,000
就是说

3766
01:38:39,000 --> 01:38:40,000
如果它是大小写

3767
01:38:40,000 --> 01:38:41,000
preserving

3768
01:38:41,000 --> 01:38:43,000
就是 case preserving 的话

3769
01:38:43,000 --> 01:38:44,000
它

3770
01:38:44,000 --> 01:38:46,000
它哈希的那个串

3771
01:38:46,000 --> 01:38:47,000
到底是什么

3772
01:38:47,000 --> 01:38:50,000
因为大小写

3773
01:38:50,000 --> 01:38:52,000
大小写不同的两个

3774
01:38:52,000 --> 01:38:53,000
同样的字符串

3775
01:38:53,000 --> 01:38:54,000
的哈希

3776
01:38:54,000 --> 01:38:55,000
只是不一样的

3777
01:38:55,000 --> 01:38:55,000
对

3778
01:38:55,000 --> 01:38:57,000
这样的话

3779
01:38:57,000 --> 01:38:59,000
它的 case preserving

3780
01:38:59,000 --> 01:39:00,000
和它的这个

3781
01:39:00,000 --> 01:39:02,000
哈希的方式

3782
01:39:02,000 --> 01:39:03,000
其实是有冲突的

3783
01:39:03,000 --> 01:39:04,000
所以我一直没太搞明白

3784
01:39:04,000 --> 01:39:05,000
这里是怎么一回事

3785
01:39:05,000 --> 01:39:06,000
对

3786
01:39:06,000 --> 01:39:08,000
我觉得像给自弹自唱的

3787
01:39:08,000 --> 01:39:09,000
这个听众

3788
01:39:09,000 --> 01:39:09,000
简单解释一下

3789
01:39:09,000 --> 01:39:11,000
哈希是个什么样的过程

3790
01:39:11,000 --> 01:39:14,000
哈希你可以理解成为

3791
01:39:14,000 --> 01:39:16,000
就是我们把一个

3792
01:39:16,000 --> 01:39:17,000
一个字符串吧

3793
01:39:17,000 --> 01:39:19,000
然后通过某种数学的方式

3794
01:39:19,000 --> 01:39:21,000
把它变成一个

3795
01:39:21,000 --> 01:39:23,000
固定长度的一个

3796
01:39:23,000 --> 01:39:25,000
一个数字

3797
01:39:25,000 --> 01:39:26,000
这可能都是

3798
01:39:26,000 --> 01:39:28,000
比如说是 122

3799
01:39:28,000 --> 01:39:28,000
不对

3800
01:39:28,000 --> 01:39:30,000
哈希一般 16 个字节是多少

3801
01:39:30,000 --> 01:39:33,000
16 个字节是乘以 8

3802
01:39:33,000 --> 01:39:33,000
对吧

3803
01:39:33,000 --> 01:39:34,000
256 个

3804
01:39:34,000 --> 01:39:37,000
别错了

3805
01:39:37,000 --> 01:39:40,000
256 个字符

3806
01:39:40,000 --> 01:39:42,000
给他一个

3807
01:39:42,000 --> 01:39:43,000
生成了一个

3808
01:39:43,000 --> 01:39:44,000
特定的一个

3809
01:39:44,000 --> 01:39:45,000
一个定号

3810
01:39:45,000 --> 01:39:46,000
对

3811
01:39:46,000 --> 01:39:47,000
定长的

3812
01:39:47,000 --> 01:39:48,000
会返回一个

3813
01:39:48,000 --> 01:39:50,000
比如说 256 个 bit 的

3814
01:39:50,000 --> 01:39:50,000
一个数

3815
01:39:50,000 --> 01:39:52,000
或者是 512 个 bit 的

3816
01:39:52,000 --> 01:39:52,000
一个数

3817
01:39:52,000 --> 01:39:54,000
然后因为这个数

3818
01:39:54,000 --> 01:39:54,000
其实足够大

3819
01:39:54,000 --> 01:39:55,000
你想想

3820
01:39:55,000 --> 01:39:57,000
2 的 256 字方

3821
01:39:57,000 --> 01:39:57,000
这个数

3822
01:39:57,000 --> 01:39:58,000
其实是非常大的

3823
01:39:58,000 --> 01:39:59,000
那么这个哈希

3824
01:39:59,000 --> 01:40:00,000
有个什么特性呢

3825
01:40:00,000 --> 01:40:00,000
就是说

3826
01:40:00,000 --> 01:40:02,000
只要我们这个哈希算法

3827
01:40:02,000 --> 01:40:03,000
或者哈希函数

3828
01:40:03,000 --> 01:40:04,000
选的少

3829
01:40:04,000 --> 01:40:05,000
我们可以做到在

3830
01:40:05,000 --> 01:40:08,000
一个几乎可以忽略的概率上

3831
01:40:08,000 --> 01:40:10,000
得到那个数和

3832
01:40:10,000 --> 01:40:11,000
就两个

3833
01:40:11,000 --> 01:40:12,000
就不太可能

3834
01:40:12,000 --> 01:40:13,000
你不太可能

3835
01:40:13,000 --> 01:40:15,000
拿两个有意义的文本

3836
01:40:15,000 --> 01:40:17,000
得到两个完全一样的

3837
01:40:17,000 --> 01:40:18,000
哈希的值

3838
01:40:18,000 --> 01:40:20,000
这个可能有很多人

3839
01:40:20,000 --> 01:40:22,000
比较容易费解这个东西

3840
01:40:22,000 --> 01:40:23,000
因为你想一下

3841
01:40:23,000 --> 01:40:23,000
这个在数据上

3842
01:40:23,000 --> 01:40:24,000
是不可能的

3843
01:40:24,000 --> 01:40:26,000
因为你的那个字符串的

3844
01:40:26,000 --> 01:40:27,000
就是你的那个函数的

3845
01:40:27,000 --> 01:40:28,000
哈希函数的

3846
01:40:28,000 --> 01:40:30,000
这个输入的那个 space

3847
01:40:30,000 --> 01:40:30,000
input space

3848
01:40:30,000 --> 01:40:31,000
是远远大于

3849
01:40:31,000 --> 01:40:32,000
output space

3850
01:40:32,000 --> 01:40:34,000
它是一个

3851
01:40:34,000 --> 01:40:35,000
它是一个固定

3852
01:40:35,000 --> 01:40:36,000
固定的一个

3853
01:40:36,000 --> 01:40:36,000
它是一个有限级

3854
01:40:36,000 --> 01:40:37,000
对

3855
01:40:37,000 --> 01:40:38,000
它是一个有限级

3856
01:40:38,000 --> 01:40:38,000
但你输入的

3857
01:40:38,000 --> 01:40:39,000
其实是一个无限级

3858
01:40:39,000 --> 01:40:41,000
但是因为

3859
01:40:41,000 --> 01:40:42,000
因为那个无限

3860
01:40:42,000 --> 01:40:43,000
输出那个

3861
01:40:43,000 --> 01:40:44,000
有限级的空间

3862
01:40:44,000 --> 01:40:45,000
足够足够大

3863
01:40:45,000 --> 01:40:47,000
然后只要我们这个

3864
01:40:47,000 --> 01:40:47,000
哈希函数

3865
01:40:47,000 --> 01:40:48,000
选的足够好的话

3866
01:40:48,000 --> 01:40:49,000
我们是可以

3867
01:40:49,000 --> 01:40:51,000
在大概率上认为

3868
01:40:51,000 --> 01:40:52,000
是不会出现那种

3869
01:40:52,000 --> 01:40:54,000
两个不同的输入

3870
01:40:54,000 --> 01:40:56,000
走到同一个哈希值的

3871
01:40:56,000 --> 01:40:57,000
然后这个哈希值

3872
01:40:57,000 --> 01:40:58,000
就我们可以拿来

3873
01:40:58,000 --> 01:40:58,000
做很多事情

3874
01:40:58,000 --> 01:40:59,000
比如说我们可以拿来

3875
01:40:59,000 --> 01:41:00,000
把一个东西

3876
01:41:00,000 --> 01:41:01,000
缩短成一个

3877
01:41:01,000 --> 01:41:02,000
我们认为

3878
01:41:02,000 --> 01:41:03,000
这个它是一个

3879
01:41:03,000 --> 01:41:04,000
类似于指纹的

3880
01:41:04,000 --> 01:41:04,000
一个概念

3881
01:41:04,000 --> 01:41:05,000
对吧

3882
01:41:05,000 --> 01:41:06,000
我们就说

3883
01:41:06,000 --> 01:41:07,000
它这一串哈希值

3884
01:41:07,000 --> 01:41:08,000
可以对应

3885
01:41:08,000 --> 01:41:09,000
那串原文

3886
01:41:09,000 --> 01:41:10,000
因为我们找不到

3887
01:41:10,000 --> 01:41:11,000
另外一串原文

3888
01:41:11,000 --> 01:41:11,000
跟这个

3889
01:41:11,000 --> 01:41:13,000
可以得到同样的

3890
01:41:13,000 --> 01:41:14,000
哈希值

3891
01:41:14,000 --> 01:41:15,000
然后

3892
01:41:15,000 --> 01:41:16,000
APFS 里面

3893
01:41:16,000 --> 01:41:17,000
它就说

3894
01:41:17,000 --> 01:41:18,000
我是用这个哈希值

3895
01:41:18,000 --> 01:41:19,000
来保存文件的

3896
01:41:19,000 --> 01:41:19,000
对吧

3897
01:41:19,000 --> 01:41:21,000
保存文件名

3898
01:41:21,000 --> 01:41:22,000
对

3899
01:41:22,000 --> 01:41:23,000
但我就不太理解

3900
01:41:23,000 --> 01:41:24,000
就是说这里面

3901
01:41:24,000 --> 01:41:25,000
如果它怎么去解决

3902
01:41:25,000 --> 01:41:25,000
刚才讲的

3903
01:41:25,000 --> 01:41:27,000
那个 case preserving 的问题

3904
01:41:27,000 --> 01:41:27,000
就其实我看起来

3905
01:41:27,000 --> 01:41:29,000
还觉得还挺难的

3906
01:41:29,000 --> 01:41:30,000
所以啊

3907
01:41:30,000 --> 01:41:31,000
就是这有一个历史

3908
01:41:31,000 --> 01:41:32,000
就是在这个

3909
01:41:32,000 --> 01:41:34,000
呃

3910
01:41:34,000 --> 01:41:35,000
MacOS Sierra

3911
01:41:35,000 --> 01:41:37,000
这个去年六月份

3912
01:41:37,000 --> 01:41:39,000
他已经

3913
01:41:39,000 --> 01:41:40,000
他有做一个

3914
01:41:40,000 --> 01:41:41,000
APFS 的第一版的

3915
01:41:41,000 --> 01:41:42,000
开发者的预览版

3916
01:41:42,000 --> 01:41:44,000
当时这个预览版里面

3917
01:41:44,000 --> 01:41:47,000
只有 case sensitive 的版本

3918
01:41:47,000 --> 01:41:48,000
嗯哼

3919
01:41:48,000 --> 01:41:49,000
就是说明那时候

3920
01:41:49,000 --> 01:41:50,000
苹果还没没想好

3921
01:41:50,000 --> 01:41:51,000
就怎么做

3922
01:41:51,000 --> 01:41:51,000
你知道吗

3923
01:41:51,000 --> 01:41:52,000
所以当时他

3924
01:41:52,000 --> 01:41:53,000
做的第一版的

3925
01:41:53,000 --> 01:41:54,000
开发者预览版

3926
01:41:54,000 --> 01:41:56,000
只能做 case sensitive

3927
01:41:56,000 --> 01:41:57,000
对大小写生

3928
01:41:57,000 --> 01:41:58,000
因为这是最简单吗

3929
01:41:58,000 --> 01:42:00,000
对对对对

3930
01:42:00,000 --> 01:42:01,000
然后等到后面

3931
01:42:01,000 --> 01:42:03,000
MacOS 的 10 点

3932
01:42:03,000 --> 01:42:05,000
12.4 了以后

3933
01:42:05,000 --> 01:42:06,000
给这个开发者的预料版

3934
01:42:06,000 --> 01:42:08,000
后面他才补加了

3935
01:42:08,000 --> 01:42:09,000
做出来这个 case

3936
01:42:09,000 --> 01:42:10,000
insensitive 的版本

3937
01:42:10,000 --> 01:42:11,000
因为他这个是

3938
01:42:11,000 --> 01:42:13,000
就是也是因为

3939
01:42:13,000 --> 01:42:14,000
就是为了去填

3940
01:42:14,000 --> 01:42:15,000
那个历史的坑嘛

3941
01:42:15,000 --> 01:42:16,000
因为过去 HFS

3942
01:42:16,000 --> 01:42:17,000
他是默认是 insensitive

3943
01:42:17,000 --> 01:42:19,000
你就很很尴尬

3944
01:42:19,000 --> 01:42:20,000
对

3945
01:42:20,000 --> 01:42:21,000
所以其实就是

3946
01:42:21,000 --> 01:42:22,000
他在后面

3947
01:42:22,000 --> 01:42:24,000
具体他在怎么搞

3948
01:42:24,000 --> 01:42:25,000
其实我也不大清楚

3949
01:42:25,000 --> 01:42:26,000
但是就是因为有这个坑

3950
01:42:26,000 --> 01:42:27,000
所以对

3951
01:42:27,000 --> 01:42:29,000
因为有这个坑

3952
01:42:29,000 --> 01:42:29,000
所以他

3953
01:42:29,000 --> 01:42:31,000
他也是花了很长时间

3954
01:42:31,000 --> 01:42:31,000
在搞

3955
01:42:31,000 --> 01:42:31,000
对

3956
01:42:31,000 --> 01:42:33,000
因为现在那个 APFS

3957
01:42:33,000 --> 01:42:34,000
就那个 HICR

3958
01:42:34,000 --> 01:42:35,000
还没有

3959
01:42:35,000 --> 01:42:37,000
就是正式发布

3960
01:42:37,000 --> 01:42:38,000
现在这是 beta 版

3961
01:42:38,000 --> 01:42:40,000
就说他们还有的

3962
01:42:40,000 --> 01:42:40,000
有的机会改

3963
01:42:40,000 --> 01:42:41,000
但是如果说

3964
01:42:41,000 --> 01:42:43,000
到了今年的这个 9 月份

3965
01:42:43,000 --> 01:42:44,000
也就是两个月的时间

3966
01:42:44,000 --> 01:42:44,000
对

3967
01:42:44,000 --> 01:42:46,000
就会放出来

3968
01:42:46,000 --> 01:42:47,000
放出来之后

3969
01:42:47,000 --> 01:42:48,000
如果没有

3970
01:42:48,000 --> 01:42:49,000
这个问题没解决好的话

3971
01:42:49,000 --> 01:42:51,000
就会导致很多人的软件

3972
01:42:51,000 --> 01:42:51,000
可能用不了

3973
01:42:51,000 --> 01:42:52,000
或者说是文件

3974
01:42:52,000 --> 01:42:53,000
除了那个情况

3975
01:42:53,000 --> 01:42:54,000
所以他们必须在

3976
01:42:54,000 --> 01:42:55,000
必须在这段时间

3977
01:42:55,000 --> 01:42:57,000
把这个问题给彻底解决了

3978
01:42:57,000 --> 01:42:59,000
用各种方式吧

3979
01:42:59,000 --> 01:43:00,000
就现在我们看到的

3980
01:43:00,000 --> 01:43:01,000
其实也不是一个

3981
01:43:01,000 --> 01:43:02,000
我觉得应该也不是一个

3982
01:43:02,000 --> 01:43:04,000
最终的版本

3983
01:43:04,000 --> 01:43:05,000
不过反正

3984
01:43:05,000 --> 01:43:08,000
Hi Sierra 是可以定了

3985
01:43:08,000 --> 01:43:10,000
就是肯定要用新的这个 APFS 了

3986
01:43:10,000 --> 01:43:12,000
在安装过程中

3987
01:43:12,000 --> 01:43:13,000
他会默认的

3988
01:43:13,000 --> 01:43:15,000
他会去把你格式化一遍

3989
01:43:15,000 --> 01:43:16,000
你已经装了吗

3990
01:43:16,000 --> 01:43:18,000
没有没有

3991
01:43:18,000 --> 01:43:19,000
特别知道的

3992
01:43:19,000 --> 01:43:19,000
但是

3993
01:43:19,000 --> 01:43:22,000
其实在升 iOS 10.3 的时候

3994
01:43:22,000 --> 01:43:23,000
就是这样的

3995
01:43:23,000 --> 01:43:25,000
iOS 都说了

3996
01:43:25,000 --> 01:43:26,000
他不存在

3997
01:43:26,000 --> 01:43:27,000
他不担心这个问题

3998
01:43:27,000 --> 01:43:28,000
因为 iOS 并没有

3999
01:43:28,000 --> 01:43:28,000
对没错

4000
01:43:28,000 --> 01:43:29,000
而且

4001
01:43:29,000 --> 01:43:32,000
而且 iOS 还有一个特性

4002
01:43:32,000 --> 01:43:33,000
就是他没有一个

4003
01:43:33,000 --> 01:43:34,000
他只有一套 API

4004
01:43:34,000 --> 01:43:35,000
去访问那个文件

4005
01:43:35,000 --> 01:43:36,000
就是

4006
01:43:36,000 --> 01:43:37,000
都是用 Foundation 的一些库

4007
01:43:37,000 --> 01:43:39,000
他不像 Mac 里面

4008
01:43:39,000 --> 01:43:41,000
我们用 Terminal 的时候

4009
01:43:41,000 --> 01:43:42,000
其实直接用 PoSix

4010
01:43:42,000 --> 01:43:44,000
就 Unix 那套逻辑去访问

4011
01:43:44,000 --> 01:43:48,000
所以他考虑的那个难度

4012
01:43:48,000 --> 01:43:49,000
就是要小很多

4013
01:43:49,000 --> 01:43:50,000
所以我觉得 Mac

4014
01:43:50,000 --> 01:43:52,000
其实挺大的一个坑的

4015
01:43:52,000 --> 01:43:54,000
而且说实话

4016
01:43:54,000 --> 01:43:54,000
这个东西

4017
01:43:54,000 --> 01:43:55,000
对于用户来讲

4018
01:43:55,000 --> 01:43:56,000
是完全看不见的

4019
01:43:56,000 --> 01:43:57,000
像我刚才说的

4020
01:43:57,000 --> 01:43:59,000
他这个格式化的过程

4021
01:43:59,000 --> 01:44:01,000
他其实就放到了

4022
01:44:01,000 --> 01:44:02,000
那个安装进程里面

4023
01:44:02,000 --> 01:44:02,000
你开始

4024
01:44:02,000 --> 01:44:04,000
对于

4025
01:44:04,000 --> 01:44:05,000
尤其是对于 iOS

4026
01:44:05,000 --> 01:44:07,000
你在装

4027
01:44:07,000 --> 01:44:09,000
在更新的时候

4028
01:44:09,000 --> 01:44:10,000
就用户不能做任何事情

4029
01:44:10,000 --> 01:44:11,000
反正你就等着他

4030
01:44:11,000 --> 01:44:13,000
要重新启动两遍

4031
01:44:13,000 --> 01:44:14,000
反正就是新的了

4032
01:44:14,000 --> 01:44:15,000
就这样

4033
01:44:15,000 --> 01:44:16,000
而且

4034
01:44:16,000 --> 01:44:17,000
而且就是用户

4035
01:44:17,000 --> 01:44:19,000
即便知道了这个区别

4036
01:44:19,000 --> 01:44:19,000
他也改不了

4037
01:44:19,000 --> 01:44:20,000
做不了任何事情

4038
01:44:20,000 --> 01:44:21,000
因为你用到这个程序

4039
01:44:21,000 --> 01:44:23,000
如果没有更新

4040
01:44:23,000 --> 01:44:24,000
去支持这个事情的话

4041
01:44:24,000 --> 01:44:25,000
你也是只能抓虾

4042
01:44:25,000 --> 01:44:27,000
对

4043
01:44:27,000 --> 01:44:28,000
那对于 Mac 的话

4044
01:44:28,000 --> 01:44:29,000
可能就是因为

4045
01:44:29,000 --> 01:44:31,000
如果万一搞不清楚的话

4046
01:44:31,000 --> 01:44:32,000
就会造成

4047
01:44:32,000 --> 01:44:33,000
找不到文件了

4048
01:44:33,000 --> 01:44:34,000
对吧

4049
01:44:34,000 --> 01:44:34,000
因为

4050
01:44:34,000 --> 01:44:35,000
那个

4051
01:44:35,000 --> 01:44:37,000
Normalization 不一样

4052
01:44:37,000 --> 01:44:37,000
文件名不一样

4053
01:44:37,000 --> 01:44:39,000
然后就和你

4054
01:44:39,000 --> 01:44:40,000
磁盘盘存的东西

4055
01:44:40,000 --> 01:44:41,000
不一样就找不到了

4056
01:44:41,000 --> 01:44:42,000
就有时候

4057
01:44:42,000 --> 01:44:44,000
最坑的

4058
01:44:44,000 --> 01:44:45,000
最差的结果

4059
01:44:45,000 --> 01:44:48,000
所以这个 Normalization

4060
01:44:48,000 --> 01:44:48,000
这个事情

4061
01:44:48,000 --> 01:44:50,000
会对我们交换

4062
01:44:50,000 --> 01:44:50,000
在不同的东西里面

4063
01:44:50,000 --> 01:44:51,000
交换文件产生影响

4064
01:44:51,000 --> 01:44:53,000
就是因为现在

4065
01:44:53,000 --> 01:44:54,000
有很多问题

4066
01:44:54,000 --> 01:44:54,000
比如说

4067
01:44:54,000 --> 01:44:55,000
我知道你们又收到

4068
01:44:55,000 --> 01:44:56,000
Windows 用户

4069
01:44:56,000 --> 01:44:57,000
发给你们的这种 Zip

4070
01:44:57,000 --> 01:44:59,000
这种打包的

4071
01:44:59,000 --> 01:44:59,000
这种压缩包

4072
01:44:59,000 --> 01:45:02,000
经常会乱码的事情

4073
01:45:02,000 --> 01:45:03,000
就经常会解出来

4074
01:45:03,000 --> 01:45:05,000
里面的那个文件

4075
01:45:05,000 --> 01:45:06,000
就是那个名字是乱的

4076
01:45:06,000 --> 01:45:10,000
但是那个乱码的机制

4077
01:45:10,000 --> 01:45:11,000
这很复杂的

4078
01:45:11,000 --> 01:45:12,000
就是为什么会乱

4079
01:45:12,000 --> 01:45:16,000
就是简单来说

4080
01:45:16,000 --> 01:45:18,000
那个 Zip 打包的时候

4081
01:45:18,000 --> 01:45:20,000
他会把那些文件名的信息

4082
01:45:20,000 --> 01:45:21,000
也装进去

4083
01:45:21,000 --> 01:45:22,000
这个时候

4084
01:45:22,000 --> 01:45:24,000
他用的那个 encoding 的方式

4085
01:45:24,000 --> 01:45:27,000
就是 Zip 这个格式

4086
01:45:27,000 --> 01:45:28,000
其实是比较灵活的

4087
01:45:28,000 --> 01:45:30,000
他不会要求说

4088
01:45:30,000 --> 01:45:31,000
你一定要有什么 encoding 的方式

4089
01:45:31,000 --> 01:45:32,000
这个时候都是由

4090
01:45:32,000 --> 01:45:33,000
那个打包程序决定的

4091
01:45:33,000 --> 01:45:35,000
但是解码的程序

4092
01:45:35,000 --> 01:45:36,000
如果用的

4093
01:45:36,000 --> 01:45:37,000
跟那个打包程序

4094
01:45:37,000 --> 01:45:37,000
他用的那个理解

4095
01:45:37,000 --> 01:45:38,000
是不一样的话

4096
01:45:38,000 --> 01:45:39,000
就会导致这个问题

4097
01:45:39,000 --> 01:45:41,000
经常我们说到一个

4098
01:45:41,000 --> 01:45:42,000
Windows 用户

4099
01:45:42,000 --> 01:45:43,000
发过来打包的

4100
01:45:43,000 --> 01:45:46,000
但是这是编码层次的问题

4101
01:45:46,000 --> 01:45:47,000
就是比如说

4102
01:45:47,000 --> 01:45:49,000
他没有用 UTF 8 之类的

4103
01:45:49,000 --> 01:45:52,000
这是编码和解码的事情

4104
01:45:52,000 --> 01:45:52,000
对

4105
01:45:52,000 --> 01:45:54,000
但是我就说

4106
01:45:54,000 --> 01:45:55,000
如果是

4107
01:45:55,000 --> 01:45:58,000
哪怕他们都用了 UTF 8 去编码

4108
01:45:58,000 --> 01:45:59,000
那个 Normalization 不同的话

4109
01:45:59,000 --> 01:46:00,000
解出来也会导致

4110
01:46:00,000 --> 01:46:01,000
也会不一样

4111
01:46:01,000 --> 01:46:01,000
对

4112
01:46:01,000 --> 01:46:02,000
是的

4113
01:46:02,000 --> 01:46:07,000
所以这是一个非常深的一个

4114
01:46:07,000 --> 01:46:08,000
对对对

4115
01:46:08,000 --> 01:46:09,000
所以就刚才说

4116
01:46:09,000 --> 01:46:11,000
一般遇到乱码问题的话

4117
01:46:11,000 --> 01:46:12,000
是编码层面的问题

4118
01:46:12,000 --> 01:46:14,000
而像我刚才说了

4119
01:46:14,000 --> 01:46:18,000
在日文的 Windows

4120
01:46:18,000 --> 01:46:20,000
拷贝到 Mac 上面

4121
01:46:20,000 --> 01:46:21,000
就会发现一个字

4122
01:46:21,000 --> 01:46:23,000
被拆开来了

4123
01:46:23,000 --> 01:46:24,000
就会有这样的问题

4124
01:46:24,000 --> 01:46:25,000
就是变成一个字

4125
01:46:25,000 --> 01:46:26,000
它变成两个字了

4126
01:46:26,000 --> 01:46:27,000
两个字了

4127
01:46:27,000 --> 01:46:27,000
对对

4128
01:46:27,000 --> 01:46:29,000
就是你看的已经是两个字了

4129
01:46:29,000 --> 01:46:31,000
你看的就已经是两个字

4130
01:46:31,000 --> 01:46:32,000
就会

4131
01:46:32,000 --> 01:46:34,000
就完全会被拆开来

4132
01:46:34,000 --> 01:46:35,000
就是因为

4133
01:46:35,000 --> 01:46:37,000
它已经

4134
01:46:37,000 --> 01:46:38,000
它从

4135
01:46:38,000 --> 01:46:39,000
就透到那个

4136
01:46:39,000 --> 01:46:41,000
操作系统层面上来了

4137
01:46:41,000 --> 01:46:41,000
变成

4138
01:46:41,000 --> 01:46:42,000
OK

4139
01:46:42,000 --> 01:46:43,000
就又会已经改变了

4140
01:46:43,000 --> 01:46:44,000
因为系统不一样

4141
01:46:44,000 --> 01:46:45,000
那这个时候你们怎么办呢

4142
01:46:45,000 --> 01:46:47,000
没办法呀

4143
01:46:47,000 --> 01:46:49,000
就自己再重新编辑

4144
01:46:49,000 --> 01:46:49,000
这样的证明

4145
01:46:49,000 --> 01:46:51,000
对呀

4146
01:46:51,000 --> 01:46:52,000
但其实这个

4147
01:46:52,000 --> 01:46:54,000
这件事情并不是

4148
01:46:54,000 --> 01:46:55,000
发生在

4149
01:46:55,000 --> 01:46:57,000
Normalization

4150
01:46:57,000 --> 01:46:59,000
的这个过程中

4151
01:46:59,000 --> 01:46:59,000
我觉得

4152
01:46:59,000 --> 01:47:00,000
对没错

4153
01:47:00,000 --> 01:47:01,000
这不是这个过程

4154
01:47:01,000 --> 01:47:03,000
但是毕竟是因为

4155
01:47:03,000 --> 01:47:03,000
它

4156
01:47:03,000 --> 01:47:04,000
Normalization

4157
01:47:04,000 --> 01:47:07,000
它采取的原则方式不一样

4158
01:47:07,000 --> 01:47:07,000
然后最后呢

4159
01:47:07,000 --> 01:47:09,000
而且原来

4160
01:47:09,000 --> 01:47:10,000
刚才也说了嘛

4161
01:47:10,000 --> 01:47:11,000
就 Normalization

4162
01:47:11,000 --> 01:47:11,000
这个事情

4163
01:47:11,000 --> 01:47:13,000
它其实是不会被用户

4164
01:47:13,000 --> 01:47:14,000
所知道的嘛

4165
01:47:14,000 --> 01:47:16,000
就其实它是这样的嘛

4166
01:47:16,000 --> 01:47:16,000
就是说

4167
01:47:16,000 --> 01:47:18,000
说明 Windows 的某一个用户

4168
01:47:18,000 --> 01:47:20,000
他在输入这个文件名的时候

4169
01:47:20,000 --> 01:47:22,000
他输入的那一串字符

4170
01:47:22,000 --> 01:47:22,000
其实就是一个

4171
01:47:22,000 --> 01:47:24,000
被拆解的形式

4172
01:47:24,000 --> 01:47:25,000
然后呢

4173
01:47:25,000 --> 01:47:26,000
他就被 Windows 的这个

4174
01:47:26,000 --> 01:47:27,000
操作系统记录下来

4175
01:47:27,000 --> 01:47:28,000
并且保存下来

4176
01:47:28,000 --> 01:47:29,000
那么它传到这个

4177
01:47:29,000 --> 01:47:31,000
OS 10 上的时候

4178
01:47:31,000 --> 01:47:33,000
OS 10 就觉得

4179
01:47:33,000 --> 01:47:34,000
这里其实是两个字符

4180
01:47:34,000 --> 01:47:35,000
那么我就把它们分开

4181
01:47:35,000 --> 01:47:36,000
进行一个操作

4182
01:47:36,000 --> 01:47:37,000
比如说删除的时候

4183
01:47:37,000 --> 01:47:39,000
你能删除其中的一半

4184
01:47:39,000 --> 01:47:40,000
对吧

4185
01:47:40,000 --> 01:47:41,000
对

4186
01:47:41,000 --> 01:47:42,000
但是其实

4187
01:47:42,000 --> 01:47:43,000
两个操作系统之间

4188
01:47:43,000 --> 01:47:45,000
这里反而体现了

4189
01:47:45,000 --> 01:47:47,000
Normalization 的一个好处吧

4190
01:47:47,000 --> 01:47:49,000
就虽然它可能输入的

4191
01:47:49,000 --> 01:47:50,000
这个字符串

4192
01:47:50,000 --> 01:47:52,000
行为是不一样的

4193
01:47:52,000 --> 01:47:53,000
但是至少我们在看的时候

4194
01:47:53,000 --> 01:47:55,000
看起来它们是一样的

4195
01:47:55,000 --> 01:47:56,000
并且我们搜索的时候

4196
01:47:56,000 --> 01:47:57,000
也能搜索到它

4197
01:47:57,000 --> 01:47:58,000
就是我觉得这个时候

4198
01:47:58,000 --> 01:48:00,000
反而是 Normalization

4199
01:48:00,000 --> 01:48:02,000
起到了一个保护的作用

4200
01:48:02,000 --> 01:48:04,000
就是它没有让整个文件名

4201
01:48:04,000 --> 01:48:06,000
变得不兼容了

4202
01:48:06,000 --> 01:48:07,000
而还起到了一定的

4203
01:48:07,000 --> 01:48:09,000
这个最基本的兼容

4204
01:48:09,000 --> 01:48:10,000
对

4205
01:48:10,000 --> 01:48:12,000
所以 Normalization 是必要的

4206
01:48:12,000 --> 01:48:12,000
就是

4207
01:48:12,000 --> 01:48:14,000
那我问

4208
01:48:14,000 --> 01:48:15,000
其实你们知道

4209
01:48:15,000 --> 01:48:16,000
这个中国用户

4210
01:48:16,000 --> 01:48:18,000
怎么解决这个问题吗

4211
01:48:18,000 --> 01:48:20,000
中国用户

4212
01:48:20,000 --> 01:48:22,000
其实遇到的不算太多吧

4213
01:48:22,000 --> 01:48:23,000
多吗

4214
01:48:23,000 --> 01:48:23,000
对啊

4215
01:48:23,000 --> 01:48:24,000
就为了

4216
01:48:24,000 --> 01:48:25,000
为了

4217
01:48:25,000 --> 01:48:27,000
就要避免在那个文件里面

4218
01:48:27,000 --> 01:48:28,000
使用中文嘛

4219
01:48:28,000 --> 01:48:30,000
那就用拼音的锁字母代替就好了

4220
01:48:30,000 --> 01:48:32,000
很多人

4221
01:48:32,000 --> 01:48:33,000
很多人这么干的吧

4222
01:48:33,000 --> 01:48:34,000
好吧

4223
01:48:34,000 --> 01:48:36,000
但其实这个完全是为了

4224
01:48:36,000 --> 01:48:37,000
避免编码的问题吧

4225
01:48:37,000 --> 01:48:39,000
这也为了

4226
01:48:39,000 --> 01:48:41,000
就打字比较简单嘛

4227
01:48:41,000 --> 01:48:42,000
总比你早早

4228
01:48:42,000 --> 01:48:44,000
找字相对来说方便一些嘛

4229
01:48:44,000 --> 01:48:45,000
所以我不知道

4230
01:48:45,000 --> 01:48:46,000
这个 Eric

4231
01:48:46,000 --> 01:48:48,000
你可能比较熟悉点

4232
01:48:48,000 --> 01:48:49,000
就是在日文用户里面

4233
01:48:49,000 --> 01:48:50,000
会有很多人用日文

4234
01:48:50,000 --> 01:48:52,000
去命名那个文件名吧

4235
01:48:52,000 --> 01:48:53,000
对啊

4236
01:48:53,000 --> 01:48:53,000
那肯定啊

4237
01:48:53,000 --> 01:48:54,000
OK

4238
01:48:54,000 --> 01:48:57,000
我其实经常遇到一个问题

4239
01:48:57,000 --> 01:48:58,000
比如说我看一个英文的文档

4240
01:48:58,000 --> 01:49:01,000
然后这个文档可能是排版的比较精细的

4241
01:49:01,000 --> 01:49:04,000
它里面有一些单词就会出现盒子

4242
01:49:04,000 --> 01:49:05,000
对

4243
01:49:05,000 --> 01:49:06,000
FI 盒子搜不到

4244
01:49:06,000 --> 01:49:07,000
对了

4245
01:49:07,000 --> 01:49:09,000
这个时候我用那个系统的自带的那个

4246
01:49:09,000 --> 01:49:13,000
比如说三纸双击可以取词查字典嘛

4247
01:49:13,000 --> 01:49:15,000
这时候它查到那个字

4248
01:49:15,000 --> 01:49:16,000
它就会识别不了

4249
01:49:16,000 --> 01:49:18,000
因为它里面带了一个盒子

4250
01:49:18,000 --> 01:49:19,000
我觉得这方面好像

4251
01:49:19,000 --> 01:49:23,000
至少我现在用的这个 CRL 还处理的不是很好

4252
01:49:23,000 --> 01:49:25,000
就 PDF 会有这个问题吗

4253
01:49:25,000 --> 01:49:25,000
主要是

4254
01:49:25,000 --> 01:49:25,000
对了

4255
01:49:25,000 --> 01:49:27,000
就 preview 这个 APP

4256
01:49:27,000 --> 01:49:28,000
它在这方面的处理

4257
01:49:28,000 --> 01:49:29,000
我觉得还不是特别的完善

4258
01:49:29,000 --> 01:49:30,000
它其实理论上

4259
01:49:30,000 --> 01:49:32,000
它应该是帮你做好这个 nomalization

4260
01:49:32,000 --> 01:49:34,000
再去查字典

4261
01:49:34,000 --> 01:49:37,000
这里面跟那个 PDF 生成好像还有什么关系

4262
01:49:37,000 --> 01:49:37,000
对

4263
01:49:37,000 --> 01:49:40,000
这个比较复杂

4264
01:49:40,000 --> 01:49:43,000
这不完全是 preview 的错

4265
01:49:43,000 --> 01:49:43,000
对

4266
01:49:43,000 --> 01:49:45,000
跟 PDF 规范有一定关系

4267
01:49:45,000 --> 01:49:46,000
对

4268
01:49:46,000 --> 01:49:47,000
跟 PDF 有关系

4269
01:49:47,000 --> 01:49:47,000
而且是

4270
01:49:47,000 --> 01:49:48,000
对没错

4271
01:49:48,000 --> 01:49:48,000
是的

4272
01:49:48,000 --> 01:49:53,000
但其实如果它用这个兼容方式的 nomalization

4273
01:49:53,000 --> 01:49:55,000
它处理的特别好的话

4274
01:49:55,000 --> 01:49:56,000
它其实可以绕开这个问题

4275
01:49:56,000 --> 01:50:01,000
它其实没有做这个兼容处理

4276
01:50:01,000 --> 01:50:03,000
它只是做了一个标准处理可能

4277
01:50:03,000 --> 01:50:06,000
但基本上如果你在网页上的话

4278
01:50:06,000 --> 01:50:07,000
它应该还是可以正确识别出来吧

4279
01:50:07,000 --> 01:50:09,000
不一定

4280
01:50:09,000 --> 01:50:10,000
我觉得还真不一定

4281
01:50:10,000 --> 01:50:11,000
还不一定

4282
01:50:11,000 --> 01:50:11,000
不一定

4283
01:50:11,000 --> 01:50:12,000
对

4284
01:50:12,000 --> 01:50:15,000
因为网页上很多时候你看到这个 ligature

4285
01:50:15,000 --> 01:50:18,000
可能它并不是一个真正的 unicode 的 ligature

4286
01:50:18,000 --> 01:50:22,000
它可能只是一个 font 来显示出来的 ligature

4287
01:50:22,000 --> 01:50:24,000
可能用户输的都是单独的字符

4288
01:50:24,000 --> 01:50:26,000
所以你不太会遇到这种问题

4289
01:50:26,000 --> 01:50:27,000
对

4290
01:50:27,000 --> 01:50:30,000
所以说这是你看到的东西

4291
01:50:30,000 --> 01:50:33,000
其实有一个很多层面的东西

4292
01:50:33,000 --> 01:50:34,000
你看到是一个字

4293
01:50:34,000 --> 01:50:35,000
它可能是两个字

4294
01:50:35,000 --> 01:50:37,000
但是变成一个字的时候

4295
01:50:37,000 --> 01:50:39,000
可能是系统帮你做的

4296
01:50:39,000 --> 01:50:40,000
可能是 application 帮你做

4297
01:50:40,000 --> 01:50:42,000
那也可能是 font 帮你做的

4298
01:50:42,000 --> 01:50:44,000
就是中间隔了好多道

4299
01:50:44,000 --> 01:50:45,000
对了

4300
01:50:45,000 --> 01:50:48,000
所以人类为什么要给自己找这么多麻烦

4301
01:50:48,000 --> 01:50:51,000
其实说实话

4302
01:50:51,000 --> 01:50:52,000
如果不 unicode 的话

4303
01:50:52,000 --> 01:50:54,000
就各个各自做各的

4304
01:50:54,000 --> 01:50:55,000
就不会有这么多问题

4305
01:50:55,000 --> 01:50:57,000
但是就会有各种

4306
01:50:57,000 --> 01:50:58,000
就好多好多套规则

4307
01:50:58,000 --> 01:51:00,000
比较

4308
01:51:00,000 --> 01:51:03,000
所以 unicode

4309
01:51:03,000 --> 01:51:03,000
对

4310
01:51:03,000 --> 01:51:05,000
就一个大熔炉

4311
01:51:05,000 --> 01:51:06,000
什么东西都有

4312
01:51:06,000 --> 01:51:07,000
就会发生

4313
01:51:07,000 --> 01:51:10,000
以前不曾出现过的问题

4314
01:51:10,000 --> 01:51:10,000
知道吗

4315
01:51:10,000 --> 01:51:10,000
不对

4316
01:51:10,000 --> 01:51:13,000
其实各个各的也会出现这个问题

4317
01:51:13,000 --> 01:51:13,000
你还是要考虑

4318
01:51:13,000 --> 01:51:15,000
比如你搜索的时候

4319
01:51:15,000 --> 01:51:15,000
你要考虑

4320
01:51:15,000 --> 01:51:17,000
说就见我们的问题

4321
01:51:17,000 --> 01:51:18,000
无非就是说

4322
01:51:18,000 --> 01:51:20,000
有各个应用程序自己去搞

4323
01:51:20,000 --> 01:51:22,000
还是说交给 unicode 这个组织

4324
01:51:22,000 --> 01:51:23,000
来统一搞一套

4325
01:51:23,000 --> 01:51:25,000
大家都遵守这个标准来搞就好了

4326
01:51:25,000 --> 01:51:25,000
虽然很复杂

4327
01:51:25,000 --> 01:51:28,000
可能各个的问题更多吧

4328
01:51:28,000 --> 01:51:30,000
可能搜都搜不到

4329
01:51:30,000 --> 01:51:31,000
对

4330
01:51:31,000 --> 01:51:32,000
你一个汉字

4331
01:51:32,000 --> 01:51:33,000
可能在这个 Big Five 里

4332
01:51:33,000 --> 01:51:34,000
和在 GB 里面

4333
01:51:34,000 --> 01:51:36,000
完全是不一样的内码

4334
01:51:36,000 --> 01:51:37,000
这个搜都搜不到

4335
01:51:37,000 --> 01:51:40,000
但是还好人类

4336
01:51:40,000 --> 01:51:42,000
在这一个时机的话

4337
01:51:42,000 --> 01:51:44,000
又发现必须要做 unicode

4338
01:51:44,000 --> 01:51:45,000
然后现在大家走上了

4339
01:51:45,000 --> 01:51:46,000
unicode 的阳光大道了

4340
01:51:46,000 --> 01:51:49,000
才发现还要做很多很多的向后兼容

4341
01:51:49,000 --> 01:51:53,000
但非常不幸的是

4342
01:51:53,000 --> 01:51:54,000
还有很多国内的网站

4343
01:51:54,000 --> 01:51:57,000
还是用 GB 2312 的

4344
01:51:57,000 --> 01:51:59,000
台湾有很多

4345
01:51:59,000 --> 01:52:01,000
就在用 Big Five

4346
01:52:01,000 --> 01:52:03,000
然后可能打开就会变成乱

4347
01:52:03,000 --> 01:52:05,000
对

4348
01:52:05,000 --> 01:52:07,000
声明又很不正确的

4349
01:52:07,000 --> 01:52:08,000
对吧

4350
01:52:08,000 --> 01:52:10,000
那个 HTM 声明

4351
01:52:10,000 --> 01:52:11,000
对

4352
01:52:11,000 --> 01:52:12,000
我记得台湾教育部

4353
01:52:12,000 --> 01:52:13,000
好像还有一个网站

4354
01:52:13,000 --> 01:52:14,000
是用 Big Five

4355
01:52:14,000 --> 01:52:15,000
然后它那个网页

4356
01:52:15,000 --> 01:52:16,000
不知道是出什么问题

4357
01:52:16,000 --> 01:52:17,000
用 Safari 打开

4358
01:52:17,000 --> 01:52:19,000
基本都会是乱

4359
01:52:19,000 --> 01:52:20,000
就默认就是乱的

4360
01:52:20,000 --> 01:52:20,000
对

4361
01:52:20,000 --> 01:52:22,000
你要一字是手段去调

4362
01:52:22,000 --> 01:52:24,000
对

4363
01:52:24,000 --> 01:52:25,000
浏览器的那个

4364
01:52:25,000 --> 01:52:29,000
那个就启发式判断的方法都已经失效了

4365
01:52:29,000 --> 01:52:30,000
嗯

4366
01:52:30,000 --> 01:52:31,000
特别坑

4367
01:52:31,000 --> 01:52:32,000
好吧

4368
01:52:32,000 --> 01:52:34,000
今天差不多讲到这里了

4369
01:52:34,000 --> 01:52:38,000
我其实想通过这样一个节目呢

4370
01:52:38,000 --> 01:52:40,000
就是告诉我们的听众朋友

4371
01:52:40,000 --> 01:52:40,000
就说

4372
01:52:40,000 --> 01:52:41,000
平时大家说 unicode 的

4373
01:52:41,000 --> 01:52:44,000
这感觉就是编码嘛

4374
01:52:44,000 --> 01:52:44,000
对吧

4375
01:52:44,000 --> 01:52:45,000
就是马位啊

4376
01:52:45,000 --> 01:52:46,000
什么什么这些东西

4377
01:52:46,000 --> 01:52:51,000
其实 unicode 除了就给字符编码的以外

4378
01:52:51,000 --> 01:52:53,000
它还有很多就是在 unicode

4379
01:52:53,000 --> 01:52:54,000
这个叫 standard annex

4380
01:52:54,000 --> 01:52:57,000
就是它这个标准的附录

4381
01:52:57,000 --> 01:52:59,000
然后就附录里面

4382
01:52:59,000 --> 01:53:05,000
其实有很多就是文字处理方面的一些技术信息

4383
01:53:05,000 --> 01:53:07,000
比如说像今天我们说的这个 normalization

4384
01:53:07,000 --> 01:53:11,000
其实这是一个很复杂的一个技术环节的问题

4385
01:53:11,000 --> 01:53:15,000
这其实也是 unicode 标准的其中之一

4386
01:53:15,000 --> 01:53:17,000
是而且对作为 unicode 的它是必要的

4387
01:53:17,000 --> 01:53:21,000
然后像比如说我们上次在节目也提到

4388
01:53:21,000 --> 01:53:24,000
就比如这次 10.0 里面增加了一个

4389
01:53:24,000 --> 01:53:25,000
就是 unicode 的标准附录

4390
01:53:25,000 --> 01:53:28,000
就是 unicode 的竖牌文本

4391
01:53:28,000 --> 01:53:31,000
这这这其实也是必要的嘛

4392
01:53:31,000 --> 01:53:34,000
就是说在横牌和竖牌之间是有什么样的关系

4393
01:53:34,000 --> 01:53:38,000
要给它提升到这样一个标准附录里面去的话

4394
01:53:38,000 --> 01:53:39,000
能给这个

4395
01:53:39,000 --> 01:53:42,000
它首先有个 core specification

4396
01:53:42,000 --> 01:53:46,000
就核心的这个标准的一个规范文

4397
01:53:46,000 --> 01:53:48,000
然后呢还周边有这么多标准的附录

4398
01:53:48,000 --> 01:53:53,000
这样组合起来才是一个整体的 unicode

4399
01:53:53,000 --> 01:53:56,000
这样一个应该可以说是一个系统了

4400
01:53:56,000 --> 01:53:56,000
对吧

4401
01:53:56,000 --> 01:54:02,000
那其实我们在自谈自串的这个专题里面

4402
01:54:02,000 --> 01:54:06,000
其实我们还可以再讲很多很多关于这样的事情

4403
01:54:06,000 --> 01:54:07,000
对

4404
01:54:07,000 --> 01:54:10,000
那关于这个 nominalization 的应用层面的问题

4405
01:54:10,000 --> 01:54:12,000
就是第一个我想问的问题是

4406
01:54:12,000 --> 01:54:15,000
作为一个软件的开发者来说

4407
01:54:15,000 --> 01:54:19,000
他多大程度上会遇到说我要去主动解决这个问题

4408
01:54:19,000 --> 01:54:23,000
Ru 你有没有遇到过要去解决这个问题

4409
01:54:23,000 --> 01:54:26,000
比较少其实因为特别是

4410
01:54:26,000 --> 01:54:30,000
特别操作系统和它的那个系统库都提供了

4411
01:54:30,000 --> 01:54:33,000
这个标准的流程给你去调用的时候

4412
01:54:33,000 --> 01:54:34,000
你肯定不要自己去搞

4413
01:54:34,000 --> 01:54:36,000
因为这样你自己去搞的话

4414
01:54:36,000 --> 01:54:37,000
有可能和系统的不兼容

4415
01:54:37,000 --> 01:54:40,000
但是你就有刚才提到那个难题

4416
01:54:40,000 --> 01:54:45,000
就是说比如说在 MacOS 这种比较特殊的系统上面

4417
01:54:45,000 --> 01:54:48,000
它有多套 API 的时候

4418
01:54:48,000 --> 01:54:50,000
你就比较尴尬了

4419
01:54:50,000 --> 01:54:54,000
因为它有 unix 那套比较底层的 API

4420
01:54:54,000 --> 01:54:57,000
和相对上 foundation API 那些比较高层的 API 的时候

4421
01:54:57,000 --> 01:54:57,000
那你怎么办

4422
01:54:57,000 --> 01:54:59,000
就这个时候你可能要把这两个的

4423
01:54:59,000 --> 01:55:06,000
就是哪些是支持什么样的这个 nominalization 的规范的

4424
01:55:06,000 --> 01:55:07,000
可能要搞清楚

4425
01:55:07,000 --> 01:55:09,000
然后具体说怎么实现

4426
01:55:09,000 --> 01:55:11,000
其实你是不用去太多考虑的

4427
01:55:11,000 --> 01:55:13,000
反正那些都是有标准函数去调用的

4428
01:55:13,000 --> 01:55:14,000
对

4429
01:55:14,000 --> 01:55:17,000
这个规范化的转换算法

4430
01:55:17,000 --> 01:55:20,000
其实已经有一些非常标准的方式

4431
01:55:20,000 --> 01:55:22,000
唯一作为开发者

4432
01:55:22,000 --> 01:55:23,000
你需要的知道的就是说

4433
01:55:23,000 --> 01:55:26,000
你知道在什么时候用什么样的 API

4434
01:55:26,000 --> 01:55:28,000
去调用什么样的结果

4435
01:55:28,000 --> 01:55:30,000
这个是比较重要的

4436
01:55:30,000 --> 01:55:33,000
所以去查文档的话

4437
01:55:33,000 --> 01:55:34,000
其实肯定也就是说

4438
01:55:34,000 --> 01:55:37,000
为了防止发生这个 nominalization 错误的话

4439
01:55:37,000 --> 01:55:40,000
就是去调用很广泛的 API

4440
01:55:40,000 --> 01:55:41,000
就完了

4441
01:55:41,000 --> 01:55:41,000
对

4442
01:55:41,000 --> 01:55:45,000
另外还有个事情跟我们今天讲了有点关系

4443
01:55:45,000 --> 01:55:48,000
是 Rio 上次提到的那个 IDN 的一个

4444
01:55:48,000 --> 01:55:51,000
一个伪装攻击的问题是吗

4445
01:55:51,000 --> 01:55:54,000
就一个网址的一个漏洞

4446
01:55:54,000 --> 01:55:56,000
就 Punicode 的那个的问题吗

4447
01:55:56,000 --> 01:56:00,000
这个是一个就也是 Unicode 的一个坑吧

4448
01:56:00,000 --> 01:56:05,000
我们可以这里作为这个节目的就是事后的环节

4449
01:56:05,000 --> 01:56:07,000
所以顺便涂个小槽

4450
01:56:07,000 --> 01:56:10,000
就是我们现在知道很多这个网站

4451
01:56:10,000 --> 01:56:12,000
它有一个叫做什么就钓鱼网站了

4452
01:56:12,000 --> 01:56:13,000
就他骗你

4453
01:56:13,000 --> 01:56:15,000
他说他是这个银行

4454
01:56:15,000 --> 01:56:17,000
你的那个银行的网站

4455
01:56:17,000 --> 01:56:19,000
然后让你输入你的这个卡号密码

4456
01:56:19,000 --> 01:56:21,000
然后让你去转你的钱嘛

4457
01:56:21,000 --> 01:56:21,000
对吧

4458
01:56:22,000 --> 01:56:23,000
但可能银行这个例子不太好

4459
01:56:23,000 --> 01:56:24,000
现在银行都有这个两部认证了

4460
01:56:24,000 --> 01:56:26,000
可能也不太那么容易去做

4461
01:56:26,000 --> 01:56:28,000
但是逻辑是这样的

4462
01:56:28,000 --> 01:56:31,000
就是那我们传统的在浏览器里面

4463
01:56:31,000 --> 01:56:32,000
去判定一个网站

4464
01:56:32,000 --> 01:56:34,000
是不是你访问的那个网站的时候

4465
01:56:34,000 --> 01:56:36,000
你是看它的那个域名吗

4466
01:56:36,000 --> 01:56:37,000
对吧

4467
01:56:37,000 --> 01:56:40,000
域名其实就是一个字符串构成的东西嘛

4468
01:56:40,000 --> 01:56:43,000
那坑就坑在于

4469
01:56:43,000 --> 01:56:46,000
因为 unicode 里面

4470
01:56:46,000 --> 01:56:46,000
也不叫

4471
01:56:46,000 --> 01:56:47,000
这也不是 unicode 坑

4472
01:56:47,000 --> 01:56:49,000
就是这个人类的问题吧

4473
01:56:49,000 --> 01:56:52,000
就是在某一些不同的语言里面

4474
01:56:52,000 --> 01:56:55,000
它的两个完全不同的字符

4475
01:56:55,000 --> 01:56:56,000
它看起来是一模一样的

4476
01:56:57,000 --> 01:57:01,000
比如说英文的第一个字母叫 A

4477
01:57:01,000 --> 01:57:02,000
对吧

4478
01:57:02,000 --> 01:57:04,000
但是希腊文的第一个字母叫 Alpha

4479
01:57:04,000 --> 01:57:07,000
但是两个大写字母长得一模一样

4480
01:57:07,000 --> 01:57:07,000
对

4481
01:57:07,000 --> 01:57:10,000
在过去不存在这个问题

4482
01:57:10,000 --> 01:57:11,000
因为在过去的话

4483
01:57:11,000 --> 01:57:14,000
那个域名器系统其实是一个非常简单的系统

4484
01:57:14,000 --> 01:57:15,000
它就只有 ASCII

4485
01:57:15,000 --> 01:57:16,000
就是它只能用

4486
01:57:16,000 --> 01:57:19,000
就是我们讲域名那个部分

4487
01:57:19,000 --> 01:57:21,000
只能用哪几个字符

4488
01:57:21,000 --> 01:57:24,000
26 个英文字母不区分大小写

4489
01:57:24,000 --> 01:57:26,000
10 个阿拉伯数字

4490
01:57:26,000 --> 01:57:28,000
然后再加一个那个短横线

4491
01:57:28,000 --> 01:57:29,000
对吧

4492
01:57:29,000 --> 01:57:32,000
然后在这个点呢肯定没得说了

4493
01:57:32,000 --> 01:57:34,000
就是 A 点 B 这个是可以知道的

4494
01:57:34,000 --> 01:57:37,000
然后后来呢

4495
01:57:37,000 --> 01:57:40,000
为了支持所谓的多语言的这个域名嘛

4496
01:57:40,000 --> 01:57:43,000
我们中国之前搞过

4497
01:57:43,000 --> 01:57:44,000
CNSA 搞过所谓的中文域名

4498
01:57:44,000 --> 01:57:45,000
对不对

4499
01:57:45,000 --> 01:57:46,000
就是什么点

4500
01:57:46,000 --> 01:57:47,000
汉字域名

4501
01:57:47,000 --> 01:57:47,000
对汉字域名

4502
01:57:47,000 --> 01:57:48,000
什么什么点中国

4503
01:57:48,000 --> 01:57:49,000
很傻的

4504
01:57:49,000 --> 01:57:53,000
之前应该是 90 年代末的时候

4505
01:57:53,000 --> 01:57:54,000
有流行过这些年代之后

4506
01:57:54,000 --> 01:57:56,000
就是谢天谢地终于没有流行起来

4507
01:57:56,000 --> 01:57:58,000
对吧

4508
01:57:58,000 --> 01:58:00,000
然后刚才讲的那个希腊文的那个 A

4509
01:58:00,000 --> 01:58:01,000
和英文那个 A 就有问题

4510
01:58:01,000 --> 01:58:02,000
比如说你都想访问

4511
01:58:02,000 --> 01:58:03,000
Apple.com

4512
01:58:03,000 --> 01:58:05,000
就苹果的官网对吧

4513
01:58:05,000 --> 01:58:06,000
那你看的是 Apple.com

4514
01:58:06,000 --> 01:58:08,000
但其实人家把那个 A 给换成的那个

4515
01:58:08,000 --> 01:58:10,000
希腊语的那个 A

4516
01:58:10,000 --> 01:58:11,000
你看起来也是 Apple.com

4517
01:58:11,000 --> 01:58:13,000
但是你访问的是一个完全不同的网站

4518
01:58:13,000 --> 01:58:14,000
这个时候

4519
01:58:14,000 --> 01:58:17,000
这个假的这个 Apple.com

4520
01:58:17,000 --> 01:58:18,000
这个网站让你输入

4521
01:58:18,000 --> 01:58:21,000
你的这个 iCloud 的这个账号密码

4522
01:58:21,000 --> 01:58:21,000
你输不输呢

4523
01:58:21,000 --> 01:58:25,000
对吧

4524
01:58:25,000 --> 01:58:29,000
所以我觉得就是在域名这个

4525
01:58:29,000 --> 01:58:33,000
这个比较关乎安全的这种领域里面

4526
01:58:33,000 --> 01:58:37,000
我其实挺反对去加入这种多语言支持的

4527
01:58:37,000 --> 01:58:38,000
虽然说听起来政治不正确

4528
01:58:38,000 --> 01:58:41,000
凭什么域名一定要是一个英文的一个东西

4529
01:58:41,000 --> 01:58:42,000
或者说就是对吧

4530
01:58:42,000 --> 01:58:43,000
或者说

4531
01:58:43,000 --> 01:58:46,000
其实也就拉低文的东西

4532
01:58:46,000 --> 01:58:48,000
为什么韩国人不能用韩语做域名

4533
01:58:48,000 --> 01:58:50,000
中国人不能用中文做域名

4534
01:58:50,000 --> 01:58:51,000
日本人不能用日语做域名呢

4535
01:58:51,000 --> 01:58:56,000
但是你用了之后就会出现这种不可知的结果

4536
01:58:56,000 --> 01:58:57,000
这个时候就比较尴尬了

4537
01:58:57,000 --> 01:59:02,000
另外我还有个问题

4538
01:59:02,000 --> 01:59:06,000
其实就是如果我们输入两个在这个

4539
01:59:06,000 --> 01:59:11,000
标准化之后是相等的 Unical 的字符串

4540
01:59:11,000 --> 01:59:13,000
那么浏览器会认为他们是同一个域名吗

4541
01:59:13,000 --> 01:59:17,000
但是他们实际上是不一样的

4542
01:59:17,000 --> 01:59:21,000
这里面好像那个域名有一个

4543
01:59:21,000 --> 01:59:22,000
Punicode 它是有一个规范的

4544
01:59:22,000 --> 01:59:25,000
但是这里要扯一个很坑爹的事情

4545
01:59:25,000 --> 01:59:28,000
Punicode 规范是找 Unical 的

4546
01:59:28,000 --> 01:59:30,000
是的

4547
01:59:30,000 --> 01:59:33,000
最后有一个转换的问题

4548
01:59:33,000 --> 01:59:35,000
对所以比如说我们刚才

4549
01:59:35,000 --> 01:59:37,000
我们刚才说比如说有一些字母

4550
01:59:37,000 --> 01:59:38,000
比如说像 Omega

4551
01:59:38,000 --> 01:59:40,000
它就是两个完全一模一样的字符

4552
01:59:40,000 --> 01:59:42,000
在形式上

4553
01:59:42,000 --> 01:59:44,000
在这个语意的来源上也是一样

4554
01:59:44,000 --> 01:59:47,000
但它就是分裂成两个字符了

4555
01:59:47,000 --> 01:59:49,000
一个是用来表示这个物理单位的

4556
01:59:49,000 --> 01:59:50,000
一个是 Omega 这个字符本身

4557
01:59:50,000 --> 01:59:53,000
对这个我没有去查过

4558
01:59:53,000 --> 01:59:55,000
但是照我的理解

4559
01:59:55,000 --> 01:59:58,000
应该是要先做那个 Unical 的规范化

4560
01:59:58,000 --> 01:59:59,000
然后再转成那个 Punicode

4561
01:59:59,000 --> 02:00:02,000
才能拿到一个最终的一个结果

4562
02:00:02,000 --> 02:00:05,000
这个时候应该是一个唯一的一个解

4563
02:00:05,000 --> 02:00:07,000
所以他们其实应该是一样的

4564
02:00:07,000 --> 02:00:09,000
我的理解应该是一样的

4565
02:00:09,000 --> 02:00:11,000
不然的话就出现刚才我说的另外一个问题

4566
02:00:11,000 --> 02:00:14,000
就是你看见的两个完全一模一样的

4567
02:00:14,000 --> 02:00:17,000
而且你用 Unical 的看都是一模一样的

4568
02:00:17,000 --> 02:00:19,000
或者 Unical 都是等价的两个域名

4569
02:00:19,000 --> 02:00:20,000
但是它其实反而是两个不同的网站

4570
02:00:20,000 --> 02:00:21,000
这个时候你就

4571
02:00:21,000 --> 02:00:23,000
你就非常坑爹了对不对

4572
02:00:23,000 --> 02:00:25,000
当然呢

4573
02:00:25,000 --> 02:00:27,000
这个事情可能

4574
02:00:27,000 --> 02:00:30,000
可能也会越来越不是一个事了吧

4575
02:00:30,000 --> 02:00:32,000
就是其实我们现在看很多

4576
02:00:32,000 --> 02:00:33,000
这个移动网站上

4577
02:00:33,000 --> 02:00:34,000
你根本就不知道那个网址是什么了

4578
02:00:34,000 --> 02:00:34,000
对不对

4579
02:00:34,000 --> 02:00:35,000
比如说你在这个

4580
02:00:35,000 --> 02:00:37,000
微信的流浪器里面打开一个网站

4581
02:00:37,000 --> 02:00:40,000
你都看不见那个 UIL 了

4582
02:00:40,000 --> 02:00:41,000
对

4583
02:00:41,000 --> 02:00:44,000
所以最终你可能还是得靠一些证书之类的东西

4584
02:00:44,000 --> 02:00:46,000
就其他的一些工具来验证这个网站

4585
02:00:46,000 --> 02:00:48,000
是不是你想要发现

4586
02:00:48,000 --> 02:00:48,000
对啊

4587
02:00:48,000 --> 02:00:48,000
对啊

4588
02:00:48,000 --> 02:00:49,000
对啊

4589
02:00:49,000 --> 02:00:50,000
对啊

4590
02:00:50,000 --> 02:00:51,000
但你会

4591
02:00:51,000 --> 02:00:54,000
你认一个人总是不能看名字呀

4592
02:00:54,000 --> 02:00:58,000
这也就会变得另外一个很好玩的事情

4593
02:00:58,000 --> 02:00:59,000
这个跟 Emoji 有关了

4594
02:00:59,000 --> 02:01:03,000
就是之前前几天在那个推特上转发的一个事情

4595
02:01:03,000 --> 02:01:05,000
就是现在那个浏览器

4596
02:01:05,000 --> 02:01:08,000
它不是前面靠那个地址的左边

4597
02:01:08,000 --> 02:01:10,000
有一个那个小锁的那个图标来表示

4598
02:01:10,000 --> 02:01:11,000
这是一个加密连接吗

4599
02:01:11,000 --> 02:01:13,000
对啊

4600
02:01:13,000 --> 02:01:15,000
然后觉得你常常觉得很安全吗

4601
02:01:15,000 --> 02:01:18,000
然后你知道那个 Emoji 里面是有一个锁的图标的吗

4602
02:01:18,000 --> 02:01:21,000
然后

4603
02:01:21,000 --> 02:01:21,000
然后

4604
02:01:21,000 --> 02:01:22,000
然后那个

4605
02:01:22,000 --> 02:01:23,000
有些那个

4606
02:01:23,000 --> 02:01:25,000
有些那个域名的那个

4607
02:01:25,000 --> 02:01:27,000
有些顶级域名是支持 Emoji 域名的

4608
02:01:27,000 --> 02:01:29,000
就刚刚我们讲 Unical 的

4609
02:01:29,000 --> 02:01:30,000
Punicode 的域名之外

4610
02:01:30,000 --> 02:01:32,000
它还支持 Emoji 的域名

4611
02:01:32,000 --> 02:01:33,000
这个时候有人就说

4612
02:01:33,000 --> 02:01:33,000
所以它自己画了一个

4613
02:01:33,000 --> 02:01:35,000
它做了一个

4614
02:01:35,000 --> 02:01:36,000
它的那个域名的第一个就是一个锁

4615
02:01:36,000 --> 02:01:37,000
你知道

4616
02:01:37,000 --> 02:01:38,000
然后后面假设

4617
02:01:38,000 --> 02:01:40,000
假设它是一个锁

4618
02:01:40,000 --> 02:01:40,000
然后

4619
02:01:40,000 --> 02:01:42,000
然后然后 https

4620
02:01:42,000 --> 02:01:44,000
然后再两点写杠写杠

4621
02:01:44,000 --> 02:01:46,000
然后是那个希腊字母的

4622
02:01:46,000 --> 02:01:49,000
appl.com

4623
02:01:49,000 --> 02:01:51,000
这个时候你敢不敢把网站

4624
02:01:51,000 --> 02:01:55,000
对吧

4625
02:01:55,000 --> 02:01:56,000
所以所以我觉得就是

4626
02:01:56,000 --> 02:01:57,000
就是

4627
02:01:57,000 --> 02:01:59,000
这怎么

4628
02:01:59,000 --> 02:02:01,000
这可能有点不太正确

4629
02:02:01,000 --> 02:02:02,000
但是我觉得这个事情是

4630
02:02:02,000 --> 02:02:04,000
是是有得有的有所

4631
02:02:04,000 --> 02:02:06,000
有些事情你是不能做的

4632
02:02:06,000 --> 02:02:07,000
这样我说

4633
02:02:07,000 --> 02:02:09,000
你不能在域名里面去加 Emoji

4634
02:02:09,000 --> 02:02:11,000
你不能在域名里面去加这个 Unical 的东西

4635
02:02:11,000 --> 02:02:14,000
这真的会把事情搞得无比复杂

4636
02:02:14,000 --> 02:02:16,000
就是本来大家只用考虑

4637
02:02:16,000 --> 02:02:17,000
大家刚才讲 26 个字母

4638
02:02:17,000 --> 02:02:19,000
加 10 个数字

4639
02:02:19,000 --> 02:02:20,000
再加一个横线

4640
02:02:20,000 --> 02:02:21,000
前才多少

4641
02:02:21,000 --> 02:02:22,000
才 37 个对吧

4642
02:02:22,000 --> 02:02:23,000
的一个一个

4643
02:02:23,000 --> 02:02:24,000
这个一个

4644
02:02:24,000 --> 02:02:24,000
这个一个

4645
02:02:24,000 --> 02:02:26,000
这个 space 的一个问题

4646
02:02:26,000 --> 02:02:29,000
现在突然你变成一个整个 unicode 的那个 space 都在那里

4647
02:02:29,000 --> 02:02:31,000
那是多少倍的一个

4648
02:02:31,000 --> 02:02:32,000
复杂度的扩张

4649
02:02:32,000 --> 02:02:34,000
对于用户的认知理解来说

4650
02:02:34,000 --> 02:02:35,000
你是没有办法去做这个教育的

4651
02:02:35,000 --> 02:02:36,000
嗯

4652
02:02:36,000 --> 02:02:38,000
所以你看

4653
02:02:38,000 --> 02:02:39,000
中国用户

4654
02:02:39,000 --> 02:02:40,000
大家还是比较乖的

4655
02:02:40,000 --> 02:02:42,000
大家刚才都用数字语名

4656
02:02:42,000 --> 02:02:43,000
就不会出现这种情况了

4657
02:02:43,000 --> 02:02:44,000
对吧

4658
02:02:44,000 --> 02:02:44,000
嗯

4659
02:02:44,000 --> 02:02:47,000
163.0

4660
02:02:47,000 --> 02:02:49,000
数字应该不会有这个

4661
02:02:49,000 --> 02:02:50,000
长得一样的数字

4662
02:02:50,000 --> 02:02:51,000
但是不一样的点位吧

4663
02:02:51,000 --> 02:02:54,000
有

4664
02:02:54,000 --> 02:02:55,000
也有吗

4665
02:02:55,000 --> 02:02:59,000
数字的 normalization 不是很多吗

4666
02:02:59,000 --> 02:03:00,000
天哪

4667
02:03:00,000 --> 02:03:03,000
对有那个什么半高的这种数字

4668
02:03:03,000 --> 02:03:04,000
对不对

4669
02:03:04,000 --> 02:03:06,000
还有那个叫什么来的

4670
02:03:06,000 --> 02:03:06,000
那个

4671
02:03:06,000 --> 02:03:08,000
另外罗马数

4672
02:03:08,000 --> 02:03:10,000
那是罗马数字吗

4673
02:03:10,000 --> 02:03:12,000
就是罗马数字也是有罗马数字自己的码位

4674
02:03:12,000 --> 02:03:13,000
也可以

4675
02:03:13,000 --> 02:03:16,000
对但我们一般都是用拉丁字母来写

4676
02:03:16,000 --> 02:03:18,000
他们就用什么 IV 啊之类的字母

4677
02:03:18,000 --> 02:03:19,000
对所以我就觉得嘛

4678
02:03:19,000 --> 02:03:22,000
就是有些事情其实是都是一些政治的因素

4679
02:03:22,000 --> 02:03:25,000
让我们把这个事情变得非常复杂

4680
02:03:25,000 --> 02:03:27,000
本来技术是可以做的非常简单可靠稳定的

4681
02:03:27,000 --> 02:03:28,000
嗯

4682
02:03:28,000 --> 02:03:30,000
但是一会过来一个 PM

4683
02:03:30,000 --> 02:03:32,000
那会过来一个 PM 都在提这个需求

4684
02:03:32,000 --> 02:03:34,000
这个时候你就爆炸了

4685
02:03:34,000 --> 02:03:35,000
对

4686
02:03:35,000 --> 02:03:37,000
其实说到这个 URL

4687
02:03:37,000 --> 02:03:38,000
我想起来就是

4688
02:03:38,000 --> 02:03:42,000
其实 W 3 C 也是有一趟自己的这个 normalization 的机制的

4689
02:03:42,000 --> 02:03:44,000
对

4690
02:03:44,000 --> 02:03:48,000
对就是当然它其实是基于 unicode 的

4691
02:03:48,000 --> 02:03:53,000
就是它当然它首先推荐的是 NFC 的这种标准化的形式

4692
02:03:53,000 --> 02:03:54,000
规范化的形式

4693
02:03:54,000 --> 02:03:57,000
那么同时我们知道因为 W 3 C 在网页上

4694
02:03:57,000 --> 02:04:01,000
它其实有一个特殊的字符串形式叫 character reference

4695
02:04:01,000 --> 02:04:05,000
就是一个这个 Epson 的和锦号键开头的

4696
02:04:05,000 --> 02:04:07,000
然后后面加一个数字的事列

4697
02:04:07,000 --> 02:04:09,000
然后加一个加一个分号

4698
02:04:09,000 --> 02:04:12,000
这样一个可以用来引用

4699
02:04:12,000 --> 02:04:15,000
引用到任何一个 unicode 的字符上的这样一个系列

4700
02:04:15,000 --> 02:04:17,000
那么这个系列如果你在网页上

4701
02:04:17,000 --> 02:04:19,000
在 html 里面输入的话

4702
02:04:19,000 --> 02:04:25,000
它其实要被这个 noblized 成为另外一个真正的实意的字符的

4703
02:04:25,000 --> 02:04:27,000
而不是直接保留这个东西

4704
02:04:27,000 --> 02:04:31,000
那么这个就其实是在 unicode 的基础上

4705
02:04:31,000 --> 02:04:33,000
扩展了一下

4706
02:04:33,000 --> 02:04:33,000
应该说

4707
02:04:33,000 --> 02:04:35,000
那不就是那个 punicode 吗

4708
02:04:35,000 --> 02:04:39,000
可以这么说吧

4709
02:04:39,000 --> 02:04:41,000
可以就机制是类似的

4710
02:04:41,000 --> 02:04:41,000
可能是

4711
02:04:41,000 --> 02:04:43,000
但他们的表达形式不太一样

4712
02:04:43,000 --> 02:04:49,000
就是一个挺沉重的事情

4713
02:04:49,000 --> 02:04:49,000
我觉得

4714
02:04:49,000 --> 02:04:51,000
反正我在我的那个理解里面

4715
02:04:51,000 --> 02:04:52,000
我是不介意

4716
02:04:52,000 --> 02:04:54,000
就是我是反对吧

4717
02:04:54,000 --> 02:04:55,000
把一些

4718
02:04:55,000 --> 02:04:58,000
就是其实你说一定有那么强的必要

4719
02:04:58,000 --> 02:05:00,000
要用一个中文或者日文的语名吗

4720
02:05:00,000 --> 02:05:01,000
其实也没有

4721
02:05:01,000 --> 02:05:01,000
对不对

4722
02:05:01,000 --> 02:05:02,000
大家不也过得很好

4723
02:05:02,000 --> 02:05:05,000
就为什么要认为把这个事情搞那么复杂

4724
02:05:05,000 --> 02:05:10,000
就是太多的 downside

4725
02:05:10,000 --> 02:05:12,000
没有很好的这个 upside

4726
02:05:12,000 --> 02:05:16,000
但是对于这个网页来说

4727
02:05:16,000 --> 02:05:18,000
其实它有这些需求了

4728
02:05:18,000 --> 02:05:20,000
比如你输入一些不可见字符的时候

4729
02:05:20,000 --> 02:05:21,000
你在 html 里面

4730
02:05:21,000 --> 02:05:23,000
你可能输入这个 character reference

4731
02:05:23,000 --> 02:05:25,000
就变成可见了

4732
02:05:25,000 --> 02:05:26,000
那么对于程序来说

4733
02:05:26,000 --> 02:05:28,000
这个是比较友好的一种形式

4734
02:05:28,000 --> 02:05:29,000
不 我就是说

4735
02:05:29,000 --> 02:05:31,000
你不要在网页里面做这个

4736
02:05:31,000 --> 02:05:34,000
不要在那个域名和网址里面做这个事情

4737
02:05:34,000 --> 02:05:34,000
对对对

4738
02:05:34,000 --> 02:05:36,000
在域名里面做的话

4739
02:05:36,000 --> 02:05:37,000
就是要得有所节制

4740
02:05:37,000 --> 02:05:38,000
你知道吗

4741
02:05:38,000 --> 02:05:39,000
就是现在很多

4742
02:05:39,000 --> 02:05:40,000
很多这个

4743
02:05:40,000 --> 02:05:41,000
忍不住啊

4744
02:05:41,000 --> 02:05:42,000
对

4745
02:05:42,000 --> 02:05:44,000
技术产品之所以如此复杂

4746
02:05:44,000 --> 02:05:46,000
就是因为上面提需求的人

4747
02:05:46,000 --> 02:05:46,000
就是

4748
02:05:46,000 --> 02:05:48,000
对吧

4749
02:05:48,000 --> 02:05:51,000
不考虑后果

4750
02:05:51,000 --> 02:05:54,000
好吧

4751
02:05:54,000 --> 02:05:57,000
那今天我们就聊到这里

4752
02:05:57,000 --> 02:05:58,000
对

4753
02:05:58,000 --> 02:06:03,000
对了

4754
02:06:03,000 --> 02:06:05,000
我们这次要抽

4755
02:06:05,000 --> 02:06:07,000
我们这次就不抽奖了是吧

4756
02:06:07,000 --> 02:06:08,000
对对对

4757
02:06:08,000 --> 02:06:11,000
但是我们其实上一次抽奖的结果已经出来了

4758
02:06:11,000 --> 02:06:13,000
但是有一位听众联系不到

4759
02:06:13,000 --> 02:06:15,000
所以其实那个

4760
02:06:15,000 --> 02:06:18,000
我们可以借这次节目先做一个这个通知吧

4761
02:06:18,000 --> 02:06:20,000
那你说吧

4762
02:06:20,000 --> 02:06:21,000
对就是之前呢

4763
02:06:21,000 --> 02:06:23,000
那个我们在第十

4764
02:06:23,000 --> 02:06:25,000
就上一期应该是第五十一期吧

4765
02:06:25,000 --> 02:06:27,000
我们公布了一个抽奖的通知

4766
02:06:27,000 --> 02:06:28,000
然后呢

4767
02:06:28,000 --> 02:06:30,000
接下来了一周之后呢

4768
02:06:30,000 --> 02:06:32,000
我们这个抽奖的结果其实已经出来了

4769
02:06:32,000 --> 02:06:34,000
那么我们这次抽到的两位听众呢

4770
02:06:34,000 --> 02:06:36,000
都是来自支付宝捐赠的听众

4771
02:06:36,000 --> 02:06:38,000
第一位听众他的署名是灰

4772
02:06:38,000 --> 02:06:40,000
一个灰黄的灰这个单字

4773
02:06:40,000 --> 02:06:42,000
第二位听众署名是 friend

4774
02:06:42,000 --> 02:06:44,000
那第二位听众呢

4775
02:06:44,000 --> 02:06:45,000
我已经联系上他了

4776
02:06:45,000 --> 02:06:46,000
那么他应该也已经收到了我们的奖品

4777
02:06:46,000 --> 02:06:47,000
但是第一位听众

4778
02:06:47,000 --> 02:06:49,000
我没法联系到他

4779
02:06:49,000 --> 02:06:50,000
所以如果你听到这次节目呢

4780
02:06:50,000 --> 02:06:52,000
也可以直接给我们发邮件

4781
02:06:52,000 --> 02:06:54,000
发到 podcastatthetribe.com

4782
02:06:54,000 --> 02:06:55,000
来跟我们联络

4783
02:06:55,000 --> 02:06:57,000
然后我们会跟你进一步沟通

4784
02:06:57,000 --> 02:07:00,000
然后把奖品发给你

4785
02:07:00,000 --> 02:07:02,000
好

4786
02:07:02,000 --> 02:07:03,000
感谢大家的捐赠

4787
02:07:03,000 --> 02:07:05,000
那别忘记了和我们的联系的方法呢

4788
02:07:05,000 --> 02:07:08,000
是 podcastatthetribe.com

4789
02:07:08,000 --> 02:07:11,000
有捐赠也就有机会参加我们的抽奖

4790
02:07:11,000 --> 02:07:13,000
我也今天啊

4791
02:07:13,000 --> 02:07:15,000
我给大家准备了新的礼物

4792
02:07:15,000 --> 02:07:16,000
那等我们下次再说吧

4793
02:07:16,000 --> 02:07:17,000
好吧

4794
02:07:17,000 --> 02:07:18,000
好

4795
02:07:18,000 --> 02:07:20,000
那感谢大家收听今天的节目

4796
02:07:20,000 --> 02:07:23,000
如果大家喜欢我们的节目的话

4797
02:07:23,000 --> 02:07:24,000
喜欢自谈自唱的话

4798
02:07:24,000 --> 02:07:25,000
就可以给我们捐赠

4799
02:07:25,000 --> 02:07:26,000
我们的捐赠渠道呢

4800
02:07:26,000 --> 02:07:28,000
跟我们的邮箱地址是一样的

4801
02:07:28,000 --> 02:07:30,000
都是 podcastatthetribe.com

4802
02:07:30,000 --> 02:07:35,000
podcastatthetype.com

4803
02:07:35,000 --> 02:07:35,000
同时呢

4804
02:07:35,000 --> 02:07:37,000
大家也可以在社交网站上

4805
02:07:37,000 --> 02:07:38,000
关注我们

4806
02:07:38,000 --> 02:07:39,000
在新浪微博

4807
02:07:39,000 --> 02:07:39,000
在 twitter

4808
02:07:39,000 --> 02:07:42,000
在微信上面

4809
02:07:42,000 --> 02:07:44,000
我们的 ID 都是 thetype

4810
02:07:44,000 --> 02:07:46,000
thetype

4811
02:07:46,000 --> 02:07:47,000
那么在 Facebook 上

4812
02:07:47,000 --> 02:07:49,000
搜索 typeisbeautiful

4813
02:07:49,000 --> 02:07:50,000
也可以关注到我们

4814
02:07:50,000 --> 02:07:50,000
同时呢

4815
02:07:50,000 --> 02:07:51,000
我们在知乎专栏上

4816
02:07:51,000 --> 02:07:53,000
也会同步地发布

4817
02:07:53,000 --> 02:07:56,000
每一期节目的这个节目简介

4818
02:07:56,000 --> 02:07:57,000
同时呢

4819
02:07:57,000 --> 02:07:58,000
也欢迎大家关注

4820
02:07:58,000 --> 02:08:00,000
typeisbeautiful 的网站

4821
02:08:00,000 --> 02:08:01,000
typebeautiful.com

4822
02:08:01,000 --> 02:08:04,000
感谢收听

4823
02:08:04,000 --> 02:08:05,000
IPM Podcast

4824
02:08:05,000 --> 02:08:08,000
网络旗下的 IT 技术主题娱乐节目

4825
02:08:08,000 --> 02:08:08,000
内核恐慌

4826
02:08:08,000 --> 02:08:10,000
我们号称 hardcore

4827
02:08:10,000 --> 02:08:10,000
但是也没有干货

4828
02:08:10,000 --> 02:08:11,000
想听人听

4829
02:08:11,000 --> 02:08:12,000
想听人就别听

4830
02:08:12,000 --> 02:08:14,000
您可以为本节目捐款

4831
02:08:14,000 --> 02:08:15,000
地址是

4832
02:08:15,000 --> 02:08:16,000
cernalpanic.fm

4833
02:08:16,000 --> 02:08:17,000
slash donate

4834
02:08:17,000 --> 02:08:17,000
捐款机会

4835
02:08:17,000 --> 02:08:18,000
所以只要是

4836
02:08:18,000 --> 02:08:19,000
8 的正式入背就可以了

4837
02:08:19,000 --> 02:08:21,000
捐款不会给你带来什么

4838
02:08:21,000 --> 02:08:23,000
不捐也不会让你失去什么

4839
02:08:23,000 --> 02:08:23,000
我们的口号是

4840
02:08:23,000 --> 02:08:25,000
no hard feelings

4841
02:08:25,000 --> 02:08:26,000
如果你有任何反馈

4842
02:08:26,000 --> 02:08:29,000
可以发电子邮件到

4843
02:08:29,000 --> 02:08:32,000
cernalpanic.ipm.li

4844
02:08:32,000 --> 02:08:34,000
同时也欢迎你收听

4845
02:08:34,000 --> 02:08:35,000
real 主持的

4846
02:08:35,000 --> 02:08:35,000
风头圈

4847
02:08:35,000 --> 02:08:37,000
风头圈现在好像改成收费节目

4848
02:08:38,000 --> 02:08:39,000
对

4849
02:08:39,000 --> 02:08:40,000
ok

4850
02:08:40,000 --> 02:08:41,000
我还加了会员呢

4851
02:08:41,000 --> 02:08:43,000
其他几档节目

4852
02:08:43,000 --> 02:08:44,000
未知到

4853
02:08:44,000 --> 02:08:45,000
太一来了

4854
02:08:45,000 --> 02:08:45,000
流行通信

4855
02:08:45,000 --> 02:08:46,000
high story

4856
02:08:46,000 --> 02:08:47,000
映影像

4857
02:08:47,000 --> 02:08:47,000
无资源

4858
02:08:47,000 --> 02:08:48,000
博物质

4859
02:08:48,000 --> 02:08:48,000
选美

4860
02:08:48,000 --> 02:08:49,000
陛下观

4861
02:08:49,000 --> 02:08:49,000
一天世界

4862
02:08:49,000 --> 02:08:50,000
时尚怪物

4863
02:08:50,000 --> 02:08:51,000
我们下期节目再会

4864
02:08:51,000 --> 02:08:52,000
ok

4865
02:08:52,000 --> 02:08:52,000
拜拜

4866
02:08:52,000 --> 02:08:53,000
拜拜

4867
02:08:53,000 --> 02:08:54,000
拜拜

4868
02:08:54,000 --> 02:08:54,000
拜拜

