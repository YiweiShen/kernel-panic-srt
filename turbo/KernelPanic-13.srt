1
00:00:00,000 --> 00:00:04,000
北美山地时间 2006 年 1 月 2 日下午 3 点 04 分 05 秒

2
00:00:04,000 --> 00:00:08,000
您正在收听 IPN Podcast 网络旗下的 IT 技术主义节目

3
00:00:08,000 --> 00:00:08,000
内核恐慌

4
00:00:08,000 --> 00:00:10,000
我们号称 Hardcore 啊

5
00:00:10,000 --> 00:00:11,000
但也没有干货

6
00:00:11,000 --> 00:00:12,000
想听的人听

7
00:00:12,000 --> 00:00:13,000
不想听的人就别听

8
00:00:13,000 --> 00:00:16,000
内核恐慌的网址是 ipn.li

9
00:00:16,000 --> 00:00:17,000
slashkernelpanic

10
00:00:17,000 --> 00:00:21,000
我们推荐大家使用 Podcast 客户端订阅我们的节目

11
00:00:21,000 --> 00:00:23,000
如果您不知道该用什么客户端

12
00:00:23,000 --> 00:00:24,000
请法文 ipn.li

13
00:00:24,000 --> 00:00:26,000
slashfaq

14
00:00:26,000 --> 00:00:27,000
在录音过程中

15
00:00:27,000 --> 00:00:29,000
您可以拨通热心电话参与我们的节目

16
00:00:29,000 --> 00:00:30,000
电话码是

17
00:00:30,000 --> 00:00:35,000
电话码是

18
00:00:35,000 --> 00:00:37,000
算了吧

19
00:00:37,000 --> 00:00:41,000
02189998819991197253

20
00:00:41,000 --> 00:00:43,000
我觉得 Lars 其实把那个

21
00:00:43,000 --> 00:00:46,000
其实把那个节目里面

22
00:00:46,000 --> 00:00:48,000
就是 IT crowd 里面

23
00:00:48,000 --> 00:00:50,000
唱的音在这边唱起来

24
00:00:50,000 --> 00:00:51,000
好吧

25
00:00:51,000 --> 00:00:53,000
anyway

26
00:00:53,000 --> 00:00:55,000
如果你非常喜欢我们的节目

27
00:00:55,000 --> 00:00:58,000
或者说不管你是否喜欢我们的节目

28
00:00:58,000 --> 00:00:59,000
你都可以为我们捐款

29
00:00:59,000 --> 00:01:01,000
捐款地址是 ipn.li

30
00:01:01,000 --> 00:01:03,000
slashkernelpanic

31
00:01:03,000 --> 00:01:04,000
slashdonate

32
00:01:04,000 --> 00:01:05,000
D-O-N-A-T

33
00:01:05,000 --> 00:01:07,000
捐款的金额随意

34
00:01:07,000 --> 00:01:10,000
但是必须是可以被八整出的正整数

35
00:01:10,000 --> 00:01:12,000
OK

36
00:01:12,000 --> 00:01:14,000
等一下那个地址你用的是 IPN 那个吗

37
00:01:14,000 --> 00:01:15,000
你又可以用 kernelpanic

38
00:01:15,000 --> 00:01:17,000
那个.fm 那个地址

39
00:01:17,000 --> 00:01:17,000
OK

40
00:01:17,000 --> 00:01:21,000
我们有了新的域名是 kernelpanic.fm

41
00:01:21,000 --> 00:01:23,000
所以捐款地址也可以是

42
00:01:23,000 --> 00:01:23,000
对

43
00:01:23,000 --> 00:01:25,000
这不便宜啊

44
00:01:25,000 --> 00:01:27,000
不贵的这个域名

45
00:01:27,000 --> 00:01:28,000
对

46
00:01:28,000 --> 00:01:29,000
因此我们更需要大家捐款

47
00:01:29,000 --> 00:01:29,000
要那

48
00:01:29,000 --> 00:01:32,000
贵求大家捐款

49
00:01:32,000 --> 00:01:34,000
最低八块上不封顶

50
00:01:34,000 --> 00:01:34,000
对

51
00:01:34,000 --> 00:01:36,000
捐款地址是 ipn.li

52
00:01:36,000 --> 00:01:37,000
sorry

53
00:01:37,000 --> 00:01:39,000
kernelpanic.fm

54
00:01:39,000 --> 00:01:40,000
slashdonate

55
00:01:40,000 --> 00:01:41,000
D-O-N-A-T

56
00:01:41,000 --> 00:01:45,000
今天我们是我们的第多少金

57
00:01:45,000 --> 00:01:46,000
13

58
00:01:46,000 --> 00:01:47,000
13

59
00:01:47,000 --> 00:01:50,000
0 X 0 C

60
00:01:50,000 --> 00:01:53,000
Wait a second

61
00:01:53,000 --> 00:01:54,000
0 X 0 D

62
00:01:54,000 --> 00:01:58,000
10 是 A 对吧

63
00:01:58,000 --> 00:01:59,000
11 是 B

64
00:01:59,000 --> 00:01:59,000
对

65
00:01:59,000 --> 00:02:02,000
所以是 0 X 0 D

66
00:02:02,000 --> 00:02:04,000
13 这个数字不是非常的

67
00:02:04,000 --> 00:02:07,000
吉利吗

68
00:02:07,000 --> 00:02:08,000
那好像也

69
00:02:08,000 --> 00:02:09,000
我也不知道

70
00:02:09,000 --> 00:02:10,000
在欧洲某些国家

71
00:02:10,000 --> 00:02:13,000
13 好像是个蛮吉利的数字

72
00:02:13,000 --> 00:02:13,000
那我

73
00:02:13,000 --> 00:02:16,000
因为我们这边没有 13 层那么高的楼

74
00:02:16,000 --> 00:02:16,000
所以我不知道

75
00:02:16,000 --> 00:02:18,000
没有办法验证

76
00:02:18,000 --> 00:02:22,000
大农村

77
00:02:22,000 --> 00:02:23,000
大农村

78
00:02:23,000 --> 00:02:25,000
你知道加拿大的意思吗

79
00:02:25,000 --> 00:02:26,000
Canada

80
00:02:26,000 --> 00:02:28,000
Canada

81
00:02:28,000 --> 00:02:31,000
是当地人的语言吗

82
00:02:31,000 --> 00:02:32,000
就是什么爱丝

83
00:02:32,000 --> 00:02:33,000
不是就是这种什么

84
00:02:33,000 --> 00:02:34,000
就是英纽特人

85
00:02:34,000 --> 00:02:36,000
还是什么人的语言里面

86
00:02:36,000 --> 00:02:37,000
就是 Big Village

87
00:02:37,000 --> 00:02:38,000
大农村的意思

88
00:02:38,000 --> 00:02:39,000
OK

89
00:02:39,000 --> 00:02:41,000
到底贴切

90
00:02:41,000 --> 00:02:46,000
黑的好

91
00:02:46,000 --> 00:02:48,000
对

92
00:02:48,000 --> 00:02:49,000
我们上一期请到了沐瑶

93
00:02:49,000 --> 00:02:50,000
里面

94
00:02:50,000 --> 00:02:52,000
我们上一期请到沐瑶

95
00:02:52,000 --> 00:02:53,000
那期节目里面

96
00:02:53,000 --> 00:02:54,000
我们反复提到了

97
00:02:54,000 --> 00:02:55,000
我反复提到了

98
00:02:55,000 --> 00:02:56,000
How I Met a Mother

99
00:02:56,000 --> 00:02:56,000
里面

100
00:02:56,000 --> 00:02:57,000
然后里面另外一个

101
00:02:57,000 --> 00:02:58,000
除了纽泽西

102
00:02:58,000 --> 00:03:00,000
他们也许很喜欢黑的

103
00:03:00,000 --> 00:03:01,000
另一个地方

104
00:03:01,000 --> 00:03:01,000
就是加拿大

105
00:03:01,000 --> 00:03:05,000
不是还有那个地方吗

106
00:03:05,000 --> 00:03:05,000
那个叫

107
00:03:05,000 --> 00:03:06,000
Penny

108
00:03:06,000 --> 00:03:07,000
你来的那个叫什么

109
00:03:07,000 --> 00:03:09,000
Penny

110
00:03:09,000 --> 00:03:11,000
那个 Big Bang Theory 里面

111
00:03:11,000 --> 00:03:11,000
Penny

112
00:03:11,000 --> 00:03:13,000
老家哪个地方来的

113
00:03:13,000 --> 00:03:13,000
我不知道

114
00:03:13,000 --> 00:03:16,000
那个州叫

115
00:03:16,000 --> 00:03:18,000
查一下

116
00:03:18,000 --> 00:03:19,000
Penny

117
00:03:19,000 --> 00:03:20,000
Penny

118
00:03:20,000 --> 00:03:20,000
从

119
00:03:20,000 --> 00:03:25,000
这个所以应该

120
00:03:25,000 --> 00:03:26,000
我们在 Siri

121
00:03:26,000 --> 00:03:26,000
对不对

122
00:03:26,000 --> 00:03:29,000
Penny

123
00:03:29,000 --> 00:03:39,000
Nebraska

124
00:03:39,000 --> 00:03:41,000
OK

125
00:03:41,000 --> 00:03:42,000
No I'm from Omaha

126
00:03:42,000 --> 00:03:44,000
The Walking Dead 里面

127
00:03:44,000 --> 00:03:46,000
就是行尸走肉

128
00:03:46,000 --> 00:03:47,000
每句行尸走肉里面

129
00:03:47,000 --> 00:03:48,000
有一集也叫 Nebraska

130
00:03:48,000 --> 00:03:50,000
就是讲他们想要去 Nebraska

131
00:03:50,000 --> 00:03:52,000
然后我说那边人少

132
00:03:52,000 --> 00:03:53,000
然后很多枪

133
00:03:53,000 --> 00:03:55,000
然后就是 Flying Allstate

134
00:03:55,000 --> 00:03:57,000
所以僵尸不会太多

135
00:03:57,000 --> 00:03:59,000
连在这种末日片里面

136
00:03:59,000 --> 00:03:59,000
都要被黑

137
00:03:59,000 --> 00:04:02,000
太惨

138
00:04:02,000 --> 00:04:06,000
上期我们请到了沐瑶

139
00:04:06,000 --> 00:04:08,000
大神跟我们

140
00:04:08,000 --> 00:04:10,000
然后我们瞬间多了很多

141
00:04:10,000 --> 00:04:12,000
粉丝和

142
00:04:12,000 --> 00:04:13,000
没错

143
00:04:13,000 --> 00:04:14,000
这可能是

144
00:04:14,000 --> 00:04:16,000
对我们之前觉得

145
00:04:16,000 --> 00:04:18,000
可能键盘恐慌那期

146
00:04:18,000 --> 00:04:20,000
是比较受欢迎的一期

147
00:04:20,000 --> 00:04:21,000
但是现在看来好像

148
00:04:21,000 --> 00:04:23,000
这已经是一个

149
00:04:23,000 --> 00:04:25,000
后无来者的

150
00:04:25,000 --> 00:04:26,000
全无古人

151
00:04:26,000 --> 00:04:27,000
后无来者的高度了

152
00:04:27,000 --> 00:04:28,000
对吧

153
00:04:28,000 --> 00:04:28,000
对

154
00:04:28,000 --> 00:04:29,000
《木遥》这一期

155
00:04:29,000 --> 00:04:29,000
真的是

156
00:04:29,000 --> 00:04:32,000
现在看来

157
00:04:32,000 --> 00:04:32,000
真是

158
00:04:32,000 --> 00:04:34,000
不管是在微博上

159
00:04:34,000 --> 00:04:35,000
还是在

160
00:04:35,000 --> 00:04:36,000
推特上

161
00:04:36,000 --> 00:04:37,000
还是在

162
00:04:37,000 --> 00:04:38,000
还是由

163
00:04:38,000 --> 00:04:39,000
热情听众

164
00:04:39,000 --> 00:04:40,000
热情听众们

165
00:04:40,000 --> 00:04:41,000
写来的来信里面

166
00:04:41,000 --> 00:04:43,000
这一期都是非常受欢迎

167
00:04:43,000 --> 00:04:43,000
而且

168
00:04:43,000 --> 00:04:45,000
引起热议的一期

169
00:04:45,000 --> 00:04:47,000
而且你发现没

170
00:04:47,000 --> 00:04:48,000
这一期出现之后

171
00:04:48,000 --> 00:04:50,000
我们多了很多女粉丝

172
00:04:50,000 --> 00:04:51,000
对

173
00:04:51,000 --> 00:04:54,000
然后我挨个点进

174
00:04:54,000 --> 00:04:55,000
他们的微博去看

175
00:04:55,000 --> 00:04:56,000
都是美女竟然

176
00:04:56,000 --> 00:04:58,000
你居然会挨个点进去

177
00:04:58,000 --> 00:04:59,000
看人家的微博

178
00:04:59,000 --> 00:05:00,000
你这样对吗

179
00:05:00,000 --> 00:05:02,000
我这个也是要

180
00:05:02,000 --> 00:05:04,000
关注粉丝的反馈

181
00:05:04,000 --> 00:05:05,000
对不对

182
00:05:05,000 --> 00:05:06,000
但我一把他看见

183
00:05:06,000 --> 00:05:06,000
头像是美女

184
00:05:06,000 --> 00:05:07,000
才点进去看一下

185
00:05:07,000 --> 00:05:09,000
Curnal Panic

186
00:05:09,000 --> 00:05:10,000
这么高冷的节目

187
00:05:10,000 --> 00:05:11,000
都要看脸

188
00:05:11,000 --> 00:05:11,000
这样对吗

189
00:05:11,000 --> 00:05:14,000
我们都不露脸

190
00:05:14,000 --> 00:05:14,000
没有关系

191
00:05:14,000 --> 00:05:15,000
没有关系

192
00:05:15,000 --> 00:05:16,000
好吧

193
00:05:16,000 --> 00:05:17,000
所以

194
00:05:17,000 --> 00:05:17,000
所以

195
00:05:17,000 --> 00:05:18,000
所以看下还是什么

196
00:05:18,000 --> 00:05:20,000
男神的魅力很大

197
00:05:20,000 --> 00:05:21,000
对

198
00:05:21,000 --> 00:05:21,000
而且

199
00:05:21,000 --> 00:05:22,000
而且有一个

200
00:05:22,000 --> 00:05:23,000
有一个

201
00:05:23,000 --> 00:05:23,000
有一个推特

202
00:05:23,000 --> 00:05:24,000
有一个

203
00:05:24,000 --> 00:05:25,000
有条微博说

204
00:05:25,000 --> 00:05:27,000
这一期毕竟都是男神

205
00:05:27,000 --> 00:05:28,000
得点闷

206
00:05:28,000 --> 00:05:29,000
然后

207
00:05:29,000 --> 00:05:30,000
咱俩就可怜的

208
00:05:30,000 --> 00:05:31,000
屈居来

209
00:05:31,000 --> 00:05:32,000
屈居在那个闷里面

210
00:05:32,000 --> 00:05:36,000
人家还是为了照顾下

211
00:05:36,000 --> 00:05:37,000
我们的情绪而已

212
00:05:37,000 --> 00:05:38,000
不要太当真

213
00:05:38,000 --> 00:05:39,000
不要太当真

214
00:05:39,000 --> 00:05:39,000
好了

215
00:05:39,000 --> 00:05:40,000
对

216
00:05:40,000 --> 00:05:43,000
其实我们也在酝酿

217
00:05:43,000 --> 00:05:44,000
或者说在

218
00:05:44,000 --> 00:05:46,000
YY

219
00:05:46,000 --> 00:05:49,000
将来还会有一期

220
00:05:49,000 --> 00:05:50,000
请到

221
00:05:50,000 --> 00:05:50,000
重新请到幕僚

222
00:05:50,000 --> 00:05:52,000
不过

223
00:05:52,000 --> 00:05:54,000
目前没有一个太

224
00:05:54,000 --> 00:05:57,000
确切的时间表

225
00:05:57,000 --> 00:05:58,000
但我们会努力

226
00:05:58,000 --> 00:05:59,000
对

227
00:05:59,000 --> 00:06:01,000
然后下一期

228
00:06:01,000 --> 00:06:03,000
可能会想要谈论一些

229
00:06:03,000 --> 00:06:04,000
和数据相关的

230
00:06:04,000 --> 00:06:07,000
和统计学相关的主题吧

231
00:06:07,000 --> 00:06:09,000
其实我们这边也可以请

232
00:06:09,000 --> 00:06:12,000
听众们自靠费用

233
00:06:12,000 --> 00:06:12,000
如果你觉得

234
00:06:12,000 --> 00:06:15,000
你对数据这个话题

235
00:06:15,000 --> 00:06:16,000
或者说对统计学

236
00:06:16,000 --> 00:06:17,000
这个话题比较有

237
00:06:17,000 --> 00:06:18,000
比较感兴趣

238
00:06:18,000 --> 00:06:19,000
并且可以从

239
00:06:19,000 --> 00:06:21,000
和程序相关的角度

240
00:06:21,000 --> 00:06:22,000
谈一谈你的看法

241
00:06:22,000 --> 00:06:23,000
那我们也可

242
00:06:23,000 --> 00:06:24,000
也非常欢迎你

243
00:06:24,000 --> 00:06:27,000
或者是报名参加我们的节目

244
00:06:27,000 --> 00:06:28,000
或者是为这一个

245
00:06:28,000 --> 00:06:31,000
将可能出现的主题

246
00:06:31,000 --> 00:06:31,000
写一些你的看法

247
00:06:31,000 --> 00:06:33,000
因为我们现在

248
00:06:33,000 --> 00:06:36,000
主要是会收到一些

249
00:06:36,000 --> 00:06:37,000
feedback

250
00:06:37,000 --> 00:06:39,000
就是主要是在

251
00:06:39,000 --> 00:06:40,000
节目播出之后

252
00:06:40,000 --> 00:06:41,000
比如说我们今天

253
00:06:41,000 --> 00:06:42,000
是今天吧

254
00:06:42,000 --> 00:06:44,000
收到一封 2200 多字的

255
00:06:44,000 --> 00:06:45,000
读者来信

256
00:06:45,000 --> 00:06:46,000
是

257
00:06:46,000 --> 00:06:47,000
是

258
00:06:47,000 --> 00:06:49,000
一位微软员工

259
00:06:49,000 --> 00:06:50,000
然后专门

260
00:06:50,000 --> 00:06:53,000
提供了上

261
00:06:53,000 --> 00:06:55,000
木窑这一期的很多反馈

262
00:06:55,000 --> 00:06:55,000
但是

263
00:06:55,000 --> 00:06:57,000
这些反馈里面有很多

264
00:06:57,000 --> 00:06:57,000
我们都觉得

265
00:06:57,000 --> 00:06:58,000
其实相当有意义

266
00:06:58,000 --> 00:06:59,000
但是

267
00:06:59,000 --> 00:07:02,000
全文念出来实在是

268
00:07:02,000 --> 00:07:04,000
会占用比较长的时间

269
00:07:04,000 --> 00:07:06,000
所以也许比较好的一点

270
00:07:06,000 --> 00:07:07,000
比较好的一种

271
00:07:07,000 --> 00:07:10,000
模式是我们

272
00:07:10,000 --> 00:07:11,000
告诉听众朋友们

273
00:07:11,000 --> 00:07:12,000
下一期

274
00:07:12,000 --> 00:07:13,000
或者说将来会出现的

275
00:07:13,000 --> 00:07:14,000
某一期的话题是什么

276
00:07:14,000 --> 00:07:15,000
然后

277
00:07:15,000 --> 00:07:16,000
各位听众可以就此

278
00:07:16,000 --> 00:07:18,000
写一些感想

279
00:07:18,000 --> 00:07:19,000
然后我们可以在

280
00:07:19,000 --> 00:07:21,000
节目里面

281
00:07:21,000 --> 00:07:23,000
或者是念出来

282
00:07:23,000 --> 00:07:24,000
或者是就其观点

283
00:07:24,000 --> 00:07:24,000
做出讨论

284
00:07:24,000 --> 00:07:25,000
我觉得也挺好

285
00:07:25,000 --> 00:07:26,000
嗯哼

286
00:07:26,000 --> 00:07:27,000
没错

287
00:07:27,000 --> 00:07:28,000
然后

288
00:07:28,000 --> 00:07:29,000
真的很感动

289
00:07:29,000 --> 00:07:29,000
这是

290
00:07:29,000 --> 00:07:32,000
本节目开播以来

291
00:07:32,000 --> 00:07:33,000
这也

292
00:07:33,000 --> 00:07:34,000
这不算有史以来最长

293
00:07:34,000 --> 00:07:36,000
但是觉得也是较长的

294
00:07:36,000 --> 00:07:36,000
那一些

295
00:07:36,000 --> 00:07:38,000
少数了

296
00:07:38,000 --> 00:07:39,000
对

297
00:07:39,000 --> 00:07:39,000
是

298
00:07:39,000 --> 00:07:40,000
关键是

299
00:07:40,000 --> 00:07:42,000
关键是他说

300
00:07:42,000 --> 00:07:44,000
他说他是微软的员工

301
00:07:44,000 --> 00:07:46,000
然后我们还这么黑他们

302
00:07:46,000 --> 00:07:47,000
对

303
00:07:47,000 --> 00:07:49,000
以后还坚持听

304
00:07:49,000 --> 00:07:50,000
真的是真爱

305
00:07:50,000 --> 00:07:52,000
我们以后下嘴轻一点

306
00:07:52,000 --> 00:07:53,000
特别照顾

307
00:07:53,000 --> 00:07:54,000
特别照顾

308
00:07:54,000 --> 00:07:56,000
女粉丝的心

309
00:07:56,000 --> 00:07:56,000
那个

310
00:07:56,000 --> 00:07:58,000
男粉丝就

311
00:07:58,000 --> 00:08:00,000
微软专有女粉丝

312
00:08:00,000 --> 00:08:01,000
这个真的不太正常

313
00:08:01,000 --> 00:08:02,000
不过想想

314
00:08:02,000 --> 00:08:03,000
萧继姐也是

315
00:08:03,000 --> 00:08:03,000
等等

316
00:08:03,000 --> 00:08:04,000
萧继姐是微软粉丝吗

317
00:08:04,000 --> 00:08:05,000
虽然他微软也工

318
00:08:05,000 --> 00:08:07,000
但是萧继姐是微软粉丝吗

319
00:08:07,000 --> 00:08:08,000
嗯

320
00:08:08,000 --> 00:08:09,000
我们可以下期

321
00:08:09,000 --> 00:08:11,000
找小妈妈请到她来

322
00:08:11,000 --> 00:08:12,000
你可以当面问她

323
00:08:12,000 --> 00:08:13,000
好好好

324
00:08:13,000 --> 00:08:15,000
你将来一定要有一期

325
00:08:15,000 --> 00:08:15,000
请萧继姐

326
00:08:15,000 --> 00:08:16,000
嗯

327
00:08:16,000 --> 00:08:17,000
嗯

328
00:08:17,000 --> 00:08:18,000
对

329
00:08:18,000 --> 00:08:18,000
总之

330
00:08:18,000 --> 00:08:19,000
我觉得上一期

331
00:08:19,000 --> 00:08:20,000
沐瑶这一期

332
00:08:20,000 --> 00:08:21,000
到现在还是觉得

333
00:08:21,000 --> 00:08:22,000
怎么说

334
00:08:22,000 --> 00:08:23,000
唇齿流行

335
00:08:23,000 --> 00:08:25,000
然后膝盖酸润

336
00:08:25,000 --> 00:08:27,000
上期

337
00:08:27,000 --> 00:08:27,000
嗯

338
00:08:27,000 --> 00:08:27,000
嗯

339
00:08:27,000 --> 00:08:28,000
嗯

340
00:08:28,000 --> 00:08:30,000
嗯

341
00:08:30,000 --> 00:08:31,000
其实

342
00:08:31,000 --> 00:08:34,000
回应一下上一期的一些

343
00:08:34,000 --> 00:08:36,000
一些没有彻底展开的观点吧

344
00:08:36,000 --> 00:08:36,000
就是

345
00:08:36,000 --> 00:08:38,000
其实我后来想了想

346
00:08:38,000 --> 00:08:40,000
上一期提到一些事情

347
00:08:40,000 --> 00:08:40,000
比如说我觉得

348
00:08:40,000 --> 00:08:41,000
嗯

349
00:08:41,000 --> 00:08:43,000
比如说工具不好用这件事情

350
00:08:43,000 --> 00:08:44,000
嗯

351
00:08:44,000 --> 00:08:46,000
我不知道你怎么觉得

352
00:08:46,000 --> 00:08:47,000
但我觉得

353
00:08:47,000 --> 00:08:48,000
现在的编程工具

354
00:08:48,000 --> 00:08:49,000
要比十年前

355
00:08:49,000 --> 00:08:51,000
好用太多了

356
00:08:51,000 --> 00:08:52,000
你不觉得吗

357
00:08:52,000 --> 00:08:54,000
我想要十年前我在干嘛

358
00:08:54,000 --> 00:08:56,000
别这样好吗

359
00:08:56,000 --> 00:08:57,000
别这样好

360
00:08:57,000 --> 00:08:59,000
十年前我刚上大学

361
00:08:59,000 --> 00:09:00,000
嗯

362
00:09:00,000 --> 00:09:01,000
还不怎么

363
00:09:01,000 --> 00:09:01,000
嗯

364
00:09:01,000 --> 00:09:03,000
然后学的是商科

365
00:09:03,000 --> 00:09:04,000
也不怎么写

366
00:09:04,000 --> 00:09:05,000
也不怎么写程序

367
00:09:05,000 --> 00:09:06,000
没感觉

368
00:09:06,000 --> 00:09:08,000
好吧

369
00:09:08,000 --> 00:09:10,000
但我是觉得

370
00:09:10,000 --> 00:09:11,000
现在的编程工具

371
00:09:11,000 --> 00:09:12,000
要比十年前

372
00:09:12,000 --> 00:09:13,000
就是 2005 年左右

373
00:09:13,000 --> 00:09:15,000
真的好用很多

374
00:09:15,000 --> 00:09:16,000
2005 年的时候

375
00:09:16,000 --> 00:09:18,000
嗯

376
00:09:18,000 --> 00:09:20,000
不说别的吧

377
00:09:20,000 --> 00:09:21,000
你写一个最简单的

378
00:09:21,000 --> 00:09:22,000
最基础东西

379
00:09:22,000 --> 00:09:23,000
你写个网页出来

380
00:09:23,000 --> 00:09:24,000
那个时候哪有什么

381
00:09:24,000 --> 00:09:27,000
WebKit Console 这种东西

382
00:09:27,000 --> 00:09:28,000
就那个时候

383
00:09:28,000 --> 00:09:29,000
就用

384
00:09:29,000 --> 00:09:30,000
那个时候就是什么

385
00:09:30,000 --> 00:09:31,000
呃

386
00:09:31,000 --> 00:09:32,000
编辑一下

387
00:09:32,000 --> 00:09:33,000
然后刷新页面查看

388
00:09:33,000 --> 00:09:34,000
对啊

389
00:09:34,000 --> 00:09:35,000
而且那个时候用的是

390
00:09:35,000 --> 00:09:36,000
Internet Explorer 好吗

391
00:09:36,000 --> 00:09:37,000
Internet Explorer

392
00:09:37,000 --> 00:09:38,000
那个时候还没有

393
00:09:38,000 --> 00:09:39,000
没有 tab 的

394
00:09:39,000 --> 00:09:40,000
就是你

395
00:09:40,000 --> 00:09:41,000
你用

396
00:09:41,000 --> 00:09:41,000
呃

397
00:09:41,000 --> 00:09:42,000
那个时候我是用

398
00:09:42,000 --> 00:09:43,000
Notepad++

399
00:09:43,000 --> 00:09:44,000
写一个

400
00:09:44,000 --> 00:09:46,000
写写一堆 markup

401
00:09:46,000 --> 00:09:47,000
然后在微软

402
00:09:47,000 --> 00:09:49,000
在 i 里面刷新

403
00:09:49,000 --> 00:09:50,000
嗯

404
00:09:50,000 --> 00:09:50,000
现在呢

405
00:09:50,000 --> 00:09:51,000
然后去

406
00:09:51,000 --> 00:09:52,000
然后去猜

407
00:09:52,000 --> 00:09:54,000
然后自己头脑中模拟

408
00:09:54,000 --> 00:09:54,000
那个什么

409
00:09:54,000 --> 00:09:56,000
Dome 解析器的

410
00:09:56,000 --> 00:09:56,000
一步一步猜

411
00:09:56,000 --> 00:09:57,000
它为什么会这样

412
00:09:57,000 --> 00:09:58,000
对不对

413
00:09:58,000 --> 00:09:58,000
对

414
00:09:58,000 --> 00:09:59,000
而现在

415
00:09:59,000 --> 00:10:01,000
Leb Console 是多么好用的

416
00:10:01,000 --> 00:10:02,000
一个东西

417
00:10:02,000 --> 00:10:03,000
你可以随时去改

418
00:10:03,000 --> 00:10:05,000
任何一个页面上的

419
00:10:05,000 --> 00:10:06,000
大部分元素

420
00:10:06,000 --> 00:10:07,000
嗯

421
00:10:07,000 --> 00:10:08,000
但是除非你在用一些

422
00:10:08,000 --> 00:10:09,000
比较 R 的东西

423
00:10:09,000 --> 00:10:09,000
比如说

424
00:10:09,000 --> 00:10:12,000
GWT 这种东西

425
00:10:12,000 --> 00:10:14,000
那那搞出来的东西

426
00:10:14,000 --> 00:10:15,000
是真的没有办法

427
00:10:15,000 --> 00:10:16,000
在 Web Console 里面

428
00:10:16,000 --> 00:10:16,000
Debug 的

429
00:10:16,000 --> 00:10:17,000
但是

430
00:10:17,000 --> 00:10:19,000
如果你图手写的话

431
00:10:19,000 --> 00:10:20,000
那这些工具

432
00:10:20,000 --> 00:10:22,000
真的要比 10 年前好太多

433
00:10:22,000 --> 00:10:23,000
对啊

434
00:10:23,000 --> 00:10:24,000
嗯

435
00:10:24,000 --> 00:10:25,000
而且很多语言都

436
00:10:25,000 --> 00:10:27,000
现在很多动态语言

437
00:10:27,000 --> 00:10:28,000
或者说尤其是动态语言

438
00:10:28,000 --> 00:10:29,000
都提供了自己的

439
00:10:29,000 --> 00:10:30,000
所谓 REPL

440
00:10:30,000 --> 00:10:32,000
嗯

441
00:10:32,000 --> 00:10:33,000
Repl

442
00:10:33,000 --> 00:10:33,000
对

443
00:10:33,000 --> 00:10:35,000
叫什么

444
00:10:35,000 --> 00:10:35,000
说起来着

445
00:10:35,000 --> 00:10:36,000
Write

446
00:10:36,000 --> 00:10:37,000
Read

447
00:10:37,000 --> 00:10:38,000
Evaluate

448
00:10:38,000 --> 00:10:39,000
Print Loop

449
00:10:39,000 --> 00:10:40,000
读入

450
00:10:40,000 --> 00:10:41,000
然后

451
00:10:41,000 --> 00:10:42,000
叫什么

452
00:10:42,000 --> 00:10:43,000
Evaluate

453
00:10:43,000 --> 00:10:44,000
求职

454
00:10:44,000 --> 00:10:45,000
求职

455
00:10:45,000 --> 00:10:45,000
打印

456
00:10:45,000 --> 00:10:46,000
循环

457
00:10:46,000 --> 00:10:47,000
对

458
00:10:47,000 --> 00:10:48,000
当然

459
00:10:48,000 --> 00:10:49,000
Rappo

460
00:10:49,000 --> 00:10:50,000
其实并不是一个

461
00:10:50,000 --> 00:10:51,000
非常

462
00:10:51,000 --> 00:10:52,000
嗯

463
00:10:52,000 --> 00:10:53,000
新颖的东西

464
00:10:53,000 --> 00:10:54,000
就比如说

465
00:10:54,000 --> 00:10:55,000
你说

466
00:10:55,000 --> 00:10:55,000
List

467
00:10:55,000 --> 00:10:56,000
最开始

468
00:10:56,000 --> 00:10:56,000
它就有了

469
00:10:56,000 --> 00:10:57,000
对

470
00:10:57,000 --> 00:10:58,000
而且

471
00:10:58,000 --> 00:11:00,000
就哪怕是命令是语言

472
00:11:00,000 --> 00:11:01,000
在

473
00:11:01,000 --> 00:11:03,000
Basic 上面

474
00:11:03,000 --> 00:11:04,000
其实也是一个

475
00:11:04,000 --> 00:11:05,000
Repl

476
00:11:05,000 --> 00:11:05,000
就

477
00:11:05,000 --> 00:11:06,000
在

478
00:11:06,000 --> 00:11:08,000
在 Apple 2 上面的

479
00:11:08,000 --> 00:11:09,000
Basic

480
00:11:09,000 --> 00:11:09,000
也是一个

481
00:11:09,000 --> 00:11:09,000
对对对

482
00:11:09,000 --> 00:11:10,000
没错

483
00:11:10,000 --> 00:11:11,000
也是一行一行

484
00:11:11,000 --> 00:11:12,000
解析执行

485
00:11:12,000 --> 00:11:12,000
对

486
00:11:12,000 --> 00:11:13,000
除非你打行号

487
00:11:13,000 --> 00:11:14,000
然后再

488
00:11:14,000 --> 00:11:15,000
再打 run

489
00:11:15,000 --> 00:11:17,000
否则它就是一个

490
00:11:17,000 --> 00:11:18,000
默认就是一个 Repl

491
00:11:18,000 --> 00:11:19,000
嗯

492
00:11:19,000 --> 00:11:20,000
嗯

493
00:11:20,000 --> 00:11:21,000
但是现在的 Repl

494
00:11:21,000 --> 00:11:22,000
要比

495
00:11:22,000 --> 00:11:23,000
又要比那时候的 Repl

496
00:11:23,000 --> 00:11:24,000
要好太多

497
00:11:24,000 --> 00:11:24,000
就

498
00:11:24,000 --> 00:11:26,000
不管是

499
00:11:26,000 --> 00:11:27,000
比如说我们有

500
00:11:27,000 --> 00:11:28,000
现在像

501
00:11:28,000 --> 00:11:29,000
iPython 这样的

502
00:11:29,000 --> 00:11:31,000
非常实用的

503
00:11:31,000 --> 00:11:32,000
日常笔记本工具

504
00:11:32,000 --> 00:11:33,000
嗯

505
00:11:33,000 --> 00:11:34,000
Rubio

506
00:11:34,000 --> 00:11:36,000
Pray

507
00:11:36,000 --> 00:11:38,000
是念 Pray 吧

508
00:11:38,000 --> 00:11:39,000
PRY

509
00:11:39,000 --> 00:11:40,000
就是

510
00:11:40,000 --> 00:11:41,000
撬棍的那个词

511
00:11:41,000 --> 00:11:43,000
还是念 Pry

512
00:11:43,000 --> 00:11:44,000
没怎么用

513
00:11:44,000 --> 00:11:45,000
Pry 吧

514
00:11:45,000 --> 00:11:45,000
没怎么用

515
00:11:45,000 --> 00:11:45,000
对

516
00:11:45,000 --> 00:11:48,000
这些

517
00:11:48,000 --> 00:11:48,000
就是这些东西

518
00:11:48,000 --> 00:11:49,000
都是支持

519
00:11:49,000 --> 00:11:50,000
比如说你在输的时候

520
00:11:50,000 --> 00:11:51,000
就可以语法高量

521
00:11:51,000 --> 00:11:51,000
然后

522
00:11:51,000 --> 00:11:52,000
嗯

523
00:11:52,000 --> 00:11:54,000
是你可以把它当成一个

524
00:11:54,000 --> 00:11:56,000
一个包

525
00:11:56,000 --> 00:11:57,000
呃

526
00:11:57,000 --> 00:11:58,000
嵌到你的

527
00:11:58,000 --> 00:12:00,000
嵌到你要

528
00:12:00,000 --> 00:12:01,000
想要 debug 的程序里面

529
00:12:01,000 --> 00:12:02,000
然后你在那地方

530
00:12:02,000 --> 00:12:03,000
设置一个

531
00:12:03,000 --> 00:12:04,000
以前是要设置一个断点

532
00:12:04,000 --> 00:12:06,000
用什么 PYDB 之类的

533
00:12:06,000 --> 00:12:07,000
而现在你可以直接把

534
00:12:07,000 --> 00:12:07,000
iPython

535
00:12:07,000 --> 00:12:09,000
断在那个地方

536
00:12:09,000 --> 00:12:09,000
然后

537
00:12:09,000 --> 00:12:10,000
执行到的时候

538
00:12:10,000 --> 00:12:11,000
你跳出来

539
00:12:11,000 --> 00:12:11,000
一个 iPython

540
00:12:11,000 --> 00:12:12,000
执行环境

541
00:12:12,000 --> 00:12:13,000
你可以随便想干什么

542
00:12:13,000 --> 00:12:14,000
都干什么

543
00:12:14,000 --> 00:12:14,000
对

544
00:12:14,000 --> 00:12:17,000
然后有

545
00:12:17,000 --> 00:12:18,000
比如说我们之前

546
00:12:18,000 --> 00:12:21,000
在苹果的发布会上

547
00:12:21,000 --> 00:12:22,000
看到的 Swift 的那个

548
00:12:22,000 --> 00:12:23,000
Playground

549
00:12:23,000 --> 00:12:25,000
它其实也是一个

550
00:12:25,000 --> 00:12:27,000
更为先进的

551
00:12:27,000 --> 00:12:27,000
Repl 吧

552
00:12:27,000 --> 00:12:27,000
就是它

553
00:12:27,000 --> 00:12:28,000
它有所谓

554
00:12:28,000 --> 00:12:30,000
live programming 的

555
00:12:30,000 --> 00:12:31,000
的能力

556
00:12:31,000 --> 00:12:31,000
你可以

557
00:12:31,000 --> 00:12:33,000
更加直观的看到

558
00:12:33,000 --> 00:12:34,000
你写出来的东西

559
00:12:34,000 --> 00:12:35,000
是什么

560
00:12:35,000 --> 00:12:36,000
或者说它

561
00:12:36,000 --> 00:12:37,000
它跑起来

562
00:12:37,000 --> 00:12:38,000
它在局部跑起来

563
00:12:38,000 --> 00:12:39,000
是一个什么样的

564
00:12:39,000 --> 00:12:40,000
过程

565
00:12:40,000 --> 00:12:41,000
其实都是非常非常

566
00:12:41,000 --> 00:12:42,000
方便的一些特性

567
00:12:42,000 --> 00:12:43,000
嗯

568
00:12:43,000 --> 00:12:44,000
那就是说

569
00:12:44,000 --> 00:12:46,000
就我们这么过去

570
00:12:46,000 --> 00:12:48,000
实际间就在普及用的工具

571
00:12:48,000 --> 00:12:49,000
还是在进步吧

572
00:12:49,000 --> 00:12:51,000
不过我觉得可能

573
00:12:51,000 --> 00:12:53,000
离真正像普通人

574
00:12:53,000 --> 00:12:54,000
或者是说像沐阳老师

575
00:12:54,000 --> 00:12:56,000
这种不喜欢用工

576
00:12:56,000 --> 00:12:57,000
就不太喜欢

577
00:12:57,000 --> 00:12:59,000
花时间去学这种工具的人

578
00:12:59,000 --> 00:13:00,000
它可能还是有点

579
00:13:00,000 --> 00:13:01,000
困难

580
00:13:01,000 --> 00:13:02,000
比如说至少

581
00:13:02,000 --> 00:13:03,000
我们在日常用的时候

582
00:13:03,000 --> 00:13:04,000
很多那种

583
00:13:04,000 --> 00:13:05,000
repl

584
00:13:05,000 --> 00:13:07,000
它还是有很多限制的嘛

585
00:13:07,000 --> 00:13:08,000
比如你不能做很多事情

586
00:13:08,000 --> 00:13:09,000
有时候

587
00:13:09,000 --> 00:13:11,000
而且对这个环境的

588
00:13:11,000 --> 00:13:12,000
inspection

589
00:13:12,000 --> 00:13:14,000
就是检查的能力

590
00:13:14,000 --> 00:13:15,000
也是有一定的限制的

591
00:13:15,000 --> 00:13:17,000
你不像说在

592
00:13:17,000 --> 00:13:18,000
像再早一点

593
00:13:18,000 --> 00:13:19,000
什么像 small talk

594
00:13:19,000 --> 00:13:20,000
那种虚拟经济

595
00:13:20,000 --> 00:13:21,000
那叫什么

596
00:13:21,000 --> 00:13:21,000
scroll

597
00:13:21,000 --> 00:13:22,000
对不对

598
00:13:22,000 --> 00:13:22,000
对

599
00:13:22,000 --> 00:13:23,000
它自带一个

600
00:13:23,000 --> 00:13:24,000
核齿

601
00:13:24,000 --> 00:13:25,000
核齿就是怎么说的

602
00:13:25,000 --> 00:13:26,000
是有点像 IDE

603
00:13:26,000 --> 00:13:27,000
但又不像

604
00:13:27,000 --> 00:13:28,000
都不是 IDE

605
00:13:28,000 --> 00:13:30,000
它的那个好

606
00:13:30,000 --> 00:13:31,000
就是说整个

607
00:13:31,000 --> 00:13:31,000
那个

608
00:13:31,000 --> 00:13:32,000
整个

609
00:13:32,000 --> 00:13:33,000
就是那个环境

610
00:13:33,000 --> 00:13:34,000
那个操作系统

611
00:13:34,000 --> 00:13:34,000
那个世界

612
00:13:34,000 --> 00:13:36,000
都是可以被 inspection

613
00:13:36,000 --> 00:13:38,000
就是可以很方便的

614
00:13:38,000 --> 00:13:38,000
语法

615
00:13:38,000 --> 00:13:39,000
很统一的规则

616
00:13:39,000 --> 00:13:40,000
去做它

617
00:13:40,000 --> 00:13:41,000
就所以

618
00:13:41,000 --> 00:13:42,000
历史上是

619
00:13:42,000 --> 00:13:44,000
确实曾经出现过那种

620
00:13:44,000 --> 00:13:44,000
所谓

621
00:13:44,000 --> 00:13:47,000
就哪怕是按现在的观点来看

622
00:13:47,000 --> 00:13:47,000
就是所谓

623
00:13:47,000 --> 00:13:48,000
精为天人的

624
00:13:48,000 --> 00:13:51,000
这种工具的设计

625
00:13:51,000 --> 00:13:52,000
但是这是因为一些

626
00:13:52,000 --> 00:13:54,000
商业的

627
00:13:54,000 --> 00:13:55,000
或者是这个

628
00:13:55,000 --> 00:13:55,000
其他的原因

629
00:13:55,000 --> 00:13:56,000
没有流行起来

630
00:13:56,000 --> 00:13:57,000
所以现在我们

631
00:13:57,000 --> 00:13:58,000
还是在

632
00:13:58,000 --> 00:14:00,000
不断的去朝那个方向

633
00:14:00,000 --> 00:14:00,000
眼镜

634
00:14:00,000 --> 00:14:02,000
虽然还没有达到

635
00:14:02,000 --> 00:14:03,000
那个高度而已

636
00:14:03,000 --> 00:14:04,000
其实这也是一个

637
00:14:04,000 --> 00:14:05,000
很有意思的问题

638
00:14:05,000 --> 00:14:05,000
就是

639
00:14:05,000 --> 00:14:09,000
有时候我们很难说

640
00:14:09,000 --> 00:14:10,000
一个成功的

641
00:14:10,000 --> 00:14:12,000
事物

642
00:14:12,000 --> 00:14:13,000
就是因为

643
00:14:13,000 --> 00:14:14,000
它的技术比较优越

644
00:14:14,000 --> 00:14:15,000
而

645
00:14:15,000 --> 00:14:17,000
经常都不是这样子的

646
00:14:17,000 --> 00:14:18,000
特别是在技术界面

647
00:14:18,000 --> 00:14:19,000
我们不是有个说法

648
00:14:19,000 --> 00:14:19,000
叫做

649
00:14:19,000 --> 00:14:20,000
Worse is better

650
00:14:20,000 --> 00:14:21,000
就好像

651
00:14:21,000 --> 00:14:22,000
经常很多人吐槽

652
00:14:22,000 --> 00:14:22,000
说

653
00:14:22,000 --> 00:14:23,000
你那个 Linux

654
00:14:23,000 --> 00:14:24,000
这么流行

655
00:14:24,000 --> 00:14:25,000
但是你看一下

656
00:14:25,000 --> 00:14:26,000
你的底层的设计

657
00:14:26,000 --> 00:14:28,000
很多地方是很不优雅的

658
00:14:28,000 --> 00:14:29,000
很不 Unix 的

659
00:14:29,000 --> 00:14:30,000
对吧

660
00:14:30,000 --> 00:14:30,000
很恶心的

661
00:14:30,000 --> 00:14:31,000
但是反过来

662
00:14:31,000 --> 00:14:32,000
你说那些优雅的

663
00:14:32,000 --> 00:14:34,000
比较高端的东西

664
00:14:34,000 --> 00:14:35,000
却又往往流行不起来

665
00:14:35,000 --> 00:14:36,000
比如说 Planet

666
00:14:36,000 --> 00:14:41,000
甚至不说 Planet

667
00:14:41,000 --> 00:14:42,000
这么比较冷门的东西

668
00:14:42,000 --> 00:14:44,000
编程语言里面也是

669
00:14:44,000 --> 00:14:45,000
基本上是

670
00:14:45,000 --> 00:14:46,000
比较流行的语言

671
00:14:46,000 --> 00:14:48,000
往往是比较糟糕的语言

672
00:14:48,000 --> 00:14:51,000
尽管它

673
00:14:51,000 --> 00:14:52,000
有点黑

674
00:14:52,000 --> 00:14:53,000
算了

675
00:14:53,000 --> 00:14:55,000
我们就不举具体的事例

676
00:14:55,000 --> 00:14:59,000
对

677
00:14:59,000 --> 00:15:00,000
然后

678
00:15:00,000 --> 00:15:02,000
但是我也承认

679
00:15:02,000 --> 00:15:04,000
就是现在的编程工具

680
00:15:04,000 --> 00:15:06,000
虽然要比 10 年前好很多

681
00:15:06,000 --> 00:15:08,000
但它仍旧没有能够

682
00:15:08,000 --> 00:15:09,000
好到一个

683
00:15:09,000 --> 00:15:10,000
就是怎么说呢

684
00:15:10,000 --> 00:15:11,000
就是造成一个

685
00:15:11,000 --> 00:15:14,000
所谓范式转化的地固

686
00:15:14,000 --> 00:15:15,000
就是没有说一个

687
00:15:15,000 --> 00:15:17,000
工具是如此的好用

688
00:15:17,000 --> 00:15:18,000
以至于

689
00:15:18,000 --> 00:15:20,000
整个编程界的

690
00:15:20,000 --> 00:15:22,000
整个编程方法论

691
00:15:22,000 --> 00:15:23,000
都被颠覆了

692
00:15:23,000 --> 00:15:24,000
对

693
00:15:24,000 --> 00:15:25,000
还没有

694
00:15:25,000 --> 00:15:28,000
还没有出现过这种东西吧

695
00:15:28,000 --> 00:15:28,000
就出现

696
00:15:28,000 --> 00:15:29,000
曾经出现过

697
00:15:29,000 --> 00:15:32,000
但是没有被保留下来

698
00:15:32,000 --> 00:15:33,000
可以这么讲

699
00:15:33,000 --> 00:15:33,000
对

700
00:15:33,000 --> 00:15:35,000
就好像有一个

701
00:15:35,000 --> 00:15:36,000
电影

702
00:15:36,000 --> 00:15:36,000
有个电影叫什么

703
00:15:36,000 --> 00:15:37,000
简余行动

704
00:15:37,000 --> 00:15:38,000
里面

705
00:15:38,000 --> 00:15:39,000
主角

706
00:15:39,000 --> 00:15:40,000
在

707
00:15:40,000 --> 00:15:42,000
在编程的时候

708
00:15:42,000 --> 00:15:43,000
它编程的方法

709
00:15:43,000 --> 00:15:44,000
就是把一大堆

710
00:15:44,000 --> 00:15:45,000
方块拖来拖去

711
00:15:45,000 --> 00:15:46,000
然后

712
00:15:46,000 --> 00:15:47,000
而且是

713
00:15:47,000 --> 00:15:48,000
而且是非常

714
00:15:48,000 --> 00:15:50,000
看起来

715
00:15:50,000 --> 00:15:51,000
同样很复杂

716
00:15:51,000 --> 00:15:52,000
但是你会觉得

717
00:15:52,000 --> 00:15:53,000
你会

718
00:15:53,000 --> 00:15:54,000
就是至少观众们

719
00:15:54,000 --> 00:15:55,000
会认为这是在编程

720
00:15:55,000 --> 00:15:56,000
但在程序员看来

721
00:15:56,000 --> 00:15:56,000
这是在

722
00:15:56,000 --> 00:15:58,000
这是在解构的方块

723
00:15:58,000 --> 00:15:58,000
还是怎样

724
00:15:58,000 --> 00:16:02,000
如果真的有那样的工具

725
00:16:02,000 --> 00:16:02,000
出现的话

726
00:16:02,000 --> 00:16:07,000
也许是一个非常颠覆性的创新之举

727
00:16:07,000 --> 00:16:08,000
到那个时候

728
00:16:08,000 --> 00:16:09,000
也许

729
00:16:09,000 --> 00:16:10,000
木窑大神们

730
00:16:10,000 --> 00:16:14,000
就可以比较无障碍的

731
00:16:14,000 --> 00:16:16,000
利用编程工具

732
00:16:16,000 --> 00:16:18,000
解决更

733
00:16:18,000 --> 00:16:20,000
怎么说的

734
00:16:20,000 --> 00:16:21,000
抽象层级更高的问题

735
00:16:21,000 --> 00:16:22,000
而不是去

736
00:16:22,000 --> 00:16:24,000
操心这些

737
00:16:24,000 --> 00:16:25,000
西之末

738
00:16:25,000 --> 00:16:26,000
比如说

739
00:16:26,000 --> 00:16:26,000
分号

740
00:16:26,000 --> 00:16:27,000
或者是

741
00:16:27,000 --> 00:16:28,000
缩近之类的事情

742
00:16:28,000 --> 00:16:29,000
没错

743
00:16:29,000 --> 00:16:31,000
所以觉得

744
00:16:31,000 --> 00:16:32,000
有时候我一直在想

745
00:16:32,000 --> 00:16:34,000
其实可能现在造成

746
00:16:34,000 --> 00:16:36,000
现在这种工具

747
00:16:36,000 --> 00:16:37,000
比较乱

748
00:16:37,000 --> 00:16:39,000
然后设计也不够优雅的局面

749
00:16:39,000 --> 00:16:40,000
是不是

750
00:16:40,000 --> 00:16:41,000
我有时候在想

751
00:16:41,000 --> 00:16:43,000
是不是应该等我们这批人死掉之后

752
00:16:43,000 --> 00:16:45,000
要从另外一批人

753
00:16:45,000 --> 00:16:45,000
重新来设计

754
00:16:45,000 --> 00:16:46,000
那么一些理念

755
00:16:46,000 --> 00:16:47,000
可能会好一点

756
00:16:47,000 --> 00:16:49,000
从娃娃抓起

757
00:16:49,000 --> 00:16:49,000
重新想一下

758
00:16:49,000 --> 00:16:51,000
怎么去教小朋友

759
00:16:51,000 --> 00:16:53,000
一个比较直观的

760
00:16:53,000 --> 00:16:54,000
或者说

761
00:16:54,000 --> 00:16:56,000
更加合理的

762
00:16:56,000 --> 00:16:57,000
抽象层级吧

763
00:16:57,000 --> 00:16:58,000
然后将来去

764
00:16:58,000 --> 00:16:59,000
初步去学会

765
00:16:59,000 --> 00:17:00,000
这种新的范式

766
00:17:00,000 --> 00:17:01,000
可能会有意思

767
00:17:01,000 --> 00:17:02,000
很多

768
00:17:02,000 --> 00:17:03,000
对

769
00:17:03,000 --> 00:17:03,000
有时候

770
00:17:03,000 --> 00:17:04,000
对

771
00:17:04,000 --> 00:17:04,000
有时候

772
00:17:04,000 --> 00:17:06,000
我其实刚刚也在想这个问题

773
00:17:06,000 --> 00:17:06,000
就是

774
00:17:06,000 --> 00:17:07,000
我想到

775
00:17:07,000 --> 00:17:10,000
虽然 60 年代的那一批

776
00:17:10,000 --> 00:17:11,000
计算机先驱们

777
00:17:11,000 --> 00:17:11,000
已经溜门去了

778
00:17:11,000 --> 00:17:13,000
但是我们现在活着的

779
00:17:13,000 --> 00:17:15,000
计算机先驱们

780
00:17:15,000 --> 00:17:16,000
比如说 Rodepic

781
00:17:16,000 --> 00:17:17,000
Rodepic

782
00:17:17,000 --> 00:17:18,000
还是在做

783
00:17:18,000 --> 00:17:19,000
在 Google

784
00:17:19,000 --> 00:17:21,000
做一线的这种

785
00:17:21,000 --> 00:17:22,000
原开发工作

786
00:17:22,000 --> 00:17:23,000
但是我在想说

787
00:17:23,000 --> 00:17:26,000
我们能够和这些人

788
00:17:26,000 --> 00:17:27,000
仍旧在同一个时代

789
00:17:27,000 --> 00:17:28,000
是一种幸福

790
00:17:28,000 --> 00:17:29,000
但是如果

791
00:17:29,000 --> 00:17:30,000
再远一点

792
00:17:30,000 --> 00:17:31,000
比如说过个二三十年

793
00:17:31,000 --> 00:17:32,000
等这批人去了之后

794
00:17:32,000 --> 00:17:33,000
那个时候的

795
00:17:33,000 --> 00:17:34,000
编程的

796
00:17:34,000 --> 00:17:36,000
地平线

797
00:17:36,000 --> 00:17:37,000
会是一个什么样的

798
00:17:37,000 --> 00:17:38,000
什么样的风景呢

799
00:17:38,000 --> 00:17:39,000
可能会跟现在

800
00:17:39,000 --> 00:17:39,000
完全不一样

801
00:17:39,000 --> 00:17:40,000
就

802
00:17:40,000 --> 00:17:41,000
就好像那天

803
00:17:41,000 --> 00:17:42,000
我做了那个

804
00:17:42,000 --> 00:17:43,000
内燃机的比喻

805
00:17:43,000 --> 00:17:44,000
也许我们现在用的

806
00:17:44,000 --> 00:17:44,000
就是内燃机

807
00:17:44,000 --> 00:17:45,000
也许

808
00:17:45,000 --> 00:17:46,000
也许

809
00:17:46,000 --> 00:17:48,000
过了二十年

810
00:17:48,000 --> 00:17:49,000
电动机出现的时候

811
00:17:49,000 --> 00:17:50,000
编程真的

812
00:17:50,000 --> 00:17:51,000
和现在的

813
00:17:51,000 --> 00:17:52,000
和现在我们

814
00:17:52,000 --> 00:17:53,000
所熟悉的这些工具

815
00:17:53,000 --> 00:17:56,000
就完全不一样

816
00:17:56,000 --> 00:17:58,000
而且这是一种

817
00:17:58,000 --> 00:18:00,000
很难想象的状态

818
00:18:00,000 --> 00:18:01,000
也许

819
00:18:01,000 --> 00:18:01,000
那个时候我也不知道

820
00:18:01,000 --> 00:18:02,000
三进制计算机

821
00:18:02,000 --> 00:18:05,000
平衡三进制计算机

822
00:18:05,000 --> 00:18:07,000
起码的人

823
00:18:07,000 --> 00:18:08,000
永远不会想到

824
00:18:08,000 --> 00:18:09,000
会飞的人

825
00:18:09,000 --> 00:18:10,000
是怎么样的一种心态

826
00:18:10,000 --> 00:18:11,000
对不对

827
00:18:11,000 --> 00:18:11,000
对

828
00:18:11,000 --> 00:18:12,000
就好像

829
00:18:12,000 --> 00:18:13,000
那些

830
00:18:13,000 --> 00:18:16,000
十九世纪初期的科幻画

831
00:18:16,000 --> 00:18:17,000
幻想二十世纪

832
00:18:17,000 --> 00:18:18,000
是什么样子

833
00:18:18,000 --> 00:18:18,000
那个时候

834
00:18:18,000 --> 00:18:20,000
想到二十世纪

835
00:18:20,000 --> 00:18:21,000
说每个人都在天上飞

836
00:18:21,000 --> 00:18:23,000
然后天上飞的人

837
00:18:23,000 --> 00:18:27,000
会受到天上飞的交警的指挥

838
00:18:27,000 --> 00:18:27,000
可是他

839
00:18:27,000 --> 00:18:28,000
可是他画出来

840
00:18:28,000 --> 00:18:30,000
那个会在天上飞的交警

841
00:18:30,000 --> 00:18:33,000
身上是一双翅膀

842
00:18:33,000 --> 00:18:33,000
而且还是在

843
00:18:33,000 --> 00:18:35,000
还是在那边吹哨子

844
00:18:35,000 --> 00:18:36,000
就

845
00:18:36,000 --> 00:18:38,000
如果现在有什么

846
00:18:38,000 --> 00:18:41,000
空中单人的交通工具的话

847
00:18:41,000 --> 00:18:42,000
那我相信

848
00:18:42,000 --> 00:18:45,000
去控制这种交通工具的规则

849
00:18:45,000 --> 00:18:46,000
肯定不会是吹哨子吧

850
00:18:46,000 --> 00:18:50,000
因素已经太慢了

851
00:18:50,000 --> 00:18:50,000
对

852
00:18:50,000 --> 00:18:52,000
所以我们现在所做出的任何想象

853
00:18:52,000 --> 00:18:56,000
可能在那个时候看来都是非常幼稚而可笑的

854
00:18:56,000 --> 00:18:56,000
嗯

855
00:18:56,000 --> 00:18:59,000
但这仍旧拦不住我们去想

856
00:18:59,000 --> 00:18:59,000
对

857
00:18:59,000 --> 00:19:01,000
好吧

858
00:19:01,000 --> 00:19:03,000
那个什么上期的 follow up

859
00:19:03,000 --> 00:19:04,000
就到这里

860
00:19:04,000 --> 00:19:05,000
我们

861
00:19:05,000 --> 00:19:06,000
其实还有一个

862
00:19:06,000 --> 00:19:07,000
就是

863
00:19:07,000 --> 00:19:09,000
上期

864
00:19:09,000 --> 00:19:11,000
孟瑶收到的

865
00:19:11,000 --> 00:19:12,000
比如说

866
00:19:12,000 --> 00:19:13,000
那个有些语言

867
00:19:13,000 --> 00:19:14,000
非常要求你

868
00:19:14,000 --> 00:19:15,000
什么

869
00:19:15,000 --> 00:19:16,000
注意

870
00:19:16,000 --> 00:19:17,000
分号

871
00:19:17,000 --> 00:19:17,000
缩近

872
00:19:17,000 --> 00:19:18,000
大小写之类的

873
00:19:18,000 --> 00:19:19,000
他有没有说大小写

874
00:19:19,000 --> 00:19:20,000
我不记得

875
00:19:20,000 --> 00:19:22,000
但是我前两天看了看那个 nim 语言

876
00:19:22,000 --> 00:19:23,000
就是新出的那个

877
00:19:23,000 --> 00:19:25,000
之前叫 nimrod

878
00:19:25,000 --> 00:19:26,000
然后现在叫 nim 的语言

879
00:19:26,000 --> 00:19:28,000
这个语言

880
00:19:28,000 --> 00:19:29,000
有一个很有趣的一点

881
00:19:29,000 --> 00:19:30,000
就是他

882
00:19:30,000 --> 00:19:32,000
区分一个标识符的时候

883
00:19:32,000 --> 00:19:35,000
只区分第一个字母是不是大小写

884
00:19:35,000 --> 00:19:38,000
后面是无关的

885
00:19:38,000 --> 00:19:41,000
而且带下滑线也是无关的

886
00:19:41,000 --> 00:19:43,000
这边有什么好处呢

887
00:19:43,000 --> 00:19:44,000
就是他

888
00:19:44,000 --> 00:19:45,000
他列举的好处是

889
00:19:45,000 --> 00:19:46,000
呃

890
00:19:46,000 --> 00:19:46,000
比如说你

891
00:19:46,000 --> 00:19:47,000
你的

892
00:19:47,000 --> 00:19:49,000
你写一个

893
00:19:49,000 --> 00:19:50,000
呃

894
00:19:50,000 --> 00:19:52,000
写一个程序要用到别人的库

895
00:19:52,000 --> 00:19:55,000
别人的库有一个他自己的变量 convention

896
00:19:55,000 --> 00:19:56,000
然后

897
00:19:56,000 --> 00:19:57,000
或者说

898
00:19:57,000 --> 00:19:58,000
呃

899
00:19:58,000 --> 00:19:59,000
函数 convention

900
00:19:59,000 --> 00:20:01,000
当你要掉用那些砍数的时候

901
00:20:01,000 --> 00:20:02,000
你可以

902
00:20:02,000 --> 00:20:04,000
利用自己的 convention

903
00:20:04,000 --> 00:20:04,000
因为

904
00:20:04,000 --> 00:20:07,000
也许他是用下滑线做分合

905
00:20:07,000 --> 00:20:08,000
分格服的

906
00:20:08,000 --> 00:20:09,000
而你喜欢 camel case

907
00:20:09,000 --> 00:20:10,000
那你可以

908
00:20:10,000 --> 00:20:12,000
在你的程序里面写 camel case

909
00:20:12,000 --> 00:20:12,000
呃

910
00:20:12,000 --> 00:20:13,000
呃呃

911
00:20:13,000 --> 00:20:14,000
那个编译期和自己去猜

912
00:20:14,000 --> 00:20:17,000
真正的标识服是什么

913
00:20:17,000 --> 00:20:20,000
就我觉得这是一个很有很有意思的

914
00:20:20,000 --> 00:20:21,000
很有意思的 feature

915
00:20:21,000 --> 00:20:22,000
这是一个恶趣味啊

916
00:20:22,000 --> 00:20:23,000
对

917
00:20:23,000 --> 00:20:24,000
但

918
00:20:24,000 --> 00:20:26,000
可能从另外一个角度讲

919
00:20:26,000 --> 00:20:28,000
他也是在试图解决这样一种

920
00:20:28,000 --> 00:20:30,000
就是呃

921
00:20:30,000 --> 00:20:32,000
你可以再去忽略另外一个细节

922
00:20:32,000 --> 00:20:33,000
就是你不用去

923
00:20:33,000 --> 00:20:36,000
永远去刻意的注意大小写要一致

924
00:20:36,000 --> 00:20:36,000
然后你可以

925
00:20:36,000 --> 00:20:40,000
借用这个 feature 来保证自己的编程风格

926
00:20:40,000 --> 00:20:41,000
在内部是一致

927
00:20:41,000 --> 00:20:42,000
嗯

928
00:20:42,000 --> 00:20:43,000
嗯

929
00:20:43,000 --> 00:20:46,000
说一下这周发生的一些小新闻吧

930
00:20:46,000 --> 00:20:47,000
嗯

931
00:20:47,000 --> 00:20:49,000
然后那个你也看到那个苹果发布会了哈

932
00:20:49,000 --> 00:20:50,000
好呀

933
00:20:50,000 --> 00:20:54,000
那我们之前专门讨论过那个谣传中的新的 MacBook

934
00:20:54,000 --> 00:20:55,000
呃

935
00:20:55,000 --> 00:20:56,000
他其实不是 Air 的

936
00:20:56,000 --> 00:20:57,000
他就是 MacBook

937
00:20:57,000 --> 00:20:58,000
然后

938
00:20:58,000 --> 00:20:59,000
对

939
00:20:59,000 --> 00:21:00,000
其实是很有很有趣的

940
00:21:00,000 --> 00:21:02,000
为什么 MacBook Air 还叫 MacBook Air

941
00:21:02,000 --> 00:21:05,000
然后新的这个更薄更 Air 的还叫

942
00:21:05,000 --> 00:21:06,000
反而叫 MacBook

943
00:21:06,000 --> 00:21:09,000
因为我我后来是这么理解的

944
00:21:09,000 --> 00:21:09,000
就是

945
00:21:09,000 --> 00:21:13,000
因为你有现在就现在那个 MacBook Pro

946
00:21:13,000 --> 00:21:14,000
它也变得很薄了嘛

947
00:21:14,000 --> 00:21:16,000
所以以后就不分

948
00:21:16,000 --> 00:21:17,000
以后这个 Air 就概念了

949
00:21:17,000 --> 00:21:19,000
就薄是一个必然的属性

950
00:21:19,000 --> 00:21:22,000
然后只区分是否专业

951
00:21:22,000 --> 00:21:24,000
所以 MacBook Air 那个产品性可能过几年

952
00:21:24,000 --> 00:21:26,000
过两三年就直接就没有

953
00:21:26,000 --> 00:21:26,000
消失了

954
00:21:26,000 --> 00:21:26,000
OK

955
00:21:26,000 --> 00:21:27,000
对

956
00:21:27,000 --> 00:21:30,000
就只有 MacBook 和 MacBook Pro 这样的两个分野

957
00:21:30,000 --> 00:21:32,000
我觉得这样其实是更清晰的一个结构

958
00:21:32,000 --> 00:21:35,000
然后如果你要比 MacBook 更薄的东西

959
00:21:35,000 --> 00:21:36,000
就只能去买 iPad

960
00:21:36,000 --> 00:21:38,000
对

961
00:21:38,000 --> 00:21:38,000
没错

962
00:21:38,000 --> 00:21:39,000
OK

963
00:21:39,000 --> 00:21:40,000
嗯

964
00:21:40,000 --> 00:21:43,000
可以最最重要的一件事情是

965
00:21:43,000 --> 00:21:45,000
Escape 键没有动

966
00:21:45,000 --> 00:21:46,000
对

967
00:21:46,000 --> 00:21:50,000
我觉得他们也应该是内部顶住了巨大的压力

968
00:21:50,000 --> 00:21:51,000
不

969
00:21:51,000 --> 00:21:53,000
我们先不确定之前那个那个图上面

970
00:21:53,000 --> 00:21:54,000
那个 Escape 键

971
00:21:54,000 --> 00:21:56,000
就是真的有原型机长那样吗

972
00:21:56,000 --> 00:21:58,000
其实是挺值得怀疑的

973
00:21:58,000 --> 00:21:59,000
好吧

974
00:21:59,000 --> 00:22:02,000
说得也是也有可能内部从来没有出现过一个 Escape

975
00:22:02,000 --> 00:22:05,000
在这么让人天怒人怨的地方

976
00:22:05,000 --> 00:22:06,000
对

977
00:22:06,000 --> 00:22:09,000
那个谁画图的时候不小心就画成那样了

978
00:22:09,000 --> 00:22:10,000
对不对

979
00:22:10,000 --> 00:22:10,000
而已

980
00:22:10,000 --> 00:22:14,000
不过不管如何 Escape 键的位置没变

981
00:22:14,000 --> 00:22:15,000
而且还变大了

982
00:22:15,000 --> 00:22:16,000
这个是挺好的一件事

983
00:22:16,000 --> 00:22:19,000
因为你用过那个 11 寸的 MacBook Air 吗

984
00:22:19,000 --> 00:22:20,000
嗯

985
00:22:20,000 --> 00:22:21,000
用过一次

986
00:22:21,000 --> 00:22:25,000
就是我有一次借前公司的老板的那个办公电脑

987
00:22:25,000 --> 00:22:26,000
出过一次拆

988
00:22:26,000 --> 00:22:29,000
你们公司已经这么惨

989
00:22:29,000 --> 00:22:30,000
还要借老板的电脑出餐

990
00:22:30,000 --> 00:22:32,000
因为我自己的电脑太大了

991
00:22:32,000 --> 00:22:32,000
听起来好心酸

992
00:22:32,000 --> 00:22:33,000
太重

993
00:22:33,000 --> 00:22:33,000
OK

994
00:22:33,000 --> 00:22:37,000
我觉得我不是很喜欢 MacBook Air

995
00:22:37,000 --> 00:22:37,000
就

996
00:22:37,000 --> 00:22:39,000
当然可能主要也是因为

997
00:22:39,000 --> 00:22:41,000
就是屏幕实在是太小了

998
00:22:41,000 --> 00:22:42,000
11 寸的确实是很小

999
00:22:42,000 --> 00:22:44,000
13 寸的还是很小

1000
00:22:44,000 --> 00:22:44,000
我觉得

1001
00:22:44,000 --> 00:22:46,000
它边框也比较大了

1002
00:22:46,000 --> 00:22:47,000
对

1003
00:22:47,000 --> 00:22:49,000
所以你会觉得挺糟糕的

1004
00:22:49,000 --> 00:22:50,000
呃

1005
00:22:50,000 --> 00:22:52,000
特别是 11 寸那个 Escape 键特别小

1006
00:22:52,000 --> 00:22:54,000
因为它那个半高

1007
00:22:54,000 --> 00:22:56,000
不三分之一高的那个键吧

1008
00:22:56,000 --> 00:22:57,000
呃

1009
00:22:57,000 --> 00:22:58,000
然后而且还那么小一坨

1010
00:22:58,000 --> 00:23:02,000
然后现在那个 MacBook 上这个 Escape 键变得很长嘛

1011
00:23:02,000 --> 00:23:05,000
然后我们作为一个 VIM 党

1012
00:23:05,000 --> 00:23:05,000
这件事是什么

1013
00:23:05,000 --> 00:23:07,000
福音啊

1014
00:23:07,000 --> 00:23:08,000
对

1015
00:23:08,000 --> 00:23:09,000
所以

1016
00:23:09,000 --> 00:23:10,000
所以你是要买一台

1017
00:23:10,000 --> 00:23:13,000
如果听上次 IT 公论的

1018
00:23:13,000 --> 00:23:14,000
印象没错

1019
00:23:14,000 --> 00:23:15,000
OK

1020
00:23:15,000 --> 00:23:16,000
嗯

1021
00:23:16,000 --> 00:23:18,000
因为我老婆那条他要换嘛

1022
00:23:18,000 --> 00:23:19,000
他给他买一台顺便

1023
00:23:19,000 --> 00:23:19,000
我玩一下

1024
00:23:19,000 --> 00:23:20,000
到时候

1025
00:23:20,000 --> 00:23:21,000
假设我要出门

1026
00:23:21,000 --> 00:23:22,000
做些什么事情

1027
00:23:22,000 --> 00:23:23,000
我就拿他那台去好了

1028
00:23:23,000 --> 00:23:24,000
OK

1029
00:23:24,000 --> 00:23:28,000
这就是顺便玩一下的意思就是

1030
00:23:28,000 --> 00:23:30,000
80%的时间是你在用

1031
00:23:30,000 --> 00:23:31,000
没有没有

1032
00:23:31,000 --> 00:23:32,000
那个性能不太够吧

1033
00:23:32,000 --> 00:23:33,000
它那个最高

1034
00:23:33,000 --> 00:23:36,000
就内存是固定的 8 G 不能再扩张了

1035
00:23:36,000 --> 00:23:36,000
对

1036
00:23:36,000 --> 00:23:37,000
这是比较一个蛋疼一点

1037
00:23:37,000 --> 00:23:39,000
8 G 真的不是很高

1038
00:23:39,000 --> 00:23:40,000
对

1039
00:23:40,000 --> 00:23:41,000
因为这件事情

1040
00:23:41,000 --> 00:23:43,000
其实还是挺麻烦的

1041
00:23:43,000 --> 00:23:44,000
现在你看一下

1042
00:23:44,000 --> 00:23:46,000
我们跑了很多软件的

1043
00:23:46,000 --> 00:23:47,000
特别是 64 位之后

1044
00:23:47,000 --> 00:23:49,000
那些很多软件的体积是

1045
00:23:49,000 --> 00:23:50,000
就越来越大了

1046
00:23:50,000 --> 00:23:52,000
而且现在开个网页

1047
00:23:52,000 --> 00:23:53,000
动不动就几百

1048
00:23:53,000 --> 00:23:54,000
一个 type 就几百

1049
00:23:54,000 --> 00:23:55,000
照上一个 G 的

1050
00:23:55,000 --> 00:23:57,000
所以还是 8 G

1051
00:23:57,000 --> 00:23:59,000
你要再开虚拟机的话

1052
00:23:59,000 --> 00:24:00,000
就肯定是不太

1053
00:24:00,000 --> 00:24:01,000
有点捉襟见肘吧

1054
00:24:01,000 --> 00:24:02,000
至少

1055
00:24:02,000 --> 00:24:02,000
对

1056
00:24:02,000 --> 00:24:06,000
你那台是 16 的吗

1057
00:24:06,000 --> 00:24:07,000
我现在这台是 16

1058
00:24:07,000 --> 00:24:08,000
对

1059
00:24:08,000 --> 00:24:08,000
OK

1060
00:24:08,000 --> 00:24:09,000
我也是 16 的

1061
00:24:09,000 --> 00:24:11,000
就是现在就作为一个开发者的话

1062
00:24:11,000 --> 00:24:14,000
可能还是要 16 才至少够吧

1063
00:24:14,000 --> 00:24:16,000
当然现在可能主要瓶领

1064
00:24:16,000 --> 00:24:18,000
不是在内存上面

1065
00:24:18,000 --> 00:24:20,000
就有时候跑一些比较大的游戏

1066
00:24:20,000 --> 00:24:22,000
会风扇狂转

1067
00:24:22,000 --> 00:24:23,000
它肯定没有风扇来

1068
00:24:23,000 --> 00:24:25,000
不是内存的问题

1069
00:24:25,000 --> 00:24:25,000
对

1070
00:24:25,000 --> 00:24:26,000
我是说我现在这台

1071
00:24:26,000 --> 00:24:27,000
OK

1072
00:24:27,000 --> 00:24:29,000
如果买新的 MacBook

1073
00:24:29,000 --> 00:24:31,000
应该就很多游戏又不能玩了

1074
00:24:31,000 --> 00:24:32,000
不知道

1075
00:24:32,000 --> 00:24:34,000
它那款性能现在还没出来

1076
00:24:34,000 --> 00:24:35,000
昨天我看了一下

1077
00:24:35,000 --> 00:24:37,000
那个有网上有测评

1078
00:24:37,000 --> 00:24:39,000
联想出了一款

1079
00:24:39,000 --> 00:24:40,000
就出了一款那个

1080
00:24:40,000 --> 00:24:41,000
就那个什么

1081
00:24:41,000 --> 00:24:43,000
它那种联想不是有个本

1082
00:24:43,000 --> 00:24:45,000
它可以变成平板用的那种笔记本

1083
00:24:45,000 --> 00:24:46,000
就是我本来的

1084
00:24:46,000 --> 00:24:47,000
Convert

1085
00:24:47,000 --> 00:24:49,000
Tablet 之类的

1086
00:24:49,000 --> 00:24:50,000
它用的那个处理器

1087
00:24:50,000 --> 00:24:52,000
我看了一下性能和那个参数

1088
00:24:52,000 --> 00:24:53,000
应该是和

1089
00:24:53,000 --> 00:24:56,000
其实新款的 MacBook 里面

1090
00:24:56,000 --> 00:24:57,000
那款是差不多的

1091
00:24:57,000 --> 00:24:58,000
我看了一下

1092
00:24:58,000 --> 00:24:59,000
它在测评的性能

1093
00:24:59,000 --> 00:25:02,000
其实跟 14 款的 MacBook Air

1094
00:25:02,000 --> 00:25:03,000
是差不多的

1095
00:25:03,000 --> 00:25:04,000
我觉得还凑合了

1096
00:25:04,000 --> 00:25:06,000
就其实很多时候已经够用了

1097
00:25:06,000 --> 00:25:09,000
就只要你不是经常要编译什么

1098
00:25:09,000 --> 00:25:11,000
编译 Swift 的代码的话

1099
00:25:11,000 --> 00:25:13,000
你只是做一些

1100
00:25:13,000 --> 00:25:14,000
比如说像我用 Go 的话

1101
00:25:14,000 --> 00:25:15,000
就编译很快

1102
00:25:15,000 --> 00:25:16,000
就无所谓

1103
00:25:16,000 --> 00:25:17,000
然后你说做 Web 开发

1104
00:25:17,000 --> 00:25:18,000
都是动态语言

1105
00:25:18,000 --> 00:25:19,000
没有这个编译过程

1106
00:25:19,000 --> 00:25:20,000
那也无所谓

1107
00:25:20,000 --> 00:25:22,000
所以我觉得性能可能

1108
00:25:22,000 --> 00:25:23,000
对大多数情况下

1109
00:25:23,000 --> 00:25:25,000
也是也是凑合够了

1110
00:25:25,000 --> 00:25:27,000
好吧

1111
00:25:27,000 --> 00:25:29,000
我觉得可能做 iOS 开发

1112
00:25:29,000 --> 00:25:30,000
还是有点够强

1113
00:25:30,000 --> 00:25:32,000
屏幕太小了吗

1114
00:25:32,000 --> 00:25:36,000
我觉得 iOS 开发

1115
00:25:36,000 --> 00:25:37,000
跑那个模拟器的时候

1116
00:25:37,000 --> 00:25:39,000
其实还是挺费的

1117
00:25:39,000 --> 00:25:40,000
对

1118
00:25:40,000 --> 00:25:41,000
没错

1119
00:25:41,000 --> 00:25:42,000
而且他们现在不是说这个事吗

1120
00:25:42,000 --> 00:25:45,000
就是因为现在不是所有的 iOS

1121
00:25:45,000 --> 00:25:46,000
就是所谓的 retina 分辨率

1122
00:25:46,000 --> 00:25:47,000
就两倍的

1123
00:25:47,000 --> 00:25:49,000
那么你要在屏幕上

1124
00:25:49,000 --> 00:25:51,000
真实还原 1 比 1 的话

1125
00:25:51,000 --> 00:25:52,000
你的屏幕要比那个大

1126
00:25:52,000 --> 00:25:53,000
对

1127
00:25:53,000 --> 00:25:54,000
现在如果你屏幕那么小的话

1128
00:25:54,000 --> 00:25:56,000
就没有办法很好的还原

1129
00:25:56,000 --> 00:25:57,000
它就装不

1130
00:25:57,000 --> 00:25:58,000
模拟器装不下

1131
00:25:58,000 --> 00:25:58,000
你只能缩放

1132
00:25:58,000 --> 00:26:00,000
就不是太好

1133
00:26:00,000 --> 00:26:00,000
对

1134
00:26:00,000 --> 00:26:01,000
但是我相信

1135
00:26:01,000 --> 00:26:02,000
现在也有很多开发者

1136
00:26:02,000 --> 00:26:03,000
就是他

1137
00:26:03,000 --> 00:26:04,000
如果他真的要跑的话

1138
00:26:04,000 --> 00:26:05,000
他就不在模拟器上跑

1139
00:26:05,000 --> 00:26:06,000
直接接射

1140
00:26:06,000 --> 00:26:07,000
直接上针机吗

1141
00:26:07,000 --> 00:26:08,000
对

1142
00:26:08,000 --> 00:26:08,000
也是

1143
00:26:08,000 --> 00:26:11,000
那个传输好像还是比较

1144
00:26:11,000 --> 00:26:11,000
就是你那个

1145
00:26:11,000 --> 00:26:13,000
就是那个 cycle 还是比较长

1146
00:26:13,000 --> 00:26:14,000
你要传到那个

1147
00:26:14,000 --> 00:26:16,000
iOS 上去

1148
00:26:16,000 --> 00:26:17,000
然后你要马上看结果

1149
00:26:17,000 --> 00:26:18,000
中间还是要等那么

1150
00:26:18,000 --> 00:26:19,000
可能一两分钟吧

1151
00:26:19,000 --> 00:26:20,000
我估计

1152
00:26:20,000 --> 00:26:24,000
我的经历还好吧

1153
00:26:24,000 --> 00:26:25,000
我觉得就可能要比

1154
00:26:25,000 --> 00:26:27,000
在虚拟机里面

1155
00:26:27,000 --> 00:26:28,000
快的

1156
00:26:28,000 --> 00:26:29,000
慢的吗

1157
00:26:29,000 --> 00:26:31,000
最多 20 秒吧

1158
00:26:31,000 --> 00:26:33,000
我觉得还是可以忍受的

1159
00:26:33,000 --> 00:26:36,000
那也是很大的这个损耗了呀

1160
00:26:36,000 --> 00:26:38,000
不但到你到后期的时候

1161
00:26:38,000 --> 00:26:41,000
我觉得大部分人可能会

1162
00:26:41,000 --> 00:26:44,000
就怎么说呢

1163
00:26:44,000 --> 00:26:44,000
就回到那个

1164
00:26:44,000 --> 00:26:46,000
回到我们之前讨论的

1165
00:26:46,000 --> 00:26:47,000
Ripple

1166
00:26:47,000 --> 00:26:48,000
在没有 Ripple 时代

1167
00:26:48,000 --> 00:26:49,000
你可能要用头脑去模拟

1168
00:26:49,000 --> 00:26:51,000
那个机器

1169
00:26:51,000 --> 00:26:52,000
跑出来的

1170
00:26:52,000 --> 00:26:53,000
什么样子里面想

1171
00:26:53,000 --> 00:26:53,000
是不是

1172
00:26:53,000 --> 00:26:54,000
对

1173
00:26:54,000 --> 00:26:55,000
我觉得到后期

1174
00:26:55,000 --> 00:26:55,000
iOS 开发

1175
00:26:55,000 --> 00:26:56,000
其实很多人都是

1176
00:26:56,000 --> 00:27:02,000
会花相对长的时间在写

1177
00:27:02,000 --> 00:27:04,000
然后真正看效果的时间

1178
00:27:04,000 --> 00:27:07,000
可能只有开发时间的 10%不到

1179
00:27:07,000 --> 00:27:09,000
但除非你在

1180
00:27:09,000 --> 00:27:10,000
但除非你在 Bbug

1181
00:27:10,000 --> 00:27:10,000
Bbug 的话

1182
00:27:10,000 --> 00:27:12,000
那就是那要另说

1183
00:27:12,000 --> 00:27:14,000
对

1184
00:27:14,000 --> 00:27:15,000
没错

1185
00:27:15,000 --> 00:27:15,000
对

1186
00:27:15,000 --> 00:27:18,000
这个新款的本

1187
00:27:18,000 --> 00:27:20,000
还有一个挺大的事

1188
00:27:20,000 --> 00:27:22,000
是它那个键盘的轴不一样了

1189
00:27:22,000 --> 00:27:23,000
对

1190
00:27:23,000 --> 00:27:23,000
蝴蝶轴

1191
00:27:23,000 --> 00:27:24,000
蝴蝶轴

1192
00:27:24,000 --> 00:27:24,000
什么概念

1193
00:27:24,000 --> 00:27:25,000
你有概念吗

1194
00:27:25,000 --> 00:27:28,000
我其实也没有很看懂

1195
00:27:28,000 --> 00:27:29,000
这个蝴蝶轴

1196
00:27:29,000 --> 00:27:32,000
它是这次才新发明

1197
00:27:32,000 --> 00:27:34,000
之前是没有这种机制的是吧

1198
00:27:34,000 --> 00:27:34,000
就没有

1199
00:27:34,000 --> 00:27:35,000
之前是只有剪刀脚的

1200
00:27:35,000 --> 00:27:36,000
对吧

1201
00:27:36,000 --> 00:27:37,000
我说英国上

1202
00:27:37,000 --> 00:27:38,000
就在其他人

1203
00:27:38,000 --> 00:27:38,000
有用过这种

1204
00:27:38,000 --> 00:27:39,000
所谓蝴蝶轴

1205
00:27:39,000 --> 00:27:40,000
从来没有

1206
00:27:40,000 --> 00:27:41,000
从来没有键盘

1207
00:27:41,000 --> 00:27:42,000
因为我看他说的

1208
00:27:42,000 --> 00:27:43,000
应该是他们自己

1209
00:27:43,000 --> 00:27:44,000
新发明的一种

1210
00:27:44,000 --> 00:27:47,000
一种那个键盘轴的机制吧

1211
00:27:47,000 --> 00:27:48,000
对

1212
00:27:48,000 --> 00:27:49,000
然后他说

1213
00:27:49,000 --> 00:27:49,000
这个有个好处

1214
00:27:49,000 --> 00:27:50,000
就是说剪刀脚

1215
00:27:50,000 --> 00:27:50,000
有个问题

1216
00:27:50,000 --> 00:27:51,000
就是说如果你

1217
00:27:51,000 --> 00:27:52,000
它会不平稳嘛

1218
00:27:52,000 --> 00:27:53,000
就是你说你

1219
00:27:53,000 --> 00:27:55,000
你按一个键的一个角落

1220
00:27:55,000 --> 00:27:57,000
它会斜着下去

1221
00:27:57,000 --> 00:27:58,000
有时候会触发不到

1222
00:27:58,000 --> 00:27:59,000
对

1223
00:27:59,000 --> 00:28:00,000
虽然我自己从来

1224
00:28:00,000 --> 00:28:01,000
没有意识到这种情况

1225
00:28:01,000 --> 00:28:02,000
但是我不知道

1226
00:28:02,000 --> 00:28:03,000
这个是很常见的现象吗

1227
00:28:03,000 --> 00:28:04,000
还是怎样

1228
00:28:04,000 --> 00:28:05,000
就是你

1229
00:28:05,000 --> 00:28:08,000
你在按苹果的键盘上

1230
00:28:08,000 --> 00:28:08,000
一个键的时候

1231
00:28:08,000 --> 00:28:09,000
你会明显感觉到

1232
00:28:09,000 --> 00:28:10,000
你按的时候

1233
00:28:10,000 --> 00:28:11,000
那个键是随着

1234
00:28:11,000 --> 00:28:12,000
你按的那一角

1235
00:28:12,000 --> 00:28:13,000
先开始下线

1236
00:28:13,000 --> 00:28:14,000
然后其他部分一起

1237
00:28:14,000 --> 00:28:16,000
才跟着下线的

1238
00:28:16,000 --> 00:28:17,000
但是不应该

1239
00:28:17,000 --> 00:28:18,000
你按那个键的中心位置吗

1240
00:28:18,000 --> 00:28:19,000
你为什么会按

1241
00:28:19,000 --> 00:28:21,000
那个边角呢

1242
00:28:21,000 --> 00:28:24,000
我倒是觉得

1243
00:28:24,000 --> 00:28:25,000
在大部分时候

1244
00:28:25,000 --> 00:28:25,000
你是不可能

1245
00:28:25,000 --> 00:28:28,000
就正儿八经

1246
00:28:28,000 --> 00:28:29,000
按到它的中心位置

1247
00:28:29,000 --> 00:28:29,000
这样

1248
00:28:29,000 --> 00:28:30,000
OK

1249
00:28:30,000 --> 00:28:30,000
对我

1250
00:28:30,000 --> 00:28:31,000
因为我自己

1251
00:28:31,000 --> 00:28:32,000
从来没有留意到

1252
00:28:32,000 --> 00:28:34,000
我有发出现过这种

1253
00:28:34,000 --> 00:28:36,000
因为按到

1254
00:28:36,000 --> 00:28:37,000
那个剪刀脚

1255
00:28:37,000 --> 00:28:38,000
那么我一个边

1256
00:28:38,000 --> 00:28:39,000
而不是中心位置

1257
00:28:39,000 --> 00:28:40,000
出发不了的情况

1258
00:28:40,000 --> 00:28:41,000
所以我还挺好奇

1259
00:28:41,000 --> 00:28:42,000
他在发布会说

1260
00:28:42,000 --> 00:28:44,000
出发不了是肯定不会的

1261
00:28:44,000 --> 00:28:44,000
但是

1262
00:28:44,000 --> 00:28:45,000
剪刀脚

1263
00:28:45,000 --> 00:28:47,000
所造成的问题就是

1264
00:28:47,000 --> 00:28:48,000
你

1265
00:28:48,000 --> 00:28:50,000
按那个键的时候

1266
00:28:50,000 --> 00:28:51,000
你会觉得键

1267
00:28:51,000 --> 00:28:52,000
怎么说呢

1268
00:28:52,000 --> 00:28:53,000
我觉得这个区别是

1269
00:28:53,000 --> 00:28:54,000
只有你在按上去的时候

1270
00:28:54,000 --> 00:28:55,000
才会

1271
00:28:55,000 --> 00:28:56,000
感觉到的

1272
00:28:56,000 --> 00:28:57,000
就是

1273
00:28:57,000 --> 00:28:58,000
你按一个

1274
00:28:58,000 --> 00:28:58,000
比如说

1275
00:28:58,000 --> 00:28:59,000
我在

1276
00:28:59,000 --> 00:29:00,000
我在按

1277
00:29:00,000 --> 00:29:01,000
那个

1278
00:29:01,000 --> 00:29:02,000
HHKB 的时候

1279
00:29:02,000 --> 00:29:03,000
按一个键

1280
00:29:03,000 --> 00:29:04,000
这个键是

1281
00:29:04,000 --> 00:29:06,000
本身是不会晃动的

1282
00:29:06,000 --> 00:29:06,000
对吧

1283
00:29:06,000 --> 00:29:07,000
就是

1284
00:29:07,000 --> 00:29:10,000
我按这个键的最左上角

1285
00:29:10,000 --> 00:29:10,000
整个键会

1286
00:29:10,000 --> 00:29:11,000
随着我的手指

1287
00:29:11,000 --> 00:29:12,000
一起下线

1288
00:29:12,000 --> 00:29:13,000
但是你在按一个

1289
00:29:13,000 --> 00:29:15,000
剪刀脚的时候

1290
00:29:15,000 --> 00:29:16,000
那个键的左上角

1291
00:29:16,000 --> 00:29:17,000
会先下线

1292
00:29:17,000 --> 00:29:18,000
然后其他部分

1293
00:29:18,000 --> 00:29:19,000
才跟着下线

1294
00:29:19,000 --> 00:29:20,000
没错

1295
00:29:20,000 --> 00:29:21,000
是这样的

1296
00:29:21,000 --> 00:29:21,000
就这个键

1297
00:29:21,000 --> 00:29:22,000
会有一定的

1298
00:29:22,000 --> 00:29:23,000
所谓

1299
00:29:23,000 --> 00:29:24,000
摇晃

1300
00:29:24,000 --> 00:29:25,000
对吧

1301
00:29:25,000 --> 00:29:25,000
对

1302
00:29:25,000 --> 00:29:26,000
wobbling space

1303
00:29:26,000 --> 00:29:28,000
就是它会有一种

1304
00:29:28,000 --> 00:29:29,000
不稳的感觉

1305
00:29:29,000 --> 00:29:29,000
但是

1306
00:29:29,000 --> 00:29:30,000
但是我相信

1307
00:29:30,000 --> 00:29:31,000
它

1308
00:29:31,000 --> 00:29:31,000
虎蝶脚

1309
00:29:31,000 --> 00:29:32,000
所要解决的问题

1310
00:29:32,000 --> 00:29:33,000
就是你不会再有

1311
00:29:33,000 --> 00:29:34,000
这种感觉

1312
00:29:34,000 --> 00:29:35,000
这个键就是实的

1313
00:29:35,000 --> 00:29:36,000
然后你按下去一点

1314
00:29:36,000 --> 00:29:36,000
整个键会

1315
00:29:36,000 --> 00:29:38,000
跟着一起下线

1316
00:29:38,000 --> 00:29:40,000
他们那个

1317
00:29:40,000 --> 00:29:41,000
现场去测

1318
00:29:41,000 --> 00:29:42,000
就是试用过那款

1319
00:29:42,000 --> 00:29:43,000
新的 MacBook 的

1320
00:29:43,000 --> 00:29:44,000
那个键盘的时候

1321
00:29:44,000 --> 00:29:45,000
都说那个键程

1322
00:29:45,000 --> 00:29:46,000
非常非常短嘛

1323
00:29:46,000 --> 00:29:47,000
因为它那个

1324
00:29:47,000 --> 00:29:48,000
整个厚度降低了

1325
00:29:48,000 --> 00:29:49,000
而且它这个

1326
00:29:49,000 --> 00:29:50,000
蝴蝶轴的

1327
00:29:50,000 --> 00:29:51,000
这个本来的

1328
00:29:51,000 --> 00:29:52,000
一个设计出动

1329
00:29:52,000 --> 00:29:53,000
就是为了减低

1330
00:29:53,000 --> 00:29:54,000
这个厚度嘛

1331
00:29:54,000 --> 00:29:54,000
对吧

1332
00:29:54,000 --> 00:29:54,000
高度

1333
00:29:54,000 --> 00:29:56,000
那我不太清楚

1334
00:29:56,000 --> 00:29:57,000
这种键程

1335
00:29:57,000 --> 00:29:58,000
极短的情况下

1336
00:29:58,000 --> 00:29:59,000
对编程的时候的

1337
00:29:59,000 --> 00:30:01,000
打字的手感

1338
00:30:01,000 --> 00:30:01,000
会有什么

1339
00:30:01,000 --> 00:30:02,000
变化

1340
00:30:02,000 --> 00:30:05,000
你喜欢长键程

1341
00:30:05,000 --> 00:30:06,000
还是短键程的按键

1342
00:30:06,000 --> 00:30:07,000
那个键盘

1343
00:30:07,000 --> 00:30:11,000
其实我不怎么挑

1344
00:30:11,000 --> 00:30:11,000
但我觉得

1345
00:30:11,000 --> 00:30:12,000
不挑

1346
00:30:12,000 --> 00:30:13,000
对

1347
00:30:13,000 --> 00:30:14,000
但我觉得就是

1348
00:30:14,000 --> 00:30:16,000
在用触摸板的时候

1349
00:30:16,000 --> 00:30:18,000
你可以理解为

1350
00:30:18,000 --> 00:30:19,000
这个键程是零

1351
00:30:19,000 --> 00:30:19,000
对吧

1352
00:30:19,000 --> 00:30:20,000
那

1353
00:30:20,000 --> 00:30:23,000
我不知道就是

1354
00:30:23,000 --> 00:30:24,000
也许在配了

1355
00:30:24,000 --> 00:30:25,000
触摸板的

1356
00:30:25,000 --> 00:30:27,000
笔记本电脑上

1357
00:30:27,000 --> 00:30:28,000
按一个键程

1358
00:30:28,000 --> 00:30:29,000
比较短的键

1359
00:30:29,000 --> 00:30:32,000
其感觉

1360
00:30:32,000 --> 00:30:33,000
是不是至少

1361
00:30:33,000 --> 00:30:34,000
要比 iPad 好了

1362
00:30:34,000 --> 00:30:35,000
就是

1363
00:30:35,000 --> 00:30:36,000
你至少是

1364
00:30:36,000 --> 00:30:37,000
有一点点键程的

1365
00:30:37,000 --> 00:30:38,000
你在 iPad 上

1366
00:30:38,000 --> 00:30:38,000
iPad 上

1367
00:30:38,000 --> 00:30:39,000
因为那个

1368
00:30:39,000 --> 00:30:40,000
虚拟键盘的时候

1369
00:30:40,000 --> 00:30:41,000
手感是非常差的

1370
00:30:41,000 --> 00:30:41,000
对吧

1371
00:30:41,000 --> 00:30:42,000
那虚拟键盘

1372
00:30:42,000 --> 00:30:43,000
手感差

1373
00:30:43,000 --> 00:30:44,000
一个主要是

1374
00:30:44,000 --> 00:30:44,000
有几个原因

1375
00:30:44,000 --> 00:30:45,000
不光是

1376
00:30:45,000 --> 00:30:46,000
它没有键程

1377
00:30:46,000 --> 00:30:46,000
因为主要是

1378
00:30:46,000 --> 00:30:48,000
一个是没有触觉的

1379
00:30:48,000 --> 00:30:48,000
分隔

1380
00:30:48,000 --> 00:30:49,000
你不知道

1381
00:30:49,000 --> 00:30:50,000
你按了哪个键了

1382
00:30:50,000 --> 00:30:51,000
你如果不看的话

1383
00:30:51,000 --> 00:30:51,000
对

1384
00:30:51,000 --> 00:30:52,000
就是因为零键程

1385
00:30:52,000 --> 00:30:53,000
所以才没有分隔

1386
00:30:53,000 --> 00:30:54,000
不是吗

1387
00:30:54,000 --> 00:30:54,000
就是我的意思

1388
00:30:54,000 --> 00:30:56,000
这两个其实是一回事

1389
00:30:56,000 --> 00:30:58,000
你说

1390
00:30:58,000 --> 00:30:59,000
这没有突出

1391
00:30:59,000 --> 00:31:01,000
然后也没有下线

1392
00:31:01,000 --> 00:31:01,000
对

1393
00:31:01,000 --> 00:31:03,000
就算是零键程的话

1394
00:31:03,000 --> 00:31:04,000
它也是可以有分隔的

1395
00:31:04,000 --> 00:31:05,000
就是

1396
00:31:05,000 --> 00:31:07,000
我不知道你有没有用过

1397
00:31:07,000 --> 00:31:09,000
微软那个 Surface

1398
00:31:09,000 --> 00:31:10,000
它不是有两款键盘吗

1399
00:31:10,000 --> 00:31:12,000
一款是所谓的

1400
00:31:12,000 --> 00:31:13,000
叫什么

1401
00:31:13,000 --> 00:31:14,000
Touch Cover

1402
00:31:14,000 --> 00:31:15,000
对

1403
00:31:15,000 --> 00:31:16,000
就是那个多么键盘

1404
00:31:16,000 --> 00:31:18,000
它不是一个

1405
00:31:18,000 --> 00:31:19,000
就是他们

1406
00:31:19,000 --> 00:31:21,000
那个就是有分隔

1407
00:31:21,000 --> 00:31:22,000
但是无键程的一个键盘

1408
00:31:22,000 --> 00:31:23,000
就你其实按的是一个

1409
00:31:23,000 --> 00:31:24,000
对

1410
00:31:24,000 --> 00:31:25,000
是一个平板

1411
00:31:25,000 --> 00:31:26,000
然后它也有一款

1412
00:31:26,000 --> 00:31:27,000
叫做 Type Cover

1413
00:31:27,000 --> 00:31:28,000
我记得

1414
00:31:28,000 --> 00:31:29,000
然后我是用过

1415
00:31:29,000 --> 00:31:30,000
那个键程也蛮短的

1416
00:31:30,000 --> 00:31:32,000
然后我两款都试了一下

1417
00:31:32,000 --> 00:31:34,000
都感觉不是很好

1418
00:31:34,000 --> 00:31:35,000
就键程短

1419
00:31:35,000 --> 00:31:36,000
这件事情本身是

1420
00:31:36,000 --> 00:31:37,000
不是太好的

1421
00:31:37,000 --> 00:31:38,000
就一切情况相同的情况下

1422
00:31:38,000 --> 00:31:39,000
OK

1423
00:31:39,000 --> 00:31:42,000
因为你就没有办法

1424
00:31:42,000 --> 00:31:45,000
就有时候你可能会觉得不确定

1425
00:31:45,000 --> 00:31:45,000
你就按下去

1426
00:31:45,000 --> 00:31:45,000
没有

1427
00:31:45,000 --> 00:31:47,000
我觉得可能会这样

1428
00:31:47,000 --> 00:31:47,000
会是这个原因

1429
00:31:47,000 --> 00:31:49,000
但是他们说

1430
00:31:49,000 --> 00:31:51,000
这个蝴蝶轴的

1431
00:31:51,000 --> 00:31:52,000
这个有些其他的好处

1432
00:31:52,000 --> 00:31:54,000
比如说它不会左右乱晃

1433
00:31:54,000 --> 00:31:56,000
然后它这个打字也很

1434
00:31:56,000 --> 00:31:57,000
就是

1435
00:31:57,000 --> 00:32:01,000
他们说那个手感挺特别的

1436
00:32:01,000 --> 00:32:02,000
我现在也没有打过

1437
00:32:02,000 --> 00:32:03,000
我不知道到底是个什么手感

1438
00:32:03,000 --> 00:32:04,000
我想很想去试一下

1439
00:32:04,000 --> 00:32:06,000
但我又在想

1440
00:32:06,000 --> 00:32:07,000
其实键程短

1441
00:32:07,000 --> 00:32:10,000
反而不是应该能帮助你

1442
00:32:10,000 --> 00:32:11,000
长时间打字吗

1443
00:32:11,000 --> 00:32:13,000
这样用力会比较小

1444
00:32:13,000 --> 00:32:13,000
是不是

1445
00:32:13,000 --> 00:32:16,000
这个我觉得

1446
00:32:16,000 --> 00:32:19,000
可能最终省下来的力

1447
00:32:19,000 --> 00:32:20,000
也只有一点点

1448
00:32:20,000 --> 00:32:21,000
一牛

1449
00:32:21,000 --> 00:32:22,000
打了一只天

1450
00:32:22,000 --> 00:32:24,000
省了一牛的力

1451
00:32:24,000 --> 00:32:27,000
对

1452
00:32:27,000 --> 00:32:28,000
我觉得这个建成

1453
00:32:28,000 --> 00:32:29,000
可能更多带来的

1454
00:32:29,000 --> 00:32:32,000
还是触觉触感上的

1455
00:32:32,000 --> 00:32:34,000
而真正的省力什么的

1456
00:32:34,000 --> 00:32:37,000
都是非常浮云的东西

1457
00:32:37,000 --> 00:32:39,000
反过来说

1458
00:32:39,000 --> 00:32:40,000
你可能你会觉得

1459
00:32:40,000 --> 00:32:43,000
也许是喜欢长建成的人

1460
00:32:43,000 --> 00:32:44,000
可以去用一个

1461
00:32:44,000 --> 00:32:46,000
就前两天在推特上看到的

1462
00:32:46,000 --> 00:32:48,000
USB typewriter

1463
00:32:48,000 --> 00:32:51,000
打字机转 USB 的接口

1464
00:32:51,000 --> 00:32:52,000
然后接电脑上打

1465
00:32:52,000 --> 00:32:52,000
对

1466
00:32:52,000 --> 00:32:53,000
我觉得这个

1467
00:32:53,000 --> 00:32:54,000
这个实际上太怀旧了

1468
00:32:54,000 --> 00:32:55,000
就是你可以去

1469
00:32:55,000 --> 00:32:56,000
你可以选择

1470
00:32:56,000 --> 00:32:58,000
直接从网站上买一台

1471
00:32:58,000 --> 00:33:00,000
已经转化好的 typewriter

1472
00:33:00,000 --> 00:33:02,000
就是它是货真价实的打字机

1473
00:33:02,000 --> 00:33:04,000
然后你可以把这个打字机

1474
00:33:04,000 --> 00:33:05,000
机械式来接

1475
00:33:05,000 --> 00:33:05,000
对

1476
00:33:05,000 --> 00:33:06,000
机械式的打字机

1477
00:33:06,000 --> 00:33:09,000
接到你的 USB 口上

1478
00:33:09,000 --> 00:33:11,000
然后把打字机当中键盘来用

1479
00:33:11,000 --> 00:33:12,000
它那个原理是什么

1480
00:33:12,000 --> 00:33:15,000
它是探测那个机械件的位移

1481
00:33:15,000 --> 00:33:17,000
然后转成 USB 电信号吗

1482
00:33:17,000 --> 00:33:18,000
对

1483
00:33:18,000 --> 00:33:20,000
其实就是如果你去看它的那个

1484
00:33:20,000 --> 00:33:22,000
converter kit 的话

1485
00:33:22,000 --> 00:33:25,000
那个就是如果你直接从网站上买的

1486
00:33:25,000 --> 00:33:25,000
比较贵

1487
00:33:25,000 --> 00:33:27,000
可能要 599 还是 699 美元

1488
00:33:27,000 --> 00:33:28,000
一台

1489
00:33:28,000 --> 00:33:30,000
但你可以买另外一个 kit

1490
00:33:30,000 --> 00:33:31,000
这 kit 就是 99 美元

1491
00:33:31,000 --> 00:33:33,000
然后里面有一大堆触版

1492
00:33:33,000 --> 00:33:34,000
就是一个比较长条

1493
00:33:34,000 --> 00:33:36,000
像书子一样的东西

1494
00:33:36,000 --> 00:33:38,000
和一个很小的

1495
00:33:38,000 --> 00:33:39,000
应该不是阿罗伊

1496
00:33:39,000 --> 00:33:41,000
是一个他们自己做的一个 IC 版

1497
00:33:41,000 --> 00:33:43,000
你把那个长条的梳子一样的

1498
00:33:43,000 --> 00:33:45,000
背板贴到

1499
00:33:45,000 --> 00:33:48,000
机械打字机的后面

1500
00:33:48,000 --> 00:33:52,000
然后再把那个 IC 电路

1501
00:33:52,000 --> 00:33:54,000
塞在打字机的内部

1502
00:33:54,000 --> 00:33:59,000
然后你就可以把它转化成一个 USB 打字机了

1503
00:33:59,000 --> 00:34:00,000
就其实它就是去探测

1504
00:34:00,000 --> 00:34:03,000
因为你在按下一个打字机上面键的时候

1505
00:34:03,000 --> 00:34:05,000
它后面会有一个东西抬起来

1506
00:34:05,000 --> 00:34:09,000
然后它就感应哪个键抬起来

1507
00:34:09,000 --> 00:34:12,000
然后把它转化为键板

1508
00:34:12,000 --> 00:34:14,000
对应的那个键按键

1509
00:34:14,000 --> 00:34:15,000
这也是

1510
00:34:15,000 --> 00:34:17,000
但其实那个很累的嘛

1511
00:34:17,000 --> 00:34:18,000
打机械

1512
00:34:18,000 --> 00:34:22,000
机械打字机的那个按键是很费力的

1513
00:34:22,000 --> 00:34:22,000
对啊

1514
00:34:22,000 --> 00:34:24,000
就我小时候用打字机打英语作业的时候

1515
00:34:24,000 --> 00:34:27,000
就每天晚上打完了手指会疼的

1516
00:34:27,000 --> 00:34:27,000
真的

1517
00:34:27,000 --> 00:34:29,000
那个时候你小孩手也小了

1518
00:34:29,000 --> 00:34:30,000
就

1519
00:34:30,000 --> 00:34:31,000
而且那个时候直发也不好

1520
00:34:31,000 --> 00:34:32,000
对

1521
00:34:32,000 --> 00:34:34,000
只能用食指和中指再按

1522
00:34:34,000 --> 00:34:36,000
然后有些字母

1523
00:34:36,000 --> 00:34:39,000
如果你用那时候我去用小指去按的话

1524
00:34:39,000 --> 00:34:40,000
有点是虚的

1525
00:34:40,000 --> 00:34:42,000
比如说 PE 之类的

1526
00:34:42,000 --> 00:34:43,000
PEQ 有点是虚的

1527
00:34:43,000 --> 00:34:45,000
对

1528
00:34:45,000 --> 00:34:47,000
这也是一种恶趣味

1529
00:34:47,000 --> 00:34:48,000
对

1530
00:34:48,000 --> 00:34:50,000
这叫什么蒸汽朋克

1531
00:34:50,000 --> 00:34:52,000
机械朋克

1532
00:34:52,000 --> 00:34:53,000
机械朋克

1533
00:34:53,000 --> 00:34:54,000
机械朋克键盘

1534
00:34:54,000 --> 00:34:59,000
说到这个笔记程序员用的笔记本

1535
00:34:59,000 --> 00:35:00,000
前两天 Google

1536
00:35:00,000 --> 00:35:01,000
就是应该不是前两天

1537
00:35:01,000 --> 00:35:04,000
就是苹果发布那个新款 MacBook 之后

1538
00:35:04,000 --> 00:35:08,000
第二天 Google 也发布了这个新款的 Chromebook Pixel

1539
00:35:08,000 --> 00:35:09,000
就是它那块

1540
00:35:09,000 --> 00:35:15,000
虽然就官方配置是只能用上网的一个笔记本

1541
00:35:15,000 --> 00:35:17,000
但是它的整个配置还是不错的

1542
00:35:17,000 --> 00:35:18,000
有一个高分屏

1543
00:35:18,000 --> 00:35:19,000
也是 13 寸

1544
00:35:19,000 --> 00:35:21,000
一个方投方脑的一个设计吧

1545
00:35:21,000 --> 00:35:25,000
然后我知道很多人就是 Linux 用户

1546
00:35:25,000 --> 00:35:26,000
他会选这个

1547
00:35:26,000 --> 00:35:27,000
然后他装那个

1548
00:35:27,000 --> 00:35:30,000
上面有一个这种软件叫做 Chromebook

1549
00:35:30,000 --> 00:35:31,000
就可以在上面

1550
00:35:31,000 --> 00:35:36,000
在一个类似于这个 container 的环境里面

1551
00:35:36,000 --> 00:35:38,000
跑一个其他内核的

1552
00:35:38,000 --> 00:35:38,000
不叫其他内核

1553
00:35:38,000 --> 00:35:41,000
就其他的这个 Linux 的发新版

1554
00:35:41,000 --> 00:35:42,000
比如说 Chromebook 之类的

1555
00:35:42,000 --> 00:35:44,000
然后这样的话就有很多好处

1556
00:35:44,000 --> 00:35:46,000
因为 Chromebook 它本身是一个类似于

1557
00:35:46,000 --> 00:35:47,000
iOS 的设计

1558
00:35:47,000 --> 00:35:49,000
就整个它是杀核机制的

1559
00:35:49,000 --> 00:35:51,000
然后你没有办法去更改系统的东西

1560
00:35:51,000 --> 00:35:53,000
就安全性是有保障的

1561
00:35:53,000 --> 00:35:55,000
然后你在那个 container 里面

1562
00:35:55,000 --> 00:35:57,000
再跑一个 Linux 发新版

1563
00:35:57,000 --> 00:35:58,000
你就弄坏了

1564
00:35:58,000 --> 00:36:00,000
再删掉重新来一个就好了

1565
00:36:00,000 --> 00:36:02,000
就很多人会选择这种方式来做

1566
00:36:02,000 --> 00:36:03,000
是

1567
00:36:03,000 --> 00:36:06,000
它那个板的唯一的问题就是

1568
00:36:06,000 --> 00:36:08,000
存储空间太小了

1569
00:36:08,000 --> 00:36:10,000
它最大只有 64 G 的 SSD

1570
00:36:10,000 --> 00:36:12,000
对

1571
00:36:12,000 --> 00:36:13,000
我觉得我也不知道

1572
00:36:13,000 --> 00:36:16,000
你见过身边的人在用 Chromebook 吗

1573
00:36:16,000 --> 00:36:18,000
为什么我总有一种感觉就是

1574
00:36:18,000 --> 00:36:21,000
它是一个怎么叫好不叫做的成品

1575
00:36:21,000 --> 00:36:24,000
我没有见过有人自己花钱买它

1576
00:36:24,000 --> 00:36:26,000
然后但不过我有个朋友

1577
00:36:26,000 --> 00:36:30,000
他是前年去 Google I.O.的时候

1578
00:36:30,000 --> 00:36:33,000
那年不是 Google 去餐

1579
00:36:33,000 --> 00:36:34,000
或者是每个人送了一台吗

1580
00:36:34,000 --> 00:36:35,000
就是第一代的 Crumble Pixel

1581
00:36:35,000 --> 00:36:37,000
然后他就拿了一台回来

1582
00:36:37,000 --> 00:36:38,000
我玩了一下

1583
00:36:38,000 --> 00:36:41,000
整个做工和工艺还是不错的

1584
00:36:41,000 --> 00:36:41,000
我觉得

1585
00:36:41,000 --> 00:36:44,000
但是就是能做的事情感觉挺有限的

1586
00:36:44,000 --> 00:36:45,000
OK

1587
00:36:45,000 --> 00:36:48,000
因为它那个空间确实比较小

1588
00:36:48,000 --> 00:36:51,000
它那个是带那个 LTE 还是 4 G 网络的

1589
00:36:51,000 --> 00:36:51,000
对

1590
00:36:51,000 --> 00:36:52,000
它可以插那个 Sync 卡

1591
00:36:52,000 --> 00:36:54,000
这点比较有意思

1592
00:36:54,000 --> 00:36:56,000
对

1593
00:36:56,000 --> 00:36:59,000
就是其实我之前在想说

1594
00:36:59,000 --> 00:37:01,000
新的 MacBook

1595
00:37:01,000 --> 00:37:04,000
为什么不能直接内置 LTE model

1596
00:37:04,000 --> 00:37:08,000
因为它那个轻薄的程度

1597
00:37:08,000 --> 00:37:09,000
它那个轻薄的程度

1598
00:37:09,000 --> 00:37:11,000
其实已经非常适合

1599
00:37:11,000 --> 00:37:12,000
就是带着到处跑

1600
00:37:12,000 --> 00:37:12,000
但是带着到处跑

1601
00:37:12,000 --> 00:37:14,000
有问题就是在没有网络的地方

1602
00:37:14,000 --> 00:37:15,000
比如说

1603
00:37:15,000 --> 00:37:16,000
它那个宣传广告里面

1604
00:37:16,000 --> 00:37:18,000
有一个女孩

1605
00:37:18,000 --> 00:37:20,000
拿着她盘腿

1606
00:37:20,000 --> 00:37:23,000
坐在一个公园旁边的长椅上

1607
00:37:23,000 --> 00:37:23,000
然后我就想说

1608
00:37:23,000 --> 00:37:24,000
它的网从哪来

1609
00:37:24,000 --> 00:37:28,000
那个苹果的解决方案是说

1610
00:37:28,000 --> 00:37:29,000
你只要有手机在旁边

1611
00:37:29,000 --> 00:37:31,000
可以通过无线的连接一个

1612
00:37:31,000 --> 00:37:32,000
Tethering

1613
00:37:32,000 --> 00:37:33,000
对对

1614
00:37:33,000 --> 00:37:35,000
它可以做一个这个

1615
00:37:35,000 --> 00:37:36,000
好吧

1616
00:37:36,000 --> 00:37:36,000
我觉得还可以吧

1617
00:37:36,000 --> 00:37:38,000
因为其实你如果

1618
00:37:38,000 --> 00:37:40,000
每一个设备都做一个 Sync 卡的话

1619
00:37:40,000 --> 00:37:41,000
你每个月的这个

1620
00:37:41,000 --> 00:37:42,000
交给运营商的月费

1621
00:37:42,000 --> 00:37:43,000
还是蛮多的

1622
00:37:43,000 --> 00:37:44,000
就如果是偶尔的

1623
00:37:44,000 --> 00:37:46,000
就这种场合在使用的话

1624
00:37:46,000 --> 00:37:47,000
这样也没什么不好

1625
00:37:47,000 --> 00:37:50,000
之前用做那个 Tethering

1626
00:37:50,000 --> 00:37:51,000
还比较麻烦

1627
00:37:51,000 --> 00:37:53,000
你要先配在手机上打开

1628
00:37:53,000 --> 00:37:55,000
然后你在电脑上连接一下

1629
00:37:55,000 --> 00:37:56,000
现在自从那个

1630
00:37:56,000 --> 00:37:56,000
Yosemite 里面

1631
00:37:56,000 --> 00:37:57,000
不是你可以直接

1632
00:37:57,000 --> 00:37:59,000
就只要你手机在旁边

1633
00:37:59,000 --> 00:38:00,000
你点那个 Wi-Fi 的 logo 里面

1634
00:38:00,000 --> 00:38:01,000
就可以很方便的

1635
00:38:01,000 --> 00:38:02,000
有一个选项

1636
00:38:02,000 --> 00:38:04,000
可以直接通过你手机

1637
00:38:04,000 --> 00:38:05,000
iPhone

1638
00:38:05,000 --> 00:38:05,000
Tethering

1639
00:38:05,000 --> 00:38:07,000
所以我觉得还好吧

1640
00:38:07,000 --> 00:38:08,000
而且是现在

1641
00:38:08,000 --> 00:38:10,000
就出门

1642
00:38:10,000 --> 00:38:12,000
你要真的进下来办公

1643
00:38:12,000 --> 00:38:13,000
但除非你是去什么

1644
00:38:13,000 --> 00:38:14,000
公园里面再说

1645
00:38:14,000 --> 00:38:15,000
就是说你是什么咖啡馆

1646
00:38:15,000 --> 00:38:16,000
就有 Wi-Fi 的地方

1647
00:38:16,000 --> 00:38:17,000
还是太多了吧

1648
00:38:17,000 --> 00:38:19,000
说的也是

1649
00:38:19,000 --> 00:38:21,000
我感觉是这样子

1650
00:38:21,000 --> 00:38:23,000
你又 ever

1651
00:38:23,000 --> 00:38:25,000
带着一个笔记本

1652
00:38:25,000 --> 00:38:27,000
出去办公这种事情吧

1653
00:38:27,000 --> 00:38:28,000
就是你觉得家里太憋

1654
00:38:28,000 --> 00:38:30,000
或者是外面阳光真好

1655
00:38:30,000 --> 00:38:31,000
想要一边写程序

1656
00:38:31,000 --> 00:38:33,000
一边享受阳光之类的

1657
00:38:33,000 --> 00:38:34,000
你做这种事情吗

1658
00:38:34,000 --> 00:38:34,000
有啊

1659
00:38:34,000 --> 00:38:35,000
夏天的时候

1660
00:38:35,000 --> 00:38:36,000
我经常带出去

1661
00:38:36,000 --> 00:38:36,000
在海边

1662
00:38:36,000 --> 00:38:37,000
因为我们在

1663
00:38:37,000 --> 00:38:39,000
我这个地方就是在靠海

1664
00:38:39,000 --> 00:38:42,000
我家离这个大西洋的直线距离

1665
00:38:42,000 --> 00:38:45,000
可能只有两三公里的样子

1666
00:38:45,000 --> 00:38:46,000
然后我就开着开着海边

1667
00:38:46,000 --> 00:38:48,000
找个这种稍微

1668
00:38:48,000 --> 00:38:50,000
就是那个视线比较好的地方

1669
00:38:50,000 --> 00:38:52,000
我就坐在那个

1670
00:38:52,000 --> 00:38:54,000
那个附加的位置上

1671
00:38:54,000 --> 00:38:57,000
把那个椅子往后折

1672
00:38:57,000 --> 00:38:57,000
然后在那里办公

1673
00:38:57,000 --> 00:38:58,000
就是听着

1674
00:38:58,000 --> 00:39:00,000
聆听着拍案的怒涛

1675
00:39:00,000 --> 00:39:01,000
然后

1676
00:39:01,000 --> 00:39:02,000
我们这里没有怒涛

1677
00:39:02,000 --> 00:39:03,000
只有小浪

1678
00:39:03,000 --> 00:39:04,000
好吧

1679
00:39:04,000 --> 00:39:06,000
看着大西洋的浑浊海浪

1680
00:39:06,000 --> 00:39:08,000
大西洋是很蓝的

1681
00:39:08,000 --> 00:39:08,000
谢谢

1682
00:39:08,000 --> 00:39:10,000
不像太平洋

1683
00:39:10,000 --> 00:39:12,000
太平洋就很蓝

1684
00:39:12,000 --> 00:39:13,000
太平洋更蓝吧

1685
00:39:13,000 --> 00:39:13,000
应该

1686
00:39:13,000 --> 00:39:14,000
我不知道

1687
00:39:14,000 --> 00:39:15,000
我之前在

1688
00:39:15,000 --> 00:39:19,000
就起码在东国的海岸线上

1689
00:39:19,000 --> 00:39:20,000
看的的太平洋

1690
00:39:20,000 --> 00:39:21,000
都是挺黄浑浊的

1691
00:39:21,000 --> 00:39:23,000
那是因为中国的

1692
00:39:23,000 --> 00:39:25,000
就是河流

1693
00:39:25,000 --> 00:39:26,000
对

1694
00:39:26,000 --> 00:39:27,000
那边的海比较浅

1695
00:39:27,000 --> 00:39:27,000
像渤海有

1696
00:39:27,000 --> 00:39:29,000
我们家门口的渤海

1697
00:39:29,000 --> 00:39:30,000
有时候会冻上来

1698
00:39:30,000 --> 00:39:31,000
就浅到这个地步

1699
00:39:31,000 --> 00:39:32,000
OK

1700
00:39:32,000 --> 00:39:34,000
蓝海其实是

1701
00:39:34,000 --> 00:39:35,000
就是足够深的地方

1702
00:39:35,000 --> 00:39:35,000
都是蓝色

1703
00:39:35,000 --> 00:39:36,000
这个没什么

1704
00:39:36,000 --> 00:39:37,000
那边可能就是很深的

1705
00:39:37,000 --> 00:39:38,000
我就看都是

1706
00:39:38,000 --> 00:39:39,000
一望无际那种

1707
00:39:39,000 --> 00:39:41,000
就之前是照片上

1708
00:39:41,000 --> 00:39:42,000
看到的那种蓝

1709
00:39:42,000 --> 00:39:43,000
现在就是我们家旁边的

1710
00:39:43,000 --> 00:39:43,000
这种蓝

1711
00:39:43,000 --> 00:39:44,000
OK

1712
00:39:44,000 --> 00:39:46,000
好吧

1713
00:39:46,000 --> 00:39:48,000
我好像我很少干这种事情

1714
00:39:48,000 --> 00:39:49,000
就是带着一个笔记本

1715
00:39:49,000 --> 00:39:50,000
出去办公

1716
00:39:50,000 --> 00:39:51,000
我觉得

1717
00:39:51,000 --> 00:39:54,000
之前我不是看到一个德国人

1718
00:39:54,000 --> 00:39:54,000
他说

1719
00:39:54,000 --> 00:39:56,000
他都不要

1720
00:39:56,000 --> 00:39:57,000
他是做

1721
00:39:57,000 --> 00:39:58,000
好像开发那种

1722
00:39:58,000 --> 00:40:00,000
他是在那种

1723
00:40:00,000 --> 00:40:00,000
就是

1724
00:40:00,000 --> 00:40:02,000
主机上

1725
00:40:02,000 --> 00:40:02,000
不是主机

1726
00:40:02,000 --> 00:40:03,000
就是

1727
00:40:03,000 --> 00:40:05,000
服务器上开发那种

1728
00:40:05,000 --> 00:40:06,000
科学计算的应用的人

1729
00:40:06,000 --> 00:40:08,000
他都直接不要笔记本了

1730
00:40:08,000 --> 00:40:08,000
他就带个 iPad

1731
00:40:08,000 --> 00:40:10,000
然后带个蓝牙键盘出门

1732
00:40:10,000 --> 00:40:11,000
然后 iPad 有

1733
00:40:11,000 --> 00:40:12,000
什么 LT

1734
00:40:12,000 --> 00:40:12,000
有司机

1735
00:40:12,000 --> 00:40:14,000
他就在那个什么

1736
00:40:14,000 --> 00:40:14,000
公园里面

1737
00:40:14,000 --> 00:40:15,000
找个

1738
00:40:15,000 --> 00:40:17,000
找个凳子坐上

1739
00:40:17,000 --> 00:40:18,000
然后就在公园

1740
00:40:18,000 --> 00:40:19,000
不就是长椅

1741
00:40:19,000 --> 00:40:19,000
那种木凳

1742
00:40:19,000 --> 00:40:21,000
然后他就把那个拿出来

1743
00:40:21,000 --> 00:40:22,000
然后通过 LT 上

1744
00:40:22,000 --> 00:40:23,000
他反正只需要那个 SSH

1745
00:40:23,000 --> 00:40:24,000
就过去

1746
00:40:24,000 --> 00:40:25,000
所有软件都可以在

1747
00:40:25,000 --> 00:40:26,000
那个服务器上有

1748
00:40:26,000 --> 00:40:29,000
他如果只是

1749
00:40:29,000 --> 00:40:32,000
纯 console 下面编程的话

1750
00:40:32,000 --> 00:40:33,000
这样的确是可取的

1751
00:40:33,000 --> 00:40:36,000
但你只要稍微接触到

1752
00:40:36,000 --> 00:40:38,000
接触到任何非 console 的东西

1753
00:40:38,000 --> 00:40:39,000
那 iPad 直接就废了

1754
00:40:39,000 --> 00:40:39,000
我觉得

1755
00:40:39,000 --> 00:40:40,000
对

1756
00:40:40,000 --> 00:40:42,000
你要在本地做事情

1757
00:40:42,000 --> 00:40:43,000
那肯定是不可取的

1758
00:40:43,000 --> 00:40:44,000
除非你要

1759
00:40:44,000 --> 00:40:45,000
除非你

1760
00:40:45,000 --> 00:40:46,000
现在 iPad 上面有

1761
00:40:46,000 --> 00:40:49,000
X Windows 的客户端吗

1762
00:40:49,000 --> 00:40:50,000
没有吧

1763
00:40:50,000 --> 00:40:52,000
我不太清楚

1764
00:40:52,000 --> 00:40:52,000
不过有那个

1765
00:40:52,000 --> 00:40:53,000
有那个叫什么

1766
00:40:53,000 --> 00:40:55,000
Remote VNC

1767
00:40:55,000 --> 00:40:55,000
对

1768
00:40:55,000 --> 00:40:57,000
VNC 的这种东西

1769
00:40:57,000 --> 00:40:58,000
然后鼠标怎么

1770
00:40:58,000 --> 00:41:01,000
就是你用点屏幕

1771
00:41:01,000 --> 00:41:06,000
你要用鼠标

1772
00:41:06,000 --> 00:41:06,000
肯定就疏烂

1773
00:41:06,000 --> 00:41:09,000
听起来有点淡淡

1774
00:41:09,000 --> 00:41:11,000
或者用纯键盘的

1775
00:41:11,000 --> 00:41:13,000
创作管理器

1776
00:41:13,000 --> 00:41:13,000
应该也可以

1777
00:41:13,000 --> 00:41:15,000
对你不是反正 VNC

1778
00:41:15,000 --> 00:41:16,000
大部分的时候

1779
00:41:16,000 --> 00:41:18,000
都用那个 VNC 的 K 班里吗

1780
00:41:18,000 --> 00:41:19,000
应该也差不多合适了

1781
00:41:19,000 --> 00:41:19,000
我觉得

1782
00:41:19,000 --> 00:41:21,000
好吧

1783
00:41:21,000 --> 00:41:22,000
下次可以试试

1784
00:41:22,000 --> 00:41:24,000
我起手去说吧

1785
00:41:24,000 --> 00:41:25,000
你没有吧

1786
00:41:25,000 --> 00:41:25,000
对

1787
00:41:25,000 --> 00:41:26,000
我是一个

1788
00:41:26,000 --> 00:41:27,000
我觉得如果出门的话

1789
00:41:27,000 --> 00:41:28,000
就不要办公

1790
00:41:28,000 --> 00:41:29,000
如果办公的话

1791
00:41:29,000 --> 00:41:29,000
就不要出门

1792
00:41:29,000 --> 00:41:31,000
那你想换个环境

1793
00:41:31,000 --> 00:41:33,000
散散心怎么办

1794
00:41:33,000 --> 00:41:34,000
那就不办公

1795
00:41:34,000 --> 00:41:36,000
就想散心的时候散心

1796
00:41:36,000 --> 00:41:37,000
那什么

1797
00:41:37,000 --> 00:41:40,000
叫什么李大钞的那篇文章

1798
00:41:40,000 --> 00:41:42,000
玩就玩个痛快

1799
00:41:42,000 --> 00:41:43,000
学就学个舒服

1800
00:41:43,000 --> 00:41:45,000
真的

1801
00:41:45,000 --> 00:41:46,000
不是学就学个舒服

1802
00:41:46,000 --> 00:41:47,000
学就学个什么

1803
00:41:47,000 --> 00:41:48,000
然后玩就玩个痛快

1804
00:41:48,000 --> 00:41:51,000
就该干嘛

1805
00:41:51,000 --> 00:41:52,000
就是 work hard

1806
00:41:52,000 --> 00:41:52,000
play hard

1807
00:41:52,000 --> 00:41:53,000
对

1808
00:41:53,000 --> 00:41:55,000
就不要又想

1809
00:41:55,000 --> 00:41:56,000
又想轻松

1810
00:41:56,000 --> 00:41:56,000
又想

1811
00:41:56,000 --> 00:41:59,000
要办公就站着

1812
00:41:59,000 --> 00:42:01,000
然后敲一台

1813
00:42:01,000 --> 00:42:02,000
机械奖板

1814
00:42:02,000 --> 00:42:02,000
用一个

1815
00:42:02,000 --> 00:42:04,000
用一台 power mac

1816
00:42:04,000 --> 00:42:06,000
然后要出去

1817
00:42:06,000 --> 00:42:06,000
就什么又不

1818
00:42:06,000 --> 00:42:07,000
什么都不要带

1819
00:42:07,000 --> 00:42:09,000
那如果你是这种人的话

1820
00:42:09,000 --> 00:42:10,000
你为什么买个笔记本呢

1821
00:42:10,000 --> 00:42:13,000
因为我并不具备

1822
00:42:13,000 --> 00:42:14,000
尚不具备

1823
00:42:14,000 --> 00:42:17,000
一个可以装

1824
00:42:17,000 --> 00:42:19,000
power mac 的办公室

1825
00:42:19,000 --> 00:42:20,000
我觉得

1826
00:42:20,000 --> 00:42:22,000
不你可以用那个

1827
00:42:22,000 --> 00:42:23,000
什么 iMac 之类的

1828
00:42:23,000 --> 00:42:27,000
我之前的确是在

1829
00:42:27,000 --> 00:42:28,000
iMac 和

1830
00:42:28,000 --> 00:42:29,000
power

1831
00:42:29,000 --> 00:42:30,000
和

1832
00:42:30,000 --> 00:42:32,000
MVP 之间

1833
00:42:32,000 --> 00:42:34,000
犹豫了一阵

1834
00:42:34,000 --> 00:42:35,000
因为那个时候

1835
00:42:35,000 --> 00:42:36,000
我正要从

1836
00:42:36,000 --> 00:42:37,000
一个城市

1837
00:42:37,000 --> 00:42:38,000
搬到另外一城市

1838
00:42:38,000 --> 00:42:39,000
就是考虑到自己

1839
00:42:39,000 --> 00:42:40,000
可能基金要工作

1840
00:42:40,000 --> 00:42:41,000
对

1841
00:42:41,000 --> 00:42:42,000
然后现在

1842
00:42:42,000 --> 00:42:42,000
对

1843
00:42:42,000 --> 00:42:44,000
然后那个时候

1844
00:42:44,000 --> 00:42:45,000
正考虑说

1845
00:42:45,000 --> 00:42:46,000
如果搬到女朋友

1846
00:42:46,000 --> 00:42:46,000
那边去住

1847
00:42:46,000 --> 00:42:47,000
然后可能暂时

1848
00:42:47,000 --> 00:42:48,000
不会有一个办公室

1849
00:42:48,000 --> 00:42:49,000
实际上我现在的确

1850
00:42:49,000 --> 00:42:50,000
没有一个办公室

1851
00:42:50,000 --> 00:42:51,000
所以可能

1852
00:42:51,000 --> 00:42:52,000
还是

1853
00:42:52,000 --> 00:42:54,000
有一台笔记本

1854
00:42:54,000 --> 00:42:54,000
比较方便

1855
00:42:54,000 --> 00:42:55,000
对

1856
00:42:55,000 --> 00:42:56,000
起码

1857
00:42:56,000 --> 00:42:57,000
它在整个体积上

1858
00:42:57,000 --> 00:42:58,000
还是可以小一些

1859
00:42:58,000 --> 00:42:59,000
然后拿走的话

1860
00:42:59,000 --> 00:43:00,000
也方便一点

1861
00:43:00,000 --> 00:43:01,000
对

1862
00:43:01,000 --> 00:43:03,000
其实我也是这样

1863
00:43:03,000 --> 00:43:03,000
我的笔记本

1864
00:43:03,000 --> 00:43:04,000
大部分都是

1865
00:43:04,000 --> 00:43:05,000
就是放在桌上

1866
00:43:05,000 --> 00:43:07,000
然后接显示器

1867
00:43:07,000 --> 00:43:08,000
然后插各种些

1868
00:43:08,000 --> 00:43:10,000
就当桌面机

1869
00:43:10,000 --> 00:43:10,000
就什么

1870
00:43:10,000 --> 00:43:12,000
Desktop Replacement

1871
00:43:12,000 --> 00:43:12,000
对

1872
00:43:12,000 --> 00:43:14,000
因为就我觉得

1873
00:43:14,000 --> 00:43:15,000
MacBook Pro

1874
00:43:15,000 --> 00:43:16,000
其实有一点就是

1875
00:43:16,000 --> 00:43:18,000
如果你出去旅游的时候

1876
00:43:18,000 --> 00:43:18,000
我要带它

1877
00:43:18,000 --> 00:43:19,000
还是不带它

1878
00:43:19,000 --> 00:43:19,000
就

1879
00:43:19,000 --> 00:43:21,000
不带它

1880
00:43:21,000 --> 00:43:22,000
显然

1881
00:43:22,000 --> 00:43:22,000
对

1882
00:43:22,000 --> 00:43:24,000
但如果我有一台 iMac

1883
00:43:24,000 --> 00:43:26,000
和一台新的那个 MacBook

1884
00:43:26,000 --> 00:43:27,000
我可能会毫不犹豫地

1885
00:43:27,000 --> 00:43:28,000
想要带上

1886
00:43:28,000 --> 00:43:29,000
对

1887
00:43:29,000 --> 00:43:30,000
因为小嘛

1888
00:43:30,000 --> 00:43:31,000
对

1889
00:43:31,000 --> 00:43:33,000
所以还是

1890
00:43:33,000 --> 00:43:35,000
可能我们这种情况

1891
00:43:35,000 --> 00:43:35,000
比较特殊

1892
00:43:35,000 --> 00:43:36,000
有很多这种

1893
00:43:36,000 --> 00:43:37,000
所谓的这种

1894
00:43:37,000 --> 00:43:38,000
白领

1895
00:43:38,000 --> 00:43:40,000
他可能经常需要去开会

1896
00:43:40,000 --> 00:43:41,000
办公之类的

1897
00:43:41,000 --> 00:43:43,000
他就需要

1898
00:43:43,000 --> 00:43:45,000
拿一台电脑

1899
00:43:45,000 --> 00:43:46,000
然后 iPad 又不行

1900
00:43:46,000 --> 00:43:47,000
这个时候

1901
00:43:47,000 --> 00:43:49,000
那种轻薄的笔记本

1902
00:43:49,000 --> 00:43:49,000
就有的

1903
00:43:49,000 --> 00:43:51,000
就是一个必须的选项

1904
00:43:51,000 --> 00:43:52,000
没错

1905
00:43:52,000 --> 00:43:54,000
今天主题是什么

1906
00:43:54,000 --> 00:43:56,000
今天的主题是

1907
00:43:56,000 --> 00:43:58,000
并发和异步

1908
00:43:58,000 --> 00:44:00,000
听起来是不是就

1909
00:44:00,000 --> 00:44:01,000
等一下

1910
00:44:01,000 --> 00:44:03,000
这是不是又太干了

1911
00:44:03,000 --> 00:44:05,000
并发和异步

1912
00:44:05,000 --> 00:44:06,000
其实我们可以讲的

1913
00:44:06,000 --> 00:44:06,000
比较

1914
00:44:06,000 --> 00:44:08,000
泛一点的

1915
00:44:08,000 --> 00:44:09,000
比较

1916
00:44:09,000 --> 00:44:09,000
比较

1917
00:44:09,000 --> 00:44:11,000
浅入浅出一点

1918
00:44:11,000 --> 00:44:13,000
霍金

1919
00:44:13,000 --> 00:44:14,000
霍金不是在

1920
00:44:14,000 --> 00:44:15,000
时间前事里面说

1921
00:44:15,000 --> 00:44:18,000
你在书里面加一个公式

1922
00:44:18,000 --> 00:44:20,000
你的读者就会少一半

1923
00:44:20,000 --> 00:44:22,000
每多加一个公式

1924
00:44:22,000 --> 00:44:24,000
你的读者就会少一半

1925
00:44:24,000 --> 00:44:26,000
所以我们想可能是

1926
00:44:26,000 --> 00:44:29,000
我们每增加一个术语

1927
00:44:29,000 --> 00:44:31,000
可能的听众就会少一半

1928
00:44:31,000 --> 00:44:32,000
比如说上一期

1929
00:44:32,000 --> 00:44:33,000
编程与数学

1930
00:44:33,000 --> 00:44:38,000
可能已经限定了很多

1931
00:44:38,000 --> 00:44:40,000
听很多对数学和编程

1932
00:44:40,000 --> 00:44:41,000
不感兴趣的听众是不会的

1933
00:44:41,000 --> 00:44:44,000
当然对数学和编程不感兴趣的听众

1934
00:44:44,000 --> 00:44:45,000
为什么要听得很恐慌

1935
00:44:45,000 --> 00:44:46,000
没事

1936
00:44:46,000 --> 00:44:47,000
根本还可以听

1937
00:44:47,000 --> 00:44:48,000
这个沐瑶老师的声音

1938
00:44:48,000 --> 00:44:50,000
说得是

1939
00:44:50,000 --> 00:44:55,000
我们应该把沐瑶专门

1940
00:44:55,000 --> 00:44:58,000
挖到 IPN 来单独做一档节目

1941
00:44:58,000 --> 00:44:59,000
各位听众说怎么样

1942
00:44:59,000 --> 00:45:01,000
然后粉丝全过去了

1943
00:45:01,000 --> 00:45:02,000
我们这没剩几个人

1944
00:45:02,000 --> 00:45:03,000
对

1945
00:45:03,000 --> 00:45:05,000
此处应该插入幼儿园的

1946
00:45:05,000 --> 00:45:07,000
所有小朋友

1947
00:45:07,000 --> 00:45:07,000
也不起说

1948
00:45:07,000 --> 00:45:08,000
好

1949
00:45:08,000 --> 00:45:11,000
对

1950
00:45:11,000 --> 00:45:13,000
好

1951
00:45:13,000 --> 00:45:14,000
好

1952
00:45:14,000 --> 00:45:15,000
对

1953
00:45:15,000 --> 00:45:16,000
好吧

1954
00:45:16,000 --> 00:45:19,000
所以并发和并行

1955
00:45:19,000 --> 00:45:20,000
其实是两个概念

1956
00:45:20,000 --> 00:45:21,000
不不不

1957
00:45:21,000 --> 00:45:22,000
并发和异步

1958
00:45:22,000 --> 00:45:23,000
对不对

1959
00:45:23,000 --> 00:45:24,000
concurrency

1960
00:45:24,000 --> 00:45:26,000
concurrent 和 parallel

1961
00:45:26,000 --> 00:45:27,000
OK

1962
00:45:27,000 --> 00:45:28,000
先讲并发这一块

1963
00:45:28,000 --> 00:45:29,000
对

1964
00:45:29,000 --> 00:45:31,000
并发和并行

1965
00:45:31,000 --> 00:45:34,000
这个术语其实有点很纠结的

1966
00:45:34,000 --> 00:45:36,000
我觉得没有一个很清晰的

1967
00:45:36,000 --> 00:45:39,000
就起码中文没有一个很清晰的概念

1968
00:45:39,000 --> 00:45:40,000
就 concurrency

1969
00:45:40,000 --> 00:45:43,000
英文两边是两个完全不一样的词

1970
00:45:43,000 --> 00:45:43,000
对吧

1971
00:45:43,000 --> 00:45:45,000
但是在中文里面

1972
00:45:45,000 --> 00:45:47,000
你说并发和并行有什么太大区别

1973
00:45:47,000 --> 00:45:47,000
好像也没有

1974
00:45:47,000 --> 00:45:50,000
但我觉得就是怎么说

1975
00:45:50,000 --> 00:45:52,000
有人人工程里面有很多很多词汇

1976
00:45:52,000 --> 00:45:52,000
都是这样

1977
00:45:52,000 --> 00:45:55,000
而且你说 concurrency 和 parallel

1978
00:45:55,000 --> 00:45:57,000
在英文里面的区别

1979
00:45:57,000 --> 00:45:59,000
是每一个程序员都了解的吗

1980
00:45:59,000 --> 00:46:00,000
肯定也不是

1981
00:46:00,000 --> 00:46:02,000
甚至连那个词典的定义

1982
00:46:02,000 --> 00:46:04,000
都是很非常接近

1983
00:46:04,000 --> 00:46:06,000
你说都没有一个很严格的区分

1984
00:46:06,000 --> 00:46:07,000
造成哪个是哪个

1985
00:46:07,000 --> 00:46:08,000
对

1986
00:46:08,000 --> 00:46:11,000
但是我觉得可能在软件界

1987
00:46:11,000 --> 00:46:12,000
有很多很多这样的问题

1988
00:46:12,000 --> 00:46:15,000
比如说 argument 和 pyrameter 的差别

1989
00:46:15,000 --> 00:46:18,000
可能有很多时候也会回用

1990
00:46:18,000 --> 00:46:20,000
就看语境嘛

1991
00:46:20,000 --> 00:46:22,000
就大部分时候是不分的

1992
00:46:22,000 --> 00:46:22,000
我觉得

1993
00:46:22,000 --> 00:46:23,000
对

1994
00:46:23,000 --> 00:46:28,000
但具体到这一期的话题上来说

1995
00:46:28,000 --> 00:46:30,000
我觉得可能正确的区分

1996
00:46:30,000 --> 00:46:32,000
concurrency 和 parallel 也是

1997
00:46:32,000 --> 00:46:35,000
就接下来的讨论比较重要的事情

1998
00:46:35,000 --> 00:46:36,000
甚至可以说

1999
00:46:36,000 --> 00:46:37,000
如果我们这期节目

2000
00:46:37,000 --> 00:46:38,000
可以让

2001
00:46:38,000 --> 00:46:41,000
可以帮助听过的人

2002
00:46:41,000 --> 00:46:43,000
确切的了解了

2003
00:46:43,000 --> 00:46:45,000
concurrency 和 parallel 之间的差别

2004
00:46:45,000 --> 00:46:47,000
那可能也已经是很有

2005
00:46:47,000 --> 00:46:48,000
成功了

2006
00:46:48,000 --> 00:46:48,000
很有好处

2007
00:46:48,000 --> 00:46:49,000
对

2008
00:46:49,000 --> 00:46:50,000
很有成功的一件事

2009
00:46:50,000 --> 00:46:51,000
很成功的一件事

2010
00:46:51,000 --> 00:46:53,000
所以我们要先把这个范围

2011
00:46:53,000 --> 00:46:54,000
缩得很窄

2012
00:46:54,000 --> 00:46:55,000
就是说我们在这里讲的

2013
00:46:55,000 --> 00:46:56,000
并发和并行

2014
00:46:56,000 --> 00:46:57,000
但对应的两个词

2015
00:46:57,000 --> 00:46:59,000
就是 concurrency 和 parallel

2016
00:46:59,000 --> 00:47:01,000
这两个词的时候是讲在

2017
00:47:01,000 --> 00:47:02,000
叫什么

2018
00:47:02,000 --> 00:47:05,000
多线程

2019
00:47:05,000 --> 00:47:07,000
或者说在这个程序语言的

2020
00:47:07,000 --> 00:47:10,000
这个构建的时候的一个场景

2021
00:47:10,000 --> 00:47:12,000
那至于说这个场景以外

2022
00:47:12,000 --> 00:47:13,000
你要怎么去用这两个词

2023
00:47:13,000 --> 00:47:14,000
那就随你变吧

2024
00:47:14,000 --> 00:47:15,000
对

2025
00:47:15,000 --> 00:47:19,000
所以什么是 concurrency

2026
00:47:19,000 --> 00:47:20,000
什么是并发

2027
00:47:20,000 --> 00:47:24,000
concurrency 我是这么理解的

2028
00:47:24,000 --> 00:47:27,000
就是说它是一种思维方式

2029
00:47:27,000 --> 00:47:29,000
就是说它你是怎么去

2030
00:47:29,000 --> 00:47:31,000
在逻辑上去构建一个东西

2031
00:47:31,000 --> 00:47:33,000
是它它两个之间是

2032
00:47:33,000 --> 00:47:35,000
可以没有一个先后顺序的

2033
00:47:35,000 --> 00:47:36,000
依赖关系的

2034
00:47:36,000 --> 00:47:39,000
我这么解释可不是合理

2035
00:47:39,000 --> 00:47:40,000
或者是清晰

2036
00:47:40,000 --> 00:47:41,000
但我是这么理解

2037
00:47:41,000 --> 00:47:41,000
OK

2038
00:47:41,000 --> 00:47:44,000
那什么是 parallel

2039
00:47:44,000 --> 00:47:45,000
什么是并行

2040
00:47:45,000 --> 00:47:47,000
并行的话就是说

2041
00:47:47,000 --> 00:47:49,000
这个是我就是相对于

2042
00:47:49,000 --> 00:47:50,000
刚才那里讲

2043
00:47:50,000 --> 00:47:51,000
是在逻辑层面的话

2044
00:47:51,000 --> 00:47:52,000
那个 concurrency

2045
00:47:52,000 --> 00:47:53,000
在逻辑层面的一个概念的话

2046
00:47:53,000 --> 00:47:54,000
并行可能就是在一个

2047
00:47:54,000 --> 00:47:56,000
物理层面的一个概念

2048
00:47:56,000 --> 00:48:00,000
就是说在逻辑上并发的东西

2049
00:48:00,000 --> 00:48:00,000
在物理上

2050
00:48:00,000 --> 00:48:02,000
它并不一定是在并行之行

2051
00:48:02,000 --> 00:48:03,000
它也可以是先做一个

2052
00:48:03,000 --> 00:48:04,000
后做一个

2053
00:48:04,000 --> 00:48:05,000
只是说它这个先后

2054
00:48:05,000 --> 00:48:07,000
是没有太大关系的

2055
00:48:07,000 --> 00:48:08,000
就谁先谁后都一样

2056
00:48:08,000 --> 00:48:10,000
但是并就是在

2057
00:48:10,000 --> 00:48:12,000
实现层面的并行的话

2058
00:48:12,000 --> 00:48:13,000
就是说它两个是在

2059
00:48:13,000 --> 00:48:16,000
物理事件中同时发生的

2060
00:48:16,000 --> 00:48:17,000
OK

2061
00:48:17,000 --> 00:48:18,000
这样解释可以吗

2062
00:48:18,000 --> 00:48:19,000
我觉得

2063
00:48:19,000 --> 00:48:21,000
我觉得应该是可以的

2064
00:48:21,000 --> 00:48:22,000
就是怎么说的

2065
00:48:22,000 --> 00:48:23,000
就是有一句

2066
00:48:23,000 --> 00:48:24,000
就是 Rod Pike

2067
00:48:24,000 --> 00:48:28,000
曾经做过一个对 Go Long 的

2068
00:48:28,000 --> 00:48:29,000
Go Routine 的

2069
00:48:29,000 --> 00:48:32,000
PowerPoint 叫什么

2070
00:48:32,000 --> 00:48:34,000
幻灯片

2071
00:48:34,000 --> 00:48:35,000
幻灯片

2072
00:48:35,000 --> 00:48:35,000
对

2073
00:48:35,000 --> 00:48:38,000
这个幻灯片在网上可以得到

2074
00:48:38,000 --> 00:48:42,000
然后它对并发和并行的定义是

2075
00:48:42,000 --> 00:48:44,000
并发是同一时间

2076
00:48:44,000 --> 00:48:46,000
应对多件事情的能力

2077
00:48:46,000 --> 00:48:49,000
就 Dealing with a lot of things

2078
00:48:49,000 --> 00:48:51,000
而并行呢

2079
00:48:51,000 --> 00:48:52,000
就是 Parallel

2080
00:48:52,000 --> 00:48:54,000
则是同一时间动手去做

2081
00:48:54,000 --> 00:48:56,000
很多件事情的东西

2082
00:48:56,000 --> 00:48:56,000
就

2083
00:48:56,000 --> 00:48:57,000
但这里你就要解释

2084
00:48:57,000 --> 00:48:58,000
什么是

2085
00:48:58,000 --> 00:48:59,000
什么是

2086
00:48:59,000 --> 00:49:00,000
什么是应对

2087
00:49:00,000 --> 00:49:01,000
和什么是做

2088
00:49:01,000 --> 00:49:02,000
对吧

2089
00:49:02,000 --> 00:49:02,000
对

2090
00:49:02,000 --> 00:49:04,000
我觉得可以理解为

2091
00:49:04,000 --> 00:49:05,000
就是这两个

2092
00:49:05,000 --> 00:49:07,000
这两个概念的抽象层级

2093
00:49:07,000 --> 00:49:08,000
是不一样

2094
00:49:08,000 --> 00:49:09,000
就并发

2095
00:49:09,000 --> 00:49:11,000
或者说他们描述的

2096
00:49:11,000 --> 00:49:12,000
问题的领域是不一样

2097
00:49:12,000 --> 00:49:14,000
所谓并发

2098
00:49:14,000 --> 00:49:14,000
Concurrency

2099
00:49:14,000 --> 00:49:23,000
指的是一个比较在问题领域的概念

2100
00:49:23,000 --> 00:49:25,000
就是你有很多问题

2101
00:49:25,000 --> 00:49:27,000
你需要去解决这些问题

2102
00:49:27,000 --> 00:49:30,000
而这些问题的发生是同时发生的

2103
00:49:30,000 --> 00:49:31,000
你就可以说

2104
00:49:31,000 --> 00:49:35,000
我要我所面对的问题

2105
00:49:35,000 --> 00:49:37,000
有 Concurrency 的特征

2106
00:49:37,000 --> 00:49:41,000
而 Parallel 则是在你实际去做一件事情的时候

2107
00:49:41,000 --> 00:49:42,000
你要比如说

2108
00:49:42,000 --> 00:49:46,000
你要去解决一个病发的问题

2109
00:49:46,000 --> 00:49:48,000
你怎么去解决它

2110
00:49:48,000 --> 00:49:48,000
好

2111
00:49:48,000 --> 00:49:51,000
你可以使用病情的手段去解决它

2112
00:49:51,000 --> 00:49:55,000
我大概理解你意思

2113
00:49:55,000 --> 00:49:57,000
不然我觉得听起来有点少

2114
00:49:57,000 --> 00:49:58,000
对吧

2115
00:49:58,000 --> 00:49:58,000
比如说

2116
00:49:58,000 --> 00:49:59,000
或者说

2117
00:49:59,000 --> 00:50:03,000
我们还是举例子来解释

2118
00:50:03,000 --> 00:50:04,000
就比如说

2119
00:50:04,000 --> 00:50:09,000
我在做一些事情的时候

2120
00:50:09,000 --> 00:50:10,000
需要去做另外一件事情

2121
00:50:10,000 --> 00:50:10,000
比如说我要做饭

2122
00:50:10,000 --> 00:50:11,000
好

2123
00:50:11,000 --> 00:50:14,000
但是我的碗还没洗

2124
00:50:14,000 --> 00:50:14,000
锅也没刷

2125
00:50:14,000 --> 00:50:14,000
好

2126
00:50:14,000 --> 00:50:16,000
那我要先刷锅

2127
00:50:16,000 --> 00:50:17,000
再洗碗

2128
00:50:17,000 --> 00:50:18,000
然后再切菜

2129
00:50:18,000 --> 00:50:20,000
然后再把油倒进锅里

2130
00:50:20,000 --> 00:50:21,000
然后开始炒菜

2131
00:50:21,000 --> 00:50:22,000
炒完菜再装盘

2132
00:50:22,000 --> 00:50:24,000
所有这些事情可以理解为

2133
00:50:24,000 --> 00:50:27,000
我是有些事情是可以同时做的

2134
00:50:27,000 --> 00:50:27,000
对吧

2135
00:50:27,000 --> 00:50:31,000
比如说我可以先洗一部分碗

2136
00:50:31,000 --> 00:50:32,000
然后先把锅洗了

2137
00:50:32,000 --> 00:50:34,000
然后用锅来炒菜

2138
00:50:34,000 --> 00:50:36,000
然后在菜被煮的过程中

2139
00:50:36,000 --> 00:50:37,000
假设我是做一个炖菜

2140
00:50:37,000 --> 00:50:40,000
不需要长时间的去翻它的炖菜

2141
00:50:40,000 --> 00:50:44,000
然后我可以在炖菜的时候去洗碗

2142
00:50:44,000 --> 00:50:45,000
对吧

2143
00:50:45,000 --> 00:50:50,000
此时我可以说做饭这件事情是一个并发的事情

2144
00:50:50,000 --> 00:50:55,000
因为有很多头绪需要我去做

2145
00:50:55,000 --> 00:50:57,000
甚至我可以把买菜加进去

2146
00:50:57,000 --> 00:50:59,000
比如说我可以去买菜

2147
00:50:59,000 --> 00:51:00,000
我需要先去买菜

2148
00:51:00,000 --> 00:51:02,000
然后再去刷锅洗碗

2149
00:51:02,000 --> 00:51:03,000
然后再开始炖菜

2150
00:51:03,000 --> 00:51:03,000
然后再开始装菜

2151
00:51:03,000 --> 00:51:05,000
然后再开始摆桌子之类的

2152
00:51:05,000 --> 00:51:08,000
但是因为我只有一个人

2153
00:51:08,000 --> 00:51:11,000
所以我可能没有办法用并行的手段去做它

2154
00:51:11,000 --> 00:51:11,000
对吧

2155
00:51:11,000 --> 00:51:12,000
对没错

2156
00:51:12,000 --> 00:51:14,000
但如果我可以

2157
00:51:14,000 --> 00:51:15,000
你有女朋友

2158
00:51:15,000 --> 00:51:16,000
拉着我女朋友

2159
00:51:16,000 --> 00:51:16,000
对

2160
00:51:16,000 --> 00:51:18,000
首先我得有一个女朋友

2161
00:51:18,000 --> 00:51:19,000
首先你得有

2162
00:51:19,000 --> 00:51:20,000
幸好

2163
00:51:20,000 --> 00:51:22,000
幸好我已经有了一个女朋友

2164
00:51:22,000 --> 00:51:23,000
我可以拉着她说

2165
00:51:23,000 --> 00:51:23,000
好

2166
00:51:23,000 --> 00:51:24,000
我去买菜

2167
00:51:24,000 --> 00:51:25,000
你把锅油洗了

2168
00:51:25,000 --> 00:51:26,000
对吧

2169
00:51:26,000 --> 00:51:29,000
此时我就可以说我在做并行

2170
00:51:29,000 --> 00:51:33,000
因为我在同一时间同时做很多事情

2171
00:51:33,000 --> 00:51:35,000
此时就是 parallel

2172
00:51:35,000 --> 00:51:38,000
我不知道这样是不是

2173
00:51:38,000 --> 00:51:41,000
所以这个从一个开阔的说法来讲

2174
00:51:41,000 --> 00:51:46,000
就是说并发 concurrency 是一个组织事物的概念

2175
00:51:46,000 --> 00:51:48,000
就是说你可以把事物独立出来

2176
00:51:48,000 --> 00:51:51,000
它互相之间是没有因果关系

2177
00:51:51,000 --> 00:51:52,000
或者是依赖关系的

2178
00:51:52,000 --> 00:51:54,000
它可以被并发执行

2179
00:51:54,000 --> 00:51:56,000
但你实际做的时候

2180
00:51:56,000 --> 00:51:58,000
你是不是真的同时在做几件

2181
00:51:58,000 --> 00:52:00,000
互相可以并发的事情

2182
00:52:00,000 --> 00:52:01,000
则不一定

2183
00:52:01,000 --> 00:52:03,000
就好像刚才你说这个做饭的例子

2184
00:52:03,000 --> 00:52:05,000
你有很多并发的那个任务

2185
00:52:05,000 --> 00:52:07,000
比如说洗碗是一个

2186
00:52:07,000 --> 00:52:08,000
切菜可能是一个

2187
00:52:08,000 --> 00:52:11,000
然后这个怎么洗锅可能又是一个

2188
00:52:11,000 --> 00:52:13,000
但是因为你就一个人

2189
00:52:13,000 --> 00:52:13,000
你还没有

2190
00:52:13,000 --> 00:52:16,000
并没有把这些并发的任务并行执行

2191
00:52:16,000 --> 00:52:18,000
也就是说你在面对一个 concurrency 的问题的时候

2192
00:52:18,000 --> 00:52:23,000
你可能没有办法用 parallel 的方式去解决它

2193
00:52:23,000 --> 00:52:27,000
而你用 parallel 的方式去解决问题

2194
00:52:27,000 --> 00:52:30,000
也有可能根本不是 concurrency 的问题

2195
00:52:30,000 --> 00:52:34,000
但是当时后者这样的例子可能比较难以解出来

2196
00:52:34,000 --> 00:52:36,000
对我刚才就在想说

2197
00:52:36,000 --> 00:52:37,000
我们刚才讲了说

2198
00:52:37,000 --> 00:52:41,000
那是不是说并行

2199
00:52:41,000 --> 00:52:44,000
就是 parallel 的前提是并发吗

2200
00:52:44,000 --> 00:52:44,000
你说不是

2201
00:52:44,000 --> 00:52:46,000
那有什么反例吗

2202
00:52:46,000 --> 00:52:51,000
比如说吧

2203
00:52:51,000 --> 00:52:54,000
我要在五个抽屉里面

2204
00:52:54,000 --> 00:52:55,000
我有五个抽屉

2205
00:52:55,000 --> 00:52:57,000
五个抽屉里面装满了围棋子

2206
00:52:57,000 --> 00:53:00,000
其中五个抽屉里面有一万个围棋子

2207
00:53:00,000 --> 00:53:01,000
只有一个是黑的

2208
00:53:01,000 --> 00:53:02,000
其他都是白的

2209
00:53:02,000 --> 00:53:03,000
我要在这

2210
00:53:03,000 --> 00:53:05,000
我要把那个黑的围棋子找出来

2211
00:53:05,000 --> 00:53:08,000
你说这是 concurrency 的问题吗

2212
00:53:08,000 --> 00:53:09,000
其实不是

2213
00:53:09,000 --> 00:53:14,000
这件事情本身没有任何 concurrency 在里面

2214
00:53:14,000 --> 00:53:15,000
不是吗

2215
00:53:15,000 --> 00:53:16,000
我只需要找到那个黑

2216
00:53:16,000 --> 00:53:18,000
找到黑围棋子是我唯一的目的

2217
00:53:18,000 --> 00:53:23,000
我觉得这个可能有

2218
00:53:23,000 --> 00:53:24,000
看你的这个什么定

2219
00:53:24,000 --> 00:53:25,000
叫什么

2220
00:53:25,000 --> 00:53:27,000
你的 task 的划定是怎么样子的

2221
00:53:27,000 --> 00:53:28,000
如果你划定 task 是

2222
00:53:28,000 --> 00:53:30,000
我有五个 task

2223
00:53:30,000 --> 00:53:32,000
就分别在每一个抽屉里面

2224
00:53:32,000 --> 00:53:34,000
找那个一个黑色的围棋子

2225
00:53:34,000 --> 00:53:34,000
对吧

2226
00:53:34,000 --> 00:53:37,000
这个时候它又是一个并发的概念

2227
00:53:37,000 --> 00:53:41,000
所以我觉得可能大致上可以这么认为

2228
00:53:41,000 --> 00:53:45,000
就是说并发是并行的先决条件

2229
00:53:45,000 --> 00:53:48,000
但并行并不是并发的必然结果

2230
00:53:48,000 --> 00:53:50,000
可以这么说

2231
00:53:50,000 --> 00:53:50,000
好吧

2232
00:53:50,000 --> 00:53:51,000
就或者说

2233
00:53:51,000 --> 00:53:53,000
如果你可以把问题转化为一个

2234
00:53:53,000 --> 00:53:55,000
能够并发的问题

2235
00:53:55,000 --> 00:53:58,000
那你基本上就可以用并行的方式去解决它

2236
00:53:58,000 --> 00:54:00,000
嗯哼

2237
00:54:00,000 --> 00:54:01,000
如果这个

2238
00:54:01,000 --> 00:54:03,000
多的那个 resource

2239
00:54:03,000 --> 00:54:03,000
就资源去

2240
00:54:03,000 --> 00:54:05,000
并发去做

2241
00:54:05,000 --> 00:54:07,000
刚才在你那个

2242
00:54:07,000 --> 00:54:08,000
作发那个例子里面

2243
00:54:08,000 --> 00:54:09,000
这个资源就是说

2244
00:54:09,000 --> 00:54:10,000
你得有两个人

2245
00:54:10,000 --> 00:54:11,000
或者是三个人

2246
00:54:11,000 --> 00:54:12,000
或者四个人

2247
00:54:12,000 --> 00:54:14,000
但在电脑的就是处理器这个

2248
00:54:14,000 --> 00:54:15,000
你得有多个处理器

2249
00:54:15,000 --> 00:54:16,000
就多核

2250
00:54:16,000 --> 00:54:17,000
或者是多个 CPU

2251
00:54:17,000 --> 00:54:19,000
或者说

2252
00:54:19,000 --> 00:54:21,000
更特上的就是多个逻辑单元

2253
00:54:21,000 --> 00:54:22,000
你可能

2254
00:54:22,000 --> 00:54:22,000
对

2255
00:54:22,000 --> 00:54:23,000
可以去

2256
00:54:23,000 --> 00:54:24,000
对

2257
00:54:24,000 --> 00:54:25,000
嗯

2258
00:54:25,000 --> 00:54:26,000
比如说对

2259
00:54:26,000 --> 00:54:28,000
早期的计算机

2260
00:54:28,000 --> 00:54:30,000
可能的确是不具备并发

2261
00:54:30,000 --> 00:54:32,000
就是单核处理器吗

2262
00:54:32,000 --> 00:54:32,000
对

2263
00:54:32,000 --> 00:54:33,000
甚至不是

2264
00:54:33,000 --> 00:54:35,000
先不说单核处理器

2265
00:54:35,000 --> 00:54:35,000
这个

2266
00:54:35,000 --> 00:54:36,000
这件事情

2267
00:54:36,000 --> 00:54:38,000
就是你在单核处理器上

2268
00:54:38,000 --> 00:54:38,000
可以用

2269
00:54:38,000 --> 00:54:39,000
可以在

2270
00:54:39,000 --> 00:54:42,000
操作系统层面去

2271
00:54:42,000 --> 00:54:43,000
去模拟

2272
00:54:43,000 --> 00:54:44,000
parallel

2273
00:54:44,000 --> 00:54:45,000
但是在

2274
00:54:45,000 --> 00:54:47,000
真正的早期的计算机里面

2275
00:54:47,000 --> 00:54:48,000
就连

2276
00:54:48,000 --> 00:54:49,000
连

2277
00:54:49,000 --> 00:54:49,000
连并

2278
00:54:49,000 --> 00:54:52,000
连这种操作系统层面的并行

2279
00:54:52,000 --> 00:54:54,000
都是不存在的

2280
00:54:54,000 --> 00:54:54,000
就

2281
00:54:54,000 --> 00:54:55,000
并发

2282
00:54:55,000 --> 00:54:56,000
并发

2283
00:54:56,000 --> 00:54:57,000
嗯

2284
00:54:57,000 --> 00:54:59,000
操作系统层面的并行

2285
00:54:59,000 --> 00:54:59,000
是不存在

2286
00:54:59,000 --> 00:55:00,000
我觉得

2287
00:55:00,000 --> 00:55:01,000
我想要说的就是

2288
00:55:01,000 --> 00:55:02,000
比如说那个时候

2289
00:55:02,000 --> 00:55:04,000
并发肯定是

2290
00:55:04,000 --> 00:55:05,000
呃

2291
00:55:05,000 --> 00:55:06,000
存在的

2292
00:55:06,000 --> 00:55:06,000
比如说你

2293
00:55:06,000 --> 00:55:08,000
一方面要读软盘

2294
00:55:08,000 --> 00:55:09,000
另一方面要刷新

2295
00:55:09,000 --> 00:55:10,000
屏幕上的字符

2296
00:55:10,000 --> 00:55:11,000
这个时候你已经有

2297
00:55:11,000 --> 00:55:12,000
那个了吗

2298
00:55:12,000 --> 00:55:13,000
有那个叫什么

2299
00:55:13,000 --> 00:55:15,000
有多任务了吗

2300
00:55:15,000 --> 00:55:16,000
没有多任务

2301
00:55:16,000 --> 00:55:17,000
我的意思就是

2302
00:55:17,000 --> 00:55:18,000
在很早很早的时代

2303
00:55:18,000 --> 00:55:19,000
没有多任务的时代

2304
00:55:19,000 --> 00:55:21,000
当你在读软盘的时候

2305
00:55:21,000 --> 00:55:23,000
你的屏幕就是卡死的

2306
00:55:23,000 --> 00:55:25,000
就那个时候

2307
00:55:25,000 --> 00:55:26,000
计算机是没有办法

2308
00:55:26,000 --> 00:55:27,000
用任何

2309
00:55:27,000 --> 00:55:29,000
用任何

2310
00:55:29,000 --> 00:55:30,000
不管是真实的

2311
00:55:30,000 --> 00:55:31,000
还是虚假的

2312
00:55:31,000 --> 00:55:32,000
并行手段

2313
00:55:32,000 --> 00:55:32,000
去解决这些

2314
00:55:32,000 --> 00:55:33,000
并发的问题

2315
00:55:33,000 --> 00:55:34,000
嗯

2316
00:55:34,000 --> 00:55:35,000
对

2317
00:55:35,000 --> 00:55:36,000
然后后来我们就有了

2318
00:55:36,000 --> 00:55:38,000
这种就所谓的

2319
00:55:38,000 --> 00:55:40,000
这个多任务机制

2320
00:55:40,000 --> 00:55:40,000
就是在

2321
00:55:40,000 --> 00:55:42,000
哪怕是在单一执行

2322
00:55:42,000 --> 00:55:43,000
单一逻辑盒的

2323
00:55:43,000 --> 00:55:44,000
处理这个计算机上

2324
00:55:44,000 --> 00:55:45,000
我们也可以

2325
00:55:45,000 --> 00:55:46,000
就假装我们是在

2326
00:55:46,000 --> 00:55:48,000
同时执行很多事情

2327
00:55:48,000 --> 00:55:49,000
比如说

2328
00:55:49,000 --> 00:55:50,000
我看最早实现

2329
00:55:50,000 --> 00:55:51,000
那个什么

2330
00:55:51,000 --> 00:55:52,000
就民用的话

2331
00:55:52,000 --> 00:55:53,000
应该是 Windows

2332
00:55:53,000 --> 00:55:54,000
32 还是 95

2333
00:55:54,000 --> 00:55:54,000
32 吧

2334
00:55:54,000 --> 00:55:57,000
你要是说最早的话

2335
00:55:57,000 --> 00:55:59,000
在 UNIX 下面

2336
00:55:59,000 --> 00:55:59,000
很早就有

2337
00:55:59,000 --> 00:56:02,000
就大规模使用的情况下

2338
00:56:02,000 --> 00:56:03,000
就是不可能用的

2339
00:56:03,000 --> 00:56:04,000
应该是 95 吧

2340
00:56:04,000 --> 00:56:04,000
我觉得

2341
00:56:04,000 --> 00:56:10,000
95 不是强顿是多任务

2342
00:56:10,000 --> 00:56:11,000
所以 32

2343
00:56:11,000 --> 00:56:12,000
32 已经有多任务了

2344
00:56:12,000 --> 00:56:13,000
32 已经有多任务了

2345
00:56:13,000 --> 00:56:14,000
就是那个时候

2346
00:56:14,000 --> 00:56:14,000
就已经有多任务

2347
00:56:14,000 --> 00:56:15,000
就是可以在

2348
00:56:15,000 --> 00:56:17,000
你在实现

2349
00:56:17,000 --> 00:56:18,000
你在前

2350
00:56:18,000 --> 00:56:19,000
你在放一首歌的时候

2351
00:56:19,000 --> 00:56:21,000
同时打开一个图片

2352
00:56:21,000 --> 00:56:22,000
比如说可以做这么一件事情

2353
00:56:22,000 --> 00:56:25,000
你 DOS 是大概是不能这样的吗

2354
00:56:25,000 --> 00:56:26,000
对

2355
00:56:26,000 --> 00:56:27,000
但是

2356
00:56:27,000 --> 00:56:27,000
等等

2357
00:56:27,000 --> 00:56:28,000
Windows 32

2358
00:56:28,000 --> 00:56:31,000
可能这个术语需要解释一下

2359
00:56:31,000 --> 00:56:31,000
就是

2360
00:56:31,000 --> 00:56:34,000
我们说 32 其实指 Windows 3.0

2361
00:56:34,000 --> 00:56:34,000
因为

2362
00:56:34,000 --> 00:56:36,000
Windows 3.2

2363
00:56:36,000 --> 00:56:38,000
其实是只有中国地区才有

2364
00:56:38,000 --> 00:56:39,000
Windows 3.2

2365
00:56:39,000 --> 00:56:40,000
是这样吗

2366
00:56:40,000 --> 00:56:40,000
对

2367
00:56:40,000 --> 00:56:41,000
Windows 3.2

2368
00:56:41,000 --> 00:56:43,000
其实就是一个 Windows 3.1 的简体中文版

2369
00:56:43,000 --> 00:56:44,000
啊

2370
00:56:44,000 --> 00:56:44,000
这样

2371
00:56:44,000 --> 00:56:45,000
我不知道

2372
00:56:45,000 --> 00:56:45,000
对

2373
00:56:45,000 --> 00:56:47,000
所以我们经常说 Windows 3.2

2374
00:56:47,000 --> 00:56:51,000
但其实这个概念仅限于中文圈里面

2375
00:56:51,000 --> 00:56:52,000
Windows 3 吧

2376
00:56:52,000 --> 00:56:53,000
我们都有多称

2377
00:56:53,000 --> 00:56:54,000
对

2378
00:56:54,000 --> 00:56:55,000
Windows 3 是一个比较好的

2379
00:56:55,000 --> 00:56:56,000
特别

2380
00:56:56,000 --> 00:56:57,000
术语

2381
00:56:57,000 --> 00:56:58,000
对

2382
00:56:58,000 --> 00:56:58,000
对

2383
00:56:58,000 --> 00:57:00,000
然后后来就有了这个多任务

2384
00:57:00,000 --> 00:57:01,000
就可以实现刚才那个功能

2385
00:57:01,000 --> 00:57:04,000
但是那个处理器还是一次只做一件事

2386
00:57:04,000 --> 00:57:06,000
就是他他放一会儿这个歌

2387
00:57:06,000 --> 00:57:09,000
还有把那个处理器核心切到去画一会儿图

2388
00:57:09,000 --> 00:57:11,000
然后再再切回来放一会儿歌

2389
00:57:11,000 --> 00:57:13,000
然后再切回来画一会儿图

2390
00:57:13,000 --> 00:57:14,000
他只要切得够快

2391
00:57:14,000 --> 00:57:18,000
给人的错觉是说他同时在做两件事

2392
00:57:18,000 --> 00:57:22,000
就是他在并行的执行两件并发的任务

2393
00:57:22,000 --> 00:57:23,000
但其实他只是一个单

2394
00:57:23,000 --> 00:57:25,000
他并不是并行的

2395
00:57:25,000 --> 00:57:27,000
他只是一个不带不带气化的一个东西

2396
00:57:27,000 --> 00:57:30,000
他就像闪电侠一样可以自己跟自己打乒乓球

2397
00:57:30,000 --> 00:57:31,000
对

2398
00:57:31,000 --> 00:57:32,000
这个是非常好的

2399
00:57:32,000 --> 00:57:33,000
对

2400
00:57:33,000 --> 00:57:35,000
这个是很好的比喻

2401
00:57:35,000 --> 00:57:37,000
然后真正到了要有 Pyro

2402
00:57:37,000 --> 00:57:38,000
就是有并发的感觉

2403
00:57:38,000 --> 00:57:39,000
还是有这个

2404
00:57:39,000 --> 00:57:41,000
就当时有单核处理器

2405
00:57:41,000 --> 00:57:42,000
有多线程的时候

2406
00:57:42,000 --> 00:57:43,000
就 hyperthreading 的时候

2407
00:57:43,000 --> 00:57:44,000
就是一个处理器核心

2408
00:57:44,000 --> 00:57:47,000
它模拟成两个逻辑盒在用

2409
00:57:47,000 --> 00:57:47,000
好

2410
00:57:47,000 --> 00:57:51,000
也包括到我们现在的真正的多个物理核的情况下

2411
00:57:51,000 --> 00:57:53,000
甚至在一些工作站

2412
00:57:53,000 --> 00:57:55,000
或者是服务器上所谓的那种多 CPU

2413
00:57:55,000 --> 00:57:58,000
就是不只有一个 CPU 的芯片

2414
00:57:58,000 --> 00:58:00,000
它有可能两个或者四个这样

2415
00:58:00,000 --> 00:58:00,000
对

2416
00:58:00,000 --> 00:58:03,000
这样只有到这个时候才

2417
00:58:03,000 --> 00:58:05,000
我们才说真正的 parallelism

2418
00:58:05,000 --> 00:58:05,000
并行

2419
00:58:05,000 --> 00:58:06,000
对

2420
00:58:06,000 --> 00:58:07,000
一进世界

2421
00:58:07,000 --> 00:58:08,000
对

2422
00:58:08,000 --> 00:58:11,000
不过其实并行在

2423
00:58:11,000 --> 00:58:14,000
在我们讲 CPU 的时候

2424
00:58:14,000 --> 00:58:16,000
是可能比较晚近才出现

2425
00:58:16,000 --> 00:58:19,000
但是他在讲那个 GPU

2426
00:58:19,000 --> 00:58:20,000
就图形状的机会的时候

2427
00:58:20,000 --> 00:58:21,000
它确实一直存在的

2428
00:58:21,000 --> 00:58:23,000
因为我们知道这个 GPU 的

2429
00:58:23,000 --> 00:58:27,000
它是一个大规模并行化的这种一种结构

2430
00:58:27,000 --> 00:58:29,000
就是因为图像处理这件事情

2431
00:58:29,000 --> 00:58:32,000
它与生俱来就存在着这么一个

2432
00:58:32,000 --> 00:58:37,000
可以被并行执行的问题

2433
00:58:37,000 --> 00:58:42,000
就是你需要大规模的改变一张图上的每一个点

2434
00:58:42,000 --> 00:58:48,000
那这就有点像你需要同时给两万个抽屉

2435
00:58:48,000 --> 00:58:52,000
在两万抽屉里面找有没有黑白黑子这样

2436
00:58:52,000 --> 00:58:57,000
所以这件事情是可以天生的被批量的

2437
00:58:57,000 --> 00:59:00,000
以流水线的方式并行处理的

2438
00:59:00,000 --> 00:59:01,000
所以也就是因为这个

2439
00:59:01,000 --> 00:59:03,000
这种问题的特别性

2440
00:59:03,000 --> 00:59:05,000
所以才会有 GPU 这种东西出现

2441
00:59:05,000 --> 00:59:07,000
而且就是 GPU 如果你能

2442
00:59:07,000 --> 00:59:10,000
你的问题可以被简化为

2443
00:59:10,000 --> 00:59:12,000
或者不叫复杂化为

2444
00:59:12,000 --> 00:59:15,000
这个 GPU 的那种适合模型的话

2445
00:59:15,000 --> 00:59:17,000
你能获得到这个所谓的 tune to 能力

2446
00:59:17,000 --> 00:59:18,000
就是 throughput

2447
00:59:18,000 --> 00:59:20,000
是非常非常惊人的

2448
00:59:20,000 --> 00:59:20,000
没错

2449
00:59:20,000 --> 00:59:21,000
而反过来讲

2450
00:59:21,000 --> 00:59:24,000
这也就是为什么很多跟 GPU

2451
00:59:24,000 --> 00:59:26,000
跟图像处理

2452
00:59:26,000 --> 00:59:27,000
其实没有任何联系的事情

2453
00:59:27,000 --> 00:59:28,000
可以交由 GPU 来做

2454
00:59:28,000 --> 00:59:29,000
比如说

2455
00:59:29,000 --> 00:59:31,000
Bitcoin mining

2456
00:59:31,000 --> 00:59:33,000
还有 GPU 来做

2457
00:59:33,000 --> 00:59:37,000
就是因为它其实也是一个可以天生的

2458
00:59:37,000 --> 00:59:41,000
被很好的并行处理的任务

2459
00:59:41,000 --> 00:59:42,000
对于这一类问题

2460
00:59:42,000 --> 00:59:45,000
我们一般有一个就所谓的一个名称

2461
00:59:45,000 --> 00:59:46,000
专有名称

2462
00:59:46,000 --> 00:59:47,000
说的叫做

2463
00:59:47,000 --> 00:59:49,000
embarrassly paralysable test

2464
00:59:49,000 --> 00:59:50,000
对不对

2465
00:59:50,000 --> 00:59:52,000
非常尴尬的

2466
00:59:52,000 --> 00:59:54,000
可以被并行化执行的问题

2467
00:59:54,000 --> 00:59:55,000
没错

2468
00:59:55,000 --> 00:59:56,000
这就好像

2469
00:59:56,000 --> 00:59:59,000
罚你

2470
00:59:59,000 --> 01:00:00,000
小学的时候

2471
01:00:00,000 --> 01:00:01,000
罚你把某一句话

2472
01:00:01,000 --> 01:00:02,000
抄几百天

2473
01:00:02,000 --> 01:00:05,000
就大家会用五支笔

2474
01:00:05,000 --> 01:00:06,000
五支笔

2475
01:00:06,000 --> 01:00:08,000
可能非常惊人的

2476
01:00:08,000 --> 01:00:10,000
非常了不起的小伙伴

2477
01:00:10,000 --> 01:00:10,000
才能做到

2478
01:00:10,000 --> 01:00:11,000
固定在一起

2479
01:00:11,000 --> 01:00:12,000
一般人用三支笔

2480
01:00:12,000 --> 01:00:14,000
同时抄课文是可以做到

2481
01:00:14,000 --> 01:00:16,000
把一个字写两千遍

2482
01:00:16,000 --> 01:00:19,000
这就是一个非常 embarrassing

2483
01:00:19,000 --> 01:00:21,000
parallel task

2484
01:00:21,000 --> 01:00:23,000
没错

2485
01:00:23,000 --> 01:00:25,000
其实这是一个很好的意思

2486
01:00:25,000 --> 01:00:28,000
就是把某一次超级前变

2487
01:00:28,000 --> 01:00:29,000
这是其实一个

2488
01:00:29,000 --> 01:00:31,000
其实就是一个

2489
01:00:31,000 --> 01:00:33,000
并不是非常 concurrency

2490
01:00:33,000 --> 01:00:35,000
但是可以被 parallel

2491
01:00:35,000 --> 01:00:36,000
执行的任务

2492
01:00:36,000 --> 01:00:39,000
所以有一件事情是可以确定的

2493
01:00:39,000 --> 01:00:41,000
就是现代的编程世界

2494
01:00:41,000 --> 01:00:43,000
是离开了并发模型

2495
01:00:43,000 --> 01:00:44,000
基本上是

2496
01:00:44,000 --> 01:00:46,000
或者说并行处理能力

2497
01:00:46,000 --> 01:00:47,000
是没有办法

2498
01:00:47,000 --> 01:00:49,000
没有办法

2499
01:00:49,000 --> 01:00:49,000
继续下去的

2500
01:00:49,000 --> 01:00:50,000
可以这么说

2501
01:00:50,000 --> 01:00:51,000
就是比较传统的

2502
01:00:51,000 --> 01:00:52,000
所谓 sequential programming model

2503
01:00:52,000 --> 01:00:57,000
是在现代的编程领域

2504
01:00:57,000 --> 01:00:58,000
所要处理的问题面前

2505
01:00:58,000 --> 01:01:00,000
是毫无还经质力的

2506
01:01:00,000 --> 01:01:01,000
所以我们无论如何

2507
01:01:01,000 --> 01:01:04,000
是需要 parallelism

2508
01:01:04,000 --> 01:01:06,000
那问题就来了

2509
01:01:06,000 --> 01:01:07,000
就是 parallelism

2510
01:01:07,000 --> 01:01:08,000
其实是一个

2511
01:01:08,000 --> 01:01:10,000
怎么说的

2512
01:01:10,000 --> 01:01:12,000
描述起来比较简单的概念

2513
01:01:12,000 --> 01:01:13,000
或者当你理解

2514
01:01:13,000 --> 01:01:14,000
做起来很复杂

2515
01:01:14,000 --> 01:01:15,000
但做起来

2516
01:01:15,000 --> 01:01:16,000
人们不同的人

2517
01:01:16,000 --> 01:01:18,000
有不同的意见的

2518
01:01:18,000 --> 01:01:19,000
这么一个一件事情

2519
01:01:19,000 --> 01:01:23,000
就最最简单的一个

2520
01:01:23,000 --> 01:01:25,000
一种一种并发模型

2521
01:01:25,000 --> 01:01:26,000
或者说并行模型

2522
01:01:26,000 --> 01:01:28,000
我觉得接下来的节目

2523
01:01:28,000 --> 01:01:28,000
我们还是

2524
01:01:28,000 --> 01:01:30,000
混用并发并行这个词吧

2525
01:01:30,000 --> 01:01:32,000
不然实在是太累了

2526
01:01:32,000 --> 01:01:33,000
你说呢

2527
01:01:33,000 --> 01:01:35,000
就是在不区分

2528
01:01:35,000 --> 01:01:37,000
不严格区分

2529
01:01:37,000 --> 01:01:39,000
并发并行的场合的情况下

2530
01:01:39,000 --> 01:01:39,000
这两者有时候

2531
01:01:39,000 --> 01:01:41,000
又是在混用的

2532
01:01:41,000 --> 01:01:42,000
对 没错

2533
01:01:42,000 --> 01:01:44,000
对

2534
01:01:44,000 --> 01:01:46,000
所以接下来的

2535
01:01:46,000 --> 01:01:47,000
接下来当我说到

2536
01:01:47,000 --> 01:01:48,000
并发模型的时候

2537
01:01:48,000 --> 01:01:49,000
其实我的意思

2538
01:01:49,000 --> 01:01:50,000
有可能是并行模型

2539
01:01:50,000 --> 01:01:54,000
但我说并行模型的时候

2540
01:01:54,000 --> 01:01:55,000
一般肯定是在讲并行模型

2541
01:01:55,000 --> 01:01:57,000
对

2542
01:01:57,000 --> 01:02:00,000
所以最基本的一种并行模型

2543
01:02:00,000 --> 01:02:01,000
是什么呢

2544
01:02:01,000 --> 01:02:03,000
我觉得是 thread

2545
01:02:03,000 --> 01:02:05,000
就是现成

2546
01:02:05,000 --> 01:02:07,000
或者说应该说

2547
01:02:07,000 --> 01:02:10,000
最基本的一种并行模型

2548
01:02:10,000 --> 01:02:12,000
应该是多进程

2549
01:02:12,000 --> 01:02:14,000
Multiprocess

2550
01:02:14,000 --> 01:02:17,000
如果真的要追根溯源的话

2551
01:02:17,000 --> 01:02:18,000
那应该可能还是

2552
01:02:18,000 --> 01:02:22,000
多进程限于多现成出现

2553
01:02:22,000 --> 01:02:22,000
对吧

2554
01:02:22,000 --> 01:02:23,000
没错

2555
01:02:23,000 --> 01:02:24,000
因为起码在

2556
01:02:24,000 --> 01:02:26,000
我记得 Linux

2557
01:02:26,000 --> 01:02:28,000
非常晚进才出现多现成

2558
01:02:28,000 --> 01:02:30,000
最开始的意思就是

2559
01:02:30,000 --> 01:02:31,000
多进程的模型

2560
01:02:31,000 --> 01:02:32,000
对 因为在 Linux 上面

2561
01:02:32,000 --> 01:02:35,000
开一个进程的方法

2562
01:02:35,000 --> 01:02:36,000
开一个进程

2563
01:02:36,000 --> 01:02:37,000
要比开一个现成简单很多

2564
01:02:37,000 --> 01:02:40,000
对 而且开销也不是特别大

2565
01:02:40,000 --> 01:02:40,000
就是它的

2566
01:02:40,000 --> 01:02:42,000
多一个进程的开销

2567
01:02:42,000 --> 01:02:44,000
是相对小的

2568
01:02:44,000 --> 01:02:45,000
对 距离技术系

2569
01:02:45,000 --> 01:02:46,000
我们就不解释了

2570
01:02:46,000 --> 01:02:51,000
但是其最根本的想法

2571
01:02:51,000 --> 01:02:53,000
就是在一个编程语言里面

2572
01:02:53,000 --> 01:02:55,000
如果我们要利用多进程

2573
01:02:55,000 --> 01:02:56,000
或者是多现成的话

2574
01:02:56,000 --> 01:02:58,000
好 那我就显示的写出来

2575
01:02:58,000 --> 01:03:00,000
这里请开一个新的进程

2576
01:03:00,000 --> 01:03:01,000
或者利用 fork

2577
01:03:01,000 --> 01:03:02,000
或者怎么样

2578
01:03:02,000 --> 01:03:03,000
然后或者说在这里

2579
01:03:03,000 --> 01:03:06,000
请开一个新的现成

2580
01:03:06,000 --> 01:03:08,000
用 thread

2581
01:03:08,000 --> 01:03:14,000
然后这就是非常简单

2582
01:03:14,000 --> 01:03:17,000
直接 至少对于硬件来说

2583
01:03:17,000 --> 01:03:19,000
非常简单 直接的一种

2584
01:03:19,000 --> 01:03:21,000
并行开发的模型

2585
01:03:21,000 --> 01:03:25,000
但是这种并行开发的模型

2586
01:03:25,000 --> 01:03:25,000
有一个问题

2587
01:03:25,000 --> 01:03:27,000
就是对于程序来说

2588
01:03:27,000 --> 01:03:27,000
比较挑战

2589
01:03:27,000 --> 01:03:30,000
因为受限于

2590
01:03:30,000 --> 01:03:32,000
我们只有一个大脑的限制

2591
01:03:32,000 --> 01:03:33,000
或者说我们的思维

2592
01:03:33,000 --> 01:03:34,000
天生就是一个

2593
01:03:34,000 --> 01:03:36,000
现信的思维

2594
01:03:36,000 --> 01:03:38,000
一个单现成的

2595
01:03:38,000 --> 01:03:39,000
一个单进程的思维

2596
01:03:39,000 --> 01:03:43,000
所以在理解多进程的时候

2597
01:03:43,000 --> 01:03:45,000
会有一个

2598
01:03:45,000 --> 01:03:46,000
会有一个

2599
01:03:46,000 --> 01:03:47,000
会有个卡

2600
01:03:47,000 --> 01:03:48,000
我不知道你怎么样

2601
01:03:48,000 --> 01:03:50,000
但是当我写出人生

2602
01:03:50,000 --> 01:03:52,000
第一个多进程的程序的时候

2603
01:03:52,000 --> 01:03:53,000
我是

2604
01:03:53,000 --> 01:03:55,000
我是愣了很久的

2605
01:03:55,000 --> 01:03:56,000
就是我需要

2606
01:03:56,000 --> 01:03:59,000
我需要去拥有那种

2607
01:03:59,000 --> 01:04:00,000
精神分裂的能力

2608
01:04:00,000 --> 01:04:01,000
就是在这个地方

2609
01:04:01,000 --> 01:04:02,000
我们需要判断说

2610
01:04:02,000 --> 01:04:03,000
我的 PID 是零

2611
01:04:03,000 --> 01:04:06,000
那我是一个新的进程

2612
01:04:06,000 --> 01:04:10,000
那接下来我所要做这些事情

2613
01:04:10,000 --> 01:04:12,000
然后另外一些事情

2614
01:04:12,000 --> 01:04:14,000
则要在我的附近程里面进行

2615
01:04:14,000 --> 01:04:15,000
然后这个时候

2616
01:04:15,000 --> 01:04:15,000
我就会有一种

2617
01:04:15,000 --> 01:04:17,000
会有一种

2618
01:04:17,000 --> 01:04:18,000
会有一种

2619
01:04:18,000 --> 01:04:20,000
精分的感觉

2620
01:04:20,000 --> 01:04:20,000
对

2621
01:04:20,000 --> 01:04:21,000
会有什么非常精分的感觉

2622
01:04:21,000 --> 01:04:22,000
就会觉得说

2623
01:04:22,000 --> 01:04:23,000
好吧

2624
01:04:23,000 --> 01:04:24,000
那

2625
01:04:24,000 --> 01:04:26,000
计算机

2626
01:04:26,000 --> 01:04:28,000
解释这一切的时候

2627
01:04:28,000 --> 01:04:29,000
可能会比较

2628
01:04:29,000 --> 01:04:30,000
比较方便

2629
01:04:30,000 --> 01:04:31,000
但是我

2630
01:04:31,000 --> 01:04:32,000
我就会不停地去想说

2631
01:04:32,000 --> 01:04:34,000
那我现在是在附近程里

2632
01:04:34,000 --> 01:04:35,000
还是在紫禁程里呢

2633
01:04:35,000 --> 01:04:36,000
那我做完了这件事情

2634
01:04:36,000 --> 01:04:38,000
我要回到附近程里面

2635
01:04:38,000 --> 01:04:39,000
那附近程里面

2636
01:04:39,000 --> 01:04:40,000
要做收尾工作

2637
01:04:40,000 --> 01:04:41,000
可是万一紫禁程没有

2638
01:04:41,000 --> 01:04:44,000
及时地完成这些事情

2639
01:04:44,000 --> 01:04:45,000
附近程又要等他吗

2640
01:04:45,000 --> 01:04:46,000
就是

2641
01:04:46,000 --> 01:04:47,000
在

2642
01:04:47,000 --> 01:04:49,000
我将

2643
01:04:49,000 --> 01:04:49,000
我记得在

2644
01:04:49,000 --> 01:04:52,000
学操作性能还是什么的时候

2645
01:04:52,000 --> 01:04:54,000
有很大一个篇幅

2646
01:04:54,000 --> 01:04:55,000
都是在讲

2647
01:04:55,000 --> 01:04:56,000
多进程

2648
01:04:56,000 --> 01:04:58,000
或者多线程的实现原理的

2649
01:04:58,000 --> 01:04:59,000
就比如说什么

2650
01:04:59,000 --> 01:05:01,000
很多很经典的

2651
01:05:01,000 --> 01:05:02,000
数学问题

2652
01:05:02,000 --> 01:05:03,000
数学模型

2653
01:05:03,000 --> 01:05:05,000
也是在这个领域被提出来

2654
01:05:05,000 --> 01:05:05,000
比如说什么

2655
01:05:05,000 --> 01:05:06,000
我忘了

2656
01:05:06,000 --> 01:05:07,000
哲学家吃饭问题

2657
01:05:07,000 --> 01:05:08,000
就是什么

2658
01:05:08,000 --> 01:05:09,000
一个哲学家

2659
01:05:09,000 --> 01:05:10,000
左边是刀

2660
01:05:10,000 --> 01:05:10,000
右边是叉

2661
01:05:10,000 --> 01:05:11,000
对

2662
01:05:11,000 --> 01:05:12,000
然后

2663
01:05:12,000 --> 01:05:14,000
没错

2664
01:05:14,000 --> 01:05:16,000
等等

2665
01:05:16,000 --> 01:05:17,000
而且我觉得

2666
01:05:17,000 --> 01:05:18,000
我印象里面

2667
01:05:18,000 --> 01:05:18,000
没记错的话

2668
01:05:18,000 --> 01:05:19,000
这本书的

2669
01:05:19,000 --> 01:05:21,000
英文版里面

2670
01:05:21,000 --> 01:05:23,000
哲学家是左手刀

2671
01:05:23,000 --> 01:05:23,000
左手刀

2672
01:05:23,000 --> 01:05:24,000
右手插

2673
01:05:24,000 --> 01:05:25,000
然后到中文版里面

2674
01:05:25,000 --> 01:05:26,000
变成了

2675
01:05:26,000 --> 01:05:28,000
哲学家左右各有一只筷子

2676
01:05:28,000 --> 01:05:28,000
你只有

2677
01:05:28,000 --> 01:05:30,000
就连这个地方

2678
01:05:30,000 --> 01:05:31,000
有本地话

2679
01:05:31,000 --> 01:05:32,000
你不需要

2680
01:05:32,000 --> 01:05:34,000
你不需要拿到两只筷子

2681
01:05:34,000 --> 01:05:34,000
才可以进餐

2682
01:05:34,000 --> 01:05:35,000
对

2683
01:05:35,000 --> 01:05:37,000
我记得那时候特别可笑

2684
01:05:37,000 --> 01:05:38,000
当时

2685
01:05:38,000 --> 01:05:39,000
课堂上有个同学

2686
01:05:39,000 --> 01:05:40,000
讲了一个笑话

2687
01:05:40,000 --> 01:05:41,000
就说

2688
01:05:41,000 --> 01:05:43,000
他们为什么不都换成长勺子

2689
01:05:43,000 --> 01:05:44,000
然后互相喂饭吃

2690
01:05:44,000 --> 01:05:46,000
这就跟

2691
01:05:46,000 --> 01:05:48,000
这就跟另外一个

2692
01:05:48,000 --> 01:05:51,000
也是哲学上的一个笑话

2693
01:05:51,000 --> 01:05:52,000
联系来的

2694
01:05:52,000 --> 01:05:53,000
就是说哲学上说

2695
01:05:53,000 --> 01:05:55,000
有一个

2696
01:05:55,000 --> 01:05:57,000
一堆人围坐在一口锅前面

2697
01:05:57,000 --> 01:05:58,000
要吃饭

2698
01:05:58,000 --> 01:06:00,000
但是每个人的勺子都特别长

2699
01:06:00,000 --> 01:06:02,000
没有办法把他转过来

2700
01:06:02,000 --> 01:06:04,000
为自己吃饭

2701
01:06:04,000 --> 01:06:06,000
所以每个人必须去

2702
01:06:06,000 --> 01:06:08,000
喂对方吃饭

2703
01:06:08,000 --> 01:06:09,000
所有人才不会饿死

2704
01:06:09,000 --> 01:06:12,000
然后这个故事被他在这边

2705
01:06:12,000 --> 01:06:13,000
转移到这个

2706
01:06:13,000 --> 01:06:15,000
哲学家饿死的里面

2707
01:06:15,000 --> 01:06:16,000
我觉得当时特别有习惯

2708
01:06:16,000 --> 01:06:22,000
刚才讲你说这个并发

2709
01:06:22,000 --> 01:06:25,000
并行变成 parallel programming

2710
01:06:25,000 --> 01:06:27,000
的一个核心的问题

2711
01:06:27,000 --> 01:06:29,000
就是可能对程序员的要求

2712
01:06:29,000 --> 01:06:33,000
就有数量级的提高

2713
01:06:33,000 --> 01:06:35,000
因为确实如你所说

2714
01:06:35,000 --> 01:06:36,000
这个人的思维很多

2715
01:06:36,000 --> 01:06:37,000
它是一个单线的一个过程

2716
01:06:37,000 --> 01:06:39,000
那没办法去同时考虑

2717
01:06:39,000 --> 01:06:41,000
你大脑不是一个

2718
01:06:41,000 --> 01:06:42,000
多好多核的东西

2719
01:06:42,000 --> 01:06:43,000
没错

2720
01:06:43,000 --> 01:06:46,000
那么其实就可能在传统的

2721
01:06:46,000 --> 01:06:47,000
线性编程的情况下

2722
01:06:47,000 --> 01:06:50,000
你的这个思维逻辑

2723
01:06:50,000 --> 01:06:52,000
跟着这个程序代码走一遍

2724
01:06:52,000 --> 01:06:53,000
你也知道计算机

2725
01:06:53,000 --> 01:06:54,000
也是这么执行的

2726
01:06:54,000 --> 01:06:55,000
并且不会有任何人

2727
01:06:55,000 --> 01:06:57,000
干扰你中间这个执行的步骤

2728
01:06:57,000 --> 01:06:58,000
当然可能中断

2729
01:06:58,000 --> 01:06:59,000
那些什么除外

2730
01:06:59,000 --> 01:07:00,000
没错

2731
01:07:00,000 --> 01:07:03,000
但是在一个并行的条件下

2732
01:07:03,000 --> 01:07:05,000
这个事情就变得非常诡异了

2733
01:07:05,000 --> 01:07:06,000
就是如果你不考虑

2734
01:07:06,000 --> 01:07:08,000
什么锁的那些机制

2735
01:07:08,000 --> 01:07:09,000
什么同步机制的话

2736
01:07:09,000 --> 01:07:11,000
它是有无限多种

2737
01:07:11,000 --> 01:07:12,000
可能有两个

2738
01:07:12,000 --> 01:07:14,000
就是两个或者多个

2739
01:07:14,000 --> 01:07:15,000
这种线程也好

2740
01:07:15,000 --> 01:07:15,000
进程也好

2741
01:07:15,000 --> 01:07:17,000
它可以我们叫做 interleaving

2742
01:07:17,000 --> 01:07:19,000
就是互相交织

2743
01:07:19,000 --> 01:07:20,000
互相交织

2744
01:07:20,000 --> 01:07:20,000
对

2745
01:07:20,000 --> 01:07:21,000
对

2746
01:07:21,000 --> 01:07:22,000
这个时候你就很难去看

2747
01:07:22,000 --> 01:07:23,000
看明白说

2748
01:07:23,000 --> 01:07:24,000
或者说

2749
01:07:24,000 --> 01:07:26,000
你要你的脑袋中

2750
01:07:26,000 --> 01:07:28,000
要装的那个 state space

2751
01:07:28,000 --> 01:07:30,000
就是他你到这一步的时候

2752
01:07:30,000 --> 01:07:31,000
其他人可能会怎么样

2753
01:07:31,000 --> 01:07:32,000
这种东西

2754
01:07:32,000 --> 01:07:34,000
它就是一个指数增长的东西

2755
01:07:34,000 --> 01:07:36,000
所以这个时候对人的思维挑战

2756
01:07:36,000 --> 01:07:37,000
确实是一个极其困难的

2757
01:07:37,000 --> 01:07:38,000
一个过程

2758
01:07:38,000 --> 01:07:39,000
一个过程

2759
01:07:39,000 --> 01:07:41,000
而且就为了解决这个问题

2760
01:07:41,000 --> 01:07:43,000
就是你们也有很多这种方案

2761
01:07:43,000 --> 01:07:44,000
比如说

2762
01:07:44,000 --> 01:07:46,000
最可能我们听到最多的一条

2763
01:07:46,000 --> 01:07:47,000
就说

2764
01:07:47,000 --> 01:07:49,000
shared mutable state is bad

2765
01:07:49,000 --> 01:07:49,000
is evil

2766
01:07:49,000 --> 01:07:50,000
对吧

2767
01:07:50,000 --> 01:07:51,000
就是如果你是

2768
01:07:51,000 --> 01:07:52,000
你是并行

2769
01:07:52,000 --> 01:07:54,000
并行编程的东西

2770
01:07:54,000 --> 01:07:56,000
然后你还要多个县程也好

2771
01:07:56,000 --> 01:07:57,000
进程也好

2772
01:07:57,000 --> 01:07:57,000
去共

2773
01:07:57,000 --> 01:07:59,000
去同时访问一个

2774
01:07:59,000 --> 01:08:00,000
可以被改写的一个

2775
01:08:00,000 --> 01:08:03,000
内存区域或者是变量

2776
01:08:03,000 --> 01:08:04,000
或者文件也好

2777
01:08:04,000 --> 01:08:05,000
这个时候你就非常困难了

2778
01:08:05,000 --> 01:08:07,000
因为你没有办法

2779
01:08:07,000 --> 01:08:11,000
从被改写的区域的角度来看

2780
01:08:11,000 --> 01:08:14,000
你能预测到会产生什么样的组合

2781
01:08:14,000 --> 01:08:16,000
因为这个组合是不确定性的

2782
01:08:16,000 --> 01:08:16,000
是一个叫做

2783
01:08:16,000 --> 01:08:18,000
indeterministic

2784
01:08:18,000 --> 01:08:22,000
就是不确定性的一个过程

2785
01:08:22,000 --> 01:08:22,000
没错

2786
01:08:22,000 --> 01:08:25,000
所以很多时候我们的一个解决方案

2787
01:08:25,000 --> 01:08:27,000
就说那么最好就是叫做

2788
01:08:27,000 --> 01:08:27,000
shared nothing

2789
01:08:27,000 --> 01:08:30,000
就是一切都不要共享的结构

2790
01:08:30,000 --> 01:08:31,000
这样的话有什么好处呢

2791
01:08:31,000 --> 01:08:34,000
这样你就可以在并行的环境下

2792
01:08:34,000 --> 01:08:36,000
对于某一个县程或者是进程也好

2793
01:08:36,000 --> 01:08:40,000
你不用考虑他和别的进程和县程的交互

2794
01:08:40,000 --> 01:08:40,000
怎么样

2795
01:08:40,000 --> 01:08:42,000
你只用考虑他自己本身是一个线性的

2796
01:08:42,000 --> 01:08:44,000
线性的程序走下去就好了

2797
01:08:44,000 --> 01:08:48,000
这个时候就等于说是把一个并行的问题

2798
01:08:48,000 --> 01:08:52,000
变成了一个线性的串行的问题来解决了

2799
01:08:52,000 --> 01:08:57,000
但实际上这种情况是不太可行的

2800
01:08:57,000 --> 01:08:59,000
就可能有一些比较极端的例子

2801
01:08:59,000 --> 01:09:01,000
是所谓这种 share nothing 结构的东西

2802
01:09:01,000 --> 01:09:03,000
比如说我们很多的网页服务器

2803
01:09:03,000 --> 01:09:06,000
他可能都是比如 apache 就是一个很典型的例子

2804
01:09:06,000 --> 01:09:08,000
他每一个请求来

2805
01:09:08,000 --> 01:09:09,000
他可能都是开一个新的进程

2806
01:09:09,000 --> 01:09:13,000
或者开个新的县程来响应这个请求

2807
01:09:13,000 --> 01:09:15,000
然后响应完毕这个进程或者县程也就被杀掉了

2808
01:09:15,000 --> 01:09:16,000
但这个传统的模型

2809
01:09:16,000 --> 01:09:20,000
然后在响应这个请求的县程

2810
01:09:20,000 --> 01:09:21,000
或者是进程执行的过程中

2811
01:09:21,000 --> 01:09:24,000
他你是不用考虑别的县程或者进程怎么样

2812
01:09:24,000 --> 01:09:25,000
因为你没有共享任何东西

2813
01:09:25,000 --> 01:09:28,000
但是在实际应用中

2814
01:09:28,000 --> 01:09:30,000
很多时候你确实是要共享东西的

2815
01:09:30,000 --> 01:09:32,000
比如说我们现在很多做什么 web app

2816
01:09:32,000 --> 01:09:33,000
对吧

2817
01:09:33,000 --> 01:09:35,000
你是要访问一个共享的数据库的

2818
01:09:35,000 --> 01:09:36,000
那你可能要访问一个

2819
01:09:36,000 --> 01:09:40,000
同一个共享的数据库

2820
01:09:40,000 --> 01:09:41,000
然后可能要改写东西

2821
01:09:41,000 --> 01:09:42,000
这个时候你又变成

2822
01:09:42,000 --> 01:09:44,000
本来是一个 share nothing 东西

2823
01:09:44,000 --> 01:09:46,000
又变成有一个 shared mutable state

2824
01:09:46,000 --> 01:09:49,000
这样的话整个模型就又变得很复杂

2825
01:09:49,000 --> 01:09:51,000
而且难以测试起来

2826
01:09:51,000 --> 01:09:54,000
县程加上锁这种结构

2827
01:09:54,000 --> 01:09:56,000
就好像一个到处漏水的桶

2828
01:09:56,000 --> 01:09:59,000
你总会觉得我堵住这个孔就没问题了

2829
01:09:59,000 --> 01:10:01,000
但是因为你堵住了这个孔

2830
01:10:01,000 --> 01:10:02,000
所以水压变高了

2831
01:10:02,000 --> 01:10:03,000
它会从另外一地方漏出来

2832
01:10:03,000 --> 01:10:07,000
所以有时候用县程锁编程的时候

2833
01:10:07,000 --> 01:10:11,000
你会觉得自己不仅思考的

2834
01:10:11,000 --> 01:10:11,000
大地数

2835
01:10:11,000 --> 01:10:14,000
对思考的层级非常低

2836
01:10:14,000 --> 01:10:15,000
就是你会被迫自己

2837
01:10:15,000 --> 01:10:20,000
你迫使强迫自己像一个县程挂理器那样去思考

2838
01:10:20,000 --> 01:10:22,000
而且与此同时你会发现

2839
01:10:22,000 --> 01:10:24,000
解决了一个问题

2840
01:10:24,000 --> 01:10:25,000
另外一个问题又冒出来了

2841
01:10:25,000 --> 01:10:26,000
对

2842
01:10:26,000 --> 01:10:27,000
对

2843
01:10:27,000 --> 01:10:28,000
故此是比嘛

2844
01:10:28,000 --> 01:10:29,000
没错

2845
01:10:29,000 --> 01:10:29,000
故此是比

2846
01:10:29,000 --> 01:10:30,000
这就是为什么

2847
01:10:30,000 --> 01:10:33,000
虽然县程或者说多建成

2848
01:10:33,000 --> 01:10:34,000
或者多建成

2849
01:10:34,000 --> 01:10:35,000
加上锁这种机制

2850
01:10:35,000 --> 01:10:37,000
在几乎所有像样的

2851
01:10:37,000 --> 01:10:40,000
像样一点的程序里面都有支持

2852
01:10:40,000 --> 01:10:43,000
但是用好它们却是非常

2853
01:10:43,000 --> 01:10:45,000
非常难

2854
01:10:45,000 --> 01:10:49,000
而且我觉得这种难是没有必要的一种难的事情

2855
01:10:49,000 --> 01:10:53,000
就是这是一个可能不是一个太好的抽象

2856
01:10:53,000 --> 01:10:54,000
就得出了这么一个

2857
01:10:54,000 --> 01:10:55,000
对

2858
01:10:55,000 --> 01:10:57,000
它的抽象层级可能实在是太低了

2859
01:10:57,000 --> 01:10:57,000
就有点像

2860
01:10:57,000 --> 01:11:01,000
或者说它抽象的那个角度是错的

2861
01:11:01,000 --> 01:11:01,000
就是

2862
01:11:01,000 --> 01:11:03,000
或者说它

2863
01:11:03,000 --> 01:11:04,000
我怎么说的

2864
01:11:04,000 --> 01:11:07,000
我觉得它抽象的角度没有错不错之分

2865
01:11:07,000 --> 01:11:09,000
因为在操似这种层面上

2866
01:11:09,000 --> 01:11:12,000
并行就是这么被实现的

2867
01:11:12,000 --> 01:11:16,000
它与其说它的抽象角度是错的

2868
01:11:16,000 --> 01:11:18,000
比如说它它所抽象的东西

2869
01:11:18,000 --> 01:11:19,000
但是太少了

2870
01:11:19,000 --> 01:11:23,000
就是基本上你要从非常底层的

2871
01:11:23,000 --> 01:11:24,000
不够有用的抽象

2872
01:11:24,000 --> 01:11:24,000
对不对

2873
01:11:24,000 --> 01:11:25,000
没错

2874
01:11:25,000 --> 01:11:27,000
这就是为什么

2875
01:11:27,000 --> 01:11:30,000
接下来我们会提到几种其他的

2876
01:11:30,000 --> 01:11:33,000
并行模型

2877
01:11:33,000 --> 01:11:37,000
就是它们试图从不同的角度去解决这个问题

2878
01:11:37,000 --> 01:11:40,000
但是如果没说错的话

2879
01:11:40,000 --> 01:11:46,000
很多并行模型的基本实现原理

2880
01:11:46,000 --> 01:11:48,000
还是通过县城的锁

2881
01:11:48,000 --> 01:11:51,000
就底层它是这么实现的

2882
01:11:51,000 --> 01:11:53,000
但是就是它暴露给这个开发者

2883
01:11:53,000 --> 01:11:55,000
或者程序员的这么一个

2884
01:11:55,000 --> 01:11:57,000
一个接口或者是一个表象

2885
01:11:57,000 --> 01:11:59,000
它并你看不到那些东西了

2886
01:11:59,000 --> 01:12:00,000
对

2887
01:12:00,000 --> 01:12:04,000
这其实是回到我们前很多情绪

2888
01:12:04,000 --> 01:12:07,000
至少很长时间以前讲的封装的

2889
01:12:07,000 --> 01:12:10,000
那么一个问题领域

2890
01:12:10,000 --> 01:12:15,000
就是我们接下来要介绍了几种并发模型

2891
01:12:15,000 --> 01:12:19,000
其实是对于多线程枷锁的这样一种封装

2892
01:12:19,000 --> 01:12:21,000
但是这种封装

2893
01:12:21,000 --> 01:12:23,000
当你熟悉了它之后

2894
01:12:23,000 --> 01:12:26,000
你会发现它在很大程度上

2895
01:12:26,000 --> 01:12:31,000
增加了你思考的方便程度

2896
01:12:31,000 --> 01:12:33,000
或者说让你变得更像一个人了

2897
01:12:33,000 --> 01:12:33,000
而不像一个机器

2898
01:12:33,000 --> 01:12:36,000
不用站在头脑中模拟

2899
01:12:36,000 --> 01:12:39,000
费劲的用一个单核处理器的大脑

2900
01:12:39,000 --> 01:12:41,000
去模拟一个多核处理器的 CPU

2901
01:12:41,000 --> 01:12:43,000
对没错

2902
01:12:43,000 --> 01:12:51,000
那你觉得除了多线程的模型之外

2903
01:12:51,000 --> 01:12:56,000
哪一种并发模型是最简单

2904
01:12:56,000 --> 01:12:57,000
或者说最直接

2905
01:12:57,000 --> 01:12:59,000
能够让人比较方便接受

2906
01:12:59,000 --> 01:13:05,000
那最好就是不要让我去想

2907
01:13:05,000 --> 01:13:08,000
去让我思考有这些底层

2908
01:13:08,000 --> 01:13:10,000
最理想的模型是

2909
01:13:10,000 --> 01:13:12,000
不要让我思考有这么一些东西存在的东西

2910
01:13:12,000 --> 01:13:15,000
那可能用从语言层面上来解决这个问题的话

2911
01:13:15,000 --> 01:13:17,000
如果你能实现

2912
01:13:17,000 --> 01:13:20,000
我们传统意义上的什么 FP

2913
01:13:20,000 --> 01:13:22,000
就是函数式编程的话

2914
01:13:22,000 --> 01:13:24,000
这可能就根本不用考虑这个问题了

2915
01:13:24,000 --> 01:13:26,000
因为函数式编程

2916
01:13:26,000 --> 01:13:29,000
每一个函数在纯粹的一个函数式编程里面

2917
01:13:29,000 --> 01:13:31,000
所谓的函数都是所谓的确定性结果的

2918
01:13:31,000 --> 01:13:33,000
这样的话

2919
01:13:33,000 --> 01:13:35,000
不管你怎么去执行它

2920
01:13:35,000 --> 01:13:36,000
你总是得到一个确定性的解的

2921
01:13:36,000 --> 01:13:38,000
那我不管你是顺序执行

2922
01:13:38,000 --> 01:13:39,000
并发执行

2923
01:13:39,000 --> 01:13:39,000
像是怎么样

2924
01:13:39,000 --> 01:13:41,000
你一个什么任意组合

2925
01:13:41,000 --> 01:13:42,000
我都不用管

2926
01:13:42,000 --> 01:13:42,000
我只能考虑

2927
01:13:42,000 --> 01:13:44,000
这个函数是这么写的

2928
01:13:44,000 --> 01:13:47,000
我输入这个数得到这个结果

2929
01:13:47,000 --> 01:13:47,000
那就完了

2930
01:13:47,000 --> 01:13:50,000
就根本不存在并发并行那些概念在里面

2931
01:13:50,000 --> 01:13:51,000
没错

2932
01:13:51,000 --> 01:13:53,000
我觉得可能 Functional Programming

2933
01:13:53,000 --> 01:13:59,000
所给我们最大的益处就在于

2934
01:13:59,000 --> 01:14:03,000
之前我们讨论的线程枷锁

2935
01:14:03,000 --> 01:14:05,000
所要解决的最基本问题

2936
01:14:05,000 --> 01:14:08,000
就是有一个 Changeable State

2937
01:14:08,000 --> 01:14:11,000
被 Functional Programming 彻底抹去了

2938
01:14:11,000 --> 01:14:15,000
就是如果一切问题的输入

2939
01:14:15,000 --> 01:14:17,000
乃至其中间状态

2940
01:14:17,000 --> 01:14:18,000
全都是确定的话

2941
01:14:18,000 --> 01:14:22,000
那别人根本不可能改它

2942
01:14:22,000 --> 01:14:24,000
在我看来

2943
01:14:24,000 --> 01:14:26,000
我也就不需要锁了不是吗

2944
01:14:26,000 --> 01:14:27,000
对啊

2945
01:14:27,000 --> 01:14:30,000
所以这就是为什么 Functional Programming

2946
01:14:30,000 --> 01:14:32,000
为我们提供了这样一种

2947
01:14:32,000 --> 01:14:36,000
从完全从不同角度去实现并行的机制

2948
01:14:36,000 --> 01:14:39,000
会让我们思考起来更方便的原因

2949
01:14:39,000 --> 01:14:40,000
对

2950
01:14:40,000 --> 01:14:42,000
就是说到一个最极端的例子

2951
01:14:42,000 --> 01:14:44,000
就是如果从先不考虑

2952
01:14:44,000 --> 01:14:46,000
这个实现的这个经济性来讲

2953
01:14:46,000 --> 01:14:48,000
就是说起码从逻辑上来讲

2954
01:14:48,000 --> 01:14:49,000
如果你整个语言是一个

2955
01:14:49,000 --> 01:14:51,000
纯粹的 Functional 的一个

2956
01:14:51,000 --> 01:14:53,000
就是纯粹是一个函数式的过程的话

2957
01:14:53,000 --> 01:14:57,000
每一步执行都是可以被并发执行的

2958
01:14:57,000 --> 01:14:58,000
就理论上说你每一步都可以

2959
01:14:58,000 --> 01:15:01,000
分辨到任意多个处理上去同时执行

2960
01:15:01,000 --> 01:15:02,000
然后得到一个解

2961
01:15:02,000 --> 01:15:03,000
然后再进行下一步的这个

2962
01:15:03,000 --> 01:15:05,000
这个叫什么 Reduction

2963
01:15:05,000 --> 01:15:06,000
然后得到一个最终的解出来

2964
01:15:06,000 --> 01:15:07,000
对

2965
01:15:07,000 --> 01:15:09,000
对

2966
01:15:09,000 --> 01:15:11,000
然后这样一种模型

2967
01:15:11,000 --> 01:15:15,000
它所带来的便利是非常显著的

2968
01:15:15,000 --> 01:15:17,000
但是从另外一个讲度讲

2969
01:15:17,000 --> 01:15:19,000
Functional Programming

2970
01:15:19,000 --> 01:15:23,000
写起来也是比较具有挑战性的

2971
01:15:23,000 --> 01:15:26,000
因为你只是

2972
01:15:26,000 --> 01:15:27,000
或你不只是

2973
01:15:27,000 --> 01:15:29,000
但是当你没有

2974
01:15:29,000 --> 01:15:31,000
Global Changeable State 的时候

2975
01:15:31,000 --> 01:15:34,000
你就会需要用另外的方法去解决它

2976
01:15:34,000 --> 01:15:45,000
而 Functional Programming 可能会要求你比较痛苦的去转化你的思维模型

2977
01:15:45,000 --> 01:15:48,000
那有没有一个比较好的例子可以说明

2978
01:15:48,000 --> 01:15:56,000
为什么 Functional Programming 可以比较有效的实现并发执行呢

2979
01:15:56,000 --> 01:16:01,000
我觉得可能最简单就是一个计算器的例子

2980
01:16:01,000 --> 01:16:04,000
就能够可能比较容易懂吧

2981
01:16:04,000 --> 01:16:07,000
就是我们计算一个常用的四则运算的时候

2982
01:16:07,000 --> 01:16:09,000
我们比如说

2983
01:16:09,000 --> 01:16:10,000
我举个最简单的例子

2984
01:16:10,000 --> 01:16:11,000
三乘一四

2985
01:16:11,000 --> 01:16:12,000
加五乘一六

2986
01:16:12,000 --> 01:16:14,000
这个公式

2987
01:16:14,000 --> 01:16:16,000
我们如果是人做会怎么样

2988
01:16:16,000 --> 01:16:18,000
那我们现在算三乘一四

2989
01:16:18,000 --> 01:16:19,000
十二

2990
01:16:19,000 --> 01:16:20,000
所以写在一边

2991
01:16:20,000 --> 01:16:22,000
然后再算五乘一六

2992
01:16:22,000 --> 01:16:23,000
等于到三十

2993
01:16:23,000 --> 01:16:23,000
就写在一边

2994
01:16:23,000 --> 01:16:25,000
然后再两个球颗加起来三十二

2995
01:16:25,000 --> 01:16:26,000
对吧

2996
01:16:26,000 --> 01:16:26,000
不错

2997
01:16:26,000 --> 01:16:30,000
但是如果是给机器来做的话

2998
01:16:30,000 --> 01:16:33,000
因为你整个四则运算中间的每一步

2999
01:16:33,000 --> 01:16:34,000
都是确定性结果

3000
01:16:34,000 --> 01:16:36,000
因为确定性输入的确定性结果

3001
01:16:36,000 --> 01:16:37,000
这样的话

3002
01:16:37,000 --> 01:16:39,000
它可以同时计算三乘一四和五乘一六

3003
01:16:39,000 --> 01:16:41,000
或者说它是甚至先计算五乘一六

3004
01:16:41,000 --> 01:16:42,000
再计算三乘一四

3005
01:16:42,000 --> 01:16:44,000
然后再把再去全之和

3006
01:16:44,000 --> 01:16:47,000
就是在这个过程中你可以看到

3007
01:16:47,000 --> 01:16:50,000
不管你的这个计算结果

3008
01:16:50,000 --> 01:16:54,000
并不会因为你计算的顺序有任何改变

3009
01:16:54,000 --> 01:16:56,000
而导致你的这个结果有任何变化

3010
01:16:56,000 --> 01:16:58,000
这个时候的话

3011
01:16:58,000 --> 01:17:01,000
那机器就可以做很多很多这样的优化

3012
01:17:01,000 --> 01:17:04,000
就可以把那些能够同时并行

3013
01:17:04,000 --> 01:17:06,000
这些东西都并行起来

3014
01:17:06,000 --> 01:17:06,000
对

3015
01:17:06,000 --> 01:17:08,000
假设你的这个算式

3016
01:17:08,000 --> 01:17:12,000
没有像三乘四加五乘六这么吹

3017
01:17:12,000 --> 01:17:16,000
而是一个比如说两百位的数字

3018
01:17:16,000 --> 01:17:17,000
乘以两百位的数字

3019
01:17:17,000 --> 01:17:19,000
然后这样

3020
01:17:19,000 --> 01:17:24,000
然后要给比如说五六百个这样的结果求和

3021
01:17:24,000 --> 01:17:27,000
那这样的多任务

3022
01:17:27,000 --> 01:17:30,000
这样并发的模型就可以很好用

3023
01:17:30,000 --> 01:17:33,000
很好用 Functional Program 的并行模型来解决

3024
01:17:33,000 --> 01:17:37,000
甚至我觉得其实也是一个很好的 MapReduce 的

3025
01:17:37,000 --> 01:17:38,000
没错

3026
01:17:38,000 --> 01:17:42,000
的解决的怎么说一个例子

3027
01:17:42,000 --> 01:17:44,000
如果你要像一个门外人

3028
01:17:44,000 --> 01:17:47,000
门外和解释什么叫 MapReduce

3029
01:17:47,000 --> 01:17:50,000
当然门外还为什么要对 MapReduce 成了兴趣

3030
01:17:50,000 --> 01:17:50,000
是另外一个问题

3031
01:17:50,000 --> 01:17:53,000
但如果你要像一个人解释什么是 MapReduce

3032
01:17:53,000 --> 01:17:54,000
你就可以说

3033
01:17:54,000 --> 01:17:55,000
让你算

3034
01:17:55,000 --> 01:17:58,000
让计算机算三乘四加五乘六

3035
01:17:58,000 --> 01:18:00,000
Map 这一步就是

3036
01:18:00,000 --> 01:18:01,000
给一个

3037
01:18:01,000 --> 01:18:03,000
让一个计算器算三乘四

3038
01:18:03,000 --> 01:18:05,000
然后让另外一个算五乘六

3039
01:18:05,000 --> 01:18:09,000
而 Reduce 则是把三乘四的结果和五乘六的结果加在一起

3040
01:18:09,000 --> 01:18:10,000
没错

3041
01:18:10,000 --> 01:18:13,000
但是这个

3042
01:18:13,000 --> 01:18:15,000
就是函数式变成

3043
01:18:15,000 --> 01:18:17,000
我怎么说有这么好的特性

3044
01:18:17,000 --> 01:18:19,000
但是它问题是在什么地方呢

3045
01:18:19,000 --> 01:18:20,000
问题在于

3046
01:18:20,000 --> 01:18:23,000
现实世界的很多问题并不能

3047
01:18:23,000 --> 01:18:27,000
简单或者很方便的归结于一个函数式

3048
01:18:27,000 --> 01:18:31,000
一个就是非可变状态的一种场景来去解

3049
01:18:31,000 --> 01:18:32,000
比如说

3050
01:18:32,000 --> 01:18:34,000
最简单的一个输出的时候

3051
01:18:34,000 --> 01:18:37,000
你就会牵涉到跟外部世界的状态的沟通了

3052
01:18:37,000 --> 01:18:38,000
这个时候

3053
01:18:38,000 --> 01:18:42,000
根据你的这个输入和的这个值不一样

3054
01:18:42,000 --> 01:18:44,000
你能可能某一些计算结果

3055
01:18:44,000 --> 01:18:46,000
就是如果它是依然于外部输入的话

3056
01:18:46,000 --> 01:18:49,000
它就并不是一个你可以在

3057
01:18:49,000 --> 01:18:51,000
单看这个程序本身可以预见的一个

3058
01:18:51,000 --> 01:18:53,000
预见的一个解了吗

3059
01:18:53,000 --> 01:18:54,000
对

3060
01:18:54,000 --> 01:18:55,000
比如说我们最常打的

3061
01:18:55,000 --> 01:18:57,000
最常练习的一种

3062
01:18:57,000 --> 01:19:01,000
编程题目

3063
01:19:01,000 --> 01:19:04,000
就是问操作者的名字

3064
01:19:04,000 --> 01:19:06,000
然后打出 hello 操作者的名字

3065
01:19:06,000 --> 01:19:09,000
这个就是没有办法用 Functional Programming 写出来的

3066
01:19:09,000 --> 01:19:12,000
就纯粹的 Functional Programming 是没有办法处理这种问题的

3067
01:19:12,000 --> 01:19:16,000
因为你总有一步要问操作者的名字到底是什么

3068
01:19:16,000 --> 01:19:17,000
如果

3069
01:19:17,000 --> 01:19:20,000
如果它的名字

3070
01:19:20,000 --> 01:19:22,000
就或者说在你获得它的名字之前

3071
01:19:22,000 --> 01:19:25,000
你是没有办法把输出它的名字这一步

3072
01:19:25,000 --> 01:19:27,000
和问它的名字这一步

3073
01:19:27,000 --> 01:19:28,000
并行之下

3074
01:19:28,000 --> 01:19:29,000
对

3075
01:19:29,000 --> 01:19:34,000
还有一个 Functional Programming 就不能很方便的

3076
01:19:34,000 --> 01:19:37,000
就不能归结于纯粹的 Functional Programming 的一个概念

3077
01:19:37,000 --> 01:19:38,000
就是随机数

3078
01:19:38,000 --> 01:19:38,000
对吧

3079
01:19:38,000 --> 01:19:39,000
比如你要有

3080
01:19:39,000 --> 01:19:41,000
你要一个函数的结果是

3081
01:19:41,000 --> 01:19:44,000
你每次执行它的时候得到都是不确定的结果

3082
01:19:44,000 --> 01:19:46,000
这个时候它就并不是一个

3083
01:19:46,000 --> 01:19:47,000
它甚至不是一个函数

3084
01:19:47,000 --> 01:19:51,000
因为我们讲函数它应该是一个确定的结果

3085
01:19:51,000 --> 01:19:52,000
就给定输入的时候

3086
01:19:52,000 --> 01:19:54,000
应该有确定的结果

3087
01:19:54,000 --> 01:19:56,000
但如果你的这个结果是摇骰子

3088
01:19:56,000 --> 01:19:58,000
那它本来就不是一个函数

3089
01:19:58,000 --> 01:20:00,000
甚至严格意义上它并不是一个函数了

3090
01:20:00,000 --> 01:20:01,000
数学的数学概念的函数

3091
01:20:01,000 --> 01:20:02,000
没错

3092
01:20:02,000 --> 01:20:07,000
其实这也就是数学世界和统计学世界的一个根本分野

3093
01:20:07,000 --> 01:20:12,000
统计学世界所研究的世界是包含随机数发生源的

3094
01:20:12,000 --> 01:20:13,000
而数学世界

3095
01:20:13,000 --> 01:20:16,000
数学世界所处理的问题是没有这种东西存在

3096
01:20:16,000 --> 01:20:17,000
OK

3097
01:20:17,000 --> 01:20:20,000
对

3098
01:20:20,000 --> 01:20:24,000
那说完了 Functional Programming 解决并发模型的

3099
01:20:24,000 --> 01:20:28,000
或者 Functional Programming 作为并发模型之后

3100
01:20:28,000 --> 01:20:35,000
我们可以说说其他的比较不那么 radical 的

3101
01:20:35,000 --> 01:20:37,000
不那么疯狂的主义

3102
01:20:37,000 --> 01:20:38,000
对

3103
01:20:38,000 --> 01:20:44,000
不那么彻底革新人们的世界观的并发模型

3104
01:20:44,000 --> 01:20:44,000
OK

3105
01:20:44,000 --> 01:20:46,000
那对

3106
01:20:46,000 --> 01:20:50,000
所以我们刚才提到 Raw Pike 的那一篇

3107
01:20:50,000 --> 01:20:52,000
那一个展示

3108
01:20:52,000 --> 01:20:54,000
就是他向人们介绍 GoRoutine 的那个展示

3109
01:20:54,000 --> 01:20:58,000
所以作为一个 GoLang 的传福音者

3110
01:20:58,000 --> 01:21:02,000
Rail 你对 GoLang 的并发模型是怎么理解的

3111
01:21:02,000 --> 01:21:05,000
或者你可以简单的介绍一下 GoLang 里面是怎么解释

3112
01:21:05,000 --> 01:21:07,000
怎么解决并发问题的

3113
01:21:07,000 --> 01:21:07,000
OK

3114
01:21:07,000 --> 01:21:10,000
GoLang 里面它采用的并发模型其实是一个非常古老

3115
01:21:10,000 --> 01:21:14,000
而且被就是学术学研究的很透彻的一种模型

3116
01:21:14,000 --> 01:21:17,000
简单来说这是叫做 CSP

3117
01:21:17,000 --> 01:21:19,000
就是 Communicating Sequential Processes

3118
01:21:19,000 --> 01:21:20,000
什么意思

3119
01:21:20,000 --> 01:21:23,000
就是说每一个他们叫 Process

3120
01:21:23,000 --> 01:21:24,000
这也是进程

3121
01:21:24,000 --> 01:21:27,000
当然可能包括物理上是一个超性的进程也好

3122
01:21:27,000 --> 01:21:28,000
还是这个

3123
01:21:28,000 --> 01:21:30,000
县程也好

3124
01:21:30,000 --> 01:21:31,000
它这个没有关系

3125
01:21:31,000 --> 01:21:33,000
这种 Process 是一个逻辑的概念

3126
01:21:33,000 --> 01:21:35,000
它是一个线性执行的一个单元

3127
01:21:35,000 --> 01:21:37,000
然后他说什么意思

3128
01:21:37,000 --> 01:21:39,000
就是说每一个就刚刚刚讲的

3129
01:21:39,000 --> 01:21:43,000
每一个进程都是单独自己管自己的执行

3130
01:21:43,000 --> 01:21:47,000
他只是在需要跟其他进程交互的时候

3131
01:21:47,000 --> 01:21:52,000
才通过消息传递的方式来做这么一件事

3132
01:21:52,000 --> 01:21:54,000
就等别人发消息给他或者发消息给别人

3133
01:21:54,000 --> 01:21:57,000
然后就有一个叫做 Synchronization Point

3134
01:21:57,000 --> 01:21:58,000
在那个点之后

3135
01:21:58,000 --> 01:22:00,000
然后他完成了这一步之后

3136
01:22:00,000 --> 01:22:06,000
他又再回到自己的一个比较线性的执行方式去做下去

3137
01:22:06,000 --> 01:22:09,000
这个是一个比较可能简单的解释

3138
01:22:09,000 --> 01:22:13,000
所以 Synchronize Point 跟锁的差别是什么

3139
01:22:13,000 --> 01:22:17,000
它本质上就是一个锁

3140
01:22:17,000 --> 01:22:18,000
只是说在逻辑的

3141
01:22:18,000 --> 01:22:21,000
就在抽象的方式或者抽象的角度上

3142
01:22:21,000 --> 01:22:22,000
它是有点不太一样

3143
01:22:22,000 --> 01:22:27,000
他并不是说我们两个进程要共享一个

3144
01:22:27,000 --> 01:22:28,000
资源

3145
01:22:28,000 --> 01:22:30,000
对共享一个 state 了

3146
01:22:30,000 --> 01:22:32,000
所以我们先把它锁住

3147
01:22:32,000 --> 01:22:35,000
然后我们想谁先到达锁点的时候

3148
01:22:35,000 --> 01:22:36,000
先等一下

3149
01:22:36,000 --> 01:22:37,000
等另外一个人到达锁点

3150
01:22:37,000 --> 01:22:39,000
然后再把锁解开

3151
01:22:39,000 --> 01:22:41,000
然后再把资源改变

3152
01:22:41,000 --> 01:22:43,000
然后再把锁解开

3153
01:22:43,000 --> 01:22:46,000
然后被锁住的人才可以接着进行下去

3154
01:22:46,000 --> 01:22:47,000
他这样的话

3155
01:22:47,000 --> 01:22:49,000
就有你要去想

3156
01:22:49,000 --> 01:22:51,000
哪个资源是需要被锁定的

3157
01:22:51,000 --> 01:22:52,000
这就挺麻烦嘛

3158
01:22:52,000 --> 01:22:54,000
然后他这个 CSP 的话

3159
01:22:54,000 --> 01:22:55,000
他就说

3160
01:22:55,000 --> 01:22:57,000
那我们不要去考虑这个锁的问题了

3161
01:22:57,000 --> 01:22:57,000
我们默认

3162
01:22:57,000 --> 01:22:59,000
我们要互相通讯的时候

3163
01:22:59,000 --> 01:23:01,000
就是有一个隐含的锁

3164
01:23:01,000 --> 01:23:03,000
那个锁的内容

3165
01:23:03,000 --> 01:23:05,000
就是我要传递的这个消息

3166
01:23:05,000 --> 01:23:05,000
对不对

3167
01:23:05,000 --> 01:23:09,000
然后对方取得了这个消息之后

3168
01:23:09,000 --> 01:23:10,000
那我们这个锁就解开了

3169
01:23:10,000 --> 01:23:11,000
那我可以继续往下走下去

3170
01:23:11,000 --> 01:23:14,000
就所以他本质上是一个锁了

3171
01:23:14,000 --> 01:23:15,000
但是只是说

3172
01:23:15,000 --> 01:23:17,000
他的抽象的层级是不一样的

3173
01:23:17,000 --> 01:23:19,000
或者抽象的出发点是不一样的

3174
01:23:19,000 --> 01:23:19,000
这样的话

3175
01:23:19,000 --> 01:23:21,000
对人们或者这个程序员来

3176
01:23:21,000 --> 01:23:22,000
理解起来

3177
01:23:22,000 --> 01:23:24,000
他来说是更加现实一点的

3178
01:23:24,000 --> 01:23:26,000
更加现实的一个抽象吧

3179
01:23:26,000 --> 01:23:27,000
没错

3180
01:23:27,000 --> 01:23:30,000
其实我听过一个比喻

3181
01:23:30,000 --> 01:23:32,000
就是传统的现成与锁

3182
01:23:32,000 --> 01:23:33,000
有点像储物箱

3183
01:23:33,000 --> 01:23:37,000
你要去买东西

3184
01:23:37,000 --> 01:23:39,000
然后你要先把自己的

3185
01:23:39,000 --> 01:23:40,000
你在进商场之前

3186
01:23:40,000 --> 01:23:42,000
需要把自己的东西锁在一个储物柜里

3187
01:23:42,000 --> 01:23:43,000
显示的锁

3188
01:23:43,000 --> 01:23:45,000
其实就是正二八点的锁

3189
01:23:45,000 --> 01:23:47,000
当你把一个储物箱锁起来的时候

3190
01:23:47,000 --> 01:23:48,000
别人就不能再用了

3191
01:23:48,000 --> 01:23:52,000
而这样一种 CSP 的模型

3192
01:23:52,000 --> 01:23:56,000
则是有一个专门的储物管理员

3193
01:23:56,000 --> 01:23:58,000
你只需要把你的东西给他

3194
01:23:58,000 --> 01:23:59,000
说我要把这东西存起来

3195
01:23:59,000 --> 01:24:00,000
然后我去别的地方

3196
01:24:00,000 --> 01:24:04,000
他也许在背后有另外一个储物箱

3197
01:24:04,000 --> 01:24:06,000
但是你不会去直接

3198
01:24:06,000 --> 01:24:07,000
你不用关心这个细节

3199
01:24:07,000 --> 01:24:08,000
没错

3200
01:24:08,000 --> 01:24:09,000
你不用去直接关心

3201
01:24:09,000 --> 01:24:12,000
你的东西到底锁在哪个箱子里

3202
01:24:12,000 --> 01:24:13,000
以及你是不是和别人共享了

3203
01:24:13,000 --> 01:24:15,000
同样一个储物箱

3204
01:24:15,000 --> 01:24:16,000
这样的这类问题

3205
01:24:16,000 --> 01:24:17,000
你只需要告诉他说

3206
01:24:17,000 --> 01:24:18,000
我要存东西

3207
01:24:18,000 --> 01:24:18,000
然后我走了

3208
01:24:18,000 --> 01:24:19,000
然后等我回来的时候

3209
01:24:19,000 --> 01:24:20,000
我要拿东西

3210
01:24:20,000 --> 01:24:21,000
就是这么简单

3211
01:24:21,000 --> 01:24:23,000
这个比喻很好

3212
01:24:23,000 --> 01:24:24,000
就你回来拿的时候

3213
01:24:24,000 --> 01:24:25,000
你就说我要拿我之前

3214
01:24:25,000 --> 01:24:26,000
或者说你

3215
01:24:26,000 --> 01:24:28,000
甚至不一定是你本人去拿

3216
01:24:28,000 --> 01:24:29,000
比如说你的老婆帮你去

3217
01:24:29,000 --> 01:24:30,000
去拿你的包

3218
01:24:30,000 --> 01:24:32,000
但是他有那个什么盘

3219
01:24:32,000 --> 01:24:33,000
对吧

3220
01:24:33,000 --> 01:24:35,000
他就说我要拿这个几号的包

3221
01:24:35,000 --> 01:24:37,000
然后柜台的小姐

3222
01:24:37,000 --> 01:24:38,000
就去帮你拿出来

3223
01:24:38,000 --> 01:24:39,000
然后你就等

3224
01:24:39,000 --> 01:24:41,000
你中间并不需要去关心

3225
01:24:41,000 --> 01:24:42,000
他后面有多少个锁格

3226
01:24:42,000 --> 01:24:43,000
对吧

3227
01:24:43,000 --> 01:24:45,000
他后面的锁是一个拉锁呢

3228
01:24:45,000 --> 01:24:46,000
还是一个防刀

3229
01:24:46,000 --> 01:24:47,000
保险柜呢

3230
01:24:47,000 --> 01:24:48,000
还是一个什么样的东西实现

3231
01:24:48,000 --> 01:24:49,000
对

3232
01:24:49,000 --> 01:24:51,000
所以这样一种编程模型

3233
01:24:51,000 --> 01:24:56,000
也是目前比较流行的一种模型

3234
01:24:56,000 --> 01:24:56,000
我觉得

3235
01:24:56,000 --> 01:24:59,000
就是在很多语言里面都支持他

3236
01:24:59,000 --> 01:24:59,000
就 Go

3237
01:24:59,000 --> 01:25:02,000
而且是在语言层面上

3238
01:25:02,000 --> 01:25:03,000
直接支持他的

3239
01:25:03,000 --> 01:25:05,000
而其他很多语言也都是通过

3240
01:25:05,000 --> 01:25:06,000
一个 library

3241
01:25:06,000 --> 01:25:08,000
或者是其他什么机制

3242
01:25:08,000 --> 01:25:09,000
一个一个

3243
01:25:09,000 --> 01:25:10,000
主要是通过 library

3244
01:25:10,000 --> 01:25:11,000
好像只有两种可能吧

3245
01:25:11,000 --> 01:25:14,000
你要不在直接执行呢

3246
01:25:14,000 --> 01:25:15,000
对

3247
01:25:15,000 --> 01:25:16,000
要不通过一个

3248
01:25:16,000 --> 01:25:18,000
这里要可能介绍一下

3249
01:25:18,000 --> 01:25:19,000
就除了刚才讲的

3250
01:25:19,000 --> 01:25:21,000
那个 CSP 模型之外

3251
01:25:21,000 --> 01:25:23,000
有一个与他形成

3252
01:25:23,000 --> 01:25:25,000
叫做对偶关系的一个模型

3253
01:25:25,000 --> 01:25:26,000
叫做 actor model

3254
01:25:26,000 --> 01:25:27,000
这个 actor

3255
01:25:27,000 --> 01:25:29,000
我不知道这个中文怎么翻译好

3256
01:25:29,000 --> 01:25:29,000
叫做

3257
01:25:29,000 --> 01:25:33,000
演员模型

3258
01:25:33,000 --> 01:25:33,000
也不对吧

3259
01:25:33,000 --> 01:25:34,000
actor

3260
01:25:34,000 --> 01:25:37,000
就是简单的讲

3261
01:25:37,000 --> 01:25:39,000
就是说你在 CSP 的时候

3262
01:25:39,000 --> 01:25:41,000
有一种经典的方式是说

3263
01:25:41,000 --> 01:25:43,000
我们两个之间实现一个

3264
01:25:43,000 --> 01:25:44,000
所谓的这个 channel

3265
01:25:44,000 --> 01:25:46,000
一个渠道

3266
01:25:46,000 --> 01:25:47,000
我们通过这个渠道

3267
01:25:47,000 --> 01:25:48,000
来发送这个消息

3268
01:25:48,000 --> 01:25:49,000
对吧

3269
01:25:49,000 --> 01:25:50,000
就说这个渠道

3270
01:25:50,000 --> 01:25:51,000
就是我要发消息的时候

3271
01:25:51,000 --> 01:25:51,000
我要

3272
01:25:51,000 --> 01:25:53,000
我是先把这个消息

3273
01:25:53,000 --> 01:25:55,000
通过这个渠道传送给你

3274
01:25:55,000 --> 01:25:57,000
如果你那边没有

3275
01:25:57,000 --> 01:26:00,000
还没有来接收这个渠道

3276
01:26:00,000 --> 01:26:01,000
我发消息的一个人

3277
01:26:01,000 --> 01:26:03,000
还在那边等着你接收之后

3278
01:26:03,000 --> 01:26:04,000
才可以了

3279
01:26:04,000 --> 01:26:04,000
才可以走

3280
01:26:04,000 --> 01:26:07,000
大家也明白这个意思吗

3281
01:26:07,000 --> 01:26:08,000
是

3282
01:26:08,000 --> 01:26:11,000
所以 actor

3283
01:26:11,000 --> 01:26:14,000
比如说支持 actor 的语言

3284
01:26:14,000 --> 01:26:15,000
像 Alan 或者是

3285
01:26:15,000 --> 01:26:17,000
Skala 也是一个

3286
01:26:17,000 --> 01:26:18,000
Skala 支持那个叫做

3287
01:26:18,000 --> 01:26:19,000
不过 Skala 是通过

3288
01:26:19,000 --> 01:26:20,000
Aka 支持的

3289
01:26:20,000 --> 01:26:23,000
Skala 没有原生的 actor

3290
01:26:23,000 --> 01:26:23,000
他有

3291
01:26:23,000 --> 01:26:25,000
他原生是 actor 的

3292
01:26:25,000 --> 01:26:26,000
他也可以通过 JVM

3293
01:26:26,000 --> 01:26:27,000
走 Aka 那个

3294
01:26:27,000 --> 01:26:29,000
那个 library 来实现

3295
01:26:29,000 --> 01:26:29,000
actor model

3296
01:26:29,000 --> 01:26:30,000
OK

3297
01:26:30,000 --> 01:26:33,000
然后刚才讲的是

3298
01:26:33,000 --> 01:26:34,000
那个 CSP 是通过 channel

3299
01:26:34,000 --> 01:26:34,000
来实现的

3300
01:26:34,000 --> 01:26:35,000
就是说两个人要

3301
01:26:35,000 --> 01:26:37,000
同时到达

3302
01:26:37,000 --> 01:26:38,000
那个 channel 那个点

3303
01:26:38,000 --> 01:26:40,000
然后才能够传递消息

3304
01:26:40,000 --> 01:26:42,000
这是一种方式

3305
01:26:42,000 --> 01:26:42,000
对

3306
01:26:42,000 --> 01:26:43,000
而 actor 更像一个

3307
01:26:43,000 --> 01:26:45,000
怎么说更像一个代理

3308
01:26:45,000 --> 01:26:47,000
actor 是一个叫做

3309
01:26:47,000 --> 01:26:49,000
油箱的模型

3310
01:26:49,000 --> 01:26:50,000
就是说每个人

3311
01:26:50,000 --> 01:26:51,000
就每个进程

3312
01:26:51,000 --> 01:26:52,000
都是一个所谓的一个 actor

3313
01:26:52,000 --> 01:26:53,000
然后他

3314
01:26:53,000 --> 01:26:56,000
每 actor 都只做自己的事情

3315
01:26:56,000 --> 01:26:57,000
然后但是每个 actor

3316
01:26:57,000 --> 01:26:59,000
他有一个

3317
01:26:59,000 --> 01:27:01,000
给他唯一配备的一个油箱

3318
01:27:01,000 --> 01:27:03,000
然后别人的消息来的时候

3319
01:27:03,000 --> 01:27:05,000
并不直接被

3320
01:27:05,000 --> 01:27:07,000
这个 actor 拿去

3321
01:27:07,000 --> 01:27:09,000
而是说先塞进这个油箱里面

3322
01:27:09,000 --> 01:27:10,000
然后等这个 actor 处理

3323
01:27:10,000 --> 01:27:13,000
他执行到一个条件

3324
01:27:13,000 --> 01:27:13,000
之后他说

3325
01:27:13,000 --> 01:27:15,000
我需要收一个邮件

3326
01:27:15,000 --> 01:27:16,000
然后他再去看自己的油箱

3327
01:27:16,000 --> 01:27:18,000
说有没有别人

3328
01:27:18,000 --> 01:27:19,000
给我发过来的消息

3329
01:27:19,000 --> 01:27:20,000
我看一下处理一遍

3330
01:27:20,000 --> 01:27:20,000
如果没有的话

3331
01:27:20,000 --> 01:27:22,000
我再接着做自己的事情

3332
01:27:22,000 --> 01:27:25,000
所以 CSP 和 actor model

3333
01:27:25,000 --> 01:27:26,000
是两个

3334
01:27:26,000 --> 01:27:29,000
本质上是做的同样的事情

3335
01:27:29,000 --> 01:27:30,000
只是说他们在

3336
01:27:30,000 --> 01:27:31,000
在实现方式上

3337
01:27:31,000 --> 01:27:32,000
是有一点所谓的

3338
01:27:32,000 --> 01:27:33,000
对偶关系的在里面

3339
01:27:33,000 --> 01:27:34,000
OK

3340
01:27:34,000 --> 01:27:38,000
在现实中

3341
01:27:38,000 --> 01:27:39,000
其实 go 的话

3342
01:27:39,000 --> 01:27:40,000
比较

3343
01:27:40,000 --> 01:27:41,000
他并不是一个

3344
01:27:41,000 --> 01:27:42,000
纯粹的 CSP 的模型

3345
01:27:42,000 --> 01:27:43,000
因为他的那个 channel

3346
01:27:43,000 --> 01:27:44,000
刚才讲的

3347
01:27:44,000 --> 01:27:45,000
他并不是一个

3348
01:27:45,000 --> 01:27:47,000
完全是阻塞的 channel

3349
01:27:47,000 --> 01:27:47,000
因为他的 channel

3350
01:27:47,000 --> 01:27:49,000
是可以被 buffer 的

3351
01:27:49,000 --> 01:27:49,000
对

3352
01:27:49,000 --> 01:27:51,000
其实我就刚才想说

3353
01:27:51,000 --> 01:27:52,000
go 的 channel

3354
01:27:52,000 --> 01:27:53,000
难道不也是一个油箱吗

3355
01:27:53,000 --> 01:27:54,000
就他也是一个 Q

3356
01:27:54,000 --> 01:27:56,000
对

3357
01:27:56,000 --> 01:27:57,000
所以这个就是有一个

3358
01:27:57,000 --> 01:27:57,000
有一个

3359
01:27:57,000 --> 01:27:57,000
他的

3360
01:27:57,000 --> 01:27:59,000
他不是一个纯粹的 CSP

3361
01:27:59,000 --> 01:28:00,000
的这一点

3362
01:28:00,000 --> 01:28:01,000
就是因为说

3363
01:28:01,000 --> 01:28:01,000
他那个 channel

3364
01:28:01,000 --> 01:28:03,000
他鼓励你使用一个

3365
01:28:03,000 --> 01:28:05,000
叫做 blocking channel

3366
01:28:05,000 --> 01:28:06,000
就一次只能发一条消息

3367
01:28:06,000 --> 01:28:07,000
然后你必须要等

3368
01:28:07,000 --> 01:28:09,000
对方取出这个消息之后

3369
01:28:09,000 --> 01:28:10,000
你这些发送方

3370
01:28:10,000 --> 01:28:11,000
才能直接的执行下一步

3371
01:28:11,000 --> 01:28:11,000
对

3372
01:28:11,000 --> 01:28:12,000
这就是一种

3373
01:28:12,000 --> 01:28:13,000
比较纯粹的 CSP 的状态

3374
01:28:13,000 --> 01:28:14,000
但是

3375
01:28:14,000 --> 01:28:14,000
对

3376
01:28:14,000 --> 01:28:15,000
如果你不用

3377
01:28:15,000 --> 01:28:16,000
阻塞式的 channel 的话

3378
01:28:16,000 --> 01:28:18,000
其实 go somehow

3379
01:28:18,000 --> 01:28:20,000
也是用到了 actor

3380
01:28:20,000 --> 01:28:21,000
没错

3381
01:28:21,000 --> 01:28:22,000
就是他 go 的话

3382
01:28:22,000 --> 01:28:23,000
其实也是有一个

3383
01:28:23,000 --> 01:28:24,000
因为他的

3384
01:28:24,000 --> 01:28:24,000
他的 channel

3385
01:28:24,000 --> 01:28:26,000
有一个扩展

3386
01:28:26,000 --> 01:28:26,000
就是说

3387
01:28:26,000 --> 01:28:27,000
他那个 channel

3388
01:28:27,000 --> 01:28:28,000
是可以有一个 buffer 的

3389
01:28:28,000 --> 01:28:29,000
就是一个缓冲区域的

3390
01:28:29,000 --> 01:28:30,000
比如说

3391
01:28:30,000 --> 01:28:30,000
我可以声明

3392
01:28:30,000 --> 01:28:31,000
这个 channel

3393
01:28:31,000 --> 01:28:32,000
有一个 100 个位置的

3394
01:28:32,000 --> 01:28:33,000
缓冲区域

3395
01:28:33,000 --> 01:28:34,000
什么意思呢

3396
01:28:34,000 --> 01:28:36,000
我可以往这个 channel 里面塞

3397
01:28:36,000 --> 01:28:39,000
99 条消息

3398
01:28:39,000 --> 01:28:39,000
都不足塞

3399
01:28:39,000 --> 01:28:40,000
直到我塞

3400
01:28:40,000 --> 01:28:42,000
第 100 条消息的时候

3401
01:28:42,000 --> 01:28:43,000
不对

3402
01:28:43,000 --> 01:28:43,000
我可以往那个

3403
01:28:43,000 --> 01:28:45,000
我那样塞 100 条消息

3404
01:28:45,000 --> 01:28:45,000
都不足塞

3405
01:28:45,000 --> 01:28:46,000
但我往里面塞

3406
01:28:46,000 --> 01:28:47,000
第 101 条消息的时候

3407
01:28:47,000 --> 01:28:49,000
我得等那头

3408
01:28:49,000 --> 01:28:50,000
那个人

3409
01:28:50,000 --> 01:28:51,000
就是接收方

3410
01:28:51,000 --> 01:28:52,000
挪出一条消息之后

3411
01:28:52,000 --> 01:28:54,000
我才能够再往里面塞进去

3412
01:28:54,000 --> 01:28:54,000
就是说

3413
01:28:54,000 --> 01:28:55,000
它是有一个

3414
01:28:55,000 --> 01:28:56,000
这么一个 buffer

3415
01:28:56,000 --> 01:28:56,000
这么一个概念

3416
01:28:56,000 --> 01:28:58,000
这个时候的话

3417
01:28:58,000 --> 01:28:58,000
这种 channel

3418
01:28:58,000 --> 01:28:59,000
就比较类似于

3419
01:28:59,000 --> 01:29:01,000
actor model 里面的

3420
01:29:01,000 --> 01:29:02,000
这个叫什么

3421
01:29:02,000 --> 01:29:03,000
mailbox

3422
01:29:03,000 --> 01:29:04,000
是信箱的概念了

3423
01:29:04,000 --> 01:29:05,000
但是说它没有那么

3424
01:29:05,000 --> 01:29:07,000
就灵活度和这个

3425
01:29:07,000 --> 01:29:09,000
自由纯度还是不一样的

3426
01:29:09,000 --> 01:29:10,000
比如说

3427
01:29:10,000 --> 01:29:12,000
actor model 里面

3428
01:29:12,000 --> 01:29:13,000
你如果你有信箱的概念的话

3429
01:29:13,000 --> 01:29:14,000
你一个必然的推论

3430
01:29:14,000 --> 01:29:15,000
就是每一个 actor

3431
01:29:15,000 --> 01:29:16,000
它是有一个唯一的

3432
01:29:16,000 --> 01:29:17,000
确定的那个

3433
01:29:17,000 --> 01:29:18,000
识别符的一个 ID

3434
01:29:18,000 --> 01:29:19,000
对吧

3435
01:29:19,000 --> 01:29:20,000
你才知道你这个

3436
01:29:20,000 --> 01:29:21,000
你这个消息

3437
01:29:21,000 --> 01:29:21,000
是要发

3438
01:29:21,000 --> 01:29:23,000
从哪里来发给谁

3439
01:29:23,000 --> 01:29:23,000
对吧

3440
01:29:23,000 --> 01:29:24,000
你得有这么一个过程

3441
01:29:24,000 --> 01:29:26,000
但是在 go 里面的话

3442
01:29:26,000 --> 01:29:29,000
因为你可以每一个进程

3443
01:29:29,000 --> 01:29:30,000
是可以建立多个 channel 的

3444
01:29:30,000 --> 01:29:32,000
所以它的这个对应关系

3445
01:29:32,000 --> 01:29:33,000
是不太一样的

3446
01:29:33,000 --> 01:29:35,000
但本质上它们是

3447
01:29:35,000 --> 01:29:36,000
其实同一件事情

3448
01:29:36,000 --> 01:29:38,000
所以我们可以说

3449
01:29:38,000 --> 01:29:41,000
actor 模型天生就比较适合

3450
01:29:41,000 --> 01:29:45,000
分布式计算的领域

3451
01:29:45,000 --> 01:29:48,000
因为当你把你的计算模型

3452
01:29:48,000 --> 01:29:49,000
采用分布式的方式

3453
01:29:49,000 --> 01:29:50,000
来实现的时候

3454
01:29:50,000 --> 01:29:52,000
那你每一个分布式的

3455
01:29:52,000 --> 01:29:55,000
单元都会天生的

3456
01:29:55,000 --> 01:29:57,000
带有一个标识符

3457
01:29:57,000 --> 01:29:59,000
然后在这种状况下

3458
01:29:59,000 --> 01:30:00,000
你用 actor 模型的时候

3459
01:30:00,000 --> 01:30:01,000
就非常容易的

3460
01:30:01,000 --> 01:30:04,000
把你的抽象层级连在一起

3461
01:30:04,000 --> 01:30:08,000
但是如果用 go routine 的 channel 的话

3462
01:30:08,000 --> 01:30:12,000
那可能应用在分布计算的时候

3463
01:30:12,000 --> 01:30:13,000
没有那么自然

3464
01:30:13,000 --> 01:30:16,000
其实没有关系

3465
01:30:16,000 --> 01:30:17,000
这两个是可以完全互相

3466
01:30:17,000 --> 01:30:20,000
就是可以不损失任何

3467
01:30:20,000 --> 01:30:23,000
抽象层级的互相转化的

3468
01:30:23,000 --> 01:30:24,000
比如说最简单

3469
01:30:24,000 --> 01:30:25,000
一个转化的道理就是说

3470
01:30:25,000 --> 01:30:27,000
那我每

3471
01:30:27,000 --> 01:30:29,000
我怎么在用 channel 实现

3472
01:30:29,000 --> 01:30:30,000
这个 actor model

3473
01:30:30,000 --> 01:30:32,000
很简单一个道理

3474
01:30:32,000 --> 01:30:33,000
就是说我每一个 process

3475
01:30:33,000 --> 01:30:33,000
我自建

3476
01:30:33,000 --> 01:30:35,000
我在建那个 process 的时候

3477
01:30:35,000 --> 01:30:37,000
我给它一个参数

3478
01:30:37,000 --> 01:30:37,000
就是一个 channel

3479
01:30:37,000 --> 01:30:38,000
这个 channel

3480
01:30:38,000 --> 01:30:40,000
我把它命名为一个叫做

3481
01:30:40,000 --> 01:30:41,000
命名为邮箱

3482
01:30:41,000 --> 01:30:43,000
然后这个因为 channel 是有 ID 的

3483
01:30:43,000 --> 01:30:44,000
这样的话

3484
01:30:44,000 --> 01:30:46,000
我就可以认为具备

3485
01:30:46,000 --> 01:30:50,000
这个 channel 读写功能的进程

3486
01:30:50,000 --> 01:30:51,000
就是这个 actor 本身

3487
01:30:51,000 --> 01:30:53,000
对

3488
01:30:53,000 --> 01:30:53,000
我的意思就是

3489
01:30:53,000 --> 01:30:56,000
你在这样一种解决方案的

3490
01:30:56,000 --> 01:30:58,000
你在实施这样一种解决方案的时候

3491
01:30:58,000 --> 01:31:00,000
你实际上是采用了 actor 模型

3492
01:31:00,000 --> 01:31:04,000
你只不过是在用 channel 的方式去模拟它而已

3493
01:31:04,000 --> 01:31:08,000
而我们就不要去考虑

3494
01:31:08,000 --> 01:31:11,000
这个使用一种语言的机制

3495
01:31:11,000 --> 01:31:12,000
去模拟 actor 模型

3496
01:31:12,000 --> 01:31:13,000
和真正的使用 actor 模型

3497
01:31:13,000 --> 01:31:14,000
之间的差别在哪

3498
01:31:14,000 --> 01:31:16,000
我的意思是

3499
01:31:16,000 --> 01:31:17,000
当你使用另外一种语言

3500
01:31:17,000 --> 01:31:19,000
当你使用 go long 的 feature

3501
01:31:19,000 --> 01:31:21,000
去模拟 actor 模型的时候

3502
01:31:21,000 --> 01:31:23,000
其实也就意味着

3503
01:31:23,000 --> 01:31:25,000
actor 模型是比较适合在这样一种

3504
01:31:25,000 --> 01:31:29,000
问题领域里面实时并发的模型

3505
01:31:29,000 --> 01:31:30,000
不是吗

3506
01:31:30,000 --> 01:31:35,000
我不太清楚

3507
01:31:35,000 --> 01:31:38,000
就我觉得不一定

3508
01:31:38,000 --> 01:31:39,000
就是有些时候

3509
01:31:39,000 --> 01:31:41,000
是用 channel 模型是更合适的

3510
01:31:41,000 --> 01:31:44,000
有些时候是用 actor 模型是更合适的

3511
01:31:44,000 --> 01:31:46,000
所以你怎么去选择它

3512
01:31:46,000 --> 01:31:47,000
我觉得还是要看你问题的

3513
01:31:47,000 --> 01:31:48,000
就你手上具体的问题的

3514
01:31:48,000 --> 01:31:51,000
这个本身的属性来决定的

3515
01:31:51,000 --> 01:31:54,000
就并不是说 actor 模型

3516
01:31:54,000 --> 01:31:57,000
就一定天然比这种 csp 的模型

3517
01:31:57,000 --> 01:32:00,000
要来得更直观

3518
01:32:00,000 --> 01:32:01,000
或者是更易懂这样

3519
01:32:01,000 --> 01:32:02,000
好吧

3520
01:32:02,000 --> 01:32:05,000
那大概

3521
01:32:05,000 --> 01:32:10,000
我想想我们介绍了

3522
01:32:10,000 --> 01:32:12,000
传统的现成文移所

3523
01:32:12,000 --> 01:32:13,000
介绍了 fp

3524
01:32:13,000 --> 01:32:17,000
介绍了 csp 和 actor

3525
01:32:17,000 --> 01:32:19,000
那基本上我们可以说

3526
01:32:19,000 --> 01:32:23,000
已经涵盖了比较主流的

3527
01:32:23,000 --> 01:32:24,000
这种并发模型

3528
01:32:24,000 --> 01:32:25,000
对

3529
01:32:25,000 --> 01:32:25,000
当然

3530
01:32:25,000 --> 01:32:28,000
还有一些其他的并发模型

3531
01:32:28,000 --> 01:32:29,000
比如说有一本书叫

3532
01:32:29,000 --> 01:32:36,000
7 Paralysm in 7 Weeks

3533
01:32:36,000 --> 01:32:37,000
7 周

3534
01:32:37,000 --> 01:32:38,000
7 种并发模型

3535
01:32:38,000 --> 01:32:41,000
就它那本书里面已经介绍了 7 种

3536
01:32:41,000 --> 01:32:42,000
但是

3537
01:32:42,000 --> 01:32:44,000
我们今天只说了 4 种

3538
01:32:44,000 --> 01:32:44,000
但是

3539
01:32:44,000 --> 01:32:46,000
如果我印象没错的话

3540
01:32:46,000 --> 01:32:49,000
它提到的其他 3 种

3541
01:32:49,000 --> 01:32:49,000
其实都是

3542
01:32:49,000 --> 01:32:50,000
怎么说

3543
01:32:50,000 --> 01:32:53,000
要么是我们提到的这 4 种比较

3544
01:32:53,000 --> 01:32:55,000
基本的并发模型的混合

3545
01:32:55,000 --> 01:33:00,000
或者就是在更大规模上的抽象

3546
01:33:00,000 --> 01:33:02,000
当然我印象不是很深的

3547
01:33:02,000 --> 01:33:03,000
但是我推荐

3548
01:33:03,000 --> 01:33:06,000
如果对这个问题比较感兴趣的听众们

3549
01:33:06,000 --> 01:33:07,000
可以去看看这本书

3550
01:33:07,000 --> 01:33:10,000
它是另外一本叫做

3551
01:33:10,000 --> 01:33:13,000
7 Language in 7 Weeks 的姐妹书

3552
01:33:13,000 --> 01:33:14,000
另外一本书也很好

3553
01:33:14,000 --> 01:33:16,000
OK

3554
01:33:16,000 --> 01:33:21,000
然后我们就要过渡到下一个相关

3555
01:33:21,000 --> 01:33:24,000
但并不等同的话题了

3556
01:33:24,000 --> 01:33:27,000
应该说是在抽象层级上并不等同

3557
01:33:27,000 --> 01:33:28,000
对

3558
01:33:28,000 --> 01:33:30,000
但是它有点相关

3559
01:33:30,000 --> 01:33:31,000
没错

3560
01:33:31,000 --> 01:33:34,000
就是所谓的异步和非阻塞式的

3561
01:33:34,000 --> 01:33:37,000
一个程序员的设计

3562
01:33:37,000 --> 01:33:38,000
没错

3563
01:33:38,000 --> 01:33:40,000
刚才我们提到

3564
01:33:40,000 --> 01:33:42,000
在 Functional Programming

3565
01:33:42,000 --> 01:33:43,000
非常难以解决的一个问题

3566
01:33:43,000 --> 01:33:45,000
就是当你要处理 IO 的时候

3567
01:33:45,000 --> 01:33:46,000
你怎么办吧

3568
01:33:46,000 --> 01:33:48,000
就当你需要问

3569
01:33:48,000 --> 01:33:51,000
那个使用者的姓名的时候

3570
01:33:51,000 --> 01:33:54,000
你使用多个

3571
01:33:54,000 --> 01:33:58,000
当你有一种并行机制

3572
01:33:58,000 --> 01:34:00,000
并且你需要解决

3573
01:34:00,000 --> 01:34:02,000
询问使用者姓名这个问题的时候

3574
01:34:02,000 --> 01:34:04,000
你到底应该怎么办

3575
01:34:04,000 --> 01:34:06,000
这就是我们接下来需要讨论的问题

3576
01:34:06,000 --> 01:34:09,000
就是 EboIO 最恰当的抽象到底是什么

3577
01:34:09,000 --> 01:34:13,000
我们传统上

3578
01:34:13,000 --> 01:34:14,000
不叫传统上

3579
01:34:14,000 --> 01:34:15,000
可能目前用的

3580
01:34:15,000 --> 01:34:17,000
可能大家听得最熟悉的

3581
01:34:17,000 --> 01:34:19,000
就是一个叫做 Asynchronous

3582
01:34:19,000 --> 01:34:21,000
就是 EboIO 这么一个做法

3583
01:34:21,000 --> 01:34:24,000
这个主要存在于像什么 Node

3584
01:34:24,000 --> 01:34:26,000
这种一些

3585
01:34:26,000 --> 01:34:27,000
反正是

3586
01:34:27,000 --> 01:34:30,000
你要反正设计 JavaScript 的话

3587
01:34:30,000 --> 01:34:32,000
基本上都是走这种 AsyncIO 的方式

3588
01:34:32,000 --> 01:34:34,000
然后 Python 的话

3589
01:34:34,000 --> 01:34:35,000
有这个像 Tornado

3590
01:34:35,000 --> 01:34:37,000
还有之前那个叫什么 Twisted

3591
01:34:37,000 --> 01:34:39,000
都是这种方式

3592
01:34:39,000 --> 01:34:41,000
然后 Ruby 里面是有什么

3593
01:34:41,000 --> 01:34:43,000
Ruby

3594
01:34:43,000 --> 01:34:45,000
我还真的不知道

3595
01:34:45,000 --> 01:34:46,000
就 Node 它

3596
01:34:46,000 --> 01:34:48,000
比如说它底层也是用了像 C 的

3597
01:34:48,000 --> 01:34:50,000
那个叫 LibUV 来实现它的

3598
01:34:50,000 --> 01:34:51,000
EboIO 的吗

3599
01:34:51,000 --> 01:34:52,000
对我记得

3600
01:34:52,000 --> 01:34:55,000
NeoVim 它重要的

3601
01:34:55,000 --> 01:34:56,000
非常重要的那个

3602
01:34:56,000 --> 01:34:58,000
Todo 之一

3603
01:34:58,000 --> 01:34:59,000
就是要把所有的

3604
01:34:59,000 --> 01:35:04,000
VI 的那个编辑信源的 Event 都转到

3605
01:35:04,000 --> 01:35:07,000
Vim 的编辑信源的 Event 都转到 LibUV 上实现

3606
01:35:07,000 --> 01:35:09,000
对很多人现在有很多这种采用

3607
01:35:09,000 --> 01:35:13,000
那个 EboIO 的这种大型程序

3608
01:35:13,000 --> 01:35:15,000
都在改到用这一部包来实现了

3609
01:35:15,000 --> 01:35:17,000
因为它确实写得很好

3610
01:35:17,000 --> 01:35:20,000
什么跨平台也都做得挺不错的

3611
01:35:20,000 --> 01:35:22,000
然后 Java 的话

3612
01:35:22,000 --> 01:35:24,000
有那个叫做 NIO

3613
01:35:24,000 --> 01:35:26,000
就是新 IO 的那么一个库

3614
01:35:26,000 --> 01:35:29,000
也可以做这种 EboIO 的机制了

3615
01:35:29,000 --> 01:35:31,000
现在还有什么其他的主流语言的

3616
01:35:31,000 --> 01:35:31,000
好像也差不多了

3617
01:35:31,000 --> 01:35:33,000
对

3618
01:35:33,000 --> 01:35:34,000
OK

3619
01:35:34,000 --> 01:35:39,000
然后就是 EboIO 到底是做了一件什么样的事情呢

3620
01:35:39,000 --> 01:35:40,000
就是他们都是在一个很

3621
01:35:40,000 --> 01:35:44,000
就是他们都是在一个单进程的情况下

3622
01:35:44,000 --> 01:35:46,000
去模拟或者说这么说吧

3623
01:35:46,000 --> 01:35:49,000
他们都是在一个单进程的情况下

3624
01:35:49,000 --> 01:35:51,000
去做一些并发的事情

3625
01:35:51,000 --> 01:35:52,000
对

3626
01:35:52,000 --> 01:35:53,000
他们试图用

3627
01:35:53,000 --> 01:35:58,000
其实就是一个非常简单的例子

3628
01:35:58,000 --> 01:36:01,000
就是我先做一件事情

3629
01:36:01,000 --> 01:36:05,000
然后在这件事情跑的间隙之中

3630
01:36:05,000 --> 01:36:06,000
去做另外一件事情

3631
01:36:06,000 --> 01:36:09,000
比如说回到我们刚才那个做饭的例子

3632
01:36:09,000 --> 01:36:11,000
我先把锅做在火上

3633
01:36:11,000 --> 01:36:12,000
然后开始烧水

3634
01:36:12,000 --> 01:36:14,000
然后在烧水的间隙里面

3635
01:36:14,000 --> 01:36:15,000
我开始切菜

3636
01:36:15,000 --> 01:36:17,000
然后等到水烧开了

3637
01:36:17,000 --> 01:36:17,000
我看到水在滚

3638
01:36:17,000 --> 01:36:19,000
然后我再去滚烧水的事情

3639
01:36:19,000 --> 01:36:21,000
其实就是一个非常

3640
01:36:21,000 --> 01:36:24,000
EboIO 其实就是这样一个非常简单的问题

3641
01:36:24,000 --> 01:36:26,000
只不过它具体实现起来

3642
01:36:26,000 --> 01:36:31,000
会比做菜这么简单的一个任务

3643
01:36:31,000 --> 01:36:32,000
要复杂很多

3644
01:36:32,000 --> 01:36:32,000
对

3645
01:36:32,000 --> 01:36:34,000
就为什么说

3646
01:36:34,000 --> 01:36:35,000
还有一个问题就是说

3647
01:36:35,000 --> 01:36:36,000
为什么每次提到 Ebo 的时候

3648
01:36:36,000 --> 01:36:38,000
都一定是指 IO 呢

3649
01:36:38,000 --> 01:36:40,000
因为这个其实牵涉到计算机

3650
01:36:40,000 --> 01:36:42,000
之前我们某一期讲过

3651
01:36:42,000 --> 01:36:43,000
计算机体系结构的一个问题

3652
01:36:43,000 --> 01:36:48,000
就是说在所有的计算机应用里面

3653
01:36:48,000 --> 01:36:50,000
你只要涉及到 IO 的时候

3654
01:36:50,000 --> 01:36:52,000
这个 CPU 都是远远高于

3655
01:36:52,000 --> 01:36:54,000
它的处理速度都是远远高于

3656
01:36:54,000 --> 01:36:56,000
你输入输出的速度的

3657
01:36:56,000 --> 01:36:57,000
这样的话

3658
01:36:57,000 --> 01:36:58,000
一个 B 的结果就是说

3659
01:36:58,000 --> 01:37:01,000
如果你只要一旦涉及 IO 的操作

3660
01:37:01,000 --> 01:37:03,000
你的 CPU 就要闲置起来等

3661
01:37:03,000 --> 01:37:04,000
那么 EboIO 的

3662
01:37:04,000 --> 01:37:05,000
他们一个切入点就是说

3663
01:37:05,000 --> 01:37:10,000
那我们就不要等 IO 的响应结果回来

3664
01:37:10,000 --> 01:37:12,000
一直等他啥等

3665
01:37:12,000 --> 01:37:13,000
反正也没这事做

3666
01:37:13,000 --> 01:37:16,000
我们在他结果返回来之前

3667
01:37:16,000 --> 01:37:17,000
我们先做点别的事

3668
01:37:17,000 --> 01:37:19,000
然后等那边结果返回来之后

3669
01:37:19,000 --> 01:37:20,000
你再通知我

3670
01:37:20,000 --> 01:37:21,000
再回来

3671
01:37:21,000 --> 01:37:23,000
把这件事情接着再捡起来

3672
01:37:23,000 --> 01:37:24,000
接着做下去

3673
01:37:24,000 --> 01:37:25,000
没错

3674
01:37:25,000 --> 01:37:29,000
但是 EboIO 有一个问题

3675
01:37:29,000 --> 01:37:31,000
就是很有可能你协调不好

3676
01:37:31,000 --> 01:37:33,000
对

3677
01:37:33,000 --> 01:37:36,000
就还是用做饭的例子来说

3678
01:37:36,000 --> 01:37:38,000
就是可能你想起来

3679
01:37:38,000 --> 01:37:39,000
你想当然会觉得

3680
01:37:39,000 --> 01:37:40,000
烧水的时候我切菜

3681
01:37:40,000 --> 01:37:42,000
但是你没有办法保证

3682
01:37:42,000 --> 01:37:43,000
在水烧开之前

3683
01:37:43,000 --> 01:37:44,000
你一定能把菜切好

3684
01:37:44,000 --> 01:37:46,000
就是我相信每一个

3685
01:37:46,000 --> 01:37:47,000
喜欢做饭的人

3686
01:37:47,000 --> 01:37:48,000
都会有这样的窘境

3687
01:37:48,000 --> 01:37:48,000
或者说

3688
01:37:48,000 --> 01:37:51,000
同时有很多事情

3689
01:37:51,000 --> 01:37:53,000
要你去处理

3690
01:37:53,000 --> 01:37:54,000
甚至我记得

3691
01:37:54,000 --> 01:37:56,000
新干件英语里面

3692
01:37:56,000 --> 01:37:57,000
好像有一期课文

3693
01:37:57,000 --> 01:37:57,000
就是这个

3694
01:37:57,000 --> 01:38:00,000
就是说一个主妇在活面

3695
01:38:00,000 --> 01:38:02,000
然后电话响了

3696
01:38:02,000 --> 01:38:04,000
同时又有人在敲门

3697
01:38:04,000 --> 01:38:08,000
与此同时再加上

3698
01:38:08,000 --> 01:38:09,000
如果锅开了

3699
01:38:09,000 --> 01:38:10,000
那在这种情况下

3700
01:38:10,000 --> 01:38:10,000
你该怎么办吧

3701
01:38:10,000 --> 01:38:13,000
那其实一部的 Io

3702
01:38:13,000 --> 01:38:16,000
或者说基于回调的一部 Io

3703
01:38:16,000 --> 01:38:17,000
就是这样一个

3704
01:38:17,000 --> 01:38:18,000
与生俱来的问题

3705
01:38:18,000 --> 01:38:22,000
你很难去理解

3706
01:38:22,000 --> 01:38:24,000
或者说很难事先判定

3707
01:38:24,000 --> 01:38:27,000
所有事情的发生的先后顺序

3708
01:38:27,000 --> 01:38:31,000
然后因为你作为一个程序员

3709
01:38:31,000 --> 01:38:33,000
你只能用线性的方式去写代码

3710
01:38:33,000 --> 01:38:36,000
所以你线性的代码是很难处理

3711
01:38:36,000 --> 01:38:40,000
这样一个不知道先后因果顺序的问题

3712
01:38:40,000 --> 01:38:42,000
对

3713
01:38:42,000 --> 01:38:43,000
就是这里面有一个

3714
01:38:43,000 --> 01:38:45,000
通常有个词汇来描述

3715
01:38:45,000 --> 01:38:48,000
这个采用 Io 的程序结构

3716
01:38:48,000 --> 01:38:49,000
叫做控制流导致

3717
01:38:49,000 --> 01:38:51,000
inversal control flow

3718
01:38:51,000 --> 01:38:52,000
OK

3719
01:38:52,000 --> 01:38:55,000
就是说我们通常写代码的时候

3720
01:38:55,000 --> 01:38:56,000
我们也说先怎么怎么样

3721
01:38:56,000 --> 01:38:57,000
后怎么怎么样

3722
01:38:57,000 --> 01:38:59,000
它是一个线性的前因后果的关系走下来的

3723
01:38:59,000 --> 01:39:00,000
对吧

3724
01:39:00,000 --> 01:39:02,000
但是如果你采用那种 EoIo

3725
01:39:02,000 --> 01:39:04,000
这种回调方式来做的话

3726
01:39:04,000 --> 01:39:05,000
就会发现

3727
01:39:05,000 --> 01:39:08,000
我这个消息怪了

3728
01:39:08,000 --> 01:39:09,000
我这个时候该干嘛

3729
01:39:09,000 --> 01:39:11,000
你得去找半天

3730
01:39:11,000 --> 01:39:12,000
我现在应该到这一步了

3731
01:39:12,000 --> 01:39:14,000
我应该恢复到之前那个状态

3732
01:39:14,000 --> 01:39:15,000
然后怎么接着做下去

3733
01:39:15,000 --> 01:39:17,000
就其实是一个

3734
01:39:17,000 --> 01:39:18,000
如果人脑去想

3735
01:39:18,000 --> 01:39:20,000
是一个挺费时费脑的事情

3736
01:39:20,000 --> 01:39:21,000
但如果你写代码来做的话

3737
01:39:21,000 --> 01:39:22,000
就是要考虑很多

3738
01:39:22,000 --> 01:39:27,000
可能你预想不到的组合的这种情况出现

3739
01:39:27,000 --> 01:39:28,000
没错

3740
01:39:28,000 --> 01:39:31,000
但 EoIo 的

3741
01:39:31,000 --> 01:39:32,000
基于回来的 EoIo

3742
01:39:32,000 --> 01:39:34,000
有一个什么样的好处

3743
01:39:34,000 --> 01:39:35,000
就是它可以保证

3744
01:39:35,000 --> 01:39:36,000
整个

3745
01:39:36,000 --> 01:39:38,000
因为它是一个单进程的

3746
01:39:38,000 --> 01:39:39,000
这么一个单进程

3747
01:39:39,000 --> 01:39:41,000
或者单线程的这么一个结构

3748
01:39:41,000 --> 01:39:42,000
它有一个好处

3749
01:39:42,000 --> 01:39:44,000
就是可以完全不用考虑锁的问题

3750
01:39:44,000 --> 01:39:45,000
对

3751
01:39:45,000 --> 01:39:47,000
因为你在任意时刻

3752
01:39:47,000 --> 01:39:51,000
都只有一个控制流在执行

3753
01:39:51,000 --> 01:39:53,000
只有一个工作单元在跑

3754
01:39:53,000 --> 01:39:54,000
对没错

3755
01:39:54,000 --> 01:39:56,000
你就不用去考虑说

3756
01:39:56,000 --> 01:39:58,000
我在我的进程

3757
01:39:58,000 --> 01:39:59,000
或者是线程

3758
01:39:59,000 --> 01:40:01,000
就是 memory space

3759
01:40:01,000 --> 01:40:02,000
就是内存空间以内

3760
01:40:02,000 --> 01:40:04,000
我要去修改任何状态

3761
01:40:04,000 --> 01:40:06,000
我改的时候

3762
01:40:06,000 --> 01:40:08,000
肯定是不会有任何人跟我抢的

3763
01:40:08,000 --> 01:40:09,000
没错

3764
01:40:09,000 --> 01:40:11,000
所以这可能也是有

3765
01:40:11,000 --> 01:40:12,000
包括我现在讲的 JavaScript 的

3766
01:40:12,000 --> 01:40:14,000
这个引擎也好

3767
01:40:14,000 --> 01:40:17,000
它很在意的一点

3768
01:40:17,000 --> 01:40:19,000
因为你一旦可以避免这个锁

3769
01:40:19,000 --> 01:40:23,000
或者就同步叫什么

3770
01:40:23,000 --> 01:40:24,000
shared mutable state

3771
01:40:24,000 --> 01:40:26,000
就是共享的可编状态的话

3772
01:40:26,000 --> 01:40:30,000
但可以避免这个你的整个编程的

3773
01:40:30,000 --> 01:40:31,000
怎么说呢

3774
01:40:31,000 --> 01:40:33,000
难度吧

3775
01:40:33,000 --> 01:40:36,000
就会降低很大的一个什么数量级的降低

3776
01:40:36,000 --> 01:40:39,000
但如果你不能保证这一点的话

3777
01:40:39,000 --> 01:40:41,000
你就会牵涉到刚才我们讲

3778
01:40:41,000 --> 01:40:44,000
那个并行计算的最核心的矛盾

3779
01:40:44,000 --> 01:40:45,000
就是人没有办法去思考

3780
01:40:45,000 --> 01:40:47,000
像机器那样并行的去思考

3781
01:40:47,000 --> 01:40:48,000
对

3782
01:40:48,000 --> 01:40:51,000
但是这个机翼回调的 EVO

3783
01:40:51,000 --> 01:40:54,000
就是有一个很大的缺陷

3784
01:40:54,000 --> 01:40:56,000
就是它要把我们这个程序

3785
01:40:56,000 --> 01:40:58,000
整个逻辑流分得非常碎

3786
01:40:58,000 --> 01:41:00,000
通过回调的方式

3787
01:41:00,000 --> 01:41:02,000
你要把它整个逻辑流

3788
01:41:02,000 --> 01:41:04,000
做到切成很多小片段

3789
01:41:04,000 --> 01:41:05,000
然后每个片段

3790
01:41:05,000 --> 01:41:06,000
它之间的关系

3791
01:41:06,000 --> 01:41:08,000
又不是非常的那种很线性很明朗

3792
01:41:08,000 --> 01:41:09,000
这样的话

3793
01:41:09,000 --> 01:41:12,000
对于你理解整个程序的结构

3794
01:41:12,000 --> 01:41:14,000
其实是非常不利的

3795
01:41:14,000 --> 01:41:15,000
对

3796
01:41:15,000 --> 01:41:17,000
在 JavaScript 程序员里面

3797
01:41:17,000 --> 01:41:18,000
经常会有这样的笑话

3798
01:41:18,000 --> 01:41:20,000
就是一个回调

3799
01:41:20,000 --> 01:41:22,000
欠着另外一个回调

3800
01:41:22,000 --> 01:41:23,000
然后再欠着另外一个回调

3801
01:41:23,000 --> 01:41:26,000
然后整个最后你写代码的结尾

3802
01:41:26,000 --> 01:41:28,000
就是括号分号

3803
01:41:28,000 --> 01:41:29,000
花括号

3804
01:41:29,000 --> 01:41:30,000
括号分号

3805
01:41:30,000 --> 01:41:31,000
花括号

3806
01:41:31,000 --> 01:41:32,000
括号分号

3807
01:41:32,000 --> 01:41:34,000
这样一层一层欠它不进去

3808
01:41:34,000 --> 01:41:34,000
对

3809
01:41:34,000 --> 01:41:35,000
没错

3810
01:41:35,000 --> 01:41:36,000
然后这个有一个专门的

3811
01:41:36,000 --> 01:41:38,000
我们给它一个称呼叫做

3812
01:41:38,000 --> 01:41:40,000
回调地域

3813
01:41:40,000 --> 01:41:41,000
Coreback Hell

3814
01:41:41,000 --> 01:41:42,000
Coreback Hell

3815
01:41:42,000 --> 01:41:43,000
对

3816
01:41:43,000 --> 01:41:45,000
然后就说

3817
01:41:45,000 --> 01:41:47,000
那我们有没有办法说

3818
01:41:47,000 --> 01:41:48,000
能够既保留

3819
01:41:48,000 --> 01:41:49,000
这个单

3820
01:41:49,000 --> 01:41:50,000
就是 EVOIO

3821
01:41:50,000 --> 01:41:54,000
这种单线程不需要考虑锁的机制的好处

3822
01:41:54,000 --> 01:41:58,000
同时又可以保留我们程序逻辑是线性

3823
01:41:58,000 --> 01:41:59,000
不用分的

3824
01:41:59,000 --> 01:42:01,000
不用切成小片段切得很散

3825
01:42:01,000 --> 01:42:02,000
就是这种状况

3826
01:42:02,000 --> 01:42:06,000
就也有一些很好的尝试

3827
01:42:06,000 --> 01:42:08,000
就是说基于斜程这么一个概念

3828
01:42:08,000 --> 01:42:11,000
斜程是什么意思

3829
01:42:11,000 --> 01:42:12,000
那刚才我讲的有进程

3830
01:42:12,000 --> 01:42:13,000
有现成

3831
01:42:13,000 --> 01:42:14,000
有斜程

3832
01:42:14,000 --> 01:42:19,000
斜程其实是在程序里面自己管理的一个逻辑的

3833
01:42:20,000 --> 01:42:22,000
又要用一个广义的进程了

3834
01:42:22,000 --> 01:42:24,000
对

3835
01:42:24,000 --> 01:42:27,000
我觉得斜程其实比较容易理解的

3836
01:42:27,000 --> 01:42:31,000
比较容易理解的点

3837
01:42:31,000 --> 01:42:32,000
就是说

3838
01:42:32,000 --> 01:42:36,000
斜程其实是非常贴近现实生活的一个东西

3839
01:42:36,000 --> 01:42:40,000
比如说我在沾模型

3840
01:42:40,000 --> 01:42:42,000
然后这个时候女朋友喊我说

3841
01:42:42,000 --> 01:42:44,000
水开了

3842
01:42:44,000 --> 01:42:45,000
你去把它

3843
01:42:45,000 --> 01:42:47,000
你去泡个茶

3844
01:42:47,000 --> 01:42:50,000
然后我可以很方便的放下我手中的工具

3845
01:42:50,000 --> 01:42:51,000
转身去泡茶

3846
01:42:51,000 --> 01:42:52,000
回来的时候

3847
01:42:52,000 --> 01:42:54,000
接着我刚才沾到一半的

3848
01:42:54,000 --> 01:42:57,000
The progress

3849
01:42:57,000 --> 01:42:59,000
Progress

3850
01:42:59,000 --> 01:43:00,000
中文是什么

3851
01:43:00,000 --> 01:43:02,000
进度

3852
01:43:02,000 --> 01:43:02,000
对

3853
01:43:02,000 --> 01:43:05,000
然后继续沾我的模型

3854
01:43:05,000 --> 01:43:06,000
就是说

3855
01:43:06,000 --> 01:43:09,000
其实现实生活中很多很多事情都是

3856
01:43:09,000 --> 01:43:12,000
可以对应到基层的斜程

3857
01:43:12,000 --> 01:43:14,000
但是在传统的没有斜程的

3858
01:43:14,000 --> 01:43:16,000
编程模型里面

3859
01:43:16,000 --> 01:43:17,000
编程世界里面

3860
01:43:17,000 --> 01:43:19,000
计算机是不知道怎么保存现场

3861
01:43:19,000 --> 01:43:21,000
所以说

3862
01:43:21,000 --> 01:43:23,000
协程其实就是赋予的计算机一种

3863
01:43:23,000 --> 01:43:26,000
保存一个执行到一半的函数的现场的能力

3864
01:43:26,000 --> 01:43:28,000
然后告诉你说

3865
01:43:28,000 --> 01:43:29,000
你坐到这儿

3866
01:43:29,000 --> 01:43:30,000
给了你个断点

3867
01:43:30,000 --> 01:43:31,000
你可以跳出去做别的事情

3868
01:43:31,000 --> 01:43:32,000
回来的时候

3869
01:43:32,000 --> 01:43:33,000
刚才执行到哪

3870
01:43:33,000 --> 01:43:35,000
还可以继续接着执行

3871
01:43:35,000 --> 01:43:36,000
这就是现实

3872
01:43:36,000 --> 01:43:38,000
所有的你的所谓的 context

3873
01:43:38,000 --> 01:43:41,000
你的上下文都还保留在原样

3874
01:43:41,000 --> 01:43:44,000
你可以接着假装没有中断这件事情发生

3875
01:43:44,000 --> 01:43:45,000
你接着往前走下去了

3876
01:43:45,000 --> 01:43:48,000
所以其实从这个意义上来讲

3877
01:43:48,000 --> 01:43:49,000
县程也好

3878
01:43:49,000 --> 01:43:50,000
进程也好

3879
01:43:50,000 --> 01:43:50,000
斜程也好

3880
01:43:50,000 --> 01:43:51,000
他们都做到同样一件事情

3881
01:43:51,000 --> 01:43:52,000
就是说

3882
01:43:52,000 --> 01:43:55,000
是一段可以被随时重

3883
01:43:55,000 --> 01:43:57,000
叫做 resume

3884
01:43:57,000 --> 01:43:58,000
不叫重启

3885
01:43:58,000 --> 01:43:58,000
叫什么

3886
01:43:58,000 --> 01:44:00,000
恢复

3887
01:44:00,000 --> 01:44:01,000
随时可以捡起来

3888
01:44:01,000 --> 01:44:04,000
接着再做下去的这么一个逻辑

3889
01:44:04,000 --> 01:44:04,000
对

3890
01:44:04,000 --> 01:44:05,000
但就

3891
01:44:05,000 --> 01:44:05,000
rezoom

3892
01:44:05,000 --> 01:44:06,000
对

3893
01:44:06,000 --> 01:44:07,000
resume

3894
01:44:07,000 --> 01:44:07,000
对

3895
01:44:07,000 --> 01:44:08,000
没错

3896
01:44:08,000 --> 01:44:09,000
就是说

3897
01:44:09,000 --> 01:44:10,000
但他们的之间的区别在哪里

3898
01:44:10,000 --> 01:44:11,000
就是说

3899
01:44:11,000 --> 01:44:13,000
可能在实现的这个

3900
01:44:13,000 --> 01:44:16,000
就是资源的 overhead 上面是不一样的

3901
01:44:16,000 --> 01:44:18,000
可能最重的可能是进程

3902
01:44:18,000 --> 01:44:19,000
因为超系统要做很多什么

3903
01:44:19,000 --> 01:44:21,000
CPU 寄存器的切换

3904
01:44:21,000 --> 01:44:22,000
有万千八糟的事情

3905
01:44:22,000 --> 01:44:23,000
还要保留一些什么样的

3906
01:44:23,000 --> 01:44:26,000
系统的一些 bookkeeping 的工作

3907
01:44:26,000 --> 01:44:27,000
然后

3908
01:44:27,000 --> 01:44:28,000
主要是在需要的时候

3909
01:44:28,000 --> 01:44:30,000
需要把内存里面的很多数据

3910
01:44:30,000 --> 01:44:31,000
就拷贝一份

3911
01:44:31,000 --> 01:44:32,000
这是非常非常大的

3912
01:44:32,000 --> 01:44:32,000
对

3913
01:44:32,000 --> 01:44:33,000
对

3914
01:44:33,000 --> 01:44:34,000
对

3915
01:44:34,000 --> 01:44:35,000
然后进程的开销

3916
01:44:35,000 --> 01:44:37,000
就相对要少一点

3917
01:44:37,000 --> 01:44:39,000
但是还是比较显著的

3918
01:44:39,000 --> 01:44:40,000
那么斜程

3919
01:44:40,000 --> 01:44:41,000
就是说

3920
01:44:41,000 --> 01:44:43,000
他直接就绕过操作系统内部

3921
01:44:43,000 --> 01:44:44,000
我直接在程序内部

3922
01:44:44,000 --> 01:44:47,000
通过一种自制的调度器的方式

3923
01:44:47,000 --> 01:44:49,000
来管理我自己的那些

3924
01:44:49,000 --> 01:44:51,000
那些 task

3925
01:44:51,000 --> 01:44:52,000
那些子任务

3926
01:44:52,000 --> 01:44:54,000
然后使得有一个非常

3927
01:44:54,000 --> 01:44:56,000
轻量的资源的开销

3928
01:44:56,000 --> 01:44:57,000
同时又能给我带来

3929
01:44:57,000 --> 01:44:59,000
像类似于进程

3930
01:44:59,000 --> 01:45:00,000
或者县程那样的一个

3931
01:45:00,000 --> 01:45:02,000
线性的逻辑流的好处

3932
01:45:02,000 --> 01:45:03,000
对

3933
01:45:03,000 --> 01:45:05,000
这样前面所提到的这种

3934
01:45:05,000 --> 01:45:07,000
Universal Control Flow 的问题

3935
01:45:07,000 --> 01:45:08,000
就不会再发生

3936
01:45:08,000 --> 01:45:09,000
没错

3937
01:45:09,000 --> 01:45:10,000
对

3938
01:45:10,000 --> 01:45:11,000
现实中使用

3939
01:45:11,000 --> 01:45:13,000
斜程的例子也是蛮多的

3940
01:45:13,000 --> 01:45:14,000
其实

3941
01:45:14,000 --> 01:45:16,000
总体来讲

3942
01:45:16,000 --> 01:45:16,000
像 Golan 的

3943
01:45:16,000 --> 01:45:18,000
GoRoutine

3944
01:45:18,000 --> 01:45:18,000
它就是一种

3945
01:45:18,000 --> 01:45:19,000
斜程的一种

3946
01:45:19,000 --> 01:45:21,000
一种变种

3947
01:45:21,000 --> 01:45:23,000
然后像 Python 的话

3948
01:45:23,000 --> 01:45:23,000
它有一个叫做

3949
01:45:23,000 --> 01:45:24,000
Generator

3950
01:45:24,000 --> 01:45:25,000
生成器

3951
01:45:25,000 --> 01:45:25,000
这种概念

3952
01:45:25,000 --> 01:45:26,000
就是它

3953
01:45:26,000 --> 01:45:29,000
它函数里面是有一个特殊的关键

3954
01:45:29,000 --> 01:45:31,000
关键词叫做 Yield

3955
01:45:31,000 --> 01:45:33,000
可以暂时的让出

3956
01:45:33,000 --> 01:45:35,000
Yield 就是让出的意思

3957
01:45:35,000 --> 01:45:36,000
让出程序的控制流

3958
01:45:36,000 --> 01:45:40,000
然后等那边条件合适的时候

3959
01:45:40,000 --> 01:45:42,000
你再把它回到这个位置

3960
01:45:42,000 --> 01:45:43,000
然后接着从这个点往下指示

3961
01:45:43,000 --> 01:45:46,000
然后我知道是 JavaScript

3962
01:45:46,000 --> 01:45:48,000
从应该是下一个版本

3963
01:45:48,000 --> 01:45:50,000
还是 7 的时候

3964
01:45:50,000 --> 01:45:50,000
它也再加

3965
01:45:50,000 --> 01:45:51,000
不就下一个版本

3966
01:45:51,000 --> 01:45:53,000
Emax Script 6

3967
01:45:53,000 --> 01:45:54,000
Emax Script 6

3968
01:45:54,000 --> 01:45:56,000
这个版本里面

3969
01:45:56,000 --> 01:45:57,000
就已经有这个

3970
01:45:57,000 --> 01:45:59,000
类似的 Generator

3971
01:45:59,000 --> 01:46:01,000
这么一个概念在里面了

3972
01:46:01,000 --> 01:46:03,000
然后 Ruby 的话

3973
01:46:03,000 --> 01:46:05,000
它有一个特性叫做 Fiber

3974
01:46:05,000 --> 01:46:08,000
也是一个斜程的例子

3975
01:46:08,000 --> 01:46:09,000
Fiber 一般反译成

3976
01:46:09,000 --> 01:46:09,000
叫什么

3977
01:46:09,000 --> 01:46:10,000
千成

3978
01:46:10,000 --> 01:46:13,000
就是比现成更要细的

3979
01:46:13,000 --> 01:46:14,000
千维千成

3980
01:46:14,000 --> 01:46:16,000
但是像千成就是斜程

3981
01:46:16,000 --> 01:46:18,000
因为它是对于那个 Thread

3982
01:46:18,000 --> 01:46:21,000
Thread 在织布的语境

3983
01:46:21,000 --> 01:46:22,000
就是纺织页的语境里面

3984
01:46:22,000 --> 01:46:23,000
是像什么

3985
01:46:23,000 --> 01:46:23,000
线头

3986
01:46:23,000 --> 01:46:23,000
对不对

3987
01:46:23,000 --> 01:46:24,000
对

3988
01:46:24,000 --> 01:46:24,000
一根线

3989
01:46:24,000 --> 01:46:26,000
而 Fiber 则是组成

3990
01:46:26,000 --> 01:46:28,000
线的一根纤维的纱

3991
01:46:28,000 --> 01:46:29,000
一根纱

3992
01:46:29,000 --> 01:46:29,000
对

3993
01:46:29,000 --> 01:46:30,000
没错

3994
01:46:30,000 --> 01:46:31,000
这个意思

3995
01:46:31,000 --> 01:46:33,000
然后 Python 的话

3996
01:46:33,000 --> 01:46:34,000
还有一个

3997
01:46:34,000 --> 01:46:37,000
一个 Fork 算是

3998
01:46:37,000 --> 01:46:39,000
叫做 GEvent

3999
01:46:39,000 --> 01:46:40,000
它是可以甚至通过

4000
01:46:40,000 --> 01:46:41,000
那种方式来做

4001
01:46:41,000 --> 01:46:43,000
全局的写程

4002
01:46:43,000 --> 01:46:45,000
而不是说

4003
01:46:45,000 --> 01:46:47,000
只限于 Generator

4004
01:46:47,000 --> 01:46:49,000
这种比较受限的写程

4005
01:46:49,000 --> 01:46:50,000
OK

4006
01:46:50,000 --> 01:46:51,000
所以

4007
01:46:51,000 --> 01:46:53,000
但问题在于

4008
01:46:53,000 --> 01:46:55,000
不管是回调还是斜程

4009
01:46:55,000 --> 01:46:57,000
都没有办法

4010
01:46:57,000 --> 01:46:58,000
非常有效的利用

4011
01:46:58,000 --> 01:46:59,000
多核处理器

4012
01:46:59,000 --> 01:46:59,000
不是

4013
01:46:59,000 --> 01:47:00,000
因为你

4014
01:47:00,000 --> 01:47:01,000
无论如何

4015
01:47:01,000 --> 01:47:02,000
都只有一个单

4016
01:47:02,000 --> 01:47:04,000
只有一个单个的进程

4017
01:47:04,000 --> 01:47:07,000
没错

4018
01:47:07,000 --> 01:47:09,000
一般是这样子的

4019
01:47:09,000 --> 01:47:09,000
比如刚才我们砍证的

4020
01:47:09,000 --> 01:47:10,000
那几个例子

4021
01:47:10,000 --> 01:47:11,000
它都是因为有这样

4022
01:47:11,000 --> 01:47:12,000
那样的限制

4023
01:47:12,000 --> 01:47:13,000
导致它不能使用多限制

4024
01:47:13,000 --> 01:47:16,000
但是也并不完全是这样

4025
01:47:16,000 --> 01:47:17,000
比如说 Go 的 GoRoutine

4026
01:47:17,000 --> 01:47:21,000
它其实是可以利用多个处理器核心的

4027
01:47:21,000 --> 01:47:24,000
就是看你系统的调度的时候

4028
01:47:24,000 --> 01:47:25,000
你是怎么去调度它而已

4029
01:47:25,000 --> 01:47:26,000
OK

4030
01:47:26,000 --> 01:47:31,000
然后还有像 Orlan 这种比较诡异的例子

4031
01:47:31,000 --> 01:47:33,000
但它是非常独特的一种机制

4032
01:47:33,000 --> 01:47:37,000
它里面的线程不是系统的线程

4033
01:47:37,000 --> 01:47:38,000
它是自己内置的线程

4034
01:47:38,000 --> 01:47:40,000
它也并不是一个斜程

4035
01:47:40,000 --> 01:47:42,000
就是它每个线程都是完全独立

4036
01:47:42,000 --> 01:47:46,000
就是没有任何和其他共享资源的地方

4037
01:47:46,000 --> 01:47:48,000
就是说它的那个调度

4038
01:47:48,000 --> 01:47:50,000
其实可以很方便的去管理它那些

4039
01:47:50,000 --> 01:47:53,000
那些叫做执行的步骤

4040
01:47:53,000 --> 01:47:54,000
它们叫做 Reduction

4041
01:47:54,000 --> 01:47:55,000
这么一个步骤

4042
01:47:55,000 --> 01:47:56,000
对

4043
01:47:56,000 --> 01:47:57,000
Orlan 我虽然不是很了解

4044
01:47:57,000 --> 01:47:59,000
但我觉得它的思路

4045
01:47:59,000 --> 01:48:02,000
基本上就是把 Thread 当作一种

4046
01:48:02,000 --> 01:48:03,000
语言内在的机制

4047
01:48:03,000 --> 01:48:07,000
而不是对操作系统提供的机制的一种抽象

4048
01:48:07,000 --> 01:48:08,000
没错

4049
01:48:08,000 --> 01:48:12,000
因为它使用的 actor model

4050
01:48:12,000 --> 01:48:13,000
actor 模型

4051
01:48:13,000 --> 01:48:15,000
对这种事情是有天然的需求的

4052
01:48:15,000 --> 01:48:18,000
而且它整个调度器也好

4053
01:48:18,000 --> 01:48:18,000
解析器也好

4054
01:48:18,000 --> 01:48:21,000
都是为这种方式去优化的

4055
01:48:21,000 --> 01:48:22,000
虽然说它的可能

4056
01:48:22,000 --> 01:48:25,000
就是直提供某一个这种

4057
01:48:25,000 --> 01:48:26,000
就是所谓的

4058
01:48:26,000 --> 01:48:29,000
就 CPU heavy 的东西的性能不怎么样

4059
01:48:29,000 --> 01:48:30,000
但是它对这种

4060
01:48:30,000 --> 01:48:32,000
可以并行计算的任务的处理

4061
01:48:32,000 --> 01:48:33,000
是非常非常优秀的

4062
01:48:33,000 --> 01:48:34,000
没错

4063
01:48:34,000 --> 01:48:37,000
对

4064
01:48:37,000 --> 01:48:39,000
其实我现在在学 Hasco

4065
01:48:39,000 --> 01:48:39,000
终于开始

4066
01:48:39,000 --> 01:48:41,000
或者说终于又开始

4067
01:48:41,000 --> 01:48:43,000
为什么突然有这个契机去学它

4068
01:48:43,000 --> 01:48:45,000
我也不知道

4069
01:48:45,000 --> 01:48:47,000
就是可能主要契机还是因为

4070
01:48:47,000 --> 01:48:52,000
之前看的那个 Object C 的 blog

4071
01:48:52,000 --> 01:48:55,000
他们受其蛊惑

4072
01:48:55,000 --> 01:48:55,000
对不对

4073
01:48:55,000 --> 01:48:56,000
对

4074
01:48:56,000 --> 01:49:00,000
他们提供了大量的奇迹引巧

4075
01:49:00,000 --> 01:49:02,000
就是为了让你写 Swift 的时候

4076
01:49:02,000 --> 01:49:03,000
看起来更像 Hasco

4077
01:49:03,000 --> 01:49:04,000
我觉得何必呢

4078
01:49:04,000 --> 01:49:06,000
那我干脆去学一只 Hasco

4079
01:49:06,000 --> 01:49:11,000
但这样的尝试已经有过很多次

4080
01:49:11,000 --> 01:49:12,000
但每次都没有坚持下来

4081
01:49:12,000 --> 01:49:14,000
我觉得这次应该坚持坚持

4082
01:49:14,000 --> 01:49:16,000
然后在那之后

4083
01:49:16,000 --> 01:49:17,000
我也许可以试试 Air Lounge

4084
01:49:17,000 --> 01:49:21,000
因为在我北边有一个城市

4085
01:49:21,000 --> 01:49:21,000
叫做 Air Lounge

4086
01:49:21,000 --> 01:49:24,000
我以前写过一个

4087
01:49:24,000 --> 01:49:26,000
写过一条推

4088
01:49:26,000 --> 01:49:28,000
就是说 Air Lounge 这个地方

4089
01:49:28,000 --> 01:49:31,000
就是由二战时期被纳粹

4090
01:49:31,000 --> 01:49:34,000
集中在一起的 Air Lounge 程序人建立的

4091
01:49:34,000 --> 01:49:36,000
所以他叫做 Air Lounge 在德语里面

4092
01:49:36,000 --> 01:49:38,000
就是使用 Air Lounge 编程的意思

4093
01:49:38,000 --> 01:49:40,000
对

4094
01:49:40,000 --> 01:49:42,000
Air Lounge 在德语里面什么意思

4095
01:49:42,000 --> 01:49:43,000
没有意义吗

4096
01:49:43,000 --> 01:49:44,000
还是只是一个名字

4097
01:49:44,000 --> 01:49:47,000
没有什么意义吧

4098
01:49:47,000 --> 01:49:49,000
就至少我找不出什么特别

4099
01:49:49,000 --> 01:49:53,000
至少我想不到什么特别明显的语言

4100
01:49:53,000 --> 01:49:54,000
我回头会去查试 Etymology

4101
01:49:54,000 --> 01:49:56,000
但我可以基本上可以确定

4102
01:49:56,000 --> 01:49:58,000
Air Lounge 跟 Air Lounge 没有任何关系

4103
01:49:58,000 --> 01:50:00,000
因为 Air Lounge 里面

4104
01:50:00,000 --> 01:50:01,000
也和人家讲的

4105
01:50:01,000 --> 01:50:04,000
它是爱立信的实验室做的语言

4106
01:50:04,000 --> 01:50:05,000
叫做 Archson Language

4107
01:50:05,000 --> 01:50:06,000
所以是 Air Lounge

4108
01:50:06,000 --> 01:50:08,000
原来是这么来的

4109
01:50:08,000 --> 01:50:08,000
OK

4110
01:50:08,000 --> 01:50:09,000
不知道

4111
01:50:09,000 --> 01:50:10,000
不知道

4112
01:50:10,000 --> 01:50:11,000
我原来的理解

4113
01:50:11,000 --> 01:50:13,000
了解非常非常有限

4114
01:50:13,000 --> 01:50:14,000
对

4115
01:50:14,000 --> 01:50:14,000
它就是这么

4116
01:50:14,000 --> 01:50:15,000
而且它有一个

4117
01:50:15,000 --> 01:50:17,000
这个可能之后有一期

4118
01:50:17,000 --> 01:50:19,000
专门讲 Air Lounge 的时候再说吧

4119
01:50:19,000 --> 01:50:20,000
还有一个很有意思的

4120
01:50:20,000 --> 01:50:24,000
那个就看起来甚至有点 weird 的一个短视频

4121
01:50:24,000 --> 01:50:25,000
非常有意思

4122
01:50:25,000 --> 01:50:26,000
嗯

4123
01:50:26,000 --> 01:50:29,000
就是他们因为 Air Lounge 最开始的用途

4124
01:50:29,000 --> 01:50:31,000
是用于做那个叫做什么

4125
01:50:31,000 --> 01:50:33,000
电话交换机的控制的

4126
01:50:33,000 --> 01:50:33,000
对

4127
01:50:33,000 --> 01:50:34,000
控制拨号

4128
01:50:34,000 --> 01:50:35,000
然后怎么怎么样

4129
01:50:35,000 --> 01:50:36,000
然后它就用

4130
01:50:36,000 --> 01:50:38,000
它的那个视频就整个过程都在描述

4131
01:50:38,000 --> 01:50:40,000
这么一个过程中

4132
01:50:40,000 --> 01:50:42,000
这个 Air Lounge 是怎么样起作用的

4133
01:50:42,000 --> 01:50:43,000
非常好笑的一个视频

4134
01:50:43,000 --> 01:50:44,000
一定要看一下

4135
01:50:44,000 --> 01:50:47,000
有一种 Montipython 的即视感

4136
01:50:47,000 --> 01:50:48,000
啊

4137
01:50:48,000 --> 01:50:49,000
有意思

4138
01:50:49,000 --> 01:50:51,000
所以处理电话拨号

4139
01:50:51,000 --> 01:50:53,000
其实是听起来也是一个

4140
01:50:53,000 --> 01:50:57,000
天生就带有并发性质的问题领域

4141
01:50:57,000 --> 01:50:57,000
嗯

4142
01:50:57,000 --> 01:50:58,000
没错

4143
01:50:58,000 --> 01:50:59,000
对

4144
01:50:59,000 --> 01:51:02,000
所以在从这样一种领域里面

4145
01:51:02,000 --> 01:51:04,000
所为了解决这样一个领域的问题

4146
01:51:04,000 --> 01:51:06,000
而诞生的变成语言

4147
01:51:06,000 --> 01:51:08,000
也就天生的非常强调

4148
01:51:08,000 --> 01:51:11,000
解决这种问题的方便程度

4149
01:51:11,000 --> 01:51:12,000
嗯

4150
01:51:12,000 --> 01:51:13,000
而且我觉得它

4151
01:51:13,000 --> 01:51:16,000
它这个就是 Air Lounge 它这种方式

4152
01:51:16,000 --> 01:51:17,000
而且采用它

4153
01:51:17,000 --> 01:51:19,000
它采用的这种像 Actor Model 也好

4154
01:51:19,000 --> 01:51:21,000
它自己的这种调度器也好

4155
01:51:21,000 --> 01:51:24,000
它有一个很成熟的

4156
01:51:24,000 --> 01:51:25,000
叫做监控的系统

4157
01:51:25,000 --> 01:51:27,000
Supervision System

4158
01:51:27,000 --> 01:51:28,000
叫做 OTP 嘛

4159
01:51:28,000 --> 01:51:30,000
就是 Open Telecom Platform

4160
01:51:30,000 --> 01:51:32,000
开放电信平台

4161
01:51:32,000 --> 01:51:33,000
听起来很怪

4162
01:51:33,000 --> 01:51:34,000
为什么会是电信

4163
01:51:34,000 --> 01:51:35,000
听起来非常电信

4164
01:51:35,000 --> 01:51:36,000
对

4165
01:51:36,000 --> 01:51:37,000
听起来非常爱立信

4166
01:51:37,000 --> 01:51:39,000
但是它

4167
01:51:39,000 --> 01:51:40,000
但是它确实是解决了很多

4168
01:51:40,000 --> 01:51:42,000
这种大型软件工程的一些问题

4169
01:51:42,000 --> 01:51:44,000
比如说它里面的所有的那些

4170
01:51:44,000 --> 01:51:46,000
那些就是县程嘛

4171
01:51:46,000 --> 01:51:47,000
我们叫做 Actor 也好

4172
01:51:47,000 --> 01:51:49,000
它是随时可以让他

4173
01:51:49,000 --> 01:51:50,000
就是他的错误处理

4174
01:51:50,000 --> 01:51:51,000
即使是不处理

4175
01:51:51,000 --> 01:51:52,000
让他 crash 掉

4176
01:51:52,000 --> 01:51:53,000
嗯

4177
01:51:53,000 --> 01:51:56,000
然后 crash 掉之后怎么办呢

4178
01:51:56,000 --> 01:51:57,000
他每一个 actor

4179
01:51:57,000 --> 01:52:00,000
他会为他分配一个叫做 Supervisor

4180
01:52:00,000 --> 01:52:00,000
Supervisor

4181
01:52:00,000 --> 01:52:02,000
就是监管管理者

4182
01:52:02,000 --> 01:52:04,000
然后这个管理者

4183
01:52:04,000 --> 01:52:04,000
不叫每一个

4184
01:52:04,000 --> 01:52:05,000
不是不是

4185
01:52:05,000 --> 01:52:06,000
就是说

4186
01:52:06,000 --> 01:52:08,000
这里说错了

4187
01:52:08,000 --> 01:52:09,000
应该重新讲一下

4188
01:52:09,000 --> 01:52:09,000
因为说

4189
01:52:09,000 --> 01:52:10,000
它里面每一个 actor

4190
01:52:10,000 --> 01:52:13,000
都是被一个 Supervisor 管理的

4191
01:52:13,000 --> 01:52:14,000
如果这个 Supervisor

4192
01:52:14,000 --> 01:52:16,000
探测到那个 actor 挂掉了

4193
01:52:16,000 --> 01:52:16,000
他就会

4194
01:52:16,000 --> 01:52:17,000
或者死掉了

4195
01:52:17,000 --> 01:52:19,000
他就会重新再起一个一模一样的

4196
01:52:19,000 --> 01:52:22,000
然后它里面整个这种

4197
01:52:22,000 --> 01:52:24,000
这一套思维哲学是非常

4198
01:52:24,000 --> 01:52:25,000
非常

4199
01:52:25,000 --> 01:52:27,000
很不一样

4200
01:52:27,000 --> 01:52:29,000
而且你到目前为止

4201
01:52:29,000 --> 01:52:30,000
我们做那种

4202
01:52:30,000 --> 01:52:31,000
很多这种

4203
01:52:31,000 --> 01:52:32,000
像做那种大规模的

4204
01:52:32,000 --> 01:52:33,000
分布系统的维护的时候

4205
01:52:33,000 --> 01:52:34,000
会发现

4206
01:52:34,000 --> 01:52:36,000
你做的系统越大

4207
01:52:36,000 --> 01:52:36,000
你越会

4208
01:52:36,000 --> 01:52:38,000
你的那个什么

4209
01:52:38,000 --> 01:52:40,000
整个架构会越靠近

4210
01:52:40,000 --> 01:52:40,000
像那个

4211
01:52:40,000 --> 01:52:41,000
阿兰的这种

4212
01:52:41,000 --> 01:52:42,000
这套模型来讲

4213
01:52:42,000 --> 01:52:43,000
比如说很简单的一个

4214
01:52:43,000 --> 01:52:45,000
那个 Google 的那个例子吧

4215
01:52:45,000 --> 01:52:46,000
因为 Google 的

4216
01:52:46,000 --> 01:52:47,000
它就传统上

4217
01:52:47,000 --> 01:52:49,000
我们做这种服务器软件

4218
01:52:49,000 --> 01:52:49,000
我们的可能说

4219
01:52:49,000 --> 01:52:52,000
我们这个服务器不要挂掉

4220
01:52:52,000 --> 01:52:53,000
我们要它高

4221
01:52:53,000 --> 01:52:54,000
稳定可靠

4222
01:52:54,000 --> 01:52:54,000
对吧

4223
01:52:54,000 --> 01:52:55,000
就好像我们说

4224
01:52:55,000 --> 01:52:56,000
这个服务器的可靠性

4225
01:52:56,000 --> 01:52:57,000
要高于工作站的

4226
01:52:57,000 --> 01:52:58,000
工作站的可靠性

4227
01:52:58,000 --> 01:53:00,000
要高于这种个人 PC 的

4228
01:53:00,000 --> 01:53:01,000
但是你为了换取

4229
01:53:01,000 --> 01:53:02,000
那更高可靠性

4230
01:53:02,000 --> 01:53:03,000
你要付出更高的成本

4231
01:53:03,000 --> 01:53:04,000
就单位硬件

4232
01:53:04,000 --> 01:53:05,000
和单位计算能力的成本

4233
01:53:05,000 --> 01:53:06,000
你是要上去了

4234
01:53:06,000 --> 01:53:07,000
然后 Google 当年的

4235
01:53:07,000 --> 01:53:08,000
做法就是说

4236
01:53:08,000 --> 01:53:10,000
我们做大规模的

4237
01:53:10,000 --> 01:53:12,000
这种服务端

4238
01:53:12,000 --> 01:53:13,000
我们不需要用这种

4239
01:53:13,000 --> 01:53:14,000
所谓的服务

4240
01:53:14,000 --> 01:53:15,000
就是 server grade hardware

4241
01:53:15,000 --> 01:53:17,000
就是服务器级别的硬件

4242
01:53:17,000 --> 01:53:19,000
什么高档处理器

4243
01:53:19,000 --> 01:53:20,000
或者是高档机房

4244
01:53:20,000 --> 01:53:21,000
这种东西

4245
01:53:21,000 --> 01:53:22,000
我们就用普通的

4246
01:53:22,000 --> 01:53:23,000
所谓的 commodity hardware

4247
01:53:23,000 --> 01:53:24,000
就是这种

4248
01:53:24,000 --> 01:53:26,000
随数可见

4249
01:53:26,000 --> 01:53:27,000
拓手可得的

4250
01:53:27,000 --> 01:53:28,000
普通的机器

4251
01:53:28,000 --> 01:53:30,000
就可以随意替换的机器

4252
01:53:30,000 --> 01:53:31,000
然后它虽然说

4253
01:53:31,000 --> 01:53:32,000
它的故障率

4254
01:53:32,000 --> 01:53:34,000
要比这种所谓的

4255
01:53:34,000 --> 01:53:35,000
服务器级别的硬件要高

4256
01:53:35,000 --> 01:53:36,000
但是我们只要把

4257
01:53:36,000 --> 01:53:38,000
软件的容错写好

4258
01:53:38,000 --> 01:53:40,000
我们它随时挂掉

4259
01:53:40,000 --> 01:53:41,000
任何几个机器

4260
01:53:41,000 --> 01:53:41,000
都是没有

4261
01:53:41,000 --> 01:53:43,000
没有不影响我们这个系统

4262
01:53:43,000 --> 01:53:45,000
整个系统的运作的嘛

4263
01:53:45,000 --> 01:53:46,000
然后你要实现这一点

4264
01:53:46,000 --> 01:53:47,000
你就会发现

4265
01:53:47,000 --> 01:53:49,000
你会越来越的类似

4266
01:53:49,000 --> 01:53:49,000
用到类似于

4267
01:53:49,000 --> 01:53:51,000
而来的那种机制

4268
01:53:51,000 --> 01:53:52,000
要去监控

4269
01:53:52,000 --> 01:53:53,000
然后要去

4270
01:53:53,000 --> 01:53:56,000
假设错误是不可恢复的

4271
01:53:56,000 --> 01:53:57,000
然后如果遇到错误

4272
01:53:57,000 --> 01:53:59,000
你再重新起一个新的节点

4273
01:53:59,000 --> 01:54:01,000
来接替之前挂掉的

4274
01:54:01,000 --> 01:54:02,000
那些节点的工作

4275
01:54:02,000 --> 01:54:03,000
那诸如此类的事情

4276
01:54:03,000 --> 01:54:05,000
对

4277
01:54:05,000 --> 01:54:07,000
这我脑中浮现出了

4278
01:54:07,000 --> 01:54:08,000
早期电话系统那种

4279
01:54:08,000 --> 01:54:11,000
一排接线机器

4280
01:54:11,000 --> 01:54:13,000
前面坐着很多

4281
01:54:13,000 --> 01:54:14,000
接线员的场景

4282
01:54:14,000 --> 01:54:17,000
然后一个 SuperS

4283
01:54:17,000 --> 01:54:18,000
在那边看说

4284
01:54:18,000 --> 01:54:19,000
这个接线员

4285
01:54:19,000 --> 01:54:21,000
累倒在了工作杠杆上

4286
01:54:21,000 --> 01:54:22,000
立刻把它撤走

4287
01:54:22,000 --> 01:54:23,000
换另外一个来插

4288
01:54:23,000 --> 01:54:24,000
插线图

4289
01:54:24,000 --> 01:54:26,000
感觉是学汉工厂

4290
01:54:26,000 --> 01:54:27,000
没错

4291
01:54:27,000 --> 01:54:29,000
其实这也就

4292
01:54:29,000 --> 01:54:31,000
说到这个也就想到

4293
01:54:31,000 --> 01:54:33,000
上一期我们跟木耀聊的

4294
01:54:33,000 --> 01:54:34,000
说他们我们

4295
01:54:34,000 --> 01:54:37,000
你们学 Hasco 的动机是什么

4296
01:54:37,000 --> 01:54:39,000
那或者说

4297
01:54:39,000 --> 01:54:39,000
那学

4298
01:54:39,000 --> 01:54:41,000
那我觉得可以把这个问题

4299
01:54:41,000 --> 01:54:43,000
泛化为学 Alan

4300
01:54:43,000 --> 01:54:44,000
或者是 Hasco 这种比较

4301
01:54:44,000 --> 01:54:47,000
加引号小众的辩证员

4302
01:54:47,000 --> 01:54:49,000
它的

4303
01:54:49,000 --> 01:54:52,000
它的比较功利的一个效果

4304
01:54:52,000 --> 01:54:54,000
就是你可能会发现

4305
01:54:54,000 --> 01:54:55,000
当你需要解决一个

4306
01:54:55,000 --> 01:54:57,000
特定领域的问题的时候

4307
01:54:57,000 --> 01:54:58,000
你会发现在这种

4308
01:54:58,000 --> 01:54:59,000
比较小众的语言里面

4309
01:54:59,000 --> 01:55:01,000
已经有了相当好的解决方

4310
01:55:01,000 --> 01:55:02,000
已经有了

4311
01:55:02,000 --> 01:55:06,000
已经有先人

4312
01:55:06,000 --> 01:55:08,000
对此深思熟虑过

4313
01:55:08,000 --> 01:55:10,000
并且设计出了一个

4314
01:55:10,000 --> 01:55:11,000
非常好的模型

4315
01:55:11,000 --> 01:55:12,000
那么当你在

4316
01:55:12,000 --> 01:55:14,000
当你在用你的

4317
01:55:14,000 --> 01:55:15,000
所谓原生语言

4318
01:55:15,000 --> 01:55:16,000
去解决它的时候

4319
01:55:16,000 --> 01:55:18,000
就会方便了

4320
01:55:18,000 --> 01:55:19,000
对

4321
01:55:19,000 --> 01:55:20,000
就算是说你不一定

4322
01:55:20,000 --> 01:55:22,000
真的用到这个语言的

4323
01:55:22,000 --> 01:55:23,000
具体的实现

4324
01:55:23,000 --> 01:55:24,000
甚至你都不会用这个语言

4325
01:55:24,000 --> 01:55:26,000
去写新的代码

4326
01:55:26,000 --> 01:55:28,000
但是你从这里面

4327
01:55:28,000 --> 01:55:29,000
学到的这种思想

4328
01:55:29,000 --> 01:55:30,000
可能会有助于

4329
01:55:30,000 --> 01:55:32,000
你在现有的工作中

4330
01:55:32,000 --> 01:55:33,000
去提升你的

4331
01:55:33,000 --> 01:55:35,000
这个架构的能力也好

4332
01:55:35,000 --> 01:55:35,000
或者说是

4333
01:55:35,000 --> 01:55:36,000
你去抽象事物的能力

4334
01:55:36,000 --> 01:55:37,000
你会发现

4335
01:55:37,000 --> 01:55:38,000
原来还可以从这个角度

4336
01:55:38,000 --> 01:55:39,000
去思考问题

4337
01:55:39,000 --> 01:55:40,000
对吧

4338
01:55:40,000 --> 01:55:40,000
对

4339
01:55:40,000 --> 01:55:43,000
这是为什么人要去做

4340
01:55:43,000 --> 01:55:45,000
人要去努力做一个 polyglot

4341
01:55:45,000 --> 01:55:46,000
这就好像你多学一个

4342
01:55:46,000 --> 01:55:48,000
捷克有个谚语

4343
01:55:48,000 --> 01:55:50,000
就是你会几种语言

4344
01:55:50,000 --> 01:55:51,000
你就有几种人声

4345
01:55:51,000 --> 01:55:52,000
所以

4346
01:55:52,000 --> 01:55:54,000
在编程领域

4347
01:55:54,000 --> 01:55:55,000
其实也是这样的

4348
01:55:55,000 --> 01:55:56,000
你会几种语言

4349
01:55:56,000 --> 01:55:56,000
你就可以

4350
01:55:56,000 --> 01:55:58,000
你就多几种语言

4351
01:55:58,000 --> 01:55:59,000
你就可以多理解

4352
01:55:59,000 --> 01:56:01,000
几种编程模型

4353
01:56:01,000 --> 01:56:01,000
要怎么

4354
01:56:01,000 --> 01:56:03,000
参差多太财四美

4355
01:56:03,000 --> 01:56:04,000
这里又体现出来了

4356
01:56:04,000 --> 01:56:05,000
没错

4357
01:56:05,000 --> 01:56:08,000
差不多了

4358
01:56:08,000 --> 01:56:09,000
好吧

4359
01:56:09,000 --> 01:56:12,000
今天你也结尾一下吧

4360
01:56:12,000 --> 01:56:13,000
对

4361
01:56:13,000 --> 01:56:17,000
所以今天我们大概就讲述了

4362
01:56:17,000 --> 01:56:19,000
当然可能不是非常的满意

4363
01:56:19,000 --> 01:56:26,000
因为做了很多解释一些比较复杂的问题的尝试

4364
01:56:26,000 --> 01:56:28,000
但是都没有能

4365
01:56:28,000 --> 01:56:28,000
不抢

4366
01:56:28,000 --> 01:56:29,000
失败了

4367
01:56:29,000 --> 01:56:29,000
对

4368
01:56:29,000 --> 01:56:31,000
都没有能做得很好

4369
01:56:31,000 --> 01:56:34,000
这可能也从另外一个侧面反映出了

4370
01:56:34,000 --> 01:56:36,000
并发和异步

4371
01:56:36,000 --> 01:56:40,000
其实的确是在编程领域比较难的一些问题

4372
01:56:40,000 --> 01:56:45,000
当然也有可能说我们两个太水

4373
01:56:45,000 --> 01:56:46,000
这是肯定的

4374
01:56:46,000 --> 01:56:48,000
我从来不怀疑

4375
01:56:48,000 --> 01:56:49,000
那句话怎么说来的

4376
01:56:49,000 --> 01:56:50,000
就是说

4377
01:56:50,000 --> 01:56:53,000
如果你能够用几句话的东西

4378
01:56:53,000 --> 01:56:54,000
真的能够

4379
01:56:54,000 --> 01:56:57,000
或者说你能够很清晰明白的给人家解释一个东西

4380
01:56:57,000 --> 01:57:00,000
那么你对这个事情的理解就肯定是比较透彻

4381
01:57:00,000 --> 01:57:01,000
但如果你解释不了

4382
01:57:01,000 --> 01:57:04,000
很有可能是你自己理解的还不够深刻

4383
01:57:04,000 --> 01:57:04,000
对

4384
01:57:04,000 --> 01:57:07,000
就是有很多东西都会有这样一个阶段

4385
01:57:07,000 --> 01:57:08,000
就是你以为自己懂了

4386
01:57:08,000 --> 01:57:11,000
但是当你要向别人解释的时候

4387
01:57:11,000 --> 01:57:13,000
会发现自己其实并不是真的理解

4388
01:57:13,000 --> 01:57:15,000
对

4389
01:57:15,000 --> 01:57:16,000
从这个侧面来说

4390
01:57:16,000 --> 01:57:19,000
我觉得可能做 podcast 对

4391
01:57:19,000 --> 01:57:20,000
对不知道你

4392
01:57:20,000 --> 01:57:22,000
但对我来说也是一个非常大的帮助

4393
01:57:22,000 --> 01:57:23,000
就是

4394
01:57:23,000 --> 01:57:27,000
就像之前我在知乎答案里面说过的那样

4395
01:57:27,000 --> 01:57:28,000
就是非常

4396
01:57:28,000 --> 01:57:34,000
帮助我去把自己之前可能一知半解的部分

4397
01:57:34,000 --> 01:57:36,000
弄得比较比较二知一解

4398
01:57:36,000 --> 01:57:40,000
就是把它为了像为了做好一些节目

4399
01:57:40,000 --> 01:57:42,000
可能会去看一些相关的书

4400
01:57:42,000 --> 01:57:45,000
这些对于我来说也是非常大的帮助

4401
01:57:45,000 --> 01:57:46,000
不光是这个

4402
01:57:46,000 --> 01:57:50,000
就是不管你是在说就是口述也好

4403
01:57:50,000 --> 01:57:51,000
还是说笔头写下来也好

4404
01:57:51,000 --> 01:57:54,000
就是你整个在输出的过程

4405
01:57:54,000 --> 01:57:56,000
其实就是在考验你内部的

4406
01:57:56,000 --> 01:57:59,000
那个什么知识的组织也好

4407
01:57:59,000 --> 01:58:00,000
还是你的理解也好

4408
01:58:00,000 --> 01:58:00,000
对吧

4409
01:58:00,000 --> 01:58:03,000
都是它对是一个是一个使用的过程

4410
01:58:03,000 --> 01:58:05,000
这个时候你会发现

4411
01:58:05,000 --> 01:58:08,000
如果你对某一点理解不够透彻的话

4412
01:58:08,000 --> 01:58:10,000
你这是没有办法解释清楚的

4413
01:58:10,000 --> 01:58:11,000
对

4414
01:58:11,000 --> 01:58:16,000
所以也希望这一期节目能够起到抛转眼的作用

4415
01:58:16,000 --> 01:58:21,000
如果哪位听众对于异步和并发

4416
01:58:21,000 --> 01:58:23,000
有比较深刻的理解

4417
01:58:23,000 --> 01:58:26,000
然后觉得一些我没有讲清楚

4418
01:58:26,000 --> 01:58:29,000
但是讲错的概念可以值得纠正的话

4419
01:58:29,000 --> 01:58:31,000
那也欢迎你写信给我们

4420
01:58:31,000 --> 01:58:35,000
我们的电子邮件地址是

4421
01:58:35,000 --> 01:58:37,000
CernalPanic at IPN.LI

4422
01:58:37,000 --> 01:58:40,000
然后也欢迎你拨打我们的热线电话

4423
01:58:40,000 --> 01:58:44,000
09189998819991197253

4424
01:58:44,000 --> 01:58:47,000
好

4425
01:58:47,000 --> 01:58:49,000
如果你非常喜欢我们的节目

4426
01:58:49,000 --> 01:58:51,000
或者说不管你是不是喜欢我们的节目

4427
01:58:51,000 --> 01:58:53,000
都欢迎你为我们捐款

4428
01:58:53,000 --> 01:58:55,000
捐款的地址是

4429
01:58:55,000 --> 01:58:57,000
CernalPanic.fm

4430
01:58:57,000 --> 01:58:58,000
slash donate

4431
01:58:58,000 --> 01:59:00,000
D-O-N-A-T

4432
01:59:00,000 --> 01:59:01,000
金额随意

4433
01:59:01,000 --> 01:59:05,000
但必须是可以被 8 整除的正整数

4434
01:59:05,000 --> 01:59:10,000
然后为了向线电子电机的基础组成

4435
01:59:10,000 --> 01:59:11,000
Bite 制径

4436
01:59:11,000 --> 01:59:13,000
我们把它设定为

4437
01:59:13,000 --> 01:59:15,000
至少要被 8 整除

4438
01:59:15,000 --> 01:59:17,000
好吧

4439
01:59:17,000 --> 01:59:19,000
那今天就到这了

4440
01:59:19,000 --> 01:59:19,000
OK

4441
01:59:19,000 --> 01:59:20,000
对

4442
01:59:20,000 --> 01:59:21,000
下期再见

4443
01:59:21,000 --> 01:59:23,000
拜拜

