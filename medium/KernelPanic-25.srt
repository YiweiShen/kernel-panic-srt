1
00:00:00,000 --> 00:00:02,000
欢迎收听 ipn podcast 网络旗下的

2
00:00:02,000 --> 00:00:05,000
IT 技术主题娱乐节目内核恐慌

3
00:00:05,000 --> 00:00:07,000
我们号称 Hardcore

4
00:00:07,000 --> 00:00:08,000
但是也没有什么干火

5
00:00:08,000 --> 00:00:09,000
想听的人听

6
00:00:09,000 --> 00:00:11,000
不想听的人就别听

7
00:00:11,000 --> 00:00:14,000
本节目的网址是 ipn.li

8
00:00:14,000 --> 00:00:16,000
slash kernelpanic

9
00:00:16,000 --> 00:00:18,000
我们推荐大家使用 podcast 客户端

10
00:00:18,000 --> 00:00:20,000
订阅节目

11
00:00:20,000 --> 00:00:24,000
详情请访问 ipn.lislashfaq

12
00:00:24,000 --> 00:00:26,000
欢迎你为本节目捐款

13
00:00:26,000 --> 00:00:28,000
捐款的只是 ipn.lislash

14
00:00:28,000 --> 00:00:31,000
kernelpanicslashdonate

15
00:00:31,000 --> 00:00:32,000
捐款金额随意

16
00:00:32,000 --> 00:00:33,000
只要是能被扒

17
00:00:33,000 --> 00:00:36,000
除了正整数就可以

18
00:00:36,000 --> 00:00:37,000
捐款不会给你带来什么

19
00:00:37,000 --> 00:00:39,000
不捐也不会让你失去什么

20
00:00:39,000 --> 00:00:40,000
我们的口号是

21
00:00:40,000 --> 00:00:43,000
hyper is hyper awesome

22
00:00:43,000 --> 00:00:44,000
今天我们特别荣幸

23
00:00:44,000 --> 00:00:46,000
请到一位嘉宾

24
00:00:46,000 --> 00:00:47,000
Simon 薛磊

25
00:00:47,000 --> 00:00:49,000
薛磊也给大家介绍一下自己吧

26
00:00:49,000 --> 00:00:50,000
hello 大家好

27
00:00:50,000 --> 00:00:51,000
我叫 Simon

28
00:00:51,000 --> 00:00:56,000
然后我现在从事的是一项基于

29
00:00:56,000 --> 00:00:59,000
容器的一个创业项目

30
00:00:59,000 --> 00:01:01,000
然后目前是处于初创阶段

31
00:01:01,000 --> 00:01:05,000
之前我从事的是主要是内核相关的工作

32
00:01:05,000 --> 00:01:09,000
之前也非常热衷地关注于内核相关的

33
00:01:09,000 --> 00:01:12,000
所有创业的相关的项目

34
00:01:12,000 --> 00:01:15,000
然后包括最近特别火的一个容器

35
00:01:15,000 --> 00:01:18,000
所以也加入了这个以容器

36
00:01:18,000 --> 00:01:22,000
或者说以 hyperwizer 为主题的一个创业项目

37
00:01:22,000 --> 00:01:25,000
非常荣幸的能参加

38
00:01:25,000 --> 00:01:28,000
内核恐慌这个节目之前也很关注

39
00:01:28,000 --> 00:01:29,000
非常谦虚

40
00:01:29,000 --> 00:01:32,000
因为 Simon 的自我介绍很低调

41
00:01:32,000 --> 00:01:35,000
其实 Simon 之前是在 San

42
00:01:35,000 --> 00:01:38,000
后来他卖给 Oracle 的公司

43
00:01:38,000 --> 00:01:40,000
也就是 Java 的单身地对吧

44
00:01:40,000 --> 00:01:40,000
对

45
00:01:40,000 --> 00:01:43,000
其实说到 San

46
00:01:43,000 --> 00:01:47,000
其实有更多的人其实只知道是 Java

47
00:01:47,000 --> 00:01:48,000
但是除了 Java 之外

48
00:01:48,000 --> 00:01:52,000
他有非常多的优秀的项目

49
00:01:52,000 --> 00:01:53,000
比如说 Solos

50
00:01:53,000 --> 00:01:55,000
就是 unix 的一个变种

51
00:01:55,000 --> 00:01:57,000
可能目前很多 linux 内核

52
00:01:57,000 --> 00:02:02,000
以及 linux 分化版本上面的软件

53
00:02:02,000 --> 00:02:05,000
以及内核的模块都是来自于 Solos

54
00:02:05,000 --> 00:02:08,000
比如特别著名的 ZFS

55
00:02:08,000 --> 00:02:11,000
当然可能做存储的人都知道 ZFS

56
00:02:11,000 --> 00:02:14,000
他的一个特别强大的功能

57
00:02:14,000 --> 00:02:19,000
以及调试内核的时候所用到的一些工具

58
00:02:19,000 --> 00:02:21,000
比如说 MDB

59
00:02:21,000 --> 00:02:24,000
就是 linux 上类似的就是 GDB

60
00:02:24,000 --> 00:02:29,000
然后一种追踪内核的

61
00:02:29,000 --> 00:02:32,000
不极限于内核

62
00:02:32,000 --> 00:02:36,000
除了内核还有应用程序都可以追踪 Dtrace

63
00:02:36,000 --> 00:02:39,000
就像目前的 System type

64
00:02:39,000 --> 00:02:41,000
以及 K type

65
00:02:41,000 --> 00:02:43,000
以及类似这种 trace 工具

66
00:02:43,000 --> 00:02:49,000
应该说大多数都来自于 Dtrace 的设计理念

67
00:02:49,000 --> 00:02:50,000
非常酷

68
00:02:50,000 --> 00:02:53,000
Simon 你之前在 San 的话

69
00:02:53,000 --> 00:02:55,000
具体是做哪一块工作

70
00:02:55,000 --> 00:02:59,000
我之前在 San 的时候是北京研发中心

71
00:02:59,000 --> 00:03:01,000
北京研发中心这边主要的一大块

72
00:03:01,000 --> 00:03:04,000
是大概 20 多人的一个团队

73
00:03:04,000 --> 00:03:08,000
主要是从事的是 Solos 的一个存储

74
00:03:08,000 --> 00:03:10,000
存储协议的一个研发

75
00:03:10,000 --> 00:03:12,000
主要集中在 SCSI 协议

76
00:03:12,000 --> 00:03:13,000
可能比较底层了

77
00:03:13,000 --> 00:03:17,000
可能不做内核的人不太清楚这一块东西

78
00:03:17,000 --> 00:03:22,000
这就是一个相当于一个标准的网络存储协议

79
00:03:22,000 --> 00:03:25,000
比如现在咱们说的硬盘

80
00:03:25,000 --> 00:03:26,000
就是 SCSI 硬盘

81
00:03:26,000 --> 00:03:28,000
像什么 SATA 硬盘等等

82
00:03:28,000 --> 00:03:30,000
都是走的 SCSI 协议

83
00:03:30,000 --> 00:03:35,000
所以我们其实在这一条线上去做开发

84
00:03:36,000 --> 00:03:38,000
可能也比较偏存储一点

85
00:03:38,000 --> 00:03:40,000
也比较偏内核一点

86
00:03:41,000 --> 00:03:45,000
SCSI 当年还是跟什么 IDE 那些

87
00:03:45,000 --> 00:03:46,000
是叫 IDE 吧

88
00:03:46,000 --> 00:03:46,000
对

89
00:03:46,000 --> 00:03:48,000
对应的那个时候

90
00:03:48,000 --> 00:03:50,000
现在后来是发展成了那个

91
00:03:50,000 --> 00:03:52,000
是 SATA 对那个 SAS 对吧

92
00:03:52,000 --> 00:03:54,000
SMS 两个协议

93
00:03:54,000 --> 00:03:56,000
然后 SCSI 是 SAS 的前身

94
00:03:56,000 --> 00:03:57,000
如果我理解没错的话

95
00:03:57,000 --> 00:03:58,000
对 是的

96
00:03:58,000 --> 00:03:59,000
OK

97
00:03:59,000 --> 00:04:00,000
所以你之前的主要工作是在做

98
00:04:00,000 --> 00:04:02,000
这个存储协议这一块

99
00:04:02,000 --> 00:04:02,000
对 是

100
00:04:03,000 --> 00:04:04,000
所以还是非常一个 hardcore 的人

101
00:04:04,000 --> 00:04:06,000
特别适合我们节目的主题

102
00:04:06,000 --> 00:04:10,000
所以我自开始关注疯狂

103
00:04:10,000 --> 00:04:12,000
那个节目的时候

104
00:04:12,000 --> 00:04:16,000
就因为自己从事这个行业

105
00:04:16,000 --> 00:04:18,000
所以也关注这个

106
00:04:18,000 --> 00:04:19,000
发现还是挺有意思的

107
00:04:20,000 --> 00:04:23,000
虽然我们节目一直都号称自己非常水

108
00:04:23,000 --> 00:04:25,000
然后这一期终于有一个

109
00:04:25,000 --> 00:04:26,000
够硬的干后

110
00:04:26,000 --> 00:04:27,000
满足大家的要求了

111
00:04:29,000 --> 00:04:30,000
SAMU 刚才你提到

112
00:04:30,000 --> 00:04:32,000
你现在在做一个跟容器相关的

113
00:04:32,000 --> 00:04:35,000
当然我们节目在之前的某一期里面

114
00:04:35,000 --> 00:04:38,000
也提到过这个概念

115
00:04:38,000 --> 00:04:39,000
叫做 container 对不对

116
00:04:39,000 --> 00:04:40,000
对

117
00:04:40,000 --> 00:04:40,000
然后

118
00:04:41,000 --> 00:04:43,000
但是当中毕竟我跟吴涛两个人

119
00:04:43,000 --> 00:04:45,000
都属于这个东西的一个叫做什么

120
00:04:45,000 --> 00:04:47,000
用户或者是萌外汉

121
00:04:47,000 --> 00:04:50,000
但是你其实在做相关的开发的

122
00:04:50,000 --> 00:04:52,000
所以本期我们可能会就这个问题

123
00:04:52,000 --> 00:04:54,000
进入一些更加深入的探讨

124
00:04:54,000 --> 00:04:54,000
OK

125
00:04:54,000 --> 00:04:56,000
所以你现在做这些公司

126
00:04:56,000 --> 00:04:58,000
这个项目叫什么

127
00:04:58,000 --> 00:05:00,000
其实这个项目就叫 Hyper

128
00:05:00,000 --> 00:05:03,000
然后 Hyper 我们的公司

129
00:05:03,000 --> 00:05:04,000
就叫 HyperHQ

130
00:05:04,000 --> 00:05:07,000
然后主要为什么取这个名字

131
00:05:07,000 --> 00:05:10,000
其实也是想

132
00:05:10,000 --> 00:05:13,000
针对国外的用户

133
00:05:13,000 --> 00:05:15,000
或者一些企业或者是 partner 敢去做

134
00:05:15,000 --> 00:05:16,000
所以

135
00:05:17,000 --> 00:05:19,000
中文的名字不太好听

136
00:05:19,000 --> 00:05:20,000
所以大家也就呼吁

137
00:05:20,000 --> 00:05:23,000
大家更多关注可以关注我们的英文的网站

138
00:05:23,000 --> 00:05:27,000
然后可能我们的中文网站还在做

139
00:05:27,000 --> 00:05:30,000
也没有特别的一个进展

140
00:05:30,000 --> 00:05:31,000
但是所以就是我们的一个定位

141
00:05:32,000 --> 00:05:35,000
可能跟之前的国内的一个创业团队

142
00:05:35,000 --> 00:05:36,000
不太一样

143
00:05:36,000 --> 00:05:39,000
我们还是希望能够做的足够精致

144
00:05:39,000 --> 00:05:40,000
属于 OK

145
00:05:41,000 --> 00:05:41,000
awesome

146
00:05:41,000 --> 00:05:44,000
对这个事情说来就非常巧

147
00:05:44,000 --> 00:05:46,000
其实我跟 Simon 的认识还是一个机缘巧合

148
00:05:46,000 --> 00:05:49,000
就有一天我收到了一封邮件

149
00:05:49,000 --> 00:05:51,000
然后发给我的地址

150
00:05:51,000 --> 00:05:54,000
是对应到我的 GitHub 的账号的邮箱的

151
00:05:55,000 --> 00:05:56,000
然后是 Simon 给我来的一封信

152
00:05:56,000 --> 00:05:58,000
然后他是问我说能不能

153
00:05:58,000 --> 00:06:00,000
因为我当时在 GitHub 上面有一个项目

154
00:06:00,000 --> 00:06:03,000
是使用命令行控制

155
00:06:03,000 --> 00:06:05,000
通过 Virtualbox 的命令行工具

156
00:06:05,000 --> 00:06:07,000
去控制它启动讯息机

157
00:06:07,000 --> 00:06:09,000
创建讯息机这种基本的小工具

158
00:06:10,000 --> 00:06:12,000
是一个勾烂的酷

159
00:06:13,000 --> 00:06:15,000
当时 Simon 给我来一封邮件说能不能用这个

160
00:06:15,000 --> 00:06:17,000
因为当时我在 GitHub 上面

161
00:06:17,000 --> 00:06:20,000
那个 reposted 里面没有写授权协议

162
00:06:21,000 --> 00:06:22,000
这点我还是当时我就非常感动

163
00:06:22,000 --> 00:06:23,000
因为你知道

164
00:06:23,000 --> 00:06:26,000
很多大家都是直接拿来主义

165
00:06:26,000 --> 00:06:26,000
对吧

166
00:06:26,000 --> 00:06:26,000
对

167
00:06:26,000 --> 00:06:28,000
我们也不会问这种事情的

168
00:06:28,000 --> 00:06:29,000
所以在这方面

169
00:06:29,000 --> 00:06:31,000
我觉得像 Simon 还有 Hyper 这个团队

170
00:06:31,000 --> 00:06:35,000
对版权意识还是非常看重的

171
00:06:35,000 --> 00:06:37,000
这点我觉得非常难得

172
00:06:37,000 --> 00:06:37,000
对

173
00:06:37,000 --> 00:06:40,000
因为其实我们这个项目

174
00:06:41,000 --> 00:06:41,000
据我们所知

175
00:06:41,000 --> 00:06:46,000
因为国内很少有这种创业团队去做开源项目

176
00:06:46,000 --> 00:06:48,000
而我们 Hyper 其实是一个开源项目

177
00:06:48,000 --> 00:06:49,000
既然开源项目的话

178
00:06:49,000 --> 00:06:52,000
我们也是希望能够融入足够多的社区

179
00:06:52,000 --> 00:06:53,000
足够大的社区

180
00:06:54,000 --> 00:06:56,000
然后吸引更多的开发者

181
00:06:56,000 --> 00:06:58,000
然后所以在这方面其实

182
00:06:59,000 --> 00:07:02,000
也是尽自己微薄之力

183
00:07:02,000 --> 00:07:06,000
然后能尽量的改善一下国人在

184
00:07:06,000 --> 00:07:11,000
在全球的开发者的这种印象

185
00:07:11,000 --> 00:07:13,000
因为可能更多的提到

186
00:07:13,000 --> 00:07:14,000
可能国内的工程师

187
00:07:15,000 --> 00:07:17,000
当然只能是少数

188
00:07:17,000 --> 00:07:19,000
他就拿来主义

189
00:07:19,000 --> 00:07:21,000
让直接毁坏一个圈子的名声

190
00:07:22,000 --> 00:07:24,000
对

191
00:07:25,000 --> 00:07:27,000
刚才我们聊了一堆周边的情况

192
00:07:27,000 --> 00:07:29,000
就还是回到 Hyper 这个本质上

193
00:07:30,000 --> 00:07:31,000
在这个说之前

194
00:07:31,000 --> 00:07:32,000
我们先把网址亮出来

195
00:07:32,000 --> 00:07:34,000
把网址是非常酷的一个域名

196
00:07:34,000 --> 00:07:36,000
叫做 Hyper.sh

197
00:07:36,000 --> 00:07:36,000
对

198
00:07:36,000 --> 00:07:38,000
当时你们怎么想的

199
00:07:38,000 --> 00:07:41,000
会取用这么一个域名

200
00:07:42,000 --> 00:07:45,000
因为毕竟其实我们的

201
00:07:46,000 --> 00:07:50,000
到的 SH 还是偏技术或者偏 Hack 一点

202
00:07:50,000 --> 00:07:54,000
因为 SH 你可以认为是 Bash

203
00:07:54,000 --> 00:07:57,000
或者是认为是其他的一些 Share

204
00:07:57,000 --> 00:07:58,000
对

205
00:07:58,000 --> 00:08:02,000
所以我们当时也是用了这种

206
00:08:03,000 --> 00:08:05,000
当然也是追求足够精简

207
00:08:07,000 --> 00:08:07,000
短一些

208
00:08:07,000 --> 00:08:09,000
然后就选用了这个域名

209
00:08:09,000 --> 00:08:11,000
然后当时我们之前参加

210
00:08:11,000 --> 00:08:13,000
挺有意思的一个事情

211
00:08:13,000 --> 00:08:15,000
就是我们之前参加一个云计算能大会

212
00:08:15,000 --> 00:08:18,000
然后很多人过来说

213
00:08:18,000 --> 00:08:20,000
你们这家公司成立在上海是吗

214
00:08:22,000 --> 00:08:22,000
对

215
00:08:22,000 --> 00:08:26,000
但其实到 SH 是哪个国家的国家地区来着

216
00:08:27,000 --> 00:08:29,000
这我还真正忘了

217
00:08:29,000 --> 00:08:30,000
OK

218
00:08:30,000 --> 00:08:32,000
这个我们回头查一下

219
00:08:32,000 --> 00:08:35,000
但是一般我们会把一些 SH 的工具

220
00:08:35,000 --> 00:08:38,000
会用.sh 这个定制来做

221
00:08:38,000 --> 00:08:39,000
对

222
00:08:39,000 --> 00:08:40,000
然后这个网站

223
00:08:40,000 --> 00:08:42,000
当时 Simon 给我来信的时候

224
00:08:42,000 --> 00:08:44,000
我就问到这个项目网站

225
00:08:44,000 --> 00:08:44,000
我就看了一下

226
00:08:44,000 --> 00:08:47,000
就是令我非常惊艳

227
00:08:47,000 --> 00:08:49,000
因为这确实不像是一个国内的团队

228
00:08:49,000 --> 00:08:50,000
做出来那种风格

229
00:08:50,000 --> 00:08:54,000
因为整个很美国的那种

230
00:08:54,000 --> 00:08:56,000
很酷很嘻哈的这种创业团队

231
00:08:56,000 --> 00:08:58,000
做出来的这种技术展示的页面

232
00:08:58,000 --> 00:09:00,000
非常精美非常漂亮

233
00:09:01,000 --> 00:09:02,000
所以说了这么多

234
00:09:02,000 --> 00:09:04,000
我们还没有介绍 hyper

235
00:09:04,000 --> 00:09:05,000
到底是个什么样东西

236
00:09:05,000 --> 00:09:07,000
Simon 你能够用一句简单的话

237
00:09:07,000 --> 00:09:09,000
介绍一下 hyper 是一个

238
00:09:09,000 --> 00:09:11,000
就给我们不太熟悉这个东西的听众

239
00:09:11,000 --> 00:09:12,000
介绍一下 hyper

240
00:09:12,000 --> 00:09:13,000
到底是个什么样的工具吗

241
00:09:14,000 --> 00:09:16,000
其实我觉得

242
00:09:16,000 --> 00:09:17,000
如果先介绍 hyper 之前

243
00:09:17,000 --> 00:09:18,000
应该先

244
00:09:18,000 --> 00:09:19,000
再介绍 hyper 之前

245
00:09:19,000 --> 00:09:21,000
最好先介绍一下 Docker

246
00:09:21,000 --> 00:09:24,000
因为可能很多人没有了解过

247
00:09:24,000 --> 00:09:25,000
在这个领域

248
00:09:25,000 --> 00:09:28,000
然后如果大家知道 Docker 的话

249
00:09:28,000 --> 00:09:31,000
那么说 hyper 的话就很简单

250
00:09:31,000 --> 00:09:33,000
一句话就可以说明白了

251
00:09:33,000 --> 00:09:36,000
咱们先说 Docker

252
00:09:36,000 --> 00:09:37,000
慢慢来

253
00:09:37,000 --> 00:09:41,000
Docker 它其实属于一个新兴项目

254
00:09:41,000 --> 00:09:44,000
大概也存在了两到三年的发展速度

255
00:09:44,000 --> 00:09:45,000
相当惊人

256
00:09:45,000 --> 00:09:46,000
大概现在 Docker 的公司

257
00:09:46,000 --> 00:09:49,000
大概在估值 10 亿美金

258
00:09:49,000 --> 00:09:50,000
10 亿美金超过 10 亿美金了

259
00:09:51,000 --> 00:09:55,000
然后它其实本质上是基于容器

260
00:09:56,000 --> 00:09:58,000
做的一组管理工具

261
00:09:58,000 --> 00:10:00,000
我是这么理解

262
00:10:00,000 --> 00:10:03,000
然后它将一些镜像文件

263
00:10:03,000 --> 00:10:05,000
比如 want to

264
00:10:05,000 --> 00:10:06,000
各种理性方法版本都可以

265
00:10:06,000 --> 00:10:09,000
然后作为一个运行式环境

266
00:10:09,000 --> 00:10:12,000
然后装到容器里面

267
00:10:12,000 --> 00:10:14,000
然后去增加网络

268
00:10:14,000 --> 00:10:15,000
增加存储

269
00:10:15,000 --> 00:10:16,000
这些所有的组件

270
00:10:16,000 --> 00:10:18,000
component

271
00:10:18,000 --> 00:10:21,000
然后使之作为一个

272
00:10:21,000 --> 00:10:24,000
轻量级的虚拟化工具来去运行

273
00:10:25,000 --> 00:10:26,000
然后这样的话就相当于

274
00:10:26,000 --> 00:10:27,000
在同一台机器上

275
00:10:27,000 --> 00:10:29,000
我可以虚拟出来

276
00:10:29,000 --> 00:10:31,000
多个单独的容器

277
00:10:31,000 --> 00:10:35,000
然后这样去运行不同的 APP

278
00:10:35,000 --> 00:10:37,000
Docker 其中一个理念

279
00:10:37,000 --> 00:10:38,000
或者说容器的一个理念

280
00:10:38,000 --> 00:10:39,000
就是一个容器里面

281
00:10:39,000 --> 00:10:42,000
只运行一个 APP

282
00:10:42,000 --> 00:10:45,000
就是相当于我只运行一个 TombKey

283
00:10:45,000 --> 00:10:50,000
或者说类似那个软件

284
00:10:50,000 --> 00:10:52,000
然后这样的话来做到

285
00:10:52,000 --> 00:10:54,000
使每个容器尽量的精简

286
00:10:54,000 --> 00:10:56,000
然后更便于管理

287
00:10:57,000 --> 00:10:59,000
它其实是为了

288
00:10:59,000 --> 00:11:04,000
为这些运营或者说为这些开发测试

289
00:11:04,000 --> 00:11:09,000
经过一个比较一致的一个运行式环境

290
00:11:09,000 --> 00:11:10,000
然后这样的话就是

291
00:11:10,000 --> 00:11:12,000
你可以自己提交你自己的

292
00:11:12,000 --> 00:11:14,000
contenter 的镜像

293
00:11:14,000 --> 00:11:15,000
然后直接提交过去之后

294
00:11:15,000 --> 00:11:17,000
任何人都可以下载

295
00:11:17,000 --> 00:11:18,000
这样的话就保证了一个

296
00:11:18,000 --> 00:11:21,000
非常一致的运行式环境

297
00:11:21,000 --> 00:11:25,000
就像就解决了一些

298
00:11:25,000 --> 00:11:27,000
像咱们几年前开发软件

299
00:11:27,000 --> 00:11:29,000
就是家啊各种配置

300
00:11:29,000 --> 00:11:32,000
环境变量各种参数配置等等

301
00:11:32,000 --> 00:11:34,000
这些问题就迎刃而解

302
00:11:34,000 --> 00:11:36,000
我直接下载一个镜像直接运行

303
00:11:36,000 --> 00:11:39,000
就可以跟

304
00:11:39,000 --> 00:11:40,000
就比如我是一个测试人员

305
00:11:40,000 --> 00:11:42,000
就可以跟开发人员的

306
00:11:42,000 --> 00:11:46,000
开发环境保持一致

307
00:11:46,000 --> 00:11:49,000
就解决很多环境相关的问题吧

308
00:11:50,000 --> 00:11:52,000
然后说到容器

309
00:11:52,000 --> 00:11:53,000
容器它是

310
00:11:53,000 --> 00:11:56,000
Docker 用用到容器作为运行式环境

311
00:11:56,000 --> 00:11:58,000
然后容器的这个概念呢

312
00:11:58,000 --> 00:12:02,000
就是相当于将一个

313
00:12:02,000 --> 00:12:05,000
house 主机分成多个子的容器

314
00:12:05,000 --> 00:12:08,000
来去运行 APP

315
00:12:08,000 --> 00:12:11,000
它这属于轻量级

316
00:12:11,000 --> 00:12:12,000
轻量级的另外一个

317
00:12:12,000 --> 00:12:13,000
一个好处呢

318
00:12:13,000 --> 00:12:15,000
就是速度足够的快

319
00:12:15,000 --> 00:12:17,000
然后但是它一个弊端的

320
00:12:17,000 --> 00:12:18,000
因为它是 share 的客户

321
00:12:18,000 --> 00:12:21,000
它是在一个内核上面去运行

322
00:12:21,000 --> 00:12:25,000
所以它也造成了一个安全性的隐患吧

323
00:12:25,000 --> 00:12:29,000
所以这就提到了我们存在的意义

324
00:12:29,000 --> 00:12:32,000
就是解决这个安全性的问题

325
00:12:32,000 --> 00:12:35,000
就是这个容器它是 share 的客户

326
00:12:35,000 --> 00:12:37,000
OK 我们不用 share 的客户

327
00:12:37,000 --> 00:12:39,000
而是用 hypervisor

328
00:12:39,000 --> 00:12:41,000
就是用 VM 来代替容器

329
00:12:41,000 --> 00:12:46,000
来去运行 Docker 的 image

330
00:12:46,000 --> 00:12:47,000
然后这样的话呢

331
00:12:47,000 --> 00:12:51,000
就是解决了 Docker 的一个安全性问题

332
00:12:51,000 --> 00:12:53,000
但是因为众所周知

333
00:12:53,000 --> 00:12:55,000
大家用过 vmware

334
00:12:55,000 --> 00:12:57,000
用过 waterbox 都知道它的启动速度

335
00:12:57,000 --> 00:12:59,000
可能会比较慢

336
00:12:59,000 --> 00:13:03,000
即使在你的非常好的高端的服务机上面

337
00:13:03,000 --> 00:13:06,000
大概也要在一两分钟

338
00:13:06,000 --> 00:13:08,000
或者是两三分钟吧

339
00:13:08,000 --> 00:13:08,000
没错

340
00:13:08,000 --> 00:13:12,000
所以我们也是极致的优化

341
00:13:12,000 --> 00:13:16,000
让它的启动速度大概在毫秒级别

342
00:13:16,000 --> 00:13:17,000
然后是毫秒级别

343
00:13:17,000 --> 00:13:18,000
对

344
00:13:18,000 --> 00:13:21,000
所以刚才是从一两分钟

345
00:13:21,000 --> 00:13:22,000
至少是 100 秒一级别

346
00:13:22,000 --> 00:13:24,000
我们现在已经到毫秒级别

347
00:13:24,000 --> 00:13:26,000
有四个数量级的提升

348
00:13:26,000 --> 00:13:27,000
对

349
00:13:27,000 --> 00:13:31,000
所以大概我们的测试的比较好的机器上

350
00:13:31,000 --> 00:13:32,000
大概在 300 毫秒

351
00:13:32,000 --> 00:13:35,000
OK 0.3 秒左右

352
00:13:35,000 --> 00:13:36,000
对

353
00:13:36,000 --> 00:13:40,000
所以这个相对于容器的启动速度来说

354
00:13:40,000 --> 00:13:43,000
已经算是差距不大

355
00:13:43,000 --> 00:13:47,000
而且它的安全性有很大的提升

356
00:13:47,000 --> 00:13:51,000
这样的话也就是成为我们一个核心的竞争力

357
00:13:51,000 --> 00:13:52,000
或者说一个存在的

358
00:13:52,000 --> 00:13:57,000
基于这个目的来去做的东西

359
00:13:57,000 --> 00:13:59,000
所以就是说

360
00:13:59,000 --> 00:14:04,000
Hyper 是一个可以快速启动的虚拟机

361
00:14:04,000 --> 00:14:04,000
可以这么理解吗

362
00:14:04,000 --> 00:14:05,000
对

363
00:14:05,000 --> 00:14:08,000
然后它在虚拟机的基础上

364
00:14:08,000 --> 00:14:12,000
可以很快的将 Docker 的 image 运行起来

365
00:14:13,000 --> 00:14:14,000
OK

366
00:14:14,000 --> 00:14:14,000
对

367
00:14:14,000 --> 00:14:18,000
然后 Hyper 起的虚拟机里面

368
00:14:18,000 --> 00:14:20,000
是就只跑一个 Docker 的镜像

369
00:14:20,000 --> 00:14:22,000
还是说它里面可以跑多个 Docker 的镜像

370
00:14:22,000 --> 00:14:25,000
可以跑多个 Docker 的镜像

371
00:14:25,000 --> 00:14:27,000
而我们一个虚拟机

372
00:14:27,000 --> 00:14:30,000
其实相当于是一个工作单元

373
00:14:30,000 --> 00:14:31,000
这个工作单元

374
00:14:32,000 --> 00:14:36,000
其实这个 idea 是来自于 Coopernatus

375
00:14:36,000 --> 00:14:37,000
里边的一个 POW 的概念

376
00:14:37,000 --> 00:14:41,000
就是一组 contender 的一个集合

377
00:14:41,000 --> 00:14:43,000
而这一组 contender 是有关系的

378
00:14:43,000 --> 00:14:45,000
它是为了运行一个

379
00:14:46,000 --> 00:14:49,000
比如我运行一个网站肯定要一个

380
00:14:49,000 --> 00:14:50,000
那个 NeedX

381
00:14:50,000 --> 00:14:51,000
买 Secure

382
00:14:51,000 --> 00:14:53,000
然后等等这 NeedX 的东西

383
00:14:53,000 --> 00:14:56,000
所以我买 Secure 一个 contender

384
00:14:56,000 --> 00:14:58,000
我 NeedX 一个 contender

385
00:14:58,000 --> 00:15:04,000
然后这样的话就组成一个 POW 的概念

386
00:15:04,000 --> 00:15:06,000
就包含了两个 contender

387
00:15:07,000 --> 00:15:08,000
OK

388
00:15:08,000 --> 00:15:09,000
所以可以这么理解吗

389
00:15:09,000 --> 00:15:11,000
就是说一个 Hyper 的虚拟机

390
00:15:11,000 --> 00:15:14,000
就是对应一个 POW 的盒子

391
00:15:14,000 --> 00:15:17,000
然后这个 POW 的里面是包含了

392
00:15:17,000 --> 00:15:20,000
多个 Docker 的 contender

393
00:15:20,000 --> 00:15:23,000
然后每个 contender 里面只运行单一的一个应用

394
00:15:23,000 --> 00:15:25,000
它可能是一个数据库

395
00:15:25,000 --> 00:15:26,000
像买 Secure

396
00:15:26,000 --> 00:15:28,000
可能是一个 web 服务器

397
00:15:28,000 --> 00:15:29,000
像 NGX

398
00:15:29,000 --> 00:15:31,000
还有一个像应用服务器

399
00:15:31,000 --> 00:15:32,000
比如说一个 Tomcat

400
00:15:32,000 --> 00:15:33,000
或者其他一些什么

401
00:15:33,000 --> 00:15:36,000
像 Python 或者 Ruby 写的一个应用进程

402
00:15:36,000 --> 00:15:36,000
对

403
00:15:36,000 --> 00:15:40,000
所以它用这种 POW 的概念来管理一组 service

404
00:15:40,000 --> 00:15:44,000
所以这里听起来

405
00:15:44,000 --> 00:15:47,000
它就是做这件事情的时候

406
00:15:47,000 --> 00:15:49,000
Hyper 相对一些已有的工具

407
00:15:49,000 --> 00:15:52,000
它们的主要的区别在哪里呢

408
00:15:52,000 --> 00:15:55,000
比如说可能像过去也有像基于 KVM

409
00:15:55,000 --> 00:15:56,000
Nimax 上面的 KVM

410
00:15:56,000 --> 00:15:59,000
也可以运行一些轻量级快速启动的

411
00:15:59,000 --> 00:16:02,000
当然这个可能需要定制你跑的

412
00:16:02,000 --> 00:16:03,000
那个叫做 GaST

413
00:16:03,000 --> 00:16:05,000
就是 GaST OS

414
00:16:05,000 --> 00:16:06,000
对

415
00:16:06,000 --> 00:16:07,000
就是宾客系统

416
00:16:07,000 --> 00:16:09,000
还有一些像过去基于这种

417
00:16:09,000 --> 00:16:11,000
传统的 Hypervisor 的一些工具

418
00:16:11,000 --> 00:16:12,000
像 Zen

419
00:16:12,000 --> 00:16:14,000
你也可以做一些事情

420
00:16:14,000 --> 00:16:15,000
那么从这个角度出发的话

421
00:16:15,000 --> 00:16:17,000
Hyper 和它们的区别

422
00:16:17,000 --> 00:16:19,000
刚刚提到 KVM 和 Zen

423
00:16:19,000 --> 00:16:20,000
它们的区别主要在哪里

424
00:16:20,000 --> 00:16:23,000
其实我们底层也是用了 KVM

425
00:16:23,000 --> 00:16:26,000
Zen 以及 Waterbox 这些 Hypervisor

426
00:16:26,000 --> 00:16:29,000
但是我们跟它们的一个优势

427
00:16:29,000 --> 00:16:31,000
或者说我们做过什么东西

428
00:16:31,000 --> 00:16:34,000
就是我们将 GaST OS

429
00:16:35,000 --> 00:16:37,000
我们实现一个经济

430
00:16:37,000 --> 00:16:38,000
最简单的一个 GaST OS

431
00:16:38,000 --> 00:16:43,000
主要是用于跑 Docker 的 image

432
00:16:43,000 --> 00:16:46,000
然后形成 content 的这些工作

433
00:16:46,000 --> 00:16:49,000
另外我们外边提供一整套管理工具

434
00:16:49,000 --> 00:16:52,000
然后可以管理这些 Hypervisor

435
00:16:52,000 --> 00:16:55,000
然后让它能够以泡的为单位

436
00:16:55,000 --> 00:16:57,000
去运行 Docker 的 image

437
00:16:58,000 --> 00:17:02,000
然后并且提供很多监控的工具

438
00:17:02,000 --> 00:17:03,000
这样的话方便用户

439
00:17:03,000 --> 00:17:05,000
运行 Docker image

440
00:17:05,000 --> 00:17:07,000
并有更好的安全性

441
00:17:08,000 --> 00:17:12,000
所以实际上 Hyper 是分两部分

442
00:17:12,000 --> 00:17:15,000
一个是说管理传统的像 KVMZen

443
00:17:15,000 --> 00:17:16,000
这些 Hypervisor 的工具

444
00:17:16,000 --> 00:17:19,000
然后另一方面它是说是包含一个

445
00:17:19,000 --> 00:17:21,000
你们定制过的极度精简的

446
00:17:21,000 --> 00:17:23,000
一个 GaST OS 的内核

447
00:17:23,000 --> 00:17:24,000
对 是的

448
00:17:24,000 --> 00:17:25,000
可以这么理解吗

449
00:17:25,000 --> 00:17:25,000
对

450
00:17:27,000 --> 00:17:29,000
这里就牵涉到两方面的问题了

451
00:17:29,000 --> 00:17:31,000
就是说在管理工具这一块

452
00:17:31,000 --> 00:17:36,000
Hyper 和 Docker 他们之间的界限是什么

453
00:17:38,000 --> 00:17:40,000
你一直哪方面的界限

454
00:17:40,000 --> 00:17:43,000
比如说你刚才提到 Hyper 里面

455
00:17:43,000 --> 00:17:45,000
它 GaST OS 里面包含哪些的东西

456
00:17:45,000 --> 00:17:47,000
就只有一个基础内核吗

457
00:17:47,000 --> 00:17:48,000
对

458
00:17:48,000 --> 00:17:50,000
这个 GaST OS 里面除了内核之外

459
00:17:50,000 --> 00:17:51,000
还有什么东西

460
00:17:51,000 --> 00:17:52,000
没有别的

461
00:17:52,000 --> 00:17:55,000
它只是跟外边的 Hyperdemon

462
00:17:55,000 --> 00:17:57,000
去一个交互的作用

463
00:17:57,000 --> 00:17:59,000
然后我们会把用 Hyperdemon

464
00:17:59,000 --> 00:18:01,000
会把 Docker 的 image

465
00:18:01,000 --> 00:18:03,000
从 Docker Hub 上面下载下来

466
00:18:03,000 --> 00:18:06,000
然后作为一个 Ball device

467
00:18:06,000 --> 00:18:11,000
或者是一个握他有 9 P 的一个文件

468
00:18:11,000 --> 00:18:14,000
它也是给 Hypervisor

469
00:18:14,000 --> 00:18:18,000
然后 GaST OS 拿到这些信息之后

470
00:18:18,000 --> 00:18:22,000
就会给用户生成一些运行式环境

471
00:18:22,000 --> 00:18:25,000
这是整个这样的一个大概的一个 synchro

472
00:18:26,000 --> 00:18:26,000
OK

473
00:18:26,000 --> 00:18:28,000
然后你刚才提到 Hyper

474
00:18:28,000 --> 00:18:30,000
还有一部分是管理像传统的

475
00:18:30,000 --> 00:18:31,000
像 KVM

476
00:18:31,000 --> 00:18:33,000
Synchro 这种 Hypervisor 的工具

477
00:18:33,000 --> 00:18:33,000
这一部分的话

478
00:18:33,000 --> 00:18:36,000
它又主要包含哪些组件

479
00:18:36,000 --> 00:18:37,000
或者是一些功能模块呢

480
00:18:37,000 --> 00:18:43,000
我想用过 Docker 的人都会有一些印象

481
00:18:43,000 --> 00:18:47,000
比如他可以直接用 Docker logs

482
00:18:47,000 --> 00:18:50,000
然后或者说 Docker ESE

483
00:18:50,000 --> 00:18:54,000
或者是 Docker 类似于 TTY 的这种环境

484
00:18:54,000 --> 00:18:56,000
其实我们也提供了这种工具

485
00:18:56,000 --> 00:18:57,000
就是可以

486
00:18:57,000 --> 00:19:05,000
因为如果一个用户要想看 Hypervisor 里面的信息的话

487
00:19:05,000 --> 00:19:08,000
那么或者说他的 log 的话

488
00:19:08,000 --> 00:19:12,000
就必须要登录或者 SSH 进去

489
00:19:12,000 --> 00:19:17,000
所以我们其实是将这些操作全都简化

490
00:19:17,000 --> 00:19:22,000
然后直接通过客户端或者说通过 API

491
00:19:22,000 --> 00:19:26,000
就可以让用户能够简单的访问

492
00:19:26,000 --> 00:19:31,000
到底 Hypervisor 里面运行的 content 到底怎么样了

493
00:19:31,000 --> 00:19:35,000
以及他的是否发生错误等等

494
00:19:35,000 --> 00:19:38,000
就这些全部达到一个监控的效果

495
00:19:38,000 --> 00:19:42,000
当然你也可以完全

496
00:19:42,000 --> 00:19:44,000
当这个 content 一运行的时候

497
00:19:44,000 --> 00:19:46,000
你就可以监控这个 content 的所有状态

498
00:19:46,000 --> 00:19:48,000
将 log 全部收集起来

499
00:19:48,000 --> 00:19:49,000
然后再去分析

500
00:19:49,000 --> 00:19:52,000
其实一个有很方便的 API

501
00:19:52,000 --> 00:19:55,000
方便用户再次开发

502
00:19:57,000 --> 00:20:00,000
所以如果我们画一个层次结构图的话

503
00:20:00,000 --> 00:20:03,000
最底层可能是 host 的操作系统

504
00:20:03,000 --> 00:20:07,000
然后它上面会跑着像诸如 KVM

505
00:20:07,000 --> 00:20:09,000
Zenon 这样的一些 Hypervisor 的工具

506
00:20:09,000 --> 00:20:11,000
然后再事实上就是 Hyper 这一层

507
00:20:11,000 --> 00:20:14,000
去管理 KVM 和 Zenon 这样的工具

508
00:20:14,000 --> 00:20:18,000
然后再在 Hyper 管理的这些 guest VM 里面

509
00:20:18,000 --> 00:20:21,000
会跑 Docker 的一个镜像

510
00:20:21,000 --> 00:20:25,000
然后再在镜像里面去运行我们最终的应用程序

511
00:20:25,000 --> 00:20:26,000
没错吧

512
00:20:26,000 --> 00:20:28,000
那个概念上有点不太一样

513
00:20:28,000 --> 00:20:31,000
因为刚才你说的可能就是

514
00:20:31,000 --> 00:20:34,000
更多人去想到这种方式

515
00:20:34,000 --> 00:20:38,000
其实这种方式就是目前的 boot to Docker

516
00:20:38,000 --> 00:20:43,000
它就是将 Docker 的 demon 放在一个 VM 里面去运行

517
00:20:43,000 --> 00:20:47,000
而我们其实是将 Hyper 的 demon

518
00:20:47,000 --> 00:20:49,000
其实我们这里就没有 Docker 的 demon

519
00:20:49,000 --> 00:20:51,000
因为我最开始其实是依赖于 Docker 的 demon

520
00:20:51,000 --> 00:20:52,000
但现在没有了

521
00:20:53,000 --> 00:20:55,000
对所以我们取消了 Docker 的依赖

522
00:20:55,000 --> 00:21:00,000
然后将 Hyperdemon 放在 house OS 里面去运行

523
00:21:00,000 --> 00:21:04,000
而 Docker 的 image 下载下来是

524
00:21:04,000 --> 00:21:08,000
直接把这些文件全部传进 VM

525
00:21:08,000 --> 00:21:14,000
然后 guest OS 再去用这些文件来去起 container

526
00:21:14,000 --> 00:21:17,000
然后去运行这些文件

527
00:21:18,000 --> 00:21:19,000
所以其实你们是

528
00:21:19,000 --> 00:21:23,000
Hyper 是完全替代掉了 Docker 的管理的功能

529
00:21:23,000 --> 00:21:24,000
对

530
00:21:24,000 --> 00:21:27,000
你们只是附用了 Docker 已经制作好的

531
00:21:27,000 --> 00:21:31,000
它本来是为 Docker 管理工具制作好的 container image

532
00:21:31,000 --> 00:21:31,000
对

533
00:21:32,000 --> 00:21:35,000
这个还和我之前接的有一点点出入

534
00:21:36,000 --> 00:21:37,000
这个话其实就还蛮酷的

535
00:21:37,000 --> 00:21:40,000
理论上来讲

536
00:21:40,000 --> 00:21:43,000
如果你们因为 Hyper 管理的 VM 的

537
00:21:43,000 --> 00:21:45,000
虚拟机也非常轻量

538
00:21:45,000 --> 00:21:45,000
其实也很快

539
00:21:45,000 --> 00:21:46,000
对

540
00:21:46,000 --> 00:21:49,000
同时它有具备传统的像 Docker

541
00:21:49,000 --> 00:21:52,000
无法提供的内核级别的隔离的安全性

542
00:21:52,000 --> 00:21:52,000
对吧

543
00:21:52,000 --> 00:21:53,000
对

544
00:21:53,000 --> 00:21:57,000
所以其实是在安全性和性能上是完全可以

545
00:21:57,000 --> 00:22:01,000
替代甚至超越 Docker 这个 demon 本身的

546
00:22:01,000 --> 00:22:01,000
对

547
00:22:02,000 --> 00:22:03,000
明白

548
00:22:03,000 --> 00:22:03,000
非常好

549
00:22:03,000 --> 00:22:04,000
非常好的解释

550
00:22:04,000 --> 00:22:08,000
所以现在刚才有提到一个最主要的核心要点

551
00:22:08,000 --> 00:22:12,000
就是说安全性这一块面

552
00:22:12,000 --> 00:22:15,000
可能很多不是做内核相关的朋友

553
00:22:15,000 --> 00:22:18,000
可能其实也是现在很多使用 Docker container 的

554
00:22:18,000 --> 00:22:20,000
一个新手可能一个困惑

555
00:22:20,000 --> 00:22:20,000
就是说

556
00:22:20,000 --> 00:22:23,000
因为确实你想一个 Docker 的 image

557
00:22:23,000 --> 00:22:25,000
给人感觉用起来很像一个虚拟机

558
00:22:25,000 --> 00:22:26,000
对

559
00:22:26,000 --> 00:22:28,000
但它其实并不是一个虚拟机

560
00:22:28,000 --> 00:22:30,000
只是一个我们叫做集装箱

561
00:22:30,000 --> 00:22:32,000
或者一个容器这么一个概念

562
00:22:32,000 --> 00:22:32,000
对

563
00:22:32,000 --> 00:22:36,000
所以 Simon 肯定这里要给我们这些新手

564
00:22:36,000 --> 00:22:39,000
还有很多也不太熟悉使用 Docker 的人要普及一下

565
00:22:39,000 --> 00:22:42,000
为什么说 Docker 不能提供像传统的虚拟机

566
00:22:42,000 --> 00:22:44,000
那样的这么一个安全性

567
00:22:44,000 --> 00:22:48,000
其实这个的话就是从 Docker 本身用的技术

568
00:22:48,000 --> 00:22:49,000
上面就要来讨问

569
00:22:49,000 --> 00:22:52,000
因为 Docker 其实它并没有

570
00:22:52,000 --> 00:22:56,000
就是可能说的有点太直白了

571
00:22:56,000 --> 00:23:00,000
就是 Docker 其实并没有发明任何新的技术

572
00:23:00,000 --> 00:23:01,000
OK

573
00:23:01,000 --> 00:23:02,000
对

574
00:23:02,000 --> 00:23:04,000
这个其实很多人对 Docker 的一个指责

575
00:23:04,000 --> 00:23:06,000
就说因为所有的像 container 这些概念

576
00:23:06,000 --> 00:23:08,000
可能是 10 年前就已经有了

577
00:23:08,000 --> 00:23:08,000
对

578
00:23:08,000 --> 00:23:13,000
然后很多人都说 Docker 其实只是把一些叫什么新瓶装就酒

579
00:23:13,000 --> 00:23:13,000
对

580
00:23:15,000 --> 00:23:15,000
这个到底没什么

581
00:23:15,000 --> 00:23:18,000
就是从技术角度上确实是这样子的

582
00:23:18,000 --> 00:23:20,000
就我的理解可能 Docker 的主要的价值

583
00:23:20,000 --> 00:23:22,000
还是说它提出了这么一套理念

584
00:23:22,000 --> 00:23:24,000
让大家可以说就更好的去

585
00:23:24,000 --> 00:23:29,000
从开发到测试到实际部署这么一套工具流程

586
00:23:29,000 --> 00:23:30,000
对

587
00:23:31,000 --> 00:23:32,000
那么刚才那个安全性的问题

588
00:23:33,000 --> 00:23:38,000
为什么说我们这些小白们会觉得这个 container 之间是有隔离的

589
00:23:38,000 --> 00:23:40,000
但其实并没有想象的那么好

590
00:23:40,000 --> 00:23:41,000
对

591
00:23:41,000 --> 00:23:43,000
就是因为这些 container 之间

592
00:23:43,000 --> 00:23:45,000
它的一个实验方式

593
00:23:45,000 --> 00:23:48,000
它是基于 Namespace 或者说更底层一点

594
00:23:48,000 --> 00:23:50,000
它是通过 Sick Groups

595
00:23:50,000 --> 00:23:53,000
Sick Groups 就是一个内核的一个 module

596
00:23:53,000 --> 00:23:56,000
然后它所做一个隔离性

597
00:23:56,000 --> 00:23:58,000
就是相当于用户可以配置

598
00:23:58,000 --> 00:24:01,000
然后 Sick Groups 在内核里面去限制

599
00:24:01,000 --> 00:24:03,000
某一个模块

600
00:24:03,000 --> 00:24:04,000
比如内存

601
00:24:04,000 --> 00:24:06,000
比如 CPU

602
00:24:06,000 --> 00:24:08,000
每个现场可以用多少

603
00:24:08,000 --> 00:24:09,000
但是这样的话

604
00:24:09,000 --> 00:24:14,000
它所有全都是基于一个 house OS 的 kernel 去做的

605
00:24:14,000 --> 00:24:22,000
然后如果一个 container 里面的一个 process 获取了一些更高级的权限

606
00:24:22,000 --> 00:24:25,000
它就可以控制这个内核

607
00:24:25,000 --> 00:24:27,000
而可能这个就是特别细

608
00:24:27,000 --> 00:24:30,000
怎么 hack 这个的事情

609
00:24:30,000 --> 00:24:33,000
但是本身你 share 的 kernel

610
00:24:33,000 --> 00:24:35,000
它其实就是有这种问题的

611
00:24:35,000 --> 00:24:39,000
因为你如果一个 container 出个问题

612
00:24:39,000 --> 00:24:41,000
导致 kernel panic 的话

613
00:24:41,000 --> 00:24:45,000
就会导致整个所有的 container 不可用

614
00:24:45,000 --> 00:24:48,000
看来 B 节目的名字还是很有示范意义的

615
00:24:48,000 --> 00:24:48,000
对

616
00:24:48,000 --> 00:24:50,000
对

617
00:24:50,000 --> 00:24:52,000
所以刚才你提到一个很重要的概念

618
00:24:52,000 --> 00:24:55,000
就是如果在传统的一个 dockert 的部署里面

619
00:24:55,000 --> 00:24:58,000
如果你在一个虚拟机或者同一个内核里面

620
00:24:58,000 --> 00:25:03,000
部署了多个来历不明的这么一个 image 在跑

621
00:25:03,000 --> 00:25:06,000
然后假设某一个

622
00:25:06,000 --> 00:25:09,000
因为这个内核它不可能是完美的一个程序

623
00:25:09,000 --> 00:25:10,000
对吧

624
00:25:10,000 --> 00:25:12,000
所以假设一个内核的一个漏洞

625
00:25:12,000 --> 00:25:14,000
或者说你没有及时打上一些补丁

626
00:25:14,000 --> 00:25:15,000
使得一个恶意的程序

627
00:25:15,000 --> 00:25:16,000
抓住这个漏洞

628
00:25:16,000 --> 00:25:20,000
它其实可以越权拿到最高级的权限

629
00:25:20,000 --> 00:25:25,000
从而影响或者控制其他的 container 里面的东西

630
00:25:25,000 --> 00:25:26,000
对

631
00:25:26,000 --> 00:25:27,000
OK

632
00:25:27,000 --> 00:25:28,000
所以从这个方面来讲

633
00:25:28,000 --> 00:25:31,000
我们必须采用像传统的虚拟机

634
00:25:31,000 --> 00:25:34,000
就是独立 kernel 的这种虚拟机的方式

635
00:25:34,000 --> 00:25:39,000
才能实现哪怕一个 guestkernel 的被攻陷之后

636
00:25:39,000 --> 00:25:41,000
我的 host 还是相对来说安全的

637
00:25:41,000 --> 00:25:41,000
对

638
00:25:41,000 --> 00:25:42,000
对

639
00:25:42,000 --> 00:25:42,000
OK

640
00:25:42,000 --> 00:25:44,000
那么这里就会有一个自然而然的问题

641
00:25:44,000 --> 00:25:45,000
就是说这样的话

642
00:25:45,000 --> 00:25:47,000
毕竟还是多了一个虚拟机

643
00:25:47,000 --> 00:25:49,000
多了一个内核层面的在跑

644
00:25:49,000 --> 00:25:53,000
那么相对于这种 dockert 本身

645
00:25:53,000 --> 00:25:54,000
没有一个

646
00:25:54,000 --> 00:25:55,000
它是一个共享内核的情况

647
00:25:56,000 --> 00:25:58,000
它的额外的开销会是怎么样的一个情况

648
00:25:58,000 --> 00:25:58,000
对

649
00:25:58,000 --> 00:26:02,000
所以这个也就是我们之前一直在关注的一个点

650
00:26:02,000 --> 00:26:03,000
就是它的性能问题

651
00:26:03,000 --> 00:26:04,000
性能问题的话

652
00:26:04,000 --> 00:26:06,000
就是我们做了很多的测试

653
00:26:06,000 --> 00:26:15,000
其实我们并没有说更改或者说修改 hypervisor 的代码

654
00:26:15,000 --> 00:26:18,000
然后让它达到一个非常优化的一个

655
00:26:18,000 --> 00:26:22,000
但我们目前还是希望能够用更加通用的手段

656
00:26:22,000 --> 00:26:24,000
来解决用户的问题

657
00:26:24,000 --> 00:26:30,000
然后就刚才说的一个启动一个 container 的

658
00:26:30,000 --> 00:26:33,000
所给予的时间大概在 300 毫秒

659
00:26:33,000 --> 00:26:39,000
这个跟 docker 相比基本上没差太多

660
00:26:39,000 --> 00:26:42,000
然后性能上面是这点

661
00:26:42,000 --> 00:26:46,000
然后另外就是 cpug 用意上面基本相似

662
00:26:46,000 --> 00:26:49,000
可能很大的一个问题

663
00:26:49,000 --> 00:26:54,000
就是在网外 io 以及 storage 的 io 上面

664
00:26:54,000 --> 00:26:58,000
可能会受限于 hypervisor 它的性能

665
00:26:58,000 --> 00:27:02,000
因为你像 9 p 或者是像直接的报告 device

666
00:27:02,000 --> 00:27:06,000
它都毕竟要经过多层的传递

667
00:27:06,000 --> 00:27:08,000
然后可能会达不到很好效果

668
00:27:08,000 --> 00:27:12,000
但是我们其实也在目前也在解决这个问题

669
00:27:12,000 --> 00:27:15,000
就是用因为报告 device

670
00:27:15,000 --> 00:27:19,000
它其实还是传的 storage 的协议

671
00:27:19,000 --> 00:27:20,000
比如 scars 的协议

672
00:27:20,000 --> 00:27:23,000
直接 scars 的协议怎么能够传递

673
00:27:23,000 --> 00:27:26,000
或者怎么能够更减少它的困难层次

674
00:27:26,000 --> 00:27:29,000
就是一些可能 bypass 的技术

675
00:27:29,000 --> 00:27:31,000
OK

676
00:27:31,000 --> 00:27:31,000
所以总结一下

677
00:27:31,000 --> 00:27:35,000
就是说因为 hyper 还是基于虚拟机的技术

678
00:27:35,000 --> 00:27:37,000
所以传统的虚拟机的一些缺陷

679
00:27:37,000 --> 00:27:40,000
它可能还是起码在现阶段还是免不了的

680
00:27:40,000 --> 00:27:42,000
刚才提到了几个问题

681
00:27:42,000 --> 00:27:44,000
就是说它可能

682
00:27:44,000 --> 00:27:47,000
但我们现代 CPU

683
00:27:47,000 --> 00:27:49,000
像英特尔的一些服务器的 CPU

684
00:27:49,000 --> 00:27:52,000
它对硬件虚拟化的一些支持是非常好的

685
00:27:52,000 --> 00:27:55,000
所以在运算这一块的损耗

686
00:27:55,000 --> 00:27:57,000
其实几乎可以忽略不计

687
00:27:57,000 --> 00:27:58,000
我觉得

688
00:27:58,000 --> 00:27:58,000
对

689
00:27:58,000 --> 00:28:00,000
然后但是像 Io 层面

690
00:28:00,000 --> 00:28:03,000
因为它还是需要依赖于硬件的支持

691
00:28:03,000 --> 00:28:05,000
和内核的支持

692
00:28:05,000 --> 00:28:08,000
可能还做不到说一个比较好的状态

693
00:28:08,000 --> 00:28:09,000
那么我可以大概问一下

694
00:28:09,000 --> 00:28:11,000
就直观来讲

695
00:28:11,000 --> 00:28:13,000
比如说我网络

696
00:28:13,000 --> 00:28:18,000
我 1 GB 的物理网卡的这么一个吞吐量

697
00:28:18,000 --> 00:28:21,000
传到 hyper 这个虚拟机里面之后

698
00:28:21,000 --> 00:28:22,000
大概会损耗到多少

699
00:28:25,000 --> 00:28:27,000
我们之前确实是做过调查

700
00:28:27,000 --> 00:28:31,000
但是我现在手头没有这种资料

701
00:28:31,000 --> 00:28:31,000
OK

702
00:28:31,000 --> 00:28:34,000
这个是你刚才提到最主要问题

703
00:28:34,000 --> 00:28:35,000
就是 Io 的损耗是这块

704
00:28:35,000 --> 00:28:36,000
所以我特别好奇

705
00:28:36,000 --> 00:28:38,000
但如果说如果你有资料的话

706
00:28:38,000 --> 00:28:40,000
我们可以补到 show notes 里面

707
00:28:40,000 --> 00:28:40,000
对

708
00:28:40,000 --> 00:28:43,000
然后在我们的官网上

709
00:28:43,000 --> 00:28:45,000
其实是有更详细的资料

710
00:28:45,000 --> 00:28:48,000
然后因为这部分我没有参与测试

711
00:28:48,000 --> 00:28:51,000
所以具体细节不是特别清楚

712
00:28:51,000 --> 00:28:53,000
OK 没问题

713
00:28:53,000 --> 00:28:55,000
所以也说到 Io 这一块

714
00:28:55,000 --> 00:28:57,000
所以我顺便插话问一句

715
00:28:57,000 --> 00:28:58,000
刚才你也提到有一些叫做

716
00:28:58,000 --> 00:29:00,000
就是能够绕过

717
00:29:00,000 --> 00:29:01,000
因为 Io 最麻烦的问题

718
00:29:01,000 --> 00:29:02,000
是因为是虚拟

719
00:29:02,000 --> 00:29:05,000
就是 Gas OS 和 host OS

720
00:29:05,000 --> 00:29:07,000
它是要互相复制数据

721
00:29:07,000 --> 00:29:08,000
对

722
00:29:08,000 --> 00:29:09,000
这个是导致性能损耗

723
00:29:09,000 --> 00:29:11,000
最主要的一个原因

724
00:29:11,000 --> 00:29:12,000
那么你刚才也提到一些

725
00:29:12,000 --> 00:29:14,000
一些 bypass

726
00:29:14,000 --> 00:29:17,000
就是能够绕过复制的一些机制

727
00:29:17,000 --> 00:29:18,000
可以大概介绍一下

728
00:29:18,000 --> 00:29:19,000
你们目前在考虑的

729
00:29:19,000 --> 00:29:21,000
或者说以后可能会采用的

730
00:29:21,000 --> 00:29:23,000
一些方法是什么呢

731
00:29:23,000 --> 00:29:26,000
其实我们目前已经采用了

732
00:29:26,000 --> 00:29:30,000
Water IoNight 的一个模块

733
00:29:30,000 --> 00:29:34,000
然后它其实就是将网络的 Io

734
00:29:34,000 --> 00:29:37,000
bypass 相当于

735
00:29:37,000 --> 00:29:41,000
跨过 Hypervisor 底层的一个数据传输

736
00:29:41,000 --> 00:29:45,000
但是 host OS 它的一个 TCIP

737
00:29:45,000 --> 00:29:47,000
写协议站是没办法跨越的

738
00:29:47,000 --> 00:29:49,000
所以这个技术应该是

739
00:29:49,000 --> 00:29:51,000
应该是跨越 Hypervisor 的

740
00:29:51,000 --> 00:29:52,000
一个 TCIP 协议站

741
00:29:52,000 --> 00:29:55,000
它就是减少了它的层数

742
00:29:55,000 --> 00:29:57,000
然后另外其实我们也在

743
00:29:57,000 --> 00:30:01,000
基于 BallgeDevice 去做一些操作

744
00:30:01,000 --> 00:30:02,000
因为 BallgeDevice 的话

745
00:30:02,000 --> 00:30:07,000
它毕竟还是 Qwer 设备的传输

746
00:30:07,000 --> 00:30:11,000
更偏向于它的 Io 协议本身

747
00:30:11,000 --> 00:30:12,000
所以这样的话

748
00:30:12,000 --> 00:30:19,000
能够比文件系统级的优化效果会更好

749
00:30:19,000 --> 00:30:22,000
我们也在关注这些点

750
00:30:22,000 --> 00:30:25,000
OK 刚才你提到两个用例

751
00:30:25,000 --> 00:30:27,000
一个就是对一个经典的

752
00:30:27,000 --> 00:30:29,000
网络层的传输的优化

753
00:30:29,000 --> 00:30:31,000
还有一个是对文件系统传输层的

754
00:30:31,000 --> 00:30:33,000
存储层的一个优化

755
00:30:33,000 --> 00:30:38,000
我们就着刚才那个网络层的情况来讲

756
00:30:38,000 --> 00:30:39,000
因为大家可能最常用的

757
00:30:39,000 --> 00:30:42,000
还是用来部署一个基于 Web 的 server

758
00:30:42,000 --> 00:30:43,000
或者有服务器之类的应用

759
00:30:43,000 --> 00:30:44,000
对

760
00:30:44,000 --> 00:30:45,000
所以举一个例子

761
00:30:45,000 --> 00:30:47,000
比如说在一个经典的

762
00:30:47,000 --> 00:30:48,000
Hyper 的部署情况下

763
00:30:48,000 --> 00:30:51,000
就是说底下有个 host OS

764
00:30:51,000 --> 00:30:52,000
上面跑一个假设 KVM

765
00:30:52,000 --> 00:30:55,000
然后 Hyper 在管理一个 VM

766
00:30:55,000 --> 00:30:57,000
里面再跑一个 Docker Image 的

767
00:30:57,000 --> 00:30:58,000
这种情况下

768
00:30:58,000 --> 00:30:59,000
一个数据包

769
00:30:59,000 --> 00:31:02,000
从最里面的

770
00:31:02,000 --> 00:31:06,000
假设是一个 Nginx 的服务器里面传出来

771
00:31:06,000 --> 00:31:11,000
一直传到 host OS 硬件的网卡之间

772
00:31:11,000 --> 00:31:12,000
大概需要经过哪些步骤

773
00:31:12,000 --> 00:31:13,000
可以给我描述一下吗

774
00:31:13,000 --> 00:31:16,000
目前的话咱们先说正常的话

775
00:31:16,000 --> 00:31:21,000
它肯定是经过 Hypervisor 的 TDIP 写意展

776
00:31:21,000 --> 00:31:25,000
然后经过 Hypervisor 它的一个

777
00:31:25,000 --> 00:31:27,000
但是这个就要分

778
00:31:27,000 --> 00:31:29,000
它是硬件模拟还是

779
00:31:29,000 --> 00:31:33,000
就是全讯音化还是半讯音化

780
00:31:33,000 --> 00:31:36,000
这个的话就涉及到了 Qmer 的一些知识

781
00:31:36,000 --> 00:31:38,000
就是因为 Qmer 的话

782
00:31:38,000 --> 00:31:40,000
如果是 Qmer 全休米

783
00:31:40,000 --> 00:31:41,000
全讯音化的话

784
00:31:42,000 --> 00:31:45,000
它就是相当于完全硬件讯音化

785
00:31:45,000 --> 00:31:47,000
就是它就是

786
00:31:47,000 --> 00:31:48,000
网卡都是讯出来的

787
00:31:48,000 --> 00:31:53,000
所以它走的路是跟 House OS

788
00:31:53,000 --> 00:31:54,000
是完全一致的

789
00:31:54,000 --> 00:31:56,000
大家也可以查一下资料

790
00:31:56,000 --> 00:31:57,000
就可能走 TDIP 写意展

791
00:31:57,000 --> 00:32:02,000
然后再走 Nik 的 Driver

792
00:32:02,000 --> 00:32:05,000
然后再往下走 Formwire 这些东西

793
00:32:06,000 --> 00:32:09,000
然后如果要是半讯音化的话

794
00:32:09,000 --> 00:32:12,000
它就可以用 Word.io

795
00:32:12,000 --> 00:32:14,000
Night Word.io

796
00:32:14,000 --> 00:32:16,000
反正就是相当于 Nightwork

797
00:32:16,000 --> 00:32:17,000
可能 bypass 一个技术

798
00:32:17,000 --> 00:32:21,000
就是将 Hypervisor 里面的网络包的数据

799
00:32:21,000 --> 00:32:23,000
直接给到 Nik 的 Driver

800
00:32:23,000 --> 00:32:24,000
然后用 Nik

801
00:32:24,000 --> 00:32:28,000
然后调一些 IoToken 命令

802
00:32:28,000 --> 00:32:31,000
直接让 IoToken 直接发送出去

803
00:32:31,000 --> 00:32:33,000
然后交给 House OS

804
00:32:33,000 --> 00:32:36,000
然后它其实在这个过程中

805
00:32:36,000 --> 00:32:37,000
我如果没记错的话

806
00:32:37,000 --> 00:32:44,000
应该是 Hypervisor 里面的 Nik 的讯音地址

807
00:32:44,000 --> 00:32:50,000
其实是和 House OS 里面的网卡的地址

808
00:32:50,000 --> 00:32:52,000
其实映射到一起

809
00:32:52,000 --> 00:32:54,000
然后这样的话能够缩减很多层

810
00:32:54,000 --> 00:32:56,000
就不用复制那么多次了吗

811
00:32:56,000 --> 00:32:57,000
对

812
00:32:57,000 --> 00:32:59,000
其实在网络传输过程中

813
00:32:59,000 --> 00:33:03,000
用户台和内核台之间的网络包的复制过程

814
00:33:03,000 --> 00:33:05,000
还是比较耗时的

815
00:33:05,000 --> 00:33:06,000
对

816
00:33:06,000 --> 00:33:08,000
然后另外一个就是它的

817
00:33:08,000 --> 00:33:12,000
相当于用户台和内核台一个切换过程

818
00:33:12,000 --> 00:33:15,000
但是这个的话其实没有特别好的办法

819
00:33:15,000 --> 00:33:17,000
因为你要保证实时性

820
00:33:17,000 --> 00:33:19,000
要保证能够

821
00:33:19,000 --> 00:33:22,000
它的能把这些包全都传送出去

822
00:33:22,000 --> 00:33:25,000
所以必须用一些机制来触发

823
00:33:25,000 --> 00:33:29,000
所以可能 IoToken 或者是用其他方式去触发

824
00:33:29,000 --> 00:33:33,000
但是这个东西我们目前也是用过现有的机制

825
00:33:33,000 --> 00:33:35,000
没有特别

826
00:33:35,000 --> 00:33:40,000
就目前还没有设计这方面的动作

827
00:33:40,000 --> 00:33:42,000
OK 明白

828
00:33:42,000 --> 00:33:45,000
接着 Hyper 那套工具讲

829
00:33:45,000 --> 00:33:48,000
你也提到了 Hyper 它会提供一个非常轻量级的

830
00:33:48,000 --> 00:33:53,000
Gas OS 的 VM 在那里去运行里面的 Docker Image

831
00:33:53,000 --> 00:33:56,000
这里面就可能要跟现有的一些其他的

832
00:33:56,000 --> 00:33:59,000
想做同类事情的工具相比了

833
00:33:59,000 --> 00:34:01,000
比如说比较著名的现在比较火的

834
00:34:01,000 --> 00:34:02,000
像 Core OS

835
00:34:03,000 --> 00:34:05,000
还有像一个上次

836
00:34:05,000 --> 00:34:06,000
还有 Intel 也出了一个

837
00:34:06,000 --> 00:34:08,000
是专门跑 Docker Image 的

838
00:34:08,000 --> 00:34:13,000
这么一个极度精简的 Linux 的 OS

839
00:34:13,000 --> 00:34:16,000
相比起来你们比他们的区别在哪里

840
00:34:16,000 --> 00:34:18,000
就是精简了什么东西

841
00:34:18,000 --> 00:34:19,000
是这样的

842
00:34:19,000 --> 00:34:22,000
就是 Intel 出的叫 Cogil Gainegos

843
00:34:22,000 --> 00:34:27,000
它的出现对我们来说还是作为很震惊的

844
00:34:27,000 --> 00:34:31,000
但是其实也是验证了我们的方向是正确的

845
00:34:31,000 --> 00:34:34,000
因为大厂都跟进这件事情了

846
00:34:35,000 --> 00:34:39,000
所以我们既兴奋又担心还有点惊讶

847
00:34:40,000 --> 00:34:44,000
然后它和 Cogil Gainegos 其实应该是

848
00:34:45,000 --> 00:34:47,000
应该是属于类似的东西

849
00:34:47,000 --> 00:34:49,000
但是他们的目的可能不太一样

850
00:34:49,000 --> 00:34:51,000
就是我们自己的分析

851
00:34:51,000 --> 00:34:52,000
因为 Cogil Gainegos

852
00:34:52,000 --> 00:34:54,000
它的一个

853
00:34:55,000 --> 00:34:58,000
它其实是为了验证 Intel 的硬件

854
00:34:58,000 --> 00:35:02,000
因为 Intel 它虽然说是开源技术中心做出来的

855
00:35:02,000 --> 00:35:07,000
但也不能说一帮人没什么意义去做这个东西

856
00:35:07,000 --> 00:35:11,000
我们分析它应该是为了体现

857
00:35:11,000 --> 00:35:13,000
他们的硬件足够的快

858
00:35:13,000 --> 00:35:17,000
可以达到启动一个 Nginx 的 GaSOS

859
00:35:18,000 --> 00:35:19,000
能够非常非常非常快

860
00:35:19,000 --> 00:35:21,000
几个毫秒级的

861
00:35:21,000 --> 00:35:27,000
然后当然也有很多人基于这个东西去做了很多的

862
00:35:27,000 --> 00:35:29,000
因为 Docker 目前的形式非常火

863
00:35:29,000 --> 00:35:35,000
所以很多人基于 Cogil Gainegos 去做了一些贡献

864
00:35:35,000 --> 00:35:37,000
然后就是把它改造了一下

865
00:35:37,000 --> 00:35:40,000
之前还有一个 PR 专门给 Docker 的

866
00:35:41,000 --> 00:35:44,000
相当于 Docker 的 upstream

867
00:35:44,000 --> 00:35:45,000
然后去提了一个 PR

868
00:35:45,000 --> 00:35:51,000
就是希望能够用 Cogil Gainegos 来运行

869
00:35:51,000 --> 00:35:52,000
Docker 的 image

870
00:35:53,000 --> 00:35:55,000
但是这个没有被接手

871
00:35:55,000 --> 00:35:56,000
因为可能觉得

872
00:35:58,000 --> 00:35:59,000
可能做得不太好吧

873
00:35:59,000 --> 00:36:05,000
或者说它的性能或者说整体的一个运动方式

874
00:36:05,000 --> 00:36:06,000
跟 Docker 不太一样

875
00:36:07,000 --> 00:36:08,000
对

876
00:36:08,000 --> 00:36:12,000
所以我们也关注它很长时间

877
00:36:12,000 --> 00:36:14,000
它目前也在不断的维护

878
00:36:14,000 --> 00:36:18,000
然后它跟 Cogil Gainegos

879
00:36:18,000 --> 00:36:20,000
就是就提到 Cogil Gainegos

880
00:36:20,000 --> 00:36:21,000
其实它是在 Cogil OS 里面

881
00:36:21,000 --> 00:36:24,000
它给你做了足够多的配置

882
00:36:24,000 --> 00:36:28,000
然后让你直接去运行 Docker 的 Demon

883
00:36:28,000 --> 00:36:30,000
或者说 Docker 的 contender

884
00:36:30,000 --> 00:36:35,000
然后你直接 Cogil Gainegos 是不可以装在一个

885
00:36:36,000 --> 00:36:38,000
Biomantle 的一个机器上面

886
00:36:38,000 --> 00:36:39,000
而 Cogil OS 是可以的

887
00:36:39,000 --> 00:36:42,000
它可以装在 Biomantle 机器上

888
00:36:42,000 --> 00:36:43,000
然后这样的话

889
00:36:43,000 --> 00:36:46,000
配置到一个机房就可以运行

890
00:36:46,000 --> 00:36:48,000
就可以直接你装一个 OS

891
00:36:48,000 --> 00:36:50,000
你可以直接运行 Docker 的 Demon

892
00:36:50,000 --> 00:36:51,000
Docker 的任何名令

893
00:36:51,000 --> 00:36:52,000
你都可以去直接运行

894
00:36:52,000 --> 00:36:54,000
而且它可以优化

895
00:36:54,000 --> 00:36:57,000
所以它可能的场景不太一样

896
00:36:57,000 --> 00:37:00,000
所以说我们的 Hyper 其实跟它们

897
00:37:00,000 --> 00:37:04,000
其实不是特别养育我们

898
00:37:04,000 --> 00:37:06,000
其实虽然说也提供一个 GaS OS

899
00:37:06,000 --> 00:37:08,000
但是我们这一种 GaS OS

900
00:37:08,000 --> 00:37:12,000
它其实是为了在 VM 里面

901
00:37:12,000 --> 00:37:15,000
跟外边的 HyperDemon 去配合

902
00:37:15,000 --> 00:37:19,000
然后去运行 Docker 的 image

903
00:37:19,000 --> 00:37:21,000
其实我们是一个整套的环境

904
00:37:21,000 --> 00:37:25,000
其实就是跟 Docker 平行的

905
00:37:25,000 --> 00:37:27,000
另外一套的环境

906
00:37:28,000 --> 00:37:30,000
所以如果我这样理解没错的话

907
00:37:30,000 --> 00:37:33,000
就是 Cogil OS 和 Intel 出的 Clear Linux

908
00:37:33,000 --> 00:37:35,000
它们还是依赖于 DockerDemon 本身

909
00:37:35,000 --> 00:37:36,000
对是的

910
00:37:36,000 --> 00:37:39,000
而 Hyper 是可以完全替代它的

911
00:37:39,000 --> 00:37:40,000
对对对是

912
00:37:40,000 --> 00:37:42,000
所以其实从我个人角度来讲

913
00:37:42,000 --> 00:37:45,000
肯定是少一层比多一层简单

914
00:37:45,000 --> 00:37:46,000
对对对

915
00:37:46,000 --> 00:37:48,000
这个也是看大家应用场景

916
00:37:48,000 --> 00:37:50,000
可能关注点不太一样

917
00:37:50,000 --> 00:37:55,000
但是也不能太推销我们的东西

918
00:37:56,000 --> 00:37:56,000
没错

919
00:37:56,000 --> 00:37:58,000
这里就提到应用场景

920
00:37:58,000 --> 00:37:59,000
这个非常重要

921
00:37:59,000 --> 00:38:00,000
好

922
00:38:00,000 --> 00:38:02,000
所以在你们的定位里面

923
00:38:02,000 --> 00:38:03,000
是在什么场景下

924
00:38:03,000 --> 00:38:07,000
适用用 Hyper 会比较好

925
00:38:07,000 --> 00:38:09,000
其实我们是希望

926
00:38:09,000 --> 00:38:13,000
但是我们的一个做 Hyper 的目的

927
00:38:13,000 --> 00:38:19,000
是希望有想法用 Docker

928
00:38:19,000 --> 00:38:23,000
做构建一个共有云的一个厂商

929
00:38:25,000 --> 00:38:27,000
当然可能目前已经有了

930
00:38:27,000 --> 00:38:31,000
就比如 DockerO 的点

931
00:38:31,000 --> 00:38:33,000
DockerO 他们其实就是

932
00:38:33,000 --> 00:38:38,000
声称是用 Docker 做一个

933
00:38:38,000 --> 00:38:40,000
去构建的一个共有云

934
00:38:40,000 --> 00:38:42,000
但是我不确定

935
00:38:42,000 --> 00:38:44,000
他们内部是怎么搭建的

936
00:38:44,000 --> 00:38:46,000
来保证用户的安全性

937
00:38:46,000 --> 00:38:46,000
OK

938
00:38:46,000 --> 00:38:49,000
这个就涉及到刚才我们讲的问题了

939
00:38:49,000 --> 00:38:50,000
如果说

940
00:38:50,000 --> 00:38:51,000
因为你没有内核隔离的话

941
00:38:51,000 --> 00:38:53,000
其实是 Docker 本身的

942
00:38:53,000 --> 00:38:56,000
container 隔离是无法保证安全性的

943
00:38:56,000 --> 00:38:58,000
然后如果你跑的是一个共有云

944
00:38:58,000 --> 00:38:59,000
就所谓共有云

945
00:38:59,000 --> 00:39:01,000
就是说你的两个客户之间

946
00:39:01,000 --> 00:39:05,000
可能不是一家而一个人

947
00:39:05,000 --> 00:39:08,000
然后你也没法保证你运行的应用的

948
00:39:08,000 --> 00:39:12,000
性质或者是它是不是一个恶意程序

949
00:39:12,000 --> 00:39:13,000
你是无法保证的

950
00:39:13,000 --> 00:39:16,000
可能是共有云和私有云最大的区别

951
00:39:16,000 --> 00:39:16,000
对

952
00:39:17,000 --> 00:39:19,000
所以这种情况下是必须采用 VM 隔离

953
00:39:19,000 --> 00:39:23,000
才可以实现我们可以接受的安全性

954
00:39:23,000 --> 00:39:23,000
对

955
00:39:23,000 --> 00:39:25,000
因为目前就我们所知

956
00:39:25,000 --> 00:39:28,000
一般的共有云厂商一般都是

957
00:39:28,000 --> 00:39:29,000
用这种方式

958
00:39:29,000 --> 00:39:32,000
就是底层还是用 Hypervisor 去

959
00:39:32,000 --> 00:39:34,000
或者说 VM 去做隔离

960
00:39:34,000 --> 00:39:35,000
对

961
00:39:35,000 --> 00:39:36,000
然后可能没有

962
00:39:36,000 --> 00:39:39,000
用容器直接去做隔离

963
00:39:40,000 --> 00:39:40,000
不太靠谱

964
00:39:43,000 --> 00:39:45,000
所以 Hyper 的一个主要应用场景

965
00:39:45,000 --> 00:39:47,000
就是说给那些有志于提供

966
00:39:47,000 --> 00:39:49,000
共有云的厂商

967
00:39:49,000 --> 00:39:51,000
这么一套基础的工具

968
00:39:51,000 --> 00:39:53,000
使得他们可以比较快速的启动

969
00:39:53,000 --> 00:39:56,000
或者是关闭一个虚拟机

970
00:39:56,000 --> 00:39:58,000
然后虚拟机上是可以

971
00:39:58,000 --> 00:40:01,000
但是它面向暴露给用户的

972
00:40:01,000 --> 00:40:03,000
它确实一个叫什么来的

973
00:40:03,000 --> 00:40:06,000
是类似于 Container 那种 API

974
00:40:06,000 --> 00:40:06,000
对吧

975
00:40:06,000 --> 00:40:07,000
对

976
00:40:07,000 --> 00:40:08,000
OK

977
00:40:08,000 --> 00:40:10,000
所以这个就是牵涉到另外一个问题了

978
00:40:10,000 --> 00:40:11,000
就是说

979
00:40:11,000 --> 00:40:12,000
因为我们现在大部分的

980
00:40:12,000 --> 00:40:14,000
像 Linux 也好

981
00:40:14,000 --> 00:40:15,000
AWS 也好

982
00:40:15,000 --> 00:40:16,000
还有现在比较火的

983
00:40:16,000 --> 00:40:17,000
Digital Cloud 也好

984
00:40:18,000 --> 00:40:20,000
他们都是采用传统的虚拟机

985
00:40:20,000 --> 00:40:20,000
这种方法

986
00:40:20,000 --> 00:40:23,000
这种暴露出传统虚拟机这么一个单元

987
00:40:23,000 --> 00:40:26,000
然后由用户再去管理其中的

988
00:40:28,000 --> 00:40:29,000
是否跑 Docker

989
00:40:29,000 --> 00:40:30,000
是否跑什么

990
00:40:30,000 --> 00:40:31,000
跑什么 Guest OS 的事情

991
00:40:32,000 --> 00:40:33,000
那么刚才我们讲

992
00:40:33,000 --> 00:40:34,000
你直接暴露给用户一套

993
00:40:34,000 --> 00:40:36,000
基于 Container API 的好处

994
00:40:36,000 --> 00:40:38,000
相比于现在暴露给用户

995
00:40:38,000 --> 00:40:41,000
一个基于 VM 的 API 的好处是什么呢

996
00:40:44,000 --> 00:40:46,000
其实我觉得还是另外

997
00:40:46,000 --> 00:40:48,000
从一个应用场景上面来分析

998
00:40:48,000 --> 00:40:51,000
就是如果要是

999
00:40:52,000 --> 00:40:53,000
就比如说

1000
00:40:53,000 --> 00:40:55,000
用户他想

1001
00:40:55,000 --> 00:40:57,000
他已经在本地

1002
00:40:57,000 --> 00:40:59,000
他一个开发环境

1003
00:40:59,000 --> 00:41:00,000
他本地的话

1004
00:41:00,000 --> 00:41:02,000
他可以配置任何 Docker 的

1005
00:41:02,000 --> 00:41:03,000
一个 Image

1006
00:41:03,000 --> 00:41:05,000
然后去上传到自己的 Private

1007
00:41:05,000 --> 00:41:08,000
或者是 PubKey 的一个 Hub 上面

1008
00:41:08,000 --> 00:41:11,000
然后他再去运行

1009
00:41:11,000 --> 00:41:13,000
然后如果他要是像

1010
00:41:13,000 --> 00:41:16,000
直接拿到一个 VM 的一个环境的话

1011
00:41:16,000 --> 00:41:18,000
那他完全他要在自己搭 Docker

1012
00:41:18,000 --> 00:41:19,000
然后在里面去

1013
00:41:20,000 --> 00:41:20,000
直接来部署

1014
00:41:20,000 --> 00:41:23,000
再下来再去运行

1015
00:41:23,000 --> 00:41:24,000
或者是对

1016
00:41:24,000 --> 00:41:25,000
然后但是我们这种方式

1017
00:41:25,000 --> 00:41:29,000
你直接可以将你的 Docker 的 Image

1018
00:41:29,000 --> 00:41:30,000
直接下载向外

1019
00:41:30,000 --> 00:41:32,000
你只要填一些

1020
00:41:32,000 --> 00:41:34,000
你所想要的东西

1021
00:41:34,000 --> 00:41:35,000
直接全都给你部署在后端了

1022
00:41:35,000 --> 00:41:38,000
就是不需要你去做任何的配置

1023
00:41:38,000 --> 00:41:39,000
你只要填

1024
00:41:40,000 --> 00:41:42,000
我们这有一个叫 Json

1025
00:41:42,000 --> 00:41:43,000
就是输入文件

1026
00:41:43,000 --> 00:41:44,000
就是 Json 5

1027
00:41:44,000 --> 00:41:45,000
Json 5 里面可以定义

1028
00:41:46,000 --> 00:41:47,000
你的所有的

1029
00:41:47,000 --> 00:41:49,000
这个上面运行的东西

1030
00:41:49,000 --> 00:41:49,000
比如 Contender

1031
00:41:49,000 --> 00:41:51,000
运用这个 Contender

1032
00:41:51,000 --> 00:41:53,000
从哪下载

1033
00:41:53,000 --> 00:41:55,000
然后以及那个

1034
00:41:55,000 --> 00:41:57,000
Port 的那端口影设

1035
00:41:57,000 --> 00:41:59,000
然后以及 Sourage 等等

1036
00:41:59,000 --> 00:42:01,000
你都可以去自己去配置

1037
00:42:01,000 --> 00:42:02,000
然后

1038
00:42:02,000 --> 00:42:05,000
所以就是简化用户操作

1039
00:42:05,000 --> 00:42:05,000
我觉得

1040
00:42:06,000 --> 00:42:07,000
OK

1041
00:42:07,000 --> 00:42:09,000
所以这个其实还是挺切中

1042
00:42:09,000 --> 00:42:11,000
我的个人的一个痛点

1043
00:42:11,000 --> 00:42:12,000
比如说我自己在运营

1044
00:42:12,000 --> 00:42:14,000
就这个 IPN 的服务

1045
00:42:14,000 --> 00:42:15,000
还有一些帮朋友管的一些

1046
00:42:15,000 --> 00:42:16,000
其他的一些服务

1047
00:42:16,000 --> 00:42:19,000
然后他们每次要新增一个服务

1048
00:42:19,000 --> 00:42:20,000
或者是管

1049
00:42:20,000 --> 00:42:22,000
特别是新增的时候会有一个问题

1050
00:42:22,000 --> 00:42:22,000
就是说

1051
00:42:22,000 --> 00:42:24,000
给我的虚拟机

1052
00:42:24,000 --> 00:42:25,000
新开的一个虚拟机是空白的

1053
00:42:25,000 --> 00:42:27,000
我得重新搭一套

1054
00:42:27,000 --> 00:42:29,000
就是要建管理对应的帐号

1055
00:42:29,000 --> 00:42:30,000
对吧

1056
00:42:30,000 --> 00:42:31,000
对应的

1057
00:42:31,000 --> 00:42:33,000
要安装对应的软件

1058
00:42:33,000 --> 00:42:34,000
但这可能有一部分是可以通过

1059
00:42:34,000 --> 00:42:35,000
Docker

1060
00:42:35,000 --> 00:42:37,000
那个 Image 本身打包来实现的

1061
00:42:37,000 --> 00:42:39,000
但是刚才你提到一个很重要点

1062
00:42:39,000 --> 00:42:39,000
就是 Docker

1063
00:42:39,000 --> 00:42:40,000
Demon

1064
00:42:40,000 --> 00:42:41,000
就是守护技能本身

1065
00:42:41,000 --> 00:42:42,000
还是需要配置和安装的

1066
00:42:42,000 --> 00:42:43,000
对

1067
00:42:44,000 --> 00:42:45,000
所以其实我觉得还是一个

1068
00:42:45,000 --> 00:42:48,000
就是抽象层次的一个飞跃

1069
00:42:48,000 --> 00:42:50,000
你们其实是通过 Hyper 这套

1070
00:42:50,000 --> 00:42:52,000
基于 Contender 的 API

1071
00:42:52,000 --> 00:42:53,000
同时再加上

1072
00:42:54,000 --> 00:42:55,000
这个

1073
00:42:56,000 --> 00:42:57,000
VM 的安全性

1074
00:42:57,000 --> 00:42:59,000
使得我们不用再去操心

1075
00:42:59,000 --> 00:43:01,000
我大面目这个 Contender

1076
00:43:01,000 --> 00:43:03,000
其实我是可以在逻辑上

1077
00:43:03,000 --> 00:43:05,000
按照 Contender 来做部署了

1078
00:43:05,000 --> 00:43:07,000
只是说我不用再操心

1079
00:43:07,000 --> 00:43:08,000
像传统 Docker 这种

1080
00:43:08,000 --> 00:43:10,000
Contender 之间无法内核机

1081
00:43:10,000 --> 00:43:12,000
隔离的不安全的引换

1082
00:43:12,000 --> 00:43:12,000
对

1083
00:43:13,000 --> 00:43:13,000
没错

1084
00:43:13,000 --> 00:43:14,000
对

1085
00:43:15,000 --> 00:43:16,000
对

1086
00:43:16,000 --> 00:43:17,000
然后我们下面就要进入到一个

1087
00:43:17,000 --> 00:43:19,000
很关键的一个问题的讨论

1088
00:43:19,000 --> 00:43:20,000
就是说因为基于

1089
00:43:20,000 --> 00:43:22,000
因为 Docker 其实本身

1090
00:43:22,000 --> 00:43:23,000
我觉得到目前为止

1091
00:43:23,000 --> 00:43:25,000
也并没有很好的解决这个问题

1092
00:43:25,000 --> 00:43:28,000
就是这个存储空间的问题

1093
00:43:28,000 --> 00:43:29,000
因为过去的话

1094
00:43:29,000 --> 00:43:30,000
就照我的理解

1095
00:43:30,000 --> 00:43:31,000
它 Docker 的

1096
00:43:31,000 --> 00:43:32,000
因为它是提倡的叫做

1097
00:43:33,000 --> 00:43:34,000
应用式

1098
00:43:34,000 --> 00:43:36,000
那个 Contender 是不可变的

1099
00:43:36,000 --> 00:43:38,000
就 immutable 的 Contender

1100
00:43:38,000 --> 00:43:40,000
那么比如说你作为一个应用层

1101
00:43:40,000 --> 00:43:41,000
应用服务器本身

1102
00:43:41,000 --> 00:43:42,000
可能这个倒也没什么

1103
00:43:42,000 --> 00:43:44,000
你多起几个应用

1104
00:43:44,000 --> 00:43:46,000
就可以提高你的并发数

1105
00:43:46,000 --> 00:43:46,000
对吧

1106
00:43:46,000 --> 00:43:48,000
那当然是好的

1107
00:43:48,000 --> 00:43:51,000
但是我们做大部分的网站也好

1108
00:43:51,000 --> 00:43:52,000
还是什么服务也好

1109
00:43:52,000 --> 00:43:54,000
它还是必须要考虑这个数据

1110
00:43:54,000 --> 00:43:55,000
持久化的问题

1111
00:43:55,000 --> 00:43:58,000
就是说你从客户那里拿到了数据

1112
00:43:58,000 --> 00:43:59,000
那你存到哪里

1113
00:44:00,000 --> 00:44:02,000
过去 Docker 的一个提倡的一个概念

1114
00:44:02,000 --> 00:44:03,000
就是说

1115
00:44:03,000 --> 00:44:04,000
你再建一个

1116
00:44:04,000 --> 00:44:07,000
就单纯拿来做存储的一个 image

1117
00:44:08,000 --> 00:44:09,000
来做这件事情

1118
00:44:09,000 --> 00:44:10,000
所以我不知道这件事情

1119
00:44:10,000 --> 00:44:12,000
在 Hyper 里面是一个什么样的

1120
00:44:12,000 --> 00:44:13,000
一个值得鼓励

1121
00:44:13,000 --> 00:44:15,000
就是什么样的做法是值得鼓励的

1122
00:44:15,000 --> 00:44:20,000
我们目前是有一个单独的 Wogum 的

1123
00:44:20,000 --> 00:44:23,000
一个模块

1124
00:44:23,000 --> 00:44:24,000
然后它是

1125
00:44:24,000 --> 00:44:27,000
你可以在针对某个 content

1126
00:44:27,000 --> 00:44:31,000
或者说针对几个 content 去配置

1127
00:44:31,000 --> 00:44:37,000
然后你可以自己添加你想加入的 Wogum

1128
00:44:37,000 --> 00:44:40,000
这个 Wogum 既可以是文件

1129
00:44:40,000 --> 00:44:41,000
或者是目录

1130
00:44:41,000 --> 00:44:44,000
然后也可以是博客 device

1131
00:44:44,000 --> 00:44:47,000
博客 device 就是支持非常多的形式

1132
00:44:47,000 --> 00:44:48,000
或者就是

1133
00:44:49,000 --> 00:44:51,000
然后用户可以自由配置

1134
00:44:51,000 --> 00:44:54,000
然后你可以把这个多大多少

1135
00:44:54,000 --> 00:44:55,000
你都可以自己配置

1136
00:44:55,000 --> 00:44:58,000
然后指定给哪个用户都可以自己配置

1137
00:44:58,000 --> 00:44:58,000
然后这样的话

1138
00:44:59,000 --> 00:45:01,000
你加入到一个 content 里面

1139
00:45:01,000 --> 00:45:03,000
你 content 运行的时候

1140
00:45:03,000 --> 00:45:05,000
你可以指定我将数据存到

1141
00:45:08,000 --> 00:45:11,000
博客 device 或者说是 Wogum 里面

1142
00:45:12,000 --> 00:45:13,000
这样的话

1143
00:45:14,000 --> 00:45:18,000
目前我们是支持本地的以及加

1144
00:45:18,000 --> 00:45:19,000
Safe

1145
00:45:19,000 --> 00:45:23,000
或者说你用 SRT 当然也可能配

1146
00:45:23,000 --> 00:45:24,000
直接配 Storage

1147
00:45:24,000 --> 00:45:25,000
Sore 都可以

1148
00:45:26,000 --> 00:45:26,000
OK

1149
00:45:26,000 --> 00:45:30,000
所以我理解一下大概的一个做法

1150
00:45:30,000 --> 00:45:32,000
就是说我把

1151
00:45:33,000 --> 00:45:37,000
hyper 它会允许我虚拟出一块 block device

1152
00:45:37,000 --> 00:45:39,000
就是一个快存储器

1153
00:45:39,000 --> 00:45:40,000
然后这个快存储器

1154
00:45:40,000 --> 00:45:43,000
我可以直接挂载进我的某一个 hyper 的

1155
00:45:43,000 --> 00:45:44,000
虚拟机里面

1156
00:45:44,000 --> 00:45:46,000
成为一个文件系统也好

1157
00:45:46,000 --> 00:45:47,000
一个什么目录也好

1158
00:45:47,000 --> 00:45:50,000
然后使得这样的话

1159
00:45:50,000 --> 00:45:52,000
就是 hyper 虚拟机里面本身跑的

1160
00:45:52,000 --> 00:45:54,000
它还是一个 immutable

1161
00:45:54,000 --> 00:45:55,000
就是不可变的

1162
00:45:55,000 --> 00:45:57,000
然后它的写入的数据也是通过

1163
00:45:57,000 --> 00:45:59,000
刚才挂载进去的 block device

1164
00:45:59,000 --> 00:46:01,000
持久化到其他地方

1165
00:46:01,000 --> 00:46:01,000
对

1166
00:46:02,000 --> 00:46:03,000
然后这个持久化是要么你可以在

1167
00:46:03,000 --> 00:46:07,000
本机就是同一台 host 机器上执行

1168
00:46:07,000 --> 00:46:08,000
或者是通过

1169
00:46:08,000 --> 00:46:12,000
ISGAS 这种网络的存储的协议

1170
00:46:12,000 --> 00:46:14,000
写到另外一台一个文件

1171
00:46:14,000 --> 00:46:15,000
比如说一个文件服务器上

1172
00:46:15,000 --> 00:46:16,000
对

1173
00:46:16,000 --> 00:46:16,000
没错

1174
00:46:16,000 --> 00:46:17,000
是这样吗

1175
00:46:17,000 --> 00:46:18,000
OK

1176
00:46:18,000 --> 00:46:21,000
所以这里就牵涉到一个效率的问题了

1177
00:46:21,000 --> 00:46:23,000
刚才我们也在前面也提到了

1178
00:46:23,000 --> 00:46:25,000
就是说通过这种方式挂载进去的

1179
00:46:26,000 --> 00:46:30,000
Disk I 的效率会有很大的损耗吗

1180
00:46:30,000 --> 00:46:32,000
还是说什么样的情况

1181
00:46:32,000 --> 00:46:36,000
其实主要还是说 hypervisor 本身的

1182
00:46:37,000 --> 00:46:40,000
就是因为我们如果你要是挂本机的

1183
00:46:41,000 --> 00:46:42,000
保护 device 的话

1184
00:46:42,000 --> 00:46:44,000
那么它其实还是涉及到一个

1185
00:46:45,000 --> 00:46:48,000
IO 命令的一个传递的转换

1186
00:46:48,000 --> 00:46:51,000
然后这个的话消耗应该不大

1187
00:46:51,000 --> 00:46:53,000
但是如果你要是文件级别

1188
00:46:53,000 --> 00:46:54,000
就 mood 的话

1189
00:46:54,000 --> 00:46:56,000
它其实是走的

1190
00:46:57,000 --> 00:47:02,000
它是通过 hypervisor 的 share file

1191
00:47:02,000 --> 00:47:05,000
来 share 或者 share directory 来做的

1192
00:47:05,000 --> 00:47:08,000
所以这个过程我们之前测过

1193
00:47:08,000 --> 00:47:11,000
就是不管是 vmware 或者说 Waterbox

1194
00:47:11,000 --> 00:47:13,000
或者是 tumor

1195
00:47:13,000 --> 00:47:18,000
它的 share 的 mood 的性能都不是特别好

1196
00:47:18,000 --> 00:47:21,000
所以我们特别建议用保护 device 级别的去操作

1197
00:47:22,000 --> 00:47:24,000
另外就像刚才另外一种方式

1198
00:47:25,000 --> 00:47:25,000
还有第三种方式

1199
00:47:25,000 --> 00:47:28,000
就是比如我要是远端的

1200
00:47:28,000 --> 00:47:30,000
或者说 sorry server 的话

1201
00:47:30,000 --> 00:47:31,000
那这个的话

1202
00:47:31,000 --> 00:47:35,000
它因为可以是报给 hypervisor 一个

1203
00:47:35,000 --> 00:47:36,000
保护 device

1204
00:47:36,000 --> 00:47:38,000
所以它这个的性能可能是

1205
00:47:39,000 --> 00:47:42,000
除了依赖于 hypervisor 保护 device 的支持

1206
00:47:42,000 --> 00:47:47,000
还有的话就是用的第三方工具的性能了

1207
00:47:48,000 --> 00:47:49,000
对

1208
00:47:49,000 --> 00:47:51,000
所以 share 的 mood 的话

1209
00:47:51,000 --> 00:47:56,000
这确实是一个硬上没有特别好的办法

1210
00:47:56,000 --> 00:48:00,000
因为 hypervisor 本身他们做的也不太好

1211
00:48:00,000 --> 00:48:04,000
因为它是想达到更加用户

1212
00:48:04,000 --> 00:48:07,000
就是说普通用户级别的使用

1213
00:48:08,000 --> 00:48:10,000
而不是说我用这个来做企业级

1214
00:48:10,000 --> 00:48:14,000
或者说做工业级别应用可能不太一样

1215
00:48:14,000 --> 00:48:15,000
OK

1216
00:48:15,000 --> 00:48:17,000
所以那么就牵涉到一个问题了

1217
00:48:17,000 --> 00:48:20,000
就是说在实际大规模部署的时候

1218
00:48:20,000 --> 00:48:22,000
这种比如说类似于 Google

1219
00:48:22,000 --> 00:48:25,000
或者是 Amazon 这种级别的用户

1220
00:48:25,000 --> 00:48:27,000
他们一般会采用什么样的方式去部署

1221
00:48:28,000 --> 00:48:30,000
这种存储的方案呢

1222
00:48:34,000 --> 00:48:35,000
存储的方案

1223
00:48:35,000 --> 00:48:39,000
这我还真不确定他们怎么部署的

1224
00:48:39,000 --> 00:48:40,000
OK 没关系

1225
00:48:41,000 --> 00:48:43,000
我们进入下一个话题

1226
00:48:43,000 --> 00:48:45,000
就是说刚才也提到文件存储

1227
00:48:45,000 --> 00:48:47,000
可能是效率上是一个硬上

1228
00:48:48,000 --> 00:48:51,000
这个确实在目前的技术条件下

1229
00:48:51,000 --> 00:48:52,000
好像没有特别好解决的方案

1230
00:48:52,000 --> 00:48:53,000
对

1231
00:48:53,000 --> 00:48:56,000
然后刚才之前我们也提到了网络这一块

1232
00:48:56,000 --> 00:48:57,000
因为也涉及到 Io

1233
00:48:57,000 --> 00:48:59,000
也是一个比较尴尬的状态

1234
00:49:00,000 --> 00:49:02,000
其实都说的是在

1235
00:49:02,000 --> 00:49:04,000
刚才我们大概假设的一个场景

1236
00:49:04,000 --> 00:49:07,000
都是说在一个 Linux 的 host OS 上跑

1237
00:49:08,000 --> 00:49:09,000
一个应用的场景

1238
00:49:09,000 --> 00:49:11,000
但是我现在就问一下

1239
00:49:11,000 --> 00:49:12,000
如果在开发者

1240
00:49:12,000 --> 00:49:13,000
在想

1241
00:49:13,000 --> 00:49:15,000
假如听众朋友们对 Hyper 比较感兴趣

1242
00:49:15,000 --> 00:49:16,000
他想去试一下

1243
00:49:16,000 --> 00:49:19,000
他在哪些其他系统上可以

1244
00:49:19,000 --> 00:49:21,000
去玩 Hyper 呢

1245
00:49:21,000 --> 00:49:22,000
因为我们是像 Docker

1246
00:49:22,000 --> 00:49:25,000
他可以通过一些讯息的方式

1247
00:49:25,000 --> 00:49:27,000
在小 OS 10 上也可以跑

1248
00:49:27,000 --> 00:49:28,000
Hyper 呢

1249
00:49:28,000 --> 00:49:29,000
Hyper

1250
00:49:30,000 --> 00:49:32,000
当然也支持 Mac OS

1251
00:49:32,000 --> 00:49:34,000
然后这个东西

1252
00:49:36,000 --> 00:49:38,000
Hyper 对于 Mac OS 的支持

1253
00:49:38,000 --> 00:49:40,000
大概是在这个月

1254
00:49:40,000 --> 00:49:43,000
应该是这个月初完成的

1255
00:49:43,000 --> 00:49:45,000
然后我们也在不断的去完善

1256
00:49:45,000 --> 00:49:47,000
然后目前的

1257
00:49:48,000 --> 00:49:51,000
在 Mac OS 上面

1258
00:49:51,000 --> 00:49:55,000
的 Hyper 只能用 Waterbox

1259
00:49:55,000 --> 00:49:57,000
一种 Hypervisor

1260
00:49:57,000 --> 00:50:00,000
然后如果你要是在 Linux 上面

1261
00:50:00,000 --> 00:50:04,000
那你可以用 QMilKVM

1262
00:50:04,000 --> 00:50:06,000
Zen 以及 Waterbox 都可以用

1263
00:50:07,000 --> 00:50:11,000
但是因为 Mac OS 上面

1264
00:50:11,000 --> 00:50:14,000
没有说 QMilKVM

1265
00:50:14,000 --> 00:50:17,000
或者说 Zen 的这些虚拟化工具

1266
00:50:17,000 --> 00:50:20,000
所以就没有特别好的办法

1267
00:50:20,000 --> 00:50:21,000
OK

1268
00:50:21,000 --> 00:50:23,000
因为 Waterbox 的

1269
00:50:23,000 --> 00:50:26,000
其实从它的稳定可靠性

1270
00:50:26,000 --> 00:50:28,000
还有它的性能来讲

1271
00:50:28,000 --> 00:50:30,000
就不算特别好

1272
00:50:30,000 --> 00:50:31,000
特别是在

1273
00:50:33,000 --> 00:50:34,000
OS 10 上面

1274
00:50:34,000 --> 00:50:36,000
然后经常会遇到什么

1275
00:50:36,000 --> 00:50:38,000
用开着它然后就死机的一个情况

1276
00:50:38,000 --> 00:50:39,000
也是有发生

1277
00:50:39,000 --> 00:50:39,000
对

1278
00:50:41,000 --> 00:50:44,000
其实最近我们知道好像是从

1279
00:50:44,000 --> 00:50:48,000
OS 10 是 10.9 还是 10.10 开始

1280
00:50:48,000 --> 00:50:49,000
它有一个

1281
00:50:49,000 --> 00:50:51,000
苹果开发了一套

1282
00:50:51,000 --> 00:50:52,000
这个 Firmware

1283
00:50:52,000 --> 00:50:54,000
叫做 Hypervisor.Firmware

1284
00:50:54,000 --> 00:50:55,000
对

1285
00:50:55,000 --> 00:50:57,000
这套其实它可以在

1286
00:50:57,000 --> 00:51:01,000
OS 10 上实现类似于 KVM 的功能

1287
00:51:01,000 --> 00:51:03,000
所以我不知道你们后续有什么计划

1288
00:51:03,000 --> 00:51:04,000
会用到它吗

1289
00:51:04,000 --> 00:51:07,000
其实我们也在非常关注这个点

1290
00:51:07,000 --> 00:51:09,000
然后目前有一个开源的工具

1291
00:51:09,000 --> 00:51:11,000
就是 AXI

1292
00:51:11,000 --> 00:51:12,000
就是对

1293
00:51:12,000 --> 00:51:15,000
你应该也关注过这个非常

1294
00:51:15,000 --> 00:51:17,000
就是之前在 Hypernews 上面发出来过

1295
00:51:17,000 --> 00:51:18,000
非常火

1296
00:51:18,000 --> 00:51:20,000
然后关注度也非常高

1297
00:51:22,000 --> 00:51:23,000
就它那个的历史

1298
00:51:23,000 --> 00:51:26,000
还是要追踪到 Solaris 上面去对吧

1299
00:51:26,000 --> 00:51:27,000
因为它的前身是一个

1300
00:51:27,000 --> 00:51:28,000
它是基于

1301
00:51:28,000 --> 00:51:29,000
它是一个 Behave 的 port

1302
00:51:29,000 --> 00:51:30,000
对

1303
00:51:30,000 --> 00:51:30,000
然后

1304
00:51:30,000 --> 00:51:32,000
Behave 是在 Solaris 还是在 BSD 上面

1305
00:51:32,000 --> 00:51:33,000
FreeBSD

1306
00:51:34,000 --> 00:51:34,000
FreeBSD

1307
00:51:34,000 --> 00:51:35,000
对

1308
00:51:35,000 --> 00:51:37,000
所以 Solaris 上面应该是没有的

1309
00:51:38,000 --> 00:51:38,000
OK

1310
00:51:39,000 --> 00:51:41,000
所以目前来说

1311
00:51:41,000 --> 00:51:42,000
我们还是跟

1312
00:51:42,000 --> 00:51:45,000
像 Docker 的方案一样

1313
00:51:45,000 --> 00:51:48,000
在 OS 10 上测试开发的时候

1314
00:51:48,000 --> 00:51:51,000
是通过 Virtualbox 这个虚拟机

1315
00:51:51,000 --> 00:51:53,000
来里面直接再跑一些

1316
00:51:53,000 --> 00:51:55,000
是跑到这个是 Hyper 的虚拟机了对吧

1317
00:51:55,000 --> 00:51:58,000
这个就是我们的一个

1318
00:51:58,000 --> 00:52:01,000
费了好多好多心思去做的这个东西

1319
00:52:01,000 --> 00:52:01,000
就是我们

1320
00:52:01,000 --> 00:52:04,000
Hyper 在 Mac 上面的运行

1321
00:52:04,000 --> 00:52:08,000
和 Boot 2 Docker 的运行是不太一样的

1322
00:52:08,000 --> 00:52:09,000
Boot 2 Docker

1323
00:52:09,000 --> 00:52:12,000
它其实就是一个 Docker 的可按端

1324
00:52:12,000 --> 00:52:17,000
然后它把它的 Demon 设成了 VM 的

1325
00:52:17,000 --> 00:52:20,000
Waterbox 的地址

1326
00:52:20,000 --> 00:52:24,000
然后这个在 Waterbox 里面去运行 DockerDemon

1327
00:52:24,000 --> 00:52:26,000
然后它其实相当于通过网络

1328
00:52:26,000 --> 00:52:30,000
然后将这个数据全部显示给 Docker 可按的

1329
00:52:30,000 --> 00:52:33,000
用户以为它这是本地运行的

1330
00:52:34,000 --> 00:52:35,000
其实是在所有的东西

1331
00:52:35,000 --> 00:52:37,000
在 Virtualbox 的虚拟机里面运行

1332
00:52:37,000 --> 00:52:38,000
对

1333
00:52:38,000 --> 00:52:39,000
是的

1334
00:52:39,000 --> 00:52:40,000
而对

1335
00:52:40,000 --> 00:52:40,000
OK

1336
00:52:40,000 --> 00:52:41,000
那你们的方案是怎么样的

1337
00:52:41,000 --> 00:52:42,000
我们的方面

1338
00:52:42,000 --> 00:52:45,000
我们的方案其实是跟 Linux

1339
00:52:45,000 --> 00:52:47,000
它的设计机制是完全一致的

1340
00:52:47,000 --> 00:52:49,000
就是相当于我们的 HyperDemon

1341
00:52:49,000 --> 00:52:51,000
是在 MacOS 上面

1342
00:52:51,000 --> 00:52:55,000
然后我们的 Hyper 可按的也在 MacOS 上面

1343
00:52:55,000 --> 00:52:58,000
而运行的 Docker 的 Image

1344
00:52:59,000 --> 00:53:02,000
是在 Waterbox 里面去运行的

1345
00:53:02,000 --> 00:53:05,000
它整个的一个设计思路是完全和

1346
00:53:06,000 --> 00:53:09,000
Linux 上面的 Hyper 设计思路是一致的

1347
00:53:10,000 --> 00:53:12,000
所以其实我理解

1348
00:53:12,000 --> 00:53:14,000
就是说在这种情况下

1349
00:53:14,000 --> 00:53:20,000
比如说我在 OS X 上跑了一个 Hyper 之后

1350
00:53:20,000 --> 00:53:21,000
它的管理层是

1351
00:53:21,000 --> 00:53:24,000
管理层的命令行工具都是在 OS X 的原生的东西

1352
00:53:24,000 --> 00:53:28,000
然后它是控制 Virtualbox Hypervisor

1353
00:53:28,000 --> 00:53:30,000
去里面新建一个虚拟机

1354
00:53:30,000 --> 00:53:33,000
然后虚拟机内核跑的是你们 Hyper 定制的

1355
00:53:33,000 --> 00:53:35,000
轻量级的 Gest OS

1356
00:53:35,000 --> 00:53:37,000
然后里面再跑的一个

1357
00:53:37,000 --> 00:53:40,000
或者是多个 Docker 的 Image 是这样吗

1358
00:53:40,000 --> 00:53:41,000
对 是的

1359
00:53:41,000 --> 00:53:45,000
OK 这个还真的和 Boot 2 Docker 的方式非常不一样

1360
00:53:45,000 --> 00:53:48,000
对 因为 Boot 2 Docker 你创建一个 Content

1361
00:53:49,000 --> 00:53:51,000
它是一个 VM

1362
00:53:52,000 --> 00:53:53,000
然后你创建两个它也是

1363
00:53:53,000 --> 00:53:55,000
创建三个它也是

1364
00:53:55,000 --> 00:53:57,000
它创建的 Content 都是在 VM 里面

1365
00:53:57,000 --> 00:53:59,000
而我们这种方式

1366
00:53:59,000 --> 00:54:00,000
就是你创建一个 Content

1367
00:54:00,000 --> 00:54:03,000
或者说就多一个 VM

1368
00:54:03,000 --> 00:54:05,000
这个可能会受限于

1369
00:54:05,000 --> 00:54:07,000
开发者的一个机器的一个环境配置

1370
00:54:07,000 --> 00:54:08,000
因为你多个 VM

1371
00:54:08,000 --> 00:54:11,000
它毕竟要占 CPU 占 Memory

1372
00:54:11,000 --> 00:54:13,000
这个是一个

1373
00:54:14,000 --> 00:54:16,000
但它做得很好的一个隔离性

1374
00:54:16,000 --> 00:54:17,000
对吧

1375
00:54:17,000 --> 00:54:18,000
OK

1376
00:54:18,000 --> 00:54:22,000
所以这里我要问一个很好玩的问题

1377
00:54:22,000 --> 00:54:25,000
就是说你们为了实现这个

1378
00:54:25,000 --> 00:54:27,000
采了多少 Virtualbox

1379
00:54:28,000 --> 00:54:32,000
这个我想你应该也会知道

1380
00:54:32,000 --> 00:54:34,000
Wordbox 的控制太多太多

1381
00:54:34,000 --> 00:54:39,000
就是它的 API 很难在 Mac 上面

1382
00:54:39,000 --> 00:54:40,000
因为我们是用 Go 开发的

1383
00:54:40,000 --> 00:54:44,000
所以它的 Wordbox 的 API 很难跟 Go 去结合到一起

1384
00:54:44,000 --> 00:54:46,000
所以没办法只能掉命了

1385
00:54:46,000 --> 00:54:48,000
掉命了另外一个问题就是

1386
00:54:48,000 --> 00:54:51,000
没办法监测它的一个输出的结果

1387
00:54:51,000 --> 00:54:56,000
所以就是用一些很无奈的办法

1388
00:54:56,000 --> 00:54:59,000
去直接解它的输出

1389
00:54:59,000 --> 00:55:00,000
这些办法

1390
00:55:00,000 --> 00:55:05,000
另外就是不局限于 Wordbox 的问题

1391
00:55:05,000 --> 00:55:08,000
还有就是 MacOS 的问题

1392
00:55:08,000 --> 00:55:10,000
因为众所周知

1393
00:55:10,000 --> 00:55:15,000
因为 Docker 它用了 Layer 的 FS

1394
00:55:16,000 --> 00:55:19,000
然后它用这个来做 Layer 的 Image

1395
00:55:19,000 --> 00:55:23,000
然后来保证足够的快

1396
00:55:23,000 --> 00:55:26,000
然后不至于说直接的拷贝

1397
00:55:26,000 --> 00:55:29,000
然后造成很大的一个时间

1398
00:55:29,000 --> 00:55:32,000
然后我们在 MacOS 上面

1399
00:55:32,000 --> 00:55:34,000
其实也想了很多办法

1400
00:55:34,000 --> 00:55:39,000
就怎么能够达到 Layer 这种效果

1401
00:55:39,000 --> 00:55:41,000
所以居然让我们找到了

1402
00:55:41,000 --> 00:55:43,000
Wordbox 居然能有这种机制

1403
00:55:43,000 --> 00:55:49,000
Wordbox 其实是可以做 Layer 的 Disk

1404
00:55:49,000 --> 00:55:52,000
就是它是通过 SnapShot 那个机制

1405
00:55:52,000 --> 00:55:54,000
其实它不太一样

1406
00:55:54,000 --> 00:55:57,000
但是也差不多类似实验机制

1407
00:55:57,000 --> 00:56:00,000
它是通过 ParentDisk

1408
00:56:00,000 --> 00:56:01,000
其实就是 SnapShot 我觉得

1409
00:56:03,000 --> 00:56:04,000
然后通过这种方式

1410
00:56:04,000 --> 00:56:07,000
就可以实现用 Layer 的 Disk

1411
00:56:09,000 --> 00:56:10,000
你们是这么做

1412
00:56:10,000 --> 00:56:12,000
好机智这个办法

1413
00:56:13,000 --> 00:56:16,000
出来的实际的执行效率怎么样

1414
00:56:16,000 --> 00:56:19,000
因为除非你部署

1415
00:56:19,000 --> 00:56:20,000
其实大部分开发者

1416
00:56:20,000 --> 00:56:22,000
可能还是在像 OSX

1417
00:56:22,000 --> 00:56:24,000
里面用 VirtualBox 的方式来开发

1418
00:56:24,000 --> 00:56:24,000
对

1419
00:56:24,000 --> 00:56:26,000
然后我们目前这种方式的话

1420
00:56:26,000 --> 00:56:32,000
大概在运行一个 Wordbox 2 的 Docker Image

1421
00:56:32,000 --> 00:56:34,000
就整个下来之后

1422
00:56:34,000 --> 00:56:35,000
你下来之后

1423
00:56:36,000 --> 00:56:39,000
运行大概在两分钟

1424
00:56:40,000 --> 00:56:44,000
就是从 VirtualBox 运行创建到开始起

1425
00:56:44,000 --> 00:56:44,000
对

1426
00:56:44,000 --> 00:56:47,000
你可以直接操作了

1427
00:56:47,000 --> 00:56:48,000
两分钟不到两分钟

1428
00:56:48,000 --> 00:56:49,000
不到两分钟

1429
00:56:49,000 --> 00:56:50,000
对

1430
00:56:50,000 --> 00:56:52,000
1900 多毫秒

1431
00:56:52,000 --> 00:56:53,000
OK

1432
00:56:53,000 --> 00:56:57,000
那这个中间两分钟的主要花在哪里

1433
00:56:57,000 --> 00:56:58,000
主要花在了

1434
00:56:58,000 --> 00:57:04,000
其实一部分是 Wordbox 本身的设备的一个虚拟化

1435
00:57:04,000 --> 00:57:07,000
就是它的硬件的 Device 的一个虚拟化

1436
00:57:07,000 --> 00:57:08,000
因为它

1437
00:57:08,000 --> 00:57:11,000
就叫配置一个 VirtualBox 的虚拟机出来

1438
00:57:11,000 --> 00:57:11,000
对

1439
00:57:11,000 --> 00:57:12,000
这是一部分

1440
00:57:12,000 --> 00:57:13,000
然后另外一部分

1441
00:57:13,000 --> 00:57:15,000
它就是一些硬件的虚拟化

1442
00:57:15,000 --> 00:57:18,000
就是比如我要是创建 SATA 的盘

1443
00:57:19,000 --> 00:57:22,000
我只能创建 SATA 的 Device

1444
00:57:22,000 --> 00:57:28,000
而且 Wordbox 只能是用 SATA 作为 Hotplug 的 Disk

1445
00:57:28,000 --> 00:57:33,000
而用 SATA 作为 Hotplug 的 Disk 的话

1446
00:57:33,000 --> 00:57:36,000
就创建就时间会比较漫长

1447
00:57:36,000 --> 00:57:39,000
就稍微比 SATA 的要

1448
00:57:39,000 --> 00:57:42,000
因为 SATA 它不支持 Hotplug

1449
00:57:42,000 --> 00:57:44,000
所以它的机制可能会简单好多

1450
00:57:44,000 --> 00:57:45,000
对

1451
00:57:45,000 --> 00:57:50,000
所以就损耗在这些方面就比较无奈

1452
00:57:50,000 --> 00:57:52,000
然后另外一个就是

1453
00:57:52,000 --> 00:57:55,000
当然也是有 GasOS 去运行

1454
00:57:55,000 --> 00:57:57,000
但是这个时间没办法

1455
00:57:57,000 --> 00:57:59,000
就我们已经极致的去优化了

1456
00:57:59,000 --> 00:58:02,000
但是相比这个还是会短短一些

1457
00:58:03,000 --> 00:58:04,000
OK

1458
00:58:04,000 --> 00:58:05,000
所以其实

1459
00:58:05,000 --> 00:58:08,000
就是说如果是在 OS X 上开发的话

1460
00:58:08,000 --> 00:58:12,000
用 Hyper 最主要的开销就是在创建那一块

1461
00:58:12,000 --> 00:58:14,000
然后创建好了之后

1462
00:58:14,000 --> 00:58:17,000
的启动某一个 Hyper 的虚拟机

1463
00:58:18,000 --> 00:58:20,000
还是要比在那个市场原生

1464
00:58:20,000 --> 00:58:22,000
就部署的时候效能 0.3 秒

1465
00:58:22,000 --> 00:58:23,000
要慢一些

1466
00:58:23,000 --> 00:58:24,000
对

1467
00:58:24,000 --> 00:58:24,000
是这样吗

1468
00:58:24,000 --> 00:58:29,000
因为它本身的 Waterbox 的机制没办法

1469
00:58:29,000 --> 00:58:31,000
OK

1470
00:58:31,000 --> 00:58:34,000
所以这个真的要可能要逼得你们去研究

1471
00:58:34,000 --> 00:58:36,000
新的 Hypervisor Framework

1472
00:58:36,000 --> 00:58:37,000
去解决这个问题

1473
00:58:37,000 --> 00:58:40,000
我们也在时刻关注这个东西

1474
00:58:40,000 --> 00:58:41,000
因为这个东西

1475
00:58:41,000 --> 00:58:43,000
就最近的观察来看

1476
00:58:43,000 --> 00:58:47,000
就是原作者可能在忙别的

1477
00:58:47,000 --> 00:58:48,000
然后不太开放

1478
00:58:48,000 --> 00:58:51,000
不太上心这件事情

1479
00:58:51,000 --> 00:58:53,000
然后我们也在去关注

1480
00:58:53,000 --> 00:58:57,000
希望能够去做一些贡献

1481
00:58:57,000 --> 00:58:59,000
然后但是

1482
00:58:59,000 --> 00:59:01,000
你是说 XHype 的原作者

1483
00:59:01,000 --> 00:59:03,000
所以现在我们大概就了解了

1484
00:59:03,000 --> 00:59:06,000
Hyper 的一个整个它是什么

1485
00:59:06,000 --> 00:59:08,000
然后它相对于一些

1486
00:59:08,000 --> 00:59:10,000
我们已经熟知的一些工具

1487
00:59:10,000 --> 00:59:13,000
的这么一个技术对比

1488
00:59:13,000 --> 00:59:15,000
它的优劣是在哪里了

1489
00:59:15,000 --> 00:59:17,000
就是说我们其实可能最后还在回到一个

1490
00:59:17,000 --> 00:59:18,000
最关键的问题

1491
00:59:18,000 --> 00:59:22,000
就是说为什么我作为一个网络管理员

1492
00:59:22,000 --> 00:59:25,000
或者是一个公有云的运营者

1493
00:59:25,000 --> 00:59:26,000
我要选择 Hyper

1494
00:59:26,000 --> 00:59:26,000
对

1495
00:59:26,000 --> 00:59:30,000
所以你刚才说一点非常关键的一点

1496
00:59:30,000 --> 00:59:32,000
就是作为公有云的管理者

1497
00:59:32,000 --> 00:59:35,000
当然作为一个相当于说

1498
00:59:35,000 --> 00:59:38,000
我就内部一个运营或者说测试环境

1499
00:59:38,000 --> 00:59:40,000
我用 Docker 一点问题没有

1500
00:59:40,000 --> 00:59:42,000
但是你要是用公有云的话

1501
00:59:42,000 --> 00:59:44,000
你必须要考虑它的安全性问题

1502
00:59:45,000 --> 00:59:49,000
然后所以就是考虑到安全性的问题

1503
00:59:49,000 --> 00:59:55,000
你就必须要考虑 Docker 它是否能

1504
00:59:55,000 --> 00:59:57,000
怎么能够跟 VM 去结合

1505
00:59:57,000 --> 01:00:01,000
能够最大效率的去利用 Baremental 的机制

1506
01:00:01,000 --> 01:00:04,000
所以为什么不去尝试 Hyper

1507
01:00:04,000 --> 01:00:09,000
Hyper 其实就是为你为这种公有云的运营商

1508
01:00:09,000 --> 01:00:11,000
天然去解决这个问题

1509
01:00:11,000 --> 01:00:16,000
你又想提供这种基于 Contender 的一个管理方式

1510
01:00:16,000 --> 01:00:18,000
租户的管理方式

1511
01:00:18,000 --> 01:00:20,000
然后你可以用 Docker image

1512
01:00:20,000 --> 01:00:24,000
然后跟 Docker 的使用完全没有一样

1513
01:00:24,000 --> 01:00:27,000
但是它的安全性会非常好

1514
01:00:27,000 --> 01:00:31,000
那么所以这个就是一个很好的机会

1515
01:00:31,000 --> 01:00:32,000
然后去尝试

1516
01:00:32,000 --> 01:00:32,000
OK

1517
01:00:32,000 --> 01:00:34,000
所以有一个 Hyper

1518
01:00:34,000 --> 01:00:37,000
其实我们就可以达到一个安全的公有的

1519
01:00:37,000 --> 01:00:42,000
其实一个 Cas 就是 Contender as a service

1520
01:00:42,000 --> 01:00:45,000
所以我们目前也在提这个概念

1521
01:00:45,000 --> 01:00:46,000
OK

1522
01:00:46,000 --> 01:00:49,000
所以这里就很自然的过渡到我们的下一个话题了

1523
01:00:49,000 --> 01:00:52,000
就是说你们的主要的客户

1524
01:00:52,000 --> 01:00:53,000
其实并不是说

1525
01:00:53,000 --> 01:00:56,000
当然你说要大家熟悉这套方式 API

1526
01:00:56,000 --> 01:00:57,000
肯定还是要教育用户的

1527
01:00:57,000 --> 01:00:59,000
但是说从你们这个 Customer

1528
01:00:59,000 --> 01:01:01,000
就是谁为你们付钱这件事情来讲

1529
01:01:01,000 --> 01:01:04,000
可能还是一些刚才讲的公有云的管理者

1530
01:01:04,000 --> 01:01:05,000
对

1531
01:01:06,000 --> 01:01:09,000
这就牵涉到一个所谓的商业模式的问题了

1532
01:01:09,000 --> 01:01:11,000
就是你们 Hyper 这个项目

1533
01:01:11,000 --> 01:01:14,000
你们目前打算是怎么去引力呢

1534
01:01:14,000 --> 01:01:18,000
我们目前其实 Hyper 这个项目主要还是

1535
01:01:19,000 --> 01:01:20,000
作为开源项目为主

1536
01:01:20,000 --> 01:01:26,000
这样的话也是希望吸引更多的 Hacker

1537
01:01:26,000 --> 01:01:29,000
或者说一些 contributor 来参与到我们这个项目

1538
01:01:29,000 --> 01:01:32,000
来共同打造一个基于 contender 的一个

1539
01:01:32,000 --> 01:01:35,000
或者是基于泡的一个社区

1540
01:01:36,000 --> 01:01:39,000
然后我们也是希望能够跟一些

1541
01:01:42,000 --> 01:01:46,000
基房或者说一些 ACV 这种的厂商去合作

1542
01:01:46,000 --> 01:01:49,000
希望能够帮助他们去提供更好的解决方案

1543
01:01:49,000 --> 01:01:55,000
也就是目前我们成立大概半年多的时间

1544
01:01:55,000 --> 01:01:58,000
其实像国外一个比较著名的

1545
01:01:58,000 --> 01:01:59,000
一个也是创业公司吧

1546
01:01:59,000 --> 01:02:00,000
叫 PiKIT

1547
01:02:00,000 --> 01:02:04,000
然后它其实就是已经推出基于 Hyper 的一个产品

1548
01:02:05,000 --> 01:02:08,000
对现在已经出了大家也可以去体验

1549
01:02:08,000 --> 01:02:11,000
当然可能要绑个信卡就比较麻烦

1550
01:02:13,000 --> 01:02:18,000
对于我们有足够尝鲜精神的开发者来说

1551
01:02:18,000 --> 01:02:20,000
这不是一个特别大的难题

1552
01:02:20,000 --> 01:02:26,000
当然你可以自己在自己的平台上面去部署

1553
01:02:26,000 --> 01:02:27,000
或者是去体验

1554
01:02:27,000 --> 01:02:28,000
当然也可以

1555
01:02:28,000 --> 01:02:33,000
然后除此之外跟这种厂商去合作之外

1556
01:02:33,000 --> 01:02:37,000
我们自己也在做基于容器的公有运

1557
01:02:37,000 --> 01:02:38,000
就刚才说的 CAS

1558
01:02:39,000 --> 01:02:41,000
对你们自己要运营一个公有运

1559
01:02:41,000 --> 01:02:45,000
对其实我们目前提的一个方式叫 Hyper Stack

1560
01:02:46,000 --> 01:02:47,000
对 Hyper Stack

1561
01:02:47,000 --> 01:02:52,000
就是它其实是构建于 Hyper 的基础上

1562
01:02:52,000 --> 01:02:55,000
然后结合目前非常流行的 Cobranatis

1563
01:02:56,000 --> 01:02:58,000
然后 Open Stack 里边的一些组件

1564
01:02:58,000 --> 01:03:01,000
比如像 Sinder、Nutrient 以及 Keystone

1565
01:03:01,000 --> 01:03:07,000
然后将这几个组件结合到一起

1566
01:03:07,000 --> 01:03:09,000
然后形成一个自己的 Stack

1567
01:03:10,000 --> 01:03:13,000
也是希望能够打造整个生态链

1568
01:03:13,000 --> 01:03:16,000
然后我们已经提了这个 Proposal

1569
01:03:16,000 --> 01:03:20,000
然后目前也在去组织人手去打造

1570
01:03:21,000 --> 01:03:22,000
OK

1571
01:03:22,000 --> 01:03:24,000
这里就涉及到最开始的一个问题

1572
01:03:24,000 --> 01:03:29,000
就是说因为当时我看你们 Hyper.sh 的网站上

1573
01:03:29,000 --> 01:03:31,000
也有就是说因为只有一个英文的介绍

1574
01:03:31,000 --> 01:03:33,000
并没有这个中文的任何介绍

1575
01:03:33,000 --> 01:03:37,000
这跟你们商业模型和客户选择有关系吗

1576
01:03:37,000 --> 01:03:41,000
对我们目前的一个打算

1577
01:03:41,000 --> 01:03:45,000
就是希望能够吸引更多国外的厂商

1578
01:03:45,000 --> 01:03:48,000
然后去跟他们去竞争

1579
01:03:48,000 --> 01:03:51,000
或者说去合作

1580
01:03:51,000 --> 01:03:53,000
然后之前的一个考虑

1581
01:03:53,000 --> 01:03:58,000
就是国内对于开源项目的支持

1582
01:03:58,000 --> 01:04:02,000
或者说合作不是特别大胆

1583
01:04:02,000 --> 01:04:03,000
或者不是特别明显

1584
01:04:03,000 --> 01:04:07,000
所以也考虑到这一些问题

1585
01:04:08,000 --> 01:04:09,000
在前期做一个创业公司

1586
01:04:09,000 --> 01:04:15,000
可能用一种最保险或者说最妥善的办法

1587
01:04:18,000 --> 01:04:18,000
OK

1588
01:04:18,000 --> 01:04:22,000
所以其实就很连累刚才我们一个很尴尬的情况

1589
01:04:22,000 --> 01:04:26,000
就是中国网络技术设施其实并不如美国好

1590
01:04:26,000 --> 01:04:32,000
就是从这个机房云的介绍这一块是比较落后的

1591
01:04:32,000 --> 01:04:35,000
同时在我们能够数得出来的

1592
01:04:35,000 --> 01:04:38,000
国内的一些公共云的运营者也就那么几家

1593
01:04:38,000 --> 01:04:41,000
像什么阿里云腾讯云

1594
01:04:41,000 --> 01:04:43,000
还有什么美团青云

1595
01:04:43,000 --> 01:04:46,000
美团青云以前还有那京东云好像也有

1596
01:04:46,000 --> 01:04:46,000
现在还在吗

1597
01:04:46,000 --> 01:04:48,000
现在好像关闭了

1598
01:04:48,000 --> 01:04:48,000
关掉了

1599
01:04:48,000 --> 01:04:49,000
对对对

1600
01:04:49,000 --> 01:04:55,000
然后他们其实并没有说到了足够大胆尝试这种新技术的时候

1601
01:04:55,000 --> 01:04:56,000
对

1602
01:04:57,000 --> 01:04:57,000
OK

1603
01:04:57,000 --> 01:05:00,000
所以你们选择先去开拓海外市场

1604
01:05:00,000 --> 01:05:05,000
然后等在验证好模式和技术成熟之后

1605
01:05:05,000 --> 01:05:08,000
再想办法能不能够国内的这些云厂商也能够

1606
01:05:08,000 --> 01:05:11,000
或者是出一些新的小的云厂商

1607
01:05:11,000 --> 01:05:13,000
也能够采用 Hyper 技术

1608
01:05:13,000 --> 01:05:14,000
对对对

1609
01:05:14,000 --> 01:05:15,000
没错

1610
01:05:15,000 --> 01:05:18,000
所以你们在海外的目前的一些合作伙伴

1611
01:05:18,000 --> 01:05:19,000
就刚才你提到出了 Packet

1612
01:05:19,000 --> 01:05:23,000
这个也是一个比较新和比较酷的

1613
01:05:23,000 --> 01:05:24,000
一共云的云厂之外

1614
01:05:24,000 --> 01:05:27,000
还有哪些是你们在目前是在有深度合作

1615
01:05:27,000 --> 01:05:31,000
我们现在合作的比较多的像 Zen

1616
01:05:31,000 --> 01:05:32,000
Zen 的 Dewi...

1617
01:05:32,000 --> 01:05:34,000
Mentender 和 Devoper

1618
01:05:34,000 --> 01:05:36,000
我们都有非常多的接触

1619
01:05:36,000 --> 01:05:40,000
然后之前参加了 Zen 的 Devoper Submit

1620
01:05:40,000 --> 01:05:42,000
然后去跟他们去交流

1621
01:05:42,000 --> 01:05:47,000
他们也非常支持 Hyper 对 Zen 的一个支持

1622
01:05:48,000 --> 01:05:51,000
希望能够去共同探讨

1623
01:05:51,000 --> 01:05:56,000
能够把性能或者说体验做到足够的好

1624
01:05:56,000 --> 01:06:01,000
所以 Zen 还是说是我们一个非常重要的一个伴侣

1625
01:06:01,000 --> 01:06:05,000
然后他们对我们在底层技术上的一个

1626
01:06:05,000 --> 01:06:08,000
或者说在 HyperWide 上的支持还是挺多的

1627
01:06:09,000 --> 01:06:10,000
OK

1628
01:06:10,000 --> 01:06:10,000
对

1629
01:06:11,000 --> 01:06:11,000
明白

1630
01:06:11,000 --> 01:06:16,000
所以还是一个非常值得让人激动的一个合作

1631
01:06:16,000 --> 01:06:22,000
因为 Zen 是我们一个非常传统的虚拟器的 Hypervisor

1632
01:06:22,000 --> 01:06:24,000
我记得好像 AWS 就是基于 Zen 做的

1633
01:06:24,000 --> 01:06:25,000
对

1634
01:06:26,000 --> 01:06:29,000
现在是一个也是非常好的技术

1635
01:06:29,000 --> 01:06:33,000
刚刚我们讲完了 Hyper 这个产品

1636
01:06:33,000 --> 01:06:34,000
然后包括你们的商业模式

1637
01:06:34,000 --> 01:06:35,000
其实现在我们聊到最

1638
01:06:35,000 --> 01:06:40,000
其实我个人来说最关心的一个领域就是团队

1639
01:06:40,000 --> 01:06:42,000
Sammon 你可以大概介绍一下

1640
01:06:42,000 --> 01:06:44,000
你们现在做 Hyper 这个 Team 大概什么样的情况

1641
01:06:45,000 --> 01:06:48,000
我们现在的开发者是 5 个人

1642
01:06:48,000 --> 01:06:49,000
然后 5 个人

1643
01:06:49,000 --> 01:06:49,000
5 个人

1644
01:06:49,000 --> 01:06:50,000
这么小

1645
01:06:51,000 --> 01:06:53,000
所以就是每天还是挺忙碌的

1646
01:06:54,000 --> 01:06:54,000
OK

1647
01:06:54,000 --> 01:06:58,000
然后一个人主要负责 HyperStack 相关的东西

1648
01:06:58,000 --> 01:07:02,000
然后另外就是主要集中在 Hyper 的核心产品

1649
01:07:02,000 --> 01:07:07,000
然后组过就是新的 Feature 的开发以及 Fix 一些 Bug

1650
01:07:08,000 --> 01:07:13,000
然后因为毕竟开源代码也是希望能够让代码质量足够的优质

1651
01:07:15,000 --> 01:07:15,000
对

1652
01:07:15,000 --> 01:07:20,000
然后另外有三个人主要是负责 BD 相关的东西

1653
01:07:20,000 --> 01:07:22,000
然后做一些

1654
01:07:22,000 --> 01:07:24,000
因为毕竟还是海外市场

1655
01:07:24,000 --> 01:07:27,000
所以我们有一些国外的朋友

1656
01:07:27,000 --> 01:07:30,000
然后去帮忙推或者支持这些东西

1657
01:07:31,000 --> 01:07:34,000
所以整个团队其实加起来也不超过 10 个人

1658
01:07:34,000 --> 01:07:37,000
应该挺非常小

1659
01:07:37,000 --> 01:07:38,000
然后精悍的一个团队

1660
01:07:38,000 --> 01:07:43,000
但是我们的团队还是战斗力还是挺强的

1661
01:07:43,000 --> 01:07:43,000
对

1662
01:07:44,000 --> 01:07:44,000
OK

1663
01:07:44,000 --> 01:07:48,000
所以当初你是怎么加入到这个团队里面去的

1664
01:07:48,000 --> 01:07:52,000
因为当时其实还是刀块还是挺火的

1665
01:07:52,000 --> 01:07:55,000
我也对虚拟化

1666
01:07:55,000 --> 01:07:57,000
因为我毕竟之前是做存储的

1667
01:07:57,000 --> 01:08:00,000
但是我对虚拟化的这一块还是比较感兴趣

1668
01:08:00,000 --> 01:08:04,000
所以希望能够进入到这个领域

1669
01:08:04,000 --> 01:08:09,000
然后看到网上有一个招聘

1670
01:08:09,000 --> 01:08:10,000
然后大概

1671
01:08:10,000 --> 01:08:14,000
可能想做一个基于虚拟化

1672
01:08:14,000 --> 01:08:17,000
或者基于一个容器的 OS

1673
01:08:17,000 --> 01:08:20,000
然后也想深入的去了解一下

1674
01:08:20,000 --> 01:08:22,000
大概就认识了

1675
01:08:22,000 --> 01:08:23,000
然后就聊聊聊

1676
01:08:23,000 --> 01:08:28,000
当然随着社区的变化

1677
01:08:28,000 --> 01:08:30,000
或者说现在的变化

1678
01:08:30,000 --> 01:08:32,000
可能当时的想法慢慢在调整

1679
01:08:32,000 --> 01:08:36,000
然后也做出现在的产品

1680
01:08:36,000 --> 01:08:36,000
对

1681
01:08:37,000 --> 01:08:40,000
所以你是在哪里看到他们的招聘广告

1682
01:08:40,000 --> 01:08:42,000
是在 V 2 EX

1683
01:08:45,000 --> 01:08:48,000
V 2 EX 跟我们节目的关系还是挺密切的

1684
01:08:48,000 --> 01:08:52,000
因为我们每期节目都会上面发我们的节目介绍和连接

1685
01:08:52,000 --> 01:08:56,000
然后 V 2 EX 的 Livet 也非常很 nice 的

1686
01:08:56,000 --> 01:09:02,000
免费在 podcast 分类里面加了一个测量的广告

1687
01:09:02,000 --> 01:09:04,000
也非常感谢他们

1688
01:09:04,000 --> 01:09:05,000
对

1689
01:09:05,000 --> 01:09:09,000
因为这个也是国内一个比较好的程序员

1690
01:09:09,000 --> 01:09:10,000
然后开发者的一个社区

1691
01:09:10,000 --> 01:09:13,000
其实你在上面能找到他们

1692
01:09:13,000 --> 01:09:15,000
也是其实也是意料之内

1693
01:09:15,000 --> 01:09:19,000
然后其实之前就一直在关注

1694
01:09:19,000 --> 01:09:22,000
没想到就在那去节远了

1695
01:09:24,000 --> 01:09:25,000
这个还是挺机缘巧合的事

1696
01:09:25,000 --> 01:09:26,000
对

1697
01:09:26,000 --> 01:09:28,000
大家是多混这个社区会比较好

1698
01:09:28,000 --> 01:09:29,000
对

1699
01:09:29,000 --> 01:09:30,000
其实这圈子还是挺小的

1700
01:09:30,000 --> 01:09:31,000
OK

1701
01:09:31,000 --> 01:09:34,000
所以你们现在这么一个小 5 个人的开发团队

1702
01:09:34,000 --> 01:09:37,000
你们工作模式大概是怎么样子的

1703
01:09:37,000 --> 01:09:43,000
我们现在的工作模式大概就是相当于我们 5 个开发

1704
01:09:43,000 --> 01:09:48,000
5 个 developer 然后分布在南京上海北京

1705
01:09:48,000 --> 01:09:52,000
然后其实是一个相当于 remote work 的一个工作方式

1706
01:09:52,000 --> 01:09:58,000
大家平常沟通就是 Taggram 以及 Trainload 的一个方式

1707
01:09:59,000 --> 01:10:02,000
所以其实你们 5 个人并不是在一个地方的

1708
01:10:02,000 --> 01:10:03,000
对

1709
01:10:03,000 --> 01:10:03,000
不是在一个地方

1710
01:10:03,000 --> 01:10:04,000
然后你们都是在

1711
01:10:04,000 --> 01:10:06,000
那你们会在家里工作吗

1712
01:10:06,000 --> 01:10:07,000
还是去到哪里办公

1713
01:10:08,000 --> 01:10:09,000
主要还是在家里办公

1714
01:10:09,000 --> 01:10:14,000
然后这样的话节省一些交通上的时间的成本

1715
01:10:14,000 --> 01:10:15,000
对

1716
01:10:15,000 --> 01:10:16,000
这个好爽的

1717
01:10:16,000 --> 01:10:19,000
因为其实我知道每个人可能最高效的时段是不一样的

1718
01:10:19,000 --> 01:10:22,000
然后浪费在交通上真的是一个非常让人不爽的事情

1719
01:10:23,000 --> 01:10:23,000
对

1720
01:10:23,000 --> 01:10:27,000
尤其像我在北京这种城市这么大

1721
01:10:27,000 --> 01:10:32,000
然后人挤人的这种真是有点难受

1722
01:10:32,000 --> 01:10:36,000
所有的写代码的灵感和激情都磨灭在了公交车上

1723
01:10:37,000 --> 01:10:37,000
对

1724
01:10:37,000 --> 01:10:42,000
所以当然远程办公其实是

1725
01:10:42,000 --> 01:10:44,000
当然也是比较吸引我的一种方式

1726
01:10:44,000 --> 01:10:48,000
大家希望能够更高效的去利用时间

1727
01:10:48,000 --> 01:10:49,000
OK

1728
01:10:49,000 --> 01:10:52,000
所以你们 5 个人在远程工作中

1729
01:10:52,000 --> 01:10:55,000
你刚才提到了有 Telegram 用来实施

1730
01:10:55,000 --> 01:10:56,000
这个是群组聊天对吧

1731
01:10:57,000 --> 01:10:57,000
对

1732
01:10:57,000 --> 01:11:00,000
然后还有一样那个是用什么工具来的

1733
01:11:01,000 --> 01:11:01,000
Tri-Lo

1734
01:11:03,000 --> 01:11:04,000
Tri-Lo 做协作

1735
01:11:05,000 --> 01:11:06,000
对协作

1736
01:11:06,000 --> 01:11:06,000
对

1737
01:11:06,000 --> 01:11:08,000
所以你们像代码管理

1738
01:11:08,000 --> 01:11:10,000
还有其他一些工具大概是会用到哪些

1739
01:11:11,000 --> 01:11:13,000
代码管理的话就是 GitHub

1740
01:11:13,000 --> 01:11:13,000
OK

1741
01:11:14,000 --> 01:11:14,000
对

1742
01:11:14,000 --> 01:11:18,000
然后我们之前是发布之前是 Private

1743
01:11:18,000 --> 01:11:18,000
Riple

1744
01:11:18,000 --> 01:11:20,000
然后现在是公开

1745
01:11:20,000 --> 01:11:23,000
大家也可以去我们的官网上

1746
01:11:23,000 --> 01:11:26,000
以及去 GitHub 的网页上去关注我们的项目

1747
01:11:26,000 --> 01:11:27,000
多多点赞

1748
01:11:27,000 --> 01:11:28,000
OK

1749
01:11:28,000 --> 01:11:28,000
OK

1750
01:11:28,000 --> 01:11:31,000
那个项目的地址还包括 GitHub 的地址

1751
01:11:31,000 --> 01:11:33,000
我们会稍后放到这个群组词里面

1752
01:11:33,000 --> 01:11:34,000
大家就可以看

1753
01:11:34,000 --> 01:11:34,000
好

1754
01:11:34,000 --> 01:11:36,000
这里其实可以接着聊一下

1755
01:11:36,000 --> 01:11:40,000
你们在 GitHub 上面协作的模式

1756
01:11:40,000 --> 01:11:41,000
你们是一个

1757
01:11:41,000 --> 01:11:43,000
会是一个大概是一种什么样的过程

1758
01:11:43,000 --> 01:11:44,000
可以大概描述一下吗

1759
01:11:47,000 --> 01:11:50,000
目前的过程相当于已经过往之前的

1760
01:11:50,000 --> 01:11:51,000
蜂蜜开发的一个过程

1761
01:11:51,000 --> 01:11:55,000
所以现在的进派式的模式

1762
01:11:55,000 --> 01:11:59,000
还是跟比较正规

1763
01:11:59,000 --> 01:12:02,000
然后有个派式的话是 TPR

1764
01:12:02,000 --> 01:12:06,000
然后一到两个人去旅游

1765
01:12:06,000 --> 01:12:09,000
如果没问题的话才可以莫置

1766
01:12:09,000 --> 01:12:13,000
这样的话就保证了质量以及效率

1767
01:12:13,000 --> 01:12:16,000
然后会有一些第三方的工具

1768
01:12:17,000 --> 01:12:20,000
就是我们会写了一些脚本

1769
01:12:20,000 --> 01:12:23,000
当然也在不断的完善过程中

1770
01:12:23,000 --> 01:12:27,000
希望能够在有 PR 的时候

1771
01:12:27,000 --> 01:12:30,000
触发一些自动化的检测等等一些工具

1772
01:12:30,000 --> 01:12:31,000
OK

1773
01:12:31,000 --> 01:12:32,000
所以就大致来说

1774
01:12:32,000 --> 01:12:34,000
还是一个标准的一个

1775
01:12:34,000 --> 01:12:36,000
GitHub 开面项目的流程

1776
01:12:36,000 --> 01:12:39,000
通过 PR 驱动这个 feature

1777
01:12:39,000 --> 01:12:40,000
还有 bug fix

1778
01:12:40,000 --> 01:12:45,000
然后进行经典的 code review

1779
01:12:45,000 --> 01:12:46,000
然后这样 merge 这样

1780
01:12:46,000 --> 01:12:47,000
QA 这块

1781
01:12:47,000 --> 01:12:50,000
你说你们是还没有做完全自动化的 QA 是吧

1782
01:12:50,000 --> 01:12:51,000
对

1783
01:12:51,000 --> 01:12:53,000
还没有做完全自动化的 QA

1784
01:12:53,000 --> 01:12:57,000
但是手动化的测试都会做标配

1785
01:12:57,000 --> 01:13:00,000
然后因为 Go 本身做了一些

1786
01:13:00,000 --> 01:13:01,000
它有 unitize

1787
01:13:01,000 --> 01:13:02,000
所以这个的话

1788
01:13:02,000 --> 01:13:04,000
因为当时开发时间比较紧

1789
01:13:04,000 --> 01:13:08,000
然后我们这个有的一些 component

1790
01:13:08,000 --> 01:13:09,000
可能没有太完善

1791
01:13:09,000 --> 01:13:11,000
所以这个也在不断完善

1792
01:13:12,000 --> 01:13:13,000
就这个可能需要

1793
01:13:13,000 --> 01:13:15,000
就你们一个一方面你们自己努力

1794
01:13:15,000 --> 01:13:17,000
另外一方面就是看能不能开展社区

1795
01:13:17,000 --> 01:13:18,000
能贡献一些

1796
01:13:18,000 --> 01:13:19,000
对

1797
01:13:19,000 --> 01:13:21,000
因为我们的人手实在是太少

1798
01:13:23,000 --> 01:13:24,000
有意思

1799
01:13:24,000 --> 01:13:25,000
这里刚才你也提到了

1800
01:13:25,000 --> 01:13:27,000
这个 hyper 跟 docker 一样

1801
01:13:27,000 --> 01:13:29,000
都是基于用购语言开发的

1802
01:13:30,000 --> 01:13:32,000
当初你们为什么选择用购语言

1803
01:13:32,000 --> 01:13:34,000
我们之前选择的购语言

1804
01:13:34,000 --> 01:13:41,000
其实也是考虑到了跟 docker 的一个关系

1805
01:13:41,000 --> 01:13:45,000
因为就抛开购语言本身的一些特性

1806
01:13:45,000 --> 01:13:46,000
比如并发

1807
01:13:46,000 --> 01:13:49,000
它的高效的开发等等一些特性

1808
01:13:49,000 --> 01:13:51,000
另外一方面就是

1809
01:13:51,000 --> 01:13:53,000
我们其实最开始的版本

1810
01:13:53,000 --> 01:13:55,000
是基于 dockerdemon 来做的

1811
01:13:55,000 --> 01:13:59,000
然后因为 dockerdemon 会

1812
01:13:59,000 --> 01:14:05,000
我们用到 dockerdemon 去铺它的 dockerimage

1813
01:14:05,000 --> 01:14:07,000
来铺下来

1814
01:14:07,000 --> 01:14:12,000
然后去把这个文件全部传给 hypervisor

1815
01:14:12,000 --> 01:14:13,000
然后这个过程中

1816
01:14:13,000 --> 01:14:16,000
可能用购语言直接跟 dockerdemon 去交互

1817
01:14:16,000 --> 01:14:19,000
这样的话是更省事更简单

1818
01:14:19,000 --> 01:14:20,000
哦 这样

1819
01:14:20,000 --> 01:14:21,000
对

1820
01:14:21,000 --> 01:14:26,000
但是随着后来我们移除了 dockerdemon 的一个依赖

1821
01:14:26,000 --> 01:14:29,000
其实用其他语言当然也可以

1822
01:14:29,000 --> 01:14:32,000
可能也历史原因问题

1823
01:14:32,000 --> 01:14:35,000
就是我们继续沿用了这个购语言

1824
01:14:35,000 --> 01:14:35,000
OK

1825
01:14:35,000 --> 01:14:40,000
所以其实你们在使用购语语语言写 hyper 过程中

1826
01:14:40,000 --> 01:14:41,000
你们遇到了什么样的问题

1827
01:14:41,000 --> 01:14:43,000
或者什么心得可以分享吗

1828
01:14:44,000 --> 01:14:46,000
其实购语言还是

1829
01:14:46,000 --> 01:14:48,000
从语法上还是有些坑的

1830
01:14:48,000 --> 01:14:50,000
比如说呢

1831
01:14:50,000 --> 01:14:53,000
比如说写购语写时间长

1832
01:14:53,000 --> 01:14:55,000
写 C 都不加分号

1833
01:14:55,000 --> 01:14:57,000
哈哈哈哈

1834
01:14:57,000 --> 01:14:58,000
这个是好事

1835
01:14:59,000 --> 01:15:01,000
好吧

1836
01:15:01,000 --> 01:15:05,000
然后另外一些可能就是本身购语言

1837
01:15:05,000 --> 01:15:08,000
因为它最近刚发布的是 1.6

1838
01:15:08,000 --> 01:15:10,000
还是之前是 1.5

1839
01:15:10,000 --> 01:15:11,000
应该是

1840
01:15:11,000 --> 01:15:12,000
对 1.5

1841
01:15:12,000 --> 01:15:13,000
然后 1.5 的一个版本

1842
01:15:13,000 --> 01:15:17,000
它其实有一些东西还是做得不够完善的

1843
01:15:17,000 --> 01:15:21,000
然后我们其实过程中也是采购不少坑

1844
01:15:21,000 --> 01:15:23,000
然后用其他方式去转换

1845
01:15:23,000 --> 01:15:26,000
但是可能效益上面不如有优势

1846
01:15:26,000 --> 01:15:28,000
但是这个可能就是 OS 相关的东西

1847
01:15:28,000 --> 01:15:31,000
比如在 MAC 上面的一些特性

1848
01:15:31,000 --> 01:15:33,000
它购语言是调用内核的一些东西还是

1849
01:15:34,000 --> 01:15:36,000
Syscall 的东西

1850
01:15:36,000 --> 01:15:37,000
OK

1851
01:15:37,000 --> 01:15:39,000
支持的不够完整

1852
01:15:39,000 --> 01:15:39,000
OK

1853
01:15:39,000 --> 01:15:45,000
然后所以就必须用其他一种更加 tricky 的方式去做

1854
01:15:45,000 --> 01:15:46,000
明白

1855
01:15:47,000 --> 01:15:47,000
对

1856
01:15:47,000 --> 01:15:51,000
所以其实像 Hyper 除了用购语言写大部分之外

1857
01:15:51,000 --> 01:15:53,000
你们还用到其他语言去编写

1858
01:15:53,000 --> 01:15:55,000
其他一些小部分的功能吗

1859
01:15:55,000 --> 01:15:57,000
还是说是一个纯购的一个项目

1860
01:15:57,000 --> 01:16:01,000
我们在 Gauss OS 里面是 CC 的东西

1861
01:16:02,000 --> 01:16:07,000
那部分是需要做的哪些工作是必须要用 C 来完成的

1862
01:16:08,000 --> 01:16:10,000
其实也不是说必须要用 C 来完成

1863
01:16:10,000 --> 01:16:12,000
只不过用 C 可能效益更快一点

1864
01:16:12,000 --> 01:16:13,000
Gauss OS 里面

1865
01:16:13,000 --> 01:16:14,000
它其实就是一个

1866
01:16:15,000 --> 01:16:21,000
相当于修改过的 init 程序

1867
01:16:21,000 --> 01:16:25,000
然后它是可以解析 Jason 格式

1868
01:16:25,000 --> 01:16:32,000
因为它这样的话是通过 Jason 的信息来跟 HyperDemon 去交互

1869
01:16:32,000 --> 01:16:37,000
这样达到一个传输数据或者是通信的效果

1870
01:16:37,000 --> 01:16:38,000
这个有点意思

1871
01:16:38,000 --> 01:16:40,000
就像你们 Gauss 的 OS 里面

1872
01:16:40,000 --> 01:16:42,000
还有一个自己定义的 init 程序

1873
01:16:42,000 --> 01:16:47,000
这个好像现在好像比较常见的是 SystemD 对吧

1874
01:16:47,000 --> 01:16:48,000
会比较重吗

1875
01:16:48,000 --> 01:16:49,000
还是什么原因

1876
01:16:50,000 --> 01:16:51,000
对可能速度比较快

1877
01:16:51,000 --> 01:16:55,000
速度比较重

1878
01:16:55,000 --> 01:16:58,000
然后我们这儿用启动速度会很慢

1879
01:16:58,000 --> 01:17:03,000
然后我们当时测的时候大概十几兆

1880
01:17:03,000 --> 01:17:08,000
或应该是二十几兆的 memory 就够了

1881
01:17:08,000 --> 01:17:09,000
OK

1882
01:17:09,000 --> 01:17:11,000
对所以就足够的精简

1883
01:17:11,000 --> 01:17:12,000
足够的小

1884
01:17:12,000 --> 01:17:16,000
现在一个 HyperD 的 GaussVM 用你们自定义这套东西

1885
01:17:16,000 --> 01:17:18,000
一二十兆就可以起一个了对吧

1886
01:17:18,000 --> 01:17:19,000
对应该是二十多兆

1887
01:17:19,000 --> 01:17:21,000
二十多兆十一点是不够的

1888
01:17:21,000 --> 01:17:23,000
相对于很多特别是他跑

1889
01:17:23,000 --> 01:17:27,000
他们 Tomcat 这些家伙一上来就一两个鸡的那层

1890
01:17:27,000 --> 01:17:27,000
对

1891
01:17:27,000 --> 01:17:30,000
当然我们说它是一个最简模式

1892
01:17:30,000 --> 01:17:31,000
但是如果

1893
01:17:31,000 --> 01:17:32,000
这是一个

1894
01:17:32,000 --> 01:17:37,000
我就说这种一二十兆的开销基本上可以在现代机上可以忽略了

1895
01:17:37,000 --> 01:17:38,000
对

1896
01:17:38,000 --> 01:17:39,000
还是挺好的

1897
01:17:40,000 --> 01:17:45,000
最后补充的就是希望大家有志于加入我们 hyper 项目的

1898
01:17:45,000 --> 01:17:48,000
能够多多为我们提 PR

1899
01:17:48,000 --> 01:17:51,000
我们也会非常积极的反馈

1900
01:17:51,000 --> 01:17:55,000
如果有同学提 PR 或者说被我们接受的话

1901
01:17:55,000 --> 01:18:01,000
我们在初期前 100 人应该会提供 T 恤作为奖励

1902
01:18:01,000 --> 01:18:06,000
就是之前 Rio 之前在推特上面穿过的 T 恤

1903
01:18:06,000 --> 01:18:09,000
对

1904
01:18:09,000 --> 01:18:14,000
之前我在北京跟 Simon 见面面聊过

1905
01:18:14,000 --> 01:18:16,000
然后非常厚颜无耻的要了一件

1906
01:18:16,000 --> 01:18:18,000
没没没

1907
01:18:18,000 --> 01:18:22,000
这个也是感谢 Rio 帮我们去大力的宣传

1908
01:18:22,000 --> 01:18:26,000
然后也是希望能更多的开发者去接触到开源社区

1909
01:18:26,000 --> 01:18:27,000
接触到开源项目

1910
01:18:27,000 --> 01:18:29,000
然后更多

1911
01:18:29,000 --> 01:18:31,000
更

1912
01:18:31,000 --> 01:18:31,000
就是怎么说

1913
01:18:31,000 --> 01:18:37,000
提升一个自身素质加一个写代码功力的一个水平

1914
01:18:37,000 --> 01:18:39,000
对非常感谢

1915
01:18:39,000 --> 01:18:43,000
其实因为这次我邀请 Simon 来做这些节目

1916
01:18:43,000 --> 01:18:45,000
也是因为我觉得 hyper 是我见过的

1917
01:18:45,000 --> 01:18:48,000
国人做的开源项目里面

1918
01:18:48,000 --> 01:18:50,000
还比较让我惊艳的一个

1919
01:18:50,000 --> 01:18:52,000
所以我也希望借这个机会

1920
01:18:52,000 --> 01:18:53,000
让邀请到

1921
01:18:53,000 --> 01:18:55,000
让更多人了解他

1922
01:18:55,000 --> 01:18:55,000
知道他

1923
01:18:55,000 --> 01:18:58,000
然后能够去参与到这开发

1924
01:18:58,000 --> 01:19:05,000
让我们中国的开发项目能够有一个好的上涨的趋势

1925
01:19:05,000 --> 01:19:06,000
对

1926
01:19:06,000 --> 01:19:07,000
然后另外一点

1927
01:19:07,000 --> 01:19:11,000
如果大家不觉得 TPR 不爽的话

1928
01:19:11,000 --> 01:19:14,000
也是非常希望大家能够加入到我们的团队

1929
01:19:14,000 --> 01:19:18,000
我们团队也是拥有非常多的牛人

1930
01:19:18,000 --> 01:19:21,000
然后多年的 kernel 的工程师

1931
01:19:21,000 --> 01:19:27,000
以及特别自身的 consultant 都在我们团队

1932
01:19:27,000 --> 01:19:30,000
所以如果大家有一技之长

1933
01:19:30,000 --> 01:19:34,000
或者说有志于做 hyperstrike

1934
01:19:34,000 --> 01:19:35,000
hyper 项目的

1935
01:19:35,000 --> 01:19:41,000
希望大家能够积极给我们提 TPR 或者是发奖励

1936
01:19:41,000 --> 01:19:41,000
谢谢

1937
01:19:41,000 --> 01:19:44,000
想不到毕节目还做了一个猎头的工作

1938
01:19:46,000 --> 01:19:48,000
非常好玩

1939
01:19:48,000 --> 01:19:49,000
OK

1940
01:19:49,000 --> 01:19:51,000
今天的节目就先到这里

1941
01:19:51,000 --> 01:19:56,000
感谢收听 IPN Podcast 网络之下的 IT 主题娱乐节目内核恐慌

1942
01:19:56,000 --> 01:19:59,000
我们号称 hardcore 但也没有干货

1943
01:19:59,000 --> 01:20:01,000
但是这期干货还是满满的

1944
01:20:01,000 --> 01:20:03,000
想听的人听不想听的人就别听

1945
01:20:03,000 --> 01:20:05,000
你可以问本节目捐款

1946
01:20:05,000 --> 01:20:07,000
捐款地址是 ipn.li

1947
01:20:07,000 --> 01:20:08,000
slash kernelpanic

1948
01:20:08,000 --> 01:20:09,000
slash donate

1949
01:20:09,000 --> 01:20:11,000
捐款金额随意

1950
01:20:11,000 --> 01:20:13,000
只要是能备 8 整出的正整数就可以

1951
01:20:13,000 --> 01:20:15,000
捐款不会给你带来什么

1952
01:20:15,000 --> 01:20:17,000
不捐也不会让你失去什么

1953
01:20:17,000 --> 01:20:20,000
我们的口号是 hyper is hyper awesome

1954
01:20:20,000 --> 01:20:21,000
如果你有任何反馈

1955
01:20:21,000 --> 01:20:26,000
可以发电子邮件到 kernelpanicatipn.li

1956
01:20:26,000 --> 01:20:29,000
同时也欢迎你收听 IPN 旗下其他几档节目

1957
01:20:29,000 --> 01:20:31,000
IT 公论 未知道

1958
01:20:31,000 --> 01:20:33,000
太一来了 流行通信

1959
01:20:33,000 --> 01:20:36,000
Hi story 博物制 选美

1960
01:20:36,000 --> 01:20:37,000
我们下期再会

