1
00:00:00,000 --> 00:00:03,000
大家好 欢迎收听第 17 的内核恐慌

2
00:00:03,000 --> 00:00:03,000
我是 Ryo

3
00:00:03,000 --> 00:00:04,000
我是吴涛

4
00:00:05,000 --> 00:00:07,000
今天我们请到了一位嘉宾

5
00:00:08,000 --> 00:00:09,000
他叫 Willow

6
00:00:09,000 --> 00:00:10,000
我来给大家打招呼吧

7
00:00:11,000 --> 00:00:12,000
大家好 我是 Willow

8
00:00:13,000 --> 00:00:17,000
又可以跟 Ryo 和吴涛插科打魂

9
00:00:17,000 --> 00:00:17,000
非常开心

10
00:00:19,000 --> 00:00:20,000
为什么要说又呢

11
00:00:20,000 --> 00:00:23,000
就是如果大家听过我主持的

12
00:00:23,000 --> 00:00:24,000
另外一档节目 IT 工程的话

13
00:00:24,000 --> 00:00:28,000
就知道 Willow 已经在那边做过两三次的嘉宾了

14
00:00:28,000 --> 00:00:29,000
可是我好像没有

15
00:00:30,000 --> 00:00:32,000
和 Willow 直接上过

16
00:00:33,000 --> 00:00:34,000
对

17
00:00:34,000 --> 00:00:35,000
对 我们没有上过

18
00:00:38,000 --> 00:00:39,000
不要一开始这么 A 嘛

19
00:00:41,000 --> 00:00:42,000
不过其实这是我们

20
00:00:42,000 --> 00:00:45,000
就是内核恐慌这期节目第一次邀请嘉宾吧

21
00:00:45,000 --> 00:00:45,000
对

22
00:00:46,000 --> 00:00:48,000
之前曾经邀请过一位嘉宾

23
00:00:48,000 --> 00:00:49,000
后来被 IT 工程抢走了

24
00:00:49,000 --> 00:00:51,000
对 王丑那些

25
00:00:51,000 --> 00:00:54,000
所以 Willow 也是我们他的处女嘉宾

26
00:00:54,000 --> 00:00:55,000
非常荣幸

27
00:00:56,000 --> 00:00:57,000
不知道

28
00:00:57,000 --> 00:00:59,000
我不知道是处女还是处女

29
00:01:00,000 --> 00:01:00,000
Yes

30
00:01:02,000 --> 00:01:05,000
今天请 Willow 来是要聊一件

31
00:01:05,000 --> 00:01:07,000
跟前端开发有关的事情

32
00:01:07,000 --> 00:01:08,000
因为刚好 Willow 最近

33
00:01:08,000 --> 00:01:10,000
应该是前天吧

34
00:01:10,000 --> 00:01:11,000
前天和上前天对吧

35
00:01:12,000 --> 00:01:13,000
28 号 29 号

36
00:01:13,000 --> 00:01:14,000
对

37
00:01:14,000 --> 00:01:17,000
然后去参加了 Facebook 搞的

38
00:01:17,000 --> 00:01:18,000
现在已经不算 Facebook

39
00:01:18,000 --> 00:01:20,000
他们已经独立出来了吗还是怎么样

40
00:01:20,000 --> 00:01:20,000
还是 Facebook

41
00:01:21,000 --> 00:01:22,000
还是 Facebook

42
00:01:22,000 --> 00:01:22,000
OK

43
00:01:23,000 --> 00:01:26,000
Facebook 他们有一个开发者的小型的会议

44
00:01:26,000 --> 00:01:28,000
是讲一个叫做 React

45
00:01:28,000 --> 00:01:30,000
这么一个前端开发的技术

46
00:01:30,000 --> 00:01:32,000
刚好 Willow 去了现场

47
00:01:32,000 --> 00:01:33,000
参加了两天的会议

48
00:01:34,000 --> 00:01:35,000
我们就趁着打铁

49
00:01:35,000 --> 00:01:37,000
邀请他来跟我们分享一下

50
00:01:37,000 --> 00:01:38,000
他所见所闻吧

51
00:01:38,000 --> 00:01:41,000
其实 Willow 你是为什么可以去参加

52
00:01:41,000 --> 00:01:45,000
或者说你是出于什么样的动机去参加 React.js 的 conference

53
00:01:47,000 --> 00:01:50,000
如果你看前端开发的发展的话

54
00:01:50,000 --> 00:01:51,000
你会发现

55
00:01:52,000 --> 00:01:54,000
去年和前年是非常激动的两年

56
00:01:55,000 --> 00:01:56,000
因为我们

57
00:01:57,000 --> 00:02:00,000
最开始大家写 PU JavaScript

58
00:02:00,000 --> 00:02:02,000
然后后来又写 JQuery

59
00:02:02,000 --> 00:02:07,000
然后再到 Backbone 引进了比较具体的 structure

60
00:02:09,000 --> 00:02:11,000
前端的开发好像到那里就有一点停滞

61
00:02:12,000 --> 00:02:14,000
在这个时候出现了 Angular

62
00:02:14,000 --> 00:02:16,000
然后去年又出现了 React

63
00:02:16,000 --> 00:02:19,000
实际上对于全端开发者来说

64
00:02:19,000 --> 00:02:22,000
整个前端世界是发生了巨变的

65
00:02:23,000 --> 00:02:27,000
而 React 是促使这些巨变的一个代表之一

66
00:02:28,000 --> 00:02:29,000
我们去年

67
00:02:29,000 --> 00:02:34,000
我们自己公司去年在考虑新的技术的时候

68
00:02:35,000 --> 00:02:38,000
把 React 纳入了我们想要使用的范围

69
00:02:39,000 --> 00:02:42,000
在过去的六到八个月

70
00:02:42,000 --> 00:02:49,000
我们都有在积极的把以前的东西给转移到 React 上

71
00:02:49,000 --> 00:02:51,000
我们之前是有写的一个 Backbone App

72
00:02:51,000 --> 00:02:56,000
然后我们现在在 Migrate 它去 React

73
00:02:57,000 --> 00:02:59,000
作为一个 React 开发者本身

74
00:02:59,000 --> 00:03:02,000
然后再作为一个技术的一个爱好者

75
00:03:02,000 --> 00:03:06,000
我觉得非常荣幸有机会去 React Comp

76
00:03:06,000 --> 00:03:11,000
去这个 community 看最新的东西

77
00:03:11,000 --> 00:03:14,000
然后从其他人身上学到一些东西

78
00:03:16,000 --> 00:03:20,000
你刚才提到说整个 App 要从 Backbone 迁移到 React 上面

79
00:03:20,000 --> 00:03:22,000
待会我们也可以讲一下整个迁移过程

80
00:03:22,000 --> 00:03:26,000
是不是的痛苦程度有多少

81
00:03:26,000 --> 00:03:26,000
没问题

82
00:03:26,000 --> 00:03:29,000
其实是一个非常有意思的一个过程

83
00:03:29,000 --> 00:03:34,000
相对于像 Angular 这样的庞大的 Framework 来说

84
00:03:34,000 --> 00:03:36,000
React 实际上非常的轻巧

85
00:03:36,000 --> 00:03:42,000
然后正是因此这个 Migration 没有很多人想象的会那么痛苦

86
00:03:42,000 --> 00:03:45,000
我们非常享受这个过程

87
00:03:45,000 --> 00:03:46,000
我忘了介绍了

88
00:03:46,000 --> 00:03:48,000
我们自己都很熟悉了

89
00:03:48,000 --> 00:03:50,000
但是忘了给有些听众朋友可能还

90
00:03:50,000 --> 00:03:53,000
第一次听到 Velo 的声音的话

91
00:03:53,000 --> 00:03:55,000
Velo 你还要先介绍一下自己

92
00:03:55,000 --> 00:03:59,000
你是在湾区的左前面开发对吧

93
00:04:03,000 --> 00:04:05,000
我在 IT 功论的时候也没有介绍自己

94
00:04:06,000 --> 00:04:10,000
对我觉得不知道 Velo 是谁的

95
00:04:10,000 --> 00:04:12,000
听众们可以回去听 IT 功论

96
00:04:12,000 --> 00:04:14,000
第一期是有介绍的

97
00:04:14,000 --> 00:04:20,000
我在湾区生活了三年

98
00:04:20,000 --> 00:04:23,000
然后我一直在这家叫做 Backplane 的

99
00:04:23,000 --> 00:04:24,000
对不起

100
00:04:24,000 --> 00:04:26,000
我在湾区生活了三年

101
00:04:26,000 --> 00:04:31,000
然后一直在一家叫做 Backplane 的公司做 Soft Engineer

102
00:04:31,000 --> 00:04:35,000
我很 Focus 在前端开发上

103
00:04:36,000 --> 00:04:41,000
然后我要给你们公司做什么负面宣传答应

104
00:04:41,000 --> 00:04:43,000
就是 Backplane 这家

105
00:04:43,000 --> 00:04:45,000
可能在外界最知名的就是什么他的投资人

106
00:04:45,000 --> 00:04:46,000
对吧

107
00:04:46,000 --> 00:04:47,000
什么都好

108
00:04:47,000 --> 00:04:49,000
我们待会再说

109
00:04:49,000 --> 00:04:52,000
我们最近在做什么很惊讶

110
00:04:52,000 --> 00:04:53,000
我只是说

111
00:04:53,000 --> 00:04:56,000
投资人是谁 Lady Gaga 还是

112
00:04:56,000 --> 00:04:57,000
对

113
00:04:57,000 --> 00:04:59,000
对没错

114
00:04:59,000 --> 00:05:02,000
可以帮我要一个签名吗

115
00:05:02,000 --> 00:05:05,000
他只是小股东

116
00:05:05,000 --> 00:05:08,000
签名他签我脸上

117
00:05:08,000 --> 00:05:09,000
他亲了我

118
00:05:09,000 --> 00:05:13,000
下次你来亲我一下

119
00:05:13,000 --> 00:05:16,000
应该是你下次他来你亲他一下

120
00:05:16,000 --> 00:05:17,000
这样你就和 Lady Gaga 亲上

121
00:05:17,000 --> 00:05:19,000
OK

122
00:05:19,000 --> 00:05:23,000
看多机智的一个方法

123
00:05:23,000 --> 00:05:23,000
对

124
00:05:23,000 --> 00:05:25,000
所以说回来

125
00:05:25,000 --> 00:05:29,000
所以 VLOG 是一个在湾区工作的软件开发者

126
00:05:29,000 --> 00:05:33,000
然后 VLOG 最有名的一个作品是

127
00:05:33,000 --> 00:05:38,000
或者说如果你跟 VLOG 曾经产生过什么交集的话

128
00:05:38,000 --> 00:05:41,000
也许是你用过他写的一个插件

129
00:05:41,000 --> 00:05:42,000
叫做 Wordforms

130
00:05:42,000 --> 00:05:47,000
就是用来检测网页上某一部分被显示出来的文字

131
00:05:47,000 --> 00:05:51,000
所实际采用的字体的插件

132
00:05:51,000 --> 00:05:55,000
我们之前有一期 IT 公论探讨完那个产品

133
00:05:55,000 --> 00:06:00,000
如果大家有兴趣的话可以回头听那个 Podcast

134
00:06:00,000 --> 00:06:03,000
这个产品已经已经在上线很多年了

135
00:06:03,000 --> 00:06:07,000
所以说我也很期待能够有新的作品

136
00:06:07,000 --> 00:06:08,000
拿出来给大家用

137
00:06:08,000 --> 00:06:11,000
然后我也在积极的做这方面的工作

138
00:06:13,000 --> 00:06:14,000
很好

139
00:06:15,000 --> 00:06:18,000
所以你看 VLOG 在湾区就有比较方便的机会

140
00:06:18,000 --> 00:06:23,000
去参加到各种各样比较高大上的技术会议

141
00:06:23,000 --> 00:06:26,000
这种的话不在湾区真的蛮难的

142
00:06:26,000 --> 00:06:26,000
我觉得

143
00:06:26,000 --> 00:06:31,000
是就像欧洲很多 conference 都是在各个城市

144
00:06:31,000 --> 00:06:33,000
晃来晃去很少会有这种

145
00:06:34,000 --> 00:06:36,000
因为扎堆的现象

146
00:06:36,000 --> 00:06:39,000
比如说 RECJS Europe Conference

147
00:06:39,000 --> 00:06:44,000
将在 7 月份举行在欧洲巴黎

148
00:06:44,000 --> 00:06:47,000
然后 PYCON Europe

149
00:06:47,000 --> 00:06:49,000
这个更是每一年都要换一个城市

150
00:06:49,000 --> 00:06:52,000
然后去年应该是在阿姆斯特丹

151
00:06:52,000 --> 00:06:53,000
我没记错

152
00:06:54,000 --> 00:06:55,000
还好

153
00:06:55,000 --> 00:06:56,000
欧洲交通方便

154
00:06:56,000 --> 00:06:57,000
我不觉得

155
00:06:58,000 --> 00:06:59,000
是吗

156
00:06:59,000 --> 00:07:00,000
我觉得还可以

157
00:07:01,000 --> 00:07:03,000
不管去哪都要订机票

158
00:07:03,000 --> 00:07:09,000
然后可能要去上国家的网站买火车票什么的

159
00:07:09,000 --> 00:07:10,000
就很麻烦

160
00:07:10,000 --> 00:07:10,000
不像

161
00:07:11,000 --> 00:07:13,000
离欧洲大一通的理想还比较远

162
00:07:15,000 --> 00:07:19,000
之所以 REACT CONF 在欧洲会在巴黎是因为

163
00:07:20,000 --> 00:07:24,000
那个开发者之一那个人叫什么 Christopher

164
00:07:24,000 --> 00:07:26,000
Christopher 他是法国人

165
00:07:26,000 --> 00:07:27,000
对

166
00:07:27,000 --> 00:07:31,000
他讲英语的时候有非常强的法国口音

167
00:07:32,000 --> 00:07:34,000
我还专门去查了他是哪个人

168
00:07:34,000 --> 00:07:36,000
我没有听错

169
00:07:37,000 --> 00:07:39,000
他 Last name is Chateau

170
00:07:39,000 --> 00:07:40,000
这个很明显了

171
00:07:41,000 --> 00:07:41,000
那挺好的

172
00:07:42,000 --> 00:07:45,000
这也反映一个大家很开放的态度

173
00:07:45,000 --> 00:07:46,000
其实我说英语也有口音

174
00:07:46,000 --> 00:07:50,000
但是这个并不会成为不影响工作的

175
00:07:50,000 --> 00:07:53,000
所以我也很看到他能够

176
00:07:54,000 --> 00:07:57,000
host 这个 conference 也是 validate

177
00:07:57,000 --> 00:08:00,000
大家都能这个英语这个事情不是那么重要

178
00:08:00,000 --> 00:08:01,000
所以是一个很好的事情

179
00:08:02,000 --> 00:08:05,000
其实其实 vilo 在我们三个人里面

180
00:08:05,000 --> 00:08:06,000
已经是最美口音的一个了

181
00:08:07,000 --> 00:08:08,000
对

182
00:08:09,000 --> 00:08:11,000
摸爬滚打的最久的

183
00:08:11,000 --> 00:08:15,000
回到这个正题

184
00:08:15,000 --> 00:08:18,000
其实我们可以先回顾一下

185
00:08:18,000 --> 00:08:21,000
在 REACT 之前的那些框架会有一些什么样的

186
00:08:21,000 --> 00:08:24,000
有些什么样的选择会有什么样的问题

187
00:08:24,000 --> 00:08:26,000
vilo 你们之前是用 backbond 对吧

188
00:08:26,000 --> 00:08:27,000
对

189
00:08:27,000 --> 00:08:27,000
没错

190
00:08:28,000 --> 00:08:30,000
你们在实际使用中的话

191
00:08:30,000 --> 00:08:32,000
刚才你也提到你们在往这个 REACT 迁移

192
00:08:33,000 --> 00:08:36,000
那么你们就说在 backbond 的实际使用中

193
00:08:36,000 --> 00:08:37,000
遇到一些什么样的问题

194
00:08:37,000 --> 00:08:40,000
然后迁移到 REACT 会比较好的解决

195
00:08:42,000 --> 00:08:44,000
有两方面的问题

196
00:08:44,000 --> 00:08:45,000
一方面是在

197
00:08:46,000 --> 00:08:49,000
认识在 engineering 方面会遇到一些问题

198
00:08:49,000 --> 00:08:52,000
然后你在 production 上会遇到一些问题

199
00:08:52,000 --> 00:08:54,000
production 上的问题其实蛮简单的

200
00:08:54,000 --> 00:08:55,000
就是 performance

201
00:08:57,000 --> 00:08:59,000
一个 framework 它到底能有多快

202
00:08:59,000 --> 00:09:01,000
渲染的多快

203
00:09:01,000 --> 00:09:04,000
交互能力这些东西是非常好客观评价的

204
00:09:04,000 --> 00:09:04,000
然后

205
00:09:05,000 --> 00:09:07,000
如果上网搜的话会看到很多

206
00:09:08,000 --> 00:09:09,000
负面的关于 backbond 的

207
00:09:11,000 --> 00:09:13,000
一些评测显示

208
00:09:13,000 --> 00:09:15,000
然后我们自己在 production 上也遇到这些问题

209
00:09:15,000 --> 00:09:17,000
我们网站并不算快

210
00:09:18,000 --> 00:09:21,000
然后在 memory 上也非常难管理

211
00:09:21,000 --> 00:09:22,000
这个 memory 呢

212
00:09:22,000 --> 00:09:24,000
实际上是跨了 production and engineering

213
00:09:24,000 --> 00:09:28,000
因为 backbond 的 memory management

214
00:09:28,000 --> 00:09:32,000
就好像你在原来做 ios 开发是那个

215
00:09:32,000 --> 00:09:34,000
你要 manually return things

216
00:09:34,000 --> 00:09:36,000
你要 manually manage them

217
00:09:36,000 --> 00:09:37,000
手工管理内存

218
00:09:37,000 --> 00:09:38,000
所以

219
00:09:39,000 --> 00:09:41,000
非常容易出现 memory leak

220
00:09:41,000 --> 00:09:43,000
那整个程序记忆

221
00:09:43,000 --> 00:09:44,000
在 renders 上会卖

222
00:09:44,000 --> 00:09:47,000
然后在 memory 上会 leak 的话

223
00:09:47,000 --> 00:09:49,000
那你的 performance 就非常不乐观

224
00:09:50,000 --> 00:09:52,000
就是 production 上的问题

225
00:09:52,000 --> 00:09:54,000
engineering 上的问题在于

226
00:09:55,000 --> 00:09:57,000
关键对于我们来说是代码的

227
00:09:57,000 --> 00:09:59,000
可重用性和可管理性

228
00:10:00,000 --> 00:10:01,000
在重用性上的问题

229
00:10:01,000 --> 00:10:03,000
主要来说就是

230
00:10:04,000 --> 00:10:06,000
view 的重用性

231
00:10:06,000 --> 00:10:08,000
实际上要重用一个 view 在 backbond 中

232
00:10:08,000 --> 00:10:10,000
还其实蛮复杂的

233
00:10:10,000 --> 00:10:14,000
因为你要在那个 view 里面

234
00:10:14,000 --> 00:10:16,000
在你的 template 里面

235
00:10:16,000 --> 00:10:19,000
给这个 subview 腾出一个空间

236
00:10:19,000 --> 00:10:21,000
选一个 container

237
00:10:21,000 --> 00:10:22,000
然后在你的 render 方式中

238
00:10:22,000 --> 00:10:24,000
要 initialize 那个

239
00:10:25,000 --> 00:10:25,000
excuse me

240
00:10:26,000 --> 00:10:27,000
subview

241
00:10:27,000 --> 00:10:29,000
然后把 subview 切进来

242
00:10:30,000 --> 00:10:33,000
这一系列过程对于开发者来说

243
00:10:33,000 --> 00:10:35,000
还是一个蛮头痛的事情

244
00:10:35,000 --> 00:10:36,000
所以正因为如此

245
00:10:37,000 --> 00:10:40,000
你会看到很多人不会去重用

246
00:10:42,000 --> 00:10:44,000
在代码的可管理下的关键是

247
00:10:45,000 --> 00:10:48,000
其实 view 它本身并不

248
00:10:49,000 --> 00:10:52,000
并不管理它所有的 state

249
00:10:52,000 --> 00:10:54,000
很大一部分程度上 state 是

250
00:10:54,000 --> 00:10:55,000
在 dom 里头的

251
00:10:56,000 --> 00:10:57,000
你知道我们有时候 utilize

252
00:10:57,000 --> 00:10:58,000
class

253
00:10:58,000 --> 00:10:59,000
utilize data

254
00:10:59,000 --> 00:11:00,000
probs

255
00:11:00,000 --> 00:11:00,000
这样的

256
00:11:01,000 --> 00:11:03,000
这样 dom 的 elevator 去管理

257
00:11:03,000 --> 00:11:04,000
view 的 state

258
00:11:05,000 --> 00:11:06,000
就导致

259
00:11:06,000 --> 00:11:08,000
在大家看这个 view 的时候

260
00:11:08,000 --> 00:11:10,000
并看不到全貌

261
00:11:10,000 --> 00:11:12,000
不知道这个 view 到底能够做什么事情

262
00:11:12,000 --> 00:11:13,000
会做什么事情

263
00:11:13,000 --> 00:11:15,000
其实你在看那个 view 的时候

264
00:11:15,000 --> 00:11:16,000
是很难看出来的

265
00:11:16,000 --> 00:11:17,000
所以就

266
00:11:18,000 --> 00:11:20,000
在多人合作的项目上

267
00:11:20,000 --> 00:11:22,000
或者是说你返回到你

268
00:11:22,000 --> 00:11:24,000
多年之前写的 hive 的时候

269
00:11:24,000 --> 00:11:26,000
就会是一个很大的问题

270
00:11:27,000 --> 00:11:29,000
这是我们用 backbone

271
00:11:30,000 --> 00:11:32,000
两三年的时间里

272
00:11:32,000 --> 00:11:33,000
所遇到两个方面的问题

273
00:11:34,000 --> 00:11:38,000
我觉得这可能跟 backbone 的设计理念有关系

274
00:11:38,000 --> 00:11:41,000
backbone 毕竟它强调的是

275
00:11:41,000 --> 00:11:43,000
它所提供的功能

276
00:11:43,000 --> 00:11:45,000
只是最基本

277
00:11:45,000 --> 00:11:47,000
最 backbone 的那一部分

278
00:11:48,000 --> 00:11:50,000
所以你可能不得不

279
00:11:50,000 --> 00:11:54,000
在很多地方要显示的去

280
00:11:54,000 --> 00:11:56,000
去宣告一些东西

281
00:11:56,000 --> 00:11:58,000
然后你需要告诉

282
00:11:59,000 --> 00:12:01,000
你需要显示的把逻辑写出来

283
00:12:01,000 --> 00:12:03,000
而如果你需要显示的写出来的话

284
00:12:03,000 --> 00:12:06,000
每个人写的逻辑可能会不一样

285
00:12:08,000 --> 00:12:08,000
你说你

286
00:12:08,000 --> 00:12:10,000
这就是一方面的问题

287
00:12:11,000 --> 00:12:12,000
对你说你直接看

288
00:12:12,000 --> 00:12:14,000
无法直接看到 view 想要干什么

289
00:12:14,000 --> 00:12:15,000
那其实原因之一

290
00:12:15,000 --> 00:12:17,000
也就是它没有一个

291
00:12:17,000 --> 00:12:21,000
default 的 behaviour

292
00:12:21,000 --> 00:12:23,000
可以让你去

293
00:12:23,000 --> 00:12:25,000
可以一眼让你猜到它要干什么

294
00:12:27,000 --> 00:12:30,000
backbone 既好又导致这个问题的一方面

295
00:12:30,000 --> 00:12:33,000
就是它不是很 opinionated

296
00:12:34,000 --> 00:12:37,000
我们确实在总结我们的 backbone 的

297
00:12:37,000 --> 00:12:39,000
经验的时候有提到这点

298
00:12:39,000 --> 00:12:42,000
在一个团队写作的范围中

299
00:12:43,000 --> 00:12:45,000
不 opinionated 实际上是一个很麻烦的事情

300
00:12:45,000 --> 00:12:46,000
因为大家可能写东西

301
00:12:46,000 --> 00:12:48,000
会用不同的方式

302
00:12:48,000 --> 00:12:50,000
也不是说各种方式

303
00:12:50,000 --> 00:12:51,000
哪个好哪个坏

304
00:12:51,000 --> 00:12:54,000
关键是写作上来说

305
00:12:54,000 --> 00:12:56,000
有相同的 mental model

306
00:12:56,000 --> 00:12:57,000
会更方便一点

307
00:12:58,000 --> 00:13:00,000
不管好坏只要一样的话

308
00:13:00,000 --> 00:13:01,000
能维护起来的成本

309
00:13:01,000 --> 00:13:03,000
可能也不是维护起来的成本

310
00:13:03,000 --> 00:13:05,000
就是沟通起来的成本会小一些

311
00:13:05,000 --> 00:13:08,000
就如果你用 amber.js 或者是 angular 之类的

312
00:13:08,000 --> 00:13:13,000
比较有自己的一套使用哲学的框架的话

313
00:13:13,000 --> 00:13:17,000
你会比较有一个大致的概念

314
00:13:17,000 --> 00:13:18,000
就是这件事情怎样做

315
00:13:18,000 --> 00:13:20,000
才是符合这个框架的理念的

316
00:13:20,000 --> 00:13:22,000
但是 backbone 则比较平淡

317
00:13:22,000 --> 00:13:26,000
或者说比较给了你太多自由权

318
00:13:26,000 --> 00:13:29,000
然后就会导致会有沟通上面的问题

319
00:13:29,000 --> 00:13:29,000
我是觉得

320
00:13:31,000 --> 00:13:32,000
确实有这样的因素在

321
00:13:33,000 --> 00:13:35,000
可是当我们在看

322
00:13:35,000 --> 00:13:37,000
就是像 amber.js 这样的 frame 的时候

323
00:13:37,000 --> 00:13:41,000
它相对于 backbone 是一个比较小的地境

324
00:13:41,000 --> 00:13:42,000
对我们来说

325
00:13:42,000 --> 00:13:44,000
确实它在 backbone 的每一个方面

326
00:13:44,000 --> 00:13:46,000
backbone 所设计的每一个方面

327
00:13:46,000 --> 00:13:49,000
不管是 router 还是 vue templating

328
00:13:49,000 --> 00:13:51,000
它都有相当大的进步

329
00:13:51,000 --> 00:13:51,000
however

330
00:13:52,000 --> 00:13:55,000
fundamentally 他们的框架的理念

331
00:13:55,000 --> 00:13:58,000
MVC 的理念是完全一致的

332
00:13:58,000 --> 00:14:00,000
这也是为什么我们在考虑

333
00:14:00,000 --> 00:14:04,000
更新我们的 framework 的时候

334
00:14:04,000 --> 00:14:05,000
并没有做太

335
00:14:05,000 --> 00:14:07,000
对 amber 并没有做太多的考虑

336
00:14:07,000 --> 00:14:08,000
因为

337
00:14:08,000 --> 00:14:12,000
如果你计算时间

338
00:14:12,000 --> 00:14:15,000
就是从一种 MVC 换到另一种 MVC

339
00:14:15,000 --> 00:14:18,000
只不过另外一个 MVC 更重量级一点

340
00:14:18,000 --> 00:14:19,000
更更更 opinion 的一点

341
00:14:20,000 --> 00:14:20,000
没错

342
00:14:21,000 --> 00:14:22,000
OK

343
00:14:23,000 --> 00:14:24,000
所以刚才为了你讲到

344
00:14:24,000 --> 00:14:26,000
提到像 backbone 你们做的时候

345
00:14:26,000 --> 00:14:28,000
就是我根据你的描述

346
00:14:28,000 --> 00:14:30,000
我感觉出来有几个比较核心的问题

347
00:14:30,000 --> 00:14:31,000
就一个是说

348
00:14:32,000 --> 00:14:34,000
这个叫什么封装的层级不够

349
00:14:34,000 --> 00:14:36,000
就是说它封的太散了

350
00:14:36,000 --> 00:14:37,000
比如说你很多有些

351
00:14:37,000 --> 00:14:40,000
那个数据是在 DOM 里面的

352
00:14:40,000 --> 00:14:41,000
有些数据可能是在 JavaScript 的

353
00:14:41,000 --> 00:14:43,000
那个数据结构里面的

354
00:14:43,000 --> 00:14:43,000
对吧

355
00:14:43,000 --> 00:14:44,000
这可能是一个

356
00:14:44,000 --> 00:14:45,000
还有你说那个 view

357
00:14:45,000 --> 00:14:47,000
不能在同一个地方一眼看出来

358
00:14:47,000 --> 00:14:48,000
它的相关的那一部分是怎么样

359
00:14:49,000 --> 00:14:50,000
这个其实是

360
00:14:50,000 --> 00:14:52,000
你们在工程上的话

361
00:14:52,000 --> 00:14:53,000
就是没有把这些相关的部分

362
00:14:53,000 --> 00:14:55,000
很好的就是 uncapacitate 起来

363
00:14:56,000 --> 00:14:56,000
没错

364
00:14:57,000 --> 00:15:00,000
因为这个主要是因为 DOM 这个事情

365
00:15:00,000 --> 00:15:01,000
就太他妈操蛋了

366
00:15:01,000 --> 00:15:02,000
你知道就是这样

367
00:15:04,000 --> 00:15:05,000
大家都明白

368
00:15:05,000 --> 00:15:06,000
我说为什么这么说

369
00:15:07,000 --> 00:15:07,000
因为

370
00:15:09,000 --> 00:15:10,000
DOM 的问题

371
00:15:10,000 --> 00:15:13,000
首先 API 很烂

372
00:15:13,000 --> 00:15:14,000
这个 JQuery

373
00:15:14,000 --> 00:15:14,000
kind of

374
00:15:14,000 --> 00:15:15,000
you know

375
00:15:15,000 --> 00:15:16,000
so it resolve that problem

376
00:15:16,000 --> 00:15:17,000
kind of

377
00:15:17,000 --> 00:15:18,000
然后

378
00:15:19,000 --> 00:15:21,000
关键的因素在于说 performance 太烂

379
00:15:21,000 --> 00:15:22,000
因为

380
00:15:23,000 --> 00:15:25,000
这是历史因素

381
00:15:25,000 --> 00:15:26,000
因为 DOM 的

382
00:15:26,000 --> 00:15:27,000
对

383
00:15:27,000 --> 00:15:28,000
你跟 DOM 交互的话

384
00:15:28,000 --> 00:15:30,000
肯定就是有这个所谓 overhead 比较高

385
00:15:30,000 --> 00:15:31,000
对

386
00:15:32,000 --> 00:15:33,000
实际上

387
00:15:33,000 --> 00:15:36,000
如果你真的去 compare backbone 跟 react 的话

388
00:15:36,000 --> 00:15:39,000
最关键就是他们怎么去处理这个 DOM

389
00:15:40,000 --> 00:15:41,000
你怎么去处理 DOM

390
00:15:41,000 --> 00:15:42,000
这个事情上不一样

391
00:15:42,000 --> 00:15:44,000
在 backbone 里头

392
00:15:44,000 --> 00:15:46,000
如果你要追求 performance

393
00:15:47,000 --> 00:15:49,000
如果说你不 care performance

394
00:15:49,000 --> 00:15:50,000
那是 totally different story

395
00:15:50,000 --> 00:15:51,000
但是如果你

396
00:15:52,000 --> 00:15:54,000
就是在意真正可用的东西

397
00:15:54,000 --> 00:15:56,000
还不是好用是可用的话

398
00:15:56,000 --> 00:15:58,000
你一定要在意 performance

399
00:15:58,000 --> 00:15:58,000
然后

400
00:15:59,000 --> 00:16:00,000
就导致说

401
00:16:00,000 --> 00:16:02,000
你的 DOM 的

402
00:16:03,000 --> 00:16:04,000
操作都要很小

403
00:16:04,000 --> 00:16:05,000
非常小

404
00:16:05,000 --> 00:16:06,000
比方说

405
00:16:06,000 --> 00:16:08,000
如果我要写一个

406
00:16:09,000 --> 00:16:10,000
选项的列表

407
00:16:11,000 --> 00:16:12,000
一个用户

408
00:16:12,000 --> 00:16:14,000
去点一个选项

409
00:16:14,000 --> 00:16:16,000
然后那个选项要变成红色

410
00:16:16,000 --> 00:16:17,000
这么一个小小的功能

411
00:16:17,000 --> 00:16:18,000
在你的

412
00:16:18,000 --> 00:16:19,000
backboneV 中

413
00:16:19,000 --> 00:16:21,000
你一定是会

414
00:16:21,000 --> 00:16:23,000
manually 把这个 class

415
00:16:24,000 --> 00:16:25,000
从其他的

416
00:16:25,000 --> 00:16:27,000
element 上移除出去

417
00:16:27,000 --> 00:16:29,000
然后加在 target 的

418
00:16:30,000 --> 00:16:31,000
这个

419
00:16:31,000 --> 00:16:32,000
element 上的

420
00:16:32,000 --> 00:16:34,000
就这么小小一点

421
00:16:34,000 --> 00:16:35,000
操作

422
00:16:35,000 --> 00:16:36,000
你要变力一遍

423
00:16:36,000 --> 00:16:38,000
就导致你的

424
00:16:38,000 --> 00:16:40,000
这个 state 就从 view 上 lose 掉了

425
00:16:40,000 --> 00:16:42,000
因为你整个 state

426
00:16:42,000 --> 00:16:43,000
是在 DOM 的

427
00:16:43,000 --> 00:16:44,000
那个 active class

428
00:16:44,000 --> 00:16:46,000
这个因素上的

429
00:16:46,000 --> 00:16:48,000
但是你又不可能说

430
00:16:48,000 --> 00:16:49,000
每次都把这个

431
00:16:50,000 --> 00:16:51,000
列表重新给 rendered 一下

432
00:16:52,000 --> 00:16:54,000
这就回到我们说的 performance 上面

433
00:16:55,000 --> 00:16:57,000
对于开发者来说

434
00:16:57,000 --> 00:16:58,000
如果你不需要去担心

435
00:16:58,000 --> 00:17:00,000
这么小小的这种细节操作

436
00:17:00,000 --> 00:17:01,000
而是

437
00:17:01,000 --> 00:17:04,000
描述清楚你到底这个 view

438
00:17:04,000 --> 00:17:05,000
end result 是怎么样

439
00:17:06,000 --> 00:17:08,000
那你的 code 会清楚很多

440
00:17:08,000 --> 00:17:10,000
可是因为 performance 的因素

441
00:17:10,000 --> 00:17:12,000
你必须得到

442
00:17:12,000 --> 00:17:12,000
这么

443
00:17:12,000 --> 00:17:14,000
到那个细节的小的程度

444
00:17:14,000 --> 00:17:15,000
去操作它

445
00:17:15,000 --> 00:17:17,000
就导致你不能够

446
00:17:17,000 --> 00:17:18,000
每次都 re-render

447
00:17:19,000 --> 00:17:21,000
backbone 的时代就是这样子的

448
00:17:21,000 --> 00:17:21,000
但是

449
00:17:22,000 --> 00:17:24,000
然后这就是 reactive magic

450
00:17:24,000 --> 00:17:24,000
happens

451
00:17:24,000 --> 00:17:25,000
with a happen

452
00:17:25,000 --> 00:17:27,000
magic happens

453
00:17:28,000 --> 00:17:30,000
在 reactive class 里头

454
00:17:30,000 --> 00:17:31,000
Tom

455
00:17:31,000 --> 00:17:33,000
who is the product manager

456
00:17:34,000 --> 00:17:35,000
有提到

457
00:17:36,000 --> 00:17:38,000
Facebook 内部

458
00:17:39,000 --> 00:17:40,000
去做这个

459
00:17:40,000 --> 00:17:41,000
去 initialize

460
00:17:41,000 --> 00:17:43,000
这个 project 的动机

461
00:17:43,000 --> 00:17:44,000
就有提到说

462
00:17:44,000 --> 00:17:45,000
他们很想要

463
00:17:47,000 --> 00:17:48,000
把这个

464
00:17:48,000 --> 00:17:50,000
这种细小的 dom

465
00:17:50,000 --> 00:17:51,000
操作

466
00:17:51,000 --> 00:17:52,000
隔离出来

467
00:17:52,000 --> 00:17:52,000
abstract 到

468
00:17:52,000 --> 00:17:53,000
就像

469
00:17:53,000 --> 00:17:54,000
刚刚 Rio 说的

470
00:17:55,000 --> 00:17:55,000
encapsulate

471
00:17:57,000 --> 00:17:58,000
但是他们担心 performance

472
00:17:58,000 --> 00:18:00,000
所以他们做了 performance 的测试

473
00:18:00,000 --> 00:18:02,000
其实像 performance 的测试结果

474
00:18:02,000 --> 00:18:04,000
比我们所要预想的

475
00:18:04,000 --> 00:18:06,000
都乐观很多

476
00:18:06,000 --> 00:18:08,000
其实像 dom 没有那么烂

477
00:18:08,000 --> 00:18:09,000
他们的原话是

478
00:18:09,000 --> 00:18:12,000
我记得是 IE 9 还是 IE 10

479
00:18:12,000 --> 00:18:13,000
才会非常烂

480
00:18:13,000 --> 00:18:13,000
well

481
00:18:14,000 --> 00:18:14,000
well no

482
00:18:14,000 --> 00:18:15,000
I like that's not so

483
00:18:15,000 --> 00:18:15,000
对

484
00:18:16,000 --> 00:18:16,000
but

485
00:18:18,000 --> 00:18:19,000
对 这是一个

486
00:18:19,000 --> 00:18:21,000
对 这是浏览器相关的

487
00:18:21,000 --> 00:18:22,000
毫无疑问

488
00:18:23,000 --> 00:18:23,000
对

489
00:18:24,000 --> 00:18:24,000
所以

490
00:18:25,000 --> 00:18:26,000
这是在比方说

491
00:18:26,000 --> 00:18:27,000
modern chrome 中

492
00:18:27,000 --> 00:18:29,000
如果你就是不停的 re-render 的话

493
00:18:29,000 --> 00:18:31,000
实际上也没有那么烂

494
00:18:31,000 --> 00:18:32,000
可是

495
00:18:32,000 --> 00:18:33,000
of course we want

496
00:18:34,000 --> 00:18:35,000
better performance right

497
00:18:35,000 --> 00:18:37,000
所以他们又

498
00:18:38,000 --> 00:18:39,000
脑洞大开的

499
00:18:40,000 --> 00:18:42,000
想把这个 dom 这个事情

500
00:18:42,000 --> 00:18:43,000
整个给 encapsulate

501
00:18:43,000 --> 00:18:45,000
整个给 virtualize

502
00:18:47,000 --> 00:18:48,000
所以开发者就

503
00:18:48,000 --> 00:18:50,000
完全去不去操作

504
00:18:50,000 --> 00:18:51,000
这个 dom

505
00:18:51,000 --> 00:18:52,000
然后通过

506
00:18:52,000 --> 00:18:54,000
react 本身的一套算法

507
00:18:54,000 --> 00:18:56,000
react 会

508
00:18:58,000 --> 00:18:59,000
试图发现

509
00:19:00,000 --> 00:19:02,000
两个 state 之间的区别

510
00:19:02,000 --> 00:19:04,000
帮你自动的去 update

511
00:19:05,000 --> 00:19:06,000
真正的浏览器的 dom

512
00:19:07,000 --> 00:19:09,000
这就移除了这个 performance

513
00:19:09,000 --> 00:19:10,000
的问题

514
00:19:10,000 --> 00:19:13,000
从而回过头来

515
00:19:14,000 --> 00:19:16,000
enable 了开发者去写更

516
00:19:17,000 --> 00:19:18,000
descriptive

517
00:19:18,000 --> 00:19:20,000
更 declarative 的 code

518
00:19:20,000 --> 00:19:21,000
而不是

519
00:19:22,000 --> 00:19:23,000
直接告诉浏览器去做什么

520
00:19:24,000 --> 00:19:26,000
对 这里就提到有一个

521
00:19:26,000 --> 00:19:28,000
react 它这个

522
00:19:28,000 --> 00:19:29,000
最新的这种前端的

523
00:19:29,000 --> 00:19:30,000
它也比较框架

524
00:19:30,000 --> 00:19:31,000
这个工具

525
00:19:31,000 --> 00:19:33,000
它最核心的一点就是说

526
00:19:33,000 --> 00:19:36,000
它本身是和浏览器的 dom

527
00:19:36,000 --> 00:19:36,000
是脱节的

528
00:19:36,000 --> 00:19:38,000
就是它没有一个很

529
00:19:38,000 --> 00:19:40,000
就所谓的 type coupling 在里面

530
00:19:40,000 --> 00:19:40,000
就是它

531
00:19:40,000 --> 00:19:41,000
rendertry 的结果

532
00:19:41,000 --> 00:19:43,000
并不是得到的一个

533
00:19:43,000 --> 00:19:44,000
真正的浏览器的 dom

534
00:19:44,000 --> 00:19:44,000
而是一个

535
00:19:44,000 --> 00:19:46,000
所以他们讲的一个虚拟的 dom

536
00:19:46,000 --> 00:19:47,000
对 virtualdom

537
00:19:48,000 --> 00:19:50,000
对 然后他们再有做了这么一个

538
00:19:50,000 --> 00:19:51,000
这个 diff 这一层

539
00:19:51,000 --> 00:19:52,000
然后再去说

540
00:19:53,000 --> 00:19:54,000
怎么用最小的代价

541
00:19:54,000 --> 00:19:56,000
使得浏览器里面

542
00:19:56,000 --> 00:19:58,000
现在有的那一个要真实的 dom

543
00:19:58,000 --> 00:20:00,000
能够变成你

544
00:20:00,000 --> 00:20:02,000
这个 virtualdom 需要的形状

545
00:20:02,000 --> 00:20:04,000
这样的话就可以尽量减少

546
00:20:05,000 --> 00:20:07,000
dom 那边的交互的开销

547
00:20:08,000 --> 00:20:10,000
当然这个的前提假设就是说

548
00:20:10,000 --> 00:20:12,000
你跟真实的浏览器

549
00:20:12,000 --> 00:20:13,000
真实的 dom 的交互

550
00:20:13,000 --> 00:20:14,000
是一个比较高成本的

551
00:20:15,000 --> 00:20:17,000
但是在一个现代浏览器

552
00:20:17,000 --> 00:20:19,000
现代的 javascript 的解析器的情况下

553
00:20:19,000 --> 00:20:21,000
它的 javascript 内部的

554
00:20:21,000 --> 00:20:24,000
执行和解析的速度是非常快的

555
00:20:24,000 --> 00:20:26,000
所以要解决这两个之间的差异的话

556
00:20:26,000 --> 00:20:28,000
它就通过这种做 diff 的方法来实现

557
00:20:29,000 --> 00:20:30,000
对 没错

558
00:20:30,000 --> 00:20:32,000
很有意思的是

559
00:20:32,000 --> 00:20:38,000
David Nolan 是 closure script 的作者

560
00:20:38,000 --> 00:20:42,000
然后他们有把 react 给

561
00:20:42,000 --> 00:20:46,000
写了一个 closure script 的 react 叫做 OM

562
00:20:46,000 --> 00:20:48,000
他给了一个 presentation

563
00:20:48,000 --> 00:20:50,000
然后他不把 virtualdom 叫做 virtualdom

564
00:20:50,000 --> 00:20:53,000
他把 virtualdom 叫做 dom virtual machine

565
00:20:54,000 --> 00:20:56,000
这是一个非常小的差异

566
00:20:57,000 --> 00:20:59,000
但是我想他想要说的是说

567
00:21:00,000 --> 00:21:04,000
这个 virtualdom 实际上是非常 powerful

568
00:21:06,000 --> 00:21:08,000
然后这个 react

569
00:21:08,000 --> 00:21:10,000
它的可能在思维哲学上

570
00:21:10,000 --> 00:21:12,000
我觉得有一点很大的不同

571
00:21:12,000 --> 00:21:14,000
就是说传统上我们像用 backbone 之类的

572
00:21:14,000 --> 00:21:15,000
其实你是在

573
00:21:16,000 --> 00:21:18,000
你是把 dom 当成一个巨大的 state

574
00:21:18,000 --> 00:21:21,000
然后你是在手工的去管理那些 state 对吧

575
00:21:22,000 --> 00:21:23,000
然后就可能就很多的操作

576
00:21:23,000 --> 00:21:26,000
就是可能要手动去添加什么

577
00:21:26,000 --> 00:21:27,000
这个 event handler

578
00:21:28,000 --> 00:21:29,000
然后发生什么事情

579
00:21:29,000 --> 00:21:30,000
你要记得把它取掉

580
00:21:30,000 --> 00:21:32,000
然后要做一些相应的修改

581
00:21:32,000 --> 00:21:36,000
就是整个来看交互的流程

582
00:21:36,000 --> 00:21:38,000
和你的 view

583
00:21:38,000 --> 00:21:40,000
其实是混杂在比较

584
00:21:41,000 --> 00:21:41,000
叫做什么

585
00:21:42,000 --> 00:21:43,000
那个叫什么

586
00:21:43,000 --> 00:21:45,000
犬牙交错对吧

587
00:21:46,000 --> 00:21:47,000
终于想起这个

588
00:21:47,000 --> 00:21:49,000
难为你用这么复杂的头

589
00:21:51,000 --> 00:21:53,000
但是像 react 这种思路的话

590
00:21:53,000 --> 00:21:54,000
他用那种 virtualdom 的思路

591
00:21:54,000 --> 00:21:57,000
其实刚刚 Willow 已经解释过一下

592
00:21:57,000 --> 00:22:00,000
就说他其实是放弃了这一条

593
00:22:00,000 --> 00:22:03,000
就说我们不要去手工去改

594
00:22:03,000 --> 00:22:05,000
那个一个浏览器里面 dom 的

595
00:22:05,000 --> 00:22:06,000
每一个小细节

596
00:22:06,000 --> 00:22:08,000
而是说你只要告诉我

597
00:22:08,000 --> 00:22:10,000
你需要让它达到什么样的状态

598
00:22:10,000 --> 00:22:11,000
当然这个需要

599
00:22:11,000 --> 00:22:13,000
你说你是一次性的描述性的状态

600
00:22:14,000 --> 00:22:16,000
然后这样的话

601
00:22:16,000 --> 00:22:17,000
我就只需要说

602
00:22:18,000 --> 00:22:21,000
那我不需要考虑怎么去变到那个状态

603
00:22:21,000 --> 00:22:21,000
我只需要声明

604
00:22:21,000 --> 00:22:23,000
我最后要达到什么样的状态就可以了

605
00:22:24,000 --> 00:22:25,000
其实这个让我想起

606
00:22:25,000 --> 00:22:29,000
Backbone 的一句宣传口号

607
00:22:29,000 --> 00:22:33,000
就是 get the truth out from your dom

608
00:22:34,000 --> 00:22:36,000
但实际上

609
00:22:36,000 --> 00:22:39,000
他的这个口号所指的是要把

610
00:22:40,000 --> 00:22:41,000
其实就是很简单的

611
00:22:41,000 --> 00:22:46,000
要把 dom 所要呈现的那些数据

612
00:22:47,000 --> 00:22:49,000
作为你的 model

613
00:22:49,000 --> 00:22:51,000
从 dom 里面抽吸出来

614
00:22:52,000 --> 00:22:55,000
但如果沿着这一句宣传口号

615
00:22:55,000 --> 00:22:58,000
更进一步研发的话

616
00:22:58,000 --> 00:23:00,000
会我觉得可能最终结果就是像 react 这样

617
00:23:00,000 --> 00:23:03,000
就是将 dom 作为某种

618
00:23:04,000 --> 00:23:06,000
就像 screen buffer 一样

619
00:23:07,000 --> 00:23:10,000
就是计算出最终需要的 dom

620
00:23:10,000 --> 00:23:12,000
然后去更新

621
00:23:12,000 --> 00:23:14,000
它与实际的 dom 所差异的这一部分

622
00:23:15,000 --> 00:23:16,000
这样可能更

623
00:23:16,000 --> 00:23:19,000
就是更多的 truth

624
00:23:19,000 --> 00:23:22,000
被从 dom 里面抽吸出来

625
00:23:22,000 --> 00:23:25,000
其实他这个思想也不是说原创性的

626
00:23:25,000 --> 00:23:28,000
就是在很多年前做游戏的

627
00:23:28,000 --> 00:23:30,000
大家都已经发现有这么一个

628
00:23:30,000 --> 00:23:32,000
就做那种电脑游戏的人

629
00:23:32,000 --> 00:23:33,000
都已经有这么一个概念了

630
00:23:35,000 --> 00:23:36,000
过去游戏有一个叫做

631
00:23:36,000 --> 00:23:38,000
就是绘制图形的话

632
00:23:38,000 --> 00:23:39,000
有个所谓的 immediate mode

633
00:23:39,000 --> 00:23:40,000
就是立即模式

634
00:23:41,000 --> 00:23:42,000
就是你画什么

635
00:23:42,000 --> 00:23:44,000
就在屏幕上出现什么

636
00:23:45,000 --> 00:23:46,000
然后发现其实这样的话

637
00:23:46,000 --> 00:23:51,000
对性能其实是不好的

638
00:23:51,000 --> 00:23:53,000
然后他们发现用 retain mode 的话

639
00:23:53,000 --> 00:23:58,000
你其实可以在让游戏引擎去做一些优化

640
00:23:58,000 --> 00:24:00,000
就说把 batch

641
00:24:00,000 --> 00:24:02,000
你先告诉他下一帧会显示

642
00:24:02,000 --> 00:24:02,000
应该显示什么

643
00:24:02,000 --> 00:24:05,000
让他计算出两者的差异

644
00:24:05,000 --> 00:24:08,000
其实在 react 的 com 上

645
00:24:09,000 --> 00:24:12,000
没有人提到跟游戏上差异

646
00:24:12,000 --> 00:24:14,000
所以我有点

647
00:24:14,000 --> 00:24:17,000
就是自己在想在好奇

648
00:24:17,000 --> 00:24:19,000
说到底这个是一个殊途同归

649
00:24:19,000 --> 00:24:24,000
还是他们有真正的在游戏开发者身上

650
00:24:24,000 --> 00:24:25,000
提取灵感

651
00:24:25,000 --> 00:24:26,000
我更倾向于是

652
00:24:26,000 --> 00:24:29,000
相信是一个殊途同归的结果

653
00:24:29,000 --> 00:24:30,000
对我也觉得

654
00:24:30,000 --> 00:24:33,000
那个 Peter Hunt

655
00:24:33,000 --> 00:24:36,000
他在去年的介绍 react 的会议上面

656
00:24:36,000 --> 00:24:37,000
他就讲了

657
00:24:37,000 --> 00:24:39,000
就说他们做完发现

658
00:24:39,000 --> 00:24:41,000
他们做成了 3 D 游戏的时候

659
00:24:41,000 --> 00:24:43,000
好像也是用了同样一套思路

660
00:24:43,000 --> 00:24:43,000
没错

661
00:24:43,000 --> 00:24:46,000
其实确实是一个殊途同归的结果

662
00:24:46,000 --> 00:24:49,000
其实我相信现在的 web app 领域

663
00:24:49,000 --> 00:24:51,000
的很多技术可能在

664
00:24:53,000 --> 00:24:56,000
古早的 3 D 技术发展

665
00:24:56,000 --> 00:24:58,000
道路上都已经讨论过了

666
00:24:59,000 --> 00:25:04,000
然后有些经验可能也是会需要被 backport 过来的

667
00:25:06,000 --> 00:25:09,000
或者说其实我们把这个领域

668
00:25:09,000 --> 00:25:10,000
放得更宽广一点

669
00:25:10,000 --> 00:25:13,000
前端如果不仅限于网页

670
00:25:13,000 --> 00:25:15,000
或者是一个客户端的 app 的话

671
00:25:15,000 --> 00:25:17,000
其实游戏从某种意义上来讲

672
00:25:17,000 --> 00:25:19,000
也是在做一个前端的东西

673
00:25:21,000 --> 00:25:23,000
我觉得游戏可能最大的差别是

674
00:25:23,000 --> 00:25:29,000
它和它的前端和后端之间的差异

675
00:25:29,000 --> 00:25:31,000
它和前端和后端之间

676
00:25:31,000 --> 00:25:35,000
没有中间隔着这么巨大的一个互联网的鸿沟

677
00:25:35,000 --> 00:25:41,000
就是它中间的通讯没有这么大的一个延迟

678
00:25:41,000 --> 00:25:44,000
或者说有这么大的一个协议站摆在那边

679
00:25:45,000 --> 00:25:48,000
现在你很多游戏也是网络的 network game

680
00:25:48,000 --> 00:25:50,000
所以其实还是有很大相似点

681
00:25:50,000 --> 00:25:55,000
但那一部分仅仅是用来交互游戏数据的

682
00:25:55,000 --> 00:26:03,000
你的表现层的数据仍旧是在本地生成

683
00:26:03,000 --> 00:26:05,000
除非你是在做 streaming

684
00:26:05,000 --> 00:26:07,000
但是 streaming 又是另外一个话题

685
00:26:09,000 --> 00:26:10,000
对 这也是一个问题

686
00:26:11,000 --> 00:26:12,000
react 其实还有一点

687
00:26:12,000 --> 00:26:15,000
就是说它是更倾向于你使用所有的

688
00:26:15,000 --> 00:26:16,000
immutable data structure

689
00:26:16,000 --> 00:26:19,000
就是不可修改的数据结构

690
00:26:19,000 --> 00:26:22,000
这点上我们在 count 上有提到

691
00:26:23,000 --> 00:26:26,000
然后顺带说我非常喜欢

692
00:26:26,000 --> 00:26:29,000
我在 react count 上我真的非常高兴

693
00:26:29,000 --> 00:26:30,000
非常激动

694
00:26:30,000 --> 00:26:32,000
因为传统上来说

695
00:26:32,000 --> 00:26:35,000
前端不是一个很 hard core CS 的东西

696
00:26:35,000 --> 00:26:35,000
对吧

697
00:26:35,000 --> 00:26:38,000
你说大家一般看前端看法者

698
00:26:38,000 --> 00:26:40,000
都有一点小鄙视的意思

699
00:26:40,000 --> 00:26:41,000
对

700
00:26:42,000 --> 00:26:45,000
更加工程导向而不是理论导向

701
00:26:45,000 --> 00:26:47,000
更加 25 岁以下的导向

702
00:26:48,000 --> 00:26:49,000
不要这么黑

703
00:26:49,000 --> 00:26:51,000
不不不 我又想起来那个

704
00:26:52,000 --> 00:26:56,000
所以正是在这个 conference 上

705
00:26:56,000 --> 00:26:58,000
我们有听到很多很有意思的东西

706
00:26:58,000 --> 00:27:00,000
其中有一个是 immutable data

707
00:27:00,000 --> 00:27:00,000
对吧

708
00:27:02,000 --> 00:27:06,000
我们有一个演讲是 Lee Byron 给的演讲

709
00:27:06,000 --> 00:27:08,000
在专门说 immutable data

710
00:27:08,000 --> 00:27:11,000
就是 Facebook 的 immutable data

711
00:27:11,000 --> 00:27:13,000
Java School 实现

712
00:27:13,000 --> 00:27:15,000
他有讲到很多 immutable data

713
00:27:15,000 --> 00:27:17,000
到底是什么东西

714
00:27:18,000 --> 00:27:21,000
怎么在 Java School 上实现的非常好

715
00:27:21,000 --> 00:27:25,000
这是 back 到 react 上来说的话

716
00:27:25,000 --> 00:27:28,000
之所以 immutable data 是 preferred

717
00:27:28,000 --> 00:27:29,000
Not required but preferred

718
00:27:29,000 --> 00:27:33,000
是因为正因为 react 的设计方式

719
00:27:34,000 --> 00:27:35,000
整个的 renders 的过程

720
00:27:35,000 --> 00:27:37,000
整个的 component 实际上就是

721
00:27:37,000 --> 00:27:42,000
probs plus state equal to something

722
00:27:43,000 --> 00:27:45,000
这个 equal 是 renders 方式所做的事情

723
00:27:46,000 --> 00:27:47,000
所以如果你的 probs

724
00:27:47,000 --> 00:27:50,000
跟你的 state 不变化的话

725
00:27:50,000 --> 00:27:52,000
你的 renders result 总是一致的

726
00:27:53,000 --> 00:27:54,000
总会是一样的

727
00:27:54,000 --> 00:27:55,000
对

728
00:27:55,000 --> 00:27:57,000
虽然说 virtual DOM 会帮助你

729
00:27:57,000 --> 00:27:59,000
不去 update DOM

730
00:27:59,000 --> 00:28:06,000
但是如果连 renders 方式都不用去 run 的话

731
00:28:07,000 --> 00:28:11,000
那你就实现了更好的 performance

732
00:28:11,000 --> 00:28:12,000
然后省下更多的时间

733
00:28:12,000 --> 00:28:15,000
特别是在大型的 application 上

734
00:28:16,000 --> 00:28:19,000
但是怎么去判断 probs 跟 state

735
00:28:19,000 --> 00:28:20,000
有没有改变

736
00:28:20,000 --> 00:28:22,000
就变成一个很大的问题

737
00:28:22,000 --> 00:28:23,000
传统的 mutable data 的话

738
00:28:23,000 --> 00:28:25,000
就至少是个 ON 的操作

739
00:28:25,000 --> 00:28:25,000
对不对

740
00:28:26,000 --> 00:28:27,000
你必须得

741
00:28:27,000 --> 00:28:29,000
对你得逐个去比较

742
00:28:29,000 --> 00:28:31,000
必须得把整个 object 给变例来

743
00:28:31,000 --> 00:28:34,000
然后如果你要做 deep comparison 的话

744
00:28:34,000 --> 00:28:35,000
就更大了

745
00:28:35,000 --> 00:28:36,000
是一个竖状结构

746
00:28:38,000 --> 00:28:43,000
mutable data 实现了 constant time 的 comparison

747
00:28:43,000 --> 00:28:44,000
就是 01

748
00:28:45,000 --> 00:28:47,000
你只能判断一个指针吗

749
00:28:47,000 --> 00:28:47,000
等于说最重要

750
00:28:47,000 --> 00:28:53,000
是一个时间跟空间是花在其他的部分了

751
00:28:53,000 --> 00:28:54,000
但是在这个 renders 上

752
00:28:54,000 --> 00:28:57,000
就更有帮助

753
00:28:57,000 --> 00:28:58,000
非常快

754
00:28:58,000 --> 00:29:03,000
我们在跟其他的与会者讨论的时候

755
00:29:03,000 --> 00:29:05,000
也提到很多人

756
00:29:05,000 --> 00:29:08,000
就是一开始也没有用 mutable data

757
00:29:09,000 --> 00:29:11,000
但越用 react 越觉得说

758
00:29:11,000 --> 00:29:12,000
这个 total makes sense

759
00:29:12,000 --> 00:29:13,000
你要为什么不用呢

760
00:29:13,000 --> 00:29:14,000
对吧

761
00:29:15,000 --> 00:29:18,000
所以 mutable data 这个事情非常有意思

762
00:29:18,000 --> 00:29:19,000
就不是一个传统意乡

763
00:29:19,000 --> 00:29:21,000
java school 的人 care 的东西

764
00:29:22,000 --> 00:29:30,000
正因为对于 mutable data 的喜好

765
00:29:30,000 --> 00:29:34,000
才导致了 closure script 也叫 react 的行列

766
00:29:34,000 --> 00:29:37,000
因为 closure 它所有的 data 本来就是 mutable

767
00:29:37,000 --> 00:29:38,000
它是个 function language

768
00:29:38,000 --> 00:29:40,000
然后它所有的 data 都是 mutable 的

769
00:29:40,000 --> 00:29:42,000
所以就很 natural

770
00:29:42,000 --> 00:29:46,000
它的 framwork 就很好的利用这样一个特性

771
00:29:48,000 --> 00:29:48,000
对

772
00:29:48,000 --> 00:29:50,000
上次我看了一个 ome

773
00:29:50,000 --> 00:29:52,000
就是 closure script 写的 react 实现

774
00:29:53,000 --> 00:29:55,000
他们的性能确实非常了不得多

775
00:29:55,000 --> 00:29:56,000
因为刚才讲了

776
00:29:57,000 --> 00:29:59,000
因为在 ome 里面整个

777
00:29:59,000 --> 00:30:03,000
大部分的 data structure 都是所有的 mutable 的话

778
00:30:03,000 --> 00:30:07,000
他们在渲染的时候真的就足够走树状结构

779
00:30:07,000 --> 00:30:10,000
然后判断根节点的指针的就好了

780
00:30:10,000 --> 00:30:12,000
这是非常快速的一个过程

781
00:30:14,000 --> 00:30:17,000
顺带说在整个 conference 中

782
00:30:17,000 --> 00:30:20,000
我们有提到非常多的 performance trick

783
00:30:20,000 --> 00:30:22,000
怎么样实现更好的 performance

784
00:30:22,000 --> 00:30:23,000
mutable 是其中之一

785
00:30:23,000 --> 00:30:25,000
我们有提到很多其他的东西

786
00:30:25,000 --> 00:30:28,000
如果观众听众朋友们有兴趣的话

787
00:30:28,000 --> 00:30:30,000
可以找到这些 keynote

788
00:30:30,000 --> 00:30:31,000
也可以写信问我

789
00:30:31,000 --> 00:30:33,000
或者告诉 real

790
00:30:33,000 --> 00:30:37,000
我们说不定下期可以做更多关于 react 的

791
00:30:37,000 --> 00:30:39,000
更细节更优化的东西

792
00:30:41,000 --> 00:30:45,000
对怎么过他们看现场视频

793
00:30:45,000 --> 00:30:46,000
现在跟他说一下

794
00:30:46,000 --> 00:30:49,000
这次的 reactconf 2015 的所有的视频

795
00:30:49,000 --> 00:30:52,000
都在 youtube 上面有的

796
00:30:52,000 --> 00:30:56,000
但是因为现在国内 VPN 也打击的比较严重

797
00:30:56,000 --> 00:30:57,000
能不能看到就不好说了

798
00:30:57,000 --> 00:31:00,000
他不是所有都在吧

799
00:31:00,000 --> 00:31:01,000
好像可以吧

800
00:31:01,000 --> 00:31:02,000
我在看

801
00:31:02,000 --> 00:31:08,000
因为 youtube 上有个频道叫做 facebook developer 的频道

802
00:31:08,000 --> 00:31:10,000
然后这个 channel 上基本上

803
00:31:10,000 --> 00:31:12,000
应该你需要的都可以看到

804
00:31:13,000 --> 00:31:14,000
我就说国内的

805
00:31:14,000 --> 00:31:15,000
我们听众很多人在国内

806
00:31:15,000 --> 00:31:19,000
他们没有办法去上这个 youtube

807
00:31:19,000 --> 00:31:21,000
这个东西我觉得要 facts check 一下

808
00:31:21,000 --> 00:31:24,000
我好像只有他只有三个

809
00:31:24,000 --> 00:31:25,000
只有那个 relay

810
00:31:25,000 --> 00:31:27,000
他有那 imutable.js 的那 kina 吗

811
00:31:27,000 --> 00:31:29,000
他现在他在逐渐放

812
00:31:29,000 --> 00:31:33,000
他已经我觉得他应该可能还是在做一些剪辑之类的工作

813
00:31:33,000 --> 00:31:36,000
对他最终是要他要全部放上去

814
00:31:36,000 --> 00:31:38,000
他没有理由不放出来

815
00:31:38,000 --> 00:31:39,000
因为

816
00:31:39,000 --> 00:31:40,000
对

817
00:31:40,000 --> 00:31:42,000
反正一共是有多少个

818
00:31:42,000 --> 00:31:43,000
一个是多少个 talk 来的

819
00:31:43,000 --> 00:31:45,000
有两天是

820
00:31:45,000 --> 00:31:46,000
12 个还是 9 个

821
00:31:46,000 --> 00:31:47,000
anyways

822
00:31:48,000 --> 00:31:50,000
就是讲 facts check 一下

823
00:31:50,000 --> 00:31:51,000
没有其他意思

824
00:31:52,000 --> 00:31:53,000
有的

825
00:31:53,000 --> 00:31:54,000
不用担心

826
00:31:57,000 --> 00:31:59,000
然后其实说到 react

827
00:31:59,000 --> 00:32:05,000
我们传统上一般认为他是在 MVC 里面做的 V 的角色对吧

828
00:32:05,000 --> 00:32:06,000
对

829
00:32:07,000 --> 00:32:08,000
但是我们传统一个 MVC 的话

830
00:32:09,000 --> 00:32:11,000
像 M 和 C 那部分怎么解决

831
00:32:11,000 --> 00:32:12,000
其实

832
00:32:12,000 --> 00:32:16,000
在相当长的时间内还是没有很好的一个方案吧

833
00:32:16,000 --> 00:32:18,000
但是去年年末的时候

834
00:32:18,000 --> 00:32:22,000
他们公开了一个叫做 flux 的这么一个架构吧

835
00:32:22,000 --> 00:32:25,000
也不算是一个就是一个指导方针

836
00:32:25,000 --> 00:32:31,000
只能说是就是你怎么去用 react 方式去构建一个传统的 MVC 的实现的时候

837
00:32:31,000 --> 00:32:32,000
你要注意一下什么样问题

838
00:32:32,000 --> 00:32:35,000
这个 flux 我觉得也是一个非常

839
00:32:35,000 --> 00:32:36,000
具有

840
00:32:36,000 --> 00:32:37,000
什么

841
00:32:38,000 --> 00:32:40,000
话实在意义的一个方式

842
00:32:40,000 --> 00:32:40,000
就刚刚讲的

843
00:32:40,000 --> 00:32:41,000
真的吗

844
00:32:41,000 --> 00:32:43,000
我怎么记得就是 flux 出来的时候

845
00:32:43,000 --> 00:32:47,000
黑客 news 有人黑说他们 rediscover 了一个非常古老的 idea

846
00:32:47,000 --> 00:32:48,000
然后把它

847
00:32:49,000 --> 00:32:50,000
重新包装了一遍

848
00:32:50,000 --> 00:32:52,000
然后改名叫 flux

849
00:32:52,000 --> 00:32:54,000
但其实在起码在前端开发名义

850
00:32:54,000 --> 00:32:56,000
它确实是一个挺好的事情

851
00:32:56,000 --> 00:32:56,000
我觉得

852
00:32:57,000 --> 00:33:01,000
其实这一点上我跟吴涛所说的有一点类似

853
00:33:01,000 --> 00:33:03,000
我至今也觉得 flux 的

854
00:33:04,000 --> 00:33:05,000
idea 实际

855
00:33:06,000 --> 00:33:06,000
怎么说

856
00:33:06,000 --> 00:33:08,000
我如果看历史的话

857
00:33:08,000 --> 00:33:11,000
我有看所有的 flux 的 video 这些东西

858
00:33:11,000 --> 00:33:12,000
你看的话

859
00:33:12,000 --> 00:33:16,000
flux 要解决的问题

860
00:33:16,000 --> 00:33:18,000
并不是真正的 MVC

861
00:33:18,000 --> 00:33:19,000
我觉得他们

862
00:33:20,000 --> 00:33:23,000
在最初在 invent 这个 flux 的时候

863
00:33:23,000 --> 00:33:26,000
他们所使用的做事情的方式

864
00:33:26,000 --> 00:33:28,000
并不是真正的 MVC

865
00:33:29,000 --> 00:33:31,000
但这并不是说 flux 不好

866
00:33:31,000 --> 00:33:35,000
不是因此 flux 这个框架就不对

867
00:33:35,000 --> 00:33:36,000
这我

868
00:33:38,000 --> 00:33:40,000
很有意思的是在 reactconf 上

869
00:33:41,000 --> 00:33:43,000
那些 speaker 反复的提到

870
00:33:44,000 --> 00:33:47,000
他们最初发布 react 的时候大家的反应

871
00:33:48,000 --> 00:33:54,000
最初发布 react 是在 JSCONS 的 2013 年的 JSCONS 上

872
00:33:55,000 --> 00:33:56,000
但反应都非常 negative

873
00:33:56,000 --> 00:33:59,000
就是说 reinvented the view

874
00:33:59,000 --> 00:34:01,000
yeah we reinvented the wheel

875
00:34:01,000 --> 00:34:03,000
reinvented the best practices

876
00:34:05,000 --> 00:34:07,000
后来 Pete Hunt 甚至给了一个

877
00:34:08,000 --> 00:34:12,000
rethinking best practices 的一个 speech

878
00:34:13,000 --> 00:34:13,000
所以

879
00:34:15,000 --> 00:34:17,000
上完这个会

880
00:34:17,000 --> 00:34:20,000
我也是觉得大家还是保持一个开放的心态

881
00:34:20,000 --> 00:34:21,000
也不需要去 hate 他或者怎么样

882
00:34:21,000 --> 00:34:24,000
毕竟说我们也不能够就是

883
00:34:25,000 --> 00:34:26,000
怎么说就是

884
00:34:26,000 --> 00:34:29,000
默守成规一定说之前东西就是好的

885
00:34:29,000 --> 00:34:32,000
如果 flux 能够解决你所要解决的问题

886
00:34:32,000 --> 00:34:34,000
如果 flux 能够解决 Facebook 所要解决的问题

887
00:34:34,000 --> 00:34:36,000
你清楚你的问题是什么

888
00:34:36,000 --> 00:34:37,000
我觉得这才是最重要的

889
00:34:37,000 --> 00:34:37,000
对不对

890
00:34:38,000 --> 00:34:40,000
所以 back 到 flux 上来说

891
00:34:40,000 --> 00:34:44,000
它实际上跟传统意义上的 MVC 有非常多的相似的地方

892
00:34:45,000 --> 00:34:46,000
它整个的 dispatcher mode

893
00:34:46,000 --> 00:34:50,000
整个的这个 event 的流程

894
00:34:50,000 --> 00:34:53,000
这个单向的信息的流动

895
00:34:53,000 --> 00:34:57,000
实际上跟传统意义上的 MVC 是非常非常类似的

896
00:34:57,000 --> 00:34:59,000
但它有细节上的差异

897
00:34:59,000 --> 00:35:01,000
比方说 action 是 global 的

898
00:35:01,000 --> 00:35:03,000
dispatcher 是 global 的

899
00:35:03,000 --> 00:35:08,000
比方说在一个信息没有流完的情况下

900
00:35:08,000 --> 00:35:10,000
你不能够 initialize 另外一个信息

901
00:35:10,000 --> 00:35:13,000
像这样的细节的差异实际上是

902
00:35:13,000 --> 00:35:18,000
实际上就意味着 flux 跟传统的 MVC 不一样

903
00:35:18,000 --> 00:35:20,000
特别是在

904
00:35:20,000 --> 00:35:20,000
对

905
00:35:20,000 --> 00:35:22,000
你知道比方说如果我们用 backbone

906
00:35:23,000 --> 00:35:27,000
如果 model 触发一个 change event

907
00:35:27,000 --> 00:35:29,000
这个 change event 的 event handler

908
00:35:29,000 --> 00:35:31,000
是可以再去改变这个 model

909
00:35:31,000 --> 00:35:34,000
然后从而就产生另外一个 change event

910
00:35:34,000 --> 00:35:38,000
它有 cascading 的效果在

911
00:35:38,000 --> 00:35:44,000
flux 的发明跟 cascading 非常有关系

912
00:35:44,000 --> 00:35:46,000
一个重点的原因

913
00:35:46,000 --> 00:35:49,000
要他们去发明 flux 就是不想要 cascading

914
00:35:49,000 --> 00:35:51,000
你看这样细小的一些

915
00:35:51,000 --> 00:35:52,000
因为太难管理

916
00:35:52,000 --> 00:35:54,000
你不知道发生什么

917
00:35:54,000 --> 00:35:55,000
你不知道发生什么

918
00:35:55,000 --> 00:35:59,000
就好像 react

919
00:35:59,000 --> 00:36:00,000
它本身

920
00:36:03,000 --> 00:36:08,000
想要把 code 更 declinative 化

921
00:36:08,000 --> 00:36:10,000
flux 也有这样的目的

922
00:36:10,000 --> 00:36:12,000
就是让 flow 更清晰

923
00:36:12,000 --> 00:36:15,000
每次你的 action 都是导致同一个结果

924
00:36:15,000 --> 00:36:16,000
同一个方向流动

925
00:36:16,000 --> 00:36:17,000
然后你的那个

926
00:36:18,000 --> 00:36:21,000
你不会触发另外一个

927
00:36:21,000 --> 00:36:22,000
所没有预料到的结果

928
00:36:22,000 --> 00:36:23,000
这点上

929
00:36:24,000 --> 00:36:25,000
如果你真正去用 flux 的话

930
00:36:25,000 --> 00:36:28,000
会发现实际上是非常有帮助的

931
00:36:28,000 --> 00:36:31,000
对你管理你的程序的复杂度

932
00:36:33,000 --> 00:36:34,000
我个人感觉

933
00:36:34,000 --> 00:36:37,000
我之前是在做一些小的 project

934
00:36:37,000 --> 00:36:40,000
去尝试用 flux 这种架构

935
00:36:40,000 --> 00:36:42,000
当然我具体用的是一个叫做 reflux

936
00:36:42,000 --> 00:36:43,000
的一个具体的实现

937
00:36:43,000 --> 00:36:45,000
但是它在逻辑上是大同小异的

938
00:36:45,000 --> 00:36:49,000
就是有些细微的组件上有点不一样

939
00:36:49,000 --> 00:36:50,000
我感觉有很明显的区别

940
00:36:50,000 --> 00:36:54,000
就是说采用了 flux 架构之后

941
00:36:54,000 --> 00:36:57,000
整个前端应用的逻辑

942
00:36:57,000 --> 00:36:59,000
变得非常有条理和清晰

943
00:36:59,000 --> 00:37:01,000
就知道边界在哪里

944
00:37:01,000 --> 00:37:03,000
然后哪些数据在哪里管理

945
00:37:03,000 --> 00:37:04,000
就最开始的时候

946
00:37:04,000 --> 00:37:06,000
你提到像用 backbond 的时候

947
00:37:06,000 --> 00:37:08,000
有些数据是混在 Dome 里面的

948
00:37:08,000 --> 00:37:08,000
对吧

949
00:37:08,000 --> 00:37:10,000
这样其实这如果你用 flux 这种方式

950
00:37:10,000 --> 00:37:12,000
就其实完全分离开了

951
00:37:12,000 --> 00:37:14,000
它有所谓的 store 的概念

952
00:37:14,000 --> 00:37:18,000
就大约略等同于以前 MVC 里面 model

953
00:37:18,000 --> 00:37:20,000
但是说它的 store 里面

954
00:37:20,000 --> 00:37:22,000
它有一些具体的限制

955
00:37:22,000 --> 00:37:24,000
刚才比如说你不能说 store

956
00:37:24,000 --> 00:37:27,000
触发 cascading 的东西出来

957
00:37:27,000 --> 00:37:28,000
这样其实然后就可以保证

958
00:37:28,000 --> 00:37:31,000
你这个信息的流向是单向的

959
00:37:31,000 --> 00:37:33,000
对这样的话

960
00:37:33,000 --> 00:37:35,000
就可以让你很方便的去把这个

961
00:37:35,000 --> 00:37:37,000
所谓的 separation of concern

962
00:37:37,000 --> 00:37:39,000
就是把那些需要关注的点证风格

963
00:37:39,000 --> 00:37:40,000
开来做

964
00:37:40,000 --> 00:37:44,000
对整个架构是很有帮助的一个工具

965
00:37:44,000 --> 00:37:47,000
然后 flux 其实从 facebook 的角度

966
00:37:47,000 --> 00:37:50,000
来说的话实际上只是一个 idea

967
00:37:50,000 --> 00:37:53,000
它对你到底说你的 dispatch 是什么

968
00:37:53,000 --> 00:37:54,000
你的 action 是什么

969
00:37:54,000 --> 00:37:56,000
你的 storage 是怎么实现的

970
00:37:56,000 --> 00:37:59,000
并没有很严格意义上的管理

971
00:38:00,000 --> 00:38:01,000
就是因为如此

972
00:38:02,000 --> 00:38:06,000
像我们在做从 back 到 react 的

973
00:38:06,000 --> 00:38:07,000
一个迁移

974
00:38:07,000 --> 00:38:09,000
从一定程度上来说

975
00:38:09,000 --> 00:38:11,000
我可以用传统的 backbone model

976
00:38:11,000 --> 00:38:14,000
backbone collection 来实现 flux

977
00:38:14,000 --> 00:38:15,000
这是可能的

978
00:38:15,000 --> 00:38:16,000
这是完全可能的

979
00:38:19,000 --> 00:38:21,000
所以就是

980
00:38:21,000 --> 00:38:24,000
again 不要拘泥于书本上的概念

981
00:38:25,000 --> 00:38:25,000
去想一想

982
00:38:25,000 --> 00:38:27,000
你需要解决的问题

983
00:38:27,000 --> 00:38:28,000
然后去看一看

984
00:38:28,000 --> 00:38:29,000
这个 architecture

985
00:38:29,000 --> 00:38:30,000
到底能不能解决这个问题

986
00:38:31,000 --> 00:38:32,000
才是最重要的

987
00:38:32,000 --> 00:38:35,000
而且 flux 可能在一定程度上来说

988
00:38:35,000 --> 00:38:38,000
只有对大型的 application 才有意义

989
00:38:38,000 --> 00:38:40,000
你要想 facebook 所要解决的问题

990
00:38:40,000 --> 00:38:42,000
是 massive skill

991
00:38:42,000 --> 00:38:42,000
对不对

992
00:38:42,000 --> 00:38:44,000
他们有 hundreds of engineer

993
00:38:44,000 --> 00:38:44,000
对

994
00:38:44,000 --> 00:38:45,000
如果你只有一两个人

995
00:38:45,000 --> 00:38:48,000
在一个程序上工作的话

996
00:38:48,000 --> 00:38:49,000
那或许有更轻巧

997
00:38:50,000 --> 00:38:51,000
更便宜的

998
00:38:52,000 --> 00:38:54,000
这样你能够选择

999
00:38:54,000 --> 00:38:55,000
对可能用不上

1000
00:38:55,000 --> 00:38:56,000
用使用这种

1001
00:38:56,000 --> 00:38:58,000
就所谓大规模闪闪性的武器

1002
00:39:03,000 --> 00:39:05,000
react 还有一个好处

1003
00:39:05,000 --> 00:39:07,000
就是说所谓构建

1004
00:39:07,000 --> 00:39:09,000
ISOMOFIC 的 JavaScript

1005
00:39:09,000 --> 00:39:10,000
的应用的情况

1006
00:39:10,000 --> 00:39:11,000
还是比较好的

1007
00:39:11,000 --> 00:39:12,000
因为它可以

1008
00:39:12,000 --> 00:39:14,000
同样的一个 react 组件

1009
00:39:14,000 --> 00:39:15,000
只要你构建的方式

1010
00:39:15,000 --> 00:39:17,000
稍微注意一点点

1011
00:39:17,000 --> 00:39:20,000
它是可以在客户端线

1012
00:39:20,000 --> 00:39:22,000
或者是在服务端渲染

1013
00:39:22,000 --> 00:39:23,000
然后在服务端渲染

1014
00:39:23,000 --> 00:39:24,000
它有一个什么好处

1015
00:39:24,000 --> 00:39:25,000
它可以在服务端渲染

1016
00:39:25,000 --> 00:39:28,000
从最初的页面结构之后

1017
00:39:28,000 --> 00:39:30,000
你把这个送给浏览器

1018
00:39:30,000 --> 00:39:32,000
然后在浏览器再接着

1019
00:39:32,000 --> 00:39:35,000
服务端渲染那个部分开始

1020
00:39:35,000 --> 00:39:37,000
再完成后面的后续的工作

1021
00:39:37,000 --> 00:39:38,000
这个我不太清楚

1022
00:39:38,000 --> 00:39:40,000
就是之前有其他类型的框架

1023
00:39:40,000 --> 00:39:42,000
实现过这种功能没

1024
00:39:42,000 --> 00:39:44,000
但是我第一次看到这个时候

1025
00:39:44,000 --> 00:39:45,000
觉得还是蛮惊奇的

1026
00:39:46,000 --> 00:39:47,000
As far as I know

1027
00:39:48,000 --> 00:39:51,000
如果你小心翼翼的写你的 APP 的话

1028
00:39:51,000 --> 00:39:53,000
是有可能用其他的框架

1029
00:39:53,000 --> 00:39:56,000
加上 PhantomJS 这种 Headless WebKit

1030
00:39:56,000 --> 00:39:58,000
来实现相同的功能

1031
00:39:58,000 --> 00:40:00,000
我觉得理论上是有可能的

1032
00:40:01,000 --> 00:40:03,000
但是在

1033
00:40:03,000 --> 00:40:04,000
这个太高了

1034
00:40:04,000 --> 00:40:04,000
Exactly

1035
00:40:04,000 --> 00:40:06,000
就性能上的话还会损失很多

1036
00:40:06,000 --> 00:40:08,000
因为你毕竟要 run 一个

1037
00:40:08,000 --> 00:40:10,000
WebKit 在你的 server 上

1038
00:40:10,000 --> 00:40:11,000
PhantomJS 发展到现在

1039
00:40:11,000 --> 00:40:14,000
实际上也解决了非常多的问题

1040
00:40:14,000 --> 00:40:15,000
它变成了一个 server

1041
00:40:15,000 --> 00:40:16,000
而不是你每次都要

1042
00:40:17,000 --> 00:40:18,000
put 那个 overhead

1043
00:40:18,000 --> 00:40:21,000
去 run 这个 WebKit 在里头

1044
00:40:22,000 --> 00:40:25,000
当然 react 有更大的可能性

1045
00:40:25,000 --> 00:40:27,000
因为毕竟那个 DOM 是 virtualized

1046
00:40:27,000 --> 00:40:28,000
所以

1047
00:40:28,000 --> 00:40:30,000
对它不需要去 load 一个

1048
00:40:30,000 --> 00:40:31,000
真正的 WebKit 的引擎

1049
00:40:31,000 --> 00:40:33,000
它只需要在 Yaml Stream 内部去

1050
00:40:33,000 --> 00:40:36,000
虚构一个这么一个 DOM 结构就好

1051
00:40:36,000 --> 00:40:39,000
这次我们在 conference 上有听到

1052
00:40:39,000 --> 00:40:42,000
很多公司谈到这个他们的应用

1053
00:40:42,000 --> 00:40:43,000
大部分的原因

1054
00:40:43,000 --> 00:40:44,000
也不是因为性能

1055
00:40:44,000 --> 00:40:45,000
而是因为

1056
00:40:45,000 --> 00:40:46,000
CEO

1057
00:40:46,000 --> 00:40:48,000
很多公司很关心 CEO

1058
00:40:48,000 --> 00:40:51,000
然后现在 JavaScript SEO

1059
00:40:51,000 --> 00:40:54,000
还是一个没能解决问题

1060
00:40:54,000 --> 00:40:55,000
惊喜我

1061
00:40:55,000 --> 00:40:56,000
过去这么多年了

1062
00:40:56,000 --> 00:40:58,000
仍旧是一个

1063
00:40:58,000 --> 00:40:59,000
疯狂的问题

1064
00:40:59,000 --> 00:41:03,000
有公司提到说

1065
00:41:04,000 --> 00:41:08,000
你知道 Google 有一个 convention

1066
00:41:09,000 --> 00:41:11,000
如果你的 URL 是一个

1067
00:41:11,000 --> 00:41:12,000
特别的什么结构的话

1068
00:41:12,000 --> 00:41:17,000
它会尝试去 fetch 另外一个 URL

1069
00:41:17,000 --> 00:41:19,000
which is supposed to be a static page

1070
00:41:19,000 --> 00:41:20,000
但是

1071
00:41:21,000 --> 00:41:23,000
according to some other companies

1072
00:41:24,000 --> 00:41:25,000
这个功能非常

1073
00:41:26,000 --> 00:41:27,000
Google 不怎么在意这个功能

1074
00:41:27,000 --> 00:41:28,000
然后经常就坏掉

1075
00:41:28,000 --> 00:41:30,000
所以它们经常

1076
00:41:30,000 --> 00:41:33,000
经常就是那个 fetch rate

1077
00:41:33,000 --> 00:41:34,000
到抓不到 0 你知道吗

1078
00:41:34,000 --> 00:41:35,000
就是对于公司来说

1079
00:41:35,000 --> 00:41:36,000
这是一个 disaster

1080
00:41:36,000 --> 00:41:38,000
他们很多公司都是

1081
00:41:38,000 --> 00:41:40,000
就很靠 Google 流量

1082
00:41:40,000 --> 00:41:42,000
如果说有这样一个问题的话

1083
00:41:42,000 --> 00:41:45,000
对他们的 business critical

1084
00:41:45,000 --> 00:41:47,000
所以他们就

1085
00:41:47,000 --> 00:41:48,000
就是电达西扣

1086
00:41:48,000 --> 00:41:49,000
非常在意

1087
00:41:49,000 --> 00:41:52,000
这个 asomorphic 的可能性

1088
00:41:53,000 --> 00:41:53,000
对

1089
00:41:53,000 --> 00:41:55,000
而且之前说 Google 说

1090
00:41:55,000 --> 00:41:57,000
它说一干一准是一种方式

1091
00:41:57,000 --> 00:41:59,000
通过一种特殊的 URL 结构去说

1092
00:41:59,000 --> 00:42:01,000
告知 Google 的爬虫

1093
00:42:01,000 --> 00:42:02,000
我这个动态网页

1094
00:42:02,000 --> 00:42:04,000
你可以在另外一个地址

1095
00:42:04,000 --> 00:42:05,000
找到它的静态版本

1096
00:42:05,000 --> 00:42:07,000
这是一个比较传统的解决方案

1097
00:42:07,000 --> 00:42:08,000
然后 Google 是

1098
00:42:08,000 --> 00:42:10,000
应该是去年年末的时候

1099
00:42:10,000 --> 00:42:11,000
它是说

1100
00:42:12,000 --> 00:42:14,000
他们也会渲染 JavaScript 的页面

1101
00:42:14,000 --> 00:42:15,000
就是它会当

1102
00:42:15,000 --> 00:42:17,000
把自己模拟成一个

1103
00:42:18,000 --> 00:42:18,000
浏览器

1104
00:42:19,000 --> 00:42:21,000
一个浏览器的引擎

1105
00:42:21,000 --> 00:42:23,000
去解析那个页面的 JavaScript 引擎

1106
00:42:23,000 --> 00:42:24,000
但是现在问题就是说

1107
00:42:24,000 --> 00:42:26,000
它没有办法去判断哪些东西

1108
00:42:26,000 --> 00:42:27,000
是可以点的

1109
00:42:27,000 --> 00:42:28,000
因为你知道浏览器

1110
00:42:28,000 --> 00:42:29,000
就是 JavaScript 里面的

1111
00:42:29,000 --> 00:42:30,000
很多可以点击

1112
00:42:30,000 --> 00:42:32,000
可以 navigate 的项目

1113
00:42:32,000 --> 00:42:33,000
它并不像

1114
00:42:33,000 --> 00:42:35,000
说网页上你是有个 A 的

1115
00:42:35,000 --> 00:42:36,000
那种 anchored tag

1116
00:42:36,000 --> 00:42:38,000
可以去很明显的发现

1117
00:42:38,000 --> 00:42:38,000
对吧

1118
00:42:38,000 --> 00:42:40,000
所以其实对他们来讲

1119
00:42:40,000 --> 00:42:41,000
速度引擎去

1120
00:42:41,000 --> 00:42:43,000
发现这些动态的内容

1121
00:42:43,000 --> 00:42:44,000
始终是有问题的

1122
00:42:45,000 --> 00:42:46,000
所以在这种情况下

1123
00:42:46,000 --> 00:42:48,000
那种 Aesomorphic 的

1124
00:42:48,000 --> 00:42:50,000
还是不可避免

1125
00:42:50,000 --> 00:42:51,000
然后我的感觉就是说

1126
00:42:51,000 --> 00:42:53,000
用 React 这种方式

1127
00:42:53,000 --> 00:42:54,000
来实现 Aesomorphic 的话

1128
00:42:54,000 --> 00:42:56,000
它的难度是相

1129
00:42:56,000 --> 00:42:58,000
就极大的被降低了

1130
00:42:58,000 --> 00:43:00,000
就是相对于你之前手工的去

1131
00:43:00,000 --> 00:43:01,000
要么用 FantomJS

1132
00:43:01,000 --> 00:43:03,000
去做一个这个什么 Render Farm

1133
00:43:03,000 --> 00:43:04,000
手工的去渲染一下

1134
00:43:04,000 --> 00:43:06,000
用这个比较高成本

1135
00:43:06,000 --> 00:43:07,000
然后另外就是说

1136
00:43:07,000 --> 00:43:09,000
它可以实现所谓的无缝迁移

1137
00:43:09,000 --> 00:43:10,000
就是你可以随意决定

1138
00:43:10,000 --> 00:43:12,000
哪一部分是在服务端渲染

1139
00:43:12,000 --> 00:43:13,000
然后哪一部分是在

1140
00:43:14,000 --> 00:43:15,000
这个客户端渲染

1141
00:43:15,000 --> 00:43:17,000
这个是非常不错的一个工具

1142
00:43:17,000 --> 00:43:19,000
刚刚 Rio 做了一个非常好的总结

1143
00:43:21,000 --> 00:43:23,000
在实际的应用中

1144
00:43:23,000 --> 00:43:26,000
React 可能是最好的 balance

1145
00:43:26,000 --> 00:43:29,000
就是性能跟可管理性最好的 balance

1146
00:43:29,000 --> 00:43:31,000
如果你的应用场景是

1147
00:43:31,000 --> 00:43:35,000
你又要需要非常好的 performance 的话

1148
00:43:35,000 --> 00:43:38,000
那或许你应该去看

1149
00:43:38,000 --> 00:43:39,000
其他的一些选项

1150
00:43:39,000 --> 00:43:42,000
比方说用共用 template

1151
00:43:42,000 --> 00:43:44,000
而不是共用 Java SuperLogic

1152
00:43:44,000 --> 00:43:46,000
然后在服务器端

1153
00:43:46,000 --> 00:43:48,000
用服务器的 native language

1154
00:43:48,000 --> 00:43:49,000
whatever

1155
00:43:49,000 --> 00:43:50,000
php 或 java

1156
00:43:51,000 --> 00:43:54,000
来写 template 的 Render Function

1157
00:43:54,000 --> 00:43:55,000
这样的话

1158
00:43:55,000 --> 00:43:57,000
你要写两个 Rendering 的

1159
00:43:58,000 --> 00:43:59,000
application

1160
00:44:00,000 --> 00:44:03,000
在你的工程上是更麻烦

1161
00:44:03,000 --> 00:44:05,000
但是如果你要追求性能的话

1162
00:44:05,000 --> 00:44:07,000
那是一个更好的选项

1163
00:44:07,000 --> 00:44:09,000
React 现在的问题是在于说

1164
00:44:10,000 --> 00:44:13,000
即使你在服务器端渲染

1165
00:44:13,000 --> 00:44:16,000
React 还是会给你做很多

1166
00:44:16,000 --> 00:44:18,000
不必要的 DOM 的操作

1167
00:44:19,000 --> 00:44:20,000
或者是模拟

1168
00:44:20,000 --> 00:44:23,000
有什么具体的情况

1169
00:44:23,000 --> 00:44:24,000
as a result

1170
00:44:24,000 --> 00:44:27,000
有公司做了测试

1171
00:44:27,000 --> 00:44:28,000
然后 as a result

1172
00:44:28,000 --> 00:44:29,000
相对于说

1173
00:44:29,000 --> 00:44:30,000
就是我刚刚说的那个

1174
00:44:30,000 --> 00:44:34,000
用 php 来 Render 这个 template 的话

1175
00:44:34,000 --> 00:44:38,000
它的输出率只有 template 的

1176
00:44:39,000 --> 00:44:42,000
大概 25%

1177
00:44:43,000 --> 00:44:44,000
差这么多吗

1178
00:44:44,000 --> 00:44:45,000
这是非常可以优化的

1179
00:44:45,000 --> 00:44:47,000
因为有很多 DOM 的

1180
00:44:48,000 --> 00:44:49,000
比方说 Event Handling

1181
00:44:49,000 --> 00:44:50,000
这些东西

1182
00:44:50,000 --> 00:44:52,000
在服务器端都没有必要去关联了

1183
00:44:52,000 --> 00:44:53,000
对吧

1184
00:44:54,000 --> 00:44:56,000
因为你最终只需要一个静态的页面

1185
00:44:56,000 --> 00:44:57,000
你只需要静态的结果

1186
00:44:57,000 --> 00:44:58,000
但是

1187
00:44:59,000 --> 00:45:01,000
这就是一个 open source project

1188
00:45:01,000 --> 00:45:02,000
很有趣的地方了

1189
00:45:03,000 --> 00:45:05,000
Facebook 本身对这个没有太大的兴趣

1190
00:45:05,000 --> 00:45:07,000
因为它没有太大的需求

1191
00:45:08,000 --> 00:45:10,000
但是如果其他公司或者是你

1192
00:45:11,000 --> 00:45:13,000
我们听众对此有需求的话

1193
00:45:13,000 --> 00:45:14,000
可以去看他们的 source code

1194
00:45:14,000 --> 00:45:18,000
然后对 Virtual DOM 做出一些修改

1195
00:45:18,000 --> 00:45:19,000
来实现更好的

1196
00:45:19,000 --> 00:45:21,000
在优先上 Render 的功能

1197
00:45:21,000 --> 00:45:23,000
我想这个潜力是非常大的

1198
00:45:23,000 --> 00:45:26,000
因为它现在基本上是没有任何优化的

1199
00:45:26,000 --> 00:45:27,000
对

1200
00:45:27,000 --> 00:45:29,000
在这种情况下还是挺好我觉得

1201
00:45:30,000 --> 00:45:33,000
说到这个 React 在实际使用的时候

1202
00:45:33,000 --> 00:45:36,000
就会牵涉到一个很有意思的

1203
00:45:36,000 --> 00:45:38,000
它的写法或者一个语言

1204
00:45:38,000 --> 00:45:39,000
叫做 JSX

1205
00:45:40,000 --> 00:45:41,000
就是什么概念呢

1206
00:45:41,000 --> 00:45:42,000
就是说因为我们是在

1207
00:45:42,000 --> 00:45:45,000
在传统上我们写一个前端应用的时候

1208
00:45:45,000 --> 00:45:47,000
我们是把这个模板和这个数据

1209
00:45:47,000 --> 00:45:49,000
或者是逻辑完全分离开来的

1210
00:45:50,000 --> 00:45:51,000
就模板可能会是用什么

1211
00:45:51,000 --> 00:45:53,000
什么 Mustache 之类的一些东西

1212
00:45:53,000 --> 00:45:55,000
来用 HTML 来写一个模板

1213
00:45:55,000 --> 00:45:56,000
然后留些空

1214
00:45:56,000 --> 00:45:58,000
然后当那个 JavaScript 去把模板

1215
00:45:58,000 --> 00:46:00,000
这个 Load 出来

1216
00:46:00,000 --> 00:46:01,000
然后把那个空填上

1217
00:46:01,000 --> 00:46:03,000
就扔的出一个进他的页面

1218
00:46:03,000 --> 00:46:06,000
再发给出去填到页面里面去

1219
00:46:06,000 --> 00:46:08,000
但是在 React 里面去

1220
00:46:08,000 --> 00:46:10,000
他们推荐的方式是说

1221
00:46:10,000 --> 00:46:13,000
不要区分这个模板和这个数据和逻辑

1222
00:46:13,000 --> 00:46:14,000
你是做一个前端应用

1223
00:46:14,000 --> 00:46:16,000
你的这个模板就是你的

1224
00:46:16,000 --> 00:46:18,000
这个要核心要考虑的一部分

1225
00:46:18,000 --> 00:46:19,000
我觉得这是 React 的

1226
00:46:19,000 --> 00:46:22,000
Rethink best practices 的一部分

1227
00:46:23,000 --> 00:46:24,000
理论上来说

1228
00:46:24,000 --> 00:46:26,000
我们之前做 Molo 的那个 best practices

1229
00:46:26,000 --> 00:46:28,000
是说把模板分离开来

1230
00:46:28,000 --> 00:46:28,000
这样的话

1231
00:46:28,000 --> 00:46:30,000
你有更好的重用性

1232
00:46:30,000 --> 00:46:32,000
因为你那个模板是可以被重用的

1233
00:46:32,000 --> 00:46:32,000
对吧

1234
00:46:32,000 --> 00:46:32,000
对

1235
00:46:33,000 --> 00:46:35,000
可是如果你看 JSX

1236
00:46:35,000 --> 00:46:36,000
它实际上不是一个模板

1237
00:46:36,000 --> 00:46:37,000
它完全不是一个模板

1238
00:46:37,000 --> 00:46:39,000
你其实就是写 JavaScript code

1239
00:46:39,000 --> 00:46:41,000
你所写的

1240
00:46:41,000 --> 00:46:43,000
你只不过是用一种类似于

1241
00:46:43,000 --> 00:46:45,000
写模板的语法去描述数据

1242
00:46:45,000 --> 00:46:46,000
对

1243
00:46:46,000 --> 00:46:46,000
我觉得是这样的

1244
00:46:46,000 --> 00:46:47,000
就是它

1245
00:46:47,000 --> 00:46:48,000
你

1246
00:46:48,000 --> 00:46:48,000
对

1247
00:46:48,000 --> 00:46:49,000
你在

1248
00:46:49,000 --> 00:46:51,000
你用一种写模板的方式去写

1249
00:46:51,000 --> 00:46:53,000
你的 Data model

1250
00:46:53,000 --> 00:46:54,000
这其实是一种进步

1251
00:46:54,000 --> 00:46:55,000
而不是

1252
00:46:56,000 --> 00:46:57,000
就是某种抨击

1253
00:46:57,000 --> 00:46:59,000
某些人抨击的那样

1254
00:46:59,000 --> 00:47:00,000
是一种历史的倒退

1255
00:47:00,000 --> 00:47:00,000
我觉得可能

1256
00:47:00,000 --> 00:47:01,000
对

1257
00:47:01,000 --> 00:47:03,000
这个事情其实挺好玩

1258
00:47:03,000 --> 00:47:06,000
因为刚那个 React 去年刚发布

1259
00:47:06,000 --> 00:47:07,000
正式对外发布的时候

1260
00:47:07,000 --> 00:47:09,000
很多人就是吐槽这一点

1261
00:47:09,000 --> 00:47:11,000
因为大家都可能被这个教条

1262
00:47:11,000 --> 00:47:12,000
教条灌了

1263
00:47:12,000 --> 00:47:14,000
就说这个模板和数据要分离

1264
00:47:14,000 --> 00:47:15,000
但其实

1265
00:47:15,000 --> 00:47:17,000
我觉得当时那个 Pete Hong

1266
00:47:17,000 --> 00:47:18,000
他有一个话说得很好

1267
00:47:18,000 --> 00:47:20,000
就是说这个模板

1268
00:47:20,000 --> 00:47:21,000
他分的那个

1269
00:47:21,000 --> 00:47:23,000
就 separation concept 是分错了

1270
00:47:23,000 --> 00:47:25,000
他把两个不应该分开的东西

1271
00:47:25,000 --> 00:47:26,000
强行分开

1272
00:47:26,000 --> 00:47:27,000
但其实没有太多的好处

1273
00:47:28,000 --> 00:47:30,000
所以通过这上那个 React

1274
00:47:30,000 --> 00:47:31,000
这种 JSX 方式

1275
00:47:31,000 --> 00:47:32,000
其实是把

1276
00:47:32,000 --> 00:47:35,000
这两个本来就应该紧密联系在一起的

1277
00:47:35,000 --> 00:47:37,000
两个部分放在一个地方

1278
00:47:37,000 --> 00:47:39,000
然后大家可以一眼看到

1279
00:47:39,000 --> 00:47:40,000
就好像那个

1280
00:47:40,000 --> 00:47:42,000
Viuro 之前抱怨的说那个

1281
00:47:42,000 --> 00:47:43,000
BackBot 里面写很多这种

1282
00:47:43,000 --> 00:47:45,000
Subview 的时候不方便说

1283
00:47:45,000 --> 00:47:48,000
在一个文件里面就看出他在干什么

1284
00:47:48,000 --> 00:47:50,000
然后用这种 JSX 的方式

1285
00:47:50,000 --> 00:47:51,000
你可以一眼看出

1286
00:47:51,000 --> 00:47:53,000
我这个是在做一个模板

1287
00:47:53,000 --> 00:47:55,000
我在这个模板里面填充了这么一个数据

1288
00:47:55,000 --> 00:47:56,000
然后这个数据是从

1289
00:47:56,000 --> 00:47:58,000
这个对象哪个地方来的

1290
00:47:58,000 --> 00:48:01,000
然后我要添加哪些 Event Handler

1291
00:48:01,000 --> 00:48:02,000
都在同一个地方完成这个东西

1292
00:48:02,000 --> 00:48:04,000
这个才是一个好的

1293
00:48:04,000 --> 00:48:06,000
所谓的这个 encapsulation

1294
00:48:06,000 --> 00:48:08,000
我要再次提醒大家就是

1295
00:48:08,000 --> 00:48:10,000
你需要考虑自己的实际问题

1296
00:48:10,000 --> 00:48:12,000
然后选择正确的

1297
00:48:12,000 --> 00:48:14,000
Framework 或者 Convention Adopt

1298
00:48:16,000 --> 00:48:17,000
我们刚刚说那个 Astromorphic

1299
00:48:17,000 --> 00:48:17,000
对不对

1300
00:48:17,000 --> 00:48:18,000
在那种情况下

1301
00:48:18,000 --> 00:48:21,000
实际上如果你分离出模板来的话

1302
00:48:21,000 --> 00:48:21,000
是有好处的

1303
00:48:21,000 --> 00:48:23,000
因为如果你要在

1304
00:48:25,000 --> 00:48:27,000
后端用另外一种语言来写

1305
00:48:27,000 --> 00:48:29,000
你的 Render Logic 的话

1306
00:48:29,000 --> 00:48:31,000
那那个共用模板是可以共用的

1307
00:48:31,000 --> 00:48:34,000
但你得看在你的实际上实用过程中

1308
00:48:34,000 --> 00:48:36,000
我们是没有这么做的

1309
00:48:36,000 --> 00:48:37,000
然后我们所有的模板

1310
00:48:37,000 --> 00:48:39,000
是没有任何重用性的

1311
00:48:39,000 --> 00:48:40,000
就是也不是没有任何重用性

1312
00:48:40,000 --> 00:48:41,000
而是没有

1313
00:48:42,000 --> 00:48:44,000
它是有很强的重用性

1314
00:48:44,000 --> 00:48:46,000
因为它在另外一个

1315
00:48:46,000 --> 00:48:49,000
就是单独的自己的文件中的话

1316
00:48:49,000 --> 00:48:50,000
但是我们从来没有重用过它

1317
00:48:50,000 --> 00:48:52,000
从来没有重用过它

1318
00:48:52,000 --> 00:48:54,000
在三年的写这个程序的过程中

1319
00:48:55,000 --> 00:48:57,000
那到底做这个事情是为了什么

1320
00:48:57,000 --> 00:48:59,000
我们其实也不是很清楚

1321
00:49:00,000 --> 00:49:00,000
没想明白

1322
00:49:00,000 --> 00:49:03,000
所以在特定的应用场景下

1323
00:49:03,000 --> 00:49:05,000
特定的 Best Practice 是有道理的

1324
00:49:05,000 --> 00:49:06,000
比方说我们刚刚说

1325
00:49:06,000 --> 00:49:08,000
你如果一个模板

1326
00:49:08,000 --> 00:49:10,000
要在不同的语言中被 Render 的话

1327
00:49:10,000 --> 00:49:11,000
那实际上是非常好的一个设计

1328
00:49:11,000 --> 00:49:13,000
但如果你仅仅是在加入顺序

1329
00:49:13,000 --> 00:49:15,000
那可能真的你得重新考虑这个事情

1330
00:49:15,000 --> 00:49:16,000
到底是不是有意义的

1331
00:49:17,000 --> 00:49:19,000
何况你用 React 的时候

1332
00:49:19,000 --> 00:49:20,000
这就真的不是模板了

1333
00:49:20,000 --> 00:49:22,000
这个模板这个东西不存在的

1334
00:49:22,000 --> 00:49:23,000
它所有东西都是

1335
00:49:24,000 --> 00:49:25,000
Java Sub Object

1336
00:49:25,000 --> 00:49:27,000
There's no screen template

1337
00:49:27,000 --> 00:49:29,000
这个念头你得转过弯来

1338
00:49:29,000 --> 00:49:29,000
对

1339
00:49:29,000 --> 00:49:30,000
你写这

1340
00:49:31,000 --> 00:49:32,000
它只是看起来像而已

1341
00:49:32,000 --> 00:49:33,000
但完全不是

1342
00:49:33,000 --> 00:49:35,000
好处在于说

1343
00:49:36,000 --> 00:49:37,000
刚我们说

1344
00:49:38,000 --> 00:49:40,000
把 subview 的问题在 Backbone 里头

1345
00:49:40,000 --> 00:49:44,000
你得在模板里头给它留空间

1346
00:49:44,000 --> 00:49:46,000
然后再 Manually insert 进去

1347
00:49:46,000 --> 00:49:48,000
在 React 中这就不是问题了

1348
00:49:48,000 --> 00:49:50,000
你直接 import 一下

1349
00:49:50,000 --> 00:49:53,000
然后 import subcomponent

1350
00:49:53,000 --> 00:49:55,000
然后直接把这个 tag 写上去就好了

1351
00:49:55,000 --> 00:49:58,000
这是一个非常好的

1352
00:50:00,000 --> 00:50:01,000
就是重用性的进步

1353
00:50:02,000 --> 00:50:02,000
对

1354
00:50:02,000 --> 00:50:06,000
而且实际上也大量减轻了

1355
00:50:06,000 --> 00:50:07,000
开发者的

1356
00:50:09,000 --> 00:50:10,000
mental model

1357
00:50:10,000 --> 00:50:14,000
就是在维护一个 mental model 的负担

1358
00:50:14,000 --> 00:50:17,000
就是你不用总是在

1359
00:50:17,000 --> 00:50:18,000
我现在在写一个 template

1360
00:50:18,000 --> 00:50:19,000
我现在在写 model

1361
00:50:19,000 --> 00:50:23,000
你不用再维护这个不停的 context switch 的成本上

1362
00:50:23,000 --> 00:50:26,000
还有必须得提到的是

1363
00:50:26,000 --> 00:50:29,000
GSX 并不是一个全新的东西

1364
00:50:29,000 --> 00:50:30,000
在 Facebook 内部

1365
00:50:30,000 --> 00:50:32,000
这是一个开源的项目

1366
00:50:32,000 --> 00:50:37,000
他们一直在用类似的产品叫做 XHP

1367
00:50:37,000 --> 00:50:40,000
是 PHP 的版本

1368
00:50:40,000 --> 00:50:45,000
所以他们很长时间已经在 PHP 里写所谓 HTML tag

1369
00:50:46,000 --> 00:50:49,000
所以在这点上也是对这个 concept 的一个 validation

1370
00:50:49,000 --> 00:50:54,000
因为毕竟 Facebook 有用相同的概念用了很久

1371
00:50:54,000 --> 00:50:57,000
所以我觉得他们先人一步

1372
00:50:58,000 --> 00:50:59,000
已经 accept 的概念了

1373
00:50:59,000 --> 00:51:01,000
所以对他们来说

1374
00:51:02,000 --> 00:51:03,000
就不是一个事

1375
00:51:03,000 --> 00:51:04,000
你知道吗

1376
00:51:05,000 --> 00:51:06,000
对

1377
00:51:06,000 --> 00:51:09,000
我大概也是前年去湾区的时候

1378
00:51:09,000 --> 00:51:11,000
然后看到他们就是在 Facebook 内部

1379
00:51:11,000 --> 00:51:14,000
是怎么用这个叫做 XHP 的这么个语言

1380
00:51:14,000 --> 00:51:18,000
去写他们的服务端的软件

1381
00:51:18,000 --> 00:51:20,000
当时我就震撼到了

1382
00:51:20,000 --> 00:51:20,000
我说哇

1383
00:51:20,000 --> 00:51:23,000
因为他们等于是可以任意构建一种

1384
00:51:23,000 --> 00:51:25,000
就传统上我们写模板的时候

1385
00:51:25,000 --> 00:51:28,000
你只能用一个抽象程度很低的方式

1386
00:51:28,000 --> 00:51:29,000
因为你模板的话

1387
00:51:29,000 --> 00:51:31,000
要么就在模板层面上

1388
00:51:31,000 --> 00:51:32,000
你可以构建一些东西出来

1389
00:51:32,000 --> 00:51:33,000
或者是说

1390
00:51:34,000 --> 00:51:37,000
你在写那些 HTML 标签的时候

1391
00:51:37,000 --> 00:51:38,000
你还是要用那些标准的标签

1392
00:51:39,000 --> 00:51:40,000
但是他们在用 XHP 的时候

1393
00:51:40,000 --> 00:51:43,000
其实是可以定义自己的一个标签的

1394
00:51:43,000 --> 00:51:45,000
然后这个标签可以包含很多

1395
00:51:45,000 --> 00:51:47,000
很复杂的这种行为和数据

1396
00:51:47,000 --> 00:51:49,000
包括内部的结构在里面

1397
00:51:49,000 --> 00:51:51,000
而对标签的调用方来讲

1398
00:51:51,000 --> 00:51:53,000
完全可以不用关心

1399
00:51:53,000 --> 00:51:54,000
里面到底是如何实现的

1400
00:51:54,000 --> 00:51:56,000
其实就有点像一个 AnglerJS

1401
00:51:56,000 --> 00:51:59,000
所做出来的新的 HTML tag

1402
00:51:59,000 --> 00:52:03,000
只不过这一切都是在 PHP 里面

1403
00:52:03,000 --> 00:52:04,000
他们应该也是叫做 Complement

1404
00:52:04,000 --> 00:52:05,000
那个时候

1405
00:52:06,000 --> 00:52:09,000
所谓组件化的时候

1406
00:52:09,000 --> 00:52:10,000
就一个什么

1407
00:52:10,000 --> 00:52:12,000
要达到一个什么样的场景

1408
00:52:12,000 --> 00:52:14,000
就是说我只要构建好我这个组件

1409
00:52:14,000 --> 00:52:16,000
我这个组件对外部来说

1410
00:52:16,000 --> 00:52:17,000
是一个完全封闭的

1411
00:52:17,000 --> 00:52:20,000
你只要外部提供给我需要的数据

1412
00:52:20,000 --> 00:52:23,000
和我需要的包括一些回调函数的话

1413
00:52:23,000 --> 00:52:25,000
我这个组件就能完成你需要的工作

1414
00:52:25,000 --> 00:52:27,000
就不再需要去

1415
00:52:27,000 --> 00:52:28,000
每个人都去看到这个组件

1416
00:52:28,000 --> 00:52:29,000
内部是有多少个什么

1417
00:52:29,000 --> 00:52:30,000
多少个 A tag

1418
00:52:30,000 --> 00:52:32,000
多少个 Div 这种层层包起来

1419
00:52:32,000 --> 00:52:33,000
这么一个东西

1420
00:52:33,000 --> 00:52:34,000
这一点我觉得是一个

1421
00:52:34,000 --> 00:52:36,000
在抽象层级上

1422
00:52:36,000 --> 00:52:37,000
是一个化时代的进步

1423
00:52:37,000 --> 00:52:37,000
我觉得

1424
00:52:38,000 --> 00:52:39,000
是

1425
00:52:39,000 --> 00:52:41,000
然后

1426
00:52:41,000 --> 00:52:42,000
当时那个

1427
00:52:42,000 --> 00:52:43,000
就是我看到 Facebook

1428
00:52:43,000 --> 00:52:44,000
他们内部在用这个

1429
00:52:44,000 --> 00:52:45,000
最后怎么玩

1430
00:52:45,000 --> 00:52:46,000
觉得哇这个真是

1431
00:52:46,000 --> 00:52:48,000
因为我没有在其他地方看到有类似的

1432
00:52:48,000 --> 00:52:51,000
产品或者是语言吧

1433
00:52:51,000 --> 00:52:52,000
在做类似的事情

1434
00:52:52,000 --> 00:52:53,000
真的是

1435
00:52:53,000 --> 00:52:56,000
感觉走在什么时代的前列的那种

1436
00:52:56,000 --> 00:52:57,000
跟我们不一样

1437
00:52:57,000 --> 00:52:59,000
跟其他的人确实差的

1438
00:52:59,000 --> 00:53:01,000
领先的蛮远的

1439
00:53:01,000 --> 00:53:03,000
那我们下面讲那个

1440
00:53:03,000 --> 00:53:04,000
REACT Native 吧

1441
00:53:05,000 --> 00:53:07,000
ES 6

1442
00:53:07,000 --> 00:53:08,000
我讲吧

1443
00:53:08,000 --> 00:53:09,000
那个

1444
00:53:09,000 --> 00:53:11,000
那其实不是很重要我觉得

1445
00:53:11,000 --> 00:53:11,000
OK

1446
00:53:11,000 --> 00:53:12,000
这个是

1447
00:53:12,000 --> 00:53:13,000
Waylon 你觉得呢

1448
00:53:13,000 --> 00:53:15,000
说到 ES 6 呢

1449
00:53:15,000 --> 00:53:18,000
我觉得 Angler 跟

1450
00:53:18,000 --> 00:53:20,000
这主要是 Angler 跟 REACT 的区别之一吧

1451
00:53:20,000 --> 00:53:21,000
因为

1452
00:53:22,000 --> 00:53:24,000
我觉得 REACT 似乎在

1453
00:53:24,000 --> 00:53:27,000
它的发展过程中考虑了更多的

1454
00:53:27,000 --> 00:53:29,000
Java Scrum Native 的东西

1455
00:53:29,000 --> 00:53:32,000
while Angler 好像在创造一个自己的小世界

1456
00:53:33,000 --> 00:53:34,000
我们有

1457
00:53:34,000 --> 00:53:37,000
一个 Panel 上有那个 Sebastian

1458
00:53:37,000 --> 00:53:40,000
是 REACT 的主要的维护者之一

1459
00:53:40,000 --> 00:53:41,000
然后他实际上

1460
00:53:41,000 --> 00:53:44,000
他本身是在那个 ES 6 的

1461
00:53:45,000 --> 00:53:46,000
委员会上的

1462
00:53:46,000 --> 00:53:48,000
所以他有提到说

1463
00:53:49,000 --> 00:53:51,000
REACT 是非常非常 aggressive

1464
00:53:51,000 --> 00:53:54,000
在推 ES 6 的支持

1465
00:53:54,000 --> 00:53:57,000
他甚至把那个 Mixing 的支持给去掉了

1466
00:53:57,000 --> 00:53:58,000
在最新的版本

1467
00:53:58,000 --> 00:53:59,000
拿掉了吗

1468
00:53:59,000 --> 00:54:01,000
他解释是因为 ES 6 的

1469
00:54:02,000 --> 00:54:04,000
Mixing 支持

1470
00:54:04,000 --> 00:54:05,000
在那个

1471
00:54:06,000 --> 00:54:07,000
不是比较糟糕

1472
00:54:07,000 --> 00:54:09,000
而是在 Standard 中被去掉了

1473
00:54:09,000 --> 00:54:12,000
就是 ES 6 现在的标准

1474
00:54:12,000 --> 00:54:13,000
就是在这一版中的话

1475
00:54:13,000 --> 00:54:14,000
是没有 Mixing 的

1476
00:54:14,000 --> 00:54:15,000
没有提到 Mixing 的

1477
00:54:15,000 --> 00:54:18,000
他们在 ES 7 中才会去支持 Mixing

1478
00:54:18,000 --> 00:54:21,000
或者说才会把这个事情再提上一成

1479
00:54:21,000 --> 00:54:23,000
所以正因为如此呢

1480
00:54:23,000 --> 00:54:25,000
在那个 Native 的 Class Up 或者中

1481
00:54:25,000 --> 00:54:28,000
REACT 把那个 Mixing 给去掉了

1482
00:54:28,000 --> 00:54:30,000
当然这些事情都是 on-going events

1483
00:54:30,000 --> 00:54:34,000
所以还有可能有其他的变化

1484
00:54:34,000 --> 00:54:36,000
不过我觉得

1485
00:54:36,000 --> 00:54:37,000
至少在我看来的话

1486
00:54:37,000 --> 00:54:41,000
REACT 是非常在积极的推动和

1487
00:54:41,000 --> 00:54:43,000
就是

1488
00:54:44,000 --> 00:54:47,000
实现 ES 6 的标准

1489
00:54:49,000 --> 00:54:50,000
其实你

1490
00:54:50,000 --> 00:54:52,000
Reno 你对 ES 6

1491
00:54:52,000 --> 00:54:54,000
就是 JavaScript 下一个版本的语言

1492
00:54:54,000 --> 00:54:56,000
你是什么样的态度

1493
00:54:58,000 --> 00:55:00,000
老实说我不是很熟悉

1494
00:55:00,000 --> 00:55:01,000
所以我把这段剪接掉吧

1495
00:55:02,000 --> 00:55:04,000
OK 好那行

1496
00:55:04,000 --> 00:55:04,000
我没有用

1497
00:55:04,000 --> 00:55:06,000
我们在座有谁比较熟悉吗

1498
00:55:06,000 --> 00:55:08,000
有人紧跟着 ES 7

1499
00:55:08,000 --> 00:55:10,000
我有在跟这个

1500
00:55:10,000 --> 00:55:11,000
你在跟

1501
00:55:11,000 --> 00:55:13,000
对你现在在搞这个

1502
00:55:13,000 --> 00:55:13,000
没有没有

1503
00:55:13,000 --> 00:55:15,000
我也有在用它

1504
00:55:15,000 --> 00:55:17,000
就是在尝试去使用它

1505
00:55:17,000 --> 00:55:18,000
现在我把

1506
00:55:18,000 --> 00:55:19,000
我昨天还在转

1507
00:55:19,000 --> 00:55:22,000
就是那个 IPN 背后不是有个

1508
00:55:22,000 --> 00:55:23,000
我自己写的 CMS 吗

1509
00:55:23,000 --> 00:55:24,000
嗯哼

1510
00:55:24,000 --> 00:55:25,000
然后有一个管理后台

1511
00:55:25,000 --> 00:55:27,000
那个其实是用 REACT 写的

1512
00:55:27,000 --> 00:55:27,000
嗯

1513
00:55:28,000 --> 00:55:29,000
那我想想

1514
00:55:29,000 --> 00:55:30,000
那我是先讲 Relay 呢

1515
00:55:30,000 --> 00:55:32,000
还是先讲这个

1516
00:55:32,000 --> 00:55:36,000
因为 Native 实际上是一个非常自然的过渡

1517
00:55:36,000 --> 00:55:36,000
因为

1518
00:55:38,000 --> 00:55:39,000
在 REACT 中

1519
00:55:39,000 --> 00:55:41,000
你的最初的版本中

1520
00:55:41,000 --> 00:55:43,000
你的那个 Render Target 是 Virtual DOM

1521
00:55:43,000 --> 00:55:44,000
对不对

1522
00:55:44,000 --> 00:55:48,000
但是为什么一定要 Render 到 DOM 上来

1523
00:55:48,000 --> 00:55:49,000
反正已经 Virtualized 了

1524
00:55:49,000 --> 00:55:52,000
就好像你用那个虚拟机一样

1525
00:55:52,000 --> 00:55:55,000
你到底那个虚拟机是在 Windows 上 RUN

1526
00:55:55,000 --> 00:55:56,000
是在 Mac 上 RUN

1527
00:55:56,000 --> 00:55:59,000
是在 OS 2 上 RUN

1528
00:56:00,000 --> 00:56:01,000
并不重要嘛对吧

1529
00:56:03,000 --> 00:56:03,000
所以

1530
00:56:03,000 --> 00:56:04,000
对

1531
00:56:04,000 --> 00:56:07,000
就等于它提供一层新的抽象

1532
00:56:07,000 --> 00:56:08,000
然后介入这一层新的抽象

1533
00:56:08,000 --> 00:56:09,000
你就有了新的自由

1534
00:56:09,000 --> 00:56:10,000
你可以把它

1535
00:56:10,000 --> 00:56:13,000
你可以把它的底层

1536
00:56:13,000 --> 00:56:14,000
迁移到其他的 platform 上面

1537
00:56:15,000 --> 00:56:17,000
那我忘了是那个

1538
00:56:17,000 --> 00:56:19,000
是 Tom 还是那个 Krestoffers 说的

1539
00:56:19,000 --> 00:56:20,000
就说他说我们

1540
00:56:20,000 --> 00:56:22,000
他们之前做那个 Virtual DOM 的时候

1541
00:56:22,000 --> 00:56:23,000
的最终目的

1542
00:56:23,000 --> 00:56:24,000
并不是说

1543
00:56:24,000 --> 00:56:27,000
要把这个 DOM Virtualize 这件事情本身

1544
00:56:27,000 --> 00:56:28,000
而是说要完全去掉这个 DOM

1545
00:56:28,000 --> 00:56:32,000
就是要把 React 跟 DOM 的依赖直接切掉

1546
00:56:32,000 --> 00:56:33,000
就完全没有关系

1547
00:56:33,000 --> 00:56:35,000
我可以不依赖一个 DOM

1548
00:56:35,000 --> 00:56:37,000
然后最终的结果就是我们现在看到的

1549
00:56:37,000 --> 00:56:39,000
它这次发布了一个重量级的产品

1550
00:56:39,000 --> 00:56:39,000
叫做 React

1551
00:56:39,000 --> 00:56:41,000
一个工具吧叫做 React Native

1552
00:56:42,000 --> 00:56:43,000
什么意思呢

1553
00:56:43,000 --> 00:56:43,000
简单描述一下

1554
00:56:43,000 --> 00:56:45,000
就是说

1555
00:56:45,000 --> 00:56:47,000
我还是用 JavaScript 写我的应用

1556
00:56:47,000 --> 00:56:49,000
但是相比在网页上

1557
00:56:49,000 --> 00:56:51,000
我是把它渲染成一个网页的

1558
00:56:51,000 --> 00:56:55,000
那些 HTML 的这种 TAG 标签的话

1559
00:56:55,000 --> 00:57:00,000
我是直接用某一个平台原生的 UI 组件

1560
00:57:00,000 --> 00:57:02,000
比如说在 IOS 上面就是一个原生的

1561
00:57:02,000 --> 00:57:03,000
比如说这个列表

1562
00:57:03,000 --> 00:57:05,000
那个可以滚动的那种有带重力

1563
00:57:05,000 --> 00:57:07,000
不是叫带什么加速度的

1564
00:57:07,000 --> 00:57:09,000
惯性的那种滚动窗口

1565
00:57:09,000 --> 00:57:12,000
或者说是我用一个原生的地图

1566
00:57:12,000 --> 00:57:13,000
这个组件

1567
00:57:13,000 --> 00:57:14,000
来实现我的这些功能

1568
00:57:14,000 --> 00:57:17,000
但是我的这个程序的实际的后台的

1569
00:57:17,000 --> 00:57:18,000
所有的这个 Model

1570
00:57:18,000 --> 00:57:19,000
还有所有的数据

1571
00:57:19,000 --> 00:57:20,000
还有包括一些逻辑

1572
00:57:20,000 --> 00:57:22,000
都其实是在 JavaScript 里面运行的

1573
00:57:22,000 --> 00:57:23,000
对

1574
00:57:23,000 --> 00:57:25,000
这个我觉得是非常了不得的一个事情

1575
00:57:25,000 --> 00:57:26,000
就是说

1576
00:57:26,000 --> 00:57:28,000
我就知道很多这个 IOS

1577
00:57:28,000 --> 00:57:30,000
或者是 Android 开发都在吐槽

1578
00:57:30,000 --> 00:57:30,000
这个

1579
00:57:30,000 --> 00:57:32,000
其实

1580
00:57:32,000 --> 00:57:33,000
哪怕是现在

1581
00:57:33,000 --> 00:57:35,000
应该开发一个 IOS 应用

1582
00:57:35,000 --> 00:57:35,000
或者是 Android 应用

1583
00:57:35,000 --> 00:57:37,000
都还不是那么爽的一件事情

1584
00:57:37,000 --> 00:57:40,000
它有点像在 Backbone 时代的

1585
00:57:40,000 --> 00:57:42,000
有一点像在 Backbone 时代的

1586
00:57:42,000 --> 00:57:43,000
开发 Web App 的感觉

1587
00:57:43,000 --> 00:57:44,000
对

1588
00:57:44,000 --> 00:57:46,000
我觉得对我来讲

1589
00:57:46,000 --> 00:57:47,000
最重要的概念

1590
00:57:47,000 --> 00:57:49,000
在 React Native 中最重要的概念

1591
00:57:49,000 --> 00:57:52,000
是我 Thompson 说的

1592
00:57:52,000 --> 00:57:55,000
Learn once, write everywhere

1593
00:57:55,000 --> 00:57:58,000
React Native 它必须是要你

1594
00:57:58,000 --> 00:58:00,000
write once, run everywhere

1595
00:58:00,000 --> 00:58:01,000
它没有

1596
00:58:01,000 --> 00:58:04,000
React Native 本身它没有

1597
00:58:04,000 --> 00:58:07,000
merge the gap between Android and iOS

1598
00:58:07,000 --> 00:58:09,000
Android 还是要写 Android App

1599
00:58:09,000 --> 00:58:11,000
IOS 还是要写 IOS App

1600
00:58:11,000 --> 00:58:13,000
但是你写程序的方式

1601
00:58:13,000 --> 00:58:15,000
发生了根本的变化

1602
00:58:15,000 --> 00:58:17,000
不管是写 Web App 好

1603
00:58:17,000 --> 00:58:18,000
还是写 Android App 好

1604
00:58:18,000 --> 00:58:20,000
还是写 IOS App 好

1605
00:58:20,000 --> 00:58:21,000
你会用

1606
00:58:21,000 --> 00:58:23,000
exactly the same way

1607
00:58:23,000 --> 00:58:26,000
来写这三个不同的

1608
00:58:26,000 --> 00:58:28,000
环境下的 application

1609
00:58:28,000 --> 00:58:31,000
只是你会用这个环境的

1610
00:58:31,000 --> 00:58:33,000
对不同的组件

1611
00:58:33,000 --> 00:58:36,000
这一点上是非常非常有利的

1612
00:58:36,000 --> 00:58:39,000
我本人对此也是深有感触

1613
00:58:39,000 --> 00:58:43,000
因为我之前有写一个 IOS App

1614
00:58:43,000 --> 00:58:44,000
不是 word font

1615
00:58:44,000 --> 00:58:48,000
我现在还在写另外一个

1616
00:58:48,000 --> 00:58:49,000
小小的说一下

1617
00:58:49,000 --> 00:58:52,000
我又在写另外一个 IOS App

1618
00:58:52,000 --> 00:58:54,000
然后其中有很多的 layouting

1619
00:58:54,000 --> 00:58:54,000
其实像是一个

1620
00:58:54,000 --> 00:58:56,000
逻辑上来讲是一个比较简单的 App

1621
00:58:56,000 --> 00:58:58,000
但是有很多 layouting

1622
00:58:58,000 --> 00:58:59,000
我有一个 UI label

1623
00:58:59,000 --> 00:59:02,000
这个 UI label 是可变的长度

1624
00:59:02,000 --> 00:59:05,000
然后这个 UI label 又在

1625
00:59:05,000 --> 00:59:09,000
一个可变长度的 UI table sale 中

1626
00:59:09,000 --> 00:59:10,000
就实际上

1627
00:59:10,000 --> 00:59:12,000
如果你想用 auto layouting 的话

1628
00:59:12,000 --> 00:59:14,000
这是一个非常非常麻烦的事情

1629
00:59:14,000 --> 00:59:16,000
因为在 UI label

1630
00:59:16,000 --> 00:59:17,000
de-surrender 的时候

1631
00:59:17,000 --> 00:59:19,000
它并不知道它的宽度

1632
00:59:19,000 --> 00:59:21,000
如果它不知道它的宽度

1633
00:59:21,000 --> 00:59:22,000
它就不知道它的高度

1634
00:59:22,000 --> 00:59:23,000
它不知道它的高度

1635
00:59:23,000 --> 00:59:25,000
它就乱 render

1636
00:59:25,000 --> 00:59:27,000
你就得

1637
00:59:27,000 --> 00:59:28,000
auto layouting 是

1638
00:59:28,000 --> 00:59:30,000
你的 all about constraints

1639
00:59:30,000 --> 00:59:32,000
所以你需要设计一系列的 constraints

1640
00:59:32,000 --> 00:59:36,000
然后这个 layout engine 会来猜测

1641
00:59:36,000 --> 00:59:38,000
怎么样的结果能够满足

1642
00:59:38,000 --> 00:59:39,000
你所有的 constraints

1643
00:59:39,000 --> 00:59:41,000
或者尽量满足你的 constraints

1644
00:59:41,000 --> 00:59:43,000
这是个非常 non-tunative 的 way

1645
00:59:43,000 --> 00:59:45,000
然后从 web 的角度来说的话

1646
00:59:46,000 --> 00:59:48,000
box model 多简单啊

1647
00:59:48,000 --> 00:59:50,000
虽然说 box model 有时候不工作

1648
00:59:50,000 --> 00:59:51,000
但是多简单啊

1649
00:59:51,000 --> 00:59:53,000
你知道就是所谓的东西就是 box tilebox

1650
00:59:53,000 --> 00:59:54,000
box 在 box 之上

1651
00:59:54,000 --> 00:59:56,000
然后你有 margin

1652
00:59:56,000 --> 00:59:58,000
你有 padding

1653
00:59:58,000 --> 00:59:59,000
你有 border

1654
00:59:59,000 --> 01:00:00,000
这是个非常非常容易理解

1655
01:00:00,000 --> 01:00:02,000
非常直观的

1656
01:00:02,000 --> 01:00:04,000
直观的

1657
01:00:04,000 --> 01:00:06,000
一种模式

1658
01:00:06,000 --> 01:00:07,000
反观

1659
01:00:07,000 --> 01:00:07,000
你知道 IOS

1660
01:00:07,000 --> 01:00:09,000
如果你不用 auto layout

1661
01:00:09,000 --> 01:00:11,000
就是 constraints 非常难以理解

1662
01:00:11,000 --> 01:00:13,000
然后你那个结果也不 intuitive

1663
01:00:13,000 --> 01:00:14,000
你如果

1664
01:00:14,000 --> 01:00:15,000
只给我一系列的 constraints

1665
01:00:15,000 --> 01:00:17,000
如果你

1666
01:00:17,000 --> 01:00:18,000
不告诉我结果的话

1667
01:00:18,000 --> 01:00:19,000
我很难

1668
01:00:19,000 --> 01:00:20,000
说我很有信心

1669
01:00:20,000 --> 01:00:21,000
说这些 constraints

1670
01:00:21,000 --> 01:00:22,000
会得到我想要的结果

1671
01:00:24,000 --> 01:00:27,000
我觉得可能最重大的一个差别就是

1672
01:00:27,000 --> 01:00:28,000
constraints based layout

1673
01:00:28,000 --> 01:00:33,000
要求你能够在头脑中维护一个

1674
01:00:33,000 --> 01:00:36,000
最终视觉效果的模型

1675
01:00:36,000 --> 01:00:39,000
而 box model 对此要求就

1676
01:00:39,000 --> 01:00:40,000
低一点

1677
01:00:40,000 --> 01:00:42,000
或者说低很多吧应该说

1678
01:00:42,000 --> 01:00:44,000
如果你不用 auto layout 的话呢

1679
01:00:44,000 --> 01:00:45,000
你又得

1680
01:00:45,000 --> 01:00:46,000
就是

1681
01:00:46,000 --> 01:00:48,000
manually 去做很多的 math

1682
01:00:48,000 --> 01:00:51,000
如果你看那个 Christopher 的 slides

1683
01:00:51,000 --> 01:00:53,000
他有一张全都是 math

1684
01:00:53,000 --> 01:00:54,000
math

1685
01:00:54,000 --> 01:00:55,000
exactly right

1686
01:00:55,000 --> 01:00:58,000
但倒也不是说有多难多容易

1687
01:00:58,000 --> 01:00:59,000
很多那个 IOS 开发者跟我说

1688
01:00:59,000 --> 01:01:00,000
那不难

1689
01:01:00,000 --> 01:01:02,000
但是那 ugly 啊

1690
01:01:02,000 --> 01:01:03,000
多丑陋啊我靠

1691
01:01:03,000 --> 01:01:05,000
然后你想要改一点什么东西的话

1692
01:01:05,000 --> 01:01:07,000
又回头得去算

1693
01:01:07,000 --> 01:01:07,000
然后

1694
01:01:07,000 --> 01:01:09,000
哦妈呀真的是

1695
01:01:09,000 --> 01:01:10,000
真可怕

1696
01:01:10,000 --> 01:01:10,000
对吧

1697
01:01:11,000 --> 01:01:13,000
reconinting

1698
01:01:13,000 --> 01:01:15,000
所以我觉得其实他们这次做的那个

1699
01:01:15,000 --> 01:01:16,000
就是他们发布的 react native

1700
01:01:16,000 --> 01:01:18,000
他们也解决了这个问题

1701
01:01:18,000 --> 01:01:20,000
他们用 JavaScript

1702
01:01:20,000 --> 01:01:23,000
实现了一套那个 CSS 最新的那个叫做

1703
01:01:23,000 --> 01:01:25,000
flexbox 的那个 box model

1704
01:01:25,000 --> 01:01:25,000
对

1705
01:01:25,000 --> 01:01:28,000
然后他们用那个模型就去解决了

1706
01:01:28,000 --> 01:01:32,000
这个再去怎么去布局那些原生的 UI 组件的问题

1707
01:01:32,000 --> 01:01:34,000
这个我觉得就刚刚那个 Willow 也已经

1708
01:01:34,000 --> 01:01:36,000
大家相信已经听出来

1709
01:01:36,000 --> 01:01:38,000
Willow 对这个什么 constraint layout

1710
01:01:38,000 --> 01:01:40,000
auto layout 这东西已经吐槽很久了

1711
01:01:40,000 --> 01:01:42,000
其实就从我一个印象讲

1712
01:01:42,000 --> 01:01:44,000
那个什么 constraint based layout 的话

1713
01:01:44,000 --> 01:01:45,000
其实它是要你在

1714
01:01:45,000 --> 01:01:47,000
你头脑中构建一个这个

1715
01:01:47,000 --> 01:01:48,000
就是这个就是什么

1716
01:01:48,000 --> 01:01:49,000
动态规划机

1717
01:01:50,000 --> 01:01:51,000
对吧

1718
01:01:51,000 --> 01:01:53,000
你得自己在头脑中随时解那个

1719
01:01:53,000 --> 01:01:54,000
解那个方程解完之后再说

1720
01:01:54,000 --> 01:01:56,000
这个会出现在那里

1721
01:01:56,000 --> 01:01:57,000
这个会出现在那里

1722
01:01:57,000 --> 01:01:58,000
就不像那个 box model

1723
01:01:58,000 --> 01:02:01,000
它更加反映出是一个比较直观的

1724
01:02:01,000 --> 01:02:02,000
这个应该是多大

1725
01:02:02,000 --> 01:02:03,000
它应该有多宽

1726
01:02:03,000 --> 01:02:06,000
然后它多到一个边框是

1727
01:02:06,000 --> 01:02:08,000
就那个什么 margin 东西叫什么来的

1728
01:02:08,000 --> 01:02:09,000
刘白对吧

1729
01:02:09,000 --> 01:02:10,000
刘白要多少

1730
01:02:10,000 --> 01:02:13,000
或者是跟其他的东西间距要多少

1731
01:02:13,000 --> 01:02:14,000
我这个确实是 CSS

1732
01:02:14,000 --> 01:02:17,000
就是这个比较好的解决的一个地方

1733
01:02:17,000 --> 01:02:19,000
就我很好奇为什么

1734
01:02:19,000 --> 01:02:21,000
像 iOS 和安卓之前

1735
01:02:21,000 --> 01:02:23,000
他们没有用到这种同样的模型

1736
01:02:23,000 --> 01:02:24,000
去做这个事情

1737
01:02:25,000 --> 01:02:26,000
这是一个很好问题

1738
01:02:26,000 --> 01:02:30,000
其实这个可以将来专门找一期谈这个

1739
01:02:30,000 --> 01:02:32,000
就是为什么 box model 这种

1740
01:02:32,000 --> 01:02:35,000
看起来如此简单一行

1741
01:02:35,000 --> 01:02:37,000
又

1742
01:02:37,000 --> 01:02:41,000
有大量解放生产力的布局

1743
01:02:41,000 --> 01:02:43,000
仅仅在 web 领域独树一致

1744
01:02:43,000 --> 01:02:45,000
就甚至很多

1745
01:02:45,000 --> 01:02:50,000
比如说排版软件都完全不去考虑这种

1746
01:02:50,000 --> 01:02:53,000
但我觉得可能还是惯性在里面

1747
01:02:53,000 --> 01:02:56,000
对这个是挺奇怪的

1748
01:02:56,000 --> 01:02:57,000
对比如说你说 iOS 为什么不用它

1749
01:02:57,000 --> 01:03:00,000
iOS 不用它是因为 OS X 不用它

1750
01:03:01,000 --> 01:03:04,000
iOS 毕竟一开始只是 OS X 的一个改版

1751
01:03:04,000 --> 01:03:08,000
就麦克上的 APP 不可能

1752
01:03:08,000 --> 01:03:10,000
从来没有用过 box layout

1753
01:03:10,000 --> 01:03:13,000
所以 iOS 上面也就不用了

1754
01:03:14,000 --> 01:03:17,000
这次这个 react native 它发布

1755
01:03:17,000 --> 01:03:19,000
我觉得还有一点我觉得特别特别特别

1756
01:03:19,000 --> 01:03:20,000
就是说

1757
01:03:20,000 --> 01:03:23,000
就令人觉得比较惊奇的一点

1758
01:03:24,000 --> 01:03:26,000
就是它因为整个

1759
01:03:27,000 --> 01:03:29,000
程序的逻辑和这些

1760
01:03:29,000 --> 01:03:32,000
包括这个 model

1761
01:03:32,000 --> 01:03:34,000
都是在 javascript 里面实现的

1762
01:03:34,000 --> 01:03:36,000
然后 javascript 它是依赖于一个

1763
01:03:36,000 --> 01:03:38,000
所谓解析器或者是 javascript 引擎的

1764
01:03:39,000 --> 01:03:40,000
然后这个引擎可以

1765
01:03:40,000 --> 01:03:43,000
不用跑在手机上面

1766
01:03:43,000 --> 01:03:44,000
它可以跑在

1767
01:03:44,000 --> 01:03:45,000
他们在现场 demo 的时候

1768
01:03:45,000 --> 01:03:48,000
它解析器是跑在浏览器里面的

1769
01:03:48,000 --> 01:03:53,000
然后它可以在 Chrome 里面去改浏览器

1770
01:03:53,000 --> 01:03:55,000
然后即时重刷新一下

1771
01:03:55,000 --> 01:03:58,000
然后在 iPhone 模拟器里面

1772
01:03:58,000 --> 01:04:03,000
对应的一个原生的 UI 的界面

1773
01:04:03,000 --> 01:04:04,000
就随之发生改变了

1774
01:04:04,000 --> 01:04:06,000
这个非常了不得

1775
01:04:06,000 --> 01:04:08,000
这个在实际的 production 中是

1776
01:04:08,000 --> 01:04:10,000
不可能就是很难实现的

1777
01:04:11,000 --> 01:04:13,000
however 但是这反映了就是说

1778
01:04:14,000 --> 01:04:17,000
react native 到底是怎么样实现

1779
01:04:17,000 --> 01:04:19,000
从 javascript 到 native 的这个转换

1780
01:04:22,000 --> 01:04:24,000
react native 不想要成为一个性能瓶颈

1781
01:04:25,000 --> 01:04:25,000
of course not

1782
01:04:26,000 --> 01:04:29,000
所以它的实现方式就是在

1783
01:04:29,000 --> 01:04:31,000
把 javascript 这个引擎放到

1784
01:04:31,000 --> 01:04:34,000
单独的 background thread 中

1785
01:04:34,000 --> 01:04:34,000
一个单独

1786
01:04:34,000 --> 01:04:36,000
它自己一个单独的线程中

1787
01:04:37,000 --> 01:04:39,000
然后在这个线程中

1788
01:04:39,000 --> 01:04:45,000
有一个 javascript 的引擎在不断的渲染

1789
01:04:45,000 --> 01:04:46,000
然后得到结果

1790
01:04:46,000 --> 01:04:48,000
再通过 channel 的方式

1791
01:04:48,000 --> 01:04:51,000
把这个渲染结果

1792
01:04:51,000 --> 01:04:53,000
发回到那个你的主线程中

1793
01:04:54,000 --> 01:04:56,000
所以你的主线程是没有被拨

1794
01:04:56,000 --> 01:04:56,000
可能随时

1795
01:04:57,000 --> 01:04:58,000
这个结果就是说

1796
01:04:58,000 --> 01:05:00,000
你的主线程总是很 smooth 的

1797
01:05:01,000 --> 01:05:01,000
反观

1798
01:05:02,000 --> 01:05:05,000
如果你用一个 web view 的一个解决方式

1799
01:05:05,000 --> 01:05:08,000
先不说就是你不能够用 native component

1800
01:05:08,000 --> 01:05:10,000
这种极大的问题

1801
01:05:11,000 --> 01:05:13,000
关键是说你的 javascript 是会 block

1802
01:05:13,000 --> 01:05:14,000
你的主线程的

1803
01:05:14,000 --> 01:05:17,000
所以说如果你 javascript 在做一些

1804
01:05:17,000 --> 01:05:18,000
大量的运算的时候

1805
01:05:19,000 --> 01:05:23,000
那个用户如果在比方说在向下滑

1806
01:05:23,000 --> 01:05:23,000
那个页面

1807
01:05:23,000 --> 01:05:25,000
那个页面就不会不动

1808
01:05:25,000 --> 01:05:26,000
所以那个页面就不 smooth

1809
01:05:26,000 --> 01:05:30,000
整个的那个体验就很不易

1810
01:05:30,000 --> 01:05:31,000
就很不乐观

1811
01:05:32,000 --> 01:05:33,000
所以 react

1812
01:05:33,000 --> 01:05:35,000
既让你 react native

1813
01:05:35,000 --> 01:05:38,000
既让你使用 native component

1814
01:05:38,000 --> 01:05:40,000
有 native 的 experience

1815
01:05:40,000 --> 01:05:43,000
也从性能上帮助你

1816
01:05:44,000 --> 01:05:48,000
不要提供不好的体验

1817
01:05:50,000 --> 01:05:54,000
就他把这个 UI 的渲染和这个逻辑的

1818
01:05:54,000 --> 01:05:57,000
就是业务逻辑的执行是完全隔裂开场

1819
01:05:57,000 --> 01:05:59,000
通过异步的方式进行通讯同步的

1820
01:06:00,000 --> 01:06:03,000
这个是我觉得非常好的一件事情

1821
01:06:03,000 --> 01:06:05,000
但是这就牵涉到另外一个问题了

1822
01:06:05,000 --> 01:06:06,000
就他这样的话

1823
01:06:06,000 --> 01:06:08,000
对后台的执行 javascript

1824
01:06:08,000 --> 01:06:12,000
解析器的进程的性能会有要求吗

1825
01:06:12,000 --> 01:06:13,000
比如说据我所知

1826
01:06:13,000 --> 01:06:15,000
在 iOS 上面

1827
01:06:16,000 --> 01:06:18,000
你单独自己跑一个 javascript

1828
01:06:18,000 --> 01:06:19,000
这个解析器的话

1829
01:06:19,000 --> 01:06:21,000
是没有他们那个叫什么来的

1830
01:06:21,000 --> 01:06:24,000
那个 JIT 的优化

1831
01:06:26,000 --> 01:06:28,000
这一点上我并不是特别清楚

1832
01:06:28,000 --> 01:06:29,000
就是他们主要实现方式

1833
01:06:29,000 --> 01:06:32,000
但是有一点很重要的是

1834
01:06:32,000 --> 01:06:33,000
你刚刚说的那个问题

1835
01:06:33,000 --> 01:06:38,000
只有在你直接使用 web view 的情况下

1836
01:06:38,000 --> 01:06:39,000
才会出现

1837
01:06:39,000 --> 01:06:40,000
为什么

1838
01:06:40,000 --> 01:06:43,000
因为那个 engine 是在 web view 里头

1839
01:06:43,000 --> 01:06:46,000
但是他们的那个 react 的实现方式

1840
01:06:46,000 --> 01:06:50,000
并不代表说他一定要用那个 javascript engine

1841
01:06:50,000 --> 01:06:54,000
他可以自己包装一个其他的 JIT engine 在里头

1842
01:06:54,000 --> 01:06:55,000
就是他可以说

1843
01:06:55,000 --> 01:06:59,000
我不用苹果那个 iOS 自带的那个 javascript engine

1844
01:06:59,000 --> 01:07:03,000
然后我自己包一个带 JIT 的这个 javascript 解析器进去

1845
01:07:03,000 --> 01:07:05,000
这样执行吗

1846
01:07:05,000 --> 01:07:06,000
没错

1847
01:07:06,000 --> 01:07:08,000
那这样不会就会

1848
01:07:08,000 --> 01:07:11,000
撞到那个 App Store 的审核条例的那某一条说

1849
01:07:11,000 --> 01:07:13,000
不能自带解析器吗

1850
01:07:13,000 --> 01:07:14,000
真的吗

1851
01:07:14,000 --> 01:07:16,000
有这么一条的曾经

1852
01:07:16,000 --> 01:07:18,000
我记得后来就

1853
01:07:18,000 --> 01:07:21,000
那个条片我还写过 blog

1854
01:07:21,000 --> 01:07:24,000
就说他只能用规定的集容语言来写

1855
01:07:24,000 --> 01:07:27,000
但好像没有说不能自带虚拟机吧

1856
01:07:27,000 --> 01:07:30,000
不然那些什么在洛亚的东西是怎么被

1857
01:07:30,000 --> 01:07:31,000
审核通过的

1858
01:07:31,000 --> 01:07:33,000
这就是一个挺模糊的一点

1859
01:07:33,000 --> 01:07:34,000
就是后来因为很多游戏

1860
01:07:34,000 --> 01:07:38,000
他需要用那个路外解析器做一些辅助的事情

1861
01:07:38,000 --> 01:07:40,000
所以他就后来又通过

1862
01:07:40,000 --> 01:07:43,000
现在我也不太清楚苹果在对这件事情的这个

1863
01:07:43,000 --> 01:07:44,000
的立场是什么

1864
01:07:44,000 --> 01:07:45,000
但是

1865
01:07:45,000 --> 01:07:47,000
这个只能在意了

1866
01:07:47,000 --> 01:07:49,000
我可以再查一下

1867
01:07:49,000 --> 01:07:51,000
因为我有那个

1868
01:07:51,000 --> 01:07:53,000
他们把那个

1869
01:07:53,000 --> 01:07:55,000
Native 就是他的那个演示的代码

1870
01:07:55,000 --> 01:07:58,000
给所有的语汇者都分享了一份

1871
01:07:58,000 --> 01:07:59,000
所以我是可以发个 check

1872
01:07:59,000 --> 01:08:00,000
去看他们到底用什么音讯

1873
01:08:02,000 --> 01:08:03,000
OK

1874
01:08:03,000 --> 01:08:05,000
你可以看一下他用的是苹果原生的

1875
01:08:05,000 --> 01:08:07,000
就是那个叫什么 JavaScript Core 的

1876
01:08:07,000 --> 01:08:08,000
对对对

1877
01:08:08,000 --> 01:08:09,000
JavaScript Core

1878
01:08:09,000 --> 01:08:10,000
我理解应该是吧

1879
01:08:10,000 --> 01:08:13,000
这个是个成本比较低的方案

1880
01:08:13,000 --> 01:08:14,000
你不用自己做任何事情

1881
01:08:16,000 --> 01:08:16,000
而且

1882
01:08:16,000 --> 01:08:19,000
如果每个应用都要自己带一个 JavaScript 解析器的话

1883
01:08:19,000 --> 01:08:22,000
那个应用的尺寸也会比较大

1884
01:08:23,000 --> 01:08:24,000
这是一个问题我觉得

1885
01:08:24,000 --> 01:08:25,000
好

1886
01:08:26,000 --> 01:08:28,000
就是其实现在用那个 React Native

1887
01:08:28,000 --> 01:08:31,000
其实已经有一个 APP 的典范了

1888
01:08:31,000 --> 01:08:34,000
就在 IOS 这个 APP Store 里面

1889
01:08:34,000 --> 01:08:37,000
Facebook 一个叫做新的应用叫做 Groups

1890
01:08:37,000 --> 01:08:39,000
就是 Facebook 群组的这个单独的一个应用

1891
01:08:39,000 --> 01:08:43,000
它其实是在很大程度下用了这个 React Native 写的

1892
01:08:44,000 --> 01:08:45,000
然后我之前

1893
01:08:45,000 --> 01:08:48,000
我在知道他是用 React Native 之前

1894
01:08:48,000 --> 01:08:49,000
我就已经下载过

1895
01:08:49,000 --> 01:08:49,000
用过它

1896
01:08:49,000 --> 01:08:51,000
当时我完全没有感觉到

1897
01:08:51,000 --> 01:08:53,000
它不是一个 Native 的软件

1898
01:08:53,000 --> 01:08:54,000
就是非常

1899
01:08:54,000 --> 01:08:56,000
就整个体验是非常好的

1900
01:08:56,000 --> 01:08:58,000
问题是我们并不是很清楚说

1901
01:08:58,000 --> 01:09:01,000
它到底哪一部分是 UI 的那个

1902
01:09:02,000 --> 01:09:03,000
就是多少比例是用的

1903
01:09:03,000 --> 01:09:06,000
对或许正是这个好处所在

1904
01:09:06,000 --> 01:09:08,000
你知道用户如果说他

1905
01:09:08,000 --> 01:09:10,000
他都不知道哪一部分

1906
01:09:10,000 --> 01:09:11,000
他都感受不出来

1907
01:09:11,000 --> 01:09:13,000
那就证明这个东西说不定就成功了

1908
01:09:13,000 --> 01:09:14,000
对

1909
01:09:15,000 --> 01:09:15,000
对

1910
01:09:15,000 --> 01:09:15,000
对

1911
01:09:15,000 --> 01:09:17,000
我们所拿

1912
01:09:17,000 --> 01:09:20,000
就是与会者所拿到的这个版本跟

1913
01:09:21,000 --> 01:09:23,000
Facebook 他所用的版本实际上是不同步的

1914
01:09:23,000 --> 01:09:27,000
Facebook 他还在做很多的工作来

1915
01:09:27,000 --> 01:09:29,000
把这个东西给完善

1916
01:09:29,000 --> 01:09:32,000
然后才会正式的向大众发布

1917
01:09:32,000 --> 01:09:33,000
目前来说的话

1918
01:09:33,000 --> 01:09:35,000
我们所看到的版本

1919
01:09:35,000 --> 01:09:35,000
都是一个

1920
01:09:35,000 --> 01:09:36,000
只是一个

1921
01:09:37,000 --> 01:09:38,000
Tech Pro View

1922
01:09:38,000 --> 01:09:39,000
Kind of thing

1923
01:09:42,000 --> 01:09:43,000
OK 明白

1924
01:09:44,000 --> 01:09:46,000
就是说 React Native 刚才

1925
01:09:46,000 --> 01:09:47,000
威伦也提到了

1926
01:09:47,000 --> 01:09:48,000
他们的口号是叫做 Learn Once

1927
01:09:48,000 --> 01:09:49,000
Write Everywhere

1928
01:09:49,000 --> 01:09:52,000
然后其实我也在想

1929
01:09:52,000 --> 01:09:54,000
如果你按这种方式去构建你的 App 之后

1930
01:09:54,000 --> 01:09:57,000
其实还是可以有满多部件

1931
01:09:57,000 --> 01:09:59,000
是可以在各平台间重用的

1932
01:09:59,000 --> 01:10:01,000
比如说之前

1933
01:10:01,000 --> 01:10:03,000
我那是在前期还是上前期的时候

1934
01:10:03,000 --> 01:10:05,000
我们在讨论过

1935
01:10:05,000 --> 01:10:07,000
那个 Google 不是做了那个叫 Inbox 那个 App 吗

1936
01:10:07,000 --> 01:10:08,000
就新的

1937
01:10:08,000 --> 01:10:11,000
但是它是有安卓版有 AS 版

1938
01:10:11,000 --> 01:10:12,000
然后还有一个这个 Chrome

1939
01:10:12,000 --> 01:10:15,000
只有 Chrome 软件可以用的 Web 版

1940
01:10:15,000 --> 01:10:17,000
然后他们后来发了一篇博客文章

1941
01:10:17,000 --> 01:10:19,000
就讲他们怎么去做这么一件事

1942
01:10:19,000 --> 01:10:20,000
就是说他们把这个

1943
01:10:20,000 --> 01:10:22,000
假设你把这个整个应用分成两部分

1944
01:10:22,000 --> 01:10:23,000
一对是前端

1945
01:10:23,000 --> 01:10:26,000
就跟那个用户交互的那部分

1946
01:10:26,000 --> 01:10:27,000
那么这部分就是说在

1947
01:10:27,000 --> 01:10:29,000
iOS 上面就是 Object C 写的

1948
01:10:29,000 --> 01:10:32,000
然后在安卓上就是用那个 Java 写的

1949
01:10:32,000 --> 01:10:34,000
然后在这个

1950
01:10:34,000 --> 01:10:36,000
Web 上就是 JavaScript 写的

1951
01:10:36,000 --> 01:10:38,000
但是他们其实都是用 Java 写的

1952
01:10:38,000 --> 01:10:40,000
然后通过 GWT 转化成 JavaScript

1953
01:10:40,000 --> 01:10:43,000
然后通过一个叫做 J 2 Object C 的一个工具

1954
01:10:43,000 --> 01:10:45,000
转换成 Object C 代码来做

1955
01:10:45,000 --> 01:10:48,000
不做那个逻辑的那一部分

1956
01:10:48,000 --> 01:10:51,000
就是跟原生界面无关

1957
01:10:51,000 --> 01:10:53,000
但是是跟这个后台的事物逻辑相关的

1958
01:10:53,000 --> 01:10:54,000
就是同一套语言

1959
01:10:54,000 --> 01:10:56,000
然后再转化成不同的

1960
01:10:56,000 --> 01:10:58,000
通常用 Java 写

1961
01:10:58,000 --> 01:10:59,000
然后通过这两种工具转换成

1962
01:10:59,000 --> 01:11:01,000
对应的 JavaScript 或者 Object C

1963
01:11:01,000 --> 01:11:04,000
但如果我们用这个 Reality 来写的话

1964
01:11:04,000 --> 01:11:06,000
其实就这一步都可以省去了

1965
01:11:06,000 --> 01:11:09,000
我直接把所有的事物和逻辑

1966
01:11:09,000 --> 01:11:11,000
都写成 JavaScript 就好了

1967
01:11:11,000 --> 01:11:15,000
对其实这让我想起那个

1968
01:11:15,000 --> 01:11:19,000
AppCelerator 出的 Titanium

1969
01:11:19,000 --> 01:11:22,000
它也是用 JavaScript 来写整个所有的事物逻辑

1970
01:11:22,000 --> 01:11:26,000
但是其使用的那个 UI Widgets

1971
01:11:26,000 --> 01:11:29,000
全都是原生的

1972
01:11:29,000 --> 01:11:30,000
它那个体验怎么样呢

1973
01:11:30,000 --> 01:11:32,000
不是特别好

1974
01:11:32,000 --> 01:11:39,000
就因为前公司在做 Mobile App 的时候

1975
01:11:39,000 --> 01:11:41,000
考虑过用 Titanium

1976
01:11:41,000 --> 01:11:44,000
可能当时最大的一个问题就是

1977
01:11:44,000 --> 01:11:48,000
首先那个时候正好是 IOS 6 升到 7 的过程中

1978
01:11:48,000 --> 01:11:52,000
然后他们大概是比 7 落后了

1979
01:11:52,000 --> 01:11:54,000
可能三到五个月的时间

1980
01:11:54,000 --> 01:11:55,000
就是我觉得这个是不可忍受的

1981
01:11:55,000 --> 01:11:58,000
就新的 IOS 版本已经在那边了

1982
01:11:58,000 --> 01:11:59,000
然后你如果你用 Titanium 的话

1983
01:11:59,000 --> 01:12:02,000
你用不到新的那些 Widgets

1984
01:12:02,000 --> 01:12:03,000
对

1985
01:12:03,000 --> 01:12:08,000
然后他们的那一套东西据说

1986
01:12:08,000 --> 01:12:10,000
其实是非常优秀的

1987
01:12:10,000 --> 01:12:14,000
但是没有什么文档主要是

1988
01:12:16,000 --> 01:12:18,000
可能是用任何第三方平台

1989
01:12:18,000 --> 01:12:20,000
或者是框架都会遇到的问题吧

1990
01:12:20,000 --> 01:12:21,000
对

1991
01:12:21,000 --> 01:12:23,000
据说 AppCelerator 还在搞

1992
01:12:23,000 --> 01:12:25,000
现在还在搞一些新的什么东西

1993
01:12:25,000 --> 01:12:28,000
但我一时也想不出来名字了

1994
01:12:28,000 --> 01:12:32,000
其大概的走向可能会 React

1995
01:12:32,000 --> 01:12:34,000
有点一举同工的地方

1996
01:12:34,000 --> 01:12:36,000
我还要看一下

1997
01:12:36,000 --> 01:12:37,000
OK

1998
01:12:37,000 --> 01:12:39,000
那说回这个 Renative 这种方式

1999
01:12:39,000 --> 01:12:41,000
其实我还不是特别赞同

2000
01:12:41,000 --> 01:12:43,000
他们说完全不在乎这个

2001
01:12:43,000 --> 01:12:44,000
Right once, wrong anywhere

2002
01:12:44,000 --> 01:12:45,000
这么一个口号的话

2003
01:12:45,000 --> 01:12:47,000
就说起码你假设你看到

2004
01:12:47,000 --> 01:12:49,000
像这些后台的逻辑

2005
01:12:49,000 --> 01:12:51,000
还有这些数据这些模型

2006
01:12:51,000 --> 01:12:52,000
都可以用 Javascript 勾结

2007
01:12:52,000 --> 01:12:54,000
这一块是完全可以在各平台间重用

2008
01:12:54,000 --> 01:12:55,000
没错

2009
01:12:55,000 --> 01:12:57,000
而且我可以预见到

2010
01:12:57,000 --> 01:13:00,000
肯定会有人做一个中间层

2011
01:13:00,000 --> 01:13:02,000
然后说用这些组件的话

2012
01:13:02,000 --> 01:13:03,000
这些组件可以

2013
01:13:03,000 --> 01:13:06,000
就变成那个 environmental sensitive

2014
01:13:06,000 --> 01:13:09,000
然后他们会根据 environment 来

2015
01:13:09,000 --> 01:13:11,000
就原生了组件

2016
01:13:11,000 --> 01:13:13,000
TabView 你可以用这个组件的 TabView

2017
01:13:13,000 --> 01:13:16,000
然后这个 TabView 背后的实现

2018
01:13:16,000 --> 01:13:19,000
会根据你的 target 是 Android

2019
01:13:19,000 --> 01:13:20,000
或 target 的 IOS

2020
01:13:20,000 --> 01:13:25,000
来自动选择相应平台的 TabView

2021
01:13:25,000 --> 01:13:26,000
这并不是 React Native

2022
01:13:26,000 --> 01:13:28,000
自己本身的一个设计理念

2023
01:13:28,000 --> 01:13:32,000
React Native 非常鼓励你去

2024
01:13:32,000 --> 01:13:35,000
根据各种平台本身的特性

2025
01:13:35,000 --> 01:13:38,000
来设计不一样的 UI

2026
01:13:38,000 --> 01:13:40,000
来用不一样的 component

2027
01:13:40,000 --> 01:13:44,000
而不是像这样的简单的替换的逻辑

2028
01:13:44,000 --> 01:13:45,000
但是我想我们肯定会看到

2029
01:13:45,000 --> 01:13:49,000
第三方的一些 solution 出来的

2030
01:13:50,000 --> 01:13:52,000
对我觉得这个就是很多

2031
01:13:52,000 --> 01:13:54,000
像企业这种软件

2032
01:13:54,000 --> 01:13:55,000
可能会采取这种方式

2033
01:13:55,000 --> 01:13:56,000
因为它没有那么多的资源

2034
01:13:56,000 --> 01:13:58,000
或者说就是人手

2035
01:13:58,000 --> 01:14:00,000
去优化每一个平台的细节的体验

2036
01:14:00,000 --> 01:14:03,000
那么更加节省成本的

2037
01:14:03,000 --> 01:14:05,000
节省开发时间的一个方式

2038
01:14:05,000 --> 01:14:07,000
就是通过这种中间层去转换一下

2039
01:14:07,000 --> 01:14:08,000
我觉得

2040
01:14:09,000 --> 01:14:10,000
虽然体验不是太好

2041
01:14:10,000 --> 01:14:12,000
但是起码成本下去了

2042
01:14:12,000 --> 01:14:14,000
我觉得这个对很多企业软件来讲

2043
01:14:14,000 --> 01:14:16,000
就是这样的一个诉求

2044
01:14:16,000 --> 01:14:16,000
没错

2045
01:14:18,000 --> 01:14:24,000
我们现在等于说如果 React Native 这一套

2046
01:14:25,000 --> 01:14:28,000
能够吸引到一部分人

2047
01:14:28,000 --> 01:14:30,000
去把它炒起来的话

2048
01:14:30,000 --> 01:14:34,000
可以说企业级跨平台应用开发

2049
01:14:34,000 --> 01:14:35,000
又多了一个新的选择

2050
01:14:35,000 --> 01:14:38,000
在 Java 变成 JavaScript

2051
01:14:39,000 --> 01:14:42,000
我有跟我们的 developers 所讨论这个问题

2052
01:14:43,000 --> 01:14:45,000
它并不单是在 solution 上

2053
01:14:45,000 --> 01:14:49,000
就是 tech solution 上有改变你的组织架构

2054
01:14:49,000 --> 01:14:50,000
而关键是说

2055
01:14:51,000 --> 01:14:53,000
如果你想这个

2056
01:14:53,000 --> 01:14:54,000
如果你真正实现

2057
01:14:54,000 --> 01:14:56,000
Learn once write everywhere 的话

2058
01:14:56,000 --> 01:15:00,000
那所谓 web developer 跟

2059
01:15:00,000 --> 01:15:03,000
mobile developer 之间的界限就变得更模糊了

2060
01:15:03,000 --> 01:15:04,000
我觉得对于

2061
01:15:05,000 --> 01:15:07,000
可能是二合一了很多时候

2062
01:15:07,000 --> 01:15:10,000
对企业资源的一个应用

2063
01:15:10,000 --> 01:15:13,000
实际上是一个非常有意思的事情

2064
01:15:13,000 --> 01:15:17,000
所以我们的如果现在 web application

2065
01:15:17,000 --> 01:15:19,000
不需要太多维护的话

2066
01:15:19,000 --> 01:15:21,000
那这时程就可以去写那个

2067
01:15:21,000 --> 01:15:23,000
Android App 去写 IOS App

2068
01:15:23,000 --> 01:15:23,000
对不对

2069
01:15:23,000 --> 01:15:25,000
所以这一点上对企业来说

2070
01:15:25,000 --> 01:15:26,000
可能是一个非常重要的事情

2071
01:15:27,000 --> 01:15:31,000
所以我也有跟我们的 web developer 开玩笑说

2072
01:15:31,000 --> 01:15:35,000
那你现在得赶紧去学 HTML CSS

2073
01:15:35,000 --> 01:15:36,000
不要失恋了

2074
01:15:36,000 --> 01:15:38,000
赶紧开始学

2075
01:15:41,000 --> 01:15:44,000
他现在那个 Renative 这个还是在什么

2076
01:15:44,000 --> 01:15:47,000
ARFA 阶段可能是 pre-ARFA 阶段

2077
01:15:47,000 --> 01:15:50,000
他们现在是说有一个私有的 GitHub 的 repostory

2078
01:15:50,000 --> 01:15:50,000
你们可以访问

2079
01:15:50,000 --> 01:15:52,000
就参与与会者可以访问

2080
01:15:52,000 --> 01:15:54,000
外界还不公开

2081
01:15:55,000 --> 01:15:56,000
我不知道你看了多少

2082
01:15:56,000 --> 01:15:58,000
但是我都就比较好奇

2083
01:15:58,000 --> 01:16:00,000
他怎么去实现他这个

2084
01:16:00,000 --> 01:16:02,000
就是 JavaScript 那部分的业务代码

2085
01:16:02,000 --> 01:16:06,000
业务逻辑怎么去和原生的那些进行交互

2086
01:16:06,000 --> 01:16:07,000
那块是

2087
01:16:07,000 --> 01:16:09,000
我没有还来还没有来得及

2088
01:16:09,000 --> 01:16:12,000
对这个代码本身做很多的研究

2089
01:16:12,000 --> 01:16:15,000
但是对 developer 来说的话

2090
01:16:15,000 --> 01:16:19,000
你所做的事情真的跟以前写 web application

2091
01:16:19,000 --> 01:16:20,000
没有太大的区别

2092
01:16:20,000 --> 01:16:21,000
我可以把流程说一下

2093
01:16:21,000 --> 01:16:24,000
就是说从那个纯粹的开发者的

2094
01:16:24,000 --> 01:16:26,000
这个角度来说的话

2095
01:16:26,000 --> 01:16:29,000
你 clone 这个 repository

2096
01:16:29,000 --> 01:16:32,000
然后你做 NPM install

2097
01:16:32,000 --> 01:16:35,000
就是传统的 JavaScript

2098
01:16:35,000 --> 01:16:36,000
大家都知道

2099
01:16:36,000 --> 01:16:38,000
然后你是说 NPM start

2100
01:16:39,000 --> 01:16:41,000
NPM start 的理由

2101
01:16:41,000 --> 01:16:42,000
原因是

2102
01:16:42,000 --> 01:16:45,000
现在是在一个 dev environment 里头

2103
01:16:45,000 --> 01:16:47,000
你这些 JavaScript 的文件

2104
01:16:47,000 --> 01:16:51,000
需要 serve 到那个 simulator 里头去

2105
01:16:51,000 --> 01:16:51,000
对不对

2106
01:16:51,000 --> 01:16:53,000
那个 SIMulator 里头去

2107
01:16:53,000 --> 01:16:56,000
所以这个 NPM start 就会

2108
01:16:58,000 --> 01:17:00,000
启动一个这样的 serve

2109
01:17:00,000 --> 01:17:02,000
然后 watch 你的那些文件

2110
01:17:03,000 --> 01:17:05,000
然后你如果去看那些文件的话

2111
01:17:05,000 --> 01:17:12,000
实际上跟你写 react 的 web 的 application

2112
01:17:12,000 --> 01:17:14,000
并没有太大的区别

2113
01:17:14,000 --> 01:17:16,000
如果真的要说最大的区别

2114
01:17:16,000 --> 01:17:19,000
可能就是说你没有 CSS file 了

2115
01:17:19,000 --> 01:17:20,000
你所有的 file 都是 inline

2116
01:17:20,000 --> 01:17:21,000
所有的 style 都是 inline

2117
01:17:21,000 --> 01:17:22,000
这是最大的区别了

2118
01:17:22,000 --> 01:17:24,000
其他的东西都看起来非常地相似

2119
01:17:24,000 --> 01:17:27,000
然后你写的是真的是纯

2120
01:17:27,000 --> 01:17:28,000
就是 common.js 那种组件

2121
01:17:30,000 --> 01:17:32,000
最神奇的地方在于

2122
01:17:32,000 --> 01:17:34,000
如果你看到那个 video 的话有这一点

2123
01:17:34,000 --> 01:17:35,000
就是

2124
01:17:36,000 --> 01:17:39,000
比方说如果你改变一下 CSS

2125
01:17:40,000 --> 01:17:41,000
那个 iOS 的 simulator

2126
01:17:41,000 --> 01:17:43,000
是直接可以得到这个结果的

2127
01:17:43,000 --> 01:17:45,000
你是不需要去 recompile 的

2128
01:17:45,000 --> 01:17:47,000
这点非常的神奇

2129
01:17:49,000 --> 01:17:51,000
他们有一个说法

2130
01:17:51,000 --> 01:17:52,000
就是说要实现

2131
01:17:52,000 --> 01:17:55,000
你在这边边境器里面改一行代码

2132
01:17:55,000 --> 01:17:59,000
然后在 iOS 模拟器里面出现改动

2133
01:17:59,000 --> 01:18:00,000
只需要不到一秒

2134
01:18:00,000 --> 01:18:05,000
这个我觉得对开发效率非常大的提升

2135
01:18:05,000 --> 01:18:08,000
live reload 的时间级别

2136
01:18:08,000 --> 01:18:09,000
对

2137
01:18:09,000 --> 01:18:12,000
Java 世界里面有个教练 J-Rebel

2138
01:18:12,000 --> 01:18:13,000
也做类似的事情

2139
01:18:16,000 --> 01:18:18,000
这个我觉得看那个 demo 真的是挺酷炫的

2140
01:18:19,000 --> 01:18:21,000
不过你们觉得这样的话

2141
01:18:21,000 --> 01:18:22,000
那不变成

2142
01:18:23,000 --> 01:18:25,000
Java script 变成一个什么通用能力

2143
01:18:25,000 --> 01:18:26,000
这已经是现实了

2144
01:18:28,000 --> 01:18:29,000
对

2145
01:18:29,000 --> 01:18:31,000
这浏览器已经是好事了

2146
01:18:32,000 --> 01:18:34,000
电脑上面另一层电脑

2147
01:18:34,000 --> 01:18:35,000
对

2148
01:18:35,000 --> 01:18:37,000
这个浏览器那边我们就毫无疑问

2149
01:18:37,000 --> 01:18:38,000
Java script 已经是一个

2150
01:18:38,000 --> 01:18:40,000
如果它不是通用语言

2151
01:18:40,000 --> 01:18:41,000
它至少是一个构建的基石

2152
01:18:41,000 --> 01:18:42,000
因为很多语言可以所谓

2153
01:18:42,000 --> 01:18:44,000
compile to JavaScript

2154
01:18:44,000 --> 01:18:44,000
对

2155
01:18:44,000 --> 01:18:47,000
我觉得 Java script 其实就是现在的 C

2156
01:18:47,000 --> 01:18:50,000
就现在的浏览器

2157
01:18:50,000 --> 01:18:52,000
就是当初的 PDP 11 之类的

2158
01:18:52,000 --> 01:18:58,000
然后 C 语言本来是多设计的

2159
01:18:58,000 --> 01:18:59,000
多么粗糙的一个语言

2160
01:18:59,000 --> 01:19:01,000
但就是因为时事造英雄

2161
01:19:01,000 --> 01:19:04,000
把它推到了现在的霸主地位

2162
01:19:04,000 --> 01:19:05,000
我觉得 Java script 基本上

2163
01:19:05,000 --> 01:19:06,000
就是另外一个 C

2164
01:19:07,000 --> 01:19:07,000
对

2165
01:19:07,000 --> 01:19:09,000
但是现在 reignative 它要做的事情

2166
01:19:09,000 --> 01:19:12,000
就是说把这件事情再往 mobile

2167
01:19:12,000 --> 01:19:13,000
就移动端再推

2168
01:19:13,000 --> 01:19:15,000
因为之前移动端大家还是在

2169
01:19:15,000 --> 01:19:17,000
就至少我们是鼓励

2170
01:19:17,000 --> 01:19:18,000
或者消费者也愿意使用

2171
01:19:18,000 --> 01:19:20,000
所谓的原生的应用

2172
01:19:20,000 --> 01:19:21,000
但这个原生打引号

2173
01:19:21,000 --> 01:19:24,000
就可能说你要用平台自己的那种工具

2174
01:19:24,000 --> 01:19:25,000
然后自己的语言来写

2175
01:19:25,000 --> 01:19:27,000
但现在你在看 reignative

2176
01:19:27,000 --> 01:19:30,000
它能够把整个效果做得这么跟原生

2177
01:19:30,000 --> 01:19:32,000
就是说以假乱真吧至少是

2178
01:19:33,000 --> 01:19:36,000
就完全没有必要再用平台原生的语言来写了

2179
01:19:36,000 --> 01:19:37,000
就好像说

2180
01:19:37,000 --> 01:19:39,000
我是现在是一个 web developer

2181
01:19:39,000 --> 01:19:41,000
那我也可以做 LS 应用

2182
01:19:41,000 --> 01:19:43,000
不需要学这么 object C 或者 Swift

2183
01:19:43,000 --> 01:19:48,000
对这就好像把 C 语言移植到不同的架构的处理器上

2184
01:19:51,000 --> 01:19:52,000
我觉得吴涛刚刚说的很好

2185
01:19:52,000 --> 01:19:54,000
就是这怎么说

2186
01:19:54,000 --> 01:19:57,000
就是既定事实

2187
01:19:57,000 --> 01:19:59,000
Java script 的应用就是既定事实

2188
01:19:59,000 --> 01:20:02,000
所以我很期待 ES 6 ES 7

2189
01:20:02,000 --> 01:20:06,000
因为这个语言本身还是有非常多的问题的

2190
01:20:06,000 --> 01:20:09,000
特别是它的 prototype 这样一个架构

2191
01:20:09,000 --> 01:20:11,000
而不是 class based

2192
01:20:11,000 --> 01:20:13,000
ES 6 ES 7

2193
01:20:13,000 --> 01:20:15,000
我很期待他们把这些问题解决好

2194
01:20:15,000 --> 01:20:16,000
这样的话

2195
01:20:16,000 --> 01:20:18,000
对于我们这些语言的使用者来说

2196
01:20:18,000 --> 01:20:20,000
是一个非常好的事情

2197
01:20:20,000 --> 01:20:23,000
因为作为一个 web developer

2198
01:20:23,000 --> 01:20:24,000
你经常不喜欢

2199
01:20:24,000 --> 01:20:25,000
我不是不喜欢

2200
01:20:25,000 --> 01:20:29,000
而是说在真正的应用上面

2201
01:20:29,000 --> 01:20:34,000
我们很多时候都是在用 prototype 去 simulate class

2202
01:20:34,000 --> 01:20:36,000
因为没有 native class support

2203
01:20:36,000 --> 01:20:38,000
这是我所不喜欢的一点

2204
01:20:38,000 --> 01:20:40,000
不是说 prototype 本身

2205
01:20:40,000 --> 01:20:42,000
在 ES 6 中加入真正的 class support

2206
01:20:42,000 --> 01:20:44,000
这是我所期待的

2207
01:20:44,000 --> 01:20:47,000
prototype 倒是有 prototype 的好处和应用

2208
01:20:47,000 --> 01:20:49,000
但是实际的应用中的话

2209
01:20:49,000 --> 01:20:50,000
如果我们要用 class 的话

2210
01:20:50,000 --> 01:20:52,000
那我还是希望能有真正的 class

2211
01:20:53,000 --> 01:20:54,000
对

2212
01:20:54,000 --> 01:20:56,000
我觉得 class 出现其实是比较

2213
01:20:56,000 --> 01:21:00,000
如果有比较合理的 class 的支持的话

2214
01:21:00,000 --> 01:21:05,000
对于构建大型程序实际上是更加有力的

2215
01:21:05,000 --> 01:21:09,000
因为 prototype based object orientation

2216
01:21:09,000 --> 01:21:10,000
它的优点

2217
01:21:10,000 --> 01:21:12,000
我觉得就在于你做原型开发

2218
01:21:12,000 --> 01:21:13,000
非常的快

2219
01:21:13,000 --> 01:21:15,000
因为你不需要去考虑

2220
01:21:15,000 --> 01:21:22,000
那个模板和实际的 instance 之间的抽象的问题

2221
01:21:22,000 --> 01:21:24,000
但当你要做大一些的东西的时候

2222
01:21:24,000 --> 01:21:27,000
这个抽象其实还是相当必要的

2223
01:21:27,000 --> 01:21:28,000
OK

2224
01:21:28,000 --> 01:21:28,000
对

2225
01:21:28,000 --> 01:21:29,000
我不知道

2226
01:21:29,000 --> 01:21:34,000
因为我对这种所谓传统的经典的 GV class 的这种

2227
01:21:34,000 --> 01:21:35,000
O 的化

2228
01:21:35,000 --> 01:21:37,000
我其实并没有太特别的偏好

2229
01:21:37,000 --> 01:21:40,000
所以我觉得两种都还好

2230
01:21:40,000 --> 01:21:42,000
没有那么

2231
01:21:42,000 --> 01:21:44,000
class based 没有那么好

2232
01:21:44,000 --> 01:21:46,000
prototype based 没有那么差

2233
01:21:46,000 --> 01:21:46,000
我觉得是这样

2234
01:21:46,000 --> 01:21:48,000
Go 也是没有 class 对吧

2235
01:21:48,000 --> 01:21:51,000
Go 根本就没有连 prototype 都没有

2236
01:21:51,000 --> 01:21:52,000
它是基于 interface 的

2237
01:21:52,000 --> 01:21:54,000
完全更不一样

2238
01:21:54,000 --> 01:21:55,000
我觉得其实直接用起来

2239
01:21:55,000 --> 01:21:57,000
我觉得那种是更灵活的

2240
01:21:57,000 --> 01:21:59,000
所以我觉得你其实就是一个你比你比较不喜欢

2241
01:21:59,000 --> 01:22:02,000
经典的 class

2242
01:22:02,000 --> 01:22:03,000
对没错

2243
01:22:03,000 --> 01:22:06,000
加了看太多了

2244
01:22:06,000 --> 01:22:09,000
我觉得你可以去看一看 Io 这个语言

2245
01:22:09,000 --> 01:22:11,000
我不知道怎么念

2246
01:22:11,000 --> 01:22:13,000
它其实也是 prototype based

2247
01:22:13,000 --> 01:22:13,000
然后

2248
01:22:13,000 --> 01:22:16,000
不这个说来其实还蛮奇怪的

2249
01:22:16,000 --> 01:22:19,000
那个 Object C 算是一个经典的 GV class 的

2250
01:22:19,000 --> 01:22:21,000
继承 O 语言也不算

2251
01:22:21,000 --> 01:22:24,000
它是类似于 small talk 那种方式

2252
01:22:24,000 --> 01:22:27,000
它是在 C 上面加了一层 small talk

2253
01:22:27,000 --> 01:22:29,000
然后用一个

2254
01:22:29,000 --> 01:22:31,000
用一个最近看到的句话来说

2255
01:22:31,000 --> 01:22:36,000
Object C 就是过去 25 年计算机语言发展史的缩影

2256
01:22:36,000 --> 01:22:38,000
你在看里面不同语言特性的时候

2257
01:22:39,000 --> 01:22:41,000
如果你从一个计算机历史学家

2258
01:22:41,000 --> 01:22:43,000
加引号的角度来看的话

2259
01:22:43,000 --> 01:22:47,000
就你会看到这个特征来自于那个时代的一个思潮

2260
01:22:47,000 --> 01:22:50,000
考古语言

2261
01:22:50,000 --> 01:22:52,000
所以其实我就很好奇

2262
01:22:52,000 --> 01:22:55,000
就是 Archima Object C 也已经证明了

2263
01:22:55,000 --> 01:22:58,000
就是说你没有一个大规模的

2264
01:22:58,000 --> 01:23:02,000
就没有 class 的支持的一个 O 的语言

2265
01:23:02,000 --> 01:23:03,000
也可以做得很好

2266
01:23:05,000 --> 01:23:07,000
就是不能证明这一点

2267
01:23:07,000 --> 01:23:10,000
我觉得不能不太能证明

2268
01:23:10,000 --> 01:23:12,000
不过这算了

2269
01:23:12,000 --> 01:23:14,000
我们可以留待以后就讨论

2270
01:23:14,000 --> 01:23:17,000
专门讲这个编程语言的一些

2271
01:23:17,000 --> 01:23:21,000
我们刚刚说到就是 JavaScript 应用这么广泛

2272
01:23:21,000 --> 01:23:24,000
实际上在这个 talk 中

2273
01:23:24,000 --> 01:23:28,000
我们有一个 Netflix 的那个 speaker

2274
01:23:28,000 --> 01:23:30,000
他有说到说就是

2275
01:23:30,000 --> 01:23:32,000
我们现在有很多智能那个电视

2276
01:23:32,000 --> 01:23:35,000
智能电视上有很多可以看 Netflix

2277
01:23:35,000 --> 01:23:39,000
然后他们都是用 JavaScript 来写这个东西的

2278
01:23:39,000 --> 01:23:47,000
他们都是 ship 一个 webkit 的封装给电视场上

2279
01:23:47,000 --> 01:23:50,000
然后就其中有他们的 Netflix 的 application

2280
01:23:52,000 --> 01:23:55,000
对 你知道那个 Apple TV 也是这种方式实现的吗

2281
01:23:55,000 --> 01:23:56,000
哦 真有趣

2282
01:23:56,000 --> 01:23:59,000
Netflix 的

2283
01:24:00,000 --> 01:24:05,000
Nexflix 他们实际上现在是用 React 来写那个 TV app

2284
01:24:05,000 --> 01:24:06,000
就好像 React Native 一样

2285
01:24:06,000 --> 01:24:08,000
他们是 React TV

2286
01:24:09,000 --> 01:24:11,000
那个不是开源程序

2287
01:24:11,000 --> 01:24:14,000
但是他有介绍说这个是怎么样实现的

2288
01:24:15,000 --> 01:24:17,000
之前我也在玩那个

2289
01:24:17,000 --> 01:24:21,000
你有那个就什么 Chromecast 那个小棒子吗

2290
01:24:21,000 --> 01:24:22,000
我在公司有

2291
01:24:22,000 --> 01:24:24,000
但是我没有很经常去

2292
01:24:24,000 --> 01:24:25,000
我自己有一个

2293
01:24:25,000 --> 01:24:26,000
然后我之前玩过一段时间

2294
01:24:26,000 --> 01:24:28,000
就他也是那种方式

2295
01:24:28,000 --> 01:24:30,000
他整个就是其实就是一个浏览器窗口

2296
01:24:30,000 --> 01:24:31,000
他你可以电视上的

2297
01:24:33,000 --> 01:24:34,000
然后你们也可以做类似的事情

2298
01:24:34,000 --> 01:24:37,000
就是你可以把整个 React 组件丢过去

2299
01:24:37,000 --> 01:24:39,000
然后做一些很好玩的事

2300
01:24:39,000 --> 01:24:40,000
我插问你一句

2301
01:24:41,000 --> 01:24:43,000
Chromecast 那个小棒子

2302
01:24:43,000 --> 01:24:47,000
他要求有外界的 WiFi 在是吧

2303
01:24:47,000 --> 01:24:49,000
对 他只能通过 WiFi 和外界

2304
01:24:49,000 --> 01:24:51,000
他自己不能提供一个热点

2305
01:24:52,000 --> 01:24:52,000
他自己不

2306
01:24:52,000 --> 01:24:54,000
他是一个 WiFi 接收器而已

2307
01:24:54,000 --> 01:24:56,000
但是你把他 hack 掉

2308
01:24:56,000 --> 01:24:57,000
应该也可能做一个热点

2309
01:24:57,000 --> 01:24:58,000
但为什么你会想到

2310
01:24:58,000 --> 01:25:03,000
因为如果他能够自己成为 WiFi 接点的话

2311
01:25:03,000 --> 01:25:05,000
我出去在酒店里面

2312
01:25:05,000 --> 01:25:07,000
利用酒店的电视

2313
01:25:08,000 --> 01:25:13,000
看在 iPad 上面预先漏的好的视频

2314
01:25:13,000 --> 01:25:15,000
你想发送过去是吧

2315
01:25:15,000 --> 01:25:17,000
不 首先有两点是有问题的

2316
01:25:17,000 --> 01:25:18,000
第一个

2317
01:25:18,000 --> 01:25:21,000
他只能是一个 WiFi 的 client

2318
01:25:21,000 --> 01:25:22,000
他不是一个 AP

2319
01:25:22,000 --> 01:25:24,000
但估计你 hack 一下应该也行

2320
01:25:24,000 --> 01:25:25,000
但第二个问题就是说

2321
01:25:25,000 --> 01:25:29,000
Chromecast 那整个的一个 API

2322
01:25:29,000 --> 01:25:30,000
包括认证机制

2323
01:25:30,000 --> 01:25:32,000
是不允许你随意播放

2324
01:25:32,000 --> 01:25:35,000
你本机的视频文件的

2325
01:25:35,000 --> 01:25:35,000
OK

2326
01:25:35,000 --> 01:25:37,000
就比较麻烦

2327
01:25:37,000 --> 01:25:37,000
你可以做

2328
01:25:37,000 --> 01:25:38,000
但是比较麻烦

2329
01:25:38,000 --> 01:25:39,000
就像私人做

2330
01:25:39,000 --> 01:25:41,000
没有那种比较现成的 AP 来搞这种

2331
01:25:42,000 --> 01:25:43,000
好吧

2332
01:25:43,000 --> 01:25:44,000
不过不影响

2333
01:25:44,000 --> 01:25:46,000
现在很多手机就可以建一个热点

2334
01:25:46,000 --> 01:25:48,000
然后你可以用手机的

2335
01:25:49,000 --> 01:25:50,000
有很多安卓的 AP

2336
01:25:50,000 --> 01:25:51,000
可以让你做到这件事情

2337
01:25:51,000 --> 01:25:52,000
OK

2338
01:25:53,000 --> 01:25:55,000
iOS 就暂时没有解决了

2339
01:25:56,000 --> 01:25:57,000
Apple TV 都没有

2340
01:25:57,000 --> 01:25:58,000
没有办法

2341
01:25:58,000 --> 01:25:58,000
打个岔

2342
01:26:00,000 --> 01:26:01,000
我们接下来讲

2343
01:26:01,000 --> 01:26:03,000
React Native 还有什么要补充的吗

2344
01:26:03,000 --> 01:26:04,000
我跟他差不多

2345
01:26:04,000 --> 01:26:04,000
我想想

2346
01:26:04,000 --> 01:26:06,000
我觉得差不多了吧

2347
01:26:07,000 --> 01:26:08,000
其实有一个问题就是

2348
01:26:09,000 --> 01:26:12,000
React Native 可以用来写游戏吗

2349
01:26:16,000 --> 01:26:18,000
那种什么 Lite game 应该是可以的吧

2350
01:26:18,000 --> 01:26:18,000
我觉得

2351
01:26:18,000 --> 01:26:19,000
对

2352
01:26:19,000 --> 01:26:19,000
就是

2353
01:26:21,000 --> 01:26:22,000
不过也不一定

2354
01:26:22,000 --> 01:26:24,000
有人用那个什么 WebGL 来写

2355
01:26:24,000 --> 01:26:26,000
那种很复杂的设计游戏

2356
01:26:26,000 --> 01:26:29,000
可是在 React Native

2357
01:26:29,000 --> 01:26:32,000
React Native 所能操纵的原生组件

2358
01:26:32,000 --> 01:26:35,000
到底到一个什么层级呢

2359
01:26:35,000 --> 01:26:36,000
比如说那个

2360
01:26:37,000 --> 01:26:38,000
iOS 上面的 SpriteKit

2361
01:26:38,000 --> 01:26:40,000
它可以用吗

2362
01:26:41,000 --> 01:26:43,000
这个就只有 Willow 才能回答

2363
01:26:44,000 --> 01:26:46,000
有人问过类似的问题

2364
01:26:46,000 --> 01:26:47,000
但不是直接问问游戏

2365
01:26:47,000 --> 01:26:48,000
而是说到底

2366
01:26:48,000 --> 01:26:49,000
它可以用到

2367
01:26:49,000 --> 01:26:50,000
哪些组件是可以用是吧

2368
01:26:50,000 --> 01:26:51,000
对

2369
01:26:51,000 --> 01:26:53,000
然后所得到的答案是说

2370
01:26:55,000 --> 01:26:57,000
我的理解不是扣了扣头

2371
01:26:57,000 --> 01:26:59,000
是说所有的组件都是可以用的

2372
01:26:59,000 --> 01:27:00,000
但可能有些组件

2373
01:27:00,000 --> 01:27:02,000
你得自己手工把它包装一下

2374
01:27:03,000 --> 01:27:05,000
OK

2375
01:27:05,000 --> 01:27:05,000
对

2376
01:27:05,000 --> 01:27:06,000
就以什么方式包装

2377
01:27:06,000 --> 01:27:08,000
是说我必须在用 CWRP

2378
01:27:08,000 --> 01:27:10,000
或者是 OBJEC

2379
01:27:10,000 --> 01:27:11,000
写一个 Rapper

2380
01:27:11,000 --> 01:27:12,000
然后它可以调用

2381
01:27:13,000 --> 01:27:13,000
不是

2382
01:27:13,000 --> 01:27:15,000
是在 Java School 这端写一个 Rapper

2383
01:27:16,000 --> 01:27:17,000
你这样想

2384
01:27:18,000 --> 01:27:19,000
你这样想

2385
01:27:20,000 --> 01:27:21,000
不考虑 React Native

2386
01:27:21,000 --> 01:27:23,000
就考虑那个

2387
01:27:23,000 --> 01:27:25,000
React 的 JS 的 part

2388
01:27:25,000 --> 01:27:27,000
你可以用 Deep 对吧

2389
01:27:27,000 --> 01:27:27,000
你可以用 Deep

2390
01:27:27,000 --> 01:27:28,000
你可以用 like

2391
01:27:29,000 --> 01:27:30,000
Almost any HTML component

2392
01:27:31,000 --> 01:27:32,000
但是 Deep 本身

2393
01:27:32,000 --> 01:27:34,000
它有一个中间层是

2394
01:27:35,000 --> 01:27:37,000
React 已经提供给你的

2395
01:27:37,000 --> 01:27:38,000
React 已经写了这个 Deep

2396
01:27:38,000 --> 01:27:39,000
这个 component

2397
01:27:39,000 --> 01:27:40,000
对不对

2398
01:27:40,000 --> 01:27:41,000
就 Virtual DOM 里面会有一个 Deep 的

2399
01:27:41,000 --> 01:27:44,000
对应的一个对象吧

2400
01:27:44,000 --> 01:27:45,000
然后这个

2401
01:27:46,000 --> 01:27:48,000
这个东西是 Java script

2402
01:27:48,000 --> 01:27:49,000
是在 Java script 里头

2403
01:27:49,000 --> 01:27:51,000
有一个组件来告诉 Virtual DOM

2404
01:27:51,000 --> 01:27:53,000
说我自己要做什么

2405
01:27:53,000 --> 01:27:54,000
我能够做什么

2406
01:27:54,000 --> 01:27:55,000
如果我的 state change

2407
01:27:55,000 --> 01:27:57,000
我应该怎么变化

2408
01:27:57,000 --> 01:27:58,000
这个是在那个 Java script

2409
01:27:58,000 --> 01:27:59,000
的 definition 里头的

2410
01:28:00,000 --> 01:28:00,000
同样的

2411
01:28:00,000 --> 01:28:01,000
如果说你现在

2412
01:28:02,000 --> 01:28:04,000
HTML 出现了一个新的东西

2413
01:28:04,000 --> 01:28:05,000
出现了一个新的 tag

2414
01:28:05,000 --> 01:28:06,000
然后你想要用这个 tag

2415
01:28:07,000 --> 01:28:08,000
by the way 那个 React

2416
01:28:08,000 --> 01:28:09,000
还有一些

2417
01:28:09,000 --> 01:28:12,000
SVG 所相关的那个 tag

2418
01:28:12,000 --> 01:28:13,000
它没有实现

2419
01:28:13,000 --> 01:28:14,000
如果大家有兴趣的话

2420
01:28:14,000 --> 01:28:15,000
可以去 contribute

2421
01:28:17,000 --> 01:28:18,000
现在要加入这个

2422
01:28:18,000 --> 01:28:20,000
对这些新的原生 tag

2423
01:28:20,000 --> 01:28:21,000
的实现的话呢

2424
01:28:21,000 --> 01:28:22,000
那你也写一个

2425
01:28:23,000 --> 01:28:24,000
React 的 component

2426
01:28:24,000 --> 01:28:25,000
来实现它对不对

2427
01:28:26,000 --> 01:28:29,000
所以转换成 React native 的逻辑呢

2428
01:28:29,000 --> 01:28:30,000
如果你有一个

2429
01:28:30,000 --> 01:28:33,000
原生的 native 的那个

2430
01:28:33,000 --> 01:28:35,000
component 你要使用的话

2431
01:28:35,000 --> 01:28:38,000
你只需要在 Java script 端写

2432
01:28:38,000 --> 01:28:39,000
写一个 adapter 来说

2433
01:28:40,000 --> 01:28:42,000
这个东西是个什么东西

2434
01:28:42,000 --> 01:28:43,000
怎么样 initialize 它

2435
01:28:43,000 --> 01:28:46,000
它能够提供什么样的操作

2436
01:28:46,000 --> 01:28:47,000
然后

2437
01:28:48,000 --> 01:28:50,000
React 的那个引擎

2438
01:28:50,000 --> 01:28:53,000
肯定有一个就是 protocol 来说

2439
01:28:53,000 --> 01:28:54,000
你要怎么写这个文件

2440
01:28:54,000 --> 01:28:55,000
在 Java script

2441
01:28:55,000 --> 01:28:56,000
然后你按照它

2442
01:28:57,000 --> 01:28:58,000
一幅画片把它写出来之后呢

2443
01:28:58,000 --> 01:29:00,000
那你就可以用这个原生组件了

2444
01:29:00,000 --> 01:29:02,000
但我觉得可能无套的问题就是说

2445
01:29:02,000 --> 01:29:04,000
那是就是说

2446
01:29:04,000 --> 01:29:06,000
是 React native 这个 library 提供

2447
01:29:07,000 --> 01:29:09,000
Java script 到

2448
01:29:09,000 --> 01:29:11,000
这个 iOS 的那些原生组件

2449
01:29:11,000 --> 01:29:12,000
这一个桥吗

2450
01:29:12,000 --> 01:29:13,000
还是怎么样

2451
01:29:13,000 --> 01:29:16,000
是 React native 自己本身实现那一个

2452
01:29:16,000 --> 01:29:19,000
那这会不会有这样类似于

2453
01:29:19,000 --> 01:29:20,000
这个叫什么 titanium 那种

2454
01:29:20,000 --> 01:29:21,000
同样的问题就是说

2455
01:29:21,000 --> 01:29:24,000
你要等这个 React native 这个 library

2456
01:29:24,000 --> 01:29:26,000
提供了对应的

2457
01:29:26,000 --> 01:29:29,000
这个比如说 iOS 的一些

2458
01:29:29,000 --> 01:29:32,000
原生的组件的这个桥了之后

2459
01:29:32,000 --> 01:29:33,000
你才可以用的

2460
01:29:33,000 --> 01:29:34,000
而不是说我自己可以

2461
01:29:34,000 --> 01:29:35,000
比如假设苹果 iOS 9

2462
01:29:35,000 --> 01:29:37,000
它又出了一些新的原生组件

2463
01:29:37,000 --> 01:29:38,000
那我作为开发者

2464
01:29:38,000 --> 01:29:39,000
我可以自己包一下就可以用

2465
01:29:39,000 --> 01:29:40,000
而不是说要等到

2466
01:29:41,000 --> 01:29:42,000
这个 React native 发布一个新版

2467
01:29:42,000 --> 01:29:43,000
支持说

2468
01:29:43,000 --> 01:29:46,000
就说 expose 那些原生的组件出来

2469
01:29:46,000 --> 01:29:47,000
才可以用的

2470
01:29:48,000 --> 01:29:50,000
根据在那个

2471
01:29:50,000 --> 01:29:52,000
会上的 Q&A 的答案的话

2472
01:29:52,000 --> 01:29:55,000
我相信是你可以自己来做这个事情

2473
01:29:55,000 --> 01:29:57,000
就他们做了一个通用的桥

2474
01:29:57,000 --> 01:29:58,000
这个非常好

2475
01:29:58,000 --> 01:29:59,000
这个就很厉害了

2476
01:29:59,000 --> 01:30:00,000
就不用考虑

2477
01:30:00,000 --> 01:30:02,000
就不会遇到之前 titanium 那种问题了

2478
01:30:02,000 --> 01:30:03,000
对

2479
01:30:04,000 --> 01:30:04,000
这个真的不

2480
01:30:04,000 --> 01:30:05,000
这个了不得

2481
01:30:06,000 --> 01:30:08,000
我刚才这样那么 swap 不就挂了

2482
01:30:10,000 --> 01:30:11,000
JavaScript 多简单

2483
01:30:12,000 --> 01:30:14,000
你知道技术的发展

2484
01:30:14,000 --> 01:30:15,000
总是有很多不确定性的

2485
01:30:15,000 --> 01:30:17,000
所以大家不要把鸡蛋

2486
01:30:17,000 --> 01:30:18,000
放在同一个篮子里头

2487
01:30:19,000 --> 01:30:20,000
这是没错

2488
01:30:20,000 --> 01:30:21,000
还好我已经不做前段了

2489
01:30:21,000 --> 01:30:22,000
也

2490
01:30:23,000 --> 01:30:24,000
不过这也是一个问题

2491
01:30:24,000 --> 01:30:26,000
前端真的变化好快

2492
01:30:26,000 --> 01:30:27,000
对

2493
01:30:27,000 --> 01:30:29,000
其实这也是我在提纲里面写的

2494
01:30:29,000 --> 01:30:30,000
就是

2495
01:30:30,000 --> 01:30:32,000
我觉得现在前端真的是没有人知道

2496
01:30:32,000 --> 01:30:33,000
峰会往里面吹

2497
01:30:34,000 --> 01:30:35,000
就是说三天一小遍

2498
01:30:35,000 --> 01:30:36,000
七天一大遍

2499
01:30:36,000 --> 01:30:37,000
对

2500
01:30:37,000 --> 01:30:39,000
就是 front end technology

2501
01:30:39,000 --> 01:30:41,000
可能你这个网站你所用的东西

2502
01:30:41,000 --> 01:30:43,000
跟另外一个网站所用的东西

2503
01:30:43,000 --> 01:30:45,000
完全不一样

2504
01:30:45,000 --> 01:30:47,000
没有任何一点点交集

2505
01:30:47,000 --> 01:30:48,000
然后两个人都觉得

2506
01:30:49,000 --> 01:30:51,000
自己做的才是前途

2507
01:30:51,000 --> 01:30:52,000
或者反过来两个人都觉得

2508
01:30:52,000 --> 01:30:54,000
对方做的才是正确的

2509
01:30:54,000 --> 01:30:57,000
这个是非常让人疑惑的一件事情

2510
01:30:57,000 --> 01:30:57,000
其实

2511
01:30:57,000 --> 01:30:59,000
你这个都是高端了

2512
01:30:59,000 --> 01:31:00,000
你想遇到那种比较低端的

2513
01:31:00,000 --> 01:31:01,000
那些说

2514
01:31:01,000 --> 01:31:01,000
哼

2515
01:31:01,000 --> 01:31:02,000
我们不是都是用 JCurry 吗

2516
01:31:02,000 --> 01:31:03,000
对

2517
01:31:05,000 --> 01:31:06,000
你知道就是所谓

2518
01:31:06,000 --> 01:31:07,000
就是最好的时代

2519
01:31:07,000 --> 01:31:09,000
也是最坏的时代

2520
01:31:09,000 --> 01:31:09,000
对

2521
01:31:09,000 --> 01:31:11,000
你看看你自己说出的位置是怎么样

2522
01:31:14,000 --> 01:31:16,000
我觉得这也可能就是前端技术

2523
01:31:16,000 --> 01:31:19,000
比较让人有兴趣的一部分

2524
01:31:20,000 --> 01:31:22,000
你总是可以看到一些新的

2525
01:31:22,000 --> 01:31:24,000
然后看到一些有趣的东西

2526
01:31:24,000 --> 01:31:25,000
看到年轻人的活力

2527
01:31:26,000 --> 01:31:27,000
对

2528
01:31:27,000 --> 01:31:30,000
这从一个程度上来讲的话

2529
01:31:30,000 --> 01:31:31,000
它也是有

2530
01:31:31,000 --> 01:31:33,000
就是技术有很固定的时候

2531
01:31:33,000 --> 01:31:36,000
比方说算是阶段性发展

2532
01:31:36,000 --> 01:31:37,000
你知道

2533
01:31:37,000 --> 01:31:38,000
就 JCurry

2534
01:31:38,000 --> 01:31:39,000
有 JCurry 的一段时间

2535
01:31:39,000 --> 01:31:40,000
大家都用 JCurry

2536
01:31:40,000 --> 01:31:41,000
然后 Backbone 的一段时间

2537
01:31:41,000 --> 01:31:42,000
大家都用 Backbone

2538
01:31:42,000 --> 01:31:43,000
然后我觉得我们可能

2539
01:31:43,000 --> 01:31:44,000
之所以这么

2540
01:31:44,000 --> 01:31:45,000
就是现在那么精彩

2541
01:31:45,000 --> 01:31:47,000
是因为我们在进入一个新的阶段

2542
01:31:49,000 --> 01:31:51,000
从我的角度来说的话

2543
01:31:51,000 --> 01:31:53,000
我觉得 React 是最承诺的一个解决

2544
01:31:53,000 --> 01:31:54,000
因为 Angler

2545
01:31:54,000 --> 01:31:55,000
看自己在吃饭

2546
01:31:55,000 --> 01:31:56,000
你看

2547
01:31:58,000 --> 01:31:58,000
没办法

2548
01:31:58,000 --> 01:31:59,000
这个

2549
01:31:59,000 --> 01:31:59,000
对

2550
01:31:59,000 --> 01:32:01,000
太复杂了他们

2551
01:32:01,000 --> 01:32:02,000
所以

2552
01:32:02,000 --> 01:32:05,000
而且它那个 2.0 跟 1.0 又不匹配

2553
01:32:05,000 --> 01:32:06,000
然后 2.0 又在

2554
01:32:06,000 --> 01:32:08,000
又需要那么长时间来开发

2555
01:32:08,000 --> 01:32:10,000
所以 Angler 有点就是

2556
01:32:10,000 --> 01:32:12,000
就是自身的那个

2557
01:32:12,000 --> 01:32:13,000
即将作死

2558
01:32:13,000 --> 01:32:15,000
真的有点这个意思

2559
01:32:16,000 --> 01:32:18,000
所以 React

2560
01:32:18,000 --> 01:32:20,000
很可能就是下一个阶段的

2561
01:32:20,000 --> 01:32:21,000
一个主力了

2562
01:32:21,000 --> 01:32:24,000
所以我不管你对

2563
01:32:25,000 --> 01:32:26,000
React 自己本身

2564
01:32:26,000 --> 01:32:27,000
怎么想

2565
01:32:27,000 --> 01:32:28,000
就是做一个前段的开发者的话

2566
01:32:28,000 --> 01:32:30,000
真的应该去了解它

2567
01:32:30,000 --> 01:32:32,000
至少知道它为什么好

2568
01:32:32,000 --> 01:32:34,000
或者是它哪里好

2569
01:32:36,000 --> 01:32:39,000
而且从公司的支持来说的话

2570
01:32:39,000 --> 01:32:41,000
Facebook 对 React 支持

2571
01:32:41,000 --> 01:32:43,000
是非常非常强烈的

2572
01:32:43,000 --> 01:32:45,000
你可以看到它

2573
01:32:45,000 --> 01:32:46,000
它从

2574
01:32:46,000 --> 01:32:47,000
它最初是

2575
01:32:47,000 --> 01:32:49,000
最初的模型是 Facebook Ads Group

2576
01:32:49,000 --> 01:32:52,000
就是 Ads Group 做出来的

2577
01:32:52,000 --> 01:32:53,000
然后现在

2578
01:32:53,000 --> 01:32:54,000
后来到 Chat 到

2579
01:32:54,000 --> 01:32:55,000
大部分的前段

2580
01:32:55,000 --> 01:32:57,000
他们所现在写的都是

2581
01:32:57,000 --> 01:32:58,000
Adopt React

2582
01:32:58,000 --> 01:33:01,000
到 Group 现在用用 React Native 写

2583
01:33:01,000 --> 01:33:04,000
所以 React 背后有非常多 Facebook 的支持

2584
01:33:04,000 --> 01:33:07,000
反观 Angler 反倒是在 Google 里头

2585
01:33:07,000 --> 01:33:08,000
它自己都不怎么用吗

2586
01:33:08,000 --> 01:33:09,000
对

2587
01:33:09,000 --> 01:33:10,000
我们并不知道特别多的

2588
01:33:10,000 --> 01:33:11,000
Angler 所写的应用

2589
01:33:11,000 --> 01:33:14,000
那个 Inbox 倒是一个

2590
01:33:14,000 --> 01:33:16,000
Angler 的案例对不对

2591
01:33:16,000 --> 01:33:18,000
Inbox 是不是

2592
01:33:18,000 --> 01:33:23,000
上次 Ryo 说是 GWP 写的

2593
01:33:23,000 --> 01:33:25,000
然后我冲动的破碎了这个谣言

2594
01:33:25,000 --> 01:33:25,000
对

2595
01:33:25,000 --> 01:33:26,000
它是这样

2596
01:33:26,000 --> 01:33:27,000
它是两部分

2597
01:33:27,000 --> 01:33:29,000
它的前端那部分不知道没有说

2598
01:33:29,000 --> 01:33:31,000
但是后就是那个业务逻辑那边

2599
01:33:31,000 --> 01:33:32,000
它是加把转过去了

2600
01:33:32,000 --> 01:33:32,000
对

2601
01:33:32,000 --> 01:33:33,000
OK

2602
01:33:33,000 --> 01:33:34,000
OK

2603
01:33:34,000 --> 01:33:34,000
就是

2604
01:33:34,000 --> 01:33:36,000
我现在不想说

2605
01:33:36,000 --> 01:33:37,000
你别写我这些

2606
01:33:37,000 --> 01:33:37,000
OK

2607
01:33:37,000 --> 01:33:39,000
很有可能就是它

2608
01:33:39,000 --> 01:33:41,000
它的 Inbox 的网页版的前端

2609
01:33:41,000 --> 01:33:43,000
可能是用 Angler JS 写的

2610
01:33:43,000 --> 01:33:43,000
对

2611
01:33:44,000 --> 01:33:46,000
还有它或许有很多 Internal Tool

2612
01:33:46,000 --> 01:33:47,000
用 Angler 写

2613
01:33:47,000 --> 01:33:49,000
但是我们并没有看到很多直接的支持

2614
01:33:49,000 --> 01:33:50,000
我觉得这一点上

2615
01:33:50,000 --> 01:33:52,000
对于技术本身的发展

2616
01:33:52,000 --> 01:33:55,000
是不是特别好

2617
01:33:55,000 --> 01:33:57,000
因为没有干爹支持

2618
01:33:57,000 --> 01:33:58,000
对

2619
01:34:00,000 --> 01:34:02,000
这个是个很大的问题

2620
01:34:03,000 --> 01:34:05,000
我们看选技术选择

2621
01:34:05,000 --> 01:34:06,000
而且先看爹

2622
01:34:06,000 --> 01:34:07,000
对吧

2623
01:34:07,000 --> 01:34:08,000
你还选了 Go

2624
01:34:08,000 --> 01:34:09,000
真的是这样子

2625
01:34:09,000 --> 01:34:09,000
现在干啥

2626
01:34:09,000 --> 01:34:10,000
天哪

2627
01:34:11,000 --> 01:34:13,000
我们接下来说一下 Relay

2628
01:34:13,000 --> 01:34:16,000
这个还是要留在下期还是怎么样

2629
01:34:16,000 --> 01:34:18,000
还是一次过把它讲完好了

2630
01:34:19,000 --> 01:34:21,000
他们这次这个大会上面

2631
01:34:21,000 --> 01:34:25,000
除了发布令人激动人心什么

2632
01:34:25,000 --> 01:34:29,000
令 Web App 可以秒杀 IOS

2633
01:34:29,000 --> 01:34:29,000
或者安卓

2634
01:34:29,000 --> 01:34:30,000
Groundbreaking

2635
01:34:30,000 --> 01:34:32,000
就直接

2636
01:34:32,000 --> 01:34:34,000
直接就秒试了的这么一个

2637
01:34:34,000 --> 01:34:36,000
对 Groundbreaking 的技术之外

2638
01:34:36,000 --> 01:34:37,000
还发布了一个

2639
01:34:37,000 --> 01:34:39,000
其实作为一个前端开发

2640
01:34:39,000 --> 01:34:40,000
半个前端开发者

2641
01:34:40,000 --> 01:34:41,000
对我来讲

2642
01:34:41,000 --> 01:34:43,000
这个还是非常令我激动的

2643
01:34:43,000 --> 01:34:45,000
要做一个 Relay 的这么一个技术

2644
01:34:46,000 --> 01:34:48,000
这个事情跟之前讲的 Flux

2645
01:34:48,000 --> 01:34:50,000
是有或多或少的关系的

2646
01:34:50,000 --> 01:34:53,000
因为他们在去年发布 Flux 架构的时候

2647
01:34:53,000 --> 01:34:54,000
并没有说

2648
01:34:54,000 --> 01:34:55,000
因为 Flux 它只是一个 idea

2649
01:34:55,000 --> 01:34:56,000
刚才魏导也讲了

2650
01:34:56,000 --> 01:34:57,000
他并没有说告诉你一些

2651
01:34:57,000 --> 01:35:00,000
具体的执行的措施是怎么样子

2652
01:35:00,000 --> 01:35:01,000
然后其中有一个很

2653
01:35:03,000 --> 01:35:04,000
任何一个 Web App

2654
01:35:04,000 --> 01:35:05,000
都逃不掉的问题

2655
01:35:05,000 --> 01:35:06,000
就是你怎么去

2656
01:35:06,000 --> 01:35:07,000
从服务端获取数据

2657
01:35:08,000 --> 01:35:08,000
对

2658
01:35:09,000 --> 01:35:11,000
然后在传统的方式下

2659
01:35:11,000 --> 01:35:12,000
那个可能最简单的

2660
01:35:12,000 --> 01:35:13,000
我就用 JQuery 写个

2661
01:35:13,000 --> 01:35:14,000
或者用那个什么

2662
01:35:15,000 --> 01:35:16,000
XML HTTP request

2663
01:35:16,000 --> 01:35:17,000
发一个请求

2664
01:35:17,000 --> 01:35:18,000
然后回来

2665
01:35:18,000 --> 01:35:19,000
用什么一个 call back

2666
01:35:19,000 --> 01:35:20,000
就更新了一下这个 DOM

2667
01:35:20,000 --> 01:35:22,000
这个可能是最原始的

2668
01:35:22,000 --> 01:35:24,000
一个从服务端取数据

2669
01:35:24,000 --> 01:35:25,000
然后在一个 Web App

2670
01:35:25,000 --> 01:35:26,000
里面展示的方法

2671
01:35:26,000 --> 01:35:28,000
但是到了一定层级之后

2672
01:35:28,000 --> 01:35:29,000
这种方式就是完全是

2673
01:35:29,000 --> 01:35:29,000
不可以管理的

2674
01:35:30,000 --> 01:35:32,000
有很多其实观看的问题要解决

2675
01:35:32,000 --> 01:35:32,000
没错

2676
01:35:32,000 --> 01:35:35,000
然后他们这次发布的这个 Relay

2677
01:35:35,000 --> 01:35:37,000
其实就是要解决这么一个问题

2678
01:35:39,000 --> 01:35:40,000
我不知道为了你们在之前的时候

2679
01:35:40,000 --> 01:35:42,000
是怎么去做这个

2680
01:35:42,000 --> 01:35:43,000
从服务端获取数据

2681
01:35:43,000 --> 01:35:44,000
这么一个过程

2682
01:35:46,000 --> 01:35:48,000
因为我们都之前都是在用

2683
01:35:48,000 --> 01:35:50,000
那个传统意义上的

2684
01:35:51,000 --> 01:35:52,000
MVC 的 model

2685
01:35:52,000 --> 01:35:53,000
我们还没有到

2686
01:35:53,000 --> 01:35:55,000
我们并没有使用 Storage 的概念

2687
01:35:55,000 --> 01:35:56,000
但是我觉得 Storage 的概念

2688
01:35:56,000 --> 01:36:00,000
可能跟那个 model 是可以 Map 的

2689
01:36:00,000 --> 01:36:02,000
所以然后我们的后台

2690
01:36:02,000 --> 01:36:03,000
是一个 Restful API

2691
01:36:04,000 --> 01:36:06,000
在前端我们有 model

2692
01:36:06,000 --> 01:36:07,000
然后这个 model

2693
01:36:08,000 --> 01:36:10,000
它可以去跟那个后台去 sync

2694
01:36:11,000 --> 01:36:12,000
然后这个 sync 是一个

2695
01:36:12,000 --> 01:36:15,000
Restful 的 Http request

2696
01:36:15,000 --> 01:36:17,000
然后那个 server 会把你所获取

2697
01:36:17,000 --> 01:36:19,000
需要获取的信息给发送回来

2698
01:36:19,000 --> 01:36:20,000
然后这样 model 就有了

2699
01:36:20,000 --> 01:36:23,000
就得到了所有需要的信息

2700
01:36:24,000 --> 01:36:25,000
那么这里就有一个问题

2701
01:36:25,000 --> 01:36:27,000
就是说刚才我们这次

2702
01:36:27,000 --> 01:36:29,000
可能要介入这么一个新的概念

2703
01:36:29,000 --> 01:36:32,000
也不叫先说你做前端开发

2704
01:36:32,000 --> 01:36:34,000
肯定会遇到 Rest 这么一个 API

2705
01:36:34,000 --> 01:36:35,000
那什么意思呢

2706
01:36:35,000 --> 01:36:36,000
就是说它起码

2707
01:36:36,000 --> 01:36:37,000
它就说把我把这个我后台

2708
01:36:37,000 --> 01:36:39,000
我能够提供的所有的资源

2709
01:36:39,000 --> 01:36:40,000
一个 resource

2710
01:36:40,000 --> 01:36:43,000
通过一个 UIL 的节点暴露出来

2711
01:36:43,000 --> 01:36:44,000
然后你通过像什么标准的

2712
01:36:44,000 --> 01:36:47,000
什么 put delete post get

2713
01:36:47,000 --> 01:36:50,000
这些方法去获取这些资源

2714
01:36:51,000 --> 01:36:52,000
但是这有一个问题就是说

2715
01:36:53,000 --> 01:36:54,000
我不知道你们那边是不是怎么样子

2716
01:36:54,000 --> 01:36:57,000
就是我看到的大部分的 Rest API

2717
01:36:57,000 --> 01:36:58,000
都有一个共通的问题

2718
01:36:58,000 --> 01:37:00,000
就是它有太多的所谓 endpoint

2719
01:37:00,000 --> 01:37:00,000
太多的节点

2720
01:37:00,000 --> 01:37:01,000
因为每个资源

2721
01:37:01,000 --> 01:37:02,000
就要对应一个节点

2722
01:37:02,000 --> 01:37:03,000
没错

2723
01:37:03,000 --> 01:37:05,000
然后如果为了你讲的那种情况

2724
01:37:05,000 --> 01:37:06,000
如果我理解来没有错的话

2725
01:37:06,000 --> 01:37:08,000
你们也是说

2726
01:37:08,000 --> 01:37:10,000
每一个 model 应该是对应一个

2727
01:37:10,000 --> 01:37:11,000
一个 resource 一个资源

2728
01:37:11,000 --> 01:37:13,000
然后每个 model 去负责去

2729
01:37:13,000 --> 01:37:14,000
那个节点的

2730
01:37:14,000 --> 01:37:17,000
那个资源对应的 Rest 的节点

2731
01:37:17,000 --> 01:37:18,000
去访问它对吧

2732
01:37:19,000 --> 01:37:20,000
但这样我觉得其实这样管理

2733
01:37:20,000 --> 01:37:22,000
和编写起来都不是很方便

2734
01:37:22,000 --> 01:37:23,000
而且在使用起来

2735
01:37:23,000 --> 01:37:24,000
我觉得有很多问题

2736
01:37:24,000 --> 01:37:26,000
就我先讲讲我的体验怎么样子

2737
01:37:26,000 --> 01:37:27,000
感觉

2738
01:37:27,000 --> 01:37:29,000
就像刚才讲节点太多

2739
01:37:29,000 --> 01:37:30,000
你要为每一个资源

2740
01:37:30,000 --> 01:37:31,000
就增加一个节点

2741
01:37:31,000 --> 01:37:32,000
然后你要考虑

2742
01:37:32,000 --> 01:37:34,000
每个资源它能够支持的这些

2743
01:37:34,000 --> 01:37:35,000
所有的这些动词

2744
01:37:35,000 --> 01:37:36,000
verb

2745
01:37:36,000 --> 01:37:38,000
它对应的一些所谓的这个

2746
01:37:38,000 --> 01:37:39,000
这个语意是什么

2747
01:37:39,000 --> 01:37:40,000
比如说我有一个 user

2748
01:37:40,000 --> 01:37:41,000
如果我 put 这个 user

2749
01:37:41,000 --> 01:37:42,000
是一个什么意思对吧

2750
01:37:42,000 --> 01:37:43,000
然后我 post 这个 user

2751
01:37:43,000 --> 01:37:44,000
又是一个什么意思

2752
01:37:44,000 --> 01:37:45,000
然后 delete

2753
01:37:45,000 --> 01:37:46,000
当然可能更好理解一点

2754
01:37:46,000 --> 01:37:48,000
但是因为会牵涉到资源的种

2755
01:37:48,000 --> 01:37:49,000
那个不一样

2756
01:37:49,000 --> 01:37:50,000
有所谓的什么 collection

2757
01:37:50,000 --> 01:37:51,000
有所谓的 individual

2758
01:37:51,000 --> 01:37:53,000
这种 resource

2759
01:37:53,000 --> 01:37:53,000
其实很多事情

2760
01:37:53,000 --> 01:37:55,000
还是不是那么清晰的

2761
01:37:55,000 --> 01:37:55,000
对

2762
01:37:55,000 --> 01:37:58,000
而且这个 Rest 本身的定义

2763
01:37:58,000 --> 01:38:00,000
就是很多人有很不同的理解

2764
01:38:00,000 --> 01:38:01,000
虽然那个最开始那篇

2765
01:38:01,000 --> 01:38:03,000
博士论文里面有把这个概念

2766
01:38:03,000 --> 01:38:04,000
阐述的很详细

2767
01:38:04,000 --> 01:38:06,000
但是我可以确信

2768
01:38:06,000 --> 01:38:07,000
绝大部分做 Rest 的人

2769
01:38:07,000 --> 01:38:10,000
都是没有看过那篇博士论文的

2770
01:38:11,000 --> 01:38:12,000
然后 Rest 我觉得

2771
01:38:12,000 --> 01:38:13,000
还有一个问题就是说

2772
01:38:13,000 --> 01:38:14,000
它的那个

2773
01:38:14,000 --> 01:38:16,000
这个就约束太多了

2774
01:38:16,000 --> 01:38:17,000
首先一个约束就是说

2775
01:38:17,000 --> 01:38:20,000
假设你要暴露出来一个 user

2776
01:38:20,000 --> 01:38:21,000
这么一个节点

2777
01:38:21,000 --> 01:38:22,000
这么一个资源

2778
01:38:22,000 --> 01:38:24,000
可能代表是某一个

2779
01:38:24,000 --> 01:38:26,000
一个账号体系的一个用户对吧

2780
01:38:26,000 --> 01:38:27,000
它返回给你的数据

2781
01:38:27,000 --> 01:38:30,000
肯定是固定结构的

2782
01:38:30,000 --> 01:38:31,000
就是你取一个 user

2783
01:38:31,000 --> 01:38:32,000
你就取到它所有的信息

2784
01:38:32,000 --> 01:38:34,000
比如说你要取它的用户名

2785
01:38:34,000 --> 01:38:35,000
email

2786
01:38:35,000 --> 01:38:37,000
它会把所有的详细的信息

2787
01:38:37,000 --> 01:38:38,000
都返给你

2788
01:38:38,000 --> 01:38:39,000
哪怕你只是需要

2789
01:38:39,000 --> 01:38:40,000
用它的所谓的一个用户名

2790
01:38:40,000 --> 01:38:42,000
来显示出一个

2791
01:38:42,000 --> 01:38:43,000
或者一个头像

2792
01:38:43,000 --> 01:38:44,000
来显示出一个

2793
01:38:44,000 --> 01:38:44,000
一个所谓的

2794
01:38:44,000 --> 01:38:46,000
一个头像框而已对吧

2795
01:38:46,000 --> 01:38:47,000
对你没有它对于它的

2796
01:38:47,000 --> 01:38:49,000
更为精细的控制

2797
01:38:49,000 --> 01:38:49,000
对

2798
01:38:49,000 --> 01:38:51,000
对每一个资源来讲

2799
01:38:51,000 --> 01:38:52,000
你比较难去说

2800
01:38:52,000 --> 01:38:55,000
你在做一些更精细的要求

2801
01:38:55,000 --> 01:38:57,000
而且

2802
01:38:57,000 --> 01:38:58,000
它所谓的

2803
01:38:58,000 --> 01:38:59,000
可组合性也比较低

2804
01:38:59,000 --> 01:39:00,000
比如说

2805
01:39:00,000 --> 01:39:02,000
就是举个最简单的例子

2806
01:39:02,000 --> 01:39:03,000
我有一个 user

2807
01:39:03,000 --> 01:39:04,000
这么一个节点

2808
01:39:04,000 --> 01:39:05,000
然后我有一个像一个 post

2809
01:39:05,000 --> 01:39:06,000
就一个文章

2810
01:39:06,000 --> 01:39:08,000
或者帖子这么一个节点

2811
01:39:08,000 --> 01:39:11,000
我想在取到说这个用户

2812
01:39:11,000 --> 01:39:13,000
发过的那个文章的时候

2813
01:39:13,000 --> 01:39:14,000
你会牵涉到一个很麻烦的问题

2814
01:39:14,000 --> 01:39:15,000
就是说

2815
01:39:15,000 --> 01:39:17,000
你把这个对应的请求

2816
01:39:17,000 --> 01:39:19,000
它显然不是完全归属于

2817
01:39:19,000 --> 01:39:20,000
用户那个节点

2818
01:39:20,000 --> 01:39:21,000
它也不是完全归属于

2819
01:39:21,000 --> 01:39:23,000
这个 post 那个节点对吧

2820
01:39:23,000 --> 01:39:23,000
嗯

2821
01:39:23,000 --> 01:39:24,000
就有一些这种

2822
01:39:24,000 --> 01:39:26,000
很不正交的东西

2823
01:39:26,000 --> 01:39:26,000
出现在里面

2824
01:39:26,000 --> 01:39:28,000
而且你又办法很方便的

2825
01:39:28,000 --> 01:39:29,000
在同一个请求里面

2826
01:39:29,000 --> 01:39:31,000
去同时取这两个不同的东西

2827
01:39:31,000 --> 01:39:33,000
就他们的可组合性

2828
01:39:33,000 --> 01:39:34,000
我觉得是比较低的

2829
01:39:34,000 --> 01:39:35,000
没错

2830
01:39:35,000 --> 01:39:36,000
然后最后一个

2831
01:39:36,000 --> 01:39:38,000
就是说我实际用的体验中

2832
01:39:38,000 --> 01:39:40,000
就是因为大部分的 rest API

2833
01:39:40,000 --> 01:39:42,000
是通过 HTTP 的这种方法

2834
01:39:42,000 --> 01:39:43,000
去访问的

2835
01:39:43,000 --> 01:39:44,000
然后我们现在用的 HTTP

2836
01:39:44,000 --> 01:39:46,000
所谓 1.0 1.1 这个版本

2837
01:39:46,000 --> 01:39:47,000
有一个问题就是说

2838
01:39:47,000 --> 01:39:48,000
它有一个很严酷的

2839
01:39:48,000 --> 01:39:51,000
request response

2840
01:39:51,000 --> 01:39:53,000
就是请求答复

2841
01:39:53,000 --> 01:39:54,000
这么一个流程

2842
01:39:54,000 --> 01:39:55,000
你不可能说

2843
01:39:55,000 --> 01:39:56,000
我发五个请求出去

2844
01:39:56,000 --> 01:39:58,000
然后等五个回复出来对吧

2845
01:39:58,000 --> 01:40:01,000
这种有一个效率的问题

2846
01:40:01,000 --> 01:40:02,000
那么很多人就为了解决

2847
01:40:02,000 --> 01:40:03,000
这个效率问题

2848
01:40:03,000 --> 01:40:04,000
他要去考虑说

2849
01:40:04,000 --> 01:40:05,000
我把这个请求

2850
01:40:05,000 --> 01:40:06,000
所谓打包就是 batch

2851
01:40:07,000 --> 01:40:08,000
比如我要请求五个用户

2852
01:40:08,000 --> 01:40:10,000
或者说我请求五个用户

2853
01:40:10,000 --> 01:40:10,000
三个文章

2854
01:40:10,000 --> 01:40:12,000
我要把这几个请求包在一起

2855
01:40:12,000 --> 01:40:13,000
然后发一个请求过去

2856
01:40:13,000 --> 01:40:15,000
这个时候你用 rest API 的话

2857
01:40:15,000 --> 01:40:16,000
就不是非常好做了

2858
01:40:16,000 --> 01:40:17,000
没错

2859
01:40:17,000 --> 01:40:18,000
所以总体来讲

2860
01:40:18,000 --> 01:40:20,000
我觉得 rest 在

2861
01:40:20,000 --> 01:40:21,000
它的逻辑是很好的

2862
01:40:21,000 --> 01:40:23,000
就是说整个概念是非常方便

2863
01:40:23,000 --> 01:40:26,000
但是我觉得它始终是更适用于

2864
01:40:26,000 --> 01:40:28,000
那种所谓面向文档的

2865
01:40:28,000 --> 01:40:30,000
那种类型的应用是比较好的

2866
01:40:30,000 --> 01:40:32,000
但是在我们目前在做的

2867
01:40:32,000 --> 01:40:33,000
很多这种面向

2868
01:40:33,000 --> 01:40:35,000
一些什么社交网络也好

2869
01:40:35,000 --> 01:40:37,000
还有其他的一些更新形态的应用的时候

2870
01:40:37,000 --> 01:40:38,000
用 rest 这种 API

2871
01:40:38,000 --> 01:40:41,000
其实我觉得并不是一个特别好的选择

2872
01:40:42,000 --> 01:40:43,000
我吃饱了就讲

2873
01:40:43,000 --> 01:40:45,000
我觉得

2874
01:40:45,000 --> 01:40:46,000
就是我们所看到 relate

2875
01:40:46,000 --> 01:40:48,000
它的确在解决

2876
01:40:48,000 --> 01:40:49,000
另外一系列的问题

2877
01:40:49,000 --> 01:40:50,000
但是

2878
01:40:52,000 --> 01:40:56,000
而且是非常有意义的一个解决方案

2879
01:40:56,000 --> 01:40:59,000
我总归是觉得

2880
01:40:59,000 --> 01:41:01,000
relate

2881
01:41:01,000 --> 01:41:04,000
它的意义更在于是

2882
01:41:04,000 --> 01:41:06,000
帮助像 facebook 这样大型的公司

2883
01:41:06,000 --> 01:41:08,000
来管理它的复杂度

2884
01:41:08,000 --> 01:41:10,000
因为只有在那个规模上

2885
01:41:10,000 --> 01:41:13,000
你才会在意那么小级别

2886
01:41:13,000 --> 01:41:15,000
就是说到底是哪个

2887
01:41:15,000 --> 01:41:17,000
哪个 view 得到哪个 field 来

2888
01:41:17,000 --> 01:41:19,000
来减少那个贷款的需求

2889
01:41:19,000 --> 01:41:23,000
然后同时有更好的封装

2890
01:41:23,000 --> 01:41:24,000
和保护不同的数据

2891
01:41:24,000 --> 01:41:26,000
这是非常有意义的事情

2892
01:41:26,000 --> 01:41:28,000
但是我觉得还是跟规模是相关的

2893
01:41:28,000 --> 01:41:32,000
小公司其实是不需要这种复杂的需求的吗

2894
01:41:32,000 --> 01:41:33,000
对

2895
01:41:33,000 --> 01:41:35,000
从很大程度来说

2896
01:41:35,000 --> 01:41:36,000
我觉得是这样子

2897
01:41:36,000 --> 01:41:37,000
但是

2898
01:41:37,000 --> 01:41:38,000
again

2899
01:41:38,000 --> 01:41:39,000
这也是给你一个

2900
01:41:39,000 --> 01:41:41,000
所要解决的问题

2901
01:41:41,000 --> 01:41:42,000
所那个

2902
01:41:42,000 --> 01:41:43,000
available 的方案

2903
01:41:43,000 --> 01:41:45,000
是有相关的

2904
01:41:45,000 --> 01:41:46,000
而且从一定程度上来讲

2905
01:41:46,000 --> 01:41:49,000
如果你在 restfulAPI 的基础上

2906
01:41:49,000 --> 01:41:52,000
加上一些控制的变量

2907
01:41:52,000 --> 01:41:53,000
比如说

2908
01:41:53,000 --> 01:41:56,000
Facebook 自己本身的 Graph API

2909
01:41:56,000 --> 01:41:58,000
有一个叫 field 的概念

2910
01:41:58,000 --> 01:41:58,000
就是

2911
01:41:58,000 --> 01:42:03,000
field 会帮助你

2912
01:42:03,000 --> 01:42:05,000
控制它所返回的那个 attributes

2913
01:42:05,000 --> 01:42:06,000
到底是哪一些 field

2914
01:42:06,000 --> 01:42:10,000
这跟 relay 中的一些概念是非常相似的

2915
01:42:10,000 --> 01:42:11,000
非常 mapped

2916
01:42:11,000 --> 01:42:13,000
我也可以预见

2917
01:42:13,000 --> 01:42:15,000
就是在 relay 真正的发布的时候

2918
01:42:15,000 --> 01:42:20,000
会有人给传统的 restfulAPI 写一些 adapter

2919
01:42:20,000 --> 01:42:23,000
然后从而到那个传统的 restfulAPI

2920
01:42:23,000 --> 01:42:26,000
也支持这个 relay 的实现方式

2921
01:42:26,000 --> 01:42:28,000
刚好昨天那个

2922
01:42:28,000 --> 01:42:29,000
因为 relay 现在还没有

2923
01:42:29,000 --> 01:42:31,000
它只是发布了这个概念

2924
01:42:31,000 --> 01:42:33,000
它并没有公布它后面的一些产品

2925
01:42:33,000 --> 01:42:35,000
然后昨天在那个 hacker news 上面

2926
01:42:35,000 --> 01:42:38,000
Facebook 他们有一个叫做

2927
01:42:38,000 --> 01:42:38,000
Wincent

2928
01:42:38,000 --> 01:42:39,000
不是 Wincent

2929
01:42:39,000 --> 01:42:40,000
Wincent 这么一个人

2930
01:42:40,000 --> 01:42:44,000
他不是在 Github 上写了一个 relay 的 FAQ 吗

2931
01:42:44,000 --> 01:42:45,000
常见问题解答

2932
01:42:45,000 --> 01:42:48,000
然后上面我就问了他们这么一个问题

2933
01:42:48,000 --> 01:42:49,000
就是说

2934
01:42:49,000 --> 01:42:51,000
relay 它很依赖一个核心的组件

2935
01:42:51,000 --> 01:42:52,000
就是那个什么 graphql

2936
01:42:52,000 --> 01:42:55,000
就是这个图查询语言

2937
01:42:55,000 --> 01:42:56,000
这个是跟 Facebook

2938
01:42:56,000 --> 01:42:59,000
他们后台有一个叫做 TALTAL 的一个图数据库

2939
01:42:59,000 --> 01:43:01,000
是隐秘相关的

2940
01:43:01,000 --> 01:43:02,000
但我不太清楚

2941
01:43:02,000 --> 01:43:03,000
就是说

2942
01:43:03,000 --> 01:43:04,000
对于一个第三方

2943
01:43:04,000 --> 01:43:05,000
就是作为一个 Facebook 以外的人

2944
01:43:05,000 --> 01:43:07,000
或者是中小开发者

2945
01:43:07,000 --> 01:43:08,000
或中小网站

2946
01:43:08,000 --> 01:43:11,000
你没有一个基于这么一个图的

2947
01:43:11,000 --> 01:43:12,000
结构的后台的话

2948
01:43:12,000 --> 01:43:17,000
你怎么去适应这种 graphql 的要求

2949
01:43:17,000 --> 01:43:18,000
去做到 relay 这种效果

2950
01:43:18,000 --> 01:43:20,000
我觉得它是很大的一个疑惑

2951
01:43:20,000 --> 01:43:21,000
OK

2952
01:43:21,000 --> 01:43:22,000
这是一个机会

2953
01:43:22,000 --> 01:43:23,000
就是一个就是空白

2954
01:43:23,000 --> 01:43:25,000
市场现在是空白的

2955
01:43:25,000 --> 01:43:25,000
对不对

2956
01:43:25,000 --> 01:43:25,000
对

2957
01:43:25,000 --> 01:43:26,000
然后如果

2958
01:43:26,000 --> 01:43:29,000
如果我们有听众

2959
01:43:29,000 --> 01:43:35,000
想要再借此机会来写一个什么 open source library

2960
01:43:35,000 --> 01:43:36,000
或者是甚至开个公司

2961
01:43:36,000 --> 01:43:39,000
我觉得这个机会是有可能存在的

2962
01:43:39,000 --> 01:43:41,000
你要知道

2963
01:43:41,000 --> 01:43:47,000
这个 graphql 它最终

2964
01:43:47,000 --> 01:43:49,000
最终即使是 open source

2965
01:43:49,000 --> 01:43:51,000
不是最终它会有 open source

2966
01:43:51,000 --> 01:43:52,000
但是我们需要等一段时间

2967
01:43:52,000 --> 01:43:53,000
它在 open source 之后

2968
01:43:53,000 --> 01:43:57,000
它也更多的是作为一个 protocol 的存在

2969
01:43:57,000 --> 01:43:58,000
就像 flux 那样

2970
01:43:58,000 --> 01:44:00,000
真正实现的是需要

2971
01:44:00,000 --> 01:44:01,000
你自己去做的

2972
01:44:01,000 --> 01:44:06,000
根据它所用的那个软件来实现的

2973
01:44:06,000 --> 01:44:06,000
对

2974
01:44:06,000 --> 01:44:08,000
我觉得有点像一个像 SQL

2975
01:44:08,000 --> 01:44:12,000
你可以做一个 graphql database

2976
01:44:12,000 --> 01:44:16,000
然后或者说类 database 的 graphql server

2977
01:44:16,000 --> 01:44:18,000
然后这个 server 可能会

2978
01:44:19,000 --> 01:44:21,000
会说一种 graphql 的 dialect

2979
01:44:21,000 --> 01:44:25,000
然后带某种扩展

2980
01:44:25,000 --> 01:44:26,000
就像 SQL 一模一样

2981
01:44:26,000 --> 01:44:27,000
对没错

2982
01:44:27,000 --> 01:44:29,000
他们就算 relay 以后发布的时候

2983
01:44:29,000 --> 01:44:30,000
它也只会包含首先

2984
01:44:30,000 --> 01:44:32,000
第二是客户端的 graphql 那些组件

2985
01:44:32,000 --> 01:44:35,000
比如说它可以在每一个

2986
01:44:35,000 --> 01:44:37,000
它可以在每个 react 组件里面声明

2987
01:44:37,000 --> 01:44:39,000
你那个组件需要哪一个

2988
01:44:39,000 --> 01:44:40,000
哪一种类型的数据

2989
01:44:40,000 --> 01:44:43,000
然后它可以通过 relay 的 library

2990
01:44:43,000 --> 01:44:46,000
去把这些需求都一次抽出来

2991
01:44:46,000 --> 01:44:49,000
然后网服务端发一个请求

2992
01:44:49,000 --> 01:44:49,000
就可以解决

2993
01:44:49,000 --> 01:44:52,000
包括它会帮你去做好刚才讲的那个 batch

2994
01:44:52,000 --> 01:44:54,000
就是这个请求打包

2995
01:44:54,000 --> 01:44:56,000
包括哪些是可以重用的请求

2996
01:44:56,000 --> 01:44:57,000
就可以不用发送

2997
01:44:57,000 --> 01:44:59,000
包括那个本地的缓存

2998
01:44:59,000 --> 01:45:00,000
它都给你解决了

2999
01:45:00,000 --> 01:45:02,000
但是我觉得始终是

3000
01:45:02,000 --> 01:45:04,000
反而就问题在客户端那边

3001
01:45:04,000 --> 01:45:06,000
在服务端那边你是没有办法的

3002
01:45:06,000 --> 01:45:08,000
因为它最终它只会给你一个 graphql 的

3003
01:45:08,000 --> 01:45:09,000
这个那个叫什么

3004
01:45:09,000 --> 01:45:10,000
parser

3005
01:45:10,000 --> 01:45:12,000
然后它会给你一个语法术

3006
01:45:12,000 --> 01:45:14,000
但你怎么去满足它每一个

3007
01:45:14,000 --> 01:45:16,000
这个 graphql 写的这么一个查询

3008
01:45:16,000 --> 01:45:18,000
你还是要要挺费脑筋的

3009
01:45:18,000 --> 01:45:22,000
而且我觉得这不是一个小小企业

3010
01:45:22,000 --> 01:45:25,000
或者是个人能够很轻易做得到的事情吧

3011
01:45:25,000 --> 01:45:26,000
对

3012
01:45:26,000 --> 01:45:28,000
我很期待看到有人做一个

3013
01:45:28,000 --> 01:45:30,000
Risk 4 API 的 adapter

3014
01:45:30,000 --> 01:45:32,000
因为虽然说

3015
01:45:32,000 --> 01:45:35,000
虽然说他们两者的那个概念上有区别

3016
01:45:35,000 --> 01:45:37,000
但是实际上最终

3017
01:45:38,000 --> 01:45:39,000
graphql 和 Risk 4 都是

3018
01:45:39,000 --> 01:45:41,000
访问数据的一个方式

3019
01:45:41,000 --> 01:45:42,000
所以说他们

3020
01:45:42,000 --> 01:45:45,000
他们两者之间是有可以 map 的地方的

3021
01:45:45,000 --> 01:45:47,000
所以如果说有人能做一个

3022
01:45:47,000 --> 01:45:49,000
不要说 reals

3023
01:45:49,000 --> 01:45:50,000
你不要 reals apps

3024
01:45:50,000 --> 01:45:52,000
肯定可以有人做一个 reals

3025
01:45:52,000 --> 01:45:53,000
graphql

3026
01:45:53,000 --> 01:45:55,000
然后一个 gene

3027
01:45:55,000 --> 01:45:56,000
你把这个加上之后

3028
01:45:56,000 --> 01:45:58,000
那个它的那个 Risk 4 API

3029
01:45:58,000 --> 01:46:00,000
就可以通过这个 adapter 来

3030
01:46:00,000 --> 01:46:02,000
来实现 graphql

3031
01:46:02,000 --> 01:46:03,000
我觉得对这个

3032
01:46:03,000 --> 01:46:05,000
可能在性能上会有一些损失

3033
01:46:05,000 --> 01:46:07,000
然后也不是说直接你实现了 graphql

3034
01:46:07,000 --> 01:46:09,000
但是对于推广这个技术

3035
01:46:09,000 --> 01:46:11,000
你应用这个技术是非常好处的

3036
01:46:12,000 --> 01:46:13,000
就作为一个过渡方案

3037
01:46:13,000 --> 01:46:14,000
对作为一个过渡方案

3038
01:46:14,000 --> 01:46:15,000
应该是挺好的

3039
01:46:15,000 --> 01:46:16,000
对吧

3040
01:46:16,000 --> 01:46:17,000
所以我就还是在想

3041
01:46:17,000 --> 01:46:19,000
因为之前在珠库的时候

3042
01:46:19,000 --> 01:46:20,000
我的很大的一部分工作

3043
01:46:20,000 --> 01:46:22,000
就是在琢磨这些

3044
01:46:22,000 --> 01:46:25,000
无奇八糟的有的没的图的结构

3045
01:46:25,000 --> 01:46:28,000
其实我后来的一个体验就是说

3046
01:46:28,000 --> 01:46:30,000
其实真的是蛮难的

3047
01:46:30,000 --> 01:46:32,000
就是作为一个普通的团队

3048
01:46:32,000 --> 01:46:33,000
就像很多这种

3049
01:46:33,000 --> 01:46:34,000
所有的 web 英雄

3050
01:46:34,000 --> 01:46:35,000
它都是一个什么

3051
01:46:35,000 --> 01:46:37,000
MySQL 一个后台

3052
01:46:37,000 --> 01:46:39,000
然后前面加封一个 Risk 的

3053
01:46:39,000 --> 01:46:40,000
一个 API 层

3054
01:46:40,000 --> 01:46:42,000
然后再加几个 Redis 的这种

3055
01:46:42,000 --> 01:46:43,000
叫什么

3056
01:46:43,000 --> 01:46:45,000
就是缓冲层

3057
01:46:45,000 --> 01:46:48,000
它就可以满足一个中型网站的应用了

3058
01:46:48,000 --> 01:46:51,000
但是你要实现像 graphql

3059
01:46:51,000 --> 01:46:53,000
那么灵活多变的查询

3060
01:46:53,000 --> 01:46:57,000
而且要达到那种好用程度

3061
01:46:57,000 --> 01:46:59,000
你真的是要后台要做很多工作

3062
01:46:59,000 --> 01:47:01,000
才能够实现 graph 的结构的

3063
01:47:01,000 --> 01:47:02,000
就这个 graphql 出现

3064
01:47:02,000 --> 01:47:03,000
让我发现

3065
01:47:03,000 --> 01:47:07,000
其实这一个抽象层级的需求

3066
01:47:07,000 --> 01:47:08,000
是非常明显的

3067
01:47:08,000 --> 01:47:09,000
但是在它做出来

3068
01:47:09,000 --> 01:47:11,000
在 graphql 出现之前

3069
01:47:11,000 --> 01:47:13,000
好像没有人去讨论它

3070
01:47:13,000 --> 01:47:14,000
是有的

3071
01:47:14,000 --> 01:47:15,000
但是就是说因为

3072
01:47:15,000 --> 01:47:16,000
无声无口答应

3073
01:47:16,000 --> 01:47:16,000
因为它不是 Facebook

3074
01:47:16,000 --> 01:47:18,000
没有吸引到足够的眼球

3075
01:47:18,000 --> 01:47:18,000
是吧

3076
01:47:18,000 --> 01:47:20,000
我觉得主要是因为现在的主流

3077
01:47:20,000 --> 01:47:23,000
就是除了像 Facebook 这种巨头

3078
01:47:23,000 --> 01:47:25,000
能够有精力或者有资源

3079
01:47:25,000 --> 01:47:28,000
去把它的后端做成一个这种

3080
01:47:28,000 --> 01:47:30,000
这种结构的方式去查询的话

3081
01:47:30,000 --> 01:47:32,000
其他那些中小企业真的是还蛮难

3082
01:47:32,000 --> 01:47:34,000
因为没有一个现成的

3083
01:47:34,000 --> 01:47:36,000
或者说被像 MySQL 这种级别

3084
01:47:36,000 --> 01:47:38,000
能被大众广泛接受

3085
01:47:38,000 --> 01:47:40,000
有好用的就是图数据库

3086
01:47:40,000 --> 01:47:42,000
有几个例子像什么

3087
01:47:42,000 --> 01:47:43,000
Neo 4 j

3088
01:47:43,000 --> 01:47:45,000
什么 OrenDB 之类的

3089
01:47:45,000 --> 01:47:47,000
他们但是

3090
01:47:47,000 --> 01:47:48,000
就是你可以看到

3091
01:47:48,000 --> 01:47:49,000
就成功案例很少

3092
01:47:49,000 --> 01:47:50,000
就是你首先一个熟悉程度

3093
01:47:50,000 --> 01:47:51,000
也就是它的程度

3094
01:47:51,000 --> 01:47:53,000
程度本身也不够

3095
01:47:53,000 --> 01:47:54,000
然后就是大家也不太敢用

3096
01:47:54,000 --> 01:47:56,000
然后这样的话就会反而导致

3097
01:47:56,000 --> 01:47:59,000
这一块其实在市场上是很弱的

3098
01:47:59,000 --> 01:48:00,000
我倒是希望说

3099
01:48:00,000 --> 01:48:02,000
这个 relay 或者是 graphql

3100
01:48:02,000 --> 01:48:05,000
这个正式开源出来之后

3101
01:48:05,000 --> 01:48:08,000
大家会意识到这个的好处

3102
01:48:08,000 --> 01:48:09,000
以及对这个包括前端

3103
01:48:09,000 --> 01:48:13,000
开发的这个难度的降低

3104
01:48:13,000 --> 01:48:15,000
然后包括后端的开发的成本的降低

3105
01:48:15,000 --> 01:48:17,000
然后能够使得大家更多去思考

3106
01:48:17,000 --> 01:48:20,000
那我要不要用一下这种图

3107
01:48:20,000 --> 01:48:23,000
就以图为主要结构的这种数据后台

3108
01:48:23,000 --> 01:48:23,000
对

3109
01:48:23,000 --> 01:48:27,000
这算是 Facebook 对于整个

3110
01:48:27,000 --> 01:48:29,000
Tech Stack 做出的一个贡献吗

3111
01:48:30,000 --> 01:48:31,000
其实

3112
01:48:31,000 --> 01:48:33,000
那个 real

3113
01:48:33,000 --> 01:48:38,000
你提到图结构的数据

3114
01:48:38,000 --> 01:48:40,000
其实我

3115
01:48:40,000 --> 01:48:41,000
这是正式的问题

3116
01:48:41,000 --> 01:48:44,000
我并不清楚这个东西

3117
01:48:44,000 --> 01:48:46,000
它那个命名是一个

3118
01:48:46,000 --> 01:48:48,000
出于一个 branding 的考虑

3119
01:48:48,000 --> 01:48:50,000
还是它真的就是所谓图

3120
01:48:50,000 --> 01:48:52,000
我没有听说过图数据

3121
01:48:52,000 --> 01:48:54,000
就是正式的没有听说过

3122
01:48:54,000 --> 01:48:55,000
对

3123
01:48:55,000 --> 01:48:58,000
这个是一个相对于没有那么

3124
01:48:58,000 --> 01:48:59,000
大众的一个应用

3125
01:48:59,000 --> 01:49:01,000
其实图数据过要解决的问题

3126
01:49:01,000 --> 01:49:02,000
也是蛮简单的

3127
01:49:02,000 --> 01:49:05,000
你可以想象一个普通的是一个社交网络

3128
01:49:05,000 --> 01:49:07,000
只有一种类型的节点

3129
01:49:07,000 --> 01:49:08,000
我们就考虑最简单的一个情况

3130
01:49:08,000 --> 01:49:10,000
我们有用户

3131
01:49:10,000 --> 01:49:11,000
就 user 你和我

3132
01:49:11,000 --> 01:49:13,000
然后无套我们三个人

3133
01:49:13,000 --> 01:49:14,000
然后图数据过存储什么

3134
01:49:14,000 --> 01:49:16,000
就存储节点

3135
01:49:16,000 --> 01:49:18,000
我们这个本身节点有些什么样的属性

3136
01:49:18,000 --> 01:49:20,000
比如说我作为一个人

3137
01:49:20,000 --> 01:49:22,000
这个 user 这么一个节点

3138
01:49:22,000 --> 01:49:25,000
有什么名字性别年龄出生日期

3139
01:49:25,000 --> 01:49:27,000
之类的一些 attributes

3140
01:49:27,000 --> 01:49:28,000
对吧

3141
01:49:28,000 --> 01:49:31,000
这个是跟传统的包括这种

3142
01:49:31,000 --> 01:49:32,000
我们像 MICECO 这种

3143
01:49:32,000 --> 01:49:33,000
就是 RDB

3144
01:49:33,000 --> 01:49:34,000
就是 Relational Database

3145
01:49:34,000 --> 01:49:35,000
其实是没有太大区别的

3146
01:49:35,000 --> 01:49:36,000
就是

3147
01:49:36,000 --> 01:49:38,000
无非就是说每一个节点

3148
01:49:38,000 --> 01:49:41,000
对应 Relation Database 里面的一个一行

3149
01:49:41,000 --> 01:49:41,000
一个 Role

3150
01:49:41,000 --> 01:49:43,000
然后每一个 attribute

3151
01:49:43,000 --> 01:49:45,000
对应它的传统的

3152
01:49:45,000 --> 01:49:48,000
Relation Database 的一个 column

3153
01:49:48,000 --> 01:49:49,000
对吧

3154
01:49:49,000 --> 01:49:49,000
对

3155
01:49:49,000 --> 01:49:50,000
然后

3156
01:49:51,000 --> 01:49:55,000
但是一个图数据过更加重要的一点

3157
01:49:55,000 --> 01:49:57,000
其实是存储这个节点

3158
01:49:57,000 --> 01:49:58,000
节点之间的关系

3159
01:49:58,000 --> 01:50:00,000
比方说我可以说我可以 friend

3160
01:50:00,000 --> 01:50:00,000
你们两个

3161
01:50:00,000 --> 01:50:02,000
你们可以两个之间互相 friend

3162
01:50:02,000 --> 01:50:03,000
然后可以

3163
01:50:03,000 --> 01:50:05,000
然后你可以和别的人也

3164
01:50:05,000 --> 01:50:07,000
就是互相 friend

3165
01:50:07,000 --> 01:50:08,000
这个时候的话

3166
01:50:08,000 --> 01:50:09,000
这个时候它表现出来的结构

3167
01:50:09,000 --> 01:50:12,000
如果我们在传统的一个 Relation Database

3168
01:50:12,000 --> 01:50:13,000
去实现会怎么样

3169
01:50:13,000 --> 01:50:14,000
会通过一个

3170
01:50:14,000 --> 01:50:15,000
因为一张表

3171
01:50:15,000 --> 01:50:18,000
来做一个那个连接

3172
01:50:18,000 --> 01:50:18,000
对

3173
01:50:18,000 --> 01:50:19,000
另外比方说

3174
01:50:19,000 --> 01:50:20,000
叫做关注

3175
01:50:20,000 --> 01:50:21,000
就会写

3176
01:50:21,000 --> 01:50:23,000
Sorry cut it off

3177
01:50:23,000 --> 01:50:25,000
我只是做一个 check 而已

3178
01:50:25,000 --> 01:50:26,000
所以谢谢你的解释

3179
01:50:26,000 --> 01:50:28,000
但是我们还是不挖吧

3180
01:50:28,000 --> 01:50:30,000
我觉得这段就不用在那个 podcast

3181
01:50:30,000 --> 01:50:32,000
没事可以放进来接着解释

3182
01:50:32,000 --> 01:50:34,000
很多人不理解

3183
01:50:34,000 --> 01:50:36,000
听众也可能不是很熟悉这个概念

3184
01:50:36,000 --> 01:50:37,000
因为这个确实

3185
01:50:37,000 --> 01:50:39,000
在工业中我有用的不多了

3186
01:50:39,000 --> 01:50:39,000
对

3187
01:50:39,000 --> 01:50:40,000
因为对我来讲的话

3188
01:50:40,000 --> 01:50:41,000
我觉得就是说

3189
01:50:41,000 --> 01:50:43,000
那个 graphql 所谓 graph

3190
01:50:43,000 --> 01:50:44,000
只是一个 branding 而已

3191
01:50:44,000 --> 01:50:47,000
并不是真正在说

3192
01:50:47,000 --> 01:50:47,000
不它真的是

3193
01:50:47,000 --> 01:50:49,000
就说 graphql 本身

3194
01:50:49,000 --> 01:50:51,000
它真的是要有这么一种

3195
01:50:52,000 --> 01:50:54,000
对后端其实是有很大要求的

3196
01:50:54,000 --> 01:50:56,000
你才可以做到它那么灵活的查询

3197
01:50:56,000 --> 01:50:57,000
不然的话

3198
01:50:57,000 --> 01:50:58,000
你可以做

3199
01:50:58,000 --> 01:51:00,000
你可以去用什么叫 adapter 的方式

3200
01:51:00,000 --> 01:51:02,000
去把 graphql 的查询

3201
01:51:02,000 --> 01:51:04,000
转换成对应的 rest 的查询

3202
01:51:04,000 --> 01:51:06,000
但是这样的效率非常低

3203
01:51:06,000 --> 01:51:08,000
因为整个你的后台的数据库

3204
01:51:08,000 --> 01:51:09,000
组织的结构

3205
01:51:09,000 --> 01:51:11,000
就不是按照一个

3206
01:51:11,000 --> 01:51:13,000
那种图的查询的方式来查询的

3207
01:51:13,000 --> 01:51:16,000
因为图里面查询的最常见的什么

3208
01:51:16,000 --> 01:51:16,000
就是

3209
01:51:16,000 --> 01:51:17,000
便利嘛

3210
01:51:17,000 --> 01:51:18,000
节点便利嘛

3211
01:51:18,000 --> 01:51:19,000
对吧

3212
01:51:19,000 --> 01:51:20,000
这个在

3213
01:51:20,000 --> 01:51:21,000
你的 RTB

3214
01:51:21,000 --> 01:51:22,000
这个这么在

3215
01:51:22,000 --> 01:51:23,000
如果在一个传统 releasing database 里面做

3216
01:51:23,000 --> 01:51:25,000
这个性能是作死的

3217
01:51:25,000 --> 01:51:26,000
你想一下你要

3218
01:51:26,000 --> 01:51:26,000
假设

3219
01:51:27,000 --> 01:51:29,000
在一个社交网状那个图里面

3220
01:51:29,000 --> 01:51:31,000
你要从某个节点为中心

3221
01:51:31,000 --> 01:51:32,000
查询他的好友的话

3222
01:51:32,000 --> 01:51:35,000
你在一个传统的 releasing database 里面

3223
01:51:35,000 --> 01:51:36,000
你要去

3224
01:51:36,000 --> 01:51:37,000
要查好多张表

3225
01:51:38,000 --> 01:51:40,000
你要查三个维度的好友

3226
01:51:40,000 --> 01:51:43,000
就是三度分割的好友的话

3227
01:51:43,000 --> 01:51:45,000
你要用那个传统的 releasing database 查询的话

3228
01:51:45,000 --> 01:51:46,000
这是非常困难的

3229
01:51:47,000 --> 01:51:47,000
所以

3230
01:51:47,000 --> 01:51:49,000
所以我就是在想就是说

3231
01:51:50,000 --> 01:51:50,000
其实

3232
01:51:51,000 --> 01:51:53,000
现在有这么多的社交场合的应用

3233
01:51:53,000 --> 01:51:55,000
反而是没有一个

3234
01:51:55,000 --> 01:51:56,000
基于

3235
01:51:56,000 --> 01:51:58,000
能够很好满足社交查询的

3236
01:51:58,000 --> 01:52:00,000
这么一种数据存储的引擎

3237
01:52:00,000 --> 01:52:02,000
能够大规模的方便的使用

3238
01:52:02,000 --> 01:52:04,000
其实是蛮悲哀的一个现状

3239
01:52:04,000 --> 01:52:05,000
其实也是挺奇怪的

3240
01:52:07,000 --> 01:52:08,000
难过嘛

3241
01:52:08,000 --> 01:52:09,000
对确实挺难的

3242
01:52:11,000 --> 01:52:13,000
就比如说我们传统的作业

3243
01:52:13,000 --> 01:52:14,000
releasing database

3244
01:52:14,000 --> 01:52:14,000
你的性能不够

3245
01:52:14,000 --> 01:52:15,000
你可以做简单的

3246
01:52:15,000 --> 01:52:16,000
什么 sharding

3247
01:52:16,000 --> 01:52:17,000
就是分割嘛

3248
01:52:17,000 --> 01:52:18,000
按照这个

3249
01:52:18,000 --> 01:52:21,000
按照这个 key 的这个范围来分割嘛

3250
01:52:21,000 --> 01:52:23,000
但是你怎么就分割一个图呢

3251
01:52:23,000 --> 01:52:24,000
就很难的一件事情

3252
01:52:24,000 --> 01:52:25,000
对

3253
01:52:26,000 --> 01:52:28,000
所以就里面还是有很多这种

3254
01:52:28,000 --> 01:52:28,000
非常 hardcore 的

3255
01:52:28,000 --> 01:52:30,000
computer science 的东西

3256
01:52:30,000 --> 01:52:32,000
在里面要解决

3257
01:52:32,000 --> 01:52:34,000
而市面上现有的解决方案

3258
01:52:34,000 --> 01:52:37,000
都给人一种信心不足的感觉

3259
01:52:39,000 --> 01:52:40,000
真的

3260
01:52:40,000 --> 01:52:41,000
就我觉得其实这段

3261
01:52:41,000 --> 01:52:42,000
我就是蛮担忧的

3262
01:52:42,000 --> 01:52:43,000
就是说

3263
01:52:43,000 --> 01:52:44,000
如果这个解决不好

3264
01:52:44,000 --> 01:52:45,000
那个 graphic care 这种东西

3265
01:52:45,000 --> 01:52:46,000
就真的是只能

3266
01:52:46,000 --> 01:52:48,000
局限于像 facebook

3267
01:52:48,000 --> 01:52:50,000
像 Google 这种庞大的企业

3268
01:52:50,000 --> 01:52:51,000
它能够有这个资源

3269
01:52:51,000 --> 01:52:53,000
或者这个能力去实现自己的

3270
01:52:53,000 --> 01:52:55,000
或者维护自己的这么一套

3271
01:52:55,000 --> 01:52:56,000
基于图的

3272
01:52:56,000 --> 01:52:58,000
或者是以图结构为导向的

3273
01:52:58,000 --> 01:53:00,000
这么一个后台系统

3274
01:53:00,000 --> 01:53:02,000
否则其他人还是只能

3275
01:53:02,000 --> 01:53:04,000
很乐呵呵地继续用 Rest

3276
01:53:04,000 --> 01:53:04,000
嗯

3277
01:53:07,000 --> 01:53:07,000
对

3278
01:53:07,000 --> 01:53:08,000
那个什么

3279
01:53:08,000 --> 01:53:09,000
那威隆你说一下

3280
01:53:09,000 --> 01:53:10,000
就整个

3281
01:53:10,000 --> 01:53:11,000
就说刚才我们讲了这个

3282
01:53:11,000 --> 01:53:12,000
react 相关

3283
01:53:12,000 --> 01:53:13,000
包括你在会上

3284
01:53:13,000 --> 01:53:14,000
看到一些东西

3285
01:53:14,000 --> 01:53:16,000
但是你说整个来讲

3286
01:53:16,000 --> 01:53:17,000
你对这个会

3287
01:53:17,000 --> 01:53:18,000
本身是什么样的一个感受

3288
01:53:21,000 --> 01:53:22,000
这是我所去过的

3289
01:53:22,000 --> 01:53:24,000
比较好的一个会议之一了

3290
01:53:24,000 --> 01:53:26,000
因为整个的

3291
01:53:26,000 --> 01:53:26,000
所有的 speech

3292
01:53:26,000 --> 01:53:28,000
就非常的有意义

3293
01:53:28,000 --> 01:53:29,000
非常能觉得

3294
01:53:29,000 --> 01:53:30,000
从中能够学到东西

3295
01:53:30,000 --> 01:53:31,000
都不是在

3296
01:53:33,000 --> 01:53:34,000
都非常有意义

3297
01:53:34,000 --> 01:53:35,000
非常 hard core CS

3298
01:53:35,000 --> 01:53:37,000
我觉得这一点是非常非常难得的

3299
01:53:37,000 --> 01:53:40,000
那个会议的组织

3300
01:53:40,000 --> 01:53:41,000
肯定做了很好的工作

3301
01:53:41,000 --> 01:53:43,000
来选取这些

3302
01:53:44,000 --> 01:53:46,000
这些演讲者和演讲本身

3303
01:53:48,000 --> 01:53:49,000
我们有非常多的

3304
01:53:49,000 --> 01:53:50,000
那个 social 的机会

3305
01:53:50,000 --> 01:53:51,000
在其中也遇到了

3306
01:53:51,000 --> 01:53:52,000
非常非常多人

3307
01:53:52,000 --> 01:53:54,000
然后 react 真的是被应用到

3308
01:53:54,000 --> 01:53:56,000
各种各方各面

3309
01:53:56,000 --> 01:53:59,000
很多你想不到的一些

3310
01:53:59,000 --> 01:54:01,000
application 都在使用 react

3311
01:54:01,000 --> 01:54:04,000
或者在考虑使用 react

3312
01:54:04,000 --> 01:54:05,000
非常的激动人心的

3313
01:54:05,000 --> 01:54:07,000
就是可能看到这么多

3314
01:54:07,000 --> 01:54:08,000
实际的应用

3315
01:54:08,000 --> 01:54:11,000
这么多积极主动来

3316
01:54:11,000 --> 01:54:13,000
参与这个社区的人

3317
01:54:13,000 --> 01:54:14,000
所以整体来说

3318
01:54:14,000 --> 01:54:15,000
我觉得是一个非常

3319
01:54:15,000 --> 01:54:18,000
非常非常好的

3320
01:54:18,000 --> 01:54:19,000
一个气氛

3321
01:54:19,000 --> 01:54:21,000
大家都非常的

3322
01:54:21,000 --> 01:54:23,000
对这个 react 的情景都非常乐观

3323
01:54:25,000 --> 01:54:27,000
我也很高兴看到

3324
01:54:27,000 --> 01:54:29,000
Facebook 对整个会议的支持

3325
01:54:29,000 --> 01:54:31,000
跟对整个这个

3326
01:54:31,000 --> 01:54:33,000
react 技术的支持

3327
01:54:33,000 --> 01:54:34,000
After all

3328
01:54:34,000 --> 01:54:36,000
我也觉得非常开心

3329
01:54:36,000 --> 01:54:37,000
能够得到这个 react

3330
01:54:37,000 --> 01:54:39,000
native 的一个 preview

3331
01:54:39,000 --> 01:54:41,000
我有给我的同事演示

3332
01:54:41,000 --> 01:54:44,000
这对我们做接下来一些

3333
01:54:44,000 --> 01:54:47,000
technology 选项都是非常有帮助的

3334
01:54:47,000 --> 01:54:50,000
所以贵公司也是要出一颗

3335
01:54:50,000 --> 01:54:52,000
mobile 领域的客户端的吗

3336
01:54:52,000 --> 01:54:55,000
我们一直有 mobile 的客户端

3337
01:54:55,000 --> 01:54:57,000
我们有 iOS 跟 Android 的客户端

3338
01:54:57,000 --> 01:54:58,000
然后

3339
01:54:58,000 --> 01:55:02,000
forseeable future 肯定不是 reactnative

3340
01:55:02,000 --> 01:55:02,000
对不对

3341
01:55:02,000 --> 01:55:05,000
但是对于技术的选项

3342
01:55:05,000 --> 01:55:06,000
观察技术的发展来说的话

3343
01:55:06,000 --> 01:55:08,000
我们肯定现在是

3344
01:55:08,000 --> 01:55:11,000
把它是摆在一个比较重要的位置

3345
01:55:11,000 --> 01:55:12,000
对

3346
01:55:12,000 --> 01:55:13,000
没错

3347
01:55:13,000 --> 01:55:14,000
OK 那行

3348
01:55:14,000 --> 01:55:16,000
今天我们非常高兴邀请到 Wilo

3349
01:55:16,000 --> 01:55:18,000
来跟我们讨论 react

3350
01:55:19,000 --> 01:55:21,000
把一系列相关的东西

3351
01:55:21,000 --> 01:55:22,000
然后

3352
01:55:22,000 --> 01:55:24,000
那今天的节目就到此为止吧

3353
01:55:24,000 --> 01:55:25,000
谢谢大家

3354
01:55:25,000 --> 01:55:27,000
谢谢大家的收听

3355
01:55:27,000 --> 01:55:29,000
谢谢大家

3356
01:55:29,000 --> 01:55:30,000
我们下期再见

3357
01:55:30,000 --> 01:55:33,000
我还要念那个吗

3358
01:55:33,000 --> 01:55:34,000
你念吧

3359
01:55:34,000 --> 01:55:35,000
OK

3360
01:55:35,000 --> 01:55:37,000
感谢大家收听内核恐慌

3361
01:55:37,000 --> 01:55:39,000
也欢迎大家收听 IPN 旗下的

3362
01:55:39,000 --> 01:55:40,000
其他五档 podcast

3363
01:55:40,000 --> 01:55:43,000
包括技术主题节目

3364
01:55:43,000 --> 01:55:44,000
ID 公论

3365
01:55:44,000 --> 01:55:46,000
医疗主题节目太医来了

3366
01:55:46,000 --> 01:55:47,000
美食节目未知道

3367
01:55:47,000 --> 01:55:50,000
以及艺术类节目流行通信

3368
01:55:50,000 --> 01:55:52,000
最后还有不知道

3369
01:55:52,000 --> 01:55:54,000
是在播什么的无主题节目无词源

3370
01:55:54,000 --> 01:55:55,000
感谢大家的收听

