1
00:00:00,000 --> 00:00:05,000
欢迎收听 ipnpodcast 网络旗下的 IT 技术主题娱乐节目内核恐慌

2
00:00:05,000 --> 00:00:08,000
我们号称 hardcore 但是也没有干货

3
00:00:08,000 --> 00:00:10,000
想听人听不想听的人就别听

4
00:00:10,000 --> 00:00:14,000
内核恐慌的网址是 ipn.li.co.panic

5
00:00:14,000 --> 00:00:17,000
我们推荐大家使用 podcast 客户端订阅节目

6
00:00:17,000 --> 00:00:20,000
如果您不知道该使用哪种客户端

7
00:00:20,000 --> 00:00:23,000
欢迎访问 ipn.li.faq

8
00:00:23,000 --> 00:00:26,000
也同样欢迎你为我们的节目捐款

9
00:00:26,000 --> 00:00:31,000
捐款地址是 ipn.li.co.panic.donate

10
00:00:31,000 --> 00:00:33,000
捐款金额随意

11
00:00:33,000 --> 00:00:35,000
只要是能被 8 整出的正正数就可以

12
00:00:35,000 --> 00:00:37,000
捐款不会为你带来什么

13
00:00:37,000 --> 00:00:40,000
不捐也不会让你失去什么

14
00:00:40,000 --> 00:00:42,000
我们的口号是 no hard feelings

15
00:00:44,000 --> 00:00:47,000
所以我们今天是第 27

16
00:00:47,000 --> 00:00:49,000
居然都已经 27 了

17
00:00:49,000 --> 00:00:52,000
一晃已经过去 40 周了

18
00:00:52,000 --> 00:00:53,000
小半年

19
00:00:53,000 --> 00:00:54,000
哎不对

20
00:00:54,000 --> 00:00:54,000
大半年

21
00:00:54,000 --> 00:00:56,000
快一年了

22
00:00:56,000 --> 00:00:57,000
对

23
00:00:57,000 --> 00:01:00,000
还是做一些简单的 follow up 吧

24
00:01:01,000 --> 00:01:04,000
对我们今天两个人今天

25
00:01:04,000 --> 00:01:06,000
状态都不太正常

26
00:01:06,000 --> 00:01:08,000
一个是不停的打分离

27
00:01:08,000 --> 00:01:09,000
另一个得烟烟

28
00:01:09,000 --> 00:01:12,000
基本上说话一块就会咳嗽

29
00:01:12,000 --> 00:01:16,000
所以我们今天可能就不会讲太多的话

30
00:01:16,000 --> 00:01:17,000
但

31
00:01:19,000 --> 00:01:22,000
应该会跳过新闻单元吧

32
00:01:23,000 --> 00:01:24,000
对就从 follow up 开始

33
00:01:25,000 --> 00:01:26,000
对

34
00:01:26,000 --> 00:01:27,000
这个 follow up 之前

35
00:01:27,000 --> 00:01:32,000
先说一下上周我们找听众帮我们

36
00:01:32,000 --> 00:01:36,000
去排查为什么下载会出错问题

37
00:01:36,000 --> 00:01:37,000
你还记得吗

38
00:01:37,000 --> 00:01:38,000
对

39
00:01:38,000 --> 00:01:42,000
我们现在终于找到了一个鲜活的案例

40
00:01:42,000 --> 00:01:46,000
对有一位非常热心的听众

41
00:01:46,000 --> 00:01:51,000
极端及时的向我们爆出了 bug 的

42
00:01:52,000 --> 00:01:53,000
怎么说呢

43
00:01:53,000 --> 00:01:55,000
这位同学遇到了这个 bug

44
00:01:55,000 --> 00:01:57,000
然后及时给我们写了邮件

45
00:01:57,000 --> 00:02:00,000
并且我们趁这个 bug 还鲜活的时候

46
00:02:01,000 --> 00:02:02,000
给他捉住了

47
00:02:02,000 --> 00:02:03,000
对

48
00:02:03,000 --> 00:02:07,000
从他那里认识了一个 CURL 的命令

49
00:02:07,000 --> 00:02:10,000
然后及时发下了这个 bug 的所在

50
00:02:10,000 --> 00:02:13,000
所以要解释一下成因吗

51
00:02:13,000 --> 00:02:15,000
对我这肯定要解释一下

52
00:02:15,000 --> 00:02:17,000
好不容易捉住一个虫子是吧

53
00:02:19,000 --> 00:02:20,000
简单来讲是这样

54
00:02:20,000 --> 00:02:23,000
就是国内的部分运营商

55
00:02:24,000 --> 00:02:27,000
但这里部分运营商主要是以长程宽带这种

56
00:02:29,000 --> 00:02:30,000
这种叫什么来着

57
00:02:32,000 --> 00:02:34,000
二刀贩子运营商为主

58
00:02:34,000 --> 00:02:35,000
然后他们

59
00:02:35,000 --> 00:02:36,000
South Contract

60
00:02:36,000 --> 00:02:41,000
对他们为了减缓他们网络的压力

61
00:02:41,000 --> 00:02:42,000
因为他买的贷款也有限

62
00:02:42,000 --> 00:02:45,000
然后他们自己在内部做了一个缓存

63
00:02:46,000 --> 00:02:47,000
就是说凡是你下载一些比较

64
00:02:47,000 --> 00:02:51,000
通过 HTCP 协议下载的一些比较大型的文件

65
00:02:51,000 --> 00:02:56,000
他们会在他们内部的一个服务器上缓存下来

66
00:02:56,000 --> 00:02:59,000
这样的话如果假设有 100 个长宽的用户

67
00:02:59,000 --> 00:03:02,000
都去请求那一个文件的话

68
00:03:02,000 --> 00:03:06,000
他只有第一个人的时候会去下载

69
00:03:06,000 --> 00:03:08,000
从原那里拿那个文件

70
00:03:08,000 --> 00:03:11,000
然后后面的 99 个人都是从长宽自己的服务器走了

71
00:03:11,000 --> 00:03:12,000
这样的话

72
00:03:12,000 --> 00:03:16,000
因为长宽内部到他自己客户的这边网络的

73
00:03:16,000 --> 00:03:18,000
这个贷款是比较充足的

74
00:03:18,000 --> 00:03:22,000
但是长宽去到别的网络的贷款是比较涌赌的

75
00:03:23,000 --> 00:03:25,000
所以通过这种缓存的方法

76
00:03:25,000 --> 00:03:28,000
他们可以用一个比较小的

77
00:03:28,000 --> 00:03:30,000
就比较便宜的

78
00:03:30,000 --> 00:03:33,000
就去外面贷款去支撑足够多的用户

79
00:03:33,000 --> 00:03:35,000
从而降低他们这个成本

80
00:03:37,000 --> 00:03:38,000
这个做法本来倒也没什么

81
00:03:38,000 --> 00:03:41,000
很多公司也是这么干的

82
00:03:41,000 --> 00:03:43,000
之前我在知乎的时候

83
00:03:43,000 --> 00:03:44,000
我们也是这么用的

84
00:03:44,000 --> 00:03:48,000
就是在网关上会做这么一个脱名缓存

85
00:03:48,000 --> 00:03:51,000
然后到时候那些下载过的文件大家可以共享

86
00:03:52,000 --> 00:03:54,000
因为最主要痛点是每年一次

87
00:03:54,000 --> 00:03:55,000
那个就 10 月份

88
00:03:55,000 --> 00:03:58,000
苹果发布新的 OS X 或者 iOS 的时候

89
00:04:00,000 --> 00:04:03,000
会把那个公司的出口贷款给撑爆

90
00:04:04,000 --> 00:04:06,000
做了这个之后大家觉得好下载好快

91
00:04:06,000 --> 00:04:09,000
而且公司出口贷款也不怎么受影响

92
00:04:10,000 --> 00:04:14,000
这个就是说一个在公司级别和长宽中

93
00:04:14,000 --> 00:04:16,000
在运营商级别是做同样的事情对吧

94
00:04:17,000 --> 00:04:19,000
问题在哪呢

95
00:04:19,000 --> 00:04:23,000
他们在做他们的缓存系统

96
00:04:23,000 --> 00:04:25,000
我真是无力吐槽了

97
00:04:25,000 --> 00:04:27,000
简单来讲我们缓存的一个 URL

98
00:04:27,000 --> 00:04:29,000
一个是文件应该说是

99
00:04:29,000 --> 00:04:32,000
你一个 URL 对应的一个文件

100
00:04:32,000 --> 00:04:33,000
可能就是这么一个

101
00:04:34,000 --> 00:04:36,000
就是它的唯一标识符是一个完整的 URL

102
00:04:36,000 --> 00:04:37,000
对吧

103
00:04:37,000 --> 00:04:40,000
比如说我们的存放的路径

104
00:04:40,000 --> 00:04:43,000
可能是 ipn.li 然后什么

105
00:04:44,000 --> 00:04:46,000
假设目录是 kernelpanic

106
00:04:46,000 --> 00:04:48,000
然后又写杠文件名是 ep

107
00:04:48,000 --> 00:04:53,000
假设是就是 ep 20.mp 3 这么一个文件对吧

108
00:04:53,000 --> 00:04:54,000
对

109
00:04:54,000 --> 00:04:56,000
你做缓存的时候是不是应该说

110
00:04:56,000 --> 00:05:00,000
我把这个 URL 完整的就是复制

111
00:05:00,000 --> 00:05:04,000
就是作为这个文件在这个缓存系统里面的一个标识符

112
00:05:04,000 --> 00:05:04,000
对吧

113
00:05:04,000 --> 00:05:07,000
就包括我们的域名 ipn.li

114
00:05:08,000 --> 00:05:11,000
包括它的路径 kernelpanic

115
00:05:12,000 --> 00:05:13,000
包括它文件名

116
00:05:14,000 --> 00:05:16,000
ep 20.mp 3 对吧

117
00:05:16,000 --> 00:05:18,000
对一个正常人会这样实现

118
00:05:18,000 --> 00:05:20,000
对正常人不然的话你说如果

119
00:05:21,000 --> 00:05:22,000
正常人是这么想的没问题

120
00:05:22,000 --> 00:05:24,000
但是我们发现

121
00:05:24,000 --> 00:05:29,000
就根据我们帮助我们热心出虫的

122
00:05:29,000 --> 00:05:31,000
这位听众给我反馈来看

123
00:05:31,000 --> 00:05:35,000
长宽的缓存系统完全不是这么弄的

124
00:05:35,000 --> 00:05:37,000
它只选择了两个信息

125
00:05:37,000 --> 00:05:38,000
一个是域名

126
00:05:38,000 --> 00:05:40,000
一个是文件名

127
00:05:40,000 --> 00:05:43,000
它把中间的文件路径给漏掉了

128
00:05:43,000 --> 00:05:47,000
对它假设每一台服务器上所有的文件都是独一无二的

129
00:05:47,000 --> 00:05:49,000
所有的文件名都是独一无二的

130
00:05:49,000 --> 00:05:50,000
不管它处在哪个路径之下

131
00:05:50,000 --> 00:05:51,000
对

132
00:05:52,000 --> 00:05:56,000
然后碰巧我们这个节目的文件名都比较一致

133
00:05:56,000 --> 00:05:57,000
对吧

134
00:05:57,000 --> 00:06:03,000
我们就说 kernelpanic 血干 ep 20.mp 3 是我们这一期节目的

135
00:06:03,000 --> 00:06:04,000
但是同样的对于

136
00:06:04,000 --> 00:06:05,000
假设 IT 工论

137
00:06:05,000 --> 00:06:07,000
它也有第 27

138
00:06:07,000 --> 00:06:09,000
那是 IT 工论血干 ep 20.mp 3

139
00:06:10,000 --> 00:06:10,000
然后碰巧

140
00:06:11,000 --> 00:06:13,000
我们又是同一个域名下面的

141
00:06:13,000 --> 00:06:14,000
ipn.li 下面的

142
00:06:14,000 --> 00:06:15,000
对吧

143
00:06:15,000 --> 00:06:19,000
在长宽的缓存代理这么一过

144
00:06:19,000 --> 00:06:20,000
就会发现

145
00:06:21,000 --> 00:06:24,000
都是 ep 20.mp 3 这个文件

146
00:06:24,000 --> 00:06:25,000
他们肯定应该是几个吧

147
00:06:26,000 --> 00:06:27,000
然后它就默默的

148
00:06:28,000 --> 00:06:35,000
把 IT 工论的第 27 的音频文件当做了 kernelpanic 的

149
00:06:35,000 --> 00:06:41,000
第 27 文件给发回给你的流量器或者是你的播客户端了

150
00:06:41,000 --> 00:06:43,000
于是就会出现我们之前很多人遇到的

151
00:06:43,000 --> 00:06:45,000
这个所谓的串台的现象

152
00:06:45,000 --> 00:06:47,000
就是明明下的是怎么听着太一

153
00:06:47,000 --> 00:06:48,000
怎么变成了未知道

154
00:06:48,000 --> 00:06:50,000
或者是听着什么流行通讯

155
00:06:50,000 --> 00:06:52,000
怎么变成了其他的什么节目

156
00:06:52,000 --> 00:06:53,000
对

157
00:06:53,000 --> 00:06:54,000
就这种诡异的事情

158
00:06:57,000 --> 00:06:58,000
我已经无力吐槽无套

159
00:06:58,000 --> 00:06:59,000
你接着说

160
00:07:00,000 --> 00:07:01,000
其实我在想说

161
00:07:01,000 --> 00:07:07,000
如果每一次串台的都可以找到一个相同之处

162
00:07:07,000 --> 00:07:09,000
就是每一期的

163
00:07:11,000 --> 00:07:13,000
怎么说番号是一样的话

164
00:07:13,000 --> 00:07:18,000
我们也是早一点就可以猜想出这个故障的原因来了

165
00:07:18,000 --> 00:07:23,000
但是之前的故障回报里面好像从来没有人提起

166
00:07:23,000 --> 00:07:26,000
不过说比如说流行通讯第 18 期

167
00:07:26,000 --> 00:07:28,000
串到内容恐慌的第 18 期

168
00:07:28,000 --> 00:07:30,000
都会是第 18 期

169
00:07:30,000 --> 00:07:34,000
我想可能一部分原因也是因为大部分人发现串台了

170
00:07:34,000 --> 00:07:36,000
就不会再仔细听说

171
00:07:37,000 --> 00:07:38,000
是多少期对吧

172
00:07:38,000 --> 00:07:42,000
而且也不是每一个主播都会念说这一次是多少期

173
00:07:42,000 --> 00:07:46,000
对我们很多节目都不会讲就是第多少多少期

174
00:07:46,000 --> 00:07:49,000
因为有可能比如说他可能预先录制了两三期这样

175
00:07:50,000 --> 00:07:52,000
然后发布的时候其实是在 Lawrence

176
00:07:52,000 --> 00:07:54,000
在决定按发布的时间

177
00:07:54,000 --> 00:07:55,000
先到时候你去排这个序号

178
00:07:57,000 --> 00:07:59,000
所以这种情况下没有办法

179
00:08:00,000 --> 00:08:02,000
你只是无意中透露了一个商业金

180
00:08:03,000 --> 00:08:04,000
什么商业金

181
00:08:04,000 --> 00:08:08,000
批量生产然后分批分开几期播放

182
00:08:08,000 --> 00:08:09,000
还是比较少

183
00:08:09,000 --> 00:08:14,000
但是确实以前有做过这种所谓的备用方案

184
00:08:15,000 --> 00:08:18,000
对反正找到这个东西的原因

185
00:08:18,000 --> 00:08:22,000
我们的消灭它的方法也比较简单

186
00:08:22,000 --> 00:08:25,000
我们直接在文件前面加个钱赘

187
00:08:25,000 --> 00:08:28,000
因为既然那个什么长宽的这种 2 B

188
00:08:29,000 --> 00:08:30,000
这个缓存系统

189
00:08:30,000 --> 00:08:35,000
竟然能不顾路径直接管文件名

190
00:08:35,000 --> 00:08:38,000
就认为是就同样文件名的文件认为是一样的

191
00:08:39,000 --> 00:08:40,000
那我们把文件名改成不一样的

192
00:08:40,000 --> 00:08:42,000
比如说每个节目的钱加个钱赘

193
00:08:42,000 --> 00:08:44,000
比如是 Colonel Panic

194
00:08:45,000 --> 00:08:48,000
然后横杠 EP 20.MP 3

195
00:08:48,000 --> 00:08:51,000
然后另外那个是 IT 工的横杠 EP 20.MP 3

196
00:08:51,000 --> 00:08:54,000
希望这样就可以绕过那个长宽的这个

197
00:08:55,000 --> 00:09:00,000
有 bug 就是无力吐槽的 bug 的缓存系统

198
00:09:01,000 --> 00:09:03,000
然后这让我想到说

199
00:09:03,000 --> 00:09:05,000
其实这个 bug 也许会造成更大的伤害

200
00:09:05,000 --> 00:09:09,000
因为我们的节目其实只是一个 podcast 而已

201
00:09:09,000 --> 00:09:11,000
你最多只不过串了台而已对吧

202
00:09:11,000 --> 00:09:14,000
但是如果相同 bug 发生了一些比较

203
00:09:15,000 --> 00:09:17,000
mission critical 的软件上面

204
00:09:17,000 --> 00:09:17,000
那可能

205
00:09:18,000 --> 00:09:19,000
这不用可能

206
00:09:19,000 --> 00:09:20,000
这个事情已经确实是在发生的

207
00:09:20,000 --> 00:09:27,000
而且是已经是出于这种商业恶意的行为在做了

208
00:09:28,000 --> 00:09:30,000
很简单的一个原因就是

209
00:09:30,000 --> 00:09:34,000
安卓那些的应用包是可以通过一种软件下载

210
00:09:34,000 --> 00:09:36,000
APK 的形式去安装的

211
00:09:37,000 --> 00:09:41,000
然后国内有很多应用商店是这么搞的

212
00:09:41,000 --> 00:09:43,000
然后就有运营商

213
00:09:43,000 --> 00:09:44,000
我不说哪一家

214
00:09:44,000 --> 00:09:45,000
大家自己去猜

215
00:09:45,000 --> 00:09:47,000
当然也不是一个普遍现象

216
00:09:47,000 --> 00:09:48,000
可能个别地区

217
00:09:48,000 --> 00:09:53,000
他就直接在你下载 APK 这个过程中

218
00:09:53,000 --> 00:09:54,000
给你劫持了

219
00:09:54,000 --> 00:09:57,000
你本来要下一个 A 的应用

220
00:09:57,000 --> 00:09:59,000
他给你劫持成同类的 B 的

221
00:10:02,000 --> 00:10:04,000
然后你作为一个消费者

222
00:10:04,000 --> 00:10:06,000
你下载后来看怎么回事

223
00:10:06,000 --> 00:10:07,000
我明明下的是本来是 A 应用的

224
00:10:07,000 --> 00:10:09,000
变成了 B 应用的这种东西

225
00:10:09,000 --> 00:10:11,000
那你觉得是哪里的问题呢

226
00:10:11,000 --> 00:10:15,000
如果你不具备这种基础的网络知识

227
00:10:15,000 --> 00:10:17,000
你不具备像上次我们热情

228
00:10:18,000 --> 00:10:21,000
听说这种刨根问题的这种精神

229
00:10:21,000 --> 00:10:24,000
你想可能是不是你这个应用商店有问题

230
00:10:24,000 --> 00:10:25,000
还是怎么样对吧

231
00:10:25,000 --> 00:10:26,000
对

232
00:10:27,000 --> 00:10:29,000
所以这件事情说到底

233
00:10:29,000 --> 00:10:31,000
你技术的解决方案也是有的

234
00:10:31,000 --> 00:10:35,000
那就是全面启用 HTCPS 就是加密的连接

235
00:10:35,000 --> 00:10:36,000
加密连接有个好处

236
00:10:36,000 --> 00:10:37,000
就是中间缓存

237
00:10:37,000 --> 00:10:39,000
他是没有办法去做手脚的

238
00:10:39,000 --> 00:10:41,000
因为你做手脚就会被爆错

239
00:10:42,000 --> 00:10:43,000
至少我希望如此

240
00:10:46,000 --> 00:10:49,000
但是这就会有一点点问题

241
00:10:49,000 --> 00:10:50,000
就假设比如说

242
00:10:50,000 --> 00:10:52,000
因为如果用加密连接的话

243
00:10:52,000 --> 00:10:55,000
就长宽那种代理缓存就没办法用了

244
00:10:55,000 --> 00:10:57,000
那假设你是长宽的用户

245
00:10:57,000 --> 00:10:59,000
你那个假设你有一百个长宽的用户

246
00:11:00,000 --> 00:11:02,000
这 100 个人每次都要从长宽

247
00:11:03,000 --> 00:11:06,000
不是这 100 个用户都要从原始的

248
00:11:06,000 --> 00:11:08,000
出出那里下载这么一个比较大的文件

249
00:11:08,000 --> 00:11:11,000
那么如果大家都碰巧是在同一个时间下载的话

250
00:11:12,000 --> 00:11:15,000
可能就会把长宽的出口代码给承包

251
00:11:16,000 --> 00:11:18,000
所以其实你发现说到这里

252
00:11:18,000 --> 00:11:23,000
就是在安全隐私和这个效率上面

253
00:11:23,000 --> 00:11:24,000
之间是有一些矛盾的

254
00:11:25,000 --> 00:11:26,000
怎么去取舍

255
00:11:26,000 --> 00:11:31,000
我觉得过去我们通常觉得说效率先嘛

256
00:11:31,000 --> 00:11:32,000
那安全隐私那些

257
00:11:32,000 --> 00:11:34,000
反正我又不在乎有什么问题呢

258
00:11:34,000 --> 00:11:38,000
但是其实今天以今天这种情况来看

259
00:11:38,000 --> 00:11:41,000
就什么运营商劫持啊

260
00:11:41,000 --> 00:11:42,000
还有各路神仙

261
00:11:43,000 --> 00:11:48,000
在搞那种灰色甚至黑色的利益的勾当的时候

262
00:11:49,000 --> 00:11:53,000
我们甚至有可能是不是就不得不牺牲一些效率

263
00:11:53,000 --> 00:11:55,000
下载慢去选择

264
00:11:55,000 --> 00:11:57,000
那我至少保证下东西回来是可靠的对吧

265
00:11:58,000 --> 00:11:58,000
对

266
00:11:59,000 --> 00:12:00,000
呃

267
00:12:00,000 --> 00:12:02,000
是啊反正最不论如何

268
00:12:02,000 --> 00:12:06,000
我们还是要在这边感谢这位帮我们找到

269
00:12:06,000 --> 00:12:07,000
这个 bug 的听众

270
00:12:07,000 --> 00:12:09,000
他叫做 Lian Z

271
00:12:11,000 --> 00:12:12,000
非常感谢

272
00:12:13,000 --> 00:12:13,000
对

273
00:12:13,000 --> 00:12:14,000
啊

274
00:12:14,000 --> 00:12:16,000
还要感谢另外一位是在那个

275
00:12:16,000 --> 00:12:20,000
V 2 EX 上面我们每期节目的那个文章上面

276
00:12:20,000 --> 00:12:21,000
他也另外那位朋友也帮我们做了

277
00:12:22,000 --> 00:12:23,000
这个同样的事情

278
00:12:23,000 --> 00:12:24,000
非常感谢大家

279
00:12:24,000 --> 00:12:25,000
是

280
00:12:26,000 --> 00:12:27,000
呃

281
00:12:28,000 --> 00:12:30,000
接下来一条 Full Up 就是

282
00:12:30,000 --> 00:12:35,000
我上一期节目里面提到的那个莫尔斯玛的 App

283
00:12:35,000 --> 00:12:37,000
这个如果大家忘记了

284
00:12:37,000 --> 00:12:38,000
我们这里先描述一下

285
00:12:39,000 --> 00:12:42,000
我上次让吴涛去

286
00:12:42,000 --> 00:12:46,000
捣鼓一下一个在 Apple Watch 上跑的原生的

287
00:12:46,000 --> 00:12:50,000
通过莫尔斯玛来发送信息的一个应用

288
00:12:50,000 --> 00:12:51,000
所以后来怎么样了

289
00:12:52,000 --> 00:12:53,000
呃

290
00:12:53,000 --> 00:12:56,000
其实原因也就是

291
00:12:57,000 --> 00:13:00,000
即便在新发布的 WatchOS 上面

292
00:13:01,000 --> 00:13:02,000
呃

293
00:13:03,000 --> 00:13:06,000
苹果提供的这一堆空调还是有

294
00:13:06,000 --> 00:13:06,000
呃

295
00:13:06,000 --> 00:13:09,000
还是只支持非常简单的实践模型

296
00:13:09,000 --> 00:13:10,000
就是比如说

297
00:13:11,000 --> 00:13:13,000
你可以在里面放一个 button

298
00:13:13,000 --> 00:13:15,000
但是你只

299
00:13:15,000 --> 00:13:17,000
你放了 button 之后

300
00:13:17,000 --> 00:13:20,000
你对它做的事情就仅有探测它

301
00:13:21,000 --> 00:13:23,000
被按下了一次这个

302
00:13:23,000 --> 00:13:25,000
action 这个 event

303
00:13:25,000 --> 00:13:26,000
而没有说

304
00:13:26,000 --> 00:13:27,000
呃

305
00:13:27,000 --> 00:13:30,000
我的手指碰到了 button 按下去了

306
00:13:30,000 --> 00:13:31,000
这是 event

307
00:13:31,000 --> 00:13:33,000
或者是我的手指提起来

308
00:13:33,000 --> 00:13:33,000
呃

309
00:13:33,000 --> 00:13:36,000
从 button 上面移开了这个 event

310
00:13:36,000 --> 00:13:38,000
就是相当于

311
00:13:38,000 --> 00:13:39,000
呃

312
00:13:39,000 --> 00:13:41,000
如果你搞过

313
00:13:41,000 --> 00:13:42,000
iOS 变成的话

314
00:13:42,000 --> 00:13:47,000
就相当于 touch start 和 touch end

315
00:13:47,000 --> 00:13:48,000
嗯哼

316
00:13:49,000 --> 00:13:50,000
这两个事件

317
00:13:50,000 --> 00:13:53,000
还是 touch leave inside 这两个事件

318
00:13:53,000 --> 00:13:53,000
对

319
00:13:53,000 --> 00:13:54,000
它唯一能做的就是

320
00:13:54,000 --> 00:13:54,000
哦

321
00:13:54,000 --> 00:13:56,000
这个按钮被按下了一次

322
00:13:56,000 --> 00:13:57,000
但是没有办法判断这个按钮

323
00:13:57,000 --> 00:13:58,000
把它按下了长短

324
00:13:59,000 --> 00:14:00,000
所以这样一来

325
00:14:00,000 --> 00:14:03,000
你想要像那些比较

326
00:14:04,000 --> 00:14:04,000
嗯

327
00:14:07,000 --> 00:14:07,000
呃

328
00:14:07,000 --> 00:14:10,000
熟练一点的电报员那样

329
00:14:10,000 --> 00:14:14,000
通过快速敲击表盘来发点和滑的

330
00:14:14,000 --> 00:14:15,000
呃

331
00:14:15,000 --> 00:14:16,000
希望的泡汤

332
00:14:16,000 --> 00:14:19,000
因为每一个按键被按下去的过程

333
00:14:19,000 --> 00:14:20,000
实际上是非常缓慢的

334
00:14:21,000 --> 00:14:24,000
而且我相信苹果为了防止说

335
00:14:24,000 --> 00:14:25,000
呃

336
00:14:26,000 --> 00:14:28,000
一个人

337
00:14:28,000 --> 00:14:32,000
误触一个按键两次

338
00:14:32,000 --> 00:14:34,000
在短时间内误触个按键两次

339
00:14:34,000 --> 00:14:35,000
他故意

340
00:14:36,000 --> 00:14:37,000
放了一段怎么说

341
00:14:37,000 --> 00:14:38,000
将职期在那边

342
00:14:38,000 --> 00:14:39,000
就是你

343
00:14:39,000 --> 00:14:41,000
我可能想说不应急

344
00:14:41,000 --> 00:14:43,000
哈哈

345
00:14:43,000 --> 00:14:44,000
所以在这段时间之内

346
00:14:45,000 --> 00:14:47,000
你怎么按这个键都没有反应

347
00:14:47,000 --> 00:14:48,000
呃

348
00:14:49,000 --> 00:14:50,000
所以

349
00:14:50,000 --> 00:14:51,000
从这个角度讲

350
00:14:51,000 --> 00:14:52,000
呃

351
00:14:52,000 --> 00:14:55,000
原本的设想是就已经做不到了

352
00:14:55,000 --> 00:14:57,000
然后我现在临时的方案是

353
00:14:57,000 --> 00:14:58,000
放两个按键的上面

354
00:14:58,000 --> 00:15:00,000
一个代表点一个代表滑

355
00:15:00,000 --> 00:15:00,000
但是

356
00:15:01,000 --> 00:15:03,000
最大的一个很明显

357
00:15:03,000 --> 00:15:04,000
对这样不酷呀

358
00:15:04,000 --> 00:15:05,000
而且

359
00:15:06,000 --> 00:15:07,000
仍旧是比较慢

360
00:15:08,000 --> 00:15:09,000
然后我

361
00:15:09,000 --> 00:15:10,000
我打个岔问一个事

362
00:15:10,000 --> 00:15:13,000
就是他那个表上不是还有两个物理的东西吗

363
00:15:13,000 --> 00:15:16,000
一个是那个叫做数字表观的东西

364
00:15:16,000 --> 00:15:18,000
还有一个就是旁边有个数字表观下面有个按钮

365
00:15:19,000 --> 00:15:21,000
那两个是可以通过 API 访问的到的

366
00:15:21,000 --> 00:15:21,000
他的

367
00:15:22,000 --> 00:15:23,000
操作的吗

368
00:15:23,000 --> 00:15:24,000
呃

369
00:15:24,000 --> 00:15:27,000
并不直接访问并不能直接访问到

370
00:15:27,000 --> 00:15:28,000
首先朋友的那个键

371
00:15:29,000 --> 00:15:29,000
呃

372
00:15:29,000 --> 00:15:31,000
那键的官方名字叫什么

373
00:15:32,000 --> 00:15:32,000
呃

374
00:15:32,000 --> 00:15:32,000
Frankie

375
00:15:33,000 --> 00:15:34,000
哈哈

376
00:15:34,000 --> 00:15:35,000
我到那个官方

377
00:15:35,000 --> 00:15:36,000
就就

378
00:15:36,000 --> 00:15:38,000
反正我在上面那个叫 Digital Chrome

379
00:15:39,000 --> 00:15:39,000
下面那个叫

380
00:15:39,000 --> 00:15:41,000
下面可能就叫 Side Button

381
00:15:41,000 --> 00:15:42,000
如果没记错

382
00:15:42,000 --> 00:15:43,000
反正就是按钮

383
00:15:43,000 --> 00:15:43,000
对

384
00:15:43,000 --> 00:15:45,000
这个按钮的按点

385
00:15:45,000 --> 00:15:48,000
就是按下是可以在你的应用里面探测得到的吗

386
00:15:49,000 --> 00:15:49,000
对

387
00:15:50,000 --> 00:15:54,000
然后这两个键 Side Button 是没有办法直接编程获得的

388
00:15:54,000 --> 00:15:57,000
然后 Digital Chrome 也不能直接编程说

389
00:15:57,000 --> 00:15:58,000
呃

390
00:15:58,000 --> 00:16:01,000
此时发生了一个 Digital Chrome 被转动的事件

391
00:16:02,000 --> 00:16:04,000
而只能通过一个叫做

392
00:16:04,000 --> 00:16:05,000
如果没记错的话

393
00:16:05,000 --> 00:16:07,000
应该叫 Interface Speaker

394
00:16:09,000 --> 00:16:09,000
的

395
00:16:10,000 --> 00:16:10,000
呃

396
00:16:11,000 --> 00:16:14,000
空间来接来获取它

397
00:16:14,000 --> 00:16:18,000
就是哪怕是在这个所谓 Watch OS 2 也是这样吗

398
00:16:18,000 --> 00:16:19,000
就新版

399
00:16:19,000 --> 00:16:20,000
哪怕在 Watch OS 2 里面也是这样

400
00:16:21,000 --> 00:16:23,000
而且好像是只有在 Watch OS 2 里面

401
00:16:23,000 --> 00:16:25,000
才可以使用这个空间

402
00:16:25,000 --> 00:16:25,000
也就是说

403
00:16:26,000 --> 00:16:29,000
之前在目前的版本的 X Code 6 里面

404
00:16:29,000 --> 00:16:31,000
是没有办法去

405
00:16:31,000 --> 00:16:33,000
以任何方法获得

406
00:16:34,000 --> 00:16:36,000
这个 Digital Chrome 被转动的时间

407
00:16:37,000 --> 00:16:38,000
然后在 Watch OS 2 里面

408
00:16:38,000 --> 00:16:40,000
你可以放一个 Picker

409
00:16:40,000 --> 00:16:41,000
然后这个 Picker 的

410
00:16:42,000 --> 00:16:43,000
呃

411
00:16:43,000 --> 00:16:45,000
的外观其实就像

412
00:16:46,000 --> 00:16:47,000
呃

413
00:16:47,000 --> 00:16:48,000
比如说那个键

414
00:16:48,000 --> 00:16:51,000
就是监测你的 Activity 的那个 App 里面

415
00:16:51,000 --> 00:16:52,000
你可以

416
00:16:52,000 --> 00:16:53,000
呃

417
00:16:53,000 --> 00:16:54,000
通过

418
00:16:54,000 --> 00:16:57,000
指头在表盘上下滑动

419
00:16:57,000 --> 00:16:59,000
或者是通过 Digital Chrome 来

420
00:16:59,000 --> 00:17:03,000
转动去选择一个列表之中的某一下

421
00:17:03,000 --> 00:17:04,000
然后这个 slider

422
00:17:04,000 --> 00:17:07,000
然后这个 Picker 会发生一个

423
00:17:08,000 --> 00:17:08,000
呃

424
00:17:08,000 --> 00:17:10,000
Selected Item Changed

425
00:17:10,000 --> 00:17:12,000
怎么样这样一个 Event

426
00:17:12,000 --> 00:17:15,000
所以你可以通过这个 Event 来间接的判断说

427
00:17:15,000 --> 00:17:16,000
Chrome 现在被转动

428
00:17:17,000 --> 00:17:18,000
那也仅此而已

429
00:17:18,000 --> 00:17:18,000
对

430
00:17:19,000 --> 00:17:20,000
还有一个

431
00:17:20,000 --> 00:17:22,000
就是我提的一个建议

432
00:17:22,000 --> 00:17:23,000
后来他证明也是不行的

433
00:17:23,000 --> 00:17:24,000
就是说

434
00:17:24,000 --> 00:17:25,000
他那个

435
00:17:25,000 --> 00:17:27,000
表的那个

436
00:17:27,000 --> 00:17:27,000
嗯

437
00:17:27,000 --> 00:17:29,000
触屏不是可以探测压感吗

438
00:17:30,000 --> 00:17:32,000
就可以通过什么 Forstouch

439
00:17:32,000 --> 00:17:35,000
就是用力的压和不用力的压区分 0 和 1

440
00:17:35,000 --> 00:17:37,000
这个后来是一个什么样的情况

441
00:17:37,000 --> 00:17:38,000
事实上也是不行的

442
00:17:38,000 --> 00:17:40,000
因为 Forstouch 这个

443
00:17:40,000 --> 00:17:42,000
动作被

444
00:17:42,000 --> 00:17:42,000
呃

445
00:17:42,000 --> 00:17:44,000
SDK 限制为

446
00:17:45,000 --> 00:17:45,000
呃

447
00:17:45,000 --> 00:17:47,000
呼出

448
00:17:47,000 --> 00:17:49,000
快捷菜单这么一个

449
00:17:49,000 --> 00:17:50,000
呼出

450
00:17:50,000 --> 00:17:52,000
呼出 Context Menu 这么一个动作

451
00:17:52,000 --> 00:17:53,000
所以如果你要

452
00:17:54,000 --> 00:17:54,000
呃

453
00:17:54,000 --> 00:17:56,000
触发处理这个事件的话呢

454
00:17:56,000 --> 00:17:59,000
那你唯一能做的就是把它连到一个

455
00:17:59,000 --> 00:18:00,000
呃

456
00:18:00,000 --> 00:18:00,000
菜单上面

457
00:18:01,000 --> 00:18:01,000
嗯哼

458
00:18:02,000 --> 00:18:03,000
别的不能做了

459
00:18:04,000 --> 00:18:06,000
然后这个菜单出来

460
00:18:06,000 --> 00:18:08,000
比如说上面有一个唯一一个按键就是

461
00:18:08,000 --> 00:18:09,000
点一下就

462
00:18:09,000 --> 00:18:10,000
就输入 1

463
00:18:10,000 --> 00:18:10,000
不可以吗

464
00:18:11,000 --> 00:18:12,000
呃

465
00:18:12,000 --> 00:18:15,000
我觉得这个操作还是非常的

466
00:18:15,000 --> 00:18:16,000
奇怪了

467
00:18:16,000 --> 00:18:16,000
不够帅是吧

468
00:18:17,000 --> 00:18:17,000
对

469
00:18:18,000 --> 00:18:20,000
那其实还不如放两个按钮

470
00:18:20,000 --> 00:18:20,000
因为你

471
00:18:21,000 --> 00:18:24,000
无论如何在长按之下还要点一下就非常的

472
00:18:24,000 --> 00:18:24,000
嗯

473
00:18:25,000 --> 00:18:29,000
关键是我觉得他那个 Forstouch 的那个力度很不好控制

474
00:18:29,000 --> 00:18:30,000
没错

475
00:18:30,000 --> 00:18:31,000
而且我觉得

476
00:18:31,000 --> 00:18:33,000
苹果有点

477
00:18:34,000 --> 00:18:36,000
对于上下的滚动太敏感了

478
00:18:36,000 --> 00:18:38,000
苹果表对于上下的滚动太敏感了

479
00:18:38,000 --> 00:18:40,000
就是我不知道你有没有这个感觉

480
00:18:40,000 --> 00:18:41,000
就是你在走路的时候

481
00:18:42,000 --> 00:18:42,000
嗯哼

482
00:18:42,000 --> 00:18:44,000
如果你试图呃

483
00:18:44,000 --> 00:18:46,000
按一个按键

484
00:18:46,000 --> 00:18:46,000
嗯哼

485
00:18:46,000 --> 00:18:48,000
你会发现这个

486
00:18:48,000 --> 00:18:51,000
表会更倾向于转动它的

487
00:18:51,000 --> 00:18:53,000
呃上下滑动它的屏幕

488
00:18:53,000 --> 00:18:54,000
而不是让你把这个按键按下去

489
00:18:54,000 --> 00:18:56,000
尤其是这个屏幕可以滑动的时候

490
00:18:56,000 --> 00:18:57,000
比如说

491
00:18:57,000 --> 00:18:58,000
回复一个人的短信

492
00:18:58,000 --> 00:19:02,000
好你一边走路一边抬起手腕来看到一个人的短信

493
00:19:02,000 --> 00:19:05,000
然后你想要回复他

494
00:19:05,000 --> 00:19:07,000
回复回复哪一下就很难点了

495
00:19:07,000 --> 00:19:08,000
因为对

496
00:19:08,000 --> 00:19:09,000
这里有一个问题

497
00:19:09,000 --> 00:19:11,000
就是就就刚才你说的两个事件

498
00:19:11,000 --> 00:19:13,000
一个 touch start 和 touch end

499
00:19:14,000 --> 00:19:15,000
他们之间是有一个间隙的

500
00:19:15,000 --> 00:19:17,000
然后你你在运动中

501
00:19:17,000 --> 00:19:18,000
你这个

502
00:19:18,000 --> 00:19:20,000
那个肯定是会发生位移的吗

503
00:19:20,000 --> 00:19:21,000
那个触摸的手指

504
00:19:22,000 --> 00:19:23,000
对

505
00:19:23,000 --> 00:19:25,000
然后这样一来你在

506
00:19:25,000 --> 00:19:27,000
对这样一来你在

507
00:19:28,000 --> 00:19:31,000
选择回复的时候就已经很吃力了

508
00:19:31,000 --> 00:19:33,000
你可能需要把

509
00:19:33,000 --> 00:19:35,000
食指按在手腕上

510
00:19:35,000 --> 00:19:38,000
然后用中指去点那个回复键

511
00:19:38,000 --> 00:19:40,000
因为这样可以减少两个手之间的相对移动

512
00:19:41,000 --> 00:19:42,000
然后等你

513
00:19:43,000 --> 00:19:45,000
呼出了那个一堆

514
00:19:46,000 --> 00:19:47,000
短暂的

515
00:19:47,000 --> 00:19:49,000
快捷回复内容的时候

516
00:19:49,000 --> 00:19:50,000
可能

517
00:19:50,000 --> 00:19:51,000
你又要

518
00:19:52,000 --> 00:19:54,000
很小心的去按其中的某一个

519
00:19:54,000 --> 00:19:56,000
不然他又会处理被滑动

520
00:19:57,000 --> 00:19:59,000
对这个是挺糟糕的一件事

521
00:19:59,000 --> 00:20:01,000
可能他们还得再微调一下

522
00:20:01,000 --> 00:20:01,000
因为毕竟

523
00:20:02,000 --> 00:20:05,000
这么小的表盘上的这种

524
00:20:06,000 --> 00:20:07,000
触摸的操作

525
00:20:07,000 --> 00:20:09,000
和手机大屏幕的触摸到的情况

526
00:20:09,000 --> 00:20:11,000
还是有点不同的

527
00:20:11,000 --> 00:20:14,000
怎么去制定一些边界的条件

528
00:20:14,000 --> 00:20:14,000
我觉得还是挺

529
00:20:15,000 --> 00:20:16,000
怎么说呢

530
00:20:16,000 --> 00:20:17,000
挺麻烦一个事儿

531
00:20:18,000 --> 00:20:18,000
对

532
00:20:18,000 --> 00:20:20,000
然后我希望在接下来的几代

533
00:20:20,000 --> 00:20:21,000
iOS

534
00:20:21,000 --> 00:20:22,000
啊不

535
00:20:22,000 --> 00:20:25,000
Watch OS 里面可以提供更多的事件

536
00:20:26,000 --> 00:20:27,000
以及更多的 API 支持

537
00:20:27,000 --> 00:20:30,000
比如说现在好像没有办法去

538
00:20:32,000 --> 00:20:34,000
检测他的那个陀螺仪

539
00:20:34,000 --> 00:20:36,000
或者是血压计都没有办法

540
00:20:37,000 --> 00:20:39,000
就只能做一些非常简单的功能

541
00:20:39,000 --> 00:20:40,000
然后

542
00:20:40,000 --> 00:20:43,000
所有动画都必须通过

543
00:20:43,000 --> 00:20:44,000
图片来实现

544
00:20:44,000 --> 00:20:45,000
就是如果你想要

545
00:20:46,000 --> 00:20:47,000
显示一个动画

546
00:20:47,000 --> 00:20:49,000
你得预先把每一帧都

547
00:20:49,000 --> 00:20:51,000
存成一幅照片

548
00:20:51,000 --> 00:20:55,000
然后就是连着放那个换成片

549
00:20:55,000 --> 00:20:57,000
对然后连着放换成片

550
00:20:57,000 --> 00:20:58,000
然后苹果的

551
00:20:58,000 --> 00:21:00,000
这次 WWDC 上面

552
00:21:01,000 --> 00:21:03,000
还劝告开发者说注意

553
00:21:04,000 --> 00:21:05,000
图片的尺寸

554
00:21:06,000 --> 00:21:08,000
因为在 iOS

555
00:21:08,000 --> 00:21:10,000
在 Watch OS 一代里面

556
00:21:10,000 --> 00:21:12,000
图片每次都要传到手表上

557
00:21:13,000 --> 00:21:14,000
而在 Watch OS

558
00:21:15,000 --> 00:21:17,000
对而在 Watch OS 2 上面

559
00:21:17,000 --> 00:21:20,000
至少在第一次安装的时候

560
00:21:20,000 --> 00:21:22,000
这个传输过程也是比较

561
00:21:22,000 --> 00:21:23,000
耗时的

562
00:21:23,000 --> 00:21:25,000
并且如果你

563
00:21:25,000 --> 00:21:26,000
图片太大的话

564
00:21:26,000 --> 00:21:28,000
它存在手表上也是很占地

565
00:21:29,000 --> 00:21:29,000
对

566
00:21:29,000 --> 00:21:32,000
好像手把有个内置有个什么 8 GB 的

567
00:21:32,000 --> 00:21:33,000
存储文件吧

568
00:21:33,000 --> 00:21:34,000
总共

569
00:21:34,000 --> 00:21:36,000
对然后其中大概有

570
00:21:37,000 --> 00:21:39,000
三分之一被操作总共

571
00:21:40,000 --> 00:21:41,000
嗯

572
00:21:42,000 --> 00:21:42,000
嗯

573
00:21:43,000 --> 00:21:46,000
所以其实为这个机类玩意儿

574
00:21:46,000 --> 00:21:48,000
开发东西还是挺难的

575
00:21:48,000 --> 00:21:49,000
没错

576
00:21:51,000 --> 00:21:52,000
但怎么说呢

577
00:21:52,000 --> 00:21:53,000
毕竟是第一代产品

578
00:21:53,000 --> 00:21:54,000
希望以后会有的也好

579
00:21:54,000 --> 00:21:57,000
也许以后会有摄像机出现在

580
00:21:58,000 --> 00:21:59,000
手表上

581
00:22:00,000 --> 00:22:01,000
摄像机

582
00:22:02,000 --> 00:22:02,000
对啊

583
00:22:03,000 --> 00:22:04,000
就是用一个摄像头

584
00:22:05,000 --> 00:22:08,000
装一个摄像头在人手表上还是挺实用的

585
00:22:09,000 --> 00:22:10,000
我有点担心

586
00:22:10,000 --> 00:22:12,000
然后那个就会布那个

587
00:22:12,000 --> 00:22:14,000
Google Glass 的后成

588
00:22:15,000 --> 00:22:17,000
你干嘛用你的手表对着我

589
00:22:17,000 --> 00:22:18,000
你是不是在录像

590
00:22:18,000 --> 00:22:19,000
没错啊

591
00:22:19,000 --> 00:22:21,000
你那么隐蔽的一个摄像装置

592
00:22:21,000 --> 00:22:23,000
谁知道你没有在拍人家群体是不是

593
00:22:23,000 --> 00:22:24,000
嗯

594
00:22:25,000 --> 00:22:26,000
特别是在日本这种国家的吧

595
00:22:26,000 --> 00:22:28,000
就挺麻烦的我觉得

596
00:22:28,000 --> 00:22:29,000
对

597
00:22:29,000 --> 00:22:32,000
其实在目前的手表上可以遥控

598
00:22:32,000 --> 00:22:35,000
手机上的相机已经有一点

599
00:22:35,000 --> 00:22:38,000
就是可以用它来做一些不那么

600
00:22:39,000 --> 00:22:40,000
道德的事情的嫌疑了

601
00:22:40,000 --> 00:22:41,000
很明

602
00:22:41,000 --> 00:22:43,000
目前还没有看到对此的批评

603
00:22:44,000 --> 00:22:46,000
他如果遥控手机的话

604
00:22:46,000 --> 00:22:48,000
反正比如说你在日本购买的合法的

605
00:22:49,000 --> 00:22:51,000
这个 iPhone 的那个拍照的时候

606
00:22:51,000 --> 00:22:52,000
那个咔嚓声是关不掉的吗

607
00:22:54,000 --> 00:22:55,000
你知道这事吗

608
00:22:55,000 --> 00:22:56,000
我不知道

609
00:22:56,000 --> 00:22:58,000
就好像只有日本

610
00:22:58,000 --> 00:23:02,000
就是日版的 iPhone 是有这个限制

611
00:23:02,000 --> 00:23:03,000
就是说你中国的

612
00:23:03,000 --> 00:23:05,000
就是欧版或者是中国大陆的

613
00:23:05,000 --> 00:23:06,000
卖的那个

614
00:23:07,000 --> 00:23:11,000
iPhone 手机的那个调成这个震动模式之后

615
00:23:11,000 --> 00:23:12,000
你用拍照的时候

616
00:23:12,000 --> 00:23:13,000
它是不会发出任何声音的

617
00:23:14,000 --> 00:23:15,000
拍了就拍了

618
00:23:15,000 --> 00:23:18,000
但是你在日本买了就会咔嚓

619
00:23:18,000 --> 00:23:20,000
哪怕是在震动模式也会有这个

620
00:23:20,000 --> 00:23:22,000
是指在

621
00:23:22,000 --> 00:23:26,000
是指在照片 APP 这个层级上限制呢

622
00:23:26,000 --> 00:23:27,000
还是在所有的 APP 里面

623
00:23:27,000 --> 00:23:29,000
在 API 的层级上限制

624
00:23:29,000 --> 00:23:31,000
只要有拍照这个功能都会发出声音

625
00:23:31,000 --> 00:23:32,000
Holy fuck

626
00:23:33,000 --> 00:23:35,000
我当时知道这个消息的时候

627
00:23:35,000 --> 00:23:36,000
我也是震惊了

628
00:23:38,000 --> 00:23:39,000
不可思议

629
00:23:40,000 --> 00:23:41,000
狗狗什么

630
00:23:41,000 --> 00:23:41,000
有国情嘛

631
00:23:41,000 --> 00:23:42,000
有国情

632
00:23:43,000 --> 00:23:43,000
嗯

633
00:23:44,000 --> 00:23:45,000
好吧

634
00:23:45,000 --> 00:23:48,000
那个我们下面念几封这个听众来信好吧

635
00:23:49,000 --> 00:23:49,000
对

636
00:23:49,000 --> 00:23:54,000
上一期的节目在微博上面没有太多人评论

637
00:23:54,000 --> 00:23:55,000
但是

638
00:23:55,000 --> 00:23:59,000
我们却收到了好几封又长又热情读者来信

639
00:24:00,000 --> 00:24:00,000
嗯哼

640
00:24:01,000 --> 00:24:03,000
先念第一位吧

641
00:24:03,000 --> 00:24:06,000
这个是一叫陈一鸣

642
00:24:06,000 --> 00:24:08,000
这只拼音不知道怎么写

643
00:24:08,000 --> 00:24:10,000
陈一鸣的来信

644
00:24:10,000 --> 00:24:11,000
对

645
00:24:11,000 --> 00:24:12,000
Rail 吴涛你们好

646
00:24:12,000 --> 00:24:14,000
听了你们这期内核恐慌

647
00:24:15,000 --> 00:24:17,000
我也想发表一下自己对测试的看法

648
00:24:18,000 --> 00:24:22,000
第一次接触测试可以说是在高中算法竞赛的时候

649
00:24:22,000 --> 00:24:23,000
哇好厉害

650
00:24:23,000 --> 00:24:25,000
高中就算法竞赛

651
00:24:25,000 --> 00:24:30,000
当时老师特地请了 ACM 大牛来学校指导我们

652
00:24:30,000 --> 00:24:32,000
在休息的时候就顺便教我们如何写

653
00:24:33,000 --> 00:24:35,000
对拍程序

654
00:24:35,000 --> 00:24:36,000
什么是对拍程序

655
00:24:37,000 --> 00:24:39,000
对拍程序就是

656
00:24:40,000 --> 00:24:41,000
就像一个

657
00:24:42,000 --> 00:24:44,000
那个节奏器吧

658
00:24:44,000 --> 00:24:46,000
我很理解就是你要和他对

659
00:24:46,000 --> 00:24:47,000
对

660
00:24:47,000 --> 00:24:48,000
对你的拍子

661
00:24:48,000 --> 00:24:49,000
OK

662
00:24:49,000 --> 00:24:52,000
啊这这点念成有这个就是有三个步骤

663
00:24:53,000 --> 00:24:56,000
第一步是先写一个低下的程序

664
00:24:56,000 --> 00:24:57,000
保证这个程序的正确性

665
00:24:58,000 --> 00:25:02,000
然后第二步是再写一个随机生成输入数据的程序

666
00:25:02,000 --> 00:25:04,000
并保证生成各种边界条件

667
00:25:04,000 --> 00:25:08,000
第三就是最后写自己打算提交的最终代码

668
00:25:08,000 --> 00:25:11,000
并用以上两个程序来保证该代码的正确性

669
00:25:12,000 --> 00:25:16,000
当时还是在 Windows 下用命令行提示符写脚本

670
00:25:16,000 --> 00:25:18,000
对输出进行对比

671
00:25:18,000 --> 00:25:19,000
因此印象深刻

672
00:25:19,000 --> 00:25:22,000
但学了之后在比赛中真正用到的人很少

673
00:25:22,000 --> 00:25:26,000
又或者是我没有进到省机上的比赛没接触到

674
00:25:26,000 --> 00:25:27,000
这是括号里面的一个话

675
00:25:27,000 --> 00:25:31,000
现在看来当时学的测试方法已经很标准有效了

676
00:25:31,000 --> 00:25:33,000
然而实践起来却难上架了

677
00:25:33,000 --> 00:25:34,000
难

678
00:25:34,000 --> 00:25:36,000
写最终代码都来不及了

679
00:25:36,000 --> 00:25:40,000
哪还有时间写低下程序和更麻烦的数据生成脚本

680
00:25:41,000 --> 00:25:44,000
也因此我对测试并没有什么好印象

681
00:25:45,000 --> 00:25:48,000
但是这学期我在一个课程的这个 project

682
00:25:48,000 --> 00:25:50,000
用的是 Python 的 Jangle 中

683
00:25:50,000 --> 00:25:52,000
第一次尝试了 TDD

684
00:25:52,000 --> 00:25:54,000
就像上次我讲的 Test Driven Development

685
00:25:55,000 --> 00:25:56,000
测试驱动的开发

686
00:25:57,000 --> 00:25:59,000
对测试大大改观

687
00:25:59,000 --> 00:26:02,000
发现测试并没有之前想象的那么无用

688
00:26:02,000 --> 00:26:06,000
也比二位在节目中说的重要得多

689
00:26:07,000 --> 00:26:10,000
我在节目中没有说它不重要

690
00:26:10,000 --> 00:26:11,000
我只是不喜欢它

691
00:26:11,000 --> 00:26:12,000
但从来没有说过它不重要

692
00:26:13,000 --> 00:26:15,000
对我们都一致认可测试的重要性

693
00:26:15,000 --> 00:26:16,000
有总是比没有好的

694
00:26:16,000 --> 00:26:18,000
只是我们都不太喜欢写测试

695
00:26:20,000 --> 00:26:21,000
他说这个接着讲

696
00:26:21,000 --> 00:26:24,000
他说测试最重要是帮助我们写出

697
00:26:24,000 --> 00:26:26,000
意义测试的代码

698
00:26:26,000 --> 00:26:30,000
单元测试的定义决定的程序的每一个小功能

699
00:26:30,000 --> 00:26:31,000
都要有一个接口

700
00:26:31,000 --> 00:26:33,000
供测试代码调用

701
00:26:33,000 --> 00:26:34,000
而先写单元测试

702
00:26:34,000 --> 00:26:37,000
这样我们先对这个接口有一个设想

703
00:26:37,000 --> 00:26:40,000
帮助我们降低项目的吻合度

704
00:26:40,000 --> 00:26:41,000
提高内置性

705
00:26:41,000 --> 00:26:44,000
当然有一个架构的过程也能办到

706
00:26:44,000 --> 00:26:48,000
但一个小团队或者一个需要快速开发的项目

707
00:26:48,000 --> 00:26:50,000
往往没有那么多时间去架构

708
00:26:50,000 --> 00:26:52,000
测试能在架构上提供帮助

709
00:26:53,000 --> 00:26:55,000
这一点我觉得有点意思

710
00:26:55,000 --> 00:26:55,000
就是说

711
00:26:57,000 --> 00:27:00,000
写单元测试能够帮助所谓做一个

712
00:27:00,000 --> 00:27:04,000
最小颗粒度的独立运行的一段代码对吧

713
00:27:04,000 --> 00:27:05,000
对

714
00:27:05,000 --> 00:27:09,000
这样的话就可以至少说我们不会写一个

715
00:27:10,000 --> 00:27:13,000
翻五页都翻不完的单一函数对吧

716
00:27:14,000 --> 00:27:15,000
这样就没法测了

717
00:27:17,000 --> 00:27:19,000
所以从这两段我觉得还是有一定好处

718
00:27:19,000 --> 00:27:23,000
就起码在对你这个叫什么代码的组织上是有一定帮助的

719
00:27:24,000 --> 00:27:28,000
对你每一测试其实就是一个对于你真正的 API 的考验

720
00:27:29,000 --> 00:27:29,000
对

721
00:27:30,000 --> 00:27:33,000
很多考验是如果你没有用过的话

722
00:27:33,000 --> 00:27:37,000
完全不知道自己没有办法通过这个考验

723
00:27:37,000 --> 00:27:40,000
所以如果一开始能把这个考验就先写出来的话

724
00:27:40,000 --> 00:27:44,000
那设计 API 的时候其实会方便很多

725
00:27:45,000 --> 00:27:45,000
对

726
00:27:46,000 --> 00:27:48,000
然后接着念他这个来信

727
00:27:48,000 --> 00:27:49,000
然后他这里马上举了一个反例

728
00:27:49,000 --> 00:27:52,000
就是这学期我做的另一个项目

729
00:27:52,000 --> 00:27:54,000
PAYQT 5

730
00:27:54,000 --> 00:27:57,000
完全没有测试写出来就杂乱无章

731
00:27:57,000 --> 00:27:58,000
偶何的过紧

732
00:27:58,000 --> 00:28:00,000
以至于最后自己都不想再写下去了

733
00:28:01,000 --> 00:28:04,000
当然主要是我没做好前期架构的工作对吧

734
00:28:04,000 --> 00:28:06,000
就其实就是有这么一个

735
00:28:06,000 --> 00:28:07,000
叫什么

736
00:28:08,000 --> 00:28:10,000
没有纪律性的程序员

737
00:28:10,000 --> 00:28:12,000
需要这个

738
00:28:12,000 --> 00:28:14,000
通过测试这种一种外部的手段

739
00:28:14,000 --> 00:28:16,000
强制你把这个代码的

740
00:28:16,000 --> 00:28:19,000
这个颗粒度缩的比较小

741
00:28:19,000 --> 00:28:22,000
然后每个是可以有独立逻辑可以独立运作的

742
00:28:23,000 --> 00:28:24,000
我不知道你写代码是怎么样子

743
00:28:24,000 --> 00:28:26,000
但我写代码的时候

744
00:28:26,000 --> 00:28:29,000
我不喜欢那种非常长的一段函数

745
00:28:29,000 --> 00:28:30,000
就是

746
00:28:30,000 --> 00:28:32,000
有这种

747
00:28:32,000 --> 00:28:36,000
洁癖就是凡是要抽象出来成一个函数

748
00:28:37,000 --> 00:28:38,000
是吧

749
00:28:38,000 --> 00:28:40,000
因为我记得

750
00:28:40,000 --> 00:28:43,000
很早以前就在那本书上看到我是

751
00:28:43,000 --> 00:28:44,000
Pragmatical

752
00:28:44,000 --> 00:28:46,000
Pragmatical 上面说了

753
00:28:47,000 --> 00:28:48,000
每一个函数最好

754
00:28:48,000 --> 00:28:51,000
长度不要超过一瓶这样

755
00:28:51,000 --> 00:28:53,000
你不用转动屏幕就可以

756
00:28:53,000 --> 00:28:55,000
看明白他是在干嘛

757
00:28:55,000 --> 00:28:55,000
那没错

758
00:28:56,000 --> 00:28:57,000
基本上我也是这个习惯

759
00:28:59,000 --> 00:29:01,000
但是字号要足够大才行

760
00:29:01,000 --> 00:29:02,000
不然就

761
00:29:03,000 --> 00:29:05,000
开 6 号字

762
00:29:05,000 --> 00:29:07,000
一瓶还是数瓶呢你怎么办

763
00:29:08,000 --> 00:29:09,000
那也是挺痛苦的

764
00:29:10,000 --> 00:29:11,000
对

765
00:29:12,000 --> 00:29:13,000
接着念这个

766
00:29:13,000 --> 00:29:17,000
其次是保证在重构时不犯错

767
00:29:17,000 --> 00:29:20,000
在我的项目开发的过程短短几天时间里

768
00:29:20,000 --> 00:29:24,000
我就有好几次对大片的代码进行重构或者是优化

769
00:29:24,000 --> 00:29:26,000
如果没有测试做保障

770
00:29:26,000 --> 00:29:29,000
无法想象能在短时间内一个人完成这些工作

771
00:29:30,000 --> 00:29:34,000
使用 TDD 的感受就是对代码的每一次更改都很安心

772
00:29:34,000 --> 00:29:38,000
因为有 Test 在代码错错的第一时间帮我指出

773
00:29:38,000 --> 00:29:42,000
而重构不犯错的另一个好处是让它维护更加方便

774
00:29:42,000 --> 00:29:43,000
只要通过测试就可以了

775
00:29:44,000 --> 00:29:46,000
这个其实怎么说呢

776
00:29:48,000 --> 00:29:50,000
这个确实是有好处的

777
00:29:50,000 --> 00:29:53,000
对回归测试就是做这样

778
00:29:53,000 --> 00:29:59,000
就是保证你在引入新特性或者重新架构你的程序的时候

779
00:29:59,000 --> 00:30:02,000
可以保证既有的正确的东西不会被改变

780
00:30:03,000 --> 00:30:05,000
这个基本上只有测试可以做到

781
00:30:05,000 --> 00:30:09,000
没有办法用其他任何办法来试图达到这个目的

782
00:30:10,000 --> 00:30:12,000
都是事倍功半的

783
00:30:12,000 --> 00:30:15,000
但主要是有一点我觉得比较好奇的是

784
00:30:15,000 --> 00:30:17,000
如果它对大片代码进行了重构

785
00:30:18,000 --> 00:30:20,000
与之对应的单人测试不要重写

786
00:30:25,000 --> 00:30:27,000
其实这是一个集成单单身机的问题

787
00:30:27,000 --> 00:30:32,000
如果一开始的单人测试写的就让你没有那么好重构的话

788
00:30:32,000 --> 00:30:34,000
那重构起来也是困难的

789
00:30:35,000 --> 00:30:37,000
但如果你一开始单人测试写的颗粒足够小

790
00:30:37,000 --> 00:30:41,000
然后你的接口也保证的比较好

791
00:30:41,000 --> 00:30:46,000
基本上单人测试是在很大一部分程度上可以

792
00:30:48,000 --> 00:30:49,000
沿流下来沿用

793
00:30:51,000 --> 00:30:53,000
这还是要回到一开始

794
00:30:53,000 --> 00:30:56,000
就是你得一开始做一定的架构

795
00:30:56,000 --> 00:30:59,000
你不能完全依赖于自己的单人测试

796
00:31:00,000 --> 00:31:03,000
所以其实我理解这么一个重构的还是有一定的

797
00:31:03,000 --> 00:31:08,000
就两个不同的层次

798
00:31:08,000 --> 00:31:11,000
比如说你对某一个函数的内部实现

799
00:31:11,000 --> 00:31:14,000
或者某一个就不改变接口情况下

800
00:31:14,000 --> 00:31:17,000
内部实现的重构是完全没有问题

801
00:31:17,000 --> 00:31:18,000
这个做起来也非常爽

802
00:31:18,000 --> 00:31:20,000
你只要确保那些

803
00:31:20,000 --> 00:31:21,000
因为测试是按照接口

804
00:31:21,000 --> 00:31:23,000
单人测试按接口来做的

805
00:31:23,000 --> 00:31:26,000
你把那些边界条件都弄出来

806
00:31:26,000 --> 00:31:27,000
然后看一下能不能跑通

807
00:31:27,000 --> 00:31:30,000
大致上也有什么八九不离十的信心了

808
00:31:30,000 --> 00:31:35,000
但是如果你是连这个接口都发生了比较大的改变的重复的话

809
00:31:35,000 --> 00:31:38,000
我觉得你在过程中也不会爽到哪里去

810
00:31:38,000 --> 00:31:39,000
因为毕竟还是要写很多

811
00:31:39,000 --> 00:31:42,000
要重写很多单人测试的

812
00:31:42,000 --> 00:31:42,000
因为接口变了

813
00:31:43,000 --> 00:31:44,000
对

814
00:31:45,000 --> 00:31:46,000
接着念下面一个

815
00:31:47,000 --> 00:31:50,000
测试还是形式证明

816
00:31:51,000 --> 00:31:52,000
这个选择挺好

817
00:31:52,000 --> 00:31:54,000
节目中 Rio 提到对代码的可靠性

818
00:31:54,000 --> 00:31:57,000
进行形式证明更靠谱

819
00:31:57,000 --> 00:31:59,000
我认为这理论上没错

820
00:31:59,000 --> 00:32:01,000
但对于一个现代工程来说

821
00:32:01,000 --> 00:32:04,000
对项目的正确性进行形式证明几乎是不可能的

822
00:32:05,000 --> 00:32:08,000
因为一个大项目很少从框架都自己搭起

823
00:32:08,000 --> 00:32:11,000
那么就无法保证使用框架的正确性

824
00:32:11,000 --> 00:32:14,000
比如万一 Jango 项本身出了 bug

825
00:32:14,000 --> 00:32:15,000
或者升级后 API 变动

826
00:32:15,000 --> 00:32:17,000
导致程序出错

827
00:32:17,000 --> 00:32:20,000
可能我形式证明过我写的部分是对的

828
00:32:20,000 --> 00:32:23,000
但由于这些基础项目是超出我的能力范围外的

829
00:32:23,000 --> 00:32:26,000
那只能用测试来保证代码的正确性

830
00:32:27,000 --> 00:32:28,000
这怎么说呢

831
00:32:29,000 --> 00:32:30,000
没错

832
00:32:30,000 --> 00:32:31,000
形式证明是一个很好的东西

833
00:32:31,000 --> 00:32:38,000
但是我们通常你不会在非学院学术研究的领域还看到它

834
00:32:39,000 --> 00:32:40,000
不但也有一个有实践的例子

835
00:32:40,000 --> 00:32:45,000
我记得那个 Windows 上不是有个虚拟机的 hypervisor

836
00:32:46,000 --> 00:32:47,000
叫什么来的

837
00:32:48,000 --> 00:32:49,000
名字我忘了

838
00:32:50,000 --> 00:32:51,000
据说

839
00:32:51,000 --> 00:32:55,000
微软研究院是对那个 hypervisor 的代码进行了形式证明的

840
00:32:55,000 --> 00:32:58,000
但至于覆盖度多少我不太清楚

841
00:32:58,000 --> 00:32:59,000
这不还是蛮吃惊

842
00:32:59,000 --> 00:33:01,000
因为那个代码量还是比较大

843
00:33:03,000 --> 00:33:05,000
微软研究院不差人不差钱

844
00:33:05,000 --> 00:33:07,000
对他们有时间

845
00:33:07,000 --> 00:33:09,000
有的是有的是人

846
00:33:09,000 --> 00:33:12,000
有的是时间多少个博士生砸进去

847
00:33:12,000 --> 00:33:13,000
在搞这种事情

848
00:33:14,000 --> 00:33:15,000
但怎么说

849
00:33:15,000 --> 00:33:17,000
我觉得现在事情这样子

850
00:33:17,000 --> 00:33:17,000
就是说

851
00:33:18,000 --> 00:33:21,000
需要形式证明可靠性的东西

852
00:33:21,000 --> 00:33:22,000
可能是要求比较高的

853
00:33:22,000 --> 00:33:27,000
一个是刚才我讲的那个怎么像虚拟机的 hypervisor

854
00:33:27,000 --> 00:33:29,000
另外一些就是之前我们提到的

855
00:33:29,000 --> 00:33:30,000
就是 mission critical 的东西

856
00:33:30,000 --> 00:33:34,000
什么 NASA 的发火箭的代码

857
00:33:34,000 --> 00:33:37,000
什么 Tesla 的控制汽车行驶的代码

858
00:33:37,000 --> 00:33:39,000
对那些是需要经过这个东西来做的

859
00:33:40,000 --> 00:33:43,000
还有一些事情是我们觉得过去觉得可能无关紧要

860
00:33:43,000 --> 00:33:47,000
但是其实是急需要形式证明去证明它是安全可靠的

861
00:33:48,000 --> 00:33:50,000
我们现在互联网底层的一些

862
00:33:51,000 --> 00:33:53,000
包括一些不是互联网底层

863
00:33:53,000 --> 00:33:54,000
就是我们现在计算机硬件底层

864
00:33:54,000 --> 00:33:56,000
一些涉及到安全相关的东西

865
00:33:56,000 --> 00:33:56,000
对吧

866
00:33:57,000 --> 00:33:57,000
前段时间

867
00:33:57,000 --> 00:34:02,000
不就是去年和今年连续爆出来的多个重大的安全漏洞

868
00:34:03,000 --> 00:34:07,000
都是都不是因为测试可以简单的复盖得到的

869
00:34:07,000 --> 00:34:09,000
我觉得不是靠测试可以解决的

870
00:34:10,000 --> 00:34:11,000
没错没错

871
00:34:11,000 --> 00:34:15,000
就你真的是要去证明它每一行代码是经过去推敲的

872
00:34:15,000 --> 00:34:18,000
因为那些 bug 非常隐晦

873
00:34:19,000 --> 00:34:22,000
因为通常的测试你根本想不到会是那么一种方式去出错

874
00:34:23,000 --> 00:34:27,000
所以我觉得看这个东西的重要性

875
00:34:27,000 --> 00:34:29,000
我觉得如果是足够重要的话

876
00:34:29,000 --> 00:34:32,000
还是要通过形式证明的方式来它更好

877
00:34:32,000 --> 00:34:34,000
但是我觉得确实没错

878
00:34:34,000 --> 00:34:36,000
对绝大多数这种商业性的项目来讲

879
00:34:37,000 --> 00:34:40,000
你能给它写测试能都已经不错了

880
00:34:40,000 --> 00:34:41,000
你还要求什么形式证明

881
00:34:41,000 --> 00:34:42,000
这不吃人说梦吗

882
00:34:43,000 --> 00:34:44,000
对

883
00:34:47,000 --> 00:34:50,000
接下来的一篇读出来

884
00:34:50,000 --> 00:34:52,000
刚才你这个还没念完

885
00:34:52,000 --> 00:34:53,000
你要把这个结尾念完

886
00:34:54,000 --> 00:34:54,000
对

887
00:34:55,000 --> 00:34:57,000
然后他在结尾说了一个事情

888
00:34:57,000 --> 00:35:00,000
就是说现在再回过头来看当初的竞赛测试

889
00:35:00,000 --> 00:35:04,000
也许按那个一二三步的流程来能更好的完成比赛

890
00:35:04,000 --> 00:35:06,000
机效程序保证的正确性

891
00:35:06,000 --> 00:35:09,000
数据生成帮助思考编辑条件

892
00:35:10,000 --> 00:35:12,000
最终程序来优化拿高分

893
00:35:12,000 --> 00:35:15,000
总之测试最大的价值可能不在于它本身

894
00:35:16,000 --> 00:35:19,000
而在于它给我们带来的对代码更加深入的理解

895
00:35:20,000 --> 00:35:21,000
这个其实我挺认可的

896
00:35:21,000 --> 00:35:24,000
但我忘了说刚才他讲那个一二三步的步骤

897
00:35:24,000 --> 00:35:25,000
为什么会有这个东西

898
00:35:25,000 --> 00:35:28,000
因为在各种各样的这种什么程序竞赛

899
00:35:28,000 --> 00:35:32,000
ACM 这种比赛他们他这个逻辑一般的是这么给的

900
00:35:32,000 --> 00:35:35,000
他先给你一个所谓的一个题目的描述

901
00:35:35,000 --> 00:35:35,000
让你做一件事

902
00:35:36,000 --> 00:35:37,000
然后他会给你一个 sample

903
00:35:38,000 --> 00:35:40,000
其实就是一个测试的一个样本

904
00:35:40,000 --> 00:35:42,000
然后你要用你的程序去跑这个 sample

905
00:35:42,000 --> 00:35:44,000
看那个大致对不对

906
00:35:44,000 --> 00:35:45,000
你觉得大致对了

907
00:35:45,000 --> 00:35:49,000
你就把你这个程序提交到他们一个平台上面去

908
00:35:49,000 --> 00:35:52,000
平常他用这个东西跑一个更大的一个样本

909
00:35:52,000 --> 00:35:54,000
去看你这个代码是否得到的结果

910
00:35:54,000 --> 00:35:56,000
是不是如预期所料对吧

911
00:35:57,000 --> 00:35:59,000
如果全都正确的话就是 AC

912
00:35:59,000 --> 00:36:02,000
对其实就是有点黑盒的意思

913
00:36:02,000 --> 00:36:05,000
就是他给你一个一小组数据

914
00:36:05,000 --> 00:36:07,000
让你去验证你的程序代码怎么样

915
00:36:07,000 --> 00:36:10,000
所以他在这种用力的场合下

916
00:36:11,000 --> 00:36:15,000
用他那个 123 刚才那个步骤来讲其实还蛮好的

917
00:36:15,000 --> 00:36:17,000
但我不太清楚在实际工程中

918
00:36:18,000 --> 00:36:21,000
有多少人会遵循这么一种方式去做

919
00:36:22,000 --> 00:36:29,000
对我之前在 Coursera 上上了一门课

920
00:36:29,000 --> 00:36:34,000
也是基本上也是以滴滴滴的方式来查你们作业

921
00:36:34,000 --> 00:36:36,000
就是给你一道题

922
00:36:36,000 --> 00:36:39,000
然后让你把程序传上去

923
00:36:39,000 --> 00:36:42,000
他其实本质上就是在后台跑

924
00:36:42,000 --> 00:36:45,000
跑这个大堆 Dock test

925
00:36:45,000 --> 00:36:47,000
就是 Python Dock test

926
00:36:47,000 --> 00:36:49,000
然后最后来告诉你是不是正确

927
00:36:49,000 --> 00:36:52,000
但在实际生产之中

928
00:36:53,000 --> 00:36:56,000
我能想到的基本上就是每天你写完的程序

929
00:36:56,000 --> 00:37:00,000
他会把所有单元测试自动跑一遍

930
00:37:00,000 --> 00:37:03,000
然后告诉你今天写的这些东西

931
00:37:04,000 --> 00:37:05,000
质量怎么样

932
00:37:06,000 --> 00:37:07,000
然后也会告诉你说

933
00:37:10,000 --> 00:37:14,000
比如有个叫 Sona 软件可以告诉你说

934
00:37:14,000 --> 00:37:17,000
你写的代码有多少被测试覆盖到

935
00:37:18,000 --> 00:37:22,000
然后如果你今天写的代码很多

936
00:37:22,000 --> 00:37:23,000
但是覆盖率却降低了的话

937
00:37:23,000 --> 00:37:27,000
那你基本上可以知道你做的东西出来

938
00:37:27,000 --> 00:37:29,000
可能不是特别的可靠

939
00:37:31,000 --> 00:37:33,000
这不觉得其实挺悲剧的吗

940
00:37:33,000 --> 00:37:35,000
我觉得如果你写一段代码

941
00:37:35,000 --> 00:37:40,000
你都不能自己在不经过机器测试的情况下

942
00:37:40,000 --> 00:37:42,000
对自己写出代码的质量有足够的信心

943
00:37:44,000 --> 00:37:48,000
我觉得反正我是不太喜欢这种心态的

944
00:37:48,000 --> 00:37:52,000
至少一切靠测试去给你增加你的自信

945
00:37:53,000 --> 00:37:54,000
我觉得是这样的

946
00:37:54,000 --> 00:37:57,000
这里面有一个信心积累的过程

947
00:37:57,000 --> 00:38:02,000
你那些 AT&T 早期的黑客们肯定也不是用 TD 的

948
00:38:03,000 --> 00:38:08,000
但是你要在一个比较大的公司里面工作

949
00:38:08,000 --> 00:38:10,000
然后你也没有办法保证

950
00:38:10,000 --> 00:38:15,000
你和你的所有的同事们都能够写出来同样高质量的代码

951
00:38:16,000 --> 00:38:20,000
然后你也没有办法保证你的同事

952
00:38:21,000 --> 00:38:23,000
自信满满的写出来代码

953
00:38:23,000 --> 00:38:26,000
就像他希望的那样高质量

954
00:38:26,000 --> 00:38:29,000
在这个情况下

955
00:38:29,000 --> 00:38:32,000
你怎么样来维护一道准诊

956
00:38:33,000 --> 00:38:41,000
其实单元测试覆盖率和单元测试的存在本身

957
00:38:41,000 --> 00:38:44,000
就已经是一种保护一种保障

958
00:38:45,000 --> 00:38:48,000
所以你这么说的潜台资我这么理解

959
00:38:48,000 --> 00:38:53,000
就是说这是一个保障若干平庸的程序

960
00:38:53,000 --> 00:38:58,000
你还能够写出质量还凑合过得去的一个管理手段

961
00:39:00,000 --> 00:39:02,000
我觉得 TD 在很大程度上

962
00:39:02,000 --> 00:39:03,000
就像我说的很印度

963
00:39:03,000 --> 00:39:04,000
其实就是这意思

964
00:39:06,000 --> 00:39:11,000
它是人类转件工程的规模逐渐大起来

965
00:39:11,000 --> 00:39:15,000
所不得不采用的一种相关的手段

966
00:39:16,000 --> 00:39:25,000
对其实没有太值得去去吃他的事情

967
00:39:25,000 --> 00:39:29,000
因为你没有更好的方法

968
00:39:29,000 --> 00:39:34,000
不然你找一个怎么样的方法来判断一个代码是不是好

969
00:39:35,000 --> 00:39:35,000
没错

970
00:39:37,000 --> 00:39:39,000
但其实这里还可以扯到一个

971
00:39:39,000 --> 00:39:43,000
就是我们上期节目里面没有提到的测试覆盖率这个指标

972
00:39:44,000 --> 00:39:46,000
你觉得理想的测试覆盖率是多少

973
00:39:46,000 --> 00:39:49,000
其实一个比较幼稚的答案就是 100%覆盖

974
00:39:50,000 --> 00:39:51,000
其实非常难的

975
00:39:51,000 --> 00:39:56,000
而且如果真的要写到 100%测试的测试覆盖率的话

976
00:39:58,000 --> 00:40:02,000
可能时间成本是非常精致的

977
00:40:02,000 --> 00:40:03,000
对

978
00:40:03,000 --> 00:40:06,000
而且有一些东西是不能没有办法测试

979
00:40:06,000 --> 00:40:08,000
比如说 CSS 你要怎么测试

980
00:40:09,000 --> 00:40:15,000
所以一个比较理想的测试覆盖率其实是在 50%左右

981
00:40:15,000 --> 00:40:18,000
然后如果你能达到 85%的话

982
00:40:18,000 --> 00:40:21,000
基本上就是极端高质量的代码

983
00:40:23,000 --> 00:40:23,000
等等

984
00:40:24,000 --> 00:40:26,000
代码的质量为什么会和测试覆盖率手上关系

985
00:40:27,000 --> 00:40:29,000
就是极端可靠的代码

986
00:40:29,000 --> 00:40:31,000
哦说这个意思明白

987
00:40:31,000 --> 00:40:31,000
对

988
00:40:31,000 --> 00:40:32,000
不是高质量

989
00:40:32,000 --> 00:40:33,000
不一定高质量

990
00:40:33,000 --> 00:40:34,000
但至少是可靠

991
00:40:34,000 --> 00:40:35,000
嗯哼

992
00:40:35,000 --> 00:40:36,000
好吧

993
00:40:36,000 --> 00:40:38,000
我们接着进入到下一封读感感信息

994
00:40:39,000 --> 00:40:41,000
这位朋友名字叫张昊中

995
00:40:41,000 --> 00:40:42,000
应该是

996
00:40:43,000 --> 00:40:43,000
嗨

997
00:40:43,000 --> 00:40:44,000
吴涛和瑞尔

998
00:40:44,000 --> 00:40:47,000
我非常喜欢你们主持的 Podcast 节目内核恐慌

999
00:40:47,000 --> 00:40:51,000
献与一个理工科学生语文有限的表达能力

1000
00:40:51,000 --> 00:40:53,000
此处省略一美之词一万次

1001
00:40:55,000 --> 00:40:56,000
非常感谢你

1002
00:40:57,000 --> 00:40:58,000
这压缩率好高啊

1003
00:40:58,000 --> 00:40:59,000
对

1004
00:41:02,000 --> 00:41:04,000
比金军煤的压缩率还高

1005
00:41:05,000 --> 00:41:05,000
嗯哼

1006
00:41:06,000 --> 00:41:10,000
作为一个研究方向为 formal verification 的老博士

1007
00:41:10,000 --> 00:41:12,000
我想评论一下第十九期之中

1008
00:41:12,000 --> 00:41:14,000
关于 formal verification 的部分内容

1009
00:41:15,000 --> 00:41:16,000
终于来了专业人士

1010
00:41:16,000 --> 00:41:17,000
我好激动

1011
00:41:17,000 --> 00:41:18,000
呵呵

1012
00:41:18,000 --> 00:41:19,000
首先

1013
00:41:19,000 --> 00:41:20,000
如两位主播所言

1014
00:41:20,000 --> 00:41:25,000
formal verification 的中文翻译通常为形式化验证

1015
00:41:25,000 --> 00:41:28,000
这里已经讨论对软件的 formal verification

1016
00:41:29,000 --> 00:41:31,000
其实 formal verification 和测试

1017
00:41:32,000 --> 00:41:34,000
都在试图解决相同的问题

1018
00:41:34,000 --> 00:41:38,000
也就是给定人们对一个程序的行为的预期

1019
00:41:38,000 --> 00:41:41,000
例如给什么样的输出有什么样的输入

1020
00:41:42,000 --> 00:41:44,000
啊给什么样的输出有什么样输出

1021
00:41:45,000 --> 00:41:46,000
Wait a second

1022
00:41:46,000 --> 00:41:49,000
给什么样的输入有什么样的输出

1023
00:41:50,000 --> 00:41:51,000
运行的时间效率

1024
00:41:51,000 --> 00:41:53,000
甚至程序的功耗等等

1025
00:41:54,000 --> 00:41:54,000
呃

1026
00:41:54,000 --> 00:41:56,000
以及这个程序本身

1027
00:41:56,000 --> 00:41:58,000
构建一个 witness

1028
00:41:58,000 --> 00:42:01,000
以表明这个程序的确能够

1029
00:42:01,000 --> 00:42:02,000
的确能够提供预期的行为

1030
00:42:03,000 --> 00:42:05,000
通常我们称这些预期行为

1031
00:42:05,000 --> 00:42:06,000
为程序的规范

1032
00:42:06,000 --> 00:42:08,000
也就是 specification

1033
00:42:09,000 --> 00:42:11,000
而称这个程序本身

1034
00:42:11,000 --> 00:42:13,000
为这个 specification 的一个实现

1035
00:42:13,000 --> 00:42:15,000
那就是 implementation

1036
00:42:16,000 --> 00:42:18,000
formal verification 和测试

1037
00:42:18,000 --> 00:42:22,000
使用不同的手段来试图构造这样一个 witness

1038
00:42:22,000 --> 00:42:24,000
对于 formal verification 来说

1039
00:42:24,000 --> 00:42:26,000
它使用数学和逻辑语言

1040
00:42:26,000 --> 00:42:29,000
表示 specification 和 implementation

1041
00:42:29,000 --> 00:42:33,000
并通过数学和逻辑严格证明 implementation

1042
00:42:33,000 --> 00:42:35,000
在任何可能的情况下

1043
00:42:35,000 --> 00:42:39,000
都能够满足 specification

1044
00:42:40,000 --> 00:42:42,000
而对于测试在很多情况之下

1045
00:42:43,000 --> 00:42:47,000
specification 使用和 implementation 一样的语言表达

1046
00:42:47,000 --> 00:42:49,000
也就是一个一个的测试用力

1047
00:42:50,000 --> 00:42:54,000
测试保证如果一个测试用力被执行到

1048
00:42:54,000 --> 00:42:57,000
那么可以通过这个测试用力的执行结果

1049
00:42:57,000 --> 00:43:00,000
来检查 implementation 的证据与否

1050
00:43:00,000 --> 00:43:03,000
但是如果一个测试用力没有被执行到

1051
00:43:03,000 --> 00:43:07,000
或者测试用力没有覆盖到程序的所有可能执行路径

1052
00:43:08,000 --> 00:43:09,000
那么测试就无能为力

1053
00:43:10,000 --> 00:43:14,000
似乎这样看来 formal verification 可以提供比测试

1054
00:43:14,000 --> 00:43:18,000
更严格和有效的对于程序正确性的保证

1055
00:43:19,000 --> 00:43:21,000
理应在工业界得到更为广泛的应用

1056
00:43:22,000 --> 00:43:26,000
但是目前而言 formal verification 的性价比太低

1057
00:43:26,000 --> 00:43:29,000
并且对于使用者的要求也太高了

1058
00:43:30,000 --> 00:43:32,000
一方面平均验证一行员程序

1059
00:43:33,000 --> 00:43:37,000
大概需要几百行甚至更多的形式化证明代码

1060
00:43:37,000 --> 00:43:42,000
口号是的我们有专门用于形式化证明的程序语言

1061
00:43:43,000 --> 00:43:43,000
口号结束

1062
00:43:44,000 --> 00:43:46,000
而且在很多情况之下

1063
00:43:46,000 --> 00:43:48,000
这些证明没有办法自动生成

1064
00:43:48,000 --> 00:43:51,000
并且要耗费大量的时间去创造

1065
00:43:52,000 --> 00:43:56,000
另一方面对于能够进行 formal verification 的人

1066
00:43:57,000 --> 00:44:01,000
他即要对验证的对象有着深刻的理解

1067
00:44:02,000 --> 00:44:06,000
比如我为了验证一个 hypervisor 中很小的一部分功能

1068
00:44:06,000 --> 00:44:11,000
从零开始写了一个能够实际工作在 X 86 机器上的

1069
00:44:11,000 --> 00:44:15,000
可以同时运行多个 Linux 虚拟机的实验性的 hypervisor

1070
00:44:15,000 --> 00:44:16,000
口号完毕

1071
00:44:17,000 --> 00:44:23,000
又要有足够和复杂的数学与逻辑学知识

1072
00:44:23,000 --> 00:44:28,000
各种抽象代数、数理逻辑、集合论、范畴论什么的

1073
00:44:28,000 --> 00:44:29,000
口号结束

1074
00:44:30,000 --> 00:44:30,000
相对而言

1075
00:44:30,000 --> 00:44:35,000
目前的测试则可以在相对可控的成本值下提供不完美

1076
00:44:35,000 --> 00:44:39,000
但是在多数情况下足够好和易于实现的解决方案

1077
00:44:40,000 --> 00:44:41,000
其次

1078
00:44:41,000 --> 00:44:43,000
我要吐槽一下节目中所说到的

1079
00:44:44,000 --> 00:44:49,000
对于非确定性的程序很难验证只好测试的观念

1080
00:44:50,000 --> 00:44:51,000
这好像是我说的吧

1081
00:44:51,000 --> 00:44:52,000
恰恰相反

1082
00:44:52,000 --> 00:44:54,000
对于非确定性程序

1083
00:44:54,000 --> 00:44:58,000
特别是并化程序和操作系统内核之中涉及中断的代码

1084
00:44:59,000 --> 00:45:04,000
formal verification 可以非常简洁和严格的表达并证明它们的正确性

1085
00:45:04,000 --> 00:45:07,000
而测试此时更多是向来碰运气

1086
00:45:08,000 --> 00:45:11,000
以操作系统内核中可以被中断的代码片段为例

1087
00:45:12,000 --> 00:45:16,000
在这个代码片段的每一条指令的执行可能被中断打断

1088
00:45:17,000 --> 00:45:20,000
也就是说每一条指令的执行有可能有被中断打断

1089
00:45:20,000 --> 00:45:22,000
所以每一条指令的执行有可能有二条路径

1090
00:45:22,000 --> 00:45:31,000
所以一个包含 N 条指令的代码段可能有 R rest power of N 个执行路径

1091
00:45:31,000 --> 00:45:35,000
因为在实际的机器上中断的发生是不确定的

1092
00:45:36,000 --> 00:45:41,000
所以测试很难保证在短时间内能够覆盖到所有的执行路径

1093
00:45:42,000 --> 00:45:46,000
相对的在 formal verification 之中举个例子

1094
00:45:46,000 --> 00:45:50,000
我们可以把每条指令的执行化形式表示成

1095
00:45:52,000 --> 00:45:53,000
这应该怎么念

1096
00:45:54,000 --> 00:45:55,000
你真的要念

1097
00:45:56,000 --> 00:45:58,000
PCQ

1098
00:45:58,000 --> 00:46:00,000
其中 C 是这条指令

1099
00:46:00,000 --> 00:46:03,000
P 称为前条件也就是 precondition

1100
00:46:03,000 --> 00:46:07,000
它描述了 C 执行之前机器的状态

1101
00:46:08,000 --> 00:46:10,000
例如某个计存器的值是什么

1102
00:46:10,000 --> 00:46:12,000
某个内存单元的值是什么

1103
00:46:12,000 --> 00:46:15,000
通常不需要覆盖所有的计存器和内存单元

1104
00:46:16,000 --> 00:46:22,000
仅需要根据验证的 specification 选取我们关心的部分

1105
00:46:23,000 --> 00:46:25,000
Q 称为后条件也就是 postcondition

1106
00:46:26,000 --> 00:46:29,000
它描述了 C 执行之后的机器状态

1107
00:46:29,000 --> 00:46:37,000
注意这里的 Q 同时描述了 C 被中断和不被中断的执行之后的机器状态

1108
00:46:38,000 --> 00:46:46,000
非形式化的 PCQ 表示在满足前条件 P 的机器上执行 C 之后

1109
00:46:47,000 --> 00:46:49,000
得到的机器状态满足后条件 Q

1110
00:46:50,000 --> 00:46:54,000
这样一来对于上述的一个态表辨论 C 1 C 2

1111
00:46:54,000 --> 00:47:01,000
一直到 Cn 我们有 P 下标 1 C 下标 1 Q 下标 1

1112
00:47:01,000 --> 00:47:04,000
P 下标 2 C 下标 2 Q 下标 2

1113
00:47:04,000 --> 00:47:08,000
一直到 P 下标 nC 下标 nQ 下标 n

1114
00:47:08,000 --> 00:47:10,000
然后我们可以证明 Q 下标 1

1115
00:47:11,000 --> 00:47:13,000
这应该怎么念呢

1116
00:47:13,000 --> 00:47:15,000
推导出

1117
00:47:17,000 --> 00:47:18,000
implies

1118
00:47:19,000 --> 00:47:20,000
应该是 implies

1119
00:47:20,000 --> 00:47:24,000
然后我们可以证明出如果有 Q 1 那么一定有 P 2

1120
00:47:24,000 --> 00:47:34,000
不对这个是然后我们可以证明 Q 下标 1 可以推导出 P 下标 2

1121
00:47:34,000 --> 00:47:39,000
一直到 Q 下标 n-1 可以推导出 P 下标 n

1122
00:47:40,000 --> 00:47:45,000
从而可以证明 P 1 P 下标 1 C 下标 1 C 下标 2

1123
00:47:46,000 --> 00:47:49,000
一直到 C 下标 nQ 下标 n

1124
00:47:50,000 --> 00:47:57,000
同样的如果在这个代码片段的 specification 可以写成例如 PC 下标 1 C 下标 2

1125
00:47:59,000 --> 00:48:03,000
一直到 C 下标 nQ 我们只需要再证明 P

1126
00:48:04,000 --> 00:48:08,000
可以推导出 P 下标 1 和 Q 下标 n 可以推导出 Q

1127
00:48:09,000 --> 00:48:15,000
也就是也就可以证明这个代码片段的确满足了给定的 specification

1128
00:48:16,000 --> 00:48:21,000
因为这里的 P Q P 下标 i Q 下标 i 等等描述了所有的可能状况

1129
00:48:21,000 --> 00:48:24,000
并且只需要描述 specification 关心的部分

1130
00:48:25,000 --> 00:48:28,000
所以这里的 formalification 比测试更加完备和简洁

1131
00:48:28,000 --> 00:48:33,000
在实际工作中我们往往会针对验证的所有程序的特点

1132
00:48:33,000 --> 00:48:38,000
设定特定的逻辑系统以进一步降低证明的难度和复杂度

1133
00:48:39,000 --> 00:48:44,000
我在读这段文章的时候大概明白他在说什么

1134
00:48:44,000 --> 00:48:47,000
但是我念出来之后发现自己根本不明白他在说什么

1135
00:48:48,000 --> 00:48:49,000
其实很简单

1136
00:48:49,000 --> 00:48:52,000
刚才那一段话你听众肯定是没听明白的

1137
00:48:52,000 --> 00:48:54,000
你也没有看见那个东西

1138
00:48:54,000 --> 00:48:58,000
我觉得这一段还是把他 poll 出来比较好

1139
00:48:59,000 --> 00:49:02,000
其实那句话其实有个比较直白的解释

1140
00:49:02,000 --> 00:49:04,000
就是说你有一串代码

1141
00:49:04,000 --> 00:49:09,000
每一步都会有一个所谓的前条件

1142
00:49:09,000 --> 00:49:10,000
就是所谓前因后果

1143
00:49:10,000 --> 00:49:14,000
你执行在这一个步骤之前是一个什么样的状况

1144
00:49:14,000 --> 00:49:16,000
执行之后你预期它是什么样的一个状况

1145
00:49:16,000 --> 00:49:20,000
然后如果你能够把前面一条代码的结果

1146
00:49:20,000 --> 00:49:21,000
推到那个状况

1147
00:49:21,000 --> 00:49:27,000
推到后面一个一行代码的这个叫做前因

1148
00:49:27,000 --> 00:49:29,000
你能把东西连续地串起来

1149
00:49:29,000 --> 00:49:33,000
你只能证明这个东西整个代码片段的可靠性

1150
00:49:33,000 --> 00:49:34,000
你把它的东西

1151
00:49:34,000 --> 00:49:40,000
这个是我上学的时候不停写作业要做的一部分

1152
00:49:40,000 --> 00:49:42,000
现在看来真是好痛苦

1153
00:49:42,000 --> 00:49:43,000
OK

1154
00:49:43,000 --> 00:49:44,000
所以其实它就是一个状态机

1155
00:49:44,000 --> 00:49:48,000
然后如果你能证明这个状态机的每一步都是可以

1156
00:49:48,000 --> 00:49:53,000
达到的或者说每一步状态机的每一个状态都是彼此相连的

1157
00:49:53,000 --> 00:49:56,000
整个状态机的可靠性就是可以被验证

1158
00:49:56,000 --> 00:49:56,000
大概是这个意思

1159
00:49:56,000 --> 00:49:58,000
有点那个意思

1160
00:49:58,000 --> 00:50:00,000
OK

1161
00:50:00,000 --> 00:50:01,000
我没有学过这种东西

1162
00:50:01,000 --> 00:50:04,000
我们通讯就是不学这种让人头大

1163
00:50:04,000 --> 00:50:09,000
其实它不算难

1164
00:50:09,000 --> 00:50:11,000
但是非常繁琐

1165
00:50:11,000 --> 00:50:13,000
感觉像解九连环

1166
00:50:13,000 --> 00:50:16,000
你要给出下面一步

1167
00:50:16,000 --> 00:50:18,000
你必须要达到前面那一步

1168
00:50:18,000 --> 00:50:18,000
对

1169
00:50:18,000 --> 00:50:20,000
你要一步一步去弄那个东西

1170
00:50:20,000 --> 00:50:22,000
其实所以为什么讲

1171
00:50:22,000 --> 00:50:24,000
要我专门的这个这个程序

1172
00:50:24,000 --> 00:50:30,000
那个那种语言去基于各种各样的 Logic 的方法去去证明

1173
00:50:30,000 --> 00:50:34,000
那个东西就是想把这个繁琐的东西机械化

1174
00:50:34,000 --> 00:50:35,000
让机械去做

1175
00:50:35,000 --> 00:50:38,000
我们人只用把那个 Specification 给好就可以了

1176
00:50:38,000 --> 00:50:44,000
但是其实你在真正在做的时候就正如那个叫什么张博士所言

1177
00:50:44,000 --> 00:50:47,000
你为了验证一行代码的这个可靠性

1178
00:50:47,000 --> 00:50:51,000
然后去证明它是否符合这个某个 Spec

1179
00:50:51,000 --> 00:50:53,000
你可能要再写好多好多遍的代码

1180
00:50:55,000 --> 00:50:55,000
对

1181
00:50:55,000 --> 00:50:56,000
没错

1182
00:50:57,000 --> 00:50:58,000
接着念这封信

1183
00:50:58,000 --> 00:51:03,000
另一个体现 Formerification 比测试强大的地方是对于各种 Logless

1184
00:51:03,000 --> 00:51:06,000
Augurism 的实现的正确性的验证

1185
00:51:06,000 --> 00:51:10,000
也就是无所的算法的实现的正确性验证

1186
00:51:10,000 --> 00:51:13,000
这是一个非常大和复杂的话题

1187
00:51:13,000 --> 00:51:14,000
这里就不展开了

1188
00:51:14,000 --> 00:51:19,000
另外学术界一直以来都试图将 Formerification 的应用

1189
00:51:19,000 --> 00:51:22,000
应用到实际的软件开发之中

1190
00:51:22,000 --> 00:51:25,000
目前两个最为瞩目的结果是 Cell 4

1191
00:51:27,000 --> 00:51:32,000
它是对一个 VNA 和操作系统的完整的形式化验证

1192
00:51:32,000 --> 00:51:34,000
它的网址都很酷

1193
00:51:34,000 --> 00:51:42,000
叫做 htps//Cell 4.systems

1194
00:51:45,000 --> 00:51:47,000
所以.systems 是一个顶级域名吗

1195
00:51:48,000 --> 00:51:49,000
你不知道吗

1196
00:51:49,000 --> 00:51:50,000
现在有一批各种各样

1197
00:51:50,000 --> 00:51:52,000
其实怪怪的新的顶级语冒出来

1198
00:51:52,000 --> 00:51:54,000
对我知道 XXX

1199
00:51:54,000 --> 00:51:56,000
但是好像没有听说过 Systems

1200
00:51:56,000 --> 00:51:58,000
有 Dora 有.systems

1201
00:51:58,000 --> 00:51:58,000
还有各种

1202
00:51:58,000 --> 00:52:00,000
好像有.beer

1203
00:52:02,000 --> 00:52:03,000
你可以注册一个

1204
00:52:04,000 --> 00:52:06,000
然后还有一个叫做 Compcert

1205
00:52:07,000 --> 00:52:13,000
是法国 Irea 实现的一个验证过的 C 语言编辑器

1206
00:52:14,000 --> 00:52:16,000
曾经用在 Airbus

1207
00:52:16,000 --> 00:52:18,000
空客的记载软件的开发之中

1208
00:52:18,000 --> 00:52:20,000
这个很屌真的很牛

1209
00:52:20,000 --> 00:52:24,000
网址是 htp.slash.compsert

1210
00:52:24,000 --> 00:52:31,000
compcert.inria.fr

1211
00:52:31,000 --> 00:52:36,000
最后既然节目中提到的 TDD 和 BDD

1212
00:52:36,000 --> 00:52:39,000
那我就不得不提到 Formerification 之中

1213
00:52:39,000 --> 00:52:43,000
对应的叫做 Program Synthesis 的东西

1214
00:52:44,000 --> 00:52:46,000
程序合成的东西

1215
00:52:46,000 --> 00:52:50,000
简单来说就是软件开发要先写 Specification

1216
00:52:50,000 --> 00:52:53,000
和程序满足 Specification 的数学证明

1217
00:52:53,000 --> 00:52:57,000
然后从这些证明自动生成满足 Specification 的程序

1218
00:52:58,000 --> 00:53:00,000
前面提到的 Compcert

1219
00:53:00,000 --> 00:53:02,000
主要就是用这种方法开发出来的

1220
00:53:02,000 --> 00:53:03,000
简单来说

1221
00:53:03,000 --> 00:53:07,000
这个东西基于这样一个已经被证明的数学理论基础

1222
00:53:08,000 --> 00:53:10,000
计算和证明是等价的

1223
00:53:11,000 --> 00:53:13,000
当然这么牛逼闪闪的东西

1224
00:53:13,000 --> 00:53:17,000
目前还有大量的理论和工程方面的问题需要解决

1225
00:53:17,000 --> 00:53:21,000
所以广大程序员在有生之年无需失业

1226
00:53:21,000 --> 00:53:24,000
而我在有生之年也不太靠这个东西发家是富

1227
00:53:24,000 --> 00:53:26,000
大概就是这些

1228
00:53:27,000 --> 00:53:29,000
刚才读到这些

1229
00:53:29,000 --> 00:53:32,000
就读到这一部分的时候我心里一领

1230
00:53:32,000 --> 00:53:34,000
想说我靠

1231
00:53:34,000 --> 00:53:37,000
要是被这帮 Freak 们搞出来

1232
00:53:37,000 --> 00:53:42,000
我们这些跟自己的吃程序饭的人该怎么办

1233
00:53:42,000 --> 00:53:45,000
结果他说有生之年无需担心失业

1234
00:53:45,000 --> 00:53:47,000
我心里的一颗大石头就放了

1235
00:53:48,000 --> 00:53:48,000
对

1236
00:53:48,000 --> 00:53:54,000
因为现在你说什么狼鳞的工种被各种各样的机械化

1237
00:53:54,000 --> 00:53:56,000
自动化的东西弃带掉了

1238
00:53:56,000 --> 00:53:57,000
是吧

1239
00:53:57,000 --> 00:54:00,000
反正我觉得师傅在我们挂掉之前

1240
00:54:00,000 --> 00:54:03,000
还不用担心程序员的工种被自动化掉

1241
00:54:04,000 --> 00:54:09,000
但是他提到这件事就是计算和证明是等价的

1242
00:54:09,000 --> 00:54:15,000
所以一切可计算的东西都是可以证明

1243
00:54:15,000 --> 00:54:20,000
这不是跟是否等于 NP 那个东西是一个原理吗

1244
00:54:20,000 --> 00:54:22,000
还有数

1245
00:54:22,000 --> 00:54:23,000
对

1246
00:54:23,000 --> 00:54:24,000
对吧

1247
00:54:24,000 --> 00:54:26,000
P 和 NP 是验证和可计算

1248
00:54:26,000 --> 00:54:29,000
这样我想到一件事情

1249
00:54:29,000 --> 00:54:32,000
我们在前面幕僚那一期的时候提到

1250
00:54:32,000 --> 00:54:36,000
如果计算机能够做数学题的话

1251
00:54:36,000 --> 00:54:38,000
它能不能证明数学题呢

1252
00:54:38,000 --> 00:54:42,000
我记得当时在 MLblog 里面提到

1253
00:54:42,000 --> 00:54:46,000
如果一台计算机可以证明一件东西的话

1254
00:54:46,000 --> 00:54:49,000
那将会是非常了不起的一件事

1255
00:54:49,000 --> 00:54:52,000
但是很遗憾的就是

1256
00:54:52,000 --> 00:54:54,000
我们人类都有时候不太清楚

1257
00:54:54,000 --> 00:54:57,000
自己证明一个东西到底是怎样的一个过程

1258
00:54:57,000 --> 00:55:04,000
我觉得如果脑洞大致上有了这个

1259
00:55:04,000 --> 00:55:07,000
你告诉计算机说我要一个什么样的程序

1260
00:55:07,000 --> 00:55:12,000
就是给出这样一个程序的 specification

1261
00:55:12,000 --> 00:55:17,000
你还是要用自己的脑力来证明这个 specification

1262
00:55:17,000 --> 00:55:20,000
是合以为算出来的

1263
00:55:20,000 --> 00:55:23,000
这个过程终究还是不能用计算机来体验

1264
00:55:23,000 --> 00:55:26,000
所以也许将来的程序员们

1265
00:55:26,000 --> 00:55:27,000
不一定需要自己去写程序

1266
00:55:27,000 --> 00:55:30,000
但他们仍旧需要自己去想出来

1267
00:55:30,000 --> 00:55:33,000
这个程序为什么可以被写出来

1268
00:55:33,000 --> 00:55:36,000
感觉又难了一些了

1269
00:55:36,000 --> 00:55:38,000
生活又艰辛了一点点

1270
00:55:38,000 --> 00:55:40,000
对将来就不是

1271
00:55:40,000 --> 00:55:45,000
将来写程序这个职业就不再是一个

1272
00:55:45,000 --> 00:55:49,000
仅仅受过中学教育和一定培训的人

1273
00:55:49,000 --> 00:55:50,000
就可以胜任的工作了

1274
00:55:50,000 --> 00:55:51,000
不像现在

1275
00:55:51,000 --> 00:55:53,000
你的意思是说蓝翔要关门了

1276
00:55:56,000 --> 00:55:57,000
其实我觉得是一件好事

1277
00:55:57,000 --> 00:56:02,000
就是现在你看我这样的人都可以来转行写程序

1278
00:56:04,000 --> 00:56:06,000
这有自黑的条件

1279
00:56:06,000 --> 00:56:07,000
对

1280
00:56:07,000 --> 00:56:12,000
Summer 让程序的光环变得没有那么盛捷了

1281
00:56:12,000 --> 00:56:13,000
是不是

1282
00:56:13,000 --> 00:56:13,000
对

1283
00:56:13,000 --> 00:56:15,000
是一个邪恶光环

1284
00:56:15,000 --> 00:56:23,000
接下来是一个非常重头的反馈

1285
00:56:23,000 --> 00:56:27,000
这位听众朋友不但写了一封很长的信

1286
00:56:27,000 --> 00:56:32,000
最后还录了一个将近一个小时的视频

1287
00:56:32,000 --> 00:56:34,000
来向我们展示这个 TVD

1288
00:56:36,000 --> 00:56:37,000
怎么办

1289
00:56:37,000 --> 00:56:38,000
来吧我来吧

1290
00:56:38,000 --> 00:56:40,000
嗨

1291
00:56:40,000 --> 00:56:41,000
无头好尤

1292
00:56:41,000 --> 00:56:44,000
首先非常喜欢听你们的节目

1293
00:56:44,000 --> 00:56:45,000
已经从头追了一遍

1294
00:56:45,000 --> 00:56:48,000
受益匪浅也试着反馈一次

1295
00:56:48,000 --> 00:56:55,000
作为一个已经被成功安利的 TDD 和 Pair Programming

1296
00:56:55,000 --> 00:56:55,000
这叫什么

1297
00:56:55,000 --> 00:56:57,000
结对编程是吧

1298
00:56:57,000 --> 00:56:58,000
对

1299
00:56:58,000 --> 00:57:00,000
两个人一块剪刀

1300
00:57:00,000 --> 00:57:00,000
对

1301
00:57:00,000 --> 00:57:01,000
这剑心者

1302
00:57:01,000 --> 00:57:02,000
那个剑

1303
00:57:02,000 --> 00:57:08,000
最近四年的代码几乎都是被测试驱动出来的

1304
00:57:08,000 --> 00:57:10,000
可见中毒之声

1305
00:57:10,000 --> 00:57:13,000
我想反馈一些我自己的体会

1306
00:57:13,000 --> 00:57:15,000
我个人理解单元测试有两种作用

1307
00:57:15,000 --> 00:57:16,000
一个是保障作用

1308
00:57:16,000 --> 00:57:20,000
保障代码还是在按预期交付业务价值

1309
00:57:20,000 --> 00:57:21,000
这个就不提

1310
00:57:21,000 --> 00:57:22,000
另外一个是驱动作用

1311
00:57:22,000 --> 00:57:24,000
就是 TDD 中间那个 Driven

1312
00:57:24,000 --> 00:57:26,000
大家谈论 TDD 的时候

1313
00:57:26,000 --> 00:57:30,000
经常忽略的也就是这个 Driven 而关注在 Test 的时候

1314
00:57:30,000 --> 00:57:32,000
当 Test 起 Driven 作用的时候

1315
00:57:32,000 --> 00:57:34,000
一旦 Driven 作用完成

1316
00:57:34,000 --> 00:57:38,000
也就是实现被 Driven 出来后

1317
00:57:38,000 --> 00:57:41,000
理论就可以被删除

1318
00:57:41,000 --> 00:57:43,000
这叫怎么没读通算

1319
00:57:44,000 --> 00:57:47,000
他意思就是当 Test 起 Driven 作用的时候

1320
00:57:47,000 --> 00:57:53,000
也就是说这个 Test 在驱使你写 Test 的时候

1321
00:57:53,000 --> 00:57:57,000
它只是一个动力

1322
00:57:57,000 --> 00:57:59,000
或者说它只是一个刺激源

1323
00:57:59,000 --> 00:58:02,000
它刺激你说我把这些 Test 都满足了

1324
00:58:02,000 --> 00:58:04,000
然后我的代码也就写出来了

1325
00:58:04,000 --> 00:58:05,000
OK

1326
00:58:05,000 --> 00:58:06,000
这么理解

1327
00:58:07,000 --> 00:58:08,000
但写都写了

1328
00:58:08,000 --> 00:58:09,000
稍微休息一下

1329
00:58:09,000 --> 00:58:12,000
你就可以留着继续发挥余热

1330
00:58:12,000 --> 00:58:15,000
转化为可以起到保障作用的单元测试

1331
00:58:15,000 --> 00:58:16,000
何乐而不为呢

1332
00:58:16,000 --> 00:58:17,000
追问的作用

1333
00:58:17,000 --> 00:58:19,000
我再查一句

1334
00:58:19,000 --> 00:58:21,000
他意思就是你要修一栋楼

1335
00:58:21,000 --> 00:58:24,000
你修个脚手架

1336
00:58:24,000 --> 00:58:26,000
然后再盖这个楼

1337
00:58:26,000 --> 00:58:28,000
理论上楼盖好了之后

1338
00:58:28,000 --> 00:58:29,000
脚手架就应该拆除了

1339
00:58:29,000 --> 00:58:31,000
但是在软件的世界里面

1340
00:58:31,000 --> 00:58:34,000
做这样的比喻实际上是不恰当的

1341
00:58:34,000 --> 00:58:36,000
在软件的世界里面

1342
00:58:36,000 --> 00:58:39,000
这个楼可能是要继续生长和变化的

1343
00:58:39,000 --> 00:58:42,000
此时如果你一开始搭了脚手架

1344
00:58:42,000 --> 00:58:44,000
那你搭可以留着脚手架

1345
00:58:44,000 --> 00:58:47,000
如果这个变化是在预期之外的话

1346
00:58:47,000 --> 00:58:50,000
这个脚手架可能就会被撞倒

1347
00:58:50,000 --> 00:58:53,000
然后你就知道这个东西已经在你的

1348
00:58:53,000 --> 00:58:57,000
这一部分的更改已经变更了

1349
00:58:57,000 --> 00:58:59,000
你一开始对于这个建筑的预期

1350
00:58:59,000 --> 00:59:00,000
大概是这样一个

1351
00:59:00,000 --> 00:59:02,000
我能想到一个比较合适的比喻

1352
00:59:02,000 --> 00:59:09,000
接着说追问的作用是如何被体现的

1353
00:59:09,000 --> 00:59:11,000
我们习惯的开发思路

1354
00:59:11,000 --> 00:59:13,000
可以理解是自上而下的

1355
00:59:13,000 --> 00:59:14,000
top-down approach

1356
00:59:14,000 --> 00:59:16,000
就碰到一个问题或需求

1357
00:59:16,000 --> 00:59:20,000
先做完备的设计再来实现

1358
00:59:20,000 --> 00:59:22,000
而 TDD 所体现的

1359
00:59:22,000 --> 00:59:25,000
只是一个相反的自下而上的模式

1360
00:59:25,000 --> 00:59:27,000
就是说程序的设计和算法

1361
00:59:27,000 --> 00:59:30,000
不是说在你开始写之前

1362
00:59:30,000 --> 00:59:32,000
就要想清楚的所有细节

1363
00:59:32,000 --> 00:59:35,000
而是可以基于对目标的任务进行分解

1364
00:59:35,000 --> 00:59:38,000
以及实现的逐步演进

1365
00:59:38,000 --> 00:59:42,000
并通过每次红绿 cycle 后的重构被驱动出来

1366
00:59:42,000 --> 00:59:44,000
好多数语

1367
00:59:44,000 --> 00:59:47,000
红绿 cycle 就是一开始没通过

1368
00:59:47,000 --> 00:59:49,000
然后你写好了它通过

1369
00:59:49,000 --> 00:59:50,000
老是挂各种测试

1370
00:59:50,000 --> 00:59:53,000
然后绿了一下又红了

1371
00:59:53,000 --> 00:59:55,000
接着改又绿了

1372
00:59:55,000 --> 00:59:58,000
好处恰恰就是 real 所吐槽的那种

1373
00:59:58,000 --> 01:00:00,000
外包公司所能达到的

1374
01:00:00,000 --> 01:00:02,000
刚刚好满足需求的实现

1375
01:00:02,000 --> 01:00:06,000
不过我觉得在满足所有业务需求的前提下

1376
01:00:06,000 --> 01:00:09,000
刚刚好不一定就是坏事

1377
01:00:09,000 --> 01:00:12,000
正好契合当今精益的思想

1378
01:00:12,000 --> 01:00:13,000
这个我不反对

1379
01:00:13,000 --> 01:00:15,000
我觉得这确实是很好的

1380
01:00:15,000 --> 01:00:17,000
前提是有重构的保证

1381
01:00:17,000 --> 01:00:19,000
这种刚刚好的实现

1382
01:00:19,000 --> 01:00:23,000
也是已经消除了识别出的 bad smell

1383
01:00:23,000 --> 01:00:25,000
就是坏味道

1384
01:00:25,000 --> 01:00:26,000
对坏味道

1385
01:00:26,000 --> 01:00:29,000
例如代码重复各种 switch

1386
01:00:29,000 --> 01:00:31,000
还有非常长的方法或者函数的

1387
01:00:32,000 --> 01:00:36,000
比较干净的实现

1388
01:00:36,000 --> 01:00:38,000
我靠这怎么念

1389
01:00:39,000 --> 01:00:40,000
这种刚刚好的实现

1390
01:00:40,000 --> 01:00:43,000
也就是已经消除了识别出的 bad smell 之后

1391
01:00:43,000 --> 01:00:44,000
比较 clean 的实现

1392
01:00:45,000 --> 01:00:45,000
对

1393
01:00:46,000 --> 01:00:46,000
对错

1394
01:00:47,000 --> 01:00:50,000
而这两种开放模式也没有好坏之分

1395
01:00:50,000 --> 01:00:51,000
只是这两种开放模式

1396
01:00:51,000 --> 01:00:52,000
一个是自顶向上

1397
01:00:52,000 --> 01:00:55,000
还是自下而上的两种区分方式

1398
01:00:56,000 --> 01:00:58,000
只是思考的问题和方向的问题

1399
01:00:58,000 --> 01:01:00,000
可能最终的结果是一致的

1400
01:01:02,000 --> 01:01:02,000
对吧

1401
01:01:04,000 --> 01:01:05,000
其实这怎么说

1402
01:01:05,000 --> 01:01:09,000
就这种大概念性的争吵

1403
01:01:09,000 --> 01:01:10,000
其实也没有什么太大的用处

1404
01:01:10,000 --> 01:01:11,000
就是有些人习惯

1405
01:01:12,000 --> 01:01:14,000
先有一个大的红

1406
01:01:14,000 --> 01:01:15,000
跟写作玩一样

1407
01:01:15,000 --> 01:01:18,000
有些人习惯说先来把七纲写出来

1408
01:01:18,000 --> 01:01:20,000
然后再来听这些天气之魔眼

1409
01:01:20,000 --> 01:01:21,000
有人喜欢写散谋

1410
01:01:21,000 --> 01:01:23,000
他一定要边写边弄

1411
01:01:23,000 --> 01:01:25,000
然后再拼出来看

1412
01:01:25,000 --> 01:01:26,000
写出这么个东西

1413
01:01:27,000 --> 01:01:27,000
对

1414
01:01:27,000 --> 01:01:29,000
我小时候会经常写一些

1415
01:01:31,000 --> 01:01:32,000
没有上下方的片段

1416
01:01:32,000 --> 01:01:33,000
然后最后

1417
01:01:33,000 --> 01:01:34,000
拼在一起是吧

1418
01:01:35,000 --> 01:01:36,000
最后写作玩的时候

1419
01:01:36,000 --> 01:01:38,000
可以想起来一个段子

1420
01:01:38,000 --> 01:01:38,000
然后拼进去

1421
01:01:41,000 --> 01:01:44,000
他有一个什么 TDD 实施的三个步骤

1422
01:01:44,000 --> 01:01:46,000
用他自己的理解去说

1423
01:01:46,000 --> 01:01:46,000
先写一个测试

1424
01:01:46,000 --> 01:01:48,000
然后让边缘通过

1425
01:01:48,000 --> 01:01:49,000
这上次我们已经提到过

1426
01:01:49,000 --> 01:01:50,000
就是只让

1427
01:01:50,000 --> 01:01:51,000
你已经解释过一次

1428
01:01:51,000 --> 01:01:53,000
就是只边写能恰好

1429
01:01:53,000 --> 01:01:55,000
让所有测试通过的代码

1430
01:01:55,000 --> 01:01:56,000
然后不断的传购

1431
01:01:56,000 --> 01:01:58,000
然后去反复这个过程

1432
01:01:58,000 --> 01:01:59,000
然后消灭掉所有的那些

1433
01:01:59,000 --> 01:02:00,000
Bad smell

1434
01:02:01,000 --> 01:02:02,000
但就我们那期节目中

1435
01:02:02,000 --> 01:02:04,000
他说本期节目中没有提到重构

1436
01:02:04,000 --> 01:02:07,000
这也是人们在谈论 TDD 中

1437
01:02:07,000 --> 01:02:08,000
经常忽略的

1438
01:02:08,000 --> 01:02:10,000
如果没有重构这个步骤的话

1439
01:02:10,000 --> 01:02:12,000
理论上确实所有的逻辑

1440
01:02:12,000 --> 01:02:14,000
都可以通过无数的

1441
01:02:14,000 --> 01:02:17,000
乙穷举输入与输出的映射来实现

1442
01:02:17,000 --> 01:02:19,000
虽然说还挺寒熟悉

1443
01:02:19,000 --> 01:02:21,000
这其实也有可能是将来

1444
01:02:21,000 --> 01:02:22,000
计算机写程序的一种方法

1445
01:02:23,000 --> 01:02:27,000
暴力的把你所有可能需要的场景

1446
01:02:27,000 --> 01:02:28,000
全都自动生成语言

1447
01:02:28,000 --> 01:02:29,000
然后程序就写出来

1448
01:02:29,000 --> 01:02:30,000
对

1449
01:02:30,000 --> 01:02:32,000
我们都知道这样是不对的

1450
01:02:32,000 --> 01:02:35,000
代码将很快陷入腐化

1451
01:02:35,000 --> 01:02:37,000
我想这也是为什么节目中说

1452
01:02:37,000 --> 01:02:38,000
可以调色代码

1453
01:02:38,000 --> 01:02:40,000
都是啰嗦的代码的原因之一

1454
01:02:40,000 --> 01:02:42,000
总之我个人认为

1455
01:02:42,000 --> 01:02:44,000
没有重构的 TDD 都是耍流氓

1456
01:02:44,000 --> 01:02:47,000
如果说前两步保证

1457
01:02:47,000 --> 01:02:49,000
我们的代码实现了业务价值

1458
01:02:49,000 --> 01:02:50,000
那重构就保证

1459
01:02:50,000 --> 01:02:52,000
我们代码本身的质量和设计

1460
01:02:52,000 --> 01:02:54,000
从而避免代码的快速腐化

1461
01:02:54,000 --> 01:02:55,000
只有这样才能体现

1462
01:02:55,000 --> 01:02:58,000
TDD 的价值和好处

1463
01:02:58,000 --> 01:02:59,000
但一个重要的前提是

1464
01:02:59,000 --> 01:03:01,000
测试要写对

1465
01:03:01,000 --> 01:03:03,000
否则很容易适得其反

1466
01:03:03,000 --> 01:03:05,000
严重影响重构以及变化

1467
01:03:05,000 --> 01:03:06,000
最简单的

1468
01:03:06,000 --> 01:03:07,000
就是重构的时候

1469
01:03:07,000 --> 01:03:08,000
需要修改测试

1470
01:03:08,000 --> 01:03:10,000
刚才我们已经提到这个问题了

1471
01:03:10,000 --> 01:03:12,000
就是你重构的过程中

1472
01:03:12,000 --> 01:03:15,000
导致接口变了

1473
01:03:15,000 --> 01:03:17,000
那么你测试就要重写

1474
01:03:17,000 --> 01:03:19,000
这其实在他看来

1475
01:03:19,000 --> 01:03:20,000
这个是什么

1476
01:03:20,000 --> 01:03:23,000
测试写的不好的一个典范

1477
01:03:23,000 --> 01:03:24,000
对

1478
01:03:25,000 --> 01:03:27,000
一种常见的问题就是

1479
01:03:27,000 --> 01:03:30,000
测试 target 不是业务价值

1480
01:03:32,000 --> 01:03:32,000
我来念吧

1481
01:03:32,000 --> 01:03:33,000
这一段应该是

1482
01:03:34,000 --> 01:03:36,000
一种常见的问题就是

1483
01:03:36,000 --> 01:03:39,000
测试的目标不是业务价值

1484
01:03:39,000 --> 01:03:41,000
比如罗马数字与阿拉伯数字的

1485
01:03:41,000 --> 01:03:43,000
转化的结果是否正确

1486
01:03:43,000 --> 01:03:46,000
而是实现本身

1487
01:03:46,000 --> 01:03:49,000
也就是他写的这个测试

1488
01:03:49,000 --> 01:03:50,000
测试的是

1489
01:03:50,000 --> 01:03:52,000
是否采用了某种算法

1490
01:03:52,000 --> 01:03:55,000
来处理罗马数字与阿拉伯数字的转化

1491
01:03:55,000 --> 01:03:57,000
在这种情况之下

1492
01:03:57,000 --> 01:03:58,000
如果你要换算法的话

1493
01:03:58,000 --> 01:03:59,000
你就得修改测试

1494
01:04:01,000 --> 01:04:02,000
你要是这个意思

1495
01:04:02,000 --> 01:04:03,000
OK

1496
01:04:04,000 --> 01:04:06,000
然后他说如果测试写的不对

1497
01:04:06,000 --> 01:04:09,000
那么测试的稳定性及价值

1498
01:04:09,000 --> 01:04:10,000
就会大打折扣

1499
01:04:10,000 --> 01:04:12,000
而且测试维护测试的成本

1500
01:04:12,000 --> 01:04:14,000
也会大大增加

1501
01:04:14,000 --> 01:04:15,000
这正好说明了

1502
01:04:15,000 --> 01:04:17,000
为什么大多数人不爱写测试

1503
01:04:17,000 --> 01:04:20,000
其实写好或者写的对的测试

1504
01:04:20,000 --> 01:04:21,000
确实挺难的

1505
01:04:21,000 --> 01:04:23,000
有时候要比写好或者写对的

1506
01:04:23,000 --> 01:04:25,000
这个实现还要难很多

1507
01:04:25,000 --> 01:04:28,000
这也印证刚才张博士的说法

1508
01:04:28,000 --> 01:04:30,000
你这个什么形式证明也是很难的

1509
01:04:30,000 --> 01:04:33,000
测试也没有简单的那里去是吧

1510
01:04:33,000 --> 01:04:33,000
没错

1511
01:04:33,000 --> 01:04:36,000
其实你能写测试

1512
01:04:36,000 --> 01:04:39,000
已经意味着你对写程序这件事情

1513
01:04:39,000 --> 01:04:41,000
有相当的了解了

1514
01:04:41,000 --> 01:04:41,000
对

1515
01:04:41,000 --> 01:04:43,000
写测试有点像

1516
01:04:43,000 --> 01:04:45,000
你要教一个人

1517
01:04:45,000 --> 01:04:48,000
你要教一个人武功

1518
01:04:48,000 --> 01:04:49,000
你自己得先会武功

1519
01:04:49,000 --> 01:04:51,000
就你这武功得比他强

1520
01:04:51,000 --> 01:04:53,000
你才能跟他对拆

1521
01:04:53,000 --> 01:04:56,000
然后到三当又打错了

1522
01:04:56,000 --> 01:04:57,000
写测试也是

1523
01:04:57,000 --> 01:04:59,000
其实是这样

1524
01:04:59,000 --> 01:05:01,000
如果你能写出一个好的测试

1525
01:05:01,000 --> 01:05:02,000
基本上就意味着你是一个

1526
01:05:03,000 --> 01:05:06,000
比能够写出好的代码更好的程序

1527
01:05:06,000 --> 01:05:07,000
对

1528
01:05:07,000 --> 01:05:08,000
起码你对整个接口

1529
01:05:08,000 --> 01:05:10,000
它哪些地方可能会出错

1530
01:05:11,000 --> 01:05:13,000
你会有一个比较完备的理解

1531
01:05:13,000 --> 01:05:13,000
你才能做到

1532
01:05:14,000 --> 01:05:17,000
测试写出来是足够覆盖度的

1533
01:05:17,000 --> 01:05:19,000
然后有足够多的一种

1534
01:05:19,000 --> 01:05:22,000
所谓边界条件去验证那些东西的

1535
01:05:22,000 --> 01:05:23,000
会不会出问题

1536
01:05:24,000 --> 01:05:24,000
没错

1537
01:05:26,000 --> 01:05:27,000
他又说

1538
01:05:27,000 --> 01:05:29,000
关于 TDD 很硬度

1539
01:05:29,000 --> 01:05:29,000
就是你说的

1540
01:05:30,000 --> 01:05:33,000
将测试作为详细设计说明书的

1541
01:05:33,000 --> 01:05:34,000
可运行版本

1542
01:05:34,000 --> 01:05:36,000
来实现分工和流程化

1543
01:05:37,000 --> 01:05:40,000
因为他们就是他在工作那个地方

1544
01:05:40,000 --> 01:05:42,000
没有严格的分工和分级

1545
01:05:42,000 --> 01:05:44,000
也没有架构师设计师之类的角色

1546
01:05:44,000 --> 01:05:47,000
所以他感觉不到他们只有 BA

1547
01:05:47,000 --> 01:05:49,000
就是什么 business analyst

1548
01:05:49,000 --> 01:05:50,000
是吧

1549
01:05:50,000 --> 01:05:52,000
QA quality assurance

1550
01:05:52,000 --> 01:05:54,000
然后 dev 就是开发和 UX

1551
01:05:54,000 --> 01:05:58,000
就是用户体验这些角色

1552
01:05:58,000 --> 01:06:02,000
开发自己要负责一个 story 的

1553
01:06:02,000 --> 01:06:04,000
需求建设与反馈

1554
01:06:04,000 --> 01:06:06,000
他们的那个好多术语

1555
01:06:08,000 --> 01:06:09,000
任务拆分

1556
01:06:09,000 --> 01:06:11,000
然后开发前端

1557
01:06:11,000 --> 01:06:13,000
还有甚至给客户去 showcase

1558
01:06:13,000 --> 01:06:14,000
应该是 demo 这点东西

1559
01:06:15,000 --> 01:06:16,000
所以这块我们还好

1560
01:06:16,000 --> 01:06:17,000
没有感觉任何不是

1561
01:06:17,000 --> 01:06:19,000
就没有觉得自己很

1562
01:06:19,000 --> 01:06:21,000
像吴涛说的那么很硬度

1563
01:06:21,000 --> 01:06:24,000
他们还是很开心的在做 TDD 的建设

1564
01:06:25,000 --> 01:06:28,000
反而在测试的保障下

1565
01:06:28,000 --> 01:06:31,000
我们可以灵活的修改实现和设计

1566
01:06:31,000 --> 01:06:32,000
甚至灵活的响应需求的变化

1567
01:06:33,000 --> 01:06:34,000
他们现在这个项目

1568
01:06:34,000 --> 01:06:35,000
就有四多个人开发

1569
01:06:35,000 --> 01:06:38,000
是基于一个.net 的 web API

1570
01:06:38,000 --> 01:06:41,000
再加前端是 reangler.js

1571
01:06:42,000 --> 01:06:43,000
现在也在换 react.js

1572
01:06:44,000 --> 01:06:46,000
然后基于微服务的方法来做的

1573
01:06:46,000 --> 01:06:49,000
用的是吴涛最爱的 csharp

1574
01:06:49,000 --> 01:06:50,000
都做了五年了

1575
01:06:51,000 --> 01:06:53,000
然后目前还可以做到相对灵活的

1576
01:06:54,000 --> 01:06:57,000
响应需求变化以代码实现的演进

1577
01:06:57,000 --> 01:06:59,000
甚至工具框架的演进

1578
01:06:59,000 --> 01:07:01,000
可以说 TDD 也是功不可没

1579
01:07:01,000 --> 01:07:02,000
这确实挺难得的

1580
01:07:02,000 --> 01:07:03,000
一个五年的项目

1581
01:07:03,000 --> 01:07:05,000
没有积攒出那么多的 craft

1582
01:07:05,000 --> 01:07:08,000
反而还能在做一套整个业务

1583
01:07:09,000 --> 01:07:11,000
业务思想的这么指导下

1584
01:07:11,000 --> 01:07:13,000
能够保持敏捷性

1585
01:07:13,000 --> 01:07:14,000
这确实非常不容易

1586
01:07:15,000 --> 01:07:16,000
对

1587
01:07:16,000 --> 01:07:18,000
他说到 TDD 很印度

1588
01:07:21,000 --> 01:07:23,000
我觉得还是有必要解释一下

1589
01:07:23,000 --> 01:07:24,000
什么叫印度

1590
01:07:24,000 --> 01:07:27,000
印度就是印度人有一个特点

1591
01:07:27,000 --> 01:07:30,000
就是他只做你告诉他该做的事情

1592
01:07:31,000 --> 01:07:33,000
然后你告诉他该做的事情

1593
01:07:33,000 --> 01:07:34,000
他不一定能做好

1594
01:07:34,000 --> 01:07:37,000
所以印度人为了管理印度人

1595
01:07:38,000 --> 01:07:40,000
我知道没有地狱歧视

1596
01:07:40,000 --> 01:07:41,000
或者种族歧视的意思

1597
01:07:41,000 --> 01:07:43,000
但是如果你听出来了

1598
01:07:43,000 --> 01:07:43,000
我有这个意思

1599
01:07:43,000 --> 01:07:44,000
我也没有

1600
01:07:44,000 --> 01:07:45,000
我也没有什么可以解释

1601
01:07:46,000 --> 01:07:48,000
印度人想出来管理印度人的方法就是

1602
01:07:49,000 --> 01:07:55,000
有一个高高在上的拿着鞭子的人

1603
01:07:57,000 --> 01:07:59,000
告诉你每一步应该做什么

1604
01:07:59,000 --> 01:08:00,000
然后反复来检查你

1605
01:08:01,000 --> 01:08:04,000
我的印度指的是这个意思

1606
01:08:04,000 --> 01:08:05,000
而他所说的

1607
01:08:05,000 --> 01:08:08,000
他们在公司里面没有严格的分工和分级

1608
01:08:09,000 --> 01:08:10,000
这本身就已经非常不印度了

1609
01:08:11,000 --> 01:08:13,000
然后说没有架构师

1610
01:08:13,000 --> 01:08:14,000
没有设计师之类的角色

1611
01:08:16,000 --> 01:08:18,000
其实一个公司里面没有架构师

1612
01:08:18,000 --> 01:08:19,000
没有设计师

1613
01:08:19,000 --> 01:08:21,000
并不意味着这个公司就不需要做架构

1614
01:08:21,000 --> 01:08:22,000
不需要做设计

1615
01:08:23,000 --> 01:08:27,000
只不过这个架构和设计的职责

1616
01:08:27,000 --> 01:08:28,000
分担到了每一个代表身上

1617
01:08:29,000 --> 01:08:32,000
这个对于开发者的要求其实比较高的

1618
01:08:32,000 --> 01:08:36,000
但是反过来也会让开发者有这样一种感觉

1619
01:08:37,000 --> 01:08:40,000
我做的东西是我自己亲手设计出来的

1620
01:08:40,000 --> 01:08:41,000
我做的东西是我想要做的

1621
01:08:42,000 --> 01:08:44,000
然后你在主观能动性上会高一点

1622
01:08:45,000 --> 01:08:45,000
但是

1623
01:08:49,000 --> 01:08:52,000
我觉得是这种制度保证了你没有那么印度

1624
01:08:52,000 --> 01:08:53,000
但并不意味着

1625
01:08:55,000 --> 01:08:57,000
我也不要一定说 TPP

1626
01:08:57,000 --> 01:09:02,000
TPP 就是一定非常适合印度的开发方法

1627
01:09:02,000 --> 01:09:07,000
我只是说 TPP 很容易被拿来在这种

1628
01:09:07,000 --> 01:09:12,000
刚才我说的这种抽象式的符号化的印度式的管理上

1629
01:09:15,000 --> 01:09:15,000
OK

1630
01:09:16,000 --> 01:09:16,000
然后

1631
01:09:17,000 --> 01:09:18,000
下一则你来念

1632
01:09:20,000 --> 01:09:20,000
对

1633
01:09:20,000 --> 01:09:25,000
然后这位朋友说他在公司推荐了我们的节目

1634
01:09:25,000 --> 01:09:29,000
然后自己也会一边开车听节目的时候一边偷笑

1635
01:09:31,000 --> 01:09:37,000
而且会认为说他的同事们这群被 TPP 安利洗脑的家伙伙们

1636
01:09:37,000 --> 01:09:40,000
肯定会听到我们的这些节目产生各种不是

1637
01:09:42,000 --> 01:09:47,000
不过他们的同事也比较崇尚和而不同的环境

1638
01:09:47,000 --> 01:09:49,000
互通有误也没什么不好

1639
01:09:51,000 --> 01:09:52,000
对

1640
01:09:52,000 --> 01:09:52,000
其实

1641
01:09:52,000 --> 01:09:58,000
我觉得这位先生的工作环境是非常理想的一个环境

1642
01:09:58,000 --> 01:10:00,000
这位叫做王健的朋友

1643
01:10:01,000 --> 01:10:03,000
如果你们招人的话

1644
01:10:03,000 --> 01:10:06,000
我们可以给你们打个广告

1645
01:10:06,000 --> 01:10:12,000
然后最最牛逼的是他在最后录了一段 TDD 写我这个

1646
01:10:12,000 --> 01:10:19,000
写我在节目里面提到的这个罗马数字转换为阿拉伯数字转换为罗马数字的程序

1647
01:10:19,000 --> 01:10:24,000
就是相对严格的按照这个 TDD 的先写一个测试

1648
01:10:24,000 --> 01:10:26,000
然后再写一段程序

1649
01:10:26,000 --> 01:10:27,000
再写一点测试

1650
01:10:27,000 --> 01:10:28,000
再写一点程序

1651
01:10:28,000 --> 01:10:29,000
这是这样的步骤来的

1652
01:10:29,000 --> 01:10:34,000
然后他把视频传到 YouTube 和优酷上来

1653
01:10:34,000 --> 01:10:36,000
我只看到 YouTube 版本

1654
01:10:36,000 --> 01:10:40,000
我们会把这个链接放在节目的末尾

1655
01:10:40,000 --> 01:10:43,000
所以如果你没有你从来没有见过 TDD 是什么样子的话

1656
01:10:43,000 --> 01:10:44,000
你可以看到一位

1657
01:10:44,000 --> 01:10:46,000
火车神的弟子

1658
01:10:46,000 --> 01:10:51,000
世界上最好用的编辑环境 Virtual Studio

1659
01:10:51,000 --> 01:10:53,000
以及世界上最好的语言

1660
01:10:53,000 --> 01:10:59,000
C-Shop 为你执行整个 TDD 过程

1661
01:11:00,000 --> 01:11:03,000
接下来我来念两封比较短的读者回馈

1662
01:11:03,000 --> 01:11:10,000
一封是一位来自于石霞星座

1663
01:11:10,000 --> 01:11:17,000
一封是一位来自于石霞星的朋友

1664
01:11:18,000 --> 01:11:20,000
他的署名是 Star Samurai

1665
01:11:21,000 --> 01:11:24,000
他来自于法国

1666
01:11:24,000 --> 01:11:27,000
我们经常回法国

1667
01:11:27,000 --> 01:11:28,000
是 Star Sasumi

1668
01:11:29,000 --> 01:11:31,000
啊 Star Sasumi

1669
01:11:32,000 --> 01:11:32,000
OK sorry

1670
01:11:34,000 --> 01:11:37,000
他来自于法国南特旷月学院

1671
01:11:38,000 --> 01:11:40,000
也是一个名字听起来非常的

1672
01:11:41,000 --> 01:11:42,000
Nade

1673
01:11:42,000 --> 01:11:44,000
但实际上在欧洲也是非常好的学校

1674
01:11:44,000 --> 01:11:45,000
他说

1675
01:11:45,000 --> 01:11:47,000
Hi 的很喜欢你们的节目

1676
01:11:47,000 --> 01:11:49,000
这里是关于试用期测试力量反馈

1677
01:11:50,000 --> 01:11:54,000
然后 Digivoo 的读音是 Digivoo

1678
01:11:56,000 --> 01:11:59,000
不过 Digivoo 已经被美国人读太多

1679
01:11:59,000 --> 01:12:01,000
也能算是英文世界的发音了吧

1680
01:12:02,000 --> 01:12:03,000
在这里唱一下

1681
01:12:03,000 --> 01:12:04,000
乌涛总是黑我们法国

1682
01:12:08,000 --> 01:12:08,000
对不起

1683
01:12:08,000 --> 01:12:10,000
我是故意的

1684
01:12:13,000 --> 01:12:15,000
然后关于女生选择做测试这一点

1685
01:12:15,000 --> 01:12:18,000
根据我们的学姐说就是比较轻松

1686
01:12:18,000 --> 01:12:18,000
也不需要加班

1687
01:12:19,000 --> 01:12:21,000
不论是需求改了

1688
01:12:21,000 --> 01:12:22,000
还是上线之后出问题

1689
01:12:22,000 --> 01:12:24,000
测试团队都不用被紧急着急

1690
01:12:25,000 --> 01:12:28,000
上线出问题这个 QA 会不会抓回来

1691
01:12:28,000 --> 01:12:29,000
他都上线了

1692
01:12:29,000 --> 01:12:31,000
你找测试团队有什么用

1693
01:12:32,000 --> 01:12:33,000
好像也已经太晚了

1694
01:12:33,000 --> 01:12:36,000
你就拿那个 productive 的环境来

1695
01:12:36,000 --> 01:12:36,000
当测试环境

1696
01:12:37,000 --> 01:12:39,000
然后改到能用为止

1697
01:12:40,000 --> 01:12:40,000
还能怎么办

1698
01:12:42,000 --> 01:12:45,000
第二篇回馈是一位叫李建宏的朋友

1699
01:12:45,000 --> 01:12:48,000
问我们一款在 Pickstart 的时候

1700
01:12:48,000 --> 01:12:50,000
那个什么 trackpad 的那个事情要说一下吗

1701
01:12:52,000 --> 01:12:53,000
对

1702
01:12:55,000 --> 01:12:57,000
然后听众还问我们说

1703
01:12:57,000 --> 01:13:01,000
一天下来手指会不会因为 trackpad 用多了

1704
01:13:01,000 --> 01:13:02,000
而关节疼

1705
01:13:02,000 --> 01:13:04,000
他最近实习下班了

1706
01:13:04,000 --> 01:13:06,000
总是中指关节微微发疼

1707
01:13:06,000 --> 01:13:08,000
中指是 tap 的主力手指

1708
01:13:08,000 --> 01:13:10,000
两位有合适解决方法吗

1709
01:13:10,000 --> 01:13:11,000
你有这个问题吗

1710
01:13:12,000 --> 01:13:14,000
我的解决方法是换鼠标

1711
01:13:17,000 --> 01:13:18,000
其实我也是

1712
01:13:19,000 --> 01:13:21,000
其实我现在家里面偶尔也会用一下鼠标

1713
01:13:21,000 --> 01:13:24,000
主要是最近打游戏比较多

1714
01:13:26,000 --> 01:13:28,000
其实我觉得 trackpad

1715
01:13:28,000 --> 01:13:29,000
就这种

1716
01:13:29,000 --> 01:13:31,000
特别是 Mac 上面多点触碰 trackpad

1717
01:13:32,000 --> 01:13:34,000
最严重的问题倒不是说关节痛

1718
01:13:34,000 --> 01:13:36,000
而是会变成蓝花指

1719
01:13:39,000 --> 01:13:40,000
是有点

1720
01:13:40,000 --> 01:13:42,000
因为你用的时候总会把小指翘起来一面

1721
01:13:42,000 --> 01:13:43,000
对

1722
01:13:43,000 --> 01:13:45,000
久而久之就娘了

1723
01:13:49,000 --> 01:13:50,000
对

1724
01:13:50,000 --> 01:13:52,000
其实我有个解决方案就是用中指

1725
01:13:52,000 --> 01:13:54,000
用食指和无名指

1726
01:13:55,000 --> 01:13:56,000
食指和无名指

1727
01:13:57,000 --> 01:13:57,000
对

1728
01:13:57,000 --> 01:13:58,000
这怎么有握法

1729
01:13:59,000 --> 01:14:00,000
中指不用了

1730
01:14:00,000 --> 01:14:02,000
就是中指不用中指

1731
01:14:02,000 --> 01:14:05,000
始终保持一个 screw 的状态

1732
01:14:05,000 --> 01:14:07,000
就是一直翘了

1733
01:14:07,000 --> 01:14:08,000
这是一个很硬朗的做法

1734
01:14:08,000 --> 01:14:09,000
是吧

1735
01:14:11,000 --> 01:14:12,000
总之我有三个建议

1736
01:14:12,000 --> 01:14:16,000
一个是关掉触摸板的 click touch

1737
01:14:16,000 --> 01:14:18,000
就是你不要按下去

1738
01:14:18,000 --> 01:14:19,000
你只用轻触

1739
01:14:19,000 --> 01:14:19,000
tap

1740
01:14:20,000 --> 01:14:21,000
对

1741
01:14:21,000 --> 01:14:22,000
只用 tap 来代替 click

1742
01:14:22,000 --> 01:14:26,000
然后这样会对手指的捞损小一点

1743
01:14:26,000 --> 01:14:27,000
第二就是可以用

1744
01:14:27,000 --> 01:14:33,000
可以用 Star Trek 里面 Live Long and Prosper 的手势

1745
01:14:33,000 --> 01:14:36,000
用把你的食指和中指并在一起

1746
01:14:36,000 --> 01:14:39,000
把无名指和小指并在一起

1747
01:14:41,000 --> 01:14:42,000
大部分时候也

1748
01:14:42,000 --> 01:14:45,000
这样可以增强手指的力度

1749
01:14:45,000 --> 01:14:48,000
或者说增强手指的依赖

1750
01:14:48,000 --> 01:14:49,000
第三就是经常在

1751
01:14:50,000 --> 01:14:51,000
我刚才说的

1752
01:14:51,000 --> 01:14:54,000
只用食指和无名指的手势

1753
01:14:54,000 --> 01:14:57,000
以及 Star Trek 手势之间切换

1754
01:14:57,000 --> 01:15:02,000
这样可以比较有效的减少手指的捞损

1755
01:15:02,000 --> 01:15:04,000
当然还有一个 tip 就是经常用左手

1756
01:15:04,000 --> 01:15:05,000
我觉得也挺好

1757
01:15:12,000 --> 01:15:16,000
下一篇反馈是一位来自李建鸿的朋友

1758
01:15:16,000 --> 01:15:17,000
sorry

1759
01:15:17,000 --> 01:15:22,000
问我们在 Kickstar 上看到一款众筹的键盘怎么样

1760
01:15:23,000 --> 01:15:24,000
我就看了一下

1761
01:15:24,000 --> 01:15:24,000
他

1762
01:15:24,000 --> 01:15:25,000
你看了吗

1763
01:15:25,000 --> 01:15:26,000
我看了

1764
01:15:26,000 --> 01:15:30,000
之前我推荐那款叫什么

1765
01:15:30,000 --> 01:15:34,000
Truly Renomic Keyboard 的长相有点接近

1766
01:15:34,000 --> 01:15:35,000
跟他差不多

1767
01:15:35,000 --> 01:15:37,000
只不过他更极端一点

1768
01:15:37,000 --> 01:15:38,000
就是他把

1769
01:15:40,000 --> 01:15:43,000
首先他把键盘做成一个木底

1770
01:15:44,000 --> 01:15:45,000
下面那个东西是木头做的

1771
01:15:47,000 --> 01:15:48,000
看起来比较

1772
01:15:49,000 --> 01:15:50,000
我很难说它是漂亮

1773
01:15:50,000 --> 01:15:51,000
但有一种不一样的美

1774
01:15:52,000 --> 01:15:56,000
然后上面的键它做成了一个

1775
01:15:56,000 --> 01:15:57,000
它比较重大的测试

1776
01:15:57,000 --> 01:15:58,000
设计就是

1777
01:15:59,000 --> 01:16:00,000
首先两个键盘

1778
01:16:00,000 --> 01:16:02,000
键盘的左右部分是可以分开的

1779
01:16:02,000 --> 01:16:03,000
其次

1780
01:16:03,000 --> 01:16:06,000
拇指会承担很多工作

1781
01:16:06,000 --> 01:16:06,000
比如说

1782
01:16:08,000 --> 01:16:10,000
空格键被减少了一个键

1783
01:16:10,000 --> 01:16:14,000
然后你在这个拇指的最下面的那个指关节

1784
01:16:14,000 --> 01:16:16,000
就是最大那个指关节的部分

1785
01:16:17,000 --> 01:16:18,000
也有一个按键

1786
01:16:18,000 --> 01:16:19,000
然后拇指

1787
01:16:19,000 --> 01:16:22,000
拇指的上面部分还要分别控制四个键

1788
01:16:24,000 --> 01:16:26,000
我理解就是他的设计

1789
01:16:26,000 --> 01:16:30,000
可以让你保证说你的手指基本上不会移动

1790
01:16:30,000 --> 01:16:31,000
你的手腕基本上不会移动

1791
01:16:32,000 --> 01:16:34,000
你的手放在那就可以按到所有按键

1792
01:16:34,000 --> 01:16:38,000
而且那个放在一次是一个手掌和手

1793
01:16:39,000 --> 01:16:41,000
前臂对吧

1794
01:16:41,000 --> 01:16:43,000
它是在一条直线上的

1795
01:16:43,000 --> 01:16:44,000
而不是说那种一个弯

1796
01:16:44,000 --> 01:16:46,000
就是一个斜角这样长期的会导致

1797
01:16:46,000 --> 01:16:47,000
叫什么来的

1798
01:16:47,000 --> 01:16:50,000
万管综合症

1799
01:16:50,000 --> 01:16:51,000
卖管综合症

1800
01:16:51,000 --> 01:16:52,000
到底是哪个来着

1801
01:16:52,000 --> 01:16:53,000
万管综合症

1802
01:16:53,000 --> 01:16:54,000
我上次说

1803
01:16:54,000 --> 01:16:54,000
万管综合症

1804
01:16:54,000 --> 01:16:55,000
对

1805
01:16:55,000 --> 01:16:57,000
我一站就一直在说卖管综合症

1806
01:16:57,000 --> 01:16:57,000
对

1807
01:16:57,000 --> 01:16:59,000
然后被被初遥老师说了

1808
01:17:02,000 --> 01:17:03,000
好吧

1809
01:17:03,000 --> 01:17:06,000
我们今天就不讲

1810
01:17:07,000 --> 01:17:08,000
其实那个键盘

1811
01:17:08,000 --> 01:17:11,000
我要补充一个最主要的这种异形的键盘

1812
01:17:11,000 --> 01:17:13,000
打字都是其实挺好

1813
01:17:13,000 --> 01:17:14,000
挺容易适应的

1814
01:17:14,000 --> 01:17:16,000
可能打个三五分钟

1815
01:17:16,000 --> 01:17:17,000
或者最慢一点的一两天

1816
01:17:17,000 --> 01:17:18,000
怎么也适应过来了

1817
01:17:18,000 --> 01:17:19,000
对吧

1818
01:17:19,000 --> 01:17:22,000
最难适应的是各种快捷键的组合

1819
01:17:22,000 --> 01:17:23,000
完全不一样

1820
01:17:24,000 --> 01:17:24,000
对

1821
01:17:24,000 --> 01:17:25,000
没错

1822
01:17:25,000 --> 01:17:27,000
当然我对这个键盘也不能说完全

1823
01:17:31,000 --> 01:17:32,000
怎么说

1824
01:17:32,000 --> 01:17:32,000
完全

1825
01:17:33,000 --> 01:17:36,000
比如说完全买它的主意

1826
01:17:36,000 --> 01:17:37,000
就是它有个问题

1827
01:17:37,000 --> 01:17:40,000
就是你要把手挪开键盘之后

1828
01:17:40,000 --> 01:17:42,000
再放回去的过程可能会比较痛苦

1829
01:17:43,000 --> 01:17:44,000
就

1830
01:17:44,000 --> 01:17:45,000
因为一般的键盘

1831
01:17:45,000 --> 01:17:46,000
它没有考虑人体工学的话

1832
01:17:48,000 --> 01:17:50,000
你把手挪出去再挪回来

1833
01:17:50,000 --> 01:17:52,000
你不用特别在意说

1834
01:17:52,000 --> 01:17:54,000
我要把手放到一个特定的位置

1835
01:17:55,000 --> 01:17:57,000
但是如果你用这个蝴蝶键盘的话

1836
01:17:57,000 --> 01:17:58,000
你每次把手放回来

1837
01:17:58,000 --> 01:18:01,000
你都要小心的调整手掌

1838
01:18:01,000 --> 01:18:04,000
让手掌落到那个最完美的位置

1839
01:18:07,000 --> 01:18:09,000
我这上我想到一个广告

1840
01:18:09,000 --> 01:18:09,000
就是

1841
01:18:10,000 --> 01:18:11,000
上面是一把德国刀

1842
01:18:11,000 --> 01:18:13,000
德国的双利人

1843
01:18:13,000 --> 01:18:14,000
还是 WMF 的厨刀

1844
01:18:16,000 --> 01:18:19,000
下面是一把日本的菜刀

1845
01:18:21,000 --> 01:18:24,000
德国的厨刀非常符合人体工学

1846
01:18:26,000 --> 01:18:26,000
日本的厨刀

1847
01:18:27,000 --> 01:18:30,000
刀柄就是一个平直的木头

1848
01:18:31,000 --> 01:18:32,000
下面的注释就是说

1849
01:18:33,000 --> 01:18:36,000
德国的刀只有一种最完美的握法

1850
01:18:37,000 --> 01:18:37,000
而日本的刀

1851
01:18:37,000 --> 01:18:39,000
你想怎么握都可以

1852
01:18:40,000 --> 01:18:41,000
然后基本上也就是

1853
01:18:42,000 --> 01:18:43,000
我觉得我比较喜欢那种审美

1854
01:18:44,000 --> 01:18:45,000
日式的

1855
01:18:45,000 --> 01:18:47,000
你可以把这个键盘

1856
01:18:48,000 --> 01:18:50,000
这键盘本身并不去会贴合你

1857
01:18:50,000 --> 01:18:52,000
但是你要去贴合这个键盘

1858
01:18:52,000 --> 01:18:53,000
但同时也就

1859
01:18:55,000 --> 01:18:56,000
意味着你有更多的自由

1860
01:19:00,000 --> 01:19:01,000
其实你说这种什么

1861
01:19:01,000 --> 01:19:04,000
Ergonomic 这种人体工学键盘

1862
01:19:04,000 --> 01:19:05,000
其实我一直在想

1863
01:19:06,000 --> 01:19:08,000
所谓真正的人体工学

1864
01:19:08,000 --> 01:19:09,000
好歹也是要

1865
01:19:09,000 --> 01:19:11,000
是不是每个人还是要不同的

1866
01:19:11,000 --> 01:19:11,000
对吧

1867
01:19:12,000 --> 01:19:14,000
人和人之间是有差异的

1868
01:19:15,000 --> 01:19:17,000
你真的要做到好的人体工学

1869
01:19:17,000 --> 01:19:20,000
得可能按这个人的量下来定制

1870
01:19:20,000 --> 01:19:20,000
对吧

1871
01:19:20,000 --> 01:19:21,000
其实做不到

1872
01:19:21,000 --> 01:19:22,000
那不如扫码吧

1873
01:19:22,000 --> 01:19:22,000
对

1874
01:19:22,000 --> 01:19:25,000
除非只有在这个传说中的

1875
01:19:25,000 --> 01:19:26,000
工业 4.0

1876
01:19:26,000 --> 01:19:28,000
或者工业 4.50

1877
01:19:28,000 --> 01:19:29,000
三 D 打印一块

1878
01:19:29,000 --> 01:19:32,000
你先把你的手放到扫码云下面

1879
01:19:33,000 --> 01:19:34,000
看它的尺寸

1880
01:19:34,000 --> 01:19:34,000
然后

1881
01:19:35,000 --> 01:19:36,000
打印出一个

1882
01:19:36,000 --> 01:19:39,000
只有你用的最舒服的键盘出来

1883
01:19:39,000 --> 01:19:40,000
那才是真正的

1884
01:19:40,000 --> 01:19:41,000
就别人用各种

1885
01:19:41,000 --> 01:19:43,000
别人用就你用的爽

1886
01:19:43,000 --> 01:19:44,000
对

1887
01:19:44,000 --> 01:19:45,000
所以从这小组讲

1888
01:19:47,000 --> 01:19:48,000
这是一个生意

1889
01:19:48,000 --> 01:19:50,000
我们就可以做 Basebook Keyboard

1890
01:19:53,000 --> 01:19:54,000
也许等我老了就差不多

1891
01:19:55,000 --> 01:19:56,000
其实我在想说

1892
01:19:56,000 --> 01:19:57,000
这个工业 4.0

1893
01:19:57,000 --> 01:19:58,000
其实有点

1894
01:19:59,000 --> 01:19:59,000
有点朝

1895
01:20:02,000 --> 01:20:04,000
mass production 的反方向跑

1896
01:20:04,000 --> 01:20:07,000
因为人类近代史上最伟大的发明之一

1897
01:20:07,000 --> 01:20:08,000
就是流水线

1898
01:20:09,000 --> 01:20:11,000
或者所谓 massive production

1899
01:20:12,000 --> 01:20:14,000
可以批量化生产

1900
01:20:14,000 --> 01:20:15,000
我记得我之前在看一本

1901
01:20:16,000 --> 01:20:18,000
经济学书里面讲说

1902
01:20:18,000 --> 01:20:19,000
亚当斯密的时代

1903
01:20:20,000 --> 01:20:20,000
一个人

1904
01:20:20,000 --> 01:20:21,000
一个工人

1905
01:20:21,000 --> 01:20:22,000
一个熟练的工人

1906
01:20:22,000 --> 01:20:24,000
一个小时可能只能造十几根针

1907
01:20:24,000 --> 01:20:25,000
大头针

1908
01:20:25,000 --> 01:20:26,000
而我们这个时代

1909
01:20:26,000 --> 01:20:29,000
一个工人在平均的小时之内

1910
01:20:29,000 --> 01:20:31,000
可以造出几万枚大头针

1911
01:20:32,000 --> 01:20:36,000
但是工业 4.0 时代也许

1912
01:20:36,000 --> 01:20:36,000
就意味着

1913
01:20:38,000 --> 01:20:40,000
朝这个潮流的逆向走

1914
01:20:42,000 --> 01:20:46,000
当然基础材料还是 mass production 出来的

1915
01:20:47,000 --> 01:20:48,000
打印机的粉末

1916
01:20:48,000 --> 01:20:50,000
但是最终的成品却是

1917
01:20:50,000 --> 01:20:52,000
只有在你需要的时候

1918
01:20:52,000 --> 01:20:55,000
才在你需要的一个地方

1919
01:20:55,000 --> 01:20:56,000
被你自己生产出来

1920
01:20:56,000 --> 01:20:58,000
这个就是他们这样

1921
01:20:58,000 --> 01:21:01,000
这前两年还是流行过的一个就是 mass

1922
01:21:02,000 --> 01:21:03,000
你看讲是 mass production

1923
01:21:03,000 --> 01:21:04,000
大规模生产

1924
01:21:04,000 --> 01:21:07,000
叫什么大规模定制 mass customization

1925
01:21:08,000 --> 01:21:08,000
对

1926
01:21:09,000 --> 01:21:10,000
就差不多做

1927
01:21:10,000 --> 01:21:12,000
其实这两个这些本质是有矛盾的

1928
01:21:12,000 --> 01:21:14,000
但得益于现在有什么各种各样的

1929
01:21:15,000 --> 01:21:16,000
机器人技术

1930
01:21:16,000 --> 01:21:17,000
这种 3 D 打印技术

1931
01:21:17,000 --> 01:21:18,000
可以很快速的

1932
01:21:19,000 --> 01:21:23,000
根据图纸切换出不同的模型出来

1933
01:21:24,000 --> 01:21:28,000
在定制化的基础上

1934
01:21:28,000 --> 01:21:29,000
又能同时满足生产的效率

1935
01:21:29,000 --> 01:21:31,000
这还是非常了不得的一个

1936
01:21:32,000 --> 01:21:33,000
工业史上的一个创新

1937
01:21:34,000 --> 01:21:35,000
没错

1938
01:21:36,000 --> 01:21:37,000
说到刚才快捷键的问题

1939
01:21:37,000 --> 01:21:40,000
这两天也是为什么我一直老觉得很别扭

1940
01:21:40,000 --> 01:21:43,000
就是在 HKB 上的那些键位和

1941
01:21:45,000 --> 01:21:47,000
Magazine kit 键盘的键位

1942
01:21:47,000 --> 01:21:48,000
有些那种功能键不太一样

1943
01:21:49,000 --> 01:21:53,000
那个主键区字母键数字那些都非常容易适应的

1944
01:21:53,000 --> 01:21:56,000
但就是功能键非常难改

1945
01:21:56,000 --> 01:22:00,000
然后你要用这种更加人体工学的键盘

1946
01:22:00,000 --> 01:22:04,000
他会考虑把那些功能键做到一个

1947
01:22:04,000 --> 01:22:07,000
通常我们是用什么小指来按那些左边的功能键

1948
01:22:07,000 --> 01:22:09,000
或者右边的功能键

1949
01:22:09,000 --> 01:22:12,000
但是你在这种完全人体工学的键盘上

1950
01:22:12,000 --> 01:22:14,000
反而是要用食指来按

1951
01:22:14,000 --> 01:22:15,000
到时候你会发现

1952
01:22:15,000 --> 01:22:18,000
我要按一个 Ctrl G 怎么办

1953
01:22:18,000 --> 01:22:19,000
就会很多纠结

1954
01:22:20,000 --> 01:22:24,000
关键是在很多这种软件设计者

1955
01:22:24,000 --> 01:22:26,000
他在制定默认的快捷键的时候

1956
01:22:26,000 --> 01:22:30,000
他会假设是一个正常布局的普通键盘来去这么设计

1957
01:22:31,000 --> 01:22:35,000
他说比如说复制粘贴这功能比较常用

1958
01:22:35,000 --> 01:22:36,000
我们做个快捷键

1959
01:22:36,000 --> 01:22:38,000
看哪个快捷键比较顺手按

1960
01:22:38,000 --> 01:22:39,000
然后大约你记得住了

1961
01:22:39,000 --> 01:22:42,000
发现 Ctrl C、Ctrl V 也不错

1962
01:22:42,000 --> 01:22:45,000
或者在 Mac 上就是 Ctrl C、Ctrl V

1963
01:22:46,000 --> 01:22:47,000
但是如果你换一下这种

1964
01:22:48,000 --> 01:22:49,000
这种异形的键盘

1965
01:22:49,000 --> 01:22:51,000
你发现好像不是那么顺手

1966
01:22:52,000 --> 01:22:56,000
所以这里面你要做的改动还是蛮多的

1967
01:22:56,000 --> 01:22:58,000
你得自己定义出一套

1968
01:22:59,000 --> 01:23:00,000
假设你那个软件是可以更改

1969
01:23:00,000 --> 01:23:02,000
这个自制快捷键的话

1970
01:23:02,000 --> 01:23:04,000
有很多人其实是不支持的

1971
01:23:04,000 --> 01:23:05,000
就是你要想

1972
01:23:05,000 --> 01:23:07,000
我怎么去在这个键盘上

1973
01:23:07,000 --> 01:23:08,000
不许上去找一套

1974
01:23:08,000 --> 01:23:10,000
我觉得还不错

1975
01:23:10,000 --> 01:23:12,000
能够为自己能记得住的

1976
01:23:13,000 --> 01:23:14,000
一套快捷键的组合

1977
01:23:14,000 --> 01:23:15,000
不是一个两个

1978
01:23:15,000 --> 01:23:16,000
是整套整套的换

1979
01:23:18,000 --> 01:23:18,000
对

1980
01:23:18,000 --> 01:23:19,000
其实挺辛苦的

1981
01:23:20,000 --> 01:23:21,000
是

1982
01:23:23,000 --> 01:23:23,000
OK

1983
01:23:24,000 --> 01:23:26,000
现在我们进入今天的主题

1984
01:23:26,000 --> 01:23:28,000
是 Design Pattern

1985
01:23:29,000 --> 01:23:30,000
设计模式

1986
01:23:32,000 --> 01:23:33,000
又是一期比较

1987
01:23:35,000 --> 01:23:36,000
水可能也不一定

1988
01:23:36,000 --> 01:23:37,000
但是会比较

1989
01:23:39,000 --> 01:23:40,000
玄学的东西

1990
01:23:42,000 --> 01:23:43,000
我知道

1991
01:23:45,000 --> 01:23:47,000
我所感受到的一种

1992
01:23:48,000 --> 01:23:50,000
一种心态

1993
01:23:50,000 --> 01:23:52,000
或者一种思潮就是

1994
01:23:53,000 --> 01:23:56,000
一切和架构和设计有关的东西都非常虚

1995
01:23:58,000 --> 01:24:02,000
一切和一切比较接近于底层实现

1996
01:24:02,000 --> 01:24:03,000
或者是比较接近于

1997
01:24:05,000 --> 01:24:06,000
理论和概念性的东西

1998
01:24:06,000 --> 01:24:11,000
才是真正值得人花精力去研究的内功心法

1999
01:24:14,000 --> 01:24:15,000
我不能说这样想不对

2000
01:24:16,000 --> 01:24:17,000
但是我总觉得

2001
01:24:18,000 --> 01:24:18,000
在

2002
01:24:20,000 --> 01:24:24,000
现代软件越来越大规模的

2003
01:24:25,000 --> 01:24:26,000
更新化的时代

2004
01:24:28,000 --> 01:24:29,000
学一点设计模式还是

2005
01:24:31,000 --> 01:24:32,000
有相当必要的

2006
01:24:32,000 --> 01:24:32,000
因为

2007
01:24:34,000 --> 01:24:34,000
怎么说呢

2008
01:24:34,000 --> 01:24:34,000
虽然

2009
01:24:35,000 --> 01:24:36,000
最近几年随着

2010
01:24:38,000 --> 01:24:40,000
我感觉打官腔的感觉

2011
01:24:40,000 --> 01:24:40,000
就是

2012
01:24:41,000 --> 01:24:43,000
这几年开源运动非常的火

2013
01:24:44,000 --> 01:24:46,000
同时也推行了一大批

2014
01:24:47,000 --> 01:24:47,000
比较黑客

2015
01:24:50,000 --> 01:24:52,000
走酷炫流派的

2016
01:24:54,000 --> 01:24:55,000
程序员的思潮

2017
01:24:57,000 --> 01:24:58,000
你是想说 Ruby on Rails 吗

2018
01:25:02,000 --> 01:25:03,000
没有特别针对某一个

2019
01:25:05,000 --> 01:25:06,000
Ruby on Rails

2020
01:25:06,000 --> 01:25:07,000
没有针对某一个语言

2021
01:25:07,000 --> 01:25:09,000
或者针对某一个 framework

2022
01:25:09,000 --> 01:25:11,000
但是我想说的一件事情就是

2023
01:25:11,000 --> 01:25:11,000
比如说

2024
01:25:12,000 --> 01:25:12,000
有些

2025
01:25:13,000 --> 01:25:14,000
时候

2026
01:25:15,000 --> 01:25:16,000
我不知道你怎么样

2027
01:25:16,000 --> 01:25:17,000
但是现在我有时候会觉得

2028
01:25:17,000 --> 01:25:19,000
自己判断一个人是不是牛人的

2029
01:25:20,000 --> 01:25:21,000
标准

2030
01:25:21,000 --> 01:25:22,000
是看他有没有

2031
01:25:23,000 --> 01:25:25,000
有没有打过出一个知名的工具来

2032
01:25:28,000 --> 01:25:29,000
会看他 GitHub 上面的

2033
01:25:30,000 --> 01:25:31,000
repostory 怎么样

2034
01:25:33,000 --> 01:25:34,000
我想说这

2035
01:25:34,000 --> 01:25:37,000
这些指标的确可以反映出一个人的

2036
01:25:39,000 --> 01:25:39,000
编程能力

2037
01:25:40,000 --> 01:25:41,000
但是

2038
01:25:42,000 --> 01:25:42,000
反过来

2039
01:25:44,000 --> 01:25:45,000
另外有一些编程能力是

2040
01:25:46,000 --> 01:25:48,000
没有办法通过一个 Git repository

2041
01:25:50,000 --> 01:25:52,000
通过一套算法面试题

2042
01:25:52,000 --> 01:25:56,000
或者是通过一篇解释某一个

2043
01:25:57,000 --> 01:25:57,000
比较

2044
01:25:58,000 --> 01:26:00,000
灰色的编程概念能够体现出来的

2045
01:26:02,000 --> 01:26:04,000
而这种能力却恰恰

2046
01:26:04,000 --> 01:26:05,000
很有可能是在

2047
01:26:06,000 --> 01:26:08,000
构建大型程序的时候

2048
01:26:10,000 --> 01:26:11,000
非常需要的

2049
01:26:12,000 --> 01:26:13,000
我觉得这种能力

2050
01:26:13,000 --> 01:26:16,000
的体现其实就在于对于

2051
01:26:17,000 --> 01:26:20,000
比如像设计模式这样一些听起来比较

2052
01:26:22,000 --> 01:26:24,000
大而无当的概念的掌握程度上

2053
01:26:25,000 --> 01:26:27,000
其实我啰嗦这么一大堆想说什么

2054
01:26:27,000 --> 01:26:28,000
我想说的就是

2055
01:26:29,000 --> 01:26:31,000
最开始提出设计模式的四个人

2056
01:26:31,000 --> 01:26:31,000
或者说

2057
01:26:31,000 --> 01:26:35,000
最开始让设计模式这四个字深入人心的

2058
01:26:35,000 --> 01:26:36,000
这四个人

2059
01:26:38,000 --> 01:26:39,000
Eric

2060
01:26:40,000 --> 01:26:42,000
他是个瑞士人

2061
01:26:42,000 --> 01:26:42,000
所以是

2062
01:26:43,000 --> 01:26:44,000
Eric Gamma

2063
01:26:45,000 --> 01:26:46,000
Richard Helm

2064
01:26:46,000 --> 01:26:47,000
Ralph Johnson

2065
01:26:47,000 --> 01:26:51,000
还有 John Vlissides

2066
01:26:52,000 --> 01:26:53,000
这四个人

2067
01:26:53,000 --> 01:26:55,000
他们其实都没有什么

2068
01:26:55,000 --> 01:26:57,000
说出来特别了不起的成绩

2069
01:26:59,000 --> 01:27:02,000
当然 Eric Gamma 是一个比较

2070
01:27:02,000 --> 01:27:03,000
比较重要的人物

2071
01:27:03,000 --> 01:27:04,000
他现在在

2072
01:27:05,000 --> 01:27:07,000
应该是现在应该是在 Microsoft 公司

2073
01:27:08,000 --> 01:27:10,000
这四个人都没有什么

2074
01:27:10,000 --> 01:27:12,000
能够单独摆出来说

2075
01:27:12,000 --> 01:27:14,000
这个人就是做了那件事的那个人

2076
01:27:15,000 --> 01:27:17,000
但是他们四个人毫无疑问都是在

2077
01:27:17,000 --> 01:27:21,000
工业在比较大的软件界

2078
01:27:22,000 --> 01:27:24,000
比较大的软件工程

2079
01:27:24,000 --> 01:27:26,000
项目之中摸拍过哪很多年的人

2080
01:27:27,000 --> 01:27:29,000
才可以写出这样一些比较

2081
01:27:29,000 --> 01:27:30,000
才可以把

2082
01:27:31,000 --> 01:27:33,000
比较重要的设计模式总结

2083
01:27:33,000 --> 01:27:34,000
成这样一本书

2084
01:27:34,000 --> 01:27:38,000
然后展现给大家

2085
01:27:38,000 --> 01:27:40,000
如果你去搜他们四人的资料的话

2086
01:27:42,000 --> 01:27:44,000
其实就找不到什么

2087
01:27:44,000 --> 01:27:47,000
但是并不意味着他们就没有

2088
01:27:48,000 --> 01:27:49,000
能够

2089
01:27:50,000 --> 01:27:51,000
交给别人的东西

2090
01:27:51,000 --> 01:27:54,000
所以 Ralph 你是什么时候接触设计模式

2091
01:27:54,000 --> 01:27:56,000
或者说你根本接触过设计模式

2092
01:27:56,000 --> 01:27:57,000
你使用过设计模式

2093
01:27:58,000 --> 01:27:59,000
没有

2094
01:27:59,000 --> 01:28:01,000
因为其实在我的理解里面

2095
01:28:01,000 --> 01:28:03,000
设计模式这种一般是属于

2096
01:28:03,000 --> 01:28:05,000
一个很大的设计模式

2097
01:28:05,000 --> 01:28:06,000
在我的理解里面

2098
01:28:06,000 --> 01:28:08,000
设计模式这种一般是属于

2099
01:28:08,000 --> 01:28:10,000
这种学 software engineering 的

2100
01:28:10,000 --> 01:28:12,000
专业的人才会去

2101
01:28:12,000 --> 01:28:14,000
去关注的

2102
01:28:14,000 --> 01:28:17,000
甚至这年通常一上 CS

2103
01:28:17,000 --> 01:28:18,000
就是肯定是 science

2104
01:28:18,000 --> 01:28:19,000
他对这个东西

2105
01:28:19,000 --> 01:28:21,000
对这个就没有那么关注

2106
01:28:21,000 --> 01:28:23,000
因为它是一个非常工业化的

2107
01:28:24,000 --> 01:28:25,000
需求对吧

2108
01:28:25,000 --> 01:28:27,000
并不是一个学院化的东西

2109
01:28:28,000 --> 01:28:29,000
对

2110
01:28:29,000 --> 01:28:32,000
所以如果打一个不太恰当的比例

2111
01:28:32,000 --> 01:28:33,000
比方的话

2112
01:28:33,000 --> 01:28:35,000
那就是

2113
01:28:35,000 --> 01:28:37,000
Design Patterns 所描述的是

2114
01:28:38,000 --> 01:28:40,000
你应该盖什么样的房子

2115
01:28:40,000 --> 01:28:42,000
或者说你应该怎样盖房子

2116
01:28:42,000 --> 01:28:45,000
而我们日常在

2117
01:28:46,000 --> 01:28:48,000
至少在学校里面所学到的

2118
01:28:48,000 --> 01:28:49,000
更多的是比如像结构力学

2119
01:28:50,000 --> 01:28:51,000
或者是

2120
01:28:53,000 --> 01:28:54,000
防务造假核算

2121
01:28:54,000 --> 01:28:56,000
这样的一些东西

2122
01:28:56,000 --> 01:28:57,000
对

2123
01:28:58,000 --> 01:28:59,000
这基本上是一个

2124
01:29:00,000 --> 01:29:02,000
艺术和科学之间的分野

2125
01:29:02,000 --> 01:29:03,000
就如果你要

2126
01:29:03,000 --> 01:29:05,000
一定要把它往高达上的方向说的话

2127
01:29:05,000 --> 01:29:07,000
设计模式其实是这样的东西

2128
01:29:08,000 --> 01:29:08,000
然后

2129
01:29:09,000 --> 01:29:11,000
我看设计模式已经是

2130
01:29:13,000 --> 01:29:15,000
10 年前的事了至少

2131
01:29:15,000 --> 01:29:17,000
所以我为了准备这期节目

2132
01:29:17,000 --> 01:29:19,000
也没有把它找出来重新看一遍

2133
01:29:19,000 --> 01:29:20,000
我只记得

2134
01:29:21,000 --> 01:29:23,000
那本书的封面是艾舍尔的画

2135
01:29:24,000 --> 01:29:26,000
艾舍尔是一个荷兰画家

2136
01:29:26,000 --> 01:29:27,000
他的画非常有意思

2137
01:29:28,000 --> 01:29:30,000
然后我对他唯一的印象就是

2138
01:29:30,000 --> 01:29:32,000
就是他封面是那幅画

2139
01:29:32,000 --> 01:29:34,000
然后这四个人合起来

2140
01:29:34,000 --> 01:29:35,000
被叫做四人帮

2141
01:29:36,000 --> 01:29:37,000
刚福尔这个名字其实是

2142
01:29:38,000 --> 01:29:40,000
这本书出来的时候

2143
01:29:41,000 --> 01:29:43,000
中国的文化大革命的

2144
01:29:44,000 --> 01:29:46,000
四人帮这个概念刚刚传到

2145
01:29:46,000 --> 01:29:47,000
国外不久

2146
01:29:47,000 --> 01:29:49,000
所以他们就把这个四人帮的

2147
01:29:49,000 --> 01:29:52,000
称呼拿过来套在了这四人身上

2148
01:29:52,000 --> 01:29:53,000
太倒霉了

2149
01:29:55,000 --> 01:29:57,000
这不是说真的这样

2150
01:29:57,000 --> 01:29:58,000
我知道他们太倒霉了

2151
01:30:01,000 --> 01:30:04,000
我觉得可能英语世界的人

2152
01:30:04,000 --> 01:30:06,000
不太能够理解四人帮在

2153
01:30:06,000 --> 01:30:09,000
至少在中国语境之下

2154
01:30:09,000 --> 01:30:11,000
说出来是一个

2155
01:30:11,000 --> 01:30:14,000
多么负面和恐怖的词

2156
01:30:15,000 --> 01:30:16,000
也觉得他们看来

2157
01:30:16,000 --> 01:30:18,000
真的就是一个杠而已

2158
01:30:19,000 --> 01:30:22,000
然后我记得如果我没记错的话

2159
01:30:22,000 --> 01:30:24,000
他们在前沿里面提到了

2160
01:30:25,000 --> 01:30:25,000
一本书

2161
01:30:26,000 --> 01:30:29,000
这本书是来自于建筑专业的

2162
01:30:30,000 --> 01:30:32,000
一本讲述

2163
01:30:33,000 --> 01:30:34,000
怎么说呢

2164
01:30:34,000 --> 01:30:36,000
建筑方法论那本书

2165
01:30:36,000 --> 01:30:37,000
这本书叫做

2166
01:30:37,000 --> 01:30:38,000
建筑永恒之道

2167
01:30:38,000 --> 01:30:40,000
The timeless way of building

2168
01:30:42,000 --> 01:30:44,000
之后在一个很机缘巧合

2169
01:30:44,000 --> 01:30:46,000
场景下我拿到那本书的中文版

2170
01:30:47,000 --> 01:30:49,000
翻译一下觉得没有

2171
01:30:50,000 --> 01:30:52,000
这个没有设计模式这本书

2172
01:30:52,000 --> 01:30:55,000
没吹加引号的那么神奇

2173
01:30:59,000 --> 01:31:01,000
而且我也不是很推荐大家去看

2174
01:31:01,000 --> 01:31:03,000
因为如果你不结合

2175
01:31:04,000 --> 01:31:09,000
这本书当时的 context 的话

2176
01:31:09,000 --> 01:31:11,000
是挺难理解的一本书

2177
01:31:11,000 --> 01:31:13,000
这本书出版于 1979 年

2178
01:31:13,000 --> 01:31:17,000
就比 90 年代的面相模式

2179
01:31:20,000 --> 01:31:22,000
设计模式还要早是 20 年

2180
01:31:27,000 --> 01:31:28,000
总的来说

2181
01:31:28,000 --> 01:31:29,000
建筑永恒之道这本书

2182
01:31:29,000 --> 01:31:31,000
美人所试图表达的一个观点

2183
01:31:31,000 --> 01:31:34,000
就是你在造建筑的时候

2184
01:31:34,000 --> 01:31:38,000
你必须想方设法的去达到一种

2185
01:31:39,000 --> 01:31:42,000
没有办法定义的 quality

2186
01:31:44,000 --> 01:31:46,000
有点像那个神棍书

2187
01:31:46,000 --> 01:31:50,000
就是禅玉摩托车维护的艺术里面

2188
01:31:50,000 --> 01:31:51,000
所提到的所谓良知

2189
01:31:52,000 --> 01:31:56,000
你要使你的建筑能够体现出这样一种

2190
01:31:56,000 --> 01:31:58,000
你说它是美也好

2191
01:31:58,000 --> 01:31:59,000
说它是道也好

2192
01:31:59,000 --> 01:32:01,000
这样一种质量

2193
01:32:02,000 --> 01:32:05,000
而为了达成这种质量

2194
01:32:05,000 --> 01:32:07,000
你必须遵循一些特定的模式

2195
01:32:08,000 --> 01:32:09,000
然后这个概念

2196
01:32:09,000 --> 01:32:11,000
这个 design pattern 的概念

2197
01:32:11,000 --> 01:32:13,000
就源自于这本书

2198
01:32:15,000 --> 01:32:19,000
1994 年四位作者所写的设计模式

2199
01:32:19,000 --> 01:32:20,000
或者说全称叫做

2200
01:32:21,000 --> 01:32:27,000
如何构建更好的面向对象的程序

2201
01:32:28,000 --> 01:32:30,000
也就借用这个概念

2202
01:32:30,000 --> 01:32:32,000
是想要总结出一些

2203
01:32:32,000 --> 01:32:35,000
在使用面向对象的技术来写程序的时候

2204
01:32:35,000 --> 01:32:40,000
人们应该遵循的一些比较常见的技巧和方法

2205
01:32:43,000 --> 01:32:45,000
这基本上就是一个对于设计模式

2206
01:32:45,000 --> 01:32:49,000
不那么教科书式的介绍

2207
01:32:50,000 --> 01:32:52,000
至少大概就是我的意见

2208
01:32:53,000 --> 01:32:56,000
所以其实如果我们接着拿那个建筑

2209
01:32:56,000 --> 01:32:58,000
那个例子来做对比的话

2210
01:32:58,000 --> 01:32:59,000
所谓设计模式

2211
01:32:59,000 --> 01:33:02,000
会就是说有一堆老师傅告诉你说

2212
01:33:02,000 --> 01:33:04,000
你看我跟你说

2213
01:33:04,000 --> 01:33:05,000
你这个什么

2214
01:33:06,000 --> 01:33:08,000
这个墙得这么弃

2215
01:33:08,000 --> 01:33:10,000
它才会稳固才会倒

2216
01:33:10,000 --> 01:33:12,000
你要按你那个方法弃也可以

2217
01:33:12,000 --> 01:33:14,000
但是可能就是那个什么

2218
01:33:14,000 --> 01:33:16,000
不太结实一推就倒了

2219
01:33:17,000 --> 01:33:18,000
这总是一个

2220
01:33:18,000 --> 01:33:22,000
把过往的经验抽象出来

2221
01:33:22,000 --> 01:33:24,000
叫怎么来的

2222
01:33:25,000 --> 01:33:26,000
就是成为一个

2223
01:33:27,000 --> 01:33:29,000
可以被后人学习的这么一个东西

2224
01:33:30,000 --> 01:33:32,000
对可以这么说

2225
01:33:32,000 --> 01:33:34,000
但我要强调的一点就是

2226
01:33:34,000 --> 01:33:35,000
设计模式是一个比较

2227
01:33:37,000 --> 01:33:39,000
在更高的抽象层级上

2228
01:33:39,000 --> 01:33:40,000
工作的这样一种技术

2229
01:33:40,000 --> 01:33:42,000
就是你说的弃强

2230
01:33:42,000 --> 01:33:46,000
我觉得可能更合适的比喻是

2231
01:33:46,000 --> 01:33:47,000
比如说 Hacker's Delight

2232
01:33:47,000 --> 01:33:51,000
或者是 Program Perl

2233
01:33:51,000 --> 01:33:53,000
就是编程猪鸡

2234
01:33:53,000 --> 01:33:56,000
这本书里面所讲的那些技巧

2235
01:33:56,000 --> 01:33:58,000
就是在一些比较

2236
01:34:00,000 --> 01:34:04,000
比较颗粒度比较小的级别上面

2237
01:34:04,000 --> 01:34:06,000
告诉你怎样写出质量更好的代码

2238
01:34:07,000 --> 01:34:09,000
而设计模式则更多的是在

2239
01:34:09,000 --> 01:34:12,000
比较高级的层面上

2240
01:34:12,000 --> 01:34:14,000
比如说沿用建筑的比方的话

2241
01:34:14,000 --> 01:34:15,000
那可能建筑模式

2242
01:34:15,000 --> 01:34:16,000
设计模式

2243
01:34:16,000 --> 01:34:17,000
所要表达的是

2244
01:34:17,000 --> 01:34:19,000
比如说你要怎样用两个

2245
01:34:19,000 --> 01:34:24,000
怎样用一个长廊连接两个屋子

2246
01:34:24,000 --> 01:34:26,000
然后你把屋子摆成这样

2247
01:34:26,000 --> 01:34:31,000
会给人一种什么样的印象

2248
01:34:31,000 --> 01:34:34,000
让起居者会有怎样的动线

2249
01:34:34,000 --> 01:34:38,000
乃至于你造的屋子

2250
01:34:38,000 --> 01:34:41,000
要怎样才能跟周围的环境融合起来

2251
01:34:42,000 --> 01:34:45,000
怎样才能保证说你要符合当地的

2252
01:34:46,000 --> 01:34:47,000
比如说风水

2253
01:34:47,000 --> 01:34:48,000
或者是要比如

2254
01:34:49,000 --> 01:34:52,000
要怎样才能不去破坏周围的植被

2255
01:34:52,000 --> 01:34:54,000
乃至于怎样故意的

2256
01:34:54,000 --> 01:34:57,000
让你的建筑和周围的建筑产生一定的反差

2257
01:34:57,000 --> 01:35:02,000
比如说北京的大剧院

2258
01:35:02,000 --> 01:35:05,000
或者是杜玉明做的卢浮宫的入口

2259
01:35:06,000 --> 01:35:06,000
诸如此类的东西

2260
01:35:07,000 --> 01:35:09,000
设计模式逃动是这样一种东西

2261
01:35:09,000 --> 01:35:11,000
就是更接近于艺术性的东西

2262
01:35:12,000 --> 01:35:15,000
但是与此同时它又没有那么的

2263
01:35:17,000 --> 01:35:18,000
渺渺

2264
01:35:18,000 --> 01:35:19,000
有时候我觉得

2265
01:35:20,000 --> 01:35:23,000
当然我对建筑只是比较奇怪的

2266
01:35:23,000 --> 01:35:25,000
有比较奇怪的兴趣

2267
01:35:25,000 --> 01:35:26,000
但是有时候我会觉得建筑里面的模式

2268
01:35:26,000 --> 01:35:28,000
是非常难以总结和复用的

2269
01:35:29,000 --> 01:35:31,000
而且建筑的艺术性太强了

2270
01:35:31,000 --> 01:35:33,000
建筑师会倾向于用

2271
01:35:34,000 --> 01:35:39,000
比较有个性化的方法去诠释所谓的设计模式

2272
01:35:39,000 --> 01:35:42,000
但是在软件工程的设计模式里面

2273
01:35:42,000 --> 01:35:47,000
基本上每一个模式都是不那么风格化的

2274
01:35:48,000 --> 01:35:49,000
比如说

2275
01:35:51,000 --> 01:35:52,000
你也写 Visitor Pattern

2276
01:35:52,000 --> 01:35:54,000
我也写 Visitor Pattern

2277
01:35:54,000 --> 01:35:54,000
都一样

2278
01:35:54,000 --> 01:35:56,000
你哪怕起另外一个名字

2279
01:35:57,000 --> 01:35:58,000
玫瑰一千种名字

2280
01:35:59,000 --> 01:36:01,000
它还是那样一个东西

2281
01:36:01,000 --> 01:36:04,000
就是如果你接触这个模式

2282
01:36:04,000 --> 01:36:06,000
别人哪怕换一个名字来写

2283
01:36:06,000 --> 01:36:08,000
你还是可以意识到就是那个模式本身

2284
01:36:09,000 --> 01:36:11,000
它没有那么多的艺术价值

2285
01:36:11,000 --> 01:36:12,000
所以总结来说

2286
01:36:14,000 --> 01:36:17,000
设计模式基本上就是比较高层次的

2287
01:36:18,000 --> 01:36:20,000
被总结出来的凝固的 Best Practice

2288
01:36:21,000 --> 01:36:24,000
然后它的意义就是可以在帮助你

2289
01:36:25,000 --> 01:36:28,000
告诉你在各种情况之下怎样能比较好

2290
01:36:30,000 --> 01:36:31,000
构建你的代码

2291
01:36:31,000 --> 01:36:34,000
然后让你的代码之间节要

2292
01:36:34,000 --> 01:36:35,000
因为

2293
01:36:36,000 --> 01:36:38,000
设计模式的两大要素

2294
01:36:38,000 --> 01:36:43,000
就是一个是要 Program to Interface

2295
01:36:43,000 --> 01:36:44,000
Not an Implementation

2296
01:36:44,000 --> 01:36:51,000
另一个就是 Prefer object Composition over inheritance

2297
01:36:51,000 --> 01:36:58,000
就是你要针对这个界面而非实现来变成

2298
01:36:58,000 --> 01:36:59,000
另外一方面

2299
01:36:59,000 --> 01:37:02,000
你要更多的使用 object Composition

2300
01:37:02,000 --> 01:37:06,000
就是你要让一个 object 去包含另外一个 object

2301
01:37:06,000 --> 01:37:10,000
而不是让一个 object 继承自另外一个 object

2302
01:37:10,000 --> 01:37:12,000
我觉得这两点其实

2303
01:37:13,000 --> 01:37:17,000
算是过了这么久一直颠覆不破的两个真理

2304
01:37:18,000 --> 01:37:23,000
而且你如果从这个角度去反观很多设计的话

2305
01:37:23,000 --> 01:37:25,000
你会觉得很多设计都是有问题

2306
01:37:27,000 --> 01:37:28,000
我不知道你怎么看

2307
01:37:28,000 --> 01:37:32,000
但至少 object Composition over inheritance

2308
01:37:32,000 --> 01:37:37,000
这一点在 objective C 里面体现的非常明显

2309
01:37:40,000 --> 01:37:41,000
不应该这么说

2310
01:37:41,000 --> 01:37:43,000
应该说 objective C 的一个库

2311
01:37:43,000 --> 01:37:46,000
也就是苹果用的 Cocoa 库里面

2312
01:37:46,000 --> 01:37:47,000
这一点体现的比较明显

2313
01:37:49,000 --> 01:37:54,000
Cocoa 的所有的用力基本上都在推荐你使用 Composition

2314
01:37:54,000 --> 01:38:02,000
很少会说你来继承一下我的这样一个积累

2315
01:38:02,000 --> 01:38:07,000
然后通过继承方法来实现你自己的一些用逻辑

2316
01:38:07,000 --> 01:38:09,000
可是反过来在胡佑黑诈

2317
01:38:10,000 --> 01:38:13,000
在这样的世界里面你会发现很多人

2318
01:38:13,000 --> 01:38:15,000
尤其在 G 2 E 的世界里面有很多东西

2319
01:38:15,000 --> 01:38:19,000
很多时候你都是被逼着使用 inheritance

2320
01:38:19,000 --> 01:38:24,000
然后你会大量的去找说目前这个类

2321
01:38:24,000 --> 01:38:26,000
inheritance 的 true 是怎么样的

2322
01:38:26,000 --> 01:38:27,000
它上面继承了谁

2323
01:38:27,000 --> 01:38:29,000
下面又被谁继承

2324
01:38:29,000 --> 01:38:32,000
然后导致你迁移发而动绝身

2325
01:38:32,000 --> 01:38:33,000
然后这个时候你再回头来看

2326
01:38:35,000 --> 01:38:39,000
Design Pattern 这本书里面所强调 object Composition over inheritance

2327
01:38:39,000 --> 01:38:43,000
你会觉得何苦

2328
01:38:43,000 --> 01:38:44,000
真的是

2329
01:38:44,000 --> 01:38:50,000
对这个可能也是就为什么大家一直在黑 Java 的一个重要的原因

2330
01:38:50,000 --> 01:38:56,000
就是你总感我总有一种感觉就是 Java 本身还是挺好的

2331
01:38:56,000 --> 01:39:03,000
但是被一堆被 OOP 邪教迷惑了的人在那里

2332
01:39:03,000 --> 01:39:07,000
在 Java 平台上写一些东西出来

2333
01:39:07,000 --> 01:39:08,000
搞得非常臃肿不堪

2334
01:39:08,000 --> 01:39:10,000
然后也不是很灵活

2335
01:39:11,000 --> 01:39:13,000
对我前两天在 HackNews 上看了一个

2336
01:39:14,000 --> 01:39:17,000
News Group 里面的八卦

2337
01:39:18,000 --> 01:39:23,000
Java 设计员的设计者的第二设计者

2338
01:39:23,000 --> 01:39:29,000
就是起到了一些语法方面的决策作用的一个人

2339
01:39:29,000 --> 01:39:32,000
叫什么人

2340
01:39:32,000 --> 01:39:32,000
Norton

2341
01:39:32,000 --> 01:39:33,000
他应该姓 Norton

2342
01:39:33,000 --> 01:39:36,000
他是一个志泽科技术这个名字

2343
01:39:36,000 --> 01:39:39,000
是因为他在 90 年代末期有过一桩非常有名的炼铜案件

2344
01:39:40,000 --> 01:39:45,000
他坐着私人的喷气机去迪斯尼

2345
01:39:46,000 --> 01:39:48,000
会一个 13 岁的小女孩

2346
01:39:48,000 --> 01:39:53,000
并且要求这个小女孩跳脱衣舞

2347
01:39:55,000 --> 01:39:58,000
还是做一些别的什么事情

2348
01:39:58,000 --> 01:40:02,000
然后后来这个小女孩其实是 FBI 的一个侦探

2349
01:40:03,000 --> 01:40:05,000
只是看起来比较小

2350
01:40:05,000 --> 01:40:07,000
然后隐藏了自己的身份证明

2351
01:40:07,000 --> 01:40:09,000
然后这个人被告到法庭上

2352
01:40:09,000 --> 01:40:12,000
最后的处罚好像挺荒诞的

2353
01:40:12,000 --> 01:40:17,000
是让他免费为 FBI 工作一年之类的这名处

2354
01:40:18,000 --> 01:40:20,000
然后打个岔

2355
01:40:20,000 --> 01:40:22,000
这个人他是 Java 的语言的发明者

2356
01:40:22,000 --> 01:40:23,000
然后他在

2357
01:40:23,000 --> 01:40:24,000
之一

2358
01:40:24,000 --> 01:40:27,000
他在 News Group 里面提到说

2359
01:40:28,000 --> 01:40:33,000
Java 其实受到了非常严重的 objective C 的影响

2360
01:40:34,000 --> 01:40:40,000
但是这种影响很显然仅仅局限在语言的特性上

2361
01:40:40,000 --> 01:40:43,000
比如说它有很多动态的机制

2362
01:40:44,000 --> 01:40:51,000
每个方法都是存储在 class 内部的一个 field 之类

2363
01:40:51,000 --> 01:40:55,000
但是这样一种语言所衍生出来的两个库

2364
01:40:55,000 --> 01:40:57,000
确实大相径定了

2365
01:40:57,000 --> 01:41:03,000
比如说在 Java 的整个类库里面

2366
01:41:04,000 --> 01:41:10,000
在很多时候都是和这个 objective C 所衍生出来的最广泛使用的类库

2367
01:41:11,000 --> 01:41:15,000
完全不相像的一些设计哲学的系组

2368
01:41:16,000 --> 01:41:20,000
这也是我之前在用 Scalar 的时候遇到的一个问题

2369
01:41:20,000 --> 01:41:23,000
就是因为 Scalar 是解剖的这一边

2370
01:41:23,000 --> 01:41:27,000
它也是比较能够方便调用 Java 的那些

2371
01:41:27,000 --> 01:41:30,000
用 Java 写的那些包

2372
01:41:30,000 --> 01:41:31,000
对

2373
01:41:31,000 --> 01:41:38,000
然后你会发现它一旦到了你用别人一个针对 Java 写的这么一个包的时候

2374
01:41:38,000 --> 01:41:43,000
它的一些接口整个设计哲学就完全是一种纯 OOP 的思维

2375
01:41:43,000 --> 01:41:49,000
然后 Scalar 它是一个 OOP 加 FP 混合的这么一种范式的语言

2376
01:41:49,000 --> 01:41:52,000
就用起来非常非常边缘

2377
01:41:52,000 --> 01:41:55,000
你需要在两种思维范式之间切换吗

2378
01:41:55,000 --> 01:41:56,000
对

2379
01:41:56,000 --> 01:41:59,000
有时候你会看到为什么 Java 这不是傻逼吗

2380
01:41:59,000 --> 01:41:59,000
为什么这么设计

2381
01:41:59,000 --> 01:42:04,000
但其实主要的原因就是说 Java 语言本身有一些特殊的限制

2382
01:42:04,000 --> 01:42:10,000
导致不那么写反而可能重用和这个叫什么来着

2383
01:42:10,000 --> 01:42:12,000
代码的构码也没有那么灵活

2384
01:42:12,000 --> 01:42:17,000
但是你到一个更加灵活的语言里面去看

2385
01:42:17,000 --> 01:42:23,000
然后 Java 那种设计那种限制导致出来的接口的设计其实非常笨拙

2386
01:42:25,000 --> 01:42:26,000
是

2387
01:42:26,000 --> 01:42:28,000
其实我最近在写 Swift 的时候有种感觉

2388
01:42:29,000 --> 01:42:32,000
因为 Swift 目前的状态还是有

2389
01:42:33,000 --> 01:42:35,000
虽然在之间减少

2390
01:42:35,000 --> 01:42:43,000
但还是有一部分东西是要跟 Coco 或者是跟底层的 OBJECT C 的代码实现相交互的

2391
01:42:43,000 --> 01:42:50,000
然后这个时候你会发现你会感觉到一种从文法上面

2392
01:42:50,000 --> 01:42:58,000
不是文法是从 literacy 上面就可以感受到两者的冲撞

2393
01:42:59,000 --> 01:43:02,000
Swift 的很多东西都是非常简洁的

2394
01:43:02,000 --> 01:43:04,000
比如说 function 这个词都不愿意拼好

2395
01:43:04,000 --> 01:43:05,000
写个 func

2396
01:43:05,000 --> 01:43:10,000
然后或者有很多 shortcut 比如说最新的什么 fall

2397
01:43:11,000 --> 01:43:14,000
x in y where z

2398
01:43:14,000 --> 01:43:16,000
然后你可以少写一个

2399
01:43:16,000 --> 01:43:26,000
你可以通过这个 filter 直接在 loop 体的外面就把一些边界条件过去掉

2400
01:43:26,000 --> 01:43:30,000
但是当你采用这样一种简洁的写法写程序正爽的时候

2401
01:43:30,000 --> 01:43:33,000
忽然跳到一个地方你需要呼叫一个 obj

2402
01:43:33,000 --> 01:43:38,000
一看就是 OBJECT C 时代留下的 API 的时候

2403
01:43:39,000 --> 01:43:40,000
这个 API 的名字是怒场

2404
01:43:42,000 --> 01:43:43,000
觉得很另类是不是

2405
01:43:43,000 --> 01:43:49,000
对 String by appending another string with format 之类的这样一个非常长的

2406
01:43:51,000 --> 01:43:53,000
如果没有这自动提示真的是

2407
01:43:54,000 --> 01:43:58,000
杀了我们的新出来的对这样一喊出名出来

2408
01:43:58,000 --> 01:44:04,000
你就可以明显地感觉到这两种编程思维在冲撞

2409
01:44:05,000 --> 01:44:09,000
但所幸目前看来 Swift 的更新速度还是比较快的

2410
01:44:09,000 --> 01:44:20,000
也许在比较足够近的将来我们就可以使用一些比较有更多的 Swiftness 在里面的 API

2411
01:44:21,000 --> 01:44:26,000
但现在不是上次 WC 说的时候是他们也逐渐把那些

2412
01:44:27,000 --> 01:44:30,000
Cocoa 那些底层的酷要叫做 Swift 化了吗

2413
01:44:31,000 --> 01:44:36,000
对就是按照 Swift 方法给一个这种新的接口就不要用那种原用

2414
01:44:36,000 --> 01:44:39,000
你确实很用起来真的很别扭

2415
01:44:40,000 --> 01:44:48,000
对我乐观估计这个大概需要三到五年是果然很乐观

2416
01:44:48,000 --> 01:44:50,000
不是五到十年吗

2417
01:44:51,000 --> 01:44:53,000
我觉得三到五年应该差不多

2418
01:44:53,000 --> 01:44:56,000
对因为看他们决心怎么样

2419
01:44:56,000 --> 01:45:01,000
我觉得还是要看他们对于新产品的投入以及对于改这个

2420
01:45:03,000 --> 01:45:08,000
偿还技术债务的投入之间找到的平衡怎么样

2421
01:45:08,000 --> 01:45:13,000
但也像你说你说目前采用这个叫什么 Tic Tac 的策略

2422
01:45:14,000 --> 01:45:26,000
一年发布新产品一次发出新产品另一次做维护做升级修复既有产品的账额

2423
01:45:26,000 --> 01:45:30,000
缺陷我觉得这个策略还是挺好但就可能保持得怎么样

2424
01:45:31,000 --> 01:45:36,000
说回这个设计模式其实有一点我一直有点疑惑

2425
01:45:36,000 --> 01:45:40,000
其实我也是看很多人对设计模式的批评

2426
01:45:40,000 --> 01:45:44,000
就是说至少在那本书里面的很多设计模式

2427
01:45:44,000 --> 01:45:51,000
其实很它的存在的意义仅仅是因为 Java 这个语言本身的一些限制所导致的

2428
01:45:51,000 --> 01:45:56,000
不过设计模式写出来的时候其实是被 CC 加写的

2429
01:45:57,000 --> 01:46:00,000
之类的就是两个动用所以静态语言

2430
01:46:00,000 --> 01:46:08,000
然后有一些所谓动态语言的鼓吹的就说你费劲搞那么多各种各样的 pattern

2431
01:46:09,000 --> 01:46:12,000
你看我们动态语言里面根本不用操心这个问题

2432
01:46:12,000 --> 01:46:16,000
我一个列表我就是可以装多种不同类型的元素你把我咋地对吧

2433
01:46:17,000 --> 01:46:25,000
对其实这也是一种正确的理解就是编程里面设计模式在很多时候

2434
01:46:26,000 --> 01:46:36,000
与其说是一种做事情方法倒不如说是因为语言没有办法让你欢快乐的做某事

2435
01:46:36,000 --> 01:46:48,000
你不得不先以一种比较约定俗成的一种比较经过考验的 best practice 把这件事情做出来

2436
01:46:49,000 --> 01:46:56,000
没错每期名曰设计模式但其实它只是一个秘制而已

2437
01:46:56,000 --> 01:47:02,000
前人在这条路上躺过了才拢出个坑发现这个坑的副作用是最小的

2438
01:47:03,000 --> 01:47:07,000
告诉后人说来我插个小钱在这里别走那边那几个坑

2439
01:47:07,000 --> 01:47:10,000
此处有雷请这样绕行

2440
01:47:10,000 --> 01:47:15,000
对给人家画了一条我们现在抽象出脑子这边是一条路

2441
01:47:15,000 --> 01:47:22,000
你要从地图的左下角穿到右上角去但是雷区遍地你不知道吗新的你可能跟着踩一下就死了

2442
01:47:22,000 --> 01:47:29,000
所以前人在踏着堆堆白骨的技术上总结出一条非常曲折绕的方法

2443
01:47:29,000 --> 01:47:35,000
可以带你顺利到达这个目的地对吧这就是我们所谓的设计模式

2444
01:47:36,000 --> 01:47:40,000
但是其实我就很多对设计模式的批评者来看

2445
01:47:40,000 --> 01:47:47,000
你费那么多精力搞这个仅仅是因为你语言不够好你画一个好一点语言不就没这么多事了吗

2446
01:47:47,000 --> 01:47:54,000
对就像在沿用这个比方的话你要从 A 点到达 B 点在你发展

2447
01:47:54,000 --> 01:48:00,000
你发展出隧道绝境技术之前你不都不在山上绕一圈

2448
01:48:00,000 --> 01:48:03,000
可是如果你能挖条隧道的话那就不用了

2449
01:48:04,000 --> 01:48:10,000
比如说我觉得这个地方其实可以举起例子你刚才说的动态语言

2450
01:48:11,000 --> 01:48:16,000
比相对来说更为强大的容器类型是一个好例子

2451
01:48:16,000 --> 01:48:24,000
但另外一方面比如说原始的设计模式里面有个叫做 Observer 的模式

2452
01:48:25,000 --> 01:48:31,000
一个人做一个类作为 Observer 的注册者

2453
01:48:32,000 --> 01:48:34,000
他来生产一定的消息

2454
01:48:34,000 --> 01:48:44,000
然后另外一些这个 Observer 作为这个 Observer 来去注册这个

2455
01:48:45,000 --> 01:48:52,000
像这个对象注册说我对你的某一些消息感兴趣如果你这个消息请通知我

2456
01:48:53,000 --> 01:48:58,000
在 Java 里面这一边是当作或者说 CNN 里面是当作一个模式来用的

2457
01:48:58,000 --> 01:48:59,000
但是到了 Syshap 这一步

2458
01:49:00,000 --> 01:49:06,000
我们都知道 Syshap 脱胎于 Java 或者说它汲取了 Java 的优点

2459
01:49:07,000 --> 01:49:08,000
如果 Java 有什么优点的话

2460
01:49:10,000 --> 01:49:17,000
Syshap 内置有所谓 Delegate Event 这两个在语言层面上实现的

2461
01:49:18,000 --> 01:49:19,000
怎么说呢

2462
01:49:19,000 --> 01:49:20,000
抽象概念

2463
01:49:21,000 --> 01:49:25,000
有了这个语言结构出来 Observer 模式就没有用了

2464
01:49:25,000 --> 01:49:28,000
因为你自己不需要去构建这个 Observer 的模式

2465
01:49:28,000 --> 01:49:34,000
你只需要直接使用 Syshap 内部的这两个语法堂就可以了

2466
01:49:37,000 --> 01:49:38,000
你还能想到一个别的

2467
01:49:38,000 --> 01:49:40,000
其实这个事情顺着说下去

2468
01:49:40,000 --> 01:49:46,000
你这种经常在这种设计 UI 界面的情况用的非常多

2469
01:49:46,000 --> 01:49:49,000
现在新的思潮是什么来的

2470
01:49:49,000 --> 01:49:52,000
就是什么 FRP Functional Reactive Programming

2471
01:49:53,000 --> 01:49:55,000
他连这种叫什么来的

2472
01:49:56,000 --> 01:49:59,000
这种交互式的观察者

2473
01:49:59,000 --> 01:50:00,000
还有是被观察者

2474
01:50:00,000 --> 01:50:02,000
就是注册这种事情都直接就免了

2475
01:50:03,000 --> 01:50:04,000
我们全部单向流

2476
01:50:06,000 --> 01:50:09,000
完全是不同意的一种思路在做这个事情

2477
01:50:10,000 --> 01:50:12,000
你会发现其实有些设计模式

2478
01:50:12,000 --> 01:50:16,000
其实也是非常在观念上是比较成就的一个东西

2479
01:50:17,000 --> 01:50:23,000
当然我们现在总是站在一种马虎炮的这个角度去

2480
01:50:24,000 --> 01:50:26,000
说设计模式里面有些模式

2481
01:50:26,000 --> 01:50:28,000
其实根本就是在修语言

2482
01:50:28,000 --> 01:50:30,000
或者是有些模式根本过时了

2483
01:50:31,000 --> 01:50:33,000
但是在 90 年代的时候

2484
01:50:33,000 --> 01:50:38,000
这本书还是影响了整整一代必须说

2485
01:50:39,000 --> 01:50:40,000
而且在这本书之后

2486
01:50:40,000 --> 01:50:44,000
也其实出现了很多其他的设计模式

2487
01:50:44,000 --> 01:50:48,000
比如说这本书一上来就提到了 MVC 模式

2488
01:50:48,000 --> 01:50:50,000
在接下来的很多年里面

2489
01:50:50,000 --> 01:50:52,000
首先它有很多种不同的解读

2490
01:50:52,000 --> 01:50:58,000
基本上每两个程序员对于 MVC 解读都是不一样的

2491
01:51:00,000 --> 01:51:03,000
甚至后来也由 MVC 衍生出来

2492
01:51:03,000 --> 01:51:04,000
比如什么 MVVM

2493
01:51:08,000 --> 01:51:09,000
很多其他莫名其妙

2494
01:51:09,000 --> 01:51:10,000
我现在也想不起来的缩写

2495
01:51:11,000 --> 01:51:15,000
都是脱胎原文为 MVC 这样一种模式的

2496
01:51:17,000 --> 01:51:19,000
以至于很多语言本身也会说

2497
01:51:20,000 --> 01:51:21,000
在使用这种语言的时候

2498
01:51:21,000 --> 01:51:23,000
我会有一个特别的模式

2499
01:51:23,000 --> 01:51:28,000
比如说我记得以前看过一个是 Python patterns

2500
01:51:30,000 --> 01:51:32,000
总结了使用 Python 编程的时候

2501
01:51:33,000 --> 01:51:35,000
能够经常使用到的新 Python

2502
01:51:35,000 --> 01:51:36,000
我印象很深

2503
01:51:36,000 --> 01:51:40,000
真的是里面有叫做 Cyborg 的 Python

2504
01:51:41,000 --> 01:51:46,000
Cyborg 就是那个星际迷航 Star Trek 里面有一个种族叫 Cyborg

2505
01:51:46,000 --> 01:51:51,000
他们的个体没有个体的意识

2506
01:51:51,000 --> 01:51:56,000
然后他们战斗力非常强

2507
01:51:56,000 --> 01:51:57,000
然后他们每征服一个种族

2508
01:51:57,000 --> 01:52:04,000
就把这个种族里面的每个个体融合到他们的一个 Mastermind

2509
01:52:05,000 --> 01:52:06,000
他们只有一个集体意识

2510
01:52:06,000 --> 01:52:09,000
然后个体服从一集体

2511
01:52:09,000 --> 01:52:17,000
然后 Cyborg 这个名字就被借用来描述这样一种 Python 的设计模式

2512
01:52:17,000 --> 01:52:24,000
就是很多 object 共享一个 global 的 state

2513
01:52:28,000 --> 01:52:29,000
然后还有比如说

2514
01:52:29,000 --> 01:52:35,000
我前年看了一本 Coco pattern

2515
01:52:35,000 --> 01:52:36,000
Coco design pattern

2516
01:52:36,000 --> 01:52:41,000
也是讲在 Coco 里面经常被用到的一些模式

2517
01:52:41,000 --> 01:52:44,000
比如说 observer 模式

2518
01:52:44,000 --> 01:52:45,000
不是 observer

2519
01:52:45,000 --> 01:52:46,000
Coco 叫什么

2520
01:52:46,000 --> 01:52:48,000
Delegation 模式

2521
01:52:48,000 --> 01:52:53,000
乃至于在 Coco 下面的 MVC 模式

2522
01:52:54,000 --> 01:52:56,000
以及比如说

2523
01:52:56,000 --> 01:53:00,000
在写 objectc 的时候

2524
01:53:00,000 --> 01:53:04,000
经常会用到一个 selector

2525
01:53:04,000 --> 01:53:05,000
然后你会说

2526
01:53:05,000 --> 01:53:08,000
我需要延迟一点时间来执行 selector

2527
01:53:08,000 --> 01:53:10,000
诸如此类这样一些模式

2528
01:53:10,000 --> 01:53:12,000
在这本书里面介绍了

2529
01:53:12,000 --> 01:53:16,000
可以说从试者模式这本书开始之后

2530
01:53:16,000 --> 01:53:21,000
陆陆续续人们才开始着眼于总结出

2531
01:53:21,000 --> 01:53:24,000
使用某一种特定工具的时候

2532
01:53:24,000 --> 01:53:28,000
应该使用一些最佳实践

2533
01:53:28,000 --> 01:53:29,000
然后把他们总结下来

2534
01:53:29,000 --> 01:53:31,000
把他们汇总出来

2535
01:53:31,000 --> 01:53:36,000
起上某某 domain 之下的设计模式

2536
01:53:36,000 --> 01:53:37,000
这样一个名字

2537
01:53:37,000 --> 01:53:39,000
OK

2538
01:53:39,000 --> 01:53:41,000
所以其实我有一点很疑惑的

2539
01:53:41,000 --> 01:53:42,000
就是说

2540
01:53:42,000 --> 01:53:46,000
你觉得对于一个某一个工具也好

2541
01:53:46,000 --> 01:53:47,000
某一个语言也好

2542
01:53:47,000 --> 01:53:48,000
对于一个新手来说

2543
01:53:48,000 --> 01:53:51,000
设计模式这个东西有多大的意义

2544
01:53:51,000 --> 01:53:54,000
因为我一直是抱着这么一种想法

2545
01:53:54,000 --> 01:53:55,000
刚刚我们说

2546
01:53:55,000 --> 01:53:59,000
这个是一个在一个布满雷区的地图上

2547
01:53:59,000 --> 01:54:00,000
给你画了条线这么一个功能

2548
01:54:00,000 --> 01:54:01,000
对吧

2549
01:54:01,000 --> 01:54:03,000
但是其实对于很多新手来讲

2550
01:54:03,000 --> 01:54:04,000
你不让他去犯那些错误

2551
01:54:04,000 --> 01:54:06,000
他是永远都不知道为什么会这样

2552
01:54:06,000 --> 01:54:08,000
为什么会有另外一种方式来做

2553
01:54:08,000 --> 01:54:09,000
会更好

2554
01:54:09,000 --> 01:54:10,000
看起来可能更曲折

2555
01:54:10,000 --> 01:54:12,000
但结果可能会更加好

2556
01:54:12,000 --> 01:54:15,000
就是没有这么一个学习的过程

2557
01:54:15,000 --> 01:54:17,000
就是我们强行给他灌了一碗鸡汤

2558
01:54:17,000 --> 01:54:19,000
说喝这个对你有益

2559
01:54:19,000 --> 01:54:20,000
别问为什么

2560
01:54:20,000 --> 01:54:22,000
但是他心里一定有无数个为什么

2561
01:54:22,000 --> 01:54:23,000
没错

2562
01:54:23,000 --> 01:54:25,000
就是如果你没有踩过雷的话

2563
01:54:25,000 --> 01:54:27,000
是不知道被雷炸死有多疼

2564
01:54:30,000 --> 01:54:33,000
而设计模式其实并不是一个适合

2565
01:54:33,000 --> 01:54:36,000
你刚刚学会编程的时候就看的东西

2566
01:54:36,000 --> 01:54:39,000
因为我觉得

2567
01:54:39,000 --> 01:54:41,000
我自己可能也是看设计模式的时候

2568
01:54:41,000 --> 01:54:43,000
比较道行还不够深

2569
01:54:43,000 --> 01:54:44,000
当然我现在道行也不深

2570
01:54:45,000 --> 01:54:47,000
那个时候这更是会觉得

2571
01:54:47,000 --> 01:54:49,000
这些设计模式里面很多地方就是

2572
01:54:50,000 --> 01:54:51,000
脱了裤子放屁

2573
01:54:51,000 --> 01:54:54,000
就是我明明可以直接一步就做到了

2574
01:54:54,000 --> 01:54:56,000
为什么一定要通过这么周张

2575
01:54:56,000 --> 01:54:59,000
大费周章的方式来实践它

2576
01:54:59,000 --> 01:55:01,000
但是只有你在

2577
01:55:03,000 --> 01:55:07,000
官方话叫做长期的工作实践中

2578
01:55:09,000 --> 01:55:09,000
对

2579
01:55:09,000 --> 01:55:11,000
打关墙是长期的工作时间

2580
01:55:11,000 --> 01:55:13,000
只有你在经历过

2581
01:55:16,000 --> 01:55:19,000
因为自己的代码越来越大

2582
01:55:20,000 --> 01:55:23,000
让你每次开始写它都会产生一种

2583
01:55:24,000 --> 01:55:27,000
恐惧和恶心的情绪的时候

2584
01:55:28,000 --> 01:55:31,000
当你因为每天心不在焉

2585
01:55:31,000 --> 01:55:32,000
被你的女朋友说

2586
01:55:34,000 --> 01:55:35,000
你是不是不爱我

2587
01:55:37,000 --> 01:55:40,000
你所能做出的回答只是

2588
01:55:40,000 --> 01:55:41,000
My code doesn't work

2589
01:55:41,000 --> 01:55:44,000
的时候你才会体会到

2590
01:55:45,000 --> 01:55:46,000
设计模式其实是一种

2591
01:55:47,000 --> 01:55:48,000
多么伟大的存在

2592
01:55:50,000 --> 01:55:52,000
我觉得其实一个比较合适的切入点是

2593
01:55:52,000 --> 01:55:55,000
你可以写一些程序

2594
01:55:56,000 --> 01:55:58,000
然后总结出你自己觉得

2595
01:55:59,000 --> 01:56:04,000
看起来是个不错的模式加引号的时候

2596
01:56:04,000 --> 01:56:05,000
再去回头去看一些

2597
01:56:07,000 --> 01:56:07,000
回头去看

2598
01:56:08,000 --> 01:56:09,000
比如说设计模式这本书

2599
01:56:10,000 --> 01:56:12,000
乃至于在这本书出版之后

2600
01:56:12,000 --> 01:56:13,000
有很多其他的比如说

2601
01:56:15,000 --> 01:56:17,000
Design patterns in C-sharp

2602
01:56:17,000 --> 01:56:18,000
或者是 Design patterns

2603
01:56:18,000 --> 01:56:19,000
implement in JavaScript

2604
01:56:19,000 --> 01:56:20,000
这类的书

2605
01:56:20,000 --> 01:56:25,000
你才会切身领悟到这些设计模式真正的意义何在

2606
01:56:26,000 --> 01:56:26,000
对

2607
01:56:26,000 --> 01:56:29,000
所以其实最合适的阅读这种

2608
01:56:29,000 --> 01:56:31,000
设计模式这种思想

2609
01:56:31,000 --> 01:56:34,000
这种比较玄学的书也好

2610
01:56:34,000 --> 01:56:36,000
还是文章也好

2611
01:56:36,000 --> 01:56:36,000
的时候

2612
01:56:36,000 --> 01:56:39,000
其实是在你有一定的工作积累

2613
01:56:39,000 --> 01:56:42,000
还过不少雷被炸死过好多次之后

2614
01:56:42,000 --> 01:56:43,000
然后又想

2615
01:56:43,000 --> 01:56:45,000
又进一步提高自己的水平

2616
01:56:45,000 --> 01:56:46,000
又遇到这个平静

2617
01:56:46,000 --> 01:56:49,000
不知道该下一步该怎么走的时候

2618
01:56:49,000 --> 01:56:50,000
来看这个可能有一种那种

2619
01:56:50,000 --> 01:56:51,000
提乎惯定的感觉

2620
01:56:53,000 --> 01:56:54,000
对

2621
01:56:57,000 --> 01:56:58,000
然后在

2622
01:57:00,000 --> 01:57:03,000
应该是前年的时候有这样一篇报道

2623
01:57:03,000 --> 01:57:05,000
就是他们请到了

2624
01:57:06,000 --> 01:57:06,000
Elish Gamma

2625
01:57:07,000 --> 01:57:08,000
Richard Helm

2626
01:57:08,000 --> 01:57:09,000
还有 Ralph Johnson

2627
01:57:09,000 --> 01:57:11,000
就是四人帮里面三个人

2628
01:57:12,000 --> 01:57:16,000
来在这本书出版了 15 年之后重新讨论

2629
01:57:17,000 --> 01:57:17,000
设计模式

2630
01:57:19,000 --> 01:57:21,000
的利与弊

2631
01:57:21,000 --> 01:57:22,000
大概是这么一意思

2632
01:57:22,000 --> 01:57:23,000
有这两篇报道

2633
01:57:26,000 --> 01:57:27,000
反思绘

2634
01:57:29,000 --> 01:57:29,000
算吧

2635
01:57:29,000 --> 01:57:30,000
算是一个对

2636
01:57:32,000 --> 01:57:33,000
老兵俱乐部这种感觉

2637
01:57:36,000 --> 01:57:37,000
然后在那边

2638
01:57:37,000 --> 01:57:40,000
在这个访谈里面有这样一句话说

2639
01:57:42,000 --> 01:57:49,000
A high level vocabulary simplifies communication between software practitioners

2640
01:57:50,000 --> 01:57:55,000
and enables concise description of higher level concepts

2641
01:57:55,000 --> 01:57:58,000
我觉得这也是设计模式比较重要的一点

2642
01:57:58,000 --> 01:57:59,000
就是

2643
01:58:00,000 --> 01:58:02,000
有了设计模式之后

2644
01:58:02,000 --> 01:58:04,000
你可以用很短的句子

2645
01:58:05,000 --> 01:58:08,000
跟别人交流一些比较浓缩的概念

2646
01:58:09,000 --> 01:58:09,000
比如说

2647
01:58:10,000 --> 01:58:12,000
你不用跟别人说

2648
01:58:12,000 --> 01:58:13,000
我在这里想到一个方法

2649
01:58:14,000 --> 01:58:16,000
这个方法的作用就是根据

2650
01:58:18,000 --> 01:58:19,000
实际的类型需求

2651
01:58:19,000 --> 01:58:23,000
来生产出不同类型的 object

2652
01:58:23,000 --> 01:58:24,000
你应该直接跟他说

2653
01:58:24,000 --> 01:58:25,000
这边是一个

2654
01:58:27,000 --> 01:58:27,000
factory

2655
01:58:30,000 --> 01:58:31,000
工厂方法

2656
01:58:31,000 --> 01:58:32,000
这里是一个工厂方法

2657
01:58:33,000 --> 01:58:33,000
然后

2658
01:58:35,000 --> 01:58:35,000
你可以说

2659
01:58:35,000 --> 01:58:36,000
这里是一个

2660
01:58:36,000 --> 01:58:39,000
这是一个 metafactory

2661
01:58:39,000 --> 01:58:39,000
不对

2662
01:58:39,000 --> 01:58:40,000
叫什么

2663
01:58:40,000 --> 01:58:42,000
abstract factory

2664
01:58:42,000 --> 01:58:43,000
这是一个生产工厂的工厂

2665
01:58:44,000 --> 01:58:47,000
应该用非常简单的句子表达相对来说

2666
01:58:47,000 --> 01:58:48,000
更加复杂的概念

2667
01:58:49,000 --> 01:58:50,000
然后这样

2668
01:58:51,000 --> 01:58:52,000
从这个层面来说

2669
01:58:52,000 --> 01:58:53,000
你懂一些设计模式之后

2670
01:58:53,000 --> 01:59:00,000
你也可以更加方便的去表达

2671
01:59:00,000 --> 01:59:02,000
乃至于理解别人通过一大片代码

2672
01:59:02,000 --> 01:59:05,000
或者是一些很简短的句子

2673
01:59:05,000 --> 01:59:06,000
想要表达的意思

2674
01:59:09,000 --> 01:59:09,000
然后这边

2675
01:59:11,000 --> 01:59:12,000
访谈里面还提到说

2676
01:59:13,000 --> 01:59:14,000
访谈的主持人说

2677
01:59:14,000 --> 01:59:15,000
访谈的主持人也就是

2678
01:59:17,000 --> 01:59:18,000
也不重要

2679
01:59:18,000 --> 01:59:19,000
主持人问说

2680
01:59:20,000 --> 01:59:21,000
在现在这个时代

2681
01:59:23,000 --> 01:59:26,000
我们只需要写一行这个

2682
01:59:26,000 --> 01:59:27,000
php 代码就可以

2683
01:59:30,000 --> 01:59:31,000
做出一个网站来

2684
01:59:31,000 --> 01:59:32,000
写着 Hello world

2685
01:59:32,000 --> 01:59:36,000
the time is dollar time

2686
01:59:36,000 --> 01:59:37,000
这样一个网站出来

2687
01:59:37,000 --> 01:59:39,000
那么在这样一个时代里面

2688
01:59:40,000 --> 01:59:41,000
设计模式还有一个名义

2689
01:59:43,000 --> 01:59:43,000
然后

2690
01:59:45,000 --> 01:59:46,000
Richard 说

2691
01:59:48,000 --> 01:59:49,000
I think there has been

2692
01:59:49,000 --> 01:59:52,000
an evolution level of sophistication

2693
01:59:52,000 --> 01:59:56,000
也就是说在复杂度的层级上面

2694
01:59:56,000 --> 01:59:58,000
在过去的这 15 年里面

2695
01:59:58,000 --> 02:00:03,000
软件有一个非常大的进化

2696
02:00:04,000 --> 02:00:06,000
可以复用的软件

2697
02:00:06,000 --> 02:00:07,000
已经被移植到了比较

2698
02:00:09,000 --> 02:00:10,000
接近于底层的位置

2699
02:00:10,000 --> 02:00:11,000
比如说一个 toolkit

2700
02:00:11,000 --> 02:00:12,000
或者是一个 framework

2701
02:00:13,000 --> 02:00:16,000
然后这些东西的设计

2702
02:00:16,000 --> 02:00:20,000
应该更多的被 be left to the experts

2703
02:00:21,000 --> 02:00:22,000
眼下之意就是说

2704
02:00:22,000 --> 02:00:23,000
现在大部分写书序的人

2705
02:00:23,000 --> 02:00:24,000
都不是 experts

2706
02:00:24,000 --> 02:00:27,000
他们只是在沿用这些个

2707
02:00:27,000 --> 02:00:30,000
他们所做的工作

2708
02:00:30,000 --> 02:00:33,000
只是把一些 framework 里面的东西

2709
02:00:33,000 --> 02:00:34,000
组合起来

2710
02:00:34,000 --> 02:00:37,000
然后妥妥通空间写写业务逻辑

2711
02:00:37,000 --> 02:00:37,000
然后就可以用了

2712
02:00:38,000 --> 02:00:40,000
那么在这种情况之下

2713
02:00:42,000 --> 02:00:45,000
the goal for most software developers

2714
02:00:45,000 --> 02:00:48,000
still remains to design for change

2715
02:00:48,000 --> 02:00:49,000
and there are debates

2716
02:00:49,000 --> 02:00:52,000
do you do it early or later

2717
02:00:52,000 --> 02:00:54,000
in many cases

2718
02:00:54,000 --> 02:00:55,000
the design should be refactored

2719
02:00:55,000 --> 02:00:58,000
and the patents provide a target to do this

2720
02:00:59,000 --> 02:00:59,000
也就是说

2721
02:01:01,000 --> 02:01:02,000
即便在这种情况之下

2722
02:01:02,000 --> 02:01:06,000
你虽然不直接参与一个框架

2723
02:01:06,000 --> 02:01:09,000
或者是一个大库的开发

2724
02:01:09,000 --> 02:01:11,000
但你仍旧需要做出一些决定

2725
02:01:11,000 --> 02:01:12,000
这些决定也就是

2726
02:01:13,000 --> 02:01:15,000
我们刚才的读者来信里面也提到了

2727
02:01:15,000 --> 02:01:16,000
在很大程度上

2728
02:01:16,000 --> 02:01:16,000
它是一种重构

2729
02:01:17,000 --> 02:01:18,000
然后你在做重构的时候

2730
02:01:18,000 --> 02:01:19,000
你就会发现

2731
02:01:20,000 --> 02:01:22,000
设计模式其实是有大用处的

2732
02:01:23,000 --> 02:01:24,000
你在重构的时候

2733
02:01:24,000 --> 02:01:27,000
你会去看到说

2734
02:01:27,000 --> 02:01:29,000
目前的这块代码

2735
02:01:29,000 --> 02:01:32,000
尤其是在比较敏捷的状况之下

2736
02:01:32,000 --> 02:01:33,000
写出来的代码

2737
02:01:33,000 --> 02:01:35,000
它内部可能存在一些什么样的问题

2738
02:01:35,000 --> 02:01:39,000
而设计模式则可以为你提供一些

2739
02:01:39,000 --> 02:01:41,000
解决这些问题的思路

2740
02:01:41,000 --> 02:01:42,000
我觉得这也是设计模式

2741
02:01:42,000 --> 02:01:45,000
即便在很多很多年之后

2742
02:01:45,000 --> 02:01:48,000
我们大部分从业者都不是那么

2743
02:01:48,000 --> 02:01:49,000
expert 的情况下

2744
02:01:49,000 --> 02:01:51,000
仍旧有用的一个例子

2745
02:01:51,000 --> 02:01:52,000
嗯哼

2746
02:01:52,000 --> 02:01:53,000
没错

2747
02:01:53,000 --> 02:01:54,000
嗯

2748
02:01:54,000 --> 02:01:56,000
那节目的最后

2749
02:01:56,000 --> 02:01:58,000
我们讲一个跟设计模式相关的

2750
02:01:58,000 --> 02:02:00,000
他的男生兄弟

2751
02:02:00,000 --> 02:02:02,000
Anti-Pattern

2752
02:02:02,000 --> 02:02:03,000
对

2753
02:02:03,000 --> 02:02:05,000
这翻译成中文怎么翻

2754
02:02:05,000 --> 02:02:06,000
反模式

2755
02:02:06,000 --> 02:02:06,000
逆模式吧

2756
02:02:06,000 --> 02:02:08,000
还是反模式

2757
02:02:08,000 --> 02:02:09,000
反模式

2758
02:02:09,000 --> 02:02:10,000
逆模式反模式

2759
02:02:10,000 --> 02:02:11,000
反模式

2760
02:02:11,000 --> 02:02:12,000
对

2761
02:02:12,000 --> 02:02:14,000
Anti-Pattern 就是那些所有

2762
02:02:14,000 --> 02:02:16,000
容易掉进的坑

2763
02:02:16,000 --> 02:02:17,000
我觉得可以这么说

2764
02:02:17,000 --> 02:02:19,000
就是有些

2765
02:02:19,000 --> 02:02:21,000
有些坑是

2766
02:02:21,000 --> 02:02:22,000
有些坑是

2767
02:02:22,000 --> 02:02:25,000
人人避开的

2768
02:02:25,000 --> 02:02:25,000
对

2769
02:02:25,000 --> 02:02:27,000
有些坑是人人避开的

2770
02:02:27,000 --> 02:02:29,000
而有些坑则人人都会掉进去

2771
02:02:29,000 --> 02:02:30,000
我相信

2772
02:02:30,000 --> 02:02:32,000
Anti-Pattern

2773
02:02:32,000 --> 02:02:34,000
我相信 Anti-Pattern 的数量是要

2774
02:02:34,000 --> 02:02:36,000
远远远远多于 Design Pattern

2775
02:02:36,000 --> 02:02:39,000
不知道什么这个假设是不是正确

2776
02:02:39,000 --> 02:02:41,000
至少你去搜

2777
02:02:41,000 --> 02:02:43,000
如果你去搜 Anti-Pattern 的话

2778
02:02:43,000 --> 02:02:46,000
你可以找到一些汇总的页面

2779
02:02:46,000 --> 02:02:47,000
这些页面上列出的那个

2780
02:02:48,000 --> 02:02:51,000
Pattern 可能远远远远超过

2781
02:02:51,000 --> 02:02:52,000
这个四人帮

2782
02:02:52,000 --> 02:02:54,000
所以开始给出那 23 个

2783
02:02:54,000 --> 02:02:56,000
比较好的 Design Pattern

2784
02:02:59,000 --> 02:03:00,000
举几个例子吧

2785
02:03:00,000 --> 02:03:01,000
第一个例子就是

2786
02:03:01,000 --> 02:03:04,000
我能想到的就是高的 object

2787
02:03:04,000 --> 02:03:06,000
对 Anti-Pattern 其实也是有名字的

2788
02:03:06,000 --> 02:03:10,000
我能想到的第一个就是高的 object

2789
02:03:10,000 --> 02:03:12,000
我不知道各位有没有这样一个阶段

2790
02:03:12,000 --> 02:03:14,000
就是如果你写入很多程序的话

2791
02:03:14,000 --> 02:03:16,000
你的程序如果大到一个境界

2792
02:03:16,000 --> 02:03:27,000
你会下意识的把那些不知道归给谁的东西

2793
02:03:27,000 --> 02:03:28,000
归到同一个东西下面

2794
02:03:30,000 --> 02:03:33,000
最常见的就是你会写一个叫做 Toolkit

2795
02:03:33,000 --> 02:03:40,000
或者是 Utility 或者是 Base 这样一个 object

2796
02:03:40,000 --> 02:03:41,000
然后里面放了一大堆

2797
02:03:41,000 --> 02:03:42,000
还有 Command 之类的

2798
02:03:42,000 --> 02:03:44,000
对 Command 点什么什么

2799
02:03:44,000 --> 02:03:45,000
一大堆根本就不知道

2800
02:03:45,000 --> 02:03:47,000
你不知道该往哪放的东西全都放在那

2801
02:03:47,000 --> 02:03:52,000
比如说 Utilities 里面可能有一个绘图函数

2802
02:03:52,000 --> 02:03:54,000
然后一个打开文件的函数

2803
02:03:54,000 --> 02:03:55,000
对

2804
02:03:56,000 --> 02:03:58,000
一个做网络通信的函数

2805
02:03:58,000 --> 02:04:00,000
然后一个帮你存密码的函数

2806
02:04:00,000 --> 02:04:03,000
或者是一个帮你烧水的函数

2807
02:04:03,000 --> 02:04:04,000
全都放在里面

2808
02:04:04,000 --> 02:04:08,000
其实这就是一个非常知名的 Anti-Pattern

2809
02:04:08,000 --> 02:04:10,000
叫做高的 object

2810
02:04:10,000 --> 02:04:13,000
就是这个 object 无所不能全知全能

2811
02:04:13,000 --> 02:04:14,000
有非常多的

2812
02:04:15,000 --> 02:04:15,000
对

2813
02:04:15,000 --> 02:04:20,000
其实这个 pattern 在命令式编程里面也会出现

2814
02:04:20,000 --> 02:04:23,000
如果你放了太多的全球变量的话

2815
02:04:23,000 --> 02:04:28,000
其实也是一个比较明显的高的 object

2816
02:04:28,000 --> 02:04:31,000
它违反了一个原则

2817
02:04:31,000 --> 02:04:34,000
就是你应该提供尽量清晰的接口

2818
02:04:35,000 --> 02:04:39,000
你应该尽量让每一个 object 的值得清晰化

2819
02:04:40,000 --> 02:04:43,000
但是在高的 object 这里这一切都被你换了

2820
02:04:44,000 --> 02:04:47,000
你会发现这个高的 object 只是无处不在

2821
02:04:47,000 --> 02:04:48,000
就是个大杂烩

2822
02:04:48,000 --> 02:04:49,000
对

2823
02:04:49,000 --> 02:04:51,000
然后你会发现重构变得非常艰难

2824
02:04:51,000 --> 02:04:53,000
因为你根本就不知道哪些业务逻辑

2825
02:04:54,000 --> 02:04:56,000
可以从这个 object 里面提取出来

2826
02:04:57,000 --> 02:04:58,000
这是一个比较

2827
02:04:58,000 --> 02:05:02,000
这是一个我自己能想到的第一个比较著名的 Anti-Pattern

2828
02:05:06,000 --> 02:05:06,000
还有什么

2829
02:05:06,000 --> 02:05:07,000
Golden Hammer

2830
02:05:07,000 --> 02:05:08,000
对

2831
02:05:08,000 --> 02:05:13,000
Golden Hammer 也是一个比较知名的 Anti-Pattern

2832
02:05:13,000 --> 02:05:15,000
就是有这样的俗话说

2833
02:05:15,000 --> 02:05:17,000
我有一把锤子

2834
02:05:17,000 --> 02:05:19,000
我看什么都像钉子

2835
02:05:22,000 --> 02:05:24,000
如果要把它总结成一个 pattern 的话

2836
02:05:24,000 --> 02:05:27,000
那就是你会了一门语言

2837
02:05:27,000 --> 02:05:29,000
或者是你掌握了一个酷

2838
02:05:29,000 --> 02:05:31,000
你会觉得说

2839
02:05:32,000 --> 02:05:34,000
甚至不一定是一个个人

2840
02:05:34,000 --> 02:05:35,000
可能是一个人

2841
02:05:35,000 --> 02:05:36,000
不一定是一个个人

2842
02:05:36,000 --> 02:05:39,000
可能在一个团队上也会体现出这样一种倾向来

2843
02:05:39,000 --> 02:05:41,000
就是说我要用这个工具解决一切的问题

2844
02:05:42,000 --> 02:05:44,000
所有问题都应该转化到这个工具上来解决

2845
02:05:45,000 --> 02:05:46,000
或者说所有的

2846
02:05:48,000 --> 02:05:52,000
你意思是 OOP 本身就是一个 Golden Hammer 是吧

2847
02:05:52,000 --> 02:05:52,000
对

2848
02:05:52,000 --> 02:05:53,000
你有说过吗

2849
02:05:54,000 --> 02:05:56,000
其实你现在看很多那种

2850
02:05:56,000 --> 02:05:57,000
罗桑总是在哪里

2851
02:05:57,000 --> 02:05:59,000
《职工伤洗个自媒刀》吗

2852
02:05:59,000 --> 02:06:04,000
就是说什么时候你觉得 OOP 的这条路已经走得太远了

2853
02:06:04,000 --> 02:06:05,000
你看到这种语句

2854
02:06:05,000 --> 02:06:06,000
叫做

2855
02:06:06,000 --> 02:06:08,000
Executor.execute

2856
02:06:10,000 --> 02:06:11,000
开框号管

2857
02:06:13,000 --> 02:06:13,000
对

2858
02:06:13,000 --> 02:06:15,000
是你那个

2859
02:06:15,000 --> 02:06:18,000
其实我能想到的就是

2860
02:06:18,000 --> 02:06:21,000
有些面试题比如说 FizzBuzz

2861
02:06:23,000 --> 02:06:25,000
这样面试题

2862
02:06:26,000 --> 02:06:28,000
你明明写一个函数就可以解决

2863
02:06:28,000 --> 02:06:29,000
其实你不用写函数

2864
02:06:29,000 --> 02:06:31,000
你写一个 followup 就可以解决的问题

2865
02:06:32,000 --> 02:06:33,000
有些人要先

2866
02:06:34,000 --> 02:06:37,000
因为他只学过面相就这样

2867
02:06:37,000 --> 02:06:40,000
所以他情不自禁的一上来要写个 Lay

2868
02:06:40,000 --> 02:06:41,000
不这个也是 Java 害的

2869
02:06:41,000 --> 02:06:43,000
因为 Java 没有不是 Lay 的东西

2870
02:06:43,000 --> 02:06:45,000
你没有 Lay 也没有办法执行

2871
02:06:46,000 --> 02:06:46,000
对

2872
02:06:46,000 --> 02:06:49,000
Java 连一个程序的入口点都放在一个 Lay 里面

2873
02:06:49,000 --> 02:06:50,000
这是何苦

2874
02:06:52,000 --> 02:06:54,000
程序何苦没人程序

2875
02:06:56,000 --> 02:06:57,000
对

2876
02:06:57,000 --> 02:07:01,000
与 Golden Hammer 相对的也有一个 Silver Bullet

2877
02:07:02,000 --> 02:07:03,000
这也是一个

2878
02:07:03,000 --> 02:07:04,000
对

2879
02:07:05,000 --> 02:07:06,000
其实 Silver Bullet 的话我查了一下

2880
02:07:06,000 --> 02:07:07,000
它是有一个来历的

2881
02:07:07,000 --> 02:07:09,000
只不过这个来历是如此的久远

2882
02:07:09,000 --> 02:07:11,000
也至于我们新生代的这个

2883
02:07:11,000 --> 02:07:13,000
我们已经是步入中年了

2884
02:07:13,000 --> 02:07:16,000
在此生就可以自豪地说一声

2885
02:07:16,000 --> 02:07:18,000
我们新生代的程序员不知道这个

2886
02:07:19,000 --> 02:07:20,000
梗的来历是情有可原的

2887
02:07:21,000 --> 02:07:22,000
就是在 30 年代

2888
02:07:23,000 --> 02:07:27,000
有这样一些故事讲述一个叫做

2889
02:07:28,000 --> 02:07:30,000
The Long Ranger

2890
02:07:32,000 --> 02:07:35,000
的西部牛仔

2891
02:07:35,000 --> 02:07:36,000
不是牛仔

2892
02:07:37,000 --> 02:07:39,000
他应该是西部的一个检察官

2893
02:07:39,000 --> 02:07:43,000
后来变成了一个匡扶正义的侠客这么一个形象

2894
02:07:43,000 --> 02:07:44,000
他有把枪

2895
02:07:44,000 --> 02:07:45,000
Ranger 就是奇景嘛

2896
02:07:46,000 --> 02:07:48,000
Ranger 就是奇景嘛

2897
02:07:48,000 --> 02:07:52,000
Ranger 最古老的意思指的是巡林客

2898
02:07:52,000 --> 02:07:57,000
就是在游骑兵嘛

2899
02:07:57,000 --> 02:07:57,000
应该是

2900
02:07:58,000 --> 02:07:59,000
对

2901
02:08:00,000 --> 02:08:01,000
但这不重要

2902
02:08:01,000 --> 02:08:04,000
反正他这个形象最大的绝杀

2903
02:08:04,000 --> 02:08:06,000
就是他有一个

2904
02:08:06,000 --> 02:08:07,000
他有把很长的枪

2905
02:08:07,000 --> 02:08:09,000
然后这个枪可以射出 Silver Bullet

2906
02:08:10,000 --> 02:08:13,000
Silver Bullet 每一次击中什么东西都是

2907
02:08:14,000 --> 02:08:15,000
首先他是个神枪手

2908
02:08:15,000 --> 02:08:18,000
然后他可以做到比如说这个人快被吊死了

2909
02:08:18,000 --> 02:08:21,000
他在两三百米开外打一颗银弹

2910
02:08:21,000 --> 02:08:22,000
打一颗 Silver Bullet

2911
02:08:22,000 --> 02:08:23,000
把那个人的

2912
02:08:23,000 --> 02:08:24,000
把这个人

2913
02:08:24,000 --> 02:08:26,000
把吊这个人的绳子射断

2914
02:08:27,000 --> 02:08:33,000
然后或者是一枪打爆一个锁

2915
02:08:33,000 --> 02:08:35,000
然后这个锁偏巧就可以弹开

2916
02:08:35,000 --> 02:08:37,000
然后可以让门打开之类的

2917
02:08:37,000 --> 02:08:41,000
这样一种非常奇迹隐巧的技术

2918
02:08:41,000 --> 02:08:44,000
好像最近应该是前年

2919
02:08:44,000 --> 02:08:48,000
前年 The Long Ranger 这个故事还重新被搬上萤幕

2920
02:08:48,000 --> 02:08:48,000
而且

2921
02:08:48,000 --> 02:08:49,000
对

2922
02:08:49,000 --> 02:08:51,000
Johnny Depp 演的

2923
02:08:53,000 --> 02:08:53,000
对

2924
02:08:53,000 --> 02:08:56,000
这个 Silver Bullet 实际上来自这样一个稿

2925
02:08:56,000 --> 02:08:58,000
然后 Silver Bullet 的特点就是

2926
02:08:58,000 --> 02:09:00,000
相信有这样一种技术

2927
02:09:00,000 --> 02:09:06,000
能够可以一劳永逸的解决一些

2928
02:09:07,000 --> 02:09:07,000
对

2929
02:09:07,000 --> 02:09:08,000
无视其

2930
02:09:08,000 --> 02:09:13,000
无视其边界条件的难题

2931
02:09:14,000 --> 02:09:18,000
然后这个 Silver Bullet 也是通过人跃神话这本书背

2932
02:09:18,000 --> 02:09:19,000
发言光大

2933
02:09:19,000 --> 02:09:21,000
以至于现在很多

2934
02:09:21,000 --> 02:09:23,000
就我相信大部分同学都应该听过这个名字

2935
02:09:23,000 --> 02:09:25,000
但是不太清楚他是怎么来的

2936
02:09:25,000 --> 02:09:28,000
但实际上 Silver Bullet 也是一个比较著名的

2937
02:09:28,000 --> 02:09:30,000
Antipath

2938
02:09:30,000 --> 02:09:36,000
这个翻译成中文应该叫什么来的

2939
02:09:36,000 --> 02:09:37,000
万金油

2940
02:09:37,000 --> 02:09:39,000
对

2941
02:09:39,000 --> 02:09:41,000
Silver Bullet 万金油模式

2942
02:09:41,000 --> 02:09:44,000
Golden Hammer 其实也是一个万金油

2943
02:09:44,000 --> 02:09:45,000
也有点万金油的意思

2944
02:09:45,000 --> 02:09:48,000
但 Server Bullet 强调的还是

2945
02:09:48,000 --> 02:09:52,000
强调的是这种解决方案的魔法性

2946
02:09:52,000 --> 02:09:58,000
就是这个解决方案真的是要刀并除一劳永逸

2947
02:09:58,000 --> 02:10:01,000
而 Golden Hammer 则更强调的是这样一种方法

2948
02:10:01,000 --> 02:10:03,000
这样某一个方法的普世性

2949
02:10:03,000 --> 02:10:05,000
就是拿它来干什么都可以

2950
02:10:05,000 --> 02:10:07,000
所以应该是 Golden Hammer 等价于万金油

2951
02:10:07,000 --> 02:10:10,000
然后 Silver Bullet 是叫什么来的

2952
02:10:11,000 --> 02:10:12,000
灵丹妙药是不是

2953
02:10:12,000 --> 02:10:13,000
对灵丹妙药

2954
02:10:13,000 --> 02:10:15,000
翻译不错

2955
02:10:15,000 --> 02:10:19,000
以后我们可以试试把所有的 Antipath 都给一个本土化的中文名

2956
02:10:19,000 --> 02:10:21,000
哈哈哈哈

2957
02:10:21,000 --> 02:10:23,000
读起来很酸爽

2958
02:10:23,000 --> 02:10:25,000
呵呵呵

2959
02:10:25,000 --> 02:10:31,000
感谢你收听本期 IPN Podcast 网络旗下的 IT 技术主题娱乐节目内容文化

2960
02:10:31,000 --> 02:10:34,000
我们号称 Hardcore 但是也没有干货

2961
02:10:34,000 --> 02:10:36,000
想听的人听不想听的人就别听

2962
02:10:36,000 --> 02:10:38,000
您可以为本节目捐款

2963
02:10:38,000 --> 02:10:42,000
捐款的意思是 ipn.li slash kernelpanic slash donate

2964
02:10:42,000 --> 02:10:45,000
捐款结合随意只要是能为 8 整除的正常数就可以

2965
02:10:45,000 --> 02:10:48,000
捐款不会为你带来什么不捐也不会让你吃什么

2966
02:10:48,000 --> 02:10:50,000
我们的口号是 know-how feelings

2967
02:10:50,000 --> 02:10:52,000
如果你有任何反馈

2968
02:10:52,000 --> 02:10:57,000
欢迎你发邮件到 kernelpanicatipn.li

2969
02:10:57,000 --> 02:11:00,000
如果写得足够长的话我们一定会念出来

2970
02:11:00,000 --> 02:11:01,000
呵呵呵

2971
02:11:01,000 --> 02:11:06,000
同时也欢迎你收听 IPN 旗下的其他几档节目

2972
02:11:06,000 --> 02:11:09,000
ID 公论 伪之道 太一来了 流行东西

2973
02:11:09,000 --> 02:11:11,000
Hi story 以及硬影下

2974
02:11:11,000 --> 02:11:13,000
我们下期节目再会

2975
02:11:36,000 --> 02:11:38,000
第一次上次可以烂成这个样子

2976
02:11:38,000 --> 02:11:40,000
所以呢

2977
02:11:40,000 --> 02:11:42,000
赶紧给我们捐款吧

