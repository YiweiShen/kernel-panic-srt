1
00:00:00,000 --> 00:00:19,000
《七月二十五号》

2
00:00:19,000 --> 00:00:22,000
大家好 今天是七月二十五号

3
00:00:22,000 --> 00:00:26,000
现在您听的是《自谈自串》的第五十二期

4
00:00:26,000 --> 00:00:29,000
同时也是《内核共荒》的第四十八期

5
00:00:29,000 --> 00:00:35,000
这也是我们《自谈自串》和《内核共荒》串台的《自谈自串》节目的第五期

6
00:00:35,000 --> 00:00:39,000
《自谈自串》是全球首家用华语制作的字体反映主题播客节目

7
00:00:39,000 --> 00:00:42,000
我是主播文川西半动音剧 Eric

8
00:00:42,000 --> 00:00:45,000
我是主播黄浦江宾新彧云宇、钱彧云宇

9
00:00:46,000 --> 00:00:50,000
《内核共荒》是 IPN Podcast 网络旗下的 IT 技术主题娱乐节目

10
00:00:50,000 --> 00:00:53,000
我号称 Hotcore 但谁没有干货

11
00:00:53,000 --> 00:00:55,000
想听人听不想听人就别听

12
00:00:55,000 --> 00:00:57,000
我是主播吴涛

13
00:00:58,000 --> 00:00:59,000
我是 Rail

14
00:01:00,000 --> 00:01:03,000
你说我们这个节目串台都已经串了第五期了

15
00:01:03,000 --> 00:01:07,000
等到上次五月底才第一次四个人一起在同一个空间见面是吧

16
00:01:07,000 --> 00:01:09,000
历史性的会晤啊

17
00:01:09,000 --> 00:01:11,000
对我们四个人没有合照

18
00:01:11,000 --> 00:01:14,000
那年活动来了好多播客主播吧

19
00:01:14,000 --> 00:01:17,000
数来应该有差不多小于十个

20
00:01:18,000 --> 00:01:20,000
你们后来就背着我们直接去喝酒了

21
00:01:20,000 --> 00:01:22,000
你们不是也去喝酒了吗

22
00:01:22,000 --> 00:01:24,000
你们不是还要去打扫场地吗

23
00:01:24,000 --> 00:01:26,000
那没有办法呀

24
00:01:27,000 --> 00:01:30,000
虽然说是 TIB 十周年活动节目

25
00:01:30,000 --> 00:01:36,000
搞得好像是变成国内 IPN 和各台电台主播的一个小聚会了

26
00:01:36,000 --> 00:01:38,000
小众播客网络

27
00:01:39,000 --> 00:01:42,000
而且其实现下我跟 Eric 在东京见过

28
00:01:42,000 --> 00:01:45,000
然后我跟 Rail 见过很久了

29
00:01:46,000 --> 00:01:50,000
Eric 跟曾宇之前也在上海见过很多次

30
00:01:51,000 --> 00:01:53,000
我跟 Rail 也见过一次

31
00:01:53,000 --> 00:01:56,000
然后我跟 Rail 在深圳也见过一两次

32
00:01:57,000 --> 00:01:58,000
两次

33
00:01:59,000 --> 00:02:02,000
但真正所有人在一起见这是第一次

34
00:02:02,000 --> 00:02:04,000
还挺难得的

35
00:02:04,000 --> 00:02:07,000
我们可以在那个 show notes 发一下

36
00:02:07,000 --> 00:02:09,000
这个上次活动的剧本

37
00:02:09,000 --> 00:02:11,000
四个人都在的照片应该有吧

38
00:02:11,000 --> 00:02:12,000
没有

39
00:02:12,000 --> 00:02:14,000
好像咱们四个没有合影对

40
00:02:14,000 --> 00:02:16,000
oh my god

41
00:02:17,000 --> 00:02:18,000
这么惨

42
00:02:18,000 --> 00:02:19,000
把吴涛披上去

43
00:02:20,000 --> 00:02:25,000
不是那个 Rail 也没有跟其他三个人合过影

44
00:02:25,000 --> 00:02:27,000
Rail 也没有跟你们两个合过影

45
00:02:27,000 --> 00:02:31,000
可能有照片同时有我和 Eric 和 Rail 的

46
00:02:32,000 --> 00:02:33,000
我记得有一张

47
00:02:33,000 --> 00:02:35,000
有一张有各种主播在一起

48
00:02:35,000 --> 00:02:39,000
有一张是你们两个在那个内间

49
00:02:40,000 --> 00:02:42,000
那个是一个节目

50
00:02:42,000 --> 00:02:43,000
然后 Rail 站在外面的照片

51
00:02:43,000 --> 00:02:45,000
对这个也有

52
00:02:45,000 --> 00:02:50,000
然后活动结束的时候我跟 Eric 和曾宇都有合影

53
00:02:50,000 --> 00:02:52,000
但是那个时候吴涛不知道去哪去了

54
00:02:52,000 --> 00:02:53,000
我去喝酒

55
00:02:53,000 --> 00:02:54,000
就泡妹子了

56
00:02:54,000 --> 00:02:55,000
我要喝花酒

57
00:02:55,000 --> 00:02:57,000
泡屁

58
00:03:02,000 --> 00:03:04,000
首先跟大家讲一讲

59
00:03:04,000 --> 00:03:05,000
其实这也不算广告了

60
00:03:05,000 --> 00:03:09,000
我们自己 type school 7 月份的课程已经结束了

61
00:03:09,000 --> 00:03:13,000
7 月份西文的字体设计课程大家应该

62
00:03:13,000 --> 00:03:14,000
虽然很累

63
00:03:14,000 --> 00:03:15,000
很辛苦

64
00:03:15,000 --> 00:03:18,000
但是估计大家收获也蛮大的

65
00:03:18,000 --> 00:03:19,000
一共有几天了

66
00:03:19,000 --> 00:03:21,000
两个礼拜

67
00:03:22,000 --> 00:03:27,000
我也过去和大家凑了一会儿热闹

68
00:03:27,000 --> 00:03:32,000
看我们的格二格老师给大家讲 Grips 挺有意思的

69
00:03:32,000 --> 00:03:34,000
对了我一直很好奇

70
00:03:34,000 --> 00:03:36,000
Gilg 他是一个字体设计师吗

71
00:03:36,000 --> 00:03:38,000
对他自己设计师

72
00:03:38,000 --> 00:03:40,000
他自己设计字体

73
00:03:40,000 --> 00:03:43,000
但是他有一些计算机开发的基础

74
00:03:43,000 --> 00:03:46,000
然后他做 Grips 几乎现在就

75
00:03:46,000 --> 00:03:49,000
几乎全职都在做 Grips 这个软件了变成

76
00:03:49,000 --> 00:03:53,000
所以他应该是一个计算机科学出身的人吗

77
00:03:53,000 --> 00:03:55,000
他是设计师出身

78
00:03:55,000 --> 00:03:58,000
那他竟然能写这么复杂的

79
00:03:58,000 --> 00:04:00,000
我觉得 Grips 已经是一个非常复杂的软件了

80
00:04:00,000 --> 00:04:01,000
对

81
00:04:01,000 --> 00:04:04,000
非常令人惊讶

82
00:04:04,000 --> 00:04:07,000
设计系需要这样的人才

83
00:04:07,000 --> 00:04:12,000
所以我也希望有更多的设计师来听我们的字坛字串

84
00:04:12,000 --> 00:04:13,000
好吧

85
00:04:13,000 --> 00:04:17,000
然后有很多朋友问

86
00:04:18,000 --> 00:04:20,000
因为这次是讲西文

87
00:04:20,000 --> 00:04:23,000
有没有学中文的字体设计课程

88
00:04:23,000 --> 00:04:27,000
其实可能大家在微信上面也看到消息了

89
00:04:27,000 --> 00:04:30,000
我们在 8 月 4 号到 9 号会有这样一个课程

90
00:04:30,000 --> 00:04:32,000
叫 TypeSchool 的中文字体设计课

91
00:04:32,000 --> 00:04:35,000
而且这次不是在上海是在北京

92
00:04:35,000 --> 00:04:37,000
然后我们请到了老师

93
00:04:37,000 --> 00:04:40,000
有翻正字库的思维设计师

94
00:04:40,000 --> 00:04:45,000
包括像裘颖先生这样经验非常丰富的字体设计师

95
00:04:45,000 --> 00:04:51,000
很多中文字体设计师可能大家都知道他最著名的字体就是油黑

96
00:04:51,000 --> 00:04:55,000
然后 TypeSchool 就会教大家如何实现字库

97
00:04:55,000 --> 00:04:56,000
然后因为是做中文

98
00:04:56,000 --> 00:04:59,000
所以可能工程比较浩大

99
00:04:59,000 --> 00:05:06,000
从 12 个字扩展到 50 个字到 500,5000,5000

100
00:05:06,000 --> 00:05:07,000
对吧

101
00:05:07,000 --> 00:05:10,000
平时大家设计中文的话是没有头绪

102
00:05:10,000 --> 00:05:12,000
不知道怎么用什么方法做

103
00:05:12,000 --> 00:05:13,000
然后要做多少字

104
00:05:13,000 --> 00:05:17,000
一旦多的话怎么提高效率

105
00:05:17,000 --> 00:05:22,000
然后尽早发现问题

106
00:05:22,000 --> 00:05:25,000
比如说大小不一样怎么处理

107
00:05:25,000 --> 00:05:30,000
这些我们都会具体的在 TypeSchool 请老师给大家介绍

108
00:05:30,000 --> 00:05:34,000
对不过五天时间其实做 12 个字也就差不多了

109
00:05:34,000 --> 00:05:37,000
我们这次有一个很好的机会是

110
00:05:37,000 --> 00:05:40,000
优秀的学员可以和方舟签约

111
00:05:40,000 --> 00:05:47,000
只要你先做好几百个字剩下的成千上万字方舟会帮你做

112
00:05:47,000 --> 00:05:52,000
对这个其实就跟之前的字体竞赛很相似

113
00:05:52,000 --> 00:05:55,000
就是你提交一份样子的作品

114
00:05:55,000 --> 00:05:58,000
然后如果字体公司觉得非常合适

115
00:05:58,000 --> 00:05:59,000
有商业化的价值的话

116
00:05:59,000 --> 00:06:01,000
他会与你签约

117
00:06:01,000 --> 00:06:04,000
然后帮你把它做成一个真正意义这样的字库

118
00:06:04,000 --> 00:06:06,000
当然在这样的课程里面

119
00:06:06,000 --> 00:06:11,000
大家也会接触到 Grips 这样一个什么字体神器

120
00:06:11,000 --> 00:06:17,000
而且这次我们 Grips 开发者 GluckGolg 来中国

121
00:06:17,000 --> 00:06:23,000
他切身赶到了做翻块汉字的一些特殊的要求

122
00:06:23,000 --> 00:06:27,000
我们有很多新的功能也会加到 Grips 里面

123
00:06:27,000 --> 00:06:29,000
大家可以试用一下

124
00:06:29,000 --> 00:06:33,000
这次我们还邀请到了德国的 MetaDesign

125
00:06:33,000 --> 00:06:41,000
德国的他们公司的设计师也会参与到活动里面进来

126
00:06:41,000 --> 00:06:45,000
对 MetaDesign 感兴趣的朋友们也有机会

127
00:06:45,000 --> 00:06:48,000
所以这也是蛮难得的一个机会

128
00:06:50,000 --> 00:06:52,000
8 月份北京比较热

129
00:06:52,000 --> 00:06:56,000
但是我觉得 7 月份的上海也够热的

130
00:06:56,000 --> 00:06:57,000
上海更热

131
00:06:57,000 --> 00:07:00,000
我觉得这两天北京比上海凉快多了

132
00:07:01,000 --> 00:07:03,000
北京还好是干热嘛

133
00:07:03,000 --> 00:07:05,000
上海却 20 度比较大比较难受

134
00:07:05,000 --> 00:07:07,000
上海这周是爆热

135
00:07:07,000 --> 00:07:09,000
已经超过 40 度了

136
00:07:09,000 --> 00:07:10,000
对啊

137
00:07:10,000 --> 00:07:13,000
有这种下令营的感觉

138
00:07:13,000 --> 00:07:17,000
大家也欢迎大家多多的进行报名

139
00:07:17,000 --> 00:07:19,000
有这样的机会是非常难得的

140
00:07:22,000 --> 00:07:25,000
好了难得我们这次第 5 次的串台

141
00:07:25,000 --> 00:07:28,000
但是还要先讲一下反馈

142
00:07:28,000 --> 00:07:31,000
上次我们的《字弹字串》第四期

143
00:07:31,000 --> 00:07:33,000
《峰回路转换航》来

144
00:07:33,000 --> 00:07:35,000
有一位朋友说

145
00:07:35,000 --> 00:07:37,000
吴涛重新发明打字机

146
00:07:37,000 --> 00:07:40,000
带回车键的打字机

147
00:07:40,000 --> 00:07:41,000
感到好

148
00:07:42,000 --> 00:07:44,000
所以打字机是没有回车键的对吧

149
00:07:44,000 --> 00:07:47,000
打字机没有一个键

150
00:07:47,000 --> 00:07:49,000
是你按下去之后它会跳到下一航

151
00:07:49,000 --> 00:07:51,000
好像是有的

152
00:07:51,000 --> 00:07:54,000
但这个键并不是回车键

153
00:07:54,000 --> 00:07:56,000
也不是在每一个打字机上都有

154
00:07:56,000 --> 00:08:00,000
然后换航的时候是你拨动左边的拨杆

155
00:08:00,000 --> 00:08:02,000
把自车往右拨的过程中

156
00:08:02,000 --> 00:08:06,000
它会自动朝下滚一格

157
00:08:06,000 --> 00:08:10,000
所以换航这个功能实际上是在自车上实现的

158
00:08:10,000 --> 00:08:14,000
郑宇还是把那位听众的反馈念一下吧

159
00:08:14,000 --> 00:08:16,000
好吧

160
00:08:16,000 --> 00:08:18,000
刚刚 Eric 念的是第一航

161
00:08:18,000 --> 00:08:19,000
然后接下来念

162
00:08:19,000 --> 00:08:21,000
打字机没有回车键

163
00:08:21,000 --> 00:08:23,000
打字机滚筒左端的手柄

164
00:08:23,000 --> 00:08:25,000
坚持回车于换航功能

165
00:08:25,000 --> 00:08:27,000
手柄从左向右平推

166
00:08:27,000 --> 00:08:29,000
可以将滚轮向右推送

167
00:08:29,000 --> 00:08:31,000
就是回车

168
00:08:31,000 --> 00:08:33,000
手柄从左向右搬动

169
00:08:33,000 --> 00:08:36,000
同时带点轻微的顺时针扭转

170
00:08:36,000 --> 00:08:39,000
可以滚动滚动就是换航

171
00:08:39,000 --> 00:08:42,000
搬得轻一点可以换半航或四分之一航

172
00:08:42,000 --> 00:08:46,000
打字时当滚动航进行到

173
00:08:46,000 --> 00:08:52,000
滚动航近到接近航末位置时

174
00:08:52,000 --> 00:08:55,000
会有钉的一声铃音提示

175
00:08:55,000 --> 00:08:58,000
平推手柄将滚轮推到最右实现回车

176
00:08:58,000 --> 00:09:00,000
顺势继续用手

177
00:09:00,000 --> 00:09:04,000
顺势继续用力手柄会自然向右

178
00:09:04,000 --> 00:09:07,000
反动转动滚轮

179
00:09:07,000 --> 00:09:08,000
这好奥口

180
00:09:08,000 --> 00:09:10,000
你怎么了你用这种障碍的话全程以内

181
00:09:10,000 --> 00:09:11,000
这好奥口

182
00:09:11,000 --> 00:09:13,000
实现换航

183
00:09:13,000 --> 00:09:14,000
OK

184
00:09:14,000 --> 00:09:15,000
大家听懂了吗

185
00:09:15,000 --> 00:09:16,000
没有

186
00:09:16,000 --> 00:09:17,000
我是没听懂

187
00:09:17,000 --> 00:09:20,000
我知不知道他的什么意思

188
00:09:20,000 --> 00:09:21,000
什么意思就是

189
00:09:21,000 --> 00:09:25,000
你在敲一航比如说这一航有 80 个字符

190
00:09:25,000 --> 00:09:27,000
你敲了大概 75 个的时候

191
00:09:27,000 --> 00:09:31,000
打字机会钉一声告诉你说没地儿了赶紧换航

192
00:09:31,000 --> 00:09:33,000
然后这个时候你

193
00:09:33,000 --> 00:09:37,000
压左侧的换航杆稍微压一下

194
00:09:37,000 --> 00:09:40,000
然后自车就会往上滚一格

195
00:09:40,000 --> 00:09:42,000
然后你继续往下压

196
00:09:42,000 --> 00:09:47,000
它就会把整个自车拉到指的最左边

197
00:09:47,000 --> 00:09:49,000
然后就这么一件事

198
00:09:51,000 --> 00:09:52,000
我还是很好奇

199
00:09:52,000 --> 00:09:54,000
为什么你们小时候都没有用过打字机

200
00:09:56,000 --> 00:09:58,000
对就没有用过西文

201
00:09:58,000 --> 00:09:59,000
没有用过

202
00:09:59,000 --> 00:10:02,000
所以你用过中文的打字机那更屌了

203
00:10:02,000 --> 00:10:05,000
中文打字机是一个一米乘一米的大台子

204
00:10:07,000 --> 00:10:10,000
对这个我用过就玩过一下

205
00:10:10,000 --> 00:10:12,000
那个真的存在吗

206
00:10:12,000 --> 00:10:15,000
就是那么多个字是那么大怎么移动呢

207
00:10:15,000 --> 00:10:19,000
是一个迪卡尔平面

208
00:10:19,000 --> 00:10:21,000
你要 XY

209
00:10:21,000 --> 00:10:22,000
真的

210
00:10:25,000 --> 00:10:27,000
那能有多少个字啊小明字母

211
00:10:27,000 --> 00:10:29,000
将近一万个吧

212
00:10:29,000 --> 00:10:30,000
很多很多

213
00:10:30,000 --> 00:10:32,000
没有吧没有没有不到一万多吧

214
00:10:32,000 --> 00:10:35,000
那一两千肯定是有的

215
00:10:35,000 --> 00:10:40,000
我的印象里面我玩过的那台是有六千字

216
00:10:40,000 --> 00:10:44,000
因为中文常用字也就三千五吧

217
00:10:44,000 --> 00:10:47,000
就他把常用字放在上面然后不够的是用空格

218
00:10:47,000 --> 00:10:48,000
然后有三手写

219
00:10:48,000 --> 00:10:51,000
他底下那个可以换的可以替换

220
00:10:51,000 --> 00:10:54,000
我印象里面是个一百乘一百的个子你知道吧

221
00:10:54,000 --> 00:10:59,000
我印象好像有那么多吗没那么大吧

222
00:10:59,000 --> 00:11:00,000
没有一百乘一百吗

223
00:11:00,000 --> 00:11:02,000
记不大清楚了

224
00:11:02,000 --> 00:11:04,000
挺大的对挺大的

225
00:11:04,000 --> 00:11:06,000
对反正是个相当大的东西

226
00:11:06,000 --> 00:11:08,000
我刚给大家发了一个链接

227
00:11:08,000 --> 00:11:11,000
那个也是一种汉字的打字机

228
00:11:11,000 --> 00:11:13,000
这个是日本人做的

229
00:11:13,000 --> 00:11:18,000
然后他是一个滚筒式的选字机构

230
00:11:18,000 --> 00:11:21,000
哦 OK 这个比较浓厌

231
00:11:21,000 --> 00:11:27,000
对这个是在京都的汉字博物馆里面展示了一件展品

232
00:11:27,000 --> 00:11:30,000
其实如果这么多就怎么记啊

233
00:11:30,000 --> 00:11:33,000
可能熟能生巧

234
00:11:33,000 --> 00:11:35,000
另外他肯定排字是有规则的

235
00:11:35,000 --> 00:11:37,000
你看他有标了不同颜色

236
00:11:37,000 --> 00:11:39,000
可以这样排吗

237
00:11:39,000 --> 00:11:41,000
不汉字应该不是这样排的

238
00:11:41,000 --> 00:11:43,000
应该是按音式排的吧

239
00:11:43,000 --> 00:11:45,000
他有颜色划分

240
00:11:45,000 --> 00:11:47,000
应该是按那个所谓的行和列

241
00:11:47,000 --> 00:11:53,000
就是五十音的行和列的发音来标音之后再分开

242
00:11:53,000 --> 00:11:56,000
怎么记得住啊哪个字在哪个位置

243
00:11:56,000 --> 00:11:57,000
还是要找的

244
00:11:57,000 --> 00:12:03,000
你想假设就三千个常用字的滚筒的话

245
00:12:03,000 --> 00:12:06,000
这打字速度应该很慢吧

246
00:12:06,000 --> 00:12:10,000
就得转转然后找找完以后才打出一个字

247
00:12:10,000 --> 00:12:13,000
他这个毕竟还是按拼音排列的

248
00:12:13,000 --> 00:12:18,000
我觉得可能还是要比中文打字机那个按部首排列的要快一点

249
00:12:18,000 --> 00:12:22,000
对不过因为日语一个字有很多发音

250
00:12:22,000 --> 00:12:25,000
所以你可能得记住这个字他用的是哪个标音

251
00:12:25,000 --> 00:12:32,000
像我以前我以前看的我就是我爸单位他们那个打字员用的那种打字机的话

252
00:12:32,000 --> 00:12:38,000
他底下那个反那个刚刚冲的那个刚字的盘是可以换的

253
00:12:38,000 --> 00:12:42,000
所以他经常会把这比较常用的字的组合他

254
00:12:42,000 --> 00:12:44,000
因为他可以随任意调配嘛

255
00:12:44,000 --> 00:12:46,000
然后把常用的放在一起

256
00:12:46,000 --> 00:12:51,000
比如中华人民共和国他就全部放在那他就顺下来可以直接打出来就可以

257
00:12:51,000 --> 00:12:57,000
而且我记得就我见到那个中文打字机好像他那个字盘不止是一层

258
00:12:57,000 --> 00:12:59,000
他有两层的可以抽的

259
00:12:59,000 --> 00:13:00,000
对没错

260
00:13:00,000 --> 00:13:04,000
上边有一层可能是常用的下面还有层次常用的

261
00:13:04,000 --> 00:13:06,000
哦对对对没错对

262
00:13:06,000 --> 00:13:10,000
所以我印象中的中文打字机没那么大

263
00:13:10,000 --> 00:13:16,000
嗯有道理对 100 乘 100 好像移动起来挺麻烦的

264
00:13:17,000 --> 00:13:19,000
打太极拳都可以

265
00:13:19,000 --> 00:13:25,000
因为我小时候其实就根本没有见过这些就纯机械的打字机

266
00:13:25,000 --> 00:13:29,000
因为我记得我小时候第一次看人打字的时候已经是有那个叫

267
00:13:29,000 --> 00:13:35,000
那个叫什么来的就是字符那个 DOSDOS 环节里面有一个中文的系统

268
00:13:35,000 --> 00:13:39,000
WPSCCED 吧

269
00:13:39,000 --> 00:13:42,000
CCED 是更早的后来 WPS 后出的嘛

270
00:13:42,000 --> 00:13:49,000
然后后出的时候那个时候已经有那种就是在那个 WPS 的那个就是字符界面那个版本里面去海映

271
00:13:49,000 --> 00:13:53,000
然后用那种真实打印机再把那个打出来嘛

272
00:13:53,000 --> 00:13:57,000
所以这个时候其实已经没有见过真的那种传统一的打字机了

273
00:13:57,000 --> 00:14:04,000
我高中办校报的时候就是用那个先进 UCDOS 然后再进 WPS

274
00:14:04,000 --> 00:14:08,000
然后呢那不是一个它是字符编辑界面吧

275
00:14:08,000 --> 00:14:10,000
那不是那个所见即所得的嘛

276
00:14:10,000 --> 00:14:15,000
所以你得要一些装饰的东西都用那个符号写进去后来不停不停的预览

277
00:14:15,000 --> 00:14:17,000
然后经常 386 的机器还会死机

278
00:14:18,000 --> 00:14:22,000
对那时候对于所见即所得没什么概念嘛就是

279
00:14:22,000 --> 00:14:23,000
对

280
00:14:23,000 --> 00:14:24,000
你要不停的预览

281
00:14:24,000 --> 00:14:31,000
但是后来基本上熟练的人会对于文章大概会看起来是什么样子

282
00:14:31,000 --> 00:14:34,000
有个概念就跟现在手写的试验蛮有意思

283
00:14:34,000 --> 00:14:37,000
然后对本身也是一种 markup 语言吗那个

284
00:14:37,000 --> 00:14:39,000
是那完全就是 markup

285
00:14:39,000 --> 00:14:42,000
所以你脑子中要想好你所要的是什么东西嘛

286
00:14:44,000 --> 00:14:46,000
就像我们又回 markdown 又回去了是吧

287
00:14:46,000 --> 00:14:47,000
又回来了对

288
00:14:48,000 --> 00:14:53,000
实际上我觉得我这个所见即所得并不是一个强需求说实话

289
00:14:54,000 --> 00:14:55,000
对

290
00:14:55,000 --> 00:15:00,000
就要看他那个门槛放低了以后是可以让更多人进来嘛

291
00:15:00,000 --> 00:15:03,000
但是对于专业用户的话可能需求不一样嘛

292
00:15:03,000 --> 00:15:04,000
对

293
00:15:04,000 --> 00:15:07,000
我觉得所见即所得本身是没有问题的

294
00:15:07,000 --> 00:15:10,000
主要问题在于现在就主要就是像 word 的那个实现

295
00:15:10,000 --> 00:15:13,000
它的那个实现过程有问题就是

296
00:15:13,000 --> 00:15:18,000
他把所有的那个效果都直接所见了

297
00:15:18,000 --> 00:15:23,000
你没有办法用一个类似于像模板或者是一种格式的方式

298
00:15:23,000 --> 00:15:27,000
虽然有格式刷但是那个格式刷就是极其不稳定嘛

299
00:15:27,000 --> 00:15:30,000
word 我觉得这大问题它太迁就用户了

300
00:15:30,000 --> 00:15:38,000
就是用户说我这个小标题要 15 帮重加粗

301
00:15:38,000 --> 00:15:42,000
下一个小标题它就弄了一个 16 帮重然后清洗

302
00:15:42,000 --> 00:15:44,000
然后 word 就傻逼了

303
00:15:44,000 --> 00:15:46,000
word 说我应该怎么办呢

304
00:15:46,000 --> 00:15:50,000
我应该问用户说不对你上一个小标题用的是这个

305
00:15:50,000 --> 00:15:52,000
然后这小标题你也得用那个

306
00:15:52,000 --> 00:15:54,000
但是这样一来用户可能不耍

307
00:15:54,000 --> 00:15:57,000
那我还是迁就用户再多分出来一个小标题吧

308
00:15:57,000 --> 00:16:00,000
然后等到整篇文章写完之后

309
00:16:00,000 --> 00:16:03,000
我发现小标题的 style 可能有 20 种

310
00:16:03,000 --> 00:16:04,000
35 种

311
00:16:04,000 --> 00:16:05,000
对

312
00:16:05,000 --> 00:16:09,000
如果一上来你们从来没有学会过用 word 格式刷这个习惯的话

313
00:16:09,000 --> 00:16:12,000
那基本上就最后只能手动改

314
00:16:12,000 --> 00:16:17,000
关键是那个格式刷它那个格式刷它也是一个就是事后加的东西

315
00:16:17,000 --> 00:16:21,000
我觉得就是它的本质上它的主理结构是以那个实际看的为准的

316
00:16:21,000 --> 00:16:25,000
这点跟那个苹果那个 pages 就是跟 word 差不多的一个软件

317
00:16:25,000 --> 00:16:27,000
的逻辑是完全不一样的

318
00:16:27,000 --> 00:16:30,000
pages 里面其实你是可以先定义那个文章的结构

319
00:16:30,000 --> 00:16:33,000
比如说这个刚才讲说这个是标题

320
00:16:33,000 --> 00:16:38,000
啊就是一级标题二级标题这样子正文啊这个是这个表格的内容

321
00:16:38,000 --> 00:16:42,000
然后定好之后你是可以直接通过改那个那个那个类型的文本

322
00:16:42,000 --> 00:16:45,000
比如说啊对吧改标题都改成一种同样的东西

323
00:16:45,000 --> 00:16:49,000
它可以直接更新然后让所有的标题文本都是长那个样子的

324
00:16:49,000 --> 00:16:52,000
但是在 word 里面这一点实现起来是非常不稳定的

325
00:16:52,000 --> 00:16:56,000
word 也有这个功能 word 也有对只是用的人非常的少

326
00:16:56,000 --> 00:16:59,000
不是不是它的时间确实是有问题的

327
00:16:59,000 --> 00:17:03,000
就是它不是那么强强调那个结构和统一的这么一个概念

328
00:17:03,000 --> 00:17:07,000
就刚才讲吴涛说的嘛就是用用户觉得哎这里要改一点那一点改

329
00:17:07,000 --> 00:17:11,000
他就他就不去 enforce 这个对什么一致性的问题

330
00:17:11,000 --> 00:17:15,000
这个其实是专业用户的一个需求不一样的

331
00:17:15,000 --> 00:17:19,000
像我当年也曾经用 word 做 40 页的小册子的时候

332
00:17:19,000 --> 00:17:23,000
我都是用那个样那个叫什么 style 样式吧

333
00:17:23,000 --> 00:17:27,000
他他专门有个样式小窗口来来做对你做长文档的时候

334
00:17:27,000 --> 00:17:31,000
就必须要用那样来做要不然的话非常复杂

335
00:17:31,000 --> 00:17:34,000
对就是那个实际的使用情况下 word 就会出现刚才我才讲那个问题

336
00:17:34,000 --> 00:17:38,000
就是你的那个格式刷它不是有个选一个列表有多少种格式吗

337
00:17:38,000 --> 00:17:42,000
你可能一边稍微长 10 页的可能会出现四五十种那个不同的

338
00:17:42,000 --> 00:17:46,000
就是你就是你想把 word 用好的话你要有一个你要有一个非常好的怎么说

339
00:17:46,000 --> 00:17:52,000
deception 就是你必须是一个非常自律高度自律的人对对

340
00:17:52,000 --> 00:17:58,000
你一定要忍住那个选中这一行字然后直接往上改变它的格式的这个

341
00:17:58,000 --> 00:18:04,000
改变它样式的这个这个冲动然后人肉负重的去用格式刷来刷这行字

342
00:18:04,000 --> 00:18:08,000
对否则你就乱了

343
00:18:08,000 --> 00:18:12,000
它很容易在那些小细节地方就变调就是你用格式刷也刷不回来

344
00:18:12,000 --> 00:18:16,000
就有些我不知道你们遇到过有些比如说两个字之间出现一个东西

345
00:18:16,000 --> 00:18:22,000
你不能用格式刷点多少次它都不会变的就是它的内部应该是有一些实现的 bug 的

346
00:18:22,000 --> 00:18:27,000
这个东西就是那你要自律的话看有没有洁癖的对吧

347
00:18:27,000 --> 00:18:31,000
就千万不能用硬回车来称行具对吧

348
00:18:31,000 --> 00:18:35,000
用空格来称字句对吧像这种东西

349
00:18:35,000 --> 00:18:39,000
本来就是排版的排版的首先的这个做法是不一样的

350
00:18:39,000 --> 00:18:44,000
这样 OK 是个补充一句刚才说的那个中文打字机啊

351
00:18:44,000 --> 00:18:50,000
我记得那个中文打字机它有一个最大的问题就是它不像英文打字机啊

352
00:18:50,000 --> 00:18:53,000
英文打字机也有这个问题但是没那么严重就是

353
00:18:53,000 --> 00:18:58,000
你在用英文打字机的时候你可能按一个键你的力度轻了那个

354
00:18:58,000 --> 00:19:01,000
那个打在纸上的字就会不轻松

355
00:19:01,000 --> 00:19:06,000
力度轻了那个打在纸上的字就会不清楚

356
00:19:06,000 --> 00:19:10,000
而中文打字机是如果你力度轻了那字不清楚也就罢了

357
00:19:10,000 --> 00:19:14,000
如果你用力比较重的话那字比划也比较复杂

358
00:19:14,000 --> 00:19:21,000
比如繁体的什么国家国字啊这种字你一打上去那个纸会不会穿烂的

359
00:19:21,000 --> 00:19:29,000
所以所以那个时候那个时候不仅打字是一个要要寻纸

360
00:19:29,000 --> 00:19:33,000
还要控制自己打字的力量真的是很累很累

361
00:19:33,000 --> 00:19:35,000
哎为什么会这样呢

362
00:19:35,000 --> 00:19:38,000
所以它那个它那个按键是不是均匀力度下决

363
00:19:38,000 --> 00:19:41,000
是靠你的那个手的力量来决定的

364
00:19:41,000 --> 00:19:44,000
对其实是把一张纸卷在一个大滚筒上

365
00:19:44,000 --> 00:19:51,000
滚筒是在这个 DTAR 评论上就就就就移动的嘛

366
00:19:51,000 --> 00:19:53,000
然后移动的时候你找到一个字

367
00:19:53,000 --> 00:19:56,000
你要把那个压你把那个手你压下去

368
00:19:56,000 --> 00:20:00,000
然后我理解是他把那个签字吸上来

369
00:20:00,000 --> 00:20:02,000
然后在纸上戳一下

370
00:20:02,000 --> 00:20:05,000
然后这个如果戳的比较狠的话那个纸会破

371
00:20:05,000 --> 00:20:07,000
对

372
00:20:07,000 --> 00:20:10,000
但我觉得像用键盘的这种打字机

373
00:20:10,000 --> 00:20:13,000
它完全是可以用机械设计解决这问题

374
00:20:13,000 --> 00:20:17,000
对像 IBM 那种又是用球形的那个打字头打字机

375
00:20:17,000 --> 00:20:22,000
它就是它把输入跟那个打字的部分分开了

376
00:20:22,000 --> 00:20:25,000
就是实际上你是驱动一个发条

377
00:20:25,000 --> 00:20:28,000
然后那个发条每次会以均匀的力度把那个字打在纸上

378
00:20:28,000 --> 00:20:29,000
对对对

379
00:20:29,000 --> 00:20:30,000
但这个都比较高端了

380
00:20:30,000 --> 00:20:32,000
对这个都比较高端了

381
00:20:32,000 --> 00:20:36,000
就家用的那种就是便有些便携的绣针的打字机

382
00:20:36,000 --> 00:20:40,000
都是还是你按你的手按的力度多大

383
00:20:40,000 --> 00:20:41,000
那个字就有多深

384
00:20:41,000 --> 00:20:45,000
怪不得看有些那种那种以前那种打字机打的文档

385
00:20:45,000 --> 00:20:47,000
它有些那个字符的出息是不一样的

386
00:20:47,000 --> 00:20:48,000
就是因为这个原因是吧

387
00:20:48,000 --> 00:20:50,000
对就是用力太多了

388
00:20:50,000 --> 00:20:51,000
力度的问题

389
00:20:53,000 --> 00:20:55,000
这也是这个真的是个手艺花

390
00:20:55,000 --> 00:21:00,000
对你像那个 IBM 出的打字机里面

391
00:21:00,000 --> 00:21:03,000
Corear 这个字体就是这么来的

392
00:21:03,000 --> 00:21:09,000
就是专门为了探个一个滚筒式打字机的那个设计的一套字体

393
00:21:10,000 --> 00:21:11,000
有什么讲究吗

394
00:21:12,000 --> 00:21:13,000
就是等宽吧

395
00:21:13,000 --> 00:21:16,000
那个时候的等宽然后是就有点 slap 的感觉

396
00:21:16,000 --> 00:21:17,000
就是带一点点衬衫

397
00:21:21,000 --> 00:21:23,000
最近有个新闻可以和大家分享一下

398
00:21:23,000 --> 00:21:26,000
因为我们前段时间说过那个 emoji 就是表情符号

399
00:21:26,000 --> 00:21:29,000
刚好 7 月 17 号就是 emoji 日

400
00:21:29,000 --> 00:21:31,000
7 月 17 号是 emoji 日这个事情你们知道吗

401
00:21:32,000 --> 00:21:33,000
我们提过

402
00:21:33,000 --> 00:21:35,000
emoji 还有自己的节日了已经

403
00:21:36,000 --> 00:21:38,000
我们讲 emoji 那期提过这个事情

404
00:21:39,000 --> 00:21:40,000
为什么是那天我忘了

405
00:21:40,000 --> 00:21:45,000
就是因为那个 emoji 的那个日历的图标上写了是 7 月 17

406
00:21:45,000 --> 00:21:46,000
对对对

407
00:21:46,000 --> 00:21:48,000
苹果那个日历

408
00:21:48,000 --> 00:21:53,000
沿用苹果的那个那个当时还叫 iCal 的日子

409
00:21:54,000 --> 00:22:00,000
然后这次苹果居然在他们官方网站上面搞一个什么新闻出来了是吧

410
00:22:00,000 --> 00:22:04,000
预先把今年稍晚推出的那个表情符号跟大家展示了一下

411
00:22:04,000 --> 00:22:07,000
这是 iOS 11 里面会搭载那套新的

412
00:22:08,000 --> 00:22:15,000
对也就是 6 月份 i-unicode 第 10 版里面已经通过的这些

413
00:22:16,000 --> 00:22:18,000
他已经准备好已经画好了嘛

414
00:22:18,000 --> 00:22:21,000
就马上就要拿出来跟大家用了

415
00:22:21,000 --> 00:22:24,000
比如说有什么僵尸水

416
00:22:24,000 --> 00:22:27,000
有什么带头巾的女人长胡须的人

417
00:22:27,000 --> 00:22:30,000
僵尸和穆斯林是同一个批次的说

418
00:22:34,000 --> 00:22:37,000
或者说应该应该还有什么饺子和筷子吗

419
00:22:37,000 --> 00:22:40,000
不是我上次在节目我在我们节目里面说过

420
00:22:40,000 --> 00:22:43,000
到他到底是画成包子还是画成馄饨呢

421
00:22:43,000 --> 00:22:45,000
那就不知道了到时候看实现吧

422
00:22:47,000 --> 00:22:50,000
所以现在在那个 iOS 11 的预览那个就是什么

423
00:22:50,000 --> 00:22:52,000
Beta 版里面应该已经可以看得到了吧

424
00:22:53,000 --> 00:22:54,000
你们装的吗

425
00:22:54,000 --> 00:23:00,000
我在 iPad 上装但还没注意到看那个表情那个 emoji 的变化

426
00:23:01,000 --> 00:23:03,000
好像还没吧我没装

427
00:23:04,000 --> 00:23:07,000
我也没装但好像还没上吧

428
00:23:08,000 --> 00:23:11,000
他上了那个叫做 public beta 上了两次了

429
00:23:11,000 --> 00:23:13,000
对我知道但 emoji 好像很不稳定

430
00:23:13,000 --> 00:23:15,000
我看好多人都说不稳定

431
00:23:16,000 --> 00:23:18,000
我在那个 iPad 上装的反正还行

432
00:23:18,000 --> 00:23:20,000
因为这次 iPad 感动比较大嘛

433
00:23:20,000 --> 00:23:22,000
待会我们去看一下看那个 iPad 上有没有

434
00:23:26,000 --> 00:23:31,000
那现在就可以念另外一封听众反馈了是吧

435
00:23:31,000 --> 00:23:32,000
可以啊

436
00:23:32,000 --> 00:23:34,000
好我来念一下吧

437
00:23:35,000 --> 00:23:38,000
有一位没有署名的听众

438
00:23:38,000 --> 00:23:42,000
后来我问了他我还专门写信是问了他应该怎么称呼

439
00:23:42,000 --> 00:23:45,000
他说可以称呼他叫 Tiger 老虎

440
00:23:45,000 --> 00:23:51,000
然后这位自称叫老虎的听众来了一封邮件说赞美主播并求解两个问题

441
00:23:52,000 --> 00:23:54,000
两位主播好他是写给自弹自唱的

442
00:23:54,000 --> 00:23:57,000
两位主播好我是一个通信工程毕业的马农

443
00:23:57,000 --> 00:24:00,000
具体来说是做 iOS 开发的大概一年前吧

444
00:24:00,000 --> 00:24:02,000
偶然机会发现了你们的播客

445
00:24:02,000 --> 00:24:07,000
一直听到现在很佩服你们的毅力能够持续更新超越了内核恐慌

446
00:24:09,000 --> 00:24:12,000
我是马农所以最开始听的是内核恐慌

447
00:24:12,000 --> 00:24:14,000
听你们播客过程中

448
00:24:14,000 --> 00:24:15,000
感觉我们很容易超越

449
00:24:16,000 --> 00:24:19,000
我授意非浅知道任何东西都不是简简单单的

450
00:24:19,000 --> 00:24:22,000
一个设计作品或者具体到一个 UI 界面

451
00:24:22,000 --> 00:24:25,000
看起来很舒服一定是有其背后的道理

452
00:24:25,000 --> 00:24:29,000
我也看了你们推荐的一些书籍做了一些笔记这里就不说了

453
00:24:29,000 --> 00:24:33,000
一直以来就想着就这样被你们任务系无声也挺好的

454
00:24:33,000 --> 00:24:37,000
但是我最近遇到了一些问题想得到你们的指教

455
00:24:37,000 --> 00:24:40,000
因为有个问题是偏计算机方面和字体没啥关系

456
00:24:40,000 --> 00:24:42,000
不知道提出来是不是很合适

457
00:24:42,000 --> 00:24:44,000
不过我觉得真与主播一定可以的

458
00:24:44,000 --> 00:24:45,000
其实真与主播不可以

459
00:24:46,000 --> 00:24:47,000
压力大不大

460
00:24:47,000 --> 00:24:50,000
问题关于中西文混排时的高度

461
00:24:50,000 --> 00:24:55,000
在一个 Label 上展示文字时最终展示的高度如何确定

462
00:24:55,000 --> 00:24:59,000
如果文字只有英文字号选择是 14 号字

463
00:24:59,000 --> 00:25:01,000
在两倍视网膜屏幕上

464
00:25:01,000 --> 00:25:05,000
那么最后文字的高度不会超过 28 px

465
00:25:05,000 --> 00:25:08,000
虽然他写的是 point 我估计这是笔误

466
00:25:08,000 --> 00:25:11,000
这个高度应该等于深部线到降部线的高度

467
00:25:11,000 --> 00:25:16,000
如果文字只有中文那么类似最后文字的高度也不会超过 28 px

468
00:25:16,000 --> 00:25:19,000
虽然中文不一定有深部线和降部线

469
00:25:19,000 --> 00:25:20,000
但是原理是类似的

470
00:25:20,000 --> 00:25:23,000
如果是中英混排最后文字的高度会是怎样

471
00:25:24,000 --> 00:25:28,000
我问了我们的设计师说是会比 28 px 多出一到两个像素

472
00:25:28,000 --> 00:25:30,000
这是什么原因呢

473
00:25:30,000 --> 00:25:32,000
是因为中文和英文的基线没有对齐吗

474
00:25:32,000 --> 00:25:34,000
希望可以得到主播的解答

475
00:25:34,000 --> 00:25:37,000
问题二关于多语言字符串

476
00:25:37,000 --> 00:25:39,000
先回答一个再讲吧

477
00:25:39,000 --> 00:25:43,000
这个我给他写了一个邮件去说明了一下其中一些问题

478
00:25:43,000 --> 00:25:49,000
但是我觉得他对他们的设计师对整个渲染机制可能没有理解

479
00:25:49,000 --> 00:25:51,000
所以说的完全不着调

480
00:25:52,000 --> 00:25:54,000
我还简单来说一下

481
00:25:54,000 --> 00:26:00,000
首先就是说 iOS 它维护了一套所谓的逻辑尺寸

482
00:26:00,000 --> 00:26:02,000
就是逻辑布局的空间

483
00:26:02,000 --> 00:26:10,000
所以它的这个 point 换算成一个 pixel 的值并不是一定 1 比 1、1 比 2、1 比 3 或者是 1 比几点几的

484
00:26:10,000 --> 00:26:14,000
因为还有像 iPhone Plus 这样子奇葩的屏幕分辨率

485
00:26:14,000 --> 00:26:17,000
另外就是用户也可以调这个屏幕分辨率

486
00:26:17,000 --> 00:26:18,000
就一定程度上

487
00:26:18,000 --> 00:26:20,000
叫什么 Dynamic Type 是吧

488
00:26:20,000 --> 00:26:23,000
就是它可以调这个缩放

489
00:26:23,000 --> 00:26:25,000
比如说你视力不好

490
00:26:25,000 --> 00:26:26,000
对对对

491
00:26:26,000 --> 00:26:27,000
所以你可以调这个

492
00:26:27,000 --> 00:26:31,000
所以这个具体几倍几倍其实是由操作系统来维护的

493
00:26:31,000 --> 00:26:35,000
那么你只能使用一个逻辑的 point 的值

494
00:26:35,000 --> 00:26:38,000
这个值是 iOS 给开发者使用的

495
00:26:38,000 --> 00:26:42,000
所以一个字符当它被设定成比如说 14 point 的时候

496
00:26:42,000 --> 00:26:47,000
其实简单来说我们用一个 typography unit 的概念来说

497
00:26:47,000 --> 00:26:51,000
我们就是将一个 em 的尺寸设成了 14 个 point

498
00:26:51,000 --> 00:26:59,000
那么究竟一个 em 的 glitch 它的显示的这个尺寸是多少个 point 或者是具体到多少个 pixel

499
00:26:59,000 --> 00:27:01,000
其实完全是由字体来决定的

500
00:27:01,000 --> 00:27:04,000
你可以将一个 em 的 glitch 设计的只占一个像素那么大

501
00:27:04,000 --> 00:27:09,000
你也可以设计的超过一个 em 的方格的空间

502
00:27:09,000 --> 00:27:11,000
这都是没有问题的

503
00:27:12,000 --> 00:27:15,000
所以具体渲染成多少个像素或者多少个 point

504
00:27:15,000 --> 00:27:17,000
完全是由这个字体来决定的

505
00:27:17,000 --> 00:27:20,000
就跟其他的没有任何关系

506
00:27:20,000 --> 00:27:22,000
就像你选 zapfino

507
00:27:22,000 --> 00:27:32,000
你选一个 14 号的 zapfino 最终渲染出来的一个单词可能会占 100 x 200 这么大

508
00:27:32,000 --> 00:27:33,000
这都是有可能的

509
00:27:33,000 --> 00:27:35,000
对比如说它的 f 就会非常的高

510
00:27:35,000 --> 00:27:37,000
有一个非常长的降步

511
00:27:37,000 --> 00:27:39,000
然后他问那个问题

512
00:27:39,000 --> 00:27:41,000
其实我理解是不是之前也遇到过

513
00:27:41,000 --> 00:27:45,000
就是以前你们记不记得 macOS 的 textedit 那个程序

514
00:27:45,000 --> 00:27:47,000
它会跳

515
00:27:47,000 --> 00:27:50,000
对它的中英文混排的时候那个航高是有问题的

516
00:27:50,000 --> 00:27:53,000
它不一致就不稳定

517
00:27:53,000 --> 00:27:54,000
因为是这个问题

518
00:27:54,000 --> 00:27:57,000
这个问题当时好像

519
00:27:57,000 --> 00:27:58,000
我们也讲过好像

520
00:27:58,000 --> 00:27:59,000
对对对

521
00:27:59,000 --> 00:28:00,000
它有个问题就是说

522
00:28:00,000 --> 00:28:06,000
当时的 textedit 好像是以整个文档的第一个字符的那个方式

523
00:28:06,000 --> 00:28:10,000
来决定这个文档的航高是多少的

524
00:28:10,000 --> 00:28:13,000
但是你在这个输入的这个 fly 的过程中

525
00:28:13,000 --> 00:28:15,000
就这个 input fly 的过程中

526
00:28:15,000 --> 00:28:22,000
它好像又会动态的去调用当前这个 glitch 的方式来计算当前这个光标所在位置的航高

527
00:28:22,000 --> 00:28:25,000
所以如果说你是一个多语言

528
00:28:25,000 --> 00:28:26,000
对对对就会有跳动

529
00:28:26,000 --> 00:28:28,000
但现在好像这个问题被改善了吧

530
00:28:28,000 --> 00:28:30,000
它会预设一个比较大的问题

531
00:28:30,000 --> 00:28:31,000
因为已经修复吧

532
00:28:31,000 --> 00:28:33,000
我最近好像没有注意到这个问题

533
00:28:33,000 --> 00:28:35,000
就再没出现过了

534
00:28:35,000 --> 00:28:37,000
对已经修复了

535
00:28:37,000 --> 00:28:42,000
那他问那个就中文和英文这个基线没有对齐这个事情是可能发生的吗

536
00:28:42,000 --> 00:28:44,000
还是说没有解决这个事

537
00:28:44,000 --> 00:28:46,000
对这就排排排排名前来决定的

538
00:28:46,000 --> 00:28:50,000
就中文你可以说是要它的基线来跟

539
00:28:50,000 --> 00:28:57,000
不对是用中文字框的底线和英文的基线对齐

540
00:28:57,000 --> 00:29:03,000
还是用中文现况的底线和英文现况的底线对齐

541
00:29:03,000 --> 00:29:10,000
还是用中文现况的上顶端和那个英文的就是上升部的顶端对齐

542
00:29:10,000 --> 00:29:14,000
这就很多这几种有什么就是我听出这个区别了

543
00:29:14,000 --> 00:29:17,000
就是说我们日常采取的一般是单独方式呢

544
00:29:17,000 --> 00:29:19,000
一般是基线对底线吗

545
00:29:19,000 --> 00:29:22,000
不是一般是基线对基线

546
00:29:22,000 --> 00:29:28,000
对就是说在正常的哪怕是中文或者汉字的字体设计里面

547
00:29:28,000 --> 00:29:31,000
现在呢就是真正的 Founder 们也会画一个基线

548
00:29:31,000 --> 00:29:33,000
虽然说基线也是给西文设计的

549
00:29:33,000 --> 00:29:36,000
但是呢就是说中文设计首先是有个字框嘛

550
00:29:36,000 --> 00:29:40,000
但是现在的现代字体都会在字框上面再补一个基线

551
00:29:40,000 --> 00:29:44,000
因为不管怎么样操作系统的话都是以基线来对齐的

552
00:29:44,000 --> 00:29:50,000
无论是 Found 很多排排引擎还有 Web 都是这样

553
00:29:50,000 --> 00:29:54,000
它只去调用一个 Found 里面的基线

554
00:29:54,000 --> 00:29:58,000
所以呢它即使是中文字体它也会设成一个基线

555
00:29:58,000 --> 00:30:02,000
然后在很多的中文日文字体比如说大家会默认

556
00:30:02,000 --> 00:30:06,000
中文的方框是那个字框是 10001000 嘛

557
00:30:06,000 --> 00:30:11,000
的一个正方形的话一般来讲会把这个基线放在 120 左右

558
00:30:11,000 --> 00:30:16,000
就是底下 120 上面 880 就是放在这样一个位置

559
00:30:16,000 --> 00:30:19,000
然后呢排排引擎的话不管你是中文还是西文

560
00:30:19,000 --> 00:30:25,000
它都会去调用你这个 Found 里面 Metrics 里面的这个基线的位置

561
00:30:25,000 --> 00:30:27,000
它是按基线对齐的

562
00:30:27,000 --> 00:30:34,000
无论你这个是阿拉伯文还是印度的天成文还是中文的汉字

563
00:30:34,000 --> 00:30:36,000
它们都有一个基线的值

564
00:30:36,000 --> 00:30:40,000
所以那个印度天成就是天成文的那个基线在哪

565
00:30:40,000 --> 00:30:42,000
是在靠下的位置还是

566
00:30:42,000 --> 00:30:46,000
天成文它本身的基线它是憨音它是挂在上面的

567
00:30:46,000 --> 00:30:50,000
但是呢它为了混排的话它也有

568
00:30:50,000 --> 00:30:54,000
它也在事先字体设计要设一个基线

569
00:30:54,000 --> 00:30:55,000
虽然它不用

570
00:30:55,000 --> 00:30:58,000
名字叫什么呢是叫 Bassline 还是

571
00:30:58,000 --> 00:30:59,000
就是叫 Bassline

572
00:30:59,000 --> 00:31:01,000
然后它本身的那条 Hungline 叫什么

573
00:31:01,000 --> 00:31:02,000
叫 Hungline 吗

574
00:31:03,000 --> 00:31:05,000
那个有天成文它们自己的名字

575
00:31:05,000 --> 00:31:06,000
Ok

576
00:31:06,000 --> 00:31:11,000
就是 OpenType 里面有一个 Table 就叫 Bass

577
00:31:11,000 --> 00:31:15,000
就是 Bass 这个 Table 就是描述的你这条 Bassline 的位置

578
00:31:15,000 --> 00:31:20,000
在这个原始坐标 00 跟它相对的这个位置在哪里

579
00:31:20,000 --> 00:31:23,000
其实它默认就在 00 这个位置上了

580
00:31:23,000 --> 00:31:25,000
那么那个你在设一个中文字体的时候呢

581
00:31:25,000 --> 00:31:29,000
你可以将你的这个起点比如说设在 0-多少多少

582
00:31:29,000 --> 00:31:32,000
比如说-120 这个是 Adobe 常用的一个数值

583
00:31:32,000 --> 00:31:34,000
那么 Monotype 可能会有什么-110 之类的

584
00:31:34,000 --> 00:31:39,000
就每个自己厂商他们都会有他自己的 convention 来做这个事情

585
00:31:39,000 --> 00:31:42,000
所以呢其实这个就是一个普通的字体文件里面

586
00:31:42,000 --> 00:31:45,000
它 Metrics 我们叫度量或者量度它的一个设置

587
00:31:45,000 --> 00:31:48,000
就自己设计是必须要设置的

588
00:31:48,000 --> 00:31:51,000
然后再由排版引擎去调用

589
00:31:51,000 --> 00:31:52,000
Ok

590
00:31:52,000 --> 00:31:55,000
所以就其实不会出现这个中文

591
00:31:55,000 --> 00:31:58,000
他问的这个中文和英文基线没对齐的情况对吧

592
00:31:58,000 --> 00:32:00,000
这个好像还是可以改的吧

593
00:32:00,000 --> 00:32:05,000
就是比如说像我说的你可以强行说在这个排版的时候

594
00:32:05,000 --> 00:32:09,000
或者说在这个 Label 里面让所有字符底端对齐

595
00:32:09,000 --> 00:32:11,000
这个还是可以做到的

596
00:32:11,000 --> 00:32:12,000
可以的

597
00:32:12,000 --> 00:32:14,000
如果你强行要这么设的话还是可能的

598
00:32:14,000 --> 00:32:19,000
因为像那个 CSS 里面就是有这个一个几个基线对齐的概念嘛

599
00:32:19,000 --> 00:32:22,000
但是他他他他应该没有区分这个多元文本

600
00:32:22,000 --> 00:32:24,000
他是整个和那个图片的对齐

601
00:32:24,000 --> 00:32:30,000
那想来如果一个比较高级的排版引擎应该也是可以允许做这种

602
00:32:30,000 --> 00:32:32,000
比较非标准的操作吧

603
00:32:32,000 --> 00:32:35,000
如果是印刷方面的话比如说 indesign 的话

604
00:32:35,000 --> 00:32:39,000
这个特别尤其是中西文化比如说在做复合字体的时候

605
00:32:39,000 --> 00:32:41,000
就可以做基线偏移

606
00:32:41,000 --> 00:32:45,000
而且呢在在更以广的范围来讲

607
00:32:45,000 --> 00:32:48,000
比如说把一个数字做成上标或者下标

608
00:32:48,000 --> 00:32:50,000
其实也是一种基线偏移

609
00:32:50,000 --> 00:32:57,000
就是在不同的不同的环境下不同的排版引擎都是有这样的功能的

610
00:32:57,000 --> 00:33:00,000
那具体在 CSS 的话是另外的实现吧对吧

611
00:33:00,000 --> 00:33:04,000
对 CSS 他是这样的就是他的机制比较麻烦

612
00:33:04,000 --> 00:33:09,000
他有一个所谓的 linebox 和这个 inlinebox 的概念

613
00:33:09,000 --> 00:33:12,000
所以就是当他放到盒子里嘛

614
00:33:12,000 --> 00:33:17,000
他会把一个行内的一小段字符串

615
00:33:17,000 --> 00:33:20,000
计算他一个很小的一个矩形

616
00:33:20,000 --> 00:33:22,000
然后矩形的这个高度会有一个高度

617
00:33:22,000 --> 00:33:25,000
然后基线会在这个矩形内部的一个相对位置里面

618
00:33:25,000 --> 00:33:30,000
然后这个时候 CSS 的那个 vertical align 这个属性

619
00:33:30,000 --> 00:33:32,000
这个 propte 里面设了几种值

620
00:33:32,000 --> 00:33:35,000
就会来决定这个基线之间相互对齐的关系

621
00:33:35,000 --> 00:33:38,000
但这个 vertical align 的这个属性非常的不直观

622
00:33:38,000 --> 00:33:41,000
我觉得这是 CSS 设计的一个缺陷吧

623
00:33:41,000 --> 00:33:46,000
就是对于入门者来说你很难去直观的感受到你做了哪些对齐

624
00:33:46,000 --> 00:33:48,000
因为你有的时候选 middle 对齐的时候

625
00:33:48,000 --> 00:33:51,000
你发现他其实并不是你预期的那种 middle 的方式

626
00:33:51,000 --> 00:33:54,000
他是以他定义的那种 middle 的方式

627
00:33:54,000 --> 00:33:58,000
然后 base line 是默认的一种对齐方式

628
00:33:58,000 --> 00:34:01,000
这个还和字体有关系吧

629
00:34:01,000 --> 00:34:03,000
CSS 他会比较简单

630
00:34:03,000 --> 00:34:14,000
他会对一段文字使用同一种字体的这个参数来计算这个 linebox 的高度的这样一个属性

631
00:34:14,000 --> 00:34:18,000
但是这个 linebox 的高度他算起来就不是很准

632
00:34:18,000 --> 00:34:20,000
他也不是在所有地方都很准

633
00:34:22,000 --> 00:34:24,000
而且他首先他会调用就是

634
00:34:24,000 --> 00:34:26,000
因为如果你是调用一个中文字体的话

635
00:34:26,000 --> 00:34:28,000
中文字体内部也有 C 文

636
00:34:28,000 --> 00:34:35,000
首先他会调用一个字体设计师他本身设定好的就是中西文的那个机械

637
00:34:35,000 --> 00:34:39,000
因为这个你调用的字体 phone 的本身是有这个信息的

638
00:34:39,000 --> 00:34:41,000
然后他要拿到这个信息的话

639
00:34:41,000 --> 00:34:43,000
这个信息再继续调整

640
00:34:44,000 --> 00:34:46,000
对但 CSS 有个问题就是说

641
00:34:46,000 --> 00:34:49,000
他在计算一个 linebox 的这个高度的时候

642
00:34:49,000 --> 00:34:54,000
他默认是按 CSS 设定的那个 line height 的那个数值来计算的

643
00:34:55,000 --> 00:35:01,000
对但这个 line height 的值未必跟字体设计师定义的那个默认的 line height 是一样的

644
00:35:01,000 --> 00:35:05,000
所以这个时候机械应该放在什么位置其实是有一点问题的

645
00:35:05,000 --> 00:35:07,000
有的时候是会出 bug 的

646
00:35:08,000 --> 00:35:11,000
line height 的话就是我们说中文就是行高嘛

647
00:35:11,000 --> 00:35:14,000
那大家也知道 CSS 里面行高的话

648
00:35:14,000 --> 00:35:18,000
他是要把行间距除以 2

649
00:35:18,000 --> 00:35:21,000
一半放上面一半放下面

650
00:35:21,000 --> 00:35:22,000
对对对

651
00:35:22,000 --> 00:35:23,000
那个盒子的对

652
00:35:23,000 --> 00:35:27,000
所以这个盒子是怎么算的是比较麻烦

653
00:35:28,000 --> 00:35:32,000
对特别是你多种字体混合组合的时候会有一些问题

654
00:35:33,000 --> 00:35:36,000
而且是不同字号的时候会非常麻烦

655
00:35:36,000 --> 00:35:38,000
啊对

656
00:35:39,000 --> 00:35:42,000
OK 他他问了第二个问题啊

657
00:35:42,000 --> 00:35:44,000
是关于这个多语言字符串

658
00:35:44,000 --> 00:35:47,000
关于多语言字符串的排序和所以

659
00:35:47,000 --> 00:35:48,000
这个要讲吗

660
00:35:48,000 --> 00:35:51,000
这个是不是跟今天我们要说的有点关系

661
00:35:51,000 --> 00:35:53,000
有点关系或者说

662
00:35:54,000 --> 00:35:57,000
要不我们等到后面专门一起来讲的排序

663
00:35:57,000 --> 00:36:00,000
对要不我们就先念一下他这个邮件吧

664
00:36:00,000 --> 00:36:02,000
就答不答再说了

665
00:36:03,000 --> 00:36:04,000
如今是多语言国际化的时代

666
00:36:04,000 --> 00:36:07,000
多语言字符串排序和索引的规则是什么呢

667
00:36:07,000 --> 00:36:10,000
iPhone 通讯录中姓名的排序规则是什么呢

668
00:36:10,000 --> 00:36:12,000
对于整个问题我自己也做了

669
00:36:12,000 --> 00:36:13,000
我自己也做了一些研究

670
00:36:13,000 --> 00:36:16,000
大致是 unicode 给出了一套规则

671
00:36:16,000 --> 00:36:18,000
根据这个规则来实现就好了

672
00:36:18,000 --> 00:36:20,000
但是 unicode 的文档

673
00:36:20,000 --> 00:36:22,000
卷纸号凡吗

674
00:36:22,000 --> 00:36:24,000
这是卷纸

675
00:36:24,000 --> 00:36:25,000
我实在无能为力

676
00:36:25,000 --> 00:36:26,000
卷义号凡吗是吧

677
00:36:26,000 --> 00:36:27,000
卷义

678
00:36:27,000 --> 00:36:29,000
这是义字吗

679
00:36:29,000 --> 00:36:30,000
这是纸吧

680
00:36:30,000 --> 00:36:32,000
对卷纸

681
00:36:32,000 --> 00:36:35,000
卷纸号凡

682
00:36:35,000 --> 00:36:38,000
各位提供暴露了自己的文化修养

683
00:36:38,000 --> 00:36:39,000
生掉念头了

684
00:36:39,000 --> 00:36:41,000
我实在无能为力完全搞懂

685
00:36:41,000 --> 00:36:42,000
我自己总结了一点东西

686
00:36:42,000 --> 00:36:44,000
写了三篇文章放在博客上

687
00:36:44,000 --> 00:36:46,000
希望可以得到两位主播的指点

688
00:36:46,000 --> 00:36:48,000
同时我自己也有一点问题没有搞明白

689
00:36:48,000 --> 00:36:49,000
第一

690
00:36:49,000 --> 00:36:51,000
索引时指定的排序规则是什么呢

691
00:36:51,000 --> 00:36:52,000
似乎是按照评音

692
00:36:52,000 --> 00:36:55,000
但是中文和英文交织并不一定中文

693
00:36:55,000 --> 00:36:58,000
并不是中文一定在英文前面或者后面

694
00:36:58,000 --> 00:37:00,000
怎样得到每个汉字的读音呢

695
00:37:00,000 --> 00:37:03,000
在指定汉字顺势的

696
00:37:03,000 --> 00:37:06,000
zh.xml

697
00:37:06,000 --> 00:37:08,000
这是一个文件

698
00:37:08,000 --> 00:37:12,000
汉字读音在警号之后似乎是被注视掉了

699
00:37:12,000 --> 00:37:14,000
那么怎么知道汉字的读音呢

700
00:37:14,000 --> 00:37:15,000
具体来说

701
00:37:15,000 --> 00:37:18,000
左边的读音是左边

702
00:37:18,000 --> 00:37:19,000
它写的是一个拼音的左边

703
00:37:19,000 --> 00:37:21,000
是怎么被确定的呢

704
00:37:21,000 --> 00:37:23,000
这个问题和字体排音没啥关系

705
00:37:23,000 --> 00:37:25,000
和你们做的 unicode 串台节目

706
00:37:25,000 --> 00:37:26,000
有那么一点点关系

707
00:37:26,000 --> 00:37:28,000
所以希望可以得到解答

708
00:37:28,000 --> 00:37:30,000
这个问题已经困扰我好久好久了

709
00:37:30,000 --> 00:37:36,000
他应该是拿了一个什么 database 来做这个排序吧

710
00:37:36,000 --> 00:37:38,000
这个事比较复杂

711
00:37:38,000 --> 00:37:40,000
那个 iPhone 的那个通讯

712
00:37:40,000 --> 00:37:43,000
iOS 通讯楼上面它有一个这个机制就可能很多

713
00:37:43,000 --> 00:37:45,000
iPhone 上我不知道有没有办法添加

714
00:37:45,000 --> 00:37:48,000
在 Mac 上是可以给那个联系人的名字

715
00:37:48,000 --> 00:37:50,000
加一个叫做 phonetic

716
00:37:50,000 --> 00:37:51,000
对注音

717
00:37:51,000 --> 00:37:52,000
对我想说

718
00:37:52,000 --> 00:37:54,000
它除了它有一个 phonetic

719
00:37:54,000 --> 00:37:57,000
还有另外一个注音

720
00:37:57,000 --> 00:37:59,000
就除了 phonetic 之外

721
00:37:59,000 --> 00:38:00,000
还有另外一个注音

722
00:38:00,000 --> 00:38:02,000
我忘了叫什么字还是

723
00:38:02,000 --> 00:38:04,000
然后这两个可以

724
00:38:04,000 --> 00:38:07,000
这两个可以拿来做排序的依据

725
00:38:07,000 --> 00:38:11,000
但是排序的时候的那个

726
00:38:11,000 --> 00:38:12,000
比如说你用中文

727
00:38:12,000 --> 00:38:14,000
就是你把系统设成中文的时候

728
00:38:14,000 --> 00:38:17,000
排序规则跟设成英文的时候排序规则不一样

729
00:38:17,000 --> 00:38:22,000
哪怕你设成中文也可以用不同的排序

730
00:38:22,000 --> 00:38:24,000
如果大家用 Mac 的话

731
00:38:24,000 --> 00:38:26,000
打开那个系统批号设置

732
00:38:26,000 --> 00:38:31,000
语言地区那边就专门有一个列表排列顺序的一个设置

733
00:38:31,000 --> 00:38:34,000
然后中文默认是拼音顺序

734
00:38:34,000 --> 00:38:36,000
但是中文中文你也可以用

735
00:38:36,000 --> 00:38:39,000
比如说你用笔画顺序也可以

736
00:38:39,000 --> 00:38:42,000
用 GB 的内码的顺序也可以

737
00:38:42,000 --> 00:38:45,000
对但是在手机上面有这个设置吗

738
00:38:45,000 --> 00:38:48,000
跟你的语言环境有关系

739
00:38:48,000 --> 00:38:51,000
我的理解是在用那个

740
00:38:51,000 --> 00:38:56,000
比如说你在 Mac 上面可以说我的系统语言是英语

741
00:38:56,000 --> 00:39:00,000
但是我的第三 preferred language 是中文

742
00:39:01,000 --> 00:39:08,000
与此同时我可以把 list source order 设成中文的

743
00:39:08,000 --> 00:39:10,000
比如说笔画排序或者是注音排序

744
00:39:10,000 --> 00:39:13,000
但是在 iPhone 上是没有这个设定的

745
00:39:13,000 --> 00:39:15,000
就是你不能说系统语言是中文

746
00:39:15,000 --> 00:39:19,000
系统语言是英文同时你还可以指定中文的排序方式

747
00:39:19,000 --> 00:39:26,000
就是我以前在推上好像是跟精雷还是谁去研究过这个问题

748
00:39:26,000 --> 00:39:31,000
他想说手机的系统是英文的同时

749
00:39:31,000 --> 00:39:36,000
还可以让通讯录按照中文的笔画数去排列

750
00:39:36,000 --> 00:39:39,000
但后来发现这个其实做不到的

751
00:39:39,000 --> 00:39:43,000
当时我产生的状态是我先把手机设成中文

752
00:39:43,000 --> 00:39:50,000
然后发现通讯录被用中文 iOS 的默认通讯录排序是什么来着

753
00:39:50,000 --> 00:39:52,000
是注音排序

754
00:39:52,000 --> 00:39:54,000
拼音吧

755
00:39:54,000 --> 00:39:58,000
然后当我切换回英文系统的时候

756
00:39:58,000 --> 00:40:00,000
这个排序是得以保留的

757
00:40:00,000 --> 00:40:04,000
但是只要我往里面新加一个通讯录了

758
00:40:04,000 --> 00:40:06,000
只要我往里面新加一个联络人

759
00:40:06,000 --> 00:40:10,000
整个排序就又变成了英文排序

760
00:40:10,000 --> 00:40:12,000
然后所有的中文会被集中堆在后面

761
00:40:12,000 --> 00:40:14,000
除非你设定了那个

762
00:40:14,000 --> 00:40:18,000
Pronunciation

763
00:40:18,000 --> 00:40:20,000
它才会在英文的部分出现

764
00:40:21,000 --> 00:40:23,000
我的情况好

765
00:40:23,000 --> 00:40:25,000
我的 iPhone 是设置成日文状态的

766
00:40:25,000 --> 00:40:26,000
然后呢

767
00:40:26,000 --> 00:40:29,000
所以我打开我的那个通讯录的时候呢

768
00:40:29,000 --> 00:40:30,000
因为日文状态

769
00:40:30,000 --> 00:40:32,000
它会默认用那首先日文排序

770
00:40:32,000 --> 00:40:35,000
首先右边那个 index

771
00:40:35,000 --> 00:40:38,000
右边不是有个快速的可以转播那个 index 吗

772
00:40:38,000 --> 00:40:39,000
如果是这样的话

773
00:40:39,000 --> 00:40:40,000
在日文状态的话

774
00:40:40,000 --> 00:40:42,000
首先它会有日文的 akasatana 的顺序

775
00:40:42,000 --> 00:40:44,000
然后后面还有 26 个字母的顺序

776
00:40:44,000 --> 00:40:45,000
所以呢

777
00:40:45,000 --> 00:40:46,000
在这样的状态

778
00:40:46,000 --> 00:40:48,000
日文和那个英文首先是分开的

779
00:40:48,000 --> 00:40:49,000
然后呢

780
00:40:49,000 --> 00:40:51,000
因为我系统默认是日文

781
00:40:51,000 --> 00:40:52,000
所以首先呢

782
00:40:52,000 --> 00:40:55,000
汉字呢是按照那个日文顺序排的

783
00:40:55,000 --> 00:40:57,000
然后如果我

784
00:40:57,000 --> 00:40:59,000
当然我这里面有中国朋友

785
00:40:59,000 --> 00:41:02,000
中国朋友如果我不加注音的话

786
00:41:02,000 --> 00:41:04,000
它的中文汉字的

787
00:41:04,000 --> 00:41:06,000
所有是堆在底下的

788
00:41:06,000 --> 00:41:08,000
警号的那个

789
00:41:08,000 --> 00:41:09,000
对警号的

790
00:41:09,000 --> 00:41:11,000
但是如果我

791
00:41:11,000 --> 00:41:14,000
因为这个注音这个词在日文是非常常见的

792
00:41:14,000 --> 00:41:15,000
因为日本人的汉字

793
00:41:15,000 --> 00:41:16,000
如果你不加读音

794
00:41:16,000 --> 00:41:18,000
根本都不知道他怎么念

795
00:41:18,000 --> 00:41:19,000
所以这一般来

796
00:41:19,000 --> 00:41:21,000
对他如果是开成日文以后

797
00:41:21,000 --> 00:41:22,000
他会默认

798
00:41:22,000 --> 00:41:24,000
首先把那个注音的那个 field 打开

799
00:41:24,000 --> 00:41:25,000
他会让你写

800
00:41:25,000 --> 00:41:28,000
中文的话可能有时候他默认不打开

801
00:41:28,000 --> 00:41:30,000
很多人都不知道有这样一个 field

802
00:41:30,000 --> 00:41:32,000
在日本的话

803
00:41:32,000 --> 00:41:33,000
那个 field 默认是打开的

804
00:41:33,000 --> 00:41:36,000
你可以往里面填这个词怎么念

805
00:41:36,000 --> 00:41:39,000
然后呢我个人的做法是把这个中文的名字

806
00:41:39,000 --> 00:41:40,000
把它拼音写上去

807
00:41:40,000 --> 00:41:41,000
这样的话呢

808
00:41:41,000 --> 00:41:43,000
在我的手机范围里面

809
00:41:43,000 --> 00:41:45,000
日本人就在假名那一堆

810
00:41:45,000 --> 00:41:49,000
然后中国人就按照拼音放在这个 Alphabet 这一堆

811
00:41:49,000 --> 00:41:50,000
我个人是这样去分的

812
00:41:50,000 --> 00:41:52,000
哦 还这样好啊

813
00:41:52,000 --> 00:41:54,000
但是很麻烦啊

814
00:41:54,000 --> 00:41:55,000
你要每个人

815
00:41:55,000 --> 00:41:57,000
这是一个非常蛋疼的事情对

816
00:41:57,000 --> 00:41:58,000
对

817
00:41:58,000 --> 00:42:00,000
所以在那个 Mac 上面

818
00:42:00,000 --> 00:42:03,000
就是我们的朋友就是江江

819
00:42:03,000 --> 00:42:05,000
他之前写过一个小软件

820
00:42:05,000 --> 00:42:09,000
就是自动给那个通讯录里面的中文名字的人

821
00:42:09,000 --> 00:42:11,000
标注他的那个 phonetic names

822
00:42:11,000 --> 00:42:13,000
就是 phonetic 的姓和名

823
00:42:13,000 --> 00:42:16,000
就叫他他就可以在应用环境下

824
00:42:16,000 --> 00:42:19,000
还可以按照那个读音来排序

825
00:42:19,000 --> 00:42:22,000
对这件事比较适合脚本来做

826
00:42:22,000 --> 00:42:23,000
对对

827
00:42:23,000 --> 00:42:25,000
但 iPhone 上好像就这个我不知道有人

828
00:42:25,000 --> 00:42:27,000
音乐也是可以的

829
00:42:27,000 --> 00:42:29,000
就是知道数据导一下吗

830
00:42:29,000 --> 00:42:30,000
对对

831
00:42:30,000 --> 00:42:32,000
因为 iPhone 那个就是通讯录是可以访问的嘛

832
00:42:32,000 --> 00:42:33,000
通过 API

833
00:42:33,000 --> 00:42:34,000
然后你去给他改一下

834
00:42:34,000 --> 00:42:37,000
但这里就会牵涉到他问的那个第二个问题

835
00:42:37,000 --> 00:42:38,000
就怎样得到一个汉字的读音

836
00:42:38,000 --> 00:42:39,000
因为这个

837
00:42:39,000 --> 00:42:40,000
比较简单的

838
00:42:40,000 --> 00:42:42,000
比较简单的就是有一个对照表的

839
00:42:42,000 --> 00:42:44,000
就是汉字和他的那个拼音的对照表的

840
00:42:44,000 --> 00:42:46,000
这个是这个是很多线上面都自带的

841
00:42:46,000 --> 00:42:48,000
但这个比较 tricky 的

842
00:42:48,000 --> 00:42:51,000
就是说有些字是那个多音字

843
00:42:51,000 --> 00:42:53,000
这个时候特别是在那个名字里面

844
00:42:53,000 --> 00:42:55,000
他有些很多是非标

845
00:42:55,000 --> 00:42:57,000
没有就不太具备这个参考意义的

846
00:42:57,000 --> 00:42:59,000
比如说有些有些字的多音字

847
00:42:59,000 --> 00:43:01,000
你是可以通过这个上下文的语意来

848
00:43:01,000 --> 00:43:03,000
看出他是念哪个的嘛

849
00:43:03,000 --> 00:43:05,000
但是在名字里面其实是一个非常

850
00:43:05,000 --> 00:43:06,000
啊

851
00:43:06,000 --> 00:43:07,000
啊

852
00:43:07,000 --> 00:43:08,000
啊

853
00:43:08,000 --> 00:43:10,000
比如说有一个朋友叫

854
00:43:10,000 --> 00:43:12,000
叫那个就是草字头一个下面

855
00:43:12,000 --> 00:43:13,000
东南西北的西字那个字

856
00:43:13,000 --> 00:43:15,000
他可以念西也可以念欠对吧

857
00:43:15,000 --> 00:43:16,000
对对

858
00:43:16,000 --> 00:43:19,000
在在名字里面很多人都是把他念欠的

859
00:43:19,000 --> 00:43:20,000
对吧

860
00:43:20,000 --> 00:43:22,000
但其实在他在选择的时候

861
00:43:22,000 --> 00:43:24,000
就把他念成念西

862
00:43:24,000 --> 00:43:25,000
这个时候你说你怎么办

863
00:43:25,000 --> 00:43:26,000
你没有办法

864
00:43:26,000 --> 00:43:28,000
对这点还好

865
00:43:28,000 --> 00:43:31,000
另外有一个问题就是有些人的这个

866
00:43:31,000 --> 00:43:32,000
信

867
00:43:32,000 --> 00:43:33,000
的同一个字的写法

868
00:43:33,000 --> 00:43:35,000
他甚至都有不一样的念法

869
00:43:35,000 --> 00:43:37,000
信的话

870
00:43:37,000 --> 00:43:41,000
一般做信的那个音会会比较比较特殊的

871
00:43:41,000 --> 00:43:43,000
就有一些会有白白白

872
00:43:43,000 --> 00:43:44,000
白读嘛

873
00:43:44,000 --> 00:43:46,000
然后这个白读又会被这个当成一种传统

874
00:43:46,000 --> 00:43:48,000
比如说那个最

875
00:43:48,000 --> 00:43:51,000
我印象最深的就是有一个信叫盖嘛

876
00:43:51,000 --> 00:43:52,000
你们知道吗

877
00:43:52,000 --> 00:43:55,000
就是盖子的盖盖叫天有一个经济原因

878
00:43:55,000 --> 00:43:56,000
嗯

879
00:43:56,000 --> 00:43:59,000
对但是这个信其实他在念信的时候

880
00:43:59,000 --> 00:44:01,000
一个比较规范的地方应该念葛

881
00:44:02,000 --> 00:44:03,000
嗯

882
00:44:03,000 --> 00:44:06,000
对但是很多人都觉得普述嘛

883
00:44:06,000 --> 00:44:08,000
普述这个普述

884
00:44:08,000 --> 00:44:09,000
啊

885
00:44:09,000 --> 00:44:10,000
那叫朴呀

886
00:44:10,000 --> 00:44:12,000
对不过他这个应该是小众吧

887
00:44:12,000 --> 00:44:14,000
他应该是一个义民之类的小众

888
00:44:14,000 --> 00:44:16,000
但那个盖和葛的问题就是

889
00:44:16,000 --> 00:44:20,000
很多人他都希望自己被念成叫盖

890
00:44:20,000 --> 00:44:22,000
就是不要改成葛这个音

891
00:44:22,000 --> 00:44:25,000
但是有一些人他可能祖上传下一直都念葛

892
00:44:25,000 --> 00:44:27,000
所以他又希望这个字念葛

893
00:44:27,000 --> 00:44:29,000
所以这个字念什么音其实也是不一样的

894
00:44:29,000 --> 00:44:31,000
就是就是就是说

895
00:44:31,000 --> 00:44:36,000
刚才讲那个问题就是信明里面这个读音是没有一个规则可以参考

896
00:44:36,000 --> 00:44:38,000
因为很多是靠他自己

897
00:44:38,000 --> 00:44:40,000
自定的一个选择来怎么念的

898
00:44:40,000 --> 00:44:42,000
这个是非常尴尬

899
00:44:42,000 --> 00:44:50,000
而且这个问题其实并不仅仅是中文或者是在表意文字才有的

900
00:44:50,000 --> 00:44:53,000
就在英文或者说在拉丁语

901
00:44:53,000 --> 00:44:56,000
拉丁字符世界甚至是拼字符世界也是有的

902
00:44:56,000 --> 00:45:02,000
比如说前阵子韩国被朝鲜弄死的那个美国人

903
00:45:02,000 --> 00:45:06,000
他的名字叫做 Warm Beer

904
00:45:06,000 --> 00:45:08,000
就是你如果你是一个美国人的话

905
00:45:08,000 --> 00:45:11,000
你念他的名字你会念成 Warm Beer

906
00:45:11,000 --> 00:45:16,000
然后有一天但是 Warm 和 Beer 这两个词就遇到了德语词

907
00:45:16,000 --> 00:45:18,000
包括这个人的整个的名字

908
00:45:18,000 --> 00:45:19,000
他的名字叫什么来着

909
00:45:19,000 --> 00:45:21,000
Auto Warm Beer

910
00:45:21,000 --> 00:45:24,000
这一听就是一个德国后裔你知道吧

911
00:45:24,000 --> 00:45:26,000
就是那种感觉就好像

912
00:45:26,000 --> 00:45:28,000
就好像这种感觉很奇怪

913
00:45:28,000 --> 00:45:30,000
就好像你是一个华人

914
00:45:30,000 --> 00:45:32,000
然后现在中国人已经是什么

915
00:45:32,000 --> 00:45:38,000
跑去我们这一带就是很多人都是双字名的

916
00:45:38,000 --> 00:45:44,000
现在的中国小孩都起什么什么易轩啊子轩啊

917
00:45:44,000 --> 00:45:47,000
什么这种非常又浓

918
00:45:47,000 --> 00:45:50,000
说不出来奇怪在哪但是有点奇怪的名字

919
00:45:51,000 --> 00:45:55,000
然后后来有一天你发现应该在美国出生的土生出长的华裔

920
00:45:55,000 --> 00:45:59,000
名字叫曾国藩或者左宗昌这种感觉

921
00:45:59,000 --> 00:46:03,000
非常古典

922
00:46:03,000 --> 00:46:05,000
他的中名是什么来着

923
00:46:05,000 --> 00:46:10,000
Auto Friedrich

924
00:46:10,000 --> 00:46:13,000
Warm Beer

925
00:46:13,000 --> 00:46:14,000
这样一个名字

926
00:46:14,000 --> 00:46:18,000
这个名字如果你如果他是一个德国人的话

927
00:46:19,000 --> 00:46:22,000
那么他的名字会变成 Warm Beer

928
00:46:22,000 --> 00:46:24,000
但如果他是一个美国人的话

929
00:46:24,000 --> 00:46:28,000
包括德国人念他在广播里面念这个人的名字的时候

930
00:46:28,000 --> 00:46:30,000
都会念成 Warm Beer

931
00:46:30,000 --> 00:46:33,000
就是按美语的发音来念

932
00:46:33,000 --> 00:46:39,000
所以这就是为什么刚才说到的那个在 iPhone 的联系人里面

933
00:46:39,000 --> 00:46:44,000
你可以给他添加两个额外的项目

934
00:46:44,000 --> 00:46:47,000
一个叫做 Pronunciation

935
00:46:47,000 --> 00:46:49,000
Pronunciation

936
00:46:49,000 --> 00:46:51,000
另外一个叫做 Phonetic

937
00:46:51,000 --> 00:46:59,000
就是我记得这两个之中一个会被 Siri 拿来当做发音的依据

938
00:46:59,000 --> 00:47:00,000
对

939
00:47:00,000 --> 00:47:07,000
就比如说你比如说吴涛这两个字你可以在

940
00:47:07,000 --> 00:47:09,000
在 Phonetic

941
00:47:10,000 --> 00:47:12,000
在 Phonetic

942
00:47:12,000 --> 00:47:16,000
里面写 WTAU

943
00:47:16,000 --> 00:47:24,000
但是在 Pronunciation 里面你可以写 WOO-TAU

944
00:47:24,000 --> 00:47:30,000
比如说然后 Siri 会试着用 WUTAW 这个方法来念这个

945
00:47:30,000 --> 00:47:35,000
Pronunciation 就纯粹是给那个语音生成那个合成器用的对吧

946
00:47:35,000 --> 00:47:36,000
对我是这么理解的

947
00:47:36,000 --> 00:47:38,000
当然我从来没有用过

948
00:47:38,000 --> 00:47:40,000
但我相信用过的人应该可以知道

949
00:47:40,000 --> 00:47:48,000
比如说你可以用这个功能来告诉 Siri 说打电话给谁是谁实现这样一个功能

950
00:47:48,000 --> 00:47:55,000
还有一个更直接的办法就是 Siri 的话你可以直接语音把这个字念成什么

951
00:47:55,000 --> 00:47:57,000
对

952
00:47:57,000 --> 00:47:59,000
所以

953
00:47:59,000 --> 00:48:00,000
对

954
00:48:00,000 --> 00:48:07,000
所以就专门有这样的一个 Field 是给语音合成器来教他念读音的这样一个 Field

955
00:48:07,000 --> 00:48:09,000
这个 Field 好像只有 LOS 上才有

956
00:48:09,000 --> 00:48:11,000
Mac 上是没有这个 Field

957
00:48:11,000 --> 00:48:12,000
我刚刚有检查了一遍

958
00:48:12,000 --> 00:48:14,000
因为 Mac 上之前没有 Siri

959
00:48:14,000 --> 00:48:15,000
所以估计没做

960
00:48:15,000 --> 00:48:17,000
但现在 Mac 上也有 Siri

961
00:48:17,000 --> 00:48:18,000
现在有了呀

962
00:48:18,000 --> 00:48:19,000
怎么办

963
00:48:19,000 --> 00:48:24,000
但是在那个 Contact 就是通讯录的那个添加那个

964
00:48:24,000 --> 00:48:25,000
那个叫什么来着

965
00:48:25,000 --> 00:48:30,000
那个 Field 那个里面是没有没有那个字端的没有 pronunciation

966
00:48:30,000 --> 00:48:31,000
只有 Fornetic

967
00:48:31,000 --> 00:48:32,000
对应该只有 Fornetic

968
00:48:32,000 --> 00:48:33,000
Pronunciation 什么出了

969
00:48:33,000 --> 00:48:35,000
他还没更新到哪里来

970
00:48:35,000 --> 00:48:38,000
Anyway 这个邮件里面其实还提了一个非常重要的事

971
00:48:38,000 --> 00:48:40,000
就是说其实我理解啊

972
00:48:40,000 --> 00:48:43,000
就是说在这种多语言的时候怎么排序

973
00:48:43,000 --> 00:48:48,000
比如刚才我们提到的这个日文环境和这个这个德语环境的时候

974
00:48:48,000 --> 00:48:49,000
他都是有这个区别的

975
00:48:49,000 --> 00:48:50,000
你没有想过这个问题

976
00:48:50,000 --> 00:48:52,000
如果一个人他精通多国语言

977
00:48:52,000 --> 00:48:55,000
比如说他会日语然后韩语

978
00:48:55,000 --> 00:48:57,000
然后会什么阿拉伯语

979
00:48:57,000 --> 00:49:01,000
他还都有讲这种语种的或者是这个名字的这个朋友

980
00:49:01,000 --> 00:49:03,000
他通讯录怎么办

981
00:49:06,000 --> 00:49:09,000
不过我们觉得应该把这件事情啊说

982
00:49:09,000 --> 00:49:11,000
要分好多层次来说

983
00:49:11,000 --> 00:49:13,000
别这样子乱起吧

984
00:49:13,000 --> 00:49:17,000
首先是有一个代码层面的问题

985
00:49:17,000 --> 00:49:18,000
对不对

986
00:49:18,000 --> 00:49:19,000
然后呢

987
00:49:19,000 --> 00:49:21,000
对

988
00:49:21,000 --> 00:49:22,000
然后呢

989
00:49:22,000 --> 00:49:24,000
首先有操作系统层面的问题

990
00:49:24,000 --> 00:49:27,000
然后还有 APP 层面的问题

991
00:49:28,000 --> 00:49:33,000
对这几个层面都都会影响到你最后看起来的最后的排序是怎么样的

992
00:49:33,000 --> 00:49:34,000
对

993
00:49:34,000 --> 00:49:37,000
因为后来想一下其实在这种在多种语种

994
00:49:37,000 --> 00:49:39,000
特别是多语种混合环境下

995
00:49:39,000 --> 00:49:41,000
就是还不是说一个一个一个系列

996
00:49:41,000 --> 00:49:43,000
比如拉丁语相对来说可以兼容嘛

997
00:49:43,000 --> 00:49:45,000
像刚才讲的那种情况下

998
00:49:45,000 --> 00:49:47,000
其实还跟你的这个叫什么来的

999
00:49:47,000 --> 00:49:50,000
政治政治政治策略有关系

1000
00:49:50,000 --> 00:49:51,000
政治政治对对对

1001
00:49:51,000 --> 00:49:54,000
你说你说要把这个某种语言的这个

1002
00:49:55,000 --> 00:49:57,000
虽然说 unicode 里面有个顺序

1003
00:49:57,000 --> 00:49:59,000
但是如果你在某一种环境下

1004
00:49:59,000 --> 00:50:02,000
你把一种语言的名字排在前面

1005
00:50:02,000 --> 00:50:03,000
另种排在后面

1006
00:50:03,000 --> 00:50:06,000
其实多多少少会有一些这个的考量在里面

1007
00:50:07,000 --> 00:50:09,000
所以其实挺复杂的一个问题的

1008
00:50:10,000 --> 00:50:11,000
那不管怎么样

1009
00:50:11,000 --> 00:50:14,000
我们刚才从一个层面来讲的话

1010
00:50:14,000 --> 00:50:15,000
在操作系统层面

1011
00:50:15,000 --> 00:50:18,000
比如说 iOS 和 MacOS 就不一样对吧

1012
00:50:18,000 --> 00:50:20,000
针对一个语言的话

1013
00:50:21,000 --> 00:50:23,000
因为 iOS 它是移动的系统

1014
00:50:23,000 --> 00:50:27,000
所以它对一个语言它只有一个默认的排序

1015
00:50:27,000 --> 00:50:28,000
但是 MacOS 上面呢

1016
00:50:28,000 --> 00:50:32,000
一个语言你可以选好多个排序

1017
00:50:32,000 --> 00:50:34,000
你是可以选的

1018
00:50:34,000 --> 00:50:37,000
然后呢在操作系统层面

1019
00:50:37,000 --> 00:50:38,000
像刚才我们说的

1020
00:50:38,000 --> 00:50:41,000
最典型的有很多需要这个通讯录

1021
00:50:41,000 --> 00:50:44,000
它是可以在另外加一个 fill 的

1022
00:50:44,000 --> 00:50:46,000
还有一个很典型的是 iTunes

1023
00:50:46,000 --> 00:50:48,000
iTunes 它是各种歌曲的名字

1024
00:50:48,000 --> 00:50:52,000
因为那个取名也有各国的取名

1025
00:50:52,000 --> 00:50:53,000
对

1026
00:50:53,000 --> 00:50:58,000
然后呢它在 MP 3 或者你在音乐的那个

1027
00:50:58,000 --> 00:51:00,000
就是 metadata 里面

1028
00:51:00,000 --> 00:51:03,000
你可以再继续把这个名字

1029
00:51:03,000 --> 00:51:05,000
像刚才注人的名字

1030
00:51:05,000 --> 00:51:08,000
把个歌曲的名字也是给它注音注进去

1031
00:51:08,000 --> 00:51:09,000
也是可以的

1032
00:51:09,000 --> 00:51:11,000
iTunes 那个比较鸡贼

1033
00:51:11,000 --> 00:51:12,000
它其实做的不是注音

1034
00:51:12,000 --> 00:51:14,000
它直接给了一个选项叫做 sort order

1035
00:51:14,000 --> 00:51:15,000
就是排序的这个顺序

1036
00:51:15,000 --> 00:51:17,000
它完全不管

1037
00:51:17,000 --> 00:51:19,000
但是它至少就是

1038
00:51:19,000 --> 00:51:21,000
它有一个 metadata 可以写嘛

1039
00:51:21,000 --> 00:51:23,000
你往那里面写的话

1040
00:51:23,000 --> 00:51:25,000
然后 iTunes 就会去读那个 fill 的嘛

1041
00:51:25,000 --> 00:51:26,000
对吧

1042
00:51:26,000 --> 00:51:29,000
iTunes 它给提供的这样的可能嘛

1043
00:51:29,000 --> 00:51:31,000
就专门为了排序

1044
00:51:31,000 --> 00:51:33,000
它提供的它做了这样一个功能嘛

1045
00:51:33,000 --> 00:51:34,000
所以像这样的功能

1046
00:51:34,000 --> 00:51:37,000
是 application 层面给它设计出来

1047
00:51:37,000 --> 00:51:38,000
然后给它做的嘛

1048
00:51:38,000 --> 00:51:39,000
对吧

1049
00:51:39,000 --> 00:51:40,000
对

1050
00:51:40,000 --> 00:51:42,000
如果你不在那边做的话

1051
00:51:42,000 --> 00:51:45,000
它会默认先去调用系统的顺序嘛

1052
00:51:45,000 --> 00:51:46,000
对吧

1053
00:51:46,000 --> 00:51:48,000
它有个 fallback 的顺序的

1054
00:51:48,000 --> 00:51:49,000
嗯

1055
00:51:49,000 --> 00:51:50,000
所以

1056
00:51:50,000 --> 00:51:51,000
然后如果系统也没设的话

1057
00:51:51,000 --> 00:51:54,000
那它直接就去读内码的顺序了

1058
00:51:54,000 --> 00:51:55,000
对吧

1059
00:51:55,000 --> 00:51:57,000
但是 unicode 它默认的

1060
00:51:57,000 --> 00:52:00,000
它真正的那个内码是什么顺序

1061
00:52:00,000 --> 00:52:03,000
所以你看这个现代软件

1062
00:52:03,000 --> 00:52:04,000
里面多少复杂性

1063
00:52:04,000 --> 00:52:07,000
就是有这些原因导致

1064
00:52:12,000 --> 00:52:13,000
好吧

1065
00:52:13,000 --> 00:52:15,000
那我们今天终于可以讲正题了吗

1066
00:52:15,000 --> 00:52:17,000
今天有正题

1067
00:52:17,000 --> 00:52:22,000
今天我们要讲一个是叫 hardcore 的正题

1068
00:52:22,000 --> 00:52:25,000
就是很多人都没有意识到这个问题的存在

1069
00:52:25,000 --> 00:52:29,000
今天我们要讲的是 unicode 的规范化形式

1070
00:52:29,000 --> 00:52:30,000
叫 normalization

1071
00:52:30,000 --> 00:52:34,000
很多人都讲 normalization 是什么东西

1072
00:52:34,000 --> 00:52:37,000
你来自问自答一下好了

1073
00:52:37,000 --> 00:52:39,000
它有中文的标准义法吗

1074
00:52:39,000 --> 00:52:41,000
或者我们有什么什么推荐义法

1075
00:52:41,000 --> 00:52:47,000
因为 unicode 它就是国际标准 ISO

1076
00:52:47,000 --> 00:52:49,000
那 ISO 它又是各国的

1077
00:52:49,000 --> 00:52:54,000
都会写到各国的国标国家标准里面

1078
00:52:54,000 --> 00:52:57,000
那么中国的国标就是 ISO

1079
00:52:57,000 --> 00:52:59,000
中国的国标是 13000

1080
00:52:59,000 --> 00:53:03,000
然后它对这个 normalization 的翻译是叫规范化

1081
00:53:03,000 --> 00:53:06,000
那我们在今天节目里面就叫规范化吧

1082
00:53:06,000 --> 00:53:08,000
要不然挺乱的

1083
00:53:11,000 --> 00:53:13,000
然后很多朋友就不知道

1084
00:53:13,000 --> 00:53:15,000
还有一个规范化的东西

1085
00:53:15,000 --> 00:53:16,000
其实很简单就是

1086
00:53:16,000 --> 00:53:20,000
你看到的比如说带声调的字符

1087
00:53:20,000 --> 00:53:22,000
比如说拼音啊啊啊啊

1088
00:53:22,000 --> 00:53:23,000
比如说那个啊

1089
00:53:23,000 --> 00:53:24,000
对吧

1090
00:53:24,000 --> 00:53:27,000
是字母 A 上面加个所谓的第二声

1091
00:53:27,000 --> 00:53:28,000
对吧

1092
00:53:28,000 --> 00:53:30,000
你看到的是这样一个字形

1093
00:53:30,000 --> 00:53:34,000
可是它的背后可能是一个编码

1094
00:53:34,000 --> 00:53:37,000
或者它也可能是两个字符

1095
00:53:37,000 --> 00:53:38,000
两个编码

1096
00:53:38,000 --> 00:53:40,000
也就是说一个字母 A 的编码

1097
00:53:40,000 --> 00:53:46,000
加上一个带声调的编码组合而成的东西

1098
00:53:46,000 --> 00:53:47,000
对

1099
00:53:47,000 --> 00:53:50,000
其实本质上 unicode 有一个现象

1100
00:53:50,000 --> 00:53:56,000
就是说当我们看到一串 unicode 的码位的组合的时候

1101
00:53:56,000 --> 00:53:58,000
他们可能在码位上是不同的

1102
00:53:58,000 --> 00:54:01,000
但他们实际上表示的这个字符

1103
00:54:01,000 --> 00:54:03,000
或者是字符串是相等的

1104
00:54:03,000 --> 00:54:05,000
就 unicode 有这样一个所谓的等

1105
00:54:05,000 --> 00:54:08,000
对有一个等加速的这样的问题

1106
00:54:08,000 --> 00:54:11,000
主要还是一个

1107
00:54:11,000 --> 00:54:14,000
本质上还是有历史的优点问题

1108
00:54:14,000 --> 00:54:19,000
它如果当初不是一定要兼容 unicode 的低位的话

1109
00:54:19,000 --> 00:54:20,000
就不会有这种问题

1110
00:54:20,000 --> 00:54:22,000
我试问一下

1111
00:54:22,000 --> 00:54:26,000
但是而且而且现在是由于 unicode 是多语言的嘛

1112
00:54:26,000 --> 00:54:28,000
那各个语言也都会有这样的问题

1113
00:54:28,000 --> 00:54:31,000
所以这个规范的话就越搞越烦

1114
00:54:31,000 --> 00:54:33,000
然后这个东西的话

1115
00:54:33,000 --> 00:54:37,000
有时候你要给它看成是一个字

1116
00:54:37,000 --> 00:54:39,000
因为比如要看成两个字

1117
00:54:39,000 --> 00:54:40,000
因为有时候必须区别嘛

1118
00:54:40,000 --> 00:54:43,000
就是带声调的和不带声调的肯定是两个字嘛

1119
00:54:43,000 --> 00:54:45,000
不一样你不能给它混在一起

1120
00:54:45,000 --> 00:54:48,000
但是有时候你又要给它混在一起

1121
00:54:48,000 --> 00:54:50,000
比如说在搜索的时候

1122
00:54:50,000 --> 00:54:52,000
你搜索的时候你可能希望

1123
00:54:52,000 --> 00:54:55,000
就是说你只打一个字母 A

1124
00:54:55,000 --> 00:55:00,000
但是你能顺带你能把这些带声调的东西能一起搜索到

1125
00:55:00,000 --> 00:55:02,000
就是能在那个候选下能出来

1126
00:55:02,000 --> 00:55:05,000
所以这个时候你又喜欢模糊的把这些全部带

1127
00:55:05,000 --> 00:55:07,000
所以这个是有这样的需求的

1128
00:55:07,000 --> 00:55:09,000
就是有时候你需要区别

1129
00:55:09,000 --> 00:55:12,000
有时候你又不想不区别

1130
00:55:12,000 --> 00:55:14,000
就是这里有个问题就是

1131
00:55:14,000 --> 00:55:18,000
为什么要同一个码位要对应两个

1132
00:55:18,000 --> 00:55:20,000
就最开始它产生的原因是什么

1133
00:55:20,000 --> 00:55:22,000
刚才那个吴涛提了一个解释

1134
00:55:22,000 --> 00:55:24,000
不是是反过来

1135
00:55:24,000 --> 00:55:28,000
是同一个字符会有多个码位

1136
00:55:28,000 --> 00:55:30,000
而不是同一个码位会对应两个字符

1137
00:55:30,000 --> 00:55:32,000
那为什么出现这种情况

1138
00:55:32,000 --> 00:55:34,000
就是它的历史背景是什么

1139
00:55:34,000 --> 00:55:36,000
最简单的一个比如说

1140
00:55:36,000 --> 00:55:46,000
当时欧洲各自都使用很多带有扩展符号的拉丁字符

1141
00:55:46,000 --> 00:55:52,000
所以当时 ASCII 的那个高位就被拿来做扩展

1142
00:55:52,000 --> 00:55:57,000
然后最常见的就是 Windows 上那个叫做 CP 1252 还是哪一个

1143
00:55:57,000 --> 00:55:59,000
代码页

1144
00:55:59,000 --> 00:56:03,000
对 Windows 直到今天都是在使用代码页这套机制

1145
00:56:03,000 --> 00:56:05,000
这套非常坑爹的机制

1146
00:56:05,000 --> 00:56:11,000
所以这是一个不能忽视的历史问题

1147
00:56:11,000 --> 00:56:14,000
所以 Unicode 一开始在做的时候

1148
00:56:14,000 --> 00:56:19,000
我记得是第一位的完全兼容 ASCII

1149
00:56:19,000 --> 00:56:21,000
然后此时就出现了一个问题

1150
00:56:21,000 --> 00:56:25,000
比如说 U 上面加两点这个字符

1151
00:56:25,000 --> 00:56:30,000
它就等于在 Unicode 里面出现了两种组合的可能

1152
00:56:30,000 --> 00:56:35,000
一种是因为 Unicode 兼容它固有的表达方式

1153
00:56:35,000 --> 00:56:39,000
就是 U 这个字符是在哪个码位上

1154
00:56:39,000 --> 00:56:45,000
然后它会直接把那个码位就坐进 Unicode 里面

1155
00:56:45,000 --> 00:56:47,000
说在这个码位上面 Unicode 这个码位上面

1156
00:56:47,000 --> 00:56:49,000
这里就是 U 上面加两点

1157
00:56:49,000 --> 00:56:54,000
但与此同时它又给出了单独的 U 和单独的两点

1158
00:56:54,000 --> 00:57:01,000
于是此时你又可以说我要一个 U 然后上的加两点来做出这个字符

1159
00:57:01,000 --> 00:57:03,000
这个就是问题吗

1160
00:57:03,000 --> 00:57:07,000
为什么会有这种组合的需求存在

1161
00:57:07,000 --> 00:57:10,000
我提一个比较极端的情况

1162
00:57:10,000 --> 00:57:16,000
如果说我们把所有的组合都是组合后的字都变成一个独立的码位

1163
00:57:16,000 --> 00:57:17,000
就不存在这个问题了吗

1164
00:57:17,000 --> 00:57:22,000
因为首先一方面就是它比较节省空间

1165
00:57:22,000 --> 00:57:25,000
另外一个就是如果你要组合的话你是组合不穷尽的

1166
00:57:25,000 --> 00:57:31,000
就尤其是比如说有些组合一方面有些组合可能完全没有意义

1167
00:57:31,000 --> 00:57:36,000
另外一方面比如像越南语就是一个字符上面可能有四五个

1168
00:57:36,000 --> 00:57:40,000
四五个可能太快了三个应该是有可能

1169
00:57:40,000 --> 00:57:41,000
三个也可能对

1170
00:57:41,000 --> 00:57:43,000
对你三个标英符号

1171
00:57:43,000 --> 00:57:45,000
然后你要把所有的 combination 都弄出来的话

1172
00:57:45,000 --> 00:57:47,000
这对于空间其实很难了

1173
00:57:48,000 --> 00:57:50,000
给大家一个比较更直观的一个例子

1174
00:57:50,000 --> 00:57:56,000
比如说汉语拼音那个 U 上有两点是 U 对吧

1175
00:57:56,000 --> 00:57:58,000
然后 U 也可以带声调

1176
00:57:58,000 --> 00:58:00,000
U U U U

1177
00:58:00,000 --> 00:58:01,000
对

1178
00:58:01,000 --> 00:58:03,000
所以比如说 U 对吧

1179
00:58:03,000 --> 00:58:10,000
因为单纯你就可以看着 U 上面加两点再加第二声

1180
00:58:10,000 --> 00:58:12,000
这到底是一个字还是三个字

1181
00:58:12,000 --> 00:58:14,000
你这个例子举的不对

1182
00:58:14,000 --> 00:58:18,000
对啊 U 应该那个 Y U 的时候

1183
00:58:18,000 --> 00:58:20,000
我不说那个单音节

1184
00:58:20,000 --> 00:58:22,000
我不说单音节的情况

1185
00:58:22,000 --> 00:58:25,000
我不说那个汉语拼音那个音节情况

1186
00:58:25,000 --> 00:58:27,000
我单单是说这个字符

1187
00:58:27,000 --> 00:58:29,000
对 OK

1188
00:58:29,000 --> 00:58:33,000
比如说绿色的绿对你加了个声调

1189
00:58:33,000 --> 00:58:38,000
然后这此之这个双点和下降调都是存在的

1190
00:58:38,000 --> 00:58:42,000
就是为了这个就是我们组合成部件

1191
00:58:42,000 --> 00:58:47,000
然后通过一个固定的方法来组合的避免去存多种变种

1192
00:58:47,000 --> 00:58:49,000
对一个是这个

1193
00:58:49,000 --> 00:58:51,000
另外一方面就是比如说像汉语

1194
00:58:51,000 --> 00:58:53,000
汉语那个字母的

1195
00:58:53,000 --> 00:58:56,000
把几个字母拼在一起的这一套合成机制

1196
00:58:56,000 --> 00:59:01,000
跟那个在字母上面加点的合成机制实际上是同一套

1197
00:59:02,000 --> 00:59:08,000
那么你如果你要把这一套只说我要完全摒弃这一套

1198
00:59:08,000 --> 00:59:10,000
然后把所有的 combinations 全都做出来的话

1199
00:59:10,000 --> 00:59:14,000
那汉语的 combinations 那横合杀手

1200
00:59:14,000 --> 00:59:16,000
一个 play 你不要这样子

1201
00:59:16,000 --> 00:59:21,000
这可能导致什么对 UTF 18 UTF 16 就不够用了是吧

1202
00:59:21,000 --> 00:59:22,000
对

1203
00:59:22,000 --> 00:59:25,000
我记得微软好像为了这事情就 hack 过这个事情

1204
00:59:25,000 --> 00:59:28,000
还把 unicode 标准给 hack 了

1205
00:59:29,000 --> 00:59:32,000
所以 unicode 标准在汉语有坑吗

1206
00:59:32,000 --> 00:59:34,000
还特别乱对特别乱

1207
00:59:34,000 --> 00:59:35,000
没有首先是这样子的

1208
00:59:35,000 --> 00:59:38,000
就是说如果大家觉得要省编码的话

1209
00:59:38,000 --> 00:59:40,000
就是说像就不用组合对吧

1210
00:59:40,000 --> 00:59:43,000
就给它当成是一个东西的话

1211
00:59:43,000 --> 00:59:47,000
这会在不同语言里面会有不同的认知

1212
00:59:47,000 --> 00:59:49,000
比如说在德语里面

1213
00:59:49,000 --> 00:59:51,000
物善加两点它就是一个字母

1214
00:59:51,000 --> 00:59:55,000
对于普通的德文的母语者来讲

1215
00:59:55,000 --> 00:59:58,000
它是一个字母它没有这种组合的感觉

1216
00:59:59,000 --> 01:00:01,000
像比如说在法语里面

1217
01:00:01,000 --> 01:00:04,000
它底下有个 C 底下可以加个软音符

1218
01:00:06,000 --> 01:00:09,000
然后像这样的对于法语的人来讲

1219
01:00:09,000 --> 01:00:12,000
这是一个字母而不会说是什么 C 加一个符号

1220
01:00:13,000 --> 01:00:15,000
而且在历史上

1221
01:00:15,000 --> 01:00:18,000
各国因为它自行的对 ASCII 进行扩充

1222
01:00:18,000 --> 01:00:21,000
所以它也有个向后兼容的需要

1223
01:00:21,000 --> 01:00:26,000
所以它必须有这样就当成一个字母的需求

1224
01:00:26,000 --> 01:00:29,000
然后又有想分开的需求

1225
01:00:29,000 --> 01:00:32,000
因为你有时候会加的无穷尽

1226
01:00:32,000 --> 01:00:38,000
还是说有这种单独第二声的这样的东西

1227
01:00:38,000 --> 01:00:40,000
或者两点这样的东西

1228
01:00:40,000 --> 01:00:43,000
这样的你可以自由的往其他的字母上面加

1229
01:00:43,000 --> 01:00:45,000
这样明显是更灵活的

1230
01:00:46,000 --> 01:00:47,000
虽然很灵活

1231
01:00:47,000 --> 01:00:49,000
但是你就浪费了码位

1232
01:00:49,000 --> 01:00:52,000
原来一个字符就可以搞定的东西

1233
01:00:52,000 --> 01:00:54,000
现在就变成两个字符了

1234
01:00:54,000 --> 01:00:57,000
然后现在的历史结果就变成

1235
01:00:58,000 --> 01:00:59,000
有的时候又要一个字符

1236
01:00:59,000 --> 01:01:00,000
有时候要两个字符

1237
01:01:00,000 --> 01:01:02,000
然后又有向后兼容性

1238
01:01:02,000 --> 01:01:05,000
没办法大家统一起来

1239
01:01:05,000 --> 01:01:08,000
unicode 就搞得这样出一个这样一个

1240
01:01:08,000 --> 01:01:09,000
normalization

1241
01:01:09,000 --> 01:01:12,000
就是所谓的规范化的一个形式

1242
01:01:12,000 --> 01:01:15,000
对 而且其实我们刚刚一直在讲这个组合的问题

1243
01:01:15,000 --> 01:01:19,000
然后事实上 unicode 的等价性问题

1244
01:01:19,000 --> 01:01:20,000
或者说 normalization 问题

1245
01:01:20,000 --> 01:01:23,000
它不仅仅要解决组合的问题

1246
01:01:23,000 --> 01:01:27,000
它要解决的是两个字符之间

1247
01:01:27,000 --> 01:01:28,000
它们虽然码位是不同的

1248
01:01:28,000 --> 01:01:30,000
它们各自也只有一个码位的时候

1249
01:01:30,000 --> 01:01:32,000
它们也有可能是等价的

1250
01:01:32,000 --> 01:01:33,000
比如举一个例子就是

1251
01:01:33,000 --> 01:01:36,000
Omega 和单位 Omu 之间

1252
01:01:36,000 --> 01:01:38,000
它们其实各有一个码位

1253
01:01:38,000 --> 01:01:40,000
但它们其实本质上是完全是同一个字符

1254
01:01:40,000 --> 01:01:44,000
那么它们有的时候也需要一种等价的处理方式

1255
01:01:45,000 --> 01:01:48,000
对 这就是那个认知的问题嘛

1256
01:01:48,000 --> 01:01:50,000
就是我们人类在说

1257
01:01:50,000 --> 01:01:54,000
我看着这个符号的时候我想的是哪一个东西

1258
01:01:54,000 --> 01:01:55,000
对对对

1259
01:01:55,000 --> 01:01:57,000
另外还有像日语的一些遗留问题

1260
01:01:57,000 --> 01:02:00,000
比如说日语有半角和全角的问题这样子

1261
01:02:00,000 --> 01:02:03,000
对 日语就坑多了

1262
01:02:03,000 --> 01:02:04,000
因为大家也知道

1263
01:02:04,000 --> 01:02:06,000
比如说像日文普通的五十音图里面

1264
01:02:06,000 --> 01:02:10,000
Kakiku Gekko 加上两点就会变成卓音

1265
01:02:10,000 --> 01:02:12,000
就变成 Kakiku Gekko 嘛

1266
01:02:12,000 --> 01:02:15,000
所以首先它就会有这种

1267
01:02:15,000 --> 01:02:18,000
所谓的加底儿这种组合的问题

1268
01:02:18,000 --> 01:02:20,000
比如说 Ka 如果是 Ga 的话

1269
01:02:20,000 --> 01:02:22,000
它可能是一个字 Ga

1270
01:02:22,000 --> 01:02:26,000
也可能是 Ka 加上两点变成的 Ga

1271
01:02:26,000 --> 01:02:29,000
首先就是有刚才说的这个组合问题

1272
01:02:29,000 --> 01:02:32,000
然后也有刚才这些字形不同的问题

1273
01:02:32,000 --> 01:02:34,000
就因为要有那个等价关系

1274
01:02:34,000 --> 01:02:38,000
一个 Ka 的话它可能可以是半角的

1275
01:02:38,000 --> 01:02:40,000
也可以是全角的

1276
01:02:40,000 --> 01:02:46,000
半角的片假名也是因为历史上

1277
01:02:46,000 --> 01:02:49,000
有 ASCII 日本人自己扩展的问题

1278
01:02:49,000 --> 01:02:51,000
所以它必须有个向后兼容性

1279
01:02:51,000 --> 01:02:54,000
它要保持这个半角片假名

1280
01:02:54,000 --> 01:02:56,000
就已经发电报时候用的

1281
01:02:56,000 --> 01:02:59,000
所以这也是一个向后兼容留下来的一个坑

1282
01:02:59,000 --> 01:03:02,000
对 基本上就是当年跑步进入新鲜时代的

1283
01:03:02,000 --> 01:03:04,000
这些国家各自为战

1284
01:03:04,000 --> 01:03:08,000
然后才导致了今天

1285
01:03:08,000 --> 01:03:11,000
今天有什么 ISO 8859

1286
01:03:11,000 --> 01:03:14,000
或者是 JS 的 Standard

1287
01:03:14,000 --> 01:03:16,000
然后 Uniqlo 不得不捏着鼻子

1288
01:03:16,000 --> 01:03:19,000
把这些历史英语问题全都收进来

1289
01:03:19,000 --> 01:03:20,000
所以才会有这样的问题

1290
01:03:20,000 --> 01:03:23,000
如果我们今天能够把人类社会推导重来

1291
01:03:23,000 --> 01:03:25,000
然后把信息技术从头再来的话

1292
01:03:25,000 --> 01:03:27,000
很多东西都会不一样

1293
01:03:27,000 --> 01:03:29,000
ASCII 也是

1294
01:03:29,000 --> 01:03:31,000
编码也是一个

1295
01:03:33,000 --> 01:03:36,000
所以这个规范化解决的问题就是

1296
01:03:36,000 --> 01:03:43,000
可以理解它是一个查找的表

1297
01:03:43,000 --> 01:03:46,000
通过这个表可以找到说

1298
01:03:46,000 --> 01:03:48,000
哪些 Uniqlo 的这种

1299
01:03:48,000 --> 01:03:50,000
一个 Uniqlo 的字符串

1300
01:03:50,000 --> 01:03:52,000
它两个的意义其实等价了

1301
01:03:52,000 --> 01:03:54,000
它解决这么一个问题

1302
01:03:54,000 --> 01:03:56,000
所以大家去看 Uniqlo 的话

1303
01:03:56,000 --> 01:03:58,000
就专门它有个标准附录

1304
01:03:58,000 --> 01:04:02,000
Normalization 是在标准附录的第 15 号

1305
01:04:02,000 --> 01:04:07,000
里面会有具体的组合是等于什么

1306
01:04:07,000 --> 01:04:10,000
它有机制的介绍和各个语言

1307
01:04:10,000 --> 01:04:12,000
所有 Uniqlo 里面带的 Normalization

1308
01:04:12,000 --> 01:04:14,000
它一个表格 chart 都有

1309
01:04:14,000 --> 01:04:16,000
然后如果大家去看

1310
01:04:16,000 --> 01:04:17,000
发现各个语言都有

1311
01:04:17,000 --> 01:04:19,000
很奇怪的各种等价

1312
01:04:19,000 --> 01:04:20,000
对

1313
01:04:20,000 --> 01:04:22,000
其实我记得以前

1314
01:04:22,000 --> 01:04:24,000
前一阵子 Swift 语言

1315
01:04:24,000 --> 01:04:26,000
当然这个比较

1316
01:04:26,000 --> 01:04:28,000
这部分可能比较内核恐慌

1317
01:04:28,000 --> 01:04:31,000
Swift 语言好像在上一版里面

1318
01:04:31,000 --> 01:04:34,000
又改变了字符串的表达方法

1319
01:04:34,000 --> 01:04:36,000
字符串现在又是一个 collection

1320
01:04:36,000 --> 01:04:40,000
并且它就是支持你

1321
01:04:40,000 --> 01:04:42,000
直接 compare 两个字符串

1322
01:04:42,000 --> 01:04:45,000
是否相等

1323
01:04:45,000 --> 01:04:46,000
然后相等的依据就是

1324
01:04:46,000 --> 01:04:50,000
它们在做 Uniqlo 的 Normalization 之后

1325
01:04:50,000 --> 01:04:51,000
是不是相等

1326
01:04:51,000 --> 01:04:53,000
比如说你这两个字符串

1327
01:04:53,000 --> 01:04:58,000
可能在 Bite 层面上是不一样的

1328
01:04:58,000 --> 01:05:03,000
一个字符串里面的 U 上面加点

1329
01:05:03,000 --> 01:05:06,000
可能是 Ascii 的 8 位 220

1330
01:05:06,000 --> 01:05:09,000
另外一个可能是一个 U 加上两个点

1331
01:05:09,000 --> 01:05:11,000
但是如果你问

1332
01:05:11,000 --> 01:05:14,000
在 Swift 里面问这两个字符串是不是相等的话

1333
01:05:14,000 --> 01:05:16,000
会说这两个字符串是相等的

1334
01:05:16,000 --> 01:05:17,000
对

1335
01:05:17,000 --> 01:05:21,000
这有时候不太喜欢 Swift 的地方

1336
01:05:21,000 --> 01:05:24,000
它老是把一些本来该交给 library 来做的事情

1337
01:05:24,000 --> 01:05:27,000
放到 language 这层面来搞

1338
01:05:27,000 --> 01:05:28,000
就搞得很乱

1339
01:05:28,000 --> 01:05:29,000
对

1340
01:05:29,000 --> 01:05:31,000
它没有某一种选项机制吗

1341
01:05:31,000 --> 01:05:33,000
就是什么情况下

1342
01:05:33,000 --> 01:05:34,000
我要认为它们是相等

1343
01:05:34,000 --> 01:05:36,000
什么情况下认为通用是不相等

1344
01:05:36,000 --> 01:05:37,000
其实现在是有的

1345
01:05:37,000 --> 01:05:40,000
就是现在的理议思路就是

1346
01:05:40,000 --> 01:05:45,000
如果你把它当做一个 String 来处理的话

1347
01:05:45,000 --> 01:05:47,000
那么它默认是个 Uniqlo 的 String

1348
01:05:47,000 --> 01:05:48,000
然后我刚才说了这个

1349
01:05:48,000 --> 01:05:52,000
就是它们在 Normalization 之后成相等

1350
01:05:52,000 --> 01:05:53,000
就算相等

1351
01:05:53,000 --> 01:05:55,000
而如果你要一定要比较

1352
01:05:55,000 --> 01:05:58,000
比较它们在 Bytes 层面上的大小的话

1353
01:05:58,000 --> 01:06:00,000
你需要取出它们的

1354
01:06:00,000 --> 01:06:02,000
我想想还是 Xset 吧

1355
01:06:02,000 --> 01:06:03,000
还是

1356
01:06:03,000 --> 01:06:07,000
就是你可以把它们转化为另外一种形式来比较

1357
01:06:07,000 --> 01:06:10,000
然后这样的话再比较就不相等

1358
01:06:13,000 --> 01:06:14,000
好吧

1359
01:06:14,000 --> 01:06:16,000
那看来 Normalization 是很必要的

1360
01:06:16,000 --> 01:06:21,000
我们再就跟大家介绍各种不同的 Normalization 规范化

1361
01:06:21,000 --> 01:06:22,000
这是另外一个坑

1362
01:06:22,000 --> 01:06:24,000
大家都来做规范化就好了嘛

1363
01:06:24,000 --> 01:06:25,000
同样规范化就

1364
01:06:25,000 --> 01:06:28,000
大家都按同样的规范化来做

1365
01:06:28,000 --> 01:06:29,000
这个事情也没用

1366
01:06:29,000 --> 01:06:30,000
方法很不一样

1367
01:06:30,000 --> 01:06:33,000
对这个坑哎呀真是的

1368
01:06:33,000 --> 01:06:35,000
我们需要一个 MetaNormalization

1369
01:06:36,000 --> 01:06:39,000
其实这里我觉得有两个层面

1370
01:06:39,000 --> 01:06:42,000
就是首先就是我们刚才说了这个规范化

1371
01:06:42,000 --> 01:06:45,000
它解决的是两个 Uniqlo 的都串

1372
01:06:45,000 --> 01:06:48,000
它是不是等价这样一个问题

1373
01:06:48,000 --> 01:06:51,000
那么这个等价其实是有多种意义的

1374
01:06:51,000 --> 01:06:52,000
或者说有多种用途

1375
01:06:52,000 --> 01:06:56,000
有的时候我们希望这个等价是一个相对来说比较严格的等价

1376
01:06:56,000 --> 01:07:00,000
他们只是我们对一种自缚的分解方式

1377
01:07:00,000 --> 01:07:02,000
或者组合方式的认知不同

1378
01:07:02,000 --> 01:07:05,000
那么有的时候我们可能对这个等价要求是比较宽松的

1379
01:07:05,000 --> 01:07:08,000
他们可能是一种更宽松的予以层面的等价

1380
01:07:08,000 --> 01:07:11,000
因为我们有这个搜索的需求对吧

1381
01:07:12,000 --> 01:07:16,000
所以呢等价就是所谓的规范化呢

1382
01:07:16,000 --> 01:07:17,000
它有两大类

1383
01:07:17,000 --> 01:07:20,000
然后每个大类里面又有两小类

1384
01:07:20,000 --> 01:07:22,000
所以一共有四种

1385
01:07:23,000 --> 01:07:28,000
两大类就是标准等价和这个兼容性的等价

1386
01:07:28,000 --> 01:07:32,000
刚才说了兼容就是为了大家能比如说为了搜索能找到

1387
01:07:32,000 --> 01:07:34,000
所以它有个向后兼容的需求

1388
01:07:34,000 --> 01:07:36,000
那兼容的话它有两种

1389
01:07:36,000 --> 01:07:39,000
那标准的规范化呢有两种

1390
01:07:39,000 --> 01:07:42,000
那一种呢就是叫什么 D 型

1391
01:07:42,000 --> 01:07:43,000
有 C 型 D 型

1392
01:07:43,000 --> 01:07:45,000
C 型那个叫什么

1393
01:07:45,000 --> 01:07:47,000
D 型那个叫什么

1394
01:07:47,000 --> 01:07:51,000
先分解后合成是吧

1395
01:07:51,000 --> 01:07:55,000
对先 decomposite 然后再 composite

1396
01:07:56,000 --> 01:08:00,000
然后 D 型的话就是分解掉

1397
01:08:00,000 --> 01:08:02,000
这个按分解掉

1398
01:08:03,000 --> 01:08:05,000
然后兼容分解两小类也是

1399
01:08:05,000 --> 01:08:07,000
就是兼容的默认是分解的

1400
01:08:07,000 --> 01:08:12,000
或者是兼容性的先分解后组合

1401
01:08:12,000 --> 01:08:19,000
然后很康的一点就是操作系统它又分别又采用了不同的方法

1402
01:08:19,000 --> 01:08:22,000
所以呢这又跟操纵系统有关系

1403
01:08:22,000 --> 01:08:26,000
那最近呢这个 normalization 提上话题的话

1404
01:08:26,000 --> 01:08:29,000
就有一个很有意思的一个时机

1405
01:08:29,000 --> 01:08:31,000
就是因为刚好苹果要改文件系统了

1406
01:08:31,000 --> 01:08:34,000
OK 上次 WWDC 出来的消息

1407
01:08:35,000 --> 01:08:38,000
对我们好像之前还提过了

1408
01:08:39,000 --> 01:08:44,000
现在我们跑的 iOS 10.3

1409
01:08:44,000 --> 01:08:47,000
现在的 10.3 已经是新的系统了

1410
01:08:47,000 --> 01:08:49,000
对已经是 APFS 了

1411
01:08:49,000 --> 01:08:50,000
对

1412
01:08:51,000 --> 01:08:53,000
Apple FireSystem 嘛

1413
01:08:53,000 --> 01:08:56,000
你们知道为什么明明是 Apple FireSystem

1414
01:08:56,000 --> 01:08:59,000
那为什么要缩写成 APFS 吗

1415
01:08:59,000 --> 01:09:00,000
而不是 AFS

1416
01:09:00,000 --> 01:09:02,000
APFS 被占了呀

1417
01:09:03,000 --> 01:09:07,000
对原来因为有一个那个苹果文件系统服务嘛

1418
01:09:07,000 --> 01:09:09,000
Apple FireSystem

1419
01:09:09,000 --> 01:09:14,000
刚说哪个版本的 Cierra 已经是 APFS

1420
01:09:14,000 --> 01:09:17,000
下一个就是 HiceArea 才会是

1421
01:09:17,000 --> 01:09:18,000
HiceArea 才是

1422
01:09:19,000 --> 01:09:27,000
iOS 的话更快 iOS 在 10.3 就已经把这个文件改为了 APFS 了

1423
01:09:29,000 --> 01:09:33,000
而在之前也就是说现在的我们的 Mac 呢

1424
01:09:33,000 --> 01:09:35,000
都是 HFS 加

1425
01:09:35,000 --> 01:09:36,000
这是一个超

1426
01:09:36,000 --> 01:09:38,000
好老啊这个已经十几年了

1427
01:09:38,000 --> 01:09:39,000
多少长时间了

1428
01:09:39,000 --> 01:09:41,000
八几年的文件系统

1429
01:09:41,000 --> 01:09:42,000
超老

1430
01:09:43,000 --> 01:09:44,000
对啊

1431
01:09:44,000 --> 01:09:47,000
终于苹果一咬牙一狠心要换

1432
01:09:47,000 --> 01:09:48,000
把他给他换掉

1433
01:09:48,000 --> 01:09:50,000
那换掉了以后呢就出现了一个问题

1434
01:09:50,000 --> 01:09:54,000
就是在这个新的 APFS 里面呢

1435
01:09:54,000 --> 01:09:57,000
他把这个原来的 Normalization

1436
01:09:57,000 --> 01:09:59,000
系统默认的 Normalization 换掉了

1437
01:09:59,000 --> 01:10:02,000
因为新的 APFS 呢

1438
01:10:02,000 --> 01:10:05,000
他是叫 Normalization 的 Insensitive

1439
01:10:05,000 --> 01:10:06,000
他是不敏感的

1440
01:10:06,000 --> 01:10:09,000
对这个规范化不敏感的

1441
01:10:09,000 --> 01:10:10,000
所以就说

1442
01:10:10,000 --> 01:10:14,000
无论他可以到时候你就是

1443
01:10:14,000 --> 01:10:16,000
他都能找到这个文件

1444
01:10:16,000 --> 01:10:17,000
因为刚才说了嘛

1445
01:10:17,000 --> 01:10:19,000
他如果你如果对他不敏感的话

1446
01:10:19,000 --> 01:10:20,000
就更容易搜索到嘛

1447
01:10:20,000 --> 01:10:24,000
就是无论你是用什么样的规范化来做的话

1448
01:10:24,000 --> 01:10:26,000
他都能指向这个文件

1449
01:10:27,000 --> 01:10:30,000
以前呢会有坑的问题

1450
01:10:30,000 --> 01:10:32,000
而对于用日语的朋友来讲

1451
01:10:32,000 --> 01:10:33,000
这个是最坑的问题

1452
01:10:33,000 --> 01:10:35,000
我们在我刚才说了

1453
01:10:35,000 --> 01:10:37,000
就因为日文经常要用

1454
01:10:37,000 --> 01:10:40,000
会涉及到就踩到这个规范化的坑

1455
01:10:40,000 --> 01:10:42,000
是因为日文像刚才说的

1456
01:10:42,000 --> 01:10:44,000
着音点是经常用的嘛

1457
01:10:44,000 --> 01:10:46,000
然后经常会出现

1458
01:10:46,000 --> 01:10:49,000
在日文的 Windows 的文件名

1459
01:10:49,000 --> 01:10:51,000
拷到 Mac 的时候

1460
01:10:51,000 --> 01:10:54,000
刚才说凡是带有那个着音点的字

1461
01:10:54,000 --> 01:10:58,000
放到 Mac 里面就被拆成了两个字

1462
01:11:00,000 --> 01:11:02,000
然后因为是两个字

1463
01:11:02,000 --> 01:11:04,000
你还可以一个字删除

1464
01:11:04,000 --> 01:11:06,000
所以你可以把那个着音点分别删除

1465
01:11:08,000 --> 01:11:12,000
这是因为在老的 HFS 家的时候呢

1466
01:11:12,000 --> 01:11:17,000
这也就是 Mac 现在用的这个系统里面呢

1467
01:11:17,000 --> 01:11:20,000
它对这个 Normalization 的处理是不一样的

1468
01:11:20,000 --> 01:11:24,000
因为它采用的是分解优先

1469
01:11:24,000 --> 01:11:28,000
所以它会把这个字拆成认成是两个字

1470
01:11:28,000 --> 01:11:31,000
这里可能要解释一下这个背景

1471
01:11:31,000 --> 01:11:33,000
就是为什么从改了一个文件系统

1472
01:11:33,000 --> 01:11:37,000
会导致 Normalization 的问题

1473
01:11:37,000 --> 01:11:40,000
因为 HFS Plus 就是那个旧的文件系统

1474
01:11:40,000 --> 01:11:43,000
是对这个有一个默认的处理的

1475
01:11:43,000 --> 01:11:44,000
就是那个文件系统

1476
01:11:44,000 --> 01:11:47,000
它其实是知道你写进去一个文件名

1477
01:11:47,000 --> 01:11:50,000
它会帮你去自动做一遍 Normalization

1478
01:11:50,000 --> 01:11:52,000
是这样如果我没记错的话

1479
01:11:52,000 --> 01:11:54,000
然后这个 APFS 其实

1480
01:11:54,000 --> 01:11:56,000
就之前那个设计其实有点问题的

1481
01:11:56,000 --> 01:11:58,000
因为照理说一个文件系统

1482
01:11:58,000 --> 01:12:01,000
不应该去掺和这种应用层的事情

1483
01:12:01,000 --> 01:12:02,000
对吧

1484
01:12:02,000 --> 01:12:03,000
嗯

1485
01:12:03,000 --> 01:12:06,000
因为这个 Normalization 的事情

1486
01:12:07,000 --> 01:12:08,000
这显然是应用层的问题

1487
01:12:08,000 --> 01:12:10,000
因为文件系统应该就是

1488
01:12:10,000 --> 01:12:11,000
这可能有一点

1489
01:12:11,000 --> 01:12:13,000
其实这里有个哲学问题

1490
01:12:13,000 --> 01:12:15,000
就是这也是我一个疑问

1491
01:12:15,000 --> 01:12:19,000
Normalization 究竟是应该在这个存储的

1492
01:12:19,000 --> 01:12:21,000
存储的层级上发明的对吧

1493
01:12:21,000 --> 01:12:22,000
对

1494
01:12:22,000 --> 01:12:23,000
还是在这个应用

1495
01:12:23,000 --> 01:12:25,000
调用某一个数据的过程中

1496
01:12:25,000 --> 01:12:27,000
对它进行实施的处理

1497
01:12:27,000 --> 01:12:29,000
因为本质上你说对一个文件系统来说

1498
01:12:29,000 --> 01:12:31,000
它并不关心里面存的内容是什么

1499
01:12:31,000 --> 01:12:33,000
就是你给我一堆 bytes 对吧

1500
01:12:33,000 --> 01:12:35,000
然后我把这个 bytes 按照某一种规则

1501
01:12:35,000 --> 01:12:36,000
存起来

1502
01:12:36,000 --> 01:12:37,000
编码编起来

1503
01:12:37,000 --> 01:12:39,000
到时候到时候你再问我要这堆 bytes 的时候

1504
01:12:39,000 --> 01:12:41,000
我就把这堆 bytes 还给你

1505
01:12:41,000 --> 01:12:44,000
但是我需要一个 key 找到这堆 bytes

1506
01:12:44,000 --> 01:12:46,000
这个 key 就是所有的文件名和路径

1507
01:12:46,000 --> 01:12:50,000
那么 APFS 最开始的它的那个逻辑

1508
01:12:50,000 --> 01:12:51,000
我记得当时他说过

1509
01:12:51,000 --> 01:12:52,000
他说对这个问题

1510
01:12:52,000 --> 01:12:55,000
他是就是完全不过问这些东西

1511
01:12:55,000 --> 01:12:56,000
你给我什么

1512
01:12:56,000 --> 01:12:57,000
你给我那个文件叫什么

1513
01:12:57,000 --> 01:12:58,000
我就写什么

1514
01:12:58,000 --> 01:13:00,000
但是在 HFS 里面

1515
01:13:00,000 --> 01:13:01,000
它其实是

1516
01:13:01,000 --> 01:13:05,000
它会去解析那个文件名的那个格式和内容

1517
01:13:05,000 --> 01:13:08,000
规范化这个事情是一个逻辑的概念

1518
01:13:08,000 --> 01:13:09,000
它并不是

1519
01:13:09,000 --> 01:13:11,000
它是我们在做这个叫做

1520
01:13:11,000 --> 01:13:13,000
API 的层面解决的问题

1521
01:13:13,000 --> 01:13:17,000
但是最终你写到那个磁盘上的那个东西的时候

1522
01:13:17,000 --> 01:13:19,000
它肯定是一堆 bytes

1523
01:13:19,000 --> 01:13:24,000
所以就是 APFS 它的这个设计理念就是

1524
01:13:24,000 --> 01:13:26,000
我作为一个文件系统

1525
01:13:26,000 --> 01:13:28,000
一个非常底层的东西

1526
01:13:28,000 --> 01:13:30,000
我不应该去猜忽上层逻辑 API

1527
01:13:30,000 --> 01:13:32,000
应该去解决的问题

1528
01:13:32,000 --> 01:13:33,000
不是

1529
01:13:33,000 --> 01:13:34,000
Ryo 我明白你意思

1530
01:13:34,000 --> 01:13:35,000
Ryo 我明白你意思

1531
01:13:35,000 --> 01:13:37,000
但是我有一个问题

1532
01:13:37,000 --> 01:13:38,000
比如说你说

1533
01:13:38,000 --> 01:13:40,000
你说文件系统是一个非常底层的系统

1534
01:13:40,000 --> 01:13:45,000
那么请问获得一个文件的路径这件事情很底层

1535
01:13:45,000 --> 01:13:46,000
对不对

1536
01:13:46,000 --> 01:13:49,000
那么获得一个文件的路径

1537
01:13:49,000 --> 01:13:55,000
跟这个文件的名字是以什么样的标准化形式写出来的

1538
01:13:55,000 --> 01:13:56,000
有没有关联

1539
01:13:56,000 --> 01:13:59,000
这个对文件系统肯定有关联

1540
01:13:59,000 --> 01:14:00,000
不

1541
01:14:00,000 --> 01:14:01,000
但这个不是文件系统

1542
01:14:01,000 --> 01:14:03,000
就对这个文件系统没有关系

1543
01:14:03,000 --> 01:14:05,000
因为文件拿了最终都是一堆 bytes

1544
01:14:05,000 --> 01:14:07,000
它不需要去 consert 这件事情

1545
01:14:07,000 --> 01:14:09,000
其实他做了一次转换

1546
01:14:09,000 --> 01:14:11,000
Ryo 的意思是说先规范化

1547
01:14:11,000 --> 01:14:13,000
再存储这件事情

1548
01:14:13,000 --> 01:14:15,000
不是在文件系统的层面上发生的

1549
01:14:15,000 --> 01:14:16,000
不是在文件系统的层面上发生的

1550
01:14:16,000 --> 01:14:17,000
对

1551
01:14:17,000 --> 01:14:20,000
它是在一个他们叫什么 foundation 那个

1552
01:14:20,000 --> 01:14:21,000
对

1553
01:14:21,000 --> 01:14:22,000
在操作系统的层面上发生的

1554
01:14:22,000 --> 01:14:23,000
对

1555
01:14:23,000 --> 01:14:24,000
或者是在操作系统

1556
01:14:24,000 --> 01:14:25,000
和文件系统

1557
01:14:25,000 --> 01:14:28,000
就管理文件系统那一部分的 API 里面

1558
01:14:28,000 --> 01:14:29,000
产生的

1559
01:14:29,000 --> 01:14:31,000
而不是文件系统本身需要操作的事情

1560
01:14:31,000 --> 01:14:32,000
对

1561
01:14:32,000 --> 01:14:33,000
但这里就会导致一个问题

1562
01:14:33,000 --> 01:14:34,000
就是

1563
01:14:34,000 --> 01:14:35,000
它就向后不兼容了

1564
01:14:35,000 --> 01:14:37,000
因为在 HFS 里面

1565
01:14:37,000 --> 01:14:39,000
它是文件系统就是管了这么一件事情

1566
01:14:39,000 --> 01:14:42,000
所以操作系统和包括很多应用程序

1567
01:14:42,000 --> 01:14:44,000
它就不需要过度的去考虑这个问题

1568
01:14:44,000 --> 01:14:47,000
你用什么 API 去访问那个文件

1569
01:14:47,000 --> 01:14:48,000
反正你只要给到它

1570
01:14:48,000 --> 01:14:50,000
它都会通过统一的方法规范化

1571
01:14:50,000 --> 01:14:52,000
然后形成统一的一个 bytes

1572
01:14:52,000 --> 01:14:53,000
然后再去通过那个 bytes

1573
01:14:53,000 --> 01:14:55,000
在文件系统里面去找

1574
01:14:55,000 --> 01:14:58,000
那就会变成向后兼容的问题了

1575
01:14:58,000 --> 01:15:00,000
但这个问题之所以在 IOS 里面

1576
01:15:00,000 --> 01:15:01,000
没有暴露出来

1577
01:15:01,000 --> 01:15:02,000
是因为 IOS 里面没有暴露出来

1578
01:15:02,000 --> 01:15:03,000
起码对用户而言

1579
01:15:03,000 --> 01:15:05,000
没有暴露出一个文件系统

1580
01:15:05,000 --> 01:15:07,000
起码到目前为止是没有的

1581
01:15:07,000 --> 01:15:08,000
对吧

1582
01:15:08,000 --> 01:15:09,000
那么也就不存在

1583
01:15:09,000 --> 01:15:12,000
就并不会大量存在说

1584
01:15:12,000 --> 01:15:15,000
有很多历史文件的名

1585
01:15:15,000 --> 01:15:17,000
它的规范化形式不太对

1586
01:15:17,000 --> 01:15:20,000
导致可能找不回来这个问题

1587
01:15:20,000 --> 01:15:21,000
但是在 Mac 里面

1588
01:15:21,000 --> 01:15:22,000
就会存在这个问题

1589
01:15:22,000 --> 01:15:23,000
因为 Mac 里面

1590
01:15:23,000 --> 01:15:24,000
我们现在大量还是用

1591
01:15:24,000 --> 01:15:26,000
用户直接访问文件系统

1592
01:15:26,000 --> 01:15:27,000
大家还是用 Finder

1593
01:15:27,000 --> 01:15:28,000
对吧

1594
01:15:28,000 --> 01:15:29,000
所以就导致了这个问题

1595
01:15:29,000 --> 01:15:30,000
所以现在出的都是一些

1596
01:15:30,000 --> 01:15:31,000
打补丁的方案

1597
01:15:34,000 --> 01:15:37,000
其实你一直用同样一个系统

1598
01:15:37,000 --> 01:15:39,000
相对来讲会好一些

1599
01:15:39,000 --> 01:15:41,000
主要是和 Windows

1600
01:15:41,000 --> 01:15:43,000
Windows 它默认的

1601
01:15:43,000 --> 01:15:45,000
它规范化的方式不一样

1602
01:15:46,000 --> 01:15:49,000
所以从那边不同规范化的方式

1603
01:15:49,000 --> 01:15:51,000
考过来的东西就会有问题

1604
01:15:53,000 --> 01:15:54,000
所以在 IOS 里面

1605
01:15:54,000 --> 01:15:56,000
从那边不同规范化的方式

1606
01:15:56,000 --> 01:15:58,000
考过来的东西就会有问题

1607
01:15:59,000 --> 01:16:01,000
你 Mac 一直都用这样一个

1608
01:16:01,000 --> 01:16:02,000
规范化形式的话

1609
01:16:02,000 --> 01:16:03,000
它其实相对来讲

1610
01:16:03,000 --> 01:16:05,000
它的向后金融性还是挺好的

1611
01:16:06,000 --> 01:16:07,000
但是有一个问题是这样的

1612
01:16:07,000 --> 01:16:08,000
就是说因为 APFS

1613
01:16:08,000 --> 01:16:10,000
如果按照最开始的设计理念

1614
01:16:10,000 --> 01:16:13,000
是不设计规范化和你怎么

1615
01:16:13,000 --> 01:16:15,000
它不设计你的文件怎么编码

1616
01:16:15,000 --> 01:16:17,000
你甚至可以不用 UTF 8 编码

1617
01:16:17,000 --> 01:16:18,000
理论上是可以的对吧

1618
01:16:20,000 --> 01:16:21,000
APFS 只接受有效的

1619
01:16:21,000 --> 01:16:23,000
UTF 8 编码的文件名

1620
01:16:23,000 --> 01:16:25,000
不 我就说如果它

1621
01:16:25,000 --> 01:16:27,000
就是刚才讲如果它只管是 Bytes 的话

1622
01:16:28,000 --> 01:16:30,000
就它只在字节层面上说

1623
01:16:30,000 --> 01:16:31,000
你得过什么我就存什么

1624
01:16:31,000 --> 01:16:32,000
对对对

1625
01:16:32,000 --> 01:16:33,000
存什么 就会有问题

1626
01:16:33,000 --> 01:16:34,000
就有文件系统

1627
01:16:35,000 --> 01:16:36,000
就刚才那个问题就是说

1628
01:16:36,000 --> 01:16:38,000
假设我们用那个

1629
01:16:38,000 --> 01:16:40,000
我们就是遵守 Apple 的一个规范

1630
01:16:40,000 --> 01:16:42,000
用那些 Foundation 的这些 Library

1631
01:16:42,000 --> 01:16:44,000
去去密密文件去访问文件

1632
01:16:44,000 --> 01:16:46,000
不是 Open file 之类的 API 的话

1633
01:16:46,000 --> 01:16:48,000
那你可能得到的是一个路径对吧

1634
01:16:48,000 --> 01:16:51,000
然后你在那个就是叫什么来的

1635
01:16:51,000 --> 01:16:53,000
那个命令行的界面下

1636
01:16:53,000 --> 01:16:55,000
你用那个 Unix 那套 API 去访问

1637
01:16:55,000 --> 01:16:58,000
又会得到另外一个文件的路径

1638
01:16:58,000 --> 01:16:59,000
它两个可能是不一样的

1639
01:16:59,000 --> 01:17:00,000
这个时候就会发现

1640
01:17:00,000 --> 01:17:02,000
你用那个文件

1641
01:17:02,000 --> 01:17:04,000
你用那个 Mac 的那套 API

1642
01:17:04,000 --> 01:17:05,000
去存那个文件

1643
01:17:05,000 --> 01:17:06,000
然后你在 Unix 上面

1644
01:17:06,000 --> 01:17:07,000
那个找不回那个文件了

1645
01:17:07,000 --> 01:17:08,000
就很尴尬

1646
01:17:10,000 --> 01:17:14,000
这个事情当年也存在了

1647
01:17:14,000 --> 01:17:17,000
像当年就是老 Mac

1648
01:17:17,000 --> 01:17:19,000
转成 Mac OS X 的时候

1649
01:17:19,000 --> 01:17:21,000
就是 Mac X 9 对吧

1650
01:17:21,000 --> 01:17:23,000
9 改成真正

1651
01:17:23,000 --> 01:17:24,000
不是 OS X 的时候

1652
01:17:24,000 --> 01:17:26,000
OS X 是真正的 Unix

1653
01:17:26,000 --> 01:17:29,000
但是原来老的 Mac 不是

1654
01:17:29,000 --> 01:17:32,000
所以它那个路径的那个

1655
01:17:32,000 --> 01:17:34,000
标志分割服都不一样

1656
01:17:34,000 --> 01:17:37,000
就是正邪干坊邪的那个事情

1657
01:17:37,000 --> 01:17:39,000
这个那即使操作系统的事情

1658
01:17:39,000 --> 01:17:43,000
这和它那个文件系统也不大别

1659
01:17:43,000 --> 01:17:45,000
那我们其实知道那个 Windows

1660
01:17:45,000 --> 01:17:47,000
一直以来都是用 NFC

1661
01:17:47,000 --> 01:17:48,000
这点应该没错吧

1662
01:17:48,000 --> 01:17:50,000
那么 Apple 的话

1663
01:17:50,000 --> 01:17:51,000
对 Apple 的话

1664
01:17:51,000 --> 01:17:54,000
HFS Plus 它是用哪一种形式的

1665
01:17:56,000 --> 01:17:58,000
是用 NFC 还是用 NFD

1666
01:17:58,000 --> 01:18:00,000
这个还真的不知道

1667
01:18:00,000 --> 01:18:01,000
不知道

1668
01:18:01,000 --> 01:18:02,000
我觉得这可能是第一个问题

1669
01:18:02,000 --> 01:18:04,000
然后第二个问题可能就是

1670
01:18:04,000 --> 01:18:05,000
Rail 刚才说的就是

1671
01:18:05,000 --> 01:18:09,000
在 HFS Plus 的年代里面

1672
01:18:09,000 --> 01:18:10,000
Apple 是

1673
01:18:10,000 --> 01:18:13,000
就说 Mac OS 会做一件事情

1674
01:18:13,000 --> 01:18:14,000
它做的这件事情就是

1675
01:18:14,000 --> 01:18:16,000
当你输入一个文件名的时候

1676
01:18:16,000 --> 01:18:18,000
它会帮你转成

1677
01:18:18,000 --> 01:18:20,000
已经标准化后的形式

1678
01:18:20,000 --> 01:18:23,000
再存储到你的存储介质上对吧

1679
01:18:25,000 --> 01:18:26,000
我理解的没错吧

1680
01:18:26,000 --> 01:18:28,000
应该就是说就是

1681
01:18:28,000 --> 01:18:29,000
刚才 Rail 也说的也是

1682
01:18:29,000 --> 01:18:32,000
就是说在这个文件系统里面

1683
01:18:32,000 --> 01:18:34,000
我们只说它的 Normalization

1684
01:18:34,000 --> 01:18:36,000
它是 Sensitive 还是 Insensitive

1685
01:18:36,000 --> 01:18:39,000
对这个规范是是否是

1686
01:18:39,000 --> 01:18:41,000
对这个规范是是是是

1687
01:18:41,000 --> 01:18:44,000
对这个规范是是否敏感

1688
01:18:44,000 --> 01:18:45,000
它没有在做的确

1689
01:18:45,000 --> 01:18:47,000
它只是在存储代码而已

1690
01:18:47,000 --> 01:18:49,000
存储的这个 byte 而已

1691
01:18:49,000 --> 01:18:52,000
但是它是不是对 Normalization 敏感

1692
01:18:52,000 --> 01:18:56,000
对 HFS 的确是对 Normalization 敏感

1693
01:18:56,000 --> 01:18:59,000
但是 APFS

1694
01:18:59,000 --> 01:19:01,000
它就新的就不敏感了

1695
01:19:01,000 --> 01:19:03,000
它就不敏感了

1696
01:19:03,000 --> 01:19:06,000
这个和那个大小写也是一样的

1697
01:19:06,000 --> 01:19:08,000
就是 Sensitive

1698
01:19:08,000 --> 01:19:12,000
这个就叫什么 Case Sensitive 和 Case Insensitive

1699
01:19:14,000 --> 01:19:16,000
这里还有个比较坑的一个事情

1700
01:19:16,000 --> 01:19:19,000
就是所谓这个叫做 Case Preserving

1701
01:19:19,000 --> 01:19:21,000
和 Normalization Preserving 的问题

1702
01:19:21,000 --> 01:19:25,000
对它可以保按照道理保存下来

1703
01:19:25,000 --> 01:19:27,000
但是它对它不敏感

1704
01:19:27,000 --> 01:19:29,000
还是当成一样的

1705
01:19:30,000 --> 01:19:32,000
是可保存但是它不敏感

1706
01:19:32,000 --> 01:19:34,000
就是有这样的

1707
01:19:34,000 --> 01:19:37,000
现在的话就是新的 APFS 就是这样

1708
01:19:37,000 --> 01:19:38,000
它可以保存下来

1709
01:19:38,000 --> 01:19:41,000
然后 NFC 它也认得 NFD 它也认得

1710
01:19:41,000 --> 01:19:42,000
但是它不敏感

1711
01:19:42,000 --> 01:19:44,000
所以两边都可以

1712
01:19:45,000 --> 01:19:47,000
那么其实按我的理解

1713
01:19:47,000 --> 01:19:50,000
Apple 并没有改它的这个标准化形式

1714
01:19:50,000 --> 01:19:53,000
它改的只是它对这个标准化形式

1715
01:19:53,000 --> 01:19:55,000
是不是敏感这样一个问题

1716
01:19:57,000 --> 01:19:58,000
所以它对这个文件

1717
01:19:58,000 --> 01:20:01,000
文件名处理它的行为发生变化了吗

1718
01:20:01,000 --> 01:20:03,000
刚刚我查了一下

1719
01:20:03,000 --> 01:20:08,000
HFS Plus 用的是 NFD 的这种标准化形式

1720
01:20:08,000 --> 01:20:10,000
那么这个第一个问题

1721
01:20:10,000 --> 01:20:12,000
就是跟 Windows 可能是不一样的

1722
01:20:12,000 --> 01:20:14,000
分解优先对

1723
01:20:16,000 --> 01:20:18,000
可能我们刚才把那个带过了

1724
01:20:18,000 --> 01:20:20,000
就是刚才讲的 NFC 和 NFD

1725
01:20:20,000 --> 01:20:21,000
它到底是个什么意思

1726
01:20:21,000 --> 01:20:23,000
可能还要解释一下

1727
01:20:24,000 --> 01:20:26,000
NFC 就是先

1728
01:20:27,000 --> 01:20:28,000
就等于是

1729
01:20:28,000 --> 01:20:29,000
这么说吧

1730
01:20:29,000 --> 01:20:30,000
规范化有两个思路

1731
01:20:30,000 --> 01:20:33,000
一个是说什么叫规范化的最终形式

1732
01:20:35,000 --> 01:20:36,000
第一种思路就是

1733
01:20:36,000 --> 01:20:38,000
规范化的最终形式是

1734
01:20:38,000 --> 01:20:41,000
所有能够被拆分的东西都已经被拆分了

1735
01:20:42,000 --> 01:20:43,000
然后我存储这个形式

1736
01:20:44,000 --> 01:20:46,000
第二种思路是说

1737
01:20:46,000 --> 01:20:48,000
存储的最终形式应该是

1738
01:20:48,000 --> 01:20:51,000
所有能够被合成的东西已经被合成了

1739
01:20:51,000 --> 01:20:53,000
而且是按照某一种特定方式合成的

1740
01:20:54,000 --> 01:20:55,000
这是第二种思路

1741
01:20:56,000 --> 01:20:58,000
所以就是

1742
01:20:58,000 --> 01:21:01,000
比如说第一种规范化 NFD 的话

1743
01:21:01,000 --> 01:21:04,000
那就是说以标准方式的分解

1744
01:21:04,000 --> 01:21:06,000
分解到不能再分解了

1745
01:21:06,000 --> 01:21:10,000
那我的规范化的过程就结束了

1746
01:21:11,000 --> 01:21:14,000
比如说刚才那个鱼的话

1747
01:21:14,000 --> 01:21:16,000
它就分成三个了

1748
01:21:17,000 --> 01:21:19,000
两点然后生掉

1749
01:21:19,000 --> 01:21:21,000
它能分就尽量分

1750
01:21:21,000 --> 01:21:22,000
所以它我们看到是一个字

1751
01:21:22,000 --> 01:21:24,000
但是它背面分成了三个码

1752
01:21:25,000 --> 01:21:26,000
一个是 U

1753
01:21:26,000 --> 01:21:27,000
一个是合成

1754
01:21:27,000 --> 01:21:28,000
一个是两甲

1755
01:21:30,000 --> 01:21:36,000
然后如果你说我要把它合成的状态

1756
01:21:36,000 --> 01:21:37,000
作为最终状态的话

1757
01:21:37,000 --> 01:21:39,000
那刚才这个 U 就是

1758
01:21:40,000 --> 01:21:42,000
就把它合成成一个字符

1759
01:21:42,000 --> 01:21:43,000
这样来说

1760
01:21:45,000 --> 01:21:49,000
但是由于分解和合成

1761
01:21:49,000 --> 01:21:52,000
又分别有所谓标准方式和接受方式

1762
01:21:52,000 --> 01:21:55,000
所以你可以说标准方式分解结束

1763
01:21:55,000 --> 01:21:57,000
还是接受方式分解结束

1764
01:21:57,000 --> 01:22:00,000
还是标准方式分解之后

1765
01:22:00,000 --> 01:22:03,000
再以标准方式合成结束

1766
01:22:03,000 --> 01:22:05,000
还是以标准方式分解之后

1767
01:22:05,000 --> 01:22:07,000
再以接受方式合成结束

1768
01:22:07,000 --> 01:22:08,000
或者是反过来

1769
01:22:09,000 --> 01:22:11,000
基本上是一个 combination 来的

1770
01:22:12,000 --> 01:22:15,000
我想问一下为什么要做这么多种

1771
01:22:15,000 --> 01:22:18,000
我们的 Normalization 的目的

1772
01:22:18,000 --> 01:22:20,000
不就是为了解决标准化的问题吗

1773
01:22:20,000 --> 01:22:24,000
为什么还要再搞四种不一样的方式呢

1774
01:22:24,000 --> 01:22:25,000
他们之间各有什么

1775
01:22:25,000 --> 01:22:27,000
或者说应用场景是什么

1776
01:22:27,000 --> 01:22:30,000
比如说你标准方式分解分解到不能再分解了

1777
01:22:30,000 --> 01:22:33,000
这个实际上是非常适合编程的

1778
01:22:34,000 --> 01:22:35,000
对吧

1779
01:22:35,000 --> 01:22:36,000
就是你最小单元吗

1780
01:22:38,000 --> 01:22:39,000
比如说你刚才我刚才说的

1781
01:22:39,000 --> 01:22:43,000
那个 Swift 语言判定两个字符上相等的时候

1782
01:22:43,000 --> 01:22:46,000
那你就把它们全都拆成不能再拆的状况

1783
01:22:46,000 --> 01:22:47,000
然后看两个是不是一样

1784
01:22:47,000 --> 01:22:48,000
然后一个 CodePort

1785
01:22:48,000 --> 01:22:49,000
如果是一样的话

1786
01:22:49,000 --> 01:22:51,000
那就不管他们原来是怎么样

1787
01:22:51,000 --> 01:22:53,000
对这样就结束了

1788
01:22:53,000 --> 01:22:56,000
但是如果说你要

1789
01:22:56,000 --> 01:22:58,000
太死板了

1790
01:22:58,000 --> 01:23:00,000
就是对啊

1791
01:23:00,000 --> 01:23:01,000
就是你要拆的

1792
01:23:01,000 --> 01:23:03,000
要先拆拆的这么细了以后

1793
01:23:03,000 --> 01:23:05,000
要每一个部件都都一样

1794
01:23:05,000 --> 01:23:08,000
他才判定为是一样对吧

1795
01:23:09,000 --> 01:23:12,000
对但是但是这种方式的时候就是

1796
01:23:12,000 --> 01:23:15,000
就这种规划方式是只适合

1797
01:23:16,000 --> 01:23:18,000
存储或者比较的

1798
01:23:18,000 --> 01:23:19,000
那如果你要把它

1799
01:23:19,000 --> 01:23:22,000
就是以节省空间的方式显示出来的话

1800
01:23:22,000 --> 01:23:25,000
那你还是很有可能希望说

1801
01:23:25,000 --> 01:23:29,000
我要把它最终还是要合成起来

1802
01:23:30,000 --> 01:23:32,000
就刚才那个拆的方式说可能会导致

1803
01:23:32,000 --> 01:23:34,000
比如说那个特殊的字符就是

1804
01:23:34,000 --> 01:23:36,000
u 再加一个声调的话

1805
01:23:36,000 --> 01:23:38,000
它会从理论上

1806
01:23:38,000 --> 01:23:42,000
它可以从一个点位变成三个点位嘛

1807
01:23:42,000 --> 01:23:43,000
对

1808
01:23:43,000 --> 01:23:44,000
就是那个它的空间

1809
01:23:44,000 --> 01:23:46,000
存储空间的要求变成三倍了嘛

1810
01:23:46,000 --> 01:23:47,000
对

1811
01:23:47,000 --> 01:23:49,000
然后那我们这如果就全部合到一起

1812
01:23:49,000 --> 01:23:50,000
有什么不好呢

1813
01:23:51,000 --> 01:23:52,000
嗯

1814
01:23:52,000 --> 01:23:53,000
的确

1815
01:23:53,000 --> 01:23:55,000
就是为了比较比较化

1816
01:23:55,000 --> 01:23:57,000
就是说就是说

1817
01:23:57,000 --> 01:23:59,000
NFD 的应用场景和 NFC 的应用场景

1818
01:23:59,000 --> 01:24:00,000
他们各有什么不同

1819
01:24:00,000 --> 01:24:02,000
就是不能互相替代的地方

1820
01:24:02,000 --> 01:24:04,000
因为 NFD 你要少做一部计算

1821
01:24:04,000 --> 01:24:07,000
就 NFC 你最重要把它合成起来

1822
01:24:07,000 --> 01:24:11,000
但是 NFD 的你要你要付出更多的存储空间

1823
01:24:11,000 --> 01:24:12,000
对呀

1824
01:24:12,000 --> 01:24:14,000
所以这个就是一长一短嘛

1825
01:24:14,000 --> 01:24:15,000
对呀

1826
01:24:15,000 --> 01:24:16,000
所以这个就是一长一短嘛

1827
01:24:17,000 --> 01:24:18,000
这就是时间

1828
01:24:18,000 --> 01:24:21,000
就是有时间换空间还是空间换时间的建合嘛

1829
01:24:21,000 --> 01:24:22,000
对对

1830
01:24:22,000 --> 01:24:24,000
所以这个就是逻辑问题

1831
01:24:24,000 --> 01:24:25,000
然后只是偏好问题而已

1832
01:24:25,000 --> 01:24:27,000
这个并没有什么对错或者怎么样

1833
01:24:28,000 --> 01:24:29,000
嗯

1834
01:24:29,000 --> 01:24:30,000
所以刚刚提的一个叫什么

1835
01:24:30,000 --> 01:24:32,000
这个兼容分解和标准分解有什么不一样

1836
01:24:33,000 --> 01:24:35,000
那个我简单来说一下兼容分解

1837
01:24:35,000 --> 01:24:36,000
就是

1838
01:24:36,000 --> 01:24:38,000
我不把它说得非常细

1839
01:24:38,000 --> 01:24:39,000
就兼容分解它解决一个问题

1840
01:24:39,000 --> 01:24:40,000
就是说

1841
01:24:40,000 --> 01:24:42,000
有一些有一些串

1842
01:24:42,000 --> 01:24:45,000
它在这个字符的 Bite 的表达层面是不一样的

1843
01:24:45,000 --> 01:24:46,000
然后

1844
01:24:46,000 --> 01:24:48,000
它拆分组合之后呢也是不一样的

1845
01:24:48,000 --> 01:24:50,000
但是我们希望认为他们是一样的

1846
01:24:50,000 --> 01:24:51,000
比如一个

1847
01:24:51,000 --> 01:24:53,000
常眼就是合字的问题

1848
01:24:53,000 --> 01:24:54,000
比如 FI 合字

1849
01:24:54,000 --> 01:24:56,000
那么 FI 合字我们可以理解成

1850
01:24:56,000 --> 01:24:59,000
它是一个 F 和一个 I 的两个字母的合成

1851
01:24:59,000 --> 01:25:01,000
但它同时又是一个单独的码位

1852
01:25:01,000 --> 01:25:03,000
就是 unicode 里面有一个码位

1853
01:25:03,000 --> 01:25:04,000
就是 FI 这个合字的

1854
01:25:04,000 --> 01:25:06,000
那么我们在搜索的时候呢

1855
01:25:06,000 --> 01:25:08,000
用户可能输入 FI 合字是非常复杂的

1856
01:25:08,000 --> 01:25:09,000
所以

1857
01:25:09,000 --> 01:25:11,000
我们可能希望用户输入一个 FI 合字

1858
01:25:11,000 --> 01:25:13,000
希望用户输入一个 FI

1859
01:25:13,000 --> 01:25:14,000
一个 F 和一个 I

1860
01:25:14,000 --> 01:25:16,000
我们可以把所有 FI 和字相关内容

1861
01:25:16,000 --> 01:25:17,000
也给它匹配起来

1862
01:25:17,000 --> 01:25:19,000
所以这个时候就是这个兼容性

1863
01:25:19,000 --> 01:25:21,000
分解和合成

1864
01:25:21,000 --> 01:25:22,000
需要

1865
01:25:22,000 --> 01:25:24,000
起到作用的这样一个场景

1866
01:25:24,000 --> 01:25:25,000
等一下

1867
01:25:25,000 --> 01:25:26,000
这里我提一个问题

1868
01:25:26,000 --> 01:25:27,000
好像没有区别啊

1869
01:25:27,000 --> 01:25:29,000
只用分解一次就好了吗

1870
01:25:29,000 --> 01:25:31,000
或者合成一次就好了吗

1871
01:25:31,000 --> 01:25:34,000
就是你这个问题是这样子啊

1872
01:25:34,000 --> 01:25:35,000
就是说有一堆文档

1873
01:25:35,000 --> 01:25:37,000
里面包含这个 FI 的合字

1874
01:25:37,000 --> 01:25:39,000
和 FI 分解的两种情况

1875
01:25:39,000 --> 01:25:41,000
我们没有做对它做任何处理

1876
01:25:41,000 --> 01:25:43,000
这个时候你用户来了的时候

1877
01:25:43,000 --> 01:25:44,000
用户说输入 FI

1878
01:25:44,000 --> 01:25:47,000
我们希望把前面的 FI 合字

1879
01:25:47,000 --> 01:25:49,000
和 FI 分开的都搜出来

1880
01:25:49,000 --> 01:25:50,000
这个时候有两种做法

1881
01:25:50,000 --> 01:25:51,000
第一个是说

1882
01:25:51,000 --> 01:25:53,000
我们把这个

1883
01:25:53,000 --> 01:25:55,000
我们之前存的那些文档全部做分解

1884
01:25:55,000 --> 01:25:57,000
就把 FI 的合字

1885
01:25:57,000 --> 01:25:59,000
一个 code point 分成两个

1886
01:25:59,000 --> 01:26:00,000
然后这个时候我们就可以

1887
01:26:00,000 --> 01:26:02,000
直接跟那个用户输入 FI 直接对比了嘛

1888
01:26:02,000 --> 01:26:03,000
第二个方法就是说

1889
01:26:03,000 --> 01:26:05,000
我们把用户输入的 FI

1890
01:26:05,000 --> 01:26:06,000
弄成一个合字

1891
01:26:06,000 --> 01:26:08,000
同时把所有我们已有的文档

1892
01:26:08,000 --> 01:26:10,000
里面的 FI 分开的弄成一个合字

1893
01:26:10,000 --> 01:26:11,000
这个时候再搜索也可以了嘛

1894
01:26:11,000 --> 01:26:12,000
对吧

1895
01:26:12,000 --> 01:26:13,000
就这两种操作方式嘛

1896
01:26:13,000 --> 01:26:14,000
对对对

1897
01:26:14,000 --> 01:26:15,000
OK

1898
01:26:15,000 --> 01:26:17,000
但是因为你

1899
01:26:17,000 --> 01:26:19,000
这就是为了兼容嘛

1900
01:26:19,000 --> 01:26:20,000
用户并不知道

1901
01:26:20,000 --> 01:26:23,000
这里面到底用的是合字还是分开的

1902
01:26:23,000 --> 01:26:24,000
但这里问题就是说这个

1903
01:26:24,000 --> 01:26:27,000
这个标准分解和这个

1904
01:26:27,000 --> 01:26:29,000
兼容分解好像没有区别在这里面

1905
01:26:29,000 --> 01:26:31,000
这个区别就在于

1906
01:26:31,000 --> 01:26:33,000
哪些东西是可以分的

1907
01:26:33,000 --> 01:26:34,000
就是说哪些东西是可以等价的

1908
01:26:34,000 --> 01:26:36,000
其实他们的区别就在

1909
01:26:36,000 --> 01:26:38,000
比如说那个 FI 和字

1910
01:26:38,000 --> 01:26:41,000
它本质上不能完全等同于一个 F 和一个 I

1911
01:26:41,000 --> 01:26:43,000
它们本质上是两种不同的字符

1912
01:26:43,000 --> 01:26:46,000
那么有的时候我们希望他们是等价的

1913
01:26:46,000 --> 01:26:47,000
对

1914
01:26:47,000 --> 01:26:50,000
这个其实不仅仅是说

1915
01:26:50,000 --> 01:26:53,000
这不纯粹是一个字符层面的问题

1916
01:26:53,000 --> 01:26:55,000
还是一个语言就是语言层面的问题

1917
01:26:55,000 --> 01:26:56,000
比如说在有些语言里面

1918
01:26:56,000 --> 01:26:57,000
这是一个语意的问题

1919
01:26:57,000 --> 01:26:58,000
对

1920
01:26:58,000 --> 01:27:01,000
在有些语言里面 ZH 或者是

1921
01:27:01,000 --> 01:27:05,000
SH 是被视作一个单独的字母

1922
01:27:05,000 --> 01:27:08,000
或者是在比如说像荷兰语里面

1923
01:27:08,000 --> 01:27:11,000
IJ 经常是一个单独字母

1924
01:27:11,000 --> 01:27:12,000
一个字母

1925
01:27:12,000 --> 01:27:13,000
对

1926
01:27:13,000 --> 01:27:15,000
另外就是有些语言里面

1927
01:27:15,000 --> 01:27:16,000
一个字母可能有两种形式

1928
01:27:16,000 --> 01:27:17,000
比如说阿拉伯语

1929
01:27:17,000 --> 01:27:19,000
字手字中字末

1930
01:27:19,000 --> 01:27:21,000
一个字母是表达形式不一样的

1931
01:27:21,000 --> 01:27:25,000
比如说希腊语那个是 Sigma

1932
01:27:25,000 --> 01:27:26,000
Sigma 在词尾的时候

1933
01:27:26,000 --> 01:27:28,000
写法和在词中不一样

1934
01:27:28,000 --> 01:27:30,000
又比如说那个英语里面的长 S

1935
01:27:30,000 --> 01:27:33,000
就是 VG 分那个符号

1936
01:27:33,000 --> 01:27:35,000
VG 符号那个 S

1937
01:27:35,000 --> 01:27:37,000
它跟普通的 S 也不一样

1938
01:27:37,000 --> 01:27:38,000
在德语里面

1939
01:27:38,000 --> 01:27:40,000
在旧式的德语政治法案里面

1940
01:27:40,000 --> 01:27:43,000
如果一个 S 出现在词中的话

1941
01:27:43,000 --> 01:27:45,000
你必须写成长 S

1942
01:27:45,000 --> 01:27:49,000
但是长 S 你用标准分解的话

1943
01:27:49,000 --> 01:27:52,000
你最终只能分解出一个长 S

1944
01:27:52,000 --> 01:27:55,000
因为它本来就是一个字符

1945
01:27:55,000 --> 01:27:58,000
它就是一个字符

1946
01:27:58,000 --> 01:27:59,000
而如果你用简单分解的话

1947
01:27:59,000 --> 01:28:01,000
它会说这个 S

1948
01:28:01,000 --> 01:28:03,000
这个长 S 实际上是 S 的一个变种

1949
01:28:03,000 --> 01:28:04,000
所以在匹配的时候

1950
01:28:04,000 --> 01:28:06,000
我必须把它匹配成一个短 S

1951
01:28:08,000 --> 01:28:09,000
就是说有一些

1952
01:28:09,000 --> 01:28:10,000
一遍于一搜索道

1953
01:28:10,000 --> 01:28:13,000
有一些组合在标准分解

1954
01:28:13,000 --> 01:28:14,000
它是不能分解

1955
01:28:14,000 --> 01:28:16,000
但是为了让大家防解

1956
01:28:16,000 --> 01:28:17,000
这样分解

1957
01:28:17,000 --> 01:28:20,000
就把它强行拆开

1958
01:28:24,000 --> 01:28:26,000
它有几种常见的形式

1959
01:28:26,000 --> 01:28:28,000
一种就是一个字母

1960
01:28:28,000 --> 01:28:29,000
它可能有一些

1961
01:28:29,000 --> 01:28:33,000
字体设计历史原因带来的不一样

1962
01:28:33,000 --> 01:28:34,000
比如说一个拉丁字母

1963
01:28:34,000 --> 01:28:36,000
它可以设计成好几种形式

1964
01:28:36,000 --> 01:28:37,000
比如说什么

1965
01:28:37,000 --> 01:28:39,000
有什么双层形之类的

1966
01:28:39,000 --> 01:28:41,000
这个双层是指这个视觉样式上

1967
01:28:41,000 --> 01:28:43,000
比如它有一个双勾线的这种形式

1968
01:28:43,000 --> 01:28:45,000
然后另一种形式呢

1969
01:28:45,000 --> 01:28:47,000
比如说有一些空白字符

1970
01:28:47,000 --> 01:28:49,000
它们可能都是一个空格

1971
01:28:49,000 --> 01:28:50,000
但是它们可能有

1972
01:28:50,000 --> 01:28:52,000
我们在 unicode 有非常多种空格

1973
01:28:52,000 --> 01:28:54,000
但是我们希望它们在搜索的时候

1974
01:28:54,000 --> 01:28:56,000
或者在语意识别的时候

1975
01:28:56,000 --> 01:28:57,000
认为它们都是空格这一种

1976
01:28:57,000 --> 01:28:58,000
都是 Y space

1977
01:28:58,000 --> 01:29:00,000
对 然后另外一种就是刚才吴涛说的

1978
01:29:00,000 --> 01:29:02,000
有一些语言里面有一些字母

1979
01:29:02,000 --> 01:29:03,000
它在不同的位置上

1980
01:29:03,000 --> 01:29:05,000
它其实会有不一样的写法

1981
01:29:05,000 --> 01:29:07,000
然后它也有不一样的 unicode 的码位

1982
01:29:07,000 --> 01:29:08,000
对

1983
01:29:08,000 --> 01:29:09,000
然后接下来有一种

1984
01:29:09,000 --> 01:29:11,000
比如说数字有的是带圈的

1985
01:29:11,000 --> 01:29:12,000
有的是不带圈的

1986
01:29:12,000 --> 01:29:13,000
它们可能都是同一个数字

1987
01:29:13,000 --> 01:29:14,000
1 或者数字 2

1988
01:29:14,000 --> 01:29:16,000
那么它们应该是一样的

1989
01:29:16,000 --> 01:29:18,000
就我们希望它们识别成一样的

1990
01:29:18,000 --> 01:29:19,000
然后日语里面假名有

1991
01:29:19,000 --> 01:29:21,000
半角和全角的区别

1992
01:29:21,000 --> 01:29:23,000
然后汉语里面标点符号

1993
01:29:23,000 --> 01:29:25,000
有竖排和横排的区别

1994
01:29:25,000 --> 01:29:28,000
然后还有像数学里面有上标和下标

1995
01:29:28,000 --> 01:29:31,000
和这个非上标下标的普通数字的区别

1996
01:29:31,000 --> 01:29:33,000
但它们都是同一个数字

1997
01:29:33,000 --> 01:29:35,000
另外日语里面还有一些就是

1998
01:29:35,000 --> 01:29:37,000
几个字母

1999
01:29:37,000 --> 01:29:38,000
几个字或者几个假名

2000
01:29:38,000 --> 01:29:39,000
它会组合成一起

2001
01:29:39,000 --> 01:29:40,000
比如说这个年号

2002
01:29:40,000 --> 01:29:41,000
像什么平成

2003
01:29:41,000 --> 01:29:43,000
它可能会组合成一个字符

2004
01:29:43,000 --> 01:29:46,000
但它也可以写成平成这两个字

2005
01:29:46,000 --> 01:29:47,000
诸事会数

2006
01:29:47,000 --> 01:29:48,000
对对对

2007
01:29:48,000 --> 01:29:49,000
诸事会数

2008
01:29:49,000 --> 01:29:50,000
一个叠在一起的

2009
01:29:50,000 --> 01:29:51,000
对对对

2010
01:29:51,000 --> 01:29:52,000
像一个填字格的方式

2011
01:29:52,000 --> 01:29:53,000
对

2012
01:29:53,000 --> 01:29:54,000
另外就是下有分数

2013
01:29:54,000 --> 01:29:55,000
比如说 1 分之一

2014
01:29:55,000 --> 01:29:58,000
它可能有一个单独的码位就是 1 分之一

2015
01:29:58,000 --> 01:30:01,000
但我们也可以写成 1 协杠 2 这样的一种形式

2016
01:30:01,000 --> 01:30:02,000
对 这个例子很好

2017
01:30:02,000 --> 01:30:04,000
我第一次我刚到德国的时候

2018
01:30:04,000 --> 01:30:05,000
最惊艳的一件事情就是

2019
01:30:05,000 --> 01:30:08,000
德语健康上有 1 分之二三分之一这两个健康

2020
01:30:13,000 --> 01:30:14,000
所以我问一下

2021
01:30:14,000 --> 01:30:17,000
刚才我们讲的很多都是这个外文的问题

2022
01:30:17,000 --> 01:30:18,000
中文有这个问题吗

2023
01:30:18,000 --> 01:30:19,000
中文我刚说了一个

2024
01:30:19,000 --> 01:30:20,000
就是标点的横竖形

2025
01:30:20,000 --> 01:30:22,000
就是横排和竖排标点

2026
01:30:22,000 --> 01:30:24,000
但这个不涉及拆解的问题吧

2027
01:30:24,000 --> 01:30:26,000
它就是说把哪些

2028
01:30:26,000 --> 01:30:28,000
它本来不在一个码位的标点

2029
01:30:28,000 --> 01:30:29,000
但是因为我们认为

2030
01:30:29,000 --> 01:30:32,000
它的在某一些情况下认为它是等价的

2031
01:30:32,000 --> 01:30:35,000
对 所以 normalization 不只是一个拆分的问题

2032
01:30:35,000 --> 01:30:38,000
它有的时候也是单个字符之间相互的等价问题

2033
01:30:38,000 --> 01:30:41,000
对 中文是没有拆分和组合这个问题吗

2034
01:30:41,000 --> 01:30:43,000
中文基本上没有

2035
01:30:43,000 --> 01:30:45,000
但韩语可能就会有

2036
01:30:45,000 --> 01:30:48,000
那中文那个带圈文字是有这个问题吗

2037
01:30:48,000 --> 01:30:49,000
中文什么

2038
01:30:49,000 --> 01:30:53,000
带圈文字的话就会有刚才那个兼容的问题吗

2039
01:30:53,000 --> 01:30:55,000
就是因为它即使加了一个圈

2040
01:30:55,000 --> 01:30:57,000
但是比如说那个

2041
01:30:57,000 --> 01:30:59,000
圈你们家里拆是吧

2042
01:31:01,000 --> 01:31:02,000
对啊对啊 就是圆圈嘛

2043
01:31:02,000 --> 01:31:05,000
有人说要为它升级一个特殊的码位

2044
01:31:05,000 --> 01:31:06,000
这是另外的

2045
01:31:06,000 --> 01:31:08,000
还有比如说像什么跨弧 1 对吧

2046
01:31:08,000 --> 01:31:11,000
跨弧 123456789 汉字对吧

2047
01:31:11,000 --> 01:31:13,000
像这些都是有那个兼容的

2048
01:31:13,000 --> 01:31:16,000
这样的 兼容的话给它拆成三个嘛

2049
01:31:16,000 --> 01:31:19,000
前跨弧汉字 1 后跨弧

2050
01:31:19,000 --> 01:31:23,000
就是它也要这样任意便于可以搜索到嘛

2051
01:31:23,000 --> 01:31:25,000
中文其实也有这个问题对吧

2052
01:31:25,000 --> 01:31:27,000
对 这些其实都是日本过来我觉得

2053
01:31:27,000 --> 01:31:31,000
最早应该都是日本人去申请这些码位的

2054
01:31:31,000 --> 01:31:33,000
那我再问一下 那是不是说

2055
01:31:33,000 --> 01:31:35,000
现在不是流行那个火星文吗

2056
01:31:35,000 --> 01:31:39,000
火星文不是只有半截是那个正常的字吗

2057
01:31:39,000 --> 01:31:40,000
oh my god

2058
01:31:40,000 --> 01:31:42,000
不守都是没有用的是吧

2059
01:31:42,000 --> 01:31:44,000
oh my god

2060
01:31:44,000 --> 01:31:46,000
火星文能不能等价是不是

2061
01:31:46,000 --> 01:31:50,000
对啊对啊 你必然就是我们在实际使用的情况下

2062
01:31:50,000 --> 01:31:53,000
火星文必然是等价为某一些这个

2063
01:31:53,000 --> 01:31:55,000
就是非火星文的文本的吧

2064
01:31:55,000 --> 01:31:56,000
其实它也是一个

2065
01:31:56,000 --> 01:31:58,000
这个我觉得还是

2066
01:31:58,000 --> 01:32:00,000
留给人工智能解决了

2067
01:32:00,000 --> 01:32:04,000
这个你强要一个

2068
01:32:04,000 --> 01:32:07,000
normalization 的过程考虑这种情况实在是太强一则了

2069
01:32:07,000 --> 01:32:08,000
因为

2070
01:32:08,000 --> 01:32:12,000
因为这个可能不需要在这个就不能写到规范里面去嘛

2071
01:32:12,000 --> 01:32:13,000
但是如果说

2072
01:32:13,000 --> 01:32:17,000
比如说这个我们现在在做一个这个审查系统对吧

2073
01:32:17,000 --> 01:32:21,000
我们做这个这个内容过滤可能要过滤到某一些

2074
01:32:21,000 --> 01:32:26,000
不合十一的字的时候你肯定还是要做这个火星文的拆解

2075
01:32:26,000 --> 01:32:27,000
然后做一个等价替换嘛

2076
01:32:27,000 --> 01:32:31,000
就你说能不能沿用 Unicode 这套 normalize

2077
01:32:31,000 --> 01:32:33,000
它的逻辑肯定是一样的嘛

2078
01:32:33,000 --> 01:32:34,000
对啊

2079
01:32:34,000 --> 01:32:36,000
它就是所谓的兼容分解嘛所谓的

2080
01:32:36,000 --> 01:32:38,000
这个不一定我觉得不一定

2081
01:32:38,000 --> 01:32:40,000
就要看你能不能设计出这样一套机制

2082
01:32:40,000 --> 01:32:44,000
因为其实 normalization 有一个数学上特性它叫密等性嘛

2083
01:32:44,000 --> 01:32:49,000
就是你无论对一个串做多少次这个 normalization 之后

2084
01:32:49,000 --> 01:32:50,000
结果最终是一样的

2085
01:32:50,000 --> 01:32:56,000
对对对就是你要看你的设计的这套拆解和组合机制能不能符合这个密等性

2086
01:32:56,000 --> 01:32:59,000
而且密等要倒回来

2087
01:32:59,000 --> 01:33:01,000
对当然要能倒回来

2088
01:33:01,000 --> 01:33:05,000
倒不回来的话就不是都错了嘛

2089
01:33:05,000 --> 01:33:07,000
对所以我觉得火星文可能有问题

2090
01:33:07,000 --> 01:33:09,000
火星文有问题

2091
01:33:09,000 --> 01:33:10,000
但肯定是倒不回来的呀

2092
01:33:10,000 --> 01:33:13,000
比如说比如说它原始的一个

2093
01:33:13,000 --> 01:33:18,000
我们刚才举那个 U 和上面有一个 U 撇这个一个情况嘛

2094
01:33:18,000 --> 01:33:20,000
但其实我们想来它应该有好几种组合形式对吧

2095
01:33:20,000 --> 01:33:23,000
它可以说是 U 组合一个 U

2096
01:33:23,000 --> 01:33:26,000
就最拆解三个密点然后拼一起的方式嘛

2097
01:33:26,000 --> 01:33:29,000
它可以说是就是 U 上面就 U

2098
01:33:29,000 --> 01:33:32,000
然后再加一个音调就是两个点对吧

2099
01:33:32,000 --> 01:33:35,000
它也可以是 U 有声调再加两个点嘛

2100
01:33:35,000 --> 01:33:38,000
那其实你拆解之后你是回不去的

2101
01:33:38,000 --> 01:33:40,000
它这个是一个单向的过程

2102
01:33:40,000 --> 01:33:43,000
就好像那个繁体中文转简体中文一样

2103
01:33:43,000 --> 01:33:46,000
你是不能就是过去又回来的吗

2104
01:33:46,000 --> 01:33:49,000
OK

2105
01:33:49,000 --> 01:33:53,000
就是它应该不是一个可逆的操作

2106
01:33:53,000 --> 01:33:54,000
为什么

2107
01:33:54,000 --> 01:33:56,000
因为你丢失了你最开始你

2108
01:33:56,000 --> 01:33:58,000
你丢失了一开始的信息这是没错的

2109
01:33:58,000 --> 01:33:59,000
这是没错的

2110
01:33:59,000 --> 01:34:04,000
就你你 normalize 过后你一开始什么样你就不知道

2111
01:34:04,000 --> 01:34:05,000
对啊

2112
01:34:05,000 --> 01:34:06,000
所以它是不能做到密的

2113
01:34:06,000 --> 01:34:08,000
就是可以不断重复的做一个 normalization

2114
01:34:08,000 --> 01:34:10,000
它得到的结果是稳定的

2115
01:34:10,000 --> 01:34:13,000
但是它不能它不能做不能反复不能再再逆回

2116
01:34:13,000 --> 01:34:14,000
就不可逆了

2117
01:34:14,000 --> 01:34:17,000
你的意思是你不知道它最初这个 sauce

2118
01:34:17,000 --> 01:34:19,000
究竟是哪一种表达形式

2119
01:34:19,000 --> 01:34:20,000
对对对你不知道

2120
01:34:20,000 --> 01:34:23,000
是你弄完人就就破坏掉那个信息了

2121
01:34:23,000 --> 01:34:25,000
OK 但是他们永远是相等的

2122
01:34:25,000 --> 01:34:29,000
但是如果你拆这个汉字的话就不一定了

2123
01:34:29,000 --> 01:34:33,000
因为你本质上拆汉字就是把汉字拆成各种偏旁部首

2124
01:34:33,000 --> 01:34:35,000
然后把他们组合起来

2125
01:34:35,000 --> 01:34:39,000
但我们知道汉字这个偏旁部首可能前一个字的一个偏旁

2126
01:34:39,000 --> 01:34:42,000
可以成为后一个字的另一个偏旁

2127
01:34:42,000 --> 01:34:44,000
所以他们的组合方式有很多

2128
01:34:44,000 --> 01:34:47,000
这个时候他们就可能不密等了

2129
01:34:47,000 --> 01:34:50,000
就是那个火星文的左右两边可能选出来的那个字是

2130
01:34:50,000 --> 01:34:52,000
就是一个选的左边那个部首

2131
01:34:52,000 --> 01:34:54,000
一个是选的是六辈那个部首对吧

2132
01:34:54,000 --> 01:34:56,000
对对对就有可能会有这种情况

2133
01:34:56,000 --> 01:34:59,000
这有可能会破坏这个密等性

2134
01:35:00,000 --> 01:35:02,000
所以还是听肯德约示起

2135
01:35:02,000 --> 01:35:04,000
因为 unicode 为了维持这个密等性

2136
01:35:04,000 --> 01:35:06,000
它其实是做了很多工作的

2137
01:35:06,000 --> 01:35:09,000
包括它定义了这个拆解出来的部件的顺序

2138
01:35:09,000 --> 01:35:11,000
如果你破坏了这个顺序的话

2139
01:35:11,000 --> 01:35:13,000
就有可能破坏了这个密等性

2140
01:35:13,000 --> 01:35:16,000
所以它拆解了这个顺序是有确定的顺序的

2141
01:35:16,000 --> 01:35:18,000
比如有一些字母它可能上面可以加一个点

2142
01:35:18,000 --> 01:35:19,000
下面也可以加一个点

2143
01:35:19,000 --> 01:35:22,000
那么哪个点是下面这个点在前

2144
01:35:22,000 --> 01:35:23,000
还是上面这个点在前

2145
01:35:23,000 --> 01:35:25,000
它其实是有固定顺序的

2146
01:35:28,000 --> 01:35:30,000
本期节目的那个 show notes 里面

2147
01:35:30,000 --> 01:35:32,000
还得标注一下密等性的一个连接

2148
01:35:32,000 --> 01:35:34,000
到底大家去理解一下

2149
01:35:37,000 --> 01:35:38,000
庞家对

2150
01:35:38,000 --> 01:35:40,000
最后肯定我相信肯定有读者是

2151
01:35:40,000 --> 01:35:42,000
连着密等性一路点到什么

2152
01:35:42,000 --> 01:35:44,000
庞家来什么

2153
01:35:46,000 --> 01:35:47,000
感觉那个数学问题

2154
01:35:47,000 --> 01:35:49,000
对 哥德尔不完备地理

2155
01:35:52,000 --> 01:35:53,000
玩了好大一个课

2156
01:35:53,000 --> 01:35:55,000
比如 wikipedia 的各种连接点了点

2157
01:35:55,000 --> 01:35:57,000
你最后都会点到那几个页面

2158
01:35:57,000 --> 01:35:59,000
对 最终肯定会回到哲学

2159
01:35:59,000 --> 01:36:00,000
我跟您讲

2160
01:36:00,000 --> 01:36:01,000
哲学和数学

2161
01:36:08,000 --> 01:36:10,000
刚才我们讲了这个

2162
01:36:10,000 --> 01:36:12,000
就是那个 normalization 的各种方法

2163
01:36:12,000 --> 01:36:14,000
和它的背后的一些机制

2164
01:36:14,000 --> 01:36:17,000
然后我们回来讲那个 APFS

2165
01:36:17,000 --> 01:36:20,000
它在 MacOS 和 iOS 里面

2166
01:36:20,000 --> 01:36:21,000
不一样的地方

2167
01:36:21,000 --> 01:36:23,000
我觉得这个还是挺有意思的

2168
01:36:23,000 --> 01:36:24,000
因为照我的理解

2169
01:36:24,000 --> 01:36:27,000
APFS 在 MacOS 里面对于

2170
01:36:27,000 --> 01:36:29,000
normalization 的处理是最近才决定的

2171
01:36:29,000 --> 01:36:33,000
其实我们在之前上 iOS 的 APFS

2172
01:36:33,000 --> 01:36:35,000
它是没有考虑这个问题的

2173
01:36:37,000 --> 01:36:39,000
对 所以它现在搞了一个什么样的

2174
01:36:39,000 --> 01:36:40,000
一个 hash 的方式

2175
01:36:40,000 --> 01:36:42,000
我还没太明白 你们谁看

2176
01:36:43,000 --> 01:36:44,000
我也不知道

2177
01:36:44,000 --> 01:36:45,000
就是说

2178
01:36:45,000 --> 01:36:47,000
因为它感觉 APFS

2179
01:36:48,000 --> 01:36:53,000
不管 Mac 是用 HFS 加还是用 APFS

2180
01:36:53,000 --> 01:36:56,000
它都是 normalization insensitive 的

2181
01:36:56,000 --> 01:36:59,000
它不敏感

2182
01:36:59,000 --> 01:37:01,000
它对你这个规范化形式不敏感

2183
01:37:01,000 --> 01:37:02,000
但是

2184
01:37:04,000 --> 01:37:09,000
HFS 它就直接存在磁盘上了

2185
01:37:10,000 --> 01:37:13,000
APFS 它是先规范化

2186
01:37:13,000 --> 01:37:16,000
然后文静明它会另外生成一个 hash 值

2187
01:37:17,000 --> 01:37:25,000
来给提供 normalization 的不敏感性

2188
01:37:25,000 --> 01:37:27,000
要不然的话就找不到了

2189
01:37:27,000 --> 01:37:31,000
所以它必须再给它自动付一个 hash 值

2190
01:37:33,000 --> 01:37:36,000
这里面其实还挺麻烦的

2191
01:37:36,000 --> 01:37:37,000
因为有几个问题

2192
01:37:37,000 --> 01:37:39,000
刚才也讲了有几个事情揉在一起

2193
01:37:39,000 --> 01:37:41,000
就是一个说它要不要保留

2194
01:37:41,000 --> 01:37:43,000
就是你开始的

2195
01:37:43,000 --> 01:37:45,000
先说一下还有个事情没说

2196
01:37:45,000 --> 01:37:46,000
刚才因为跟你有关系

2197
01:37:46,000 --> 01:37:50,000
iOS 的文件系统是大小写敏感的

2198
01:37:50,000 --> 01:37:53,000
就是大小写是同样一个文件

2199
01:37:53,000 --> 01:37:54,000
大小写不一样

2200
01:37:54,000 --> 01:37:57,000
它认为是不一样的文件

2201
01:37:57,000 --> 01:37:59,000
在 MacOS 里面

2202
01:38:01,000 --> 01:38:04,000
它不管是过去的 HFS 还是 APFS

2203
01:38:04,000 --> 01:38:07,000
它默认的都是大小写不敏感

2204
01:38:07,000 --> 01:38:12,000
它是大小写可保存但是不敏感

2205
01:38:12,000 --> 01:38:17,000
它会把你开始原始的大小写保留下来

2206
01:38:17,000 --> 01:38:21,000
但是它不会去区分这个事情

2207
01:38:21,000 --> 01:38:24,000
当然也可以说你在 MacOS 里面

2208
01:38:24,000 --> 01:38:26,000
你在格式化一个磁盘的时候

2209
01:38:26,000 --> 01:38:29,000
你可以选择让文件系统是做成大小写敏感的

2210
01:38:29,000 --> 01:38:30,000
但这个应该用的人不足

2211
01:38:30,000 --> 01:38:33,000
而且在用了就会导致很多兼容性的问题

2212
01:38:33,000 --> 01:38:35,000
就是不太鼓励大家这么做的

2213
01:38:35,000 --> 01:38:37,000
所以这里面如果它是用 hash 值的话

2214
01:38:37,000 --> 01:38:38,000
就会牵涉到这个问题

2215
01:38:38,000 --> 01:38:39,000
牵涉到这个问题了

2216
01:38:39,000 --> 01:38:42,000
就是说如果它是大小写保留

2217
01:38:42,000 --> 01:38:44,000
就是 case preserving 的话

2218
01:38:44,000 --> 01:38:48,000
它 hash 的串到底是什么

2219
01:38:50,000 --> 01:38:54,000
因为大小写不同的两个同样的字符串

2220
01:38:54,000 --> 01:38:56,000
的 hash 值是不一样的

2221
01:38:57,000 --> 01:38:58,000
这样的话

2222
01:38:58,000 --> 01:39:04,000
它的 case preserving 和它的 hash 的方式其实是有冲突的

2223
01:39:04,000 --> 01:39:06,000
所以我一直没太搞明白这里是怎么回事

2224
01:39:06,000 --> 01:39:10,000
我觉得先要给自弹自唱的听众简单解释一下 hash

2225
01:39:10,000 --> 01:39:12,000
是个什么样的过程

2226
01:39:13,000 --> 01:39:18,000
hash 你可以理解成为我们把一个字符串

2227
01:39:18,000 --> 01:39:20,000
然后通过某种数学的方式

2228
01:39:20,000 --> 01:39:25,000
把它变成一个固定长度的数字

2229
01:39:25,000 --> 01:39:28,000
这可能都是比如说是 120

2230
01:39:28,000 --> 01:39:31,000
hash 一般 16 个字节是多少

2231
01:39:31,000 --> 01:39:33,000
16 个字节是乘以 8

2232
01:39:33,000 --> 01:39:35,000
256 个

2233
01:39:37,000 --> 01:39:38,000
错了

2234
01:39:38,000 --> 01:39:46,000
就等于给它一个生成了一个特定的一个定号

2235
01:39:46,000 --> 01:39:51,000
对会返回一个 256 个 bit 的一个数

2236
01:39:51,000 --> 01:39:53,000
或者是 512 个 bit 的一个数

2237
01:39:53,000 --> 01:39:55,000
然后因为这个数其实足够大

2238
01:39:55,000 --> 01:39:59,000
你想一下 2 的 256 次方这个数其实非常大的

2239
01:39:59,000 --> 01:40:01,000
那么这个 hash 有个什么特性呢

2240
01:40:01,000 --> 01:40:04,000
就是只要我们 hash 算法或者 hash 函数选的少

2241
01:40:04,000 --> 01:40:10,000
我们可以做到在一个几乎可以忽略的概率上得到那个数和

2242
01:40:10,000 --> 01:40:18,000
就不太可能拿两个有意义的文本得到两个完全一样的 hash 的值

2243
01:40:18,000 --> 01:40:22,000
这可能有很多人比较容易费解这个东西

2244
01:40:22,000 --> 01:40:24,000
因为你想一下这个数在数学上是不可能的

2245
01:40:24,000 --> 01:40:31,000
因为你的那个字符串的就是你的那个函数的 hash 函数的这个输入的那个 space input space

2246
01:40:31,000 --> 01:40:33,000
是远远大于这个 output space

2247
01:40:33,000 --> 01:40:37,000
它是一个固定固定的一个

2248
01:40:37,000 --> 01:40:38,000
它是个有限级

2249
01:40:38,000 --> 01:40:40,000
但你输入的其实是个无限级

2250
01:40:40,000 --> 01:40:46,000
但是因为那个无限有输出那个有限级的空间足够足够大

2251
01:40:46,000 --> 01:40:49,000
然后只要我们这个 hash 函数选的足够好的话

2252
01:40:49,000 --> 01:40:54,000
我们是可以在大概率上认为是不会出现那种两个不同的输入

2253
01:40:54,000 --> 01:40:56,000
得到同一个 hash 值的

2254
01:40:56,000 --> 01:40:58,000
然后这个这个 hash 值我们可以拿来做很多事情

2255
01:40:58,000 --> 01:41:05,000
比如说我们可以拿来把一个东西缩短成一个我们认为这个它是一个类似于指纹的一个概念

2256
01:41:05,000 --> 01:41:09,000
对吧我们就说他这个这一串 hash 值可以对应那串原文

2257
01:41:09,000 --> 01:41:14,000
因为我们找不到另外一串原文跟这个跟这个可以得到同样的 hash 值

2258
01:41:14,000 --> 01:41:20,000
然后 APFS 里面就他就说我是用这个 hash 值来保存文件的对吧

2259
01:41:20,000 --> 01:41:22,000
保存文件名

2260
01:41:22,000 --> 01:41:27,000
对但我就不太理解就是说这里面如果他怎么去解决刚才讲的那个 case preserving 的问题

2261
01:41:27,000 --> 01:41:29,000
就其实我看见还觉得还挺难的

2262
01:41:29,000 --> 01:41:33,000
所以啊就是这有一个历史就是在这个

2263
01:41:33,000 --> 01:41:37,000
macOS Sierra 的去年六月份

2264
01:41:37,000 --> 01:41:43,000
他已经他有做一个 APFS 的第一版的开发者的预览版

2265
01:41:43,000 --> 01:41:47,000
当时这个预览版里面只有 case sensitive 的版本

2266
01:41:48,000 --> 01:41:51,000
就是说明那时候苹果还没想好就怎么做你知道吧

2267
01:41:51,000 --> 01:41:57,000
所以当时他做的第一版的开发者预览版只只能做 case sensitive 对大小写什么的

2268
01:41:57,000 --> 01:41:59,000
因为就是最简单吗

2269
01:41:59,000 --> 01:42:05,000
对对对然后等到后面 macOS 的 12.4 了以后

2270
01:42:05,000 --> 01:42:11,000
给这个开发者预览版后面他才补加了做出来这个 case insensitive 的版本

2271
01:42:11,000 --> 01:42:15,000
因为他这个是就是也是因为就是为了去填那个历史的坑嘛

2272
01:42:15,000 --> 01:42:19,000
因为过去 HFS 他是默认是 insensitive 的你就很尴尬

2273
01:42:19,000 --> 01:42:25,000
对所以其实就是他在后面具体他在怎么搞其实我也不大清楚

2274
01:42:25,000 --> 01:42:31,000
但是就是因为有这个坑所以对因为有这个坑所以他也是花了很长时间在搞

2275
01:42:31,000 --> 01:42:37,000
因为现在那个 APFS 就那个 HICERA 还没有就是就是正式发布嘛

2276
01:42:37,000 --> 01:42:41,000
现在只是 beta 版啊就说他们还有的有的机会改

2277
01:42:41,000 --> 01:42:47,000
但是如果说到了今年的这个九月份也就秋天对就会放出来放出来之后

2278
01:42:47,000 --> 01:42:51,000
如果没有这个问题没解决好的话就会导致很多人的软件可能用不了

2279
01:42:51,000 --> 01:42:53,000
或者说是文件主问的情况

2280
01:42:53,000 --> 01:42:57,000
所以他们必须在这段时间把这个问题给彻底解决了

2281
01:42:57,000 --> 01:43:03,000
用各种方式吧就现在我们看到的其实也不是一个我觉得应该也不是一个最终的版本

2282
01:43:03,000 --> 01:43:10,000
不过反正 HICERA 是可以定了就是肯定要用新的这个 APFS 了

2283
01:43:10,000 --> 01:43:15,000
在安装过程中他会默认的他会先把你格式化一遍

2284
01:43:15,000 --> 01:43:16,000
你已经装了吗?

2285
01:43:16,000 --> 01:43:18,000
没有没有就是没装了

2286
01:43:18,000 --> 01:43:23,000
但是升其实在升那个 iOS 10.3 的时候就是这样的

2287
01:43:23,000 --> 01:43:28,000
iOS 都说了嘛他不存在这个他不他不担心这个问题因为 iOS 并没有

2288
01:43:28,000 --> 01:43:29,000
对啊没错

2289
01:43:29,000 --> 01:43:36,000
而且而且而且还有一个特性就是他没有一个他只有一套 API 去访问那个文件

2290
01:43:36,000 --> 01:43:38,000
对都是用那个 Foundation 那些酷嘛

2291
01:43:38,000 --> 01:43:44,000
他不像那个 Mac 里面我们用这个 Terminal 的时候就是直接用 Posix 就 Unix 那套逻辑去访问嘛

2292
01:43:44,000 --> 01:43:49,000
所以他他考虑的那个那个那个难度就是要小很多

2293
01:43:49,000 --> 01:43:52,000
对所以我觉得 Mac 其实挺大的一个坑的

2294
01:43:52,000 --> 01:43:56,000
嗯而且说实话这个东西对于用户来讲是完全看不见的嘛

2295
01:43:56,000 --> 01:44:02,000
像我刚才说到他其实格式化的过程他其实就放到了那个安装进程那边去

2296
01:44:02,000 --> 01:44:10,000
你开始对于尤其是对于 iOS 你在装在更新的时候就用户不能做任何事情嘛

2297
01:44:10,000 --> 01:44:15,000
反正你就等着他不要重重新启动两遍反正就是新的了就这样

2298
01:44:15,000 --> 01:44:20,000
而且而且就是用户最后即便知道了这个区别他也改不了做不了任何事情

2299
01:44:20,000 --> 01:44:25,000
因为用到这个程序如果没有没有更新去支持这个事情的话你也是只能抓瞎嘛

2300
01:44:25,000 --> 01:44:33,000
对那对 Mac 的话呢可能就是因为如果万一搞不清楚的话就会造成找不到文件了对吧

2301
01:44:33,000 --> 01:44:37,000
因为那个 Normalization 不一样文件名不一样嘛

2302
01:44:37,000 --> 01:44:45,000
然后就和你自发行存的东西不一样就找不到了就是有时候最坑的最最差的结果嘛

2303
01:44:46,000 --> 01:44:51,000
所以这个 Normalization 这个事情会对我们交换在不同系统里面交换文件产生影响吗

2304
01:44:51,000 --> 01:44:59,000
就是因为现在有很多问题比如说我不知道你们有没有收到 Windows 用户发给你们这种 ZIP 这种打包的这种压缩包

2305
01:45:00,000 --> 01:45:01,000
经常会乱码的事情

2306
01:45:01,000 --> 01:45:06,000
经常会解决出来里面的那个文件就是那个名字是乱的嘛

2307
01:45:07,000 --> 01:45:11,000
但是那个乱码的机制很复杂的就是为什么会乱

2308
01:45:11,000 --> 01:45:21,000
就是简单来说那个 ZIP 打包的时候他会把那些文件名的信息也装进去嘛

2309
01:45:21,000 --> 01:45:23,000
这个时候他用的那个 encoding 的方式

2310
01:45:24,000 --> 01:45:28,000
就是 ZIP 这个格式其实是比较灵活的

2311
01:45:28,000 --> 01:45:31,000
他不会要求说你一定要有什么 encoding 的方式

2312
01:45:31,000 --> 01:45:33,000
这个时候都是由那个打包程序决定的嘛

2313
01:45:33,000 --> 01:45:39,000
但是解码的程序如果用的跟那个打包程序他用的那个理解是不一样的话就会导致这个问题

2314
01:45:39,000 --> 01:45:43,000
经常我们收到一个 Windows 用户发过来打包的

2315
01:45:44,000 --> 01:45:49,000
但是这是编码层次的问题啊就是比如说他没有用 UTF 8 之类的

2316
01:45:49,000 --> 01:45:52,000
这是编码和解码的事情啊

2317
01:45:52,000 --> 01:45:53,000
对对对对

2318
01:45:53,000 --> 01:46:01,000
但是我就说如果是哪怕他们都是用 UTF 8 去编码那个能不能这些不同的话解出来也会导致不一样

2319
01:46:01,000 --> 01:46:02,000
也会不一样对没错

2320
01:46:03,000 --> 01:46:07,000
所以这是一个非常深的一个

2321
01:46:08,000 --> 01:46:09,000
对对对

2322
01:46:09,000 --> 01:46:13,000
所以刚才说一般遇到乱码的问题的话是编码层面的问题

2323
01:46:13,000 --> 01:46:23,000
而像我刚才说的在日文的 Windows 拷贝到 Mac 上面就会发现这个字被拆开来了

2324
01:46:23,000 --> 01:46:24,000
就会有这样的问题

2325
01:46:25,000 --> 01:46:27,000
就变成一个字他变成两个字了是吧

2326
01:46:27,000 --> 01:46:28,000
两个字了对对

2327
01:46:28,000 --> 01:46:29,000
就是你看的已经是两个字了

2328
01:46:30,000 --> 01:46:35,000
你看的就已经是两个字就是嗯就会完全会被拆开来

2329
01:46:35,000 --> 01:46:41,000
就是因为他已经他从就透到那个操作系统层面上来

2330
01:46:41,000 --> 01:46:43,000
就又会已经改成了

2331
01:46:43,000 --> 01:46:44,000
因为系统不一样

2332
01:46:44,000 --> 01:46:45,000
那这个时候你们怎么办呢

2333
01:46:46,000 --> 01:46:47,000
没办法呀

2334
01:46:47,000 --> 01:46:49,000
就自己再重新编辑讲个证明

2335
01:46:50,000 --> 01:46:51,000
对啊

2336
01:46:51,000 --> 01:46:59,000
但其实这个这件事情并不是发生在 Normalization 的这个过程中我觉得

2337
01:46:59,000 --> 01:47:01,000
对没错这不是这个过程

2338
01:47:01,000 --> 01:47:07,000
但是毕竟是因为 Normalization 采取的原则方式不一样

2339
01:47:07,000 --> 01:47:08,000
然后最后呢

2340
01:47:08,000 --> 01:47:10,000
而且原来刚才也说了嘛

2341
01:47:10,000 --> 01:47:14,000
Normalization 这个事情他其实是不会被用户所知道的嘛

2342
01:47:14,000 --> 01:47:16,000
其实他是这样的嘛

2343
01:47:16,000 --> 01:47:20,000
就说明 Windows 的某一个用户他在输入这个文件名的时候

2344
01:47:20,000 --> 01:47:24,000
他输入的那一串字符其实就是一个被拆解的形式

2345
01:47:24,000 --> 01:47:28,000
然后呢他就被 Windows 的这个操作系统记录下来并且保存下来

2346
01:47:28,000 --> 01:47:31,000
那么他传到这个 OS X 上的时候

2347
01:47:31,000 --> 01:47:34,000
OS X 就觉得哎这里其实是两个字符

2348
01:47:34,000 --> 01:47:36,000
那么我就把它们分开进行一个操作

2349
01:47:36,000 --> 01:47:40,000
比如说删除的时候你能删除其中的一半对吧

2350
01:47:41,000 --> 01:47:47,000
对但是其实两个操作系统之间这里反而体现了 Normalization 的一个好处吧

2351
01:47:47,000 --> 01:47:52,000
就虽然他可能输入的这个字符串行为是不一样的

2352
01:47:52,000 --> 01:47:53,000
但是至少我们在看的时候

2353
01:47:53,000 --> 01:47:55,000
看起来他们是一样的

2354
01:47:55,000 --> 01:47:57,000
并且我们搜索的时候也能搜索到

2355
01:47:57,000 --> 01:48:02,000
我觉得这个时候反而是 Normalization 起到了一个保护的作用

2356
01:48:02,000 --> 01:48:06,000
就是他没有让整个文件名变得不兼容

2357
01:48:06,000 --> 01:48:09,000
而还起到了一定的这个最基本的兼容

2358
01:48:10,000 --> 01:48:12,000
对所以 Normalization 是必要的

2359
01:48:14,000 --> 01:48:18,000
那我问其实你们知道这个中国用户怎么解决这个问题吗

2360
01:48:20,000 --> 01:48:22,000
中国用户其实遇到的不算太多吧

2361
01:48:22,000 --> 01:48:28,000
对啊就为了就要避免在那个文件里面使用中文嘛

2362
01:48:28,000 --> 01:48:30,000
那就用拼音的所有字母代替就好

2363
01:48:31,000 --> 01:48:33,000
很多人这么干的嘛

2364
01:48:34,000 --> 01:48:37,000
好吧但其实这个完全是为了避免编买的问题吧

2365
01:48:38,000 --> 01:48:40,000
也为了就打字比较简单嘛

2366
01:48:40,000 --> 01:48:44,000
从拼音的找招找字相对来说方便一些

2367
01:48:44,000 --> 01:48:47,000
所以我不知道这个 Eric 你可能比较熟悉一点

2368
01:48:47,000 --> 01:48:51,000
就是在日文用户里面会有很多人用日文去命名那个文件名

2369
01:48:51,000 --> 01:48:53,000
对啊那肯定啊

2370
01:48:54,000 --> 01:48:56,000
我其实经常遇到一个问题

2371
01:48:56,000 --> 01:48:58,000
比如说我看一个英文的文档

2372
01:48:58,000 --> 01:49:01,000
然后这个文档可能是排版的比较精细的

2373
01:49:01,000 --> 01:49:03,000
它里面有些单词就会出现合字

2374
01:49:04,000 --> 01:49:06,000
对 FI 合字搜不到

2375
01:49:06,000 --> 01:49:09,000
这个时候我用那个系统的自带的那个

2376
01:49:09,000 --> 01:49:13,000
比如说三指双击可以耻词查字典嘛

2377
01:49:13,000 --> 01:49:16,000
这时候他查到那个字他就会识别不了

2378
01:49:16,000 --> 01:49:17,000
因为他里面带了一个合字

2379
01:49:17,000 --> 01:49:19,000
我觉得这方面好像

2380
01:49:19,000 --> 01:49:23,000
至少我现在用的这个 Cerro 还处理的不是很好

2381
01:49:23,000 --> 01:49:25,000
就 PDF 会有这个问题吗主要是

2382
01:49:25,000 --> 01:49:27,000
对对就 Preview 这个 APP

2383
01:49:27,000 --> 01:49:29,000
他在这方面的处理我觉得还不是特别的完善

2384
01:49:29,000 --> 01:49:33,000
他其实理论上他应该是帮你做好这个 Normalization 再去查字典

2385
01:49:34,000 --> 01:49:37,000
这里面跟那个 PDF 生成好像还有什么关系

2386
01:49:37,000 --> 01:49:40,000
对这个比较复杂

2387
01:49:40,000 --> 01:49:43,000
不完全是 Preview 的错

2388
01:49:43,000 --> 01:49:45,000
对跟 PDF 规范有一定关系

2389
01:49:45,000 --> 01:49:47,000
对跟 PDF 有关系

2390
01:49:47,000 --> 01:49:49,000
而且是对没错

2391
01:49:49,000 --> 01:49:53,000
但其实如果他用这个兼容方式的 Normalization

2392
01:49:53,000 --> 01:49:55,000
他处理的特别好的话

2393
01:49:55,000 --> 01:49:57,000
他其实可以绕开这个问题

2394
01:49:59,000 --> 01:50:01,000
他其实没有做这个兼容处理

2395
01:50:01,000 --> 01:50:03,000
他只是做了一个标准处理可能

2396
01:50:04,000 --> 01:50:06,000
但基本上如果你在网页上的话

2397
01:50:06,000 --> 01:50:08,000
他应该还是可以正确识别出来吧

2398
01:50:08,000 --> 01:50:10,000
不一定我觉得还真不一定

2399
01:50:10,000 --> 01:50:12,000
不一定

2400
01:50:12,000 --> 01:50:15,000
因为网页上很多时候你看到这个 Ligature

2401
01:50:15,000 --> 01:50:18,000
Ligature 可能它并不是一个真正的 unicode 的 Ligature

2402
01:50:18,000 --> 01:50:22,000
它可能只是一个 Font 来显示出来的 Ligature

2403
01:50:23,000 --> 01:50:25,000
可能用户出的都是单独的字符

2404
01:50:25,000 --> 01:50:27,000
所以你不太会遇到这种问题

2405
01:50:28,000 --> 01:50:33,000
所以说这是你看到的东西其实有一个很多层面的东西

2406
01:50:33,000 --> 01:50:36,000
你看到是一个字它可能是两个字

2407
01:50:36,000 --> 01:50:39,000
但是变成一个字的时候可能是系统把你做的

2408
01:50:39,000 --> 01:50:41,000
可能是 Application 把你做

2409
01:50:41,000 --> 01:50:43,000
那也可能是 Font 把你做的

2410
01:50:43,000 --> 01:50:45,000
就中间隔了好多道

2411
01:50:47,000 --> 01:50:49,000
所以人类为什么要给自己找这么多麻烦

2412
01:50:51,000 --> 01:50:53,000
其实说实话如果不 unicode 的话

2413
01:50:53,000 --> 01:50:56,000
就各个字做各的就不会有这么多问题

2414
01:50:56,000 --> 01:50:59,000
但是就会有各种好多套规则

2415
01:51:02,000 --> 01:51:06,000
所以 unicode 对呀就是一个大熔炉嘛

2416
01:51:06,000 --> 01:51:10,000
就什么东西都有嘛就会发生以前不曾出现过的问题知道吗

2417
01:51:10,000 --> 01:51:12,000
不对呀其实你各搞各的也会出现这个问题

2418
01:51:12,000 --> 01:51:14,000
你还是要考虑就是说比如你搜索的时候

2419
01:51:14,000 --> 01:51:16,000
你要考虑就兼容的问题嘛

2420
01:51:16,000 --> 01:51:19,000
无非就是说有各个应用程序自己去搞

2421
01:51:19,000 --> 01:51:22,000
还是说交给 unicode 这个组织统一搞一套

2422
01:51:22,000 --> 01:51:24,000
大家都遵守这个标准来搞就好了

2423
01:51:24,000 --> 01:51:25,000
虽然很复杂

2424
01:51:26,000 --> 01:51:28,000
可能各搞各的问题更多吧

2425
01:51:28,000 --> 01:51:30,000
可能搜都搜不到

2426
01:51:30,000 --> 01:51:34,000
对你一个汉字可能在这个 Big Five 里和在 GB 里面

2427
01:51:34,000 --> 01:51:37,000
完全是不一样的内码这个搜都搜不到

2428
01:51:38,000 --> 01:51:42,000
但是还好人类在这一个时机的话

2429
01:51:42,000 --> 01:51:44,000
又发现必须要做 unicode

2430
01:51:44,000 --> 01:51:47,000
然后现在大家走上了 unicode 的阳光大道了

2431
01:51:47,000 --> 01:51:50,000
才发现还要做很多很多的相互兼容

2432
01:51:51,000 --> 01:51:58,000
但非常不幸的是还有很多国内的网站还是用 GB 2312 的

2433
01:51:58,000 --> 01:52:00,000
台湾有很多

2434
01:52:00,000 --> 01:52:04,000
就再用 Big Five 然后可能打开了会变成乱的

2435
01:52:05,000 --> 01:52:09,000
对对对声明又很不正确的就是对吧

2436
01:52:09,000 --> 01:52:11,000
那个 HTM 声明

2437
01:52:11,000 --> 01:52:14,000
对我记得台湾教育部好像还有一个网站是用 Big Five

2438
01:52:14,000 --> 01:52:16,000
然后他那个网页不知道是出什么问题

2439
01:52:16,000 --> 01:52:19,000
因为 Safari 打开基本都会是乱吧

2440
01:52:19,000 --> 01:52:21,000
就默认就是乱的对

2441
01:52:21,000 --> 01:52:23,000
对你可能要手工去调就好

2442
01:52:25,000 --> 01:52:29,000
浏览器的那个那个就启发式判断的方法都已经失效了

2443
01:52:30,000 --> 01:52:31,000
特别坑

2444
01:52:32,000 --> 01:52:34,000
好吧今天差不多讲到这里了

2445
01:52:35,000 --> 01:52:38,000
我其实想经通过这样一个节目

2446
01:52:38,000 --> 01:52:40,000
就是告诉我们的听众朋友

2447
01:52:40,000 --> 01:52:42,000
就是说平时大家说 unicode

2448
01:52:42,000 --> 01:52:44,000
感觉就是就是就是编码对吧

2449
01:52:44,000 --> 01:52:46,000
就是码位什么什么这些东西

2450
01:52:46,000 --> 01:52:51,000
其实 unicode 除了就给字符编码的以外

2451
01:52:51,000 --> 01:52:52,000
他还有很多就是

2452
01:52:52,000 --> 01:52:55,000
在 unicode 这个叫 stand annex

2453
01:52:55,000 --> 01:52:58,000
就是標准的附录

2454
01:52:58,000 --> 01:53:01,000
然后就附录里面其实有很多就是

2455
01:53:01,000 --> 01:53:05,000
文字处理方面的一些技术信息

2456
01:53:05,000 --> 01:53:08,000
比如说像今天我们说的这个 normalization

2457
01:53:08,000 --> 01:53:11,000
其实这是一个很复杂的一个技术环节的问题

2458
01:53:11,000 --> 01:53:15,000
这其实也是 unicode 标准的其中之一

2459
01:53:15,000 --> 01:53:18,000
而且对作为 unicode 他是必要的

2460
01:53:18,000 --> 01:53:21,000
然后像比如说我们上次在节目也提到

2461
01:53:21,000 --> 01:53:24,000
就比如这次 10.0 里面增加了一个

2462
01:53:24,000 --> 01:53:26,000
就是 unicode 标准附录

2463
01:53:26,000 --> 01:53:29,000
就是 unicode 的竖排文本

2464
01:53:29,000 --> 01:53:31,000
这其实也是必要的

2465
01:53:31,000 --> 01:53:34,000
就是说在横排和竖排之间是有什么样的关系

2466
01:53:34,000 --> 01:53:38,000
要给它提升到这样一个标准附录里面去的话

2467
01:53:38,000 --> 01:53:40,000
能给这个

2468
01:53:40,000 --> 01:53:42,000
它首先有一个 core specification

2469
01:53:42,000 --> 01:53:46,000
核心的这个标准的一个规范

2470
01:53:46,000 --> 01:53:49,000
然后呢还周边有这么多标准的附录

2471
01:53:49,000 --> 01:53:53,000
这样组合起来才是一个整体的

2472
01:53:53,000 --> 01:53:57,000
unicode 这样一个应该可以说是一个系统了对吧

2473
01:53:59,000 --> 01:54:02,000
那其实我们在自弹自串的这个专题里面

2474
01:54:02,000 --> 01:54:06,000
其实我们还可以讲很多很多关于这样的事情

2475
01:54:06,000 --> 01:54:07,000
对

2476
01:54:07,000 --> 01:54:10,000
那关于这个 normalization 的应用层面的问题

2477
01:54:10,000 --> 01:54:12,000
就是第一个我想问的问题是

2478
01:54:12,000 --> 01:54:15,000
作为一个软件的开发者来说

2479
01:54:15,000 --> 01:54:19,000
它多大程度上会遇到说我要去主动解决这个问题

2480
01:54:19,000 --> 01:54:23,000
Ryo 你有没有预测过要去解决这个问题

2481
01:54:23,000 --> 01:54:25,000
比较少其实

2482
01:54:25,000 --> 01:54:33,000
因为特别是特别操刀系统和它的那个系统库都提供了这个标准的流程给你去去调用的时候

2483
01:54:33,000 --> 01:54:34,000
你肯定不要自己去搞

2484
01:54:34,000 --> 01:54:37,000
因为这样你自己去搞的话有可能和系统的不兼容

2485
01:54:37,000 --> 01:54:40,000
但是但是就有刚才提到那个难题嘛

2486
01:54:40,000 --> 01:54:45,000
就是说比如说在 macOS 这种比较特殊的系统上面

2487
01:54:45,000 --> 01:54:50,000
它有多套 API 的时候你就比较尴尬了

2488
01:54:50,000 --> 01:54:54,000
因为它有这个就是 unix 那套比较底层的 API

2489
01:54:54,000 --> 01:54:57,000
和相对像 foundation API 那些比较高层的 API 的时候

2490
01:54:57,000 --> 01:54:58,000
那你怎么办

2491
01:54:58,000 --> 01:55:06,000
就这个时候你可能要把这两个的就是哪些是支持什么样的这个 normalization 的规范的

2492
01:55:06,000 --> 01:55:07,000
可能搞清楚

2493
01:55:07,000 --> 01:55:11,000
然后具体说怎么实现其实你是不用去太多考虑的

2494
01:55:11,000 --> 01:55:14,000
反正那些都是有标准函数去调用的

2495
01:55:14,000 --> 01:55:20,000
对对对这个规范化的转换转换算法其实已经有一些非常标准的方式来实现

2496
01:55:20,000 --> 01:55:23,000
唯一作为开发者你需要的知道的就是说

2497
01:55:23,000 --> 01:55:28,000
你知道在什么时候用什么样的 API 去调用什么样的结果

2498
01:55:28,000 --> 01:55:30,000
这个是比较重要的

2499
01:55:31,000 --> 01:55:34,000
所以去查文档的话其实肯定也就是说

2500
01:55:34,000 --> 01:55:41,000
为了防止发生这个 normalization 错误的话就是去调用很官方的 API 就完了

2501
01:55:41,000 --> 01:55:42,000
对对

2502
01:55:42,000 --> 01:55:51,000
另外还有个事情跟我们今天讲有点关系的是 Ryo 上次提到的那个 IDN 的一个一个伪装攻击的问题是吗

2503
01:55:51,000 --> 01:55:53,000
就一个网址的一个漏洞

2504
01:55:53,000 --> 01:55:55,000
就 Punicode 那个的问题嘛

2505
01:55:56,000 --> 01:56:00,000
这个是一个也是 unicode 的一个坑吧

2506
01:56:00,000 --> 01:56:04,000
我们可以这里作为这个节目的就是事后的环节

2507
01:56:04,000 --> 01:56:06,000
所以随便图个小草

2508
01:56:06,000 --> 01:56:12,000
我们现在知道很多这个网站它有种叫做什么就钓鱼网站

2509
01:56:12,000 --> 01:56:15,000
就它骗你它说它是这个银行

2510
01:56:15,000 --> 01:56:21,000
你的那个银行的网站然后让你输入你的这个卡号密码然后让你去转你的钱嘛对吧

2511
01:56:21,000 --> 01:56:23,000
那可能银行这个例子不太好

2512
01:56:23,000 --> 01:56:26,000
现在银行都有这个两部认证了可能也不太那么容易去做

2513
01:56:26,000 --> 01:56:28,000
但是逻辑是这样的

2514
01:56:28,000 --> 01:56:36,000
逻辑是这样的就是那我们传统的在浏览器里面去判定一个网站是不是你访问的那个网站的时候你是看它的那个域名吗

2515
01:56:36,000 --> 01:56:37,000
对吧

2516
01:56:37,000 --> 01:56:41,000
域名其实就是一个字符串构成的东西嘛

2517
01:56:41,000 --> 01:56:50,000
那坑就坑在于因为 unicode 里面也不叫这也不是 unicode 坑就是这个人类的问题吧

2518
01:56:50,000 --> 01:56:55,000
就是在某一些不同的语言里面它的两个完全不同的字符

2519
01:56:55,000 --> 01:56:57,000
它看起来是一模一样的

2520
01:56:58,000 --> 01:56:59,000
嗯

2521
01:56:59,000 --> 01:57:02,000
比如说英文的第一个字母叫 A 对吧

2522
01:57:02,000 --> 01:57:05,000
但是希腊文的第一个字母叫 Alpha

2523
01:57:05,000 --> 01:57:07,000
但是两个大写字母长得一模一样

2524
01:57:07,000 --> 01:57:08,000
对

2525
01:57:08,000 --> 01:57:10,000
在过去不存在这个问题

2526
01:57:10,000 --> 01:57:14,000
因为在过去的话那个域名系系统其实是一个非常简单的系统

2527
01:57:14,000 --> 01:57:15,000
它就只有 ASCII

2528
01:57:15,000 --> 01:57:21,000
就是它只能用就是我们讲域名那个部分只能用哪几个字符

2529
01:57:21,000 --> 01:57:24,000
26 个英文字母不区分大小写

2530
01:57:24,000 --> 01:57:26,000
10 个阿拉伯数字

2531
01:57:26,000 --> 01:57:29,000
然后再加一个那个短横线对吧

2532
01:57:29,000 --> 01:57:32,000
然后在这个点肯定没得说了

2533
01:57:32,000 --> 01:57:34,000
就是 A 点 B 这个是可以知道的

2534
01:57:34,000 --> 01:57:41,000
然后后来呢为了支持所谓的多语言的这个域名嘛

2535
01:57:41,000 --> 01:57:45,000
我们中国以前搞过 CNSC 搞过所谓的中文域名对不对

2536
01:57:45,000 --> 01:57:47,000
就是汉字域名

2537
01:57:47,000 --> 01:57:50,000
汉字域名什么什么点中国很傻的

2538
01:57:50,000 --> 01:57:54,000
之前应该是九十年代末的时候有流行过这些

2539
01:57:54,000 --> 01:57:57,000
然后之后就是谢天谢地中文没有流行起来对吧

2540
01:57:57,000 --> 01:58:02,000
然后刚才讲的那个希腊文的那个 A 和英文的那个 A 就有问题

2541
01:58:02,000 --> 01:58:05,000
比如说你都想访问 Apple.com 就苹果的官网对吧

2542
01:58:05,000 --> 01:58:07,000
那你看的是 Apple.com

2543
01:58:07,000 --> 01:58:10,000
但其实人家把那个 A 给换成了那个希腊语的那个 A

2544
01:58:10,000 --> 01:58:11,000
你看起来也是 Apple.com

2545
01:58:11,000 --> 01:58:13,000
但是你访问的是一个完全不同的网站

2546
01:58:13,000 --> 01:58:22,000
这个时候这个假的 Apple.com 这个网站让你输入你的这个 iCloud 的这个账号密码你输不输呢

2547
01:58:22,000 --> 01:58:26,000
对吧

2548
01:58:26,000 --> 01:58:33,000
所以我觉得就是在域名这个这个比较关乎安全的这种领域里面

2549
01:58:33,000 --> 01:58:37,000
我其实挺反对去加入这种多语言支持的

2550
01:58:37,000 --> 01:58:41,000
虽然说听起来政治不正确凭什么域名一定要是一个英文的一个东西

2551
01:58:41,000 --> 01:58:42,000
或者说就是对吧

2552
01:58:42,000 --> 01:58:44,000
或者说 so

2553
01:58:44,000 --> 01:58:46,000
其实也就拉丁文的东西嘛

2554
01:58:46,000 --> 01:58:48,000
为什么韩国人不能用韩语做域名

2555
01:58:48,000 --> 01:58:50,000
中国人不能用中国人做域名

2556
01:58:50,000 --> 01:58:52,000
日本人不能用日语做域名

2557
01:58:52,000 --> 01:58:56,000
但是你用了之后就会出现这种不可知的结果嘛

2558
01:58:56,000 --> 01:58:58,000
这个时候就比较尴尬了

2559
01:59:01,000 --> 01:59:03,000
另外我还有个问题其实就是

2560
01:59:03,000 --> 01:59:06,000
如果我们输入两个两个在这个

2561
01:59:07,000 --> 01:59:11,000
标准化之后是相等的 Unicode 自服创

2562
01:59:11,000 --> 01:59:14,000
那么浏览器会认为他们是同一个域名吗

2563
01:59:15,000 --> 01:59:17,000
但是他们实际上是不一样的

2564
01:59:18,000 --> 01:59:22,000
这里面好像那个域名有一个这样 Pronic 它是有一个规范的

2565
01:59:22,000 --> 01:59:25,000
但是这里要扯一个很坑爹的事情

2566
01:59:26,000 --> 01:59:28,000
Pronicode 规范是找 Unicode 的

2567
01:59:29,000 --> 01:59:30,000
是的

2568
01:59:31,000 --> 01:59:33,000
这会有一个转换的问题

2569
01:59:33,000 --> 01:59:37,000
对所以比如说我们刚才我们刚才说比如说有一些字母

2570
01:59:37,000 --> 01:59:40,000
比如说像 Omega 它就是两个完全一模一样的自服

2571
01:59:41,000 --> 01:59:44,000
在形式上在这个语意的来源上也是一样

2572
01:59:44,000 --> 01:59:46,000
但它就是分裂成两个两个自服

2573
01:59:47,000 --> 01:59:51,000
一个是用来表示物理单位的一个是 Omega 这个自服本身

2574
01:59:52,000 --> 01:59:58,000
对这个我没有去查过但是照我的理解应该是要先做那个 Unicode 规范化

2575
01:59:58,000 --> 02:00:02,000
然后再转成 Pronicode 才能拿到一个最终的一个结果

2576
02:00:02,000 --> 02:00:05,000
这个时候应该是一个唯一的一个

2577
02:00:06,000 --> 02:00:08,000
所以他们其实应该是一样的

2578
02:00:08,000 --> 02:00:12,000
我的理解应该是一样的不然的话就是出现刚才我说的另外一个问题

2579
02:00:12,000 --> 02:00:15,000
你看见的两个完全一模一样的

2580
02:00:15,000 --> 02:00:17,000
而且你用 Unicode 看都是一模一样的

2581
02:00:17,000 --> 02:00:19,000
或者 Unicode 都是等价的两个域名

2582
02:00:19,000 --> 02:00:23,000
但是它其实反而两个不同的网站这个时候你就你就非常坑爹了对不对

2583
02:00:25,000 --> 02:00:30,000
当然呢这个事情可能可能也会越来越不是一个事了吧

2584
02:00:30,000 --> 02:00:35,000
就是其实我们现在看很多这个移动网站上你根本就不知道那个网址是什么的对不对

2585
02:00:35,000 --> 02:00:38,000
比如说你在这个微信的浏览器里面打开一个网站

2586
02:00:38,000 --> 02:00:40,000
你就看不见那个 URL 了

2587
02:00:40,000 --> 02:00:44,000
对所以最终你可能还是得靠一些证书之类的东西

2588
02:00:44,000 --> 02:00:48,000
就其他的一些工具来验证这个网站是不是你想要放

2589
02:00:48,000 --> 02:00:50,000
对啊对啊对啊对啊

2590
02:00:50,000 --> 02:00:54,000
但也会你任一个人总是不能看名字呀

2591
02:00:54,000 --> 02:01:00,000
这也就会变得另外一个很好玩的事情这个跟 Emoji 有关了

2592
02:01:00,000 --> 02:01:03,000
就是之前我前几天在那个推特上转发了一个事情

2593
02:01:03,000 --> 02:01:09,000
就是现在那个浏览器它不是前面靠那个地址的左边有一个那个小锁的那个图标来表现的

2594
02:01:09,000 --> 02:01:11,000
这个是一个加密连接嘛

2595
02:01:11,000 --> 02:01:14,000
对啊然后觉得你常常觉得很安全嘛

2596
02:01:14,000 --> 02:01:18,000
然后你知道那个 Emoji 里面是有一个锁的图标的吗

2597
02:01:18,000 --> 02:01:27,000
然后然后然后那个有些那个有些那个域名的那个有些顶级域名是支持 Emoji 域名的

2598
02:01:27,000 --> 02:01:31,000
就刚刚我们讲的 Prinacle 的域名之外他还支持 Emoji 的域名

2599
02:01:31,000 --> 02:01:33,000
这个时候有人就说他自己画了一个

2600
02:01:33,000 --> 02:01:37,000
他做了一个他的那个域名的第一个就是一个锁啊你知道

2601
02:01:37,000 --> 02:01:44,000
然后后面假设假设他是一个锁然后然后然后 https 然后这两点写杠写杠

2602
02:01:44,000 --> 02:01:52,000
然后是那个希腊字母的 A 的 APPL 点 com 这个时候你你你敢不敢访问这个网站

2603
02:01:52,000 --> 02:02:01,000
对吧所以所以我觉得就是就是这怎么这可能有点不太正确啊

2604
02:02:01,000 --> 02:02:06,000
但是我觉得这个事情是是是有得有的有所有些事情你是不能做的

2605
02:02:06,000 --> 02:02:11,000
这样我说你不能在域名里面去加 Emoji 你不能在域名里面去加这个 unicode 的东西

2606
02:02:11,000 --> 02:02:20,000
这真的会把事情搞得无比复杂就是本来大家只用考虑大家讲 26 个字母加 10 个数字再加一个横线

2607
02:02:20,000 --> 02:02:26,000
前才多少才 37 个对吧的一个一个那个一个一个 space 的一个问题

2608
02:02:26,000 --> 02:02:32,000
现在突然你变成一个整个 unicode 的那个 space 都在那里那是多少倍的一个复杂度的扩张

2609
02:02:32,000 --> 02:02:35,000
对于用户的认知理解来说你这没有办法去做这个教育的

2610
02:02:35,000 --> 02:02:36,000
嗯

2611
02:02:36,000 --> 02:02:43,000
所以你看中国用户大家还是比较乖的大家干脆用数字语名就不会穿这种区块了对吧

2612
02:02:43,000 --> 02:02:51,000
嗯嗯嗯嗯 163 点看数字应该不会有这个长得一样的数字但是不一样的点位吧

2613
02:02:53,000 --> 02:02:58,000
有也有吗数字的 nomination 不是很多吗

2614
02:02:58,000 --> 02:03:00,000
不是很多吗?

2615
02:03:00,000 --> 02:03:02,000
天哪!

2616
02:03:02,000 --> 02:03:04,000
对,有那个半高的数字,对不对?

2617
02:03:04,000 --> 02:03:06,000
还有那个叫什么来的?

2618
02:03:06,000 --> 02:03:08,000
那个?

2619
02:03:08,000 --> 02:03:10,000
那是罗马数字吗?

2620
02:03:10,000 --> 02:03:12,000
罗马数字也是有罗马数字自己的码位?

2621
02:03:12,000 --> 02:03:14,000
也可以!

2622
02:03:14,000 --> 02:03:16,000
对,但我们一般都是用拉丁字母来写它们

2623
02:03:16,000 --> 02:03:18,000
就用什么 IV 之类的字母

2624
02:03:18,000 --> 02:03:20,000
所以我就觉得

2625
02:03:20,000 --> 02:03:22,000
有些事情其实是

2626
02:03:22,000 --> 02:03:24,000
一些政治的因素让我们把这个事情

2627
02:03:24,000 --> 02:03:26,000
变得非常复杂

2628
02:03:26,000 --> 02:03:28,000
所以这个东西是可以做得非常简单可靠稳定的

2629
02:03:28,000 --> 02:03:30,000
但是一会儿过来一个 PM

2630
02:03:30,000 --> 02:03:32,000
一会儿过来一个 PM 都在提这个

2631
02:03:32,000 --> 02:03:34,000
失求这个时候你就爆炸

2632
02:03:34,000 --> 02:03:36,000
对

2633
02:03:36,000 --> 02:03:38,000
其实说到这个 UIL,我想起来就是

2634
02:03:38,000 --> 02:03:40,000
其实 W 3 C 也是有一趟

2635
02:03:40,000 --> 02:03:42,000
自己的 Normalization 的机制

2636
02:03:46,000 --> 02:03:48,000
对,就是,当然它其实是基于 Unetcode

2637
02:03:48,000 --> 02:03:50,000
就是它,当然它首先推荐的是

2638
02:03:50,000 --> 02:03:52,000
NFC 的这种

2639
02:03:52,000 --> 02:03:54,000
标准化的形式,规范化的形式

2640
02:03:54,000 --> 02:03:56,000
那么同时我们知道

2641
02:03:56,000 --> 02:03:58,000
因为 W 3 C 在网页上它其实有一个特殊的

2642
02:03:58,000 --> 02:04:00,000
字符串型是叫

2643
02:04:00,000 --> 02:04:02,000
Character Reference

2644
02:04:02,000 --> 02:04:04,000
就是一个 Epson 和

2645
02:04:04,000 --> 02:04:06,000
警号键开头的,然后后面加

2646
02:04:06,000 --> 02:04:08,000
一个数字的视列

2647
02:04:08,000 --> 02:04:10,000
然后加一个分号

2648
02:04:10,000 --> 02:04:12,000
这样一个可以用来

2649
02:04:12,000 --> 02:04:14,000
引用到任何一个

2650
02:04:14,000 --> 02:04:16,000
Unetcode 的字符上的这样一个视列

2651
02:04:16,000 --> 02:04:18,000
那么这个视列如果你在网页上

2652
02:04:18,000 --> 02:04:20,000
在 HTML 里面输入的话

2653
02:04:20,000 --> 02:04:22,000
它其实要被 Normalize

2654
02:04:22,000 --> 02:04:24,000
它就会成为另外一个真正的

2655
02:04:24,000 --> 02:04:26,000
实际的字符

2656
02:04:26,000 --> 02:04:28,000
而不是直接保留这个东西

2657
02:04:30,000 --> 02:04:32,000
这个就其实是在 Unetcode 的基础上

2658
02:04:32,000 --> 02:04:34,000
扩展了一下,应该说

2659
02:04:34,000 --> 02:04:36,000
那不就是那个 Punycode 吗?

2660
02:04:38,000 --> 02:04:40,000
可以这么说吧

2661
02:04:40,000 --> 02:04:42,000
机制是类似的,可能是

2662
02:04:42,000 --> 02:04:44,000
但它们的表达形式不太一样

2663
02:04:48,000 --> 02:04:50,000
这是一个挺沉重的事情,我觉得

2664
02:04:50,000 --> 02:04:52,000
可能在我的理解里面

2665
02:04:52,000 --> 02:04:54,000
我是反对

2666
02:04:54,000 --> 02:04:56,000
把一些

2667
02:04:56,000 --> 02:04:58,000
其实你说

2668
02:04:58,000 --> 02:05:00,000
一定有那么强的必要用一个中文

2669
02:05:00,000 --> 02:05:02,000
或者日文的语语吗?其实也没有,对不对?

2670
02:05:02,000 --> 02:05:04,000
大家不也过得很好了,就为什么

2671
02:05:04,000 --> 02:05:06,000
要把这个事情搞那么复杂

2672
02:05:08,000 --> 02:05:10,000
就是太多的

2673
02:05:10,000 --> 02:05:12,000
downside,没有很好的

2674
02:05:12,000 --> 02:05:14,000
upside

2675
02:05:14,000 --> 02:05:16,000
但是对于

2676
02:05:16,000 --> 02:05:18,000
这个网页来说,其实它有这些需求

2677
02:05:18,000 --> 02:05:20,000
比如你输入一些不可见字符的时候

2678
02:05:20,000 --> 02:05:22,000
你在 HTML 里面

2679
02:05:22,000 --> 02:05:24,000
你可能输入这个 character reference

2680
02:05:24,000 --> 02:05:26,000
就变成可见了

2681
02:05:26,000 --> 02:05:28,000
对于程序员来说,这个是比较友好的

2682
02:05:28,000 --> 02:05:30,000
一种形式

2683
02:05:30,000 --> 02:05:32,000
你不要在网页里面做这个

2684
02:05:32,000 --> 02:05:34,000
不要在域名和网址里面做这个事情

2685
02:05:34,000 --> 02:05:36,000
对,在域名里面做的话

2686
02:05:36,000 --> 02:05:38,000
得有所节制

2687
02:05:38,000 --> 02:05:40,000
你知道吗?

2688
02:05:40,000 --> 02:05:42,000
忍不住啊

2689
02:05:42,000 --> 02:05:44,000
技术产品之所以如此

2690
02:05:44,000 --> 02:05:46,000
复杂,就是因为上面提需求的人

2691
02:05:46,000 --> 02:05:48,000
就是,对吧

2692
02:05:50,000 --> 02:05:52,000
不考虑后果

2693
02:05:54,000 --> 02:05:56,000
好吧,今天

2694
02:05:56,000 --> 02:05:58,000
我们就聊到这里

2695
02:05:58,000 --> 02:06:00,000
对

2696
02:06:02,000 --> 02:06:04,000
对了,我们这次

2697
02:06:04,000 --> 02:06:06,000
就不抽奖了

2698
02:06:06,000 --> 02:06:08,000
是吧?

2699
02:06:08,000 --> 02:06:10,000
对,但是我们其实上一次

2700
02:06:10,000 --> 02:06:12,000
抽奖的结果已经出来了

2701
02:06:12,000 --> 02:06:14,000
但是有一位听众联系不到

2702
02:06:14,000 --> 02:06:16,000
所以其实

2703
02:06:16,000 --> 02:06:18,000
我们可以借这次节目先做一个通知

2704
02:06:18,000 --> 02:06:20,000
那你说吧

2705
02:06:20,000 --> 02:06:22,000
对,之前

2706
02:06:22,000 --> 02:06:24,000
我们在

2707
02:06:24,000 --> 02:06:26,000
上一次,应该是第 51 期吧

2708
02:06:26,000 --> 02:06:28,000
我们公布了一个抽奖的通知

2709
02:06:28,000 --> 02:06:30,000
然后呢,接下来的一周之后

2710
02:06:30,000 --> 02:06:32,000
我们这个抽奖的结果其实已经出来了

2711
02:06:32,000 --> 02:06:34,000
那么我们这次抽到的两位听众

2712
02:06:34,000 --> 02:06:36,000
都是来自支付宝捐赠的听众

2713
02:06:36,000 --> 02:06:38,000
第一位听众,他的署名是

2714
02:06:38,000 --> 02:06:40,000
灰,一个辉煌的灰

2715
02:06:40,000 --> 02:06:42,000
这个单字

2716
02:06:42,000 --> 02:06:44,000
他的署名是 Furen

2717
02:06:44,000 --> 02:06:46,000
第二位听众呢,我已经联系上他了

2718
02:06:46,000 --> 02:06:48,000
那么他应该也已经收到了我们的奖品

2719
02:06:48,000 --> 02:06:50,000
但是第一位听众,我没法联系到他

2720
02:06:50,000 --> 02:06:52,000
所以如果你听到这期节目呢

2721
02:06:52,000 --> 02:06:54,000
也可以直接给我们发邮件

2722
02:06:54,000 --> 02:06:56,000
发到 podcastatothetype.com

2723
02:06:56,000 --> 02:06:58,000
来跟我们联络,然后我们会跟你进一步沟通

2724
02:06:58,000 --> 02:07:00,000
然后把奖品发给你

2725
02:07:02,000 --> 02:07:04,000
好,感谢大家的捐赠

2726
02:07:04,000 --> 02:07:06,000
那别忘记了,和我们联系的方法呢

2727
02:07:06,000 --> 02:07:08,000
是 podcastatthetype.com

2728
02:07:08,000 --> 02:07:10,000
有捐赠

2729
02:07:10,000 --> 02:07:12,000
有机会参加我们的抽奖

2730
02:07:12,000 --> 02:07:14,000
我也今天

2731
02:07:14,000 --> 02:07:16,000
我给大家准备了新的礼物

2732
02:07:16,000 --> 02:07:18,000
那等我们下次再说吧,好吧

2733
02:07:18,000 --> 02:07:20,000
好,那感谢大家收听今天的节目

2734
02:07:20,000 --> 02:07:22,000
如果大家喜欢我们的节目的话

2735
02:07:22,000 --> 02:07:24,000
喜欢自弹自唱的话

2736
02:07:24,000 --> 02:07:26,000
就可以给我们捐赠

2737
02:07:26,000 --> 02:07:28,000
我们的捐赠渠道呢,跟我们的邮箱地址是一样的

2738
02:07:28,000 --> 02:07:30,000
都是 podcastatthetype.com

2739
02:07:30,000 --> 02:07:32,000
podcastatthetype.com

2740
02:07:32,000 --> 02:07:34,000
podcastatthetype.com

2741
02:07:34,000 --> 02:07:36,000
podcastatthetype.com

2742
02:07:36,000 --> 02:07:38,000
同时呢,大家也可以在社交网站上

2743
02:07:38,000 --> 02:07:40,000
或者是我们在新浪微博,在 Twitter

2744
02:07:40,000 --> 02:07:42,000
在微信上面

2745
02:07:42,000 --> 02:07:44,000
我们的 ID 都是

2746
02:07:44,000 --> 02:07:46,000
the type, T H E T Y P E

2747
02:07:46,000 --> 02:07:48,000
那么在 Facebook 上搜索

2748
02:07:48,000 --> 02:07:50,000
typeisbeautiful

2749
02:07:50,000 --> 02:07:52,000
也可以关注到我们,同时呢,我们在知乎专栏上

2750
02:07:52,000 --> 02:07:54,000
也会同步的发布每一期节目的

2751
02:07:54,000 --> 02:07:56,000
这个节目简介

2752
02:07:56,000 --> 02:07:58,000
同时呢,也欢迎大家

2753
02:07:58,000 --> 02:08:00,000
关注 typeisbeautiful 的网站

2754
02:08:00,000 --> 02:08:02,000
typeisbeautiful.com

2755
02:08:02,000 --> 02:08:04,000
感谢收听

2756
02:08:04,000 --> 02:08:06,000
IPNpodcast

2757
02:08:06,000 --> 02:08:08,000
网络旗下的 IT 技术主题娱乐节目

2758
02:08:08,000 --> 02:08:10,000
内核恐慌

2759
02:08:10,000 --> 02:08:12,000
我们号称 Hardcore,但是也没有干货

2760
02:08:12,000 --> 02:08:14,000
想听人听,想听人就别听

2761
02:08:14,000 --> 02:08:16,000
您可以为本节目捐款

2762
02:08:16,000 --> 02:08:18,000
地址是 kernelpanic.femme.donate

2763
02:08:18,000 --> 02:08:20,000
捐款金额索利只要是 8 的正式入备就可以了

2764
02:08:20,000 --> 02:08:22,000
捐款不会给你带来什么

2765
02:08:22,000 --> 02:08:24,000
不捐也不会让你失去什么

2766
02:08:24,000 --> 02:08:26,000
我们的口号是 nohardvillains

2767
02:08:26,000 --> 02:08:28,000
如果你有任何反馈

2768
02:08:28,000 --> 02:08:30,000
可以发电子邮件到 kernelpanic.femme.donate

2769
02:08:30,000 --> 02:08:32,000
可以发电子邮件到 kernelpanic.femme.donate

2770
02:08:32,000 --> 02:08:34,000
同时也欢迎你

2771
02:08:34,000 --> 02:08:36,000
我们是 kernelpanic.femme.donate 主持的风头圈

2772
02:08:36,000 --> 02:08:38,000
现在好像改成收费奖

2773
02:08:38,000 --> 02:08:40,000
对

2774
02:08:40,000 --> 02:08:42,000
还加了会员

2775
02:08:42,000 --> 02:08:44,000
其他几档节目

2776
02:08:44,000 --> 02:08:46,000
未知道,他一来了

2777
02:08:46,000 --> 02:08:48,000
流行通信,high story,硬影像,无资源

2778
02:08:48,000 --> 02:08:50,000
博物制,选美,必下观,一天世界

2779
02:08:50,000 --> 02:08:52,000
时尚怪物,我们下期节目再会

2780
02:08:52,000 --> 02:08:54,000
拜拜

