1
00:00:00,000 --> 00:00:03,000
3 2 1 开始

2
00:00:22,000 --> 00:00:29,000
大家好,今天是 2020 年的 5 月 26 号,也是《字谈字唱》的第 126 期。

3
00:00:29,000 --> 00:00:37,000
您正在收听内核恐慌一档大致一算机科系为主题的娱乐 podcast,我们号称硬核,但是也没有什么干货,想听就听,不想听就别听。

4
00:00:39,000 --> 00:00:42,000
这是我们的第 58 期。

5
00:00:42,000 --> 00:00:48,000
是啊,这同时也是我们《字谈字唱》和内核恐慌串台的《字谈字串》的第 9 期。

6
00:00:49,000 --> 00:00:56,000
《字谈字唱》是全球首家用华语制作的字体反映主题播客节目,我是主播,文川西藩动音剧 Eric。

7
00:00:57,000 --> 00:00:59,000
我是主播,黄浦江,明星真鱼,浅真鱼。

8
00:01:00,000 --> 00:01:01,000
我是吴涛。

9
00:01:01,000 --> 00:01:02,000
我是 Rail。

10
00:01:03,000 --> 00:01:04,000
哇,我们都串了 9 期了呀。

11
00:01:05,000 --> 00:01:10,000
对呀,然后我们上一期是一年之前录的。

12
00:01:11,000 --> 00:01:17,000
我们串了 9 期了,我们都还没有那个 title,就是你们前面那个很酷炫的那个 title。

13
00:01:17,000 --> 00:01:20,000
我们曾经有过,但是我们觉得太 awkward,所以我们放弃了。

14
00:01:20,000 --> 00:01:27,000
距离上次《字谈字串》第 8 期那期是叫什么,人造千年虫。

15
00:01:27,000 --> 00:01:33,000
哇,那是令和元年对吧,2019 年的 5 月 14 号,刚好是整整一年。

16
00:01:33,000 --> 00:01:43,000
在这一年里面,我们的《字谈字唱》从第 99 期更新到到 126 期内核恐慌,从第 55 期更新到第 58 期。

17
00:01:43,000 --> 00:01:44,000
是吧?

18
00:01:47,000 --> 00:01:49,000
沧海双浅,中间经历了多少巨变。

19
00:01:50,000 --> 00:01:55,000
人家都两位数变三位数了,我们还缓慢的爬行了,我们总共更新了 3 期。

20
00:01:57,000 --> 00:02:03,000
但是你们很厉害呀,你们图标也变了,那个域名也变了,然后连官网的字体都换掉了。

21
00:02:04,000 --> 00:02:08,000
对,我们这个是应该是 2020 年有什么,改图画面了,之前。

22
00:02:08,000 --> 00:02:11,000
我们功夫都用在节目之外了,应该说。

23
00:02:11,000 --> 00:02:13,000
这叫看得见的地方,听不见的地方。

24
00:02:13,000 --> 00:02:20,000
说实话,我现在打了个怕你哭还是感觉很有违和感,知道吗?

25
00:02:20,000 --> 00:02:22,000
为什么?不挺好的吗?

26
00:02:22,000 --> 00:02:24,000
怕你哭多好呀。

27
00:02:24,000 --> 00:02:25,000
好怪。

28
00:02:26,000 --> 00:02:27,000
听起来很日本嘛。

29
00:02:28,000 --> 00:02:31,000
然后这个点针字看起来还感觉挺好的,不过。

30
00:02:32,000 --> 00:02:38,000
对,点针字就是因为上次听到你们应该是最新一期节目吧,就是第一帽题还是前一期。

31
00:02:38,000 --> 00:02:40,000
因为我们是前一期了已经是。

32
00:02:40,000 --> 00:02:42,000
对,前一期了,你们那个速度比较快。

33
00:02:43,000 --> 00:02:54,000
然后我就说,嗯,我之前本来一直想换的嘛,然后就是因为之前我们是先换的这个 logo,先换的那个像素点,也不叫像素点,那个叫什么?

34
00:02:54,000 --> 00:02:57,000
我叫 LED 灯的那个风格的 logo 嘛。

35
00:02:57,000 --> 00:02:58,000
那是圆的是吧?

36
00:02:58,000 --> 00:03:12,000
对,当时我就想说,那干脆拿这个风格把这个正文字也换了,不是有这个 web font 嘛,但是后来转念一想,那中文字体的 web font 马上就劝退了嘛,因为都知道这个体积会比较惊人对吧。

37
00:03:13,000 --> 00:03:22,000
然后来听你们前一期节目找这个微力来聊的时候,我在想,哎,如果是纯点真的,那不就没有这个体积问题了吗?

38
00:03:22,000 --> 00:03:23,000
因为我简单算了一下这个数,对吧?

39
00:03:23,000 --> 00:03:35,000
假设我是一个 10 像素乘以 10 像素的汉字,那么一个像素,就算我不压缩的情况下,我一个汉一个方块就是 100 个 bit 嘛,100 个 bit 除以 8 才多少?

40
00:03:35,000 --> 00:03:39,000
不到不到 20 个这个 bite,对吧?

41
00:03:39,000 --> 00:03:43,000
算下来,然后再稍微压缩一下,应该是可以接受的嘛。

42
00:03:43,000 --> 00:03:47,000
但是问题是丁宝他不是真正的点证,他其实是使用字啊问题。

43
00:03:47,000 --> 00:04:03,000
这就是我遇到的第一个问题,就是后来发现是没有办法是真的使用在 web font 上,是没有办法使用点证字体的,就好像跟微力那期你们也聊了嘛,就是 windows 的自带的系统字体,他有好几个都是有内签点证的嘛。

44
00:04:03,000 --> 00:04:05,000
对这个所谓的中意宋体嘛。

45
00:04:05,000 --> 00:04:13,000
对对对,还包括之前就是在古早时期的这个 linux 系统里面有那个叫文权易那个那套东西,你知道吧?

46
00:04:13,000 --> 00:04:15,000
那应该是 pcf 吗?

47
00:04:15,000 --> 00:04:33,000
这个格式我不知道,我就说就是文权易他们当时也做过就是那种,他做过那个就是他叫他叫他在这开源吗我不知道,就是免费的这种自由的这种中文点证字,他做的一个高质量的嘛,他当时是应该是中文互联网上比较早的那种就是 crowdsourcing 的项目。

48
00:04:34,000 --> 00:04:48,000
他当时我记得是做了一个这个网页,那个时候还挺不容易的,那个时候网页技术都比较落后嘛,他们用通过这个网页的方式让大家去拆这个字,然后点这个像素点嘛,然后就是他们那边也有一套这个点证字。

49
00:04:48,000 --> 00:04:58,000
但是呢,这些都是没有办法用到这个那个 webfont 里面的,因为 webfont 的目前主流的几个格式啊,就最开始的那个 eot 什么叫做 embedded open type 对吧。

50
00:04:59,000 --> 00:05:09,000
后来的这个 svg 包括在目前最新的那个 wolf 和那个 wolf 2 对吧,他们在那个生成的时候就直接是不支持这个内签点证的,所以这条路就是断掉的。

51
00:05:09,000 --> 00:05:19,000
那所以你上期这个 willy 他做那个也是一个就是折中的方案嘛,就是用矢量来模拟点证的那种风格对吧。

52
00:05:20,000 --> 00:05:33,000
但是你还别说这其实还是有用的,就是虽然说不是一个真正的点证,就是我要我要表达一个 10 个像素乘以 10 个像素的字,我并不能真的只用 100 个 bit 就可以实现哈。

53
00:05:33,000 --> 00:05:43,000
但是因为极度简化过的那个方那个就是微点证就是矢量点证,它其实是一个各种各样的小方块嘛对吧。

54
00:05:44,000 --> 00:05:51,000
小方块就有个好处,它就什么没有这个什么什么取背塞而曲线那些转角啊什么的,它的那个点就比较少嘛。

55
00:05:51,000 --> 00:06:02,000
嗯,没错。你想想这个道理吧。OK,就是确实就拿这个 willy 他拿这个他他给了我一个这个低谋的 dtf,然后我把它转成那个那个 wolf 2。

56
00:06:02,000 --> 00:06:08,000
wolf 2 是 wolf 的那个升级版,他的压缩比例又提高了百分之好像 20 左右吧,应该是。

57
00:06:08,000 --> 00:06:14,000
那其实我我压完之后,他当时给的是一套这个就是还在 beta 中的这个 DMT 的这个文件给我嘛。

58
00:06:15,000 --> 00:06:30,000
我压完之后其实也就才不到 500 kb 的那个大小。哦,那挺好的呀。对对对,就 500 kb 反正在比如在 5 年前可能还是一个有一点纠结的这个尺寸,因为毕竟还是网络要下载,要带宽不高的情况下嘛。

59
00:06:30,000 --> 00:06:50,000
他现在在 500 kb,我们这个有四级网络,马上五级网络,对吧,又是这个光纤入户都还挺多的。500 kb 的话,你其实你在这个 instagram 上刷一张图估计都不止 500 kb 了,对吧,很多这个网页你加载一个这个什么 javascript 的这个酷,那可能都是差不多那个水平了,所以完全可以接受嘛。

60
00:06:51,000 --> 00:07:18,000
所以我就说,哎,那其实可以的,我就换上这个把我们的这个官网的那个 web font,就换上了这个 DMT 作为主,然后设了一些这个系统自带的一些 backup 嘛,就是如果因为某种原因你的这个系统,你的那个你浪迁不够现代或者是你用的那个什么插件禁用那个 web font 的话,那你还是会退到你系统貿易的那些字体嘛,所以就整个起来就风格就还觉得还不错啊。

61
00:07:18,000 --> 00:07:18,000
嗯,用这种假的点证的话,其实嗯,其实是实量嘛,但是你这样用容易用,要不然的话,你点证真点证的话,你那个字号不好弄嘛,对,就是有这个问题的话,你一个字号要一套点证,反而这种假点证的话,你可以就是你可以随意缩放吗,反而更好,是是是,因为你如果用真点证的话,缩放的话,因为其实现在我想想,呃,我们制造的这个,

62
00:07:48,000 --> 00:08:18,000
至少在英特尔出那个,还要 emd 吧,出下一代的那个显卡之前,我们目前所用的这个就是就是显卡,包括不管内嵌的还是独立的,包括手机上的也好,他都不能做我们叫做这个整数倍缩放,什么意思呢,就是比如说我要,我用现代都是用的这个什么,高分高清频,什么 2 X 3 X 的,什么意思,就是相对于相对于一个像素点,他我们之前讨论过是用可能是用 4 个物理点,或者是 9 个物理点,就是 2,2 乘以 2,

63
00:08:18,000 --> 00:08:48,000
或者是 3 乘以 3 的这个这个格子来做吗,所谓的这个整数倍缩放什么意思呢,就是说假设我是一个这个 4 K 的屏幕,对不对,然后但是你想那个 4 K 游戏,他有很多这个特效不是显卡的数理能跟不上吗,所以很多很多时候他只能用这个,就放这个 1080 来的这个分辨率来来来显示这个游戏,对吧,但是 1080 分辨率,但是你又是 4 K,4 K 就刚好是 4 个 1080 的屏幕的那个拼,就是那填字格拼起来嘛,对吧,那

64
00:08:48,000 --> 00:08:57,000
就有个问题了,那一个 1080 像素点是对应 4 个这个 4 K 的像素点吗,就我们通常想那肯定就是说把那 4 个物理像素点都渲染成这个一个

65
00:08:58,000 --> 00:09:08,000
这个逻辑像素点的那个颜色,那这样不就看起来,虽然说是 4 K 的屏幕,但看起来还是 1080 的那个清晰那么锐利,对不对,嗯,但其实并不是这样子,因为现在

66
00:09:09,000 --> 00:09:17,000
主的显卡都是叫做他叫什么 Linear 的这种,那个词叫什么来的,Interpolate,对 Interpolate,就是他就会去插纸

67
00:09:18,000 --> 00:09:24,000
插纸去算了,比如说我要,如果你你想象一下这么一个场景,你说你这个 1080 的屏幕上从左到右是一个从

68
00:09:25,000 --> 00:09:28,000
白到黑的一个渐进的一个过渡,对吧

69
00:09:28,000 --> 00:09:36,000
正常的话,如果说你是这个在 4 K 屏幕上显示,那你说你每一个线条绘制两遍嘛,就是每一数行你就绘制两遍,对不对

70
00:09:36,000 --> 00:09:40,000
但其实并不是这样,他还是要在 4 K 上,他是要算出那两条

71
00:09:40,000 --> 00:09:48,000
1080 的中间值是怎么样子,然后再把那个中间值绘制在那个 4 K 的那个多出来的那个像素,内数的这个像素上面的去吧

72
00:09:49,000 --> 00:09:57,000
那在这个网页的上面其实有类似的问题,就是说我本来说我有一个这个,比如说是这个 10 乘以 10 像素的这个点证字

73
00:09:57,000 --> 00:10:01,000
但我能不能渲染到这个 20 乘以 20 这个分辨率上去,其实做不到的,对不对

74
00:10:01,000 --> 00:10:07,000
OK,在这个情况下,就刚才 Eric 说那个问题,就是说你反而用这种

75
00:10:08,000 --> 00:10:15,000
微点证,就是用矢量来模拟的反而更好,它可以缩放一点,但是我遇到一个问题,就是现在的网页的 CSS 里面那个

76
00:10:16,000 --> 00:10:22,000
宽度啊,它有可能我不是按这个整数像素来定的那个宽度,它可能比如说是一个百分比,对吧

77
00:10:23,000 --> 00:10:26,000
百分比之后,它算出来,它最后还是要落实的,它的这个叫什么

78
00:10:27,000 --> 00:10:31,000
Rasterize 的时候,Rasterize 叫三格化的时候,它还是会

79
00:10:32,000 --> 00:10:41,000
变成,要变成一个具体的到哪一个像素点的坐标上去,有时候如果你是按百分比的话,它不就出不尽吗,它就有这个小数

80
00:10:41,000 --> 00:10:51,000
那么就变成了,就说这个就结合到我们之前几集谈过的那个四像素平滑的问题,对吧,先是就是灰度平滑,就是说我先还是一个像素,我不考虑这个

81
00:10:52,000 --> 00:11:01,000
LCD 屏幕这个这个,紫像素的结构,我直接按灰度平滑,比如说我们现在在这个 iOS 设备上面都是这样子的,对吧,它是没有这个次像素平滑,都是灰度平滑的话

82
00:11:01,000 --> 00:11:11,000
这样的话就相对来说还好一点,它就最多是在左边一个像素,或右边一个像素,或者它如果它觉得这个应该是两个像素之间,那它可能在这个灰度上面做一些这个这个平均,对不对

83
00:11:11,000 --> 00:11:15,000
但是就会导致我这个丁毛点正体啊

84
00:11:15,000 --> 00:11:23,000
本来我想的效果是应该是非常边缘锐利,我把它那个那个叫做那个像素的那个字体的尺寸调好的话,它边缘应该是非常锐利的嘛

85
00:11:23,000 --> 00:11:27,000
但是因为由于这个非整数的这个这个宽度的问题

86
00:11:28,000 --> 00:11:40,000
他可能那个字的那一数啊,就是说他旗帜的那个位置,他在排版引擎加上那个三个画质,三层,他是在这个从左到右第 32.57 个像素点,那个时候在开始

87
00:11:40,000 --> 00:11:51,000
会制这个时候怎么办,就是你还是会看到就是在有些地方他的那个这个字的边缘是有一层这个那个叫什么,就是灰灰灰灰灰的那种感觉的

88
00:11:51,000 --> 00:12:01,000
如果说你是有这个刺向素平滑,然后你这个人眼睛又比较敏感,或者是这个你的屏幕素质是有一点问题的话,你看到他可能边上有一点那种就知道那个

89
00:12:01,000 --> 00:12:08,000
踩边对,踩边那个 Clear Type 那种常见的问题嘛,所以还是挺头疼的这个事情,对

90
00:12:08,000 --> 00:12:16,000
毕竟你是假点证嘛,对对对,就是假点证的问题,但是就是说刚才你说的那个缩放的问题其实这里还是有一点技巧的,就并不是说

91
00:12:17,000 --> 00:12:23,000
我因为是这个真实量微点证就可以自由缩放了,其实也我要达到刚才那种就是

92
00:12:24,000 --> 00:12:28,000
Pixel to pixel 就是像素点对像素点的那种清晰和锐利的话

93
00:12:28,000 --> 00:12:35,000
其实还是有讲究的,比如说这个我用的那个正问题是丁毛的,丁毛其实只有两个尺寸,就是七像素和九像素嘛,对吧

94
00:12:36,000 --> 00:12:41,000
七像素假设说他其实是因为有一个像素的留白的话,他其实是八像素宽和十像素宽的这么一个

95
00:12:42,000 --> 00:12:46,000
字体,对吧,这样你在 CSS 里面设置的时候呢,你就要设置成

96
00:12:47,000 --> 00:12:51,000
正常你应该设置成十个像素,对不对,但是因为十个像素实在是太小了

97
00:12:52,000 --> 00:13:01,000
就是那个就是因为现在很多屏幕的这个 firmware 挺高的嘛,就是而且手机上你强制设置十个像素,他也字也比较小,所以我就设置成了 15

98
00:13:02,000 --> 00:13:10,000
哎 15 你想不就出不尽了吧,对不对,你必须把它量子化,但其实是可以的,因为我看目前我们大部分人用的这个不管是笔记本也好还是这个

99
00:13:10,000 --> 00:13:15,000
就至少 Mac,Mac 现在应该已经没有这个非 retina 屏幕的 Mac 在销售了,对吧

100
00:13:16,000 --> 00:13:25,000
销售肯定没有了,但使用肯定还要使用,而且你要考虑到外接显示器这个问题啊,就是至少是所有的 Mac,就是芯机和这个所有的这个

101
00:13:25,000 --> 00:13:28,000
呃就是目前应该在市的这个 iOS 设备应该都是这个

102
00:13:29,000 --> 00:13:38,000
所谓的就高分屏嘛,就是就是 retina 屏幕,对不对,那么就有两种了,我们一种是就是常见的 Mac 都是这个 2 X 的,对吧,然后还有这个那个叫什么 iPhone

103
00:13:39,000 --> 00:13:49,000
这个什么比方 11 Pro,他是那个三三三变的那个三变的,对对,但三变的话就相对来说,我就那个就相对来说我也没有那个设备嘛,所以我都是两变的设备

104
00:13:49,000 --> 00:13:52,000
我就是整十五个像素,十五个像素的逻辑

105
00:13:53,000 --> 00:14:01,000
其实对应 30 个像素的物理,对不对,OK,30 个像素的物理除以十个像素的几个丁宝的点,整体不是刚好也能是三倍吗

106
00:14:02,000 --> 00:14:08,000
所以他写的最小的最小公倍数,对对对,找搞个这个这个他能够能够整除的地方就还挺好的

107
00:14:08,000 --> 00:14:10,000
但是问题就来了哈,我后来我想起来了

108
00:14:11,000 --> 00:14:17,000
你记不记得那个你们有买最新的那个 MacBookPro 的笔本吗,就最近两三年的

109
00:14:19,000 --> 00:14:21,000
特别是 13 寸的那个那个机型,没有

110
00:14:22,000 --> 00:14:30,000
想买没有没有人给我们捐款,就是那个,对这个我们忘了在节目里面说了,请大家给我们捐款

111
00:14:31,000 --> 00:14:41,000
想请请欠我们,没有人用爱给我们发电的,说回来说回来,就是就是 13 寸那个机型的那个屏幕的那个

112
00:14:41,000 --> 00:14:47,000
那个那个面板的分辨率是我记得是 2560×1600 应该是这样,就是他的

113
00:14:48,000 --> 00:14:55,000
逻辑是 1280×800 嘛,1280×800 在当下其实是一个非常窄的一个显示的面积,对不对

114
00:14:57,000 --> 00:14:57,000
所以呢

115
00:14:58,000 --> 00:15:06,000
苹果后来,应该我记得应该是在前几年开始的,就应该就是最近这一代就是那个就是把就是蝴蝶键盘那那代开始

116
00:15:06,000 --> 00:15:11,000
他的那个出厂默认设置 13 寸的那个 MacBook 的的那个

117
00:15:12,000 --> 00:15:14,000
默认的分辨率他并不是

118
00:15:14,000 --> 00:15:25,000
是点对点的那个清晰的,他用了一个,就他的默认值是一个缩放的,就是他说发出来应该是个 1440×900 的这么一个

119
00:15:26,000 --> 00:15:34,000
逻辑的分辨率,但其实他的物理上他并除不尽嘛,你就就是 2560 除以这个 1440 是除不尽的,1260-1280 的两倍嘛

120
00:15:35,000 --> 00:15:41,000
所以他虽然说是逻辑上的这个二叉,但他物理上并不,物理上并不是,他只是没有点到点

121
00:15:41,000 --> 00:15:57,000
就他推荐的那个设置没有点到点,对对对,他现在我已经完全不点对点了呀,所有的,但我都是调到点到点的,比如我现在这台 15 寸的,我不用他默认的那个缩放,我就会改成正好是两倍的那个分辨率

122
00:15:57,000 --> 00:16:09,000
对,因为 15 寸他原生的这个点对点分辨率应该是 1440 宽的嘛,对吧,他其实调整到 12,但他推荐你设的是 1680×1050,对对对,他都是都是变成我们叫做 Scaled Mode,就是缩放模式,对不对

123
00:16:10,000 --> 00:16:12,000
对,他可以让你的屏幕看起来容量更大一点

124
00:16:12,000 --> 00:16:26,000
对对对,因为他就是要展示更多的内容嘛,但是其实这样是会影响,他可以让你的视力下降更快一点,其实你看绝大部分是看不出来的,但是如果说你对这个点对点那种有洁癖的话,比如说我们如果要强行

125
00:16:26,000 --> 00:16:33,000
用这个低毛点证,要点对点的话,你在这两个就是你在最新的这个 MacBook 笔记本上是实现不了的

126
00:16:33,000 --> 00:16:49,000
对吧,因为他默认值不是那样子的,所以我都是把那个默认值调,我都是手动把他改成 2 X 的那个点对点的模式,这样我看起来那些才正常嘛,但是这样的后果就是说你的可显示的这个实际面积感觉就变小了嘛

127
00:16:50,000 --> 00:17:01,000
就字更大嘛,对对对对,他那个设置不是就是选,你要么选较大文字,要么选更多空间嘛,字很小的空间更大嘛,是的

128
00:17:01,000 --> 00:17:04,000
嗯,那他的那个系统设计就只能这样选嘛

129
00:17:05,000 --> 00:17:15,000
对,那这样就会很影响,就本来之前吧,你说你只是你做设计的人有这个问题,你把那个这个调一下,你这样看出交付的作品还是这个点对点清晰的,对不对

130
00:17:16,000 --> 00:17:21,000
但现在这个默认值变成这个 Skill Mode,就是说哪怕你交付的作品是点对点清晰的,最后你

131
00:17:21,000 --> 00:17:27,000
就是用户选看到的时候,他其实也是被这个 Skill 掉了嘛,所以这个事情我觉得挺挺挺扯的

132
00:17:27,000 --> 00:17:39,000
所以他他的意思就是你别纠结这个事情,已经出破了视觉极限了是吧,iOS 设备的话没有办法了,iOS 至少目前还是清晰的,我觉得他的意思其实是普通用户根本不应该操心这些事情

133
00:17:39,000 --> 00:17:43,000
嗯,对呀,但是就是这还是一个 Compromise,就是说在这个

134
00:17:44,000 --> 00:17:51,000
显卡的这个处理能力面板的这个叫什么,就是这个显示就是显卡到面板的连接带宽

135
00:17:51,000 --> 00:18:00,000
以及这个面板的实际的这个工艺的限制的情况下做出了这么一个 Compromise,但我觉得这毕竟不是这个长远之计

136
00:18:01,000 --> 00:18:11,000
哎,我又想起来,我我因为我实际主力机是 27 寸的那个 iMac 嘛,是 5 K 的屏嘛,哦,那个显卡是想

137
00:18:11,000 --> 00:18:21,000
可以看得出来他很吃力,知道吗,刷给你,我可以感觉到显卡很吃力,这个共情容易,对呀,你想 5 K 的屏幕啊,你渲染的时候得多大呀

138
00:18:21,000 --> 00:18:30,000
你想想那个 5 K 的屏你抓个屏,啊,对,抓个屏出来,一个一个 PNG 文件的话,这个也是超大的

139
00:18:30,000 --> 00:18:34,000
对,那个还是就是减无损压缩的嘛,都可以好几兆了,对呀

140
00:18:35,000 --> 00:18:41,000
Anyway,就说回丁某,丁某点证,就所以就当时我们就,我就试了一下,我就感觉效果还行

141
00:18:42,000 --> 00:18:48,000
然后我就跟这个威力说这个事,然后他还帮我们做了很多其他的事情,因为丁某他应该是我

142
00:18:49,000 --> 00:19:00,000
如果我们记得说应该是我们是,应该是我们网站应该是第一个正式商用的,对,对,对,然后他就就其实遇到了很多问题,比如说

143
00:19:01,000 --> 00:19:07,000
你想我们上一次节目的时候不是有这个讨论这个令和这个这个合字吗,对不对,嗯

144
00:19:08,000 --> 00:19:13,000
他做的吧,我记得对,那个令和次丁某里面他唯一做了两个令和

145
00:19:13,000 --> 00:19:21,000
就是合在一起的,但这个时候其实已经很为难了,对不对,一个十项素成十项素点,你要加一层两个汉字进去

146
00:19:22,000 --> 00:19:28,000
我看了一下反正也是比较勉强,但是我还鼓动这个威力说,哎,那你要不要去把这个挑战一下极限

147
00:19:29,000 --> 00:19:38,000
把前面那几个都做完,那个叫什么招合,对吧,从招合开始,他说不做了,不做了,我说还有九项素做招合,我天呐

148
00:19:38,000 --> 00:19:42,000
这还不正常的,还有那个就是那个日文那个诸事会设

149
00:19:43,000 --> 00:19:49,000
我觉得做大正可能还可以想象,做其他的,oh my god,那诸事会设怎么办

150
00:19:50,000 --> 00:19:58,000
不要说这些了,当然是不要说盒子,就写一个汉这个什么雷霆万钧啊,那个那个那个都已经写的一坨一坨的

151
00:19:59,000 --> 00:20:05,000
哎,对对,就这个我就我就担心怕那个不易读嘛,然后我就套上之后,我就做了一个这个

152
00:20:06,000 --> 00:20:15,000
usability test,就是找找找找找找我太太拿来试了一下,我就把我们有一期节目的那个那个就是 summary,就是那个叫什么节目简介

153
00:20:15,000 --> 00:20:22,000
他有一段话嘛,写了一段话,就是五十七节目有一段话,我先把那个点就换上,然后那些就是点的点都调好,然后我等他来读那段话

154
00:20:23,000 --> 00:20:30,000
基本上就还挺挺超乎我意外的,就是还基本上没出他们差错,就是一人性还是很好的,而且主要是你放在

155
00:20:31,000 --> 00:20:40,000
这个有上下文之类的话,就没错,可以猜嘛,对吧,有语境的话就可以,而且我用的是那个九九九相送的,九相送相对来说还是看得清楚一些的

156
00:20:41,000 --> 00:20:43,000
七相送这款呢,如果没有上下文确实有点难度了

157
00:20:44,000 --> 00:20:55,000
嗯,这关键是有语境的话就好,是的,是的,所以我就想,哎,反正我们这个网站看的也不多,对吧,因为大部分都是在这个,就是订订阅订阅在这个这个

158
00:20:55,000 --> 00:21:04,000
播客客户端里面去去去看的,也不会说经常去我们网页翻来翻去,对吧,所以我想,那不刚好我们这个网页还可以做的这个风格

159
00:21:04,000 --> 00:21:08,000
这个别致一点,反正也不怎么常读他嘛,对吧,也没几个字其实

160
00:21:08,000 --> 00:21:13,000
对,又不像我,你们还要发这个,你们官网这个这个太不官网还要发很多这个播文什么的

161
00:21:13,000 --> 00:21:21,000
我们一般就一期节目可能不到 100 个字的这个汉字,对吧,完全没有问题,所以每期节目来来看的人也就 100 个了

162
00:21:21,000 --> 00:21:31,000
嗯,我很怀疑,我很怀疑,对,anyway,就是就这样的话,我就把那个丁毛用起来,然后,但是其实我们还遇到了其他很多问题哈,比如说

163
00:21:32,000 --> 00:21:42,000
嗯,我们上次不是也是讨论这个那期节目,除了讨论有有有讨论日本的地方,就很多那个叫 shownotes 里面有很多这个日文的这个符号嘛

164
00:21:43,000 --> 00:21:52,000
然后刚好这个丁毛里面你威力他也做了那个日文的那些什么就是对他有做的,对对,就看我,效果还挺好的,超乎我的意料

165
00:21:52,000 --> 00:22:03,000
后来他他交付给我的就是为了提还是为了这个提及的原因嘛,我就说我们大概率应该不会讲不会也不会打主要是哈也不会用这个什么阿拉伯文和希布莱文吧,就把那几个符号给去掉了

166
00:22:04,000 --> 00:22:09,000
然后我问威力说他应该是没有韩文的部分的,因为韩文好像挺坑的,就是比较难做

167
00:22:10,000 --> 00:22:15,000
但我们想一下好像我们官方也没有韩文,这个也还也就过去了

168
00:22:15,000 --> 00:22:25,000
但是又遇到另外一个问题就是我们毕竟是一个对吧,面向的一个中老年程序员的一个节目嘛,所以有有有有两期节目是有

169
00:22:26,000 --> 00:22:34,000
贴代码的,有一有一小段代码,那么我就需要一个等宽的这个这个拉丁字符嘛,然后威力就帮我们调了一个这个

170
00:22:35,000 --> 00:22:40,000
最开始是用了一个七像素嘛,但就是有些这个还是有些问题

171
00:22:40,000 --> 00:22:50,000
然后后来他又专门帮我们定制了一个这个等宽的这个点字字,但是就不是这个那个严格跟中文有那个等比的关系了

172
00:22:50,000 --> 00:22:54,000
但其实还好,因为我不需要跟中文配配对用,然后

173
00:22:55,000 --> 00:23:00,000
另外一个场景就是我们不是之前每期节目舞蹈都会有一句 slogan 嘛

174
00:23:01,000 --> 00:23:08,000
那句 slogan 在我们,本期的口号是,对对对对,我们那个那个 slogan 在排版上在网页上排版,那句 slogan 是邪题排的

175
00:23:10,000 --> 00:23:16,000
所以威力又给我们定制了一套邪题字的这个丁毛点阵的就是这个英文字符啊

176
00:23:17,000 --> 00:23:23,000
当时因为有一个事情过于疯狂,我们就是只是在微信上简单聊了一下这个事情并没有真的发生

177
00:23:23,000 --> 00:23:25,000
威力说他其实中文也有邪题的

178
00:23:25,000 --> 00:23:32,000
所以这个邪题是威力做的是吧

179
00:23:32,000 --> 00:23:34,000
是威力做的,其实还可以嘛

180
00:23:34,000 --> 00:23:43,000
也是调了几次的,就是是拉丁字幕的邪题,我想知道他是自动生成的,就是这是一个程序生成的还是他一个一个自己去排的

181
00:23:43,000 --> 00:23:50,000
最开始是那个程序生成,其实就不是那个不是邪题是那个叫做那个 oblique 是不是

182
00:23:51,000 --> 00:23:52,000
Italic

183
00:23:53,000 --> 00:23:57,000
不是 Italic 是真邪题,我有个伪邪题就直接把那个点字拉邪了

184
00:23:57,000 --> 00:24:02,000
最开始是那个,当时我都没有留意到这个问题,我都忘了我们有

185
00:24:02,000 --> 00:24:05,000
有用邪题的地方了,因为最近几个没有用

186
00:24:05,000 --> 00:24:09,000
得归无踏,说了那么多口号都被你忘了

187
00:24:10,000 --> 00:24:13,000
中文用邪题是异端啊,中文用邪题应该用台词吗?

188
00:24:13,000 --> 00:24:17,000
不是不是,就是我们口号都是英文的嘛,所以就是只是英文的部分,但是

189
00:24:17,000 --> 00:24:20,000
我开始没有意识到,后来是我把那个

190
00:24:20,000 --> 00:24:26,000
Demolweb 部署成外放到网上去,然后让 Willie 来看

191
00:24:26,000 --> 00:24:30,000
效果的时候,他发现了,然后他说这个邪题好像是有点问题,他就修了一下

192
00:24:30,000 --> 00:24:34,000
他给了我单独的一个,就之前给我单独一个叫做

193
00:24:34,000 --> 00:24:41,000
叫做 Dinky code,可是那个很宽的,后来又做了 Dinky 的 Italics

194
00:24:41,000 --> 00:24:45,000
但这两个都是只包含拉丁和

195
00:24:45,000 --> 00:24:51,000
常用符号那部分了,其他都,中文肯定没有办法做邪题这么小的情况下

196
00:24:51,000 --> 00:24:55,000
但其实你看那个邪题的话,它的那个易读性就要比

197
00:24:55,000 --> 00:24:58,000
普通的正常版本就要差好多了吧

198
00:24:58,000 --> 00:25:03,000
那肯定的,就抖啊,真邪题的刻度性是要差的,但是

199
00:25:03,000 --> 00:25:05,000
伪邪题之前的易读性还是挺不错的

200
00:25:06,000 --> 00:25:08,000
很奇怪对不对

201
00:25:09,000 --> 00:25:15,000
这个网页啊,看习惯了以后,反而就已经习惯了这个点证

202
00:25:15,000 --> 00:25:20,000
看习惯了,反而就看,比如说咱们那个字弹字串的第三期那个

203
00:25:21,000 --> 00:25:23,000
表情符号,超清晰的

204
00:25:23,000 --> 00:25:27,000
Emoji,反差感特别强烈是不是

205
00:25:27,000 --> 00:25:27,000
对

206
00:25:31,000 --> 00:25:32,000
这个太魔幻了

207
00:25:32,000 --> 00:25:38,000
反正我们目前还挺满意这个显示效果的,虽然说刚才有说如果你仔细看的话有一些这个

208
00:25:38,000 --> 00:25:46,000
那但根据你浏览器宽度啊,因为它那个那个分栏是自适应的嘛,在某些宽度下面它就会出现那个那个叫做灰标的问题

209
00:25:46,000 --> 00:25:48,000
但是有些情况下,如果你刚好

210
00:25:48,000 --> 00:25:52,000
差好,那分栏出来都是整数倍的这个像素,就不出现那个

211
00:25:53,000 --> 00:25:58,000
就是这个定位,就是半个像素的,或者是小于一个像素的情况下,它的那个

212
00:25:58,000 --> 00:26:00,000
每个边缘都是非常锐利清晰的,啊它

213
00:26:00,000 --> 00:26:01,000
还要加这个

214
00:26:02,000 --> 00:26:03,000
加这个信号就是

215
00:26:03,000 --> 00:26:09,000
你前提是你在一个真的可以点对点显示的这个 2 X 或者 3 X 屏幕上才可以对吧,因为刚才讲了

216
00:26:09,000 --> 00:26:13,000
这个 Mac 的那个问题,其实你特别在意,如果你特别在意这个

217
00:26:14,000 --> 00:26:15,000
嗯,就是

218
00:26:15,000 --> 00:26:16,000
显示器

219
00:26:16,000 --> 00:26:17,000
或者说是

220
00:26:17,000 --> 00:26:22,000
这个应该其实这个应该是浏览器带来的这个次像素渲染,或者是其他的一些这个

221
00:26:23,000 --> 00:26:26,000
抗锯齿渲染效果,你可以在 CSS 里把它关掉

222
00:26:26,000 --> 00:26:26,000
关掉

223
00:26:27,000 --> 00:26:29,000
没有用啊,关掉不解决刚才那个问题啊

224
00:26:29,000 --> 00:26:32,000
可以一定程度上缓解,因为 CSS 里面

225
00:26:33,000 --> 00:26:35,000
至少很多浏览器都支持就是这个

226
00:26:36,000 --> 00:26:40,000
Anti-Alias 的这个设置,我知道,我试过,那个效果比较糟糕

227
00:26:41,000 --> 00:26:47,000
这个还是跟底层操作有关,就是你在 Mac 和 Windows 上不能使用同样的 CSS 规则来达到同样的效果

228
00:26:47,000 --> 00:26:47,000
这是最大的问题

229
00:26:48,000 --> 00:26:53,000
可以把那个几个浏览器兼容的 CSS 全写上,它只要不冲突的话都可以都写上

230
00:26:53,000 --> 00:26:54,000
就啰嗦我一点,不是

231
00:26:55,000 --> 00:26:59,000
就是你用同样的规则在 Mac 和 Windows 上得到效果是不一样的

232
00:26:59,000 --> 00:27:06,000
这是最大的问题,就是关掉次像素平滑这个事情呢,各家的时效场都是问题比较多的

233
00:27:06,000 --> 00:27:13,000
对,所以因为这个事情也不是一个常见的,CSS 规则里面有一条就是好像叫 Tex Rendering 还是叫 Font Rendering

234
00:27:13,000 --> 00:27:20,000
然后它现在有两个,应该是莫哲达和 WebKit 各有一个视线,但这两个视线最后得到的效果都是

235
00:27:20,000 --> 00:27:25,000
在 Mac 上好很多,但是在 Windows 上还是死一坨

236
00:27:25,000 --> 00:27:27,000
对,反正这个问题是比较多的

237
00:27:28,000 --> 00:27:35,000
所以说刚才那个曾宇说这条,其实我在开发的时候我已经试过了,那个效果是比,反正一个是不一致,一个就是说其实挺糟糕的

238
00:27:36,000 --> 00:27:38,000
而且也不能解决刚才说的,比如说你的那个屏幕

239
00:27:39,000 --> 00:27:43,000
不是那个点对点导致的这个问题,这个是你不断软件怎么调都调不了的,因为那个是你在

240
00:27:44,000 --> 00:27:47,000
超市本身的设置的问题,这个你是改不了用户设置的嘛,对吧

241
00:27:47,000 --> 00:27:54,000
如果不能检测到说这个用户说是这个不是点对点,我谈个谈创说啊你这个不是点对点,你赶紧把那个点对点给弄回来

242
00:27:54,000 --> 00:27:56,000
对吧,这也不现实

243
00:27:58,000 --> 00:28:02,000
然后就是在做完这一套之后呢,我就在这应该是

244
00:28:02,000 --> 00:28:05,000
前两周吧,就在刷那个 Hacker News

245
00:28:05,000 --> 00:28:11,000
结果发现上面,竟然有人在搞这个 XP 点 CSS,什么意思

246
00:28:12,000 --> 00:28:15,000
他要用 CSS 来复原当初的这个

247
00:28:16,000 --> 00:28:20,000
Windows XP 时代,就是那个什么 640 x 480 像素的

248
00:28:20,000 --> 00:28:26,000
那个显示屏,那种压线,那种就是那种那种那种像素感,不是我们现在追求的那种

249
00:28:26,000 --> 00:28:29,000
其实也算是了,只是说可能不是特别,他是从英文

250
00:28:30,000 --> 00:28:33,000
那个事件来做的嘛,他也提到了说怎么用这个 Web Fund 来

251
00:28:34,000 --> 00:28:37,000
来实现这种像素的感,对吧,包括是就是

252
00:28:38,000 --> 00:28:40,000
你真还原当年的那个 Windows

253
00:28:40,000 --> 00:28:47,000
这个这个常用的那几个字体,比如说像 Verdana,Georgia,还像那个 Times New Roman 这些

254
00:28:47,000 --> 00:28:52,000
在关掉这个次像素平滑的那个

255
00:28:52,000 --> 00:28:58,000
情况下实现出点对点现象的感觉,对吧,但是他其实没有,他也是用这个,因为刚才讲的那个 Web Fund

256
00:28:58,000 --> 00:28:59,000
他其实不支持这个

257
00:29:00,000 --> 00:29:03,000
真像素字体嘛,都是也是微像素,也是用

258
00:29:03,000 --> 00:29:09,000
那个丁宝的类似的手法,就是把它做成十两字,但是是那 trace 出来的点,就是比较整数的

259
00:29:09,000 --> 00:29:15,000
那这样的他在 Rendering,在 Resterize 过后都得到的还是一个像素化的感觉的嘛

260
00:29:16,000 --> 00:29:21,000
对我看到有两个案例在做这件事情的,回头我们可以把这两个案例放到这个 Show Notes 里面

261
00:29:21,000 --> 00:29:24,000
大家有兴趣的话可以点来看一下,但是我就觉得

262
00:29:24,000 --> 00:29:30,000
因为他当然一个是因为拉丁字符的那个数量比较少,而且他那个点也比较好弄嘛

263
00:29:30,000 --> 00:29:31,000
就是他的滑项是效果还是比较高的

264
00:29:32,000 --> 00:29:38,000
后来我想了一下说,我能不能还原出这个,比如说我不还原 Windows XP 那种比较难的情况下

265
00:29:38,000 --> 00:29:46,000
我就还原一个这个以前那个叫什么 DOS 下面的那种什么 UC DOS 啊,那个中文 DOS 环境那种感觉行不行,对吧

266
00:29:46,000 --> 00:29:53,000
但是就是因为刚才那个不能严格点着点的那个问题可能还不太好实现,我们现在反正还在研究吧

267
00:29:53,000 --> 00:29:59,000
这个吴涛也在最近最近也在做类似风格的事情嘛,所以我们都搞错到一块了

268
00:30:00,000 --> 00:30:06,000
现在其实网上有好多那种在网页里面跑一个操作系统,就是跑一个古老的拟真操作系统的那个效果

269
00:30:06,000 --> 00:30:16,000
他们用的那个字体也差不多吧,就是虽然不是完全一致,但也是那种就是古早的 PC,IBM PC 机里面那个内嵌的那种 ROM 的字体

270
00:30:17,000 --> 00:30:18,000
那个还是比较好

271
00:30:19,000 --> 00:30:22,000
你干脆用 Canvas 直接把字体的渲染结果画出来

272
00:30:22,000 --> 00:30:30,000
你说这个思路倒是可以,就是用那个就是那个 HTML 5 那个 Canvas 那套 API 嘛,然后直接在里面画那个点

273
00:30:30,000 --> 00:30:37,000
直接往上画,但这样就有个问题啊,你那个文字就不可选了,至少我们现在做的这种伪像素感,它其实每个每个字都是可以

274
00:30:37,000 --> 00:30:44,000
都是非常 accessible 的,对,这他们做那个拟真操作系统的这也这帮人是无所谓这件事的嘛

275
00:30:44,000 --> 00:30:52,000
但是如果你想要说我要做一个伪操作系统的风格,同时又实际上是一个 accessible website,那的确是非常难

276
00:30:52,000 --> 00:30:53,000
至少你不能保证跨平台

277
00:30:55,000 --> 00:31:04,000
对对对,就这个就比较坑一点,我想一下就是如果我的那个要求不是那么高,我只是要求尽可能的像素的对齐,就包括解决这个

278
00:31:04,000 --> 00:31:11,000
比如说现在我们那个首页,它是一个用那个最新的那个 CS 3 的那个 grid,那个就是 grid 就是网格

279
00:31:11,000 --> 00:31:16,000
排布嘛,包括还不但是它比如说比如说我默认打开是一个三三列

280
00:31:16,000 --> 00:31:25,000
三蓝,对,三蓝对,三蓝就比较难除嘛,这就可能导致刚才我说的那个这个边缘有灰度,因为那个半个像素的问题,对不对

281
00:31:25,000 --> 00:31:32,000
他如果说有一个什么,我不用这个三蓝,我就用一蓝或者两,就双蓝或者是四蓝一定通过这个就是

282
00:31:33,000 --> 00:31:40,000
JavaScript 来实现的话,那也可能实现说我能够指定到像素级别的这个宽度,那至少你说在不同

283
00:31:40,000 --> 00:31:47,000
系统上它有一定的出,它至少它多一个像素,少一个像素,它至少还是个整数倍嘛,应该还是可以做的,我觉得有一些这个机会

284
00:31:49,000 --> 00:31:51,000
所以就这个是我们

285
00:31:52,000 --> 00:31:55,000
官网改头画面,其实就是都是在

286
00:31:55,000 --> 00:32:00,000
听了你们前一期节目的这个古造下面实现的,当然这里也非常感谢威力帮

287
00:32:01,000 --> 00:32:02,000
这个过程中非常

288
00:32:03,000 --> 00:32:06,000
尽心尽力啊,帮我们做了那么多的这个定制化

289
00:32:06,000 --> 00:32:12,000
然后我们也是第一个吃了这个螃蟹的人,现在好像把网站做成 Ritual 风格是一个

290
00:32:12,000 --> 00:32:14,000
三毛是个潮流,就是

291
00:32:14,000 --> 00:32:24,000
包括在在在维艺界也是有那个,怎么叫维艺界,我想说在设计界也是现在好像兴起了那个 Ritual Wave 这样一个风潮

292
00:32:24,000 --> 00:32:27,000
今年一直都流行 Ritual 啊,对啊

293
00:32:27,000 --> 00:32:30,000
复古风,但最近比如说那个争气波

294
00:32:30,000 --> 00:32:36,000
Viper Y 好像是这个名字,就是特别流行,90 年代的日本流行音乐

295
00:32:36,000 --> 00:32:38,000
配上那种什么

296
00:32:38,000 --> 00:32:41,000
美少女战士或者是超时空要塞的动画片

297
00:32:42,000 --> 00:32:46,000
然后现在各种各样的音乐全都被就是整成这个风格

298
00:32:46,000 --> 00:32:51,000
之前那个,哎,我这顺便提个打个岔的事,就是那个

299
00:32:52,000 --> 00:32:54,000
叫做班代,中文叫什么

300
00:32:54,000 --> 00:32:56,000
百代是吧

301
00:32:56,000 --> 00:33:00,000
百代在应该是去年年末的时候

302
00:33:00,000 --> 00:33:04,000
把他之前的一些老的那个,就小时候我们看了动画片

303
00:33:04,000 --> 00:33:05,000
全部给放 YouTube 上面去了

304
00:33:05,000 --> 00:33:09,000
然后我就去追了一遍那个那个叫什么来的啊

305
00:33:09,000 --> 00:33:13,000
魔神英雄传吧,应该是那个字年传吧

306
00:33:13,000 --> 00:33:16,000
是那个有个有个山,山有一圈彩虹

307
00:33:17,000 --> 00:33:19,000
什么什么创界山对吧

308
00:33:19,000 --> 00:33:21,000
然后有好多彩虹,我把那个又看了一遍

309
00:33:21,000 --> 00:33:23,000
应该是一个他驾驶一个

310
00:33:23,000 --> 00:33:26,000
类似像高达一样的机甲,对对对,类高达,龙嘛

311
00:33:26,000 --> 00:33:27,000
还有个龙嘛,骑着龙

312
00:33:27,000 --> 00:33:31,000
我觉得他好像有个有个女主的那个名字叫 Himiko

313
00:33:31,000 --> 00:33:34,000
对对对,是那个日本的女巫的一个名字

314
00:33:34,000 --> 00:33:36,000
对,那个时候这个动画片小时候好火了

315
00:33:36,000 --> 00:33:40,000
就我们班有个女生就叫 Himiko,我们也骑着

316
00:33:40,000 --> 00:33:43,000
我当时应该是上小学吧对吧

317
00:33:44,000 --> 00:33:45,000
小学几年节播啊

318
00:33:45,000 --> 00:33:47,000
反正就是那个时候特别火,一到那个

319
00:33:48,000 --> 00:33:50,000
播出的时候就手头电视机里面看,万人空巷对吧

320
00:33:50,000 --> 00:33:53,000
而且你放到现在看他是做了那个高新重制

321
00:33:53,000 --> 00:33:55,000
我还不知道怎么反正看起来那个 YouTube 上面的效果

322
00:33:55,000 --> 00:33:56,000
还挺清楚的

323
00:33:57,000 --> 00:33:59,000
那我就追了一遍,而且这个片特别坑

324
00:33:59,000 --> 00:34:02,000
他好像有有有三部,然后都烂尾了

325
00:34:02,000 --> 00:34:04,000
就没有播完,不知道为什么

326
00:34:04,000 --> 00:34:06,000
是在中国没有播完还是没有画完

327
00:34:06,000 --> 00:34:07,000
就 YouTube 上也没有

328
00:34:07,000 --> 00:34:10,000
就我不知道怎么一回事,有可能是没有没有画完

329
00:34:10,000 --> 00:34:11,000
有可能是没有画完,这就很坑

330
00:34:11,000 --> 00:34:14,000
然后这个故事到时候,就我那天是他是先放的第一部

331
00:34:14,000 --> 00:34:18,000
他是一周跟一集嘛,一集也就十拉二十分钟的样子

332
00:34:18,000 --> 00:34:23,000
然后我第一季还差两三集,可能就追完了

333
00:34:23,000 --> 00:34:27,000
他就放第二部了,然后我说然后呢然后呢

334
00:34:29,000 --> 00:34:30,000
需要付费解锁

335
00:34:31,000 --> 00:34:32,000
没有啊,他也没有这个选项啊

336
00:34:32,000 --> 00:34:34,000
他是为了卖那个卖手办

337
00:34:34,000 --> 00:34:38,000
他现在又在出那个那个那个机甲的那个手办嘛

338
00:34:38,000 --> 00:34:40,000
哦,OK,我想起来了

339
00:34:40,000 --> 00:34:42,000
他们的机甲非常 Q 版是吧

340
00:34:42,000 --> 00:34:45,000
对,他们的机甲,整个这个动画片都是那种萌系的

341
00:34:45,000 --> 00:34:48,000
就 Q 系就特别搞笑的那种啊

342
00:34:48,000 --> 00:34:50,000
对,二手式的那种,跟 Q 版高达一样

343
00:34:50,000 --> 00:34:54,000
对对对,我当时,但是我应该是小时候最喜欢的动画片

344
00:34:54,000 --> 00:34:55,000
那个应该能排到前三吧,这个

345
00:34:55,000 --> 00:34:59,000
天哪,所以就又在那里那个俯了谷一下

346
00:34:59,000 --> 00:35:01,000
而他的音乐我觉得他还挺好听的

347
00:35:01,000 --> 00:35:03,000
就是一直,现在都还记得那个

348
00:35:03,000 --> 00:35:07,000
感觉这一期节目播出之后,这个视频的点击量会大增

349
00:35:08,000 --> 00:35:10,000
就一看都是都是这个我们 IP 连过去

350
00:35:10,000 --> 00:35:12,000
我们那个 referral 过去了,对不对

351
00:35:12,000 --> 00:35:14,000
Machine AU 点 Wataru

352
00:35:14,000 --> 00:35:15,000
对吧,他们那个叫

353
00:35:15,000 --> 00:35:17,000
对对对,Wataru,Wataru 是什么意思

354
00:35:17,000 --> 00:35:19,000
男主的名字嘛,Wataru 是男主的名字

355
00:35:19,000 --> 00:35:21,000
就是一般写成汉字那个渡

356
00:35:21,000 --> 00:35:23,000
渡江的渡

357
00:35:23,000 --> 00:35:25,000
渡边渡的那个渡对吧

358
00:35:25,000 --> 00:35:27,000
对,就是他的名字

359
00:35:27,000 --> 00:35:31,000
反反这个就是最近不是在怀旧考古嘛

360
00:35:31,000 --> 00:35:33,000
特别多这种情况对不对

361
00:35:33,000 --> 00:35:35,000
然后那个最近也是在那个商场里面

362
00:35:35,000 --> 00:35:36,000
应该是疫情之前啊

363
00:35:36,000 --> 00:35:39,000
商场也看到很多那种国产复古的也有,你知道吧

364
00:35:39,000 --> 00:35:42,000
你们知不知道上海有那个大白兔奶汤

365
00:35:43,000 --> 00:35:45,000
嗯,这已经很久了吧

366
00:35:45,000 --> 00:35:47,000
这个 10 年前就出现了

367
00:35:47,000 --> 00:35:49,000
没有没有,他最近我一次

368
00:35:49,000 --> 00:35:50,000
我可能在其他地方有

369
00:35:50,000 --> 00:35:53,000
但是我是应该是去年就是 19 年

370
00:35:53,000 --> 00:35:55,000
下半年在深圳才看到

371
00:35:55,000 --> 00:35:57,000
他搞了一整个展厅的那种复古的

372
00:35:57,000 --> 00:36:00,000
而且其实你仔细翻那个时候的排版和设计

373
00:36:00,000 --> 00:36:02,000
我觉得他做的还蛮好的

374
00:36:02,000 --> 00:36:04,000
大白兔奶汤那套的设计

375
00:36:04,000 --> 00:36:05,000
但不知道是谁做的

376
00:36:05,000 --> 00:36:07,000
可以去找一期节目

377
00:36:07,000 --> 00:36:09,000
你们可以去考一下古

378
00:36:09,000 --> 00:36:11,000
当时是谁做的那个自体的设计

379
00:36:11,000 --> 00:36:12,000
他那个全部都定制的

380
00:36:12,000 --> 00:36:15,000
因为那个时候还没有什么数字化设计的

381
00:36:15,000 --> 00:36:16,000
手工化的呀

382
00:36:16,000 --> 00:36:20,000
那个时候美术字和平面设计的功底

383
00:36:20,000 --> 00:36:22,000
虽然条件非常简陋

384
00:36:22,000 --> 00:36:24,000
但是最终水准是非常高的

385
00:36:24,000 --> 00:36:26,000
在九十年代电脑普及之后

386
00:36:26,000 --> 00:36:28,000
就是这个个人桌面出版

387
00:36:28,000 --> 00:36:30,000
毁了平面设计可以说

388
00:36:30,000 --> 00:36:32,000
出自滥造对吧

389
00:36:32,000 --> 00:36:34,000
Low-end

390
00:36:34,000 --> 00:36:35,000
低端的这种

391
00:36:35,000 --> 00:36:39,000
哎呀,当年就是所有的师傅都有手上功夫的呀

392
00:36:40,000 --> 00:36:42,000
后来就都用定了

393
00:36:42,000 --> 00:36:44,000
大家就没有手上功夫了

394
00:36:44,000 --> 00:36:45,000
对,那时候我去

395
00:36:45,000 --> 00:36:47,000
我跟老师去做校刊吧

396
00:36:47,000 --> 00:36:49,000
做初中还是高中校刊

397
00:36:49,000 --> 00:36:51,000
去一个印刷厂

398
00:36:51,000 --> 00:36:53,000
我那个是师傅的手艺真的令人叹唯观止

399
00:36:53,000 --> 00:36:55,000
就是从一个剪贴画那种

400
00:36:55,000 --> 00:36:57,000
就是它实际上是一张

401
00:36:57,000 --> 00:36:59,000
一本很厚的书

402
00:36:59,000 --> 00:37:01,000
然后里面每一页都是那种半透明的剪贴画

403
00:37:01,000 --> 00:37:03,000
然后他从上面踩一下

404
00:37:03,000 --> 00:37:05,000
然后贴在一个板上

405
00:37:05,000 --> 00:37:06,000
然后问你这样行不行

406
00:37:06,000 --> 00:37:07,000
然后再去排一排

407
00:37:07,000 --> 00:37:08,000
然后最后印出来

408
00:37:08,000 --> 00:37:10,000
那个手艺真的让人非常贪腐了

409
00:37:10,000 --> 00:37:12,000
那绝对是

410
00:37:12,000 --> 00:37:14,000
你看现在一个人敲键盘,晃鼠标

411
00:37:14,000 --> 00:37:16,000
做出来排版

412
00:37:16,000 --> 00:37:18,000
感受是完全不一样的

413
00:37:18,000 --> 00:37:20,000
是一种有那种降翼的冲击在里面

414
00:37:20,000 --> 00:37:22,000
就好像你看一个什么

415
00:37:22,000 --> 00:37:24,000
看一个什么 Letterpress 的

416
00:37:24,000 --> 00:37:26,000
那种印刷机一样

417
00:37:26,000 --> 00:37:28,000
就是赏心悦目啊

418
00:37:28,000 --> 00:37:30,000
不像现在

419
00:37:30,000 --> 00:37:32,000
那时候都是剪刀工夫啊

420
00:37:32,000 --> 00:37:34,000
剪剪贴贴啊都是

421
00:37:34,000 --> 00:37:36,000
对,那天我就是

422
00:37:36,000 --> 00:37:38,000
在官商场看到大白兔

423
00:37:38,000 --> 00:37:40,000
他搞的那套东西嘛

424
00:37:40,000 --> 00:37:42,000
其实小时候就是光吃糖

425
00:37:42,000 --> 00:37:44,000
也没在意包装纸嘛

426
00:37:44,000 --> 00:37:46,000
他那个时候

427
00:37:46,000 --> 00:37:48,000
他卖到糖里面的包装纸

428
00:37:48,000 --> 00:37:50,000
因为我估计应该是成本和工艺的考虑

429
00:37:50,000 --> 00:37:52,000
他那个其实不是特别的清晰

430
00:37:52,000 --> 00:37:54,000
现在他就是全部用

431
00:37:54,000 --> 00:37:56,000
最新的工艺做出

432
00:37:56,000 --> 00:37:58,000
我原来的那个图样嘛

433
00:37:58,000 --> 00:38:00,000
所以你仔细看

434
00:38:00,000 --> 00:38:02,000
在现在工艺下面他非常清楚

435
00:38:02,000 --> 00:38:04,000
然后边缘啊那些都做得非常好

436
00:38:04,000 --> 00:38:06,000
我觉得这个仔细看那个配色

437
00:38:06,000 --> 00:38:08,000
都搭得挺棒的

438
00:38:08,000 --> 00:38:10,000
大白兔的兔毛看得很清楚

439
00:38:10,000 --> 00:38:12,000
有毛吗?没有毛吗?

440
00:38:12,000 --> 00:38:14,000
高精版大白兔

441
00:38:14,000 --> 00:38:16,000
有一个版本是有毛的

442
00:38:16,000 --> 00:38:18,000
特别搞笑

443
00:38:20,000 --> 00:38:22,000
等等等等

444
00:38:22,000 --> 00:38:24,000
我们这期节目聊啥住

445
00:38:24,000 --> 00:38:26,000
都被你扯到哪去了

446
00:38:26,000 --> 00:38:28,000
不过我们内核拱晃

447
00:38:28,000 --> 00:38:30,000
这次作为丁毛点阵体的案例

448
00:38:30,000 --> 00:38:32,000
我其实

449
00:38:32,000 --> 00:38:34,000
已经在我们的

450
00:38:34,000 --> 00:38:36,000
Type 会员的 5 月份

451
00:38:36,000 --> 00:38:38,000
这一期里面介绍了

452
00:38:38,000 --> 00:38:40,000
大家如果在会刊里面

453
00:38:40,000 --> 00:38:42,000
也可以看到我们这次

454
00:38:42,000 --> 00:38:44,000
改版后的内核拱晃的

455
00:38:44,000 --> 00:38:46,000
晚夜的效果

456
00:38:46,000 --> 00:38:48,000
感谢感谢推荐

457
00:38:48,000 --> 00:38:50,000
我们回去看一下能有多少个点击过来

458
00:38:56,000 --> 00:38:58,000
所以刚才讲了那么多这个

459
00:38:58,000 --> 00:39:00,000
与主题无关的事情

460
00:39:00,000 --> 00:39:02,000
还算是有关吗?勉强跟牵扯上

461
00:39:02,000 --> 00:39:04,000
OK 好的

462
00:39:04,000 --> 00:39:06,000
但是不是今天的主题

463
00:39:06,000 --> 00:39:08,000
我们今天主题讲什么

464
00:39:08,000 --> 00:39:10,000
我想想这个怎么描述

465
00:39:10,000 --> 00:39:12,000
其实今天这个主题跟我们之前串谈的好几期节目

466
00:39:12,000 --> 00:39:14,000
都是有

467
00:39:14,000 --> 00:39:16,000
或多或少的关联的对吧

468
00:39:16,000 --> 00:39:18,000
那当然了我这个都是

469
00:39:18,000 --> 00:39:20,000
想好的想很长时间

470
00:39:20,000 --> 00:39:22,000
晕了的

471
00:39:22,000 --> 00:39:24,000
都是有计划的对不对

472
00:39:24,000 --> 00:39:26,000
明明之中早已就计

473
00:39:26,000 --> 00:39:28,000
Eric 军是非常用心的

474
00:39:28,000 --> 00:39:30,000
像我们两个每次来都是像打酱油一样

475
00:39:30,000 --> 00:39:32,000
我们都是很欢乐的

476
00:39:32,000 --> 00:39:34,000
在这打酱油呀

477
00:39:34,000 --> 00:39:36,000
我们是双重捧人

478
00:39:36,000 --> 00:39:38,000
但是你们很能说呀

479
00:39:38,000 --> 00:39:40,000
对我们是之前串谈

480
00:39:40,000 --> 00:39:42,000
讲过 unicode 的各种问题

481
00:39:42,000 --> 00:39:44,000
然后包括应该有一

482
00:39:44,000 --> 00:39:46,000
最开始的一期也讲过什么

483
00:39:46,000 --> 00:39:48,000
你在键盘上按下一个

484
00:39:48,000 --> 00:39:50,000
按键那个字怎么出现在

485
00:39:50,000 --> 00:39:52,000
屏幕上的整个过程的对吧

486
00:39:52,000 --> 00:39:54,000
但其实今天讲的这个话题

487
00:39:54,000 --> 00:39:56,000
跟这两件事情或多或少是有一定关系的

488
00:39:56,000 --> 00:39:58,000
对吧就是说文件系统

489
00:39:58,000 --> 00:40:00,000
大家如果还知道这个什么叫文件系统的话

490
00:40:00,000 --> 00:40:02,000
现在应该很多这个 00 后没有用

491
00:40:02,000 --> 00:40:04,000
BC 或者 Buck 的话

492
00:40:04,000 --> 00:40:06,000
它可能不

493
00:40:06,000 --> 00:40:08,000
Mobile First Generation

494
00:40:08,000 --> 00:40:10,000
对就是 Mobile First Generation

495
00:40:10,000 --> 00:40:12,000
这一代应该已经不知道什么是文件系统了

496
00:40:12,000 --> 00:40:14,000
文件系统呢就是你打开这个所谓的

497
00:40:14,000 --> 00:40:16,000
资源管理器对吧

498
00:40:16,000 --> 00:40:18,000
能看到那个东西

499
00:40:18,000 --> 00:40:20,000
反正你再像我跟吴涛这个

500
00:40:20,000 --> 00:40:22,000
这个装团的人呢

501
00:40:22,000 --> 00:40:24,000
就还知道哦还可以有一个命令行

502
00:40:24,000 --> 00:40:26,000
对吧能看到这个路径什么什么的

503
00:40:26,000 --> 00:40:28,000
对但文件系统

504
00:40:28,000 --> 00:40:30,000
我们不是聊它本来那些其他各种各样的

505
00:40:30,000 --> 00:40:32,000
怎么用啊

506
00:40:32,000 --> 00:40:34,000
我们只聊一个事情就是文件系统

507
00:40:34,000 --> 00:40:36,000
怎么命名的问题啊就是一个文件

508
00:40:36,000 --> 00:40:38,000
到底它可以叫什么

509
00:40:38,000 --> 00:40:40,000
然后其实

510
00:40:40,000 --> 00:40:42,000
我们也可以扩展到

511
00:40:42,000 --> 00:40:44,000
这其他的嘛就是关于各种

512
00:40:44,000 --> 00:40:46,000
原代码还有语言

513
00:40:46,000 --> 00:40:48,000
就是我们会涉及到

514
00:40:48,000 --> 00:40:50,000
这个命名的事情

515
00:40:50,000 --> 00:40:52,000
英文它叫做什么 Naming Convention

516
00:40:52,000 --> 00:40:54,000
是吧这个叫命名规则

517
00:40:54,000 --> 00:40:56,000
其实会有各种各样的命名规则

518
00:40:56,000 --> 00:40:58,000
对

519
00:40:58,000 --> 00:41:00,000
但是像

520
00:41:00,000 --> 00:41:02,000
因为我们大家都是 Mac 用户吧

521
00:41:02,000 --> 00:41:04,000
Mac 几乎都没有规定

522
00:41:04,000 --> 00:41:06,000
就不会存在这个事情

523
00:41:06,000 --> 00:41:08,000
但是以前在很早很早以前

524
00:41:08,000 --> 00:41:10,000
我们在学命令行还在学 DOS 的时候

525
00:41:10,000 --> 00:41:12,000
各种各样的那个制度

526
00:41:12,000 --> 00:41:14,000
要遵守对吧对啊

527
00:41:14,000 --> 00:41:16,000
那时候你们还记得有说

528
00:41:16,000 --> 00:41:18,000
8.3 规则吗

529
00:41:18,000 --> 00:41:20,000
对对对这个是

530
00:41:20,000 --> 00:41:22,000
我想想一下这个得要在

531
00:41:22,000 --> 00:41:24,000
Windows 95

532
00:41:24,000 --> 00:41:26,000
之前时代的哦应该是 Windows

533
00:41:26,000 --> 00:41:28,000
32 时代的时候大家得要遵守

534
00:41:28,000 --> 00:41:30,000
的一个事情对不对从 Windows 3.1

535
00:41:30,000 --> 00:41:32,000
开始支持的长文件名应该是

536
00:41:32,000 --> 00:41:34,000
但是为了向下兼容或者说

537
00:41:34,000 --> 00:41:36,000
对

538
00:41:36,000 --> 00:41:38,000
他做了一套向下兼容的方案就是

539
00:41:38,000 --> 00:41:40,000
他这个文件名在 DOS 下面显示的时候

540
00:41:40,000 --> 00:41:42,000
还是会显示成 8.3

541
00:41:42,000 --> 00:41:44,000
还是用一个波浪号来展来

542
00:41:44,000 --> 00:41:46,000
显示一个波浪号加一个数字

543
00:41:46,000 --> 00:41:48,000
你们要跟大家解释什么叫 8.3 好吧

544
00:41:48,000 --> 00:41:50,000
Anyone

545
00:41:50,000 --> 00:41:52,000
其实我觉得要解释 8.3 先要解释什么是扩展名

546
00:41:52,000 --> 00:41:54,000
因为其实 Mac 上比如说怎么现在 Mac

547
00:41:54,000 --> 00:41:56,000
上默认的情况下还是不显示这个

548
00:41:56,000 --> 00:41:58,000
扩展名的对不对

549
00:41:58,000 --> 00:42:00,000
因为 Mac 其实即使没有扩展名

550
00:42:00,000 --> 00:42:02,000
也可以也成立就是在 Mac

551
00:42:02,000 --> 00:42:04,000
上面但是 Windows 不行啊

552
00:42:04,000 --> 00:42:06,000
是这样的是这么来的

553
00:42:06,000 --> 00:42:08,000
扩展名这个东西最早实际上是

554
00:42:08,000 --> 00:42:10,000
70 年代的一个发明吧当时

555
00:42:10,000 --> 00:42:12,000
那个操作成了 CPM 应该叫

556
00:42:12,000 --> 00:42:14,000
Ctrl

557
00:42:14,000 --> 00:42:16,000
什么 DC 是 Ctrl 我只记得

558
00:42:16,000 --> 00:42:18,000
CtrlCPM 就是 DOS

559
00:42:18,000 --> 00:42:20,000
DOS 是从 CPM 超过来的相当于

560
00:42:20,000 --> 00:42:22,000
然后 CPM 有扩展名这一项

561
00:42:22,000 --> 00:42:24,000
因为 CPM 创

562
00:42:24,000 --> 00:42:26,000
创始人认为

563
00:42:26,000 --> 00:42:28,000
在和文件相关的所有的

564
00:42:28,000 --> 00:42:30,000
原数据里面类型数据是

565
00:42:30,000 --> 00:42:32,000
最重要的所以类型数据

566
00:42:32,000 --> 00:42:34,000
应该是文件名的一部分

567
00:42:34,000 --> 00:42:36,000
其实这里是一个哲学问题就是说一个文件的扩展名

568
00:42:36,000 --> 00:42:38,000
他其实是定义这个文件是一个什么样的

569
00:42:38,000 --> 00:42:40,000
种类对不对

570
00:42:40,000 --> 00:42:42,000
然后这个种类这个信息是否是

571
00:42:42,000 --> 00:42:44,000
应该体现在这个名字里面还是说

572
00:42:44,000 --> 00:42:46,000
体现在一个什么别的地方比如说

573
00:42:46,000 --> 00:42:48,000
刚才 Eric 也提到

574
00:42:48,000 --> 00:42:50,000
其实 Mac 那边你不用扩展名也还可以

575
00:42:50,000 --> 00:42:52,000
对吧他因为他有一些别的方法

576
00:42:52,000 --> 00:42:54,000
可以判断这个文件是一个什么样

577
00:42:54,000 --> 00:42:56,000
类型的文件比如说我们

578
00:42:56,000 --> 00:42:58,000
常见那个方式有一个什么

579
00:42:58,000 --> 00:43:00,000
Magic Number 对吧就是在文件开头

580
00:43:00,000 --> 00:43:02,000
可能有几个字

581
00:43:02,000 --> 00:43:04,000
Mac 我想 Mac 是怎么实现的

582
00:43:04,000 --> 00:43:06,000
Mac 在资源

583
00:43:06,000 --> 00:43:08,000
它一个叫中文叫什么

584
00:43:08,000 --> 00:43:10,000
资源差 Fork

585
00:43:10,000 --> 00:43:12,000
在很早以前就是

586
00:43:12,000 --> 00:43:14,000
这个就更复杂了

587
00:43:14,000 --> 00:43:16,000
Fork 好像是经典就是

588
00:43:16,000 --> 00:43:18,000
Mac Classic 里面那个概念

589
00:43:18,000 --> 00:43:20,000
对就 classical 嘛对啊

590
00:43:20,000 --> 00:43:22,000
因为你 OS 10 后面又不一样了

591
00:43:22,000 --> 00:43:24,000
因为 OS 10 本质上是个 UNIX

592
00:43:24,000 --> 00:43:26,000
UNIX 的哲学就是这个文件是不是

593
00:43:26,000 --> 00:43:28,000
可执行文件我让他可执行

594
00:43:28,000 --> 00:43:30,000
给他可执行的权限他就是可执行文件了

595
00:43:30,000 --> 00:43:32,000
That's it

596
00:43:32,000 --> 00:43:34,000
然后因为实际上是不把原数据

597
00:43:34,000 --> 00:43:36,000
不把文件类型是什么

598
00:43:36,000 --> 00:43:38,000
这个原数据存在任何地方

599
00:43:38,000 --> 00:43:40,000
UNIX 里面上面有一个命令叫

600
00:43:40,000 --> 00:43:42,000
你用 file 嘛你用 file 它是一个

601
00:43:42,000 --> 00:43:44,000
启发式的探针它会去看这个文件

602
00:43:44,000 --> 00:43:46,000
看起来像什么

603
00:43:46,000 --> 00:43:48,000
怎么判断一个文件像什么

604
00:43:48,000 --> 00:43:50,000
就是它有很多方法嘛就是如果不

605
00:43:50,000 --> 00:43:52,000
看文件名的情况下啊就是说

606
00:43:52,000 --> 00:43:54,000
你看可以看文件头部它通常一些

607
00:43:54,000 --> 00:43:56,000
这种文件格式它在头部

608
00:43:56,000 --> 00:43:58,000
都会有些特殊的一个标记或者一个什么

609
00:43:58,000 --> 00:44:00,000
结构对吧它会说这是一个图片

610
00:44:00,000 --> 00:44:02,000
这是一个什么 word 文档

611
00:44:02,000 --> 00:44:04,000
这是一个什么 NP 3 的

612
00:44:04,000 --> 00:44:06,000
一个音频举个例子啊

613
00:44:06,000 --> 00:44:08,000
后来还衍生

614
00:44:08,000 --> 00:44:10,000
因此而衍生出了一些所谓

615
00:44:10,000 --> 00:44:12,000
polyglot 文件

616
00:44:12,000 --> 00:44:14,000
这个文件同时是很多种东西

617
00:44:14,000 --> 00:44:16,000
比如说它同时一张照片然后同时

618
00:44:16,000 --> 00:44:18,000
然后又是一个 RRR 压缩文档

619
00:44:20,000 --> 00:44:22,000
对对这种就是属于那个专门

620
00:44:22,000 --> 00:44:24,000
制作出来的这种

621
00:44:24,000 --> 00:44:26,000
hack 嘛

622
00:44:26,000 --> 00:44:28,000
但其实说回来就是说

623
00:44:28,000 --> 00:44:30,000
Windows 里面采取的一个方案

624
00:44:30,000 --> 00:44:32,000
就是说我 Windows 上面没有

625
00:44:32,000 --> 00:44:34,000
没有像你刚才说 file 这个命令它其实

626
00:44:34,000 --> 00:44:36,000
没有对应的东西对吧它就说我怎么知道这个

627
00:44:36,000 --> 00:44:38,000
文件是个什么类是个什么

628
00:44:38,000 --> 00:44:40,000
东西呢是个什么种类呢你告诉我

629
00:44:40,000 --> 00:44:42,000
有用户告诉他

630
00:44:42,000 --> 00:44:44,000
对啊你告诉我咯你在这个

631
00:44:44,000 --> 00:44:46,000
名字最后加个你说点 JPG

632
00:44:46,000 --> 00:44:48,000
那可能就是一个压缩的图片对吧

633
00:44:48,000 --> 00:44:50,000
要是个 NP 3 那可能就是一个

634
00:44:50,000 --> 00:44:52,000
音频文件对吧你还是点个

635
00:44:52,000 --> 00:44:54,000
NP 4 那就是个视频对不对

636
00:44:54,000 --> 00:44:56,000
然后就诸如此类啊就是搞了

637
00:44:56,000 --> 00:44:58,000
这么一套这个扩展名这么一个

638
00:44:58,000 --> 00:45:00,000
概念来描述这件事情然后

639
00:45:00,000 --> 00:45:02,000
嗯 DOS 我记得当时

640
00:45:02,000 --> 00:45:04,000
8.3 是因为它只能存 11 个

641
00:45:04,000 --> 00:45:06,000
字符宽对吧 8 个名字

642
00:45:06,000 --> 00:45:08,000
加一个点

643
00:45:08,000 --> 00:45:10,000
再加三个字母的这个

644
00:45:10,000 --> 00:45:12,000
扩展名就齐活了最多

645
00:45:12,000 --> 00:45:14,000
就这样

646
00:45:14,000 --> 00:45:16,000
所以当时的文件名最多

647
00:45:16,000 --> 00:45:18,000
只能是 8 个字符然后

648
00:45:18,000 --> 00:45:20,000
扩展名呢最多呢也就只有 3 个

649
00:45:20,000 --> 00:45:22,000
字符就就 DOS 里面它的这个

650
00:45:22,000 --> 00:45:24,000
这个限制非常严格所以

651
00:45:24,000 --> 00:45:26,000
就简称 8.3

652
00:45:26,000 --> 00:45:28,000
其实我当时一直我一再想

653
00:45:28,000 --> 00:45:30,000
不起来了就是说最多 3 个

654
00:45:30,000 --> 00:45:32,000
那其实当时一个或者两个用的

655
00:45:32,000 --> 00:45:34,000
点 C 啊

656
00:45:34,000 --> 00:45:36,000
啊对啊

657
00:45:36,000 --> 00:45:38,000
点 H 啊

658
00:45:38,000 --> 00:45:40,000
你都不用投啊

659
00:45:40,000 --> 00:45:42,000
明白明白明白

660
00:45:42,000 --> 00:45:44,000
所以现在就是讲

661
00:45:44,000 --> 00:45:46,000
我们今天讲这个命名嘛

662
00:45:46,000 --> 00:45:48,000
那命名的话首先是一个文件名的

663
00:45:48,000 --> 00:45:50,000
长度问题对吧

664
00:45:50,000 --> 00:45:52,000
所以现在刚才说的像

665
00:45:52,000 --> 00:45:54,000
DOS 它的

666
00:45:54,000 --> 00:45:56,000
限制的是只能

667
00:45:56,000 --> 00:45:58,000
有 8 个字符然后后面呢

668
00:45:58,000 --> 00:46:00,000
到 Windows 后面就最多

669
00:46:00,000 --> 00:46:02,000
是就可以有 255 个字符了

670
00:46:02,000 --> 00:46:04,000
那个的多少长也可以啊

671
00:46:04,000 --> 00:46:06,000
然后扩展名的话

672
00:46:06,000 --> 00:46:08,000
嗯好像像后面

673
00:46:08,000 --> 00:46:10,000
4 个字母也可以了对吧

674
00:46:10,000 --> 00:46:12,000
反正 Unix 的话是随便的都无所谓的

675
00:46:12,000 --> 00:46:14,000
那个有几个字母都无所谓

676
00:46:14,000 --> 00:46:16,000
对吧

677
00:46:16,000 --> 00:46:18,000
Unix 实际上也没有扩展

678
00:46:18,000 --> 00:46:20,000
名这个概念只不过后来

679
00:46:20,000 --> 00:46:22,000
扩展名这个

680
00:46:22,000 --> 00:46:24,000
扩展名这一套东西

681
00:46:24,000 --> 00:46:26,000
归根结底还是有

682
00:46:26,000 --> 00:46:28,000
意义的因为你人

683
00:46:28,000 --> 00:46:30,000
人不可能去查看文件的

684
00:46:30,000 --> 00:46:32,000
额外的 Meta data

685
00:46:32,000 --> 00:46:34,000
人只能人能看到的基本上就是

686
00:46:34,000 --> 00:46:36,000
一个文件名所以文件名

687
00:46:36,000 --> 00:46:38,000
作为扩展名作为它一套

688
00:46:38,000 --> 00:46:40,000
还是有还是有意义的所以在后面

689
00:46:40,000 --> 00:46:42,000
Unix 和

690
00:46:42,000 --> 00:46:44,000
Mac 之类也其实也都

691
00:46:44,000 --> 00:46:46,000
从善如流

692
00:46:46,000 --> 00:46:48,000
随大流把扩展名

693
00:46:48,000 --> 00:46:50,000
当成了文件的

694
00:46:50,000 --> 00:46:52,000
类型判断机制的一部分

695
00:46:52,000 --> 00:46:54,000
但是归根结底

696
00:46:54,000 --> 00:46:56,000
Linux 上面实际上是没有扩展名

697
00:46:56,000 --> 00:46:58,000
这个概念就跟 Mac 一样

698
00:46:58,000 --> 00:47:00,000
其实你们想没想这可能是

699
00:47:00,000 --> 00:47:02,000
这个叫什么来的就是

700
00:47:02,000 --> 00:47:04,000
图形界面的

701
00:47:04,000 --> 00:47:06,000
一个问题还是怎么着就是

702
00:47:06,000 --> 00:47:08,000
你在一个纯命令行的界面下面

703
00:47:08,000 --> 00:47:10,000
Cli 我们叫 Command Line Interface

704
00:47:10,000 --> 00:47:12,000
交互的方式是一定是

705
00:47:12,000 --> 00:47:14,000
一个叫什么

706
00:47:14,000 --> 00:47:16,000
动冰结构对吧我就说签下一个命令

707
00:47:16,000 --> 00:47:18,000
然后扩展什么样的一个参数就是那个参数

708
00:47:18,000 --> 00:47:20,000
就是那个文件名嘛这个时候

709
00:47:20,000 --> 00:47:22,000
这个时候你已经知道了你要用

710
00:47:22,000 --> 00:47:24,000
什么东西去处理这个后面那个

711
00:47:24,000 --> 00:47:26,000
那个冰雨对吧那个那个文件

712
00:47:26,000 --> 00:47:28,000
但其实你在这个

713
00:47:28,000 --> 00:47:30,000
比如说 Windows 里面你是要有一个这么一个

714
00:47:30,000 --> 00:47:32,000
概念就是比如你在那个

715
00:47:32,000 --> 00:47:34,000
资源管理器里面你双击一个

716
00:47:34,000 --> 00:47:36,000
图片你的想法是把它打开对吧

717
00:47:36,000 --> 00:47:38,000
这个时候你已经有个暗含了假设是说

718
00:47:38,000 --> 00:47:40,000
你用什么把它打开这里存在一个

719
00:47:40,000 --> 00:47:42,000
就是绑定的一个关系

720
00:47:42,000 --> 00:47:44,000
对不对他不是一个动冰对

721
00:47:44,000 --> 00:47:46,000
Windows 打开文件的机制也是

722
00:47:46,000 --> 00:47:48,000
跟那个扩展名相关了嘛

723
00:47:48,000 --> 00:47:50,000
他在注册表里面

724
00:47:50,000 --> 00:47:52,000
把所有扩展名对应了一个

725
00:47:52,000 --> 00:47:54,000
打开工具所以就很蠢啊

726
00:47:54,000 --> 00:47:56,000
很死板的

727
00:47:56,000 --> 00:47:58,000
这里面就是一个哲学问题嘛是你先想到了

728
00:47:58,000 --> 00:48:00,000
用什么工具你先想到

729
00:48:00,000 --> 00:48:02,000
用什么东西打开然后你再去找

730
00:48:02,000 --> 00:48:04,000
那个文件还是说你先找到那个文件

731
00:48:04,000 --> 00:48:06,000
然后你要你要用这个

732
00:48:06,000 --> 00:48:08,000
你要用你要打开这个文件

733
00:48:08,000 --> 00:48:10,000
然后再想这个这个文件是

734
00:48:10,000 --> 00:48:12,000
对应的是一个什么工具来打开就这里面我觉得

735
00:48:12,000 --> 00:48:14,000
有一个这个逻辑的前后

736
00:48:14,000 --> 00:48:16,000
的一个关系对吧

737
00:48:16,000 --> 00:48:18,000
而且像 Mac 的话

738
00:48:18,000 --> 00:48:20,000
他没有这个扩展名是因为他其实

739
00:48:20,000 --> 00:48:22,000
他是那个 GUI 图形设

740
00:48:22,000 --> 00:48:24,000
然后呢他把这些东西

741
00:48:24,000 --> 00:48:26,000
都不用写在

742
00:48:26,000 --> 00:48:28,000
就是不用当成扩展名

743
00:48:28,000 --> 00:48:30,000
写在文件名里面

744
00:48:30,000 --> 00:48:32,000
老的那个 Mac 他们是

745
00:48:32,000 --> 00:48:34,000
他用那个 Fork 嘛就是那个

746
00:48:34,000 --> 00:48:36,000
ResourceFork 资源差嘛

747
00:48:36,000 --> 00:48:38,000
其实是写在文件里头的

748
00:48:38,000 --> 00:48:40,000
这个概念可能要

749
00:48:40,000 --> 00:48:42,000
给大家解释一下这个东西其实很

750
00:48:42,000 --> 00:48:44,000
除非你对这个底层非常了解

751
00:48:44,000 --> 00:48:46,000
不然其实你根本不会想到

752
00:48:46,000 --> 00:48:48,000
这么一个结构就是这个 ResourceFork

753
00:48:48,000 --> 00:48:50,000
到底是个啥

754
00:48:50,000 --> 00:48:52,000
其实你这么想你创建了一个

755
00:48:52,000 --> 00:48:54,000
空白的一个文本文件

756
00:48:54,000 --> 00:48:56,000
对吧然后这个文件

757
00:48:56,000 --> 00:48:58,000
在一个最普通的文件系统里面

758
00:48:58,000 --> 00:49:00,000
他能记录啥这个文件叫什么名字对吧

759
00:49:00,000 --> 00:49:02,000
有些原数据什么是什么时候创建的

760
00:49:02,000 --> 00:49:04,000
有多大尺寸然后就是文件的

761
00:49:04,000 --> 00:49:06,000
这个所谓的内容了嘛就是

762
00:49:06,000 --> 00:49:08,000
就是一个零字节的就是零长的

763
00:49:08,000 --> 00:49:10,000
一个内容了那这个时候你会

764
00:49:10,000 --> 00:49:12,000
会想说那这个文件是什么

765
00:49:12,000 --> 00:49:14,000
类型这个信息到底存在哪里的问题

766
00:49:14,000 --> 00:49:16,000
刚才我们开始讲了

767
00:49:16,000 --> 00:49:18,000
DOS 和 Windows 的方案是说

768
00:49:18,000 --> 00:49:20,000
存在这个文件的扩展名里面

769
00:49:20,000 --> 00:49:22,000
对吧就最后那个点的后面那个就是

770
00:49:22,000 --> 00:49:24,000
文件的扩展名那这个信息就已经包含了

771
00:49:24,000 --> 00:49:26,000
然后这个 MacOS 就是

772
00:49:26,000 --> 00:49:28,000
不是我们现在就叫做 MacOS

773
00:49:28,000 --> 00:49:30,000
Ten 的这么一个版本而是说比如说

774
00:49:30,000 --> 00:49:32,000
MacOS 789

775
00:49:32,000 --> 00:49:34,000
这个时候他其实在文件

776
00:49:34,000 --> 00:49:36,000
系统里面有一个

777
00:49:36,000 --> 00:49:38,000
专门存储这种原信息

778
00:49:38,000 --> 00:49:40,000
的原数据的地方这个地方

779
00:49:40,000 --> 00:49:42,000
叫做这个资源差 ResourceFork

780
00:49:42,000 --> 00:49:44,000
这个实现细节比较比较莫及

781
00:49:44,000 --> 00:49:46,000
就是他是在独立于这个文件本身

782
00:49:46,000 --> 00:49:48,000
之外的一个地方去存储这个信息的

783
00:49:48,000 --> 00:49:50,000
有了这个东西之后那你能扩展

784
00:49:50,000 --> 00:49:52,000
有没有这个扩展名其实已经不重要了对不对

785
00:49:52,000 --> 00:49:54,000
因为这个文件类型是存在那个

786
00:49:54,000 --> 00:49:56,000
原数据那个资源差里面的

787
00:49:56,000 --> 00:49:58,000
他这样的对应就比较灵活嘛

788
00:49:58,000 --> 00:50:00,000
对但这样有一个代价就是他其实

789
00:50:00,000 --> 00:50:02,000
首先他跟别的系统的兼容性就比较差

790
00:50:02,000 --> 00:50:04,000
你把一个文件从

791
00:50:04,000 --> 00:50:06,000
但那个时候没有什么网络可能这种情况

792
00:50:06,000 --> 00:50:08,000
倒不是特别常出现但你到

793
00:50:08,000 --> 00:50:10,000
现在就说你要把这个文件

794
00:50:10,000 --> 00:50:12,000
比如说从经典版的 MacOS

795
00:50:12,000 --> 00:50:14,000
放到一个 Windows XB 上面

796
00:50:14,000 --> 00:50:16,000
或者 Windows 9 上面去这个时候那个资源差

797
00:50:16,000 --> 00:50:18,000
是一个 MacOS 的实现细节

798
00:50:18,000 --> 00:50:20,000
他在 Windows 上面是没有的

799
00:50:20,000 --> 00:50:22,000
这个时候你怎么办

800
00:50:22,000 --> 00:50:24,000
经常会把这个 Mac 的文件

801
00:50:24,000 --> 00:50:26,000
拷到 Windows 上会多出来一套的

802
00:50:26,000 --> 00:50:28,000
对嘛对嘛

803
00:50:28,000 --> 00:50:30,000
包括你现在用那个我们可能

804
00:50:30,000 --> 00:50:32,000
下期节目讲 NAS 的时候啊

805
00:50:32,000 --> 00:50:34,000
就是我们之前不是有去讲过 NAS

806
00:50:34,000 --> 00:50:36,000
但其实没有提到这个问题

807
00:50:36,000 --> 00:50:38,000
比如说因为现在基本上所有 NAS 系统都是以

808
00:50:38,000 --> 00:50:40,000
Linux 系统或者是 Windows 系统

809
00:50:40,000 --> 00:50:42,000
为主的嘛

810
00:50:42,000 --> 00:50:44,000
你一个 Mac 的客户端

811
00:50:44,000 --> 00:50:46,000
去访问这个 NAS 的时候

812
00:50:46,000 --> 00:50:48,000
他的资源差又变成什么了

813
00:50:48,000 --> 00:50:50,000
变成两个文件

814
00:50:50,000 --> 00:50:52,000
一个文件不是两个文件

815
00:50:52,000 --> 00:50:54,000
有一个文件是描述他原数据信息的

816
00:50:54,000 --> 00:50:56,000
然后那个文件在其他系统是没有用的

817
00:50:56,000 --> 00:50:58,000
就跟垃圾一样的

818
00:50:58,000 --> 00:51:00,000
只有 Mac 能用

819
00:51:00,000 --> 00:51:02,000
所以就是从别的操作

820
00:51:02,000 --> 00:51:04,000
的角度来看 Mac

821
00:51:04,000 --> 00:51:06,000
的用户就是一个到处乱念垃圾的

822
00:51:06,000 --> 00:51:08,000
这么一个人对吧

823
00:51:08,000 --> 00:51:10,000
两方互相都看对方不是也罢

824
00:51:10,000 --> 00:51:12,000
Windows 不是会留下那个什么 Sumna

825
00:51:12,000 --> 00:51:14,000
Mac 也会有 DS

826
00:51:14,000 --> 00:51:16,000
叫什么 DS Store 吧

827
00:51:16,000 --> 00:51:18,000
也是一个点 DS Store

828
00:51:18,000 --> 00:51:20,000
开始的 一个文件夹会多一个

829
00:51:20,000 --> 00:51:22,000
出来 每个文件夹都会有一个非常

830
00:51:22,000 --> 00:51:24,000
烦人的也是像 SNN 一样的

831
00:51:24,000 --> 00:51:26,000
很烦人

832
00:51:26,000 --> 00:51:28,000
扯远了

833
00:51:28,000 --> 00:51:30,000
这些都是考古了对吧

834
00:51:30,000 --> 00:51:32,000
其实包括今年的 MacOS

835
00:51:32,000 --> 00:51:34,000
我相信应该我们你们有谁用过今天

836
00:51:34,000 --> 00:51:36,000
MacOS 吗 我是没用过

837
00:51:36,000 --> 00:51:38,000
我只在讯息器里跑过

838
00:51:40,000 --> 00:51:42,000
然后 Windows

839
00:51:42,000 --> 00:51:44,000
95 之前的版本

840
00:51:44,000 --> 00:51:46,000
这个我们应该都用过吧

841
00:51:46,000 --> 00:51:48,000
我当年

842
00:51:48,000 --> 00:51:50,000
还用 WPS 排版呢

843
00:51:50,000 --> 00:51:52,000
WPS 是图形版

844
00:51:52,000 --> 00:51:54,000
还是 DOS 版

845
00:51:54,000 --> 00:51:56,000
DOS 版的 UCDOS 进去的

846
00:51:56,000 --> 00:51:58,000
用智能 ABC WPS

847
00:51:58,000 --> 00:52:00,000
暴露了年龄我们都是用过

848
00:52:00,000 --> 00:52:02,000
那个时代软件

849
00:52:02,000 --> 00:52:04,000
而且还不是 Wizig

850
00:52:04,000 --> 00:52:06,000
这是要预览再预览

851
00:52:06,000 --> 00:52:08,000
等等啊 那个时代除了 WPS

852
00:52:08,000 --> 00:52:10,000
还有一个

853
00:52:10,000 --> 00:52:12,000
CLI 界面下的排版工具

854
00:52:12,000 --> 00:52:14,000
CCDE 还是叫什么

855
00:52:14,000 --> 00:52:16,000
对对对

856
00:52:16,000 --> 00:52:18,000
CCDE 还是叫什么 还是四个字母

857
00:52:18,000 --> 00:52:20,000
对对 没错 是的 有的 对

858
00:52:20,000 --> 00:52:22,000
但是我没有主要 我没用过那个

859
00:52:22,000 --> 00:52:24,000
我知道 但是没用

860
00:52:24,000 --> 00:52:26,000
其实你那个下来 那个时候还是蛮高级的

861
00:52:26,000 --> 00:52:28,000
那个时候因为不能锁件技术得

862
00:52:28,000 --> 00:52:30,000
纯制服界面的情况下

863
00:52:30,000 --> 00:52:32,000
你其实是在写 MacDown 差不多这种感觉

864
00:52:32,000 --> 00:52:34,000
是的啊

865
00:52:34,000 --> 00:52:36,000
然后我们做个花边都要脑补的

866
00:52:36,000 --> 00:52:38,000
对对对 我查到了

867
00:52:38,000 --> 00:52:40,000
CCDE 是一款中文字表处理软件

868
00:52:40,000 --> 00:52:42,000
问是 1988 年

869
00:52:42,000 --> 00:52:44,000
由原北京钱为天电子技术研究所开发

870
00:52:44,000 --> 00:52:46,000
主要开发者是朱崇钧

871
00:52:46,000 --> 00:52:48,000
软件在 DOS 时代

872
00:52:48,000 --> 00:52:50,000
曾经是中国最流行的文字处理与电子表格软件之一

873
00:52:50,000 --> 00:52:52,000
1998 年之后

874
00:52:52,000 --> 00:52:54,000
出现了 甚至出现了基于 Windows 的版本

875
00:52:54,000 --> 00:52:56,000
连续多年是中国最畅销的软件之一

876
00:52:56,000 --> 00:52:58,000
是全国计算机等级考试

877
00:52:58,000 --> 00:53:00,000
以及国内不少计算机教育培训的指定类

878
00:53:00,000 --> 00:53:02,000
我的天哪 你们想想

879
00:53:02,000 --> 00:53:04,000
我用那个打印过

880
00:53:04,000 --> 00:53:06,000
连那个真实打印机打过东西

881
00:53:06,000 --> 00:53:08,000
就打过文档

882
00:53:08,000 --> 00:53:10,000
确实还用过这个东西

883
00:53:10,000 --> 00:53:12,000
非常上古的感觉

884
00:53:12,000 --> 00:53:14,000
后来 WPS 批了对

885
00:53:14,000 --> 00:53:16,000
这里面写了老对手 WPS

886
00:53:16,000 --> 00:53:18,000
借助中国政府采购计划

887
00:53:18,000 --> 00:53:20,000
恢复了生机 但 CCDE 市场就萎缩了

888
00:53:20,000 --> 00:53:22,000
等等 2010 年 2 月份 CCDE 2000 版发行

889
00:53:22,000 --> 00:53:24,000
哦天哪

890
00:53:24,000 --> 00:53:26,000
我的天哪

891
00:53:26,000 --> 00:53:28,000
我要去看

892
00:53:28,000 --> 00:53:30,000
我要去收一套

893
00:53:32,000 --> 00:53:34,000
要还一下旧的

894
00:53:34,000 --> 00:53:36,000
哎 等一下 怎么扯到那里去

895
00:53:36,000 --> 00:53:38,000
说回来

896
00:53:38,000 --> 00:53:40,000
其实这几个

897
00:53:40,000 --> 00:53:42,000
我们刚才提的那几个古早的

898
00:53:42,000 --> 00:53:44,000
操作系统线

899
00:53:44,000 --> 00:53:46,000
其实基本上都没有了

900
00:53:46,000 --> 00:53:48,000
我们现在目前主流用的还是

901
00:53:48,000 --> 00:53:50,000
Windows 的 应该是 Windows 10

902
00:53:50,000 --> 00:53:52,000
对吧 或者是至少是

903
00:53:52,000 --> 00:53:54,000
8 以后的吧

904
00:53:54,000 --> 00:53:56,000
8 和 10 这种

905
00:53:56,000 --> 00:53:58,000
Linux 桌面现在还有人用吗

906
00:53:58,000 --> 00:54:00,000
其实还比较少

907
00:54:00,000 --> 00:54:02,000
所以这个先不算

908
00:54:02,000 --> 00:54:04,000
然后就是 MacOS

909
00:54:04,000 --> 00:54:06,000
应该说是准确的说是

910
00:54:06,000 --> 00:54:08,000
现在叫 MacOS 了

911
00:54:08,000 --> 00:54:10,000
所以这两个系统我们其实

912
00:54:10,000 --> 00:54:12,000
它给的我们限制其实就没有那么多了

913
00:54:12,000 --> 00:54:14,000
其实也可以是 我记得文件名

914
00:54:14,000 --> 00:54:16,000
可以起到多少来的

915
00:54:16,000 --> 00:54:18,000
长度啊你说

916
00:54:18,000 --> 00:54:20,000
对 长度是可以很长的了已经

917
00:54:20,000 --> 00:54:22,000
对 但扩展名这个事情在各个系统上面

918
00:54:22,000 --> 00:54:24,000
我现在基本上都保留下了 不管是在

919
00:54:24,000 --> 00:54:26,000
MacOS 上面还是在这个现在 Windows 上面

920
00:54:26,000 --> 00:54:28,000
基本上扩展名这个事情都已经

921
00:54:28,000 --> 00:54:30,000
成为一个约定

922
00:54:30,000 --> 00:54:32,000
俗成的东西了 但只是说就刚才说那个

923
00:54:32,000 --> 00:54:34,000
去嘛 就是它默认

924
00:54:34,000 --> 00:54:36,000
是在图形界面下它是展示还是

925
00:54:36,000 --> 00:54:38,000
不展示扩展名的问题吗

926
00:54:38,000 --> 00:54:40,000
我记得 Windows 目前默认应该是不展示的

927
00:54:40,000 --> 00:54:42,000
Mac 也是默认

928
00:54:42,000 --> 00:54:44,000
不展示的

929
00:54:44,000 --> 00:54:46,000
然后 Linux 的桌面我就不知道了

930
00:54:46,000 --> 00:54:48,000
因为太多了 然后也不常用

931
00:54:48,000 --> 00:54:50,000
所以就这两个都是默认不展示

932
00:54:50,000 --> 00:54:52,000
就变得很尴尬对不对 本来这个东西

933
00:54:52,000 --> 00:54:54,000
是为了说 刚才武涛也讲了嘛

934
00:54:54,000 --> 00:54:56,000
是为了让用户一眼能看出

935
00:54:56,000 --> 00:54:58,000
这个文件是个什么类型的东西

936
00:54:58,000 --> 00:55:00,000
对吧 但其实因为

937
00:55:00,000 --> 00:55:02,000
有了这个图标

938
00:55:02,000 --> 00:55:04,000
就是那个 FileIcon 就是文件类型的图标

939
00:55:04,000 --> 00:55:06,000
和它 因为如果你按那个

940
00:55:06,000 --> 00:55:08,000
叫什么 多列排布的

941
00:55:08,000 --> 00:55:10,000
按列排布

942
00:55:10,000 --> 00:55:12,000
按列排布它有可能多个

943
00:55:12,000 --> 00:55:14,000
它应该是表格式吧

944
00:55:14,000 --> 00:55:16,000
它有一栏它本来就会显示这个文件

945
00:55:16,000 --> 00:55:18,000
是什么类型嘛

946
00:55:18,000 --> 00:55:20,000
所以就有了这两个

947
00:55:20,000 --> 00:55:22,000
一个是文件图标 一个是文件类型

948
00:55:22,000 --> 00:55:24,000
单独有一列显示的情况下

949
00:55:24,000 --> 00:55:26,000
这个文件名的扩展名

950
00:55:26,000 --> 00:55:28,000
其实又变得不重要了对不对

951
00:55:28,000 --> 00:55:30,000
其实当初就不要搞扩展名

952
00:55:30,000 --> 00:55:32,000
就好像 Windows 后来就

953
00:55:32,000 --> 00:55:34,000
默认隐藏扩展名对吧

954
00:55:34,000 --> 00:55:36,000
刚装好人家默认是会隐藏扩展名

955
00:55:36,000 --> 00:55:38,000
XB 开始就默认隐藏了吧

956
00:55:38,000 --> 00:55:40,000
还是之后还是 Windows 7

957
00:55:40,000 --> 00:55:42,000
我就觉得扩展名是一个

958
00:55:42,000 --> 00:55:44,000
很蠢的一个办法

959
00:55:44,000 --> 00:55:46,000
而且它特别死板 刚才说嘛

960
00:55:46,000 --> 00:55:48,000
它和应用程式只能一对一

961
00:55:48,000 --> 00:55:50,000
像 Mac 系统它是不用这个的

962
00:55:50,000 --> 00:55:52,000
因为它通过图标来体现

963
00:55:52,000 --> 00:55:54,000
甚至它那个资源 Fog 的话

964
00:55:54,000 --> 00:55:56,000
因为有更详细的定义

965
00:55:56,000 --> 00:55:58,000
它还可以同样比如说

966
00:55:58,000 --> 00:56:00,000
是 illustrator 的 AI 这个文件

967
00:56:00,000 --> 00:56:02,000
它那个图标可以体现出

968
00:56:02,000 --> 00:56:04,000
AI 的版本的不同

969
00:56:04,000 --> 00:56:06,000
它可以体现在图标上面

970
00:56:06,000 --> 00:56:08,000
就同样都是点 AI

971
00:56:08,000 --> 00:56:10,000
但是有的是显示它的 AI

972
00:56:10,000 --> 00:56:12,000
比如说数一个显示 AI 8 这种

973
00:56:12,000 --> 00:56:14,000
对 没错

974
00:56:14,000 --> 00:56:16,000
因为它 Fog 的方式

975
00:56:16,000 --> 00:56:18,000
对 没错

976
00:56:18,000 --> 00:56:22,000
它可以分叉 可以加好多内容进去的

977
00:56:22,000 --> 00:56:25,000
然后这个东西只要体现在图标上就是一样

978
00:56:25,000 --> 00:56:28,000
然后最后给用户的信息是一样的嘛

979
00:56:28,000 --> 00:56:30,000
对于用户来讲 这的确就是一个 AI 的

980
00:56:30,000 --> 00:56:32,000
这个版本的一个文件

981
00:56:32,000 --> 00:56:34,000
它达到了一个效果嘛

982
00:56:34,000 --> 00:56:36,000
并不一定要用比如说这个三个字母

983
00:56:36,000 --> 00:56:38,000
还得让用户去记这个三个字母

984
00:56:38,000 --> 00:56:40,000
是对应什么东西

985
00:56:40,000 --> 00:56:42,000
所以它其实如果这么来看

986
00:56:42,000 --> 00:56:44,000
它文件扩展名这个事情

987
00:56:44,000 --> 00:56:47,000
它其实是字符界面向图形界面过渡

988
00:56:47,000 --> 00:56:49,000
这个时期的一个复产物 对吧

989
00:56:49,000 --> 00:56:51,000
因为在字符界面下面

990
00:56:51,000 --> 00:56:53,000
你是没有图标来告诉你

991
00:56:53,000 --> 00:56:55,000
这个文件是什么类型

992
00:56:55,000 --> 00:56:58,000
也没有多列的这种附属信息

993
00:56:58,000 --> 00:57:01,000
它展示因为字符界面一般的比较窄嘛

994
00:57:01,000 --> 00:57:03,000
就蓝比较窄嘛

995
00:57:03,000 --> 00:57:05,000
所以这种情况下

996
00:57:05,000 --> 00:57:08,000
在这个过渡时期把文件扩展名这个概念给保留下来

997
00:57:08,000 --> 00:57:11,000
但其实到现在发现其实已经完全没有作用了

998
00:57:11,000 --> 00:57:13,000
对不对 又感觉是反效果

999
00:57:13,000 --> 00:57:15,000
之所以要用这个扩展名

1000
00:57:15,000 --> 00:57:19,000
就是完全屈服于这个网络时代信息文件交换的时候

1001
00:57:19,000 --> 00:57:23,000
必须要就是屈服于 Windows 这个

1002
00:57:23,000 --> 00:57:25,000
比那个更强势一些嘛

1003
00:57:25,000 --> 00:57:27,000
有的人更多嘛 对吧

1004
00:57:27,000 --> 00:57:29,000
所以这个就是一个典型的

1005
00:57:29,000 --> 00:57:32,000
就是像 D 看似的一个典型的案例嘛

1006
00:57:32,000 --> 00:57:35,000
就我们很多东西就是好的技术并没有得到发现

1007
00:57:35,000 --> 00:57:37,000
大家都是用一个很蠢的技术

1008
00:57:37,000 --> 00:57:39,000
然后再流行起来的 对

1009
00:57:39,000 --> 00:57:40,000
刚才还说到就是说

1010
00:57:40,000 --> 00:57:42,000
因为现在这个图形界面都是默认隐藏

1011
00:57:42,000 --> 00:57:44,000
隐藏这个文件扩展名的嘛

1012
00:57:44,000 --> 00:57:46,000
它其实有一个比较重要的点

1013
00:57:46,000 --> 00:57:47,000
就是说

1014
00:57:47,000 --> 00:57:51,000
比如说你在 Windows 里面还是 Mac 里面

1015
00:57:51,000 --> 00:57:53,000
默认情况下你要改一个文件的名字

1016
00:57:53,000 --> 00:57:55,000
你怎么改 你就是选了那个文件

1017
00:57:55,000 --> 00:57:56,000
要不你右键点击改名

1018
00:57:56,000 --> 00:58:00,000
或者是你就像我们这种键盘比较数 6 的人

1019
00:58:00,000 --> 00:58:01,000
你就直接按回车

1020
00:58:01,000 --> 00:58:03,000
他就一般可以改名了嘛 对不对

1021
00:58:03,000 --> 00:58:04,000
然后这个时候

1022
00:58:04,000 --> 00:58:07,000
因为它不显示这个文件的扩展名

1023
00:58:07,000 --> 00:58:09,000
你默认改就是所谓的文件名

1024
00:58:09,000 --> 00:58:11,000
就是狭义的文件名

1025
00:58:11,000 --> 00:58:13,000
不含扩展那部分的前缀那部分

1026
00:58:13,000 --> 00:58:16,000
但其实如果说你像我们都喜欢

1027
00:58:16,000 --> 00:58:17,000
比如说我至少是这样的

1028
00:58:17,000 --> 00:58:19,000
我不知道你们的默认说是怎么

1029
00:58:19,000 --> 00:58:21,000
我一定会把那个文件扩展名展示出来

1030
00:58:21,000 --> 00:58:22,000
不知道为什么保留这个习惯

1031
00:58:22,000 --> 00:58:23,000
但是就是看起来

1032
00:58:23,000 --> 00:58:26,000
因为有可能是因为我要经常在

1033
00:58:26,000 --> 00:58:31,000
这个字符界面和图形界面先切换嘛

1034
00:58:31,000 --> 00:58:32,000
所以还是有这个需求

1035
00:58:32,000 --> 00:58:35,000
看到那个文件扩展名是什么的

1036
00:58:35,000 --> 00:58:36,000
那这种情况下呢

1037
00:58:36,000 --> 00:58:38,000
你如果要改名

1038
00:58:38,000 --> 00:58:40,000
它其实也有很多小技巧的

1039
00:58:40,000 --> 00:58:42,000
比如说我现在试一下给你们看

1040
00:58:42,000 --> 00:58:43,000
我记得应该是这样子

1041
00:58:43,000 --> 00:58:45,000
比如说我现在我打开一个 Mac

1042
00:58:45,000 --> 00:58:46,000
我要改一个文件名

1043
00:58:46,000 --> 00:58:48,000
然后这个时候我是显示的一个

1044
00:58:48,000 --> 00:58:50,000
是显示带扩展名的文件名

1045
00:58:50,000 --> 00:58:51,000
我要点

1046
00:58:51,000 --> 00:58:52,000
我按回车

1047
00:58:52,000 --> 00:58:55,000
它默认会把文件名的部分

1048
00:58:55,000 --> 00:58:56,000
给我选中

1049
00:58:56,000 --> 00:58:58,000
但是扩展名是点

1050
00:58:58,000 --> 00:59:00,000
扩展名和那个点的部分是不动的

1051
00:59:00,000 --> 00:59:01,000
什么意思呢

1052
00:59:01,000 --> 00:59:04,000
就是说它不想让用户错误的

1053
00:59:04,000 --> 00:59:06,000
更改掉这个扩展名

1054
00:59:06,000 --> 00:59:08,000
对 把文件类型改掉

1055
00:59:08,000 --> 00:59:09,000
对对

1056
00:59:09,000 --> 00:59:10,000
其实虽然说我们刚才讲

1057
00:59:10,000 --> 00:59:12,000
虽然说这个文件类型不重要

1058
00:59:12,000 --> 00:59:15,000
但是如果说你用户明确的说

1059
00:59:15,000 --> 00:59:17,000
我要把这个文件改成那个类型

1060
00:59:17,000 --> 00:59:18,000
比如说很简单一个道理

1061
00:59:18,000 --> 00:59:20,000
你现在去网站上下载一张图片回来

1062
00:59:20,000 --> 00:59:21,000
还有可能下载那个

1063
00:59:21,000 --> 00:59:24,000
因为现在很多那个网站的图片

1064
00:59:24,000 --> 00:59:25,000
它本来就没有想给你下载

1065
00:59:25,000 --> 00:59:26,000
对吧

1066
00:59:26,000 --> 00:59:28,000
它的那个文件命名也不是按照这个

1067
00:59:28,000 --> 00:59:29,000
什么有扩展名的方式来弄

1068
00:59:29,000 --> 00:59:31,000
你下载就是一个普通空白的文件

1069
00:59:31,000 --> 00:59:32,000
对吧

1070
00:59:32,000 --> 00:59:33,000
但这个时候

1071
00:59:33,000 --> 00:59:35,000
因为那个是一个外部系统来的一个文件

1072
00:59:35,000 --> 00:59:37,000
我的这个母系统

1073
00:59:37,000 --> 00:59:38,000
又不知道这个文件是个什么东西

1074
00:59:38,000 --> 00:59:40,000
它就会显示一个叫做什么

1075
00:59:40,000 --> 00:59:42,000
一个 generic file

1076
00:59:42,000 --> 00:59:44,000
一个通用的一个文件放在那里

1077
00:59:44,000 --> 00:59:45,000
不知道它是个啥

1078
00:59:45,000 --> 00:59:46,000
不知道是个图片

1079
00:59:46,000 --> 00:59:47,000
也不知道是个视频

1080
00:59:47,000 --> 00:59:48,000
也不知道是个音乐还是什么东西

1081
00:59:48,000 --> 00:59:49,000
对不对

1082
00:59:49,000 --> 00:59:50,000
这个时候我就说

1083
00:59:50,000 --> 00:59:52,000
我要强行给它加一个扩展名

1084
00:59:52,000 --> 00:59:53,000
告诉我这个系统说

1085
00:59:53,000 --> 00:59:55,000
你把它当做一个图片

1086
00:59:55,000 --> 00:59:58,000
或者你把它当做一个音频

1087
00:59:58,000 --> 00:59:59,000
对吧

1088
00:59:59,000 --> 01:00:00,000
然后你再做对应的事情

1089
01:00:00,000 --> 01:00:01,000
这个时候我就不知道

1090
01:00:01,000 --> 01:00:04,000
这个什么时候能启动类似于

1091
01:00:04,000 --> 01:00:06,000
这个 file 这个机制去探测这个文件

1092
01:00:06,000 --> 01:00:07,000
是个什么样的类型

1093
01:00:07,000 --> 01:00:09,000
这里面其实还是有很多讲究的

1094
01:00:09,000 --> 01:00:10,000
所以呢

1095
01:00:10,000 --> 01:00:12,000
从 DOS、Windows 转过去

1096
01:00:12,000 --> 01:00:13,000
在用 Mac 的时候

1097
01:00:13,000 --> 01:00:14,000
在 Mac 当年

1098
01:00:14,000 --> 01:00:16,000
因为它无所谓扩展名

1099
01:00:16,000 --> 01:00:17,000
扩展名可以随便改

1100
01:00:17,000 --> 01:00:21,000
然后这个对于我们从 DOS 转过去

1101
01:00:21,000 --> 01:00:22,000
就觉得这个都能改

1102
01:00:22,000 --> 01:00:23,000
太恐怕了

1103
01:00:23,000 --> 01:00:24,000
你说这个我想到一个问题

1104
01:00:24,000 --> 01:00:26,000
就是 Mac 上面

1105
01:00:26,000 --> 01:00:27,000
有时候会出现比如说

1106
01:00:27,000 --> 01:00:30,000
一个文件它没有扩展名

1107
01:00:30,000 --> 01:00:33,000
然后 Mac 会自动去试图去猜这个文件是什么

1108
01:00:33,000 --> 01:00:36,000
尤其是在你按下通格的时候

1109
01:00:36,000 --> 01:00:38,000
然后这就导致了很多人在

1110
01:00:38,000 --> 01:00:43,000
尤其是对电脑系统不是那么在行的人

1111
01:00:43,000 --> 01:00:45,000
会经常

1112
01:00:45,000 --> 01:00:47,000
我觉得我遇到这个问题就是

1113
01:00:47,000 --> 01:00:49,000
会有人给你很多没有扩展名的文件

1114
01:00:49,000 --> 01:00:51,000
在他的电脑上显示一切正常了

1115
01:00:51,000 --> 01:00:52,000
但到你这儿就不行了

1116
01:00:52,000 --> 01:00:53,000
因为没有扩展名

1117
01:00:53,000 --> 01:00:54,000
对这个时候其实发现

1118
01:00:54,000 --> 01:00:58,000
如果一旦涉及到这个文件的交换

1119
01:00:58,000 --> 01:01:01,000
有个扩展名明确的规定这个文件

1120
01:01:01,000 --> 01:01:03,000
是什么样的类型

1121
01:01:03,000 --> 01:01:05,000
然后至少缩小一个范围吧

1122
01:01:05,000 --> 01:01:08,000
让我们再去处理还是会容易很多的

1123
01:01:08,000 --> 01:01:11,000
对有很多事情你会觉得说这样是方便的用户

1124
01:01:11,000 --> 01:01:14,000
但是这样会苦的开发者

1125
01:01:14,000 --> 01:01:17,000
这是一个两面的问题

1126
01:01:17,000 --> 01:01:19,000
所有的软件生意不是这么干的吗

1127
01:01:19,000 --> 01:01:21,000
都是这样子的方便用户

1128
01:01:21,000 --> 01:01:24,000
要关着用户的呀

1129
01:01:24,000 --> 01:01:25,000
是的

1130
01:01:26,000 --> 01:01:27,000
好吧

1131
01:01:27,000 --> 01:01:29,000
那我们文件名的长度差不多这样

1132
01:01:29,000 --> 01:01:31,000
我们我觉得扩展名的坑太深了

1133
01:01:31,000 --> 01:01:33,000
哎呀这个都没一次讲不好

1134
01:01:33,000 --> 01:01:35,000
我们本来今天重点不是讲这个的

1135
01:01:36,000 --> 01:01:38,000
讲了这么久这个坑

1136
01:01:38,000 --> 01:01:39,000
对呀

1137
01:01:39,000 --> 01:01:42,000
下面我们来谈更大一个坑

1138
01:01:42,000 --> 01:01:46,000
文件名命名是否允许包含空格的问题

1139
01:01:46,000 --> 01:01:48,000
这个事情就特别扯了

1140
01:01:48,000 --> 01:01:50,000
因为大家也知道我们所有的这些系统的话

1141
01:01:50,000 --> 01:01:53,000
都是从西方语言过来的

1142
01:01:53,000 --> 01:01:56,000
像西文的话他们都是按词分写的

1143
01:01:56,000 --> 01:01:59,000
词和词之中间都是有空格的

1144
01:01:59,000 --> 01:02:03,000
我记得 DOS 的文件名是不允许有空格的吧

1145
01:02:03,000 --> 01:02:05,000
应该是不允许

1146
01:02:05,000 --> 01:02:08,000
我一点不太记不清楚了

1147
01:02:08,000 --> 01:02:09,000
有可能是不允许

1148
01:02:09,000 --> 01:02:11,000
我学电脑开始就是从 DOS 进来的

1149
01:02:11,000 --> 01:02:15,000
所以哪怕直到现在我自己起文件名

1150
01:02:15,000 --> 01:02:18,000
还是不习惯用空格

1151
01:02:18,000 --> 01:02:20,000
我会用什么

1152
01:02:20,000 --> 01:02:24,000
用 highphone 用连字符或者下画线来写

1153
01:02:24,000 --> 01:02:25,000
OK

1154
01:02:25,000 --> 01:02:27,000
我上次看一个视频就是一个

1155
01:02:28,000 --> 01:02:29,000
他叫什么

1156
01:02:29,000 --> 01:02:31,000
他叫 8 bit guy

1157
01:02:31,000 --> 01:02:34,000
他在视频里面教你装一个

1158
01:02:34,000 --> 01:02:38,000
Micro S Classic 的操作系统

1159
01:02:38,000 --> 01:02:44,000
然后他很自然而然的把主硬盘命名为

1160
01:02:44,000 --> 01:02:46,000
iMac 空格 HD

1161
01:02:46,000 --> 01:02:47,000
然后我就想

1162
01:02:47,000 --> 01:02:49,000
我就感叹说果然是祖传 Mac 用户

1163
01:02:49,000 --> 01:02:53,000
从来不会在意文件名里面可有用

1164
01:02:53,000 --> 01:02:55,000
能不能有空格这种问题

1165
01:02:55,000 --> 01:02:58,000
你要是这种古早的 Windows 用户

1166
01:02:58,000 --> 01:02:59,000
你绝对不可能做出这种事

1167
01:02:59,000 --> 01:03:04,000
就是把一个文件命名为一个带空格的名字

1168
01:03:04,000 --> 01:03:06,000
有空格会有什么问题

1169
01:03:06,000 --> 01:03:11,000
就是在早年的命令行制服界面的时候

1170
01:03:11,000 --> 01:03:13,000
比如说我要处理

1171
01:03:13,000 --> 01:03:15,000
比如说我们想象一个场景

1172
01:03:15,000 --> 01:03:16,000
复制吧

1173
01:03:16,000 --> 01:03:19,000
假设我有一个文件叫做 a.txt

1174
01:03:19,000 --> 01:03:21,000
我要把它复制为 b.txt

1175
01:03:21,000 --> 01:03:22,000
我直接就像什么

1176
01:03:22,000 --> 01:03:23,000
就是 CP 就是 copy

1177
01:03:23,000 --> 01:03:25,000
然后 a.txt

1178
01:03:25,000 --> 01:03:27,000
然后到目标是 b.txt

1179
01:03:27,000 --> 01:03:28,000
就是完成了对不对

1180
01:03:28,000 --> 01:03:30,000
但你发现这三个部分

1181
01:03:30,000 --> 01:03:31,000
一个主语

1182
01:03:31,000 --> 01:03:32,000
两个冰语对吧

1183
01:03:32,000 --> 01:03:34,000
动词

1184
01:03:34,000 --> 01:03:35,000
一个动词

1185
01:03:35,000 --> 01:03:37,000
然后两个 object 两个目标的时候

1186
01:03:37,000 --> 01:03:38,000
你发现他用什么风格

1187
01:03:38,000 --> 01:03:40,000
用空格风格对不对

1188
01:03:40,000 --> 01:03:41,000
这个时候你说

1189
01:03:41,000 --> 01:03:43,000
我的文件是刚好是 a 空格 b

1190
01:03:43,000 --> 01:03:44,000
这个时候怎么办

1191
01:03:44,000 --> 01:03:46,000
这很尴尬对不对

1192
01:03:46,000 --> 01:03:48,000
但其实也是有解决方案的

1193
01:03:48,000 --> 01:03:52,000
就是说你把带空格的文件名

1194
01:03:52,000 --> 01:03:54,000
用引号引起来不就好了吗

1195
01:03:54,000 --> 01:03:56,000
其实你可以 copy 空格

1196
01:03:56,000 --> 01:03:57,000
然后引号开

1197
01:03:57,000 --> 01:03:58,000
就是引号

1198
01:03:58,000 --> 01:04:00,000
然后 a 空格 b.txt

1199
01:04:00,000 --> 01:04:01,000
然后引号

1200
01:04:01,000 --> 01:04:02,000
然后又下一个目标

1201
01:04:02,000 --> 01:04:03,000
就是 c.txt

1202
01:04:03,000 --> 01:04:05,000
其实也是可以的对不对

1203
01:04:05,000 --> 01:04:06,000
但只是说

1204
01:04:06,000 --> 01:04:07,000
就增加了一个麻烦

1205
01:04:07,000 --> 01:04:09,000
但其实我觉得这个还不是最坑爹的

1206
01:04:09,000 --> 01:04:11,000
就算我个人觉得

1207
01:04:11,000 --> 01:04:13,000
你可以允许空格

1208
01:04:13,000 --> 01:04:16,000
但是最好是不鼓励使用空格

1209
01:04:16,000 --> 01:04:17,000
虽然说像 MAC

1210
01:04:17,000 --> 01:04:19,000
目前的 MAC 超级

1211
01:04:19,000 --> 01:04:22,000
大量的使用了空格的这么一个

1212
01:04:22,000 --> 01:04:24,000
因为一旦涉及到空格

1213
01:04:24,000 --> 01:04:26,000
你那个文件名就必须要用引号

1214
01:04:26,000 --> 01:04:27,000
引号的话就有时候会导致

1215
01:04:27,000 --> 01:04:29,000
比如说自动补齐的一些问题

1216
01:04:29,000 --> 01:04:30,000
还有包括有一些这种

1217
01:04:30,000 --> 01:04:32,000
有些这个卷用性的问题

1218
01:04:32,000 --> 01:04:34,000
比如说我们正采用这个 xargs

1219
01:04:34,000 --> 01:04:35,000
就是有一个命令

1220
01:04:35,000 --> 01:04:39,000
它可以说你把前面的成就的输入

1221
01:04:39,000 --> 01:04:41,000
全部作为命令的参数来执行

1222
01:04:41,000 --> 01:04:43,000
这么一个辅助的命令

1223
01:04:43,000 --> 01:04:44,000
它是怎么判断前面

1224
01:04:44,000 --> 01:04:45,000
你输入了哪个参数给他

1225
01:04:45,000 --> 01:04:47,000
它就说有个空格分隔开的

1226
01:04:47,000 --> 01:04:48,000
那些都是各种各样的参数对吧

1227
01:04:48,000 --> 01:04:50,000
除非你文件名刚好又是个空格

1228
01:04:50,000 --> 01:04:51,000
你怎么办呢

1229
01:04:51,000 --> 01:04:54,000
就得你说那我就改一个来分隔幅

1230
01:04:54,000 --> 01:04:55,000
来分隔参数

1231
01:04:55,000 --> 01:04:56,000
就不要用空格分隔参数了

1232
01:04:56,000 --> 01:04:57,000
那我用一个什么

1233
01:04:57,000 --> 01:04:59,000
比如说是这个就是 0

1234
01:04:59,000 --> 01:05:00,000
就是 ask 吧

1235
01:05:00,000 --> 01:05:01,000
说 0 的那个字符

1236
01:05:01,000 --> 01:05:03,000
那个 no 那个字符来分隔

1237
01:05:03,000 --> 01:05:04,000
前面的参数

1238
01:05:04,000 --> 01:05:05,000
也可以对不对

1239
01:05:05,000 --> 01:05:09,000
但是就是这个东西就很不自然了

1240
01:05:09,000 --> 01:05:12,000
但我觉得其实用空格的最麻烦的问题

1241
01:05:12,000 --> 01:05:14,000
到前面那个都是说只是麻烦

1242
01:05:14,000 --> 01:05:17,000
还不是说不至于说完全不能用

1243
01:05:17,000 --> 01:05:21,000
用空格在文件名里面最坑爹的事情是

1244
01:05:21,000 --> 01:05:24,000
你到底连续用了几个空格

1245
01:05:24,000 --> 01:05:25,000
啊哈

1246
01:05:25,000 --> 01:05:28,000
就是 a 空格 b.txt

1247
01:05:28,000 --> 01:05:29,000
这是一个文件

1248
01:05:29,000 --> 01:05:31,000
a 空格空格 b.txt

1249
01:05:31,000 --> 01:05:32,000
这是另外一个文件对不对

1250
01:05:32,000 --> 01:05:36,000
这是在一个非等宽字体的显示环境之下

1251
01:05:36,000 --> 01:05:37,000
非常严重的问题

1252
01:05:37,000 --> 01:05:38,000
对啊

1253
01:05:38,000 --> 01:05:40,000
我们知道就是说在非等宽的情况下

1254
01:05:40,000 --> 01:05:42,000
那个 a 和 b 它可能不是一个宽度

1255
01:05:42,000 --> 01:05:43,000
我说 a 和 b 可能还看不出来

1256
01:05:43,000 --> 01:05:45,000
比如说 a 和小写字母的

1257
01:05:45,000 --> 01:05:46,000
在非等宽的情况下

1258
01:05:46,000 --> 01:05:48,000
它肯定是不一样宽的嘛

1259
01:05:48,000 --> 01:05:49,000
这个时候你说一下

1260
01:05:49,000 --> 01:05:51,000
它中间到底间隔了几个空格

1261
01:05:51,000 --> 01:05:53,000
你去数吗难道

1262
01:05:53,000 --> 01:05:56,000
或者说你说一两个的区别可能还比较明显

1263
01:05:56,000 --> 01:05:57,000
对吧

1264
01:05:57,000 --> 01:05:58,000
五个和六个的区别你能看得出来

1265
01:05:58,000 --> 01:06:02,000
但这个其实你用下滑线或者用 hyphen

1266
01:06:02,000 --> 01:06:03,000
其实面临的问题是一样的

1267
01:06:03,000 --> 01:06:05,000
我觉得关键的问题还是在于

1268
01:06:05,000 --> 01:06:08,000
空格它作为一个特殊的字符

1269
01:06:08,000 --> 01:06:11,000
它其实是有别的作用

1270
01:06:11,000 --> 01:06:12,000
它作为分格符用的

1271
01:06:12,000 --> 01:06:14,000
对一旦你要把它容纳到文件名里面

1272
01:06:14,000 --> 01:06:17,000
你可能要引入别的机制来保护它

1273
01:06:17,000 --> 01:06:19,000
比如你要加引号

1274
01:06:19,000 --> 01:06:20,000
就 escape 嘛

1275
01:06:20,000 --> 01:06:21,000
转 e 嘛

1276
01:06:21,000 --> 01:06:24,000
这样子的话文件名还能不能用引号呢

1277
01:06:24,000 --> 01:06:25,000
对

1278
01:06:25,000 --> 01:06:27,000
所以你必须要引入别的机制

1279
01:06:27,000 --> 01:06:31,000
对 escape 机制在 Windows 上面是非常非常担当的

1280
01:06:31,000 --> 01:06:34,000
就是 Windows 自从支持文件名有空格之后

1281
01:06:34,000 --> 01:06:37,000
Windows 最知名的一个带空格的文件名

1282
01:06:37,000 --> 01:06:38,000
大家想想是什么

1283
01:06:38,000 --> 01:06:40,000
program 空格 files

1284
01:06:40,000 --> 01:06:41,000
真的 fuck me

1285
01:06:41,000 --> 01:06:42,000
真的 fuck me

1286
01:06:42,000 --> 01:06:45,000
真的每次要进入这个路径真的是

1287
01:06:45,000 --> 01:06:47,000
这么说吧

1288
01:06:47,000 --> 01:06:49,000
Uniqs 能有空格

1289
01:06:49,000 --> 01:06:51,000
但是 Uniqs 支持用 backslash 做 escape

1290
01:06:51,000 --> 01:06:52,000
对吧

1291
01:06:52,000 --> 01:06:54,000
你打文件名打到一半

1292
01:06:54,000 --> 01:06:55,000
你发现有个空格

1293
01:06:55,000 --> 01:06:56,000
那你 backslash 空格就好了

1294
01:06:56,000 --> 01:07:02,000
Windows 你要回到一开始的这个参数的最开始

1295
01:07:02,000 --> 01:07:04,000
给它加一个双引号

1296
01:07:04,000 --> 01:07:08,000
而 Windows 的这个 tab autocompletion

1297
01:07:08,000 --> 01:07:10,000
它虽然会帮你加上双引号

1298
01:07:10,000 --> 01:07:11,000
但是它非常的蠢

1299
01:07:11,000 --> 01:07:13,000
你在用的时候你会觉得

1300
01:07:13,000 --> 01:07:15,000
蠢死了

1301
01:07:15,000 --> 01:07:19,000
而且 Windows 它也没有像

1302
01:07:19,000 --> 01:07:21,000
Line Editor

1303
01:07:21,000 --> 01:07:23,000
就是迷你行内行的编辑器的时候

1304
01:07:23,000 --> 01:07:24,000
它是我记得我

1305
01:07:24,000 --> 01:07:25,000
它有那功能吗

1306
01:07:25,000 --> 01:07:28,000
就是跳一个 word 的一个 word 跳

1307
01:07:28,000 --> 01:07:29,000
Auth 加 f 是吧没有

1308
01:07:29,000 --> 01:07:32,000
Auth 加 fAuth 加 w 全都没有

1309
01:07:32,000 --> 01:07:34,000
就比如说你想写一个剧场的

1310
01:07:34,000 --> 01:07:36,000
剧场的什么 C 冒号

1311
01:07:36,000 --> 01:07:37,000
斜杠斜杠

1312
01:07:37,000 --> 01:07:38,000
然后 program

1313
01:07:38,000 --> 01:07:40,000
就说你发现

1314
01:07:40,000 --> 01:07:41,000
我要打那个

1315
01:07:41,000 --> 01:07:43,000
你想要回到行手只能按 home

1316
01:07:43,000 --> 01:07:45,000
就不能按 ctrl 加 A 之类的

1317
01:07:45,000 --> 01:07:46,000
那你出来从第一个

1318
01:07:46,000 --> 01:07:49,000
慢慢用箭头再挪到对应的位置

1319
01:07:49,000 --> 01:07:50,000
加引号 C 前面

1320
01:07:50,000 --> 01:07:52,000
对你看那些一直

1321
01:07:52,000 --> 01:07:53,000
就德国有些很老的程序

1322
01:07:53,000 --> 01:07:54,000
一直缠

1323
01:07:54,000 --> 01:07:56,000
然后修改文件名的时候

1324
01:07:56,000 --> 01:07:58,000
要按那个后退键

1325
01:07:58,000 --> 01:08:00,000
按上那么 2314

1326
01:08:00,000 --> 01:08:01,000
你看它的时候

1327
01:08:01,000 --> 01:08:03,000
你就真的会替它着急

1328
01:08:04,000 --> 01:08:05,000
所以给人一种德国人

1329
01:08:05,000 --> 01:08:06,000
做事严谨的感觉

1330
01:08:06,000 --> 01:08:08,000
就在抖抖抖抖

1331
01:08:08,000 --> 01:08:10,000
按给你们听一下

1332
01:08:14,000 --> 01:08:15,000
是这种感觉

1333
01:08:15,000 --> 01:08:17,000
请问键盘什么牌子

1334
01:08:17,000 --> 01:08:19,000
对所以就刚才那个 backslash

1335
01:08:19,000 --> 01:08:21,000
其实又有就是那个叫做

1336
01:08:21,000 --> 01:08:22,000
backslash 叫什么

1337
01:08:22,000 --> 01:08:23,000
我一直搞不清楚

1338
01:08:23,000 --> 01:08:24,000
哪个是斜杠

1339
01:08:24,000 --> 01:08:25,000
哪个是反斜杠

1340
01:08:25,000 --> 01:08:26,000
反斜杠

1341
01:08:26,000 --> 01:08:27,000
backslash 是反斜杠

1342
01:08:27,000 --> 01:08:30,000
等一下斜杠是从哪

1343
01:08:30,000 --> 01:08:31,000
从右上到左下

1344
01:08:31,000 --> 01:08:32,000
到东南

1345
01:08:32,000 --> 01:08:34,000
OK 右上到左下

1346
01:08:34,000 --> 01:08:35,000
这个是斜杠对吧

1347
01:08:35,000 --> 01:08:37,000
对斜杠青年是斜杠青年

1348
01:08:37,000 --> 01:08:39,000
反斜杠青年

1349
01:08:39,000 --> 01:08:41,000
反向青年是用 backslash

1350
01:08:41,000 --> 01:08:43,000
做斜杠青年的斜杠青年

1351
01:08:46,000 --> 01:08:47,000
斜杠这个

1352
01:08:47,000 --> 01:08:49,000
右上到左下的是正斜杠

1353
01:08:49,000 --> 01:08:51,000
左上到右下的是反斜杠

1354
01:08:51,000 --> 01:08:52,000
怎么说

1355
01:08:52,000 --> 01:08:54,000
我问的这个问题有点抬杠

1356
01:08:54,000 --> 01:08:56,000
这实际上是一个怎么说

1357
01:08:56,000 --> 01:08:58,000
右撇子的世界的偏见

1358
01:08:58,000 --> 01:09:00,000
因为右撇子在砍人的时候

1359
01:09:00,000 --> 01:09:02,000
会自然从右上举起来

1360
01:09:02,000 --> 01:09:04,000
然后朝左下削下去对吧

1361
01:09:04,000 --> 01:09:06,000
为什么一定要砍人呢

1362
01:09:06,000 --> 01:09:08,000
slash 这个动作

1363
01:09:08,000 --> 01:09:09,000
不是劈砍的意思吗

1364
01:09:09,000 --> 01:09:13,000
slash 就是你把你的手举起来

1365
01:09:13,000 --> 01:09:14,000
你的惯用手举起来

1366
01:09:14,000 --> 01:09:15,000
肯定是朝右上举的

1367
01:09:15,000 --> 01:09:19,000
然后劈下来是朝左下劈的吧

1368
01:09:20,000 --> 01:09:21,000
我这么说吧

1369
01:09:21,000 --> 01:09:24,000
就是在网址里面那个斜杠是正斜杠

1370
01:09:24,000 --> 01:09:25,000
对吧

1371
01:09:25,000 --> 01:09:28,000
然后 Windows 的路径是反斜杠

1372
01:09:28,000 --> 01:09:31,000
这实际上也是一个很有意思的叫什么

1373
01:09:31,000 --> 01:09:32,000
路径依赖问题

1374
01:09:32,000 --> 01:09:35,000
因为 UNIX 最开始是用斜杠

1375
01:09:35,000 --> 01:09:37,000
作为路径分割服的

1376
01:09:37,000 --> 01:09:41,000
而 DOS 1.0 是没有路径这个概念的

1377
01:09:41,000 --> 01:09:43,000
也是后来加的

1378
01:09:43,000 --> 01:09:49,000
他们就是继承了当时 CPM 的斜杠

1379
01:09:49,000 --> 01:09:52,000
作为 FLAG 的这个用法

1380
01:09:52,000 --> 01:09:53,000
作为参数的用法

1381
01:09:53,000 --> 01:09:56,000
然后等到他们需要加入这个

1382
01:09:56,000 --> 01:09:57,000
路径的时候

1383
01:09:57,000 --> 01:09:59,000
就用了反斜杠

1384
01:09:59,000 --> 01:10:01,000
因为斜杠已经被用掉了对吧

1385
01:10:01,000 --> 01:10:03,000
对这就造成了另外一个问题

1386
01:10:03,000 --> 01:10:04,000
就是你用这个

1387
01:10:04,000 --> 01:10:06,000
我们讲用 backslash 这个叫 quoting

1388
01:10:06,000 --> 01:10:09,000
就是保护那个空格的时候

1389
01:10:09,000 --> 01:10:11,000
你发现好像没法保护对吧

1390
01:10:11,000 --> 01:10:13,000
因为我的斜杠有别的用途

1391
01:10:13,000 --> 01:10:14,000
对

1392
01:10:14,000 --> 01:10:15,000
太坑爹了

1393
01:10:15,000 --> 01:10:17,000
但现在的主流的操作系统

1394
01:10:17,000 --> 01:10:18,000
还是最新的

1395
01:10:18,000 --> 01:10:20,000
比如说 Windows 10 和 MacOS

1396
01:10:20,000 --> 01:10:21,000
都是允许使用空格

1397
01:10:21,000 --> 01:10:23,000
而且是允许使用任意多个空格

1398
01:10:23,000 --> 01:10:24,000
连续也可以

1399
01:10:24,000 --> 01:10:26,000
所以就会出现我刚才说的那个问题

1400
01:10:26,000 --> 01:10:28,000
就是你非要搞事的话

1401
01:10:28,000 --> 01:10:30,000
你只要起个文件名

1402
01:10:30,000 --> 01:10:32,000
然后隐藏后缀

1403
01:10:32,000 --> 01:10:34,000
然后又起个文件名

1404
01:10:34,000 --> 01:10:35,000
A 空格

1405
01:10:35,000 --> 01:10:36,000
又隐藏后缀

1406
01:10:36,000 --> 01:10:37,000
然后又起个文件名

1407
01:10:37,000 --> 01:10:39,000
A 空格 又隐藏后缀

1408
01:10:39,000 --> 01:10:41,000
你发现这个文件家怎么全都是文件

1409
01:10:41,000 --> 01:10:42,000
都叫 A

1410
01:10:42,000 --> 01:10:43,000
对不对

1411
01:10:43,000 --> 01:10:44,000
全是空格文件

1412
01:10:44,000 --> 01:10:46,000
还有空白的文件

1413
01:10:46,000 --> 01:10:47,000
更猛的

1414
01:10:47,000 --> 01:10:48,000
这个也很有意思

1415
01:10:48,000 --> 01:10:51,000
所以我觉得允许空格是可以的

1416
01:10:51,000 --> 01:10:53,000
但是我觉得这个文件

1417
01:10:53,000 --> 01:10:54,000
是可以的

1418
01:10:54,000 --> 01:10:55,000
但是我觉得

1419
01:10:55,000 --> 01:10:56,000
能不写空格的时候

1420
01:10:56,000 --> 01:10:57,000
尽量不写空格

1421
01:10:57,000 --> 01:10:58,000
避免太多那种坑

1422
01:11:01,000 --> 01:11:04,000
所以文件名允许空格还好

1423
01:11:04,000 --> 01:11:06,000
但是你在编程的时候

1424
01:11:06,000 --> 01:11:08,000
那些标制符

1425
01:11:08,000 --> 01:11:09,000
标识符

1426
01:11:09,000 --> 01:11:10,000
标识符

1427
01:11:10,000 --> 01:11:13,000
标识符

1428
01:11:13,000 --> 01:11:14,000
标识符的话

1429
01:11:14,000 --> 01:11:15,000
就肯定不能有空格

1430
01:11:15,000 --> 01:11:16,000
对吧

1431
01:11:16,000 --> 01:11:19,000
那就会变成两个符号了

1432
01:11:19,000 --> 01:11:21,000
identifier

1433
01:11:21,000 --> 01:11:23,000
那里有个相对好的理解

1434
01:11:23,000 --> 01:11:24,000
那里至少有个明确的语

1435
01:11:24,000 --> 01:11:25,000
跟写字是一样的

1436
01:11:25,000 --> 01:11:27,000
你知道你写的是两个 word

1437
01:11:27,000 --> 01:11:28,000
它不是一个 word

1438
01:11:28,000 --> 01:11:29,000
那肯定要用一个东西来分隔

1439
01:11:29,000 --> 01:11:31,000
空格分隔天经地义

1440
01:11:31,000 --> 01:11:33,000
就是在稀窝里面还是这样子

1441
01:11:33,000 --> 01:11:37,000
所以在编程的时候

1442
01:11:37,000 --> 01:11:39,000
就开始各种类

1443
01:11:39,000 --> 01:11:40,000
各种函数

1444
01:11:40,000 --> 01:11:42,000
就开始大家要连起来

1445
01:11:42,000 --> 01:11:46,000
于是就有各种各样的写法了

1446
01:11:46,000 --> 01:11:47,000
现在最流行的

1447
01:11:47,000 --> 01:11:49,000
应该就是那种 camel case

1448
01:11:49,000 --> 01:11:50,000
对吧

1449
01:11:50,000 --> 01:11:53,000
camel case 和下画线

1450
01:11:53,000 --> 01:11:54,000
取决于你干嘛

1451
01:11:54,000 --> 01:11:56,000
现在什么 kbob case

1452
01:11:56,000 --> 01:11:59,000
camel case 和 snake case

1453
01:11:59,000 --> 01:12:00,000
各有用处了

1454
01:12:00,000 --> 01:12:02,000
来跟大家解释一下

1455
01:12:02,000 --> 01:12:03,000
这就是什么意思

1456
01:12:03,000 --> 01:12:04,000
对吧

1457
01:12:04,000 --> 01:12:05,000
先要讲这个场景是什么

1458
01:12:05,000 --> 01:12:06,000
对不对

1459
01:12:06,000 --> 01:12:07,000
就是说为什么有这个需求

1460
01:12:07,000 --> 01:12:09,000
就是说你因为不能用空格

1461
01:12:09,000 --> 01:12:11,000
去分隔这个

1462
01:12:11,000 --> 01:12:13,000
就是编程里面的一个词

1463
01:12:13,000 --> 01:12:14,000
一个标识符

1464
01:12:14,000 --> 01:12:15,000
一个标识符

1465
01:12:15,000 --> 01:12:16,000
你不能用空格分隔

1466
01:12:16,000 --> 01:12:17,000
至少应该我觉得

1467
01:12:17,000 --> 01:12:19,000
目前主流的编程语言

1468
01:12:19,000 --> 01:12:20,000
都是不支持这个点的

1469
01:12:20,000 --> 01:12:22,000
你甚至你也不能用引号

1470
01:12:22,000 --> 01:12:23,000
对吧 不能加引号

1471
01:12:23,000 --> 01:12:24,000
引号是一个特殊符号

1472
01:12:24,000 --> 01:12:25,000
你也不能用

1473
01:12:25,000 --> 01:12:26,000
对吧 所以你要去说

1474
01:12:26,000 --> 01:12:27,000
那我要分隔

1475
01:12:27,000 --> 01:12:28,000
比如说 hello world

1476
01:12:28,000 --> 01:12:30,000
这两个写在一起的时候怎么办

1477
01:12:30,000 --> 01:12:32,000
通常的一种做法就是说

1478
01:12:32,000 --> 01:12:34,000
我这两个字就是连起来一起写

1479
01:12:34,000 --> 01:12:36,000
但是 hello h 是大写

1480
01:12:36,000 --> 01:12:38,000
然后 word 的 w 大写

1481
01:12:38,000 --> 01:12:40,000
对吧 这个叫做什么来的

1482
01:12:40,000 --> 01:12:42,000
camel case

1483
01:12:42,000 --> 01:12:43,000
驼锋石

1484
01:12:43,000 --> 01:12:44,000
等等

1485
01:12:44,000 --> 01:12:46,000
camel case 和 pascal

1486
01:12:46,000 --> 01:12:47,000
第一个应该是小写的

1487
01:12:47,000 --> 01:12:48,000
对 第一个一定要小写

1488
01:12:48,000 --> 01:12:49,000
才叫 camel case

1489
01:12:49,000 --> 01:12:51,000
第一个大写的话就 pascal case

1490
01:12:51,000 --> 01:12:54,000
但这个区别其实好像大家讲的那么多

1491
01:12:54,000 --> 01:12:56,000
大家一般还是讲就是说

1492
01:12:56,000 --> 01:12:58,000
手字母大写我们都是这样

1493
01:12:58,000 --> 01:12:59,000
对 比如说课文里面

1494
01:12:59,000 --> 01:13:01,000
大写小写是有语意的区别

1495
01:13:01,000 --> 01:13:04,000
number function 实际上是 pascal case

1496
01:13:04,000 --> 01:13:06,000
但是很多人会说那是 camel case

1497
01:13:06,000 --> 01:13:07,000
camel case 就是说

1498
01:13:07,000 --> 01:13:10,000
你看你怎么去理解它的定义是啥

1499
01:13:10,000 --> 01:13:11,000
就是说你只是说

1500
01:13:11,000 --> 01:13:16,000
有词的手字母大写这种

1501
01:13:16,000 --> 01:13:17,000
这一类你都叫 camel case

1502
01:13:17,000 --> 01:13:18,000
他也说得过去

1503
01:13:18,000 --> 01:13:20,000
只是说因为在 go 里面

1504
01:13:20,000 --> 01:13:22,000
它的第一个字母是大写和小写

1505
01:13:22,000 --> 01:13:25,000
会影响到它这个标识符的

1506
01:13:25,000 --> 01:13:27,000
就是 visibility 的可见性

1507
01:13:27,000 --> 01:13:28,000
所以这个人他就说

1508
01:13:28,000 --> 01:13:29,000
作用语

1509
01:13:29,000 --> 01:13:31,000
我又不好去单独去给它起一个名字

1510
01:13:31,000 --> 01:13:34,000
所以就只能说这一类都叫 camel case

1511
01:13:34,000 --> 01:13:35,000
好吧

1512
01:13:35,000 --> 01:13:39,000
你可以说 pascal case 实际上是 camel case 的一个特例

1513
01:13:39,000 --> 01:13:41,000
就小拖峰和大拖峰

1514
01:13:41,000 --> 01:13:43,000
所谓的小拖峰就是

1515
01:13:43,000 --> 01:13:45,000
手字母是小写

1516
01:13:45,000 --> 01:13:47,000
但是后面的词

1517
01:13:47,000 --> 01:13:50,000
第二个单词的字母是大写

1518
01:13:50,000 --> 01:13:51,000
就小拖峰

1519
01:13:51,000 --> 01:13:54,000
然后大拖峰的话就是联手字母也大写

1520
01:13:54,000 --> 01:13:57,000
这样的话也可以叫做 pascal

1521
01:13:59,000 --> 01:14:01,000
它是从 pascal 原来的

1522
01:14:01,000 --> 01:14:03,000
但这里就有一个更坑爹的事情了

1523
01:14:03,000 --> 01:14:05,000
就是说我考你们一个

1524
01:14:05,000 --> 01:14:07,000
其实有很多人有分歧的

1525
01:14:07,000 --> 01:14:09,000
缩略词

1526
01:14:09,000 --> 01:14:11,000
全大写的时候应该怎么办是吗

1527
01:14:11,000 --> 01:14:12,000
对怎么办

1528
01:14:12,000 --> 01:14:14,000
你用 L 是吧

1529
01:14:14,000 --> 01:14:16,000
因为 L 现在基本上大家都基本上都是

1530
01:14:16,000 --> 01:14:18,000
如果是在磁所的话很多都是小写

1531
01:14:18,000 --> 01:14:19,000
或者是这个

1532
01:14:19,000 --> 01:14:21,000
但也是一个要值得讨论的问题

1533
01:14:21,000 --> 01:14:22,000
这个还不是最坑的

1534
01:14:22,000 --> 01:14:23,000
最坑是这种

1535
01:14:23,000 --> 01:14:25,000
比如说是 IP 地址

1536
01:14:25,000 --> 01:14:26,000
IP address

1537
01:14:26,000 --> 01:14:28,000
我写成一个字的时候怎么这么大小写

1538
01:14:28,000 --> 01:14:31,000
IP 两个字母必须大写

1539
01:14:31,000 --> 01:14:32,000
通常来讲的话

1540
01:14:32,000 --> 01:14:34,000
那不就变成 pascal case 了吗

1541
01:14:37,000 --> 01:14:38,000
不是这里就很坑

1542
01:14:38,000 --> 01:14:39,000
但这个问题在这里

1543
01:14:39,000 --> 01:14:42,000
我们先不考虑购语言这种比较特殊

1544
01:14:42,000 --> 01:14:45,000
它对手字母大小写有语意的区别之外

1545
01:14:45,000 --> 01:14:48,000
假设是完全没有语意区别的情况下

1546
01:14:48,000 --> 01:14:49,000
它其实也有讲究的

1547
01:14:49,000 --> 01:14:53,000
比如说是 i 大写 p 小写

1548
01:14:53,000 --> 01:14:55,000
a 大写的 IP address

1549
01:14:55,000 --> 01:14:58,000
还是说 ipa 都大写

1550
01:14:58,000 --> 01:15:00,000
然后 address 的后面出手字母的都小写

1551
01:15:00,000 --> 01:15:01,000
这是一种写法

1552
01:15:01,000 --> 01:15:03,000
还有就是 ip 都小写

1553
01:15:03,000 --> 01:15:04,000
然后 a 大写

1554
01:15:04,000 --> 01:15:06,000
然后 address 的小写这种情况下

1555
01:15:06,000 --> 01:15:07,000
对吧

1556
01:15:07,000 --> 01:15:08,000
你发现没

1557
01:15:08,000 --> 01:15:11,000
它有很多这种不太明确的地方

1558
01:15:11,000 --> 01:15:14,000
然后这种你说这个 ip address

1559
01:15:14,000 --> 01:15:15,000
还比较简单对吧

1560
01:15:15,000 --> 01:15:17,000
但如果是刚好是这种说略词

1561
01:15:17,000 --> 01:15:18,000
ip 是个说略词

1562
01:15:18,000 --> 01:15:21,000
它是 internet protocol 的说略

1563
01:15:21,000 --> 01:15:27,000
如果说我要写 ipurl address 怎么办

1564
01:15:27,000 --> 01:15:30,000
没有这好像跟你的环境

1565
01:15:30,000 --> 01:15:32,000
跟那个语言有关系

1566
01:15:32,000 --> 01:15:34,000
然后有些它还是有习惯的

1567
01:15:34,000 --> 01:15:37,000
比如说这个叫手字母缩写

1568
01:15:37,000 --> 01:15:42,000
如果超过是三个或三个以上的话

1569
01:15:42,000 --> 01:15:45,000
那么把后面几个字母小写

1570
01:15:45,000 --> 01:15:47,000
有那样的语言

1571
01:15:47,000 --> 01:15:48,000
是啊

1572
01:15:48,000 --> 01:15:49,000
所以我就说这个事情呢

1573
01:15:49,000 --> 01:15:51,000
其实是一个相对来说

1574
01:15:51,000 --> 01:15:53,000
首先中文里面不存在这个问题

1575
01:15:53,000 --> 01:15:54,000
对吧

1576
01:15:54,000 --> 01:15:55,000
因为只有西文有大小写这个概念嘛

1577
01:15:55,000 --> 01:15:56,000
对啊

1578
01:15:56,000 --> 01:15:58,000
然后在西文大小写里面

1579
01:15:58,000 --> 01:16:00,000
这种就会经常导致各种

1580
01:16:00,000 --> 01:16:03,000
这种所谓的叫做胜战对吧

1581
01:16:03,000 --> 01:16:07,000
这种各种坚持一定要某一种写法才对

1582
01:16:07,000 --> 01:16:10,000
另外一种某种写法才更合理的

1583
01:16:10,000 --> 01:16:12,000
这种争论是一直都存在

1584
01:16:12,000 --> 01:16:14,000
而且我估计在我们死后

1585
01:16:14,000 --> 01:16:16,000
它应该还是会继续存在的

1586
01:16:16,000 --> 01:16:18,000
其实它怎么大小写

1587
01:16:18,000 --> 01:16:21,000
还是由 API 的设计者

1588
01:16:21,000 --> 01:16:23,000
他当时拍脑袋想的吧

1589
01:16:23,000 --> 01:16:25,000
因为我们这边有 web 开发者

1590
01:16:25,000 --> 01:16:29,000
那个 xml,http request 里面就是 xml 全大写

1591
01:16:29,000 --> 01:16:31,000
但 http 又不是全大写

1592
01:16:31,000 --> 01:16:33,000
很奇怪对不对

1593
01:16:33,000 --> 01:16:34,000
对啊

1594
01:16:34,000 --> 01:16:38,000
所以这个完全是看那个开发者当时他拍脑袋

1595
01:16:38,000 --> 01:16:40,000
他觉得这样写比较优雅

1596
01:16:40,000 --> 01:16:41,000
他就这么写

1597
01:16:41,000 --> 01:16:42,000
看心情

1598
01:16:42,000 --> 01:16:45,000
没有今天我们讲的是命名规则嘛

1599
01:16:45,000 --> 01:16:48,000
像这种东西很多时候就是有规则

1600
01:16:48,000 --> 01:16:50,000
有的地方是没规则

1601
01:16:50,000 --> 01:16:52,000
然后一个语言里面他有时候定了一个规则

1602
01:16:52,000 --> 01:16:53,000
他自己都不同意

1603
01:16:53,000 --> 01:16:55,000
经常会有这种事情

1604
01:16:55,000 --> 01:16:57,000
对每个公司它有自己的 convention

1605
01:16:57,000 --> 01:16:59,000
毕竟它是一个 convention 嘛

1606
01:16:59,000 --> 01:17:01,000
它还是一种约定

1607
01:17:01,000 --> 01:17:04,000
它没有一种很强制的机制去约束它

1608
01:17:04,000 --> 01:17:07,000
比如说如果有一个什么机器检测的机制

1609
01:17:07,000 --> 01:17:09,000
禁止它做某件事情

1610
01:17:09,000 --> 01:17:12,000
那它可能这个规则才会非常的强力的

1611
01:17:12,000 --> 01:17:14,000
然后 comply 不过是吧

1612
01:17:16,000 --> 01:17:18,000
但从实用主义角度来讲

1613
01:17:18,000 --> 01:17:22,000
因为你用 caml case 来解决什么问题

1614
01:17:22,000 --> 01:17:25,000
是解决不能用空格分词

1615
01:17:25,000 --> 01:17:29,000
也让我们后面又讲用下滑线也是一个办法

1616
01:17:29,000 --> 01:17:31,000
如果不能用空格也不用下滑线的

1617
01:17:31,000 --> 01:17:33,000
因为我认为下滑线是一个空格的变种

1618
01:17:33,000 --> 01:17:36,000
那不能用空格也不能用下滑线的情况下

1619
01:17:36,000 --> 01:17:40,000
你要用大小写来展示词与词句的区别

1620
01:17:40,000 --> 01:17:41,000
那很陷阳

1621
01:17:41,000 --> 01:17:44,000
这种情况下你就不应该把那种全大写的词

1622
01:17:44,000 --> 01:17:46,000
都真的全大写

1623
01:17:46,000 --> 01:17:48,000
这样的话你看不清楚它的边界在哪里

1624
01:17:48,000 --> 01:17:51,000
就好像刚才你说的 XML HGTB request 的情况下

1625
01:17:51,000 --> 01:17:54,000
那 XML HGTB 这是一个东西还是两个东西

1626
01:17:54,000 --> 01:17:55,000
对吧

1627
01:17:55,000 --> 01:18:00,000
原教义的那种 caml case 还是比较适合阅读的

1628
01:18:00,000 --> 01:18:01,000
虽然说看起来比较丑

1629
01:18:01,000 --> 01:18:03,000
为什么 XML 是这么一种写法

1630
01:18:03,000 --> 01:18:05,000
就好奇怪感觉怪怪的

1631
01:18:05,000 --> 01:18:07,000
但从读的角度来讲

1632
01:18:07,000 --> 01:18:09,000
或者从分词的这个角度来看

1633
01:18:09,000 --> 01:18:12,000
你还是要去找到它东西的本质是什么

1634
01:18:12,000 --> 01:18:13,000
它本质不是为了好看

1635
01:18:13,000 --> 01:18:15,000
它本质是为了 clarity

1636
01:18:15,000 --> 01:18:16,000
为了清晰

1637
01:18:16,000 --> 01:18:17,000
对吧

1638
01:18:17,000 --> 01:18:19,000
这是一种命名方式

1639
01:18:19,000 --> 01:18:20,000
第二种命名方式就是跟他讲

1640
01:18:20,000 --> 01:18:21,000
空格是肯定不行的

1641
01:18:21,000 --> 01:18:23,000
那为什么我说下划线是空格里面变轴的

1642
01:18:23,000 --> 01:18:25,000
因为下划线它其实就是

1643
01:18:25,000 --> 01:18:29,000
空格那里那个位置变成了一条线

1644
01:18:29,000 --> 01:18:34,000
然后下划线其实有一个区别是比较要紧的

1645
01:18:34,000 --> 01:18:38,000
就是在用鼠标双击选词的时候

1646
01:18:38,000 --> 01:18:40,000
下划线它不会把那个词断开

1647
01:18:40,000 --> 01:18:42,000
这个其实是蛮有用的

1648
01:18:42,000 --> 01:18:43,000
比如说什么意思

1649
01:18:43,000 --> 01:18:46,000
就是说你想想 hello world

1650
01:18:46,000 --> 01:18:47,000
如果你是空格断开

1651
01:18:47,000 --> 01:18:50,000
它肯定你点击我们默认是双击是选一个词

1652
01:18:50,000 --> 01:18:51,000
对吧

1653
01:18:51,000 --> 01:18:52,000
一个 word

1654
01:18:52,000 --> 01:18:53,000
那应该只会选到 hello

1655
01:18:53,000 --> 01:18:55,000
然后它选不到后面那个 word

1656
01:18:55,000 --> 01:18:57,000
它如果说你用下划线把 hello world 连起来之后

1657
01:18:57,000 --> 01:18:59,000
你在大多数的图形界面

1658
01:18:59,000 --> 01:19:01,000
你用双击的方式去选这个词

1659
01:19:01,000 --> 01:19:02,000
它会把整个 hello 下划线

1660
01:19:02,000 --> 01:19:03,000
都圈起来

1661
01:19:03,000 --> 01:19:05,000
都选都高量选择起来

1662
01:19:05,000 --> 01:19:06,000
对不对

1663
01:19:06,000 --> 01:19:08,000
这个其实还是蛮有用的

1664
01:19:08,000 --> 01:19:13,000
这交互设计为了优化这种字符创想这么做

1665
01:19:13,000 --> 01:19:14,000
对

1666
01:19:14,000 --> 01:19:16,000
它避免了大小写的那个尊端

1667
01:19:16,000 --> 01:19:19,000
这个时候你怎么就大小写就全看你的心情了

1668
01:19:19,000 --> 01:19:23,000
因为它跟语意和分词都不影响了

1669
01:19:23,000 --> 01:19:27,000
你都可以比如说刚刚那个 XML 下划线 HTTP

1670
01:19:27,000 --> 01:19:28,000
下划线 request

1671
01:19:28,000 --> 01:19:29,000
你都可以这么写

1672
01:19:29,000 --> 01:19:30,000
其实不影响这个了

1673
01:19:30,000 --> 01:19:32,000
那现在就是好看的问题了

1674
01:19:32,000 --> 01:19:37,000
不过理论上讲就是用下划线的话就没那么爱野

1675
01:19:37,000 --> 01:19:38,000
说实话

1676
01:19:38,000 --> 01:19:41,000
既有这个空格的空间感

1677
01:19:41,000 --> 01:19:43,000
然后也没那么爱野

1678
01:19:43,000 --> 01:19:44,000
然后因为它是在下划线

1679
01:19:44,000 --> 01:19:46,000
所以它这个名字就叫 Snake Case

1680
01:19:46,000 --> 01:19:47,000
就像是蛇

1681
01:19:47,000 --> 01:19:51,000
在地上爬蛇

1682
01:19:51,000 --> 01:19:52,000
超形象的

1683
01:19:52,000 --> 01:19:54,000
我觉得这几个名字都超形象的

1684
01:19:54,000 --> 01:19:56,000
像下划线的 Snake

1685
01:19:56,000 --> 01:19:58,000
名字符叫 K-bob 对吧

1686
01:19:58,000 --> 01:19:59,000
烤肉

1687
01:19:59,000 --> 01:20:00,000
烤串

1688
01:20:00,000 --> 01:20:01,000
烤串 case

1689
01:20:01,000 --> 01:20:02,000
啥意思

1690
01:20:02,000 --> 01:20:03,000
就像一个串

1691
01:20:03,000 --> 01:20:07,000
串在下面好多肉叉烧一样的感觉

1692
01:20:07,000 --> 01:20:10,000
这一看就是吃货去的

1693
01:20:10,000 --> 01:20:12,000
这个东西有中文翻译吗

1694
01:20:12,000 --> 01:20:13,000
肉夹馍对不对

1695
01:20:13,000 --> 01:20:14,000
就是肉夹馍

1696
01:20:14,000 --> 01:20:15,000
肉夹馍

1697
01:20:15,000 --> 01:20:18,000
字面意义上 Dunas K-bob 是旋转烧烤的意思

1698
01:20:18,000 --> 01:20:22,000
Dunas 是旋转 K-bob 是烧烤

1699
01:20:22,000 --> 01:20:25,000
然后连那起叫

1700
01:20:25,000 --> 01:20:30,000
K-bob 实际上是 Dunas K-bob 的简称

1701
01:20:30,000 --> 01:20:33,000
就是土耳其烤肉的简称

1702
01:20:33,000 --> 01:20:35,000
但是就是在 K-bob 这个词

1703
01:20:35,000 --> 01:20:37,000
在进入这个英语语系里面

1704
01:20:37,000 --> 01:20:39,000
它其实就是我们理解的那个串

1705
01:20:39,000 --> 01:20:40,000
对

1706
01:20:40,000 --> 01:20:41,000
烤吧

1707
01:20:41,000 --> 01:20:42,000
不是串

1708
01:20:42,000 --> 01:20:45,000
Dunas 是旋转 K-bob 是烤

1709
01:20:45,000 --> 01:20:47,000
K-bob 是烤的意思

1710
01:20:47,000 --> 01:20:48,000
对

1711
01:20:48,000 --> 01:20:50,000
但是我就说你在英语

1712
01:20:50,000 --> 01:20:52,000
Ryo 的语意是说

1713
01:20:52,000 --> 01:20:55,000
这个东西语意变成了 shashlik

1714
01:20:55,000 --> 01:20:56,000
对

1715
01:20:56,000 --> 01:20:58,000
变成一个串着一起的东西串

1716
01:20:58,000 --> 01:21:01,000
对像竹圈穿起来这样一个东西

1717
01:21:01,000 --> 01:21:03,000
有一个罐在中间很细

1718
01:21:03,000 --> 01:21:05,000
然后上面有一堆更宽的一个物件

1719
01:21:05,000 --> 01:21:07,000
这个就是英文里面的 K-bob

1720
01:21:07,000 --> 01:21:09,000
目前它展示了这个

1721
01:21:09,000 --> 01:21:11,000
也是这个 K-bob case 的这个意思

1722
01:21:11,000 --> 01:21:12,000
对

1723
01:21:13,000 --> 01:21:16,000
这个叫 Culture case

1724
01:21:16,000 --> 01:21:18,000
Try 这个字其实还是蛮形象

1725
01:21:18,000 --> 01:21:20,000
这要是日本人来起的话

1726
01:21:20,000 --> 01:21:22,000
就会变成那个鸟串烧

1727
01:21:22,000 --> 01:21:24,000
串鸟烧

1728
01:21:24,000 --> 01:21:25,000
对

1729
01:21:25,000 --> 01:21:26,000
但 K-bob case 有一个问题

1730
01:21:26,000 --> 01:21:29,000
就是它并不是所有的语言都支持

1731
01:21:29,000 --> 01:21:31,000
因为横线

1732
01:21:31,000 --> 01:21:32,000
不是用下滑线

1733
01:21:32,000 --> 01:21:34,000
是用连则符或者叫减号

1734
01:21:34,000 --> 01:21:35,000
对吧

1735
01:21:35,000 --> 01:21:36,000
它其实是有别的含义

1736
01:21:36,000 --> 01:21:37,000
就是 A-B 的

1737
01:21:37,000 --> 01:21:38,000
也就是 K-bob

1738
01:21:38,000 --> 01:21:39,000
然后杠这个 case

1739
01:21:39,000 --> 01:21:40,000
它可能是一个

1740
01:21:40,000 --> 01:21:42,000
它认为你叫执行一个

1741
01:21:42,000 --> 01:21:44,000
就是数学的减的一个操作

1742
01:21:44,000 --> 01:21:45,000
所以这个其实在很多语言里面

1743
01:21:45,000 --> 01:21:47,000
其实是不支持这种方式的

1744
01:21:47,000 --> 01:21:50,000
K-bob case 最常见的就是在 CSS 里面吗

1745
01:21:50,000 --> 01:21:51,000
很啰嗦

1746
01:21:51,000 --> 01:21:52,000
对 这也是因为 CSS

1747
01:21:52,000 --> 01:21:54,000
其实不进行计算的一个原因导致的

1748
01:21:54,000 --> 01:21:55,000
它没有这个 Compute

1749
01:21:55,000 --> 01:21:57,000
除非用 Calk 那个

1750
01:21:57,000 --> 01:21:58,000
它需要空格

1751
01:21:58,000 --> 01:22:00,000
CSS 现在不是支持 Calk 吗

1752
01:22:00,000 --> 01:22:01,000
所以你在 Calk 里面

1753
01:22:01,000 --> 01:22:02,000
你要想写减号的话

1754
01:22:02,000 --> 01:22:04,000
减号前后一定要有空格

1755
01:22:04,000 --> 01:22:07,000
而且这空格不能被压缩掉

1756
01:22:07,000 --> 01:22:08,000
对

1757
01:22:08,000 --> 01:22:09,000
不像有些空格可以压缩

1758
01:22:09,000 --> 01:22:10,000
就是那个

1759
01:22:10,000 --> 01:22:12,000
叫做语意敏感的空格

1760
01:22:12,000 --> 01:22:13,000
对

1761
01:22:13,000 --> 01:22:15,000
这个其实也挺不和谐

1762
01:22:18,000 --> 01:22:19,000
但是你看就是

1763
01:22:19,000 --> 01:22:21,000
它其实这种历史背景的原因

1764
01:22:21,000 --> 01:22:22,000
过去没有运算

1765
01:22:22,000 --> 01:22:24,000
所以我用这个下下线

1766
01:22:24,000 --> 01:22:25,000
用这个叫什么

1767
01:22:25,000 --> 01:22:27,000
不叫减号这样的这个横线

1768
01:22:27,000 --> 01:22:29,000
其实没有什么区别

1769
01:22:29,000 --> 01:22:30,000
对吧

1770
01:22:30,000 --> 01:22:31,000
但是后来发现

1771
01:22:31,000 --> 01:22:32,000
你现在要运算了不

1772
01:22:32,000 --> 01:22:33,000
怎么办

1773
01:22:33,000 --> 01:22:34,000
其实一切都是

1774
01:22:34,000 --> 01:22:36,000
都是以路径依赖的功能

1775
01:22:36,000 --> 01:22:38,000
假如当初键盘设计的时候

1776
01:22:38,000 --> 01:22:40,000
能明确区分连字符和减号

1777
01:22:40,000 --> 01:22:42,000
现在可能也就没有这个问题了

1778
01:22:42,000 --> 01:22:43,000
所以

1779
01:22:43,000 --> 01:22:44,000
我觉得这也区分不了吧

1780
01:22:44,000 --> 01:22:45,000
这个很难

1781
01:22:45,000 --> 01:22:46,000
对对对

1782
01:22:46,000 --> 01:22:47,000
对于人来说

1783
01:22:47,000 --> 01:22:49,000
在我们人类在非常自然的情况下

1784
01:22:49,000 --> 01:22:51,000
是不会去考虑一个符号的语意

1785
01:22:51,000 --> 01:22:52,000
跟这个符号的表现

1786
01:22:52,000 --> 01:22:53,000
是可以分开的

1787
01:22:53,000 --> 01:22:54,000
这个问题

1788
01:22:54,000 --> 01:22:55,000
就是我们看到

1789
01:22:55,000 --> 01:22:56,000
不精确的物种

1790
01:22:56,000 --> 01:22:57,000
对我们看到一个短恒

1791
01:22:57,000 --> 01:22:59,000
一定会根据上下文来判断

1792
01:22:59,000 --> 01:23:00,000
它到底是个减号

1793
01:23:00,000 --> 01:23:01,000
还是一个 hyphen 的对吧

1794
01:23:01,000 --> 01:23:02,000
但是计算机没有这个功能

1795
01:23:03,000 --> 01:23:04,000
其实这个是阿拉伯人的问题

1796
01:23:04,000 --> 01:23:05,000
对不对

1797
01:23:05,000 --> 01:23:06,000
为什么要用短行来表示减

1798
01:23:08,000 --> 01:23:10,000
你用一个更加特殊的符号来表示减

1799
01:23:10,000 --> 01:23:11,000
不就更好吗

1800
01:23:11,000 --> 01:23:13,000
这是阿拉伯人发明的吗

1801
01:23:13,000 --> 01:23:13,000
是吧

1802
01:23:14,000 --> 01:23:14,000
喂

1803
01:23:14,000 --> 01:23:16,000
我们现在加减乘除

1804
01:23:16,000 --> 01:23:18,000
四个符号中什么时候开始确定这个标准

1805
01:23:18,000 --> 01:23:20,000
诚号至少是非常不同意的

1806
01:23:20,000 --> 01:23:23,000
历史上诚号有很多种表示方法

1807
01:23:23,000 --> 01:23:26,000
诚号我们只会在那个地方

1808
01:23:26,000 --> 01:23:27,000
就只会在惩罚里面用

1809
01:23:27,000 --> 01:23:29,000
日常的这个叫什么

1810
01:23:29,000 --> 01:23:30,000
日常排版里面并不会用到

1811
01:23:30,000 --> 01:23:31,000
抛不出一个想法

1812
01:23:31,000 --> 01:23:33,000
因为中国古代也不是用减号了

1813
01:23:33,000 --> 01:23:34,000
对吧

1814
01:23:34,000 --> 01:23:35,000
中国古代减号是啥

1815
01:23:38,000 --> 01:23:39,000
所有人都卡了

1816
01:23:39,000 --> 01:23:41,000
对自己国家的文化这么不了解

1817
01:23:41,000 --> 01:23:42,000
你看看你们

1818
01:23:42,000 --> 01:23:44,000
九章算数对不对

1819
01:23:46,000 --> 01:23:48,000
现在阿拉伯人其实不用阿拉伯数字

1820
01:23:48,000 --> 01:23:51,000
阿拉伯数字实际上是西方对印度数字一套

1821
01:23:51,000 --> 01:23:53,000
一套称呼

1822
01:23:53,000 --> 01:23:55,000
所以我怀疑阿拉伯人其实也不是用减号

1823
01:23:55,000 --> 01:23:57,000
所以你不能把锅栽到阿拉伯人头上

1824
01:23:57,000 --> 01:23:58,000
阿拉伯兄弟们已经背了太多锅了

1825
01:23:59,000 --> 01:23:59,000
好的

1826
01:23:59,000 --> 01:24:01,000
那就是 whoever 发明这套东西的时候

1827
01:24:01,000 --> 01:24:03,000
他就没想过这个

1828
01:24:03,000 --> 01:24:05,000
不过你其实你这么想

1829
01:24:05,000 --> 01:24:07,000
加减乘除那四个符号里面

1830
01:24:07,000 --> 01:24:09,000
除了加和乘其他两个都是有奇异的问题的

1831
01:24:09,000 --> 01:24:11,000
除如果你是用那个除还好

1832
01:24:11,000 --> 01:24:13,000
就是如果这斜杠除也是有这个问题的

1833
01:24:13,000 --> 01:24:15,000
那其实还是减号的问题比较多

1834
01:24:16,000 --> 01:24:16,000
对吧

1835
01:24:16,000 --> 01:24:17,000
反过来说

1836
01:24:17,000 --> 01:24:18,000
现在英语键盘上

1837
01:24:18,000 --> 01:24:20,000
就是我有时候觉得挺不可思议的

1838
01:24:20,000 --> 01:24:23,000
打字机键盘上居然没有成号这个符号

1839
01:24:23,000 --> 01:24:25,000
就当初发明打字机的人

1840
01:24:25,000 --> 01:24:26,000
会认为 X 和你用

1841
01:24:27,000 --> 01:24:28,000
你用 X 来替代成号就好了

1842
01:24:28,000 --> 01:24:31,000
真的路径依赖导致了很多很多问题

1843
01:24:31,000 --> 01:24:33,000
你要说这个键盘的话

1844
01:24:33,000 --> 01:24:37,000
当年的键盘连小写字母 O 和数字 0

1845
01:24:37,000 --> 01:24:38,000
都可以用一个键位

1846
01:24:38,000 --> 01:24:38,000
对

1847
01:24:38,000 --> 01:24:39,000
那个可以理解

1848
01:24:39,000 --> 01:24:42,000
因为造个打字机机械那么复杂

1849
01:24:42,000 --> 01:24:43,000
能少一个还是能省不少

1850
01:24:43,000 --> 01:24:44,000
这个是杂性的

1851
01:24:44,000 --> 01:24:45,000
在机械打字机的情况下

1852
01:24:45,000 --> 01:24:47,000
成号跟 X 的话那不一样

1853
01:24:47,000 --> 01:24:50,000
赋予这个字符以一个固定的语意

1854
01:24:50,000 --> 01:24:54,000
其实我觉得是很计算机时代的一个事情

1855
01:24:54,000 --> 01:24:57,000
因为机器才需要去识别这些事情

1856
01:24:57,000 --> 01:25:00,000
人是一个通过语境和上下文

1857
01:25:00,000 --> 01:25:03,000
来判断符号意义的动物

1858
01:25:03,000 --> 01:25:05,000
他不是要背下来这个符号

1859
01:25:05,000 --> 01:25:07,000
或者说他根本就不可能知道

1860
01:25:07,000 --> 01:25:10,000
一个符号在抽象的一种数据结构里面

1861
01:25:10,000 --> 01:25:11,000
是一个什么东西

1862
01:25:11,000 --> 01:25:12,000
他只是看到它

1863
01:25:12,000 --> 01:25:12,000
他才知道

1864
01:25:12,000 --> 01:25:14,000
这该死的神经网络对吧

1865
01:25:14,000 --> 01:25:16,000
好了我们不讲这个东西了

1866
01:25:16,000 --> 01:25:18,000
我们以后接着回来讲我们控格的试试

1867
01:25:18,000 --> 01:25:19,000
另外常见的一个秘密

1868
01:25:19,000 --> 01:25:22,000
就是我们各种网站的

1869
01:25:22,000 --> 01:25:23,000
UiL 的

1870
01:25:23,000 --> 01:25:25,000
UiL 是不能有控格的

1871
01:25:25,000 --> 01:25:26,000
我想想

1872
01:25:26,000 --> 01:25:26,000
对

1873
01:25:26,000 --> 01:25:30,000
UiL 联盟的控格会被编码掉

1874
01:25:30,000 --> 01:25:31,000
被转移掉

1875
01:25:31,000 --> 01:25:32,000
变成是多少

1876
01:25:32,000 --> 01:25:32,000
20%

1877
01:25:33,000 --> 01:25:34,000
20%

1878
01:25:34,000 --> 01:25:38,000
然后我们常见的所谓用户名对吧

1879
01:25:38,000 --> 01:25:40,000
其实我们或者比如说你推特的

1880
01:25:40,000 --> 01:25:41,000
我们叫 handle 对吧

1881
01:25:41,000 --> 01:25:43,000
邮件的邮箱的

1882
01:25:43,000 --> 01:25:44,000
那个就是

1883
01:25:44,000 --> 01:25:45,000
那个 at

1884
01:25:45,000 --> 01:25:47,000
符号前面那部分也是不能有控格的

1885
01:25:47,000 --> 01:25:48,000
通常是这样子

1886
01:25:48,000 --> 01:25:49,000
为什么

1887
01:25:49,000 --> 01:25:50,000
因为就看他说那个问题

1888
01:25:50,000 --> 01:25:53,000
你什么时候才能确定它是不是一个

1889
01:25:54,000 --> 01:25:55,000
完整的

1890
01:25:55,000 --> 01:25:56,000
词对吧

1891
01:25:56,000 --> 01:25:57,000
跟刚才那个 attentive file 其实是一样的

1892
01:25:57,000 --> 01:25:59,000
这两个其实它本质上都是 attentive file

1893
01:25:59,000 --> 01:26:00,000
对不对

1894
01:26:00,000 --> 01:26:00,000
标识符

1895
01:26:01,000 --> 01:26:02,000
那么

1896
01:26:02,000 --> 01:26:03,000
可能显然也是不能有控格的

1897
01:26:03,000 --> 01:26:05,000
那就是你得想说

1898
01:26:05,000 --> 01:26:06,000
那就可以用下滑线

1899
01:26:06,000 --> 01:26:08,000
基本上下滑线

1900
01:26:08,000 --> 01:26:09,000
都是可以用的对吧

1901
01:26:09,000 --> 01:26:10,000
但就是说那个

1902
01:26:10,000 --> 01:26:11,000
就是横线或者是减号

1903
01:26:11,000 --> 01:26:13,000
或者你叫连字符也好

1904
01:26:13,000 --> 01:26:14,000
这个能不能用

1905
01:26:14,000 --> 01:26:15,000
其实就取决于各个系统了

1906
01:26:19,000 --> 01:26:21,000
这个断词总是一个很纠结的事情

1907
01:26:21,000 --> 01:26:24,000
因为西方他们必须要用一个控格断词

1908
01:26:24,000 --> 01:26:26,000
然后遇到不能用控格的时候

1909
01:26:26,000 --> 01:26:27,000
他们就老纠结了

1910
01:26:28,000 --> 01:26:29,000
可以想办法跟他们解决法案

1911
01:26:30,000 --> 01:26:32,000
你看现在那个 Twitter 的那个

1912
01:26:32,000 --> 01:26:34,000
用那个 hashtag

1913
01:26:34,000 --> 01:26:35,000
那个标签

1914
01:26:36,000 --> 01:26:37,000
那个也是好烦的

1915
01:26:37,000 --> 01:26:41,000
现在他们那个 API 有时候认那个标签的话

1916
01:26:41,000 --> 01:26:45,000
也是得手工加控格才

1917
01:26:45,000 --> 01:26:47,000
才会

1918
01:26:47,000 --> 01:26:49,000
认担着一个那个标签吗

1919
01:26:50,000 --> 01:26:51,000
因为他不然你不知道你

1920
01:26:51,000 --> 01:26:53,000
你断到哪个地方他不知道呀

1921
01:26:54,000 --> 01:26:54,000
对呀

1922
01:26:54,000 --> 01:26:56,000
他现在有一些优化吧

1923
01:26:56,000 --> 01:26:58,000
就是如果你输入一些很明显

1924
01:26:59,000 --> 01:27:00,000
是标点符号的

1925
01:27:00,000 --> 01:27:01,000
或者是特殊符号的字符

1926
01:27:01,000 --> 01:27:02,000
他会给你断开

1927
01:27:02,000 --> 01:27:04,000
至少我知道汉语的那些标点

1928
01:27:04,000 --> 01:27:05,000
他都会给你断开

1929
01:27:06,000 --> 01:27:07,000
你说到这个我想起来

1930
01:27:07,000 --> 01:27:09,000
Twitter 的那个 hashtag

1931
01:27:09,000 --> 01:27:10,000
好像不支持 high 分

1932
01:27:10,000 --> 01:27:12,000
就是你的 tag 里面不能有 high 分

1933
01:27:13,000 --> 01:27:14,000
没有他跟那个呀

1934
01:27:14,000 --> 01:27:15,000
他跟用户名是一样的

1935
01:27:15,000 --> 01:27:16,000
推运用户名也不能有 high 分

1936
01:27:16,000 --> 01:27:18,000
你只能用下滑线

1937
01:27:20,000 --> 01:27:21,000
所以他本知道

1938
01:27:21,000 --> 01:27:23,000
你说你回到刚才那个问题

1939
01:27:23,000 --> 01:27:23,000
就是说

1940
01:27:24,000 --> 01:27:27,000
hashtag 这个 tag 本身是个什么东西

1941
01:27:27,000 --> 01:27:28,000
它就是一个 attentive

1942
01:27:28,000 --> 01:27:29,000
如果说它是 attentive

1943
01:27:29,000 --> 01:27:31,000
你想到在编程里面你什么时候

1944
01:27:31,000 --> 01:27:32,000
你是不是觉得他都是

1945
01:27:32,000 --> 01:27:34,000
对方都不能用这个简号

1946
01:27:34,000 --> 01:27:34,000
对不对

1947
01:27:34,000 --> 01:27:35,000
那其实也是一个道理

1948
01:27:38,000 --> 01:27:40,000
到时候中文语境下面

1949
01:27:40,000 --> 01:27:41,000
这个问题就比较

1950
01:27:41,000 --> 01:27:42,000
比较奇怪了

1951
01:27:42,000 --> 01:27:43,000
你说微博他是用两个

1952
01:27:43,000 --> 01:27:44,000
他其实把那个

1953
01:27:45,000 --> 01:27:47,000
警号键当成引号来用

1954
01:27:47,000 --> 01:27:47,000
对不对

1955
01:27:48,000 --> 01:27:49,000
两个圈起来的才是

1956
01:27:49,000 --> 01:27:50,000
因为中文不分词

1957
01:27:51,000 --> 01:27:52,000
你不加一个后面来

1958
01:27:52,000 --> 01:27:53,000
你不知道这个

1959
01:27:53,000 --> 01:27:55,000
到什么地方结束吗

1960
01:27:55,000 --> 01:27:56,000
对问题就来了

1961
01:27:57,000 --> 01:27:58,000
我是警号

1962
01:27:59,000 --> 01:28:01,000
标签警号标签警号

1963
01:28:01,000 --> 01:28:02,000
这个时候算啥

1964
01:28:02,000 --> 01:28:04,000
你说配对问题是吗

1965
01:28:04,000 --> 01:28:05,000
对配对问题

1966
01:28:05,000 --> 01:28:06,000
就是有这个问题了

1967
01:28:06,000 --> 01:28:08,000
另外一个问题是吧

1968
01:28:08,000 --> 01:28:10,000
对

1969
01:28:10,000 --> 01:28:11,000
因为引号其实也是一个

1970
01:28:11,000 --> 01:28:12,000
非常坑爹的事情

1971
01:28:12,000 --> 01:28:14,000
正常说我们引号是有

1972
01:28:14,000 --> 01:28:16,000
开引号关引号的区别的

1973
01:28:17,000 --> 01:28:17,000
关键是对吧

1974
01:28:17,000 --> 01:28:18,000
为了

1975
01:28:19,000 --> 01:28:21,000
打字机我们为了省那个

1976
01:28:21,000 --> 01:28:21,000
钱为

1977
01:28:21,000 --> 01:28:22,000
我们有何二为一

1978
01:28:22,000 --> 01:28:24,000
只搞一个了对不对

1979
01:28:24,000 --> 01:28:25,000
对啊

1980
01:28:25,000 --> 01:28:26,000
所以我们做字体排印的

1981
01:28:26,000 --> 01:28:27,000
就生物痛绝的

1982
01:28:27,000 --> 01:28:29,000
千万不要用傻关引号

1983
01:28:29,000 --> 01:28:31,000
结果都是打字机惹的祸

1984
01:28:31,000 --> 01:28:32,000
对啊

1985
01:28:32,000 --> 01:28:32,000
就是为了

1986
01:28:32,000 --> 01:28:34,000
也不叫他打字机惹的祸吧

1987
01:28:34,000 --> 01:28:36,000
就是为了省钱导致

1988
01:28:37,000 --> 01:28:38,000
都是没钱

1989
01:28:39,000 --> 01:28:41,000
所以微博双警号

1990
01:28:41,000 --> 01:28:43,000
他就是你把它想成

1991
01:28:43,000 --> 01:28:44,000
引号的用法来用就行了

1992
01:28:44,000 --> 01:28:45,000
或者想成是

1993
01:28:45,000 --> 01:28:46,000
数名号都不算

1994
01:28:46,000 --> 01:28:47,000
数名号这两个是不一样的

1995
01:28:48,000 --> 01:28:50,000
就引号的这种方式来用就可以了

1996
01:28:50,000 --> 01:28:52,000
所以其实我觉得以后

1997
01:28:52,000 --> 01:28:53,000
要发明什么新的方式的

1998
01:28:53,000 --> 01:28:55,000
这种 quoting 的方式的时候

1999
01:28:55,000 --> 01:28:56,000
一定要配对

2000
01:28:56,000 --> 01:28:58,000
不要用引号来引

2001
01:28:58,000 --> 01:29:00,000
你就用数名号好了

2002
01:29:00,000 --> 01:29:00,000
对吧

2003
01:29:00,000 --> 01:29:02,000
或者用发框号来引

2004
01:29:02,000 --> 01:29:03,000
对框弧对吧

2005
01:29:03,000 --> 01:29:05,000
因为基本上框弧都是

2006
01:29:05,000 --> 01:29:08,000
肯定是有开关两个的

2007
01:29:08,000 --> 01:29:12,000
然后还得让他自动配对

2008
01:29:12,000 --> 01:29:14,000
然后还允许嵌套是吧

2009
01:29:15,000 --> 01:29:16,000
大跨国小跨国中跨国

2010
01:29:16,000 --> 01:29:17,000
对

2011
01:29:17,000 --> 01:29:19,000
这样发现你在写 Lisp

2012
01:29:21,000 --> 01:29:23,000
所以就不用去数缩进

2013
01:29:23,000 --> 01:29:24,000
或者怎么样是吧

2014
01:29:24,000 --> 01:29:24,000
对啊

2015
01:29:24,000 --> 01:29:26,000
就完全藐视缩进

2016
01:29:26,000 --> 01:29:27,000
缩进本来就很反人了

2017
01:29:28,000 --> 01:29:29,000
就是说你凭什么

2018
01:29:29,000 --> 01:29:31,000
你凭什么判断这一行

2019
01:29:31,000 --> 01:29:32,000
前面有 10 个空格

2020
01:29:32,000 --> 01:29:34,000
你凭什么要求我写程序

2021
01:29:34,000 --> 01:29:36,000
还要带着一把悠悠卡尺

2022
01:29:38,000 --> 01:29:42,000
就是一条 Python 梗

2023
01:29:42,000 --> 01:29:45,000
我把这个链接放在许诺词里面

2024
01:29:47,000 --> 01:29:48,000
笑死我了

2025
01:29:48,000 --> 01:29:50,000
不过现在 Camel Case

2026
01:29:50,000 --> 01:29:52,000
就把这个词越念越长了

2027
01:29:52,000 --> 01:29:54,000
现在特别是那个什么

2028
01:29:54,000 --> 01:29:55,000
Object C

2029
01:29:55,000 --> 01:29:57,000
咱们那种啰啰嗦嗦的语言

2030
01:29:57,000 --> 01:29:57,000
哇

2031
01:29:57,000 --> 01:29:59,000
他的名字超长的

2032
01:29:59,000 --> 01:30:00,000
那个 API 的名字

2033
01:30:00,000 --> 01:30:01,000
那简直了

2034
01:30:01,000 --> 01:30:02,000
我之前是不知道

2035
01:30:02,000 --> 01:30:03,000
就是比如说我们现在很多

2036
01:30:03,000 --> 01:30:05,000
你用的这个 iOS 的手机 APP

2037
01:30:05,000 --> 01:30:06,000
很多

2038
01:30:06,000 --> 01:30:07,000
因为现在好像开始变少

2039
01:30:07,000 --> 01:30:09,000
以前都是这个所谓的

2040
01:30:09,000 --> 01:30:10,000
Object C 这个语言写的

2041
01:30:11,000 --> 01:30:13,000
然后现在有 SWIP 这个语言

2042
01:30:13,000 --> 01:30:14,000
写可能会好一些

2043
01:30:14,000 --> 01:30:16,000
Object C 这个语言的命名规则

2044
01:30:16,000 --> 01:30:17,000
真是太奇怪了

2045
01:30:17,000 --> 01:30:18,000
他就要把一个 API 的

2046
01:30:19,000 --> 01:30:20,000
那个全部写全

2047
01:30:20,000 --> 01:30:21,000
一个 API 的一个

2048
01:30:21,000 --> 01:30:22,000
一个叫什么

2049
01:30:22,000 --> 01:30:23,000
一个参数

2050
01:30:23,000 --> 01:30:26,000
就是五个单词写全

2051
01:30:26,000 --> 01:30:26,000
对

2052
01:30:26,000 --> 01:30:27,000
他的 Message Signature

2053
01:30:27,000 --> 01:30:28,000
就是叫什么

2054
01:30:28,000 --> 01:30:31,000
方法签名是非常长的

2055
01:30:31,000 --> 01:30:32,000
就你认为他就是一个函数名

2056
01:30:32,000 --> 01:30:33,000
你可以这么理解对吧

2057
01:30:33,000 --> 01:30:33,000
对

2058
01:30:34,000 --> 01:30:35,000
这函数名都是要写全

2059
01:30:35,000 --> 01:30:36,000
我们通常都是

2060
01:30:36,000 --> 01:30:38,000
不是按我们过去 C 的那个

2061
01:30:38,000 --> 01:30:40,000
都写非常简短的吧

2062
01:30:40,000 --> 01:30:42,000
C 他是可以把单词缩写吗

2063
01:30:42,000 --> 01:30:44,000
这一切都要归功于 Smalltalk

2064
01:30:44,000 --> 01:30:46,000
就 Smalltalk 就有这一套

2065
01:30:46,000 --> 01:30:47,000
就是一个参数

2066
01:30:47,000 --> 01:30:48,000
有两个名字

2067
01:30:48,000 --> 01:30:50,000
一个是外调用者看到的名字

2068
01:30:50,000 --> 01:30:52,000
另外一个是参数内部看到的名字

2069
01:30:52,000 --> 01:30:53,000
这个其实

2070
01:30:53,000 --> 01:30:54,000
我觉得非常合理的

2071
01:30:54,000 --> 01:30:56,000
就哪怕现在 Swift

2072
01:30:56,000 --> 01:30:57,000
你看他还是继承了这一套

2073
01:30:57,000 --> 01:30:59,000
就这东西还是蛮有用的

2074
01:30:59,000 --> 01:31:00,000
而且

2075
01:31:01,000 --> 01:31:01,000
怎么说呢

2076
01:31:01,000 --> 01:31:02,000
我觉得

2077
01:31:02,000 --> 01:31:06,000
Mac 就是 Object C 和 JAR 一样

2078
01:31:06,000 --> 01:31:08,000
是一个重度依赖于 Idea 的语言

2079
01:31:08,000 --> 01:31:10,000
你没有自动补全的话

2080
01:31:10,000 --> 01:31:11,000
你拿来写这个

2081
01:31:11,000 --> 01:31:13,000
真的是非常自找苦吃的一件事

2082
01:31:13,000 --> 01:31:14,000
但是如果你有自找

2083
01:31:14,000 --> 01:31:15,000
自动补全的话

2084
01:31:15,000 --> 01:31:16,000
文件名多长也无所谓了

2085
01:31:16,000 --> 01:31:17,000
他想的是说

2086
01:31:17,000 --> 01:31:20,000
你可以直接读到参数

2087
01:31:20,000 --> 01:31:21,000
或者函数名的时候

2088
01:31:21,000 --> 01:31:22,000
你就从他的名字

2089
01:31:22,000 --> 01:31:23,000
就能一点看出来

2090
01:31:23,000 --> 01:31:24,000
这个函数是干啥

2091
01:31:24,000 --> 01:31:25,000
他会把

2092
01:31:26,000 --> 01:31:28,000
把这个东西的功能定义的非常清晰

2093
01:31:28,000 --> 01:31:30,000
但不像我们之前在

2094
01:31:30,000 --> 01:31:31,000
可能上古时代

2095
01:31:31,000 --> 01:31:32,000
Uniqs 那个时候写 C

2096
01:31:32,000 --> 01:31:34,000
都是写的非常短的文件名

2097
01:31:34,000 --> 01:31:35,000
这个函数名

2098
01:31:35,000 --> 01:31:36,000
比如说什么

2099
01:31:36,000 --> 01:31:37,000
从这个 terminal 去个字母

2100
01:31:37,000 --> 01:31:39,000
他是给人 getch 的

2101
01:31:39,000 --> 01:31:40,000
他连那个 character

2102
01:31:40,000 --> 01:31:42,000
你说我们正常写的 character

2103
01:31:42,000 --> 01:31:43,000
你说 character

2104
01:31:43,000 --> 01:31:44,000
这个是几个

2105
01:31:44,000 --> 01:31:45,000
单字母的词

2106
01:31:45,000 --> 01:31:46,000
就比较长

2107
01:31:46,000 --> 01:31:47,000
你知道写个 car 吧

2108
01:31:47,000 --> 01:31:48,000
就 char 对吧

2109
01:31:48,000 --> 01:31:49,000
他连那个黑暗都不要

2110
01:31:49,000 --> 01:31:50,000
他直接 getch

2111
01:31:50,000 --> 01:31:51,000
对吧

2112
01:31:51,000 --> 01:31:52,000
你自己猜 ch 后面是个啥

2113
01:31:52,000 --> 01:31:53,000
对

2114
01:31:53,000 --> 01:31:54,000
这实际上也是一个

2115
01:31:54,000 --> 01:31:56,000
这其实还是一个路径依赖的问题

2116
01:31:56,000 --> 01:31:57,000
就是

2117
01:31:57,000 --> 01:31:59,000
你想大型机在 60 年代那个时代

2118
01:31:59,000 --> 01:32:04,000
你每次连上主机去写程序的时候

2119
01:32:05,000 --> 01:32:06,000
你会希望自己的按的键

2120
01:32:06,000 --> 01:32:08,000
需要按的键越少越好

2121
01:32:08,000 --> 01:32:10,000
因为就像现在我有时候

2122
01:32:10,000 --> 01:32:12,000
所有人都 work from home 对吧

2123
01:32:12,000 --> 01:32:14,000
你有时候连公司的那个讯息机

2124
01:32:14,000 --> 01:32:15,000
还是会觉得

2125
01:32:15,000 --> 01:32:16,000
你打一个键

2126
01:32:16,000 --> 01:32:18,000
我们好像有期节目聊过的问题

2127
01:32:18,000 --> 01:32:19,000
就是你按一个键之后

2128
01:32:19,000 --> 01:32:20,000
多久之内

2129
01:32:20,000 --> 01:32:21,000
获不到

2130
01:32:21,000 --> 01:32:22,000
得不到延迟

2131
01:32:22,000 --> 01:32:23,000
你个人就会非常焦躁

2132
01:32:23,000 --> 01:32:25,000
你会觉得整个思路被打断了

2133
01:32:25,000 --> 01:32:27,000
我现在就经常会遇到这种状况

2134
01:32:27,000 --> 01:32:28,000
我现在就希望说

2135
01:32:28,000 --> 01:32:29,000
我靠

2136
01:32:29,000 --> 01:32:31,000
赶紧使用 Mosh

2137
01:32:32,000 --> 01:32:32,000
有道理

2138
01:32:32,000 --> 01:32:35,000
但是我要连公司的讯息机

2139
01:32:35,000 --> 01:32:37,000
这个过程是没有办法用 Mosh 来实现的

2140
01:32:37,000 --> 01:32:40,000
我要先连到公司的 work from home

2141
01:32:40,000 --> 01:32:41,000
然后再从 work from home 上 Mosh

2142
01:32:41,000 --> 01:32:43,000
到公司内部的原成界面

2143
01:32:43,000 --> 01:32:46,000
这个过程就没有什么延迟了对吧

2144
01:32:46,000 --> 01:32:47,000
所以 60 年代的时候

2145
01:32:47,000 --> 01:32:48,000
人们写程序

2146
01:32:48,000 --> 01:32:49,000
当然会希望说

2147
01:32:49,000 --> 01:32:51,000
需要输入字符越少越好

2148
01:32:51,000 --> 01:32:53,000
而且是那些很常用的底层的功能

2149
01:32:53,000 --> 01:32:55,000
它可能会被反复调用

2150
01:32:55,000 --> 01:32:56,000
然后刚才你说 stop small talk

2151
01:32:56,000 --> 01:32:59,000
它有内外的区别力的机制

2152
01:32:59,000 --> 01:33:00,000
但其实在 C 里面

2153
01:33:00,000 --> 01:33:02,000
应该是之前是没有的对吧

2154
01:33:02,000 --> 01:33:04,000
对它就是你要会反复调用

2155
01:33:04,000 --> 01:33:05,000
如果你的文件

2156
01:33:05,000 --> 01:33:06,000
那个函数名太长的话

2157
01:33:06,000 --> 01:33:09,000
其实会反复浪费掉很多字节去存储

2158
01:33:10,000 --> 01:33:12,000
调用到 entry point 在哪里

2159
01:33:12,000 --> 01:33:13,000
对

2160
01:33:13,000 --> 01:33:16,000
而到了 OptiFac 或者是 Java 的时代

2161
01:33:16,000 --> 01:33:18,000
基本上所有的人都在本地客户端

2162
01:33:18,000 --> 01:33:20,000
都是不会省了一个字节了

2163
01:33:20,000 --> 01:33:21,000
后客户端

2164
01:33:21,000 --> 01:33:23,000
因为响应都是在本地的

2165
01:33:23,000 --> 01:33:25,000
所以你就不会说

2166
01:33:25,000 --> 01:33:28,000
你需要把名字弄短这个需求对吧

2167
01:33:29,000 --> 01:33:31,000
只有奇葩的 PHP 是

2168
01:33:33,000 --> 01:33:35,000
实际上最好的语言你说什么

2169
01:33:36,000 --> 01:33:37,000
只有奇葩的 PHP 是用

2170
01:33:37,000 --> 01:33:40,000
这个函数名的长度作为一个 hash

2171
01:33:42,000 --> 01:33:43,000
你能想象吗

2172
01:33:43,000 --> 01:33:45,000
这是一个让人匪夷所思的决定

2173
01:33:45,000 --> 01:33:47,000
所以 PHP 的函数名有长有短

2174
01:33:49,000 --> 01:33:50,000
是故意有长有短的

2175
01:33:51,000 --> 01:33:51,000
不可思议

2176
01:33:52,000 --> 01:33:53,000
但是就是说回来

2177
01:33:53,000 --> 01:33:56,000
就是但是 OptiFac 的那个

2178
01:33:57,000 --> 01:33:59,000
函数名真的是过于长了

2179
01:33:59,000 --> 01:34:02,000
就是即便是在现在的目光的观点来看

2180
01:34:02,000 --> 01:34:02,000
还是过于长

2181
01:34:02,000 --> 01:34:04,000
我觉得对于写 Java 的人来说

2182
01:34:04,000 --> 01:34:05,000
真的不算什么

2183
01:34:06,000 --> 01:34:06,000
很啰嗦

2184
01:34:07,000 --> 01:34:07,000
对

2185
01:34:07,000 --> 01:34:09,000
Java 里面也有很啰嗦的函数名

2186
01:34:09,000 --> 01:34:10,000
不要太多

2187
01:34:10,000 --> 01:34:12,000
至少 Java 的那些有些参数

2188
01:34:12,000 --> 01:34:14,000
你每个参数都要写参数名吗

2189
01:34:14,000 --> 01:34:15,000
不用吧

2190
01:34:16,000 --> 01:34:16,000
不用那倒不用

2191
01:34:16,000 --> 01:34:17,000
那 OptiSC 要写的

2192
01:34:19,000 --> 01:34:21,000
OptiSC 它每个 method

2193
01:34:21,000 --> 01:34:23,000
它还会把用冒号就连起来

2194
01:34:24,000 --> 01:34:25,000
它后面带了一个参数

2195
01:34:25,000 --> 01:34:25,000
对

2196
01:34:26,000 --> 01:34:28,000
然后就串得超长超长的

2197
01:34:28,000 --> 01:34:29,000
那个是函数签名的一部分

2198
01:34:29,000 --> 01:34:31,000
这个是可以理解的

2199
01:34:31,000 --> 01:34:33,000
就好像 C 语言的函数签名

2200
01:34:33,000 --> 01:34:36,000
其实也要把函数的类型带上的

2201
01:34:36,000 --> 01:34:38,000
只不过不像 OptiFC 写的非常的显示

2202
01:34:39,000 --> 01:34:41,000
你必须显示的告诉对方

2203
01:34:41,000 --> 01:34:43,000
我要调用这个方法里面

2204
01:34:43,000 --> 01:34:44,000
这个参数叫这个名字

2205
01:34:44,000 --> 01:34:46,000
但是在有些函数里面

2206
01:34:46,000 --> 01:34:48,000
比如说 Java 的函数签名

2207
01:34:48,000 --> 01:34:49,000
实际上也是包含类型的

2208
01:34:50,000 --> 01:34:52,000
你必须写出类型来

2209
01:34:52,000 --> 01:34:54,000
而 OptiFC 是不用写出类型来的

2210
01:34:54,000 --> 01:34:55,000
但是它要写出那个别名来

2211
01:34:56,000 --> 01:34:57,000
OK

2212
01:34:57,000 --> 01:34:59,000
那至少我们可以讨论另外一件事情

2213
01:34:59,000 --> 01:35:01,000
就是假设你还是就是我们认可

2214
01:35:01,000 --> 01:35:03,000
还是要把写的尽可能清晰

2215
01:35:03,000 --> 01:35:04,000
为准到有个限度

2216
01:35:04,000 --> 01:35:05,000
这个限度在哪里的问题

2217
01:35:05,000 --> 01:35:08,000
比如说我们修诺词今天给的例子

2218
01:35:09,000 --> 01:35:10,000
这个是一个苹果的 API

2219
01:35:10,000 --> 01:35:12,000
是 AppKit 的什么

2220
01:35:12,000 --> 01:35:15,000
NSATS Type Setter 里面有一个

2221
01:35:17,000 --> 01:35:19,000
我要念一下这个函数的

2222
01:35:19,000 --> 01:35:20,000
先深吸一口气

2223
01:35:20,000 --> 01:35:21,000
你们请深吸一口气

2224
01:35:21,000 --> 01:35:22,000
我先深吸一口气

2225
01:35:22,000 --> 01:35:24,000
你们请听好了

2226
01:35:24,000 --> 01:35:27,000
should break line by hyphenate

2227
01:35:28,000 --> 01:35:30,000
before character at index

2228
01:35:30,000 --> 01:35:32,000
hyphenating

2229
01:35:32,000 --> 01:35:33,000
你要加 irg

2230
01:35:33,000 --> 01:35:35,000
对 hyphenating

2231
01:35:35,000 --> 01:35:38,000
我先测量一下这个一共有

2232
01:35:38,000 --> 01:35:39,000
拿掏出你的

2233
01:35:39,000 --> 01:35:40,000
作为一个 python 程序员

2234
01:35:40,000 --> 01:35:42,000
掏出你的邮标卡尺来

2235
01:35:42,000 --> 01:35:43,000
50 个字

2236
01:35:43,000 --> 01:35:43,000
OK

2237
01:35:44,000 --> 01:35:44,000
假设

2238
01:35:44,000 --> 01:35:45,000
当然肯定

2239
01:35:45,000 --> 01:35:46,000
当然吴涛也说了

2240
01:35:46,000 --> 01:35:47,000
因为都是图形界面不存在这个问题

2241
01:35:47,000 --> 01:35:50,000
假设你在纯字符界面

2242
01:35:50,000 --> 01:35:53,000
你是一个 80 x 25 行宽的这么一个

2243
01:35:53,000 --> 01:35:56,000
这么一个编辑器的窗口里面

2244
01:35:56,000 --> 01:35:58,000
这 50 个字就已经干掉一整行了

2245
01:35:58,000 --> 01:35:58,000
对吧

2246
01:35:58,000 --> 01:35:59,000
你还不用干别的

2247
01:35:59,000 --> 01:36:02,000
对这还不是 coco 最长的

2248
01:36:02,000 --> 01:36:05,000
show notes 里面大家看那个 API 名最长选手权了吗

2249
01:36:05,000 --> 01:36:06,000
你们打开那页看看

2250
01:36:06,000 --> 01:36:09,000
你看你会发你打开那个看到的话

2251
01:36:09,000 --> 01:36:11,000
你会发现最长是 java windows.net

2252
01:36:11,000 --> 01:36:12,000
对

2253
01:36:12,000 --> 01:36:14,000
还是.net 比较好

2254
01:36:14,000 --> 01:36:14,000
没有

2255
01:36:14,000 --> 01:36:15,000
最关键是什么呢

2256
01:36:15,000 --> 01:36:18,000
像 coco 像 opjc

2257
01:36:18,000 --> 01:36:20,000
他啰嗦就啰嗦就算了

2258
01:36:20,000 --> 01:36:21,000
但是因为他啰嗦

2259
01:36:21,000 --> 01:36:23,000
他是因为他不缩写词

2260
01:36:23,000 --> 01:36:25,000
然后他都还很有语意

2261
01:36:25,000 --> 01:36:27,000
所以读起来还算是 ok 的

2262
01:36:27,000 --> 01:36:28,000
你不像.net

2263
01:36:28,000 --> 01:36:31,000
他即使写那么长了

2264
01:36:31,000 --> 01:36:33,000
他看不懂他什么意思

2265
01:36:33,000 --> 01:36:33,000
还带缩写

2266
01:36:33,000 --> 01:36:34,000
他带了缩写

2267
01:36:34,000 --> 01:36:35,000
还看不懂什么

2268
01:36:35,000 --> 01:36:36,000
而且还很啰嗦

2269
01:36:36,000 --> 01:36:38,000
你看比如说这个例子

2270
01:36:38,000 --> 01:36:40,000
103 个字母

2271
01:36:40,000 --> 01:36:41,000
那什么鬼

2272
01:36:41,000 --> 01:36:45,000
我觉得 coco 的 API 还有一点很有意思

2273
01:36:45,000 --> 01:36:46,000
就是或者说

2274
01:36:46,000 --> 01:36:50,000
导致了间接导入了他名字比较长的一点

2275
01:36:50,000 --> 01:36:56,000
就是他会用什么 should did 来表示 before after

2276
01:36:56,000 --> 01:36:57,000
就在别的 API 里面

2277
01:36:57,000 --> 01:36:59,000
比如说什么

2278
01:36:59,000 --> 01:37:01,000
窗口 load 这件事

2279
01:37:01,000 --> 01:37:04,000
别的 API 会叫做 before windows load

2280
01:37:04,000 --> 01:37:07,000
或者是 after windows load

2281
01:37:07,000 --> 01:37:08,000
然后在 coco 这里呢

2282
01:37:08,000 --> 01:37:10,000
叫做 windows should be loaded

2283
01:37:10,000 --> 01:37:13,000
或者是 windows did load

2284
01:37:13,000 --> 01:37:15,000
这个还蛮有意思的

2285
01:37:15,000 --> 01:37:17,000
算是 coco 一套

2286
01:37:17,000 --> 01:37:19,000
就哪怕现在 swiss 也是这样的

2287
01:37:19,000 --> 01:37:21,000
我有时候在想这个是不是跟

2288
01:37:21,000 --> 01:37:23,000
另外当时他们诞生那个背景

2289
01:37:23,000 --> 01:37:25,000
有一个思潮有关系

2290
01:37:25,000 --> 01:37:26,000
就是你们还记得那个叫

2291
01:37:27,000 --> 01:37:29,000
AppleScript 那个语言吗

2292
01:37:29,000 --> 01:37:29,000
嗯

2293
01:37:30,000 --> 01:37:31,000
就他的那个语言就是

2294
01:37:31,000 --> 01:37:32,000
非常有进化是吧

2295
01:37:32,000 --> 01:37:34,000
就像自然语言吗

2296
01:37:34,000 --> 01:37:35,000
嗯

2297
01:37:35,000 --> 01:37:37,000
对所谓自然语言描述这个东西

2298
01:37:37,000 --> 01:37:38,000
那么他就会什么描述呢

2299
01:37:38,000 --> 01:37:38,000
就是说

2300
01:37:38,000 --> 01:37:40,000
就全部都是用这个

2301
01:37:40,000 --> 01:37:41,000
我们现在都是用什么符号

2302
01:37:41,000 --> 01:37:43,000
来表达一些特殊的语意的地方

2303
01:37:43,000 --> 01:37:45,000
他都尽可能用这个

2304
01:37:45,000 --> 01:37:46,000
英文来表输

2305
01:37:46,000 --> 01:37:47,000
趁着连这个

2306
01:37:47,000 --> 01:37:48,000
比如说定义参数

2307
01:37:48,000 --> 01:37:49,000
定义函数这些

2308
01:37:49,000 --> 01:37:50,000
都是用这种方式来做

2309
01:37:50,000 --> 01:37:51,000
他其实可能跟那个时候的

2310
01:37:51,000 --> 01:37:53,000
那种思潮有一定的关系

2311
01:37:53,000 --> 01:37:54,000
但是你说是

2312
01:37:54,000 --> 01:37:56,000
should 和 did 会比 before after

2313
01:37:56,000 --> 01:37:58,000
更贴近人的时候习惯吗

2314
01:37:58,000 --> 01:37:59,000
我觉得不见得了

2315
01:37:59,000 --> 01:38:00,000
不不

2316
01:38:00,000 --> 01:38:02,000
before after 跟 should

2317
01:38:02,000 --> 01:38:03,000
这个肯定是语意上是不一样的

2318
01:38:03,000 --> 01:38:04,000
这个是个判断对不对

2319
01:38:04,000 --> 01:38:05,000
他说 should 就说

2320
01:38:05,000 --> 01:38:07,000
你会得到一个是还是不是

2321
01:38:07,000 --> 01:38:08,000
但你 before after

2322
01:38:08,000 --> 01:38:11,000
他得到的一个结果不是一个 bullying 吗

2323
01:38:11,000 --> 01:38:14,000
就是要得出一个不耳直的吧

2324
01:38:14,000 --> 01:38:14,000
对他得到

2325
01:38:14,000 --> 01:38:16,000
他其实是做一个逻辑判断

2326
01:38:16,000 --> 01:38:16,000
就是说你这个时候

2327
01:38:16,000 --> 01:38:18,000
是得到一个是是还是否对吧

2328
01:38:18,000 --> 01:38:20,000
但是如果你是 before break line

2329
01:38:20,000 --> 01:38:21,000
你得到这个什么东西

2330
01:38:21,000 --> 01:38:21,000
你是看不出来的

2331
01:38:21,000 --> 01:38:24,000
问题是我说的这个 API 是一个

2332
01:38:24,000 --> 01:38:25,000
比如说他是

2333
01:38:25,000 --> 01:38:27,000
你在写 GOI 的时候

2334
01:38:27,000 --> 01:38:28,000
你要写一个函数

2335
01:38:28,000 --> 01:38:31,000
这个函数应该在窗口被汇制之前调用

2336
01:38:32,000 --> 01:38:32,000
OK

2337
01:38:32,000 --> 01:38:35,000
这个函数名在 OS X 里面叫做

2338
01:38:35,000 --> 01:38:37,000
should present

2339
01:38:37,000 --> 01:38:37,000
比如说

2340
01:38:38,000 --> 01:38:41,000
但是在别的编程语言里面

2341
01:38:41,000 --> 01:38:43,000
可能就叫 before drawing 之类的

2342
01:38:43,000 --> 01:38:45,000
可能就是语意的问题了

2343
01:38:45,000 --> 01:38:46,000
就是你怎么去定义这个东西

2344
01:38:46,000 --> 01:38:48,000
就是总体来讲

2345
01:38:48,000 --> 01:38:49,000
他还是想维持一个

2346
01:38:49,000 --> 01:38:50,000
就是所有的这个

2347
01:38:50,000 --> 01:38:51,000
真正意义上的可读性

2348
01:38:51,000 --> 01:38:52,000
可读什么意思

2349
01:38:52,000 --> 01:38:54,000
就是你用嘴去念

2350
01:38:54,000 --> 01:38:54,000
那个东西

2351
01:38:54,000 --> 01:38:56,000
他还是得到的一些这个

2352
01:38:56,000 --> 01:38:57,000
一些概念的

2353
01:38:57,000 --> 01:38:58,000
对

2354
01:38:59,000 --> 01:39:00,000
那这个东西就是说

2355
01:39:00,000 --> 01:39:02,000
不一定是适合

2356
01:39:02,000 --> 01:39:03,000
比如说假设你是一个

2357
01:39:03,000 --> 01:39:04,000
非英语母语的人

2358
01:39:04,000 --> 01:39:06,000
比如说中国很多程序员就这样

2359
01:39:06,000 --> 01:39:07,000
为什么老说中国程序员

2360
01:39:07,000 --> 01:39:08,000
做的这个

2361
01:39:08,000 --> 01:39:09,000
这个 API 比较

2362
01:39:09,000 --> 01:39:10,000
比较奇怪

2363
01:39:10,000 --> 01:39:10,000
对吧

2364
01:39:10,000 --> 01:39:12,000
因为他鬼色难懂

2365
01:39:12,000 --> 01:39:12,000
对

2366
01:39:12,000 --> 01:39:12,000
他难懂

2367
01:39:12,000 --> 01:39:14,000
他根本他脑子里面

2368
01:39:14,000 --> 01:39:15,000
不是用那套英文

2369
01:39:15,000 --> 01:39:16,000
那个逻辑来思考的

2370
01:39:16,000 --> 01:39:18,000
所以他你怎么可能要求他

2371
01:39:18,000 --> 01:39:20,000
得出一套这个

2372
01:39:20,000 --> 01:39:21,000
should break line by

2373
01:39:21,000 --> 01:39:21,000
hiver in 18 p 4

2374
01:39:21,000 --> 01:39:22,000
character at index

2375
01:39:22,000 --> 01:39:23,000
这种语句的书案

2376
01:39:23,000 --> 01:39:24,000
他肯定不会这么做

2377
01:39:24,000 --> 01:39:25,000
对不对

2378
01:39:25,000 --> 01:39:27,000
所以我们只好写文言文了

2379
01:39:27,000 --> 01:39:27,000
不不不

2380
01:39:27,000 --> 01:39:29,000
中国程序员最大的特点

2381
01:39:29,000 --> 01:39:30,000
不是用拼音缩写吗

2382
01:39:31,000 --> 01:39:34,000
包括很多政府网站都是

2383
01:39:34,000 --> 01:39:37,000
政府网站缩写为 ZFWZ

2384
01:39:37,000 --> 01:39:38,000
我靠

2385
01:39:39,000 --> 01:39:39,000
oh my god

2386
01:39:39,000 --> 01:39:42,000
对这也是一个很有意思的

2387
01:39:42,000 --> 01:39:43,000
一个事情

2388
01:39:43,000 --> 01:39:44,000
就是说如果他不用拼音缩写

2389
01:39:44,000 --> 01:39:45,000
他还能用啥

2390
01:39:46,000 --> 01:39:48,000
因为你说我先把那个翻译

2391
01:39:48,000 --> 01:39:49,000
翻译成英文

2392
01:39:49,000 --> 01:39:51,000
对这好吧

2393
01:39:51,000 --> 01:39:53,000
我承认刚才我有点

2394
01:39:53,000 --> 01:39:54,000
英语本位主义了

2395
01:39:54,000 --> 01:39:55,000
不就是

2396
01:39:55,000 --> 01:39:56,000
不也不是说英语本位主义

2397
01:39:56,000 --> 01:39:57,000
其实我觉得在

2398
01:39:57,000 --> 01:40:00,000
就是纯技术范围词里面去

2399
01:40:00,000 --> 01:40:01,000
其实是应该英语本位主义的

2400
01:40:01,000 --> 01:40:02,000
因为你的所有的

2401
01:40:03,000 --> 01:40:05,000
底层的那些逻辑都是

2402
01:40:05,000 --> 01:40:06,000
英文的方式来命名的

2403
01:40:06,000 --> 01:40:07,000
对不对

2404
01:40:07,000 --> 01:40:08,000
这个毫无疑义

2405
01:40:08,000 --> 01:40:08,000
没有问题

2406
01:40:08,000 --> 01:40:11,000
不你要真到底层的话是二金字

2407
01:40:11,000 --> 01:40:12,000
我觉得

2408
01:40:12,000 --> 01:40:13,000
不是

2409
01:40:13,000 --> 01:40:13,000
我就说在

2410
01:40:15,000 --> 01:40:16,000
你还比如说你还是会讲

2411
01:40:16,000 --> 01:40:17,000
consul

2412
01:40:17,000 --> 01:40:18,000
你会讲 device

2413
01:40:18,000 --> 01:40:19,000
你会讲什么

2414
01:40:19,000 --> 01:40:20,000
socket 这些概念

2415
01:40:20,000 --> 01:40:21,000
这些还是逃不掉的

2416
01:40:22,000 --> 01:40:23,000
现在的那些

2417
01:40:23,000 --> 01:40:25,000
操作系统软件系统的

2418
01:40:25,000 --> 01:40:26,000
那些构建单元

2419
01:40:26,000 --> 01:40:28,000
它还是以英文来命名为主的

2420
01:40:28,000 --> 01:40:29,000
你看我说那个东西

2421
01:40:29,000 --> 01:40:30,000
虽然说确实有事

2422
01:40:30,000 --> 01:40:32,000
你是有这个剧柄

2423
01:40:32,000 --> 01:40:32,000
对吧

2424
01:40:32,000 --> 01:40:33,000
你有套接字

2425
01:40:33,000 --> 01:40:33,000
对吧

2426
01:40:33,000 --> 01:40:36,000
但是你不会真的去写这几个字

2427
01:40:36,000 --> 01:40:37,000
你还是写这些 handle

2428
01:40:37,000 --> 01:40:40,000
HDL 或者是 socket 的

2429
01:40:40,000 --> 01:40:41,000
剧柄 window handle

2430
01:40:41,000 --> 01:40:43,000
这是一个 windows 编程才有概念

2431
01:40:43,000 --> 01:40:45,000
我就说这种底层的概念是英文的

2432
01:40:45,000 --> 01:40:47,000
那么你其余它构建的东西

2433
01:40:47,000 --> 01:40:49,000
你就肯定还是以英文来描述它

2434
01:40:49,000 --> 01:40:52,000
你才这个字洽

2435
01:40:52,000 --> 01:40:52,000
才通顺

2436
01:40:52,000 --> 01:40:53,000
对吧

2437
01:40:53,000 --> 01:40:54,000
这个是没有

2438
01:40:54,000 --> 01:40:55,000
这个我觉得是毫无疑问的

2439
01:40:55,000 --> 01:40:56,000
问题是出在刚才你说

2440
01:40:56,000 --> 01:40:58,000
那个就不能犯话

2441
01:40:58,000 --> 01:40:58,000
比如说

2442
01:40:58,000 --> 01:40:59,000
你说那个一二里面

2443
01:40:59,000 --> 01:41:00,000
它是说

2444
01:41:01,000 --> 01:41:03,000
我们随便想一个政府网站

2445
01:41:03,000 --> 01:41:04,000
叫今日公告

2446
01:41:04,000 --> 01:41:05,000
对吧

2447
01:41:05,000 --> 01:41:08,000
它可能是 JRG

2448
01:41:08,000 --> 01:41:09,000
GG 对吧

2449
01:41:10,000 --> 01:41:11,000
你说那肯定是这么写的

2450
01:41:11,000 --> 01:41:13,000
但是它说 today's news

2451
01:41:13,000 --> 01:41:13,000
它不会

2452
01:41:13,000 --> 01:41:14,000
对吧

2453
01:41:14,000 --> 01:41:15,000
它没有一个底层

2454
01:41:15,000 --> 01:41:16,000
没有一个 foundation

2455
01:41:16,000 --> 01:41:17,000
去给你构建这个东西

2456
01:41:17,000 --> 01:41:19,000
所以就那个不成立

2457
01:41:20,000 --> 01:41:21,000
所以这两个情况

2458
01:41:21,000 --> 01:41:22,000
我觉得还是不一样

2459
01:41:22,000 --> 01:41:23,000
就是说如果你能够讨论的

2460
01:41:24,000 --> 01:41:25,000
最小的单位

2461
01:41:26,000 --> 01:41:27,000
或者就是常用的单位

2462
01:41:27,000 --> 01:41:29,000
它是一个什么样的语言描述的

2463
01:41:29,000 --> 01:41:30,000
你可能

2464
01:41:30,000 --> 01:41:31,000
其上构建的东西

2465
01:41:31,000 --> 01:41:32,000
还是要以这个为主

2466
01:41:32,000 --> 01:41:34,000
就好像哪怕你用文言

2467
01:41:34,000 --> 01:41:35,000
编程的时候

2468
01:41:35,000 --> 01:41:36,000
除非你把底层的

2469
01:41:36,000 --> 01:41:37,000
这个什么

2470
01:41:37,000 --> 01:41:37,000
就是剧柄

2471
01:41:37,000 --> 01:41:38,000
和套节字

2472
01:41:38,000 --> 01:41:40,000
都用文言来描述

2473
01:41:40,000 --> 01:41:41,000
不然你就很尴尬

2474
01:41:42,000 --> 01:41:44,000
知乎上不是有一个答案

2475
01:41:44,000 --> 01:41:45,000
说如果

2476
01:41:45,000 --> 01:41:46,000
就是问题是什么

2477
01:41:46,000 --> 01:41:47,000
如果

2478
01:41:47,000 --> 01:41:49,000
计算机是中国人发明的

2479
01:41:49,000 --> 01:41:50,000
那么底层会是什么样的

2480
01:41:50,000 --> 01:41:52,000
其实他就把那

2481
01:41:52,000 --> 01:41:53,000
把周一的那一套话术

2482
01:41:53,000 --> 01:41:54,000
套进去了

2483
01:41:54,000 --> 01:41:55,000
阴阳这样

2484
01:41:56,000 --> 01:41:57,000
对

2485
01:41:57,000 --> 01:41:58,000
所以我觉得就是说

2486
01:41:58,000 --> 01:41:59,000
你要去评价这个

2487
01:41:59,000 --> 01:42:00,000
做法合不合理的时候

2488
01:42:00,000 --> 01:42:02,000
你都是不能单点来看

2489
01:42:02,000 --> 01:42:03,000
你可能是要成体系的来看

2490
01:42:03,000 --> 01:42:05,000
那现在的情况

2491
01:42:05,000 --> 01:42:06,000
就是说计算机的

2492
01:42:06,000 --> 01:42:07,000
所有的底层的

2493
01:42:07,000 --> 01:42:10,000
这个体系都是以英语为

2494
01:42:10,000 --> 01:42:12,000
方为主体来构建的

2495
01:42:12,000 --> 01:42:13,000
那你没有办法了

2496
01:42:13,000 --> 01:42:13,000
你就只能

2497
01:42:14,000 --> 01:42:16,000
跟着这样写了

2498
01:42:18,000 --> 01:42:19,000
不知道有没有什么大神

2499
01:42:19,000 --> 01:42:20,000
可以做一个

2500
01:42:20,000 --> 01:42:21,000
兼容 unix 的

2501
01:42:21,000 --> 01:42:22,000
完全自

2502
01:42:22,000 --> 01:42:24,000
从最底层开始

2503
01:42:24,000 --> 01:42:25,000
就由中文构建的操作系统

2504
01:42:26,000 --> 01:42:27,000
Chinix

2505
01:42:28,000 --> 01:42:29,000
Chinix

2506
01:42:30,000 --> 01:42:30,000
不行

2507
01:42:30,000 --> 01:42:31,000
我说出这个的时候

2508
01:42:31,000 --> 01:42:32,000
就已经输了对不对

2509
01:42:32,000 --> 01:42:33,000
为什么会这么写

2510
01:42:34,000 --> 01:42:36,000
一定要用中文来描述这个东西

2511
01:42:39,000 --> 01:42:40,000
没有必要

2512
01:42:40,000 --> 01:42:42,000
我觉得那个趋势是融合

2513
01:42:42,000 --> 01:42:43,000
就是

2514
01:42:43,000 --> 01:42:45,000
就融合出一种杂柔的

2515
01:42:45,000 --> 01:42:46,000
杂柔的

2516
01:42:46,000 --> 01:42:47,000
对你看那个

2517
01:42:47,000 --> 01:42:48,000
什么什么

2518
01:42:48,000 --> 01:42:50,000
这种比较好的科幻片里面

2519
01:42:50,000 --> 01:42:52,000
未来都是中西文夹合

2520
01:42:52,000 --> 01:42:53,000
科里奥利语

2521
01:42:53,000 --> 01:42:56,000
就网上现在所谓的这种什么

2522
01:42:56,000 --> 01:42:58,000
00 后用的那种网络缩写语

2523
01:42:58,000 --> 01:42:59,000
它不又是用那种

2524
01:43:00,000 --> 01:43:01,000
英语的单词

2525
01:43:01,000 --> 01:43:03,000
和这个汉语拼音的缩写

2526
01:43:03,000 --> 01:43:04,000
给它混在一起

2527
01:43:04,000 --> 01:43:05,000
然后再用一个手字母缩写

2528
01:43:05,000 --> 01:43:07,000
就这种例子非常的多

2529
01:43:07,000 --> 01:43:09,000
什么 NMSL 这种的

2530
01:43:11,000 --> 01:43:12,000
这种当然是完全的

2531
01:43:12,000 --> 01:43:14,000
这个是汉语拼音的手字母缩写

2532
01:43:14,000 --> 01:43:15,000
还有一些就是

2533
01:43:15,000 --> 01:43:16,000
记用了英语的

2534
01:43:16,000 --> 01:43:18,000
因为现在有些英语单词

2535
01:43:18,000 --> 01:43:19,000
然后就像那个泰国网友

2536
01:43:19,000 --> 01:43:21,000
泰国网友反击的时候说

2537
01:43:22,000 --> 01:43:24,000
NMSL needs

2538
01:43:24,000 --> 01:43:25,000
你妈死了 needs

2539
01:43:25,000 --> 01:43:27,000
这就是一个很典型的

2540
01:43:27,000 --> 01:43:30,000
科里奥利语的

2541
01:43:30,000 --> 01:43:30,000
例子

2542
01:43:36,000 --> 01:43:38,000
我们来聊特殊字符

2543
01:43:38,000 --> 01:43:39,000
刚才讲了一个空格

2544
01:43:39,000 --> 01:43:39,000
这个特殊字符

2545
01:43:39,000 --> 01:43:41,000
其实可能是比较常见

2546
01:43:41,000 --> 01:43:42,000
其实还有很多其他的

2547
01:43:42,000 --> 01:43:44,000
特殊字符不能在

2548
01:43:45,000 --> 01:43:46,000
很多地方使用的

2549
01:43:46,000 --> 01:43:46,000
对吧

2550
01:43:46,000 --> 01:43:47,000
主要是 Windows

2551
01:43:47,000 --> 01:43:49,000
它那个限制很多

2552
01:43:49,000 --> 01:43:50,000
像 Mac 都没有

2553
01:43:51,000 --> 01:43:52,000
你在 Windows 里面

2554
01:43:52,000 --> 01:43:54,000
命名一个非法文件的时候

2555
01:43:54,000 --> 01:43:56,000
它会跳出来一个对话框里面

2556
01:43:56,000 --> 01:43:57,000
苦口婆心的告诉你

2557
01:43:57,000 --> 01:43:58,000
哪些文件是

2558
01:43:58,000 --> 01:43:59,000
哪些符号是不能用的

2559
01:44:00,000 --> 01:44:01,000
一大堆

2560
01:44:01,000 --> 01:44:02,000
这个还蛮贴心的

2561
01:44:02,000 --> 01:44:03,000
我觉得

2562
01:44:03,000 --> 01:44:04,000
这个我觉得很好

2563
01:44:04,000 --> 01:44:05,000
就是像 Mac 那种

2564
01:44:05,000 --> 01:44:05,000
过于自由

2565
01:44:05,000 --> 01:44:06,000
我觉得是有问题的

2566
01:44:06,000 --> 01:44:08,000
就是最好建议你不要这样干

2567
01:44:08,000 --> 01:44:08,000
那种

2568
01:44:08,000 --> 01:44:09,000
那就是说你

2569
01:44:09,000 --> 01:44:10,000
就是直接禁止你这么干

2570
01:44:10,000 --> 01:44:11,000
不更好

2571
01:44:11,000 --> 01:44:13,000
但是 Mac 现在也会跳出一个对话框

2572
01:44:13,000 --> 01:44:16,000
其实 Mac 也是有禁止字符的

2573
01:44:16,000 --> 01:44:19,000
Mac 其实是不能用冒号

2574
01:44:20,000 --> 01:44:21,000
唯一一个不能用的

2575
01:44:21,000 --> 01:44:22,000
就是在文件名里面

2576
01:44:22,000 --> 01:44:24,000
是不让用冒号的

2577
01:44:24,000 --> 01:44:26,000
如果你要改冒号的时候

2578
01:44:26,000 --> 01:44:27,000
它会跳出一个对话框

2579
01:44:27,000 --> 01:44:28,000
然后提醒你

2580
01:44:28,000 --> 01:44:29,000
但是它说的

2581
01:44:29,000 --> 01:44:30,000
它说那话就是比

2582
01:44:30,000 --> 01:44:32,000
就比 Windows 说的就很温柔

2583
01:44:32,000 --> 01:44:33,000
它说

2584
01:44:33,000 --> 01:44:36,000
请尝试使用字符较少

2585
01:44:36,000 --> 01:44:38,000
或不含标点符号的名称

2586
01:44:38,000 --> 01:44:39,000
远点算不算标点符号

2587
01:44:39,000 --> 01:44:40,000
对吧

2588
01:44:40,000 --> 01:44:41,000
这就很奇怪了

2589
01:44:41,000 --> 01:44:42,000
因为其实是可以用的

2590
01:44:43,000 --> 01:44:43,000
对

2591
01:44:43,000 --> 01:44:44,000
你在 Mac 还是其他都可以

2592
01:44:44,000 --> 01:44:44,000
对

2593
01:44:44,000 --> 01:44:46,000
但其实要想一下

2594
01:44:46,000 --> 01:44:47,000
就是为什么

2595
01:44:47,000 --> 01:44:48,000
就即便可以用

2596
01:44:48,000 --> 01:44:49,000
我觉得还是不建议

2597
01:44:49,000 --> 01:44:51,000
使用这些特殊字符作为文件

2598
01:44:51,000 --> 01:44:53,000
其实有很多比较实际的问题

2599
01:44:53,000 --> 01:44:54,000
比如说这里我们

2600
01:44:54,000 --> 01:44:55,000
Show Notes 里面列了几个

2601
01:44:56,000 --> 01:44:57,000
大于一号小于一号

2602
01:44:57,000 --> 01:44:57,000
对吧

2603
01:44:57,000 --> 01:44:58,000
因为这个在

2604
01:44:59,000 --> 01:45:01,000
类 Unix 的系统下面

2605
01:45:01,000 --> 01:45:03,000
它只有管道重新向的

2606
01:45:03,000 --> 01:45:04,000
它都有其他的特殊意义

2607
01:45:05,000 --> 01:45:05,000
你这样用了之后

2608
01:45:06,000 --> 01:45:07,000
别人要调用

2609
01:45:07,000 --> 01:45:09,000
或者是要指向你这个文件的时候

2610
01:45:09,000 --> 01:45:10,000
就必须用 coating

2611
01:45:10,000 --> 01:45:11,000
或打引号的方法

2612
01:45:11,000 --> 01:45:13,000
其实会增加比较多的

2613
01:45:14,000 --> 01:45:14,000
麻烦

2614
01:45:14,000 --> 01:45:15,000
对吧

2615
01:45:15,000 --> 01:45:16,000
包括 bar

2616
01:45:16,000 --> 01:45:17,000
pipe 这个字符

2617
01:45:17,000 --> 01:45:18,000
其实也是

2618
01:45:18,000 --> 01:45:18,000
可以用监控号

2619
01:45:18,000 --> 01:45:20,000
Unix 里面可以用监控号

2620
01:45:20,000 --> 01:45:21,000
做文件名吗

2621
01:45:22,000 --> 01:45:23,000
可以

2622
01:45:23,000 --> 01:45:24,000
你就引起来

2623
01:45:25,000 --> 01:45:27,000
现在都是这样子

2624
01:45:27,000 --> 01:45:28,000
你要往一边写

2625
01:45:28,000 --> 01:45:30,000
理论上都是可行的

2626
01:45:30,000 --> 01:45:31,000
它唯一主打你的地方

2627
01:45:31,000 --> 01:45:32,000
无非就是在

2628
01:45:33,000 --> 01:45:34,000
资源管理器的时候弄一个

2629
01:45:34,000 --> 01:45:36,000
但是你自己非要写个程序

2630
01:45:36,000 --> 01:45:37,000
去生成这么一个文件名

2631
01:45:37,000 --> 01:45:39,000
然后再把它放到词盘上面去

2632
01:45:39,000 --> 01:45:40,000
这个都是可行的

2633
01:45:40,000 --> 01:45:42,000
因为文件系统本身

2634
01:45:42,000 --> 01:45:43,000
它没有限制

2635
01:45:43,000 --> 01:45:44,000
不让你存这个东西

2636
01:45:45,000 --> 01:45:47,000
他说还就是一个数字

2637
01:45:47,000 --> 01:45:48,000
我就说从

2638
01:45:48,000 --> 01:45:49,000
对

2639
01:45:49,000 --> 01:45:51,000
从实用主义的观念来讲

2640
01:45:51,000 --> 01:45:52,000
尽量去避免这些

2641
01:45:52,000 --> 01:45:54,000
总是出问题的字符会比较好

2642
01:45:54,000 --> 01:45:55,000
所以其实就回到了

2643
01:45:55,000 --> 01:45:57,000
最开始的命名规则了

2644
01:45:57,000 --> 01:45:57,000
就是说

2645
01:45:57,000 --> 01:46:00,000
如何命名你的文件

2646
01:46:00,000 --> 01:46:02,000
会导致减少问题

2647
01:46:02,000 --> 01:46:03,000
就是不要用标点符号

2648
01:46:03,000 --> 01:46:04,000
其实是最好的

2649
01:46:04,000 --> 01:46:05,000
任何标点符号

2650
01:46:05,000 --> 01:46:08,000
包括空格是最好的

2651
01:46:08,000 --> 01:46:10,000
那个下话线不算

2652
01:46:10,000 --> 01:46:11,000
又要抬杠了

2653
01:46:11,000 --> 01:46:12,000
空格是标点符号吗

2654
01:46:12,000 --> 01:46:12,000
对

2655
01:46:12,000 --> 01:46:14,000
这个标点其实是

2656
01:46:14,000 --> 01:46:17,000
指的是英语世界里的标点

2657
01:46:17,000 --> 01:46:18,000
对

2658
01:46:18,000 --> 01:46:18,000
中文的话

2659
01:46:18,000 --> 01:46:19,000
对完全不存在这个问题

2660
01:46:19,000 --> 01:46:20,000
你比如说什么

2661
01:46:20,000 --> 01:46:21,000
你要用中文的数名号

2662
01:46:21,000 --> 01:46:22,000
就根本就

2663
01:46:22,000 --> 01:46:25,000
就不认为它是个特殊符号

2664
01:46:25,000 --> 01:46:25,000
对吧

2665
01:46:25,000 --> 01:46:26,000
就没什么区别

2666
01:46:26,000 --> 01:46:29,000
主要还是因为英语的标点符号

2667
01:46:29,000 --> 01:46:30,000
就日常书写中的标点符号

2668
01:46:30,000 --> 01:46:32,000
也被程序代码

2669
01:46:32,000 --> 01:46:35,000
借用来表达了很多特殊的意义

2670
01:46:35,000 --> 01:46:36,000
对

2671
01:46:36,000 --> 01:46:37,000
是的

2672
01:46:37,000 --> 01:46:40,000
我记得当初刚学编程的时候

2673
01:46:40,000 --> 01:46:41,000
有些

2674
01:46:41,000 --> 01:46:43,000
有些同学会很疑惑

2675
01:46:43,000 --> 01:46:44,000
为什么英文的

2676
01:46:44,000 --> 01:46:45,000
就是他

2677
01:46:45,000 --> 01:46:47,000
输入法只装了中文输入法

2678
01:46:47,000 --> 01:46:48,000
然后再用中文

2679
01:46:48,000 --> 01:46:49,000
为什么用中文的标点符号

2680
01:46:49,000 --> 01:46:50,000
就看起来跟英文的一模一样

2681
01:46:50,000 --> 01:46:52,000
但是在程序就跑不起来了

2682
01:46:52,000 --> 01:46:53,000
这是一个非常

2683
01:46:53,000 --> 01:46:54,000
疑惑的问题

2684
01:46:54,000 --> 01:46:56,000
会困扰出学者问题的

2685
01:46:56,000 --> 01:46:58,000
特别是在只有十个像素

2686
01:46:58,000 --> 01:46:59,000
生于十个像素宽的时候

2687
01:46:59,000 --> 01:47:00,000
到底中文引号

2688
01:47:00,000 --> 01:47:03,000
不中文这个括号和英文括号有啥区别

2689
01:47:03,000 --> 01:47:04,000
看不得出来

2690
01:47:05,000 --> 01:47:05,000
就很坑

2691
01:47:05,000 --> 01:47:07,000
所以又变成之前

2692
01:47:07,000 --> 01:47:09,000
Uni-code 那个玄学的问题了

2693
01:47:09,000 --> 01:47:11,000
两个看起来一样的话

2694
01:47:11,000 --> 01:47:12,000
它应该是一个一个码

2695
01:47:13,000 --> 01:47:15,000
是不是一个深坑

2696
01:47:15,000 --> 01:47:16,000
是

2697
01:47:16,000 --> 01:47:18,000
不过我每次看到反斜杠

2698
01:47:18,000 --> 01:47:22,000
就想到日文 Windows 的日元符号

2699
01:47:22,000 --> 01:47:23,000
那个是因为什么

2700
01:47:23,000 --> 01:47:25,000
因为它刚好是把码面给占了

2701
01:47:26,000 --> 01:47:26,000
所以

2702
01:47:26,000 --> 01:47:27,000
对

2703
01:47:27,000 --> 01:47:29,000
就 ASCII 里面借用了一下

2704
01:47:29,000 --> 01:47:31,000
为什么会借用到这个呢

2705
01:47:31,000 --> 01:47:33,000
就他们那时候一拍脑袋

2706
01:47:34,000 --> 01:47:36,000
就觉得好像说反斜杠不用

2707
01:47:36,000 --> 01:47:39,000
然后日本人要用日元符号码

2708
01:47:40,000 --> 01:47:43,000
所以就在码位上面

2709
01:47:43,000 --> 01:47:45,000
放上了日元符号码

2710
01:47:45,000 --> 01:47:47,000
这个日元符号是在 ASCII 的

2711
01:47:47,000 --> 01:47:49,000
头 128 个里面的吗

2712
01:47:49,000 --> 01:47:49,000
对

2713
01:47:50,000 --> 01:47:51,000
我知道了

2714
01:47:51,000 --> 01:47:52,000
就是占了反斜杠的位置

2715
01:47:53,000 --> 01:47:54,000
所以当年的话

2716
01:47:54,000 --> 01:47:55,000
就是日本的系统

2717
01:47:55,000 --> 01:47:57,000
它就打不出反斜杠的

2718
01:47:57,000 --> 01:47:59,000
就只能打日元符号

2719
01:47:59,000 --> 01:48:00,000
这叫什么来着

2720
01:48:00,000 --> 01:48:02,000
以日本为代表的东亚文化

2721
01:48:02,000 --> 01:48:04,000
试图对欧美主导的

2722
01:48:04,000 --> 01:48:06,000
什么什么的一个突破

2723
01:48:06,000 --> 01:48:07,000
对吧

2724
01:48:07,000 --> 01:48:08,000
逆袭

2725
01:48:09,000 --> 01:48:10,000
唯一成功的一次

2726
01:48:12,000 --> 01:48:13,000
因为其实你看在

2727
01:48:13,000 --> 01:48:15,000
基本上所有的编码里面

2728
01:48:15,000 --> 01:48:16,000
ASCII 都是作为一个

2729
01:48:16,000 --> 01:48:17,000
神圣不可动摇的一个基础的

2730
01:48:18,000 --> 01:48:18,000
对

2731
01:48:19,000 --> 01:48:20,000
而且我觉得他们脑子很奇怪

2732
01:48:20,000 --> 01:48:21,000
如果要换的话

2733
01:48:21,000 --> 01:48:23,000
也应该把美元符号

2734
01:48:23,000 --> 01:48:24,000
换成日元符号

2735
01:48:24,000 --> 01:48:25,000
对吧

2736
01:48:25,000 --> 01:48:26,000
那么为什么要

2737
01:48:26,000 --> 01:48:27,000
不行

2738
01:48:27,000 --> 01:48:29,000
那到时候美国爸爸就不开心了

2739
01:48:29,000 --> 01:48:31,000
这还是不可能的

2740
01:48:31,000 --> 01:48:32,000
我觉得把日元符号换成美元符号

2741
01:48:32,000 --> 01:48:35,000
比换掉后面更不可取

2742
01:48:36,000 --> 01:48:38,000
那个时候美元是多重要的一个东西

2743
01:48:38,000 --> 01:48:39,000
现在很重要

2744
01:48:40,000 --> 01:48:42,000
所以他们当时肯定是觉得说

2745
01:48:42,000 --> 01:48:44,000
这个反邪杆很不重要

2746
01:48:45,000 --> 01:48:46,000
所以就把这个挪掉了

2747
01:48:46,000 --> 01:48:47,000
结果谁知道

2748
01:48:47,000 --> 01:48:49,000
Windows 把这个反邪杆来做路径了

2749
01:48:49,000 --> 01:48:51,000
结果日本的 Windows 的

2750
01:48:51,000 --> 01:48:54,000
满眼都是日元符号

2751
01:48:54,000 --> 01:48:55,000
都是钱

2752
01:48:55,000 --> 01:48:55,000
对

2753
01:48:56,000 --> 01:48:56,000
对

2754
01:48:56,000 --> 01:48:57,000
等一下

2755
01:48:57,000 --> 01:48:58,000
刚才忘记说了一个

2756
01:48:59,000 --> 01:49:02,000
在 Mac 里面唯一一个不让用的是冒号

2757
01:49:02,000 --> 01:49:03,000
对吧

2758
01:49:03,000 --> 01:49:04,000
其实这个冒号

2759
01:49:06,000 --> 01:49:08,000
是我们平时用的在 GUI

2760
01:49:09,000 --> 01:49:11,000
在图形界面上不让用冒号的

2761
01:49:11,000 --> 01:49:14,000
因为他们路径其实用的是冒号

2762
01:49:14,000 --> 01:49:14,000
对吧

2763
01:49:15,000 --> 01:49:17,000
所以是它路径的保留字

2764
01:49:17,000 --> 01:49:18,000
其实就是老 Finder 里面

2765
01:49:19,000 --> 01:49:20,000
等一下我试一下

2766
01:49:20,000 --> 01:49:22,000
命令行是可以用冒号的

2767
01:49:22,000 --> 01:49:24,000
在命令行是可以用冒号的

2768
01:49:24,000 --> 01:49:24,000
对吧

2769
01:49:24,000 --> 01:49:28,000
然后在图形界面是可以用邪杆的

2770
01:49:28,000 --> 01:49:30,000
但是同样一个文件名

2771
01:49:30,000 --> 01:49:32,000
在命令行里面

2772
01:49:32,000 --> 01:49:34,000
这个邪杆会变成冒号

2773
01:49:35,000 --> 01:49:36,000
等一下

2774
01:49:36,000 --> 01:49:37,000
我刚才在命令行里面

2775
01:49:37,000 --> 01:49:39,000
建了一个带冒号的文件

2776
01:49:39,000 --> 01:49:40,000
然后在图形界面看

2777
01:49:40,000 --> 01:49:42,000
它变成了一个邪杆

2778
01:49:43,000 --> 01:49:43,000
对

2779
01:49:44,000 --> 01:49:45,000
这就交替了

2780
01:49:46,000 --> 01:49:47,000
对

2781
01:49:47,000 --> 01:49:48,000
是反着的

2782
01:49:49,000 --> 01:49:50,000
为什么是会这样的

2783
01:49:51,000 --> 01:49:54,000
因为冒号在 GUI 里面有别的作用吗

2784
01:49:54,000 --> 01:49:55,000
我靠太神气了

2785
01:49:56,000 --> 01:49:57,000
冒号在图形界面有什么用

2786
01:49:57,000 --> 01:50:00,000
在图形界面里面是不让用冒号的

2787
01:50:00,000 --> 01:50:00,000
文件名

2788
01:50:01,000 --> 01:50:03,000
它为什么要显示成邪杆呢

2789
01:50:03,000 --> 01:50:05,000
这个很难理解

2790
01:50:05,000 --> 01:50:07,000
反正现在 Mac 的处理方式

2791
01:50:08,000 --> 01:50:11,000
图形界面和命令行里面

2792
01:50:11,000 --> 01:50:12,000
冒号和邪杆是反着的

2793
01:50:13,000 --> 01:50:14,000
互相替代

2794
01:50:15,000 --> 01:50:17,000
因为在早期的 Finder 里面

2795
01:50:17,000 --> 01:50:20,000
早期的 Finder 里面的路径

2796
01:50:20,000 --> 01:50:22,000
是用冒号隔开的

2797
01:50:23,000 --> 01:50:26,000
真的会反过来

2798
01:50:26,000 --> 01:50:27,000
我第一次知道有这个事情

2799
01:50:28,000 --> 01:50:30,000
我在 Finder 里面建一个

2800
01:50:30,000 --> 01:50:31,000
邪杆吧

2801
01:50:32,000 --> 01:50:34,000
在 Terminal 里面显示为

2802
01:50:34,000 --> 01:50:35,000
Terminal 显示为负冒号吧

2803
01:50:36,000 --> 01:50:37,000
我不跟你说了

2804
01:50:37,000 --> 01:50:38,000
我再说一遍

2805
01:50:38,000 --> 01:50:39,000
就是在老的 Finder

2806
01:50:39,000 --> 01:50:41,000
就是老的系统里面

2807
01:50:41,000 --> 01:50:44,000
就是 Classic 的 Mac 里面

2808
01:50:45,000 --> 01:50:48,000
Finder 的路径的分割服

2809
01:50:48,000 --> 01:50:48,000
是用冒号

2810
01:50:49,000 --> 01:50:50,000
路径分割 Windows 是反邪杆

2811
01:50:51,000 --> 01:50:52,000
在 Finder 里面是冒号

2812
01:50:53,000 --> 01:50:55,000
果然是一个用过 Classic Mac 的人

2813
01:50:57,000 --> 01:50:58,000
我怪不得我就说

2814
01:50:58,000 --> 01:51:01,000
所以这是老 Mac 系统里面

2815
01:51:01,000 --> 01:51:03,000
唯一一个的预留字

2816
01:51:03,000 --> 01:51:04,000
是吗

2817
01:51:05,000 --> 01:51:06,000
明白

2818
01:51:06,000 --> 01:51:08,000
所以直到现在为止

2819
01:51:08,000 --> 01:51:10,000
Mac 也是不让用了

2820
01:51:11,000 --> 01:51:13,000
然后它会跟邪杆转移

2821
01:51:13,000 --> 01:51:14,000
OK

2822
01:51:14,000 --> 01:51:16,000
但现在其实已经没有再

2823
01:51:16,000 --> 01:51:18,000
有 Classic Mac 了对吧

2824
01:51:19,000 --> 01:51:22,000
这个转移其实完全没有什么现实意义了

2825
01:51:23,000 --> 01:51:26,000
它就变成图形界面的 Finder 的一个 Spec

2826
01:51:28,000 --> 01:51:29,000
这个很有意思

2827
01:51:29,000 --> 01:51:30,000
所以说这样我想起来

2828
01:51:30,000 --> 01:51:32,000
Windows 上面其实除了文件名

2829
01:51:32,000 --> 01:51:34,000
不能用特殊字符之外

2830
01:51:34,000 --> 01:51:36,000
还不能用一些特殊保留字

2831
01:51:36,000 --> 01:51:39,000
比如说你不能把一个文件名叫做 com

2832
01:51:39,000 --> 01:51:40,000
com 是因为什么

2833
01:51:40,000 --> 01:51:42,000
是因为串口的

2834
01:51:42,000 --> 01:51:44,000
com 是 comso

2835
01:51:44,000 --> 01:51:47,000
然后还有什么 prn 还是 pnt

2836
01:51:47,000 --> 01:51:49,000
还有 aux auxiliary

2837
01:51:49,000 --> 01:51:50,000
对也不行

2838
01:51:51,000 --> 01:51:51,000
对

2839
01:51:52,000 --> 01:51:52,000
这个当时是为什么

2840
01:51:52,000 --> 01:51:53,000
我记得有这个事

2841
01:51:53,000 --> 01:51:55,000
但我忘了原因是什么了

2842
01:51:55,000 --> 01:51:56,000
com 是 comso

2843
01:51:56,000 --> 01:51:58,000
就是你要是打 copy com

2844
01:51:58,000 --> 01:52:00,000
然后空格 target.txt

2845
01:52:00,000 --> 01:52:01,000
你就可以输入

2846
01:52:01,000 --> 01:52:04,000
从那个 comso 上输入字符

2847
01:52:04,000 --> 01:52:08,000
然后把它存成 target.txt

2848
01:52:08,000 --> 01:52:08,000
就是 com

2849
01:52:08,000 --> 01:52:11,000
实际上是 comso 的一个

2850
01:52:11,000 --> 01:52:13,000
有特殊意义的名字对吧

2851
01:52:13,000 --> 01:52:14,000
对

2852
01:52:14,000 --> 01:52:16,000
它不是不能存在文件名

2853
01:52:16,000 --> 01:52:17,000
对相当于一个

2854
01:52:17,000 --> 01:52:19,000
相当于 Terminal 里面的保留字了

2855
01:52:22,000 --> 01:52:22,000
对

2856
01:52:22,000 --> 01:52:25,000
但这个还蛮不合理的

2857
01:52:25,000 --> 01:52:26,000
这个其实很常用

2858
01:52:28,000 --> 01:52:30,000
它要是为了解决这个问题

2859
01:52:30,000 --> 01:52:33,000
直接进掉了好几个比较简短的名字

2860
01:52:33,000 --> 01:52:34,000
那你如果这样

2861
01:52:34,000 --> 01:52:36,000
你还不如直接用一个什么特殊符号

2862
01:52:36,000 --> 01:52:38,000
引起来

2863
01:52:38,000 --> 01:52:39,000
或者是你在前面加一个

2864
01:52:39,000 --> 01:52:41,000
你在前面加一个 escape 也可以

2865
01:52:41,000 --> 01:52:42,000
不是下滑线

2866
01:52:42,000 --> 01:52:44,000
aux 都有比 aux 好吧

2867
01:52:45,000 --> 01:52:47,000
或者是你用

2868
01:52:47,000 --> 01:52:48,000
你反正已经有那么多

2869
01:52:48,000 --> 01:52:49,000
特殊字符不能用了

2870
01:52:49,000 --> 01:52:49,000
对吧

2871
01:52:49,000 --> 01:52:51,000
你就把用一个特殊字符

2872
01:52:51,000 --> 01:52:52,000
来作为一个前缀了

2873
01:52:54,000 --> 01:52:56,000
或者用美元符号这种情况

2874
01:52:56,000 --> 01:52:56,000
对吧

2875
01:52:56,000 --> 01:52:58,000
因为基本上不会有人

2876
01:52:58,000 --> 01:52:59,000
把文件命名为

2877
01:53:00,000 --> 01:53:01,000
美元符号开头的文件名

2878
01:53:02,000 --> 01:53:02,000
你永远不知道

2879
01:53:02,000 --> 01:53:03,000
也难说

2880
01:53:03,000 --> 01:53:06,000
所以那个时候

2881
01:53:06,000 --> 01:53:08,000
假如我们来做系统的话

2882
01:53:08,000 --> 01:53:10,000
就是当时这种选择

2883
01:53:10,000 --> 01:53:11,000
肯定有它不合理的

2884
01:53:11,000 --> 01:53:12,000
这个傻逼的地方

2885
01:53:12,000 --> 01:53:13,000
对吧

2886
01:53:13,000 --> 01:53:14,000
但是肯定有很多情况

2887
01:53:14,000 --> 01:53:16,000
也是有不得已而为之的办法

2888
01:53:18,000 --> 01:53:19,000
Legacy

2889
01:53:19,000 --> 01:53:22,000
路径依赖真的可以解释很多问题

2890
01:53:22,000 --> 01:53:23,000
对

2891
01:53:23,000 --> 01:53:24,000
你看你说刚才讲

2892
01:53:24,000 --> 01:53:25,000
为什么 MacOS 现在里面

2893
01:53:25,000 --> 01:53:27,000
你用一个反斜杆

2894
01:53:27,000 --> 01:53:28,000
会变成在

2895
01:53:28,000 --> 01:53:30,000
在字符界面会变成冒号

2896
01:53:30,000 --> 01:53:31,000
对吧

2897
01:53:31,000 --> 01:53:33,000
然后冒号那边会

2898
01:53:33,000 --> 01:53:33,000
这边又反过来

2899
01:53:33,000 --> 01:53:34,000
不就是因为

2900
01:53:34,000 --> 01:53:36,000
和 Classic Mac 要兼容吗

2901
01:53:38,000 --> 01:53:40,000
这个也是非常

2902
01:53:40,000 --> 01:53:42,000
而且因为我自己原来是

2903
01:53:42,000 --> 01:53:43,000
最早学 DOS 的

2904
01:53:43,000 --> 01:53:45,000
我是打死我也不会赶在

2905
01:53:45,000 --> 01:53:47,000
一个文件名名用斜杆的

2906
01:53:47,000 --> 01:53:48,000
说实话

2907
01:53:50,000 --> 01:53:51,000
会出问题

2908
01:53:51,000 --> 01:53:52,000
多恐怖的一件事情

2909
01:53:52,000 --> 01:53:52,000
然后

2910
01:53:53,000 --> 01:53:55,000
然后现在在 Mac 居然可以用斜杆

2911
01:53:55,000 --> 01:53:57,000
首先这是第一个意外

2912
01:53:57,000 --> 01:54:00,000
然后我再用命令行再去看一下

2913
01:54:00,000 --> 01:54:01,000
发现变得冒号了

2914
01:54:01,000 --> 01:54:02,000
就变成第二个意外

2915
01:54:02,000 --> 01:54:03,000
就疯掉了

2916
01:54:03,000 --> 01:54:04,000
所以他到底那个情况

2917
01:54:04,000 --> 01:54:06,000
到底他存的是冒号

2918
01:54:06,000 --> 01:54:07,000
还是存的是斜杆

2919
01:54:07,000 --> 01:54:08,000
就是在

2920
01:54:08,000 --> 01:54:10,000
这么描述这件事情

2921
01:54:10,000 --> 01:54:11,000
应该也还是以

2922
01:54:11,000 --> 01:54:12,000
字符界面的为准

2923
01:54:13,000 --> 01:54:15,000
只是说发现它是个显示的问题

2924
01:54:15,000 --> 01:54:16,000
真的

2925
01:54:16,000 --> 01:54:17,000
UNIX 上面的

2926
01:54:18,000 --> 01:54:19,000
文件名是存在哪的

2927
01:54:19,000 --> 01:54:20,000
是存在 Iknow 的上的吧

2928
01:54:23,000 --> 01:54:24,000
应该是吧

2929
01:54:24,000 --> 01:54:25,000
看那个文件系统的

2930
01:54:25,000 --> 01:54:27,000
所以你要用一个

2931
01:54:27,000 --> 01:54:29,000
所以你要去文件系统里面

2932
01:54:29,000 --> 01:54:29,000
看这个东西

2933
01:54:29,000 --> 01:54:32,000
到底是底层是被存成了哪一个字符是吧

2934
01:54:32,000 --> 01:54:33,000
对

2935
01:54:33,000 --> 01:54:34,000
我很好奇这件事情

2936
01:54:34,000 --> 01:54:35,000
他到底存在那里存的是啥

2937
01:54:36,000 --> 01:54:37,000
我押冒号

2938
01:54:39,000 --> 01:54:40,000
我也赌应该是冒号

2939
01:54:41,000 --> 01:54:43,000
我也觉得应该是冒号

2940
01:54:43,000 --> 01:54:44,000
对

2941
01:54:44,000 --> 01:54:44,000
高

2942
01:54:44,000 --> 01:54:44,000
嗯

2943
01:54:44,000 --> 01:54:46,000
斜杆只是给你们这些愚蠢的人类

2944
01:54:46,000 --> 01:54:47,000
看一看而已

2945
01:54:47,000 --> 01:54:49,000
斜杆是一个幻想的

2946
01:54:49,000 --> 01:54:50,000
对

2947
01:54:50,000 --> 01:54:51,000
追寻他底层到底是什么字符

2948
01:54:51,000 --> 01:54:53,000
这个问题就留给 Rail

2949
01:54:53,000 --> 01:54:55,000
当作他的客户作业了

2950
01:55:00,000 --> 01:55:00,000
好的

2951
01:55:02,000 --> 01:55:03,000
所以你看

2952
01:55:03,000 --> 01:55:04,000
就是如果这种情况发生

2953
01:55:04,000 --> 01:55:05,000
就是你们想怎么办

2954
01:55:05,000 --> 01:55:06,000
就是会发生什么事情

2955
01:55:06,000 --> 01:55:08,000
这个也是一个小作业

2956
01:55:10,000 --> 01:55:12,000
Mac 上可以的文件名

2957
01:55:12,000 --> 01:55:13,000
往 Windows 上

2958
01:55:13,000 --> 01:55:15,000
比如说你拿个 U 盘复制过去

2959
01:55:15,000 --> 01:55:16,000
或者是反过来

2960
01:55:16,000 --> 01:55:18,000
Windows 上可以有的文件名

2961
01:55:18,000 --> 01:55:20,000
往 Mac 上复制会发生什么

2962
01:55:20,000 --> 01:55:21,000
他会把你改掉

2963
01:55:21,000 --> 01:55:22,000
还是会报错

2964
01:55:24,000 --> 01:55:25,000
他不会报错

2965
01:55:25,000 --> 01:55:26,000
他会自动把你改掉

2966
01:55:26,000 --> 01:55:28,000
就是直接越逐代庖了

2967
01:55:28,000 --> 01:55:29,000
说你只能这么干

2968
01:55:29,000 --> 01:55:30,000
改掉是什么意思

2969
01:55:30,000 --> 01:55:32,000
他会替换掉

2970
01:55:33,000 --> 01:55:33,000
我有个问题

2971
01:55:33,000 --> 01:55:36,000
就比如说我现在有一个 U 盘

2972
01:55:36,000 --> 01:55:38,000
然后我把 Mac 上一个包含了

2973
01:55:38,000 --> 01:55:40,000
Windows 非法字符的文件

2974
01:55:40,000 --> 01:55:41,000
拷过去了

2975
01:55:41,000 --> 01:55:43,000
然后我这 U 盘插到 Windows 上

2976
01:55:43,000 --> 01:55:44,000
它的资源管理器

2977
01:55:44,000 --> 01:55:45,000
看起来是什么样的

2978
01:55:45,000 --> 01:55:47,000
在非法的边缘试探

2979
01:55:48,000 --> 01:55:49,000
直接炸了

2980
01:55:50,000 --> 01:55:51,000
你自己试一次

2981
01:55:54,000 --> 01:55:56,000
比如说我要整一个

2982
01:55:56,000 --> 01:55:57,000
你整一个 U 盘的

2983
01:55:58,000 --> 01:55:59,000
Aux

2984
01:55:59,000 --> 01:55:59,000
COM 1

2985
01:55:59,000 --> 01:55:59,000
COM 2

2986
01:55:59,000 --> 01:56:00,000
COM 3

2987
01:56:00,000 --> 01:56:01,000
COM 的 LPT

2988
01:56:01,000 --> 01:56:02,000
都放进去

2989
01:56:02,000 --> 01:56:02,000
然后你怎么办

2990
01:56:04,000 --> 01:56:04,000
然后打到 Windows 上去

2991
01:56:04,000 --> 01:56:06,000
无法打开

2992
01:56:06,000 --> 01:56:07,000
不可以打开这个文件

2993
01:56:07,000 --> 01:56:08,000
不可以打开

2994
01:56:08,000 --> 01:56:09,000
那是后来的吗

2995
01:56:09,000 --> 01:56:09,000
就我首先

2996
01:56:09,000 --> 01:56:11,000
我还能不能看到这文件呢

2997
01:56:11,000 --> 01:56:12,000
这文件是在

2998
01:56:12,000 --> 01:56:13,000
直接在我的 U 盘上

2999
01:56:13,000 --> 01:56:14,000
就是看不到了吗

3000
01:56:14,000 --> 01:56:15,000
是怎么样的

3001
01:56:16,000 --> 01:56:17,000
不知道

3002
01:56:17,000 --> 01:56:19,000
我们可以做个实验试一下

3003
01:56:19,000 --> 01:56:21,000
还是会被转移掉呢

3004
01:56:21,000 --> 01:56:21,000
还是

3005
01:56:21,000 --> 01:56:23,000
那个符号可以转移

3006
01:56:23,000 --> 01:56:25,000
但是像 Windows 的那几个

3007
01:56:25,000 --> 01:56:28,000
不可能存在的文件名

3008
01:56:28,000 --> 01:56:30,000
你肯定就比较尴尬了

3009
01:56:31,000 --> 01:56:31,000
让我想起来

3010
01:56:31,000 --> 01:56:33,000
那个 WimRC

3011
01:56:33,000 --> 01:56:35,000
如果你手工创建一个

3012
01:56:35,000 --> 01:56:36,000
一点开头的文件的话

3013
01:56:36,000 --> 01:56:37,000
是做不到的

3014
01:56:37,000 --> 01:56:39,000
但是你可以通过编辑器

3015
01:56:39,000 --> 01:56:41,000
把它另存为这样一个文件

3016
01:56:41,000 --> 01:56:42,000
在 Windows 上面是可以的

3017
01:56:43,000 --> 01:56:44,000
一点开头的文件

3018
01:56:44,000 --> 01:56:45,000
在 Unix 下面

3019
01:56:45,000 --> 01:56:47,000
它是叫做隐藏文件的意思吗

3020
01:56:47,000 --> 01:56:49,000
就是莫认的 listing

3021
01:56:49,000 --> 01:56:49,000
是看不见的

3022
01:56:49,000 --> 01:56:50,000
Mac 也是

3023
01:56:50,000 --> 01:56:50,000
对

3024
01:56:50,000 --> 01:56:52,000
Mac 上是 MacOS

3025
01:56:52,000 --> 01:56:54,000
它继承了这 Unix 那套逻辑

3026
01:56:54,000 --> 01:56:55,000
它也是用了这个东西的

3027
01:56:56,000 --> 01:56:57,000
因为你在早期的时候

3028
01:56:57,000 --> 01:56:58,000
没有隐藏文件这个概念

3029
01:56:58,000 --> 01:56:59,000
它只不过在

3030
01:56:59,000 --> 01:57:00,000
比如说你在 LS

3031
01:57:00,000 --> 01:57:01,000
或者是在什么的时候

3032
01:57:01,000 --> 01:57:04,000
它默认会跳过那些点和点点

3033
01:57:04,000 --> 01:57:07,000
因为代表本集目录和上集目录

3034
01:57:07,000 --> 01:57:08,000
所以有些人就发现

3035
01:57:08,000 --> 01:57:11,000
我直接把文件一点开头

3036
01:57:11,000 --> 01:57:13,000
它就不会列出来了

3037
01:57:14,000 --> 01:57:16,000
所以就是为了不写代码

3038
01:57:16,000 --> 01:57:17,000
为了损事

3039
01:57:17,000 --> 01:57:17,000
为了损事

3040
01:57:17,000 --> 01:57:18,000
想出来的一个 hack

3041
01:57:18,000 --> 01:57:19,000
对

3042
01:57:20,000 --> 01:57:20,000
其实也好了

3043
01:57:20,000 --> 01:57:21,000
这种为了损事

3044
01:57:21,000 --> 01:57:23,000
至少我觉得还有一个什么

3045
01:57:23,000 --> 01:57:24,000
客观的理由

3046
01:57:24,000 --> 01:57:24,000
对吧

3047
01:57:24,000 --> 01:57:26,000
COM 1 怎么一回事

3048
01:57:26,000 --> 01:57:26,000
就是这个

3049
01:57:28,000 --> 01:57:29,000
这很过分

3050
01:57:29,000 --> 01:57:30,000
你知道吗

3051
01:57:30,000 --> 01:57:30,000
始终不能忘回

3052
01:57:30,000 --> 01:57:32,000
里面有更好的选择

3053
01:57:32,000 --> 01:57:32,000
对

3054
01:57:32,000 --> 01:57:33,000
还要讲

3055
01:57:34,000 --> 01:57:37,000
COM 从 123456789

3056
01:57:37,000 --> 01:57:42,000
然后还有 LPT 的 123456789

3057
01:57:42,000 --> 01:57:43,000
都是不能打的

3058
01:57:43,000 --> 01:57:43,000
LPT 是什么

3059
01:57:43,000 --> 01:57:45,000
是打印机那个什么接口吗

3060
01:57:45,000 --> 01:57:45,000
还是什么玩意

3061
01:57:45,000 --> 01:57:47,000
LPT 好像是打印机

3062
01:57:48,000 --> 01:57:48,000
对吧

3063
01:57:48,000 --> 01:57:51,000
我记得就当年真实打印机

3064
01:57:51,000 --> 01:57:52,000
有这个接口是这样子的

3065
01:57:53,000 --> 01:57:53,000
对

3066
01:57:55,000 --> 01:57:56,000
OK

3067
01:57:56,000 --> 01:57:57,000
终于可以聊大小写的问题了

3068
01:57:58,000 --> 01:58:00,000
又是一个顺顺的坑

3069
01:58:02,000 --> 01:58:03,000
我先理一下

3070
01:58:03,000 --> 01:58:04,000
现在是什么一个情况

3071
01:58:04,000 --> 01:58:04,000
就是说

3072
01:58:05,000 --> 01:58:07,000
我们都不考古了

3073
01:58:07,000 --> 01:58:09,000
就只聊现在这个文件系统

3074
01:58:09,000 --> 01:58:10,000
现在的创造系统

3075
01:58:11,000 --> 01:58:13,000
在 Mac 上面默认情况下

3076
01:58:13,000 --> 01:58:15,000
是可以叫什么来的

3077
01:58:15,000 --> 01:58:16,000
区分

3078
01:58:16,000 --> 01:58:17,000
这里要先讲两个概念

3079
01:58:17,000 --> 01:58:19,000
什么叫大小写敏感

3080
01:58:19,000 --> 01:58:20,000
和大小写保留

3081
01:58:20,000 --> 01:58:21,000
对吧

3082
01:58:21,000 --> 01:58:22,000
这两个概念是什么意思呢

3083
01:58:22,000 --> 01:58:23,000
就是说

3084
01:58:23,000 --> 01:58:26,000
假设我写 AB

3085
01:58:26,000 --> 01:58:28,000
然后 A 大写 B 小写

3086
01:58:28,000 --> 01:58:30,000
和写 AB 都小写的情况下

3087
01:58:30,000 --> 01:58:32,000
它应该是一个文件

3088
01:58:32,000 --> 01:58:33,000
还是两个文件的问题

3089
01:58:34,000 --> 01:58:34,000
如果说它两个

3090
01:58:34,000 --> 01:58:36,000
你认为它是两个

3091
01:58:36,000 --> 01:58:36,000
是一个文件

3092
01:58:36,000 --> 01:58:37,000
它说明这个系统

3093
01:58:37,000 --> 01:58:38,000
是大小写不敏感

3094
01:58:38,000 --> 01:58:39,000
对吧

3095
01:58:39,000 --> 01:58:40,000
因为它认为它是同等的

3096
01:58:40,000 --> 01:58:41,000
一个东西

3097
01:58:41,000 --> 01:58:42,000
这个时候比如说我们从

3098
01:58:42,000 --> 01:58:44,000
从实现的逻辑来讲

3099
01:58:44,000 --> 01:58:45,000
你就可以认为说

3100
01:58:45,000 --> 01:58:46,000
那存的时候都是把

3101
01:58:47,000 --> 01:58:49,000
东西转移成小写

3102
01:58:49,000 --> 01:58:50,000
存在文件系统里面去

3103
01:58:50,000 --> 01:58:51,000
或者是

3104
01:58:51,000 --> 01:58:53,000
都是做成大写

3105
01:58:53,000 --> 01:58:53,000
存在文件系统里面去

3106
01:58:53,000 --> 01:58:54,000
这个不重要

3107
01:58:54,000 --> 01:58:55,000
但是比如 DOS

3108
01:58:55,000 --> 01:58:57,000
DOS 的标准操作

3109
01:58:57,000 --> 01:58:58,000
好像全都是大写

3110
01:58:58,000 --> 01:58:59,000
大写对

3111
01:58:59,000 --> 01:59:00,000
就是这个是

3112
01:59:00,000 --> 01:59:01,000
就是敏不敏感的问题

3113
01:59:02,000 --> 01:59:03,000
保不保留

3114
01:59:03,000 --> 01:59:04,000
或者英文里面叫做 preserving

3115
01:59:04,000 --> 01:59:06,000
就是 case preserving 的问题

3116
01:59:06,000 --> 01:59:07,000
就是说

3117
01:59:07,000 --> 01:59:08,000
虽然你可以不敏感

3118
01:59:08,000 --> 01:59:09,000
但是你也可以保留

3119
01:59:09,000 --> 01:59:10,000
这个的区别

3120
01:59:10,000 --> 01:59:11,000
就是什么意思

3121
01:59:11,000 --> 01:59:13,000
你还是知道说

3122
01:59:14,000 --> 01:59:14,000
虽然说 A

3123
01:59:15,000 --> 01:59:16,000
大 A 小 B 和小 A 小 B

3124
01:59:16,000 --> 01:59:19,000
都是你认为是等价的

3125
01:59:19,000 --> 01:59:20,000
但是你还是把大 A 小 B

3126
01:59:20,000 --> 01:59:21,000
给存下来了

3127
01:59:22,000 --> 01:59:22,000
对吧

3128
01:59:23,000 --> 01:59:24,000
超只是照超而已

3129
01:59:24,000 --> 01:59:26,000
但是还是把它担得一样的

3130
01:59:27,000 --> 01:59:27,000
对

3131
01:59:27,000 --> 01:59:28,000
所以这里面我就

3132
01:59:28,000 --> 01:59:29,000
一直没想明白这个事情

3133
01:59:29,000 --> 01:59:30,000
就是说

3134
01:59:30,000 --> 01:59:31,000
既然大小写都

3135
01:59:32,000 --> 01:59:32,000
都这个小什么的

3136
01:59:32,000 --> 01:59:35,000
都不敏感了

3137
01:59:35,000 --> 01:59:35,000
对吧

3138
01:59:35,000 --> 01:59:37,000
你为什么还要保留呢

3139
01:59:37,000 --> 01:59:37,000
就其实没什么用

3140
01:59:38,000 --> 01:59:39,000
我觉得是为了客户

3141
01:59:39,000 --> 01:59:40,000
用户方面

3142
01:59:40,000 --> 01:59:42,000
因为用户有时候看起来

3143
01:59:42,000 --> 01:59:43,000
对

3144
01:59:43,000 --> 01:59:45,000
这就是拉丁字母本位的表现

3145
01:59:45,000 --> 01:59:47,000
因为使用拉丁字母的人

3146
01:59:47,000 --> 01:59:49,000
他们有大写和小写

3147
01:59:49,000 --> 01:59:50,000
但是他们在

3148
01:59:51,000 --> 01:59:53,000
他们脑海中对大写和小写的

3149
01:59:53,000 --> 01:59:55,000
区分的语意的识别能力

3150
01:59:55,000 --> 01:59:56,000
会相对弱一点

3151
01:59:56,000 --> 01:59:58,000
他们会认为他们是一样的

3152
01:59:59,000 --> 02:00:00,000
意思上是一样的

3153
02:00:00,000 --> 02:00:00,000
对

3154
02:00:00,000 --> 02:00:02,000
形式上写的不一样

3155
02:00:02,000 --> 02:00:02,000
嗯

3156
02:00:02,000 --> 02:00:04,000
其实跟 unicode 的问题

3157
02:00:04,000 --> 02:00:05,000
是有点类似的

3158
02:00:05,000 --> 02:00:05,000
对吧

3159
02:00:06,000 --> 02:00:07,000
而且刚才也不说了

3160
02:00:07,000 --> 02:00:09,000
各种什么 Camel Case 这种东西

3161
02:00:09,000 --> 02:00:10,000
其实他大小写

3162
02:00:10,000 --> 02:00:13,000
只是为了容易读

3163
02:00:13,000 --> 02:00:14,000
对吧

3164
02:00:14,000 --> 02:00:15,000
意思其实是一样的

3165
02:00:16,000 --> 02:00:18,000
所以就是看起来好看而已

3166
02:00:18,000 --> 02:00:21,000
然后还是单做一个东西

3167
02:00:21,000 --> 02:00:22,000
但这些这里

3168
02:00:22,000 --> 02:00:23,000
其实在不同语境下面

3169
02:00:23,000 --> 02:00:25,000
这个东西是有非常大的区别的

3170
02:00:25,000 --> 02:00:25,000
虽然说我们

3171
02:00:25,000 --> 02:00:27,000
我们又回到刚才的 Camel Case

3172
02:00:27,000 --> 02:00:27,000
那个地方

3173
02:00:27,000 --> 02:00:28,000
那讲的是什么

3174
02:00:28,000 --> 02:00:29,000
那讲的是 identify

3175
02:00:29,000 --> 02:00:30,000
就是识别符

3176
02:00:30,000 --> 02:00:31,000
对吧

3177
02:00:31,000 --> 02:00:33,000
在绝大多数语言里面

3178
02:00:33,000 --> 02:00:34,000
识别符都是大小写敏感的

3179
02:00:34,000 --> 02:00:37,000
就是刚才说大 A 小 B 和小 A 小 B

3180
02:00:37,000 --> 02:00:38,000
它明显是

3181
02:00:38,000 --> 02:00:39,000
它可以是两个

3182
02:00:39,000 --> 02:00:41,000
它是两个不同的一个变量

3183
02:00:41,000 --> 02:00:43,000
也好像两个不同的一个名字

3184
02:00:43,000 --> 02:00:43,000
对吧

3185
02:00:43,000 --> 02:00:45,000
但是在绝大多数的

3186
02:00:46,000 --> 02:00:47,000
identify 作为

3187
02:00:48,000 --> 02:00:49,000
作为 ID 的时候

3188
02:00:49,000 --> 02:00:50,000
作为一个比如用户账户

3189
02:00:50,000 --> 02:00:51,000
用户名的时候

3190
02:00:52,000 --> 02:00:53,000
它通常是不敏感

3191
02:00:53,000 --> 02:00:54,000
比如说我们讲 Twitter 的这个

3192
02:00:54,000 --> 02:00:56,000
Twitter 就是这么一个典型的例子

3193
02:00:56,000 --> 02:00:57,000
Twitter 它是就是说

3194
02:00:57,000 --> 02:00:58,000
是大小写保留

3195
02:00:58,000 --> 02:00:59,000
但是大小写不敏感

3196
02:00:59,000 --> 02:00:59,000
对吧

3197
02:00:59,000 --> 02:01:00,000
比如说我的

3198
02:01:02,000 --> 02:01:03,000
Twitter 的 handler 叫做 real jot

3199
02:01:03,000 --> 02:01:04,000
对吧

3200
02:01:04,000 --> 02:01:05,000
就是我这是 R 和 J 大写

3201
02:01:05,000 --> 02:01:06,000
这是两个词

3202
02:01:06,000 --> 02:01:09,000
但是你在 URL 里面

3203
02:01:09,000 --> 02:01:10,000
你写这六个字母的

3204
02:01:10,000 --> 02:01:11,000
任意大小写词

3205
02:01:11,000 --> 02:01:14,000
它都是带到我的那个页面下面去的

3206
02:01:14,000 --> 02:01:15,000
所以它这一点

3207
02:01:15,000 --> 02:01:17,000
它其实 Twitter 的这个命名这一点

3208
02:01:17,000 --> 02:01:19,000
它其实是跟这个 Mac 上默认的

3209
02:01:20,000 --> 02:01:21,000
文件名命名的

3210
02:01:21,000 --> 02:01:23,000
这个大小写的敏感方式是一样的

3211
02:01:23,000 --> 02:01:25,000
叫做 case insensitive

3212
02:01:25,000 --> 02:01:25,000
大小写不敏感

3213
02:01:26,000 --> 02:01:27,000
but case preserving

3214
02:01:27,000 --> 02:01:28,000
对吧

3215
02:01:28,000 --> 02:01:29,000
但保留大小写

3216
02:01:30,000 --> 02:01:30,000
哎

3217
02:01:30,000 --> 02:01:33,000
现在的你们有人写 web basic 吗

3218
02:01:33,000 --> 02:01:37,000
web basic 应该是大小写不敏感的

3219
02:01:37,000 --> 02:01:39,000
但是 web basic 是不是大小写保留的呢

3220
02:01:40,000 --> 02:01:41,000
我记得不太清楚

3221
02:01:41,000 --> 02:01:42,000
因为当时

3222
02:01:43,000 --> 02:01:46,000
vb 当时被最被人吐槽的

3223
02:01:46,000 --> 02:01:48,000
会不会最被职业程序员吐槽的眼

3224
02:01:48,000 --> 02:01:50,000
就是它居然是一个大小写不敏感的语言

3225
02:01:50,000 --> 02:01:52,000
你可以想象吗

3226
02:01:54,000 --> 02:01:54,000
等一下

3227
02:01:54,000 --> 02:01:58,000
download 它整个命名规则是一样的吗

3228
02:01:58,000 --> 02:01:58,000
不一样

3229
02:01:58,000 --> 02:02:00,000
download 只是一个 runtime

3230
02:02:00,000 --> 02:02:01,000
不一样了

3231
02:02:01,000 --> 02:02:02,000
download 好多语言

3232
02:02:03,000 --> 02:02:05,000
download 的底层肯定是区分大小写

3233
02:02:05,000 --> 02:02:06,000
就是那套 IL

3234
02:02:07,000 --> 02:02:09,000
Mac 上面其实是可能这个问题相对复杂的

3235
02:02:09,000 --> 02:02:12,000
因为 Mac 上它存在一个同一个文件系统

3236
02:02:12,000 --> 02:02:15,000
它有另外一种方式是可以大小写敏感的

3237
02:02:15,000 --> 02:02:18,000
日制式区分大小写

3238
02:02:18,000 --> 02:02:19,000
我那个时候就是傻不拉几的

3239
02:02:19,000 --> 02:02:22,000
把自己的分区隔成了

3240
02:02:22,000 --> 02:02:25,000
严格区分大小写的文件系统

3241
02:02:25,000 --> 02:02:26,000
后来好多游戏装不了

3242
02:02:27,000 --> 02:02:28,000
装游戏的时候他会说

3243
02:02:28,000 --> 02:02:30,000
你不能把这个程序装在一个

3244
02:02:30,000 --> 02:02:32,000
大小写敏感的分区上面

3245
02:02:34,000 --> 02:02:34,000
很扯

3246
02:02:34,000 --> 02:02:35,000
因为它不一样

3247
02:02:35,000 --> 02:02:36,000
对

3248
02:02:36,000 --> 02:02:37,000
这是另外一个比较

3249
02:02:38,000 --> 02:02:40,000
因为比如说 Mac 上我们现在用的主流的

3250
02:02:40,000 --> 02:02:43,000
就是叫做固态存储

3251
02:02:43,000 --> 02:02:46,000
固态存储它现在默认的文件系统的格式是 APFS

3252
02:02:47,000 --> 02:02:48,000
但是在 Mac 上面

3253
02:02:48,000 --> 02:02:54,000
它是用的是 APFS 的大小写不敏感的默认值

3254
02:02:54,000 --> 02:02:55,000
但是在 iPhone 上面

3255
02:02:55,000 --> 02:02:56,000
虽然你看不见

3256
02:02:56,000 --> 02:02:57,000
但是在 iPhone 上面

3257
02:02:57,000 --> 02:03:00,000
它用的默认是 APFS 大小写敏感的那一套

3258
02:03:00,000 --> 02:03:02,000
iPhone 是区分大小写的

3259
02:03:03,000 --> 02:03:06,000
就是 APFS 区分大小写的

3260
02:03:06,000 --> 02:03:07,000
APFS 是大小写敏感的

3261
02:03:07,000 --> 02:03:08,000
对

3262
02:03:10,000 --> 02:03:11,000
很奇怪对吧

3263
02:03:11,000 --> 02:03:13,000
所以我觉得其实这是一个问题

3264
02:03:13,000 --> 02:03:16,000
因为我是觉得从信息的角度来讲

3265
02:03:16,000 --> 02:03:18,000
肯定说是区分是更好的

3266
02:03:18,000 --> 02:03:21,000
只是说从大小写的

3267
02:03:21,000 --> 02:03:23,000
idiot proof 这个角度来看可能稍微差一些

3268
02:03:23,000 --> 02:03:27,000
但是在 iOS 上面去用户是并不能直接读写文件系统的

3269
02:03:27,000 --> 02:03:29,000
所以不存在这个问题

3270
02:03:29,000 --> 02:03:31,000
既然他们自己不是 idiot

3271
02:03:31,000 --> 02:03:32,000
那就没有这个问题了

3272
02:03:35,000 --> 02:03:35,000
好吧

3273
02:03:36,000 --> 02:03:37,000
等一下 Windows 现在什么状况

3274
02:03:37,000 --> 02:03:38,000
我有点忘了

3275
02:03:38,000 --> 02:03:39,000
Windows 是大小写敏感吗

3276
02:03:39,000 --> 02:03:40,000
不敏感

3277
02:03:40,000 --> 02:03:41,000
Windows 现在是大小写保留

3278
02:03:42,000 --> 02:03:43,000
那就跟 Mac 一样的

3279
02:03:43,000 --> 02:03:44,000
就不敏感了

3280
02:03:44,000 --> 02:03:44,000
对

3281
02:03:46,000 --> 02:03:46,000
OK

3282
02:03:46,000 --> 02:03:50,000
然后 NTFS 是没有大小写敏感的选项的对吧

3283
02:03:50,000 --> 02:03:50,000
应该是没有的

3284
02:03:52,000 --> 02:03:54,000
其实大小写叫什么

3285
02:03:54,000 --> 02:03:55,000
大小写不敏感

3286
02:03:55,000 --> 02:03:56,000
但是大小写保留

3287
02:03:56,000 --> 02:04:00,000
其实在实现上其实有会带来一个更麻烦的事情

3288
02:04:01,000 --> 02:04:02,000
你要存

3289
02:04:02,000 --> 02:04:03,000
比如说你想一下

3290
02:04:04,000 --> 02:04:06,000
你要去判断这个文件

3291
02:04:06,000 --> 02:04:07,000
到底在这个目的里面存不存在的时候

3292
02:04:07,000 --> 02:04:08,000
你要做什么

3293
02:04:08,000 --> 02:04:10,000
你要先把这个文件名

3294
02:04:10,000 --> 02:04:11,000
找找的目的文件名

3295
02:04:11,000 --> 02:04:13,000
你要先把它统一化成一个

3296
02:04:13,000 --> 02:04:15,000
比如说都是小写的话都是大写

3297
02:04:15,000 --> 02:04:16,000
然后你还得把这个

3298
02:04:17,000 --> 02:04:17,000
就叫什么来的

3299
02:04:17,000 --> 02:04:19,000
就是只有目的里面已经有的文件名

3300
02:04:19,000 --> 02:04:21,000
都得统一成

3301
02:04:21,000 --> 02:04:23,000
多小以才能够逐个字符

3302
02:04:23,000 --> 02:04:26,000
逐个字符比较对不对

3303
02:04:27,000 --> 02:04:30,000
所以我觉得这个其实效率挺低的

3304
02:04:30,000 --> 02:04:31,000
对

3305
02:04:31,000 --> 02:04:32,000
所以我觉得大小写敏感

3306
02:04:32,000 --> 02:04:34,000
还是一个更好的方案吧

3307
02:04:34,000 --> 02:04:39,000
然后就是另外一个更加坑爹的问题了

3308
02:04:39,000 --> 02:04:43,000
就是那文件名可不可以用 unicode 来写

3309
02:04:44,000 --> 02:04:46,000
用 emoji 来写是吧

3310
02:04:46,000 --> 02:04:47,000
现在是可以的

3311
02:04:47,000 --> 02:04:50,000
现在已经可以了

3312
02:04:50,000 --> 02:04:54,000
就好像那个 swift 最开始不就是

3313
02:04:54,000 --> 02:04:58,000
好多例子里面都出现了用 unicode 做来的方案吗

3314
02:04:59,000 --> 02:05:00,000
就非常坑爹

3315
02:05:00,000 --> 02:05:03,000
你想要来一个自动完成都做不到

3316
02:05:04,000 --> 02:05:05,000
一个现代的语言

3317
02:05:05,000 --> 02:05:08,000
它基本上都是以 unicode 的友好为

3318
02:05:08,000 --> 02:05:12,000
或者叫做 unicode 的兼容为一个标准

3319
02:05:12,000 --> 02:05:13,000
对为卖点

3320
02:05:13,000 --> 02:05:16,000
它可能也是刚才我们讨论的另外一个问题了

3321
02:05:17,000 --> 02:05:22,000
既然你就说不要以英语为中心主义的话

3322
02:05:22,000 --> 02:05:26,000
那我的这个变量命名为什么不可以是中文呢

3323
02:05:28,000 --> 02:05:29,000
既然都可以是中文了

3324
02:05:29,000 --> 02:05:31,000
为什么不能是一个

3325
02:05:32,000 --> 02:05:33,000
的 emoji 呢

3326
02:05:34,000 --> 02:05:35,000
所以它可以了吗

3327
02:05:36,000 --> 02:05:37,000
你刚才发出了一个什么声音

3328
02:05:38,000 --> 02:05:41,000
就是一个某一种表情符号

3329
02:05:42,000 --> 02:05:43,000
那 O 2 的那个

3330
02:05:44,000 --> 02:05:47,000
你刚才同学们

3331
02:05:47,000 --> 02:05:50,000
刚才 Ryo 念出了 O 2 这个表情符号

3332
02:05:51,000 --> 02:05:53,000
为他赋予了语音

3333
02:05:53,000 --> 02:05:55,000
这毕竟是一个纯听觉的节目

3334
02:05:55,000 --> 02:05:56,000
你要我怎么办

3335
02:05:56,000 --> 02:05:58,000
我只能采用通感的方式给你们展现

3336
02:05:58,000 --> 02:06:00,000
我们感受到了

3337
02:06:02,000 --> 02:06:03,000
感受到了是吧

3338
02:06:04,000 --> 02:06:05,000
以后 Ryo 应该出一套

3339
02:06:05,000 --> 02:06:09,000
应该在节目里面出一套这个 emoji 的发音指南

3340
02:06:09,000 --> 02:06:11,000
不叫做

3341
02:06:11,000 --> 02:06:14,000
Podcast Emoji User Guide

3342
02:06:15,000 --> 02:06:17,000
比如说笑出助教生这个 emoji

3343
02:06:22,000 --> 02:06:23,000
有这个 emoji 吗

3344
02:06:23,000 --> 02:06:24,000
没有这个 emoji

3345
02:06:28,000 --> 02:06:29,000
这个就不叫 emoji 了

3346
02:06:29,000 --> 02:06:30,000
这个叫什么

3347
02:06:30,000 --> 02:06:33,000
这叫 voice moji 对吧

3348
02:06:34,000 --> 02:06:35,000
audio moji

3349
02:06:35,000 --> 02:06:36,000
这根本就不是 moji

3350
02:06:38,000 --> 02:06:39,000
对其实就是

3351
02:06:40,000 --> 02:06:42,000
就这里就是用 unicode 作为这个命名的方式

3352
02:06:43,000 --> 02:06:44,000
刚才会出现类似于

3353
02:06:44,000 --> 02:06:46,000
最开始提到的那个

3354
02:06:47,000 --> 02:06:49,000
中文的括号和英文的括号

3355
02:06:49,000 --> 02:06:50,000
怎么长都一样

3356
02:06:50,000 --> 02:06:53,000
但是为什么我始终找不到这个文件的这个问题

3357
02:06:53,000 --> 02:06:53,000
对不对

3358
02:06:53,000 --> 02:06:55,000
但 unicode 也提供了那个

3359
02:06:55,000 --> 02:06:57,000
我们之前也解释过有那个叫什么

3360
02:06:57,000 --> 02:06:59,000
叫什么 collide 的方案对不对

3361
02:07:01,000 --> 02:07:03,000
就是虽然这两个它不是同一个码位

3362
02:07:03,000 --> 02:07:06,000
但是我们在搜索或者是在处理的时候

3363
02:07:06,000 --> 02:07:08,000
认为他们在语意上是等价的

3364
02:07:08,000 --> 02:07:10,000
所以理论上你只要找到这个东西

3365
02:07:10,000 --> 02:07:12,000
也能找到另外一个

3366
02:07:12,000 --> 02:07:14,000
但这个就是程序要做更加复杂的

3367
02:07:15,000 --> 02:07:16,000
特别的 handle

3368
02:07:16,000 --> 02:07:17,000
就不能只是简单的

3369
02:07:18,000 --> 02:07:20,000
我只要比较这两个支付串

3370
02:07:20,000 --> 02:07:22,000
它每一个字节是不是一样就可以了

3371
02:07:22,000 --> 02:07:22,000
对吧

3372
02:07:22,000 --> 02:07:24,000
就会变得更加复杂

3373
02:07:25,000 --> 02:07:25,000
超复杂的

3374
02:07:26,000 --> 02:07:27,000
所以这个什么

3375
02:07:27,000 --> 02:07:29,000
为什么我们不能有一个简单安全的

3376
02:07:30,000 --> 02:07:32,000
应用的系统可能就是对吧

3377
02:07:32,000 --> 02:07:33,000
这帮人干的

3378
02:07:36,000 --> 02:07:37,000
你们记不记得当年应该是

3379
02:07:37,000 --> 02:07:39,000
有好几年前了

3380
02:07:39,000 --> 02:07:40,000
就是 iphone 的

3381
02:07:40,000 --> 02:07:42,000
在某最开始的几年的时候

3382
02:07:42,000 --> 02:07:43,000
经常会出现

3383
02:07:43,000 --> 02:07:45,000
因为你收到一条短信里面

3384
02:07:45,000 --> 02:07:47,000
包含了一个奇怪 unicode 的组合

3385
02:07:47,000 --> 02:07:49,000
然后你这系统就崩溃了

3386
02:07:49,000 --> 02:07:52,000
对系统就死机或者崩溃了

3387
02:07:52,000 --> 02:07:52,000
这种情况

3388
02:07:52,000 --> 02:07:53,000
对吧

3389
02:07:53,000 --> 02:07:54,000
你可以说这个是这个叫什么

3390
02:07:54,000 --> 02:07:56,000
那个程序员写的这个

3391
02:07:57,000 --> 02:07:59,000
这个代码这个软件质量不够高

3392
02:07:59,000 --> 02:08:00,000
没错的事实上也是这样的

3393
02:08:00,000 --> 02:08:00,000
对吧

3394
02:08:00,000 --> 02:08:03,000
但是这个复杂度是因为什么东西引起的

3395
02:08:04,000 --> 02:08:07,000
所以现在 unicode 他们在做很多事情的话

3396
02:08:07,000 --> 02:08:10,000
很首先就是在安全性上面

3397
02:08:10,000 --> 02:08:13,000
是他们很大的一个考虑因素

3398
02:08:14,000 --> 02:08:14,000
对

3399
02:08:14,000 --> 02:08:17,000
对 这个在各家实现的时候要考虑

3400
02:08:17,000 --> 02:08:19,000
因为他们进行信息交换的时候

3401
02:08:19,000 --> 02:08:20,000
就全部都传过去了

3402
02:08:21,000 --> 02:08:22,000
一传过去的话

3403
02:08:22,000 --> 02:08:23,000
对

3404
02:08:23,000 --> 02:08:25,000
就是本质上你从信息安全角度来讲

3405
02:08:25,000 --> 02:08:26,000
这个是

3406
02:08:26,000 --> 02:08:30,000
就是说你只要从外部传过来的一段信息

3407
02:08:30,000 --> 02:08:32,000
你就认为默认它应该是不可信的

3408
02:08:32,000 --> 02:08:32,000
对吧

3409
02:08:32,000 --> 02:08:35,000
然后又恰巧碰上了

3410
02:08:35,000 --> 02:08:37,000
unicode 这么一套复杂的要死的系统之后

3411
02:08:37,000 --> 02:08:39,000
那就很容易出现问题

3412
02:08:39,000 --> 02:08:40,000
因为复杂度越高

3413
02:08:40,000 --> 02:08:41,000
bug 越多

3414
02:08:41,000 --> 02:08:42,000
对

3415
02:08:42,000 --> 02:08:45,000
所以一开始他们就有些朋友

3416
02:08:45,000 --> 02:08:46,000
可能就觉得很奇怪

3417
02:08:46,000 --> 02:08:48,000
unicode 不就是一个文字的编码吗

3418
02:08:48,000 --> 02:08:51,000
怎么还会跟这个信息安全承上关系

3419
02:08:51,000 --> 02:08:54,000
其实就是因为它里面有很多复杂的

3420
02:08:54,000 --> 02:08:55,000
各种文字都加在里面

3421
02:08:55,000 --> 02:08:57,000
所以很容易做文章

3422
02:08:59,000 --> 02:09:02,000
逼得我们吴涛都已经不再从事安全行业了

3423
02:09:02,000 --> 02:09:04,000
都是用户需求的坑

3424
02:09:05,000 --> 02:09:07,000
我觉得主要还是

3425
02:09:07,000 --> 02:09:09,000
怎么说安全行业需要人们有意识

3426
02:09:09,000 --> 02:09:12,000
只有人们认为安全是重要的时候

3427
02:09:12,000 --> 02:09:14,000
安全成为安全全行业才有前途

3428
02:09:14,000 --> 02:09:18,000
现在只能说大部分人都太不在乎了

3429
02:09:19,000 --> 02:09:21,000
只有等到失窃的时候才会后悔

3430
02:09:21,000 --> 02:09:22,000
真的

3431
02:09:22,000 --> 02:09:24,000
那肯定

3432
02:09:25,000 --> 02:09:27,000
但我就说你的解决方案是什么

3433
02:09:27,000 --> 02:09:28,000
那就只能说加大投入

3434
02:09:29,000 --> 02:09:30,000
但我的想法就是说

3435
02:09:30,000 --> 02:09:32,000
能不能够可以不要加大成本

3436
02:09:32,000 --> 02:09:34,000
就是不要给我搞那么 unicode 麻烦事

3437
02:09:34,000 --> 02:09:34,000
好吧

3438
02:09:34,000 --> 02:09:36,000
为什么要组合

3439
02:09:37,000 --> 02:09:39,000
一个字一个码位代表一个字不好吗

3440
02:09:39,000 --> 02:09:41,000
你不缺那几个码位对吧

3441
02:09:41,000 --> 02:09:43,000
组合个毛线

3442
02:09:43,000 --> 02:09:44,000
对你知道有一种

3443
02:09:45,000 --> 02:09:45,000
比如说 Lua

3444
02:09:45,000 --> 02:09:48,000
Lua 就是一个所谓 Ascii Clean 的

3445
02:09:48,000 --> 02:09:49,000
这么一个编程语言

3446
02:09:50,000 --> 02:09:53,000
它的核心的整个 Library 是

3447
02:09:53,000 --> 02:09:56,000
不会触及到 Ascii 的第八位的

3448
02:09:57,000 --> 02:09:59,000
全部都七位搞定

3449
02:09:59,000 --> 02:10:00,000
所有的东西都在

3450
02:10:02,000 --> 02:10:03,000
耳熟能详

3451
02:10:03,000 --> 02:10:05,000
所有计算机所有的 C 语言系统

3452
02:10:05,000 --> 02:10:06,000
都支持的这些码位里面

3453
02:10:07,000 --> 02:10:08,000
这也是一个思路

3454
02:10:09,000 --> 02:10:12,000
走绝对可行的最小的集合

3455
02:10:12,000 --> 02:10:13,000
但是不行

3456
02:10:13,000 --> 02:10:14,000
用户需求提出来

3457
02:10:14,000 --> 02:10:15,000
我就要看这个

3458
02:10:16,000 --> 02:10:17,000
的 Emoji 怎么办

3459
02:10:20,000 --> 02:10:23,000
Rail 是本日最佳声用

3460
02:10:26,000 --> 02:10:29,000
所以最终还是向用户需求妥协了

3461
02:10:29,000 --> 02:10:32,000
还是必须得硬着头皮上

3462
02:10:32,000 --> 02:10:34,000
就把这些 bug 都给修了

3463
02:10:34,000 --> 02:10:35,000
然后拿着超级后

3464
02:10:35,000 --> 02:10:37,000
那个 unicode 现在应该是出到

3465
02:10:37,000 --> 02:10:39,000
11 了对不对

3466
02:10:39,000 --> 02:10:39,000
对

3467
02:10:39,000 --> 02:10:40,000
13 了

3468
02:10:40,000 --> 02:10:41,000
13 了我又 out 了

3469
02:10:41,000 --> 02:10:44,000
那个册子也有多少页了现在

3470
02:10:44,000 --> 02:10:46,000
它规范

3471
02:10:46,000 --> 02:10:49,000
你说 PDF

3472
02:10:49,000 --> 02:10:50,000
这个要问两海了

3473
02:10:51,000 --> 02:10:53,000
应该得上百兆了吧我估计

3474
02:10:54,000 --> 02:10:59,000
unicode 的第 11 版的 Core specification

3475
02:10:59,000 --> 02:11:02,000
的 PDF 版本是 976 页

3476
02:11:05,000 --> 02:11:06,000
13 肯定超过 1000 了

3477
02:11:09,000 --> 02:11:12,000
但是 PDF 一共才 14.2 M

3478
02:11:13,000 --> 02:11:14,000
还好

3479
02:11:14,000 --> 02:11:16,000
这还只是 Core

3480
02:11:16,000 --> 02:11:16,000
那还有周边的

3481
02:11:17,000 --> 02:11:19,000
这只是 Core specification

3482
02:11:19,000 --> 02:11:20,000
就不带那个码表

3483
02:11:20,000 --> 02:11:23,000
对这附录还有那些数据表非常多

3484
02:11:23,000 --> 02:11:24,000
对

3485
02:11:24,000 --> 02:11:26,000
这只是 Core specification 而已

3486
02:11:26,000 --> 02:11:28,000
一个超级无敌的深坑

3487
02:11:30,000 --> 02:11:32,000
想一想就是累啊

3488
02:11:32,000 --> 02:11:34,000
对于我们这种尽可能说

3489
02:11:34,000 --> 02:11:37,000
砍用户需求不要增加复杂度的

3490
02:11:37,000 --> 02:11:38,000
这种思维方式的

3491
02:11:39,000 --> 02:11:41,000
这个过于复杂可以不做

3492
02:11:41,000 --> 02:11:42,000
对不对

3493
02:11:42,000 --> 02:11:45,000
好吧

3494
02:11:45,000 --> 02:11:48,000
今天我们脑洞也比较多

3495
02:11:49,000 --> 02:11:51,000
然后聊了

3496
02:11:51,000 --> 02:11:52,000
哇天哪

3497
02:11:53,000 --> 02:11:55,000
从哪里聊到哪里了

3498
02:11:55,000 --> 02:11:55,000
不过挺好的

3499
02:11:57,000 --> 02:11:58,000
整个命名规则

3500
02:11:58,000 --> 02:11:59,000
对吧

3501
02:11:59,000 --> 02:12:01,000
就是文像这个长度

3502
02:12:01,000 --> 02:12:03,000
自然的字符上的长度

3503
02:12:03,000 --> 02:12:04,000
然后空格

3504
02:12:06,000 --> 02:12:08,000
保留字不允许的字符

3505
02:12:08,000 --> 02:12:11,000
不允许的这些文件名

3506
02:12:11,000 --> 02:12:12,000
你是否去别大小写

3507
02:12:12,000 --> 02:12:14,000
这个就是命名的该说的都说了

3508
02:12:15,000 --> 02:12:17,000
也聊了我一桩心愿

3509
02:12:18,000 --> 02:12:19,000
聊了一桩心愿

3510
02:12:21,000 --> 02:12:22,000
这个我憋了好久没说了

3511
02:12:23,000 --> 02:12:24,000
可以瞑目了

3512
02:12:25,000 --> 02:12:26,000
并没有瞑目

3513
02:12:26,000 --> 02:12:28,000
我们还要把你抓来串台

3514
02:12:29,000 --> 02:12:30,000
好的

3515
02:12:30,000 --> 02:12:31,000
好了

3516
02:12:31,000 --> 02:12:32,000
你们可以收个尾

3517
02:12:32,000 --> 02:12:33,000
OK

3518
02:12:33,000 --> 02:12:36,000
您刚才收听到的节目是内核恐慌一堂

3519
02:12:36,000 --> 02:12:40,000
尽量贴近计算机技术主题的娱乐 podcast

3520
02:12:40,000 --> 02:12:41,000
我们号称硬核

3521
02:12:41,000 --> 02:12:42,000
但是也没有什么干货

3522
02:12:42,000 --> 02:12:43,000
想听就听

3523
02:12:43,000 --> 02:12:44,000
不想听就别听

3524
02:12:44,000 --> 02:12:46,000
我们的网址是 pan.icu

3525
02:12:46,000 --> 02:12:49,000
您可以在网站上找到订阅我们节目的方法

3526
02:12:49,000 --> 02:12:50,000
以及联络我们的方式

3527
02:12:50,000 --> 02:12:53,000
如果您期待我们更频繁的更新节目

3528
02:12:53,000 --> 02:12:55,000
欢迎您到爱发电为我们捐款

3529
02:12:55,000 --> 02:12:56,000
捐款地址是

3530
02:12:57,000 --> 02:13:00,000
爱发电.net.net.com

3531
02:13:00,000 --> 02:13:01,000
先发电后催更

3532
02:13:01,000 --> 02:13:03,000
文明催更从你做起

3533
02:13:03,000 --> 02:13:05,000
如果您觉得意犹未尽

3534
02:13:05,000 --> 02:13:09,000
也欢迎您去收听 Rail 和黄海主播的

3535
02:13:09,000 --> 02:13:10,000
风头轩

3536
02:13:11,000 --> 02:13:13,000
Rail 和仁宁主播的提前怀旧

3537
02:13:13,000 --> 02:13:16,000
以及基本不由无套主播的自谈自唱

3538
02:13:18,000 --> 02:13:18,000
好

3539
02:13:20,000 --> 02:13:22,000
我们的发电连接太长了

3540
02:13:22,000 --> 02:13:24,000
你要念它去我们官网点连接

3541
02:13:24,000 --> 02:13:24,000
谁记得住

3542
02:13:26,000 --> 02:13:28,000
说的是回头把这个删了

3543
02:13:28,000 --> 02:13:28,000
好吧

3544
02:13:28,000 --> 02:13:33,000
那再次感谢大家收听本期的自谈自唱的

3545
02:13:33,000 --> 02:13:34,000
删拿节目自谈自串

3546
02:13:35,000 --> 02:13:37,000
如果大家对我们的节目有什么意见或者反馈

3547
02:13:37,000 --> 02:13:40,000
都可以写邮件给我们的邮箱地址是

3548
02:13:40,000 --> 02:13:42,000
podcast.com

3549
02:13:42,000 --> 02:13:46,000
podcast.com

3550
02:13:46,000 --> 02:13:49,000
同时大家也可以在推特在微信

3551
02:13:49,000 --> 02:13:52,000
以及在微博上面搜索 the type 找到我们

3552
02:13:52,000 --> 02:13:54,000
the type

3553
02:13:54,000 --> 02:13:56,000
在 facebook 上搜索 the type

3554
02:13:56,000 --> 02:13:58,000
或者 type is beautiful 都可以找到我们

3555
02:13:59,000 --> 02:14:00,000
这比我们啰嗦多了

3556
02:14:00,000 --> 02:14:01,000
我觉得

3557
02:14:02,000 --> 02:14:03,000
没有对比就没有删

3558
02:14:04,000 --> 02:14:07,000
自谈自唱基本上是不需要催更的

3559
02:14:07,000 --> 02:14:09,000
我们是各州二播出

3560
02:14:09,000 --> 02:14:12,000
从开播以来就从来没有间断过

3561
02:14:12,000 --> 02:14:15,000
所以大家可以顺便来给我们催更的话

3562
02:14:15,000 --> 02:14:18,000
来加强我们的自谈自串的这样一个

3563
02:14:18,000 --> 02:14:20,000
串台节目的催更工作

3564
02:14:20,000 --> 02:14:22,000
专门催自谈自串

3565
02:14:22,000 --> 02:14:26,000
希望我们下次的串台不会一年之后再见

3566
02:14:27,000 --> 02:14:28,000
OK

3567
02:14:28,000 --> 02:14:29,000
好

3568
02:14:29,000 --> 02:14:30,000
感谢大家的收听

3569
02:14:30,000 --> 02:14:35,000
本次节目是 Eric 在 macOS 上剪辑制作完成的

3570
02:14:35,000 --> 02:14:36,000
我们下次节目再见

3571
02:14:36,000 --> 02:14:38,000
拜拜

