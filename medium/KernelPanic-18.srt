1
00:00:00,000 --> 00:00:06,000
您正在收听的是 IPN Podcast 网络旗下的 IT 技术主题节目内核恐慌

2
00:00:06,000 --> 00:00:08,000
我们号称 Hardcore

3
00:00:08,000 --> 00:00:09,000
但是也没有干货

4
00:00:09,000 --> 00:00:10,000
想听的人听

5
00:00:10,000 --> 00:00:12,000
不想听的人就别听

6
00:00:12,000 --> 00:00:15,000
内核恐慌的网址是 kernelpanic.fm

7
00:00:15,000 --> 00:00:20,000
我们推荐大家使用泛用型 Podcast 客户端订阅我们的节目

8
00:00:20,000 --> 00:00:23,000
如果您不知道什么是客户端

9
00:00:23,000 --> 00:00:25,000
请访问 ipn.io

10
00:00:26,000 --> 00:00:29,000
欢迎你为我们的节目捐款

11
00:00:29,000 --> 00:00:32,000
捐款地址是 ipn.li

12
00:00:32,000 --> 00:00:34,000
kernelpanic.donate

13
00:00:36,000 --> 00:00:37,000
捐款金额随意

14
00:00:37,000 --> 00:00:39,000
捐款不会为你带来什么

15
00:00:39,000 --> 00:00:41,000
不捐也不会让你失去什么

16
00:00:43,000 --> 00:00:44,000
OK

17
00:00:44,000 --> 00:00:46,000
今天是我们的第 18 期节目

18
00:00:46,000 --> 00:00:49,000
不过 Rail 因为非常忙

19
00:00:49,000 --> 00:00:51,000
不能参加本期节目的录音了

20
00:00:51,000 --> 00:00:55,000
不过他一定会参加明天的 IT 工的录音

21
00:00:55,000 --> 00:00:56,000
所以各位

22
00:00:56,000 --> 00:00:59,000
尤其是会员们可以

23
00:00:59,000 --> 00:01:00,000
松一口气

24
00:01:00,000 --> 00:01:07,000
另外单纯因为迷恋 Rail 的声音的朋友

25
00:01:07,000 --> 00:01:09,000
听到这里其实就可以转台了

26
00:01:09,000 --> 00:01:11,000
因为

27
00:01:11,000 --> 00:01:14,000
必须说有台的节目更好听

28
00:01:14,000 --> 00:01:17,000
尤其推荐上一期太一来了

29
00:01:17,000 --> 00:01:20,000
主题是情趣用品

30
00:01:20,000 --> 00:01:23,000
请在家长缺席下手

31
00:01:23,000 --> 00:01:27,000
所以仍旧坚守着内行恐慌的朋友们你们好

32
00:01:27,000 --> 00:01:29,000
本期没有 Rail

33
00:01:29,000 --> 00:01:31,000
但是也没有嘉宾

34
00:01:31,000 --> 00:01:36,000
只有我一个人在这边孤独的坚守着任地

35
00:01:36,000 --> 00:01:38,000
但是这是你听起来的错觉

36
00:01:38,000 --> 00:01:40,000
因为实际情况是我的女朋友

37
00:01:40,000 --> 00:01:44,000
此刻正坐在旁边为我端茶刀水山风垂背

38
00:01:44,000 --> 00:01:49,000
所以本期的主题就是程序员怎么样才能找到一个女朋友

39
00:01:49,000 --> 00:01:53,000
但是在进入主题之前

40
00:01:53,000 --> 00:01:55,000
我们先来念几封读者来信

41
00:01:58,000 --> 00:02:00,000
首先是一位叫做萤火的朋友

42
00:02:00,000 --> 00:02:05,000
他说第 17 期的后面提到

43
00:02:05,000 --> 00:02:10,000
他说不知道 DLL 的图标是什么意思

44
00:02:10,000 --> 00:02:12,000
所以也不知道可不可以删

45
00:02:12,000 --> 00:02:17,000
而我小时候试过将系统的 DLL 文件删除了

46
00:02:17,000 --> 00:02:19,000
那个时候玩表哥家的电脑

47
00:02:19,000 --> 00:02:20,000
他们出去了

48
00:02:20,000 --> 00:02:22,000
剩我一个人在玩核心弹头

49
00:02:22,000 --> 00:02:24,000
玩了一会觉得无聊就用鼠标乱点

50
00:02:24,000 --> 00:02:26,000
花花绿绿的图标可以点开

51
00:02:26,000 --> 00:02:28,000
有齿轮的图标都点不开

52
00:02:28,000 --> 00:02:30,000
我就理所当然认为点不开是没有用的

53
00:02:30,000 --> 00:02:32,000
没有用的就应该被删掉

54
00:02:32,000 --> 00:02:36,000
所以我将所有能看到的点不开的文件都删除了

55
00:02:36,000 --> 00:02:39,000
后面要吃饭就先把一堆的关了机

56
00:02:39,000 --> 00:02:41,000
到晚上表哥回来发现电脑启动不了

57
00:02:41,000 --> 00:02:43,000
我以为弄烂的电脑很害怕

58
00:02:43,000 --> 00:02:47,000
因为那个时候电脑比电视机和摩托车都贵

59
00:02:47,000 --> 00:02:47,000
赔不起

60
00:02:49,000 --> 00:02:51,000
后来表哥打电话叫了个同学过来

61
00:02:51,000 --> 00:02:53,000
那个同学在一个黑乎乎的窗口里面打字

62
00:02:53,000 --> 00:02:55,000
折腾了半个钟头

63
00:02:55,000 --> 00:02:57,000
电脑重新可以用

64
00:02:57,000 --> 00:03:00,000
小小的我觉得那个人是大大的高手

65
00:03:00,000 --> 00:03:01,000
很久以后我才醒不过来

66
00:03:01,000 --> 00:03:03,000
那个时候删掉的文件是 DLL

67
00:03:03,000 --> 00:03:06,000
那个高手所做的叫做重装系统

68
00:03:07,000 --> 00:03:07,000
读完了

69
00:03:09,000 --> 00:03:11,000
这让我想起 DOS 10 i

70
00:03:12,000 --> 00:03:13,000
好像没有这样的疑惑

71
00:03:13,000 --> 00:03:15,000
因为 DOS 10 i

72
00:03:15,000 --> 00:03:19,000
而如果你不区分可执行文件和不可执行文件的话

73
00:03:20,000 --> 00:03:22,000
是很难知道哪个文件有用

74
00:03:22,000 --> 00:03:23,000
哪个文件没有用的

75
00:03:24,000 --> 00:03:26,000
你只能看扩展名

76
00:03:26,000 --> 00:03:28,000
而如果你不懂扩展名的意义的话

77
00:03:28,000 --> 00:03:30,000
你是不会莫名其妙就删它了

78
00:03:31,000 --> 00:03:37,000
这可能也是另外一个命令行比较安全的因素吧

79
00:03:37,000 --> 00:03:39,000
或者说早期的图形化界面

80
00:03:39,000 --> 00:03:43,000
没有默认用户有可能不知道自己在干什么

81
00:03:44,000 --> 00:03:46,000
现在的操作性都做得很好了

82
00:03:46,000 --> 00:03:49,000
把比较容易弄坏的部分都隐藏起来

83
00:03:51,000 --> 00:03:53,000
这让我想起 DOS 10 i 重装系统

84
00:03:53,000 --> 00:03:56,000
好像只需要格式化一下系统盘就可以了

85
00:03:56,000 --> 00:03:57,000
好像就一条命令

86
00:03:58,000 --> 00:03:59,000
Sys 还是什么

87
00:03:59,000 --> 00:04:01,000
还是斜杠 Sys

88
00:04:01,000 --> 00:04:06,000
就可以把 DOS 传播到一个软盘或者硬盘上

89
00:04:06,000 --> 00:04:08,000
让它变成可以 boot

90
00:04:08,000 --> 00:04:08,000
对

91
00:04:08,000 --> 00:04:11,000
如果各位久等候听众没有经历过那个时代

92
00:04:11,000 --> 00:04:14,000
那个时代重装系统没有光盘可以用

93
00:04:14,000 --> 00:04:17,000
当然更不可能有网络可以用

94
00:04:17,000 --> 00:04:20,000
基本上就是你有 10 张软盘

95
00:04:20,000 --> 00:04:21,000
甚至更多

96
00:04:21,000 --> 00:04:25,000
我现在已经不记得那个时候第一版 Windows 3.2 或者是

97
00:04:25,000 --> 00:04:28,000
我相信 Windows 95 又出过软盘

98
00:04:28,000 --> 00:04:35,000
你要把一张一张软盘依次插入软盘驱动器

99
00:04:35,000 --> 00:04:36,000
天哪软盘驱动器

100
00:04:36,000 --> 00:04:38,000
我有多久没说过这次

101
00:04:38,000 --> 00:04:43,000
然后每张软盘可能装上 10%5%左右

102
00:04:43,000 --> 00:04:46,000
然后你要耐心的坐着

103
00:04:46,000 --> 00:04:48,000
一直让一张手动的去换软盘

104
00:04:48,000 --> 00:04:50,000
那像现在科技昌明

105
00:04:50,000 --> 00:04:54,000
就像写一个文本文件告诉电脑

106
00:04:54,000 --> 00:04:56,000
你需要一台什么样的虚拟机电脑

107
00:04:56,000 --> 00:04:59,000
很快就可以在一瞬间帮你竖起来一台

108
00:04:59,000 --> 00:05:04,000
具有完整的操作系统和程序开发环境的虚拟机

109
00:05:06,000 --> 00:05:06,000
真是老了

110
00:05:08,000 --> 00:05:12,000
不过其实我从很小的时候就建立起一个信念

111
00:05:12,000 --> 00:05:13,000
只要你不去拆机箱

112
00:05:13,000 --> 00:05:14,000
电脑就是弄不坏

113
00:05:16,000 --> 00:05:19,000
我不知道现在学编程的朋友们是不是还有疑惑

114
00:05:19,000 --> 00:05:23,000
就是有时候会很担心把电脑弄坏

115
00:05:23,000 --> 00:05:27,000
但实际情况就是只要你好好做备份

116
00:05:27,000 --> 00:05:28,000
数据别弄丢

117
00:05:30,000 --> 00:05:35,000
操作系统本身基本上是非常耐操的

118
00:05:35,000 --> 00:05:37,000
哪怕你删掉所有的 DLL

119
00:05:37,000 --> 00:05:42,000
且不论你现在你是否能够安全的删除一堆 DLL

120
00:05:42,000 --> 00:05:43,000
而不被电脑发现

121
00:05:43,000 --> 00:05:44,000
或者被电脑补救回来

122
00:05:46,000 --> 00:05:46,000
即便你删掉了

123
00:05:46,000 --> 00:05:48,000
电脑也是永远可以恢复的

124
00:05:48,000 --> 00:05:50,000
只要你不拆机箱

125
00:05:50,000 --> 00:05:50,000
OK

126
00:05:50,000 --> 00:05:52,000
接下来念下一封度着来信

127
00:05:52,000 --> 00:05:56,000
一位叫做陶契红的朋友说

128
00:05:56,000 --> 00:05:59,000
第 17 期提到飞机重启的时候

129
00:05:59,000 --> 00:06:04,000
要是听到的提示音是小霸王骑得不穷

130
00:06:04,000 --> 00:06:05,000
那才是整个人不好

131
00:06:09,000 --> 00:06:12,000
来自马来西亚的听众李先生

132
00:06:12,000 --> 00:06:14,000
写了一封度着来信说

133
00:06:14,000 --> 00:06:17,000
你们说了在 Windows 平台上

134
00:06:17,000 --> 00:06:19,000
现在可以开发 Objective-C 的事情

135
00:06:19,000 --> 00:06:22,000
虽然我还没有用过微软这款新的开发工具

136
00:06:22,000 --> 00:06:24,000
但是我是这样理解的

137
00:06:24,000 --> 00:06:30,000
微软的 Virtual Studio 是主要让您编译 Objective-C 的原代码

138
00:06:30,000 --> 00:06:34,000
但并不会声称 iOS OS X 平台上的 Binary Code

139
00:06:34,000 --> 00:06:38,000
而是声称 Windows 平台的 Universal Binary Code

140
00:06:38,000 --> 00:06:40,000
所以并不存在你们所说的

141
00:06:40,000 --> 00:06:45,000
如何在 Windows 上提交 iOS App 到 App Store 的问题

142
00:06:45,000 --> 00:06:50,000
因为微软并没有想要以 Virtual Studio 去代 Xcode 的想法

143
00:06:50,000 --> 00:06:51,000
括号差个话题

144
00:06:51,000 --> 00:06:55,000
无套 H-Real 有提到说 Xcode Alternative 开发工具

145
00:06:55,000 --> 00:06:59,000
那应该是 Jetbrain 的 App Code 吧

146
00:06:59,000 --> 00:07:02,000
不过这款工具是用你们讨厌的 Java 所开发的

147
00:07:02,000 --> 00:07:04,000
笑脸,括号完毕

148
00:07:04,000 --> 00:07:09,000
这差一句就是后来我也想起来的 Jetbrain 的 App Code

149
00:07:09,000 --> 00:07:12,000
对,Jetbrain 的 App Code 是用 Java 开发的

150
00:07:12,000 --> 00:07:16,000
不过这并不妨碍它是一款优秀的 IDE

151
00:07:18,000 --> 00:07:19,000
这样是可以做出好东西的

152
00:07:19,000 --> 00:07:21,000
这个我从来没有否认过

153
00:07:21,000 --> 00:07:25,000
但是只是你用 Java 做东西的过程比较担当

154
00:07:25,000 --> 00:07:29,000
取决于你是比较注重结果还是比较注重过程

155
00:07:29,000 --> 00:07:31,000
我觉得过程还是挺重要的

156
00:07:33,000 --> 00:07:35,000
回到李先生的来信

157
00:07:36,000 --> 00:07:37,000
他接着说

158
00:07:37,000 --> 00:07:48,000
微软主要想要借此新版的 Virtual Studio 来让许多只为 Apple 开发软件的开发者提供一个快速从 iOS 移植到 Windows 的工具

159
00:07:48,000 --> 00:07:52,000
我认为这是一个比较聪明的手段来拉拢 iOS 和 Android 开发者

160
00:07:52,000 --> 00:07:56,000
Apple 早期在推出 OS X 的时候也用过这一招

161
00:07:56,000 --> 00:07:58,000
他们当时使用 Rosetta 来

162
00:07:58,000 --> 00:08:01,000
这位朋友这边可能写错了

163
00:08:01,000 --> 00:08:03,000
我记得那个东西叫 Rosetta

164
00:08:03,000 --> 00:08:05,000
就是罗塞塔石碑的那次

165
00:08:05,000 --> 00:08:11,000
来帮助开发者过渡从 OS 9 到过渡到 OS X

166
00:08:11,000 --> 00:08:14,000
同时也在 X Code 里面提供了多元的编译

167
00:08:14,000 --> 00:08:17,000
比如 Objective C,C 和 C++

168
00:08:17,000 --> 00:08:26,000
以这种方式让 Adobe 或者微软这些用 C 或者 C++的开发软件的公司

169
00:08:26,000 --> 00:08:31,000
也可以顺利地将 Photoshop、Office 等旗舰级别的软件顺利移植到 OS X

170
00:08:33,000 --> 00:08:36,000
如果您有兴趣知道详情

171
00:08:36,000 --> 00:08:40,000
以下的视频是 Virtual Studio Compiler Team 在 Build 大会上的展示

172
00:08:40,000 --> 00:08:42,000
请从 27 分 20 秒开始看

173
00:08:42,000 --> 00:08:46,000
然后给了一个 Channel 9 的 link

174
00:08:46,000 --> 00:08:48,000
这个 link 我们会贴在 show notes 里面

175
00:08:48,000 --> 00:08:50,000
我会贴在 show notes 里面

176
00:08:50,000 --> 00:08:51,000
我怎么停不了说我们呢

177
00:08:51,000 --> 00:08:54,000
哎呀好孤单啊

178
00:08:54,000 --> 00:08:57,000
这里减数视频里的一些重点

179
00:08:57,000 --> 00:09:01,000
编辑器采用 C long

180
00:09:01,000 --> 00:09:07,000
也就是 C,C++、Objective C 的编辑器的 frontend 和 C 2

181
00:09:07,000 --> 00:09:10,000
也就是微软编辑器的 backend

182
00:09:11,000 --> 00:09:16,000
在 Virtual Studio 里面可以使用 Objective C

183
00:09:16,000 --> 00:09:18,000
直接调用 Windows API

184
00:09:18,000 --> 00:09:24,000
然后编辑后的代码并不是在 Emulate 上运行的

185
00:09:24,000 --> 00:09:27,000
而是 Windows Universal 的原生代码

186
00:09:27,000 --> 00:09:30,000
微软实现了 IOS 上的一部分 API

187
00:09:30,000 --> 00:09:33,000
他们称之为 Subset of iOS API

188
00:09:33,000 --> 00:09:40,000
计划实现的 API 包括 OpenGL、OpenAL、Sensor、UIKit、Core Animation 等等

189
00:09:41,000 --> 00:09:43,000
最后视频里面有个小花絮

190
00:09:43,000 --> 00:09:49,000
当台上微软产品营里问台下有多少人在为 Apple 开发产品的时候

191
00:09:49,000 --> 00:09:50,000
台下来说一半人举手

192
00:09:52,000 --> 00:09:55,000
好非常感谢这位李先生的来信

193
00:09:55,000 --> 00:09:57,000
干活相当多

194
00:09:57,000 --> 00:10:01,000
他提到了 Apple 早期在推出 OS X 的时候

195
00:10:01,000 --> 00:10:05,000
使用 Rosetta 来帮助开发者从 OS X 过渡到 OS X

196
00:10:05,000 --> 00:10:09,000
我记得那个时候给 Apple 开发程序是要用

197
00:10:09,000 --> 00:10:13,000
除了 S Code 还有一个东西叫什么

198
00:10:13,000 --> 00:10:15,000
Code Warrior

199
00:10:15,000 --> 00:10:17,000
好像是波兰的公司出的

200
00:10:17,000 --> 00:10:20,000
我好像又信口开了

201
00:10:20,000 --> 00:10:22,000
就是没有做调查就这样

202
00:10:22,000 --> 00:10:25,000
如果 Code Warrior 不是波兰做的话

203
00:10:25,000 --> 00:10:27,000
那是谁做的

204
00:10:27,000 --> 00:10:29,000
这不重要

205
00:10:29,000 --> 00:10:34,000
同时那个时候为 OS 9 开发程序是要用到 C

206
00:10:34,000 --> 00:10:36,000
那时候还没有 Rosetta C

207
00:10:36,000 --> 00:10:39,000
天哪那是个多么洪荒的时代

208
00:10:39,000 --> 00:10:45,000
不过那个时候好像也是可以用 Java 为 OS 9 开发程序的

209
00:10:45,000 --> 00:10:47,000
我没有记错了

210
00:10:47,000 --> 00:10:49,000
我还是比较年轻的没有经历过那个时代

211
00:10:49,000 --> 00:10:52,000
如果我们听众里没有经历过那个时代的话

212
00:10:53,000 --> 00:11:01,000
怎么样 OS 9 或者 OS 8 开发程序的听众的话

213
00:11:01,000 --> 00:11:04,000
也欢迎你来信提供一下这个经验

214
00:11:04,000 --> 00:11:09,000
那个时代的苹果电脑是怎样开发程序的

215
00:11:09,000 --> 00:11:16,000
因为虽然目前我们都是已经皈依苹果教的铁杆果粉

216
00:11:16,000 --> 00:11:20,000
但是早期我们开发程序的经历

217
00:11:20,000 --> 00:11:23,000
就真的只有 Windows 9 只有 Linux

218
00:11:23,000 --> 00:11:28,000
好像我跟 Ryo 都没有做过 OS 9 时代的

219
00:11:28,000 --> 00:11:31,000
至少是给图形界面编程的经历

220
00:11:31,000 --> 00:11:33,000
欢迎各位提供保育经验

221
00:11:33,000 --> 00:11:37,000
然后他提到说

222
00:11:37,000 --> 00:11:42,000
在 F 1.2 Studio 里面可以直接以 Offline FC 调用 Windows API

223
00:11:42,000 --> 00:11:45,000
这个听起来非常的无奈其

224
00:11:46,000 --> 00:11:52,000
所以言下几就是我可以用 Offline FC 在 Windows 上面写 Windows 程序了

225
00:11:52,000 --> 00:11:55,000
有意思

226
00:11:55,000 --> 00:11:57,000
谁能想到今天呢

227
00:11:57,000 --> 00:12:05,000
接下来是一位叫做 YPolyDiary 的朋友给我们寄来的听众来信

228
00:12:05,000 --> 00:12:07,000
他说 Ryo 吴涛你们好

229
00:12:07,000 --> 00:12:09,000
还是给两位发一个邮件吧

230
00:12:09,000 --> 00:12:11,000
之前总是在微博留言

231
00:12:11,000 --> 00:12:17,000
担心写信会写的太长浪费两位的时间

232
00:12:17,000 --> 00:12:19,000
关于 VR 的问题我就不多说了

233
00:12:19,000 --> 00:12:21,000
两位只是偶尔谈到

234
00:12:21,000 --> 00:12:24,000
并没有把它当作一个正式的题目来讲

235
00:12:24,000 --> 00:12:29,000
而我也是仅仅怀有热情并不是相关项目的参与者

236
00:12:29,000 --> 00:12:32,000
所以我今天的反馈是关于很早的一期

237
00:12:32,000 --> 00:12:34,000
关于机械键盘的

238
00:12:34,000 --> 00:12:37,000
那是我们的第二期

239
00:12:38,000 --> 00:12:41,000
好像迄今也是人气最高的一期

240
00:12:41,000 --> 00:12:46,000
当然我相信沐瑶和萧继姐的那两期早晚会超过这一期

241
00:12:46,000 --> 00:12:48,000
不过目前来看

242
00:12:48,000 --> 00:12:51,000
键盘这一期的下达量是非常高

243
00:12:51,000 --> 00:12:56,000
我是从那一期开始才知道机械键盘是怎么回事

244
00:12:56,000 --> 00:12:58,000
然后就多了解了一些

245
00:12:58,000 --> 00:13:00,000
但是有一个很大的遗憾就是

246
00:13:00,000 --> 00:13:05,000
没有人谈到机械键盘压力克数的问题

247
00:13:05,000 --> 00:13:07,000
而我觉得这是一个很大的问题

248
00:13:07,000 --> 00:13:14,000
我的意思是没有把机械键盘的压力曲线和不摸键盘的压力曲线进行计算比较

249
00:13:14,000 --> 00:13:18,000
这个问题重要吗?我觉得很重要,请看后面

250
00:13:18,000 --> 00:13:20,000
我这里就不画图了

251
00:13:20,000 --> 00:13:24,000
简单的说一下就是机械键盘的弹力结构是弹簧

252
00:13:24,000 --> 00:13:26,000
暂时没有见到其他结构

253
00:13:26,000 --> 00:13:28,000
弹簧的压力曲线是从小到大

254
00:13:28,000 --> 00:13:32,000
而且压力曲线基本上是平直的

255
00:13:32,000 --> 00:13:34,000
这导致了一个问题

256
00:13:34,000 --> 00:13:36,000
就是按压的过程中要不断的施加压力

257
00:13:36,000 --> 00:13:40,000
而不摸键盘的弹力结构是橡胶板

258
00:13:40,000 --> 00:13:42,000
这种结构初始压力比较大

259
00:13:42,000 --> 00:13:44,000
但是一旦突破之后就很轻松了

260
00:13:46,000 --> 00:13:48,000
实际表现出来的结果就是

261
00:13:48,000 --> 00:13:52,000
机械键盘要保持按压状态需要一直用力按住

262
00:13:52,000 --> 00:13:54,000
这里先不谈各种轴道差异影响

263
00:13:54,000 --> 00:13:58,000
而不摸键盘一旦按下之后就很容易保持按压状态

264
00:13:58,000 --> 00:14:00,000
不需要很大的力

265
00:14:00,000 --> 00:14:02,000
还有就是每次按压所需要付出的力

266
00:14:02,000 --> 00:14:04,000
机械键盘也要比不摸键盘大

267
00:14:06,000 --> 00:14:08,000
关于力的多少可以通过计算压力曲线获得

268
00:14:08,000 --> 00:14:10,000
我没有专业的工具没法测量计算

269
00:14:10,000 --> 00:14:14,000
但是参考对弓箭施能的计算方式

270
00:14:14,000 --> 00:14:16,000
可以知道压力曲线越平直

271
00:14:16,000 --> 00:14:18,000
收集的能量就越大

272
00:14:18,000 --> 00:14:22,000
其实我能想到这个问题是因为我对弓箭感兴趣

273
00:14:22,000 --> 00:14:24,000
之前看过一些研究资料

274
00:14:24,000 --> 00:14:26,000
比如反曲弓为什么效能更高

275
00:14:26,000 --> 00:14:28,000
当然为了验证我的猜想

276
00:14:28,000 --> 00:14:30,000
我专门定了一个机械键盘试用一下

277
00:14:30,000 --> 00:14:34,000
我只是为了体验一下就退货有点不道德

278
00:14:34,000 --> 00:14:36,000
我试用的是茶肘

279
00:14:36,000 --> 00:14:38,000
因为听你们说茶肘比较轻

280
00:14:38,000 --> 00:14:40,000
体验的结果就是

281
00:14:40,000 --> 00:14:42,000
在 Counter Strike 这种

282
00:14:42,000 --> 00:14:46,000
需要长时间按住几个键的游戏里面非常的累

283
00:14:46,000 --> 00:14:50,000
打字的话也感觉比我用的薄膜键盘要累一点

284
00:14:50,000 --> 00:14:54,000
机械键盘的初始压力很小感觉一个很轻的错觉

285
00:14:54,000 --> 00:14:56,000
但是实际上通过前面的计算就知道

286
00:14:56,000 --> 00:15:00,000
每次按压需要的力实际上很大

287
00:15:00,000 --> 00:15:02,000
这也许从理论上说明了

288
00:15:02,000 --> 00:15:04,000
机械键盘不适合长时间操作

289
00:15:04,000 --> 00:15:08,000
当然我只是想说明压力曲线这一个问题

290
00:15:08,000 --> 00:15:10,000
不涉及对机械键盘优劣评论

291
00:15:10,000 --> 00:15:12,000
好吧

292
00:15:12,000 --> 00:15:16,000
其实有点担心让喜欢机械键盘的两位大声反感

293
00:15:16,000 --> 00:15:20,000
另外我个人因为身体原因对轻动比较敏感

294
00:15:20,000 --> 00:15:24,000
所以我的手所有我的感受可能不代表大多数人

295
00:15:24,000 --> 00:15:28,000
我用的是铭机海背键盘是薄膜键盘

296
00:15:28,000 --> 00:15:30,000
但是支撑组件是笔本的 X 型结构

297
00:15:30,000 --> 00:15:32,000
手感介于笔记本和普通电脑之间

298
00:15:32,000 --> 00:15:34,000
这是我用的第二个键盘

299
00:15:34,000 --> 00:15:36,000
不好意思这一期又写长了

300
00:15:36,000 --> 00:15:38,000
好不容易找到一个自己能谈的话题

301
00:15:38,000 --> 00:15:42,000
OK 这位听众的来信就念完了

302
00:15:42,000 --> 00:15:44,000
怎么说呢

303
00:15:44,000 --> 00:15:46,000
就是首先前面他说

304
00:15:46,000 --> 00:15:50,000
机械键盘压力克术的问题

305
00:15:50,000 --> 00:15:54,000
他认为机械键盘的弹力结构是弹弯的

306
00:15:54,000 --> 00:15:56,000
而弹弯的压力曲线是线性的

307
00:15:56,000 --> 00:16:00,000
按压的过程中需要不断的施加压力等等

308
00:16:00,000 --> 00:16:02,000
这个怎么说呢

309
00:16:02,000 --> 00:16:04,000
就是压力曲线每一个轴

310
00:16:04,000 --> 00:16:06,000
如果你用 Cherry 的轴来判断的话

311
00:16:06,000 --> 00:16:08,000
每一个轴其实不一样的

312
00:16:08,000 --> 00:16:12,000
有些轴是的确是线性的

313
00:16:12,000 --> 00:16:14,000
但是另外一些轴是你按到一半的时候

314
00:16:14,000 --> 00:16:16,000
它会有一个触发点

315
00:16:16,000 --> 00:16:18,000
它会有一个触发点

316
00:16:18,000 --> 00:16:20,000
它会有一个触发点

317
00:16:20,000 --> 00:16:22,000
确是线性的

318
00:16:22,000 --> 00:16:24,000
但是另外一些轴是你按到一半的时候

319
00:16:24,000 --> 00:16:26,000
它会有一个触发点

320
00:16:26,000 --> 00:16:28,000
按到这个触发点之后

321
00:16:28,000 --> 00:16:30,000
就可以松开了

322
00:16:30,000 --> 00:16:32,000
这位朋友提到一个用用场景就是

323
00:16:32,000 --> 00:16:34,000
Counter Strike

324
00:16:34,000 --> 00:16:36,000
其实我个人觉得

325
00:16:36,000 --> 00:16:38,000
打 Counter Strike 的话

326
00:16:38,000 --> 00:16:40,000
还是薄膜键盘比较好

327
00:16:40,000 --> 00:16:42,000
原因倒不是薄膜键盘显示比较好

328
00:16:42,000 --> 00:16:44,000
而是因为怎么说呢

329
00:16:44,000 --> 00:16:46,000
薄膜键盘比较便宜吧

330
00:16:46,000 --> 00:16:48,000
打 Counter Strike 是非常

331
00:16:48,000 --> 00:16:50,000
对键盘非常凌虐的一种方式

332
00:16:52,000 --> 00:16:54,000
我个人还是会

333
00:16:54,000 --> 00:16:56,000
只会用机械门打字

334
00:16:56,000 --> 00:16:58,000
我也不知道反正现在我大部分时候

335
00:16:58,000 --> 00:17:00,000
打这个比如说

336
00:17:00,000 --> 00:17:02,000
暴雪的风暴英雄或者是

337
00:17:02,000 --> 00:17:04,000
WAR Thunder

338
00:17:04,000 --> 00:17:06,000
一个二战的坦克仿真游戏

339
00:17:06,000 --> 00:17:08,000
的时候基本上都是

340
00:17:08,000 --> 00:17:10,000
单用笔记本的薄膜键盘在打

341
00:17:12,000 --> 00:17:14,000
手感这个东西

342
00:17:14,000 --> 00:17:16,000
是非常主观的一件事情

343
00:17:16,000 --> 00:17:18,000
其实如果你单纯的

344
00:17:18,000 --> 00:17:20,000
从手感上来说的话

345
00:17:20,000 --> 00:17:22,000
机器键盘里面很多东西

346
00:17:22,000 --> 00:17:24,000
都是悬悬

347
00:17:24,000 --> 00:17:26,000
但是打字比较

348
00:17:26,000 --> 00:17:28,000
累这个可能是

349
00:17:28,000 --> 00:17:30,000
可能的确是这样

350
00:17:30,000 --> 00:17:32,000
有时候我现在也会觉得

351
00:17:32,000 --> 00:17:34,000
用机器键盘打字会稍微累一点

352
00:17:34,000 --> 00:17:36,000
怎么说呢就是

353
00:17:36,000 --> 00:17:38,000
打字累的这么一点点可能跟你

354
00:17:38,000 --> 00:17:40,000
每天多走几步的

355
00:17:40,000 --> 00:17:42,000
能量消耗都差不多

356
00:17:42,000 --> 00:17:44,000
基本上可以忽略不计的

357
00:17:44,000 --> 00:17:46,000
各位想看打字减肥的朋友们就

358
00:17:46,000 --> 00:17:48,000
可以醒醒了

359
00:17:50,000 --> 00:17:52,000
最后一封读者来信

360
00:17:52,000 --> 00:17:54,000
一位来自叫做

361
00:17:54,000 --> 00:17:56,000
肖治博我不知道念对了没有

362
00:17:56,000 --> 00:17:58,000
的博士先生

363
00:17:58,000 --> 00:18:00,000
他的 E-mail 里面就

364
00:18:00,000 --> 00:18:02,000
Dr.头衔这个跟德国很像

365
00:18:02,000 --> 00:18:04,000
德国人都喜欢把自己的 Dr.头衔

366
00:18:04,000 --> 00:18:06,000
写出来

367
00:18:06,000 --> 00:18:08,000
嗨两位主播好

368
00:18:08,000 --> 00:18:10,000
听了第 15 期的 Chrono Panic

369
00:18:10,000 --> 00:18:12,000
听中来信中有人讨论

370
00:18:12,000 --> 00:18:14,000
我又坐不住了

371
00:18:14,000 --> 00:18:16,000
之前我买了本书的 Data Science Handbook

372
00:18:16,000 --> 00:18:18,000
是 Cura

373
00:18:18,000 --> 00:18:20,000
的 Data Scientist William Chen

374
00:18:20,000 --> 00:18:22,000
联合一众

375
00:18:22,000 --> 00:18:24,000
Data Scientist 做了回馈

376
00:18:24,000 --> 00:18:26,000
大众的一件大好事

377
00:18:26,000 --> 00:18:28,000
我觉得大家都可以买来看一下

378
00:18:28,000 --> 00:18:30,000
虽然现在还没有看完不过写的真的

379
00:18:30,000 --> 00:18:32,000
挺好对于想要入行 Data

380
00:18:32,000 --> 00:18:34,000
Science 已经在这个行业

381
00:18:34,000 --> 00:18:36,000
中的同学都会有所帮助

382
00:18:36,000 --> 00:18:38,000
来信中那位同学

383
00:18:38,000 --> 00:18:40,000
说现在 AZER 和

384
00:18:42,000 --> 00:18:44,000
Amazon 这样的大公司把机器学习算法

385
00:18:44,000 --> 00:18:46,000
当成服务推出来了

386
00:18:46,000 --> 00:18:48,000
可以让大家不用

387
00:18:48,000 --> 00:18:50,000
编程就能用起来

388
00:18:50,000 --> 00:18:52,000
这的确是好事

389
00:18:52,000 --> 00:18:54,000
不过说到自然语言处理

390
00:18:54,000 --> 00:18:56,000
其实还是有很多很难的事情要做的

391
00:18:56,000 --> 00:18:58,000
其实这些很

392
00:18:58,000 --> 00:19:00,000
难的工作都是人可以

393
00:19:00,000 --> 00:19:02,000
轻而易举地做到了

394
00:19:02,000 --> 00:19:04,000
比如说从一个句子里面准确

395
00:19:04,000 --> 00:19:06,000
的时约出日期和时间

396
00:19:06,000 --> 00:19:08,000
这个听起来非常简单

397
00:19:08,000 --> 00:19:10,000
现有的

398
00:19:10,000 --> 00:19:12,000
Stanford NLP

399
00:19:12,000 --> 00:19:14,000
也就是斯坦福的

400
00:19:14,000 --> 00:19:16,000
自然语言处理技术

401
00:19:16,000 --> 00:19:18,000
用基于 Conditional

402
00:19:18,000 --> 00:19:20,000
Random Field 的实体命名

403
00:19:20,000 --> 00:19:22,000
算法也可以用

404
00:19:22,000 --> 00:19:24,000
但是达到非常精确的效果

405
00:19:24,000 --> 00:19:26,000
还是有很长的路要走

406
00:19:26,000 --> 00:19:28,000
再说另一个

407
00:19:28,000 --> 00:19:30,000
从数据集中让算法自动

408
00:19:30,000 --> 00:19:32,000
时列出变量的值

409
00:19:32,000 --> 00:19:34,000
是连续型的还是离散

410
00:19:34,000 --> 00:19:36,000
型的都很难

411
00:19:36,000 --> 00:19:38,000
剑桥大学的 Zobin

412
00:19:38,000 --> 00:19:40,000
Gaharamani 教授

413
00:19:40,000 --> 00:19:42,000
在 2014 年的

414
00:19:42,000 --> 00:19:44,000
Nips

415
00:19:44,000 --> 00:19:46,000
这是一个

416
00:19:46,000 --> 00:19:48,000
Neural

417
00:19:48,000 --> 00:19:50,000
Information Processing System

418
00:19:50,000 --> 00:19:52,000
他是一个年会应该是

419
00:19:52,000 --> 00:19:54,000
跟这个神经

420
00:19:54,000 --> 00:19:56,000
信息处理性有关

421
00:19:58,000 --> 00:20:00,000
这位教授在

422
00:20:00,000 --> 00:20:02,000
2014 年的 Nips

423
00:20:02,000 --> 00:20:04,000
会议上面就这个问题

424
00:20:04,000 --> 00:20:06,000
发表了一篇论文然后顺便

425
00:20:06,000 --> 00:20:08,000
再推一下另外一个 Podcast

426
00:20:08,000 --> 00:20:10,000
Talking Machine

427
00:20:10,000 --> 00:20:12,000
网址是 HTP

428
00:20:12,000 --> 00:20:14,000
www.

429
00:20:14,000 --> 00:20:16,000
TheTalkingMachines.com

430
00:20:18,000 --> 00:20:20,000
然后其中一主持人就是哈佛大学的

431
00:20:20,000 --> 00:20:22,000
Rayan

432
00:20:22,000 --> 00:20:24,000
Proscote

433
00:20:24,000 --> 00:20:26,000
Adams 教授

434
00:20:26,000 --> 00:20:28,000
他利用他的关系几乎在每一期都请来了

435
00:20:28,000 --> 00:20:30,000
一听名字就让我心跳加速的嘉宾

436
00:20:30,000 --> 00:20:32,000
不过 Adams

437
00:20:32,000 --> 00:20:34,000
教授在节目里面的一个

438
00:20:34,000 --> 00:20:36,000
保留项目就是用人类可以听懂的

439
00:20:36,000 --> 00:20:38,000
非常简单的语言

440
00:20:38,000 --> 00:20:40,000
解释非常复杂的算法

441
00:20:40,000 --> 00:20:42,000
比如推荐系统

442
00:20:42,000 --> 00:20:44,000
里面的

443
00:20:44,000 --> 00:20:46,000
Collaborative filtering

444
00:20:46,000 --> 00:20:48,000
怎么反应协同过滤

445
00:20:48,000 --> 00:20:50,000
再比如

446
00:20:50,000 --> 00:20:52,000
非参数被夜思

447
00:20:52,000 --> 00:20:54,000
推断中非常难的

448
00:20:54,000 --> 00:20:56,000
Chinese restaurant process

449
00:20:56,000 --> 00:20:58,000
中餐馆

450
00:20:58,000 --> 00:21:00,000
过程

451
00:21:00,000 --> 00:21:02,000
我查了一下这个中餐馆的过程是

452
00:21:02,000 --> 00:21:04,000
模拟一个有无限张圆桌

453
00:21:04,000 --> 00:21:06,000
每张圆桌能做

454
00:21:06,000 --> 00:21:08,000
无限个人的中餐馆里面

455
00:21:08,000 --> 00:21:10,000
做客人的随机过程

456
00:21:10,000 --> 00:21:12,000
为什么叫这个名字大概是

457
00:21:12,000 --> 00:21:14,000
在洋人眼里面只有

458
00:21:14,000 --> 00:21:16,000
中餐馆才会有圆桌吧

459
00:21:16,000 --> 00:21:18,000
以上是这位听众所推荐的

460
00:21:18,000 --> 00:21:20,000
应该是关于自然语言处理的

461
00:21:20,000 --> 00:21:22,000
一个 Podcast

462
00:21:22,000 --> 00:21:24,000
有兴趣的听众们不妨去听听

463
00:21:24,000 --> 00:21:26,000
最后他说 PS

464
00:21:26,000 --> 00:21:28,000
虽然吴涛说了不让再推荐嘉宾了

465
00:21:28,000 --> 00:21:30,000
但是 Please Please

466
00:21:30,000 --> 00:21:32,000
我们还是请一下 Kura 的 Vidam Chen 吧

467
00:21:32,000 --> 00:21:34,000
我想如果是要做一期

468
00:21:34,000 --> 00:21:36,000
有关 Data Science 的话题

469
00:21:36,000 --> 00:21:38,000
请来这样一个 Data Science

470
00:21:38,000 --> 00:21:40,000
才好吧

471
00:21:40,000 --> 00:21:42,000
我也知道请一个陌生人上节目

472
00:21:42,000 --> 00:21:44,000
还是挺难的

473
00:21:44,000 --> 00:21:46,000
Anyway Please Keep Up The Good Work

474
00:21:48,000 --> 00:21:50,000
感谢这位听众

475
00:21:50,000 --> 00:21:52,000
对我们的确是想要请一位

476
00:21:52,000 --> 00:21:54,000
获人价实的 Data Scientist

477
00:21:54,000 --> 00:21:56,000
来聊 Data Science

478
00:21:56,000 --> 00:21:58,000
的话题

479
00:21:58,000 --> 00:22:00,000
不过目前还没有合适的人选

480
00:22:00,000 --> 00:22:02,000
我去看一下这位 Vidam Chen

481
00:22:02,000 --> 00:22:04,000
是不是

482
00:22:04,000 --> 00:22:06,000
是不是

483
00:22:06,000 --> 00:22:08,000
首先是不是一个社会接近的人

484
00:22:08,000 --> 00:22:10,000
感谢这位听众

485
00:22:10,000 --> 00:22:12,000
接下来

486
00:22:12,000 --> 00:22:14,000
我想要提到的一些

487
00:22:14,000 --> 00:22:16,000
新闻就是

488
00:22:16,000 --> 00:22:18,000
其实有这一条

489
00:22:18,000 --> 00:22:20,000
Google RL

490
00:22:20,000 --> 00:22:22,000
我不知道明天的 ID 功能会怎样聊这个话题

491
00:22:22,000 --> 00:22:24,000
我希望他们会聊这个话题吧

492
00:22:24,000 --> 00:22:26,000
但是

493
00:22:26,000 --> 00:22:28,000
从开发者层面上来说

494
00:22:28,000 --> 00:22:30,000
这次 Google IO

495
00:22:30,000 --> 00:22:32,000
大会让我印象比较深的

496
00:22:32,000 --> 00:22:34,000
当然我没有完全看这个大会

497
00:22:34,000 --> 00:22:36,000
我只是事后去看了一下

498
00:22:36,000 --> 00:22:38,000
Summary

499
00:22:38,000 --> 00:22:40,000
因为要上班

500
00:22:40,000 --> 00:22:42,000
就这次 Google IO 的

501
00:22:42,000 --> 00:22:44,000
在我看来的亮点就是

502
00:22:44,000 --> 00:22:46,000
首先是安装的 Studio IDE

503
00:22:46,000 --> 00:22:48,000
应该是 1.3 版吧

504
00:22:48,000 --> 00:22:50,000
增加了 NDK 的支持

505
00:22:50,000 --> 00:22:52,000
就是 Native

506
00:22:52,000 --> 00:22:54,000
Developer Kit

507
00:22:54,000 --> 00:22:56,000
你可以在

508
00:22:56,000 --> 00:22:58,000
他应该是使用了

509
00:22:58,000 --> 00:23:00,000
JetBrains 的 C-Line

510
00:23:00,000 --> 00:23:02,000
来支持

511
00:23:02,000 --> 00:23:04,000
用 C++

512
00:23:04,000 --> 00:23:06,000
写安装的 app

513
00:23:06,000 --> 00:23:08,000
其次就是 Google IO 此次出现了一个

514
00:23:08,000 --> 00:23:10,000
专门为 Internet

515
00:23:10,000 --> 00:23:12,000
Sense

516
00:23:12,000 --> 00:23:14,000
所开发的操作系统

517
00:23:14,000 --> 00:23:16,000
叫做 Brillo

518
00:23:16,000 --> 00:23:18,000
名字有点奇怪

519
00:23:18,000 --> 00:23:20,000
Brillo 就是一个

520
00:23:20,000 --> 00:23:22,000
被 strip down 的

521
00:23:22,000 --> 00:23:24,000
安装的系统

522
00:23:24,000 --> 00:23:26,000
你可以把它装在一些

523
00:23:26,000 --> 00:23:28,000
智能家电上

524
00:23:28,000 --> 00:23:30,000
甚至都不一定是家电

525
00:23:30,000 --> 00:23:32,000
就是一些电池比如说电灯啊

526
00:23:32,000 --> 00:23:34,000
电扇啊之类的东西上

527
00:23:34,000 --> 00:23:36,000
烟火演戏啊之类的

528
00:23:36,000 --> 00:23:38,000
你在上面插一个芯片

529
00:23:38,000 --> 00:23:40,000
然后装上这个东西

530
00:23:40,000 --> 00:23:42,000
然后

531
00:23:42,000 --> 00:23:44,000
automatically 这个东西就变成了一个

532
00:23:44,000 --> 00:23:46,000
智能家电

533
00:23:46,000 --> 00:23:48,000
你可以用你的安装的设备

534
00:23:48,000 --> 00:23:50,000
去操纵它

535
00:23:50,000 --> 00:23:52,000
最初的也就是这个

536
00:23:54,000 --> 00:23:56,000
这种小芯片

537
00:23:56,000 --> 00:23:58,000
互相通信的一种

538
00:23:58,000 --> 00:24:00,000
怎么说呢

539
00:24:00,000 --> 00:24:02,000
Communication layer

540
00:24:02,000 --> 00:24:04,000
就是一个通信层

541
00:24:04,000 --> 00:24:06,000
它的名字叫做 Weave

542
00:24:06,000 --> 00:24:08,000
也就是 W-E-A

543
00:24:08,000 --> 00:24:10,000
V-E

544
00:24:10,000 --> 00:24:12,000
这让我想起那个

545
00:24:12,000 --> 00:24:14,000
Google Wave

546
00:24:14,000 --> 00:24:16,000
那个

547
00:24:16,000 --> 00:24:18,000
已经正式开死附中

548
00:24:18,000 --> 00:24:20,000
理念超前

549
00:24:20,000 --> 00:24:22,000
Hype 无比但是最后

550
00:24:22,000 --> 00:24:24,000
就这么默默的

551
00:24:24,000 --> 00:24:26,000
消失掉了 Google Wave

552
00:24:26,000 --> 00:24:28,000
我其实我希望

553
00:24:28,000 --> 00:24:30,000
Brillo 和 Wave

554
00:24:30,000 --> 00:24:32,000
可以早点推广开来

555
00:24:32,000 --> 00:24:34,000
因为这样的话可能

556
00:24:34,000 --> 00:24:36,000
智能家电会比较

557
00:24:36,000 --> 00:24:38,000
提前进入我们生活

558
00:24:38,000 --> 00:24:40,000
我其实已经妄想过

559
00:24:40,000 --> 00:24:42,000
智能家电

560
00:24:42,000 --> 00:24:44,000
无处不在的场景了

561
00:24:44,000 --> 00:24:46,000
未来怎么还不到

562
00:24:46,000 --> 00:24:48,000
有一部电影叫做回到未来

563
00:24:48,000 --> 00:24:50,000
Back to the Future

564
00:24:50,000 --> 00:24:52,000
应该是拍摄于

565
00:24:52,000 --> 00:24:54,000
85 年即之后的三部

566
00:24:54,000 --> 00:24:56,000
关于时空旅行的电影

567
00:24:58,000 --> 00:25:00,000
其中主角在 1985 年所

568
00:25:00,000 --> 00:25:02,000
前进 30 年去到了

569
00:25:02,000 --> 00:25:04,000
2015 年

570
00:25:04,000 --> 00:25:06,000
也就是今年

571
00:25:06,000 --> 00:25:08,000
Incidentally

572
00:25:08,000 --> 00:25:10,000
10 月 15 号

573
00:25:10,000 --> 00:25:12,000
在 1985 年

574
00:25:12,000 --> 00:25:14,000
在 1985 年

575
00:25:14,000 --> 00:25:16,000
10 月 15 号吧

576
00:25:16,000 --> 00:25:18,000
还是 20 号没几错的话

577
00:25:18,000 --> 00:25:20,000
那天

578
00:25:20,000 --> 00:25:22,000
离我们录节目的今天

579
00:25:22,000 --> 00:25:24,000
大概也只有

580
00:25:24,000 --> 00:25:26,000
150 天左右

581
00:25:26,000 --> 00:25:28,000
然后电影里面的

582
00:25:28,000 --> 00:25:30,000
2015 年

583
00:25:30,000 --> 00:25:32,000
在

584
00:25:32,000 --> 00:25:34,000
有些地方是不如现在的 2015 年

585
00:25:34,000 --> 00:25:36,000
但是在很多其他地方是

586
00:25:36,000 --> 00:25:38,000
远远超越今天的科技水准

587
00:25:38,000 --> 00:25:40,000
就是

588
00:25:40,000 --> 00:25:42,000
智能家电就不说了

589
00:25:42,000 --> 00:25:44,000
它里面有个叫做 Mist Fusion 的能源装置

590
00:25:46,000 --> 00:25:48,000
可以装在车上

591
00:25:48,000 --> 00:25:50,000
只要往里面扔一些垃圾

592
00:25:50,000 --> 00:25:52,000
它就可以通过聚变来产生非常非常多的能量

593
00:25:52,000 --> 00:25:54,000
这能量足以支持让一辆车

594
00:25:54,000 --> 00:25:56,000
产生

595
00:25:56,000 --> 00:25:58,000
时空旅行

596
00:25:58,000 --> 00:26:00,000
然后还有一些非常神奇的其他东西

597
00:26:00,000 --> 00:26:02,000
比如说

598
00:26:02,000 --> 00:26:04,000
漂浮滑板

599
00:26:04,000 --> 00:26:06,000
漂浮滑板这个东西在

600
00:26:06,000 --> 00:26:08,000
我们 2015 年还是没有被实现出来

601
00:26:08,000 --> 00:26:10,000
最重要的一点是里面的车

602
00:26:10,000 --> 00:26:12,000
都是能飞的

603
00:26:12,000 --> 00:26:14,000
我觉得前一陣子在知乎上有个问题

604
00:26:14,000 --> 00:26:16,000
就是为什么

605
00:26:16,000 --> 00:26:18,000
说我们在 40 年前想要的是飞车

606
00:26:18,000 --> 00:26:20,000
而现在我们得到的

607
00:26:20,000 --> 00:26:22,000
只是 140 个字符

608
00:26:22,000 --> 00:26:24,000
当然说这个话的人是

609
00:26:24,000 --> 00:26:26,000
没记错的话

610
00:26:26,000 --> 00:26:28,000
是 Tesla 的投资人之一吧

611
00:26:28,000 --> 00:26:30,000
不是 Elon Musk 他自己

612
00:26:30,000 --> 00:26:32,000
但是这个人也是一个

613
00:26:32,000 --> 00:26:34,000
科技界的推手人士

614
00:26:34,000 --> 00:26:36,000
他说这些话的原因

615
00:26:36,000 --> 00:26:38,000
其实本质上是励志

616
00:26:38,000 --> 00:26:40,000
但是当然有些人把它当成一句吐槽来看

617
00:26:42,000 --> 00:26:44,000
重点就是

618
00:26:44,000 --> 00:26:46,000
我们对于未来的想象

619
00:26:46,000 --> 00:26:48,000
很有可能是偏差非常大的

620
00:26:48,000 --> 00:26:50,000
但是这并不

621
00:26:50,000 --> 00:26:52,000
应该妨碍我们去想象呗

622
00:26:52,000 --> 00:26:54,000
对 我就是希望智能家居可以早点

623
00:26:54,000 --> 00:26:56,000
铺开来

624
00:26:56,000 --> 00:26:58,000
应用

625
00:26:58,000 --> 00:27:00,000
让我们今天能够

626
00:27:00,000 --> 00:27:02,000
在某种程度上

627
00:27:02,000 --> 00:27:04,000
在比较方便

628
00:27:04,000 --> 00:27:06,000
方便的

629
00:27:06,000 --> 00:27:08,000
部分

630
00:27:08,000 --> 00:27:10,000
能够超越那个时候对于未来的想象

631
00:27:14,000 --> 00:27:16,000
关于飞车这个东西

632
00:27:16,000 --> 00:27:18,000
我觉得

633
00:27:18,000 --> 00:27:20,000
我之前在直播上看到

634
00:27:20,000 --> 00:27:22,000
这个问题的时候

635
00:27:22,000 --> 00:27:24,000
里面有人通过各种

636
00:27:24,000 --> 00:27:26,000
例子来论证了为什么

637
00:27:26,000 --> 00:27:28,000
140 个字符比飞车更重要

638
00:27:28,000 --> 00:27:30,000
说

639
00:27:30,000 --> 00:27:32,000
如果你可以更便捷的

640
00:27:32,000 --> 00:27:34,000
和离你

641
00:27:34,000 --> 00:27:36,000
很远的人通讯

642
00:27:36,000 --> 00:27:38,000
你就不需要去到那个人身边了

643
00:27:38,000 --> 00:27:40,000
如果你可以开

644
00:27:40,000 --> 00:27:42,000
Teleconference 的话

645
00:27:42,000 --> 00:27:44,000
你就不需要亲自跑到那个地方去

646
00:27:44,000 --> 00:27:46,000
所以

647
00:27:46,000 --> 00:27:48,000
有 140 个字符的便捷的

648
00:27:48,000 --> 00:27:50,000
交流方式其实是要比飞车

649
00:27:50,000 --> 00:27:52,000
重要的 我承认它有一定的道理

650
00:27:52,000 --> 00:27:54,000
但是

651
00:27:54,000 --> 00:27:56,000
我总觉得如果飞车

652
00:27:56,000 --> 00:27:58,000
这个东西真的可以出现的话

653
00:27:58,000 --> 00:28:00,000
或者说一个

654
00:28:00,000 --> 00:28:02,000
比较 飞车其实已经出现了

655
00:28:02,000 --> 00:28:04,000
现在已经有可以飞起来的汽车

656
00:28:04,000 --> 00:28:06,000
但是

657
00:28:06,000 --> 00:28:08,000
最大的问题是这个汽车

658
00:28:08,000 --> 00:28:10,000
首先它需要专门的跑道

659
00:28:10,000 --> 00:28:12,000
第二它

660
00:28:12,000 --> 00:28:14,000
飞的时候其实不是非常的灵活

661
00:28:16,000 --> 00:28:18,000
第三就是能耗非常高

662
00:28:18,000 --> 00:28:20,000
但是如果有 Mr.Fusion

663
00:28:20,000 --> 00:28:22,000
出现的话 能耗不是问题

664
00:28:22,000 --> 00:28:24,000
但最大的问题是

665
00:28:24,000 --> 00:28:26,000
我们想要的飞车其实像 Back to the future

666
00:28:26,000 --> 00:28:28,000
里面那样只需要把四个轮子

667
00:28:28,000 --> 00:28:30,000
朝下然后就可以

668
00:28:30,000 --> 00:28:32,000
直接悬浮起来的飞车

669
00:28:32,000 --> 00:28:34,000
或者像什么第五元素里面那种飞车

670
00:28:34,000 --> 00:28:36,000
那才是真正实用的飞车 对吧

671
00:28:36,000 --> 00:28:38,000
这样飞车解决了一个什么样的问题呢

672
00:28:38,000 --> 00:28:40,000
就是你不再需要坐飞机了

673
00:28:40,000 --> 00:28:42,000
你不再需要坐

674
00:28:42,000 --> 00:28:44,000
月阳飞机了

675
00:28:44,000 --> 00:28:46,000
点对点的直线

676
00:28:46,000 --> 00:28:48,000
交通变得非常的简单

677
00:28:50,000 --> 00:28:52,000
单一模式化

678
00:28:52,000 --> 00:28:54,000
比如说在 Back to the future 里面

679
00:28:54,000 --> 00:28:56,000
他们设想说整个美洲

680
00:28:56,000 --> 00:28:58,000
乃至于跨洲的航路

681
00:29:00,000 --> 00:29:02,000
像高速公路一样

682
00:29:02,000 --> 00:29:04,000
是已经预先化好了

683
00:29:04,000 --> 00:29:06,000
比如说如果你想从中国到美国的话

684
00:29:06,000 --> 00:29:08,000
你只需要开上自己的飞车

685
00:29:08,000 --> 00:29:10,000
从自己家的门前出发

686
00:29:10,000 --> 00:29:12,000
然后飞到高速公路上

687
00:29:12,000 --> 00:29:14,000
然后就沿着自...

688
00:29:14,000 --> 00:29:16,000
我相信一定有什么导航技术

689
00:29:16,000 --> 00:29:18,000
就是你只要坐在车里面

690
00:29:18,000 --> 00:29:20,000
然后等 这个车就会把你带到

691
00:29:20,000 --> 00:29:22,000
你在美国要去的那个地方的路旁

692
00:29:22,000 --> 00:29:24,000
这是一个非常点对点的服务

693
00:29:24,000 --> 00:29:26,000
就是

694
00:29:26,000 --> 00:29:28,000
不像现在我们需要先

695
00:29:28,000 --> 00:29:30,000
从家里面坐车到机场

696
00:29:30,000 --> 00:29:32,000
然后拖远行李 然后拆屁

697
00:29:32,000 --> 00:29:34,000
然后过安检 然后 blabla

698
00:29:34,000 --> 00:29:36,000
跟几百个不知道是不是恐怖分子

699
00:29:36,000 --> 00:29:38,000
的人坐在一起

700
00:29:38,000 --> 00:29:40,000
然后把自己的生命交在机场手里

701
00:29:40,000 --> 00:29:42,000
如果有飞车的话这一切都不需要了

702
00:29:42,000 --> 00:29:44,000
我们可以单独的

703
00:29:44,000 --> 00:29:46,000
坐在属于自己的一样

704
00:29:46,000 --> 00:29:48,000
一个一个封闭空间里面

705
00:29:48,000 --> 00:29:50,000
自己想带什么就带什么

706
00:29:50,000 --> 00:29:52,000
想带多少带多少

707
00:29:52,000 --> 00:29:54,000
只要你能

708
00:29:54,000 --> 00:29:56,000
如果有 Mr.Fusion 的话

709
00:29:56,000 --> 00:29:58,000
永远不是问题

710
00:29:58,000 --> 00:30:00,000
就这样的技术带给我们的自由度

711
00:30:00,000 --> 00:30:02,000
其实是要远远高于

712
00:30:02,000 --> 00:30:04,000
飞机或者是

713
00:30:04,000 --> 00:30:06,000
现有的任何交通工具

714
00:30:06,000 --> 00:30:08,000
所以我觉得飞车仍旧是一个非常

715
00:30:08,000 --> 00:30:10,000
重要值得梦想的事情

716
00:30:10,000 --> 00:30:12,000
不过有生之年应该是看不到的

717
00:30:12,000 --> 00:30:14,000
我觉得

718
00:30:14,000 --> 00:30:16,000
而且更不用提在 Back to the future 里面

719
00:30:16,000 --> 00:30:18,000
主角其实

720
00:30:18,000 --> 00:30:20,000
不是主角 就是未来 2015 年

721
00:30:20,000 --> 00:30:22,000
其实根本就没有

722
00:30:22,000 --> 00:30:24,000
不需要飞车 而是

723
00:30:24,000 --> 00:30:26,000
飞车改装服务

724
00:30:26,000 --> 00:30:28,000
只需要装四个轮子

725
00:30:28,000 --> 00:30:30,000
就可以让自己的车飞起来

726
00:30:30,000 --> 00:30:32,000
永远不是像现在这样

727
00:30:32,000 --> 00:30:34,000
你需要把整个

728
00:30:34,000 --> 00:30:36,000
车构造都改了

729
00:30:36,000 --> 00:30:38,000
OK

730
00:30:38,000 --> 00:30:40,000
在进入主题之前

731
00:30:40,000 --> 00:30:42,000
为了填充节目时间

732
00:30:42,000 --> 00:30:44,000
我们先来讨论一下

733
00:30:44,000 --> 00:30:46,000
计算机的编码

734
00:30:46,000 --> 00:30:48,000
这是一个压箱底的话题

735
00:30:48,000 --> 00:30:50,000
就是为了专门应付今天这种

736
00:30:50,000 --> 00:30:52,000
为了保证节目不断党

737
00:30:52,000 --> 00:30:54,000
但是又有可能

738
00:30:54,000 --> 00:30:56,000
有人缺席的情况准备

739
00:30:56,000 --> 00:30:58,000
编码

740
00:30:58,000 --> 00:31:00,000
或者说 encoding

741
00:31:00,000 --> 00:31:02,000
是一个非常常见的

742
00:31:02,000 --> 00:31:04,000
非常复杂的概念

743
00:31:04,000 --> 00:31:06,000
首先 encoding 和 coding 是不一样的

744
00:31:06,000 --> 00:31:08,000
我们口语里面应该会用

745
00:31:08,000 --> 00:31:10,000
写代码

746
00:31:10,000 --> 00:31:12,000
来指代写什么字这件事情

747
00:31:12,000 --> 00:31:14,000
但是有时候人们也会

748
00:31:14,000 --> 00:31:16,000
口误或者说

749
00:31:16,000 --> 00:31:18,000
无心的说编码

750
00:31:18,000 --> 00:31:20,000
用编码这个词来指代写常趣

751
00:31:20,000 --> 00:31:22,000
但是编码在比较

752
00:31:22,000 --> 00:31:24,000
当你比较严格的

753
00:31:24,000 --> 00:31:26,000
区分自己的错词的时候

754
00:31:26,000 --> 00:31:28,000
编码指的是 encoding

755
00:31:28,000 --> 00:31:30,000
encoding 是一个非常常见的时候

756
00:31:30,000 --> 00:31:32,000
非常复杂的概念

757
00:31:32,000 --> 00:31:34,000
常见是因为

758
00:31:34,000 --> 00:31:36,000
每时每刻我们每时每时跟它接触

759
00:31:36,000 --> 00:31:38,000
尤其是如果要

760
00:31:38,000 --> 00:31:40,000
coding 的话

761
00:31:40,000 --> 00:31:42,000
几乎完全是绕不开 encoding 的

762
00:31:42,000 --> 00:31:44,000
尤其是如果你不是一个

763
00:31:44,000 --> 00:31:46,000
专制的程序员

764
00:31:46,000 --> 00:31:48,000
可以不懂数学结构

765
00:31:48,000 --> 00:31:50,000
比如说你是搞 web 的

766
00:31:50,000 --> 00:31:52,000
可能 sorry 我又黑 web

767
00:31:52,000 --> 00:31:54,000
你是搞 web 前端的

768
00:31:54,000 --> 00:31:56,000
你可能完全不需要

769
00:31:56,000 --> 00:31:58,000
去接触算法或者数学结构

770
00:31:58,000 --> 00:32:00,000
你照样可以活得很好

771
00:32:00,000 --> 00:32:02,000
但是 encoding 这个问题

772
00:32:02,000 --> 00:32:04,000
没有可能绕开

773
00:32:04,000 --> 00:32:06,000
如果你像回避

774
00:32:06,000 --> 00:32:08,000
算法数学结构一样去回避 encoding

775
00:32:08,000 --> 00:32:10,000
很有可能会摔得很惨

776
00:32:10,000 --> 00:32:12,000
而即便是

777
00:32:12,000 --> 00:32:14,000
不写程序的人

778
00:32:14,000 --> 00:32:16,000
懂一些 encoding 也是一个

779
00:32:16,000 --> 00:32:18,000
也是一件非常有意义的事情

780
00:32:18,000 --> 00:32:20,000
比如说我记得

781
00:32:20,000 --> 00:32:22,000
很久以前大概是

782
00:32:22,000 --> 00:32:24,000
天哪那个时候我还在

783
00:32:24,000 --> 00:32:26,000
读《夜流生》

784
00:32:26,000 --> 00:32:28,000
那个时候有一个网站叫

785
00:32:28,000 --> 00:32:30,000
现在也有这个网站叫 dailywtf

786
00:32:30,000 --> 00:32:32,000
dailywtf

787
00:32:32,000 --> 00:32:34,000
当然它的官方名字叫 daily worse than failure

788
00:32:34,000 --> 00:32:36,000
但是我们都知道 wtf 是什么意思

789
00:32:36,000 --> 00:32:38,000
然后在这个网站上面

790
00:32:38,000 --> 00:32:40,000
有这样一则当时

791
00:32:40,000 --> 00:32:42,000
应该是

792
00:32:42,000 --> 00:32:44,000
一堆图片新闻里面的一条

793
00:32:44,000 --> 00:32:46,000
我记得是有人拍了一个包裹单

794
00:32:46,000 --> 00:32:48,000
这个包裹单是

795
00:32:48,000 --> 00:32:50,000
贴在一个包裹上面的

796
00:32:50,000 --> 00:32:52,000
然后这个包裹是寄给德国某个地址的

797
00:32:52,000 --> 00:32:54,000
这个地址里面有一个地方被

798
00:32:54,000 --> 00:32:56,000
寄件人

799
00:32:56,000 --> 00:32:58,000
化成了一个方块

800
00:32:58,000 --> 00:33:00,000
比如说有一个德国的地址叫做 gr

801
00:33:00,000 --> 00:33:02,000
方块

802
00:33:02,000 --> 00:33:04,000
然后 blabla

803
00:33:04,000 --> 00:33:06,000
str

804
00:33:06,000 --> 00:33:08,000
然后多少号

805
00:33:08,000 --> 00:33:10,000
原因是什么呢

806
00:33:10,000 --> 00:33:12,000
因为显示这个德国的地址的时候

807
00:33:12,000 --> 00:33:14,000
没能正确的把

808
00:33:14,000 --> 00:33:16,000
o 上加 2 点

809
00:33:16,000 --> 00:33:18,000
就是 oumlout

810
00:33:18,000 --> 00:33:20,000
这个字母显示出来

811
00:33:20,000 --> 00:33:22,000
它的计算机系统就把那个地方显示成了方块

812
00:33:22,000 --> 00:33:24,000
然后就非常忠诚的

813
00:33:24,000 --> 00:33:26,000
在那个地方化了一个方块

814
00:33:26,000 --> 00:33:28,000
如果这位寄件人

815
00:33:28,000 --> 00:33:30,000
动验 encoding 的知识的话

816
00:33:30,000 --> 00:33:32,000
这样的笑话就不会发生了

817
00:33:32,000 --> 00:33:34,000
另外比如说

818
00:33:34,000 --> 00:33:36,000
有时候

819
00:33:36,000 --> 00:33:38,000
各位在看网页的时候会发现网页上面有问号

820
00:33:38,000 --> 00:33:40,000
或者是

821
00:33:40,000 --> 00:33:42,000
莫名其妙的一些问号

822
00:33:42,000 --> 00:33:44,000
我们会说这个时候有论码

823
00:33:44,000 --> 00:33:46,000
那这个时候应该怎么解决呢

824
00:33:46,000 --> 00:33:48,000
知道的人可能会去

825
00:33:48,000 --> 00:33:50,000
我忘了 chrome 是在哪了

826
00:33:50,000 --> 00:33:52,000
chrome 好像是在兔子里面

827
00:33:52,000 --> 00:33:54,000
你要去一个地方

828
00:33:54,000 --> 00:33:56,000
选择说

829
00:33:56,000 --> 00:33:58,000
这个网页是用什么样的 encoding

830
00:33:58,000 --> 00:34:00,000
来

831
00:34:00,000 --> 00:34:02,000
encoding

832
00:34:02,000 --> 00:34:04,000
这个网页

833
00:34:04,000 --> 00:34:06,000
是用什么标准来 encoding

834
00:34:06,000 --> 00:34:08,000
你选对了一个标准

835
00:34:08,000 --> 00:34:10,000
然后你就可以看到正确

836
00:34:10,000 --> 00:34:12,000
无误的信息

837
00:34:12,000 --> 00:34:14,000
又比如以前我们

838
00:34:14,000 --> 00:34:16,000
玩一些

839
00:34:16,000 --> 00:34:18,000
很有意思的日文游戏的时候

840
00:34:18,000 --> 00:34:20,000
为什么在简体中文操作

841
00:34:20,000 --> 00:34:22,000
许多人跑起来是乱码

842
00:34:22,000 --> 00:34:24,000
对

843
00:34:24,000 --> 00:34:26,000
这一切的原因

844
00:34:26,000 --> 00:34:28,000
其实都是因为 encoding

845
00:34:28,000 --> 00:34:30,000
那为什么会有 encoding 的问题呢

846
00:34:30,000 --> 00:34:32,000
答案是因为

847
00:34:32,000 --> 00:34:34,000
二紧直

848
00:34:34,000 --> 00:34:36,000
所谓

849
00:34:36,000 --> 00:34:38,000
计算机是一个二紧直的

850
00:34:38,000 --> 00:34:40,000
东西这句话我们多多少少都听过

851
00:34:40,000 --> 00:34:42,000
但是

852
00:34:42,000 --> 00:34:44,000
就比如说

853
00:34:44,000 --> 00:34:46,000
我们都明白计算机在内部只懂得

854
00:34:46,000 --> 00:34:48,000
0 和 1

855
00:34:48,000 --> 00:34:50,000
芯片上面有一个地方是高电瓶

856
00:34:50,000 --> 00:34:52,000
低电瓶就是 0

857
00:34:52,000 --> 00:34:54,000
然后磁盘上面

858
00:34:54,000 --> 00:34:56,000
有一个地方比如说

859
00:34:56,000 --> 00:34:58,000
北磁集朝上就是 1

860
00:34:58,000 --> 00:35:00,000
北磁集朝下就是 0

861
00:35:00,000 --> 00:35:02,000
我不确定这个说法正不正确

862
00:35:02,000 --> 00:35:04,000
北磁集朝上就是 1 不太是 0

863
00:35:04,000 --> 00:35:06,000
还是北磁集朝是 1 南磁集朝是 0

864
00:35:06,000 --> 00:35:08,000
欢迎大家指正

865
00:35:08,000 --> 00:35:10,000
然后比如说光盘上面

866
00:35:10,000 --> 00:35:12,000
有坑就是 1 没坑就是 0

867
00:35:12,000 --> 00:35:14,000
这五次

868
00:35:14,000 --> 00:35:16,000
然后

869
00:35:16,000 --> 00:35:18,000
反过来平时

870
00:35:18,000 --> 00:35:20,000
使用电脑的时候你跟我却明明

871
00:35:20,000 --> 00:35:22,000
没有直接再跟 0 和 1 打交道

872
00:35:22,000 --> 00:35:24,000
不是吗比如说我们能看到

873
00:35:24,000 --> 00:35:26,000
文字

874
00:35:26,000 --> 00:35:28,000
我们能听到声音比如说各位现在听

875
00:35:28,000 --> 00:35:30,000
podcast

876
00:35:30,000 --> 00:35:32,000
我们能看到图片以及一些

877
00:35:32,000 --> 00:35:34,000
高雅的小电影

878
00:35:34,000 --> 00:35:36,000
这些东西

879
00:35:36,000 --> 00:35:38,000
都不是 0 和 1 不是吗

880
00:35:38,000 --> 00:35:40,000
在我们的观感来说

881
00:35:40,000 --> 00:35:42,000
这些东西都是切切实实的

882
00:35:42,000 --> 00:35:44,000
一些模拟

883
00:35:44,000 --> 00:35:46,000
信号不是吗

884
00:35:46,000 --> 00:35:48,000
那么具体讲的那些 0 和 1 在哪呢

885
00:35:50,000 --> 00:35:52,000
这个就要扯到

886
00:35:52,000 --> 00:35:54,000
比较

887
00:35:54,000 --> 00:35:56,000
古早的历史才能让

888
00:35:56,000 --> 00:35:58,000
大家有一个比较

889
00:35:58,000 --> 00:36:00,000
清晰的认识

890
00:36:00,000 --> 00:36:02,000
乃至于包括程序

891
00:36:02,000 --> 00:36:04,000
本身其实也都是 0 和 1 但是

892
00:36:04,000 --> 00:36:06,000
写过程序的各位

893
00:36:06,000 --> 00:36:08,000
都知道我们写程序的时候

894
00:36:08,000 --> 00:36:10,000
并不是直接写下 0 和 1

895
00:36:10,000 --> 00:36:12,000
以下内容部分摘字

896
00:36:12,000 --> 00:36:14,000
我在支付上的一个答案所以

897
00:36:14,000 --> 00:36:16,000
如果各位读过的话基本上

898
00:36:16,000 --> 00:36:18,000
就可以跳过了就可以直接拉到

899
00:36:18,000 --> 00:36:20,000
最后来听这个本期的主题

900
00:36:20,000 --> 00:36:22,000
就是程序员

901
00:36:22,000 --> 00:36:24,000
自养泡泡女朋友

902
00:36:24,000 --> 00:36:26,000
用泡这词是不太正确的

903
00:36:26,000 --> 00:36:28,000
首先要抛弃泡这个概念

904
00:36:28,000 --> 00:36:30,000
anyway 在

905
00:36:30,000 --> 00:36:32,000
计算机还都是一些旁人大物的

906
00:36:32,000 --> 00:36:34,000
实际时代我们写程序是靠

907
00:36:34,000 --> 00:36:36,000
机器语言

908
00:36:36,000 --> 00:36:38,000
虽然名字叫做机器语言

909
00:36:38,000 --> 00:36:40,000
但实际上用到的

910
00:36:40,000 --> 00:36:42,000
只有两个数字而已就是 0 和 1

911
00:36:42,000 --> 00:36:46,000
当然前提是你不去考虑三进直计算机

912
00:36:46,000 --> 00:36:48,000
对

913
00:36:48,000 --> 00:36:50,000
三进直计算机实际上是一个非常有意思的话题

914
00:36:50,000 --> 00:36:54,000
正确来说是平衡三进直计算机

915
00:36:54,000 --> 00:36:56,000
就是

916
00:36:56,000 --> 00:37:00,000
各位应该可以比较容易的想象什么是三进直

917
00:37:00,000 --> 00:37:02,000
就是纯粹的三进直

918
00:37:02,000 --> 00:37:04,000
就是只用 012 的三个数字

919
00:37:04,000 --> 00:37:06,000
0 是 0

920
00:37:06,000 --> 00:37:08,000
1 是 122

921
00:37:08,000 --> 00:37:10,000
3 是 10 对吧

922
00:37:10,000 --> 00:37:12,000
那么什么是平衡三进直的

923
00:37:12,000 --> 00:37:14,000
平衡三进直是说

924
00:37:14,000 --> 00:37:16,000
用 1 0

925
00:37:16,000 --> 00:37:18,000
和-1

926
00:37:18,000 --> 00:37:20,000
这三个数字

927
00:37:20,000 --> 00:37:22,000
来代表一切其他

928
00:37:22,000 --> 00:37:24,000
来代表一切数字

929
00:37:24,000 --> 00:37:26,000
来组合成为一切数字

930
00:37:26,000 --> 00:37:28,000
比如说在个位上是 0

931
00:37:28,000 --> 00:37:30,000
就是 0

932
00:37:30,000 --> 00:37:32,000
在个位上是 1 就是 1

933
00:37:32,000 --> 00:37:34,000
在个位上是-1 就是-1

934
00:37:34,000 --> 00:37:36,000
那么 2 怎么表示呢

935
00:37:36,000 --> 00:37:38,000
很有意思

936
00:37:38,000 --> 00:37:40,000
因为 10 的话

937
00:37:40,000 --> 00:37:42,000
在平衡三进直里面是

938
00:37:42,000 --> 00:37:44,000
代表

939
00:37:44,000 --> 00:37:46,000
3

940
00:37:46,000 --> 00:37:48,000
所以如果你要

941
00:37:48,000 --> 00:37:50,000
想要凑出一个 2 来的话

942
00:37:50,000 --> 00:37:52,000
各位上面

943
00:37:52,000 --> 00:37:54,000
写上一个-1

944
00:37:54,000 --> 00:37:56,000
也就是平衡三进直的 0 是 0

945
00:37:56,000 --> 00:37:58,000
1 是 1

946
00:37:58,000 --> 00:38:00,000
2 则是

947
00:38:00,000 --> 00:38:02,000
1-1

948
00:38:02,000 --> 00:38:04,000
就是平衡三进直里面通常会把-1 这个数字写成 t

949
00:38:04,000 --> 00:38:06,000
也就是 2 会变成 1 t

950
00:38:06,000 --> 00:38:08,000
也就是 2 会变成 1 t

951
00:38:08,000 --> 00:38:10,000
写成 t 是因为-

952
00:38:10,000 --> 00:38:12,000
如果你把-1 放在 1 上面的话

953
00:38:12,000 --> 00:38:14,000
它就看着它像一个 t

954
00:38:14,000 --> 00:38:16,000
这是一个

955
00:38:16,000 --> 00:38:18,000
非常特别

956
00:38:18,000 --> 00:38:20,000
但是对于计算机来说

957
00:38:20,000 --> 00:38:22,000
比较好实现的一种

958
00:38:22,000 --> 00:38:24,000
进制方法就是

959
00:38:24,000 --> 00:38:26,000
如果你维持一个中等

960
00:38:26,000 --> 00:38:28,000
电位的话它是 0

961
00:38:28,000 --> 00:38:30,000
一个比较高的电位的话是 1

962
00:38:30,000 --> 00:38:32,000
然后一个比较低的电位的话是-1

963
00:38:32,000 --> 00:38:34,000
平衡三进直

964
00:38:34,000 --> 00:38:36,000
有一些比较特别的

965
00:38:36,000 --> 00:38:38,000
数学特性

966
00:38:38,000 --> 00:38:40,000
比如说在平衡三进直里面

967
00:38:40,000 --> 00:38:42,000
有时候一些数字的表示方法

968
00:38:42,000 --> 00:38:44,000
有两个

969
00:38:44,000 --> 00:38:46,000
比如说 1 可以表示为

970
00:38:46,000 --> 00:38:48,000
0.11 无限循环

971
00:38:48,000 --> 00:38:50,000
或者是 1.-1

972
00:38:50,000 --> 00:38:52,000
无限循环

973
00:38:52,000 --> 00:38:54,000
然后有时候也会有一些比较

974
00:38:54,000 --> 00:38:56,000
特别的

975
00:38:56,000 --> 00:38:58,000
特性比如说在成法的时候

976
00:38:58,000 --> 00:39:00,000
有时候你会明明是

977
00:39:00,000 --> 00:39:02,000
两个多位数相乘

978
00:39:02,000 --> 00:39:04,000
最后你得出的结果的

979
00:39:04,000 --> 00:39:06,000
位数反而要比两个

980
00:39:06,000 --> 00:39:08,000
要比原来你用来

981
00:39:08,000 --> 00:39:10,000
乘的两个数字的位数要短

982
00:39:12,000 --> 00:39:14,000
对但是

983
00:39:14,000 --> 00:39:16,000
三进直这段期最终是没有能成气候

984
00:39:16,000 --> 00:39:18,000
我相信如果

985
00:39:18,000 --> 00:39:20,000
三体人

986
00:39:20,000 --> 00:39:22,000
或者是

987
00:39:22,000 --> 00:39:24,000
比较正儿八经的科幻里面

988
00:39:24,000 --> 00:39:26,000
有一部科幻叫做与拉玛相会

989
00:39:26,000 --> 00:39:28,000
如果各位没有看过的话

990
00:39:28,000 --> 00:39:30,000
非常欢迎去看一看

991
00:39:30,000 --> 00:39:32,000
要比三体不知道高到哪里去了

992
00:39:34,000 --> 00:39:36,000
也许三体人会使用三进直三级

993
00:39:38,000 --> 00:39:40,000
但是呢在我们地球上面

994
00:39:40,000 --> 00:39:42,000
目前

995
00:39:42,000 --> 00:39:44,000
占主流的

996
00:39:44,000 --> 00:39:46,000
绝对主流的压倒性主流的是

997
00:39:46,000 --> 00:39:48,000
二进直计算机

998
00:39:48,000 --> 00:39:50,000
所以

999
00:39:50,000 --> 00:39:52,000
早期的写程序也就是

1000
00:39:52,000 --> 00:39:54,000
使用特定的二进直的组合

1001
00:39:56,000 --> 00:39:58,000
来给计算机下命令

1002
00:39:58,000 --> 00:40:00,000
因为一些特定的数字组合

1003
00:40:00,000 --> 00:40:02,000
对于计算机来说有特定的意义

1004
00:40:02,000 --> 00:40:04,000
会让计算机做出一些特定的动作

1005
00:40:06,000 --> 00:40:08,000
其实我们甚至不应该叫这些

1006
00:40:08,000 --> 00:40:10,000
二进直的数字

1007
00:40:10,000 --> 00:40:12,000
因为它们其实并不代表任何数量

1008
00:40:14,000 --> 00:40:16,000
它们所代表的只是一种模式

1009
00:40:16,000 --> 00:40:18,000
这是一个什么概念呢

1010
00:40:18,000 --> 00:40:20,000
各位可以想象一台钢琴

1011
00:40:20,000 --> 00:40:22,000
假设钢琴上所有的键都被拉平了

1012
00:40:22,000 --> 00:40:24,000
就是它的黑键

1013
00:40:24,000 --> 00:40:26,000
不是嵌在白键之间

1014
00:40:28,000 --> 00:40:30,000
而是很简单的道尔米法扫拉西道

1015
00:40:30,000 --> 00:40:32,000
加上中间所有的半音

1016
00:40:32,000 --> 00:40:34,000
这样拉在一个直线上

1017
00:40:34,000 --> 00:40:36,000
我们可以这样描述怎样弹钢琴

1018
00:40:36,000 --> 00:40:38,000
每次把按下去的钢琴记录 1

1019
00:40:38,000 --> 00:40:40,000
没有按下去的钢琴记录 0

1020
00:40:42,000 --> 00:40:44,000
然后我们可以在每一个时刻得到一系列的 1 和 0

1021
00:40:48,000 --> 00:40:50,000
这些 1 和 0 你可以把它换算成一个实际的数字

1022
00:40:52,000 --> 00:40:54,000
但是本质上它只是一种

1023
00:40:54,000 --> 00:40:56,000
它只是代表按下钢琴的状态

1024
00:40:58,000 --> 00:41:00,000
我们在使用 CPU 的时候

1025
00:41:00,000 --> 00:41:02,000
我们可以用 CPU 的方式

1026
00:41:02,000 --> 00:41:04,000
用 CPU 的方式去变化

1027
00:41:04,000 --> 00:41:06,000
从 CPU 的时候

1028
00:41:06,000 --> 00:41:08,000
情况跟钢琴是类似的

1029
00:41:12,000 --> 00:41:14,000
我们把 01010101 这样的指令

1030
00:41:14,000 --> 00:41:16,000
输入一小块芯片的时候

1031
00:41:18,000 --> 00:41:20,000
真实做的事情其实是在芯片上的不同引脚上面

1032
00:41:22,000 --> 00:41:24,000
输入高或者低的电压

1033
00:41:24,000 --> 00:41:26,000
然后芯片里面会有

1034
00:41:28,000 --> 00:41:30,000
很多坨小小的晶体管

1035
00:41:30,000 --> 00:41:32,000
组成小装置

1036
00:41:32,000 --> 00:41:34,000
被我们按下了

1037
00:41:36,000 --> 00:41:38,000
然后这个组合会

1038
00:41:38,000 --> 00:41:40,000
进而引发更多的

1039
00:41:40,000 --> 00:41:42,000
由芯片工程师预先设计的

1040
00:41:42,000 --> 00:41:44,000
一系列的连锁反应

1041
00:41:46,000 --> 00:41:48,000
然后无数这样的模式数字

1042
00:41:48,000 --> 00:41:50,000
一个接一个的被输入芯片里面

1043
00:41:52,000 --> 00:41:54,000
最终你屏幕上就会出现一些能够被人理解的图案

1044
00:41:56,000 --> 00:41:58,000
然后给计算机输入这种相当于命令的数字

1045
00:41:58,000 --> 00:42:00,000
这个数字称作指令的东西

1046
00:42:02,000 --> 00:42:04,000
让它来做一些事情

1047
00:42:04,000 --> 00:42:06,000
包括但不限于

1048
00:42:06,000 --> 00:42:08,000
处理其他那些数字

1049
00:42:08,000 --> 00:42:10,000
其实就是编程的本质活动

1050
00:42:12,000 --> 00:42:14,000
比如有一台古早的计算机叫做

1051
00:42:14,000 --> 00:42:16,000
Cosmic Elf

1052
00:42:16,000 --> 00:42:18,000
它的面板上有一排开关

1053
00:42:18,000 --> 00:42:20,000
应该是有 8 个还是 10 个开关

1054
00:42:22,000 --> 00:42:24,000
这些开关可以拨上或者拨下

1055
00:42:24,000 --> 00:42:26,000
给这台计算机编程的方法就是

1056
00:42:28,000 --> 00:42:30,000
把你想要输入的数字

1057
00:42:30,000 --> 00:42:32,000
或者说把你想要按下的琴键

1058
00:42:34,000 --> 00:42:36,000
在这排开关上面

1059
00:42:36,000 --> 00:42:38,000
扳好

1060
00:42:38,000 --> 00:42:40,000
比如说扳上就是上

1061
00:42:40,000 --> 00:42:42,000
扳上就是 1,扳下就是 0

1062
00:42:42,000 --> 00:42:44,000
扳好一排之后你按一下右上角

1063
00:42:44,000 --> 00:42:46,000
它有一个按钮

1064
00:42:46,000 --> 00:42:48,000
你就可以输入下一条指令

1065
00:42:50,000 --> 00:42:52,000
好像你在怎么说呢

1066
00:42:52,000 --> 00:42:54,000
有那种早期的打孔钢琴

1067
00:42:54,000 --> 00:42:56,000
你输入一条上面布满了小哑的指带

1068
00:43:00,000 --> 00:43:02,000
每一个哑都代表

1069
00:43:02,000 --> 00:43:04,000
这个地方应该有个琴键被按下去

1070
00:43:06,000 --> 00:43:08,000
给这台计算机编程的过程就有点像

1071
00:43:08,000 --> 00:43:10,000
你在手工去钻一个指带

1072
00:43:12,000 --> 00:43:14,000
或者你在手工做一个八音盒

1073
00:43:14,000 --> 00:43:16,000
如果你看过八音盒是怎么工作的话

1074
00:43:16,000 --> 00:43:18,000
你一定明白我的什么意思

1075
00:43:18,000 --> 00:43:20,000
问题在于就是你在

1076
00:43:20,000 --> 00:43:22,000
这台计算机上面

1077
00:43:22,000 --> 00:43:24,000
输入一系列 0 和 1

1078
00:43:24,000 --> 00:43:26,000
和在那台计算机上面输入一系列 0 和 1

1079
00:43:26,000 --> 00:43:28,000
你得到的反应可能是完全不一样的

1080
00:43:30,000 --> 00:43:32,000
这是从最开始就有一个

1081
00:43:32,000 --> 00:43:34,000
差异的

1082
00:43:34,000 --> 00:43:36,000
问题

1083
00:43:36,000 --> 00:43:38,000
因为各家计算机

1084
00:43:38,000 --> 00:43:40,000
厂商会自己去研发自己的芯片

1085
00:43:42,000 --> 00:43:44,000
同样那种数字对于不同型号的

1086
00:43:44,000 --> 00:43:46,000
计算机来说有可能是完全代表

1087
00:43:46,000 --> 00:43:48,000
不同的指令

1088
00:43:48,000 --> 00:43:50,000
这点直到今天都没有改变

1089
00:43:50,000 --> 00:43:52,000
那些通过金属引脚

1090
00:43:52,000 --> 00:43:54,000
受到 0 和 1 输入的 CPU

1091
00:43:54,000 --> 00:43:56,000
所谓有这样一个指令集的概念

1092
00:43:56,000 --> 00:43:58,000
本质上指令集

1093
00:43:58,000 --> 00:44:00,000
其实就是由芯片制造厂商

1094
00:44:00,000 --> 00:44:02,000
给出的数字组合的定义

1095
00:44:02,000 --> 00:44:04,000
如果你去查什么 AMD

1096
00:44:04,000 --> 00:44:06,000
或者是 Intel 的手册的话

1097
00:44:06,000 --> 00:44:08,000
你会发现他们的

1098
00:44:08,000 --> 00:44:10,000
指令集里面

1099
00:44:10,000 --> 00:44:12,000
会

1100
00:44:12,000 --> 00:44:14,000
给出一组数字

1101
00:44:14,000 --> 00:44:16,000
这组数字其实就是

1102
00:44:16,000 --> 00:44:18,000
真正的 CPU

1103
00:44:18,000 --> 00:44:20,000
就比较所会接触到的

1104
00:44:20,000 --> 00:44:22,000
那些高低面屏组

1105
00:44:24,000 --> 00:44:26,000
由于芯片设计结构不同

1106
00:44:26,000 --> 00:44:28,000
每种芯片的指令集也就不同

1107
00:44:28,000 --> 00:44:30,000
比如常见于台式计算机的

1108
00:44:30,000 --> 00:44:32,000
Intel 芯片的指令集

1109
00:44:32,000 --> 00:44:34,000
就与常见于手持设备的 Arm 芯片的

1110
00:44:34,000 --> 00:44:36,000
指令集不一样

1111
00:44:36,000 --> 00:44:38,000
计算机语言

1112
00:44:38,000 --> 00:44:40,000
在这个层面开始

1113
00:44:40,000 --> 00:44:42,000
就已经产生了区别

1114
00:44:42,000 --> 00:44:44,000
不过

1115
00:44:44,000 --> 00:44:46,000
用纯数字的计算机

1116
00:44:46,000 --> 00:44:48,000
计算机语言编程的难度可笑而止

1117
00:44:48,000 --> 00:44:50,000
所以从数字

1118
00:44:50,000 --> 00:44:52,000
到注记符号的转译

1119
00:44:52,000 --> 00:44:54,000
很快就随之出现了

1120
00:44:54,000 --> 00:44:56,000
我们把这个东西叫做汇编语言

1121
00:44:56,000 --> 00:44:58,000
比如说

1122
00:44:58,000 --> 00:45:00,000
一组数字 00100000

1123
00:45:00,000 --> 00:45:02,000
可以让芯片把

1124
00:45:02,000 --> 00:45:04,000
内部的一个存储单位

1125
00:45:04,000 --> 00:45:06,000
我们叫它

1126
00:45:06,000 --> 00:45:08,000
存储器,记存器 X

1127
00:45:08,000 --> 00:45:10,000
加上一个值 Y

1128
00:45:10,000 --> 00:45:12,000
那么不妨就把这组数字

1129
00:45:12,000 --> 00:45:14,000
和注记符 add 对应起来

1130
00:45:14,000 --> 00:45:16,000
比如说上面的指令就可以写成

1131
00:45:16,000 --> 00:45:18,000
addX,y

1132
00:45:18,000 --> 00:45:20,000
这样,一条条类似的指令

1133
00:45:20,000 --> 00:45:22,000
写成一串,就是一个对于程序的描述

1134
00:45:22,000 --> 00:45:24,000
对吧

1135
00:45:24,000 --> 00:45:26,000
相对于纯数字来说

1136
00:45:26,000 --> 00:45:28,000
这是一个质的区别,因为

1137
00:45:28,000 --> 00:45:30,000
你终于不用去手动

1138
00:45:30,000 --> 00:45:32,000
搬那个开关了,不是吗

1139
00:45:32,000 --> 00:45:34,000
然后这样的一串

1140
00:45:34,000 --> 00:45:36,000
这样的一串字符

1141
00:45:36,000 --> 00:45:38,000
就是这些 addX,y

1142
00:45:40,000 --> 00:45:42,000
或者是 moveX,y

1143
00:45:42,000 --> 00:45:44,000
这样的字符串

1144
00:45:46,000 --> 00:45:48,000
可以由专门的小程序来翻译成

1145
00:45:48,000 --> 00:45:50,000
那些 01,01 的二次金指代碼

1146
00:45:50,000 --> 00:45:52,000
也就是真正可以被

1147
00:45:52,000 --> 00:45:54,000
输入处理器

1148
00:45:54,000 --> 00:45:56,000
去按下那些

1149
00:45:56,000 --> 00:45:58,000
晶体管的开关的

1150
00:45:58,000 --> 00:46:00,000
电子信号

1151
00:46:00,000 --> 00:46:02,000
当然每一种处理器的汇变语言

1152
00:46:02,000 --> 00:46:04,000
都是不一样的

1153
00:46:04,000 --> 00:46:06,000
机器语言或者说汇变语言

1154
00:46:06,000 --> 00:46:08,000
的优点是

1155
00:46:08,000 --> 00:46:10,000
每一条指令几乎都对应于芯片能做的一件事情

1156
00:46:10,000 --> 00:46:12,000
比如说有一条指令可以把一个数字

1157
00:46:12,000 --> 00:46:14,000
从内存里面转到计算器里面

1158
00:46:14,000 --> 00:46:16,000
另一条指令可以把

1159
00:46:16,000 --> 00:46:18,000
这个被转入计算器的

1160
00:46:18,000 --> 00:46:20,000
值加上 1

1161
00:46:20,000 --> 00:46:22,000
第三条指令又把它放回内存去

1162
00:46:24,000 --> 00:46:26,000
直接对一块芯片下命令效率非常高

1163
00:46:26,000 --> 00:46:28,000
但是对应的缺点就是

1164
00:46:28,000 --> 00:46:30,000
如果你只是想要把一个数字加上 1 的话

1165
00:46:30,000 --> 00:46:32,000
每次都要写

1166
00:46:32,000 --> 00:46:34,000
三条指令

1167
00:46:34,000 --> 00:46:36,000
时间一长是非常痛苦的一件事

1168
00:46:36,000 --> 00:46:38,000
而且还有一个问题就是

1169
00:46:38,000 --> 00:46:40,000
因为不同的芯片所支持的指令机是不一样的

1170
00:46:40,000 --> 00:46:42,000
也就意味着你在这一块芯片上

1171
00:46:42,000 --> 00:46:44,000
需要三条指令能完成的事情

1172
00:46:44,000 --> 00:46:46,000
在另外一块芯片上可能需要五条指令

1173
00:46:46,000 --> 00:46:48,000
所以如果我们能够

1174
00:46:48,000 --> 00:46:50,000
将一部分固定出现的操作

1175
00:46:50,000 --> 00:46:52,000
像连续计一样一次性释放

1176
00:46:52,000 --> 00:46:54,000
每次只要打一个指令

1177
00:46:54,000 --> 00:46:56,000
却能够在不同结构的芯片上

1178
00:46:56,000 --> 00:46:58,000
都做同样的事情该有多好呢

1179
00:46:58,000 --> 00:47:00,000
换句话说

1180
00:47:00,000 --> 00:47:02,000
在这一块芯片上

1181
00:47:02,000 --> 00:47:04,000
如果我们能够

1182
00:47:04,000 --> 00:47:06,000
把一个芯片的指令

1183
00:47:06,000 --> 00:47:08,000
改成一个数字的计算机

1184
00:47:08,000 --> 00:47:10,000
该有多好呢

1185
00:47:10,000 --> 00:47:12,000
换句话说

1186
00:47:12,000 --> 00:47:14,000
如果能有一种更倾向于

1187
00:47:14,000 --> 00:47:16,000
描述那些需要解决的问题

1188
00:47:16,000 --> 00:47:18,000
比如说给一个数字加上 1

1189
00:47:18,000 --> 00:47:20,000
而不是手把手的告诉计算机

1190
00:47:20,000 --> 00:47:22,000
说你读一个数字

1191
00:47:22,000 --> 00:47:24,000
加上一个数字

1192
00:47:24,000 --> 00:47:26,000
再写一个数字

1193
00:47:26,000 --> 00:47:28,000
有这样一种比较高级的语言

1194
00:47:28,000 --> 00:47:30,000
来封装这些比较

1195
00:47:30,000 --> 00:47:32,000
不需要我们去操心的细节

1196
00:47:32,000 --> 00:47:34,000
该有多好

1197
00:47:34,000 --> 00:47:36,000
所谓的高级语言

1198
00:47:36,000 --> 00:47:38,000
就是各位学习原成的时候学到的那种语言

1199
00:47:38,000 --> 00:47:40,000
就是做这件事

1200
00:47:40,000 --> 00:47:42,000
比如说最古老的高级语言

1201
00:47:42,000 --> 00:47:44,000
有 Fortune、Algo、Cobalt

1202
00:47:46,000 --> 00:47:48,000
乃至于

1203
00:47:48,000 --> 00:47:50,000
同样古老但是来源迥异的 Lisp

1204
00:47:50,000 --> 00:47:52,000
我觉得我们应该专门找一期来说 Lisp

1205
00:47:54,000 --> 00:47:56,000
所有这些语言

1206
00:47:56,000 --> 00:47:58,000
他们都会最终被转换

1207
00:47:58,000 --> 00:48:00,000
二进人的形式

1208
00:48:00,000 --> 00:48:02,000
包括现在大家

1209
00:48:02,000 --> 00:48:04,000
比较喜欢的动态语言

1210
00:48:04,000 --> 00:48:06,000
比如说 Python

1211
00:48:06,000 --> 00:48:08,000
Ruby

1212
00:48:08,000 --> 00:48:10,000
Lua

1213
00:48:10,000 --> 00:48:12,000
他们归根结底都是会

1214
00:48:12,000 --> 00:48:14,000
被转换二进制

1215
00:48:14,000 --> 00:48:16,000
代码输入到 CPU 之间

1216
00:48:16,000 --> 00:48:18,000
他们和这个

1217
00:48:18,000 --> 00:48:20,000
比较低端的

1218
00:48:20,000 --> 00:48:22,000
或者说比较原始的语言比如 C

1219
00:48:22,000 --> 00:48:24,000
或者是 Fortune 的区别就在于他们

1220
00:48:24,000 --> 00:48:26,000
单一一条指令

1221
00:48:26,000 --> 00:48:28,000
里面

1222
00:48:28,000 --> 00:48:30,000
所包括

1223
00:48:30,000 --> 00:48:32,000
所涵盖的那些二进制指令

1224
00:48:32,000 --> 00:48:34,000
要多很多

1225
00:48:34,000 --> 00:48:36,000
然后他们完成

1226
00:48:36,000 --> 00:48:38,000
这一个特点

1227
00:48:38,000 --> 00:48:40,000
的手段就是

1228
00:48:40,000 --> 00:48:42,000
他们的

1229
00:48:42,000 --> 00:48:44,000
底层其实又是利用你的

1230
00:48:44,000 --> 00:48:46,000
实体 CPU 去模拟

1231
00:48:46,000 --> 00:48:48,000
一个

1232
00:48:48,000 --> 00:48:50,000
只在逻辑意义上

1233
00:48:50,000 --> 00:48:52,000
存在的虚拟

1234
00:48:52,000 --> 00:48:54,000
CPU

1235
00:48:54,000 --> 00:48:56,000
对这个就不展开讲了

1236
00:48:56,000 --> 00:48:58,000
有兴趣的同学

1237
00:48:58,000 --> 00:49:00,000
可以自己去找一些

1238
00:49:00,000 --> 00:49:02,000
这个方面的书看

1239
00:49:02,000 --> 00:49:04,000
我会推荐一本 code

1240
00:49:04,000 --> 00:49:06,000
我相信之前我已经 code 过了

1241
00:49:06,000 --> 00:49:08,000
我已经推荐过了 sorry

1242
00:49:08,000 --> 00:49:10,000
可能是在某一期的 IT 工作上面

1243
00:49:10,000 --> 00:49:12,000
我说这本书是奇迹书

1244
00:49:12,000 --> 00:49:14,000
推荐拿来去看一看

1245
00:49:16,000 --> 00:49:18,000
以上大概讲了这个

1246
00:49:18,000 --> 00:49:20,000
编程语言是怎么样

1247
00:49:20,000 --> 00:49:22,000
利用

1248
00:49:22,000 --> 00:49:24,000
零和一

1249
00:49:24,000 --> 00:49:26,000
或者说编程语言是怎样

1250
00:49:26,000 --> 00:49:28,000
转化零和一

1251
00:49:28,000 --> 00:49:30,000
但是正就没有解释我们一开始提出的问题

1252
00:49:30,000 --> 00:49:32,000
就是我们看到的图像

1253
00:49:32,000 --> 00:49:34,000
看到的文字

1254
00:49:34,000 --> 00:49:36,000
是怎样转化零和一的

1255
00:49:38,000 --> 00:49:40,000
其实道理是类似的

1256
00:49:40,000 --> 00:49:42,000
我们约定说

1257
00:49:42,000 --> 00:49:44,000
在计算机里面

1258
00:49:44,000 --> 00:49:46,000
某一些特定的零和一的组合

1259
00:49:46,000 --> 00:49:48,000
代表一个特定的数字

1260
00:49:48,000 --> 00:49:50,000
或者代表一个特定的字符

1261
00:49:50,000 --> 00:49:52,000
或者代表一个特定的图像

1262
00:49:52,000 --> 00:49:54,000
与我们最常见的 ASCII 码

1263
00:49:54,000 --> 00:49:56,000
也就是国家

1264
00:49:56,000 --> 00:49:58,000
美国国家标准局的代码

1265
00:49:58,000 --> 00:50:00,000
ASCII 代码来看的话

1266
00:50:00,000 --> 00:50:02,000
它的方法是

1267
00:50:02,000 --> 00:50:04,000
挑出一个七位的

1268
00:50:04,000 --> 00:50:06,000
注意是七位的二阶级数字

1269
00:50:06,000 --> 00:50:08,000
把它第一位标成一

1270
00:50:08,000 --> 00:50:10,000
最后一位标成一

1271
00:50:10,000 --> 00:50:12,000
也就是

1272
00:50:12,000 --> 00:50:14,000
1000001

1273
00:50:16,000 --> 00:50:18,000
这样的数字

1274
00:50:18,000 --> 00:50:20,000
让它来代表大写字

1275
00:50:20,000 --> 00:50:22,000
让它来代表大写字母 A

1276
00:50:24,000 --> 00:50:26,000
然后这个数字被转化成十进制

1277
00:50:26,000 --> 00:50:28,000
就是 65

1278
00:50:28,000 --> 00:50:30,000
65 代表 A

1279
00:50:30,000 --> 00:50:32,000
所以如果你从十进制的

1280
00:50:32,000 --> 00:50:34,000
角度去看这个数字的话

1281
00:50:34,000 --> 00:50:36,000
你会觉得很奇怪

1282
00:50:36,000 --> 00:50:38,000
为什么要用 65 代表 A 呢

1283
00:50:38,000 --> 00:50:40,000
当你把 65 转化成一个七位的

1284
00:50:40,000 --> 00:50:42,000
二阶级数字的时候

1285
00:50:42,000 --> 00:50:44,000
就会发现它其实是一个

1286
00:50:44,000 --> 00:50:46,000
相对来说比较有规律的

1287
00:50:46,000 --> 00:50:48,000
码点

1288
00:50:48,000 --> 00:50:50,000
所以码点就是

1289
00:50:50,000 --> 00:50:52,000
一个字符相对应

1290
00:50:52,000 --> 00:50:54,000
于它的

1291
00:50:54,000 --> 00:50:56,000
二阶级数字

1292
00:50:56,000 --> 00:50:58,000
所在的位置

1293
00:50:58,000 --> 00:51:00,000
叫做码点

1294
00:51:00,000 --> 00:51:02,000
那么在 65 这个码点上面

1295
00:51:02,000 --> 00:51:04,000
是 A

1296
00:51:04,000 --> 00:51:06,000
符合逻辑的方式就是

1297
00:51:06,000 --> 00:51:08,000
把 B 放在 66 上

1298
00:51:08,000 --> 00:51:10,000
然后一次推对吧

1299
00:51:10,000 --> 00:51:12,000
大写字母完了之后是

1300
00:51:12,000 --> 00:51:14,000
一对标点符号然后是小写字母

1301
00:51:14,000 --> 00:51:16,000
那

1302
00:51:16,000 --> 00:51:18,000
有一个问题就是

1303
00:51:18,000 --> 00:51:20,000
七位的二阶级数字

1304
00:51:20,000 --> 00:51:22,000
可以表示

1305
00:51:22,000 --> 00:51:24,000
127 个字符

1306
00:51:24,000 --> 00:51:26,000
对于英语来说是

1307
00:51:26,000 --> 00:51:28,000
够的甚至可以表示大写

1308
00:51:28,000 --> 00:51:30,000
小写加上数字

1309
00:51:30,000 --> 00:51:32,000
等等

1310
00:51:32,000 --> 00:51:34,000
那么为什么要选用七位这个数字也是因为

1311
00:51:34,000 --> 00:51:36,000
如果你把第八位

1312
00:51:36,000 --> 00:51:38,000
也用上的话就可以让

1313
00:51:38,000 --> 00:51:40,000
其他人去定义一些比较

1314
00:51:40,000 --> 00:51:42,000
额外的

1315
00:51:42,000 --> 00:51:44,000
比如说西欧语言会

1316
00:51:44,000 --> 00:51:46,000
用到各种各样的

1317
00:51:46,000 --> 00:51:48,000
就是在字母上面

1318
00:51:48,000 --> 00:51:50,000
加点啊

1319
00:51:50,000 --> 00:51:52,000
打撇啊等等诸如此类非常愚蠢的事情

1320
00:51:54,000 --> 00:51:56,000
那么他们所使用的方法就是

1321
00:51:56,000 --> 00:51:58,000
把

1322
00:51:58,000 --> 00:52:00,000
这个七位数字扩展到八位

1323
00:52:00,000 --> 00:52:02,000
或者说利用这个

1324
00:52:02,000 --> 00:52:04,000
Auskey 编码标准

1325
00:52:04,000 --> 00:52:06,000
刻意将第八位永远设为

1326
00:52:06,000 --> 00:52:08,000
0 的特点

1327
00:52:08,000 --> 00:52:10,000
规定了当第八位变成

1328
00:52:10,000 --> 00:52:12,000
1 的时候多出来

1329
00:52:12,000 --> 00:52:14,000
那么在这个标准上

1330
00:52:14,000 --> 00:52:16,000
西欧多了很多自己的字母标准

1331
00:52:16,000 --> 00:52:18,000
每个国家都不一样

1332
00:52:18,000 --> 00:52:20,000
然后

1333
00:52:20,000 --> 00:52:22,000
我记得 CJK 也是

1334
00:52:22,000 --> 00:52:24,000
在日本也是

1335
00:52:24,000 --> 00:52:26,000
他们利用多出来的 127 个

1336
00:52:26,000 --> 00:52:28,000
码点加入了评价明

1337
00:52:28,000 --> 00:52:30,000
骗价明等等

1338
00:52:30,000 --> 00:52:32,000
所以有了日本的一套

1339
00:52:32,000 --> 00:52:34,000
自己的规则

1340
00:52:34,000 --> 00:52:36,000
但是那个时候这个编码只能表示假

1341
00:52:36,000 --> 00:52:38,000
但是

1342
00:52:38,000 --> 00:52:40,000
我们都知道这个

1343
00:52:40,000 --> 00:52:42,000
汉字的数量繁多

1344
00:52:42,000 --> 00:52:44,000
256 个显然是不够用的

1345
00:52:44,000 --> 00:52:46,000
那早期的一个解决方案

1346
00:52:46,000 --> 00:52:48,000
就是用两个

1347
00:52:48,000 --> 00:52:50,000
二进制的

1348
00:52:50,000 --> 00:52:52,000
八位数来代表

1349
00:52:52,000 --> 00:52:54,000
一个汉字

1350
00:52:54,000 --> 00:52:56,000
所以你就有 256 x 256

1351
00:52:56,000 --> 00:52:58,000
256 x 256

1352
00:52:58,000 --> 00:53:00,000
可能性

1353
00:53:00,000 --> 00:53:02,000
问题在于

1354
00:53:02,000 --> 00:53:04,000
由于政治原因

1355
00:53:04,000 --> 00:53:06,000
早期的中国、台湾

1356
00:53:06,000 --> 00:53:08,000
和香港对于

1357
00:53:08,000 --> 00:53:10,000
汉字的编码

1358
00:53:10,000 --> 00:53:12,000
规定是不一样的

1359
00:53:12,000 --> 00:53:14,000
日本还有一套自己的体系

1360
00:53:14,000 --> 00:53:16,000
不过好在后来出现了一种叫做 Unicode

1361
00:53:16,000 --> 00:53:18,000
Unicode 首先它规定了一个序列

1362
00:53:18,000 --> 00:53:20,000
在这个序列里面

1363
00:53:20,000 --> 00:53:22,000
就是一系列的码点

1364
00:53:22,000 --> 00:53:24,000
在每个码点上

1365
00:53:24,000 --> 00:53:26,000
规定了这个码点对应哪个汉字

1366
00:53:26,000 --> 00:53:28,000
不管

1367
00:53:28,000 --> 00:53:30,000
这个汉字是

1368
00:53:30,000 --> 00:53:32,000
采用什么样的字型

1369
00:53:32,000 --> 00:53:34,000
来自哪个国家

1370
00:53:34,000 --> 00:53:36,000
全都会

1371
00:53:36,000 --> 00:53:38,000
它们就归在 Unicode 的序列里面

1372
00:53:38,000 --> 00:53:40,000
然后 Unicode

1373
00:53:40,000 --> 00:53:42,000
指定了一个编码方法

1374
00:53:42,000 --> 00:53:44,000
也就是

1375
00:53:44,000 --> 00:53:46,000
在某一个特定码点上的汉字

1376
00:53:46,000 --> 00:53:48,000
比如说

1377
00:53:48,000 --> 00:53:50,000
30002

1378
00:53:50,000 --> 00:53:52,000
码点上面的汉字

1379
00:53:52,000 --> 00:53:54,000
是假一名跟假

1380
00:53:54,000 --> 00:53:56,000
它规定说

1381
00:53:56,000 --> 00:53:58,000
当你把这个假字

1382
00:53:58,000 --> 00:54:00,000
以二进制形式表示的时候

1383
00:54:00,000 --> 00:54:02,000
你有

1384
00:54:02,000 --> 00:54:04,000
很多种选择

1385
00:54:04,000 --> 00:54:06,000
最常见的一种选择

1386
00:54:06,000 --> 00:54:08,000
我们现在叫做 UTF 8

1387
00:54:08,000 --> 00:54:12,000
在 UTF 8 的表示之下

1388
00:54:12,000 --> 00:54:16,000
位于码点 30002 的假

1389
00:54:16,000 --> 00:54:18,000
这个字

1390
00:54:18,000 --> 00:54:20,000
会不会转化为

1391
00:54:20,000 --> 00:54:22,000
有点长

1392
00:54:22,000 --> 00:54:24,000
是一个 3 x 8 位的

1393
00:54:24,000 --> 00:54:26,000
二进制数字

1394
00:54:26,000 --> 00:54:28,000
是 110011

1395
00:54:28,000 --> 00:54:30,000
10010100

1396
00:54:30,000 --> 00:54:32,000
10110010

1397
00:54:32,000 --> 00:54:36,000
我是这个世界上唯一一个把

1398
00:54:36,000 --> 00:54:38,000
假的汉字转化为

1399
00:54:38,000 --> 00:54:40,000
语音形式的二进制代码

1400
00:54:40,000 --> 00:54:42,000
是吗

1401
00:54:42,000 --> 00:54:44,000
对

1402
00:54:44,000 --> 00:54:46,000
本质上来讲

1403
00:54:46,000 --> 00:54:48,000
或者说对于计算机来讲

1404
00:54:48,000 --> 00:54:50,000
你告诉它

1405
00:54:50,000 --> 00:54:52,000
1000001

1406
00:54:52,000 --> 00:54:54,000
也好

1407
00:54:54,000 --> 00:54:56,000
还是你告诉它

1408
00:54:56,000 --> 00:54:58,000
我刚才说的是 24 个

1409
00:54:58,000 --> 00:55:00,000
二进制的数字也好

1410
00:55:00,000 --> 00:55:02,000
它们都是一样的

1411
00:55:02,000 --> 00:55:04,000
但是对于人类来说

1412
00:55:04,000 --> 00:55:06,000
及解读方式是不一样

1413
00:55:06,000 --> 00:55:08,000
那么无论音频文件

1414
00:55:08,000 --> 00:55:10,000
还是视频文件

1415
00:55:10,000 --> 00:55:12,000
归原解理基本上都可以这样类推

1416
00:55:12,000 --> 00:55:14,000
只不过里面还包含了

1417
00:55:14,000 --> 00:55:16,000
更多其他的因素比如说

1418
00:55:16,000 --> 00:55:18,000
你可以把一个点上面的颜色

1419
00:55:20,000 --> 00:55:22,000
划分为

1420
00:55:22,000 --> 00:55:24,000
红 绿 蓝

1421
00:55:24,000 --> 00:55:26,000
三个分量

1422
00:55:26,000 --> 00:55:28,000
然后每个分量

1423
00:55:28,000 --> 00:55:30,000
用一个 0-255 的数字表示

1424
00:55:34,000 --> 00:55:36,000
那么你就可以规定

1425
00:55:36,000 --> 00:55:38,000
你都可以得到每个点上的

1426
00:55:38,000 --> 00:55:40,000
选用 RGB 的值

1427
00:55:40,000 --> 00:55:42,000
但是如果你要记载

1428
00:55:42,000 --> 00:55:44,000
如果你要记载一部电影里面

1429
00:55:44,000 --> 00:55:46,000
每一帧的

1430
00:55:46,000 --> 00:55:48,000
每一个点上的这个数字

1431
00:55:48,000 --> 00:55:50,000
其代价会是非常高昂的

1432
00:55:50,000 --> 00:55:52,000
因为我们目前的

1433
00:55:52,000 --> 00:55:54,000
科技手段

1434
00:55:54,000 --> 00:55:56,000
没有办法保证说能够完全不去

1435
00:55:56,000 --> 00:55:58,000
考虑

1436
00:55:58,000 --> 00:56:00,000
存储或者说

1437
00:56:00,000 --> 00:56:02,000
传输过程之中的

1438
00:56:02,000 --> 00:56:04,000
空间乃至于时间的损耗

1439
00:56:04,000 --> 00:56:06,000
所以人没有想出

1440
00:56:06,000 --> 00:56:08,000
另外一个方法就是

1441
00:56:08,000 --> 00:56:10,000
找出所有这些

1442
00:56:10,000 --> 00:56:12,000
数字里面的重复部分

1443
00:56:12,000 --> 00:56:14,000
用一个更短的数字去代替

1444
00:56:14,000 --> 00:56:16,000
对 这就是压缩的本质

1445
00:56:16,000 --> 00:56:18,000
所以我们可以把它理解为

1446
00:56:18,000 --> 00:56:20,000
对于编码的

1447
00:56:20,000 --> 00:56:22,000
再编码

1448
00:56:22,000 --> 00:56:24,000
这是另外一层考虑

1449
00:56:26,000 --> 00:56:28,000
嗯

1450
00:56:28,000 --> 00:56:30,000
对 其实这期的提章里面

1451
00:56:30,000 --> 00:56:32,000
还束了一些其他话

1452
00:56:32,000 --> 00:56:34,000
包括 Unicode 本来都是

1453
00:56:34,000 --> 00:56:36,000
打算再展开讲

1454
00:56:36,000 --> 00:56:38,000
还有很多历史之类的

1455
00:56:38,000 --> 00:56:40,000
但是

1456
00:56:40,000 --> 00:56:42,000
目前的状况是

1457
00:56:42,000 --> 00:56:44,000
我这边录音的时间

1458
00:56:44,000 --> 00:56:46,000
刚刚突破了一个小时的 Mark

1459
00:56:46,000 --> 00:56:48,000
当然最后剪出来可能没有一个小时

1460
00:56:48,000 --> 00:56:50,000
不过

1461
00:56:50,000 --> 00:56:52,000
此时的我已经觉得嗓子非常疼了

1462
00:56:52,000 --> 00:56:54,000
而且

1463
00:56:54,000 --> 00:56:56,000
很不幸过敏性鼻炎又开始犯了

1464
00:56:56,000 --> 00:56:58,000
所以

1465
00:56:58,000 --> 00:57:00,000
这一期只能

1466
00:57:00,000 --> 00:57:02,000
我们还没有进入正题是吧

1467
00:57:02,000 --> 00:57:04,000
那我们来赶紧进入正题好了

1468
00:57:06,000 --> 00:57:08,000
正题就是程序员怎样

1469
00:57:08,000 --> 00:57:10,000
才能找到女朋友呢

1470
00:57:10,000 --> 00:57:12,000
答案很简单

1471
00:57:12,000 --> 00:57:14,000
除非你的女朋友候选人

1472
00:57:14,000 --> 00:57:16,000
就是好这一口

1473
00:57:16,000 --> 00:57:18,000
那么单纯以程序员的身份

1474
00:57:18,000 --> 00:57:20,000
对于找到女朋友来说

1475
00:57:20,000 --> 00:57:22,000
没有任何意义

1476
00:57:22,000 --> 00:57:24,000
True story

1477
00:57:24,000 --> 00:57:26,000
只有抛开我是程序员

1478
00:57:26,000 --> 00:57:28,000
这一个自我认同之后

1479
00:57:28,000 --> 00:57:30,000
找女朋友才会变得比较容易

1480
00:57:30,000 --> 00:57:32,000
比如

1481
00:57:32,000 --> 00:57:34,000
你要弄明白人和人之间沟通的

1482
00:57:34,000 --> 00:57:36,000
编码

1483
00:57:36,000 --> 00:57:38,000
这个编码体系

1484
00:57:38,000 --> 00:57:40,000
一方面要比计算机系统

1485
00:57:40,000 --> 00:57:42,000
我们刚才所说的编码简单得多

1486
00:57:42,000 --> 00:57:44,000
另一方面又比它复杂得多

1487
00:57:44,000 --> 00:57:46,000
你要去学会理解

1488
00:57:46,000 --> 00:57:48,000
不同性别之间的

1489
00:57:48,000 --> 00:57:50,000
性理差异

1490
00:57:50,000 --> 00:57:52,000
不管这种差异是怎么来的

1491
00:57:52,000 --> 00:57:54,000
你都必须了解它

1492
00:57:54,000 --> 00:57:56,000
你要去

1493
00:57:56,000 --> 00:57:58,000
了解什么是弦外之音

1494
00:57:58,000 --> 00:58:00,000
你要弄明白

1495
00:58:00,000 --> 00:58:02,000
女孩子说话有时候是

1496
00:58:02,000 --> 00:58:04,000
话里有话

1497
00:58:04,000 --> 00:58:06,000
对吧

1498
00:58:06,000 --> 00:58:08,000
我女朋友在点头

1499
00:58:08,000 --> 00:58:10,000
好吧

1500
00:58:10,000 --> 00:58:12,000
您刚刚收听完的是

1501
00:58:12,000 --> 00:58:14,000
IPN Podcast 网络旗下的

1502
00:58:14,000 --> 00:58:16,000
IT 技术节目内核浮况

1503
00:58:16,000 --> 00:58:18,000
也欢迎你收听 IPN 旗下的

1504
00:58:18,000 --> 00:58:20,000
其他六档 Podcast

1505
00:58:20,000 --> 00:58:22,000
包括

1506
00:58:22,000 --> 00:58:24,000
同样是技术主题节目 IT 公问

1507
00:58:24,000 --> 00:58:26,000
医疗主题节目太医来了

1508
00:58:26,000 --> 00:58:28,000
美食主题节目

1509
00:58:28,000 --> 00:58:30,000
伪知道,艺术主题节目

1510
00:58:30,000 --> 00:58:32,000
流行同性,无主题节目

1511
00:58:32,000 --> 00:58:34,000
无词源,故事主题节目

1512
00:58:34,000 --> 00:58:36,000
History,以及影像

1513
00:58:36,000 --> 00:58:38,000
主题节目,硬影像

1514
00:58:38,000 --> 00:58:40,000
感谢大家收听

