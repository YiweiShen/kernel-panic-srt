1
00:00:00,000 --> 00:00:04,000
欢迎收听 ipnpodcast 网络旗下的 IT 技术主题娱乐节目内核恐慌

2
00:00:04,000 --> 00:00:06,000
我们号称 Hardcore 但是也没有干货

3
00:00:06,000 --> 00:00:08,000
想听的人听不想听的人就别听

4
00:00:09,000 --> 00:00:12,000
内核恐慌的网址是 ipn.li.kernelpanic

5
00:00:12,000 --> 00:00:16,000
我们推荐大家使用 podcast 泛用型客户端订阅我们的节目

6
00:00:16,000 --> 00:00:18,000
如果您不知道什么是泛用型客户端

7
00:00:18,000 --> 00:00:20,000
或者您不知道该用什么客户端

8
00:00:20,000 --> 00:00:23,000
欢迎访问 ipn.li.faq

9
00:00:24,000 --> 00:00:26,000
同时也欢迎你为我们的节目捐款

10
00:00:26,000 --> 00:00:29,000
捐款地址是 ipn.li.kernelpanic.donate

11
00:00:30,000 --> 00:00:31,000
捐款金顿随意

12
00:00:31,000 --> 00:00:33,000
只要是能被巴掌出的证人数就可以

13
00:00:33,000 --> 00:00:35,000
捐款不会为你带来什么

14
00:00:35,000 --> 00:00:37,000
不捐也不会让你失去什么

15
00:00:37,000 --> 00:00:39,000
我们的口号是 no hard feelings

16
00:00:39,000 --> 00:00:41,000
越来越熟练了这段话

17
00:00:41,000 --> 00:00:42,000
耶对这是苦练的结果

18
00:00:42,000 --> 00:00:47,000
每天晚上含着小狮子在洗澡的时候背这段惯语

19
00:00:48,000 --> 00:00:49,000
这不是这么耳熟

20
00:00:50,000 --> 00:00:51,000
这谁来着

21
00:00:52,000 --> 00:00:52,000
我不记得了

22
00:00:52,000 --> 00:00:57,000
反正是某个演说家要克服口吃的猫咪

23
00:00:57,000 --> 00:00:57,000
然后

24
00:00:58,000 --> 00:00:58,000
这个是真的吗

25
00:00:58,000 --> 00:01:00,000
还是一个鸡汤

26
00:01:01,000 --> 00:01:02,000
good question

27
00:01:02,000 --> 00:01:02,000
我不知道

28
00:01:02,000 --> 00:01:04,000
有可能是真的

29
00:01:04,000 --> 00:01:05,000
因为我在想了一下

30
00:01:05,000 --> 00:01:08,000
含着小狮子练春话这件事情的意义何在

31
00:01:08,000 --> 00:01:09,000
就增加你的障碍

32
00:01:09,000 --> 00:01:12,000
就好像绑着沙包在操场上跑

33
00:01:12,000 --> 00:01:16,000
绑着沙包在操场上跑圈一样

34
00:01:16,000 --> 00:01:19,000
可以让你吐个小狮子之后

35
00:01:19,000 --> 00:01:21,000
发现自己的舌头好像变得灵活了

36
00:01:21,000 --> 00:01:23,000
所以以此类别的话

37
00:01:23,000 --> 00:01:25,000
如果程序员要提高自己的水平

38
00:01:25,000 --> 00:01:26,000
应该怎么增加难度呢

39
00:01:27,000 --> 00:01:29,000
不用显示器写程序

40
00:01:33,000 --> 00:01:34,000
用什么

41
00:01:34,000 --> 00:01:35,000
那个打孔吗

42
00:01:38,000 --> 00:01:39,000
或者降低的难度

43
00:01:39,000 --> 00:01:42,000
就只用单色显示器写程序

44
00:01:43,000 --> 00:01:45,000
然后等你有了语法高粱之后

45
00:01:47,000 --> 00:01:48,000
效率就可以升起来

46
00:01:49,000 --> 00:01:50,000
所以用什么

47
00:01:50,000 --> 00:01:53,000
非语法高粱的

48
00:01:53,000 --> 00:01:53,000
怎么说

49
00:01:53,000 --> 00:01:55,000
用计时本写程序

50
00:01:55,000 --> 00:01:56,000
对

51
00:01:56,000 --> 00:01:57,000
这也有部分是真的

52
00:01:57,000 --> 00:01:58,000
我必须说

53
00:01:58,000 --> 00:02:01,000
就是你不用 Idee 写程序的话

54
00:02:01,000 --> 00:02:03,000
如果你一开始就坚持不用 Idee 写程序

55
00:02:03,000 --> 00:02:05,000
那么等到你又开始用 Idee 的时候

56
00:02:05,000 --> 00:02:08,000
你的效率应该会有成倍的提升

57
00:02:10,000 --> 00:02:12,000
是不是这个道理

58
00:02:13,000 --> 00:02:14,000
想来应该是的

59
00:02:14,000 --> 00:02:15,000
所以这么说来

60
00:02:15,000 --> 00:02:17,000
我们都算是一直在背着沙包在跑

61
00:02:18,000 --> 00:02:18,000
对

62
00:02:19,000 --> 00:02:20,000
做的很难

63
00:02:20,000 --> 00:02:24,000
然后当你做的一般

64
00:02:24,000 --> 00:02:25,000
你就会发现容易了很多

65
00:02:26,000 --> 00:02:27,000
好吧

66
00:02:28,000 --> 00:02:29,000
就好像打星际军马

67
00:02:29,000 --> 00:02:31,000
先在 Brutal 下面通过关

68
00:02:31,000 --> 00:02:33,000
然后再回去打 Easy

69
00:02:34,000 --> 00:02:35,000
简直小菜一碟

70
00:02:35,000 --> 00:02:36,000
没错

71
00:02:37,000 --> 00:02:38,000
OK

72
00:02:39,000 --> 00:02:42,000
先进入我们的第一个环节 Follow up

73
00:02:42,000 --> 00:02:46,000
我听说 Rail 拿到一块 Happy Hacking Keyboard Pro 2

74
00:02:46,000 --> 00:02:47,000
是真的吗

75
00:02:47,000 --> 00:02:47,000
对

76
00:02:47,000 --> 00:02:51,000
上次 Lawrence 把他那块闲置不用的

77
00:02:51,000 --> 00:02:54,000
HHKB Pro 2 送给了我

78
00:02:55,000 --> 00:02:56,000
这是什么时候的事情

79
00:02:56,000 --> 00:02:57,000
这是两个月之前的事情

80
00:02:57,000 --> 00:02:59,000
快递走了这么久吗

81
00:02:59,000 --> 00:03:00,000
还是

82
00:03:00,000 --> 00:03:02,000
是我是挺早拿到

83
00:03:02,000 --> 00:03:05,000
但是因为还没来这几期感觉上手

84
00:03:06,000 --> 00:03:08,000
所以就也一直没有讲

85
00:03:08,000 --> 00:03:10,000
但是就算也用了一段时间

86
00:03:10,000 --> 00:03:13,000
现在也因为整个建位都变了

87
00:03:15,000 --> 00:03:16,000
所以还是花了一点时间来适应的

88
00:03:17,000 --> 00:03:19,000
现在适应之后觉得还不错

89
00:03:19,000 --> 00:03:21,000
所以我们可以讨论一下

90
00:03:24,000 --> 00:03:25,000
其实我一直有一个疑问

91
00:03:25,000 --> 00:03:27,000
HHKB 它到底有几个版本

92
00:03:28,000 --> 00:03:29,000
应该是有若干的版本

93
00:03:29,000 --> 00:03:32,000
首先它有若干版本

94
00:03:33,000 --> 00:03:35,000
因为我看 Wikipedia 上面写

95
00:03:36,000 --> 00:03:36,000
写的时候

96
00:03:36,000 --> 00:03:39,000
它有好可能是有四到四五个

97
00:03:39,000 --> 00:03:40,000
四五六个版本

98
00:03:40,000 --> 00:03:40,000
还有什么

99
00:03:40,000 --> 00:03:43,000
但根据日本的和 International 不一样

100
00:03:43,000 --> 00:03:45,000
但是包括有 HHP Professional

101
00:03:46,000 --> 00:03:47,000
Professional 2

102
00:03:47,000 --> 00:03:50,000
然后现在我看到是在卖这个 Lite

103
00:03:50,000 --> 00:03:50,000
对吧

104
00:03:50,000 --> 00:03:51,000
应该是这样的

105
00:03:51,000 --> 00:03:54,000
一开始有 HHKB 普通版本

106
00:03:54,000 --> 00:03:55,000
就是第一代 HHKB

107
00:03:55,000 --> 00:03:58,000
后来有了 HHKB Lite

108
00:03:59,000 --> 00:04:04,000
再后来有了 HHP Pro 2

109
00:04:04,000 --> 00:04:06,000
然后 Pro 2 后面又出了一个 S 版本

110
00:04:06,000 --> 00:04:08,000
Ultimum S

111
00:04:08,000 --> 00:04:09,000
就是加了橡皮圈的

112
00:04:10,000 --> 00:04:11,000
比较的

113
00:04:12,000 --> 00:04:12,000
降噪版本

114
00:04:12,000 --> 00:04:14,000
S stand for silent

115
00:04:15,000 --> 00:04:16,000
所以它们之间有什么区别呢

116
00:04:17,000 --> 00:04:19,000
Lite 版本有方向键

117
00:04:20,000 --> 00:04:22,000
啊 OK

118
00:04:22,000 --> 00:04:28,000
然后日语版本是那种大的 T 型

119
00:04:28,000 --> 00:04:31,000
不是 L 型到 L 型回车的

120
00:04:31,000 --> 00:04:31,000
应该是

121
00:04:31,000 --> 00:04:32,000
Oh no

122
00:04:33,000 --> 00:04:35,000
所以它所有

123
00:04:35,000 --> 00:04:36,000
就我们这么说吧

124
00:04:36,000 --> 00:04:39,000
它是分型号和国家的

125
00:04:39,000 --> 00:04:41,000
就是如果我们不考虑国家的区别

126
00:04:41,000 --> 00:04:43,000
只考虑型号的区别的话

127
00:04:44,000 --> 00:04:44,000
它有几个不同

128
00:04:44,000 --> 00:04:46,000
有最 Original

129
00:04:47,000 --> 00:04:48,000
是哪一款

130
00:04:48,000 --> 00:04:49,000
就最原始的那款

131
00:04:49,000 --> 00:04:51,000
Original 现在应该已经找不着了

132
00:04:51,000 --> 00:04:52,000
它停产了

133
00:04:52,000 --> 00:04:55,000
但是我想知道那款应该叫什么名字

134
00:04:55,000 --> 00:04:56,000
就叫 HHP Pro 还是叫什么

135
00:04:56,000 --> 00:04:58,000
应该是就叫 HHP Pro

136
00:04:58,000 --> 00:05:01,000
应该就只叫 HHP Pro

137
00:05:01,000 --> 00:05:04,000
然后 Lite 和 Pro 的区分是从第二版才有

138
00:05:05,000 --> 00:05:07,000
所以 Lite 和 Pro 之间是什么区别

139
00:05:07,000 --> 00:05:09,000
就 Lite 是 Lite 版本

140
00:05:12,000 --> 00:05:13,000
这是一个很有趣的问题

141
00:05:16,000 --> 00:05:18,000
Lite 和 Pro 之间的版本

142
00:05:18,000 --> 00:05:20,000
很有可能件貌是有差别的

143
00:05:21,000 --> 00:05:24,000
然后 Pro 的版本现在是不是已经没有卖了

144
00:05:25,000 --> 00:05:27,000
对第一代的版本应该已经没有卖了

145
00:05:27,000 --> 00:05:30,000
甚至第一代的版本可能是没有 International 版本的

146
00:05:30,000 --> 00:05:32,000
就是一个纯日文的 Lite

147
00:05:32,000 --> 00:05:34,000
因为我们现在用的都是所谓的

148
00:05:34,000 --> 00:05:36,000
Professional 2 对吧

149
00:05:36,000 --> 00:05:37,000
对

150
00:05:37,000 --> 00:05:37,000
Pro 2

151
00:05:38,000 --> 00:05:39,000
然后我去它那个官网看

152
00:05:39,000 --> 00:05:41,000
好像现在这款也没有卖了吗

153
00:05:41,000 --> 00:05:42,000
还是怎么样

154
00:05:43,000 --> 00:05:43,000
有吧

155
00:05:44,000 --> 00:05:45,000
不会停产了吧

156
00:05:46,000 --> 00:05:47,000
因为我去它官网

157
00:05:47,000 --> 00:05:49,000
它那个官网也长得很奇怪

158
00:05:49,000 --> 00:05:52,000
你不知道它到底是个什么样的性质吗

159
00:05:52,000 --> 00:05:53,000
因为做得很

160
00:05:55,000 --> 00:05:56,000
很日本网站

161
00:05:58,000 --> 00:05:59,000
这个描述太抽象了

162
00:06:00,000 --> 00:06:02,000
总之反正日本电商网站都不怎么样

163
00:06:02,000 --> 00:06:03,000
这是肯定的

164
00:06:04,000 --> 00:06:06,000
而且 PFU 甚至不是做电商的

165
00:06:06,000 --> 00:06:07,000
它只是一个

166
00:06:07,000 --> 00:06:07,000
没错

167
00:06:07,000 --> 00:06:08,000
其实它 PFU

168
00:06:08,000 --> 00:06:10,000
它叫做 Embedded Keyboard

169
00:06:10,000 --> 00:06:12,000
HGKB 这个页面上只有一款

170
00:06:12,000 --> 00:06:13,000
就是 Lite 2

171
00:06:14,000 --> 00:06:15,000
它在展示的

172
00:06:15,000 --> 00:06:17,000
你看是英文版本

173
00:06:17,000 --> 00:06:17,000
对

174
00:06:18,000 --> 00:06:19,000
日本内容

175
00:06:19,000 --> 00:06:21,000
日本版本和英文版本不一样

176
00:06:25,000 --> 00:06:26,000
为什么会这样

177
00:06:26,000 --> 00:06:27,000
我不知道

178
00:06:27,000 --> 00:06:28,000
也许他们

179
00:06:29,000 --> 00:06:31,000
绝大多数用户都是集中在日本

180
00:06:31,000 --> 00:06:32,000
我的这一块键盘

181
00:06:32,000 --> 00:06:34,000
实际上是托朋友从日本买的

182
00:06:34,000 --> 00:06:35,000
所以

183
00:06:35,000 --> 00:06:36,000
好吧

184
00:06:36,000 --> 00:06:38,000
所以你那款是那个日本版吗

185
00:06:38,000 --> 00:06:38,000
不是

186
00:06:38,000 --> 00:06:39,000
是英特纳手版本

187
00:06:39,000 --> 00:06:41,000
就我特别强调说

188
00:06:41,000 --> 00:06:43,000
一定要用英特纳手版本

189
00:06:43,000 --> 00:06:44,000
好乱了

190
00:06:44,000 --> 00:06:46,000
所以你那个是没有方向键

191
00:06:46,000 --> 00:06:46,000
然后只有一个

192
00:06:46,000 --> 00:06:49,000
在最右边有一个 FNK 的对吧

193
00:06:49,000 --> 00:06:49,000
对

194
00:06:50,000 --> 00:06:51,000
那跟我那款是一样

195
00:06:51,000 --> 00:06:51,000
但你的是无刻印

196
00:06:51,000 --> 00:06:52,000
我的是有刻印

197
00:06:52,000 --> 00:06:53,000
对

198
00:06:54,000 --> 00:06:56,000
一股优越感

199
00:06:56,000 --> 00:06:57,000
由然而生

200
00:07:00,000 --> 00:07:01,000
键帽可以换是吧

201
00:07:01,000 --> 00:07:02,000
对

202
00:07:02,000 --> 00:07:02,000
键帽可以换

203
00:07:03,000 --> 00:07:04,000
我要准备买一套无刻印的

204
00:07:04,000 --> 00:07:05,000
接着装逼

205
00:07:09,000 --> 00:07:11,000
然后我就看那个官网上

206
00:07:11,000 --> 00:07:13,000
现在在说这个 Lite 2

207
00:07:13,000 --> 00:07:14,000
然后 Lite 2

208
00:07:14,000 --> 00:07:15,000
刚才你也不

209
00:07:15,000 --> 00:07:16,000
所以你也不知道 Lite

210
00:07:16,000 --> 00:07:17,000
和 Professional 的区别是什么

211
00:07:17,000 --> 00:07:18,000
是吧

212
00:07:18,000 --> 00:07:20,000
我怀疑 Lite 所用的那个

213
00:07:21,000 --> 00:07:24,000
按下去的那个开关应该不是

214
00:07:25,000 --> 00:07:27,000
什么 Tor

215
00:07:27,000 --> 00:07:28,000
Top Pre

216
00:07:28,000 --> 00:07:29,000
Top Pre 的

217
00:07:29,000 --> 00:07:30,000
不是 Top Pre 的吧

218
00:07:30,000 --> 00:07:31,000
不是 Top Pre 的键帽

219
00:07:32,000 --> 00:07:35,000
所以那还是所谓的经典融键盘吗

220
00:07:35,000 --> 00:07:37,000
还是什么其他一个什么东西

221
00:07:37,000 --> 00:07:38,000
有一定可能

222
00:07:38,000 --> 00:07:40,000
因为 Lite 好像卖便宜

223
00:07:40,000 --> 00:07:43,000
而且不止便宜点

224
00:07:45,000 --> 00:07:45,000
好吧

225
00:07:46,000 --> 00:07:48,000
然后那个一盒就是

226
00:07:48,000 --> 00:07:49,000
就是就是说

227
00:07:49,000 --> 00:07:50,000
HKB Pro

228
00:07:50,000 --> 00:07:51,000
就是没有数字二的

229
00:07:51,000 --> 00:07:52,000
都是已经停产了是吧

230
00:07:52,000 --> 00:07:54,000
只有 Pro 2 和 Lite 2 在收了

231
00:07:55,000 --> 00:07:56,000
对应该是找到

232
00:07:57,000 --> 00:07:59,000
你说这个这个玩意有日文版

233
00:07:59,000 --> 00:08:00,000
这个日文版在哪里

234
00:08:01,000 --> 00:08:02,000
我给你找找

235
00:08:05,000 --> 00:08:08,000
我搜那个 HKB 的 Wikipedia

236
00:08:08,000 --> 00:08:09,000
然后他给了一个 Official website

237
00:08:10,000 --> 00:08:10,000
点过来就这个

238
00:08:10,000 --> 00:08:12,000
然后这边只有一款 Lite 2

239
00:08:12,000 --> 00:08:13,000
什么都没有了

240
00:08:13,000 --> 00:08:15,000
就没有其他任何款型

241
00:08:15,000 --> 00:08:18,000
只有在 Wikipedia 的列表里面

242
00:08:18,000 --> 00:08:21,000
能找到一些还在售的款

243
00:08:21,000 --> 00:08:23,000
他有一个列表

244
00:08:23,000 --> 00:08:24,000
有个 End of Life

245
00:08:24,000 --> 00:08:24,000
这位列表

246
00:08:24,000 --> 00:08:26,000
就有一堆都是

247
00:08:26,000 --> 00:08:27,000
应该是已经停产了的

248
00:08:28,000 --> 00:08:29,000
OK

249
00:08:30,000 --> 00:08:32,000
pfeo.fujitsu.com

250
00:08:34,000 --> 00:08:36,000
所以现在在收的是 Type S

251
00:08:37,000 --> 00:08:38,000
Professional JP

252
00:08:38,000 --> 00:08:39,000
就是日文版

253
00:08:39,000 --> 00:08:40,000
Professional 2

254
00:08:40,000 --> 00:08:41,000
Lite 2

255
00:08:41,000 --> 00:08:42,000
还有一个 Lite 2 for Mac

256
00:08:42,000 --> 00:08:43,000
对

257
00:08:43,000 --> 00:08:44,000
这个 Professional JP

258
00:08:44,000 --> 00:08:45,000
应该就是第一代的

259
00:08:48,000 --> 00:08:49,000
然后还有其他四款

260
00:08:49,000 --> 00:08:50,000
都是国际键

261
00:08:50,000 --> 00:08:52,000
是所谓的 International

262
00:08:52,000 --> 00:08:52,000
Lite 2

263
00:08:52,000 --> 00:08:55,000
Professional 2 也有 JP 的版本

264
00:08:55,000 --> 00:08:56,000
我没理解错了

265
00:08:57,000 --> 00:08:59,000
然后 Lite 2 也有 JP 的版本

266
00:09:00,000 --> 00:09:03,000
然后那个 JP 这一款的

267
00:09:04,000 --> 00:09:06,000
键的位置好像又不一样了

268
00:09:07,000 --> 00:09:09,000
就像我说的 Professional JP 的

269
00:09:09,000 --> 00:09:10,000
是第一代

270
00:09:10,000 --> 00:09:12,000
然后这一代只有日语版本

271
00:09:12,000 --> 00:09:15,000
然后这一代的下面的空格键

272
00:09:15,000 --> 00:09:15,000
非常多

273
00:09:16,000 --> 00:09:18,000
他多了好几个什么其他的键

274
00:09:18,000 --> 00:09:19,000
不知道是干嘛的

275
00:09:19,000 --> 00:09:19,000
对

276
00:09:20,000 --> 00:09:22,000
然后从 Professional 2 开始

277
00:09:22,000 --> 00:09:24,000
有了 International Layout

278
00:09:25,000 --> 00:09:27,000
Lite 2 也有 International Layout

279
00:09:27,000 --> 00:09:28,000
同时也有日语键

280
00:09:28,000 --> 00:09:29,000
好吧

281
00:09:29,000 --> 00:09:31,000
那个具体型号

282
00:09:31,000 --> 00:09:33,000
我们就不去啰嗦了

283
00:09:33,000 --> 00:09:34,000
我问你一件事

284
00:09:35,000 --> 00:09:38,000
你觉得方向键对你来说有用吗

285
00:09:39,000 --> 00:09:42,000
其实还是有一些用处

286
00:09:43,000 --> 00:09:44,000
就这么说

287
00:09:44,000 --> 00:09:46,000
因为我们两个都是 Pro 2 的版本

288
00:09:46,000 --> 00:09:47,000
是没有方向键的

289
00:09:48,000 --> 00:09:52,000
你在非文本输入框的时候

290
00:09:52,000 --> 00:09:54,000
怎么去用方向键

291
00:09:55,000 --> 00:09:56,000
你要用 FNT

292
00:09:56,000 --> 00:10:00,000
然后按四个键对吧

293
00:10:00,000 --> 00:10:00,000
对

294
00:10:01,000 --> 00:10:02,000
你经常这样干吗

295
00:10:03,000 --> 00:10:04,000
还是挺平常的

296
00:10:04,000 --> 00:10:06,000
而且我其实右手的小拇指在

297
00:10:07,000 --> 00:10:08,000
右手的小指在

298
00:10:08,000 --> 00:10:11,000
有一段时间以来是疼着的

299
00:10:13,000 --> 00:10:15,000
就按 FNT 的原因是吧

300
00:10:15,000 --> 00:10:15,000
对

301
00:10:16,000 --> 00:10:17,000
而且不止那个

302
00:10:17,000 --> 00:10:19,000
就是在公司里面

303
00:10:19,000 --> 00:10:22,000
我把 FN 加上 A 和 S

304
00:10:22,000 --> 00:10:25,000
弄成了调节音量大小

305
00:10:25,000 --> 00:10:27,000
所以调节音量也要按那两个

306
00:10:28,000 --> 00:10:30,000
FN 是可以自定义的吗

307
00:10:32,000 --> 00:10:35,000
FN 加 A 和 FN 加 S

308
00:10:35,000 --> 00:10:37,000
在普通 PC 上也是调节音量

309
00:10:37,000 --> 00:10:39,000
其实在 Mac 上也是

310
00:10:39,000 --> 00:10:39,000
我想起

311
00:10:41,000 --> 00:10:42,000
然后这个组合

312
00:10:42,000 --> 00:10:44,000
你在公司用的是 Linux 系统

313
00:10:44,000 --> 00:10:44,000
对吧

314
00:10:44,000 --> 00:10:45,000
不是 OS X

315
00:10:46,000 --> 00:10:46,000
对

316
00:10:47,000 --> 00:10:48,000
因为我上次的印象是我

317
00:10:48,000 --> 00:10:50,000
用 FN 键定义的时候

318
00:10:50,000 --> 00:10:51,000
好像没有按出来有什么

319
00:10:52,000 --> 00:10:53,000
FN 加个什么

320
00:10:53,000 --> 00:10:54,000
好像不能在

321
00:10:55,000 --> 00:10:57,000
苹果键盘的设置里面

322
00:10:57,000 --> 00:10:58,000
调成一个快捷键

323
00:10:58,000 --> 00:10:59,000
可以吗

324
00:10:59,000 --> 00:10:59,000
这个不行

325
00:10:59,000 --> 00:11:01,000
但是 FN 加 A

326
00:11:02,000 --> 00:11:05,000
直接对应了多媒体键里面的

327
00:11:05,000 --> 00:11:06,000
Volume Up

328
00:11:07,000 --> 00:11:08,000
如果我没记错的话

329
00:11:08,000 --> 00:11:08,000
对

330
00:11:08,000 --> 00:11:09,000
OK

331
00:11:09,000 --> 00:11:10,000
Good to know

332
00:11:10,000 --> 00:11:11,000
所以我还可以

333
00:11:11,000 --> 00:11:13,000
你这个怎么查

334
00:11:13,000 --> 00:11:15,000
在哪里知道有这些对应的关系

335
00:11:17,000 --> 00:11:18,000
你的

336
00:11:19,000 --> 00:11:21,000
你不是有刻印键盘吗

337
00:11:21,000 --> 00:11:22,000
你那个键盘在

338
00:11:22,000 --> 00:11:24,000
正下方是没有吗

339
00:11:24,000 --> 00:11:26,000
在 FN 就是

340
00:11:26,000 --> 00:11:27,000
就是

341
00:11:27,000 --> 00:11:28,000
这么说吧

342
00:11:28,000 --> 00:11:30,000
在左手键那些区上面

343
00:11:30,000 --> 00:11:32,000
只有键帽顶上才有

344
00:11:32,000 --> 00:11:34,000
没有侧边的

345
00:11:35,000 --> 00:11:36,000
额外的键的

346
00:11:36,000 --> 00:11:37,000
含义的

347
00:11:37,000 --> 00:11:38,000
嗯

348
00:11:39,000 --> 00:11:40,000
所以我不知道为什么

349
00:11:40,000 --> 00:11:42,000
你知道 FN 加 A 和 S 是调音量

350
00:11:42,000 --> 00:11:43,000
我从来没有试过

351
00:11:44,000 --> 00:11:46,000
因为说明书上有写吧

352
00:11:46,000 --> 00:11:46,000
我记得

353
00:11:47,000 --> 00:11:48,000
还有说明书

354
00:11:48,000 --> 00:11:49,000
对

355
00:11:49,000 --> 00:11:51,000
你是哪来的山寨

356
00:11:51,000 --> 00:11:54,000
是李如荫直接寄给你的是吧

357
00:11:55,000 --> 00:11:55,000
对啊

358
00:11:55,000 --> 00:11:56,000
因为是

359
00:11:56,000 --> 00:11:57,000
他寄过来

360
00:11:57,000 --> 00:12:00,000
就是没有原装盒子

361
00:12:00,000 --> 00:12:01,000
而且这个人

362
00:12:02,000 --> 00:12:04,000
李如荫这点做的太不靠谱了

363
00:12:04,000 --> 00:12:05,000
你要是我我一定会吧

364
00:12:06,000 --> 00:12:07,000
原厂说明书

365
00:12:07,000 --> 00:12:10,000
这个事情不管他好意

366
00:12:10,000 --> 00:12:13,000
因为是他说家人打包寄的

367
00:12:13,000 --> 00:12:14,000
所以比较麻烦

368
00:12:14,000 --> 00:12:15,000
OK

369
00:12:15,000 --> 00:12:19,000
就我拿到的时候连 USB 的线都没有

370
00:12:19,000 --> 00:12:20,000
反正都是通用的一个

371
00:12:20,000 --> 00:12:22,000
应该是

372
00:12:23,000 --> 00:12:24,000
迷你 USB 吧

373
00:12:24,000 --> 00:12:25,000
嗯对没错

374
00:12:25,000 --> 00:12:26,000
还挺常见

375
00:12:26,000 --> 00:12:27,000
我就自己配了一个

376
00:12:27,000 --> 00:12:28,000
就还可以

377
00:12:28,000 --> 00:12:30,000
但是我不知道还有说明书的

378
00:12:30,000 --> 00:12:31,000
这么一回事

379
00:12:31,000 --> 00:12:31,000
是的

380
00:12:31,000 --> 00:12:32,000
他还有说明书

381
00:12:32,000 --> 00:12:34,000
而且他说明书里面会写

382
00:12:34,000 --> 00:12:35,000
后面几个跳线

383
00:12:35,000 --> 00:12:36,000
搬到什么状态

384
00:12:36,000 --> 00:12:37,000
是什么样的功用

385
00:12:38,000 --> 00:12:40,000
DAP 可以在网站上查的

386
00:12:40,000 --> 00:12:43,000
但是你说快捷键是

387
00:12:43,000 --> 00:12:45,000
快捷键应该也能在网上查

388
00:12:45,000 --> 00:12:46,000
很准确

389
00:12:48,000 --> 00:12:48,000
真的吗

390
00:12:48,000 --> 00:12:49,000
对

391
00:12:49,000 --> 00:12:49,000
好吧

392
00:12:49,000 --> 00:12:50,000
那我查一下

393
00:12:53,000 --> 00:12:54,000
我还看到了这个

394
00:12:55,000 --> 00:12:56,000
这个 4 Mac

395
00:12:56,000 --> 00:12:57,000
它是 Lite 2 的话

396
00:12:57,000 --> 00:12:59,000
多了一个 FNK 在左边是吧

397
00:13:00,000 --> 00:13:01,000
右边 FNK 还有吗

398
00:13:02,000 --> 00:13:03,000
有也有

399
00:13:03,000 --> 00:13:04,000
但左边又多了一个 FNK

400
00:13:04,000 --> 00:13:05,000
这个还蛮有用的

401
00:13:05,000 --> 00:13:07,000
就我发现最严重的问题就是

402
00:13:08,000 --> 00:13:09,000
FNK 在右边

403
00:13:09,000 --> 00:13:11,000
然后在苹果键盘上

404
00:13:11,000 --> 00:13:12,000
FNK 是在左下角

405
00:13:13,000 --> 00:13:15,000
就是说还蛮人格分裂的

406
00:13:15,000 --> 00:13:17,000
一会按左边一会按右边

407
00:13:21,000 --> 00:13:22,000
然后再问你

408
00:13:22,000 --> 00:13:23,000
就是说在

409
00:13:24,000 --> 00:13:27,000
OS X 的系统的文本编辑框里面

410
00:13:27,000 --> 00:13:29,000
你要换上下行的时候你怎么办

411
00:13:30,000 --> 00:13:31,000
再说一遍

412
00:13:31,000 --> 00:13:33,000
OS X 系统的文本框

413
00:13:33,000 --> 00:13:35,000
就是比如说在

414
00:13:35,000 --> 00:13:35,000
这么说嘛

415
00:13:36,000 --> 00:13:37,000
在就现在用的是这个

416
00:13:37,000 --> 00:13:39,000
我们用 NV AUT 编辑这个

417
00:13:39,000 --> 00:13:40,000
Note

418
00:13:41,000 --> 00:13:43,000
你要切换上下行怎么办

419
00:13:45,000 --> 00:13:46,000
用方向键

420
00:13:49,000 --> 00:13:52,000
然后你要左右移动光标怎么办

421
00:13:54,000 --> 00:13:55,000
Ctrl 加 PN 是可以的吧

422
00:13:56,000 --> 00:13:57,000
然后

423
00:13:57,000 --> 00:13:58,000
那个是 EmacsKeyBinding

424
00:13:58,000 --> 00:14:00,000
但是你是一个 Win 用户

425
00:14:00,000 --> 00:14:00,000
对

426
00:14:01,000 --> 00:14:02,000
所以我用方向键

427
00:14:04,000 --> 00:14:06,000
我为了这件事情

428
00:14:06,000 --> 00:14:07,000
因为方向键不好用

429
00:14:07,000 --> 00:14:08,000
要用那个

430
00:14:08,000 --> 00:14:08,000
那个

431
00:14:08,000 --> 00:14:09,000
那按

432
00:14:09,000 --> 00:14:09,000
其实

433
00:14:10,000 --> 00:14:11,000
都是要用小指的

434
00:14:11,000 --> 00:14:12,000
左边的话

435
00:14:12,000 --> 00:14:14,000
Ctrl 键也算有用小指

436
00:14:14,000 --> 00:14:17,000
在普通键盘的 CapsWalk 的位置

437
00:14:19,000 --> 00:14:19,000
对吧

438
00:14:21,000 --> 00:14:22,000
然后你要用 Ctrl 按着

439
00:14:22,000 --> 00:14:24,000
然后 N 是下一行

440
00:14:24,000 --> 00:14:25,000
P 是上一行

441
00:14:25,000 --> 00:14:28,000
然后 F 是右移

442
00:14:28,000 --> 00:14:29,000
然后 B 是左移光标

443
00:14:30,000 --> 00:14:31,000
但是如果你用方向键的话

444
00:14:31,000 --> 00:14:33,000
其实就是用右手的小指按 Draft

445
00:14:33,000 --> 00:14:35,000
然后按那几个方向键的

446
00:14:35,000 --> 00:14:36,000
附用的键

447
00:14:37,000 --> 00:14:38,000
其实好像是差不多的

448
00:14:38,000 --> 00:14:39,000
我觉得

449
00:14:39,000 --> 00:14:41,000
所以你的点是什么

450
00:14:41,000 --> 00:14:42,000
就是你作为一个 Win 用户

451
00:14:42,000 --> 00:14:43,000
为了捍卫自己的尊严

452
00:14:43,000 --> 00:14:45,000
所以一定要找到一个

453
00:14:45,000 --> 00:14:46,000
我现在很分裂

454
00:14:46,000 --> 00:14:48,000
因为我一会要用 EmacsKeyBinding

455
00:14:48,000 --> 00:14:49,000
一会要用那个

456
00:14:50,000 --> 00:14:52,000
我本质上就遇到这种

457
00:14:52,000 --> 00:14:56,000
非 Win 的 KeyBinding 支持的情况下

458
00:14:56,000 --> 00:14:57,000
比如说在

459
00:14:57,000 --> 00:14:59,000
这个故意界面上

460
00:14:59,000 --> 00:15:01,000
你选择上下的一个菜单

461
00:15:01,000 --> 00:15:01,000
举个例子

462
00:15:01,000 --> 00:15:04,000
你只能用这个方向键了吗

463
00:15:04,000 --> 00:15:04,000
对

464
00:15:05,000 --> 00:15:06,000
这个时候我就只能按住

465
00:15:06,000 --> 00:15:07,000
用一个右手的小指

466
00:15:07,000 --> 00:15:08,000
按 Draft

467
00:15:08,000 --> 00:15:09,000
然后用附用方向键去

468
00:15:09,000 --> 00:15:11,000
去调那个选择

469
00:15:11,000 --> 00:15:13,000
但是在很多我们编制框里面

470
00:15:13,000 --> 00:15:15,000
我又再用 EmacsKeyBinding

471
00:15:15,000 --> 00:15:16,000
比如说在 NVAuto

472
00:15:16,000 --> 00:15:17,000
或者是这个

473
00:15:17,000 --> 00:15:19,000
比如说 Safari 的地址栏

474
00:15:19,000 --> 00:15:20,000
我要编辑它的时候

475
00:15:20,000 --> 00:15:21,000
我又会用

476
00:15:22,000 --> 00:15:24,000
EmacsKeyBinding 去

477
00:15:24,000 --> 00:15:26,000
去加速我的光标移动

478
00:15:26,000 --> 00:15:27,000
比如说可以一个 word

479
00:15:27,000 --> 00:15:27,000
一个 word

480
00:15:27,000 --> 00:15:28,000
而不是一个 character

481
00:15:28,000 --> 00:15:29,000
一个 character 移动

482
00:15:31,000 --> 00:15:34,000
所以我最近特别人格分裂

483
00:15:34,000 --> 00:15:34,000
你知道吗

484
00:15:34,000 --> 00:15:37,000
然后在 Terminal

485
00:15:37,000 --> 00:15:38,000
或者是在 Win 里面打的

486
00:15:38,000 --> 00:15:40,000
就是用 Win 的 KeyBinding

487
00:15:42,000 --> 00:15:44,000
你在 Terminal 里面用 Win 的 KeyBinding

488
00:15:45,000 --> 00:15:49,000
你是说你的 LineEdit 用的是 Win 的 KeyBinding

489
00:15:49,000 --> 00:15:50,000
对

490
00:15:51,000 --> 00:15:54,000
我已经把 LineEdit 的 KeyBinding

491
00:15:54,000 --> 00:15:57,000
就是改回默认的 EmacsKeyBinding

492
00:15:58,000 --> 00:16:00,000
所以你也叛逃了

493
00:16:00,000 --> 00:16:01,000
不我不是

494
00:16:01,000 --> 00:16:01,000
对

495
00:16:01,000 --> 00:16:04,000
主要是向现实妥协

496
00:16:04,000 --> 00:16:05,000
就是

497
00:16:05,000 --> 00:16:07,000
因为一天要连

498
00:16:08,000 --> 00:16:12,000
无数台 remote session 的话

499
00:16:12,000 --> 00:16:14,000
就 SSH 到其他的机器上的话

500
00:16:15,000 --> 00:16:15,000
不想每次都改

501
00:16:15,000 --> 00:16:16,000
不想每次都改

502
00:16:16,000 --> 00:16:17,000
对

503
00:16:18,000 --> 00:16:21,000
而且去用别人的键盘的时候

504
00:16:21,000 --> 00:16:23,000
也会非常的痛苦

505
00:16:24,000 --> 00:16:25,000
好吧理解了

506
00:16:25,000 --> 00:16:26,000
所以总体来说

507
00:16:26,000 --> 00:16:29,000
HKB Pro 2 你用起来

508
00:16:30,000 --> 00:16:31,000
你用了多久了到底

509
00:16:32,000 --> 00:16:33,000
一年多

510
00:16:34,000 --> 00:16:35,000
所以感觉如何

511
00:16:35,000 --> 00:16:36,000
我也不知道

512
00:16:36,000 --> 00:16:37,000
我觉得他已经内化了

513
00:16:37,000 --> 00:16:38,000
就是你不说的话

514
00:16:38,000 --> 00:16:41,000
不觉得他是一个什么事了是吧

515
00:16:41,000 --> 00:16:43,000
对现在我已经不觉得他是一个

516
00:16:43,000 --> 00:16:44,000
因为我刚用一个月

517
00:16:45,000 --> 00:16:46,000
所以感觉还不太一样

518
00:16:46,000 --> 00:16:47,000
就是有时候会觉得

519
00:16:47,000 --> 00:16:48,000
有点人格分裂

520
00:16:48,000 --> 00:16:51,000
因为我还用笔记本的 Magnet

521
00:16:51,000 --> 00:16:51,000
自带的那个键盘

522
00:16:51,000 --> 00:16:52,000
对我也是

523
00:16:54,000 --> 00:16:56,000
而且我的两个 layout 是不一样的

524
00:16:56,000 --> 00:16:56,000
所以其实我在想

525
00:16:58,000 --> 00:16:59,000
他现在在卖 Lite 4 Mac

526
00:16:59,000 --> 00:17:02,000
那个感觉可能稍微正常一点

527
00:17:02,000 --> 00:17:03,000
所以要买一块

528
00:17:03,000 --> 00:17:04,000
再说吧

529
00:17:04,000 --> 00:17:07,000
先适应一段时间再说

530
00:17:07,000 --> 00:17:10,000
看看到底能不能够接受这种方式

531
00:17:10,000 --> 00:17:11,000
我觉得整个手感还是不错的

532
00:17:12,000 --> 00:17:14,000
Topre 的按键的感觉还是

533
00:17:14,000 --> 00:17:14,000
噔噔噔

534
00:17:15,000 --> 00:17:15,000
这种

535
00:17:16,000 --> 00:17:16,000
比较噔噔噔

536
00:17:16,000 --> 00:17:17,000
咚噔的感觉

537
00:17:20,000 --> 00:17:21,000
OK

538
00:17:21,000 --> 00:17:22,000
好

539
00:17:22,000 --> 00:17:23,000
好吧

540
00:17:23,000 --> 00:17:24,000
不出这个单

541
00:17:25,000 --> 00:17:26,000
那今天我们接下来下一个环节

542
00:17:26,000 --> 00:17:29,000
读两封听众来信

543
00:17:30,000 --> 00:17:30,000
第一封你来吧

544
00:17:32,000 --> 00:17:32,000
好

545
00:17:33,000 --> 00:17:36,000
对这两封来信都是针对上一期

546
00:17:36,000 --> 00:17:38,000
那个我读百

547
00:17:38,000 --> 00:17:38,000
你的读百

548
00:17:38,000 --> 00:17:39,000
对

549
00:17:41,000 --> 00:17:42,000
就反正事后

550
00:17:43,000 --> 00:17:46,000
不鸟万如一和不鸟万 Rail 先生

551
00:17:46,000 --> 00:17:47,000
都表达了惊讶说

552
00:17:47,000 --> 00:17:48,000
你一个人嘚嘚嘚嘚

553
00:17:48,000 --> 00:17:50,000
居然可以多为一小时

554
00:17:50,000 --> 00:17:51,000
这个真的

555
00:17:52,000 --> 00:17:53,000
我自己也没想到我可以多为一小时

556
00:17:53,000 --> 00:17:55,000
但事实上

557
00:17:55,000 --> 00:17:57,000
我本来是计划多为两个小时

558
00:18:00,000 --> 00:18:02,000
我觉得已经很厉害了

559
00:18:02,000 --> 00:18:03,000
OK

560
00:18:03,000 --> 00:18:04,000
谢谢

561
00:18:05,000 --> 00:18:09,000
首先是我们的老朋友 Virgil Ming 先生

562
00:18:09,000 --> 00:18:10,000
是先生吗

563
00:18:10,000 --> 00:18:11,000
寄来的

564
00:18:11,000 --> 00:18:11,000
我小朋友

565
00:18:11,000 --> 00:18:12,000
对

566
00:18:12,000 --> 00:18:14,000
寄来一封听众来信

567
00:18:16,000 --> 00:18:17,000
无汤您好

568
00:18:18,000 --> 00:18:21,000
这是对新鲜出炉的第 18 期节目的反馈

569
00:18:21,000 --> 00:18:25,000
对我记得这一期应该是在上线之后

570
00:18:25,000 --> 00:18:27,000
可能五六个小时

571
00:18:27,000 --> 00:18:28,000
他就写了一封

572
00:18:28,000 --> 00:18:30,000
写了这封信来

573
00:18:30,000 --> 00:18:31,000
真是太热血了

574
00:18:34,000 --> 00:18:35,000
他说

575
00:18:35,000 --> 00:18:37,000
高级程序语言到汇编

576
00:18:37,000 --> 00:18:38,000
到可执行文件

577
00:18:38,000 --> 00:18:41,000
到机器指令这一系列过程

578
00:18:41,000 --> 00:18:42,000
并不算是编码吧

579
00:18:43,000 --> 00:18:45,000
Compile 和 Encode 是两回事

580
00:18:46,000 --> 00:18:46,000
这个

581
00:18:47,000 --> 00:18:48,000
对

582
00:18:48,000 --> 00:18:50,000
其实我之所以说自己本来计划

583
00:18:50,000 --> 00:18:52,000
计划说两个小时

584
00:18:52,000 --> 00:18:54,000
就是因为我后一个小时是要说编码的

585
00:18:55,000 --> 00:18:58,000
但是说到一个小时的时候已经就撑不住了

586
00:18:59,000 --> 00:19:02,000
前一部分是说 Compile

587
00:19:02,000 --> 00:19:02,000
对

588
00:19:02,000 --> 00:19:06,000
就是说计算机的指令是怎样转换为二进是指令的

589
00:19:07,000 --> 00:19:10,000
计算机的文本指令是如何转换为二进指令

590
00:19:11,000 --> 00:19:14,000
然后我本来计划在后半部讲编码

591
00:19:15,000 --> 00:19:16,000
就是什么 Unicode

592
00:19:16,000 --> 00:19:17,000
Ascii

593
00:19:17,000 --> 00:19:19,000
什么 GV

594
00:19:20,000 --> 00:19:21,000
blabla 一系列

595
00:19:21,000 --> 00:19:24,000
但是后来实在是抽不下去了

596
00:19:26,000 --> 00:19:28,000
所以才会给人这种印象

597
00:19:28,000 --> 00:19:28,000
对

598
00:19:28,000 --> 00:19:31,000
其实上一期的真正的主题的确是编码

599
00:19:31,000 --> 00:19:32,000
只不过

600
00:19:32,000 --> 00:19:34,000
没能进入真正主题

601
00:19:36,000 --> 00:19:36,000
这叫什么

602
00:19:36,000 --> 00:19:38,000
戛然而止

603
00:19:38,000 --> 00:19:38,000
对

604
00:19:39,000 --> 00:19:40,000
你念对那个字了

605
00:19:42,000 --> 00:19:42,000
接着读

606
00:19:43,000 --> 00:19:45,000
有一件事情让我有些感叹

607
00:19:45,000 --> 00:19:48,000
Ascii 编码里面大写字母的 A 是 65

608
00:19:48,000 --> 00:19:52,000
这件事情存在我记忆里面应该已经 10 年了吧

609
00:19:52,000 --> 00:19:54,000
然而直到今天我才明白

610
00:19:54,000 --> 00:19:55,000
那是 64 加 1

611
00:19:56,000 --> 00:19:57,000
当年只是把 65

612
00:19:59,000 --> 00:20:02,000
当年只是把 65 作为一个 Magic Number

613
00:20:02,000 --> 00:20:03,000
强行记住而已

614
00:20:04,000 --> 00:20:06,000
因为当时刚刚选而行之

615
00:20:06,000 --> 00:20:07,000
对此丝毫不敏感

616
00:20:07,000 --> 00:20:09,000
老师也没有多解释

617
00:20:09,000 --> 00:20:10,000
我也没有觉得有什么不对

618
00:20:10,000 --> 00:20:13,000
然而现在看来明天是少了一块拼图

619
00:20:13,000 --> 00:20:14,000
以此类推

620
00:20:14,000 --> 00:20:16,000
小写字母 A 是 97

621
00:20:16,000 --> 00:20:18,000
97 就等于 64 加上 32 加上 1

622
00:20:18,000 --> 00:20:19,000
也是很符合逻辑的

623
00:20:21,000 --> 00:20:21,000
所以

624
00:20:22,000 --> 00:20:23,000
这里就是

625
00:20:24,000 --> 00:20:26,000
它的意思就是 64 这个数字

626
00:20:28,000 --> 00:20:29,000
就是 8 进制

627
00:20:29,000 --> 00:20:31,000
不是 8 进制

628
00:20:31,000 --> 00:20:33,000
2 进制的 7 位的

629
00:20:33,000 --> 00:20:34,000
1

630
00:20:34,000 --> 00:20:35,000
然后跟 6 个 0

631
00:20:36,000 --> 00:20:37,000
所以这是一个特别的数字

632
00:20:37,000 --> 00:20:38,000
然后

633
00:20:39,000 --> 00:20:40,000
97 是 64 加 32

634
00:20:40,000 --> 00:20:42,000
也就是 1 后面 6 个 0

635
00:20:42,000 --> 00:20:43,000
加上 1 后面 5 个 0

636
00:20:43,000 --> 00:20:45,000
也就是 100000

637
00:20:46,000 --> 00:20:48,000
这个数字是 96

638
00:20:48,000 --> 00:20:50,000
然后 96 后面的第 1 个

639
00:20:51,000 --> 00:20:54,000
就是 1000001

640
00:20:55,000 --> 00:20:58,000
2 进制编码是代表小写字母 A

641
00:20:58,000 --> 00:20:59,000
所以这些

642
00:20:59,000 --> 00:21:00,000
其实在最开始规定

643
00:21:00,000 --> 00:21:03,000
ASCII 码的时候都已经

644
00:21:03,000 --> 00:21:05,000
都是有一定的内在逻辑

645
00:21:06,000 --> 00:21:07,000
然后

646
00:21:08,000 --> 00:21:11,000
然后 ASCII 码的 64 就是 at

647
00:21:11,000 --> 00:21:13,000
所以各位如果你要

648
00:21:13,000 --> 00:21:15,000
想去铭记某一个事件的时候

649
00:21:15,000 --> 00:21:17,000
你可以多拿几个 at

650
00:21:17,000 --> 00:21:19,000
然后前面可以加上一个大写字母 Y

651
00:21:21,000 --> 00:21:22,000
OK

652
00:21:22,000 --> 00:21:23,000
接着读

653
00:21:25,000 --> 00:21:27,000
这让我想到另一件事

654
00:21:27,000 --> 00:21:30,000
大一的思学家课程里面有一道西题

655
00:21:30,000 --> 00:21:32,000
实现一个支持 reverse

656
00:21:32,000 --> 00:21:34,000
polish notation 的计算器

657
00:21:34,000 --> 00:21:36,000
当时也没觉得有什么特别之处

658
00:21:36,000 --> 00:21:38,000
无非就是个循环练习吗

659
00:21:38,000 --> 00:21:41,000
为什么要弄出这么一套反直觉的计法呢

660
00:21:41,000 --> 00:21:42,000
直到两年之后

661
00:21:42,000 --> 00:21:44,000
到 functional programming 课

662
00:21:45,000 --> 00:21:47,000
到快捞系统考试的时候

663
00:21:47,000 --> 00:21:48,000
才突然反应过来

664
00:21:48,000 --> 00:21:50,000
这无非就是换一个形式

665
00:21:50,000 --> 00:21:53,000
针对四字标运算非常特别的情况

666
00:21:54,000 --> 00:21:58,000
显示的把地规优化成循环

667
00:21:59,000 --> 00:22:04,000
而 reverse polish notation 发明早于 Lisp 二三十年

668
00:22:04,000 --> 00:22:07,000
我也没读 Lisp 最早的那篇论文

669
00:22:07,000 --> 00:22:09,000
但我相信两者形式上相通

670
00:22:09,000 --> 00:22:10,000
绝不只是偶然

671
00:22:11,000 --> 00:22:12,000
这种感觉不知道怎么形容

672
00:22:12,000 --> 00:22:14,000
Djavu 吗

673
00:22:14,000 --> 00:22:15,000
如果在一开始学习的时候

674
00:22:15,000 --> 00:22:18,000
就能了解背后这些神秘的东西

675
00:22:18,000 --> 00:22:20,000
Computer science 本来应该可以更迷人

676
00:22:22,000 --> 00:22:23,000
至于你的节目里面

677
00:22:23,000 --> 00:22:26,000
只有一分钟不到的正题

678
00:22:26,000 --> 00:22:29,000
省略几百字的吐槽

679
00:22:29,000 --> 00:22:31,000
但有一点我想说明

680
00:22:31,000 --> 00:22:32,000
这么说吧

681
00:22:32,000 --> 00:22:34,000
我们口号

682
00:22:34,000 --> 00:22:36,000
仅止我自己周边的人

683
00:22:36,000 --> 00:22:38,000
我生于 1992 年

684
00:22:38,000 --> 00:22:39,000
口号结束

685
00:22:39,000 --> 00:22:41,000
这就是为什么我说这是个小朋友

686
00:22:41,000 --> 00:22:43,000
1992 年

687
00:22:43,000 --> 00:22:43,000
天哪

688
00:22:45,000 --> 00:22:47,000
90 后的明先生你好

689
00:22:47,000 --> 00:22:49,000
对 90 后的明小朋友你好

690
00:22:51,000 --> 00:22:52,000
接念

691
00:22:52,000 --> 00:22:54,000
我们生长起来的环境里面

692
00:22:54,000 --> 00:22:56,000
并没有什么机制来保证

693
00:22:56,000 --> 00:22:58,000
人们在生长过程中

694
00:22:58,000 --> 00:23:00,000
能够以较温和的方式

695
00:23:00,000 --> 00:23:03,000
了解如何谈恋爱这个常识

696
00:23:04,000 --> 00:23:06,000
独生子女和父母离婚成风

697
00:23:07,000 --> 00:23:09,000
90 年代人们突然像赶狮毛似的

698
00:23:09,000 --> 00:23:13,000
开始考虑甚至执行离婚结束

699
00:23:13,000 --> 00:23:14,000
但影响都不提了

700
00:23:14,000 --> 00:23:16,000
我可以确定的是

701
00:23:16,000 --> 00:23:19,000
在大学之前三观尚未定型的时候

702
00:23:19,000 --> 00:23:22,000
在国内练习谈恋爱的机会不仅是少

703
00:23:22,000 --> 00:23:25,000
而且大多数情况下是离经叛道

704
00:23:25,000 --> 00:23:27,000
得不到任何可靠的第三方支持的

705
00:23:27,000 --> 00:23:28,000
于是

706
00:23:28,000 --> 00:23:30,000
等到上了大学之后

707
00:23:30,000 --> 00:23:32,000
我听到看到了许多

708
00:23:32,000 --> 00:23:34,000
不知道该称为悲剧还是黑色幽默的故事

709
00:23:35,000 --> 00:23:36,000
我自己也

710
00:23:36,000 --> 00:23:38,000
不知道有幸还是不幸

711
00:23:38,000 --> 00:23:40,000
参与了其中一个

712
00:23:41,000 --> 00:23:43,000
Learn it the hard way 的确是有效的策略

713
00:23:43,000 --> 00:23:45,000
但是如果我们讨论的是感情

714
00:23:46,000 --> 00:23:48,000
这里的 hard way 可能对你

715
00:23:48,000 --> 00:23:51,000
或者对于对方造成不可逆的伤害

716
00:23:52,000 --> 00:23:53,000
真的没问题吗

717
00:23:53,000 --> 00:23:54,000
更重要的是

718
00:23:54,000 --> 00:23:56,000
最好的时机已经过去了

719
00:23:56,000 --> 00:23:58,000
这个 bug 改起来会非常痛苦

720
00:23:58,000 --> 00:23:59,000
进入于不可行

721
00:23:59,000 --> 00:24:01,000
这不只是程序员的问题

722
00:24:01,000 --> 00:24:02,000
我承认外行人

723
00:24:02,000 --> 00:24:05,000
甚至业内人士对于程序员的 stereotype

724
00:24:05,000 --> 00:24:06,000
有时候不可理喻

725
00:24:06,000 --> 00:24:08,000
但问题的本质及仅是

726
00:24:08,000 --> 00:24:10,000
作为一个人

727
00:24:10,000 --> 00:24:13,000
如何发展处理和另一个人的亲密关系而已

728
00:24:14,000 --> 00:24:16,000
把职业甚至相关的 stereotype

729
00:24:16,000 --> 00:24:18,000
卷进来作为预设处理

730
00:24:18,000 --> 00:24:20,000
难道不是原木求鱼吗

731
00:24:20,000 --> 00:24:22,000
最后你为什么要一次性录完

732
00:24:22,000 --> 00:24:24,000
不能休息一天接着录吗

733
00:24:25,000 --> 00:24:26,000
OK 念完了

734
00:24:28,000 --> 00:24:29,000
任何什么想说的吗

735
00:24:30,000 --> 00:24:34,000
其实我觉得他对你上期的

736
00:24:34,000 --> 00:24:36,000
打引号的政题的诠释挺好的

737
00:24:37,000 --> 00:24:39,000
这个真的是一件跟职业

738
00:24:39,000 --> 00:24:41,000
什么其他关系不大的事情

739
00:24:41,000 --> 00:24:42,000
这就是一个

740
00:24:43,000 --> 00:24:46,000
做人的基本的一些东西

741
00:24:46,000 --> 00:24:47,000
在我们现在

742
00:24:48,000 --> 00:24:50,000
我很社会的一个欠缺

743
00:24:51,000 --> 00:24:52,000
但我觉得很神奇的是

744
00:24:52,000 --> 00:24:55,000
90 后现在谈恋爱还是这么受限吗

745
00:24:55,000 --> 00:24:56,000
对我有这个感想

746
00:24:57,000 --> 00:24:57,000
我觉得

747
00:24:58,000 --> 00:25:01,000
我们这 80 年代以后的这一批人

748
00:25:01,000 --> 00:25:02,000
这次 Rail 调不到了

749
00:25:02,000 --> 00:25:04,000
你好歹也是个 80 后

750
00:25:05,000 --> 00:25:07,000
我们在年轻的时候

751
00:25:07,000 --> 00:25:08,000
谈恋爱也很受限制

752
00:25:08,000 --> 00:25:10,000
这个是实情

753
00:25:10,000 --> 00:25:11,000
但是我怎么觉得好像

754
00:25:13,000 --> 00:25:15,000
90 后应该不存在这样的限制

755
00:25:16,000 --> 00:25:16,000
难道

756
00:25:17,000 --> 00:25:20,000
难道是中国还是那个样子吗

757
00:25:22,000 --> 00:25:24,000
作为两个

758
00:25:25,000 --> 00:25:27,000
外国生活在外国的人

759
00:25:27,000 --> 00:25:29,000
怎么说真的是

760
00:25:32,000 --> 00:25:32,000
什么

761
00:25:32,000 --> 00:25:34,000
对我觉得我们觉得我不够了解他们

762
00:25:34,000 --> 00:25:35,000
就不不够了解

763
00:25:35,000 --> 00:25:37,000
这个后一个 10 年出生的人

764
00:25:37,000 --> 00:25:39,000
他们的一个成长的状况

765
00:25:39,000 --> 00:25:40,000
这个是挺

766
00:25:40,000 --> 00:25:42,000
挺讨厌的一件事情

767
00:25:43,000 --> 00:25:45,000
不过可能也可以理解

768
00:25:45,000 --> 00:25:48,000
因为你想我们毕业的时候

769
00:25:48,000 --> 00:25:49,000
带我们的那些老师

770
00:25:50,000 --> 00:25:52,000
至少还会在

771
00:25:52,000 --> 00:25:53,000
教职上

772
00:25:53,000 --> 00:25:55,000
对至少还会在教职上

773
00:25:55,000 --> 00:25:57,000
再待个 10 年

774
00:25:57,000 --> 00:25:58,000
所以

775
00:26:00,000 --> 00:26:01,000
也许

776
00:26:01,000 --> 00:26:02,000
现在谈恋爱的环境

777
00:26:02,000 --> 00:26:04,000
没有我们想象的这么开放

778
00:26:04,000 --> 00:26:06,000
或者这么理解

779
00:26:06,000 --> 00:26:08,000
就是只要高考这件事情还存在

780
00:26:08,000 --> 00:26:10,000
就只要中国还是这么一种

781
00:26:11,000 --> 00:26:11,000
这种

782
00:26:11,000 --> 00:26:14,000
就是说人多的竞争的模式

783
00:26:14,000 --> 00:26:16,000
可能这件事情就很难幸免

784
00:26:19,000 --> 00:26:20,000
有道理

785
00:26:21,000 --> 00:26:22,000
说到高考

786
00:26:22,000 --> 00:26:23,000
好像是昨天还是前几天

787
00:26:23,000 --> 00:26:24,000
刚刚高考结束

788
00:26:25,000 --> 00:26:28,000
不知道我们听众朋友里面有没有

789
00:26:29,000 --> 00:26:31,000
现在是属于解脱呢

790
00:26:31,000 --> 00:26:32,000
还是什么一个状态呢

791
00:26:33,000 --> 00:26:35,000
或者是刚刚考完

792
00:26:35,000 --> 00:26:36,000
打算报集团机系

793
00:26:36,000 --> 00:26:37,000
你千万别

794
00:26:39,000 --> 00:26:40,000
三思是吧

795
00:26:40,000 --> 00:26:41,000
对

796
00:26:41,000 --> 00:26:42,000
你得想清楚

797
00:26:43,000 --> 00:26:44,000
好吧

798
00:26:45,000 --> 00:26:47,000
然后我觉得他说的那个

799
00:26:48,000 --> 00:26:49,000
程旋的 stereotype

800
00:26:49,000 --> 00:26:51,000
就是我其实上一期

801
00:26:51,000 --> 00:26:52,000
我已经不记得自己说什么了

802
00:26:53,000 --> 00:26:53,000
突然忘了

803
00:26:53,000 --> 00:26:54,000
但是你上一期

804
00:26:54,000 --> 00:26:55,000
我觉得有一点

805
00:26:55,000 --> 00:26:57,000
就是我觉得他这里

806
00:26:57,000 --> 00:26:58,000
也有提到

807
00:26:58,000 --> 00:26:59,000
就是说

808
00:27:00,000 --> 00:27:02,000
这件事情跟职业真的没有太大关系

809
00:27:02,000 --> 00:27:03,000
对

810
00:27:03,000 --> 00:27:04,000
其实我上一期之所以会想到这个

811
00:27:04,000 --> 00:27:05,000
就是因为

812
00:27:07,000 --> 00:27:09,000
可能是在网上看到哪个帖子

813
00:27:09,000 --> 00:27:10,000
说什么我是程旋员

814
00:27:10,000 --> 00:27:11,000
找不到女朋友

815
00:27:11,000 --> 00:27:11,000
blabla

816
00:27:13,000 --> 00:27:14,000
或者是什么

817
00:27:14,000 --> 00:27:14,000
我男朋友是程旋员

818
00:27:14,000 --> 00:27:17,000
我想要送他一个什么什么什么什么玩意

819
00:27:17,000 --> 00:27:18,000
然后总是在想说

820
00:27:18,000 --> 00:27:20,000
程旋员这个身份有什么重要吗

821
00:27:21,000 --> 00:27:22,000
为什么

822
00:27:23,000 --> 00:27:25,000
要把这个身份单独提出来

823
00:27:25,000 --> 00:27:27,000
好像他三号三位就改变了

824
00:27:27,000 --> 00:27:28,000
你是一个

825
00:27:30,000 --> 00:27:31,000
人这一个

826
00:27:32,000 --> 00:27:32,000
基本

827
00:27:33,000 --> 00:27:35,000
现实一样

828
00:27:36,000 --> 00:27:39,000
有可能是跟你有一次说到

829
00:27:39,000 --> 00:27:40,000
这么一个事情有关系

830
00:27:40,000 --> 00:27:43,000
就是编程其实是一个逐渐易化的过程

831
00:27:43,000 --> 00:27:44,000
就是

832
00:27:44,000 --> 00:27:46,000
抛掉你作为人的那一面

833
00:27:46,000 --> 00:27:46,000
然后

834
00:27:47,000 --> 00:27:50,000
要把你假设成一个理性的机器

835
00:27:50,000 --> 00:27:51,000
去一行一行

836
00:27:51,000 --> 00:27:54,000
去解析执行那段代码的那个过程

837
00:27:54,000 --> 00:27:57,000
然后所以我不知道是不是时间长了之后

838
00:27:57,000 --> 00:27:58,000
会让人变得

839
00:27:59,000 --> 00:28:00,000
非

840
00:28:02,000 --> 00:28:05,000
非人类变得过于理性和非人类

841
00:28:05,000 --> 00:28:05,000
对

842
00:28:05,000 --> 00:28:06,000
然后

843
00:28:06,000 --> 00:28:09,000
你知道很多这个中国国内的这种

844
00:28:09,000 --> 00:28:11,000
教育出来的那种理工科生会

845
00:28:11,000 --> 00:28:13,000
有个字叫什么特别轴

846
00:28:13,000 --> 00:28:14,000
你知道吗

847
00:28:14,000 --> 00:28:15,000
就认死脸

848
00:28:15,000 --> 00:28:16,000
就不知道怎么变

849
00:28:16,000 --> 00:28:20,000
经常会把我们理科生挂在嘴边

850
00:28:20,000 --> 00:28:21,000
没错

851
00:28:21,000 --> 00:28:22,000
然后这个时候就这种人在

852
00:28:23,000 --> 00:28:24,000
感情上出现问题

853
00:28:24,000 --> 00:28:26,000
就是说你觉得逻辑上的事情是成立的

854
00:28:26,000 --> 00:28:28,000
但是你要知道这个事件并不是

855
00:28:29,000 --> 00:28:30,000
绕着逻辑的方式运行的

856
00:28:30,000 --> 00:28:31,000
对

857
00:28:31,000 --> 00:28:33,000
这件事情可能会让很多人感到伤感

858
00:28:33,000 --> 00:28:36,000
但现实就是在现实世界里面

859
00:28:36,000 --> 00:28:37,000
如果你把一个

860
00:28:38,000 --> 00:28:39,000
condition 测试一万遍

861
00:28:39,000 --> 00:28:40,000
那可能

862
00:28:41,000 --> 00:28:42,000
有 5000 遍

863
00:28:43,000 --> 00:28:44,000
是 true

864
00:28:44,000 --> 00:28:45,000
另外 5000 遍是 false

865
00:28:45,000 --> 00:28:47,000
你得不到一个确定的

866
00:28:47,000 --> 00:28:49,000
而不像程序里面

867
00:28:50,000 --> 00:28:52,000
我们接下来要接触的主题

868
00:28:52,000 --> 00:28:54,000
就是有些事情是可以重复的

869
00:28:54,000 --> 00:28:57,000
有些是这样重复的事情就是可以被测试

870
00:28:57,000 --> 00:29:00,000
但现实生活里面很多的一个东西是没有办法

871
00:29:01,000 --> 00:29:02,000
重复验证

872
00:29:02,000 --> 00:29:03,000
也许你再来一次

873
00:29:04,000 --> 00:29:06,000
得到的结果就会完全不一样

874
00:29:06,000 --> 00:29:07,000
谁知道

875
00:29:07,000 --> 00:29:08,000
甚至就说他们经常说那句话

876
00:29:08,000 --> 00:29:11,000
两点之间对最短的线路可能不是直的

877
00:29:11,000 --> 00:29:13,000
但这句话你怎么理解你自己去想

878
00:29:13,000 --> 00:29:14,000
对

879
00:29:14,000 --> 00:29:16,000
取决于你怎么定义的最短

880
00:29:16,000 --> 00:29:19,000
可能最省时间而已

881
00:29:19,000 --> 00:29:20,000
对

882
00:29:20,000 --> 00:29:22,000
这就好像一个 GPS 导航员一回问你

883
00:29:22,000 --> 00:29:25,000
你是要最省时间的还是要最短的线路

884
00:29:25,000 --> 00:29:26,000
刚刚学开车的时候

885
00:29:26,000 --> 00:29:28,000
我想说这两者难道不一样吗

886
00:29:29,000 --> 00:29:30,000
后来才明白真的不一样

887
00:29:33,000 --> 00:29:37,000
而且我觉得对很多程序员也好

888
00:29:37,000 --> 00:29:38,000
他的可能

889
00:29:39,000 --> 00:29:41,000
很多人的职业规划是说要在几年

890
00:29:41,000 --> 00:29:43,000
三五年十年之后做成一个

891
00:29:43,000 --> 00:29:47,000
所谓的技术岗位的管理者这么一个

892
00:29:47,000 --> 00:29:47,000
对

893
00:29:48,000 --> 00:29:50,000
这个时候其实你会发现你一旦走向

894
00:29:50,000 --> 00:29:51,000
所谓的管理岗位

895
00:29:51,000 --> 00:29:53,000
其实你要写代码的时候就不多了

896
00:29:53,000 --> 00:29:56,000
这反而是考验你对人的理解

897
00:29:56,000 --> 00:29:59,000
对人性的思考的地方

898
00:29:59,000 --> 00:30:04,000
会比你逻辑的地方多了多的时候

899
00:30:04,000 --> 00:30:04,000
所以

900
00:30:06,000 --> 00:30:07,000
你如果处理不好

901
00:30:07,000 --> 00:30:10,000
你和你亲密的人的关系

902
00:30:10,000 --> 00:30:13,000
估计你走管理岗位也会挺郁闷的

903
00:30:13,000 --> 00:30:13,000
对

904
00:30:13,000 --> 00:30:16,000
你会发现自己此前一直努力压抑的情商

905
00:30:16,000 --> 00:30:18,000
忽然变得无比重要了

906
00:30:19,000 --> 00:30:23,000
觉得自己就是一个白痴一样在那里

907
00:30:23,000 --> 00:30:23,000
对

908
00:30:24,000 --> 00:30:26,000
当然说到最后这个事情

909
00:30:26,000 --> 00:30:28,000
我们可以反正你上次

910
00:30:29,000 --> 00:30:30,000
在吐槽了

911
00:30:30,000 --> 00:30:32,000
我也来吐槽一下

912
00:30:32,000 --> 00:30:33,000
就是反正我找的朋友

913
00:30:33,000 --> 00:30:35,000
是我在我成为程序员之前的事了

914
00:30:36,000 --> 00:30:37,000
后面怎么着我也管不着了

915
00:30:38,000 --> 00:30:40,000
治国国的炫耀

916
00:30:40,000 --> 00:30:43,000
好吧

917
00:30:43,000 --> 00:30:44,000
OK

918
00:30:44,000 --> 00:30:45,000
我们讲

919
00:30:45,000 --> 00:30:47,000
那个下一条的听众反馈

920
00:30:47,000 --> 00:30:49,000
这是一封来自一位叫

921
00:30:50,000 --> 00:30:52,000
Flihly

922
00:30:52,000 --> 00:30:53,000
徐

923
00:30:53,000 --> 00:30:54,000
应该是徐

924
00:30:54,000 --> 00:30:54,000
对

925
00:30:54,000 --> 00:30:55,000
就是叫这个是

926
00:30:55,000 --> 00:30:56,000
维砣马拼

927
00:30:56,000 --> 00:30:57,000
对

928
00:30:58,000 --> 00:30:58,000
他说

929
00:30:59,000 --> 00:31:02,000
我不知道是不是 Podcast 客户端有问题

930
00:31:02,000 --> 00:31:05,000
或者是你们的 Podcast 发布服务器有问题

931
00:31:05,000 --> 00:31:06,000
总之有一段时间

932
00:31:06,000 --> 00:31:08,000
当我下载内核恐慌

933
00:31:08,000 --> 00:31:09,000
并打开来收听的时候

934
00:31:09,000 --> 00:31:12,000
会传出一个很好听很温柔的女生说

935
00:31:12,000 --> 00:31:13,000
大家好

936
00:31:13,000 --> 00:31:15,000
欢迎收听游戏通信地 XX 7

937
00:31:15,000 --> 00:31:19,000
我并不知道 IPN 还有另外一档叫做游行通信的节目

938
00:31:19,000 --> 00:31:21,000
我多次以为是两位主播受不了之前

939
00:31:21,000 --> 00:31:23,000
许多没有主题

940
00:31:23,000 --> 00:31:26,000
重心重点和深度的 softcore 讨论

941
00:31:26,000 --> 00:31:28,000
终于找来了哪一位美女大牛

942
00:31:28,000 --> 00:31:31,000
进行一个高级话题的讨论

943
00:31:31,000 --> 00:31:33,000
但是后来我才意识到原来是下载错了节目

944
00:31:34,000 --> 00:31:37,000
再后来当我看到录音的时间短于一个小时的时候

945
00:31:37,000 --> 00:31:38,000
我就会本能的以为

946
00:31:38,000 --> 00:31:39,000
Podcast 又出问题了

947
00:31:39,000 --> 00:31:41,000
然后删除重新下载

948
00:31:41,000 --> 00:31:43,000
这个事情在 ID 功能里面

949
00:31:43,000 --> 00:31:45,000
其实我有一次已经提到过了

950
00:31:46,000 --> 00:31:47,000
这是一个 bug

951
00:31:47,000 --> 00:31:48,000
Not a feature

952
00:31:49,000 --> 00:31:51,000
这是我们的 Podcast 发布服务器问题

953
00:31:51,000 --> 00:31:52,000
或者是

954
00:31:52,000 --> 00:31:54,000
对 但是这个 bug 的成因

955
00:31:54,000 --> 00:31:55,000
我到目前为止都没有找到

956
00:31:55,000 --> 00:31:57,000
因为我没有办法重现它

957
00:31:57,000 --> 00:32:00,000
我们应该在这里发动广大的程序员

958
00:32:00,000 --> 00:32:02,000
听众帮我们测试一下

959
00:32:02,000 --> 00:32:03,000
如果你遇到这个场景

960
00:32:04,000 --> 00:32:05,000
请千万去

961
00:32:05,000 --> 00:32:07,000
Somehow someway traceback 一下

962
00:32:07,000 --> 00:32:09,000
这个网址是怎么来的

963
00:32:09,000 --> 00:32:11,000
它经过了哪些路由

964
00:32:11,000 --> 00:32:13,000
它是到底是怎么一回事

965
00:32:14,000 --> 00:32:18,000
因为我现在想了几个可能出现问题的地方

966
00:32:18,000 --> 00:32:22,000
一个是我们自己的 IPM 的 CMS 有问题

967
00:32:22,000 --> 00:32:23,000
对 但是我

968
00:32:24,000 --> 00:32:25,000
待会我做了很多测试

969
00:32:25,000 --> 00:32:27,000
这个是今天我们的后面的主题

970
00:32:27,000 --> 00:32:28,000
一会再说

971
00:32:28,000 --> 00:32:29,000
我做了很多测试

972
00:32:30,000 --> 00:32:32,000
就是我完全没办法重现这件事情

973
00:32:32,000 --> 00:32:34,000
然后我又想到说

974
00:32:34,000 --> 00:32:36,000
那是不是所谓运营商的劫持

975
00:32:36,000 --> 00:32:40,000
但现在看来又不是一个非常确定的东西

976
00:32:40,000 --> 00:32:42,000
因为有不同的人在不同的网络环境下

977
00:32:42,000 --> 00:32:43,000
不同运营商

978
00:32:43,000 --> 00:32:45,000
他都遇到类似的问题

979
00:32:45,000 --> 00:32:47,000
而且这个事情似乎是一个

980
00:32:48,000 --> 00:32:50,000
怎么讲 就难以预测规律的东西

981
00:32:50,000 --> 00:32:52,000
我不知道到底是为什么

982
00:32:52,000 --> 00:32:53,000
然后之前又考虑说

983
00:32:53,000 --> 00:32:55,000
是不是因为强的问题

984
00:32:55,000 --> 00:32:56,000
因为我们的服务器在国外

985
00:32:57,000 --> 00:32:59,000
但是他来找一些朋友测试之后

986
00:32:59,000 --> 00:33:01,000
也没有得出一个确定结论

987
00:33:01,000 --> 00:33:02,000
所以到目前为止这是一个叫什么

988
00:33:02,000 --> 00:33:03,000
phantom bug

989
00:33:03,000 --> 00:33:04,000
对

990
00:33:05,000 --> 00:33:06,000
蝇虫

991
00:33:07,000 --> 00:33:10,000
就是他一会出现 一会不出现

992
00:33:10,000 --> 00:33:11,000
你也不知道他什么时候出现

993
00:33:11,000 --> 00:33:13,000
以及他在什么情况下会出现

994
00:33:14,000 --> 00:33:15,000
所以我也很郁闷

995
00:33:15,000 --> 00:33:16,000
OK

996
00:33:16,000 --> 00:33:17,000
这是一个声明

997
00:33:17,000 --> 00:33:19,000
大家如果有能够帮助我们

998
00:33:20,000 --> 00:33:23,000
除下虫 万分感谢

999
00:33:24,000 --> 00:33:24,000
然后接着念

1000
00:33:26,000 --> 00:33:27,000
Felili 的来信

1001
00:33:27,000 --> 00:33:30,000
他说 而这次我重新下载了三次

1002
00:33:30,000 --> 00:33:33,000
发现节目的长度依然只有 59 分钟

1003
00:33:33,000 --> 00:33:35,000
我发现原来这一次没有下错

1004
00:33:35,000 --> 00:33:36,000
节目真的只有 59 分钟

1005
00:33:37,000 --> 00:33:40,000
所以少了那么多内容和水分

1006
00:33:40,000 --> 00:33:41,000
是因为少了一个人吗

1007
00:33:41,000 --> 00:33:42,000
对呀 正常

1008
00:33:42,000 --> 00:33:43,000
我们两个人一人加一碗水

1009
00:33:43,000 --> 00:33:44,000
就是两个小时

1010
00:33:44,000 --> 00:33:46,000
如果只有人打个对折 差不多

1011
00:33:47,000 --> 00:33:48,000
OK

1012
00:33:50,000 --> 00:33:51,000
他说以上只是一个玩笑

1013
00:33:52,000 --> 00:33:53,000
接着说

1014
00:33:53,000 --> 00:33:55,000
关于机械键盘的手感是玄学的观点

1015
00:33:55,000 --> 00:33:57,000
感觉非常扯淡

1016
00:33:57,000 --> 00:33:58,000
我用过各种键盘

1017
00:33:59,000 --> 00:34:01,000
我长时间使用过红轴和黑轴

1018
00:34:01,000 --> 00:34:02,000
薄膜键盘也用

1019
00:34:03,000 --> 00:34:05,000
而现在主要使用的是

1020
00:34:05,000 --> 00:34:08,000
Realforce 的静电容键盘

1021
00:34:08,000 --> 00:34:09,000
在我身边

1022
00:34:09,000 --> 00:34:11,000
喜欢薄膜键盘的人也不少

1023
00:34:11,000 --> 00:34:13,000
他们不喜欢机械键盘的手感

1024
00:34:13,000 --> 00:34:15,000
但是对于薄膜键盘的不好

1025
00:34:15,000 --> 00:34:16,000
他们非常清楚

1026
00:34:16,000 --> 00:34:18,000
就是在薄膜键盘老化的时候

1027
00:34:18,000 --> 00:34:19,000
按键无法回弹

1028
00:34:20,000 --> 00:34:21,000
或者回弹缓慢

1029
00:34:21,000 --> 00:34:23,000
而这就是让人们对薄膜键盘

1030
00:34:23,000 --> 00:34:24,000
手感感觉不好的原因

1031
00:34:25,000 --> 00:34:26,000
真的是这样吗

1032
00:34:26,000 --> 00:34:27,000
我不太清楚

1033
00:34:27,000 --> 00:34:29,000
应该是没错吧

1034
00:34:29,000 --> 00:34:30,000
OK

1035
00:34:30,000 --> 00:34:31,000
接着念

1036
00:34:31,000 --> 00:34:33,000
我们平时所说的薄膜键盘

1037
00:34:33,000 --> 00:34:35,000
是依靠底部的碗状硅胶

1038
00:34:35,000 --> 00:34:36,000
进行回弹的

1039
00:34:37,000 --> 00:34:38,000
在一些键盘中

1040
00:34:38,000 --> 00:34:40,000
还会辅助利用到一些机械结构

1041
00:34:40,000 --> 00:34:42,000
比如最知名的笔记本电脑

1042
00:34:42,000 --> 00:34:44,000
使用的 X 结构

1043
00:34:44,000 --> 00:34:45,000
就是叫做 Scissors Switch

1044
00:34:45,000 --> 00:34:45,000
对吧

1045
00:34:45,000 --> 00:34:46,000
对

1046
00:34:46,000 --> 00:34:47,000
剪刀脚

1047
00:34:47,000 --> 00:34:47,000
对

1048
00:34:47,000 --> 00:34:49,000
但是硅胶碗的寿命

1049
00:34:49,000 --> 00:34:51,000
根据键盘质量

1050
00:34:51,000 --> 00:34:52,000
在几十万次到百万次不得

1051
00:34:53,000 --> 00:34:55,000
不同键盘的使用寿命也不太一样

1052
00:34:55,000 --> 00:34:56,000
但是必须承认

1053
00:34:56,000 --> 00:34:59,000
新买回来的薄膜键盘手感是非常好的

1054
00:34:59,000 --> 00:35:00,000
之所以不选择它

1055
00:35:00,000 --> 00:35:02,000
就是因为你很可能在几个月之后

1056
00:35:03,000 --> 00:35:04,000
这些按键就不能回弹

1057
00:35:04,000 --> 00:35:05,000
甚至回弹缓慢了

1058
00:35:06,000 --> 00:35:08,000
这个时候的手感就很糟糕

1059
00:35:08,000 --> 00:35:10,000
这样缓慢的回弹

1060
00:35:10,000 --> 00:35:12,000
是我们的手指

1061
00:35:12,000 --> 00:35:13,000
可能需要自己费力抬起来

1062
00:35:13,000 --> 00:35:17,000
而不是放松之后被按键推上来

1063
00:35:17,000 --> 00:35:22,000
这种稀微的变化会被手指敏感的察觉到

1064
00:35:22,000 --> 00:35:26,000
而抬起手指的力气也会比按下按键更费力

1065
00:35:27,000 --> 00:35:29,000
而在按键无法彻底回弹的时候

1066
00:35:30,000 --> 00:35:32,000
按下按键的心情会变得烦躁不安

1067
00:35:32,000 --> 00:35:34,000
其实这也说明了为什么这么多人喜欢

1068
00:35:34,000 --> 00:35:37,000
RealForce 和 HHKV 这类不是键盘

1069
00:35:37,000 --> 00:35:40,000
不是机械键盘的高级键盘

1070
00:35:40,000 --> 00:35:45,000
因为静电容键盘的原理和手感

1071
00:35:46,000 --> 00:35:48,000
跟普通的薄膜键盘太相似了

1072
00:35:49,000 --> 00:35:51,000
静电容键盘内部是一个橡胶瓦

1073
00:35:51,000 --> 00:35:53,000
里面是一个碗型的弹簧

1074
00:35:54,000 --> 00:35:57,000
所使用的橡胶的寿命要高于普通的硅胶

1075
00:35:57,000 --> 00:36:02,000
并且里面的碗型弹簧不仅是用来改变电容出发按键

1076
00:36:02,000 --> 00:36:03,000
还可以帮助回弹

1077
00:36:03,000 --> 00:36:07,000
所以静电容键盘的感觉像是回弹有力

1078
00:36:07,000 --> 00:36:09,000
并且永远是新买回来状态的薄膜键盘

1079
00:36:11,000 --> 00:36:14,000
这其实跟我刚才讲的 HHKV 的一段有点关系

1080
00:36:14,000 --> 00:36:17,000
因为我的感觉就是我第一次

1081
00:36:17,000 --> 00:36:20,000
因为之前我们讨论过键盘那一期的 HHKV

1082
00:36:20,000 --> 00:36:20,000
尽量键盘

1083
00:36:20,000 --> 00:36:21,000
但是我自己从来没有用过

1084
00:36:22,000 --> 00:36:24,000
就直到上次 Lawrence 把他那块机构

1085
00:36:24,000 --> 00:36:26,000
我当时第一次拿到的时候

1086
00:36:26,000 --> 00:36:27,000
感觉还是蛮特别的

1087
00:36:27,000 --> 00:36:28,000
这个手感

1088
00:36:28,000 --> 00:36:33,000
因为它并不像我预期的那种机械键盘当中很阴朗的感觉

1089
00:36:33,000 --> 00:36:33,000
而是一种比较

1090
00:36:33,000 --> 00:36:34,000
OK 你刚才念对了

1091
00:36:34,000 --> 00:36:38,000
它原文的确是 RealforceHKV 这类

1092
00:36:38,000 --> 00:36:39,000
不是机械键盘的关键

1093
00:36:41,000 --> 00:36:42,000
它漏写了机械两个字

1094
00:36:42,000 --> 00:36:45,000
但是你的结构应该是正确

1095
00:36:45,000 --> 00:36:46,000
对我理解是这么理解

1096
00:36:46,000 --> 00:36:49,000
所以其实这个我觉得就挺有意思

1097
00:36:49,000 --> 00:36:54,000
因为静电容的手感真的是很难形容

1098
00:36:54,000 --> 00:36:55,000
它说是薄膜键盘

1099
00:36:56,000 --> 00:36:57,000
我觉得也不太像

1100
00:36:57,000 --> 00:37:00,000
我没有用过任何一款薄膜键盘是这种感觉的

1101
00:37:01,000 --> 00:37:02,000
对没错

1102
00:37:02,000 --> 00:37:04,000
机器键盘你会有明显的那种

1103
00:37:04,000 --> 00:37:05,000
咔嚓的感觉

1104
00:37:05,000 --> 00:37:10,000
就是你会感觉到自己在按一个弹簧那样的东西

1105
00:37:10,000 --> 00:37:15,000
但是在静电容键盘里面这种感觉被淡化

1106
00:37:15,000 --> 00:37:17,000
你能感觉到自己没有在按一个薄膜

1107
00:37:17,000 --> 00:37:21,000
但按下去也肯定不是弹簧

1108
00:37:21,000 --> 00:37:23,000
对所以这件事情我觉得真的

1109
00:37:23,000 --> 00:37:26,000
像很多东西越来越多的实体物件一样

1110
00:37:26,000 --> 00:37:28,000
你光听描述是没有用的

1111
00:37:28,000 --> 00:37:30,000
除非你自己真的按上去那一天

1112
00:37:30,000 --> 00:37:33,000
或者说甚至说除非你要连续使用相当长一段时间

1113
00:37:33,000 --> 00:37:36,000
你才能感觉到这种细微的差别

1114
00:37:36,000 --> 00:37:37,000
给你的手感

1115
00:37:37,000 --> 00:37:39,000
给你的工作带来什么样的一种影响和变化

1116
00:37:40,000 --> 00:37:42,000
所以这里就不再多说了

1117
00:37:42,000 --> 00:37:43,000
大家有机会去摸一下

1118
00:37:44,000 --> 00:37:47,000
接着念几个它后面还有一些你一大段的反馈

1119
00:37:47,000 --> 00:37:51,000
对于这一期主题的编码

1120
00:37:51,000 --> 00:37:53,000
我觉得主播在答案周围转了一圈

1121
00:37:53,000 --> 00:37:56,000
甚至延伸扯到了指令集以及三进制

1122
00:37:56,000 --> 00:37:58,000
这些更无关的其他东西

1123
00:37:58,000 --> 00:38:01,000
但是始终就没有说到底什么是编码

1124
00:38:02,000 --> 00:38:02,000
主播已经提到

1125
00:38:02,000 --> 00:38:04,000
比如说我们能看到文字

1126
00:38:04,000 --> 00:38:06,000
我们能听到声音

1127
00:38:06,000 --> 00:38:08,000
比如说各位现在听到的 podcast

1128
00:38:08,000 --> 00:38:09,000
我们能看到图片

1129
00:38:09,000 --> 00:38:10,000
以及一些高雅的小电影

1130
00:38:11,000 --> 00:38:13,000
这些东西都不是零和一不是吗

1131
00:38:13,000 --> 00:38:16,000
如何用零和一表示这些东西就是编码

1132
00:38:16,000 --> 00:38:18,000
而用这些零和一或者说数字

1133
00:38:19,000 --> 00:38:22,000
或者说更准确地说是用整数表示文字

1134
00:38:22,000 --> 00:38:23,000
那就是文字编码

1135
00:38:23,000 --> 00:38:24,000
用来表示音乐

1136
00:38:24,000 --> 00:38:25,000
就是音乐的编码

1137
00:38:25,000 --> 00:38:27,000
比如 MP 3、WMA 之类的

1138
00:38:28,000 --> 00:38:32,000
为了让本来只能表示一二进制数的计算机

1139
00:38:32,000 --> 00:38:33,000
能够处理文本

1140
00:38:33,000 --> 00:38:36,000
就必须将文本变化为相应的数字

1141
00:38:36,000 --> 00:38:38,000
这种对应于文本的数值

1142
00:38:38,000 --> 00:38:39,000
就成文本编码

1143
00:38:39,000 --> 00:38:42,000
这段话是在松本信宏

1144
00:38:42,000 --> 00:38:43,000
这谁

1145
00:38:43,000 --> 00:38:46,000
松本信宏是一个日本的程序员

1146
00:38:46,000 --> 00:38:48,000
好像我记得他好像自学成才还是怎么着

1147
00:38:49,000 --> 00:38:49,000
写了这本书

1148
00:38:49,000 --> 00:38:50,000
对

1149
00:38:51,000 --> 00:38:54,000
这段话是在松本信宏

1150
00:38:54,000 --> 00:38:54,000
在他的书

1151
00:38:54,000 --> 00:38:57,000
松本信宏的程序世界 7.1.1

1152
00:38:57,000 --> 00:38:59,000
章节里面早期文字编码中

1153
00:39:00,000 --> 00:39:02,000
对于文字编码的描述

1154
00:39:02,000 --> 00:39:03,000
这大概算是一个非常简洁

1155
00:39:03,000 --> 00:39:05,000
而且易懂的描述

1156
00:39:05,000 --> 00:39:08,000
松本信宏就是 Mats

1157
00:39:09,000 --> 00:39:09,000
Ruby 那个作者

1158
00:39:09,000 --> 00:39:10,000
对

1159
00:39:11,000 --> 00:39:12,000
我一直没反应过来

1160
00:39:12,000 --> 00:39:13,000
我觉得看他名字特别眼熟

1161
00:39:13,000 --> 00:39:14,000
但我不确定到底是谁

1162
00:39:14,000 --> 00:39:16,000
我把它跟另外一个日本

1163
00:39:16,000 --> 00:39:18,000
所以他日本名字怎么念

1164
00:39:18,000 --> 00:39:19,000
Mats 是什么

1165
00:39:19,000 --> 00:39:22,000
Yokihiro Matsumoto

1166
00:39:23,000 --> 00:39:24,000
Matsumoto

1167
00:39:24,000 --> 00:39:25,000
Matsumoto

1168
00:39:25,000 --> 00:39:26,000
对

1169
00:39:26,000 --> 00:39:26,000
Katou

1170
00:39:28,000 --> 00:39:29,000
接下来你好

1171
00:39:29,000 --> 00:39:32,000
此外这本书中还介绍了一些很有历史

1172
00:39:33,000 --> 00:39:35,000
但是很奇葩的文字编码

1173
00:39:35,000 --> 00:39:40,000
如定义了半角片甲名的标准

1174
00:39:40,000 --> 00:39:42,000
JISX 0201

1175
00:39:42,000 --> 00:39:45,000
以及一种类似 ISO 8859 的方法实现

1176
00:39:45,000 --> 00:39:48,000
但是 ASCII 部分以

1177
00:39:49,000 --> 00:39:50,000
这叫什么来的

1178
00:39:50,000 --> 00:39:51,000
日元符号

1179
00:39:51,000 --> 00:39:52,000
或者是人民币符号

1180
00:39:52,000 --> 00:39:53,000
因为都是一个

1181
00:39:54,000 --> 00:39:56,000
就是那个阳少一横

1182
00:39:56,000 --> 00:39:57,000
替代了反斜杠

1183
00:39:57,000 --> 00:40:01,000
以上话线替代了波浪号

1184
00:40:02,000 --> 00:40:03,000
阳少一横

1185
00:40:03,000 --> 00:40:04,000
他有词

1186
00:40:04,000 --> 00:40:04,000
不对吗

1187
00:40:05,000 --> 00:40:08,000
他其实是日元的那个印

1188
00:40:08,000 --> 00:40:10,000
印上面打了两横

1189
00:40:11,000 --> 00:40:12,000
人民币也是用他

1190
00:40:12,000 --> 00:40:12,000
对吧

1191
00:40:12,000 --> 00:40:13,000
人民币是直接

1192
00:40:13,000 --> 00:40:13,000
对

1193
00:40:13,000 --> 00:40:14,000
我一直好奇为什么

1194
00:40:14,000 --> 00:40:18,000
这个反日分子从来没有拿这个符号开到的

1195
00:40:20,000 --> 00:40:23,000
这个符号是人民币举版权搬迁日元的

1196
00:40:23,000 --> 00:40:25,000
你看这卤布都有自己的符号

1197
00:40:26,000 --> 00:40:27,000
说明我们应该用阳

1198
00:40:27,000 --> 00:40:29,000
他们比他们还多一横

1199
00:40:29,000 --> 00:40:29,000
对

1200
00:40:29,000 --> 00:40:29,000
没错

1201
00:40:30,000 --> 00:40:31,000
登时高级

1202
00:40:32,000 --> 00:40:34,000
下次我们不打那个阴

1203
00:40:34,000 --> 00:40:35,000
我们打阳

1204
00:40:35,000 --> 00:40:36,000
对

1205
00:40:37,000 --> 00:40:40,000
另一个编码则是奇葩的 ISO-2022

1206
00:40:41,000 --> 00:40:44,000
这种单身于 1993 年的神奇编码方式

1207
00:40:44,000 --> 00:40:48,000
使用类似于编程语言中引号或者注释的方法

1208
00:40:48,000 --> 00:40:50,000
通过一个特殊的引号

1209
00:40:50,000 --> 00:40:52,000
将 ASCII 编码和其他语言的编码

1210
00:40:52,000 --> 00:40:58,000
如汉语的 GB 2312 和日语的 JSX 0208 引起来

1211
00:40:58,000 --> 00:41:01,000
也就是在 ASCII 编码的文本当中

1212
00:41:01,000 --> 00:41:03,000
当遇到三个特殊字符

1213
00:41:04,000 --> 00:41:04,000
ESCAPE

1214
00:41:04,000 --> 00:41:06,000
DOLLSIGN 和 B

1215
00:41:06,000 --> 00:41:10,000
则后面的内容开始切换到 JSX 0208 编码

1216
00:41:11,000 --> 00:41:13,000
当遇到另外三个特殊字符 ESCAPE

1217
00:41:14,000 --> 00:41:15,000
开阔号 B

1218
00:41:16,000 --> 00:41:18,000
又切换回 ASCII 编码

1219
00:41:18,000 --> 00:41:20,000
在我看到这本书的时候

1220
00:41:20,000 --> 00:41:23,000
我不仅感叹原来人类还设计过如此愚蠢的编码

1221
00:41:23,000 --> 00:41:27,000
相比起来 UTF 系列真是不知道搞到哪里去了

1222
00:41:28,000 --> 00:41:29,000
是没错

1223
00:41:30,000 --> 00:41:34,000
所以他都不叫就最后那个调整 ISO-2022

1224
00:41:34,000 --> 00:41:37,000
这个都已经不算是一个编码方式

1225
00:41:37,000 --> 00:41:38,000
它就是一个怎么讲

1226
00:41:38,000 --> 00:41:39,000
ESCAPE 方式

1227
00:41:39,000 --> 00:41:45,000
规定一组规则告诉你在这个时候可以插入其他编码的东西

1228
00:41:46,000 --> 00:41:48,000
这感觉好像在写 XML 对吧

1229
00:41:48,000 --> 00:41:48,000
对

1230
00:41:48,000 --> 00:41:50,000
开阔号

1231
00:41:50,000 --> 00:41:52,000
对它是一种原编码

1232
00:41:52,000 --> 00:41:53,000
关于编码

1233
00:41:53,000 --> 00:41:53,000
对

1234
00:41:54,000 --> 00:41:56,000
不过其实这个方式在 UTF 里面也实现过

1235
00:41:56,000 --> 00:41:57,000
上次我记得你也聊到

1236
00:41:57,000 --> 00:41:58,000
那个叫做

1237
00:41:59,000 --> 00:42:00,000
这个叫什么 Pair 的

1238
00:42:00,000 --> 00:42:01,000
Seregay Pair

1239
00:42:03,000 --> 00:42:04,000
呃 What

1240
00:42:05,000 --> 00:42:06,000
你们听到我还是

1241
00:42:06,000 --> 00:42:07,000
我没有提到 Seregay Pair

1242
00:42:07,000 --> 00:42:09,000
就是在 UTF 16 这个编码

1243
00:42:09,000 --> 00:42:11,000
因为 UTF 16 是固定两个字节的

1244
00:42:11,000 --> 00:42:12,000
对

1245
00:42:12,000 --> 00:42:13,000
但是 UTF 的 unicode 那个

1246
00:42:13,000 --> 00:42:17,000
那个平面那个总的字符数是远远超过 16 个字节可以容纳的

1247
00:42:18,000 --> 00:42:22,000
所以怎么在 16 个字节这种定常的编码里面装

1248
00:42:23,000 --> 00:42:25,000
超过 16 个字节那些东西怎么办

1249
00:42:25,000 --> 00:42:26,000
对我没有提到这个

1250
00:42:26,000 --> 00:42:27,000
你没听到

1251
00:42:27,000 --> 00:42:28,000
那我可以先稍微解释一下

1252
00:42:28,000 --> 00:42:32,000
这个我之前做研究的时候写过这么一段小笔记

1253
00:42:33,000 --> 00:42:33,000
就是说

1254
00:42:33,000 --> 00:42:38,000
我们必然有一个办法要用多于 16 个字节

1255
00:42:38,000 --> 00:42:40,000
就两个 byte 的方式来编码

1256
00:42:40,000 --> 00:42:41,000
其他东西

1257
00:42:41,000 --> 00:42:44,000
所以它定义了一个特殊的一个

1258
00:42:44,000 --> 00:42:47,000
一个就有一个范围的字节

1259
00:42:48,000 --> 00:42:49,000
只要那个字节开始的时候

1260
00:42:49,000 --> 00:42:50,000
它会进入另外一种

1261
00:42:50,000 --> 00:42:52,000
就是非定常 16

1262
00:42:52,000 --> 00:42:53,000
16 不是 16 字节

1263
00:42:53,000 --> 00:42:54,000
16 个

1264
00:42:55,000 --> 00:42:57,000
bit 两个字节的那种模式

1265
00:42:57,000 --> 00:42:57,000
刚才说错了

1266
00:42:57,000 --> 00:42:58,000
不是 16 个字节

1267
00:42:58,000 --> 00:42:59,000
那也太长了

1268
00:42:59,000 --> 00:43:00,000
16 个位

1269
00:43:00,000 --> 00:43:01,000
就是两个字节的这种方式

1270
00:43:01,000 --> 00:43:06,000
就有一些特殊组合的两个 byte

1271
00:43:07,000 --> 00:43:08,000
它会定义说从这里开始

1272
00:43:08,000 --> 00:43:10,000
我们进入另外一种模式

1273
00:43:10,000 --> 00:43:12,000
然后另外还有一些特殊的两个 byte

1274
00:43:12,000 --> 00:43:14,000
它会说从这里开始

1275
00:43:14,000 --> 00:43:15,000
我们结束那个特殊模式

1276
00:43:15,000 --> 00:43:17,000
回到正常的 UTF 16 的编码

1277
00:43:17,000 --> 00:43:20,000
这种特殊的 byte

1278
00:43:20,000 --> 00:43:21,000
叫做 serigate pair

1279
00:43:21,000 --> 00:43:24,000
叫做什么代理组和代理对

1280
00:43:25,000 --> 00:43:28,000
其实跟 ISO 的 202 的方式差不多了

1281
00:43:28,000 --> 00:43:30,000
但你不得不说

1282
00:43:30,000 --> 00:43:31,000
在当时的物理史

1283
00:43:31,000 --> 00:43:33,000
就是 UTF 16 应该是在 90 年代

1284
00:43:33,000 --> 00:43:34,000
中后期实现的

1285
00:43:35,000 --> 00:43:35,000
开发出来

1286
00:43:36,000 --> 00:43:38,000
在当时的历史情况下

1287
00:43:38,000 --> 00:43:41,000
只用两个字节来处理

1288
00:43:42,000 --> 00:43:44,000
可能应对绝大部分的所谓的

1289
00:43:44,000 --> 00:43:45,000
主流的文本

1290
00:43:45,000 --> 00:43:47,000
因为在那个时代能够用到计算机

1291
00:43:47,000 --> 00:43:48,000
进行文本处理的

1292
00:43:48,000 --> 00:43:50,000
也就是所谓一些发达国家

1293
00:43:50,000 --> 00:43:50,000
大国这种

1294
00:43:50,000 --> 00:43:51,000
像那些小国那种

1295
00:43:51,000 --> 00:43:53,000
非常不起眼的文字

1296
00:43:53,000 --> 00:43:55,000
就已经无暇顾及也无所谓

1297
00:43:56,000 --> 00:43:57,000
我觉得那个时候还是主要

1298
00:43:57,000 --> 00:43:59,000
为了应对东亚语

1299
00:44:00,000 --> 00:44:01,000
那个时候东亚市场

1300
00:44:01,000 --> 00:44:04,000
对东亚市场战心非常快

1301
00:44:04,000 --> 00:44:07,000
然后微软为了切入这个吃啥

1302
00:44:07,000 --> 00:44:09,000
就不得不采用了这么一个

1303
00:44:10,000 --> 00:44:10,000
对

1304
00:44:10,000 --> 00:44:12,000
而且这也是一个比较临时的饭

1305
00:44:12,000 --> 00:44:14,000
但是那个时候做出的技术演奏

1306
00:44:14,000 --> 00:44:15,000
对我们今天来说

1307
00:44:15,000 --> 00:44:16,000
其实影响非常深

1308
00:44:16,000 --> 00:44:17,000
影响是非常深的

1309
00:44:17,000 --> 00:44:19,000
对 UTF 如此愚蠢的东西

1310
00:44:19,000 --> 00:44:20,000
真的

1311
00:44:21,000 --> 00:44:23,000
这是 Windows 上又一个痛点

1312
00:44:23,000 --> 00:44:24,000
并不得不展开

1313
00:44:25,000 --> 00:44:26,000
没错

1314
00:44:26,000 --> 00:44:27,000
因为当时在我的

1315
00:44:27,000 --> 00:44:29,000
我的那个笔记里面有写在

1316
00:44:29,000 --> 00:44:30,000
至少是在

1317
00:44:31,000 --> 00:44:31,000
我想想

1318
00:44:31,000 --> 00:44:33,000
应该是在 Windows NT 的内核

1319
00:44:33,000 --> 00:44:34,000
是默认是这个

1320
00:44:35,000 --> 00:44:35,000
也不是这个

1321
00:44:35,000 --> 00:44:36,000
不是 UTF 16

1322
00:44:36,000 --> 00:44:37,000
它是叫 UCSR

1323
00:44:38,000 --> 00:44:39,000
这么一个方式来的

1324
00:44:40,000 --> 00:44:41,000
就是 UTF 16 其实是 UCSR

1325
00:44:41,000 --> 00:44:42,000
就是刚才那种

1326
00:44:42,000 --> 00:44:44,000
就是所有东西都是两个字节的

1327
00:44:44,000 --> 00:44:45,000
没有额外的情况

1328
00:44:45,000 --> 00:44:48,000
UTF 16 是这个 UCSR

1329
00:44:48,000 --> 00:44:50,000
再加了刚才我讲的那个

1330
00:44:50,000 --> 00:44:52,000
那个叫做 server 给 pair 的方法

1331
00:44:52,000 --> 00:44:53,000
去编码超过那种

1332
00:44:53,000 --> 00:44:55,000
就是超过那个

1333
00:44:55,000 --> 00:44:57,000
就是 OXF

1334
00:44:57,000 --> 00:44:58,000
4 个 F 这么一个段的

1335
00:44:58,000 --> 00:45:00,000
更高的点位的那些字

1336
00:45:01,000 --> 00:45:01,000
对吧

1337
00:45:01,000 --> 00:45:03,000
但其实就是 UCSR 这种方式

1338
00:45:03,000 --> 00:45:04,000
在很多这种

1339
00:45:04,000 --> 00:45:06,000
变超系统里面也好

1340
00:45:06,000 --> 00:45:08,000
不过那个 NT 的

1341
00:45:08,000 --> 00:45:10,000
我记得 NT 的默认的

1342
00:45:11,000 --> 00:45:12,000
文件路径

1343
00:45:12,000 --> 00:45:14,000
是用 UCSR 来实现的

1344
00:45:14,000 --> 00:45:17,000
然后像那个 Java 是一点几

1345
00:45:17,000 --> 00:45:20,000
到 1.5 之前

1346
00:45:20,000 --> 00:45:21,000
1.6 之前都是用的

1347
00:45:21,000 --> 00:45:22,000
这个 UCSR 的方法

1348
00:45:22,000 --> 00:45:25,000
就是到 Java 1.6

1349
00:45:26,000 --> 00:45:28,000
还是 Java 5

1350
00:45:28,000 --> 00:45:29,000
Java 1.2

1351
00:45:29,000 --> 00:45:31,000
一直到 1.6 之前应该都是这样

1352
00:45:31,000 --> 00:45:33,000
1.7 后面我不知道怎么办

1353
00:45:33,000 --> 00:45:33,000
反正

1354
00:45:33,000 --> 00:45:34,000
他在换 UTF 16

1355
00:45:35,000 --> 00:45:36,000
他就可以用 server 给 pair 的方法来实现

1356
00:45:36,000 --> 00:45:37,000
对

1357
00:45:37,000 --> 00:45:38,000
然后 Python 也是

1358
00:45:38,000 --> 00:45:39,000
Python 2

1359
00:45:40,000 --> 00:45:41,000
2.不管什么

1360
00:45:41,000 --> 00:45:44,000
全部都是用的 UCSR

1361
00:45:44,000 --> 00:45:45,000
或者 UCS 4 的方法来表达

1362
00:45:45,000 --> 00:45:46,000
unicode

1363
00:45:46,000 --> 00:45:48,000
就是他连 UTF 16 都没有

1364
00:45:49,000 --> 00:45:49,000
对

1365
00:45:50,000 --> 00:45:52,000
所以其实你会看到这种

1366
00:45:52,000 --> 00:45:53,000
编码的选择

1367
00:45:53,000 --> 00:45:55,000
对后视的影响还是非常深远的

1368
00:45:55,000 --> 00:45:57,000
当然我们日常可能觉得

1369
00:45:57,000 --> 00:45:58,000
我怎么没有遇到

1370
00:45:58,000 --> 00:45:59,000
那是因为你出的文本

1371
00:45:59,000 --> 00:46:02,000
还不够不足以

1372
00:46:02,000 --> 00:46:07,000
就是因为你没有用过文件路径相关的 API

1373
00:46:07,000 --> 00:46:08,000
每个这些 API

1374
00:46:08,000 --> 00:46:09,000
每个都有两个版本

1375
00:46:09,000 --> 00:46:11,000
一个是 A 版本

1376
00:46:11,000 --> 00:46:12,000
一个是 W 版本

1377
00:46:12,000 --> 00:46:14,000
A 代表说他可以处理 ASCII 一遍

1378
00:46:15,000 --> 00:46:18,000
W 版本说他可以处理这种所谓宽字节的

1379
00:46:18,000 --> 00:46:20,000
Wide Cactus

1380
00:46:20,000 --> 00:46:22,000
这是一个 Giant

1381
00:46:23,000 --> 00:46:25,000
但是有什么办法

1382
00:46:25,000 --> 00:46:26,000
谁叫人家商业上成功

1383
00:46:28,000 --> 00:46:29,000
就是 legacy

1384
00:46:29,000 --> 00:46:33,000
所以其实我们要往这种 Future Compatible 方法的话

1385
00:46:33,000 --> 00:46:35,000
大家还是尽量使用 UTF 8 这种

1386
00:46:36,000 --> 00:46:38,000
比较通用的方式来实现表

1387
00:46:38,000 --> 00:46:40,000
虽然说可能 UTF 8

1388
00:46:40,000 --> 00:46:41,000
我觉得可能很多人反对他的

1389
00:46:41,000 --> 00:46:42,000
这是一个效率的原因

1390
00:46:42,000 --> 00:46:43,000
他不是定长的

1391
00:46:43,000 --> 00:46:43,000
对吧

1392
00:46:43,000 --> 00:46:45,000
他要是一个变长的

1393
00:46:45,000 --> 00:46:47,000
处理起来效率可能会比较低

1394
00:46:47,000 --> 00:46:51,000
但我觉得在现代的这种计算机的处理器的形态

1395
00:46:51,000 --> 00:46:52,000
这点完全不是问题

1396
00:46:52,000 --> 00:46:55,000
而且还有一个发源就是 UTF 8

1397
00:46:55,000 --> 00:46:56,000
因为它的编码方式的原因

1398
00:46:56,000 --> 00:47:01,000
它的编码非 ASCII 的时候的效率不高

1399
00:47:01,000 --> 00:47:03,000
特别是编码东亚文字的时候可能效率要低

1400
00:47:03,000 --> 00:47:05,000
经常需要三到四个字节

1401
00:47:05,000 --> 00:47:05,000
没错

1402
00:47:05,000 --> 00:47:07,000
就越冷批的那些字节

1403
00:47:07,000 --> 00:47:10,000
那些字符可能需要的字节数越多

1404
00:47:10,000 --> 00:47:11,000
但是其实

1405
00:47:12,000 --> 00:47:13,000
我们现在不是有压缩吗

1406
00:47:13,000 --> 00:47:13,000
对吧

1407
00:47:13,000 --> 00:47:14,000
这种东西

1408
00:47:14,000 --> 00:47:16,000
我觉得问题并不大

1409
00:47:16,000 --> 00:47:19,000
而且就是用 GZIP 流失压缩的话

1410
00:47:19,000 --> 00:47:22,000
你在一台正常的现代的机箱

1411
00:47:22,000 --> 00:47:24,000
根本感觉不到这种性能的差异

1412
00:47:24,000 --> 00:47:25,000
所以我觉得

1413
00:47:25,000 --> 00:47:28,000
还是为了处理方便期间

1414
00:47:28,000 --> 00:47:30,000
尽量采用这种方式实现

1415
00:47:30,000 --> 00:47:33,000
但是我不知道你了不了解这个情况

1416
00:47:33,000 --> 00:47:35,000
国内很多这种网站还是

1417
00:47:36,000 --> 00:47:37,000
直到现在都是 GB 的

1418
00:47:40,000 --> 00:47:41,000
好吧

1419
00:47:41,000 --> 00:47:42,000
我们叫到下个环节

1420
00:47:42,000 --> 00:47:45,000
这周有什么小新闻吗

1421
00:47:45,000 --> 00:47:45,000
不是这周

1422
00:47:45,000 --> 00:47:47,000
这一个月有什么小新闻

1423
00:47:47,000 --> 00:47:51,000
真的和 Rail 已经扩别四周了

1424
00:47:52,000 --> 00:47:54,000
两周一期的节目

1425
00:47:54,000 --> 00:47:55,000
如果 miss 掉一期就是一个月

1426
00:47:56,000 --> 00:47:56,000
对

1427
00:47:57,000 --> 00:47:58,000
再四周五周一下就是半年

1428
00:47:59,000 --> 00:48:00,000
没错

1429
00:48:02,000 --> 00:48:03,000
一期不见如隔半年

1430
00:48:07,000 --> 00:48:11,000
其实也没有什么太特别的新闻

1431
00:48:11,000 --> 00:48:12,000
然后我最近比较忙

1432
00:48:12,000 --> 00:48:12,000
没有怎么看

1433
00:48:12,000 --> 00:48:14,000
唯一值得提起的

1434
00:48:14,000 --> 00:48:15,000
或者说唯一

1435
00:48:15,000 --> 00:48:18,000
我知道你肯定会感兴趣的东西

1436
00:48:18,000 --> 00:48:22,000
就是前两天刚刚结束了 WWDC

1437
00:48:23,000 --> 00:48:24,000
还没有结束

1438
00:48:24,000 --> 00:48:26,000
现在还在进行中

1439
00:48:26,000 --> 00:48:26,000
Exactly

1440
00:48:26,000 --> 00:48:28,000
我只是想到

1441
00:48:28,000 --> 00:48:29,000
如果这一期节目上线的时候

1442
00:48:29,000 --> 00:48:30,000
也许

1443
00:48:31,000 --> 00:48:31,000
对

1444
00:48:31,000 --> 00:48:33,000
但我们在录制的时候

1445
00:48:33,000 --> 00:48:37,000
WC 其实才开到第三天

1446
00:48:38,000 --> 00:48:40,000
一下子暴露了录制的这期

1447
00:48:41,000 --> 00:48:41,000
没关系

1448
00:48:41,000 --> 00:48:44,000
这个又不是什么行业机密

1449
00:48:44,000 --> 00:48:44,000
是吧

1450
00:48:46,000 --> 00:48:48,000
所以其实现在你的表也拿到了

1451
00:48:48,000 --> 00:48:48,000
对吧

1452
00:48:49,000 --> 00:48:49,000
对

1453
00:48:50,000 --> 00:48:51,000
你买了一款什么表

1454
00:48:52,000 --> 00:48:55,000
女朋友给我买的 42 毫米的

1455
00:48:56,000 --> 00:48:58,000
是 sport 还是钢的

1456
00:48:58,000 --> 00:48:58,000
对

1457
00:48:59,000 --> 00:48:59,000
高档

1458
00:48:59,000 --> 00:49:01,000
然后什么带子

1459
00:49:02,000 --> 00:49:03,000
最普通的黑色带

1460
00:49:05,000 --> 00:49:07,000
是皮带那款

1461
00:49:08,000 --> 00:49:09,000
这不是皮带吧

1462
00:49:09,000 --> 00:49:09,000
硅胶的应该是

1463
00:49:11,000 --> 00:49:12,000
钢带是默认配硅胶的吗

1464
00:49:12,000 --> 00:49:13,000
钢的也是默认配硅胶

1465
00:49:13,000 --> 00:49:14,000
就是 sport

1466
00:49:14,000 --> 00:49:15,000
那个不叫硅胶

1467
00:49:15,000 --> 00:49:16,000
那个叫

1468
00:49:16,000 --> 00:49:17,000
想想想什么那个

1469
00:49:17,000 --> 00:49:19,000
floreastomer

1470
00:49:21,000 --> 00:49:22,000
终于想起他叫

1471
00:49:22,000 --> 00:49:23,000
他终于就在他念什么了

1472
00:49:25,000 --> 00:49:26,000
你觉得那个手感怎么样

1473
00:49:26,000 --> 00:49:27,000
那个带子

1474
00:49:28,000 --> 00:49:30,000
就还 OK 吧

1475
00:49:30,000 --> 00:49:31,000
还 OK

1476
00:49:31,000 --> 00:49:32,000
我也不知道

1477
00:49:32,000 --> 00:49:33,000
因为我从来不带表

1478
00:49:33,000 --> 00:49:34,000
你就能就

1479
00:49:34,000 --> 00:49:35,000
不是

1480
00:49:35,000 --> 00:49:37,000
实话说穷玩奢富玩表

1481
00:49:37,000 --> 00:49:39,000
我肯定是不是玩表那些

1482
00:49:40,000 --> 00:49:41,000
所以我也说不上来

1483
00:49:41,000 --> 00:49:43,000
而且我有一件很惨痛的事情

1484
00:49:43,000 --> 00:49:44,000
就是我在

1485
00:49:46,000 --> 00:49:48,000
初中的时候有一天看到那个

1486
00:49:49,000 --> 00:49:51,000
地摊上卖的

1487
00:49:51,000 --> 00:49:52,000
漂亮的塑料电子表

1488
00:49:52,000 --> 00:49:53,000
非常高兴

1489
00:49:54,000 --> 00:49:55,000
买了一块

1490
00:49:55,000 --> 00:49:56,000
然后从那个

1491
00:49:56,000 --> 00:49:58,000
那个塑料电子表的后盖

1492
00:49:58,000 --> 00:49:59,000
是镀镍里面

1493
00:50:00,000 --> 00:50:02,000
然后从那天开始

1494
00:50:02,000 --> 00:50:04,000
我对镍产生了过敏

1495
00:50:06,000 --> 00:50:07,000
真的有激素过敏

1496
00:50:07,000 --> 00:50:09,000
任何活泼金属带到我手上

1497
00:50:09,000 --> 00:50:11,000
都会立刻起爆

1498
00:50:13,000 --> 00:50:14,000
所以在

1499
00:50:14,000 --> 00:50:15,000
这是什么原理

1500
00:50:16,000 --> 00:50:18,000
我就是对活泼金属过敏

1501
00:50:18,000 --> 00:50:20,000
对贵重金属比较

1502
00:50:20,000 --> 00:50:22,000
比较惰性一点的金属就没问题

1503
00:50:22,000 --> 00:50:23,000
什么铝

1504
00:50:23,000 --> 00:50:26,000
所以你是暗示我们给你买个金表

1505
00:50:27,000 --> 00:50:27,000
对

1506
00:50:27,000 --> 00:50:29,000
给我买个金表吧

1507
00:50:29,000 --> 00:50:30,000
不会还是新来的

1508
00:50:30,000 --> 00:50:32,000
所以你连铝的都不能带

1509
00:50:33,000 --> 00:50:34,000
铝的应该可以

1510
00:50:34,000 --> 00:50:37,000
铝会被氧化对吧

1511
00:50:38,000 --> 00:50:39,000
你等一下

1512
00:50:39,000 --> 00:50:40,000
你说活泼金属怎么定义一下

1513
00:50:41,000 --> 00:50:43,000
活泼金属是镍

1514
00:50:44,000 --> 00:50:45,000
个啊

1515
00:50:45,000 --> 00:50:47,000
猛啊

1516
00:50:47,000 --> 00:50:48,000
主要是镍

1517
00:50:48,000 --> 00:50:50,000
我之前查过

1518
00:50:50,000 --> 00:50:51,000
因为德国也有很多人

1519
00:50:51,000 --> 00:50:52,000
其实过敏

1520
00:50:52,000 --> 00:50:55,000
主要是镍这种东西

1521
00:50:56,000 --> 00:50:58,000
因为我想如果你对铝过敏的话

1522
00:50:58,000 --> 00:50:59,000
那你还用得了 iPhone

1523
00:50:59,000 --> 00:51:00,000
不行

1524
00:51:00,000 --> 00:51:01,000
肯定不行

1525
00:51:02,000 --> 00:51:02,000
就只能装

1526
00:51:02,000 --> 00:51:04,000
我连铝锅都端不了是吧

1527
00:51:07,000 --> 00:51:07,000
好吧

1528
00:51:07,000 --> 00:51:09,000
所以那个

1529
00:51:09,000 --> 00:51:10,000
就是体验上我觉得可能

1530
00:51:11,000 --> 00:51:11,000
不

1531
00:51:11,000 --> 00:51:11,000
你觉得还好吧

1532
00:51:11,000 --> 00:51:12,000
我的意思就是

1533
00:51:12,000 --> 00:51:14,000
我这么大以来

1534
00:51:14,000 --> 00:51:15,000
这是第一次正儿八经的

1535
00:51:15,000 --> 00:51:16,000
每天都代表

1536
00:51:16,000 --> 00:51:17,000
当然我之前有一块

1537
00:51:19,000 --> 00:51:20,000
德国那个叫什么

1538
00:51:20,000 --> 00:51:21,000
BRAWL

1539
00:51:21,000 --> 00:51:22,000
BRAWL

1540
00:51:23,000 --> 00:51:24,000
复刻版的

1541
00:51:24,000 --> 00:51:26,000
最普通的电子表

1542
00:51:26,000 --> 00:51:27,000
就是看起来和 iPhone

1543
00:51:27,000 --> 00:51:30,000
不是说看起来和 iPhone 神似

1544
00:51:30,000 --> 00:51:31,000
只不过那个是正儿八经的

1545
00:51:31,000 --> 00:51:33,000
就只能显示六个数字

1546
00:51:33,000 --> 00:51:33,000
这样

1547
00:51:34,000 --> 00:51:35,000
非常古老的

1548
00:51:36,000 --> 00:51:38,000
所以你带了多久了拿到

1549
00:51:39,000 --> 00:51:39,000
不到

1550
00:51:39,000 --> 00:51:40,000
应该一个月了

1551
00:51:40,000 --> 00:51:41,000
差不多

1552
00:51:41,000 --> 00:51:42,000
OK

1553
00:51:42,000 --> 00:51:43,000
所以感觉如何

1554
00:51:45,000 --> 00:51:47,000
但就只是一块表而已

1555
00:51:47,000 --> 00:51:48,000
我觉得

1556
00:51:48,000 --> 00:51:48,000
不

1557
00:51:48,000 --> 00:51:50,000
你这上面那些软件

1558
00:51:50,000 --> 00:51:51,000
那种各种什么

1559
00:51:51,000 --> 00:51:52,000
Watch Extension

1560
00:51:52,000 --> 00:51:53,000
你觉得好用吗

1561
00:51:54,000 --> 00:51:56,000
实用性并不太高

1562
00:51:56,000 --> 00:51:56,000
必须说

1563
00:51:56,000 --> 00:51:57,000
对

1564
00:51:57,000 --> 00:51:57,000
对

1565
00:51:57,000 --> 00:51:58,000
我觉得

1566
00:51:58,000 --> 00:52:00,000
主要的原因就是因为它太慢了

1567
00:52:01,000 --> 00:52:02,000
我经历了一个很久的状况

1568
00:52:02,000 --> 00:52:04,000
我点那个 Glass

1569
00:52:04,000 --> 00:52:05,000
出来一个比如说

1570
00:52:05,000 --> 00:52:06,000
地图

1571
00:52:06,000 --> 00:52:06,000
上次之后

1572
00:52:06,000 --> 00:52:08,000
在 iT 工程图查最久的

1573
00:52:08,000 --> 00:52:09,000
我等十秒

1574
00:52:09,000 --> 00:52:10,000
我有那个功夫

1575
00:52:10,000 --> 00:52:11,000
屏幕已经黑了

1576
00:52:11,000 --> 00:52:12,000
还没有漏出来

1577
00:52:12,000 --> 00:52:12,000
对吧

1578
00:52:12,000 --> 00:52:13,000
对

1579
00:52:13,000 --> 00:52:14,000
等那功夫出来

1580
00:52:14,000 --> 00:52:15,000
我都是直接手机看了

1581
00:52:15,000 --> 00:52:15,000
好吧

1582
00:52:15,000 --> 00:52:16,000
三跑三位

1583
00:52:16,000 --> 00:52:17,000
我发现这个是

1584
00:52:17,000 --> 00:52:18,000
就是你用一段时间之后

1585
00:52:18,000 --> 00:52:20,000
它就会变快的

1586
00:52:21,000 --> 00:52:21,000
是吗

1587
00:52:21,000 --> 00:52:22,000
我不知道这是我的错觉

1588
00:52:22,000 --> 00:52:23,000
还是怎么样

1589
00:52:23,000 --> 00:52:24,000
就是一开始一周

1590
00:52:24,000 --> 00:52:26,000
我也有这样的状况

1591
00:52:26,000 --> 00:52:27,000
但是后来就真的还好

1592
00:52:28,000 --> 00:52:28,000
好吧

1593
00:52:29,000 --> 00:52:31,000
所以我一直在

1594
00:52:31,000 --> 00:52:33,000
今天我在推特上跟他们讨论

1595
00:52:33,000 --> 00:52:33,000
就说

1596
00:52:34,000 --> 00:52:35,000
他们在说

1597
00:52:35,000 --> 00:52:37,000
这不是刚好 WT 上说了

1598
00:52:37,000 --> 00:52:38,000
WatchOS 2

1599
00:52:39,000 --> 00:52:40,000
它会出原生的 SDK

1600
00:52:40,000 --> 00:52:42,000
可以直接跑在 Watch 上面

1601
00:52:42,000 --> 00:52:43,000
因为之前的话

1602
00:52:44,000 --> 00:52:46,000
其实所谓的 Watch App

1603
00:52:46,000 --> 00:52:47,000
都只是一个

1604
00:52:47,000 --> 00:52:48,000
远程桌面

1605
00:52:48,000 --> 00:52:49,000
差不多这个意思

1606
00:52:50,000 --> 00:52:51,000
你是显示

1607
00:52:51,000 --> 00:52:52,000
在手表上

1608
00:52:52,000 --> 00:52:54,000
但是整个逻辑是跑在手机上面的

1609
00:52:54,000 --> 00:52:55,000
通过蓝牙来通讯

1610
00:52:55,000 --> 00:52:55,000
对

1611
00:52:55,000 --> 00:52:56,000
这是一个

1612
00:52:57,000 --> 00:52:58,000
这是一个物理世界里的

1613
00:52:58,000 --> 00:53:00,000
你们看到 MVC 分隔

1614
00:53:01,000 --> 00:53:03,000
MVC 跑在你的裤刀里

1615
00:53:03,000 --> 00:53:04,000
然后

1616
00:53:04,000 --> 00:53:06,000
V 在你的手腕上

1617
00:53:06,000 --> 00:53:07,000
对

1618
00:53:07,000 --> 00:53:08,000
那这个就是一个问题

1619
00:53:08,000 --> 00:53:09,000
就是说挺费电

1620
00:53:09,000 --> 00:53:09,000
而且挺

1621
00:53:09,000 --> 00:53:10,000
但慢的都已经讲了

1622
00:53:10,000 --> 00:53:12,000
就是一个很大的问题

1623
00:53:12,000 --> 00:53:14,000
就是蓝牙通讯的时候

1624
00:53:14,000 --> 00:53:17,000
手机的 CPU 和表的 CPU 都不能休眠

1625
00:53:17,000 --> 00:53:18,000
而表的屏幕还是亮着的

1626
00:53:18,000 --> 00:53:20,000
你的等一直看着它

1627
00:53:20,000 --> 00:53:20,000
对吧

1628
00:53:21,000 --> 00:53:22,000
这样其实对

1629
00:53:22,000 --> 00:53:24,000
两边的电池续航时间都会有影响

1630
00:53:24,000 --> 00:53:26,000
其实反而你是跑在表上

1631
00:53:26,000 --> 00:53:27,000
原生的一个 SDK 的话

1632
00:53:27,000 --> 00:53:27,000
反而

1633
00:53:27,000 --> 00:53:28,000
要好些

1634
00:53:29,000 --> 00:53:29,000
要好些

1635
00:53:29,000 --> 00:53:30,000
因为它可以快速地完成

1636
00:53:30,000 --> 00:53:32,000
因为现在 CPU 其实是很快的

1637
00:53:32,000 --> 00:53:34,000
Watch 里面他们说的是

1638
00:53:34,000 --> 00:53:34,000
应该是

1639
00:53:34,000 --> 00:53:36,000
就是 A 5 的架构做小

1640
00:53:36,000 --> 00:53:37,000
然后放进去的

1641
00:53:38,000 --> 00:53:38,000
然后

1642
00:53:39,000 --> 00:53:40,000
计算是非常快的

1643
00:53:40,000 --> 00:53:42,000
Performance 不是说只有 A 4 的机缘吗

1644
00:53:43,000 --> 00:53:45,000
A 5 我当时比较清楚

1645
00:53:45,000 --> 00:53:46,000
记得是 A 5

1646
00:53:46,000 --> 00:53:48,000
因为现在 A 5 是在苹果大多数的

1647
00:53:49,000 --> 00:53:51,000
卫生级的老旧设备里面大量存在的

1648
00:53:51,000 --> 00:53:52,000
比如说那个 iPad

1649
00:53:53,000 --> 00:53:54,000
2

1650
00:53:54,000 --> 00:53:55,000
还没有在卖的吧

1651
00:53:55,000 --> 00:53:55,000
还在卖

1652
00:53:56,000 --> 00:53:57,000
iPad 2 就没有在卖

1653
00:53:57,000 --> 00:53:58,000
iPad 的

1654
00:53:58,000 --> 00:53:59,000
iPad mini

1655
00:53:59,000 --> 00:54:01,000
然后那个 Apple Touch

1656
00:54:02,000 --> 00:54:03,000
就这里都是用 A 5

1657
00:54:03,000 --> 00:54:04,000
然后那个还有 Apple TV

1658
00:54:04,000 --> 00:54:05,000
都是 A 5 处理器

1659
00:54:05,000 --> 00:54:06,000
对

1660
00:54:06,000 --> 00:54:07,000
反正

1661
00:54:07,000 --> 00:54:10,000
用了现在我的感觉就是

1662
00:54:11,000 --> 00:54:13,000
有一些 Apple

1663
00:54:13,000 --> 00:54:15,000
我觉得自己可能会用到

1664
00:54:15,000 --> 00:54:16,000
比如说得铁的 Apple

1665
00:54:16,000 --> 00:54:18,000
就是它会告诉你说

1666
00:54:18,000 --> 00:54:19,000
下一班火车

1667
00:54:19,000 --> 00:54:19,000
还有几点来

1668
00:54:19,000 --> 00:54:22,000
下一班火车现在在哪儿

1669
00:54:22,000 --> 00:54:24,000
然后你需要去哪个站台

1670
00:54:25,000 --> 00:54:26,000
但是

1671
00:54:26,000 --> 00:54:28,000
从来没有机会用到

1672
00:54:28,000 --> 00:54:29,000
然后

1673
00:54:30,000 --> 00:54:31,000
最实用的功能就是

1674
00:54:32,000 --> 00:54:32,000
有

1675
00:54:33,000 --> 00:54:34,000
或者说最常用的功能

1676
00:54:34,000 --> 00:54:36,000
就是有邮件来的时候抬手看一下

1677
00:54:36,000 --> 00:54:37,000
这邮件值不值得看

1678
00:54:38,000 --> 00:54:39,000
如果值得看的话就

1679
00:54:40,000 --> 00:54:42,000
切换到手机或者电脑上去看

1680
00:54:42,000 --> 00:54:43,000
然后

1681
00:54:44,000 --> 00:54:46,000
再就是回软信了

1682
00:54:46,000 --> 00:54:46,000
就是它

1683
00:54:46,000 --> 00:54:47,000
我觉得

1684
00:54:47,000 --> 00:54:48,000
让我最

1685
00:54:48,000 --> 00:54:50,000
迄今让我最舒服

1686
00:54:50,000 --> 00:54:52,000
或者说让我最意外的一点就是

1687
00:54:52,000 --> 00:54:54,000
它的语音识别准确率非常非常高

1688
00:54:55,000 --> 00:54:56,000
对

1689
00:54:56,000 --> 00:54:57,000
比 iPhone 上的还高

1690
00:54:58,000 --> 00:54:59,000
而且很神奇的是

1691
00:54:59,000 --> 00:55:01,000
我的手表的系统语言是英语

1692
00:55:01,000 --> 00:55:03,000
手机的系统语言是德语

1693
00:55:03,000 --> 00:55:05,000
然后

1694
00:55:05,000 --> 00:55:07,000
我用中文说话

1695
00:55:07,000 --> 00:55:09,000
它可以准确的把我说的话识别为中文

1696
00:55:09,000 --> 00:55:11,000
即便对方给我发的是英文

1697
00:55:11,000 --> 00:55:12,000
没错

1698
00:55:12,000 --> 00:55:13,000
我也觉得这个事情超神奇

1699
00:55:13,000 --> 00:55:14,000
我不知道它怎么做到

1700
00:55:14,000 --> 00:55:14,000
对

1701
00:55:14,000 --> 00:55:15,000
但是我现在

1702
00:55:16,000 --> 00:55:17,000
我现在没法重现那个事情了

1703
00:55:17,000 --> 00:55:19,000
我不知道怎么弄

1704
00:55:19,000 --> 00:55:20,000
什么意思

1705
00:55:21,000 --> 00:55:22,000
就是我现在又只能输入英文了

1706
00:55:22,000 --> 00:55:23,000
What

1707
00:55:23,000 --> 00:55:24,000
就是语音输入

1708
00:55:24,000 --> 00:55:24,000
就很奇怪

1709
00:55:24,000 --> 00:55:26,000
我也就之前我刚来的时候

1710
00:55:27,000 --> 00:55:29,000
是又有一段时间是用

1711
00:55:29,000 --> 00:55:30,000
就是你说那种情况

1712
00:55:30,000 --> 00:55:32,000
用系统语言是英文吗

1713
00:55:32,000 --> 00:55:33,000
然后回复的时候是说中文

1714
00:55:33,000 --> 00:55:34,000
它既然能听出来是中文

1715
00:55:34,000 --> 00:55:36,000
然后给我出中文的字

1716
00:55:36,000 --> 00:55:38,000
但是自从设那个 1.0.1 之后

1717
00:55:38,000 --> 00:55:39,000
好像又不行

1718
00:55:40,000 --> 00:55:40,000
这个太奇怪了

1719
00:55:40,000 --> 00:55:41,000
我一直都可以

1720
00:55:41,000 --> 00:55:43,000
而且它很神奇的就是

1721
00:55:43,000 --> 00:55:44,000
我说奥迪

1722
00:55:45,000 --> 00:55:46,000
我说奥迪

1723
00:55:46,000 --> 00:55:47,000
它会帮我

1724
00:55:48,000 --> 00:55:49,000
转成奥迪

1725
00:55:49,000 --> 00:55:50,000
A-U-D-I

1726
00:55:50,000 --> 00:55:53,000
然后这四个拉丁字母加在中文里面

1727
00:55:53,000 --> 00:55:54,000
就我现在

1728
00:55:54,000 --> 00:55:55,000
所以我的猜想是这样子

1729
00:55:55,000 --> 00:55:56,000
就是说它为了

1730
00:55:56,000 --> 00:55:59,000
因为手表上的输入比较受限

1731
00:56:00,000 --> 00:56:01,000
他们苹果肯定在后台上

1732
00:56:01,000 --> 00:56:03,000
对这个事情做了一个什么特殊的处理

1733
00:56:03,000 --> 00:56:06,000
就是后台上放一个人在那听血是吧

1734
00:56:06,000 --> 00:56:09,000
顾了 100 万个印度人

1735
00:56:10,000 --> 00:56:11,000
这不是那个什么

1736
00:56:11,000 --> 00:56:13,000
那个 Silicon Valley 里面那一期

1737
00:56:13,000 --> 00:56:15,000
黑他们的用的事情吗

1738
00:56:18,000 --> 00:56:20,000
我觉得它可能是用了一个更加

1739
00:56:20,000 --> 00:56:23,000
费劲的方式去处理这个 Siri 的语音输入

1740
00:56:23,000 --> 00:56:25,000
就包括这个多语言识别

1741
00:56:25,000 --> 00:56:27,000
还有这个专注上是有很大的提升的

1742
00:56:27,000 --> 00:56:30,000
相比于那个 iPhone 上面的 Siri 来讲

1743
00:56:30,000 --> 00:56:31,000
对

1744
00:56:31,000 --> 00:56:33,000
因为感觉这样成本应该是

1745
00:56:33,000 --> 00:56:34,000
服务器的成本是蛮高的

1746
00:56:37,000 --> 00:56:39,000
所以其实你看你用的那几个都是所谓的原生的

1747
00:56:40,000 --> 00:56:42,000
你没有用第三方的 App

1748
00:56:43,000 --> 00:56:44,000
那个体验都不太好吧

1749
00:56:45,000 --> 00:56:47,000
也还可以吧

1750
00:56:47,000 --> 00:56:50,000
你有用哪个第三方的体验比较流畅的吗

1751
00:56:51,000 --> 00:56:53,000
WattApp 还可以

1752
00:56:54,000 --> 00:56:56,000
通讯内的对还行

1753
00:56:56,000 --> 00:56:57,000
然后 Gmail 其实也还可以

1754
00:56:58,000 --> 00:57:02,000
就是 Gmail 有 Watch 的扩展

1755
00:57:02,000 --> 00:57:04,000
它没有直接 Watch 扩展

1756
00:57:04,000 --> 00:57:07,000
但是它可以把 Message 送到 Watch 上

1757
00:57:08,000 --> 00:57:09,000
这个还不错

1758
00:57:09,000 --> 00:57:09,000
对

1759
00:57:10,000 --> 00:57:13,000
然后我还用其他比如说 Instagram 也还 OK 了

1760
00:57:14,000 --> 00:57:18,000
然后有一个德国的天气网站也还挺好

1761
00:57:18,000 --> 00:57:19,000
然后

1762
00:57:20,000 --> 00:57:22,000
对反正还比如说那个

1763
00:57:23,000 --> 00:57:25,000
叫什么 Clear

1764
00:57:25,000 --> 00:57:27,000
就是那个 Todo List Clear

1765
00:57:27,000 --> 00:57:28,000
这个不错

1766
00:57:28,000 --> 00:57:30,000
然后 Lufthansa 的汉沙航空也还 OK

1767
00:57:31,000 --> 00:57:34,000
就做的好的第三方 App 还是有的

1768
00:57:34,000 --> 00:57:36,000
但总体来说

1769
00:57:39,000 --> 00:57:40,000
就还好

1770
00:57:42,000 --> 00:57:45,000
这不是一个像 iPad 那样

1771
00:57:45,000 --> 00:57:46,000
就是我在拿到 iPad 的第二天

1772
00:57:46,000 --> 00:57:47,000
我说

1773
00:57:47,000 --> 00:57:48,000
我靠

1774
00:57:48,000 --> 00:57:50,000
我的后半生离不开这个东西了

1775
00:57:50,000 --> 00:57:52,000
Apple Watch 没有给我这样的感觉

1776
00:57:53,000 --> 00:57:54,000
就是一个

1777
00:57:55,000 --> 00:57:56,000
可有可无的产品

1778
00:57:57,000 --> 00:57:58,000
这样说准确吗

1779
00:57:59,000 --> 00:58:00,000
Nice to have 的产品

1780
00:58:00,000 --> 00:58:00,000
对

1781
00:58:01,000 --> 00:58:02,000
没有也无所谓

1782
00:58:03,000 --> 00:58:04,000
有的当然更好了

1783
00:58:04,000 --> 00:58:04,000
对

1784
00:58:05,000 --> 00:58:07,000
还没有出现所谓的 Killer feature

1785
00:58:08,000 --> 00:58:08,000
对

1786
00:58:08,000 --> 00:58:10,000
但我觉得 Killer feature 早晚会出现

1787
00:58:11,000 --> 00:58:14,000
等它原生的 SDK 出来之后

1788
00:58:14,000 --> 00:58:15,000
现在是什么情况

1789
00:58:15,000 --> 00:58:17,000
就说是可以

1790
00:58:18,000 --> 00:58:19,000
开发者可以马上

1791
00:58:19,000 --> 00:58:21,000
你已经可以拿到这个 SDK 来测试了吗

1792
00:58:21,000 --> 00:58:21,000
还是怎么样

1793
00:58:21,000 --> 00:58:24,000
应该是我昨天下了

1794
00:58:24,000 --> 00:58:28,000
我昨天重新激活了我的 Apple Developer 账户

1795
00:58:29,000 --> 00:58:30,000
扔了 100 欧元进去

1796
00:58:31,000 --> 00:58:33,000
因为我之前在公司

1797
00:58:33,000 --> 00:58:35,000
就是在我的前公司里面有一个

1798
00:58:36,000 --> 00:58:37,000
Enterprise Program

1799
00:58:37,000 --> 00:58:40,000
然后我就把个人的退了

1800
00:58:41,000 --> 00:58:42,000
然后离职之后

1801
00:58:42,000 --> 00:58:43,000
反正一直没碰

1802
00:58:43,000 --> 00:58:45,000
就一直没重新开

1803
00:58:45,000 --> 00:58:46,000
然后直到昨天再重新续

1804
00:58:47,000 --> 00:58:51,000
续长之后又把新的

1805
00:58:51,000 --> 00:58:55,000
现在有两个版本的 Xcode Beta

1806
00:58:55,000 --> 00:58:57,000
一个是 Xcode 7.0 的 Beta

1807
00:58:57,000 --> 00:58:59,000
另一个是 Xcode 6.4 的 Beta

1808
00:58:59,000 --> 00:59:02,000
然后 7.0 的 Beta 里面已经包含了

1809
00:59:03,000 --> 00:59:04,000
如果没理解错的话

1810
00:59:04,000 --> 00:59:06,000
应该已经包含了 Watcher S 2.0

1811
00:59:06,000 --> 00:59:08,000
然后对

1812
00:59:08,000 --> 00:59:10,000
愿意的话可以去摆动摆动试试

1813
00:59:10,000 --> 00:59:12,000
我反正今天做完节目之后

1814
00:59:12,000 --> 00:59:13,000
应该就会摆动摆动试试

1815
00:59:14,000 --> 00:59:15,000
所以你体验一下

1816
00:59:15,000 --> 00:59:18,000
到底能做出一个折托是什么样一个化来

1817
00:59:18,000 --> 00:59:22,000
然后看看有什么体验上的提升了

1818
00:59:22,000 --> 00:59:25,000
我觉得如果能原生在表上跑

1819
00:59:25,000 --> 00:59:26,000
然后响应速度

1820
00:59:26,000 --> 00:59:29,000
能到原生那些 App 的层次的话

1821
00:59:29,000 --> 00:59:31,000
我觉得整个体验会好很多

1822
00:59:31,000 --> 00:59:34,000
但现在确实太糟糕了

1823
00:59:35,000 --> 00:59:36,000
我觉得就是 Sum 好 Sum 好

1824
00:59:36,000 --> 00:59:39,000
我觉得这个 Apple Watch

1825
00:59:39,000 --> 00:59:41,000
其实可以拿来做很多

1826
00:59:42,000 --> 00:59:44,000
不需要显示屏的事情

1827
00:59:46,000 --> 00:59:46,000
比如说

1828
00:59:47,000 --> 00:59:52,000
在中国应该是汉朝的时候

1829
00:59:52,000 --> 00:59:55,000
就是商人们有一种秀礼术

1830
00:59:55,000 --> 00:59:58,000
就是他们看了一个商品

1831
00:59:58,000 --> 01:00:00,000
然后两个人要交易的时候

1832
01:00:00,000 --> 01:00:02,000
他们会把很长的袖子

1833
01:00:02,000 --> 01:00:04,000
套在彼此的手上

1834
01:00:04,000 --> 01:00:05,000
然后按对方的手

1835
01:00:06,000 --> 01:00:06,000
然后按对方的手

1836
01:00:06,000 --> 01:00:09,000
就可以知道对方要出什么价

1837
01:00:09,000 --> 01:00:12,000
你按对方手指的某一个部分

1838
01:00:12,000 --> 01:00:14,000
对方就明白了你要出多少钱

1839
01:00:14,000 --> 01:00:15,000
然后对方可以按回来还价

1840
01:00:16,000 --> 01:00:18,000
我觉得 Apple Watch 可以做类似的事情

1841
01:00:18,000 --> 01:00:21,000
比如说我把手背到后面

1842
01:00:21,000 --> 01:00:24,000
然后以某种特定的频率晃这块表

1843
01:00:24,000 --> 01:00:26,000
然后这块表就可以在别人的手腕上

1844
01:00:26,000 --> 01:00:28,000
产生某种特定的信号

1845
01:00:29,000 --> 01:00:30,000
对

1846
01:00:30,000 --> 01:00:31,000
这样就可以

1847
01:00:31,000 --> 01:00:34,000
不用你现在不是就直接在表盘上

1848
01:00:34,000 --> 01:00:35,000
画小花吗

1849
01:00:35,000 --> 01:00:38,000
对但此时旁边看你表盘的人是看得到

1850
01:00:40,000 --> 01:00:42,000
你要有一个秘密的手势

1851
01:00:42,000 --> 01:00:44,000
你要有一个别人

1852
01:00:44,000 --> 01:00:47,000
察觉不到的方式来彼此通讯

1853
01:00:48,000 --> 01:00:52,000
所以一个比较宅比较 Geek 的方式是什么

1854
01:00:52,000 --> 01:00:53,000
经常那些你看到

1855
01:00:54,000 --> 01:00:58,000
比如说欧美的年轻人

1856
01:00:58,000 --> 01:00:59,000
或者说咱们兄弟会碰头的时候

1857
01:00:59,000 --> 01:01:01,000
会有一堆手特别的手势

1858
01:01:02,000 --> 01:01:03,000
对吧

1859
01:01:04,000 --> 01:01:06,000
我们以后要带着表来玩这件事情

1860
01:01:07,000 --> 01:01:08,000
把整个要记录下来

1861
01:01:08,000 --> 01:01:11,000
要计算一下你这个是否某一个动作做标准了

1862
01:01:12,000 --> 01:01:13,000
不标准不给开锁

1863
01:01:13,000 --> 01:01:16,000
或者最简单的就是

1864
01:01:17,000 --> 01:01:21,000
直接做一个莫尔斯码

1865
01:01:21,000 --> 01:01:24,000
然后你敲表盘

1866
01:01:24,000 --> 01:01:27,000
然后对方就会收到你敲的震动

1867
01:01:27,000 --> 01:01:30,000
什么 Taptic Engine 直接在那里显示

1868
01:01:30,000 --> 01:01:31,000
你直接打到手上是吧

1869
01:01:31,000 --> 01:01:32,000
对

1870
01:01:32,000 --> 01:01:34,000
通过人工的方式去读那个 code

1871
01:01:34,000 --> 01:01:37,000
对然后你提供一个菜鸟模式

1872
01:01:37,000 --> 01:01:40,000
就是对方发莫尔斯码

1873
01:01:40,000 --> 01:01:41,000
然后你看表盘

1874
01:01:41,000 --> 01:01:44,000
这个表盘会把对方的莫尔斯码翻译出来

1875
01:01:45,000 --> 01:01:48,000
要不你第一个 Watch App 就做这个吧

1876
01:01:48,000 --> 01:01:49,000
我觉得也挺有市场的

1877
01:01:49,000 --> 01:01:50,000
可以试试做一下

1878
01:01:50,000 --> 01:01:52,000
感觉实现起来也比较简单

1879
01:01:53,000 --> 01:01:53,000
对

1880
01:01:54,000 --> 01:01:57,000
对我前两天看

1881
01:01:57,000 --> 01:01:58,000
这段我们要卡掉吗

1882
01:01:58,000 --> 01:02:02,000
因为这个属于那个什么 Business Product Idea

1883
01:02:02,000 --> 01:02:05,000
我始终觉得 idea is cheap

1884
01:02:05,000 --> 01:02:06,000
Show me the code

1885
01:02:06,000 --> 01:02:10,000
所以各位听众里面如果有哪个人做出来一个

1886
01:02:10,000 --> 01:02:11,000
欢迎你们来开源

1887
01:02:11,000 --> 01:02:12,000
然后大家可以

1888
01:02:12,000 --> 01:02:15,000
大家可以下来编译一下

1889
01:02:15,000 --> 01:02:17,000
有一个新闻就是

1890
01:02:17,000 --> 01:02:20,000
有一个新闻就是现在好像 Apple 可以

1891
01:02:20,000 --> 01:02:23,000
不用注册 Developer 就可以把

1892
01:02:23,000 --> 01:02:25,000
程序跑在实体机器上

1893
01:02:27,000 --> 01:02:27,000
对

1894
01:02:27,000 --> 01:02:29,000
就是如果各位听众不知道的话

1895
01:02:29,000 --> 01:02:32,000
就是在以前你要为 iOS 开发程序

1896
01:02:32,000 --> 01:02:34,000
理论上是不需要交钱的

1897
01:02:34,000 --> 01:02:36,000
你只需要下载 S Code

1898
01:02:36,000 --> 01:02:37,000
然后写一程序

1899
01:02:37,000 --> 01:02:38,000
然后在模拟器里面跑

1900
01:02:38,000 --> 01:02:41,000
但是如果你想要把这个 App

1901
01:02:41,000 --> 01:02:42,000
在你的实体机器上跑的话

1902
01:02:42,000 --> 01:02:43,000
你必须先去注册

1903
01:02:44,000 --> 01:02:46,000
但是目前看来

1904
01:02:46,000 --> 01:02:48,000
就是如果理解的这个新闻没错的话

1905
01:02:48,000 --> 01:02:50,000
将来你不需要

1906
01:02:50,000 --> 01:02:52,000
一个开发者账号

1907
01:02:52,000 --> 01:02:55,000
也可以把你的 App 直接跑在实体设备上

1908
01:02:55,000 --> 01:02:57,000
但只能是保你自己那台机器

1909
01:02:57,000 --> 01:02:59,000
应该是只能保你自己那台机器

1910
01:02:59,000 --> 01:03:01,000
那也完全够了自己玩票用

1911
01:03:01,000 --> 01:03:02,000
对这就是

1912
01:03:02,000 --> 01:03:05,000
那种早期的 Homebrew 的方式又可以流行起来

1913
01:03:05,000 --> 01:03:08,000
就是你把原单牌发到 GitHub 上

1914
01:03:08,000 --> 01:03:09,000
然后别人当下来

1915
01:03:09,000 --> 01:03:12,000
然后编译一下就可以跑到自己的机器上

1916
01:03:12,000 --> 01:03:14,000
对这可能是很多这种

1917
01:03:14,000 --> 01:03:17,000
就是玩票他也不打算真的是放一个东西

1918
01:03:17,000 --> 01:03:20,000
上架到 App Store 里面那种票邮

1919
01:03:21,000 --> 01:03:23,000
编程票有的抱怨

1920
01:03:23,000 --> 01:03:25,000
就是我干嘛要花个每年 100 刀

1921
01:03:25,000 --> 01:03:27,000
去买这个我一年用两次的东西对吧

1922
01:03:27,000 --> 01:03:28,000
对

1923
01:03:29,000 --> 01:03:31,000
安卓就没有这个问题

1924
01:03:31,000 --> 01:03:32,000
插上线什么都可以装

1925
01:03:35,000 --> 01:03:36,000
对有这个我觉得还是挺好的

1926
01:03:36,000 --> 01:03:37,000
起码我会有更多东西

1927
01:03:37,000 --> 01:03:39,000
那我也学一下这个

1928
01:03:39,000 --> 01:03:42,000
来写一个东西来玩一下

1929
01:03:42,000 --> 01:03:42,000
对

1930
01:03:44,000 --> 01:03:46,000
但是起码到目前为止我们对这个

1931
01:03:46,000 --> 01:03:48,000
对这个表的物理的

1932
01:03:49,000 --> 01:03:50,000
就是 Spec

1933
01:03:50,000 --> 01:03:50,000
叫什么来着

1934
01:03:51,000 --> 01:03:53,000
硬件参数是还不太清楚的是吧

1935
01:03:53,000 --> 01:03:55,000
嗯对吧

1936
01:03:55,000 --> 01:03:57,000
那个 Chipwag 好像还没有把它

1937
01:03:57,000 --> 01:03:59,000
Chipwork 还没有把它拆开

1938
01:03:59,000 --> 01:04:00,000
然后

1939
01:04:00,000 --> 01:04:01,000
Chipwag

1940
01:04:02,000 --> 01:04:04,000
Sorry 德语翻译我出来

1941
01:04:06,000 --> 01:04:09,000
把它放在 X 光机下面照一下

1942
01:04:09,000 --> 01:04:12,000
然后告诉我们上面都是什么

1943
01:04:14,000 --> 01:04:15,000
然后包括内存

1944
01:04:15,000 --> 01:04:17,000
它的内存是确定是 512 兆

1945
01:04:17,000 --> 01:04:18,000
512 兆应该是

1946
01:04:18,000 --> 01:04:20,000
但是有多少能给应用用多少

1947
01:04:20,000 --> 01:04:22,000
是被系统占掉了

1948
01:04:22,000 --> 01:04:23,000
现在也不知道

1949
01:04:23,000 --> 01:04:23,000
对

1950
01:04:23,000 --> 01:04:25,000
刚才我们讨论到的是 A 4 的芯片

1951
01:04:25,000 --> 01:04:26,000
还是 A 5 的芯片

1952
01:04:26,000 --> 01:04:27,000
然后它做那么小

1953
01:04:27,000 --> 01:04:28,000
到底是有多

1954
01:04:28,000 --> 01:04:30,000
就是功耗上会有多大限制

1955
01:04:30,000 --> 01:04:31,000
这都不太清楚

1956
01:04:31,000 --> 01:04:32,000
嗯

1957
01:04:33,000 --> 01:04:33,000
所以

1958
01:04:34,000 --> 01:04:36,000
这就靠你去研究一下这个

1959
01:04:36,000 --> 01:04:38,000
Xcode 7.0 的版本之后

1960
01:04:38,000 --> 01:04:40,000
能不能做出一个好玩的东西来

1961
01:04:41,000 --> 01:04:42,000
好

1962
01:04:42,000 --> 01:04:43,000
你快把那个 Mores 码做出来

1963
01:04:43,000 --> 01:04:44,000
我们先装上

1964
01:04:44,000 --> 01:04:45,000
我们先试试

1965
01:04:45,000 --> 01:04:50,000
我还得先学 Mores code

1966
01:04:50,000 --> 01:04:51,000
这怎么办

1967
01:04:52,000 --> 01:04:53,000
这学得还挺快

1968
01:04:54,000 --> 01:04:56,000
至少你是会两个的

1969
01:04:56,000 --> 01:04:57,000
S 和 O

1970
01:04:58,000 --> 01:05:01,000
SOS 就是三短

1971
01:05:01,000 --> 01:05:03,000
然后三长三短

1972
01:05:03,000 --> 01:05:05,000
三短三长三短

1973
01:05:06,000 --> 01:05:07,000
为什么不是三长两短

1974
01:05:08,000 --> 01:05:09,000
因为 S 是三长

1975
01:05:10,000 --> 01:05:11,000
S 是三短

1976
01:05:11,000 --> 01:05:12,000
O 是三长

1977
01:05:13,000 --> 01:05:13,000
好吧

1978
01:05:13,000 --> 01:05:14,000
对

1979
01:05:14,000 --> 01:05:17,000
所以现在其实我们对原生的

1980
01:05:17,000 --> 01:05:20,000
OS 2 的 SDK 还没有太多可以讲的

1981
01:05:21,000 --> 01:05:22,000
因为现在只是公布出来

1982
01:05:22,000 --> 01:05:24,000
还没有真的去试过

1983
01:05:24,000 --> 01:05:26,000
可能以后等

1984
01:05:26,000 --> 01:05:27,000
我们的吴涛同志去试了之后

1985
01:05:27,000 --> 01:05:30,000
我们在今后的节目里面再来提一下

1986
01:05:30,000 --> 01:05:33,000
这次 WT 上还发布了一个

1987
01:05:33,000 --> 01:05:35,000
我觉得挺开心的消息

1988
01:05:35,000 --> 01:05:36,000
就是 Swift 2

1989
01:05:36,000 --> 01:05:36,000
对

1990
01:05:36,000 --> 01:05:38,000
并且它开源了

1991
01:05:38,000 --> 01:05:38,000
对

1992
01:05:38,000 --> 01:05:42,000
这个是当时我也是在看电视的时候

1993
01:05:43,000 --> 01:05:44,000
我和我女朋友一边在做饭

1994
01:05:44,000 --> 01:05:46,000
然后一边在看 WAC

1995
01:05:46,000 --> 01:05:47,000
然后我看到说

1996
01:05:47,000 --> 01:05:49,000
多么温馨的一个场面

1997
01:05:49,000 --> 01:05:51,000
忽然双手举招说

1998
01:05:51,000 --> 01:05:53,000
Swift 2 开源了

1999
01:05:53,000 --> 01:05:54,000
然后女朋友疑惑了

2000
01:05:54,000 --> 01:05:56,000
那是什么意思呢

2001
01:05:57,000 --> 01:05:59,000
然后进入了教学模式

2002
01:06:00,000 --> 01:06:02,000
多么幸福的一个场景

2003
01:06:02,000 --> 01:06:06,000
在听的单身狗们感受到深深的恶意没

2004
01:06:08,000 --> 01:06:10,000
我没有这个意思

2005
01:06:13,000 --> 01:06:16,000
但它开源是说发布了

2006
01:06:16,000 --> 01:06:21,000
这个 iOS OS X 和 Linux 的版本

2007
01:06:21,000 --> 01:06:22,000
对

2008
01:06:22,000 --> 01:06:23,000
我觉得这还挺

2009
01:06:23,000 --> 01:06:25,000
当时我听到 Linux 也是心一惊

2010
01:06:26,000 --> 01:06:26,000
心想说

2011
01:06:26,000 --> 01:06:27,000
我靠

2012
01:06:27,000 --> 01:06:34,000
这是多久没有在 WDC 上听到 Linux 的名字了

2013
01:06:35,000 --> 01:06:37,000
而且不敢相信的是

2014
01:06:37,000 --> 01:06:40,000
稍后又听到了一次 Android

2015
01:06:40,000 --> 01:06:43,000
而且是以一种正面的方式听到很整

2016
01:06:46,000 --> 01:06:50,000
他在宣布 Apple Music 将会在 Android 上推出的时候

2017
01:06:50,000 --> 01:06:51,000
我心里也还觉得

2018
01:06:51,000 --> 01:06:54,000
这是发生了什么

2019
01:06:54,000 --> 01:06:55,000
而且我跟你说

2020
01:06:56,000 --> 01:06:58,000
他们还出了一个 Android 的 App

2021
01:06:58,000 --> 01:06:59,000
不是音乐那个

2022
01:07:00,000 --> 01:07:03,000
叫做 Android Migration

2023
01:07:03,000 --> 01:07:05,000
可以可以从 Android 上

2024
01:07:05,000 --> 01:07:07,000
就帮助你从 Android 手机切换到 iPhone 了

2025
01:07:07,000 --> 01:07:08,000
简单来讲

2026
01:07:09,000 --> 01:07:11,000
因为 Android 是可以拿到很多系统的资料的

2027
01:07:12,000 --> 01:07:15,000
然后给你做了这么一个一键导入切换到 Apple ID 里面

2028
01:07:15,000 --> 01:07:16,000
然后再给你

2029
01:07:17,000 --> 01:07:19,000
直接可以帮你设置好很多东西了

2030
01:07:19,000 --> 01:07:21,000
这个还是蛮狠的

2031
01:07:21,000 --> 01:07:24,000
Mac 上面也曾经有过什么

2032
01:07:24,000 --> 01:07:25,000
没错

2033
01:07:25,000 --> 01:07:27,000
可以从 Windows Migrate 过去

2034
01:07:27,000 --> 01:07:30,000
他就把等于等于这个就是 iOS 版的那个东西了

2035
01:07:31,000 --> 01:07:34,000
叫做 Migration Assistant 应该是

2036
01:07:35,000 --> 01:07:37,000
我等一下我确认一下是不是叫这个

2037
01:07:37,000 --> 01:07:38,000
对 Migration Assistant

2038
01:07:39,000 --> 01:07:40,000
就是这点还是蛮狠的

2039
01:07:40,000 --> 01:07:42,000
因为你知道这个东西是单向接吗

2040
01:07:42,000 --> 01:07:43,000
One Way Street

2041
01:07:43,000 --> 01:07:44,000
对那肯定有

2042
01:07:45,000 --> 01:07:47,000
因为 iOS 里面没有

2043
01:07:47,000 --> 01:07:49,000
就除了苹果之外没有

2044
01:07:49,000 --> 01:07:53,000
就哪怕苹果应该是不太可能拿得到那些应用里面的资料

2045
01:07:53,000 --> 01:07:55,000
就是有这个沙盒模型的限制

2046
01:07:55,000 --> 01:07:56,000
而且他把系统全面锁得很死

2047
01:07:56,000 --> 01:07:57,000
你不可能做

2048
01:07:58,000 --> 01:08:00,000
就第三方是没有办法做这么一个应用

2049
01:08:00,000 --> 01:08:02,000
装到一个 iOS 里面

2050
01:08:02,000 --> 01:08:03,000
然后再把数据导到

2051
01:08:03,000 --> 01:08:05,000
那个另外的地方去

2052
01:08:05,000 --> 01:08:08,000
但可能拿那个通讯录啊

2053
01:08:08,000 --> 01:08:09,000
这种比较常

2054
01:08:09,000 --> 01:08:10,000
还有照片啊这种常见的还可以

2055
01:08:10,000 --> 01:08:12,000
但其他的就不行

2056
01:08:12,000 --> 01:08:15,000
我不太清楚那个 Android Migration 这个 App 到底能做多少的事

2057
01:08:16,000 --> 01:08:18,000
总之苹果的反正这一套东西就是

2058
01:08:19,000 --> 01:08:21,000
一堆吃满到次的丛林

2059
01:08:21,000 --> 01:08:22,000
进去就出不来

2060
01:08:23,000 --> 01:08:23,000
没错

2061
01:08:23,000 --> 01:08:25,000
那再说回那个 SWAP 开源的事情

2062
01:08:26,000 --> 01:08:27,000
你觉得他们为什么会选

2063
01:08:27,000 --> 01:08:29,000
会做这件事情

2064
01:08:29,000 --> 01:08:30,000
他们的动机是什么

2065
01:08:31,000 --> 01:08:32,000
呃

2066
01:08:34,000 --> 01:08:38,000
我觉得他们还是想要把 Swift 这个

2067
01:08:39,000 --> 01:08:41,000
目前看起来非常优秀的语言特性

2068
01:08:41,000 --> 01:08:43,000
尽可能的拓展开来

2069
01:08:43,000 --> 01:08:44,000
然后

2070
01:08:44,000 --> 01:08:46,000
借此来

2071
01:08:46,000 --> 01:08:47,000
呃

2072
01:08:47,000 --> 01:08:50,000
一方面是能让语言本身能够

2073
01:08:51,000 --> 01:08:52,000
心境火传下去

2074
01:08:52,000 --> 01:08:57,000
另外一方面也是希望能够借此让其他平台上的人尝一尝

2075
01:08:58,000 --> 01:08:58,000
呃

2076
01:08:59,000 --> 01:09:02,000
给苹果编程是一种什么样的体验

2077
01:09:02,000 --> 01:09:04,000
哈哈没错

2078
01:09:04,000 --> 01:09:06,000
因为你以前在

2079
01:09:06,000 --> 01:09:09,000
除非你是一个非常非常非常非常有受虐形象的人

2080
01:09:09,000 --> 01:09:12,000
你是一般不会在其他操作系统上

2081
01:09:12,000 --> 01:09:14,000
试图去搞

2082
01:09:14,000 --> 01:09:16,000
Ubjective-C 这套东西

2083
01:09:16,000 --> 01:09:19,000
就是你可以去采用那个叫什么 OpenStep

2084
01:09:20,000 --> 01:09:21,000
呃这套东西来

2085
01:09:22,000 --> 01:09:25,000
呃在其他平台上编译 Ubjective-C 是可行的

2086
01:09:25,000 --> 01:09:27,000
但是从来没人这样做

2087
01:09:27,000 --> 01:09:27,000
或者说

2088
01:09:28,000 --> 01:09:31,000
你这样做的人最后都把头发抓光

2089
01:09:31,000 --> 01:09:32,000
然后出家了

2090
01:09:32,000 --> 01:09:34,000
呃

2091
01:09:34,000 --> 01:09:37,000
而 Swift 2 如果开源并且跨平台的话

2092
01:09:37,000 --> 01:09:40,000
那你也许将来可以在不知不觉的在

2093
01:09:40,000 --> 01:09:41,000
呃

2094
01:09:41,000 --> 01:09:43,000
Links 上面爱上这种语言

2095
01:09:43,000 --> 01:09:48,000
然后你发现你的这个知识可以迁移到给苹果开发系统

2096
01:09:48,000 --> 01:09:50,000
或者给苹果开发软件

2097
01:09:50,000 --> 01:09:53,000
那也许你就会随手去做一个呢

2098
01:09:53,000 --> 01:09:55,000
也许这也是苹果的考量之一

2099
01:09:56,000 --> 01:10:00,000
我觉得可能最眼下最务实的一个事情

2100
01:10:00,000 --> 01:10:00,000
就是说

2101
01:10:00,000 --> 01:10:02,000
很多这个 IOS 开发者

2102
01:10:02,000 --> 01:10:04,000
他因为你知道 IOS 的

2103
01:10:04,000 --> 01:10:05,000
现在不是有个风潮吗

2104
01:10:05,000 --> 01:10:08,000
就是说我们做一个新的产品或者服务的时候

2105
01:10:08,000 --> 01:10:09,000
连网站那个都省了

2106
01:10:09,000 --> 01:10:11,000
直接就做一个 API 的后台

2107
01:10:11,000 --> 01:10:14,000
再加一个 IOS 客户端就搞定了对吧

2108
01:10:14,000 --> 01:10:14,000
嗯哼

2109
01:10:14,000 --> 01:10:15,000
但是呢

2110
01:10:15,000 --> 01:10:18,000
这个服务端那边一般不可能用

2111
01:10:18,000 --> 01:10:19,000
刚才讲嘛

2112
01:10:19,000 --> 01:10:21,000
不可能用苹果的东西来写之前就对

2113
01:10:21,000 --> 01:10:22,000
就非常少

2114
01:10:22,000 --> 01:10:27,000
用 OBJECT C 写后台已经是 20 年前的事情了

2115
01:10:27,000 --> 01:10:28,000
并且

2116
01:10:29,000 --> 01:10:30,000
对

2117
01:10:30,000 --> 01:10:33,000
就连应该我这是连苹果自己那个叫什么

2118
01:10:33,000 --> 01:10:34,000
web 什么来的

2119
01:10:34,000 --> 01:10:36,000
weblogic

2120
01:10:36,000 --> 01:10:37,000
web

2121
01:10:38,000 --> 01:10:40,000
他有一个叫什么

2122
01:10:40,000 --> 01:10:41,000
我来搜一下

2123
01:10:42,000 --> 01:10:43,000
webobjects

2124
01:10:44,000 --> 01:10:45,000
对对对 webobjects

2125
01:10:45,000 --> 01:10:47,000
weblogic 后来转成

2126
01:10:48,000 --> 01:10:49,000
加码了

2127
01:10:49,000 --> 01:10:50,000
后来转成加码吗

2128
01:10:50,000 --> 01:10:51,000
没错

2129
01:10:51,000 --> 01:10:51,000
ok

2130
01:10:52,000 --> 01:10:53,000
这个我很确定

2131
01:10:53,000 --> 01:10:56,000
就是苹果曾经他自己是有一套这个

2132
01:10:56,000 --> 01:10:57,000
当然是那个是 web 1.0 时代

2133
01:10:57,000 --> 01:11:00,000
对非常非常古老的时代

2134
01:11:00,000 --> 01:11:03,000
因为最初发布的时候是 19 年前 96 年的时候

2135
01:11:03,000 --> 01:11:04,000
然后

2136
01:11:05,000 --> 01:11:07,000
他最开始的时候是那个 OBJECT C 写的

2137
01:11:07,000 --> 01:11:11,000
后来是都因为面对现实改成了加码

2138
01:11:11,000 --> 01:11:12,000
来实现的

2139
01:11:12,000 --> 01:11:13,000
啊

2140
01:11:14,000 --> 01:11:15,000
这其实还是蛮坑爹的嘛

2141
01:11:15,000 --> 01:11:18,000
你要学两个语言两种 runtime

2142
01:11:18,000 --> 01:11:20,000
然后各种不一样的区别 API 都完全不一样

2143
01:11:21,000 --> 01:11:22,000
然后有了这个 sweep 2

2144
01:11:22,000 --> 01:11:24,000
就 sweep 他如果开原有这么实现之后

2145
01:11:24,000 --> 01:11:25,000
你可以做到这么一件事

2146
01:11:25,000 --> 01:11:26,000
就是

2147
01:11:26,000 --> 01:11:30,000
那个客户端的开发者和服务端 API 的开发者

2148
01:11:31,000 --> 01:11:32,000
可以是同一班人嘛

2149
01:11:33,000 --> 01:11:35,000
或者说就不用再学两套语言了

2150
01:11:35,000 --> 01:11:36,000
就整个都是一样的

2151
01:11:36,000 --> 01:11:38,000
唯一现在可能比较存疑的

2152
01:11:38,000 --> 01:11:41,000
就是这个标准库和第三方库的问题

2153
01:11:41,000 --> 01:11:42,000
因为刚出来肯定是没有的

2154
01:11:42,000 --> 01:11:45,000
因为他那些比较好的现成的

2155
01:11:45,000 --> 01:11:46,000
这个

2156
01:11:46,000 --> 01:11:48,000
就是因为为什么说这个 OBJECT C

2157
01:11:48,000 --> 01:11:51,000
做那个客户端开发比较好用

2158
01:11:51,000 --> 01:11:52,000
或者说 sweep 2

2159
01:11:52,000 --> 01:11:54,000
做客户端开发开发比较好用

2160
01:11:54,000 --> 01:11:55,000
是因为他有那个

2161
01:11:55,000 --> 01:11:56,000
coco 嘛

2162
01:11:56,000 --> 01:11:57,000
也是叫 coco 嘛

2163
01:11:57,000 --> 01:11:59,000
but UI kit 这一套东西

2164
01:11:59,000 --> 01:12:00,000
coco 也对啊

2165
01:12:00,000 --> 01:12:02,000
在 mac 上面

2166
01:12:02,000 --> 01:12:03,000
啊对

2167
01:12:03,000 --> 01:12:06,000
就 mac 和 iOS 上面都是同一套

2168
01:12:06,000 --> 01:12:07,000
一个是经典版

2169
01:12:07,000 --> 01:12:08,000
差不多这么理解吧

2170
01:12:10,000 --> 01:12:12,000
但是他现在如果开源到 linux 上面

2171
01:12:12,000 --> 01:12:14,000
其实我不清楚

2172
01:12:14,000 --> 01:12:16,000
他只有语言还有编译器开源呢

2173
01:12:16,000 --> 01:12:19,000
还是说他会把这一套比较完善的

2174
01:12:19,000 --> 01:12:21,000
这个标准库也拿过去用

2175
01:12:21,000 --> 01:12:22,000
我觉得可能不太显示

2176
01:12:22,000 --> 01:12:23,000
对应该是不是

2177
01:12:23,000 --> 01:12:25,000
我希望

2178
01:12:25,000 --> 01:12:28,000
我觉得苹果的希望应该是

2179
01:12:28,000 --> 01:12:32,000
能够让第三方开发者自己生长出一套

2180
01:12:32,000 --> 01:12:34,000
就开发社区来做这个事

2181
01:12:34,000 --> 01:12:34,000
对

2182
01:12:35,000 --> 01:12:36,000
swift on rails

2183
01:12:39,000 --> 01:12:42,000
swift on power cables

2184
01:12:42,000 --> 01:12:45,000
就是一群燕子站在这个电线上

2185
01:12:46,000 --> 01:12:49,000
ok 我们的连项目名字都想好了

2186
01:12:49,000 --> 01:12:50,000
开始干嘛

2187
01:12:54,000 --> 01:12:56,000
所以其实这个我觉得好处还是很显而易见的

2188
01:12:56,000 --> 01:12:58,000
就是可以看时间感的我说的那一点

2189
01:12:58,000 --> 01:13:00,000
然后其实从一个

2190
01:13:00,000 --> 01:13:02,000
就是这个 mindshare

2191
01:13:02,000 --> 01:13:05,000
这个脑力的争夺站来讲

2192
01:13:05,000 --> 01:13:08,000
其实我觉得现在定位最好的应该是

2193
01:13:09,000 --> 01:13:09,000
android 吧

2194
01:13:09,000 --> 01:13:11,000
因为 java 很多人都会嘛

2195
01:13:11,000 --> 01:13:14,000
java 可以写这个客户端

2196
01:13:14,000 --> 01:13:15,000
可以写签入式

2197
01:13:15,000 --> 01:13:16,000
可以写服务端

2198
01:13:16,000 --> 01:13:17,000
可以写桌面应用

2199
01:13:17,000 --> 01:13:19,000
当然桌面应用不太适合

2200
01:13:19,000 --> 01:13:23,000
但是总体来说还是一个适用性非常广的语言

2201
01:13:23,000 --> 01:13:26,000
但有意思的是 google 正在有意无意的把 java

2202
01:13:26,000 --> 01:13:27,000
deaching 了

2203
01:13:27,000 --> 01:13:28,000
你不觉得吧

2204
01:13:28,000 --> 01:13:32,000
就是首先 server side 肯定要用 go language 这些

2205
01:13:32,000 --> 01:13:34,000
这件事情已经成立了吗

2206
01:13:34,000 --> 01:13:35,000
我觉得还没有吧

2207
01:13:35,000 --> 01:13:37,000
他正在试图找这个方向前进不是吗

2208
01:13:37,000 --> 01:13:38,000
你不觉得

2209
01:13:39,000 --> 01:13:42,000
这点事情我是觉得是存疑的

2210
01:13:42,000 --> 01:13:43,000
就是你觉得

2211
01:13:44,000 --> 01:13:46,000
google 在我们有生之年不会抛弃 java 吗

2212
01:13:47,000 --> 01:13:48,000
起码在安卓的这一端

2213
01:13:48,000 --> 01:13:50,000
我觉得是可能比较难

2214
01:13:50,000 --> 01:13:53,000
因为其实你真的用 google 来写客户端的话

2215
01:13:53,000 --> 01:13:55,000
其实发现还是坑蛮多的

2216
01:13:55,000 --> 01:13:55,000
不

2217
01:13:55,000 --> 01:13:59,000
可是我们上次不是提到了他的那个叫什么 sky

2218
01:13:59,000 --> 01:14:00,000
对他有这个尝试

2219
01:14:01,000 --> 01:14:02,000
但是我不太清楚这件事情

2220
01:14:02,000 --> 01:14:04,000
支付真的能够做得成

2221
01:14:04,000 --> 01:14:06,000
因为这个惯性还是蛮大的

2222
01:14:06,000 --> 01:14:06,000
你不知道

2223
01:14:06,000 --> 01:14:09,000
因为 java 是什么

2224
01:14:10,000 --> 01:14:11,000
教学及语言

2225
01:14:12,000 --> 01:14:14,000
我以为你要说小强语言

2226
01:14:15,000 --> 01:14:16,000
有一个意思

2227
01:14:17,000 --> 01:14:19,000
在学校里面他在培养的人

2228
01:14:19,000 --> 01:14:21,000
教学的时候就是用这个东西

2229
01:14:21,000 --> 01:14:23,000
我觉得这个对一大批的

2230
01:14:24,000 --> 01:14:27,000
程序员成长的经验上还是非常重要的影响

2231
01:14:27,000 --> 01:14:30,000
所以我不太确定他这就能短期内实现这一点

2232
01:14:30,000 --> 01:14:30,000
而且

2233
01:14:32,000 --> 01:14:33,000
哪怕是在服务端

2234
01:14:33,000 --> 01:14:35,000
他在用 go 去替代 java

2235
01:14:35,000 --> 01:14:38,000
也是在比较小范围的有限度的去整理一个场式

2236
01:14:38,000 --> 01:14:40,000
而并不是说全公司的

2237
01:14:40,000 --> 01:14:41,000
怎么去推这么一个东西

2238
01:14:42,000 --> 01:14:46,000
如果纯粹以前后端使用单语言来衡量的话

2239
01:14:46,000 --> 01:14:47,000
不考虑市场份额

2240
01:14:47,000 --> 01:14:49,000
那 windows phone 难道不是最好吗

2241
01:14:50,000 --> 01:14:50,000
对

2242
01:14:50,000 --> 01:14:52,000
所以其实我们来现在看现在微软

2243
01:14:52,000 --> 01:14:53,000
其实挺有意思的一个情况

2244
01:14:53,000 --> 01:14:54,000
就是他

2245
01:14:55,000 --> 01:14:57,000
csharp 其实是做得挺好的

2246
01:14:57,000 --> 01:14:59,000
对通吃所有平台所有端

2247
01:15:00,000 --> 01:15:00,000
对

2248
01:15:00,000 --> 01:15:01,000
而且如果我理解没错的话

2249
01:15:01,000 --> 01:15:04,000
他用 clr 的 runtime 之后

2250
01:15:04,000 --> 01:15:06,000
他编译生成 c

2251
01:15:07,000 --> 01:15:09,000
你甚至不一定要用 csharp 来写 windows phone 的应用

2252
01:15:09,000 --> 01:15:12,000
可以用他们 fsharp 来写也可以对吧

2253
01:15:13,000 --> 01:15:16,000
对或者什么 objectivec.net

2254
01:15:16,000 --> 01:15:17,000
如果你感兴趣

2255
01:15:17,000 --> 01:15:18,000
对这这这类的东西

2256
01:15:18,000 --> 01:15:20,000
其实他的定位是更好

2257
01:15:20,000 --> 01:15:21,000
当然他因为没有

2258
01:15:22,000 --> 01:15:24,000
没有什么没有市场占有量

2259
01:15:24,000 --> 01:15:25,000
这件事情就

2260
01:15:25,000 --> 01:15:28,000
没有对大外宣来说没有什么意义

2261
01:15:28,000 --> 01:15:29,000
就我们只是讨论

2262
01:15:29,000 --> 01:15:32,000
安卓和 RSC 两个情况来看

2263
01:15:32,000 --> 01:15:32,000
就是

2264
01:15:32,000 --> 01:15:35,000
苹果在这上面上是我就稍微是有点吃亏的

2265
01:15:36,000 --> 01:15:37,000
嗯

2266
01:15:38,000 --> 01:15:39,000
很难说吧

2267
01:15:39,000 --> 01:15:39,000
我觉得

2268
01:15:39,000 --> 01:15:40,000
就

2269
01:15:40,000 --> 01:15:40,000
嗯

2270
01:15:40,000 --> 01:15:41,000
嗯

2271
01:15:41,000 --> 01:15:42,000
我觉得

2272
01:15:44,000 --> 01:15:46,000
苹果是试图以

2273
01:15:47,000 --> 01:15:49,000
语言本身的优势

2274
01:15:49,000 --> 01:15:52,000
以及他在客户端的

2275
01:15:53,000 --> 01:15:56,000
比较相对来说比较广泛的开发者群

2276
01:15:56,000 --> 01:15:58,000
去反攻服务端

2277
01:15:59,000 --> 01:16:04,000
去反反过来去试图向服务端扩展这一技术

2278
01:16:05,000 --> 01:16:06,000
而

2279
01:16:06,000 --> 01:16:10,000
我看不到 Google 有一种新的语言可以

2280
01:16:11,000 --> 01:16:12,000
单词重任

2281
01:16:12,000 --> 01:16:15,000
另外一方面 Google 好像本身也没有这个心思

2282
01:16:16,000 --> 01:16:19,000
他之前不是大家都在猜他会不会用那个叫

2283
01:16:19,000 --> 01:16:20,000
那个叫什么来的

2284
01:16:20,000 --> 01:16:22,000
之前宣布有没有搭载的

2285
01:16:23,000 --> 01:16:24,000
Dart

2286
01:16:24,000 --> 01:16:24,000
是吗

2287
01:16:24,000 --> 01:16:25,000
对 Dart

2288
01:16:25,000 --> 01:16:25,000
对

2289
01:16:25,000 --> 01:16:27,000
Dart 不就是 style

2290
01:16:28,000 --> 01:16:29,000
呃

2291
01:16:29,000 --> 01:16:30,000
但是我觉得那个事情可能

2292
01:16:31,000 --> 01:16:32,000
他想的可能还不太一样

2293
01:16:32,000 --> 01:16:34,000
那个 Dart 是初中是要

2294
01:16:34,000 --> 01:16:37,000
从 web 那段开始简化这个 UI

2295
01:16:37,000 --> 01:16:39,000
就是 UI 的那个构建的方法了

2296
01:16:40,000 --> 01:16:40,000
嗯

2297
01:16:41,000 --> 01:16:43,000
但是到了这个安卓上

2298
01:16:43,000 --> 01:16:44,000
我不知道性能啊

2299
01:16:44,000 --> 01:16:46,000
还有这些方面真的是靠谱吗

2300
01:16:46,000 --> 01:16:47,000
反正他起码现在没有做这件事

2301
01:16:48,000 --> 01:16:50,000
可能还是有一定的技术门槛我觉得

2302
01:16:50,000 --> 01:16:51,000
嗯

2303
01:16:52,000 --> 01:16:52,000
拭目以待吧

2304
01:16:52,000 --> 01:16:54,000
反正 Google 的东西都是要等

2305
01:16:55,000 --> 01:16:58,000
然后随时可能不就 cancel 了

2306
01:16:58,000 --> 01:16:58,000
对

2307
01:16:58,000 --> 01:17:01,000
我觉得这次 WDC 给我一个印象就是

2308
01:17:01,000 --> 01:17:03,000
你在那边看着他说

2309
01:17:03,000 --> 01:17:05,000
哎这个东西我们是什么样的

2310
01:17:05,000 --> 01:17:08,000
然后你转联你就可以下载下来用了

2311
01:17:09,000 --> 01:17:09,000
还是

2312
01:17:10,000 --> 01:17:12,000
delivered 到了

2313
01:17:12,000 --> 01:17:13,000
不像 Google 老是画饼子

2314
01:17:13,000 --> 01:17:14,000
对说

2315
01:17:15,000 --> 01:17:17,000
说这个东西我们有啊

2316
01:17:17,000 --> 01:17:20,000
然后各位再等两年就可以用到

2317
01:17:21,000 --> 01:17:22,000
哦对还有一个

2318
01:17:22,000 --> 01:17:26,000
比较小的重点就是 Sift 2 里面有

2319
01:17:26,000 --> 01:17:27,000
这个 trycatch

2320
01:17:27,000 --> 01:17:30,000
当然他们的语他的语法是 do catch

2321
01:17:31,000 --> 01:17:33,000
Do 里面就是一个 DoBlock

2322
01:17:33,000 --> 01:17:35,000
DoBlock 里面有一些关键的部分

2323
01:17:35,000 --> 01:17:37,000
可能会抛出一场的部分

2324
01:17:37,000 --> 01:17:39,000
你要用 try 关于字去

2325
01:17:39,000 --> 01:17:41,000
就是有那个 exception 机制了吗

2326
01:17:41,000 --> 01:17:42,000
对

2327
01:17:42,000 --> 01:17:46,000
然后我之前在直播上写过一篇答案比较

2328
01:17:46,000 --> 01:17:47,000
呃

2329
01:17:48,000 --> 01:17:50,000
比较笃定的

2330
01:17:51,000 --> 01:17:55,000
阐述了为什么没有 exception 机制比较好

2331
01:17:55,000 --> 01:17:58,000
然后现在 exception 机制出了

2332
01:17:58,000 --> 01:17:59,000
被打脸了是吧

2333
01:17:59,000 --> 01:17:59,000
对

2334
01:18:00,000 --> 01:18:00,000
呃

2335
01:18:01,000 --> 01:18:02,000
anyway

2336
01:18:02,000 --> 01:18:05,000
当然我那篇文章里面非常圆滑的

2337
01:18:05,000 --> 01:18:06,000
没有把话说死

2338
01:18:06,000 --> 01:18:09,000
我也默默的去改了那个

2339
01:18:09,000 --> 01:18:10,000
当时的措辞

2340
01:18:10,000 --> 01:18:11,000
就说啊现在已经有了

2341
01:18:11,000 --> 01:18:12,000
所以

2342
01:18:13,000 --> 01:18:13,000
anyway

2343
01:18:14,000 --> 01:18:15,000
OK

2344
01:18:15,000 --> 01:18:18,000
那我们接下来可以进入本期的正题

2345
01:18:18,000 --> 01:18:21,000
在一个多小时之后

2346
01:18:21,000 --> 01:18:22,000
开始进入正题

2347
01:18:23,000 --> 01:18:23,000
太好了

2348
01:18:23,000 --> 01:18:24,000
我们只能谈半个小时

2349
01:18:24,000 --> 01:18:25,000
对

2350
01:18:26,000 --> 01:18:27,000
所以本期的主题是

2351
01:18:27,000 --> 01:18:28,000
测试

2352
01:18:28,000 --> 01:18:31,000
testing

2353
01:18:32,000 --> 01:18:33,000
然后

2354
01:18:33,000 --> 01:18:34,000
什么是测试

2355
01:18:34,000 --> 01:18:35,000
解释一下

2356
01:18:35,000 --> 01:18:36,000
呃

2357
01:18:36,000 --> 01:18:36,000
好问题

2358
01:18:37,000 --> 01:18:38,000
你说什么测试

2359
01:18:38,000 --> 01:18:40,000
就我其实今天在准备

2360
01:18:40,000 --> 01:18:43,000
或者说这段时间在准备这个提纲的时候

2361
01:18:43,000 --> 01:18:45,000
想了很多测试的例子

2362
01:18:45,000 --> 01:18:46,000
但是

2363
01:18:46,000 --> 01:18:47,000
呃

2364
01:18:48,000 --> 01:18:49,000
我觉得可以这么说吧

2365
01:18:49,000 --> 01:18:51,000
就是测试有两个含义

2366
01:18:51,000 --> 01:18:52,000
一个是广义的测试

2367
01:18:52,000 --> 01:18:53,000
一个是狭义的测试

2368
01:18:53,000 --> 01:18:54,000
就像相对论一样

2369
01:18:54,000 --> 01:18:55,000
呃

2370
01:18:55,000 --> 01:18:58,000
广义的测试可以指比如说

2371
01:18:58,000 --> 01:18:59,000
penetration test

2372
01:19:00,000 --> 01:19:01,000
也是一种测试

2373
01:19:01,000 --> 01:19:02,000
就是

2374
01:19:02,000 --> 01:19:04,000
看贵公司的网站是否安全

2375
01:19:05,000 --> 01:19:05,000
我做一个

2376
01:19:05,000 --> 01:19:07,000
不管是黑帽子还是白帽子

2377
01:19:07,000 --> 01:19:08,000
试着去

2378
01:19:08,000 --> 01:19:10,000
扫一扫端口呀

2379
01:19:10,000 --> 01:19:11,000
破一破密码呀

2380
01:19:11,000 --> 01:19:12,000
找一找注入点呀

2381
01:19:12,000 --> 01:19:14,000
这些可以叫做测试

2382
01:19:14,000 --> 01:19:15,000
甚至

2383
01:19:15,000 --> 01:19:17,000
英文名字也叫 penetration test

2384
01:19:17,000 --> 01:19:20,000
甚至有一个专门的错写叫做 pentest

2385
01:19:20,000 --> 01:19:21,000
对

2386
01:19:21,000 --> 01:19:22,000
然后

2387
01:19:22,000 --> 01:19:23,000
呃

2388
01:19:23,000 --> 01:19:25,000
发烟测试也可以叫做测试

2389
01:19:26,000 --> 01:19:26,000
就比如说

2390
01:19:27,000 --> 01:19:29,000
发烟 smoke testing

2391
01:19:29,000 --> 01:19:31,000
这个我还不太理解

2392
01:19:31,000 --> 01:19:32,000
这边这种各种数语

2393
01:19:32,000 --> 01:19:33,000
这个是讲什么

2394
01:19:33,000 --> 01:19:34,000
smoke test

2395
01:19:35,000 --> 01:19:37,000
smoke testing 实际上大家每天都在做

2396
01:19:37,000 --> 01:19:39,000
或者经常会做

2397
01:19:39,000 --> 01:19:42,000
比如说你装好了 Royal Rails

2398
01:19:42,000 --> 01:19:43,000
然后你

2399
01:19:43,000 --> 01:19:44,000
呃

2400
01:19:44,000 --> 01:19:46,000
开始运行服务器

2401
01:19:46,000 --> 01:19:48,000
打开流感器

2402
01:19:48,000 --> 01:19:49,000
输入 localhost 8080

2403
01:19:49,000 --> 01:19:50,000
回车

2404
01:19:50,000 --> 01:19:50,000
诶

2405
01:19:50,000 --> 01:19:52,000
屏幕上出现了这个

2406
01:19:52,000 --> 01:19:54,000
it works 之类的这么一个

2407
01:19:55,000 --> 01:19:56,000
一个表示说

2408
01:19:56,000 --> 01:19:57,000
这个东西开始运行了

2409
01:19:57,000 --> 01:19:58,000
这么一个提示

2410
01:19:59,000 --> 01:20:01,000
这就是这个过程就是一个 smoke test

2411
01:20:01,000 --> 01:20:03,000
这个 smoke 是和

2412
01:20:03,000 --> 01:20:04,000
怎么一个说法

2413
01:20:05,000 --> 01:20:05,000
呃

2414
01:20:05,000 --> 01:20:06,000
它应该是

2415
01:20:06,000 --> 01:20:08,000
介于

2416
01:20:08,000 --> 01:20:11,000
介用自另外一个领域

2417
01:20:11,000 --> 01:20:12,000
我忘了是哪个领域

2418
01:20:12,000 --> 01:20:13,000
是矿东还是什么

2419
01:20:14,000 --> 01:20:15,000
呃

2420
01:20:15,000 --> 01:20:17,000
公种的一个既有的测试

2421
01:20:17,000 --> 01:20:18,000
就是

2422
01:20:18,000 --> 01:20:19,000
如果你看到冒烟了

2423
01:20:19,000 --> 01:20:21,000
说明这个东西是已经开始正常

2424
01:20:21,000 --> 01:20:23,000
好像是孤独之类的

2425
01:20:23,000 --> 01:20:25,000
一个非常古老的

2426
01:20:25,000 --> 01:20:26,000
术语

2427
01:20:26,000 --> 01:20:27,000
发烟测试

2428
01:20:27,000 --> 01:20:30,000
确定不是摩托车之类的吗

2429
01:20:30,000 --> 01:20:31,000
该不是摩托车吧

2430
01:20:31,000 --> 01:20:33,000
摩托车冒烟的肯定是有故障

2431
01:20:33,000 --> 01:20:34,000
哈哈哈哈

2432
01:20:35,000 --> 01:20:36,000
好吧

2433
01:20:36,000 --> 01:20:38,000
发烟测试指的就是你在

2434
01:20:38,000 --> 01:20:38,000
呃

2435
01:20:38,000 --> 01:20:39,000
你在试一个东西

2436
01:20:39,000 --> 01:20:41,000
你想要看一看它的那些

2437
01:20:41,000 --> 01:20:42,000
最为 critical

2438
01:20:42,000 --> 01:20:43,000
最为基本的

2439
01:20:44,000 --> 01:20:45,000
功能是不是运行

2440
01:20:45,000 --> 01:20:45,000
比如说你

2441
01:20:45,000 --> 01:20:47,000
你想知道

2442
01:20:48,000 --> 01:20:50,000
你想知道来电了没有

2443
01:20:50,000 --> 01:20:51,000
或者说你想知道是不是停电了

2444
01:20:51,000 --> 01:20:54,000
你去搬一个电动的开关

2445
01:20:54,000 --> 01:20:56,000
这就是一种 smoke testing

2446
01:20:56,000 --> 01:20:57,000
因为它

2447
01:20:57,000 --> 01:20:59,000
所测试的并不是你家整个电路

2448
01:20:59,000 --> 01:21:00,000
是不是完好无缺

2449
01:21:00,000 --> 01:21:02,000
是不是有地方有破损

2450
01:21:02,000 --> 01:21:03,000
是不是有地方电阻太高

2451
01:21:03,000 --> 01:21:04,000
是不是有可能

2452
01:21:04,000 --> 01:21:06,000
有火灾的风险

2453
01:21:06,000 --> 01:21:07,000
它唯一测试的就是

2454
01:21:07,000 --> 01:21:09,000
你家的电路是不是在运行

2455
01:21:10,000 --> 01:21:10,000
但是

2456
01:21:10,000 --> 01:21:13,000
狭义的测试则是不包括刚才说的

2457
01:21:13,000 --> 01:21:15,000
比如说 penetration testing

2458
01:21:15,000 --> 01:21:16,000
或者 smoke testing

2459
01:21:17,000 --> 01:21:17,000
呃

2460
01:21:17,000 --> 01:21:19,000
狭义的测试其实

2461
01:21:19,000 --> 01:21:22,000
如果要用比较简单的语言来说

2462
01:21:22,000 --> 01:21:22,000
就是

2463
01:21:25,000 --> 01:21:26,000
让你知道

2464
01:21:26,000 --> 01:21:30,000
让你有种可以重复的方法

2465
01:21:30,000 --> 01:21:33,000
来知道自己写的软件是

2466
01:21:34,000 --> 01:21:35,000
按照你

2467
01:21:35,000 --> 01:21:37,000
所希望的那些

2468
01:21:38,000 --> 01:21:40,000
方式而运行的一系列东西

2469
01:21:40,000 --> 01:21:41,000
就会叫做测试

2470
01:21:42,000 --> 01:21:43,000
刚才讲了各种各样的测试

2471
01:21:43,000 --> 01:21:44,000
测试的

2472
01:21:45,000 --> 01:21:46,000
主要的一个目的是什么

2473
01:21:46,000 --> 01:21:47,000
主要的目的是什么

2474
01:21:47,000 --> 01:21:49,000
基本上就是要

2475
01:21:49,000 --> 01:21:49,000
呃

2476
01:21:49,000 --> 01:21:52,000
基本上测试的意义就是让你有一个

2477
01:21:52,000 --> 01:21:54,000
有一个可以度量的准

2478
01:21:54,000 --> 01:21:55,000
就是你

2479
01:21:55,000 --> 01:21:56,000
因为我们知道

2480
01:21:56,000 --> 01:21:58,000
你写了一个程序之后

2481
01:21:58,000 --> 01:21:59,000
你会说让这个程序

2482
01:21:59,000 --> 01:22:01,000
看起来是正确的

2483
01:22:01,000 --> 01:22:04,000
或者说他在大部分情况下也都是正确的

2484
01:22:04,000 --> 01:22:05,000
但是你

2485
01:22:05,000 --> 01:22:07,000
怎么样才能有一种比较

2486
01:22:07,000 --> 01:22:09,000
可以验证的客观的

2487
01:22:09,000 --> 01:22:11,000
可以量化的

2488
01:22:11,000 --> 01:22:12,000
指标来告诉你说

2489
01:22:12,000 --> 01:22:14,000
对这个软件的确是可以工作的呢

2490
01:22:15,000 --> 01:22:16,000
这就是测试了

2491
01:22:16,000 --> 01:22:19,000
就是你为了获得一些特定的指标

2492
01:22:19,000 --> 01:22:19,000
而对

2493
01:22:19,000 --> 01:22:21,000
你写好的软件

2494
01:22:21,000 --> 01:22:23,000
采取了一系列度量的方法

2495
01:22:24,000 --> 01:22:25,000
就是测试

2496
01:22:26,000 --> 01:22:28,000
所以就是其实它是一个质量的

2497
01:22:28,000 --> 01:22:29,000
就 QA 的概念

2498
01:22:30,000 --> 01:22:31,000
呃对

2499
01:22:31,000 --> 01:22:33,000
早期的

2500
01:22:34,000 --> 01:22:36,000
早期的测试

2501
01:22:36,000 --> 01:22:39,000
呃是为了验证程序的

2502
01:22:39,000 --> 01:22:40,000
behaviour 是不是正确

2503
01:22:41,000 --> 01:22:44,000
而后期比如说现今的测试

2504
01:22:44,000 --> 01:22:46,000
很大程度上已经变成一种

2505
01:22:47,000 --> 01:22:48,000
呃

2506
01:22:48,000 --> 01:22:49,000
质检的关卡

2507
01:22:49,000 --> 01:22:51,000
就是我们知道有一个

2508
01:22:53,000 --> 01:22:54,000
呃验证体系应该是

2509
01:22:55,000 --> 01:22:57,000
RSO 9000 吧

2510
01:22:57,000 --> 01:23:00,000
在软件界好像还有一个另外的编号 92

2511
01:23:01,000 --> 01:23:02,000
然后这个

2512
01:23:02,000 --> 01:23:05,000
认证体系很大一个指标就是要看

2513
01:23:05,000 --> 01:23:08,000
你这个软件公司的测试

2514
01:23:09,000 --> 01:23:09,000
有没有写

2515
01:23:09,000 --> 01:23:11,000
如果有的话是什么样的能在写

2516
01:23:11,000 --> 01:23:13,000
然后有没有一个专门的

2517
01:23:13,000 --> 01:23:16,000
负责把关的部门来去

2518
01:23:16,000 --> 01:23:18,000
盯住去盯这些测试

2519
01:23:19,000 --> 01:23:20,000
嗯注册此类

2520
01:23:20,000 --> 01:23:20,000
对

2521
01:23:20,000 --> 01:23:23,000
如今测试已经成了一个特别重要的一个

2522
01:23:23,000 --> 01:23:25,000
一个软件工程里面的环节

2523
01:23:26,000 --> 01:23:28,000
然后测试又可以分为呃

2524
01:23:28,000 --> 01:23:31,000
功能性的测试以及非功能性的测试

2525
01:23:31,000 --> 01:23:33,000
也就是说狭义上的测试

2526
01:23:33,000 --> 01:23:35,000
又可以分为功能性的测试和非功能性的

2527
01:23:35,000 --> 01:23:36,000
非功能性的测试

2528
01:23:36,000 --> 01:23:39,000
呃功能性的测试也就是说比如说你啊

2529
01:23:39,000 --> 01:23:40,000
你写了一个函数

2530
01:23:40,000 --> 01:23:41,000
这个函数可以返回两个

2531
01:23:42,000 --> 01:23:43,000
数值的合

2532
01:23:43,000 --> 01:23:46,000
然后你写所谓功能性的测试就是你

2533
01:23:46,000 --> 01:23:47,000
输入三和四

2534
01:23:47,000 --> 01:23:49,000
然后看这个函数是不是返回七

2535
01:23:50,000 --> 01:23:50,000
对

2536
01:23:50,000 --> 01:23:53,000
有比如说你你写了一个

2537
01:23:53,000 --> 01:23:55,000
呃除法的函数

2538
01:23:55,000 --> 01:23:57,000
然后你输入一和零想要看这个

2539
01:23:58,000 --> 01:24:00,000
函数会不会返回说除零错

2540
01:24:01,000 --> 01:24:02,000
那这是一种功能性的测试

2541
01:24:02,000 --> 01:24:05,000
而非功能性的测试则是比如说

2542
01:24:05,000 --> 01:24:06,000
看你这个函数的

2543
01:24:07,000 --> 01:24:08,000
执行的速度怎么样

2544
01:24:08,000 --> 01:24:09,000
比如说你写了一个

2545
01:24:09,000 --> 01:24:12,000
加法的函数是正确的没错

2546
01:24:12,000 --> 01:24:13,000
但是它需要一天才能得出结果

2547
01:24:14,000 --> 01:24:17,000
那这样的函数可能

2548
01:24:17,000 --> 01:24:19,000
没有办法通过所谓功能性的测试来

2549
01:24:19,000 --> 01:24:23,000
验证它对功能性的测试会告诉你说它没问题

2550
01:24:23,000 --> 01:24:25,000
但是一一旦你去做一个

2551
01:24:25,000 --> 01:24:27,000
呃 performance testing

2552
01:24:27,000 --> 01:24:30,000
那你会立刻意识到这样的函数是完全不过关的

2553
01:24:31,000 --> 01:24:32,000
有比如说这个

2554
01:24:32,000 --> 01:24:35,000
performance testing 其实有一个专门的数

2555
01:24:35,000 --> 01:24:36,000
我们叫做 benchmark 对吧

2556
01:24:36,000 --> 01:24:37,000
可以这么说对

2557
01:24:38,000 --> 01:24:38,000
嗯

2558
01:24:39,000 --> 01:24:42,000
然后其实就这么说

2559
01:24:42,000 --> 01:24:42,000
就是这么算

2560
01:24:42,000 --> 01:24:44,000
其实 benchmark 是测试的一个

2561
01:24:45,000 --> 01:24:47,000
子级嗯

2562
01:24:47,000 --> 01:24:48,000
怎么说呢

2563
01:24:48,000 --> 01:24:52,000
performance testing 可以归类为

2564
01:24:52,000 --> 01:24:54,000
profiling 的一种

2565
01:24:54,000 --> 01:24:58,000
而 benchmark 则是 profiling 的一个指标

2566
01:24:58,000 --> 01:25:02,000
所以我倾向于认为两者还是有

2567
01:25:03,000 --> 01:25:04,000
多少有点不一样的

2568
01:25:05,000 --> 01:25:05,000
OK

2569
01:25:07,000 --> 01:25:08,000
因为嗯

2570
01:25:10,000 --> 01:25:14,000
当然也是可以用 benchmark 最终的分数来作为

2571
01:25:14,000 --> 01:25:17,000
performance testing 的一个指标也没错

2572
01:25:18,000 --> 01:25:19,000
那这不重要

2573
01:25:19,000 --> 01:25:23,000
因为我们本次节目所要集中的这个

2574
01:25:23,000 --> 01:25:26,000
呃话题其实是在狭义的

2575
01:25:26,000 --> 01:25:29,000
非呃功能性测试上面

2576
01:25:29,000 --> 01:25:30,000
而不是非功能性测试

2577
01:25:30,000 --> 01:25:32,000
因为非功能测试可以

2578
01:25:32,000 --> 01:25:35,000
可能涉及到的面实在是太广太广了

2579
01:25:36,000 --> 01:25:37,000
呃对

2580
01:25:37,000 --> 01:25:41,000
因为软件工程本身就是一个非常非常广的话题机

2581
01:25:41,000 --> 01:25:43,000
而测试又是软件工程上面

2582
01:25:44,000 --> 01:25:45,000
相当大的一个分支

2583
01:25:45,000 --> 01:25:50,000
我们显然不可能在一个预计时间只有两个小时

2584
01:25:51,000 --> 01:25:53,000
左右的节目里面把

2585
01:25:53,000 --> 01:25:55,000
呃面无面与剧道的吧

2586
01:25:55,000 --> 01:25:57,000
测试每一方面都谈到

2587
01:25:57,000 --> 01:26:00,000
所以我们这次主要的集中的

2588
01:26:01,000 --> 01:26:04,000
呃主题还是在功能性测试上

2589
01:26:05,000 --> 01:26:09,000
而且功能性测试里面我们应该只会谈及呃

2590
01:26:10,000 --> 01:26:11,000
unit test 就是单元测试

2591
01:26:12,000 --> 01:26:15,000
呃以及部分的所谓

2592
01:26:15,000 --> 01:26:17,000
呃 acceptance test

2593
01:26:17,000 --> 01:26:19,000
也就是接受性测试

2594
01:26:19,000 --> 01:26:22,000
我不知道是什么交接测试还是

2595
01:26:23,000 --> 01:26:24,000
中文术语是什么忘记了

2596
01:26:25,000 --> 01:26:26,000
没关系

2597
01:26:26,000 --> 01:26:27,000
anyway 对

2598
01:26:28,000 --> 01:26:31,000
嗯所以 Ryo 你写测试吗

2599
01:26:31,000 --> 01:26:34,000
呃很惭愧我不写

2600
01:26:35,000 --> 01:26:36,000
伟大的成员都是不写测试

2601
01:26:36,000 --> 01:26:37,000
这话我现在

2602
01:26:37,000 --> 01:26:41,000
不是我我一直就在想了解这么一个事啊

2603
01:26:41,000 --> 01:26:42,000
就是说

2604
01:26:42,000 --> 01:26:43,000
我们经常有这个

2605
01:26:43,000 --> 01:26:46,000
也有一种开发程序的思路叫做

2606
01:26:46,000 --> 01:26:47,000
test driven development ttd 嘛对吧

2607
01:26:47,000 --> 01:26:48,000
对

2608
01:26:48,000 --> 01:26:51,000
我一直很好奇这事靠谱吗

2609
01:26:51,000 --> 01:26:52,000
就这么说吧

2610
01:26:53,000 --> 01:26:54,000
如果我们把软件工程

2611
01:26:54,000 --> 01:26:56,000
真的作为一项工程来讲

2612
01:26:56,000 --> 01:26:58,000
我们会这么去想它就是

2613
01:26:58,000 --> 01:27:00,000
你修一栋楼

2614
01:27:00,000 --> 01:27:02,000
你会说哎这个楼我们算出来它的

2615
01:27:02,000 --> 01:27:04,000
乘重是比如说 1000 吨

2616
01:27:05,000 --> 01:27:06,000
某一层对吧

2617
01:27:06,000 --> 01:27:08,000
我们知道这个数字是靠谱

2618
01:27:08,000 --> 01:27:09,000
反正就举随便举一个 1000 吨

2619
01:27:09,000 --> 01:27:11,000
然后我们会从力学结构上计算出它

2620
01:27:11,000 --> 01:27:13,000
没错它确实可以

2621
01:27:13,000 --> 01:27:14,000
这个承受 1000 吨

2622
01:27:14,000 --> 01:27:16,000
就是从物理算数

2623
01:27:16,000 --> 01:27:18,000
这个怎么就是公式算出来就这么多

2624
01:27:18,000 --> 01:27:20,000
但我们不会真的弄一千东西上去

2625
01:27:20,000 --> 01:27:22,000
给它实际压一下对吧

2626
01:27:23,000 --> 01:27:24,000
嗯

2627
01:27:26,000 --> 01:27:27,000
是这样说没错

2628
01:27:27,000 --> 01:27:28,000
但我有办法反驳你

2629
01:27:28,000 --> 01:27:30,000
你还有别的要说的吗

2630
01:27:30,000 --> 01:27:32,000
没有我这是就在这个思路说下去

2631
01:27:32,000 --> 01:27:33,000
就说

2632
01:27:33,000 --> 01:27:35,000
其实有很多事情

2633
01:27:35,000 --> 01:27:37,000
我们是没有办法

2634
01:27:37,000 --> 01:27:40,000
去真的去实践那个条件去测的

2635
01:27:40,000 --> 01:27:42,000
就是有些所谓的 edge cases 对吧

2636
01:27:42,000 --> 01:27:43,000
但是软件不一样

2637
01:27:43,000 --> 01:27:45,000
因为软件很适合

2638
01:27:45,000 --> 01:27:46,000
模拟各种情况出来

2639
01:27:46,000 --> 01:27:47,000
你都可以

2640
01:27:47,000 --> 01:27:49,000
就是说你一千多产母币

2641
01:27:49,000 --> 01:27:50,000
输个多加个零一万吨

2642
01:27:50,000 --> 01:27:52,000
我都可以给你测出来

2643
01:27:52,000 --> 01:27:53,000
没有问题

2644
01:27:53,000 --> 01:27:54,000
但我觉得这个

2645
01:27:54,000 --> 01:27:57,000
我一直很好奇这会不会让人变得

2646
01:27:57,000 --> 01:27:58,000
奇怪

2647
01:27:58,000 --> 01:27:59,000
变得或者变得懒

2648
01:27:59,000 --> 01:28:01,000
因为我一直觉得

2649
01:28:01,000 --> 01:28:03,000
你要保证软件质量

2650
01:28:03,000 --> 01:28:05,000
测试当然是少不了一个环节

2651
01:28:05,000 --> 01:28:07,000
但是这个不是最根本的问题

2652
01:28:07,000 --> 01:28:09,000
最根本的问题是你在设计的时候

2653
01:28:09,000 --> 01:28:10,000
就要想好

2654
01:28:10,000 --> 01:28:13,000
在理论上可不可能会出现这种问题

2655
01:28:13,000 --> 01:28:14,000
就或者说这么说吧

2656
01:28:14,000 --> 01:28:15,000
你写了一个函数

2657
01:28:15,000 --> 01:28:18,000
它有多少种可能的进入方法

2658
01:28:18,000 --> 01:28:20,000
有多少种可能的退出方法

2659
01:28:20,000 --> 01:28:23,000
中间有多少种可能的出现异常的

2660
01:28:23,000 --> 01:28:24,000
这个原因

2661
01:28:24,000 --> 01:28:25,000
我们把这些都

2662
01:28:25,000 --> 01:28:27,000
每一个都考虑过了

2663
01:28:27,000 --> 01:28:28,000
我们在写函数

2664
01:28:28,000 --> 01:28:30,000
就才可以说它是一个

2665
01:28:31,000 --> 01:28:32,000
无错的

2666
01:28:32,000 --> 01:28:34,000
一定是证明过

2667
01:28:34,000 --> 01:28:34,000
确实是

2668
01:28:35,000 --> 01:28:36,000
被

2669
01:28:36,000 --> 01:28:38,000
证明过确实是没有

2670
01:28:38,000 --> 01:28:39,000
你所有的

2671
01:28:39,000 --> 01:28:40,000
路径都考虑了

2672
01:28:40,000 --> 01:28:41,000
没有一个漏掉的东西

2673
01:28:41,000 --> 01:28:43,000
这个时候你不用写测试了

2674
01:28:43,000 --> 01:28:44,000
因为你在设计的阶段

2675
01:28:44,000 --> 01:28:46,000
你已经把所有的可能性都考虑过了

2676
01:28:47,000 --> 01:28:48,000
但是

2677
01:28:48,000 --> 01:28:50,000
做这件事情本身可能是比较难的

2678
01:28:51,000 --> 01:28:51,000
就是说

2679
01:28:51,000 --> 01:28:53,000
特别是软件工程大了之后

2680
01:28:53,000 --> 01:28:54,000
你可能不可能面面俱到

2681
01:28:54,000 --> 01:28:55,000
对吧

2682
01:28:55,000 --> 01:28:56,000
所以我们才要测试一些

2683
01:28:56,000 --> 01:28:57,000
选择一些点

2684
01:28:58,000 --> 01:28:59,000
就是说

2685
01:28:59,000 --> 01:29:00,000
做统计抽样的办法

2686
01:29:00,000 --> 01:29:02,000
我们假设如果这些点过了之后

2687
01:29:02,000 --> 01:29:04,000
我们有较大的信心认为

2688
01:29:04,000 --> 01:29:05,000
这个东西是

2689
01:29:05,000 --> 01:29:06,000
设计上是没有问题的

2690
01:29:06,000 --> 01:29:08,000
但是和我刚才讲的那种修楼

2691
01:29:08,000 --> 01:29:10,000
修楼你用力学公式

2692
01:29:11,000 --> 01:29:12,000
结构力学算出来之后

2693
01:29:12,000 --> 01:29:14,000
它肯定能承受这么多

2694
01:29:14,000 --> 01:29:18,000
然后我们并不需要真的去加上极限的重量去测

2695
01:29:18,000 --> 01:29:20,000
它能不能实际承受那么多

2696
01:29:20,000 --> 01:29:21,000
是一个概念

2697
01:29:21,000 --> 01:29:22,000
就是说我们能够算出来之后

2698
01:29:22,000 --> 01:29:24,000
我们不需要真的去做那些测试

2699
01:29:24,000 --> 01:29:24,000
所以

2700
01:29:25,000 --> 01:29:26,000
我一直很好奇

2701
01:29:26,000 --> 01:29:28,000
我们是不是把测试的

2702
01:29:29,000 --> 01:29:31,000
功能想得太伟大了

2703
01:29:31,000 --> 01:29:32,000
我就说测试的重点

2704
01:29:32,000 --> 01:29:35,000
它倒而把从设计

2705
01:29:35,000 --> 01:29:38,000
从原理层面的东西放的抓一点太少

2706
01:29:43,000 --> 01:29:43,000
槽点太多

2707
01:29:43,000 --> 01:29:45,000
不知道从哪突起

2708
01:29:46,000 --> 01:29:46,000
没事

2709
01:29:46,000 --> 01:29:48,000
开玩笑

2710
01:29:48,000 --> 01:29:48,000
我这个就是

2711
01:29:49,000 --> 01:29:51,000
我其实我还是很

2712
01:29:51,000 --> 01:29:53,000
比较认同你的看法

2713
01:29:53,000 --> 01:29:53,000
说实话

2714
01:29:53,000 --> 01:29:54,000
因为

2715
01:29:58,000 --> 01:29:58,000
这么说

2716
01:29:58,000 --> 01:30:02,000
我其实对于测试一直是抱有多多少少有点抵触情绪

2717
01:30:05,000 --> 01:30:08,000
甚至我自己也不是一个非常喜欢写测试的人

2718
01:30:08,000 --> 01:30:10,000
但是我必须反驳你的一点

2719
01:30:10,000 --> 01:30:15,000
就是你觉得测试似乎在软件工程里面被高估了

2720
01:30:15,000 --> 01:30:17,000
而我则觉得

2721
01:30:17,000 --> 01:30:20,000
从目前大部分软件的水平来看

2722
01:30:20,000 --> 01:30:21,000
它应该是被低估

2723
01:30:24,000 --> 01:30:26,000
拿回你这个钢结构的例子

2724
01:30:26,000 --> 01:30:28,000
就是你的建筑的例子

2725
01:30:28,000 --> 01:30:30,000
就是你会说你设计这一层

2726
01:30:31,000 --> 01:30:32,000
它的

2727
01:30:34,000 --> 01:30:35,000
应力可能是

2728
01:30:36,000 --> 01:30:39,000
2000 吨或者是多重

2729
01:30:39,000 --> 01:30:42,000
但是你之所以能得出这个

2730
01:30:43,000 --> 01:30:45,000
数值本身其实就是因为

2731
01:30:45,000 --> 01:30:49,000
用来搭这个建筑的钢材

2732
01:30:50,000 --> 01:30:52,000
真的经历过

2733
01:30:52,000 --> 01:30:55,000
在一个比较小的规模上的应力测试

2734
01:30:56,000 --> 01:30:59,000
你才可以拿到钢材相关的数据

2735
01:30:59,000 --> 01:31:03,000
然后你才能算出钢材在什么样的高度

2736
01:31:03,000 --> 01:31:04,000
什么样的长度

2737
01:31:04,000 --> 01:31:06,000
什么样的直径上面能够承受多大的重力

2738
01:31:09,000 --> 01:31:10,000
在现实生活里面

2739
01:31:10,000 --> 01:31:11,000
在实体世界里面

2740
01:31:11,000 --> 01:31:15,000
有很多东西的数值真的不是可以算出来的

2741
01:31:15,000 --> 01:31:16,000
比如说化学或者是

2742
01:31:16,000 --> 01:31:17,000
当然这个是扯远

2743
01:31:17,000 --> 01:31:20,000
但就很大一部分程度上

2744
01:31:20,000 --> 01:31:23,000
我们对于很多材料的认知

2745
01:31:23,000 --> 01:31:25,000
都是非常愚蠢的

2746
01:31:25,000 --> 01:31:29,000
去在实验室里面不停的去试出来

2747
01:31:31,000 --> 01:31:33,000
包括合金或者是

2748
01:31:34,000 --> 01:31:35,000
算了不说这些了

2749
01:31:35,000 --> 01:31:37,000
但总之最重要的一点就是

2750
01:31:37,000 --> 01:31:41,000
在现实生活里面测试本身就已经是一个

2751
01:31:41,000 --> 01:31:43,000
比较 fundamental 的东西

2752
01:31:43,000 --> 01:31:44,000
它如此思维见贯

2753
01:31:44,000 --> 01:31:46,000
以至于你有可能

2754
01:31:47,000 --> 01:31:48,000
不会去重视它

2755
01:31:48,000 --> 01:31:49,000
因为

2756
01:31:50,000 --> 01:31:52,000
如果你是一个建筑工人的话

2757
01:31:52,000 --> 01:31:54,000
或者如果你是一个材料

2758
01:31:55,000 --> 01:31:56,000
力学专家的话

2759
01:31:56,000 --> 01:31:59,000
你可能会觉得我在软件里面拖一拖

2760
01:31:59,000 --> 01:32:00,000
线图

2761
01:32:00,000 --> 01:32:03,000
然后它自动部就会帮我估算出来

2762
01:32:03,000 --> 01:32:05,000
这个东西大概有什么样的

2763
01:32:05,000 --> 01:32:07,000
能够承受多大的重量

2764
01:32:07,000 --> 01:32:10,000
但实际上这个数值本身就是

2765
01:32:11,000 --> 01:32:13,000
首先通过测试才能得到的

2766
01:32:15,000 --> 01:32:18,000
然后这个是其实对应软件的

2767
01:32:18,000 --> 01:32:20,000
所谓的 unit test

2768
01:32:20,000 --> 01:32:22,000
保证每一个结构

2769
01:32:22,000 --> 01:32:23,000
就每一个 component

2770
01:32:23,000 --> 01:32:25,000
每一个组件是正确的

2771
01:32:27,000 --> 01:32:28,000
是意思吗

2772
01:32:28,000 --> 01:32:29,000
差不多吧

2773
01:32:29,000 --> 01:32:33,000
但实际上软件的 unit test

2774
01:32:33,000 --> 01:32:37,000
更如果一定要在建筑里面找出一个对应的话

2775
01:32:37,000 --> 01:32:40,000
可能更像是说

2776
01:32:40,000 --> 01:32:42,000
OK 我为这个楼设计了

2777
01:32:45,000 --> 01:32:46,000
一层

2778
01:32:46,000 --> 01:32:47,000
然后我要在

2779
01:32:48,000 --> 01:32:49,000
我就想起萧姐姐说的

2780
01:32:49,000 --> 01:32:52,000
对萧姐姐说的那个体育馆的意思吧

2781
01:32:53,000 --> 01:32:54,000
它设计了一个体育馆

2782
01:32:54,000 --> 01:32:57,000
然后体育馆里面每一层要摆上 20 个厕所

2783
01:32:59,000 --> 01:33:02,000
unit test 更像是说

2784
01:33:02,000 --> 01:33:03,000
把每一个厕所

2785
01:33:04,000 --> 01:33:07,000
假如每一个厕所都可以做成一个预购件的话

2786
01:33:08,000 --> 01:33:10,000
把每一个厕所的预购件拿出来

2787
01:33:10,000 --> 01:33:12,000
单独给它通上水通上电

2788
01:33:12,000 --> 01:33:13,000
然后

2789
01:33:14,000 --> 01:33:15,000
你进去使用一次

2790
01:33:15,000 --> 01:33:17,000
然后看它能不能充水

2791
01:33:20,000 --> 01:33:22,000
或者说你进去用一次之后

2792
01:33:22,000 --> 01:33:24,000
看看它有没有什么不合理的地方

2793
01:33:24,000 --> 01:33:26,000
这才更接近一个 unit test

2794
01:33:27,000 --> 01:33:27,000
然后

2795
01:33:28,000 --> 01:33:29,000
最重要的一点就是

2796
01:33:29,000 --> 01:33:32,000
世界上没有两栋建筑是一模一样的

2797
01:33:33,000 --> 01:33:34,000
with 三个

2798
01:33:36,000 --> 01:33:38,000
脑中浮现出来

2799
01:33:38,000 --> 01:33:40,000
不是脑中浮现出的

2800
01:33:41,000 --> 01:33:43,000
社会主义国家里面那些非常

2801
01:33:43,000 --> 01:33:46,000
一个小七十多件都是一样的

2802
01:33:47,000 --> 01:33:50,000
有个笑话说把你截到一个中国三线城市

2803
01:33:51,000 --> 01:33:52,000
的郊区扔下来

2804
01:33:52,000 --> 01:33:55,000
给你一个小时的时间让你找出自己是在哪个城市

2805
01:33:55,000 --> 01:33:56,000
你是找不出来的

2806
01:34:01,000 --> 01:34:04,000
软件里面可能也是很多软件都彼此相似

2807
01:34:04,000 --> 01:34:05,000
但是

2808
01:34:05,000 --> 01:34:07,000
没有两个软件是彼此相同的

2809
01:34:07,000 --> 01:34:08,000
所以

2810
01:34:09,000 --> 01:34:10,000
如果你不写测试的话

2811
01:34:11,000 --> 01:34:16,000
很有可能在你认为这个软件的这一部分

2812
01:34:16,000 --> 01:34:17,000
应该

2813
01:34:17,000 --> 01:34:18,000
那样

2814
01:34:18,000 --> 01:34:19,000
工作的

2815
01:34:21,000 --> 01:34:23,000
这个想法本身就是没有办法验证

2816
01:34:23,000 --> 01:34:24,000
而且不成立

2817
01:34:24,000 --> 01:34:25,000
最终你会发现它是不成立

2818
01:34:27,000 --> 01:34:28,000
嗯

2819
01:34:30,000 --> 01:34:32,000
另外一个就是

2820
01:34:32,000 --> 01:34:34,000
有些软件是

2821
01:34:35,000 --> 01:34:36,000
无关紧要的

2822
01:34:36,000 --> 01:34:37,000
比如说你打一个 Hello World

2823
01:34:37,000 --> 01:34:41,000
然后你可能最后会漏了那个换行符

2824
01:34:41,000 --> 01:34:45,000
或者是你把 Hello World 打成了 HAL

2825
01:34:46,000 --> 01:34:47,000
这些都是无关紧要的

2826
01:34:47,000 --> 01:34:49,000
但是另外一些软件则是人命关天的

2827
01:34:49,000 --> 01:34:50,000
比如说你

2828
01:34:51,000 --> 01:34:52,000
你开着车

2829
01:34:54,000 --> 01:34:55,000
控制刹车的部分

2830
01:34:55,000 --> 01:34:57,000
或者是控制转向的部分

2831
01:34:57,000 --> 01:34:59,000
如果这个部分的软件出了问题

2832
01:34:59,000 --> 01:35:01,000
那很有可能是会死干的

2833
01:35:03,000 --> 01:35:05,000
我们之前请到了原浩哥哥

2834
01:35:05,000 --> 01:35:06,000
他

2835
01:35:06,000 --> 01:35:07,000
在

2836
01:35:07,000 --> 01:35:09,000
他所在的那一家 ElectroVid

2837
01:35:10,000 --> 01:35:12,000
所做的工作

2838
01:35:13,000 --> 01:35:16,000
之所以会非常强调测试

2839
01:35:16,000 --> 01:35:18,000
就是因为他们的软件

2840
01:35:18,000 --> 01:35:21,000
里面有四个人身伤害的标准

2841
01:35:21,000 --> 01:35:22,000
如果我没有起错的话

2842
01:35:22,000 --> 01:35:24,000
第一个标准是

2843
01:35:24,000 --> 01:35:26,000
这个软件如果出了问题

2844
01:35:27,000 --> 01:35:30,000
有可能这个标准的第一等级就是

2845
01:35:30,000 --> 01:35:32,000
如果这个软件出了问题

2846
01:35:32,000 --> 01:35:35,000
那可能会有一个人受伤

2847
01:35:36,000 --> 01:35:38,000
第二等级是如果这个软件出问题

2848
01:35:38,000 --> 01:35:40,000
可能会有一个人死亡

2849
01:35:41,000 --> 01:35:42,000
第三等级是如果这个软件出了问题

2850
01:35:42,000 --> 01:35:44,000
可能会有多个人受伤

2851
01:35:45,000 --> 01:35:48,000
第四等级就是可能会有多个人死亡

2852
01:35:48,000 --> 01:35:52,000
你看看人家的软件的危险标准是这么来的

2853
01:35:53,000 --> 01:35:56,000
在这样如果你是负责开发这样一个软件的话

2854
01:35:56,000 --> 01:35:57,000
那可能

2855
01:35:58,000 --> 01:35:58,000
不是可能

2856
01:35:58,000 --> 01:35:59,000
就是

2857
01:35:59,000 --> 01:36:01,000
任何级别的测试都是必不可少

2858
01:36:03,000 --> 01:36:05,000
所以其实面对这种

2859
01:36:05,000 --> 01:36:06,000
我理解你说那个意思

2860
01:36:06,000 --> 01:36:09,000
就是面对这种所谓的 mission critical 的组件

2861
01:36:09,000 --> 01:36:12,000
不是更应该从源头上去解决它的问题

2862
01:36:12,000 --> 01:36:14,000
而不是依赖过度依赖于测试吗

2863
01:36:17,000 --> 01:36:19,000
我刚才已经在试图绕开你的问题

2864
01:36:19,000 --> 01:36:21,000
就是你想说

2865
01:36:22,000 --> 01:36:24,000
好的架构可以取代测试

2866
01:36:26,000 --> 01:36:28,000
不这面有一个人要再解释一下

2867
01:36:28,000 --> 01:36:29,000
就是说

2868
01:36:31,000 --> 01:36:34,000
好的架构可以减轻对于测试的依赖

2869
01:36:34,000 --> 01:36:36,000
我觉得就是一个

2870
01:36:36,000 --> 01:36:38,000
验证一个软件正确性的方法

2871
01:36:38,000 --> 01:36:39,000
有两个

2872
01:36:39,000 --> 01:36:42,000
一个是你测出它所有的输入所有的输出

2873
01:36:42,000 --> 01:36:43,000
对吧

2874
01:36:43,000 --> 01:36:46,000
如果它这个输入输出是一个有限级的话

2875
01:36:46,000 --> 01:36:48,000
你看是不是符合你的预期

2876
01:36:48,000 --> 01:36:50,000
就是暴力穷局法

2877
01:36:50,000 --> 01:36:52,000
但是另外一个方法就是说

2878
01:36:53,000 --> 01:36:55,000
你跟他做那个逻辑分析

2879
01:36:55,000 --> 01:36:57,000
我们叫 formal verification

2880
01:36:58,000 --> 01:37:01,000
就是你给他一个描述

2881
01:37:01,000 --> 01:37:02,000
说他应该怎么怎么样

2882
01:37:02,000 --> 01:37:04,000
然后你通过一些正式的方法

2883
01:37:04,000 --> 01:37:06,000
叫 formal 这个叫什么来的

2884
01:37:06,000 --> 01:37:07,000
对

2885
01:37:07,000 --> 01:37:08,000
形式的方法

2886
01:37:08,000 --> 01:37:08,000
应该说

2887
01:37:08,000 --> 01:37:11,000
对形式的方法去证明他确实是

2888
01:37:11,000 --> 01:37:13,000
按照这种情况没有特例

2889
01:37:13,000 --> 01:37:14,000
没有考虑过的

2890
01:37:15,000 --> 01:37:16,000
对吧

2891
01:37:16,000 --> 01:37:17,000
所以

2892
01:37:17,000 --> 01:37:20,000
测试其实是在我说的前一种方法

2893
01:37:20,000 --> 01:37:22,000
就是去看他的输入输出

2894
01:37:22,000 --> 01:37:24,000
然后看我们选取一些点

2895
01:37:25,000 --> 01:37:26,000
比如说一些比较奇怪的点

2896
01:37:26,000 --> 01:37:27,000
看看会出现什么问题

2897
01:37:27,000 --> 01:37:28,000
选取一些正常的点

2898
01:37:28,000 --> 01:37:31,000
看他是不是产生符合我们预期的答案

2899
01:37:31,000 --> 01:37:32,000
然后选择一些奇怪的点

2900
01:37:32,000 --> 01:37:35,000
看看是不是出现我们预期的异常或者错误

2901
01:37:35,000 --> 01:37:36,000
对吧

2902
01:37:36,000 --> 01:37:38,000
但其实这个覆盖和

2903
01:37:38,000 --> 01:37:40,000
有一个 formal verification

2904
01:37:40,000 --> 01:37:41,000
就是正

2905
01:37:41,000 --> 01:37:42,000
叫什么来的

2906
01:37:42,000 --> 01:37:43,000
这不叫正式的

2907
01:37:43,000 --> 01:37:44,000
形式证明

2908
01:37:45,000 --> 01:37:46,000
对形式证明的

2909
01:37:46,000 --> 01:37:48,000
这个得色结论是完全不具为

2910
01:37:48,000 --> 01:37:49,000
像可比性的

2911
01:37:49,000 --> 01:37:50,000
因为一个是说

2912
01:37:50,000 --> 01:37:52,000
我们有 50%的

2913
01:37:52,000 --> 01:37:53,000
5%的把握证明

2914
01:37:54,000 --> 01:37:55,000
他们应该没有问题

2915
01:37:55,000 --> 01:37:55,000
好

2916
01:37:55,000 --> 01:37:56,000
好这边形式证明是说

2917
01:37:56,000 --> 01:37:59,000
我们百分之百确定他不会出错

2918
01:37:59,000 --> 01:38:00,000
有没有我意思吗

2919
01:38:00,000 --> 01:38:01,000
嗯

2920
01:38:02,000 --> 01:38:03,000
但我觉得有两点

2921
01:38:03,000 --> 01:38:05,000
首先第一点是

2922
01:38:05,000 --> 01:38:07,000
你通过形式证明

2923
01:38:08,000 --> 01:38:10,000
知晓了

2924
01:38:10,000 --> 01:38:13,000
这一个软件这样写应该没有问题

2925
01:38:13,000 --> 01:38:16,000
但是你仍旧没有办法确定说

2926
01:38:16,000 --> 01:38:18,000
你写出来的就一定

2927
01:38:18,000 --> 01:38:20,000
完全符合你的形式证明

2928
01:38:20,000 --> 01:38:20,000
比如说

2929
01:38:21,000 --> 01:38:22,000
你在某个地方多打了一个点

2930
01:38:22,000 --> 01:38:25,000
或者是在某一地方把加号写成个成号

2931
01:38:26,000 --> 01:38:29,000
这些东西都是没有办法通过形式证明来

2932
01:38:29,000 --> 01:38:30,000
唯一确认的

2933
01:38:32,000 --> 01:38:33,000
可以吧

2934
01:38:33,000 --> 01:38:36,000
如果你把那个 specification 写的足够

2935
01:38:37,000 --> 01:38:39,000
但你可以说这个界限就比较模糊了

2936
01:38:39,000 --> 01:38:39,000
对吧

2937
01:38:40,000 --> 01:38:42,000
如果这个 specification 就写得那么详细的

2938
01:38:43,000 --> 01:38:44,000
这不就是 BDD 吗

2939
01:38:44,000 --> 01:38:46,000
这不就是别人追问 development

2940
01:38:46,000 --> 01:38:50,000
这不就是测试先行驱动的一种特殊形式

2941
01:38:51,000 --> 01:38:53,000
然后其次第二点是

2942
01:38:54,000 --> 01:38:56,000
做形式分析是非常花时间的

2943
01:38:57,000 --> 01:38:59,000
而且很多时候是不可能的

2944
01:38:59,000 --> 01:39:00,000
对

2945
01:39:00,000 --> 01:39:02,000
而现代软件里面有很大的一个问题

2946
01:39:02,000 --> 01:39:03,000
你刚才说

2947
01:39:04,000 --> 01:39:05,000
如果你知道自己想要什么

2948
01:39:05,000 --> 01:39:08,000
但现在的问题就是在很多领域里面

2949
01:39:09,000 --> 01:39:12,000
最终负责验收业软件的那个人

2950
01:39:12,000 --> 01:39:13,000
是不知道自己要什么的

2951
01:39:14,000 --> 01:39:16,000
只有把它做出来才能知道自己要什么

2952
01:39:17,000 --> 01:39:20,000
这个可能就是学院派和工程派做事情的

2953
01:39:20,000 --> 01:39:22,000
不同的一个出发点我觉得

2954
01:39:22,000 --> 01:39:22,000
对

2955
01:39:22,000 --> 01:39:25,000
这就是 V 型模型

2956
01:39:25,000 --> 01:39:27,000
瀑布模型和螺旋模型

2957
01:39:27,000 --> 01:39:29,000
就是敏捷模型最大的区别

2958
01:39:30,000 --> 01:39:30,000
嗯

2959
01:39:31,000 --> 01:39:32,000
你要解释一下吗

2960
01:39:34,000 --> 01:39:35,000
这个好吧

2961
01:39:35,000 --> 01:39:38,000
有一个问题就是我没学过人家工程

2962
01:39:38,000 --> 01:39:39,000
你学过人家工程吗

2963
01:39:39,000 --> 01:39:40,000
你也没学过吧

2964
01:39:41,000 --> 01:39:41,000
对啊

2965
01:39:41,000 --> 01:39:41,000
对

2966
01:39:41,000 --> 01:39:43,000
本质上我是一个学通信的人

2967
01:39:43,000 --> 01:39:43,000
然后

2968
01:39:44,000 --> 01:39:46,000
本质上我不是学 CS 的人

2969
01:39:46,000 --> 01:39:46,000
对

2970
01:39:46,000 --> 01:39:47,000
好吧

2971
01:39:47,000 --> 01:39:49,000
我就一个个解释一下

2972
01:39:49,000 --> 01:39:50,000
所谓

2973
01:39:51,000 --> 01:39:53,000
瀑布模型的意思就是

2974
01:39:54,000 --> 01:39:56,000
你就像盖房子一样

2975
01:39:56,000 --> 01:39:58,000
一上来给你一个蓝图

2976
01:39:59,000 --> 01:40:00,000
假设你是业主

2977
01:40:00,000 --> 01:40:01,000
你

2978
01:40:02,000 --> 01:40:05,000
就像对我的同事正在盖房子

2979
01:40:05,000 --> 01:40:06,000
他经历的过程

2980
01:40:06,000 --> 01:40:09,000
首先你去一个设计师住所

2981
01:40:09,000 --> 01:40:11,000
说我买了一亩地

2982
01:40:11,000 --> 01:40:13,000
然后要在这亩地上盖一个房子

2983
01:40:13,000 --> 01:40:16,000
然后设计师公司说行

2984
01:40:16,000 --> 01:40:20,000
然后他拿这个小区的规划

2985
01:40:20,000 --> 01:40:22,000
比如说德国有些小区规定说房顶必须是尖的

2986
01:40:22,000 --> 01:40:26,000
然后尖的角度必须是多少度以上

2987
01:40:26,000 --> 01:40:27,000
呃

2988
01:40:27,000 --> 01:40:29,000
他拿了一大堆 regulation

2989
01:40:29,000 --> 01:40:30,000
然后帮你看一眼

2990
01:40:30,000 --> 01:40:31,000
说好

2991
01:40:31,000 --> 01:40:32,000
根据这些 regulation

2992
01:40:32,000 --> 01:40:33,000
我可以给你

2993
01:40:34,000 --> 01:40:34,000
呃

2994
01:40:35,000 --> 01:40:36,000
三个房型

2995
01:40:37,000 --> 01:40:39,000
然后你看着三个房型

2996
01:40:39,000 --> 01:40:40,000
然后看着三个房型的平面图

2997
01:40:40,000 --> 01:40:42,000
看着三个房型的效果图

2998
01:40:43,000 --> 01:40:45,000
看着三个房型的内部结构图

2999
01:40:45,000 --> 01:40:46,000
然后你说好

3000
01:40:46,000 --> 01:40:47,000
我觉得这间房子太小了

3001
01:40:47,000 --> 01:40:48,000
我要把它改大一点

3002
01:40:48,000 --> 01:40:49,000
blah blah blah

3003
01:40:49,000 --> 01:40:50,000
然后经过这一个过程

3004
01:40:51,000 --> 01:40:52,000
你最终确定一个方案

3005
01:40:52,000 --> 01:40:54,000
你要在这个方案上签字

3006
01:40:55,000 --> 01:40:55,000
然后

3007
01:40:56,000 --> 01:40:57,000
建中呃

3008
01:40:57,000 --> 01:40:58,000
这个设计公司把它

3009
01:40:58,000 --> 01:41:00,000
交给他们认识的一个包工头

3010
01:41:00,000 --> 01:41:01,000
然后包工头开始干

3011
01:41:01,000 --> 01:41:03,000
然后干上一段时间

3012
01:41:03,000 --> 01:41:04,000
你隔一段时间去看一看

3013
01:41:04,000 --> 01:41:06,000
然后这个呃

3014
01:41:06,000 --> 01:41:07,000
你

3015
01:41:07,000 --> 01:41:09,000
会看到他先挖一个坑

3016
01:41:09,000 --> 01:41:09,000
然后打地基

3017
01:41:09,000 --> 01:41:11,000
然后盖一层

3018
01:41:11,000 --> 01:41:11,000
盖第二层

3019
01:41:11,000 --> 01:41:12,000
把玉纸板插上

3020
01:41:12,000 --> 01:41:12,000
盖第三层

3021
01:41:12,000 --> 01:41:13,000
然后

3022
01:41:13,000 --> 01:41:15,000
呃外墙装修内装修

3023
01:41:15,000 --> 01:41:15,000
最后

3024
01:41:16,000 --> 01:41:17,000
水道取消

3025
01:41:18,000 --> 01:41:18,000
这么一个

3026
01:41:19,000 --> 01:41:21,000
你拿到了你拿到的一间

3027
01:41:21,000 --> 01:41:22,000
和自己最初的图纸

3028
01:41:22,000 --> 01:41:23,000
可能略有出入

3029
01:41:23,000 --> 01:41:25,000
但是基本上是你想象的那个样子

3030
01:41:25,000 --> 01:41:26,000
房子

3031
01:41:26,000 --> 01:41:28,000
这是一个在实体世界里面

3032
01:41:28,000 --> 01:41:29,000
非常司空见惯的事情

3033
01:41:29,000 --> 01:41:30,000
然后

3034
01:41:30,000 --> 01:41:32,000
在软件工程的早期

3035
01:41:32,000 --> 01:41:33,000
人们也的确是这样做的

3036
01:41:33,000 --> 01:41:35,000
就是一开始就找一些

3037
01:41:35,000 --> 01:41:37,000
最终会使用人家的人说

3038
01:41:37,000 --> 01:41:37,000
哦

3039
01:41:38,000 --> 01:41:39,000
你最终会拿到软件

3040
01:41:39,000 --> 01:41:40,000
可能是这个样子的

3041
01:41:40,000 --> 01:41:41,000
然后你按这个按钮

3042
01:41:41,000 --> 01:41:42,000
就会出现那个

3043
01:41:43,000 --> 01:41:44,000
呃

3044
01:41:44,000 --> 01:41:45,000
点这里就会做那个

3045
01:41:45,000 --> 01:41:47,000
然后按下这个按钮

3046
01:41:47,000 --> 01:41:49,000
然后核弹就会飞起来之类的

3047
01:41:51,000 --> 01:41:52,000
这所谓的需求文档吗

3048
01:41:52,000 --> 01:41:53,000
对

3049
01:41:53,000 --> 01:41:54,000
首先你有一套需求文档

3050
01:41:54,000 --> 01:41:56,000
就像房子的蓝图一样

3051
01:41:56,000 --> 01:41:59,000
接下来软件工程的团队开始施工

3052
01:41:59,000 --> 01:42:00,000
然后在这个施工过程中

3053
01:42:00,000 --> 01:42:01,000
你是没有办法去

3054
01:42:03,000 --> 01:42:04,000
勒令他们停下来

3055
01:42:04,000 --> 01:42:05,000
说不行

3056
01:42:05,000 --> 01:42:05,000
我不要这套房子了

3057
01:42:05,000 --> 01:42:06,000
我把它

3058
01:42:06,000 --> 01:42:07,000
呃

3059
01:42:07,000 --> 01:42:08,000
你给我扒了

3060
01:42:08,000 --> 01:42:09,000
把它重新建一面

3061
01:42:09,000 --> 01:42:10,000
或者说不对

3062
01:42:10,000 --> 01:42:11,000
这个地方我要

3063
01:42:11,000 --> 01:42:12,000
本来我是三层楼

3064
01:42:12,000 --> 01:42:14,000
然后我现在要改成五层

3065
01:42:14,000 --> 01:42:15,000
这些这些都是不行的

3066
01:42:15,000 --> 01:42:16,000
在那个

3067
01:42:16,000 --> 01:42:17,000
美好的时代

3068
01:42:17,000 --> 01:42:17,000
如果

3069
01:42:18,000 --> 01:42:19,000
如果你是一个

3070
01:42:19,000 --> 01:42:20,000
足够土豪的甲方

3071
01:42:20,000 --> 01:42:21,000
好像是可以的吧

3072
01:42:23,000 --> 01:42:24,000
呃

3073
01:42:25,000 --> 01:42:27,000
如果是一个足够土豪的甲方

3074
01:42:28,000 --> 01:42:30,000
你所面临的

3075
01:42:30,000 --> 01:42:33,000
损失仍旧远远不如

3076
01:42:33,000 --> 01:42:35,000
你从一开始就明确的知道

3077
01:42:35,000 --> 01:42:36,000
自己要什么要来

3078
01:42:36,000 --> 01:42:37,000
当然这个没错

3079
01:42:37,000 --> 01:42:38,000
如果你要

3080
01:42:38,000 --> 01:42:39,000
所以我觉得

3081
01:42:39,000 --> 01:42:40,000
瀑布这个词用的很好

3082
01:42:40,000 --> 01:42:41,000
就是你知道

3083
01:42:41,000 --> 01:42:42,000
瀑布的水就是往下走的对吧

3084
01:42:42,000 --> 01:42:44,000
它不会再回去了

3085
01:42:44,000 --> 01:42:44,000
你是

3086
01:42:44,000 --> 01:42:47,000
在这个瀑布模型里面的任何一步

3087
01:42:47,000 --> 01:42:48,000
你都是回不了头的

3088
01:42:48,000 --> 01:42:49,000
现在该反过来

3089
01:42:49,000 --> 01:42:50,000
呃

3090
01:42:50,000 --> 01:42:52,000
而反过来敏捷模型则是

3091
01:42:53,000 --> 01:42:56,000
在软件蓬勃发展的

3092
01:42:56,000 --> 01:42:57,000
90 年代

3093
01:42:58,000 --> 01:43:00,000
人们终于有

3094
01:43:00,000 --> 01:43:01,000
怎么说

3095
01:43:01,000 --> 01:43:02,000
更终有更多的人

3096
01:43:02,000 --> 01:43:04,000
可以有这个资本去

3097
01:43:05,000 --> 01:43:06,000
呃

3098
01:43:06,000 --> 01:43:07,000
买

3099
01:43:07,000 --> 01:43:08,000
或者说订购一套

3100
01:43:08,000 --> 01:43:10,000
属于他们自己的软件

3101
01:43:10,000 --> 01:43:11,000
比如说一些小商贩啊

3102
01:43:12,000 --> 01:43:13,000
一个小公司啊

3103
01:43:13,000 --> 01:43:14,000
可以有自己的

3104
01:43:14,000 --> 01:43:15,000
可以有自己的网站

3105
01:43:15,000 --> 01:43:17,000
或者是可以有自己专门的应用

3106
01:43:17,000 --> 01:43:18,000
呃

3107
01:43:18,000 --> 01:43:19,000
此时发生了一个问题

3108
01:43:19,000 --> 01:43:20,000
发生了一个问题

3109
01:43:20,000 --> 01:43:20,000
就是

3110
01:43:20,000 --> 01:43:22,000
早期的瀑布模型再也进不通了

3111
01:43:22,000 --> 01:43:24,000
因为很多很多人是

3112
01:43:25,000 --> 01:43:26,000
包括你和我

3113
01:43:26,000 --> 01:43:27,000
都是那些

3114
01:43:27,000 --> 01:43:28,000
都是

3115
01:43:28,000 --> 01:43:28,000
不知道

3116
01:43:28,000 --> 01:43:29,000
不知道自己要什么

3117
01:43:30,000 --> 01:43:32,000
对于自己的想象力和

3118
01:43:32,000 --> 01:43:33,000
怎么说

3119
01:43:33,000 --> 01:43:34,000
高估了自己的想象力

3120
01:43:34,000 --> 01:43:36,000
同时又低估了自己的野心

3121
01:43:36,000 --> 01:43:37,000
这边确实

3122
01:43:37,000 --> 01:43:38,000
可以站在那边

3123
01:43:38,000 --> 01:43:40,000
表达能力

3124
01:43:40,000 --> 01:43:40,000
对

3125
01:43:42,000 --> 01:43:43,000
有一点

3126
01:43:43,000 --> 01:43:44,000
呃

3127
01:43:44,000 --> 01:43:48,000
资本可以来做一个项目的验收方的时候

3128
01:43:48,000 --> 01:43:49,000
他们

3129
01:43:49,000 --> 01:43:51,000
你会发现这些人是完全没有

3130
01:43:51,000 --> 01:43:52,000
办法

3131
01:43:52,000 --> 01:43:53,000
在

3132
01:43:53,000 --> 01:43:54,000
呃

3133
01:43:54,000 --> 01:43:54,000
瀑布

3134
01:43:54,000 --> 01:43:56,000
瀑布模型之下工作的

3135
01:43:56,000 --> 01:43:57,000
无法验收

3136
01:43:57,000 --> 01:43:58,000
对

3137
01:43:58,000 --> 01:43:59,000
你开始给他

3138
01:44:00,000 --> 01:44:01,000
跟他答应了好好的一些东西

3139
01:44:01,000 --> 01:44:02,000
他

3140
01:44:02,000 --> 01:44:03,000
做了一半

3141
01:44:03,000 --> 01:44:05,000
你给他看一个半成品的时候

3142
01:44:05,000 --> 01:44:05,000
他说

3143
01:44:05,000 --> 01:44:06,000
我靠

3144
01:44:06,000 --> 01:44:07,000
我要的不是这样的

3145
01:44:08,000 --> 01:44:09,000
呃

3146
01:44:10,000 --> 01:44:12,000
在这种情况之下呢

3147
01:44:12,000 --> 01:44:12,000
呃

3148
01:44:12,000 --> 01:44:13,000
人们就推出一种叫做

3149
01:44:13,000 --> 01:44:14,000
呃

3150
01:44:14,000 --> 01:44:16,000
extreme program

3151
01:44:16,000 --> 01:44:16,000
或者说

3152
01:44:16,000 --> 01:44:17,000
对早期

3153
01:44:17,000 --> 01:44:18,000
对

3154
01:44:18,000 --> 01:44:20,000
extreme program 要早于 agile

3155
01:44:20,000 --> 01:44:21,000
改

3156
01:44:21,000 --> 01:44:21,000
呃

3157
01:44:21,000 --> 01:44:22,000
推出一种所谓

3158
01:44:23,000 --> 01:44:25,000
XP 就是极限编程的这么一种理念

3159
01:44:25,000 --> 01:44:27,000
就是在这种模型之下呢

3160
01:44:28,000 --> 01:44:28,000
呃

3161
01:44:28,000 --> 01:44:32,000
你一开始只问这个最终客户很小的一个问题

3162
01:44:32,000 --> 01:44:32,000
就说

3163
01:44:32,000 --> 01:44:32,000
呃

3164
01:44:32,000 --> 01:44:33,000
比如说

3165
01:44:34,000 --> 01:44:35,000
打个比方吧

3166
01:44:35,000 --> 01:44:36,000
你希望你的网站

3167
01:44:36,000 --> 01:44:38,000
你希望你的网站鸡色是什么颜色的

3168
01:44:38,000 --> 01:44:39,000
他说

3169
01:44:39,000 --> 01:44:39,000
哦

3170
01:44:39,000 --> 01:44:39,000
蓝色的

3171
01:44:40,000 --> 01:44:40,000
然后你好

3172
01:44:40,000 --> 01:44:41,000
嗯

3173
01:44:41,000 --> 01:44:42,000
写一个网页

3174
01:44:42,000 --> 01:44:44,000
然后把这个背景换成某种蓝色

3175
01:44:44,000 --> 01:44:45,000
说

3176
01:44:45,000 --> 01:44:45,000
这样吗

3177
01:44:46,000 --> 01:44:47,000
客户一看说

3178
01:44:47,000 --> 01:44:48,000
我靠

3179
01:44:48,000 --> 01:44:49,000
纯蓝色怎么这么丑

3180
01:44:49,000 --> 01:44:49,000
不行

3181
01:44:49,000 --> 01:44:50,000
我要粉红色

3182
01:44:51,000 --> 01:44:51,000
好

3183
01:44:51,000 --> 01:44:53,000
你马上就可以换成粉红色

3184
01:44:53,000 --> 01:44:54,000
然后

3185
01:44:54,000 --> 01:44:55,000
就算什么

3186
01:44:55,000 --> 01:44:55,000
就

3187
01:44:55,000 --> 01:44:57,000
也算是交互式编程了吧

3188
01:44:57,000 --> 01:44:57,000
对

3189
01:44:57,000 --> 01:44:59,000
这就是一个非常非常小的迭代

3190
01:45:00,000 --> 01:45:01,000
iteration

3191
01:45:01,000 --> 01:45:02,000
在这个过程之中

3192
01:45:02,000 --> 01:45:05,000
你首先确立了用户一个非常基本的需求

3193
01:45:05,000 --> 01:45:07,000
然后你把这个需求实现出来

3194
01:45:07,000 --> 01:45:10,000
实现出来这一部分最小的功能找客户去反馈

3195
01:45:11,000 --> 01:45:11,000
客户

3196
01:45:11,000 --> 01:45:12,000
他对你的反馈

3197
01:45:12,000 --> 01:45:13,000
如果是正的的话

3198
01:45:13,000 --> 01:45:14,000
你就可以继续做下去

3199
01:45:14,000 --> 01:45:15,000
如果是负的话你就要改

3200
01:45:16,000 --> 01:45:17,000
然后

3201
01:45:17,000 --> 01:45:18,000
把整个

3202
01:45:18,000 --> 01:45:19,000
软件工程的

3203
01:45:20,000 --> 01:45:20,000
呃

3204
01:45:21,000 --> 01:45:24,000
过程切分为很多很多这样的

3205
01:45:24,000 --> 01:45:25,000
很小的迭代过程

3206
01:45:26,000 --> 01:45:26,000
呃

3207
01:45:26,000 --> 01:45:28,000
如果你画成一个图的话

3208
01:45:28,000 --> 01:45:28,000
大概就是

3209
01:45:28,000 --> 01:45:30,000
一个越做越大的软件

3210
01:45:30,000 --> 01:45:31,000
不停地经历这样的

3211
01:45:31,000 --> 01:45:32,000
iteration

3212
01:45:32,000 --> 01:45:35,000
那最终画出来就是一个大概螺旋性的这么一个

3213
01:45:37,000 --> 01:45:37,000
哎

3214
01:45:37,000 --> 01:45:38,000
应该怎么说呢

3215
01:45:38,000 --> 01:45:39,000
进度图

3216
01:45:39,000 --> 01:45:40,000
对

3217
01:45:40,000 --> 01:45:41,000
这就是我

3218
01:45:41,000 --> 01:45:42,000
呃

3219
01:45:42,000 --> 01:45:43,000
这是我刚才提到的

3220
01:45:43,000 --> 01:45:45,000
铺模型和敏捷模型的区别

3221
01:45:45,000 --> 01:45:47,000
所以敏捷编程或者说

3222
01:45:48,000 --> 01:45:48,000
呃

3223
01:45:48,000 --> 01:45:51,000
极限编程所解决的问题就是

3224
01:45:51,000 --> 01:45:53,000
如何应对需求的改变

3225
01:45:54,000 --> 01:45:54,000
对吧

3226
01:45:55,000 --> 01:45:55,000
嗯

3227
01:45:55,000 --> 01:45:56,000
那

3228
01:45:56,000 --> 01:46:00,000
怎么才能知道一个需求的改变

3229
01:46:00,000 --> 01:46:02,000
有没有准确的在

3230
01:46:03,000 --> 01:46:03,000
呃

3231
01:46:04,000 --> 01:46:06,000
不管是被更改的软件也好

3232
01:46:06,000 --> 01:46:06,000
还是

3233
01:46:06,000 --> 01:46:09,000
刚刚写出来的软件的那

3234
01:46:09,000 --> 01:46:10,000
新的那一部分里面

3235
01:46:10,000 --> 01:46:12,000
正确的实现出来了呢

3236
01:46:13,000 --> 01:46:16,000
那这个时候软件测试的意义

3237
01:46:16,000 --> 01:46:17,000
也就凸显出来了

3238
01:46:18,000 --> 01:46:18,000
嗯

3239
01:46:21,000 --> 01:46:23,000
也就是说比如说呃

3240
01:46:24,000 --> 01:46:25,000
客户

3241
01:46:25,000 --> 01:46:27,000
告诉你说这个地方

3242
01:46:27,000 --> 01:46:29,000
我希望他

3243
01:46:29,000 --> 01:46:31,000
在最终的成品里面

3244
01:46:31,000 --> 01:46:34,000
一个按钮是在另外一个按钮的左边的

3245
01:46:34,000 --> 01:46:36,000
那你就可以写一个测试去

3246
01:46:36,000 --> 01:46:39,000
判断这个两个按钮的 id

3247
01:46:39,000 --> 01:46:41,000
以及他们之间相关位置

3248
01:46:41,000 --> 01:46:42,000
是不是正

3249
01:46:42,000 --> 01:46:42,000
比如说

3250
01:46:42,000 --> 01:46:43,000
对

3251
01:46:43,000 --> 01:46:45,000
右边这个按钮的 id 的 x

3252
01:46:46,000 --> 01:46:46,000
呃

3253
01:46:47,000 --> 01:46:49,000
对 x 减去左边这个按钮的 x

3254
01:46:49,000 --> 01:46:50,000
如果他是正的话

3255
01:46:50,000 --> 01:46:52,000
你就可以确定说这个按钮是在

3256
01:46:52,000 --> 01:46:53,000
另外一个按钮的右边

3257
01:46:54,000 --> 01:46:54,000
嗯

3258
01:46:55,000 --> 01:46:56,000
我觉得可以说

3259
01:46:56,000 --> 01:46:58,000
正是

3260
01:46:58,000 --> 01:47:00,000
呃敏捷的这个过程

3261
01:47:00,000 --> 01:47:02,000
或者说整个软件工程

3262
01:47:02,000 --> 01:47:03,000
向敏捷这个方向

3263
01:47:03,000 --> 01:47:05,000
所转移的这样一个

3264
01:47:07,000 --> 01:47:08,000
范式迁移

3265
01:47:08,000 --> 01:47:10,000
导致现在这样一个

3266
01:47:10,000 --> 01:47:11,000
呃

3267
01:47:11,000 --> 01:47:13,000
人们比相对来说比较强调

3268
01:47:13,000 --> 01:47:14,000
测试的这么一个状态

3269
01:47:15,000 --> 01:47:16,000
所以其实如果归纳来讲

3270
01:47:16,000 --> 01:47:17,000
就是说

3271
01:47:18,000 --> 01:47:19,000
啊

3272
01:47:19,000 --> 01:47:20,000
需求不明确

3273
01:47:20,000 --> 01:47:21,000
然后这个

3274
01:47:21,000 --> 01:47:22,000
就是

3275
01:47:22,000 --> 01:47:24,000
形式证明不可能的情况下

3276
01:47:24,000 --> 01:47:27,000
我们只能用测试来尽可能的保障

3277
01:47:27,000 --> 01:47:28,000
我们在

3278
01:47:28,000 --> 01:47:29,000
呃

3279
01:47:29,000 --> 01:47:30,000
快速迭代中

3280
01:47:30,000 --> 01:47:33,000
能够有一个相对稳定的产品质量

3281
01:47:34,000 --> 01:47:34,000
对

3282
01:47:34,000 --> 01:47:35,000
就是因为呃

3283
01:47:35,000 --> 01:47:38,000
测试会给你一个比较清晰的

3284
01:47:38,000 --> 01:47:39,000
一个比较客观的

3285
01:47:40,000 --> 01:47:40,000
呃

3286
01:47:40,000 --> 01:47:42,000
关于你的这个

3287
01:47:42,000 --> 01:47:45,000
软件产品的质量的反应

3288
01:47:45,000 --> 01:47:45,000
嗯哼

3289
01:47:45,000 --> 01:47:46,000
呃

3290
01:47:46,000 --> 01:47:51,000
所以才能让你有信心去执行一个比较敏捷的

3291
01:47:51,000 --> 01:47:52,000
软件迭代的过程

3292
01:47:52,000 --> 01:47:53,000
因为

3293
01:47:53,000 --> 01:47:54,000
很有可能说

3294
01:47:54,000 --> 01:47:55,000
呃

3295
01:47:55,000 --> 01:47:57,000
如果你不写测试的话

3296
01:47:57,000 --> 01:47:58,000
你可能做了一部分

3297
01:47:59,000 --> 01:47:59,000
呃

3298
01:48:00,000 --> 01:48:01,000
去弄坏另一部分

3299
01:48:01,000 --> 01:48:04,000
而直到你在最后给客户演示的时候

3300
01:48:04,000 --> 01:48:05,000
这个 bug 才暴露出来

3301
01:48:05,000 --> 01:48:06,000
我们知道

3302
01:48:06,000 --> 01:48:09,000
根据墨菲定律这种情况是永远会出会出现的

3303
01:48:09,000 --> 01:48:12,000
而书写足够多的测试

3304
01:48:12,000 --> 01:48:13,000
以及呃

3305
01:48:14,000 --> 01:48:18,000
执行所谓回归测试可以帮助你减少这种情况的发生

3306
01:48:19,000 --> 01:48:20,000
然后

3307
01:48:21,000 --> 01:48:21,000
呃

3308
01:48:21,000 --> 01:48:22,000
另外一方面

3309
01:48:22,000 --> 01:48:25,000
如果你一定要写测试的话

3310
01:48:25,000 --> 01:48:28,000
首先你得写出能够被测试的代码

3311
01:48:29,000 --> 01:48:31,000
然后这样一来

3312
01:48:31,000 --> 01:48:33,000
你如果在写代码的时候会想到说啊

3313
01:48:33,000 --> 01:48:34,000
这个地方要被测试了

3314
01:48:35,000 --> 01:48:38,000
那你可能会强迫自己写一些比较

3315
01:48:38,000 --> 01:48:40,000
干净的比较模块化的代码

3316
01:48:41,000 --> 01:48:46,000
然后这也会才从另外一方面去帮助你提升整个软件的

3317
01:48:46,000 --> 01:48:48,000
可控程度以及整个人的质量

3318
01:48:48,000 --> 01:48:51,000
然后我们刚才提到的一个所谓呃

3319
01:48:52,000 --> 01:48:52,000
软件

3320
01:48:52,000 --> 01:48:53,000
呃

3321
01:48:53,000 --> 01:48:56,000
测试驱动开发的各种一个概念

3322
01:48:56,000 --> 01:48:57,000
就呃

3323
01:48:58,000 --> 01:49:00,000
TDD 对 TDD

3324
01:49:00,000 --> 01:49:01,000
TDD 是什么呢

3325
01:49:01,000 --> 01:49:04,000
就是人们一发现这个

3326
01:49:04,000 --> 01:49:05,000
驱动

3327
01:49:05,000 --> 01:49:07,000
诶不测试是如此好的是一个东西

3328
01:49:08,000 --> 01:49:09,000
以至于有些人

3329
01:49:10,000 --> 01:49:11,000
朝这个

3330
01:49:12,000 --> 01:49:12,000
呃

3331
01:49:12,000 --> 01:49:14,000
比较原教旨主义的方向发展就说好

3332
01:49:15,000 --> 01:49:18,000
那我们在写软件之前先写测试吧

3333
01:49:20,000 --> 01:49:20,000
这就是 TDD

3334
01:49:20,000 --> 01:49:23,000
就是让测试成为需求的一部分

3335
01:49:24,000 --> 01:49:25,000
呃

3336
01:49:26,000 --> 01:49:27,000
这还要更进一步了

3337
01:49:27,000 --> 01:49:29,000
我们先说 TDD 吧

3338
01:49:29,000 --> 01:49:31,000
TDD 最基本的一个实践就是

3339
01:49:32,000 --> 01:49:32,000
好

3340
01:49:32,000 --> 01:49:34,000
我上来要写一个 Hello World

3341
01:49:34,000 --> 01:49:35,000
呃

3342
01:49:36,000 --> 01:49:37,000
在我写 Hello World 之前

3343
01:49:38,000 --> 01:49:40,000
我要先写一个测试

3344
01:49:40,000 --> 01:49:41,000
来确定

3345
01:49:41,000 --> 01:49:43,000
我将要写出来的程序

3346
01:49:43,000 --> 01:49:45,000
能够输出 Hello World

3347
01:49:45,000 --> 01:49:47,000
然后我再去写 Hello World

3348
01:49:47,000 --> 01:49:49,000
这是一个非常

3349
01:49:50,000 --> 01:49:50,000
怎么说呢

3350
01:49:50,000 --> 01:49:52,000
一开始听起来会觉得有些疯狂的感觉

3351
01:49:52,000 --> 01:49:54,000
就呃

3352
01:49:54,000 --> 01:49:57,000
准确的说 TDD 的执行的三原则是

3353
01:49:57,000 --> 01:49:58,000
一

3354
01:49:58,000 --> 01:50:01,000
在写出一个测试失败的单元测试之前

3355
01:50:01,000 --> 01:50:02,000
不写功能来吧

3356
01:50:02,000 --> 01:50:04,000
这是这是一个什么概念

3357
01:50:04,000 --> 01:50:04,000
就是

3358
01:50:05,000 --> 01:50:05,000
啊

3359
01:50:05,000 --> 01:50:06,000
我要写一行程序

3360
01:50:06,000 --> 01:50:08,000
但是在我写这行程序之前

3361
01:50:08,000 --> 01:50:09,000
我先要写一个

3362
01:50:09,000 --> 01:50:12,000
没有这行程序就肯定会失败的单元测试

3363
01:50:15,000 --> 01:50:17,000
那你怎么测这个 Hello World

3364
01:50:18,000 --> 01:50:19,000
呃 Hello World 实在太缺口

3365
01:50:19,000 --> 01:50:21,000
比如说我之前很喜欢的一个

3366
01:50:21,000 --> 01:50:23,000
Kata 就是

3367
01:50:23,000 --> 01:50:23,000
嗯

3368
01:50:23,000 --> 01:50:26,000
把阿拉伯数字转为罗马数字

3369
01:50:26,000 --> 01:50:27,000
呃

3370
01:50:28,000 --> 01:50:29,000
我要写这个

3371
01:50:29,000 --> 01:50:32,000
比如说我面对一门新的陌生语

3372
01:50:32,000 --> 01:50:34,000
比如说 Haskell 或者是 Swift

3373
01:50:34,000 --> 01:50:35,000
呃

3374
01:50:35,000 --> 01:50:36,000
我首先

3375
01:50:37,000 --> 01:50:38,000
呃

3376
01:50:38,000 --> 01:50:40,000
可以用其他的语言

3377
01:50:40,000 --> 01:50:42,000
来判断

3378
01:50:42,000 --> 01:50:43,000
这个语言

3379
01:50:43,000 --> 01:50:46,000
我将要学的这个语言所输出的是不是正确

3380
01:50:46,000 --> 01:50:47,000
比如说

3381
01:50:47,000 --> 01:50:51,000
我知道阿拉伯数字的 1 会转为罗马数字的 i

3382
01:50:51,000 --> 01:50:52,000
那我就

3383
01:50:52,000 --> 01:50:53,000
先写这样一个测试

3384
01:50:53,000 --> 01:50:54,000
呃

3385
01:50:54,000 --> 01:50:55,000
这个程序运行之后

3386
01:50:55,000 --> 01:50:57,000
它应该在屏幕上

3387
01:50:57,000 --> 01:50:58,000
输出

3388
01:50:58,000 --> 01:50:59,000
或者这么说吧

3389
01:50:59,000 --> 01:50:59,000
这个

3390
01:51:00,000 --> 01:51:01,000
我将要写的程序

3391
01:51:01,000 --> 01:51:03,000
首先应该接纳一个文本文件

3392
01:51:03,000 --> 01:51:04,000
里面是

3393
01:51:04,000 --> 01:51:06,000
1 到 1000 的罗马数字

3394
01:51:07,000 --> 01:51:07,000
嗯

3395
01:51:08,000 --> 01:51:09,000
啊 sorry

3396
01:51:09,000 --> 01:51:10,000
首先

3397
01:51:10,000 --> 01:51:12,000
它应该接受一个文本文件

3398
01:51:12,000 --> 01:51:14,000
然后输出另外一个文本文件

3399
01:51:14,000 --> 01:51:16,000
然后我需要把它输出这个文本文件

3400
01:51:16,000 --> 01:51:19,000
和我的目标文本文件作为对比

3401
01:51:19,000 --> 01:51:20,000
嗯

3402
01:51:21,000 --> 01:51:22,000
比如说一开始这个

3403
01:51:23,000 --> 01:51:25,000
一开始文本文件里面只有一个 1

3404
01:51:26,000 --> 01:51:29,000
然后在目标文本文件里面应该有一个 i

3405
01:51:29,000 --> 01:51:31,000
当我准备好了这一切之后

3406
01:51:31,000 --> 01:51:31,000
我才可以

3407
01:51:31,000 --> 01:51:34,000
我才开始着手用这种新的语言

3408
01:51:35,000 --> 01:51:36,000
去写

3409
01:51:36,000 --> 01:51:38,000
我将要写的这个

3410
01:51:38,000 --> 01:51:41,000
我希望写这个阿拉伯数字转成罗马数字的程序

3411
01:51:41,000 --> 01:51:42,000
好

3412
01:51:43,000 --> 01:51:44,000
然后

3413
01:51:44,000 --> 01:51:46,000
这个第二准则是

3414
01:51:46,000 --> 01:51:50,000
纸边写恰好能体现一个失败情况的测试

3415
01:51:51,000 --> 01:51:52,000
嗯

3416
01:51:52,000 --> 01:51:53,000
一个比较简单的例子就是说

3417
01:51:53,000 --> 01:51:54,000
你可以判断说

3418
01:51:55,000 --> 01:51:55,000
呃

3419
01:51:55,000 --> 01:51:57,000
如果输入是阿拉伯数字 1

3420
01:51:58,000 --> 01:52:00,000
那么输出必然是罗马数字 i

3421
01:52:00,000 --> 01:52:01,000
对

3422
01:52:01,000 --> 01:52:03,000
然后如果你先给他一个

3423
01:52:03,000 --> 01:52:05,000
因为没有功能代码就是一个空函数对吧

3424
01:52:06,000 --> 01:52:06,000
对

3425
01:52:06,000 --> 01:52:08,000
那么去他再输入什么

3426
01:52:08,000 --> 01:52:09,000
出来都是空

3427
01:52:09,000 --> 01:52:09,000
对

3428
01:52:09,000 --> 01:52:10,000
你知道

3429
01:52:10,000 --> 01:52:11,000
这个测试会挂掉

3430
01:52:11,000 --> 01:52:11,000
对

3431
01:52:11,000 --> 01:52:12,000
然后呢

3432
01:52:12,000 --> 01:52:14,000
第三条准则更变态

3433
01:52:14,000 --> 01:52:17,000
说纸边写恰好能通过测试的功能

3434
01:52:17,000 --> 01:52:18,000
来吧

3435
01:52:18,000 --> 01:52:19,000
这是什么概念

3436
01:52:19,000 --> 01:52:20,000
就是

3437
01:52:20,000 --> 01:52:21,000
我们

3438
01:52:21,000 --> 01:52:22,000
完成了刚才两步

3439
01:52:22,000 --> 01:52:23,000
一

3440
01:52:23,000 --> 01:52:26,000
在写一个测试失败的单元测试之前不写功能代码

3441
01:52:26,000 --> 01:52:27,000
好

3442
01:52:27,000 --> 01:52:27,000
我写了功能代码

3443
01:52:27,000 --> 01:52:28,000
我写了

3444
01:52:28,000 --> 01:52:29,000
呃

3445
01:52:29,000 --> 01:52:31,000
会让测试失败的单元测试

3446
01:52:32,000 --> 01:52:32,000
二

3447
01:52:32,000 --> 01:52:33,000
我写了

3448
01:52:33,000 --> 01:52:35,000
刚好只能通过

3449
01:52:35,000 --> 01:52:35,000
呃

3450
01:52:35,000 --> 01:52:38,000
刚好只能体现一个失败行动测试

3451
01:52:38,000 --> 01:52:38,000
好

3452
01:52:38,000 --> 01:52:41,000
我给在左边的文件里面给了 1

3453
01:52:41,000 --> 01:52:42,000
阿拉伯数字 1

3454
01:52:42,000 --> 01:52:45,000
右边的文件里面给了拉丁字母 i

3455
01:52:45,000 --> 01:52:46,000
好

3456
01:52:46,000 --> 01:52:46,000
第三条

3457
01:52:46,000 --> 01:52:49,000
我纸边写恰好能通过该测试的功能代码

3458
01:52:49,000 --> 01:52:54,000
我在新的程序里面写说

3459
01:52:54,000 --> 01:52:56,000
if input is 1

3460
01:52:56,000 --> 01:52:58,000
then output i 就可以了

3461
01:52:58,000 --> 01:53:01,000
对吧

3462
01:53:01,000 --> 01:53:02,000
对

3463
01:53:02,000 --> 01:53:08,000
那这样一种比较变态的开发方法

3464
01:53:09,000 --> 01:53:10,000
你仔细想一下

3465
01:53:10,000 --> 01:53:13,000
其实是很难让你

3466
01:53:13,000 --> 01:53:14,000
让一个

3467
01:53:15,000 --> 01:53:18,000
神志正常的人去接受的

3468
01:53:18,000 --> 01:53:18,000
对吧

3469
01:53:18,000 --> 01:53:20,000
比如说我刚才说了这句话

3470
01:53:20,000 --> 01:53:24,000
说你是说 TDP 的践行者就神志不正常

3471
01:53:25,000 --> 01:53:25,000
Wait a second

3472
01:53:26,000 --> 01:53:26,000
呃

3473
01:53:29,000 --> 01:53:30,000
好

3474
01:53:30,000 --> 01:53:31,000
现在我话说完

3475
01:53:31,000 --> 01:53:32,000
就是

3476
01:53:32,000 --> 01:53:34,000
如果你是一个神志正常人的话

3477
01:53:34,000 --> 01:53:35,000
你肯定知道

3478
01:53:35,000 --> 01:53:36,000
如果输出是

3479
01:53:36,000 --> 01:53:38,000
如果输出是 1

3480
01:53:38,000 --> 01:53:41,000
直接输出 i 是一个非常蠢的

3481
01:53:42,000 --> 01:53:42,000
主意

3482
01:53:42,000 --> 01:53:44,000
因为从一开始

3483
01:53:44,000 --> 01:53:47,000
你就把自己限定在一个

3484
01:53:48,000 --> 01:53:50,000
非常着眼欲

3485
01:53:50,000 --> 01:53:53,000
非常短视的这么一个数不算光的状态

3486
01:53:53,000 --> 01:53:54,000
就是你只看得到输出

3487
01:53:54,000 --> 01:53:55,000
输入是 1

3488
01:53:55,000 --> 01:53:57,000
然后也只输出 1

3489
01:53:57,000 --> 01:53:57,000
打个岔

3490
01:53:57,000 --> 01:54:02,000
你觉得这个方法特别适合外包团队

3491
01:54:02,000 --> 01:54:04,000
因为你可以给别人干活

3492
01:54:04,000 --> 01:54:05,000
你先满足他的需求

3493
01:54:05,000 --> 01:54:06,000
他会插回去测

3494
01:54:06,000 --> 01:54:08,000
然后你干多了没有用

3495
01:54:08,000 --> 01:54:10,000
你只要干得刚刚好就可以了

3496
01:54:11,000 --> 01:54:12,000
嗯

3497
01:54:12,000 --> 01:54:17,000
事实上也的确是外包团队在最多的使用体验

3498
01:54:18,000 --> 01:54:19,000
我必须这么说

3499
01:54:20,000 --> 01:54:20,000
好吧

3500
01:54:21,000 --> 01:54:22,000
嗯

3501
01:54:22,000 --> 01:54:23,000
对

3502
01:54:24,000 --> 01:54:27,000
总之刚才你说的这句话其实是有道理的

3503
01:54:27,000 --> 01:54:29,000
就是使用 TDD 的人实质是不太清楚

3504
01:54:30,000 --> 01:54:32,000
我心里其实是很认同这句话

3505
01:54:32,000 --> 01:54:35,000
因为 TDD 就好像案例一样

3506
01:54:35,000 --> 01:54:38,000
就是你只有深陷其中了

3507
01:54:38,000 --> 01:54:41,000
你才会真正的感受到它的好

3508
01:54:42,000 --> 01:54:43,000
我刚才这句话

3509
01:54:43,000 --> 01:54:46,000
绝对不是一个以一种 compliment 的方式来说

3510
01:54:46,000 --> 01:54:47,000
就是

3511
01:54:47,000 --> 01:54:49,000
因为我从来没有深陷其中过

3512
01:54:49,000 --> 01:54:50,000
所以我从来不觉得它的好

3513
01:54:50,000 --> 01:54:51,000
但是

3514
01:54:52,000 --> 01:54:54,000
三方三方位我也可以理解

3515
01:54:54,000 --> 01:54:57,000
其用户所持的这样的观点就是

3516
01:54:57,000 --> 01:55:00,000
别看你使用的这三个原则非常的愚蠢

3517
01:55:00,000 --> 01:55:03,000
但是到你开发一个大型软件的后期

3518
01:55:04,000 --> 01:55:05,000
你会发现

3519
01:55:05,000 --> 01:55:10,000
迁移放而动全身的状况是经常有的

3520
01:55:10,000 --> 01:55:14,000
而如果你能坚持着用这种非常愚蠢的方法

3521
01:55:14,000 --> 01:55:17,000
把每一个最为微小的修改

3522
01:55:18,000 --> 01:55:21,000
都以测试先行的方式写出来的话

3523
01:55:21,000 --> 01:55:24,000
你会发现到后期你犯一点点小错

3524
01:55:25,000 --> 01:55:26,000
都可以马上会发现出

3525
01:55:27,000 --> 01:55:31,000
而所有这些被发现出来的小错

3526
01:55:31,000 --> 01:55:32,000
保证了你的软件质量

3527
01:55:33,000 --> 01:55:34,000
OK

3528
01:55:35,000 --> 01:55:37,000
然后刚才你说的这个

3529
01:55:37,000 --> 01:55:40,000
一上来就描述整个系统的 behavior

3530
01:55:40,000 --> 01:55:42,000
那其实是 TDD 更进一步

3531
01:55:42,000 --> 01:55:44,000
叫做 BDD

3532
01:55:45,000 --> 01:55:46,000
behavior driven development

3533
01:55:47,000 --> 01:55:49,000
它的核心理念其实就是像你说的

3534
01:55:49,000 --> 01:55:51,000
那至于可以更进一步

3535
01:55:51,000 --> 01:55:53,000
就是不是用代码

3536
01:55:53,000 --> 01:55:55,000
而是用一种比较

3537
01:55:57,000 --> 01:56:01,000
项目经理也能读懂的普通语言

3538
01:56:01,000 --> 01:56:02,000
大白话

3539
01:56:02,000 --> 01:56:03,000
等于用大白话来

3540
01:56:04,000 --> 01:56:07,000
近似于大白话的普通的简单的句子

3541
01:56:07,000 --> 01:56:10,000
来描述出整个系统的状态

3542
01:56:10,000 --> 01:56:11,000
不是整个系统

3543
01:56:11,000 --> 01:56:12,000
是整个组件的状态

3544
01:56:13,000 --> 01:56:16,000
所以一个最古老的例子就是创世纪

3545
01:56:16,000 --> 01:56:16,000
对吧

3546
01:56:17,000 --> 01:56:18,000
创世纪

3547
01:56:18,000 --> 01:56:19,000
对啊

3548
01:56:19,000 --> 01:56:20,000
因为上帝说要有光嘛

3549
01:56:20,000 --> 01:56:21,000
There should be lights

3550
01:56:23,000 --> 01:56:24,000
这是最早的 BDD

3551
01:56:25,000 --> 01:56:26,000
说得没错

3552
01:56:27,000 --> 01:56:29,000
只不过在 BDD 里面

3553
01:56:30,000 --> 01:56:32,000
创始人和

3554
01:56:33,000 --> 01:56:35,000
开发者和验收人是同一个人

3555
01:56:36,000 --> 01:56:38,000
这是比较操蛋的一点

3556
01:56:38,000 --> 01:56:40,000
就是上帝只是要说

3557
01:56:40,000 --> 01:56:42,000
上帝看着这一切是好的

3558
01:56:42,000 --> 01:56:43,000
就可以了

3559
01:56:43,000 --> 01:56:46,000
而不是验收通过合格

3560
01:56:46,000 --> 01:56:48,000
上帝的老婆看到这一切

3561
01:56:48,000 --> 01:56:49,000
把上帝揍了一顿之类的

3562
01:56:52,000 --> 01:56:53,000
对

3563
01:56:53,000 --> 01:56:56,000
你在写这些 BDD 的

3564
01:56:56,000 --> 01:56:56,000
你说什么

3565
01:56:56,000 --> 01:56:57,000
太不严肃了

3566
01:57:01,000 --> 01:57:02,000
我们两个都是不可

3567
01:57:02,000 --> 01:57:03,000
我不知道你

3568
01:57:03,000 --> 01:57:04,000
我是不可知论者

3569
01:57:04,000 --> 01:57:04,000
所以

3570
01:57:05,000 --> 01:57:06,000
圣经就是一部 Bullshit

3571
01:57:11,000 --> 01:57:12,000
歌王

3572
01:57:13,000 --> 01:57:14,000
对啊

3573
01:57:14,000 --> 01:57:15,000
我希望没有 insult

3574
01:57:15,000 --> 01:57:15,000
So

3575
01:57:16,000 --> 01:57:18,000
我觉得已经发生了

3576
01:57:18,000 --> 01:57:18,000
但是

3577
01:57:18,000 --> 01:57:19,000
Doesn't matter

3578
01:57:22,000 --> 01:57:22,000
OK

3579
01:57:22,000 --> 01:57:23,000
对

3580
01:57:23,000 --> 01:57:25,000
你在写这个 BDD 的

3581
01:57:26,000 --> 01:57:27,000
测试行为描述的时候

3582
01:57:27,000 --> 01:57:29,000
就会很有那种上帝的感觉

3583
01:57:29,000 --> 01:57:30,000
plagal

3584
01:57:30,000 --> 01:57:31,000
你可以说

3585
01:57:33,000 --> 01:57:34,000
It should

3586
01:57:36,000 --> 01:57:39,000
Throw division by zero error

3587
01:57:39,000 --> 01:57:41,000
The input is given by zero

3588
01:57:42,000 --> 01:57:43,000
之类的句子

3589
01:57:43,000 --> 01:57:44,000
然后

3590
01:57:46,000 --> 01:57:47,000
比较了

3591
01:57:47,000 --> 01:57:48,000
比较比较牛逼的

3592
01:57:48,000 --> 01:57:49,000
这个 BDD 的工具

3593
01:57:49,000 --> 01:57:50,000
比如说

3594
01:57:51,000 --> 01:57:52,000
Cucumber

3595
01:57:52,000 --> 01:57:53,000
对应该是 Cucumber

3596
01:57:54,000 --> 01:57:55,000
可以让

3597
01:57:55,000 --> 01:57:56,000
可以有一个工具

3598
01:57:56,000 --> 01:57:58,000
可以自然而然的把你的这些

3599
01:57:59,000 --> 01:57:59,000
对于

3600
01:58:00,000 --> 01:58:03,000
整个组件的行为描述

3601
01:58:03,000 --> 01:58:05,000
转化为相应的测试来

3602
01:58:06,000 --> 01:58:08,000
然后自动的

3603
01:58:08,000 --> 01:58:09,000
在你写出来之后

3604
01:58:09,000 --> 01:58:10,000
我帮你执行

3605
01:58:11,000 --> 01:58:13,000
这就是要用 NLP 的方式

3606
01:58:13,000 --> 01:58:15,000
来去解析那些东西吗

3607
01:58:15,000 --> 01:58:17,000
其实是一个非常简单的

3608
01:58:17,000 --> 01:58:18,000
regular expression

3609
01:58:18,000 --> 01:58:19,000
如果没记错

3610
01:58:20,000 --> 01:58:20,000
OK

3611
01:58:20,000 --> 01:58:23,000
就是用一些比较规则的结构

3612
01:58:23,000 --> 01:58:24,000
去描述

3613
01:58:24,000 --> 01:58:25,000
首先你在写

3614
01:58:26,000 --> 01:58:28,000
behavior description 的时候

3615
01:58:28,000 --> 01:58:30,000
就不能用完全的自然语

3616
01:58:30,000 --> 01:58:33,000
你必须用一些特定的句子

3617
01:58:33,000 --> 01:58:33,000
就像你说

3618
01:58:34,000 --> 01:58:35,000
你在

3619
01:58:35,000 --> 01:58:37,000
指使 C 3 去做什么事情的时候

3620
01:58:37,000 --> 01:58:38,000
你必须用一个特定的

3621
01:58:38,000 --> 01:58:39,000
范式的句子

3622
01:58:40,000 --> 01:58:42,000
然后 TDD 的描述源

3623
01:58:42,000 --> 01:58:43,000
跟它比较相似

3624
01:58:44,000 --> 01:58:45,000
你必须用一些特定的句式

3625
01:58:45,000 --> 01:58:46,000
it should

3626
01:58:47,000 --> 01:58:47,000
之类

3627
01:58:47,000 --> 01:58:47,000
对

3628
01:58:47,000 --> 01:58:49,000
其实你知道这有时候

3629
01:58:49,000 --> 01:58:52,000
为什么比较讨厌这种 BDD 的

3630
01:58:52,000 --> 01:58:53,000
test suite

3631
01:58:53,000 --> 01:58:56,000
test suite 的一个原因就是

3632
01:58:56,000 --> 01:58:58,000
感觉好像 Apple script

3633
01:59:00,000 --> 01:59:00,000
对

3634
01:59:00,000 --> 01:59:02,000
看起来好像在写什么去

3635
01:59:02,000 --> 01:59:02,000
但是又

3636
01:59:03,000 --> 01:59:05,000
没有真的在写什么去

3637
01:59:05,000 --> 01:59:05,000
对

3638
01:59:05,000 --> 01:59:07,000
然后你就很难去模糊到

3639
01:59:07,000 --> 01:59:09,000
我要到底写一个什么样的语句

3640
01:59:09,000 --> 01:59:11,000
才能够满足它生成一个

3641
01:59:11,000 --> 01:59:13,000
可以被它执行的 Test case

3642
01:59:13,000 --> 01:59:14,000
就很郁闷

3643
01:59:14,000 --> 01:59:15,000
你不要搞这个

3644
01:59:15,000 --> 01:59:17,000
你直接给一个写一个正常的语句

3645
01:59:17,000 --> 01:59:17,000
好不好

3646
01:59:17,000 --> 01:59:18,000
对

3647
01:59:18,000 --> 01:59:20,000
这可能就是怎么说

3648
01:59:20,000 --> 01:59:23,000
编程语言里面的恐怖古礼

3649
01:59:24,000 --> 01:59:27,000
你要么写非常贴近机器的编程语言

3650
01:59:27,000 --> 01:59:29,000
你要么就直接用自然语

3651
01:59:30,000 --> 01:59:31,000
要么你就逻辑一点

3652
01:59:31,000 --> 01:59:32,000
要不你就自然

3653
01:59:32,000 --> 01:59:33,000
就真的是自然语言

3654
01:59:33,000 --> 01:59:33,000
你能分析出来

3655
01:59:33,000 --> 01:59:36,000
但是你这个介意之间就不中不息的

3656
01:59:37,000 --> 01:59:38,000
就非常难受

3657
01:59:38,000 --> 01:59:38,000
而且

3658
01:59:39,000 --> 01:59:40,000
而且就是

3659
01:59:41,000 --> 01:59:43,000
就是用 BD 的践行者经常会在

3660
01:59:43,000 --> 01:59:46,000
反正 Ruby 是这个算命做的比较极端的

3661
01:59:46,000 --> 01:59:47,000
Ruby Scala 这种也好

3662
01:59:48,000 --> 01:59:49,000
它会把 DSL

3663
01:59:50,000 --> 01:59:53,000
Domain Specific Language 特性用到极致

3664
01:59:54,000 --> 01:59:54,000
对

3665
01:59:54,000 --> 01:59:57,000
就发现一些匪夷所思的语法在那里用着

3666
01:59:58,000 --> 01:59:59,000
相当坑爹

3667
01:59:59,000 --> 01:59:59,000
对

3668
01:59:59,000 --> 02:00:01,000
谁叫他们灵活

3669
02:00:01,000 --> 02:00:02,000
灵活有灵活的代价

3670
02:00:04,000 --> 02:00:04,000
好怕

3671
02:00:07,000 --> 02:00:07,000
对

3672
02:00:07,000 --> 02:00:10,000
所以其实就可以过渡到我们的

3673
02:00:11,000 --> 02:00:13,000
下一个重点

3674
02:00:13,000 --> 02:00:13,000
就是

3675
02:00:14,000 --> 02:00:15,000
为什么人们讨厌测试

3676
02:00:15,000 --> 02:00:17,000
或者说为什么人们

3677
02:00:18,000 --> 02:00:20,000
会觉得测试是可有可无的东西

3678
02:00:22,000 --> 02:00:23,000
你为什么讨厌测试

3679
02:00:23,000 --> 02:00:25,000
或者说你为什么不喜欢写测试

3680
02:00:26,000 --> 02:00:27,000
我觉得

3681
02:00:27,000 --> 02:00:28,000
就是刚才我讲

3682
02:00:28,000 --> 02:00:30,000
我喜欢有一些确定性的

3683
02:00:30,000 --> 02:00:32,000
经过形式证明的东西

3684
02:00:32,000 --> 02:00:35,000
就是说我写的这么一堆小团代码

3685
02:00:35,000 --> 02:00:38,000
经过严密的理论推敲

3686
02:00:38,000 --> 02:00:39,000
它是不可能出错的

3687
02:00:40,000 --> 02:00:41,000
我觉得这是好的

3688
02:00:42,000 --> 02:00:43,000
然后你给我突然间挑起来

3689
02:00:43,000 --> 02:00:44,000
跟我说不对

3690
02:00:44,000 --> 02:00:45,000
你这个太麻烦了

3691
02:00:45,000 --> 02:00:46,000
有些你做不到

3692
02:00:46,000 --> 02:00:49,000
我这个代码有 200 号长

3693
02:00:49,000 --> 02:00:50,000
你怎么证明它

3694
02:00:50,000 --> 02:00:50,000
对吧

3695
02:00:50,000 --> 02:00:52,000
它要带着什么输入数

3696
02:00:52,000 --> 02:00:52,000
就是什么叫做

3697
02:00:54,000 --> 02:00:55,000
非确定性的

3698
02:00:55,000 --> 02:00:57,000
indeterministic

3699
02:00:57,000 --> 02:00:57,000
对吧

3700
02:00:59,000 --> 02:01:01,000
要是你怎么去形式证明的

3701
02:01:01,000 --> 02:01:01,000
没有办法

3702
02:01:02,000 --> 02:01:04,000
那么我们来个 2 HT 词

3703
02:01:04,000 --> 02:01:04,000
写测试

3704
02:01:05,000 --> 02:01:08,000
写的 50 个 unit test

3705
02:01:09,000 --> 02:01:10,000
这个 cases

3706
02:01:10,000 --> 02:01:12,000
那可能覆盖到大多数常见

3707
02:01:12,000 --> 02:01:13,000
和不常见的情况

3708
02:01:13,000 --> 02:01:15,000
然后你都跑通了

3709
02:01:15,000 --> 02:01:15,000
那么觉得

3710
02:01:15,000 --> 02:01:17,000
在心理上有一定的把握

3711
02:01:17,000 --> 02:01:18,000
证明这个事情是可行的

3712
02:01:19,000 --> 02:01:20,000
但是我还是有一种

3713
02:01:20,000 --> 02:01:21,000
深深的不安的感觉

3714
02:01:21,000 --> 02:01:22,000
总觉得

3715
02:01:22,000 --> 02:01:24,000
万一有一个情况没覆盖到怎么办

3716
02:01:27,000 --> 02:01:29,000
然后就觉得还是从逻辑上

3717
02:01:29,000 --> 02:01:30,000
就一层一层分析它

3718
02:01:30,000 --> 02:01:31,000
哪里会出错

3719
02:01:31,000 --> 02:01:34,000
哪里会跳出

3720
02:01:34,000 --> 02:01:35,000
这样会比较好

3721
02:01:35,000 --> 02:01:37,000
当然这也是一个间接的原因

3722
02:01:37,000 --> 02:01:38,000
导致为什么我不喜欢

3723
02:01:39,000 --> 02:01:40,000
异常机制

3724
02:01:40,000 --> 02:01:41,000
就是 exception mechanism

3725
02:01:41,000 --> 02:01:43,000
因为它会导致你那个逻辑

3726
02:01:43,000 --> 02:01:44,000
那个 control flow

3727
02:01:44,000 --> 02:01:47,000
是多重的 exit point

3728
02:01:47,000 --> 02:01:48,000
对吧

3729
02:01:48,000 --> 02:01:50,000
这样会导致你整个状态是

3730
02:01:50,000 --> 02:01:51,000
不干净的

3731
02:01:52,000 --> 02:01:53,000
如果你状态不干净的话

3732
02:01:53,000 --> 02:01:54,000
你就很难去

3733
02:01:54,000 --> 02:01:58,000
用 formal verification 的方法去验证

3734
02:01:58,000 --> 02:02:01,000
或者说你很难用推理的方法

3735
02:02:01,000 --> 02:02:03,000
去证明它是不可能出错的

3736
02:02:03,000 --> 02:02:06,000
这是一些相关的问题

3737
02:02:06,000 --> 02:02:06,000
我觉得

3738
02:02:06,000 --> 02:02:09,000
然后写册是一个很痛苦的过程

3739
02:02:10,000 --> 02:02:10,000
对

3740
02:02:11,000 --> 02:02:13,000
我觉得很大一个原因就是

3741
02:02:14,000 --> 02:02:17,000
为什么会说写册是一个很痛苦的过程

3742
02:02:17,000 --> 02:02:18,000
就是因为

3743
02:02:18,000 --> 02:02:23,000
它不会给你一种 achievement 的感觉

3744
02:02:23,000 --> 02:02:25,000
你写册是不会有成就的

3745
02:02:26,000 --> 02:02:28,000
你不会觉得自己在创造新的东西

3746
02:02:29,000 --> 02:02:30,000
你只是

3747
02:02:31,000 --> 02:02:33,000
你只是在做一件

3748
02:02:33,000 --> 02:02:34,000
比如说给别人批诺页

3749
02:02:34,000 --> 02:02:35,000
或者是

3750
02:02:35,000 --> 02:02:36,000
写完了卷子之后

3751
02:02:36,000 --> 02:02:39,000
在那边验算自己写的对不对

3752
02:02:39,000 --> 02:02:40,000
这样一种过程

3753
02:02:40,000 --> 02:02:41,000
对

3754
02:02:41,000 --> 02:02:43,000
就刚才我讲你写代码的时候

3755
02:02:43,000 --> 02:02:44,000
你会有一种创造的快感

3756
02:02:44,000 --> 02:02:45,000
对吧

3757
02:02:45,000 --> 02:02:46,000
creation

3758
02:02:46,000 --> 02:02:47,000
就这种感觉的

3759
02:02:47,000 --> 02:02:49,000
也就一种上帝的视角在里面

3760
02:02:49,000 --> 02:02:51,000
然后你证明它的时候

3761
02:02:51,000 --> 02:02:51,000
你有一种

3762
02:02:51,000 --> 02:02:53,000
我不知道有些人做数学题

3763
02:02:53,000 --> 02:02:54,000
他证明的一道很难的题

3764
02:02:54,000 --> 02:02:55,000
他可能会有一种快感

3765
02:02:55,000 --> 02:02:56,000
其实写那个

3766
02:02:56,000 --> 02:02:58,000
就是写 formal verification

3767
02:02:58,000 --> 02:03:00,000
其实有类似的作用

3768
02:03:00,000 --> 02:03:02,000
但是你说写测试

3769
02:03:02,000 --> 02:03:03,000
感觉就好像什么呢

3770
02:03:03,000 --> 02:03:04,000
就为了证明到数学题

3771
02:03:04,000 --> 02:03:06,000
你只拿个计算器在那按

3772
02:03:06,000 --> 02:03:07,000
说先数一个 5

3773
02:03:07,000 --> 02:03:08,000
得出是 50

3774
02:03:08,000 --> 02:03:10,000
结果是先出一个 6

3775
02:03:10,000 --> 02:03:11,000
得出是 600

3776
02:03:12,000 --> 02:03:13,000
你觉得这是对的

3777
02:03:13,000 --> 02:03:14,000
你写的没错

3778
02:03:14,000 --> 02:03:15,000
写了这么做

3779
02:03:15,000 --> 02:03:16,000
重复做试了 100 次之后

3780
02:03:16,000 --> 02:03:18,000
你就说我这个过程应该是正确的

3781
02:03:18,000 --> 02:03:19,000
我这个答案应该是正确的

3782
02:03:19,000 --> 02:03:21,000
因为我测试了 100 个

3783
02:03:21,000 --> 02:03:21,000
觉得都是正确的

3784
02:03:21,000 --> 02:03:22,000
但其实没有经过证明

3785
02:03:22,000 --> 02:03:24,000
你还是不确定

3786
02:03:24,000 --> 02:03:24,000
就没有快

3787
02:03:24,000 --> 02:03:25,000
没有成就感

3788
02:03:25,000 --> 02:03:27,000
就是一个很机械的劳动

3789
02:03:27,000 --> 02:03:27,000
我觉得

3790
02:03:28,000 --> 02:03:28,000
对

3791
02:03:30,000 --> 02:03:31,000
另外一方面也是因为我们

3792
02:03:33,000 --> 02:03:34,000
从来没有在

3793
02:03:34,000 --> 02:03:35,000
哪怕科班出身的人

3794
02:03:35,000 --> 02:03:37,000
都很难会说

3795
02:03:37,000 --> 02:03:39,000
自己曾经在求学

3796
02:03:39,000 --> 02:03:41,000
就学编程的过程中学得过

3797
02:03:42,000 --> 02:03:43,000
怎样写测试

3798
02:03:44,000 --> 02:03:45,000
我相信

3799
02:03:46,000 --> 02:03:48,000
应该现在没有哪个大学里面

3800
02:03:48,000 --> 02:03:50,000
会专门开设软件测试

3801
02:03:50,000 --> 02:03:51,000
这一个课程

3802
02:03:51,000 --> 02:03:52,000
哪怕是

3803
02:03:52,000 --> 02:03:54,000
会在那个 software engineer 里面

3804
02:03:54,000 --> 02:03:55,000
作为一个

3805
02:03:55,000 --> 02:03:56,000
使用的工具

3806
02:03:56,000 --> 02:03:57,000
去讲

3807
02:03:57,000 --> 02:03:59,000
这个我有体会

3808
02:04:00,000 --> 02:04:02,000
所以你还是偷偷上过人间过程了

3809
02:04:03,000 --> 02:04:03,000
没

3810
02:04:04,000 --> 02:04:05,000
但是我做过助教

3811
02:04:07,000 --> 02:04:08,000
原来如此

3812
02:04:09,000 --> 02:04:09,000
对

3813
02:04:11,000 --> 02:04:12,000
但是

3814
02:04:12,000 --> 02:04:13,000
科班出身的人

3815
02:04:13,000 --> 02:04:15,000
可能有这样一个机会

3816
02:04:15,000 --> 02:04:16,000
但是那些自学成才的人

3817
02:04:16,000 --> 02:04:18,000
可能就完全没有

3818
02:04:18,000 --> 02:04:22,000
学过怎样去写测试

3819
02:04:22,000 --> 02:04:23,000
乃至于怎样写出

3820
02:04:23,000 --> 02:04:25,000
可以为测试代码

3821
02:04:25,000 --> 02:04:26,000
而我们必须承认的也是

3822
02:04:27,000 --> 02:04:28,000
拿对一个

3823
02:04:28,000 --> 02:04:28,000
很

3824
02:04:28,000 --> 02:04:30,000
就编程编得相对熟练的人来说

3825
02:04:30,000 --> 02:04:31,000
你要他

3826
02:04:32,000 --> 02:04:33,000
去去适应一个

3827
02:04:33,000 --> 02:04:35,000
把所有代码都写的

3828
02:04:36,000 --> 02:04:38,000
易于测试的这么一个

3829
02:04:38,000 --> 02:04:40,000
写出易于测试这么一个风格来

3830
02:04:41,000 --> 02:04:43,000
也其实挺难的一点事情

3831
02:04:47,000 --> 02:04:50,000
尤其是有时候可以测试的代码

3832
02:04:51,000 --> 02:04:52,000
跟不啰嗦的代码

3833
02:04:52,000 --> 02:04:54,000
其实是非常相

3834
02:04:54,000 --> 02:04:56,000
彼此抵触的这么一个状态

3835
02:04:57,000 --> 02:04:59,000
有时候也许你可以判断一个条件

3836
02:04:59,000 --> 02:05:00,000
是必然啰嗦

3837
02:05:02,000 --> 02:05:04,000
可测试的代码

3838
02:05:05,000 --> 02:05:06,000
必然是啰嗦的

3839
02:05:06,000 --> 02:05:07,000
测试本身当然是

3840
02:05:08,000 --> 02:05:09,000
完全是不必要的废话

3841
02:05:09,000 --> 02:05:11,000
但可测试的代码

3842
02:05:11,000 --> 02:05:13,000
为了保证其可测试性

3843
02:05:13,000 --> 02:05:16,000
可能要比不可测试的代码啰嗦很多

3844
02:05:16,000 --> 02:05:17,000
比如说可能有一个边界条件

3845
02:05:18,000 --> 02:05:19,000
你要去检测这边的条件

3846
02:05:19,000 --> 02:05:21,000
同时根据这个边界条件

3847
02:05:21,000 --> 02:05:22,000
给某一个数值

3848
02:05:23,000 --> 02:05:24,000
同时根据这个边界条件

3849
02:05:24,000 --> 02:05:25,000
去改变某一个数值

3850
02:05:26,000 --> 02:05:28,000
如果不需要写测试的话

3851
02:05:28,000 --> 02:05:33,000
你可以直接去测验

3852
02:05:34,000 --> 02:05:35,000
验证这个边界条件

3853
02:05:35,000 --> 02:05:37,000
并且马上再改数值

3854
02:05:38,000 --> 02:05:41,000
但是如果你要为了把这一部分的功能

3855
02:05:41,000 --> 02:05:42,000
做的可以测试的话

3856
02:05:42,000 --> 02:05:45,000
你可能会需要把修改数值

3857
02:05:45,000 --> 02:05:47,000
那一部分单独立出去

3858
02:05:47,000 --> 02:05:48,000
专门去测量

3859
02:05:48,000 --> 02:05:50,000
先来测量一下这个边界条件

3860
02:05:51,000 --> 02:05:52,000
诸如此类等等

3861
02:05:53,000 --> 02:05:55,000
当然觉得何必呢

3862
02:05:56,000 --> 02:05:59,000
刚才提到科班培养的

3863
02:05:59,000 --> 02:06:01,000
训练的都没有训练写测试代码

3864
02:06:01,000 --> 02:06:02,000
我想补充一点

3865
02:06:02,000 --> 02:06:03,000
就刚才我讲

3866
02:06:03,000 --> 02:06:05,000
哪怕是我做过这个软件工程

3867
02:06:05,000 --> 02:06:06,000
这种课的助教

3868
02:06:06,000 --> 02:06:07,000
我去看了他们的一些培训

3869
02:06:07,000 --> 02:06:11,000
其实我的感觉在现在的大学的教育里面

3870
02:06:11,000 --> 02:06:13,000
还是没有把这个事情放到一个

3871
02:06:13,000 --> 02:06:14,000
非常重要的地位上来去讲

3872
02:06:15,000 --> 02:06:18,000
可能一方面是因为大学的一个定位

3873
02:06:19,000 --> 02:06:20,000
它并不是说

3874
02:06:20,000 --> 02:06:21,000
我不是一个 vacation school

3875
02:06:21,000 --> 02:06:23,000
vacation school 就是不是一个

3876
02:06:23,000 --> 02:06:24,000
职业技术学院对吧

3877
02:06:24,000 --> 02:06:26,000
我并不是要培养出一帮

3878
02:06:26,000 --> 02:06:27,000
产业工人能够上线直接用的

3879
02:06:27,000 --> 02:06:29,000
而是说培养一种思维

3880
02:06:29,000 --> 02:06:32,000
这种定性的方

3881
02:06:32,000 --> 02:06:35,000
这个出发点会导致他们会轻视

3882
02:06:35,000 --> 02:06:36,000
就重视原理

3883
02:06:36,000 --> 02:06:37,000
轻视实践

3884
02:06:37,000 --> 02:06:39,000
而测试属于那种

3885
02:06:39,000 --> 02:06:41,000
实践远远超过原理的东西

3886
02:06:42,000 --> 02:06:43,000
哪怕是在现在的一些大学里面

3887
02:06:43,000 --> 02:06:45,000
开软件工程的课里面

3888
02:06:45,000 --> 02:06:47,000
他对测试怎么写都只是提前说

3889
02:06:48,000 --> 02:06:50,000
我再给你展示几个案例

3890
02:06:50,000 --> 02:06:52,000
然后你剩下的原理你自己看书去吧

3891
02:06:52,000 --> 02:06:54,000
我可以讲一些大的原则

3892
02:06:54,000 --> 02:06:55,000
但并不会告诉你

3893
02:06:55,000 --> 02:06:57,000
说话说得告诉你怎么去实操这个东西

3894
02:06:57,000 --> 02:06:59,000
所以这也难怪你说

3895
02:06:59,000 --> 02:07:01,000
就哪怕是科班出生了

3896
02:07:01,000 --> 02:07:03,000
他也不会有特别好的这种

3897
02:07:04,000 --> 02:07:06,000
那种实践的经验去写测试

3898
02:07:06,000 --> 02:07:08,000
其实也就牵涉到另外一个问题

3899
02:07:08,000 --> 02:07:12,000
就是作为工程学的计算机软件

3900
02:07:12,000 --> 02:07:14,000
其实可以作为一种降低

3901
02:07:14,000 --> 02:07:16,000
就是所谓的 craftsmanship

3902
02:07:18,000 --> 02:07:21,000
它其实更适合使用这种

3903
02:07:22,000 --> 02:07:25,000
工匠制或者说学徒制的方法来传授

3904
02:07:26,000 --> 02:07:28,000
强调实践

3905
02:07:28,000 --> 02:07:32,000
强调经验的传承

3906
02:07:32,000 --> 02:07:33,000
强调手把手

3907
02:07:33,000 --> 02:07:36,000
比如说敏捷编程里面有一个很重要的原则

3908
02:07:36,000 --> 02:07:38,000
就是节列编程

3909
02:07:39,000 --> 02:07:41,000
两个程序员共用一个键盘

3910
02:07:41,000 --> 02:07:42,000
共用一个鼠标

3911
02:07:42,000 --> 02:07:43,000
共用一个屏幕

3912
02:07:43,000 --> 02:07:44,000
这其实是

3913
02:07:44,000 --> 02:07:47,000
同样也是就像 TDD 那三个原则一样

3914
02:07:47,000 --> 02:07:50,000
非常难以接受的一件事情

3915
02:07:51,000 --> 02:07:52,000
但是其

3916
02:07:53,000 --> 02:07:55,000
就是会就像安利一样

3917
02:07:55,000 --> 02:07:58,000
喜欢他的人会觉得他是非常非常好

3918
02:07:58,000 --> 02:08:00,000
一个实践的原则

3919
02:08:01,000 --> 02:08:05,000
那在大学里面所进行的软件工程的教育

3920
02:08:05,000 --> 02:08:09,000
可能会比较流于理论

3921
02:08:09,000 --> 02:08:10,000
因为

3922
02:08:10,000 --> 02:08:14,000
毕竟在很多时候教授软件工程的教授本身

3923
02:08:14,000 --> 02:08:15,000
可能完全没搞出来

3924
02:08:15,000 --> 02:08:17,000
但是一个比较

3925
02:08:17,000 --> 02:08:21,000
从相对比较学院派的角度去

3926
02:08:23,000 --> 02:08:26,000
再向学生传授一个自己想象之中的软件工程是

3927
02:08:26,000 --> 02:08:28,000
怎样实施

3928
02:08:29,000 --> 02:08:31,000
这是为什么

3929
02:08:31,000 --> 02:08:36,000
测试一直没能得到足够的在课堂里面的重视原理

3930
02:08:36,000 --> 02:08:39,000
因为它本身就不适合课堂

3931
02:08:39,000 --> 02:08:40,000
应该这么说

3932
02:08:41,000 --> 02:08:41,000
对

3933
02:08:44,000 --> 02:08:46,000
其实这还让我想到另外一个问题

3934
02:08:46,000 --> 02:08:47,000
就是

3935
02:08:49,000 --> 02:08:50,000
我不知道你感官是什么样

3936
02:08:50,000 --> 02:08:54,000
就是我好像印象里面有很多女孩子都会在

3937
02:08:55,000 --> 02:08:57,000
毕业之后如果进了软件公司的话

3938
02:08:57,000 --> 02:08:58,000
选择去做测试

3939
02:08:58,000 --> 02:08:59,000
这是为什么

3940
02:09:00,000 --> 02:09:02,000
这个事情我也是很好奇

3941
02:09:02,000 --> 02:09:04,000
因为之前在知乎的时候

3942
02:09:04,000 --> 02:09:07,000
我们最早当的测试的工作

3943
02:09:07,000 --> 02:09:10,000
也是一个女孩子在那边做

3944
02:09:11,000 --> 02:09:12,000
可能有一种传统想象

3945
02:09:12,000 --> 02:09:14,000
认为说女性会心细一些

3946
02:09:15,000 --> 02:09:17,000
我觉得这是一模一样的歧视

3947
02:09:17,000 --> 02:09:18,000
三胖松尾

3948
02:09:18,000 --> 02:09:19,000
我也觉得是

3949
02:09:19,000 --> 02:09:21,000
但是好像你

3950
02:09:21,000 --> 02:09:24,000
就像觉得测试是一个没有创造力

3951
02:09:24,000 --> 02:09:27,000
然后又非常需要心细的人去做

3952
02:09:27,000 --> 02:09:29,000
如果即便不算歧视的话

3953
02:09:29,000 --> 02:09:30,000
至少是一种偏见

3954
02:09:30,000 --> 02:09:30,000
我觉得

3955
02:09:31,000 --> 02:09:31,000
对

3956
02:09:31,000 --> 02:09:32,000
他

3957
02:09:32,000 --> 02:09:35,000
三胖带了一个默认的性别偏见

3958
02:09:35,000 --> 02:09:36,000
就是他觉得

3959
02:09:38,000 --> 02:09:40,000
女性适合于做这种

3960
02:09:41,000 --> 02:09:44,000
扩号没什么技术水准的话

3961
02:09:45,000 --> 02:09:47,000
测试好吧

3962
02:09:48,000 --> 02:09:50,000
但其实测试是相当有技术水准

3963
02:09:50,000 --> 02:09:51,000
如果你要把

3964
02:09:51,000 --> 02:09:53,000
对我觉得要写好一个测试的

3965
02:09:53,000 --> 02:09:54,000
那个 test case 还是

3966
02:09:54,000 --> 02:09:57,000
蛮多事情要考虑的

3967
02:09:57,000 --> 02:09:58,000
但不

3968
02:09:58,000 --> 02:09:59,000
这里面有些测试就是说

3969
02:09:59,000 --> 02:10:01,000
是一个看有的 smoke test

3970
02:10:01,000 --> 02:10:03,000
就是他甚至不会去接触到

3971
02:10:03,000 --> 02:10:03,000
圆码

3972
02:10:03,000 --> 02:10:05,000
只是会说测试成品怎么样

3973
02:10:05,000 --> 02:10:05,000
就是另外一种

3974
02:10:06,000 --> 02:10:07,000
新测试跟我们今天讲的

3975
02:10:07,000 --> 02:10:09,000
那个单元测试还不是一个东西

3976
02:10:11,000 --> 02:10:12,000
这就不展开讲了

3977
02:10:12,000 --> 02:10:13,000
对

3978
02:10:14,000 --> 02:10:15,000
有兴趣的

3979
02:10:15,000 --> 02:10:17,000
或者说对此有感触的

3980
02:10:17,000 --> 02:10:19,000
听众欢迎你写信来谈一谈

3981
02:10:19,000 --> 02:10:20,000
你所遇到的

3982
02:10:20,000 --> 02:10:22,000
开启的吐槽模式

3983
02:10:22,000 --> 02:10:22,000
对

3984
02:10:23,000 --> 02:10:24,000
是不是很多

3985
02:10:24,000 --> 02:10:25,000
乃至于我相信

3986
02:10:25,000 --> 02:10:26,000
也许我们的听众里面

3987
02:10:26,000 --> 02:10:28,000
的确有很多做测试的女孩子

3988
02:10:28,000 --> 02:10:30,000
女性听众

3989
02:10:31,000 --> 02:10:31,000
不妨也谈谈

3990
02:10:31,000 --> 02:10:33,000
你为什么会选择去做测试

3991
02:10:33,000 --> 02:10:34,000
乃至于你觉得

3992
02:10:35,000 --> 02:10:37,000
测试真的

3993
02:10:37,000 --> 02:10:39,000
比较适合

3994
02:10:39,000 --> 02:10:40,000
女性吗

3995
02:10:41,000 --> 02:10:43,000
然后你觉得你有这个过程中

3996
02:10:43,000 --> 02:10:44,000
你有成就感吗

3997
02:10:44,000 --> 02:10:44,000
对

3998
02:10:45,000 --> 02:10:46,000
欢迎来信

3999
02:10:47,000 --> 02:10:48,000
长短不限

4000
02:10:50,000 --> 02:10:51,000
OK

4001
02:10:51,000 --> 02:10:52,000
那

4002
02:10:53,000 --> 02:10:53,000
根据提招

4003
02:10:53,000 --> 02:10:55,000
我们接下来要讲到的是

4004
02:10:55,000 --> 02:10:56,000
一系列

4005
02:10:57,000 --> 02:10:58,000
和单元测试相关的工具

4006
02:10:59,000 --> 02:11:00,000
就是

4007
02:11:01,000 --> 02:11:04,000
本意也是希望对测试感兴趣的人

4008
02:11:05,000 --> 02:11:06,000
听众可以

4009
02:11:06,000 --> 02:11:08,000
而对测试没有足够多经验的

4010
02:11:08,000 --> 02:11:09,000
听众可以去

4011
02:11:09,000 --> 02:11:10,000
找一些

4012
02:11:10,000 --> 02:11:12,000
就可以去搜一些相关的工具

4013
02:11:12,000 --> 02:11:13,000
然后看一看

4014
02:11:13,000 --> 02:11:14,000
咱们是怎么使用的

4015
02:11:14,000 --> 02:11:16,000
总之进行到下一个环节之前

4016
02:11:16,000 --> 02:11:18,000
我们可以最后来吐槽一下

4017
02:11:18,000 --> 02:11:19,000
这个 TED

4018
02:11:19,000 --> 02:11:20,000
我觉得

4019
02:11:21,000 --> 02:11:22,000
火力全开

4020
02:11:22,000 --> 02:11:23,000
来吧

4021
02:11:23,000 --> 02:11:24,000
对

4022
02:11:24,000 --> 02:11:25,000
我觉得 TED 非常印度

4023
02:11:26,000 --> 02:11:27,000
非常什么

4024
02:11:27,000 --> 02:11:28,000
非常印度

4025
02:11:30,000 --> 02:11:31,000
这怎么讲

4026
02:11:31,000 --> 02:11:32,000
这是一个非常地图炮

4027
02:11:32,000 --> 02:11:34,000
而且地域歧视的说法

4028
02:11:34,000 --> 02:11:34,000
就是

4029
02:11:35,000 --> 02:11:37,000
TED 是一个

4030
02:11:39,000 --> 02:11:41,000
为了保证质量

4031
02:11:42,000 --> 02:11:43,000
而忽视了

4032
02:11:45,000 --> 02:11:48,000
而压抑了人的创造性的这么一个

4033
02:11:50,000 --> 02:11:51,000
软件方法

4034
02:11:52,000 --> 02:11:54,000
你可以说 TED 的出现是历史的必然

4035
02:11:54,000 --> 02:11:55,000
就好像

4036
02:11:56,000 --> 02:11:57,000
福特 T 型车

4037
02:11:57,000 --> 02:11:58,000
会在

4038
02:11:58,000 --> 02:12:00,000
会以流水线的方式来生产

4039
02:12:00,000 --> 02:12:01,000
是历史的必然

4040
02:12:01,000 --> 02:12:02,000
但是

4041
02:12:04,000 --> 02:12:07,000
也正是因为 TED 或者说流水线的出现

4042
02:12:07,000 --> 02:12:09,000
这种所谓 mass production 的出现

4043
02:12:10,000 --> 02:12:11,000
导致了

4044
02:12:13,000 --> 02:12:14,000
human

4045
02:12:15,000 --> 02:12:17,000
变成了 human resource

4046
02:12:19,000 --> 02:12:21,000
我这么说可能

4047
02:12:21,000 --> 02:12:23,000
扯得有点大

4048
02:12:23,000 --> 02:12:24,000
有点形而上

4049
02:12:24,000 --> 02:12:25,000
但

4050
02:12:25,000 --> 02:12:27,000
没有我觉得这个很好

4051
02:12:27,000 --> 02:12:27,000
我觉得这个点很好

4052
02:12:27,000 --> 02:12:28,000
就是如果你看

4053
02:12:29,000 --> 02:12:31,000
一个公司一旦出现了 HR 这个部门之后

4054
02:12:32,000 --> 02:12:35,000
这个公司通常都会有一点点问题

4055
02:12:36,000 --> 02:12:38,000
对就好像

4056
02:12:40,000 --> 02:12:41,000
Benz 在

4057
02:12:42,000 --> 02:12:43,000
开发第一辆车的时候

4058
02:12:43,000 --> 02:12:47,000
它显然不会给每一个零件做测试

4059
02:12:48,000 --> 02:12:50,000
AT&T 贝尔实验室的

4060
02:12:51,000 --> 02:12:53,000
hackers 们在一开始写

4061
02:12:53,000 --> 02:12:54,000
第一版 Linux

4062
02:12:54,000 --> 02:12:56,000
Uniqs 的时候可能也不会

4063
02:12:57,000 --> 02:12:58,000
去写单元测试

4064
02:12:59,000 --> 02:13:01,000
真正具有创造性的工作是

4065
02:13:02,000 --> 02:13:03,000
不会写测试

4066
02:13:05,000 --> 02:13:08,000
我觉得 TED 最大的问题就是它打破了

4067
02:13:08,000 --> 02:13:10,000
创造的流 flow

4068
02:13:12,000 --> 02:13:14,000
比如你在想你在做一件很投入

4069
02:13:14,000 --> 02:13:16,000
很有创造性的事情

4070
02:13:16,000 --> 02:13:17,000
你会进入一种状态

4071
02:13:17,000 --> 02:13:20,000
你会持续做一个创造性的工作

4072
02:13:20,000 --> 02:13:23,000
去构建一整套的东西出来在脑海中

4073
02:13:23,000 --> 02:13:25,000
然后把它落实到笔头也好

4074
02:13:25,000 --> 02:13:26,000
还是键盘上也好

4075
02:13:26,000 --> 02:13:28,000
把它变成一个实体的物件

4076
02:13:28,000 --> 02:13:29,000
但是

4077
02:13:29,000 --> 02:13:33,000
TED 其实是把这个流给切成无数的碎片

4078
02:13:33,000 --> 02:13:36,000
然后你不断的在跳来跳出

4079
02:13:36,000 --> 02:13:38,000
跳入跳出去写测试

4080
02:13:38,000 --> 02:13:40,000
然后再跳回来创造

4081
02:13:40,000 --> 02:13:41,000
整个 flow 就已经没有了

4082
02:13:42,000 --> 02:13:42,000
对

4083
02:13:42,000 --> 02:13:45,000
我觉得在 TED 的整个过程里面

4084
02:13:45,000 --> 02:13:48,000
唯一爽的人其实就是架构师

4085
02:13:48,000 --> 02:13:50,000
或者说是拆分工作的人

4086
02:13:50,000 --> 02:13:50,000
没错

4087
02:13:50,000 --> 02:13:52,000
他是唯一一个有创造性的角色

4088
02:13:53,000 --> 02:13:55,000
对他把那个什么蓝

4089
02:13:55,000 --> 02:13:57,000
blueprint 都给你画好了

4090
02:13:57,000 --> 02:13:58,000
然后你说

4091
02:13:58,000 --> 02:13:59,000
你们这些

4092
02:14:00,000 --> 02:14:01,000
包工头

4093
02:14:01,000 --> 02:14:03,000
human resource

4094
02:14:03,000 --> 02:14:03,000
什么包工头

4095
02:14:03,000 --> 02:14:04,000
你们这些小工

4096
02:14:05,000 --> 02:14:06,000
造这个图纸干就好了

4097
02:14:06,000 --> 02:14:07,000
你们如果干不好

4098
02:14:07,000 --> 02:14:08,000
我随时可以换一个人

4099
02:14:09,000 --> 02:14:10,000
没错

4100
02:14:10,000 --> 02:14:10,000
对

4101
02:14:10,000 --> 02:14:13,000
就好像在建筑领域里面

4102
02:14:13,000 --> 02:14:15,000
一个建筑造了再

4103
02:14:16,000 --> 02:14:18,000
委轮委换再功能完善

4104
02:14:18,000 --> 02:14:20,000
人们也只会记住建筑师的名字

4105
02:14:20,000 --> 02:14:22,000
而不是你搬砖的小王的名字

4106
02:14:22,000 --> 02:14:23,000
对

4107
02:14:24,000 --> 02:14:26,000
这就是为什么我看到任何一个

4108
02:14:27,000 --> 02:14:30,000
nforce TDD 的公司都会觉得

4109
02:14:31,000 --> 02:14:33,000
简直是 living hell

4110
02:14:34,000 --> 02:14:35,000
能躲就躲是吧

4111
02:14:35,000 --> 02:14:36,000
对

4112
02:14:36,000 --> 02:14:37,000
这其实让我想起来

4113
02:14:37,000 --> 02:14:39,000
前阵子刘一说

4114
02:14:39,000 --> 02:14:42,000
在有一期 ID 公众里面

4115
02:14:42,000 --> 02:14:44,000
你们提到一个独立游戏开发者说

4116
02:14:45,000 --> 02:14:46,000
什么去 EA

4117
02:14:46,000 --> 02:14:48,000
或者是去 EA 这样的大公司

4118
02:14:48,000 --> 02:14:49,000
大的游戏公司

4119
02:14:50,000 --> 02:14:51,000
简直就是 hell

4120
02:14:51,000 --> 02:14:52,000
对

4121
02:14:52,000 --> 02:14:53,000
有类似的原因

4122
02:14:53,000 --> 02:14:54,000
对

4123
02:14:54,000 --> 02:14:55,000
它的道理其实就是

4124
02:14:55,000 --> 02:14:57,000
你在这样的公司里面扮演的

4125
02:14:57,000 --> 02:14:59,000
其实就是一个流水线上的工人

4126
02:15:00,000 --> 02:15:00,000
然后你

4127
02:15:00,000 --> 02:15:01,000
steam 啊传说中的

4128
02:15:02,000 --> 02:15:02,000
对

4129
02:15:02,000 --> 02:15:03,000
你的个性被抹杀了

4130
02:15:03,000 --> 02:15:05,000
你成为 human resource

4131
02:15:05,000 --> 02:15:07,000
然后

4132
02:15:08,000 --> 02:15:10,000
你唯一出现的就是最终的演织原表里面

4133
02:15:10,000 --> 02:15:11,000
一个

4134
02:15:11,000 --> 02:15:14,000
没有大部分玩家都会立刻按 A

4135
02:15:14,000 --> 02:15:16,000
去跳过什么一个字幕里面的一部分

4136
02:15:17,000 --> 02:15:18,000
是

4137
02:15:18,000 --> 02:15:20,000
不过这件事如果反过来讲

4138
02:15:20,000 --> 02:15:21,000
也可以说

4139
02:15:21,000 --> 02:15:23,000
这样才可以保证出品的稳定

4140
02:15:23,000 --> 02:15:23,000
对吧

4141
02:15:23,000 --> 02:15:24,000
如果

4142
02:15:24,000 --> 02:15:25,000
也只有采用这样的方式

4143
02:15:25,000 --> 02:15:27,000
也只有采用这种不信任人

4144
02:15:27,000 --> 02:15:30,000
让人成为可以被替换的零件的方式

4145
02:15:30,000 --> 02:15:33,000
才可以做出规模足够大的东西

4146
02:15:33,000 --> 02:15:35,000
这个我是毫不否认的

4147
02:15:35,000 --> 02:15:38,000
而且就是能保证他的出品是稳定的

4148
02:15:38,000 --> 02:15:39,000
就好像为什么

4149
02:15:39,000 --> 02:15:41,000
我们老是吐槽说

4150
02:15:41,000 --> 02:15:42,000
中餐难以标准化

4151
02:15:43,000 --> 02:15:45,000
因为他的出品不够稳定

4152
02:15:45,000 --> 02:15:46,000
你换一个人

4153
02:15:46,000 --> 02:15:47,000
换一个厨师

4154
02:15:47,000 --> 02:15:49,000
或者甚至换一种调料

4155
02:15:49,000 --> 02:15:49,000
这个事情

4156
02:15:49,000 --> 02:15:51,000
就就就就口味就变掉了

4157
02:15:52,000 --> 02:15:53,000
所以

4158
02:15:53,000 --> 02:15:54,000
我就是在想

4159
02:15:54,000 --> 02:15:56,000
这个到底是一个怎么样的情况

4160
02:15:56,000 --> 02:15:57,000
怎么能才能够

4161
02:15:57,000 --> 02:15:59,000
拿到良辙的好处

4162
02:15:59,000 --> 02:16:00,000
从此避免良辙的短板

4163
02:16:00,000 --> 02:16:03,000
好像现在看来没有什么太好的解决方案

4164
02:16:03,000 --> 02:16:05,000
我觉得一个解决方案可能就是人工智能

4165
02:16:05,000 --> 02:16:06,000
就是

4166
02:16:06,000 --> 02:16:06,000
因为

4167
02:16:07,000 --> 02:16:08,000
TDD

4168
02:16:09,000 --> 02:16:11,000
可能现在 TDD 还太原始

4169
02:16:11,000 --> 02:16:15,000
就是假如将来我们可以直接先给出所有的边境条件

4170
02:16:15,000 --> 02:16:19,000
然后让 AI 自己去帮我们写出程序来

4171
02:16:19,000 --> 02:16:20,000
可能

4172
02:16:21,000 --> 02:16:21,000
到那个时候

4173
02:16:21,000 --> 02:16:24,000
我们也就不需要再为这种事情发愁了

4174
02:16:24,000 --> 02:16:25,000
因为其实这个已经也有了

4175
02:16:25,000 --> 02:16:27,000
这个所谓的什么第四代编程语言

4176
02:16:27,000 --> 02:16:28,000
不就做这种事情

4177
02:16:28,000 --> 02:16:30,000
人指定一个 constraint

4178
02:16:30,000 --> 02:16:32,000
他自己去解决

4179
02:16:32,000 --> 02:16:34,000
怎么去找到

4180
02:16:34,000 --> 02:16:36,000
满足 constraint 的一个解

4181
02:16:36,000 --> 02:16:38,000
但是效率是很成问题的

4182
02:16:40,000 --> 02:16:40,000
对

4183
02:16:40,000 --> 02:16:42,000
然后这个就又

4184
02:16:42,000 --> 02:16:45,000
跟我们之前提到的那个

4185
02:16:46,000 --> 02:16:47,000
The Rabbits

4186
02:16:47,000 --> 02:16:48,000
还是

4187
02:16:49,000 --> 02:16:50,000
那个网站叫什么来着

4188
02:16:50,000 --> 02:16:52,000
那个带

4189
02:16:52,000 --> 02:16:52,000
对

4190
02:16:52,000 --> 02:16:54,000
带一些代码那个

4191
02:16:54,000 --> 02:16:55,000
你会叫什么来着

4192
02:16:56,000 --> 02:16:56,000
对

4193
02:16:56,000 --> 02:16:57,000
反正和兔子有关

4194
02:16:59,000 --> 02:16:59,000
然后

4195
02:16:59,000 --> 02:17:01,000
就叫 The Rabbits 吧

4196
02:17:01,000 --> 02:17:02,000
OK The Rabbits

4197
02:17:03,000 --> 02:17:05,000
以及和之前和沐阳聊到了

4198
02:17:05,000 --> 02:17:08,000
没能跟沐阳聊起的那个话题就是

4199
02:17:09,000 --> 02:17:11,000
计算机可以做数学

4200
02:17:12,000 --> 02:17:13,000
计算机可以做出

4201
02:17:14,000 --> 02:17:16,000
计算机可以设计出来一个

4202
02:17:17,000 --> 02:17:18,000
有创造性的算法

4203
02:17:19,000 --> 02:17:20,000
其实也是

4204
02:17:21,000 --> 02:17:23,000
目前现阶段看来不太可能也是

4205
02:17:23,000 --> 02:17:24,000
就是

4206
02:17:24,000 --> 02:17:26,000
我们也许可以通过 TDD

4207
02:17:26,000 --> 02:17:29,000
通过第四代第五代计算机语言来

4208
02:17:29,000 --> 02:17:31,000
完成一些枯燥的

4209
02:17:31,000 --> 02:17:32,000
只有现阶段

4210
02:17:32,000 --> 02:17:35,000
只有依靠 TDD 或者 BDD 才可以

4211
02:17:35,000 --> 02:17:36,000
达到的

4212
02:17:37,000 --> 02:17:38,000
大规模软件

4213
02:17:38,000 --> 02:17:41,000
就所谓的穷局法证明吗

4214
02:17:41,000 --> 02:17:42,000
对

4215
02:17:43,000 --> 02:17:44,000
说这个其实已经有

4216
02:17:44,000 --> 02:17:46,000
像 TDD 那个证明那个叫什么来着

4217
02:17:46,000 --> 02:17:49,000
D 叫什么 Coloring Problems

4218
02:17:49,000 --> 02:17:51,000
地图填色的那个难题

4219
02:17:51,000 --> 02:17:53,000
四色定理

4220
02:17:53,000 --> 02:17:54,000
对四色定理

4221
02:17:54,000 --> 02:17:55,000
那个好像不是证明出来吗

4222
02:17:55,000 --> 02:17:57,000
就是靠暴力不见

4223
02:17:57,000 --> 02:17:57,000
对

4224
02:17:57,000 --> 02:17:57,000
对

4225
02:17:57,000 --> 02:17:59,000
这个就是 T 就是什么

4226
02:17:59,000 --> 02:18:00,000
数学领域的 TDD 吧

4227
02:18:01,000 --> 02:18:01,000
对

4228
02:18:04,000 --> 02:18:05,000
也不尽然

4229
02:18:05,000 --> 02:18:06,000
那对

4230
02:18:07,000 --> 02:18:09,000
各位理解这什么意思都好

4231
02:18:11,000 --> 02:18:12,000
有神似之处

4232
02:18:12,000 --> 02:18:13,000
但并不是一回事

4233
02:18:14,000 --> 02:18:14,000
另外一个

4234
02:18:14,000 --> 02:18:16,000
我又想起来一个暴力的方法

4235
02:18:16,000 --> 02:18:17,000
就是

4236
02:18:18,000 --> 02:18:19,000
说最近

4237
02:18:19,000 --> 02:18:22,000
近一段时间维旗的 AI 有比较大的提升

4238
02:18:22,000 --> 02:18:24,000
就是因为他们采用了一种

4239
02:18:25,000 --> 02:18:26,000
比较暴力的算法

4240
02:18:26,000 --> 02:18:27,000
就是穷局所有

4241
02:18:28,000 --> 02:18:30,000
用蒙特卡洛算法

4242
02:18:31,000 --> 02:18:33,000
随机的去

4243
02:18:33,000 --> 02:18:37,000
随机的去采用一些可能的走法

4244
02:18:37,000 --> 02:18:39,000
然后从里面找出来一个

4245
02:18:40,000 --> 02:18:41,000
效果最好的

4246
02:18:41,000 --> 02:18:44,000
然后成功的让业余起手

4247
02:18:45,000 --> 02:18:47,000
基本上没有人能够下过这个维旗算法

4248
02:18:48,000 --> 02:18:48,000
OK

4249
02:18:48,000 --> 02:18:51,000
回头可以把相关的报道找出来

4250
02:18:51,000 --> 02:18:53,000
大概就是这个意思

4251
02:18:56,000 --> 02:18:58,000
我觉得 TDD 是一个

4252
02:19:00,000 --> 02:19:01,000
是历史的必然

4253
02:19:01,000 --> 02:19:05,000
但就好像这个汽车的生产线

4254
02:19:07,000 --> 02:19:09,000
可能还有一些地方是在用手工

4255
02:19:09,000 --> 02:19:11,000
但至少德国基本上四大车厂

4256
02:19:11,000 --> 02:19:13,000
全都是在用机器人

4257
02:19:14,000 --> 02:19:16,000
来完成那些以往需要人类

4258
02:19:16,000 --> 02:19:18,000
才可以完成的流水线工作

4259
02:19:18,000 --> 02:19:19,000
将来我觉得

4260
02:19:20,000 --> 02:19:23,000
这些比较低级的代码

4261
02:19:24,000 --> 02:19:25,000
的验证

4262
02:19:26,000 --> 02:19:27,000
乃至于生成工作

4263
02:19:27,000 --> 02:19:29,000
应该是可以交由人工智能自动完成

4264
02:19:30,000 --> 02:19:33,000
所以这就是我为什么说 TDD 非常印度

4265
02:19:33,000 --> 02:19:35,000
就是因为印度家里

4266
02:19:35,000 --> 02:19:37,000
我只不过不愿意说中国

4267
02:19:38,000 --> 02:19:38,000
就是在

4268
02:19:40,000 --> 02:19:41,000
这个第三世界国家

4269
02:19:41,000 --> 02:19:42,000
确实是很印度

4270
02:19:42,000 --> 02:19:43,000
因为那个

4271
02:19:43,000 --> 02:19:45,000
亚马逊那个 Mechanic Turk

4272
02:19:46,000 --> 02:19:47,000
好像那些服务商都在印度

4273
02:19:48,000 --> 02:19:51,000
但这种说法比较怎么说政治不正确

4274
02:19:51,000 --> 02:19:53,000
但是我们也没有在追求政治正确

4275
02:19:53,000 --> 02:19:54,000
所以

4276
02:19:54,000 --> 02:19:57,000
一言下之意就是在第三世界国家这种

4277
02:19:58,000 --> 02:19:59,000
密集脑力劳动的

4278
02:20:00,000 --> 02:20:01,000
产业

4279
02:20:01,000 --> 02:20:03,000
链的这样一个

4280
02:20:03,000 --> 02:20:04,000
环节

4281
02:20:04,000 --> 02:20:05,000
这还算脑力劳动

4282
02:20:05,000 --> 02:20:06,000
这个算体力活了吧

4283
02:20:06,000 --> 02:20:06,000
已经

4284
02:20:07,000 --> 02:20:09,000
区分脑力劳动和体力劳动的区别

4285
02:20:09,000 --> 02:20:10,000
只是你用不用敲电盘

4286
02:20:11,000 --> 02:20:11,000
我觉得

4287
02:20:12,000 --> 02:20:13,000
TDD 还是要敲电盘

4288
02:20:14,000 --> 02:20:15,000
所以还是

4289
02:20:17,000 --> 02:20:19,000
只有在这样一个环节里面

4290
02:20:19,000 --> 02:20:23,000
我相信在印度这帮人还是会定性为高科技产业的

4291
02:20:23,000 --> 02:20:24,000
那肯定

4292
02:20:26,000 --> 02:20:28,000
但是这种说法其实也比较偏激

4293
02:20:28,000 --> 02:20:29,000
或者说比较

4294
02:20:30,000 --> 02:20:30,000
Cynical

4295
02:20:30,000 --> 02:20:32,000
因为其实在美国

4296
02:20:32,000 --> 02:20:35,000
在欧美还是有大量的

4297
02:20:35,000 --> 02:20:36,000
企业

4298
02:20:36,000 --> 02:20:37,000
会

4299
02:20:37,000 --> 02:20:42,000
采用类似于 BED 的方法来开发自己的软件

4300
02:20:42,000 --> 02:20:42,000
而且

4301
02:20:43,000 --> 02:20:45,000
即便硅谷的这些

4302
02:20:46,000 --> 02:20:49,000
单红炸子机们也是有很多会非常强

4303
02:20:49,000 --> 02:20:52,000
我相信 Facebook 也是一个非常强调测试的公司

4304
02:20:53,000 --> 02:20:55,000
微软就不用说了

4305
02:20:55,000 --> 02:20:56,000
微软据说有一个

4306
02:20:57,000 --> 02:21:00,000
非常非常非常非常大的测试部门

4307
02:21:02,000 --> 02:21:04,000
他们不是整个公司都是测试部门吗

4308
02:21:06,000 --> 02:21:06,000
这样不好

4309
02:21:07,000 --> 02:21:09,000
都在测试 Windows 10 的 Beta

4310
02:21:09,000 --> 02:21:10,000
不,Alpha

4311
02:21:11,000 --> 02:21:12,000
之类的

4312
02:21:12,000 --> 02:21:14,000
所以苹果是不怎么喜欢写测试的

4313
02:21:14,000 --> 02:21:15,000
你觉得

4314
02:21:15,000 --> 02:21:16,000
Who knows

4315
02:21:16,000 --> 02:21:19,000
看他们出品的这个质量应该是不写的吧

4316
02:21:19,000 --> 02:21:20,000
对

4317
02:21:20,000 --> 02:21:21,000
当然不

4318
02:21:21,000 --> 02:21:25,000
毕竟这一次 WDDC 上发布的这一系列

4319
02:21:26,000 --> 02:21:27,000
在怎么说呢

4320
02:21:27,000 --> 02:21:30,000
在偿还他们的技术债务的补丁

4321
02:21:30,000 --> 02:21:31,000
我觉得还是

4322
02:21:32,000 --> 02:21:33,000
比较好

4323
02:21:33,000 --> 02:21:37,000
就是软件质量至少在

4324
02:21:38,000 --> 02:21:39,000
这一代叫什么

4325
02:21:39,000 --> 02:21:40,000
Al Capitan

4326
02:21:41,000 --> 02:21:42,000
在这一代

4327
02:21:42,000 --> 02:21:43,000
对

4328
02:21:43,000 --> 02:21:46,000
在这一代没有太大的新特性

4329
02:21:46,000 --> 02:21:46,000
对

4330
02:21:46,000 --> 02:21:51,000
所以就说明他们把时间都花在了修办什么

4331
02:21:51,000 --> 02:21:52,000
那也不一定

4332
02:21:52,000 --> 02:21:55,000
你可能在搞什么 WatchOS 之类的事情

4333
02:21:56,000 --> 02:21:57,000
I don't say

4334
02:21:57,000 --> 02:21:58,000
好吧

4335
02:21:59,000 --> 02:22:01,000
就是不要太乐观我觉得

4336
02:22:02,000 --> 02:22:03,000
OK

4337
02:22:04,000 --> 02:22:07,000
所以我们接下来可以进入到本期的最后一个环节

4338
02:22:07,000 --> 02:22:09,000
就是介绍一些常用的

4339
02:22:10,000 --> 02:22:11,000
写测试的工具

4340
02:22:13,000 --> 02:22:15,000
尤其是 Unit Test

4341
02:22:15,000 --> 02:22:16,000
就是单元测试

4342
02:22:16,000 --> 02:22:19,000
单元测试是所有的你所能写的测试里面

4343
02:22:19,000 --> 02:22:20,000
最颗粒最小的一个

4344
02:22:20,000 --> 02:22:21,000
同时也是

4345
02:22:22,000 --> 02:22:25,000
作为一个开发者而不是 QA 人员

4346
02:22:25,000 --> 02:22:27,000
也就是软件检测者来说

4347
02:22:27,000 --> 02:22:29,000
所能接触到的最普

4348
02:22:29,000 --> 02:22:31,000
最常见的一种测试

4349
02:22:31,000 --> 02:22:34,000
首先要介绍给大家的就是 XUnit Family

4350
02:22:37,000 --> 02:22:38,000
怎么说呢

4351
02:22:38,000 --> 02:22:40,000
就是因为单元测试

4352
02:22:40,000 --> 02:22:40,000
对

4353
02:22:40,000 --> 02:22:41,000
X 单元 Family

4354
02:22:42,000 --> 02:22:47,000
就是因为单元测试非常非常的普遍

4355
02:22:47,000 --> 02:22:48,000
以至于有这么一套

4356
02:22:51,000 --> 02:22:52,000
Pattern

4357
02:22:52,000 --> 02:22:57,000
可以被套用在各个语言所写的程序里面

4358
02:22:58,000 --> 02:23:01,000
而这个 Pattern 在最开始的创始人

4359
02:23:01,000 --> 02:23:09,000
是一个叫做 Kent Beck 的大神

4360
02:23:09,000 --> 02:23:10,000
他应该也算大神

4361
02:23:10,000 --> 02:23:17,000
而他最开始所写的这一套 Unit Test 的工具

4362
02:23:17,000 --> 02:23:19,000
是叫做 SUnit

4363
02:23:20,000 --> 02:23:22,000
是写给 Small Tokyo

4364
02:23:23,000 --> 02:23:24,000
跟 Sunit

4365
02:23:24,000 --> 02:23:26,000
对跟 Sun 没什么关系

4366
02:23:26,000 --> 02:23:27,000
至少是 Sunit

4367
02:23:28,000 --> 02:23:31,000
你是说他是可以念出来的是吧

4368
02:23:31,000 --> 02:23:34,000
我觉得是 Sunit

4369
02:23:36,000 --> 02:23:37,000
所以这一 Unit 应该怎么念

4370
02:23:37,000 --> 02:23:38,000
Johnit

4371
02:23:39,000 --> 02:23:39,000
Johnit

4372
02:23:42,000 --> 02:23:44,000
怎么像 Janitor

4373
02:23:44,000 --> 02:23:47,000
而 RUnit 就是 Ruint

4374
02:23:48,000 --> 02:23:49,000
毁了它吧

4375
02:23:49,000 --> 02:23:50,000
不是 Runit

4376
02:23:50,000 --> 02:23:54,000
对

4377
02:23:54,000 --> 02:23:56,000
我还是轻轻把它念成 SUnit

4378
02:23:56,000 --> 02:23:57,000
Sunit

4379
02:23:57,000 --> 02:23:59,000
对就是一个正确的念法

4380
02:24:00,000 --> 02:24:00,000
OK

4381
02:24:01,000 --> 02:24:04,000
Kent Beck 这个人为 Small Talk

4382
02:24:04,000 --> 02:24:07,000
所研发出的这一套单元测试的工具

4383
02:24:09,000 --> 02:24:14,000
在紧紧跟随着极限编程的方法

4384
02:24:14,000 --> 02:24:18,000
以及整个项铭节转向的这么一个软件工程的潮流

4385
02:24:19,000 --> 02:24:22,000
逐渐被套用到了其他几乎所有语言上面

4386
02:24:22,000 --> 02:24:24,000
甚至几乎这两个字都不用加

4387
02:24:24,000 --> 02:24:26,000
除了什么 brainfac 之外

4388
02:24:28,000 --> 02:24:34,000
可能没有不支持 Xunit 的原存在

4389
02:24:35,000 --> 02:24:41,000
基本上你能想出来的什么 C、PHP、Ruby、Java

4390
02:24:41,000 --> 02:24:42,000
Java 就更不如说了

4391
02:24:42,000 --> 02:24:44,000
JUnit 简直是 Java 世界里面

4392
02:24:46,000 --> 02:24:47,000
如果你想要找到工作

4393
02:24:47,000 --> 02:24:48,000
一定要学什么一个工具

4394
02:24:49,000 --> 02:24:51,000
然后.net 世界

4395
02:24:51,000 --> 02:24:52,000
当然也有相应的

4396
02:24:52,000 --> 02:24:58,000
比如说 NUnit 或者是微软自家出的

4397
02:24:58,000 --> 02:24:59,000
之前叫 MS test

4398
02:25:00,000 --> 02:25:01,000
后来改叫 VS test

4399
02:25:01,000 --> 02:25:03,000
Visual Studio test

4400
02:25:05,000 --> 02:25:10,000
然后如果你使用 Objective-C 的话

4401
02:25:10,000 --> 02:25:12,000
之前有所谓 XC test

4402
02:25:13,000 --> 02:25:15,000
XC stand for Xcode

4403
02:25:15,000 --> 02:25:15,000
对

4404
02:25:15,000 --> 02:25:19,000
XC test 就好像 VS test 一样

4405
02:25:19,000 --> 02:25:25,000
是在 Xcode 里面执行的专门为 Objective-C

4406
02:25:25,000 --> 02:25:27,000
以及 SWIFT 应该也有

4407
02:25:28,000 --> 02:25:30,000
所开发的单元测试框架

4408
02:25:31,000 --> 02:25:34,000
其实这边直接给一个链接就好了

4409
02:25:34,000 --> 02:25:36,000
因为 Wikipedia 上有一个比较好的

4410
02:25:39,000 --> 02:25:42,000
叫做 List of unit testing frameworks

4411
02:25:42,000 --> 02:25:43,000
对

4412
02:25:43,000 --> 02:25:44,000
然后

4413
02:25:44,000 --> 02:25:49,000
这个我们想要说的一个比较有意思的东西

4414
02:25:49,000 --> 02:25:50,000
其实是 Dock test

4415
02:25:51,000 --> 02:25:52,000
我不知道你用不用过

4416
02:25:53,000 --> 02:25:55,000
就是 Python 的语言里面有一个

4417
02:25:56,000 --> 02:25:58,000
当然有一个 Unit test 包

4418
02:25:58,000 --> 02:26:00,000
然后另外 Python 有一个很有意思的包

4419
02:26:00,000 --> 02:26:02,000
叫做 Dock test

4420
02:26:03,000 --> 02:26:04,000
你用过吗

4421
02:26:05,000 --> 02:26:06,000
一个不写测试的

4422
02:26:06,000 --> 02:26:13,000
这比较想要安利一下的东西

4423
02:26:13,000 --> 02:26:15,000
就是 Dock test 这个东西

4424
02:26:15,000 --> 02:26:19,000
它有意思或者说它实用的点在哪呢

4425
02:26:19,000 --> 02:26:23,000
就是我们知道如果你在一个方法或者在一个类里面

4426
02:26:25,000 --> 02:26:27,000
它的定义下面直接写一个 String

4427
02:26:28,000 --> 02:26:31,000
这个东西被称为 Dock String

4428
02:26:31,000 --> 02:26:31,000
对吧

4429
02:26:32,000 --> 02:26:33,000
OK

4430
02:26:33,000 --> 02:26:34,000
然后你想起来

4431
02:26:34,000 --> 02:26:37,000
我有见到过这个

4432
02:26:37,000 --> 02:26:38,000
但自己没有使过

4433
02:26:38,000 --> 02:26:39,000
OK

4434
02:26:39,000 --> 02:26:42,000
然后 Dock test 这个包所支持的一个功能

4435
02:26:42,000 --> 02:26:44,000
就是你可以在 Dock String 里面

4436
02:26:44,000 --> 02:26:47,000
写一些测试

4437
02:26:48,000 --> 02:26:49,000
语法很简单

4438
02:26:49,000 --> 02:26:55,000
就是 Python 的提示符大家都知道是三个相用的代理号

4439
02:26:55,000 --> 02:26:55,000
对吧

4440
02:26:56,000 --> 02:27:01,000
那么你只需要在 Dock String 里面写三个相用的代理号

4441
02:27:01,000 --> 02:27:05,000
然后写这个测试所应该执行的语句

4442
02:27:06,000 --> 02:27:11,000
然后在信令起义好像在不写三个代理号的情况下

4443
02:27:11,000 --> 02:27:14,000
写出这个程序执行之后所应该有的指

4444
02:27:15,000 --> 02:27:16,000
你就写好了一个测试

4445
02:27:16,000 --> 02:27:17,000
是不是很神奇呢

4446
02:27:17,000 --> 02:27:24,000
就好像你在 Dock String 里面给你的函数写了一个用法的视力

4447
02:27:25,000 --> 02:27:28,000
然后这个视力本身忽然就可以当作单元测试来用了

4448
02:27:28,000 --> 02:27:29,000
对

4449
02:27:29,000 --> 02:27:33,000
这是一个非常好的一个工具

4450
02:27:33,000 --> 02:27:38,000
但我觉得唯一的问题就是有时候力度

4451
02:27:38,000 --> 02:27:41,000
它不是一个 unit 的时候你也没法用这个方法

4452
02:27:41,000 --> 02:27:42,000
对

4453
02:27:42,000 --> 02:27:45,000
就 Dock test 仅限于 unit test 用

4454
02:27:46,000 --> 02:27:48,000
一旦跨了一个函数就不行

4455
02:27:48,000 --> 02:27:50,000
其实也是有别的方法

4456
02:27:50,000 --> 02:27:57,000
比如说 Dock test 这个包可以单独拿出来生成一个专门的 Python 文件

4457
02:27:57,000 --> 02:28:06,000
然后这个 Python 文件里面除了这样 Dock test 的语法写成的测试之外

4458
02:28:06,000 --> 02:28:06,000
别无他物

4459
02:28:06,000 --> 02:28:12,000
然后你可以在这里面用 Dock test 来

4460
02:28:12,000 --> 02:28:15,000
或是滥用 Dock test 来写一些跨模块

4461
02:28:15,000 --> 02:28:17,000
跨函数乃至跨模块的测试

4462
02:28:19,000 --> 02:28:21,000
Zop 有一个测试方案就是干这个

4463
02:28:22,000 --> 02:28:32,000
不过 Dock test 其实有点像 Donna Knuth 的 Literate Programming

4464
02:28:32,000 --> 02:28:32,000
反过来做

4465
02:28:32,000 --> 02:28:35,000
Literate Programming 中的翻译叫什么来的

4466
02:28:35,000 --> 02:28:36,000
文化编程

4467
02:28:36,000 --> 02:28:37,000
文艺编程

4468
02:28:37,000 --> 02:28:39,000
文青编程

4469
02:28:41,000 --> 02:28:43,000
我不知道这个怎么翻译

4470
02:28:43,000 --> 02:28:44,000
我怎么翻译

4471
02:28:44,000 --> 02:28:49,000
它那个东西就是说其实一直在写注释

4472
02:28:50,000 --> 02:28:53,000
代码就是穿插在你用写注释的方式来写代码

4473
02:28:53,000 --> 02:28:54,000
没错

4474
02:28:54,000 --> 02:28:55,000
然后这个就是有点反过来

4475
02:28:55,000 --> 02:28:58,000
就是说你主要是写代码

4476
02:28:58,000 --> 02:29:00,000
但是注释是对代码的一个解释

4477
02:29:00,000 --> 02:29:03,000
然后注释还是可以执行的

4478
02:29:04,000 --> 02:29:05,000
这就还比较不错

4479
02:29:06,000 --> 02:29:10,000
最后一个问题就是现在正夯的一个

4480
02:29:10,000 --> 02:29:12,000
functional programming 的概念

4481
02:29:12,000 --> 02:29:18,000
我们知道在敏捷方法崛起的过程中

4482
02:29:18,000 --> 02:29:22,000
其实基本上也就伴随着面相对象

4483
02:29:22,000 --> 02:29:23,000
这个思潮的崛起

4484
02:29:25,000 --> 02:29:25,000
基本上可以说

4485
02:29:25,000 --> 02:29:28,000
如果没有面相对象理念的话

4486
02:29:28,000 --> 02:29:30,000
敏捷是完全实现不了的

4487
02:29:32,000 --> 02:29:34,000
面对面相对象编程也已经被证明了

4488
02:29:34,000 --> 02:29:38,000
是更适合与写测试的一种方法

4489
02:29:39,000 --> 02:29:40,000
那我们可以把

4490
02:29:40,000 --> 02:29:41,000
封装的好

4491
02:29:43,000 --> 02:29:47,000
面相对象可以保证你把系统的偶和度降到最低

4492
02:29:48,000 --> 02:29:51,000
那么相同的问题

4493
02:29:51,000 --> 02:29:53,000
我们可以套用在目前正夯的

4494
02:29:53,000 --> 02:29:55,000
functional programming 的概念上

4495
02:29:56,000 --> 02:29:59,000
functional programming 适合写测试吗

4496
02:30:01,000 --> 02:30:03,000
其实我觉得还蛮合适的

4497
02:30:03,000 --> 02:30:05,000
因为怎么说呢

4498
02:30:05,000 --> 02:30:08,000
就是 functional programming 的一个思潮

4499
02:30:08,000 --> 02:30:12,000
就是说每一个函数的独立性很好

4500
02:30:12,000 --> 02:30:15,000
就是它至少就是在原则上

4501
02:30:15,000 --> 02:30:17,000
我们是鼓励每个函数

4502
02:30:17,000 --> 02:30:19,000
它是认为一个函数

4503
02:30:19,000 --> 02:30:19,000
对吧

4504
02:30:19,000 --> 02:30:21,000
所谓函数就是说它是确定数字

4505
02:30:21,000 --> 02:30:22,000
没有副多用

4506
02:30:22,000 --> 02:30:23,000
对

4507
02:30:23,000 --> 02:30:24,000
side effect free

4508
02:30:24,000 --> 02:30:26,000
就是我确定一个数就确定一个输出了

4509
02:30:26,000 --> 02:30:28,000
这个时候你写测试就比较简单了

4510
02:30:28,000 --> 02:30:30,000
因为你不用考虑说

4511
02:30:30,000 --> 02:30:33,000
你从某一种状态进入函数

4512
02:30:33,000 --> 02:30:34,000
或者进入一个过程的时候

4513
02:30:34,000 --> 02:30:36,000
会得到一个解

4514
02:30:36,000 --> 02:30:37,000
但是你从另外一个状态进入的时候

4515
02:30:37,000 --> 02:30:37,000
得到另外一个解

4516
02:30:37,000 --> 02:30:39,000
这样的话

4517
02:30:39,000 --> 02:30:41,000
你这个试试没法写了

4518
02:30:41,000 --> 02:30:41,000
对吧

4519
02:30:41,000 --> 02:30:42,000
你得去先

4520
02:30:42,000 --> 02:30:44,000
set up the environment

4521
02:30:44,000 --> 02:30:46,000
你得先设置这个环境才可以

4522
02:30:46,000 --> 02:30:48,000
但是如果是 FP 的话

4523
02:30:48,000 --> 02:30:48,000
就不存在一个问题

4524
02:30:48,000 --> 02:30:50,000
你这种照着写

4525
02:30:50,000 --> 02:30:51,000
什么说出

4526
02:30:51,000 --> 02:30:52,000
给什么结果

4527
02:30:52,000 --> 02:30:55,000
你就可以马上把这个一对应的关系列出来

4528
02:30:55,000 --> 02:30:55,000
对

4529
02:30:56,000 --> 02:31:01,000
所以这也就为我们提供另外一个拥抱函数编程的理由

4530
02:31:01,000 --> 02:31:02,000
理由

4531
02:31:02,000 --> 02:31:03,000
对

4532
02:31:03,000 --> 02:31:03,000
没错

4533
02:31:04,000 --> 02:31:06,000
测试好写

4534
02:31:06,000 --> 02:31:06,000
没错

4535
02:31:06,000 --> 02:31:07,000
测试好写

4536
02:31:07,000 --> 02:31:09,000
所以如果你们还没有接触函数编程的话

4537
02:31:09,000 --> 02:31:11,000
一定要去试试

4538
02:31:13,000 --> 02:31:15,000
对找工作很有帮助

4539
02:31:17,000 --> 02:31:19,000
可以瞬间提升

4540
02:31:19,000 --> 02:31:20,000
逼格

4541
02:31:20,000 --> 02:31:21,000
大英

4542
02:31:21,000 --> 02:31:22,000
提升内力

4543
02:31:22,000 --> 02:31:26,000
逼格不逼格

4544
02:31:26,000 --> 02:31:26,000
何必

4545
02:31:26,000 --> 02:31:29,000
写册是有什么逼格

4546
02:31:31,000 --> 02:31:32,000
说的也是

4547
02:31:32,000 --> 02:31:35,000
真的猛试只用 printf

4548
02:31:35,000 --> 02:31:39,000
来验证自己的

4549
02:31:39,000 --> 02:31:42,000
所以你现在还只用 printf

4550
02:31:42,000 --> 02:31:46,000
我其实还是要解释一下

4551
02:31:46,000 --> 02:31:47,000
我之前写 Go 的时候

4552
02:31:47,000 --> 02:31:52,000
其实也已经有在写测试了

4553
02:31:52,000 --> 02:31:54,000
因为 Go 它是随语言

4554
02:31:54,000 --> 02:31:57,000
它就自带一个比较好的统一的规范

4555
02:31:57,000 --> 02:32:00,000
就不用单独再学一个第三方的东西

4556
02:32:00,000 --> 02:32:02,000
其实写测试

4557
02:32:02,000 --> 02:32:04,000
去特别写单样测试的话还是挺方便的

4558
02:32:04,000 --> 02:32:06,000
就要承认一下

4559
02:32:06,000 --> 02:32:08,000
有时候还有点用

4560
02:32:08,000 --> 02:32:10,000
可能现在语言是一个思潮

4561
02:32:10,000 --> 02:32:11,000
也是要越来越多了

4562
02:32:11,000 --> 02:32:14,000
在原内部集成一些

4563
02:32:14,000 --> 02:32:15,000
比如说测试

4564
02:32:15,000 --> 02:32:17,000
比如说调试之类的特性

4565
02:32:21,000 --> 02:32:22,000
OK

4566
02:32:22,000 --> 02:32:23,000
那好吧

4567
02:32:23,000 --> 02:32:24,000
这期到这了吧

4568
02:32:24,000 --> 02:32:26,000
您刚刚收听的是

4569
02:32:26,000 --> 02:32:27,000
IBN Podcast 网络旗下的

4570
02:32:27,000 --> 02:32:31,000
IT 技术主题娱乐节目内核恐慌

4571
02:32:31,000 --> 02:32:33,000
IBN 旗下的其他用户 Podcast

4572
02:32:33,000 --> 02:32:35,000
包括 softcore 技术节目

4573
02:32:35,000 --> 02:32:36,000
非娱乐技术节目

4574
02:32:36,000 --> 02:32:37,000
IT 功愿

4575
02:32:37,000 --> 02:32:39,000
医疗主题节目太医来了

4576
02:32:39,000 --> 02:32:40,000
美食主题节目未知道

4577
02:32:41,000 --> 02:32:42,000
艺术主题节目流行通信

4578
02:32:42,000 --> 02:32:43,000
无主题节目无资源

4579
02:32:43,000 --> 02:32:45,000
故事主题节目 History

4580
02:32:45,000 --> 02:32:48,000
以及影像主题节目影像

4581
02:32:48,000 --> 02:32:49,000
如果你喜欢我们的节目

4582
02:32:49,000 --> 02:32:52,000
欢迎你为我们的节目捐款

4583
02:32:52,000 --> 02:32:54,000
捐款例子是

4584
02:32:54,000 --> 02:32:55,000
你可以把本节目再听一遍

4585
02:32:55,000 --> 02:32:57,000
开头有请

4586
02:32:58,000 --> 02:32:59,000
这个要念

4587
02:32:59,000 --> 02:33:05,000
是 kernelpanic.fm.donate

4588
02:33:05,000 --> 02:33:06,000
好吧

4589
02:33:07,000 --> 02:33:08,000
要提醒大家一点

4590
02:33:08,000 --> 02:33:12,000
是不要加 htps 这个方式

4591
02:33:12,000 --> 02:33:15,000
反正它会跳转的无所谓

4592
02:33:15,000 --> 02:33:15,000
对

4593
02:33:15,000 --> 02:33:17,000
但是为了保证您安全

4594
02:33:17,000 --> 02:33:19,000
它会自动跳转到一个

4595
02:33:19,000 --> 02:33:24,000
daihtps 加密

4596
02:33:24,000 --> 02:33:25,000
OK

4597
02:33:26,000 --> 02:33:27,000
今天的节目就

4598
02:33:28,000 --> 02:33:29,000
到这里了

4599
02:33:29,000 --> 02:33:31,000
1.79 Gb

