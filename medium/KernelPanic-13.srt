1
00:00:00,000 --> 00:00:04,000
北美山地时间 2006 年 1 月 2 日下午 3 点 04 分 05 秒

2
00:00:04,000 --> 00:00:06,000
您正在收听 ipnpodcast 网络旗下的

3
00:00:06,000 --> 00:00:09,000
IT 技术主题节目内核恐慌

4
00:00:09,000 --> 00:00:11,000
我们号称 Hakko 但也没有干货

5
00:00:11,000 --> 00:00:13,000
想听的人听不想听的人就别听

6
00:00:13,000 --> 00:00:18,000
内核恐慌的网址是 ipn.li.kernelpanic

7
00:00:18,000 --> 00:00:21,000
我们推荐大家使用 podcast 客户端订阅我们的节目

8
00:00:21,000 --> 00:00:23,000
如果您不知道该用什么客户端

9
00:00:23,000 --> 00:00:26,000
请访问 ipn.li.faq

10
00:00:26,000 --> 00:00:27,000
在录音过程中

11
00:00:27,000 --> 00:00:30,000
希望您可以拨通热心电话参与我们的节目

12
00:00:30,000 --> 00:00:31,000
电话号码是

13
00:00:35,000 --> 00:00:35,000
电话号码是

14
00:00:37,000 --> 00:00:37,000
算了吧

15
00:00:37,000 --> 00:00:41,000
0189998819999197253

16
00:00:42,000 --> 00:00:46,000
我觉得 Lawrence 其实是把那个节目里面

17
00:00:46,000 --> 00:00:50,000
就是 IT crowd 里面唱的音在这边唱起来

18
00:00:51,000 --> 00:00:52,000
好吧

19
00:00:53,000 --> 00:00:53,000
anyway

20
00:00:54,000 --> 00:00:55,000
如果你非常喜欢我们的节目

21
00:00:55,000 --> 00:00:58,000
或者说不管你是否喜欢我们的节目

22
00:00:58,000 --> 00:00:59,000
你都可以为我们捐款

23
00:00:59,000 --> 00:01:04,000
捐款地址是 ipn.li.kernelpanic.donate

24
00:01:04,000 --> 00:01:06,000
donate

25
00:01:06,000 --> 00:01:07,000
捐款金额随意

26
00:01:07,000 --> 00:01:10,000
但是必须是可以被巴整出的正整数

27
00:01:12,000 --> 00:01:12,000
OK

28
00:01:12,000 --> 00:01:14,000
等一下那个地址你用的是 ipn 那个吗

29
00:01:14,000 --> 00:01:17,000
你又可以用 kernelpanic.fm 那个地址

30
00:01:17,000 --> 00:01:17,000
OK

31
00:01:17,000 --> 00:01:21,000
我们有了新的域名是 kernelpanic.fm

32
00:01:21,000 --> 00:01:23,000
所以捐款地址可以是

33
00:01:23,000 --> 00:01:24,000
对

34
00:01:24,000 --> 00:01:25,000
这不便宜啊

35
00:01:26,000 --> 00:01:27,000
不贵的这个域名

36
00:01:27,000 --> 00:01:28,000
对

37
00:01:28,000 --> 00:01:29,000
因此我们更需要大家捐款

38
00:01:29,000 --> 00:01:30,000
有没有

39
00:01:30,000 --> 00:01:32,000
贵臣大家捐款

40
00:01:32,000 --> 00:01:34,000
最低 8 块上不封顶

41
00:01:34,000 --> 00:01:35,000
对

42
00:01:35,000 --> 00:01:41,000
捐款地址是 ipn.fm.donate

43
00:01:43,000 --> 00:01:46,000
今天是我们的第多少金

44
00:01:46,000 --> 00:01:46,000
13

45
00:01:46,000 --> 00:01:48,000
13 系

46
00:01:48,000 --> 00:01:49,000
13 系

47
00:01:49,000 --> 00:01:50,000
0 x 0 c

48
00:01:52,000 --> 00:01:54,000
Wait a second 0 x 0 d

49
00:01:56,000 --> 00:01:58,000
10 是 a 对吧

50
00:01:58,000 --> 00:01:59,000
11 是 b

51
00:01:59,000 --> 00:02:01,000
对

52
00:02:01,000 --> 00:02:02,000
所以是 0 x 0 d

53
00:02:03,000 --> 00:02:05,000
13 这个数字不是非常的

54
00:02:06,000 --> 00:02:07,000
吉利吗

55
00:02:07,000 --> 00:02:08,000
好像也

56
00:02:08,000 --> 00:02:09,000
我也不知道

57
00:02:09,000 --> 00:02:12,000
在欧洲某些国家 13 好像是个蛮吉利的数字

58
00:02:14,000 --> 00:02:16,000
因为我们这边没有 13 层那么高的楼

59
00:02:16,000 --> 00:02:18,000
所以我不知道没有办法验证

60
00:02:21,000 --> 00:02:22,000
大农村

61
00:02:22,000 --> 00:02:23,000
大农村

62
00:02:24,000 --> 00:02:26,000
你知道加拿大的意思吗

63
00:02:26,000 --> 00:02:26,000
Canada

64
00:02:27,000 --> 00:02:31,000
Canada 是当地人的语言吗

65
00:02:31,000 --> 00:02:32,000
就是什么

66
00:02:32,000 --> 00:02:33,000
爱斯不是就是那种什么

67
00:02:33,000 --> 00:02:36,000
就是英语特人还是什么人的语言里面

68
00:02:36,000 --> 00:02:37,000
就是 big village

69
00:02:37,000 --> 00:02:38,000
大农村的意思

70
00:02:39,000 --> 00:02:39,000
OK

71
00:02:40,000 --> 00:02:41,000
倒也贴切

72
00:02:45,000 --> 00:02:46,000
黑的好

73
00:02:48,000 --> 00:02:48,000
对

74
00:02:48,000 --> 00:02:50,000
我们上一期请到的幕遥里面

75
00:02:50,000 --> 00:02:53,000
就是我们上一期请到幕遥那期节目里面

76
00:02:53,000 --> 00:02:54,000
我们反复提到了

77
00:02:54,000 --> 00:02:55,000
我反复提到了

78
00:02:55,000 --> 00:02:56,000
How I Met a Mother

79
00:02:56,000 --> 00:02:57,000
里面然后里面另外一个

80
00:02:57,000 --> 00:02:58,000
除了纽德西他们

81
00:02:59,000 --> 00:03:00,000
也许很喜欢黑的

82
00:03:00,000 --> 00:03:01,000
另一个地方就是加拿大

83
00:03:03,000 --> 00:03:05,000
不是还有那个地方吗

84
00:03:05,000 --> 00:03:05,000
那个叫

85
00:03:06,000 --> 00:03:07,000
Penny 那边叫什么

86
00:03:08,000 --> 00:03:09,000
Penny

87
00:03:10,000 --> 00:03:12,000
那个 Big Bang Zero 里面 Penny

88
00:03:12,000 --> 00:03:13,000
老家哪个地方来的

89
00:03:13,000 --> 00:03:14,000
我不知道

90
00:03:15,000 --> 00:03:16,000
那个州叫

91
00:03:17,000 --> 00:03:18,000
查一下

92
00:03:19,000 --> 00:03:20,000
Penny from

93
00:03:23,000 --> 00:03:26,000
这个所应该不认 Siri 对不对

94
00:03:38,000 --> 00:03:39,000
Nebraska

95
00:03:40,000 --> 00:03:41,000
啊那 OK

96
00:03:41,000 --> 00:03:42,000
Now I'm from Omaha

97
00:03:42,000 --> 00:03:45,000
哦那个 The Walking Dead 里面就是

98
00:03:45,000 --> 00:03:48,000
每句行驶走肉里面有一集也叫

99
00:03:48,000 --> 00:03:49,000
Nebraska

100
00:03:49,000 --> 00:03:50,000
就是讲他们想要去 Nebraska

101
00:03:50,000 --> 00:03:52,000
然后说那边人少

102
00:03:52,000 --> 00:03:53,000
然后很多枪

103
00:03:54,000 --> 00:03:56,000
然后又是 Flying Oral State

104
00:03:56,000 --> 00:03:57,000
所以僵尸不会太多

105
00:03:57,000 --> 00:04:00,000
连在这种末日片里面都要被黑

106
00:04:02,000 --> 00:04:02,000
太惨

107
00:04:04,000 --> 00:04:06,000
上期我们请到了幕遥

108
00:04:06,000 --> 00:04:08,000
大神跟我们

109
00:04:08,000 --> 00:04:08,000
然后

110
00:04:09,000 --> 00:04:12,000
我们瞬间多了很多粉丝和

111
00:04:13,000 --> 00:04:13,000
没错

112
00:04:13,000 --> 00:04:14,000
这可能是

113
00:04:15,000 --> 00:04:17,000
对我们之前觉得可能

114
00:04:17,000 --> 00:04:19,000
键盘狗皇那一期是比较

115
00:04:19,000 --> 00:04:20,000
比较受欢迎的一期

116
00:04:20,000 --> 00:04:22,000
但是现在看来好像

117
00:04:22,000 --> 00:04:23,000
这已经是一个

118
00:04:23,000 --> 00:04:25,000
后无来者的

119
00:04:25,000 --> 00:04:26,000
最受欢迎的一期了

120
00:04:26,000 --> 00:04:28,000
后无来者的高度了对吧

121
00:04:28,000 --> 00:04:30,000
对幕遥这一期真的是

122
00:04:30,000 --> 00:04:30,000
我靠

123
00:04:30,000 --> 00:04:31,000
现在

124
00:04:31,000 --> 00:04:32,000
现在看来真是

125
00:04:32,000 --> 00:04:35,000
不管是在微博上还是在

126
00:04:36,000 --> 00:04:37,000
推特上还是在

127
00:04:37,000 --> 00:04:39,000
还是由热情听众

128
00:04:39,000 --> 00:04:41,000
热情听众们写的来信里面

129
00:04:41,000 --> 00:04:43,000
这一期都是非常受欢迎

130
00:04:43,000 --> 00:04:45,000
而且引起热议的一期

131
00:04:45,000 --> 00:04:46,000
嗯哼

132
00:04:46,000 --> 00:04:47,000
而且你发现没

133
00:04:47,000 --> 00:04:48,000
这一期出现之后

134
00:04:48,000 --> 00:04:50,000
我们多了很多女粉丝

135
00:04:51,000 --> 00:04:51,000
对

136
00:04:51,000 --> 00:04:52,000
就

137
00:04:52,000 --> 00:04:55,000
然后我挨个点进他们微博去看

138
00:04:55,000 --> 00:04:56,000
都是美女竟然

139
00:04:57,000 --> 00:04:58,000
你居然会挨个点进去

140
00:04:58,000 --> 00:04:59,000
看人家的微博

141
00:04:59,000 --> 00:05:00,000
你这样对吗

142
00:05:01,000 --> 00:05:04,000
我这个也是要关注粉丝的反馈吗

143
00:05:04,000 --> 00:05:04,000
对不对

144
00:05:05,000 --> 00:05:06,000
但我一把看见头像是美女

145
00:05:06,000 --> 00:05:07,000
才点进去看一下

146
00:05:07,000 --> 00:05:10,000
这 Colonel Panic 这么高冷的节目

147
00:05:10,000 --> 00:05:11,000
都要看脸

148
00:05:11,000 --> 00:05:11,000
这样对吗

149
00:05:13,000 --> 00:05:14,000
我们都不露脸

150
00:05:14,000 --> 00:05:14,000
没有关系

151
00:05:14,000 --> 00:05:15,000
没有关系

152
00:05:16,000 --> 00:05:16,000
好吧

153
00:05:16,000 --> 00:05:17,000
所以

154
00:05:17,000 --> 00:05:19,000
所以看一下还是什么

155
00:05:19,000 --> 00:05:20,000
男神的魅力很大

156
00:05:21,000 --> 00:05:21,000
对

157
00:05:21,000 --> 00:05:21,000
而且

158
00:05:21,000 --> 00:05:22,000
而且有一个

159
00:05:22,000 --> 00:05:23,000
有一个

160
00:05:23,000 --> 00:05:23,000
有一个推

161
00:05:23,000 --> 00:05:24,000
有一个

162
00:05:24,000 --> 00:05:25,000
有一条微博说

163
00:05:25,000 --> 00:05:27,000
这一期毕竟都是男神

164
00:05:27,000 --> 00:05:28,000
得点闷

165
00:05:28,000 --> 00:05:29,000
然后

166
00:05:29,000 --> 00:05:31,000
咱们两个就可怜的屈居在

167
00:05:31,000 --> 00:05:33,000
屈居在那个闷里面了

168
00:05:35,000 --> 00:05:37,000
人家还是为了照顾下我们的情绪而已

169
00:05:37,000 --> 00:05:38,000
不要太当真

170
00:05:38,000 --> 00:05:39,000
不要太当真

171
00:05:39,000 --> 00:05:40,000
好了

172
00:05:40,000 --> 00:05:40,000
对

173
00:05:40,000 --> 00:05:42,000
其实我们也

174
00:05:42,000 --> 00:05:45,000
在酝酿或者说在

175
00:05:46,000 --> 00:05:46,000
歪歪

176
00:05:47,000 --> 00:05:50,000
将来还会有一期请到

177
00:05:50,000 --> 00:05:51,000
重新请到幕僚

178
00:05:51,000 --> 00:05:52,000
不过

179
00:05:52,000 --> 00:05:54,000
目前没有一个太

180
00:05:56,000 --> 00:05:57,000
确切的时间表

181
00:05:57,000 --> 00:05:59,000
但我们会努力

182
00:05:59,000 --> 00:06:00,000
对

183
00:06:00,000 --> 00:06:03,000
然后下一期可能会想要谈论一些

184
00:06:03,000 --> 00:06:04,000
和数据相关的

185
00:06:04,000 --> 00:06:07,000
和统计学相关的主题吧

186
00:06:07,000 --> 00:06:10,000
其实我们这边也可以请

187
00:06:10,000 --> 00:06:12,000
听众们自靠分友

188
00:06:12,000 --> 00:06:13,000
如果你觉得你对

189
00:06:14,000 --> 00:06:15,000
数据这个话题

190
00:06:15,000 --> 00:06:17,000
或者说对统计学这个话题比较有

191
00:06:17,000 --> 00:06:18,000
比较感兴趣

192
00:06:18,000 --> 00:06:19,000
并且可以从

193
00:06:19,000 --> 00:06:21,000
和程序相关的角度

194
00:06:21,000 --> 00:06:22,000
谈一谈你的看法

195
00:06:22,000 --> 00:06:24,000
那我们也可以非常欢迎你

196
00:06:25,000 --> 00:06:27,000
或者是报名参加我们的节目

197
00:06:27,000 --> 00:06:29,000
或者是为这一个将

198
00:06:29,000 --> 00:06:32,000
可能出现的主题写一些你的看法

199
00:06:32,000 --> 00:06:33,000
因为我们现在

200
00:06:35,000 --> 00:06:36,000
主要是会收到一些

201
00:06:37,000 --> 00:06:37,000
feedback

202
00:06:38,000 --> 00:06:40,000
主要是在节目播出之后

203
00:06:40,000 --> 00:06:41,000
比如说我们今天

204
00:06:41,000 --> 00:06:42,000
是今天吧

205
00:06:42,000 --> 00:06:45,000
收到一封 2200 多字的读者来信

206
00:06:45,000 --> 00:06:46,000
是

207
00:06:47,000 --> 00:06:48,000
是

208
00:06:48,000 --> 00:06:49,000
一位微软员工

209
00:06:49,000 --> 00:06:51,000
然后专门

210
00:06:52,000 --> 00:06:55,000
提供了上幕杨这一期的很多反馈

211
00:06:55,000 --> 00:06:57,000
但是这些反馈里面有很多

212
00:06:57,000 --> 00:06:58,000
我们都觉得其实相当有意义

213
00:06:58,000 --> 00:06:59,000
但是

214
00:07:01,000 --> 00:07:01,000
全文念出来

215
00:07:01,000 --> 00:07:02,000
实在是

216
00:07:03,000 --> 00:07:04,000
会占用比较长的时间

217
00:07:04,000 --> 00:07:06,000
所以也许比较好的一点

218
00:07:06,000 --> 00:07:07,000
比较好的一种

219
00:07:09,000 --> 00:07:12,000
模式是我们告诉听众朋友们

220
00:07:12,000 --> 00:07:13,000
下一期或者说将来会出现的

221
00:07:13,000 --> 00:07:14,000
某一些的话题是什么

222
00:07:14,000 --> 00:07:15,000
然后

223
00:07:15,000 --> 00:07:18,000
各位听众可以就此写一些感想

224
00:07:18,000 --> 00:07:19,000
然后我们可以在

225
00:07:20,000 --> 00:07:21,000
节目里面

226
00:07:22,000 --> 00:07:23,000
或者是念出来

227
00:07:23,000 --> 00:07:24,000
或者是就其观点做出讨论

228
00:07:24,000 --> 00:07:25,000
我觉得也挺好的

229
00:07:26,000 --> 00:07:27,000
没错

230
00:07:27,000 --> 00:07:29,000
然后真的很感动

231
00:07:29,000 --> 00:07:29,000
这是

232
00:07:30,000 --> 00:07:32,000
本节目开播以来

233
00:07:32,000 --> 00:07:34,000
这也这不算有史以来最长

234
00:07:34,000 --> 00:07:37,000
但是觉得也是较长的那一些

235
00:07:37,000 --> 00:07:38,000
少数了

236
00:07:38,000 --> 00:07:40,000
对是关键是

237
00:07:41,000 --> 00:07:42,000
关键是他说

238
00:07:43,000 --> 00:07:44,000
他说他是微软的员工

239
00:07:45,000 --> 00:07:46,000
然后我们还这么黑他们

240
00:07:47,000 --> 00:07:47,000
对

241
00:07:48,000 --> 00:07:49,000
比如以后黑人还坚持

242
00:07:49,000 --> 00:07:50,000
下得轻一点

243
00:07:50,000 --> 00:07:50,000
真的是真爱

244
00:07:51,000 --> 00:07:52,000
我们以后下得轻一点

245
00:07:53,000 --> 00:07:53,000
特别照顾

246
00:07:53,000 --> 00:07:57,000
特别照顾女粉丝的心情

247
00:07:57,000 --> 00:07:57,000
对不对

248
00:07:58,000 --> 00:07:59,000
男粉丝就

249
00:07:59,000 --> 00:08:00,000
微软居然有女粉丝

250
00:08:00,000 --> 00:08:01,000
这个真的不太正常

251
00:08:01,000 --> 00:08:03,000
不过想想萧姐姐也是

252
00:08:03,000 --> 00:08:04,000
等等萧姐姐也是微软粉丝吗

253
00:08:04,000 --> 00:08:05,000
虽然她是微软员工

254
00:08:05,000 --> 00:08:07,000
但是萧姐姐也是微软粉丝吗

255
00:08:08,000 --> 00:08:09,000
我们可以下期

256
00:08:09,000 --> 00:08:11,000
想办法请到她来

257
00:08:11,000 --> 00:08:12,000
你可以当面问她

258
00:08:13,000 --> 00:08:13,000
好好好

259
00:08:13,000 --> 00:08:15,000
你将来一定要有一期请萧姐姐

260
00:08:17,000 --> 00:08:18,000
对

261
00:08:18,000 --> 00:08:20,000
总之我觉得上一期

262
00:08:20,000 --> 00:08:21,000
幕窑这一期到现在还是觉得

263
00:08:21,000 --> 00:08:22,000
怎么说

264
00:08:22,000 --> 00:08:23,000
纯指流行

265
00:08:24,000 --> 00:08:25,000
然后膝盖酸软

266
00:08:26,000 --> 00:08:27,000
上期

267
00:08:29,000 --> 00:08:30,000
Anyway

268
00:08:30,000 --> 00:08:31,000
其实

269
00:08:32,000 --> 00:08:34,000
回应一下上一期的一些

270
00:08:34,000 --> 00:08:36,000
没有彻底展开的观点

271
00:08:37,000 --> 00:08:38,000
其实我后来要想想

272
00:08:38,000 --> 00:08:40,000
上一期提到的一些事情

273
00:08:40,000 --> 00:08:40,000
比如说我觉得

274
00:08:42,000 --> 00:08:44,000
比如说工具不好用这件事情

275
00:08:45,000 --> 00:08:46,000
我不知道你怎么觉得

276
00:08:46,000 --> 00:08:48,000
但我觉得现在的编程工具

277
00:08:48,000 --> 00:08:50,000
要比 10 年前

278
00:08:50,000 --> 00:08:51,000
好用太多了

279
00:08:51,000 --> 00:08:52,000
你不觉得吗

280
00:08:53,000 --> 00:08:54,000
我想想 10 年前我在干嘛

281
00:08:55,000 --> 00:08:56,000
别这样好吧

282
00:08:56,000 --> 00:08:57,000
别这样

283
00:08:58,000 --> 00:08:59,000
10 年前我刚上了大学

284
00:09:00,000 --> 00:09:01,000
还不怎么

285
00:09:02,000 --> 00:09:03,000
然后学的是商科

286
00:09:03,000 --> 00:09:04,000
也不怎么写

287
00:09:04,000 --> 00:09:05,000
也不怎么写程序

288
00:09:05,000 --> 00:09:06,000
没感觉

289
00:09:08,000 --> 00:09:08,000
好吧

290
00:09:09,000 --> 00:09:11,000
但我是觉得现在的编程工具

291
00:09:11,000 --> 00:09:12,000
要比 10 年前

292
00:09:12,000 --> 00:09:13,000
就是 2005 年左右

293
00:09:14,000 --> 00:09:15,000
真的好用很多

294
00:09:15,000 --> 00:09:17,000
2005 年的时候

295
00:09:19,000 --> 00:09:20,000
不说别的吧

296
00:09:20,000 --> 00:09:21,000
你写一个最简单的

297
00:09:21,000 --> 00:09:22,000
最基础的东西

298
00:09:22,000 --> 00:09:23,000
你写个网页出来

299
00:09:23,000 --> 00:09:25,000
那个时候哪有什么

300
00:09:25,000 --> 00:09:26,000
VacuConsul 这种东西

301
00:09:27,000 --> 00:09:28,000
那个时候

302
00:09:29,000 --> 00:09:30,000
就用

303
00:09:30,000 --> 00:09:30,000
就是什么

304
00:09:32,000 --> 00:09:32,000
编辑一下

305
00:09:32,000 --> 00:09:34,000
然后刷新页面查看

306
00:09:34,000 --> 00:09:34,000
对

307
00:09:34,000 --> 00:09:36,000
而且那个时候用的是 Internet Explorer

308
00:09:36,000 --> 00:09:36,000
好吗

309
00:09:36,000 --> 00:09:37,000
Internet Explorer

310
00:09:37,000 --> 00:09:38,000
那个时候还没有

311
00:09:38,000 --> 00:09:39,000
没有 Type 的

312
00:09:42,000 --> 00:09:43,000
那个时候我是用 NodePad++

313
00:09:43,000 --> 00:09:44,000
写一个

314
00:09:45,000 --> 00:09:46,000
写一个 Markup

315
00:09:46,000 --> 00:09:49,000
然后在 IE 里面刷新

316
00:09:50,000 --> 00:09:51,000
现在呢

317
00:09:51,000 --> 00:09:52,000
然后去猜

318
00:09:52,000 --> 00:09:54,000
然后自己头脑中模拟

319
00:09:54,000 --> 00:09:56,000
那个什么 Dome 解析器的一步一步猜

320
00:09:56,000 --> 00:09:58,000
它为什么会这样对不对

321
00:09:58,000 --> 00:09:59,000
对

322
00:09:59,000 --> 00:09:59,000
而现在

323
00:10:00,000 --> 00:10:02,000
VacuConsul 是多么好用的一个东西

324
00:10:02,000 --> 00:10:03,000
你可以随时去改

325
00:10:04,000 --> 00:10:06,000
任何一个页面上的大部分元素

326
00:10:07,000 --> 00:10:09,000
但是除非你再用一些比较 R 的东西

327
00:10:09,000 --> 00:10:12,000
比如说 GWT 这种东西

328
00:10:12,000 --> 00:10:14,000
那搞出来的东西

329
00:10:14,000 --> 00:10:16,000
是真的没有办法在 VacuConsul 里面 Debug

330
00:10:16,000 --> 00:10:17,000
但是

331
00:10:18,000 --> 00:10:19,000
如果你徒手写的话

332
00:10:19,000 --> 00:10:22,000
那这些工具真的要比十年前好太多

333
00:10:22,000 --> 00:10:23,000
对

334
00:10:24,000 --> 00:10:26,000
而且很多语言都

335
00:10:26,000 --> 00:10:27,000
现在很多动态语言

336
00:10:27,000 --> 00:10:28,000
或者说尤其是动态语言

337
00:10:28,000 --> 00:10:31,000
都提供了自己的所谓 Repl

338
00:10:32,000 --> 00:10:33,000
Repl

339
00:10:33,000 --> 00:10:33,000
对

340
00:10:33,000 --> 00:10:34,000
Repl

341
00:10:34,000 --> 00:10:36,000
这是什么说起来的

342
00:10:36,000 --> 00:10:36,000
Write

343
00:10:36,000 --> 00:10:37,000
Read

344
00:10:37,000 --> 00:10:39,000
Evaluate

345
00:10:39,000 --> 00:10:39,000
Print

346
00:10:39,000 --> 00:10:40,000
Loop

347
00:10:40,000 --> 00:10:41,000
读入

348
00:10:41,000 --> 00:10:43,000
然后叫什么 Evaluate

349
00:10:43,000 --> 00:10:43,000
中文叫

350
00:10:43,000 --> 00:10:44,000
求职

351
00:10:44,000 --> 00:10:45,000
求职

352
00:10:45,000 --> 00:10:46,000
打印

353
00:10:46,000 --> 00:10:46,000
循环

354
00:10:47,000 --> 00:10:47,000
对

355
00:10:48,000 --> 00:10:52,000
当然 Repl 其实并不是一个非常

356
00:10:52,000 --> 00:10:53,000
新颖的东西

357
00:10:53,000 --> 00:10:54,000
就比如说

358
00:10:54,000 --> 00:10:57,000
你说最开始的时候它就有了

359
00:10:57,000 --> 00:10:58,000
对

360
00:10:58,000 --> 00:10:58,000
而且

361
00:10:59,000 --> 00:11:00,000
哪怕是命令式语言

362
00:11:00,000 --> 00:11:03,000
在 Basic 上面

363
00:11:03,000 --> 00:11:05,000
其实也是一个 Repl

364
00:11:05,000 --> 00:11:05,000
就

365
00:11:06,000 --> 00:11:10,000
在 Apple 2 上面的 Basic 也是一个 Repl

366
00:11:10,000 --> 00:11:12,000
也是一行一行解析执行

367
00:11:12,000 --> 00:11:12,000
对

368
00:11:12,000 --> 00:11:13,000
除非你打行号

369
00:11:13,000 --> 00:11:14,000
然后再

370
00:11:15,000 --> 00:11:16,000
再打 Run

371
00:11:16,000 --> 00:11:17,000
否则它就是一个

372
00:11:17,000 --> 00:11:18,000
默认就是一个 Repl

373
00:11:20,000 --> 00:11:24,000
但是现在的 Repl 又要比那时候的 Repl 要好太多了

374
00:11:25,000 --> 00:11:26,000
不管是

375
00:11:26,000 --> 00:11:29,000
比如说我们有现在像 iPython 这样的

376
00:11:29,000 --> 00:11:32,000
非常实用的日常笔记本工具

377
00:11:33,000 --> 00:11:35,000
Rubio

378
00:11:36,000 --> 00:11:36,000
Prey

379
00:11:37,000 --> 00:11:38,000
是念 Prey 吧

380
00:11:38,000 --> 00:11:39,000
P-R-Y

381
00:11:39,000 --> 00:11:41,000
就是撬棍的那个词

382
00:11:42,000 --> 00:11:43,000
还是念 Pry

383
00:11:43,000 --> 00:11:44,000
没怎么用过

384
00:11:44,000 --> 00:11:45,000
Pry 吧

385
00:11:45,000 --> 00:11:46,000
没怎么用过

386
00:11:47,000 --> 00:11:49,000
这些东西都是支持

387
00:11:49,000 --> 00:11:51,000
比如说你在输的时候就可以语法高谅

388
00:11:51,000 --> 00:11:52,000
然后

389
00:11:53,000 --> 00:11:55,000
甚至你可以把它当成一个

390
00:11:55,000 --> 00:11:56,000
一个包

391
00:11:57,000 --> 00:11:58,000
嵌到你的

392
00:11:59,000 --> 00:12:01,000
嵌到你想要 Debug 的程序里面

393
00:12:01,000 --> 00:12:03,000
然后你在那个地方设置一个

394
00:12:03,000 --> 00:12:04,000
以前是要设置一个断点

395
00:12:04,000 --> 00:12:06,000
用什么 PyDB 之类的

396
00:12:06,000 --> 00:12:08,000
而现在你可以直接把 iPython

397
00:12:08,000 --> 00:12:09,000
断在那个地方

398
00:12:09,000 --> 00:12:09,000
然后

399
00:12:09,000 --> 00:12:11,000
执行到那个时候

400
00:12:11,000 --> 00:12:12,000
你跳出来一个 iPython 执行环境

401
00:12:12,000 --> 00:12:14,000
你可以随便想干什么

402
00:12:14,000 --> 00:12:15,000
就这样

403
00:12:16,000 --> 00:12:17,000
然后有

404
00:12:17,000 --> 00:12:18,000
比如说我们之前

405
00:12:19,000 --> 00:12:21,000
在苹果的发布会上看到的

406
00:12:21,000 --> 00:12:23,000
Swift 的 Playground

407
00:12:23,000 --> 00:12:25,000
它其实也是一个

408
00:12:26,000 --> 00:12:27,000
更为先进的 Repl

409
00:12:27,000 --> 00:12:30,000
它有所谓的 Live Programming 的

410
00:12:31,000 --> 00:12:31,000
的能力

411
00:12:31,000 --> 00:12:32,000
你可以

412
00:12:32,000 --> 00:12:34,000
更加直观地看到你写出来的东西

413
00:12:34,000 --> 00:12:35,000
是什么

414
00:12:35,000 --> 00:12:37,000
或者说它跑起来

415
00:12:37,000 --> 00:12:39,000
它在局部跑起来是一个什么样的

416
00:12:39,000 --> 00:12:40,000
过程

417
00:12:40,000 --> 00:12:42,000
其实都是非常非常方便的一些特性

418
00:12:43,000 --> 00:12:44,000
这只是说

419
00:12:45,000 --> 00:12:47,000
我们这么过去十几年间

420
00:12:47,000 --> 00:12:49,000
就在普及用的工具还是在进步

421
00:12:49,000 --> 00:12:51,000
不过我觉得可能

422
00:12:51,000 --> 00:12:52,000
离真正像

423
00:12:52,000 --> 00:12:55,000
普通人或者是说像沐阳老师这种

424
00:12:55,000 --> 00:12:56,000
不喜欢用工

425
00:12:56,000 --> 00:12:57,000
就不太喜欢

426
00:12:57,000 --> 00:12:59,000
花时间去学这种工具的人

427
00:12:59,000 --> 00:13:01,000
这可能还是有点困难

428
00:13:01,000 --> 00:13:03,000
比如说至少我们在日常用的时候

429
00:13:03,000 --> 00:13:05,000
很多那种 Repl

430
00:13:05,000 --> 00:13:07,000
它还是有很多限制的

431
00:13:07,000 --> 00:13:08,000
比如你不能做很多事情

432
00:13:08,000 --> 00:13:09,000
有时候

433
00:13:10,000 --> 00:13:12,000
而且对环境的 Inspection

434
00:13:12,000 --> 00:13:14,000
就是检查的能力

435
00:13:14,000 --> 00:13:15,000
也是有一定的限制的

436
00:13:15,000 --> 00:13:17,000
你不像说在

437
00:13:17,000 --> 00:13:18,000
像再早一点

438
00:13:18,000 --> 00:13:20,000
什么像 Small Talk 那种讯息机

439
00:13:20,000 --> 00:13:22,000
那叫什么 Scroll 对不对

440
00:13:22,000 --> 00:13:23,000
对 自带一个

441
00:13:23,000 --> 00:13:25,000
核指就是怎么说

442
00:13:25,000 --> 00:13:26,000
有点像 IDE

443
00:13:26,000 --> 00:13:29,000
但又不是 IDE 的这么一个

444
00:13:29,000 --> 00:13:30,000
它的好处就是说

445
00:13:30,000 --> 00:13:33,000
整个环境

446
00:13:33,000 --> 00:13:35,000
超大系统那个世界

447
00:13:35,000 --> 00:13:36,000
都是可以被 Inspection

448
00:13:36,000 --> 00:13:38,000
就是可以很方便的

449
00:13:38,000 --> 00:13:40,000
与法很统一的规则去做它

450
00:13:40,000 --> 00:13:43,000
所以历史上是

451
00:13:43,000 --> 00:13:45,000
确实曾经出现过那种所谓

452
00:13:45,000 --> 00:13:47,000
就哪怕是按现在的观点来看

453
00:13:47,000 --> 00:13:49,000
这所谓惊为天人的

454
00:13:49,000 --> 00:13:51,000
这种工具的设计

455
00:13:51,000 --> 00:13:52,000
但是只是因为一些

456
00:13:53,000 --> 00:13:55,000
商业的或者是其他的原因

457
00:13:55,000 --> 00:13:56,000
没有流行起来

458
00:13:56,000 --> 00:13:58,000
所以现在我们

459
00:13:58,000 --> 00:14:01,000
还是在不断的去朝那个方向眼镜

460
00:14:01,000 --> 00:14:03,000
虽然还没有达到那个高度而已

461
00:14:04,000 --> 00:14:05,000
其实这也是一个很有意思的问题

462
00:14:05,000 --> 00:14:06,000
就是

463
00:14:07,000 --> 00:14:12,000
有时候我们很难说一个成功的事物

464
00:14:13,000 --> 00:14:15,000
就是因为它的技术比较优越

465
00:14:15,000 --> 00:14:17,000
而经常都不是这样子的

466
00:14:17,000 --> 00:14:18,000
特别是在技术界面

467
00:14:18,000 --> 00:14:19,000
我们不是有个说法吗

468
00:14:19,000 --> 00:14:20,000
叫做 Worse is better

469
00:14:21,000 --> 00:14:22,000
就好像经常很多人吐槽说

470
00:14:22,000 --> 00:14:23,000
哎呀

471
00:14:23,000 --> 00:14:24,000
你那个 Linux 这么流行

472
00:14:24,000 --> 00:14:26,000
但是你看一下你的底层的设计

473
00:14:26,000 --> 00:14:28,000
很多地方是很不优雅的

474
00:14:28,000 --> 00:14:29,000
很不 Uniqc 的

475
00:14:29,000 --> 00:14:30,000
对吧

476
00:14:30,000 --> 00:14:30,000
很恶心的

477
00:14:31,000 --> 00:14:32,000
但是反过来你说那些优雅的

478
00:14:32,000 --> 00:14:34,000
比较高竿的东西

479
00:14:34,000 --> 00:14:35,000
却又往往流行不起来

480
00:14:35,000 --> 00:14:37,000
比如说 Planet 9

481
00:14:40,000 --> 00:14:42,000
甚至不说 Planet 9 这么比较冷门的东西

482
00:14:42,000 --> 00:14:44,000
在编程语言里面也是

483
00:14:44,000 --> 00:14:46,000
基本上是比较流行的语言

484
00:14:46,000 --> 00:14:48,000
往往是比较糟糕的语言

485
00:14:51,000 --> 00:14:52,000
长得比较黑

486
00:14:53,000 --> 00:14:53,000
算了

487
00:14:53,000 --> 00:14:55,000
我们就不举具体的视力

488
00:14:56,000 --> 00:14:56,000
OK

489
00:14:59,000 --> 00:14:59,000
对

490
00:14:59,000 --> 00:15:00,000
然后

491
00:15:00,000 --> 00:15:02,000
但是我也承认

492
00:15:02,000 --> 00:15:04,000
就是现在的编程工具

493
00:15:04,000 --> 00:15:06,000
虽然要比十年前好很多

494
00:15:06,000 --> 00:15:09,000
但它们仍旧没有能够好到一个

495
00:15:09,000 --> 00:15:10,000
就是怎么说呢

496
00:15:10,000 --> 00:15:14,000
就是造成一个所谓范式转化的地步

497
00:15:14,000 --> 00:15:17,000
就是没有说一个工具是如此好用

498
00:15:17,000 --> 00:15:20,000
以至于整个编程界的

499
00:15:21,000 --> 00:15:23,000
整个编程方法论都被颠覆了

500
00:15:24,000 --> 00:15:24,000
对

501
00:15:24,000 --> 00:15:25,000
还没有

502
00:15:26,000 --> 00:15:27,000
它没有出现过这种东西

503
00:15:27,000 --> 00:15:29,000
就曾经出现过

504
00:15:29,000 --> 00:15:32,000
但是没有被保留下来

505
00:15:32,000 --> 00:15:33,000
可以这么讲

506
00:15:33,000 --> 00:15:33,000
对

507
00:15:34,000 --> 00:15:36,000
就好像有一个电影

508
00:15:36,000 --> 00:15:37,000
叫什么《箭雨行动》

509
00:15:37,000 --> 00:15:42,000
里面主角在编程的时候

510
00:15:42,000 --> 00:15:45,000
他编程的方法就是把一大堆方块拖来拖去

511
00:15:46,000 --> 00:15:48,000
然后而且是非常

512
00:15:49,000 --> 00:15:51,000
看起来真同样很复杂

513
00:15:51,000 --> 00:15:52,000
但是你会觉得

514
00:15:53,000 --> 00:15:53,000
你会

515
00:15:54,000 --> 00:15:55,000
至少观众们会认为这是在编程

516
00:15:55,000 --> 00:15:57,000
但在程序员看来这是在搞

517
00:15:57,000 --> 00:15:58,000
这是在解割方块吗还是怎样

518
00:16:00,000 --> 00:16:02,000
如果真的有那样的工具出现的话

519
00:16:02,000 --> 00:16:07,000
也许是一个非常颠覆性的创新秩序

520
00:16:08,000 --> 00:16:10,000
到那个时候也许

521
00:16:10,000 --> 00:16:14,000
幕遥大使们就可以比较无障碍地

522
00:16:15,000 --> 00:16:17,000
利用编程工具解决

523
00:16:17,000 --> 00:16:19,000
解决更

524
00:16:19,000 --> 00:16:20,000
怎么说呢

525
00:16:20,000 --> 00:16:21,000
抽象层级更高的问题

526
00:16:21,000 --> 00:16:22,000
而不是去

527
00:16:22,000 --> 00:16:25,000
而不是去操心这些细致末节

528
00:16:25,000 --> 00:16:28,000
比如说分号或者是缩进之类的事情

529
00:16:29,000 --> 00:16:29,000
没错

530
00:16:30,000 --> 00:16:31,000
所以觉得

531
00:16:31,000 --> 00:16:32,000
有时候我就在想

532
00:16:32,000 --> 00:16:37,000
其实可能造成现在这种工具比较乱

533
00:16:37,000 --> 00:16:39,000
然后设计也不够优雅的局面

534
00:16:39,000 --> 00:16:40,000
是不是有

535
00:16:40,000 --> 00:16:41,000
我有时候在想

536
00:16:41,000 --> 00:16:43,000
是不是应该等我们这批人死掉之后

537
00:16:43,000 --> 00:16:45,000
要从另外一批人重新来设计

538
00:16:45,000 --> 00:16:47,000
那么一些理念可能会好一点

539
00:16:48,000 --> 00:16:49,000
从娃娃抓起

540
00:16:49,000 --> 00:16:50,000
重新想一下

541
00:16:50,000 --> 00:16:53,000
怎么去教小朋友一个比较直观的

542
00:16:54,000 --> 00:16:57,000
或者说更加合理的抽象层级

543
00:16:58,000 --> 00:16:59,000
然后这样就去

544
00:16:59,000 --> 00:17:00,000
初步去学会这种新的范式

545
00:17:00,000 --> 00:17:02,000
可能会有一丝很多

546
00:17:03,000 --> 00:17:03,000
对

547
00:17:03,000 --> 00:17:04,000
有时候

548
00:17:04,000 --> 00:17:06,000
对有时候我其实刚刚也在想这个问题

549
00:17:06,000 --> 00:17:07,000
就是我想到

550
00:17:08,000 --> 00:17:11,000
虽然 60 年代的那一批计算机先驱闷

551
00:17:11,000 --> 00:17:11,000
已经流门而去了

552
00:17:11,000 --> 00:17:13,000
但是我们现在活着的

553
00:17:15,000 --> 00:17:15,000
计算机先驱闷

554
00:17:15,000 --> 00:17:16,000
比如说 ROPEPAC

555
00:17:16,000 --> 00:17:18,000
ROPEPAC 还是在做

556
00:17:18,000 --> 00:17:22,000
在 Google 做一线的这种原开发工作

557
00:17:22,000 --> 00:17:23,000
但是我在想说

558
00:17:23,000 --> 00:17:26,000
我们能够和这些人

559
00:17:26,000 --> 00:17:28,000
仍旧在同一个时代是一种幸福

560
00:17:28,000 --> 00:17:30,000
但是如果再远一点

561
00:17:30,000 --> 00:17:31,000
比如说过个二三十年

562
00:17:31,000 --> 00:17:32,000
等这批人去了之后

563
00:17:33,000 --> 00:17:36,000
那个时候的边城的地平线

564
00:17:36,000 --> 00:17:38,000
会是一个什么样的风景呢

565
00:17:38,000 --> 00:17:39,000
可能会跟现在完全不一样

566
00:17:40,000 --> 00:17:43,000
就好像那天我做的那个内燃机的比喻

567
00:17:43,000 --> 00:17:44,000
也许我们现在用的就是内燃机

568
00:17:44,000 --> 00:17:47,000
也许

569
00:17:47,000 --> 00:17:48,000
过了 20 年

570
00:17:48,000 --> 00:17:49,000
电动机出现的时候

571
00:17:49,000 --> 00:17:51,000
边城真的和现在的

572
00:17:51,000 --> 00:17:54,000
和现在我们所熟悉的这些工具

573
00:17:55,000 --> 00:17:56,000
就完全不一样

574
00:17:58,000 --> 00:18:00,000
而且这是一种很难想象的状态

575
00:18:00,000 --> 00:18:02,000
也许那个时候我也不知道

576
00:18:02,000 --> 00:18:03,000
三进制计算机

577
00:18:03,000 --> 00:18:05,000
平衡三进制计算机

578
00:18:06,000 --> 00:18:09,000
起码永远不会想到会飞的人

579
00:18:09,000 --> 00:18:11,000
是怎么样的一种心态对不对

580
00:18:11,000 --> 00:18:14,000
就好像那些

581
00:18:14,000 --> 00:18:16,000
19 世纪初期的科幻画

582
00:18:16,000 --> 00:18:18,000
幻想 20 世纪是什么样子

583
00:18:18,000 --> 00:18:20,000
那个时候想到 20 世纪说

584
00:18:20,000 --> 00:18:21,000
每个人都在天上飞

585
00:18:21,000 --> 00:18:27,000
然后天上飞的人会受到天上飞的交警的指挥

586
00:18:27,000 --> 00:18:30,000
可是他画出来那个会在天上飞的交警

587
00:18:30,000 --> 00:18:33,000
身上是一双翅膀

588
00:18:33,000 --> 00:18:35,000
而且还是在那边吹哨子

589
00:18:37,000 --> 00:18:41,000
如果现在有什么空中单人的交通工具的话

590
00:18:42,000 --> 00:18:45,000
我相信去控制这种交通工具的规则

591
00:18:45,000 --> 00:18:46,000
肯定不会是吹哨子

592
00:18:48,000 --> 00:18:50,000
因素已经太慢了

593
00:18:50,000 --> 00:18:50,000
对

594
00:18:50,000 --> 00:18:52,000
所以我们现在所做出的任何想象

595
00:18:52,000 --> 00:18:55,000
可能在那个时候看来都是非常幼稚而可笑的

596
00:18:57,000 --> 00:18:59,000
但这仍旧拦不住我们去想

597
00:19:01,000 --> 00:19:01,000
好吧

598
00:19:01,000 --> 00:19:04,000
那个什么上期的 follow up 就读到这里

599
00:19:06,000 --> 00:19:06,000
其实还有一个

600
00:19:06,000 --> 00:19:11,000
就是上期莫洋说到

601
00:19:11,000 --> 00:19:19,000
比如说有些语言非常要求你什么注意分号缩净大小写之类的

602
00:19:19,000 --> 00:19:20,000
他有没有说大小写我不记得

603
00:19:20,000 --> 00:19:22,000
但是我前两天看了看那个 Nim 语言

604
00:19:22,000 --> 00:19:25,000
就是新出的那个之前叫 Nimrod

605
00:19:25,000 --> 00:19:27,000
然后现在 Nim 的语言

606
00:19:27,000 --> 00:19:29,000
这个语言有一个很有趣的一点

607
00:19:29,000 --> 00:19:32,000
就是他区分一个标识符的时候

608
00:19:34,000 --> 00:19:35,000
只区分第一个字母是不是大小写

609
00:19:36,000 --> 00:19:38,000
后面是无关的

610
00:19:38,000 --> 00:19:40,000
而且带下滑线也是无关的

611
00:19:42,000 --> 00:19:43,000
这有什么好处呢

612
00:19:43,000 --> 00:19:46,000
就是他列举的好处是

613
00:19:46,000 --> 00:19:53,000
比如说你写一个程序要用到别人的库

614
00:19:53,000 --> 00:19:56,000
别人的库有一个他自己的变量 convention

615
00:19:56,000 --> 00:19:59,000
然后或者说函数 convention

616
00:19:59,000 --> 00:20:01,000
当你要调用那些函数的时候

617
00:20:01,000 --> 00:20:04,000
你可以利用自己的 convention

618
00:20:04,000 --> 00:20:08,000
因为也许他是用下滑线做分格符的

619
00:20:08,000 --> 00:20:09,000
而你喜欢 camel case

620
00:20:09,000 --> 00:20:12,000
那你可以在你的程序里面写 camel case

621
00:20:12,000 --> 00:20:17,000
编译起码自己去猜真正的标识符是什么

622
00:20:18,000 --> 00:20:21,000
我觉得这是一个很有意思的 feature

623
00:20:21,000 --> 00:20:23,000
这是个恶趣味

624
00:20:23,000 --> 00:20:23,000
对

625
00:20:23,000 --> 00:20:26,000
但可能从另外一个角度讲

626
00:20:26,000 --> 00:20:28,000
他也是在试图解决这样一种

627
00:20:28,000 --> 00:20:32,000
就是你可以再去忽略另外一个细节

628
00:20:32,000 --> 00:20:36,000
就是你不用去永远去刻意的注意大小写要一致

629
00:20:36,000 --> 00:20:38,000
然后你可以借用这个 feature

630
00:20:38,000 --> 00:20:41,000
来保证自己的编程风格在内部是一致

631
00:20:44,000 --> 00:20:46,000
说一下最终发生的一些小新闻

632
00:20:46,000 --> 00:20:49,000
然后你也看到苹果发布会了

633
00:20:49,000 --> 00:20:51,000
好呀

634
00:20:51,000 --> 00:20:55,000
我们之前专门讨论过谣传中的新的 MacBook

635
00:20:55,000 --> 00:20:56,000
它其实不是 Air 了

636
00:20:56,000 --> 00:20:58,000
就是 MacBook

637
00:20:58,000 --> 00:21:00,000
然后你对其实是很有很有趣的

638
00:21:00,000 --> 00:21:02,000
为什么 MacBook Air 还叫 MacBook Air

639
00:21:02,000 --> 00:21:05,000
然后新的更薄更 Air 的还叫

640
00:21:05,000 --> 00:21:07,000
反而叫 MacBook

641
00:21:07,000 --> 00:21:09,000
我后来是这么理解的

642
00:21:09,000 --> 00:21:14,000
就是因为现在 MacBook Pro 它也变得很薄了

643
00:21:14,000 --> 00:21:16,000
所以以后就不分

644
00:21:16,000 --> 00:21:17,000
有这个 Air 就该讲

645
00:21:17,000 --> 00:21:20,000
就薄是一个必然的属性

646
00:21:20,000 --> 00:21:22,000
然后只区分是否专业

647
00:21:22,000 --> 00:21:24,000
所以 MacBook Air 那个产品线可能过几年

648
00:21:24,000 --> 00:21:26,000
过两三年就直接就消失了

649
00:21:26,000 --> 00:21:27,000
OK

650
00:21:27,000 --> 00:21:30,000
就只有 MacBook 和 MacBook Pro 这样的两个分野

651
00:21:30,000 --> 00:21:33,000
我觉得这样其实是更清晰的一个结构

652
00:21:33,000 --> 00:21:35,000
然后如果你要比 MacBook 更薄的东西

653
00:21:35,000 --> 00:21:36,000
就只能去买 iPad 了

654
00:21:37,000 --> 00:21:38,000
对 没错

655
00:21:39,000 --> 00:21:39,000
OK

656
00:21:40,000 --> 00:21:46,000
所以最重要的一件事情是 Escape 键没有动

657
00:21:46,000 --> 00:21:50,000
对 我觉得他们也应该是内部顶住了巨大的压力

658
00:21:51,000 --> 00:21:53,000
我们先不确定之前那个图上面

659
00:21:53,000 --> 00:21:54,000
那个 Escape 键

660
00:21:54,000 --> 00:21:56,000
就是真的有原型机长那样吗

661
00:21:56,000 --> 00:21:58,000
其实是挺值得怀疑的

662
00:21:59,000 --> 00:22:00,000
好吧 说得也是

663
00:22:00,000 --> 00:22:02,000
也有可能内部从来没有出现过一个 Escape

664
00:22:02,000 --> 00:22:05,000
在这么让人天怒人怨的地方

665
00:22:06,000 --> 00:22:08,000
对 只可能那个谁画图的时候

666
00:22:08,000 --> 00:22:10,000
不小心就画成那样了而已

667
00:22:11,000 --> 00:22:12,000
不过不管如何

668
00:22:12,000 --> 00:22:14,000
Escape 键的位置没变

669
00:22:14,000 --> 00:22:15,000
而且还变大了

670
00:22:15,000 --> 00:22:16,000
这个是挺好的一件事

671
00:22:16,000 --> 00:22:19,000
因为你用过那个 11 寸的 MacBook Air 吗

672
00:22:20,000 --> 00:22:21,000
用过一次

673
00:22:21,000 --> 00:22:25,000
就是我有一次借前公司的老板的办公电脑

674
00:22:25,000 --> 00:22:26,000
出过一次拆

675
00:22:27,000 --> 00:22:29,000
你们公司已经这么惨

676
00:22:29,000 --> 00:22:30,000
还有借老板的电脑出差

677
00:22:30,000 --> 00:22:30,000
好笑

678
00:22:30,000 --> 00:22:32,000
因为我自己的电脑太大了

679
00:22:32,000 --> 00:22:33,000
听起来好稀酸

680
00:22:35,000 --> 00:22:37,000
我觉得我不是很喜欢 MacBook Air

681
00:22:37,000 --> 00:22:39,000
当然可能主要也是因为

682
00:22:39,000 --> 00:22:41,000
就是屏幕实在是太小了

683
00:22:41,000 --> 00:22:42,000
11 寸的确实是很小

684
00:22:42,000 --> 00:22:44,000
13 寸的还是很小

685
00:22:44,000 --> 00:22:44,000
我觉得

686
00:22:44,000 --> 00:22:46,000
它边框也比较大

687
00:22:47,000 --> 00:22:47,000
对

688
00:22:47,000 --> 00:22:49,000
所以你会觉得挺糟糕的

689
00:22:50,000 --> 00:22:52,000
特别是 11 寸 Escape 键特别小

690
00:22:52,000 --> 00:22:54,000
因为它那个半高

691
00:22:54,000 --> 00:22:56,000
不是三分之一高的键

692
00:22:57,000 --> 00:22:59,000
然后而且还那么小一坨

693
00:22:59,000 --> 00:23:02,000
然后现在 MacBook Air 的 Escape 键变得很长

694
00:23:02,000 --> 00:23:05,000
然后我们作为一个 Vim 档

695
00:23:05,000 --> 00:23:06,000
这件事什么

696
00:23:06,000 --> 00:23:07,000
福音

697
00:23:07,000 --> 00:23:08,000
对

698
00:23:09,000 --> 00:23:11,000
所以你是要买一台

699
00:23:11,000 --> 00:23:13,000
如果听上上 3 ID 公论的

700
00:23:14,000 --> 00:23:14,000
印象没错

701
00:23:16,000 --> 00:23:17,000
因为我老婆那台她要换

702
00:23:17,000 --> 00:23:18,000
她要给她买一台

703
00:23:18,000 --> 00:23:19,000
顺便我玩一下

704
00:23:19,000 --> 00:23:21,000
到时候假如我要出门

705
00:23:21,000 --> 00:23:22,000
做件什么事情

706
00:23:22,000 --> 00:23:23,000
我就拿她那台去好了

707
00:23:24,000 --> 00:23:25,000
OK

708
00:23:26,000 --> 00:23:27,000
这是顺便玩下来一次

709
00:23:27,000 --> 00:23:30,000
就是 80%的时间是你在用

710
00:23:30,000 --> 00:23:31,000
没有

711
00:23:31,000 --> 00:23:32,000
那个性能不太够

712
00:23:32,000 --> 00:23:33,000
它那个最高

713
00:23:33,000 --> 00:23:34,000
就是内存是固定的 8 G

714
00:23:34,000 --> 00:23:36,000
不能再扩张了

715
00:23:36,000 --> 00:23:37,000
这是比较一个蛋疼一点

716
00:23:37,000 --> 00:23:39,000
就是 8 G 真的不是很够

717
00:23:40,000 --> 00:23:41,000
因为这件事情

718
00:23:41,000 --> 00:23:43,000
其实还是挺麻烦的

719
00:23:43,000 --> 00:23:44,000
现在你看一下

720
00:23:44,000 --> 00:23:46,000
我们跑了很多软件的

721
00:23:46,000 --> 00:23:47,000
特别是 64 位之后

722
00:23:47,000 --> 00:23:49,000
那些很多软件的体积是

723
00:23:49,000 --> 00:23:50,000
就越来越大了

724
00:23:51,000 --> 00:23:52,000
而且现在开个网页

725
00:23:52,000 --> 00:23:53,000
动不动就击败

726
00:23:53,000 --> 00:23:54,000
一个 Tab 就击败

727
00:23:54,000 --> 00:23:55,000
照相一个 G 的

728
00:23:56,000 --> 00:23:58,000
所以还是 8 G

729
00:23:58,000 --> 00:23:59,000
你要是再开虚拟 G 的话

730
00:23:59,000 --> 00:24:00,000
就肯定是不太

731
00:24:00,000 --> 00:24:01,000
有点捉襟见肘吧

732
00:24:01,000 --> 00:24:01,000
至少

733
00:24:02,000 --> 00:24:02,000
对

734
00:24:04,000 --> 00:24:06,000
你那台是 16 的吗

735
00:24:06,000 --> 00:24:08,000
我现在这台是 16 的

736
00:24:08,000 --> 00:24:08,000
对

737
00:24:08,000 --> 00:24:08,000
OK

738
00:24:08,000 --> 00:24:09,000
我也是 16 的

739
00:24:09,000 --> 00:24:11,000
就是现在就作为一个开发者的话

740
00:24:11,000 --> 00:24:14,000
可能还是要 16 才至少一够吧

741
00:24:14,000 --> 00:24:16,000
当然现在可能主要瓶颈

742
00:24:16,000 --> 00:24:18,000
不是在内存上面

743
00:24:18,000 --> 00:24:20,000
就有时候跑一些比较大的游戏

744
00:24:20,000 --> 00:24:22,000
会风扇狂转

745
00:24:22,000 --> 00:24:23,000
它那个没有风扇了

746
00:24:24,000 --> 00:24:25,000
不是内存的问题

747
00:24:25,000 --> 00:24:26,000
对 我是说我现在这台

748
00:24:27,000 --> 00:24:27,000
OK

749
00:24:27,000 --> 00:24:29,000
如果买一个新的 MacBook

750
00:24:29,000 --> 00:24:31,000
应该就很多游戏又不能玩了

751
00:24:32,000 --> 00:24:32,000
不知道

752
00:24:32,000 --> 00:24:34,000
它那款性能现在还没出来

753
00:24:34,000 --> 00:24:35,000
昨天我看了一下

754
00:24:35,000 --> 00:24:37,000
那个有网上有测评

755
00:24:37,000 --> 00:24:39,000
联想出了一款

756
00:24:39,000 --> 00:24:41,000
就出了一款那个什么

757
00:24:41,000 --> 00:24:43,000
它那种联想不是有个本

758
00:24:43,000 --> 00:24:45,000
它是可以变成平板用的那种笔记本吗

759
00:24:45,000 --> 00:24:46,000
就是本来的

760
00:24:46,000 --> 00:24:47,000
Convert

761
00:24:48,000 --> 00:24:49,000
Tablet 之类的

762
00:24:49,000 --> 00:24:50,000
它用的处理器

763
00:24:50,000 --> 00:24:52,000
我看了一下性能和那个参数

764
00:24:52,000 --> 00:24:53,000
应该是和

765
00:24:54,000 --> 00:24:57,000
新款的跟 MacBook 里面那款是差不多的

766
00:24:57,000 --> 00:24:59,000
我看了一下它在测评的性能

767
00:24:59,000 --> 00:25:03,000
其实是跟 14 款的 MacBook Air 是差不多的

768
00:25:03,000 --> 00:25:04,000
我觉得还凑合了

769
00:25:04,000 --> 00:25:06,000
其实很多时候已经够用了

770
00:25:07,000 --> 00:25:09,000
就只要你不是经常要编译什么

771
00:25:09,000 --> 00:25:12,000
编译 Swift 的代码的话

772
00:25:12,000 --> 00:25:13,000
你只是做一些

773
00:25:13,000 --> 00:25:14,000
比如说像我用 Go 的话

774
00:25:14,000 --> 00:25:16,000
就编译很快就无所谓

775
00:25:16,000 --> 00:25:18,000
然后你说做 web 开发都是动态语言

776
00:25:18,000 --> 00:25:19,000
没有这个编译过程

777
00:25:19,000 --> 00:25:20,000
那也无所谓

778
00:25:20,000 --> 00:25:21,000
所以

779
00:25:21,000 --> 00:25:23,000
我觉得性能可能对大多数情况下也是

780
00:25:23,000 --> 00:25:25,000
也是凑合够了

781
00:25:26,000 --> 00:25:27,000
好吧

782
00:25:27,000 --> 00:25:30,000
我觉得可能做 iOS 开发还是有点够强

783
00:25:31,000 --> 00:25:32,000
屏幕太小了

784
00:25:33,000 --> 00:25:34,000
主要

785
00:25:34,000 --> 00:25:37,000
我觉得 iOS 开发跑模拟器的时候

786
00:25:37,000 --> 00:25:38,000
其实还是挺

787
00:25:38,000 --> 00:25:39,000
挺质子的

788
00:25:40,000 --> 00:25:40,000
对

789
00:25:40,000 --> 00:25:41,000
没错

790
00:25:41,000 --> 00:25:42,000
而且他们现在不是说这个事吗

791
00:25:42,000 --> 00:25:43,000
就是

792
00:25:44,000 --> 00:25:45,000
因为现在不是所有的 iOS 设备

793
00:25:45,000 --> 00:25:46,000
都是所谓的 Retina 分辨率

794
00:25:47,000 --> 00:25:48,000
就是两倍的

795
00:25:48,000 --> 00:25:49,000
那么你要在屏幕上

796
00:25:49,000 --> 00:25:51,000
真实还原 1 比 1 的话

797
00:25:51,000 --> 00:25:52,000
你的屏幕要比那个大

798
00:25:53,000 --> 00:25:53,000
现在

799
00:25:53,000 --> 00:25:54,000
如果你屏幕那么小的话

800
00:25:54,000 --> 00:25:56,000
就没有办法很好的还原

801
00:25:56,000 --> 00:25:58,000
它就模拟器装不下

802
00:25:58,000 --> 00:25:59,000
只能缩放

803
00:25:59,000 --> 00:25:59,000
不是太好

804
00:26:00,000 --> 00:26:02,000
但是我相信现在也有很多开发者

805
00:26:02,000 --> 00:26:03,000
就是他

806
00:26:03,000 --> 00:26:04,000
如果他真的要跑的话

807
00:26:04,000 --> 00:26:06,000
他就不在模拟器上跑

808
00:26:06,000 --> 00:26:06,000
直接接设

809
00:26:06,000 --> 00:26:07,000
直接上真机吗

810
00:26:07,000 --> 00:26:08,000
对

811
00:26:08,000 --> 00:26:08,000
也是

812
00:26:08,000 --> 00:26:11,000
那个传输好像还是比较

813
00:26:11,000 --> 00:26:11,000
就是你那个

814
00:26:11,000 --> 00:26:13,000
就是那个 cycle 还是比较长

815
00:26:13,000 --> 00:26:14,000
你要传到那个

816
00:26:15,000 --> 00:26:16,000
iOS 设备上去

817
00:26:16,000 --> 00:26:17,000
然后你要马上看结果

818
00:26:17,000 --> 00:26:19,000
我说你还是要等那么可能一两分钟吧

819
00:26:19,000 --> 00:26:20,000
我估计

820
00:26:22,000 --> 00:26:24,000
我的经历还好吧

821
00:26:24,000 --> 00:26:24,000
我觉得

822
00:26:24,000 --> 00:26:27,000
就可能要比在虚拟机里面

823
00:26:28,000 --> 00:26:29,000
快那么

824
00:26:29,000 --> 00:26:30,000
慢那么

825
00:26:30,000 --> 00:26:31,000
最多 20 秒吧

826
00:26:31,000 --> 00:26:32,000
我觉得

827
00:26:32,000 --> 00:26:33,000
还是可以忍受的

828
00:26:33,000 --> 00:26:36,000
那也是很大的损耗了呀

829
00:26:36,000 --> 00:26:36,000
不

830
00:26:36,000 --> 00:26:39,000
但到你到后期的时候

831
00:26:39,000 --> 00:26:41,000
我觉得大部分人可能会

832
00:26:43,000 --> 00:26:44,000
就怎么说呢

833
00:26:44,000 --> 00:26:45,000
就回到那个

834
00:26:45,000 --> 00:26:47,000
回到我们之前讨论的 repl

835
00:26:47,000 --> 00:26:48,000
在没有 repl 时代

836
00:26:48,000 --> 00:26:50,000
你可能要用头脑去模拟那个

837
00:26:50,000 --> 00:26:52,000
机器跑出来什么样子

838
00:26:52,000 --> 00:26:53,000
自己在脑子里面想是不是

839
00:26:53,000 --> 00:26:54,000
对

840
00:26:54,000 --> 00:26:55,000
我觉得到后期 iOS 开发

841
00:26:55,000 --> 00:26:57,000
其实很多人都是

842
00:26:57,000 --> 00:26:59,000
会

843
00:26:59,000 --> 00:27:02,000
花相对长的时间在写

844
00:27:02,000 --> 00:27:05,000
然后真正看效果的时间

845
00:27:05,000 --> 00:27:07,000
可能只有开发时间的 10%不到

846
00:27:08,000 --> 00:27:11,000
但除非你在 debug 的话

847
00:27:11,000 --> 00:27:12,000
那就只能要另说

848
00:27:13,000 --> 00:27:14,000
对

849
00:27:14,000 --> 00:27:14,000
对

850
00:27:14,000 --> 00:27:14,000
没错

851
00:27:15,000 --> 00:27:15,000
对

852
00:27:16,000 --> 00:27:18,000
这个新款的本

853
00:27:18,000 --> 00:27:20,000
还有一个挺大的事

854
00:27:20,000 --> 00:27:22,000
是他那个键盘的轴不一样

855
00:27:23,000 --> 00:27:23,000
蝴蝶轴

856
00:27:23,000 --> 00:27:24,000
蝴蝶轴

857
00:27:24,000 --> 00:27:24,000
是什么概念

858
00:27:24,000 --> 00:27:25,000
你有概念吗

859
00:27:26,000 --> 00:27:28,000
我其实也没有很看懂

860
00:27:29,000 --> 00:27:29,000
这个蝴蝶轴

861
00:27:29,000 --> 00:27:32,000
它是这次才新发明

862
00:27:32,000 --> 00:27:34,000
之前是没有这种机制的是吧

863
00:27:34,000 --> 00:27:34,000
就没有前面

864
00:27:34,000 --> 00:27:36,000
之前是只有剪刀角的对吧

865
00:27:36,000 --> 00:27:37,000
我说苹果上

866
00:27:37,000 --> 00:27:38,000
就在其他人有用过这种

867
00:27:38,000 --> 00:27:39,000
所谓蝴蝶轴

868
00:27:39,000 --> 00:27:40,000
从来没有

869
00:27:40,000 --> 00:27:41,000
从来没有见过

870
00:27:41,000 --> 00:27:42,000
因为我看他说的

871
00:27:42,000 --> 00:27:44,000
应该是他们自己新发明的一种

872
00:27:44,000 --> 00:27:47,000
一种键盘轴的机制吧

873
00:27:47,000 --> 00:27:48,000
对

874
00:27:48,000 --> 00:27:49,000
然后他说这个有个好处

875
00:27:49,000 --> 00:27:50,000
就是说剪刀角一个问题

876
00:27:50,000 --> 00:27:50,000
就是说

877
00:27:50,000 --> 00:27:52,000
如果他会不平稳吗

878
00:27:53,000 --> 00:27:55,000
你说你按一个键的角落

879
00:27:55,000 --> 00:27:57,000
它会斜着下去

880
00:27:57,000 --> 00:27:58,000
有时候会触发不到

881
00:27:58,000 --> 00:27:59,000
对

882
00:27:59,000 --> 00:28:01,000
虽然我自己从来没有意识到

883
00:28:01,000 --> 00:28:01,000
这种情况

884
00:28:01,000 --> 00:28:02,000
但是我不知道

885
00:28:02,000 --> 00:28:03,000
这个是很常见的现象吗

886
00:28:03,000 --> 00:28:04,000
还是怎样

887
00:28:05,000 --> 00:28:08,000
你按你在按苹果的键盘上

888
00:28:08,000 --> 00:28:08,000
一个键的时候

889
00:28:08,000 --> 00:28:09,000
你会明显感觉到

890
00:28:09,000 --> 00:28:10,000
你按的时候

891
00:28:10,000 --> 00:28:12,000
那个键是随着你按的那一角

892
00:28:12,000 --> 00:28:13,000
先开始下线

893
00:28:13,000 --> 00:28:15,000
然后其他部分一起

894
00:28:15,000 --> 00:28:16,000
才跟着下线的

895
00:28:16,000 --> 00:28:18,000
但是不应该按键的中心位置吗

896
00:28:18,000 --> 00:28:20,000
你为什么会按它的边角呢

897
00:28:22,000 --> 00:28:24,000
我倒是觉得

898
00:28:24,000 --> 00:28:25,000
在大部分时候

899
00:28:25,000 --> 00:28:26,000
你是不可能完

900
00:28:26,000 --> 00:28:29,000
就正儿八经按到它的中心位置里

901
00:28:30,000 --> 00:28:30,000
OK

902
00:28:30,000 --> 00:28:32,000
因为我自己从来没有留意到

903
00:28:32,000 --> 00:28:34,000
我有发出现过这种

904
00:28:35,000 --> 00:28:38,000
因为按到剪刀角的某一个边

905
00:28:38,000 --> 00:28:40,000
而不是中心位置触发不了的情况

906
00:28:40,000 --> 00:28:41,000
所以我还挺好奇

907
00:28:41,000 --> 00:28:42,000
他在发布会说

908
00:28:42,000 --> 00:28:44,000
触发不了是肯定不会的

909
00:28:44,000 --> 00:28:47,000
但是剪刀角所造成的问题就是

910
00:28:48,000 --> 00:28:50,000
你按那个键的时候

911
00:28:50,000 --> 00:28:52,000
你会觉得键怎么说呢

912
00:28:52,000 --> 00:28:53,000
我觉得这个区别

913
00:28:53,000 --> 00:28:54,000
是只有你在按上去的时候

914
00:28:54,000 --> 00:28:56,000
才会感觉到的

915
00:28:56,000 --> 00:28:58,000
就是你按一个

916
00:28:58,000 --> 00:29:02,000
比如说我在按那个 HHKB 的时候

917
00:29:03,000 --> 00:29:03,000
按一个键

918
00:29:03,000 --> 00:29:06,000
这个键是本身是不会晃动的

919
00:29:06,000 --> 00:29:06,000
对吧

920
00:29:07,000 --> 00:29:10,000
就是我按这个键的最左上角

921
00:29:10,000 --> 00:29:12,000
整个键会随着我的手指一起下线

922
00:29:12,000 --> 00:29:15,000
但是你再按一个剪刀角的时候

923
00:29:15,000 --> 00:29:17,000
键的左上角会先下线

924
00:29:17,000 --> 00:29:19,000
然后其他部分才跟着下线

925
00:29:19,000 --> 00:29:20,000
没错是这样的

926
00:29:21,000 --> 00:29:23,000
这个键是会有一定的所谓

927
00:29:23,000 --> 00:29:25,000
摇晃对吧

928
00:29:25,000 --> 00:29:26,000
对 wobbling space

929
00:29:26,000 --> 00:29:29,000
就是它会有一种不稳的感觉

930
00:29:29,000 --> 00:29:32,000
但是我相信它胡搁角所要解决的问题

931
00:29:32,000 --> 00:29:34,000
就是你不会再有这种感觉了

932
00:29:34,000 --> 00:29:35,000
这个键就是实的

933
00:29:35,000 --> 00:29:36,000
然后你按下去一点

934
00:29:36,000 --> 00:29:38,000
整个键会跟着一起下线

935
00:29:39,000 --> 00:29:41,000
他们现场去测

936
00:29:41,000 --> 00:29:44,000
就是试用过那款新的 MacBook 的键盘

937
00:29:44,000 --> 00:29:46,000
那时候都说键程非常短

938
00:29:46,000 --> 00:29:48,000
因为它整个厚度降低了

939
00:29:48,000 --> 00:29:50,000
而且它蝴蝶轴的

940
00:29:51,000 --> 00:29:52,000
本来的一个设计初步

941
00:29:52,000 --> 00:29:54,000
就是为了减低厚度

942
00:29:54,000 --> 00:29:54,000
对吧

943
00:29:54,000 --> 00:29:55,000
高度

944
00:29:55,000 --> 00:29:58,000
我不太清楚这种键程极短的情况下

945
00:29:58,000 --> 00:30:01,000
对编程的时候的打字的手感

946
00:30:01,000 --> 00:30:02,000
会有什么变化

947
00:30:03,000 --> 00:30:05,000
你喜欢长键程

948
00:30:05,000 --> 00:30:07,000
还是短键程的键盘

949
00:30:09,000 --> 00:30:11,000
其实我不怎么挑

950
00:30:11,000 --> 00:30:12,000
但我觉得

951
00:30:12,000 --> 00:30:13,000
对

952
00:30:13,000 --> 00:30:16,000
但我觉得就是在用触摸板的时候

953
00:30:17,000 --> 00:30:19,000
你可以理解为这个键程是零

954
00:30:19,000 --> 00:30:19,000
对吧

955
00:30:21,000 --> 00:30:27,000
我不知道也许在配了触摸板的笔记本电脑上

956
00:30:27,000 --> 00:30:30,000
按一个键程比较短的键

957
00:30:31,000 --> 00:30:34,000
起感觉是不是至少要比 iPad 好

958
00:30:34,000 --> 00:30:37,000
就是你至少是有一点点键程的

959
00:30:37,000 --> 00:30:38,000
你在 iPad 上

960
00:30:38,000 --> 00:30:40,000
因为按那个虚拟键盘的时候

961
00:30:40,000 --> 00:30:41,000
手感是非常差的

962
00:30:41,000 --> 00:30:41,000
对吧

963
00:30:42,000 --> 00:30:43,000
虚拟键盘手感差

964
00:30:43,000 --> 00:30:44,000
主要是有几个原因

965
00:30:44,000 --> 00:30:46,000
不光是它没有键程

966
00:30:46,000 --> 00:30:48,000
因为主要是一个是没有触觉的分隔

967
00:30:48,000 --> 00:30:50,000
你不知道你按了哪个键了

968
00:30:50,000 --> 00:30:51,000
你如果不看的话

969
00:30:51,000 --> 00:30:51,000
对

970
00:30:51,000 --> 00:30:52,000
就是因为零键程

971
00:30:52,000 --> 00:30:53,000
所以才没有分隔

972
00:30:53,000 --> 00:30:54,000
不是吗

973
00:30:54,000 --> 00:30:55,000
我的意思是

974
00:30:55,000 --> 00:30:57,000
这两个其实是一回事

975
00:30:58,000 --> 00:30:59,000
你说这个就没有突出

976
00:30:59,000 --> 00:31:01,000
然后也没有下线

977
00:31:01,000 --> 00:31:01,000
对

978
00:31:01,000 --> 00:31:03,000
就算是零键程的话

979
00:31:03,000 --> 00:31:04,000
它也是可以有分隔的

980
00:31:04,000 --> 00:31:05,000
就是

981
00:31:06,000 --> 00:31:09,000
我不知道你用没有用过微软 Surface

982
00:31:09,000 --> 00:31:10,000
它不是有两款键盘吗

983
00:31:11,000 --> 00:31:12,000
一款是所谓的

984
00:31:13,000 --> 00:31:13,000
叫什么

985
00:31:13,000 --> 00:31:14,000
Touch Cover

986
00:31:15,000 --> 00:31:15,000
对

987
00:31:15,000 --> 00:31:16,000
就是那个 Bowm 键盘

988
00:31:17,000 --> 00:31:18,000
它不是一个

989
00:31:18,000 --> 00:31:21,000
就是它是有分隔

990
00:31:21,000 --> 00:31:22,000
但是无键程的一个键盘

991
00:31:22,000 --> 00:31:23,000
就你其实按的是一个

992
00:31:23,000 --> 00:31:25,000
对是一块平板

993
00:31:25,000 --> 00:31:26,000
然后它也有一款

994
00:31:26,000 --> 00:31:27,000
那叫做 Type Cover

995
00:31:27,000 --> 00:31:28,000
我记得

996
00:31:28,000 --> 00:31:29,000
然后我是用过

997
00:31:29,000 --> 00:31:30,000
那个键程也蛮短的

998
00:31:30,000 --> 00:31:32,000
然后我两款都试了一下

999
00:31:32,000 --> 00:31:34,000
都感觉不是很好

1000
00:31:34,000 --> 00:31:36,000
就键程短这件事情本身是

1001
00:31:36,000 --> 00:31:37,000
不是太好的

1002
00:31:37,000 --> 00:31:38,000
就一切情况相同的情况下

1003
00:31:39,000 --> 00:31:40,000
OK

1004
00:31:40,000 --> 00:31:42,000
因为你就没有办法

1005
00:31:43,000 --> 00:31:45,000
就有时候你可能会觉得不确定

1006
00:31:45,000 --> 00:31:46,000
你就按下去没有

1007
00:31:46,000 --> 00:31:47,000
我觉得可能会这样

1008
00:31:47,000 --> 00:31:47,000
会是这个原因

1009
00:31:48,000 --> 00:31:49,000
但是他们说

1010
00:31:49,000 --> 00:31:51,000
这个蝴蝶轴的

1011
00:31:51,000 --> 00:31:52,000
这些有些其他的好处

1012
00:31:52,000 --> 00:31:54,000
比如说它不会左右乱晃

1013
00:31:54,000 --> 00:31:56,000
然后它这个打字也很

1014
00:31:57,000 --> 00:31:57,000
就是

1015
00:31:58,000 --> 00:32:01,000
他们说那个手感挺特别的

1016
00:32:01,000 --> 00:32:02,000
我现在也没有打过

1017
00:32:02,000 --> 00:32:03,000
我不知道到底是个 Smart 手感

1018
00:32:03,000 --> 00:32:04,000
我很想去试一下

1019
00:32:05,000 --> 00:32:06,000
但我又在想

1020
00:32:06,000 --> 00:32:07,000
其实键程短

1021
00:32:07,000 --> 00:32:10,000
反而不是应该能帮助你

1022
00:32:10,000 --> 00:32:11,000
长时间打字吗

1023
00:32:11,000 --> 00:32:13,000
这样用力会比较小

1024
00:32:13,000 --> 00:32:13,000
是不是

1025
00:32:15,000 --> 00:32:19,000
我觉得可能最终省下来的力

1026
00:32:19,000 --> 00:32:20,000
也只有一点点

1027
00:32:20,000 --> 00:32:21,000
一牛

1028
00:32:22,000 --> 00:32:22,000
打了一整天

1029
00:32:22,000 --> 00:32:24,000
省了一牛的力

1030
00:32:27,000 --> 00:32:28,000
对我觉得这个键程

1031
00:32:28,000 --> 00:32:29,000
可能更多带来的

1032
00:32:29,000 --> 00:32:31,000
还是触感上

1033
00:32:31,000 --> 00:32:34,000
而真正的省力什么的

1034
00:32:34,000 --> 00:32:37,000
都是非常浮云的东西

1035
00:32:39,000 --> 00:32:40,000
反过来说你可能

1036
00:32:40,000 --> 00:32:41,000
你会觉得

1037
00:32:41,000 --> 00:32:43,000
也许喜欢常见程的人

1038
00:32:43,000 --> 00:32:44,000
可以去用一个

1039
00:32:44,000 --> 00:32:46,000
就前两天在推特上看到的

1040
00:32:46,000 --> 00:32:48,000
USB Typewriter

1041
00:32:49,000 --> 00:32:51,000
打字体转 USB 的接口

1042
00:32:51,000 --> 00:32:52,000
然后接电脑上打的

1043
00:32:52,000 --> 00:32:53,000
对我觉得这个

1044
00:32:53,000 --> 00:32:54,000
这个实际上太怀旧了

1045
00:32:54,000 --> 00:32:56,000
就是你可以去

1046
00:32:56,000 --> 00:32:58,000
你可以选择直接从网站上买一台

1047
00:32:58,000 --> 00:33:00,000
已经转化好的 Typewriter

1048
00:33:00,000 --> 00:33:03,000
它是货真价实的打字机

1049
00:33:03,000 --> 00:33:05,000
然后你可以把这个打字机接到

1050
00:33:05,000 --> 00:33:09,000
机械上的打字机接到你的 USB 口上

1051
00:33:09,000 --> 00:33:11,000
然后把打字机当键盘来用

1052
00:33:11,000 --> 00:33:12,000
它那个原理是什么

1053
00:33:12,000 --> 00:33:15,000
它是探测机械键的位移

1054
00:33:15,000 --> 00:33:17,000
然后转成 USB 电信号吗

1055
00:33:17,000 --> 00:33:18,000
对其实就是

1056
00:33:18,000 --> 00:33:20,000
如果你去看它的

1057
00:33:20,000 --> 00:33:22,000
converter kit 的话

1058
00:33:22,000 --> 00:33:26,000
如果你直接从网站上买的比较贵

1059
00:33:26,000 --> 00:33:28,000
可能要 599 还是 699 美元一台

1060
00:33:28,000 --> 00:33:30,000
但你可以买另外一个 kit

1061
00:33:30,000 --> 00:33:31,000
这 kit 就是 99 美元

1062
00:33:31,000 --> 00:33:33,000
然后里面有一大堆触板

1063
00:33:33,000 --> 00:33:34,000
就是一个比较长条

1064
00:33:34,000 --> 00:33:36,000
像梳子一样的东西

1065
00:33:36,000 --> 00:33:38,000
和一个很小的

1066
00:33:38,000 --> 00:33:39,000
我应该不是 Arduino

1067
00:33:39,000 --> 00:33:41,000
是他们自己做的一个 IC 板

1068
00:33:41,000 --> 00:33:45,000
你把那个长条的梳子一样的背板

1069
00:33:45,000 --> 00:33:48,000
贴到机械打字机的后面

1070
00:33:49,000 --> 00:33:54,000
然后再把那个 IC 电路塞在打字机的内部

1071
00:33:54,000 --> 00:33:59,000
然后你就可以把它转化成一个 USB 打字机了

1072
00:33:59,000 --> 00:34:00,000
其实它就是去探测

1073
00:34:00,000 --> 00:34:03,000
因为你在按下一个打字机上面的键的时候

1074
00:34:03,000 --> 00:34:05,000
它后面会有一个东西抬起来

1075
00:34:06,000 --> 00:34:09,000
然后它就去感应哪个键抬起来

1076
00:34:10,000 --> 00:34:12,000
然后把它转化为键盘性了

1077
00:34:12,000 --> 00:34:14,000
对那个键按键

1078
00:34:16,000 --> 00:34:17,000
但其实那个很累的

1079
00:34:17,000 --> 00:34:21,000
机械打字机的那个按键是很费力的

1080
00:34:22,000 --> 00:34:22,000
对

1081
00:34:22,000 --> 00:34:24,000
我小时候用打字机打英语作业的时候

1082
00:34:24,000 --> 00:34:27,000
就每天晚上打完了手指会疼的

1083
00:34:27,000 --> 00:34:27,000
真的

1084
00:34:27,000 --> 00:34:29,000
那个时候你小孩手也小

1085
00:34:29,000 --> 00:34:31,000
而且那个时候执法也不好

1086
00:34:31,000 --> 00:34:34,000
只能用食指和中指再按

1087
00:34:34,000 --> 00:34:36,000
然后有些字母

1088
00:34:36,000 --> 00:34:36,000
如果你用

1089
00:34:36,000 --> 00:34:39,000
让我那个时候我去用小指去按的话

1090
00:34:39,000 --> 00:34:40,000
永远是虚的

1091
00:34:40,000 --> 00:34:41,000
比如说 P 之类的

1092
00:34:41,000 --> 00:34:43,000
PQ 永远是虚的

1093
00:34:46,000 --> 00:34:48,000
这也是一种恶趣味

1094
00:34:48,000 --> 00:34:48,000
对

1095
00:34:48,000 --> 00:34:51,000
这叫什么蒸汽朋克

1096
00:34:51,000 --> 00:34:52,000
机械朋克

1097
00:34:52,000 --> 00:34:53,000
机械朋克打字机

1098
00:34:53,000 --> 00:34:55,000
机械朋克键盘

1099
00:34:55,000 --> 00:34:59,000
说到这个程序员用的笔记本

1100
00:34:59,000 --> 00:35:00,000
前两天 Google

1101
00:35:00,000 --> 00:35:01,000
就是应该不是前两天

1102
00:35:01,000 --> 00:35:04,000
就是苹果发布那个新款 MacBook 之后

1103
00:35:04,000 --> 00:35:07,000
第二天 Google 也发布了这个新款的

1104
00:35:07,000 --> 00:35:08,000
Chromebook Pixel

1105
00:35:08,000 --> 00:35:09,000
就是它那款

1106
00:35:10,000 --> 00:35:15,000
虽然官方配置是只能用上网的一个笔记本

1107
00:35:15,000 --> 00:35:17,000
但是它的整个配置还是不错的

1108
00:35:17,000 --> 00:35:18,000
有一个高分屏

1109
00:35:18,000 --> 00:35:20,000
也是 13 寸一个方头方脑的一个设计

1110
00:35:21,000 --> 00:35:22,000
然后

1111
00:35:23,000 --> 00:35:24,000
我知道很多人

1112
00:35:24,000 --> 00:35:25,000
就是 Linux 用户

1113
00:35:25,000 --> 00:35:26,000
他会选这个

1114
00:35:26,000 --> 00:35:28,000
然后他装那个

1115
00:35:28,000 --> 00:35:30,000
上面有一个这种软件叫做 Chrompton

1116
00:35:30,000 --> 00:35:31,000
好像是就可以在上面

1117
00:35:32,000 --> 00:35:34,000
在一个类似于

1118
00:35:34,000 --> 00:35:36,000
这个 container 的环境里面

1119
00:35:36,000 --> 00:35:38,000
跑一个其他内核的

1120
00:35:38,000 --> 00:35:38,000
不叫其他内核

1121
00:35:38,000 --> 00:35:41,000
就其他的 Linux 的发行板

1122
00:35:41,000 --> 00:35:42,000
比如 Chrompton 之类的

1123
00:35:42,000 --> 00:35:44,000
然后这样的话就有很多好处

1124
00:35:44,000 --> 00:35:46,000
因为 Chromebook 它本身是一个类似于

1125
00:35:46,000 --> 00:35:47,000
iOS 的设计

1126
00:35:47,000 --> 00:35:49,000
就整个它是沙盒机制的

1127
00:35:49,000 --> 00:35:51,000
然后你没有办法去更改系统的东西

1128
00:35:51,000 --> 00:35:54,000
就安全性是有保障的

1129
00:35:54,000 --> 00:35:56,000
然后你在 container 里面再跑一个

1130
00:35:56,000 --> 00:35:57,000
Linux 发行板

1131
00:35:57,000 --> 00:35:58,000
你就弄坏了

1132
00:35:58,000 --> 00:36:00,000
再删掉重新来一颗就好了

1133
00:36:00,000 --> 00:36:03,000
就很多人会选择这种方式来做

1134
00:36:03,000 --> 00:36:03,000
是

1135
00:36:04,000 --> 00:36:07,000
它那个板的唯一的问题就是

1136
00:36:07,000 --> 00:36:08,000
存储空间太小了

1137
00:36:08,000 --> 00:36:11,000
它最大只有 64 G 的 SSD

1138
00:36:11,000 --> 00:36:12,000
对

1139
00:36:12,000 --> 00:36:13,000
我觉得我也不知道

1140
00:36:13,000 --> 00:36:16,000
你见过身边的人在用 Chrombook 吗

1141
00:36:17,000 --> 00:36:18,000
为什么我总有一种感觉

1142
00:36:18,000 --> 00:36:20,000
就是它是一个怎么 somehow 叫好

1143
00:36:20,000 --> 00:36:22,000
不叫错的生命

1144
00:36:22,000 --> 00:36:24,000
我没有见过有人自己花钱买它

1145
00:36:24,000 --> 00:36:26,000
然后但不过我有个朋友

1146
00:36:26,000 --> 00:36:30,000
他是前年去年去 Google IOS 的时候

1147
00:36:30,000 --> 00:36:33,000
那年不是 Google 去参购

1148
00:36:33,000 --> 00:36:34,000
或者是每个人送了一台吗

1149
00:36:34,000 --> 00:36:36,000
就是第一代的 Chrombook Pixel

1150
00:36:36,000 --> 00:36:37,000
然后他就拿了一台回来

1151
00:36:37,000 --> 00:36:38,000
我玩了一下

1152
00:36:38,000 --> 00:36:41,000
就整个做工和工艺还是不错的

1153
00:36:41,000 --> 00:36:41,000
我觉得

1154
00:36:41,000 --> 00:36:44,000
但是就是能做的事情感觉挺有限

1155
00:36:44,000 --> 00:36:45,000
OK

1156
00:36:46,000 --> 00:36:48,000
因为它那个空间确实比较小

1157
00:36:48,000 --> 00:36:51,000
它那个是带 LTE 还是 4 G 网络的

1158
00:36:51,000 --> 00:36:51,000
对

1159
00:36:51,000 --> 00:36:52,000
它可以插 SIM 卡

1160
00:36:53,000 --> 00:36:54,000
这点比较有意思

1161
00:36:56,000 --> 00:36:56,000
对

1162
00:36:56,000 --> 00:36:59,000
其实我之前在想说

1163
00:37:00,000 --> 00:37:04,000
新的 MacBook 为什么不能直接内置 LTE

1164
00:37:04,000 --> 00:37:04,000
Model

1165
00:37:07,000 --> 00:37:09,000
因为它那个轻薄的程度

1166
00:37:09,000 --> 00:37:12,000
其实已经非常适合带着到处跑

1167
00:37:12,000 --> 00:37:13,000
但是带着到处跑

1168
00:37:13,000 --> 00:37:14,000
有个问题就是在没有网络的地方

1169
00:37:14,000 --> 00:37:15,000
比如说

1170
00:37:15,000 --> 00:37:16,000
它那个宣传广告里面

1171
00:37:16,000 --> 00:37:20,000
有一个女孩拿着它盘腿

1172
00:37:20,000 --> 00:37:23,000
坐在一个公园旁边的长椅上

1173
00:37:23,000 --> 00:37:24,000
然后我就想说

1174
00:37:24,000 --> 00:37:25,000
它往从哪来

1175
00:37:27,000 --> 00:37:28,000
苹果的解决方案是说

1176
00:37:28,000 --> 00:37:29,000
你只要有手机在旁边

1177
00:37:29,000 --> 00:37:31,000
可以通过无线的连接一个

1178
00:37:31,000 --> 00:37:32,000
Tethering

1179
00:37:33,000 --> 00:37:33,000
对

1180
00:37:33,000 --> 00:37:35,000
它可以做一个这个

1181
00:37:35,000 --> 00:37:36,000
好吧

1182
00:37:36,000 --> 00:37:36,000
我觉得还可以

1183
00:37:36,000 --> 00:37:39,000
因为其实你如果每一个设备

1184
00:37:39,000 --> 00:37:40,000
都做一个 SIM 卡的话

1185
00:37:40,000 --> 00:37:43,000
你每个月的交给运营商的月费还是蛮多的

1186
00:37:43,000 --> 00:37:45,000
如果是偶尔的

1187
00:37:45,000 --> 00:37:46,000
就这种场合使用的话

1188
00:37:46,000 --> 00:37:47,000
这样也没什么不好

1189
00:37:48,000 --> 00:37:51,000
之前用 Tethering 还比较麻烦

1190
00:37:51,000 --> 00:37:53,000
你要先在手机上打开

1191
00:37:53,000 --> 00:37:55,000
然后你在电脑上连接一下

1192
00:37:55,000 --> 00:37:56,000
现在自从有 SIM 里面

1193
00:37:56,000 --> 00:37:57,000
不是你可以直接

1194
00:37:58,000 --> 00:37:59,000
就只要你手机在旁边

1195
00:37:59,000 --> 00:38:00,000
你点 WiFi 的 Logo 里面

1196
00:38:00,000 --> 00:38:01,000
就可以很方便的

1197
00:38:01,000 --> 00:38:03,000
有一个选项可以直接

1198
00:38:03,000 --> 00:38:04,000
通过你的手机

1199
00:38:04,000 --> 00:38:05,000
iPhone Tethering

1200
00:38:05,000 --> 00:38:07,000
所以我觉得还好吧

1201
00:38:07,000 --> 00:38:08,000
而且现在

1202
00:38:09,000 --> 00:38:12,000
就出门你要真的进下来办公

1203
00:38:12,000 --> 00:38:14,000
那除非你是去什么公园里面再说

1204
00:38:14,000 --> 00:38:15,000
就是如果你是什么咖啡馆

1205
00:38:15,000 --> 00:38:17,000
就以 WiFi 的地方还是太多了吧

1206
00:38:19,000 --> 00:38:19,000
说的也是

1207
00:38:19,000 --> 00:38:21,000
我感觉是这样子

1208
00:38:22,000 --> 00:38:27,000
你有 Ever 带着一个笔记本出去办公这种事情吗

1209
00:38:27,000 --> 00:38:29,000
你觉得家里太憋

1210
00:38:29,000 --> 00:38:30,000
或者是外面阳光真好

1211
00:38:30,000 --> 00:38:33,000
想要一边写程序一边享受阳光之类的

1212
00:38:33,000 --> 00:38:34,000
你做这种事情吗

1213
00:38:34,000 --> 00:38:36,000
夏天的时候我经常带出去

1214
00:38:36,000 --> 00:38:37,000
在海边

1215
00:38:37,000 --> 00:38:37,000
因为我们在

1216
00:38:37,000 --> 00:38:39,000
我这个地方就是在靠海

1217
00:38:39,000 --> 00:38:42,000
我家离大西洋的直线距离

1218
00:38:42,000 --> 00:38:44,000
可能只有两三公里的样子

1219
00:38:45,000 --> 00:38:48,000
我开车开到海边找个这种稍微

1220
00:38:49,000 --> 00:38:51,000
视线比较好的地方

1221
00:38:51,000 --> 00:38:54,000
我就坐在副驾的位置上

1222
00:38:54,000 --> 00:38:57,000
把椅子往后折

1223
00:38:57,000 --> 00:38:58,000
然后在那里办公

1224
00:38:58,000 --> 00:39:00,000
就是聆听着拍案的怒涛

1225
00:39:00,000 --> 00:39:02,000
然后我们这里没有怒涛

1226
00:39:02,000 --> 00:39:03,000
只有小浪

1227
00:39:04,000 --> 00:39:04,000
好吧

1228
00:39:04,000 --> 00:39:06,000
看着大西洋的浑浊海浪

1229
00:39:07,000 --> 00:39:08,000
大西洋是蛮的

1230
00:39:08,000 --> 00:39:08,000
谢谢

1231
00:39:09,000 --> 00:39:10,000
不像太平洋

1232
00:39:11,000 --> 00:39:12,000
太平洋是很好的

1233
00:39:12,000 --> 00:39:13,000
太平洋更蓝吧应该

1234
00:39:14,000 --> 00:39:14,000
我不知道

1235
00:39:14,000 --> 00:39:16,000
我之前在

1236
00:39:17,000 --> 00:39:19,000
起码在中国的海岸线上

1237
00:39:19,000 --> 00:39:21,000
看到的太平洋都是挺黄昏灼的

1238
00:39:22,000 --> 00:39:25,000
那是因为中国的河流浅了

1239
00:39:25,000 --> 00:39:26,000
不对

1240
00:39:26,000 --> 00:39:27,000
那边还比较浅

1241
00:39:27,000 --> 00:39:28,000
像渤海有

1242
00:39:28,000 --> 00:39:30,000
我们家门口的渤海有时候会冻上来

1243
00:39:30,000 --> 00:39:32,000
就浅到这个地步

1244
00:39:32,000 --> 00:39:32,000
OK

1245
00:39:33,000 --> 00:39:36,000
蓝海其实是足够深的地方都是蓝色的

1246
00:39:36,000 --> 00:39:37,000
那我们那边可能就是很深的

1247
00:39:37,000 --> 00:39:40,000
我就看都是一望无际那种

1248
00:39:40,000 --> 00:39:42,000
之前是照片上看到的那种蓝

1249
00:39:42,000 --> 00:39:43,000
现在就是我们家旁边的这种

1250
00:39:44,000 --> 00:39:44,000
OK

1251
00:39:45,000 --> 00:39:46,000
好吧

1252
00:39:46,000 --> 00:39:48,000
我好像我很少干这种事情

1253
00:39:48,000 --> 00:39:50,000
就是带着一个笔本出去办公

1254
00:39:51,000 --> 00:39:52,000
我觉得

1255
00:39:52,000 --> 00:39:54,000
之前我不是看到一个德国人

1256
00:39:54,000 --> 00:39:54,000
他说

1257
00:39:55,000 --> 00:39:56,000
他都不要那个

1258
00:39:56,000 --> 00:39:59,000
他是做好像开发那种

1259
00:39:59,000 --> 00:40:00,000
他是在那种

1260
00:40:01,000 --> 00:40:02,000
主机上不是主机

1261
00:40:02,000 --> 00:40:05,000
就是服务器上开发那种

1262
00:40:05,000 --> 00:40:06,000
科学计算能应用的人

1263
00:40:06,000 --> 00:40:08,000
他都直接不要笔记本了

1264
00:40:08,000 --> 00:40:08,000
他就带个 iPad

1265
00:40:08,000 --> 00:40:10,000
然后带个蓝牙键盘出门

1266
00:40:10,000 --> 00:40:11,000
然后 iPad 有什么

1267
00:40:11,000 --> 00:40:12,000
有司机

1268
00:40:13,000 --> 00:40:15,000
他就在那个什么公园里面找个

1269
00:40:15,000 --> 00:40:16,000
一凳子坐上

1270
00:40:17,000 --> 00:40:20,000
然后就是空间不就长椅那种木凳吗

1271
00:40:20,000 --> 00:40:21,000
然后他就把那个拿出来

1272
00:40:21,000 --> 00:40:22,000
然后通过 LTE 上

1273
00:40:22,000 --> 00:40:24,000
他反正只需要那个 SSH 就过去

1274
00:40:24,000 --> 00:40:26,000
所有软件都可以在服务器上有

1275
00:40:29,000 --> 00:40:32,000
他如果只是纯 Consul 下面编程的话

1276
00:40:32,000 --> 00:40:33,000
这样的确是可取的

1277
00:40:34,000 --> 00:40:38,000
但你只要稍微接触到任何非 Consul 的东西

1278
00:40:38,000 --> 00:40:39,000
那 iPad 直接就废了

1279
00:40:39,000 --> 00:40:40,000
我觉得

1280
00:40:40,000 --> 00:40:42,000
但你要在本地做事情

1281
00:40:42,000 --> 00:40:43,000
那肯定是不可取的

1282
00:40:43,000 --> 00:40:50,000
除非你现在 iPad 上面有 Xwindow 的客户端吗

1283
00:40:50,000 --> 00:40:50,000
没有吧

1284
00:40:51,000 --> 00:40:52,000
我不太清楚

1285
00:40:52,000 --> 00:40:54,000
不过有那个叫什么

1286
00:40:54,000 --> 00:40:55,000
RemoteVNC

1287
00:40:55,000 --> 00:40:57,000
对 VNC 的这种东西

1288
00:40:57,000 --> 00:40:58,000
然后鼠标怎么

1289
00:41:00,000 --> 00:41:01,000
就是你用点屏幕

1290
00:41:03,000 --> 00:41:07,000
你要用鼠标肯定就输了

1291
00:41:08,000 --> 00:41:09,000
听起来有点淡淡的

1292
00:41:09,000 --> 00:41:13,000
或者用纯键盘的创作管理器应该也可以

1293
00:41:14,000 --> 00:41:16,000
对你不是反正 VNC 大部分的时候

1294
00:41:16,000 --> 00:41:18,000
都用那个 VNC 的 K 版本吗

1295
00:41:18,000 --> 00:41:19,000
应该也差不多合适了

1296
00:41:19,000 --> 00:41:19,000
我觉得

1297
00:41:21,000 --> 00:41:21,000
好吧

1298
00:41:21,000 --> 00:41:22,000
下次可以试试

1299
00:41:23,000 --> 00:41:24,000
问题是有试试吗

1300
00:41:24,000 --> 00:41:25,000
你没有吧

1301
00:41:25,000 --> 00:41:25,000
对

1302
00:41:25,000 --> 00:41:26,000
我是一个

1303
00:41:26,000 --> 00:41:27,000
我觉得如果出门的话

1304
00:41:27,000 --> 00:41:28,000
就不要办公

1305
00:41:28,000 --> 00:41:29,000
如果办公的话就不要出门

1306
00:41:30,000 --> 00:41:32,000
那你想换个环境散散心怎么办

1307
00:41:33,000 --> 00:41:34,000
那就补办公

1308
00:41:34,000 --> 00:41:36,000
想散心的时候散心

1309
00:41:36,000 --> 00:41:37,000
那什么

1310
00:41:38,000 --> 00:41:40,000
叫什么李大超的那篇文章

1311
00:41:40,000 --> 00:41:41,000
什么玩

1312
00:41:41,000 --> 00:41:42,000
玩就玩个痛快

1313
00:41:42,000 --> 00:41:43,000
学就学个舒服

1314
00:41:45,000 --> 00:41:46,000
不是学就学个舒服

1315
00:41:46,000 --> 00:41:47,000
学就学个什么

1316
00:41:47,000 --> 00:41:49,000
在这玩就玩个痛快

1317
00:41:50,000 --> 00:41:51,000
该干嘛

1318
00:41:51,000 --> 00:41:52,000
玩硬术

1319
00:41:52,000 --> 00:41:53,000
玩硬术

1320
00:41:54,000 --> 00:41:55,000
不要又想

1321
00:41:55,000 --> 00:41:56,000
又想轻松

1322
00:41:56,000 --> 00:41:57,000
又想

1323
00:41:57,000 --> 00:41:59,000
要办公就站着

1324
00:41:59,000 --> 00:42:02,000
然后敲一开机械键盘

1325
00:42:02,000 --> 00:42:03,000
用一个

1326
00:42:03,000 --> 00:42:05,000
用一台 power mac

1327
00:42:05,000 --> 00:42:06,000
然后要出去

1328
00:42:06,000 --> 00:42:07,000
有什么要不有什么都不要带

1329
00:42:08,000 --> 00:42:09,000
那如果你是这种人的话

1330
00:42:09,000 --> 00:42:10,000
你为什么买一个笔记本

1331
00:42:11,000 --> 00:42:13,000
因为我并不具备

1332
00:42:13,000 --> 00:42:14,000
尚不具备

1333
00:42:15,000 --> 00:42:19,000
一个可以装 power mac 的办公室

1334
00:42:19,000 --> 00:42:20,000
我觉得

1335
00:42:21,000 --> 00:42:21,000
不不

1336
00:42:21,000 --> 00:42:23,000
你可以用那个什么 iMac 之类的

1337
00:42:25,000 --> 00:42:29,000
我之前的确是在 iMac 和 power

1338
00:42:29,000 --> 00:42:32,000
和 MVP 之间

1339
00:42:33,000 --> 00:42:35,000
犹豫了一阵子

1340
00:42:35,000 --> 00:42:37,000
因为那个时候我正要从

1341
00:42:37,000 --> 00:42:38,000
一个城市搬到另外一城市

1342
00:42:38,000 --> 00:42:39,000
就是考虑到自己可能

1343
00:42:39,000 --> 00:42:40,000
即将要换工作

1344
00:42:40,000 --> 00:42:41,000
对

1345
00:42:41,000 --> 00:42:41,000
对

1346
00:42:41,000 --> 00:42:42,000
然后现在对

1347
00:42:42,000 --> 00:42:43,000
挺麻烦的事情

1348
00:42:43,000 --> 00:42:43,000
对

1349
00:42:43,000 --> 00:42:45,000
然后那个时候正考虑说

1350
00:42:45,000 --> 00:42:46,000
如果搬到女朋友那边去住

1351
00:42:46,000 --> 00:42:48,000
然后可能暂时不会有一个办公室

1352
00:42:48,000 --> 00:42:50,000
事实上我现在的确没有一个办公室

1353
00:42:50,000 --> 00:42:51,000
所以可能

1354
00:42:51,000 --> 00:42:53,000
还是

1355
00:42:53,000 --> 00:42:55,000
有一台笔记本比较方便

1356
00:42:55,000 --> 00:42:57,000
起码它在整个体积上

1357
00:42:57,000 --> 00:42:58,000
还是可以小一些

1358
00:42:59,000 --> 00:43:00,000
然后拿走的话也方便一点

1359
00:43:01,000 --> 00:43:01,000
对

1360
00:43:02,000 --> 00:43:03,000
其实我也是这样

1361
00:43:03,000 --> 00:43:04,000
我这笔记本大部分都是

1362
00:43:04,000 --> 00:43:05,000
就是放在桌上

1363
00:43:05,000 --> 00:43:07,000
然后接显示器

1364
00:43:07,000 --> 00:43:08,000
然后插各种线

1365
00:43:08,000 --> 00:43:10,000
就当桌面机

1366
00:43:10,000 --> 00:43:10,000
就什么

1367
00:43:10,000 --> 00:43:12,000
Desktop replacement

1368
00:43:12,000 --> 00:43:13,000
对

1369
00:43:13,000 --> 00:43:13,000
因为

1370
00:43:13,000 --> 00:43:15,000
就我觉得 Macbook Pro 其实有一点

1371
00:43:15,000 --> 00:43:18,000
就是如果你出去旅游的时候

1372
00:43:18,000 --> 00:43:19,000
要带它还是不带它

1373
00:43:19,000 --> 00:43:19,000
就

1374
00:43:21,000 --> 00:43:22,000
不带它显然

1375
00:43:22,000 --> 00:43:22,000
对

1376
00:43:22,000 --> 00:43:24,000
但如果我有一台 iMac

1377
00:43:24,000 --> 00:43:26,000
和一台新的 Macbook

1378
00:43:26,000 --> 00:43:28,000
那我可能会毫不犹豫地想要带上

1379
00:43:29,000 --> 00:43:29,000
对

1380
00:43:29,000 --> 00:43:30,000
因为小嘛

1381
00:43:30,000 --> 00:43:31,000
对

1382
00:43:32,000 --> 00:43:33,000
所以还是

1383
00:43:33,000 --> 00:43:35,000
就可能我们这种情况比较特殊

1384
00:43:36,000 --> 00:43:37,000
有很多这种所谓的这种

1385
00:43:38,000 --> 00:43:40,000
白领他可能经常需要去开会

1386
00:43:40,000 --> 00:43:41,000
办公之类的

1387
00:43:42,000 --> 00:43:43,000
他就需要

1388
00:43:44,000 --> 00:43:45,000
拿一台电脑

1389
00:43:45,000 --> 00:43:46,000
然后 iPad 又不行

1390
00:43:47,000 --> 00:43:48,000
这个时候那种

1391
00:43:48,000 --> 00:43:50,000
轻薄的笔记本就有的

1392
00:43:50,000 --> 00:43:51,000
就是一个必须的选项

1393
00:43:51,000 --> 00:43:52,000
没错

1394
00:43:53,000 --> 00:43:54,000
今天的主题是什么

1395
00:43:55,000 --> 00:43:57,000
今天的主题是病法

1396
00:43:57,000 --> 00:43:58,000
和异步

1397
00:44:00,000 --> 00:44:01,000
听起来是不是就

1398
00:44:01,000 --> 00:44:01,000
等一下

1399
00:44:01,000 --> 00:44:02,000
这是不是又太干了

1400
00:44:04,000 --> 00:44:05,000
病法和异步

1401
00:44:05,000 --> 00:44:07,000
其实我们可以讲的比较

1402
00:44:07,000 --> 00:44:08,000
犯一点的

1403
00:44:08,000 --> 00:44:11,000
比较浅入浅出一点

1404
00:44:13,000 --> 00:44:15,000
霍金不是在时间电视里面说

1405
00:44:16,000 --> 00:44:18,000
你在书里面加一个公式

1406
00:44:18,000 --> 00:44:20,000
你的读者就会少一半

1407
00:44:21,000 --> 00:44:22,000
每多加一个公式

1408
00:44:22,000 --> 00:44:24,000
你的读者就会少一半

1409
00:44:24,000 --> 00:44:26,000
所以我们讲可能是

1410
00:44:26,000 --> 00:44:27,000
我们每次

1411
00:44:27,000 --> 00:44:29,000
我们每增加一个术语

1412
00:44:30,000 --> 00:44:31,000
可能听众就会少一半

1413
00:44:31,000 --> 00:44:33,000
比如说上一期编程与数学

1414
00:44:34,000 --> 00:44:35,000
可能

1415
00:44:36,000 --> 00:44:38,000
已经限定了很多

1416
00:44:38,000 --> 00:44:41,000
听很多对数学和编程不感兴趣的听众是不会的

1417
00:44:41,000 --> 00:44:44,000
当然对数学和编程不感兴趣的听众

1418
00:44:44,000 --> 00:44:45,000
为什么要听得很恐慌

1419
00:44:45,000 --> 00:44:46,000
没事

1420
00:44:46,000 --> 00:44:48,000
他们还可以听沐瑶老师的声音

1421
00:44:50,000 --> 00:44:50,000
说点事

1422
00:44:53,000 --> 00:44:56,000
我们应该把沐瑶专门挖到

1423
00:44:56,000 --> 00:44:58,000
IPM 来单独做一档节目

1424
00:44:58,000 --> 00:44:59,000
各位听众说怎么样

1425
00:45:00,000 --> 00:45:01,000
然后粉丝全过去了

1426
00:45:01,000 --> 00:45:03,000
我们这没升级给人家

1427
00:45:03,000 --> 00:45:06,000
对此处应该插入幼儿园的

1428
00:45:06,000 --> 00:45:08,000
所有小朋友的 MV 说好

1429
00:45:11,000 --> 00:45:11,000
对

1430
00:45:12,000 --> 00:45:13,000
好

1431
00:45:13,000 --> 00:45:14,000
好

1432
00:45:16,000 --> 00:45:16,000
对

1433
00:45:16,000 --> 00:45:16,000
好吧

1434
00:45:17,000 --> 00:45:20,000
所以并发和并行其实是两个概念

1435
00:45:21,000 --> 00:45:22,000
不并发和异步

1436
00:45:23,000 --> 00:45:23,000
对不对

1437
00:45:24,000 --> 00:45:25,000
concurrency

1438
00:45:25,000 --> 00:45:27,000
concurrent 和 parallel

1439
00:45:27,000 --> 00:45:28,000
先讲并发这一块

1440
00:45:29,000 --> 00:45:29,000
对

1441
00:45:29,000 --> 00:45:32,000
并发和并行

1442
00:45:32,000 --> 00:45:34,000
这个术语其实有点很纠结的

1443
00:45:34,000 --> 00:45:36,000
我觉得没有一个很清晰的

1444
00:45:36,000 --> 00:45:39,000
就起码中文没有一个很清晰的概念

1445
00:45:39,000 --> 00:45:40,000
就 concur

1446
00:45:40,000 --> 00:45:43,000
英文两边是两个完全不一样的词

1447
00:45:43,000 --> 00:45:43,000
对吧

1448
00:45:44,000 --> 00:45:45,000
但是在中文里面

1449
00:45:45,000 --> 00:45:47,000
你说并发和并行有什么太大区别

1450
00:45:47,000 --> 00:45:47,000
好像也没有

1451
00:45:48,000 --> 00:45:50,000
但我觉得怎么说

1452
00:45:50,000 --> 00:45:52,000
有的人专业工作没有很多词汇

1453
00:45:52,000 --> 00:45:52,000
都是这样

1454
00:45:52,000 --> 00:45:53,000
而且

1455
00:45:54,000 --> 00:45:55,000
你说 concurrency 和 parallel

1456
00:45:55,000 --> 00:45:56,000
在英文里面的

1457
00:45:57,000 --> 00:45:59,000
区别是每一个程序员都了解的吗

1458
00:45:59,000 --> 00:46:00,000
肯定也不是

1459
00:46:00,000 --> 00:46:04,000
甚至连词典的定义都是非常接近

1460
00:46:04,000 --> 00:46:06,000
你说都没有一个很严格的区分

1461
00:46:06,000 --> 00:46:07,000
到底哪个是哪个

1462
00:46:07,000 --> 00:46:08,000
对

1463
00:46:08,000 --> 00:46:11,000
但我觉得可能在软件界

1464
00:46:11,000 --> 00:46:12,000
有很多这样的问题

1465
00:46:12,000 --> 00:46:12,000
比如说

1466
00:46:13,000 --> 00:46:15,000
argument 和 parameter 的差别

1467
00:46:16,000 --> 00:46:18,000
可能有很多时候也会毁用

1468
00:46:19,000 --> 00:46:20,000
就看语境

1469
00:46:21,000 --> 00:46:22,000
大部分时候是不分的

1470
00:46:22,000 --> 00:46:22,000
我觉得

1471
00:46:23,000 --> 00:46:23,000
对

1472
00:46:24,000 --> 00:46:24,000
但

1473
00:46:25,000 --> 00:46:28,000
具体到这一期的话题上来说

1474
00:46:28,000 --> 00:46:30,000
我觉得可能正确的区分

1475
00:46:30,000 --> 00:46:32,000
concurrency 和 parallel 也是

1476
00:46:33,000 --> 00:46:35,000
就接下来的讨论比较重要的事情

1477
00:46:35,000 --> 00:46:36,000
甚至可以说

1478
00:46:36,000 --> 00:46:38,000
如果我们这期节目可以让

1479
00:46:39,000 --> 00:46:41,000
可以帮助听过的人

1480
00:46:41,000 --> 00:46:43,000
确切地了解了

1481
00:46:43,000 --> 00:46:45,000
concurrency 和 parallel 之间的差别

1482
00:46:45,000 --> 00:46:47,000
那可能也已经是

1483
00:46:47,000 --> 00:46:49,000
很有好处

1484
00:46:49,000 --> 00:46:49,000
对

1485
00:46:49,000 --> 00:46:50,000
很有成功一点

1486
00:46:50,000 --> 00:46:51,000
很成功一点

1487
00:46:51,000 --> 00:46:54,000
所以我们要先把这个范围说的很窄

1488
00:46:54,000 --> 00:46:55,000
就是说我们在这里讲的

1489
00:46:55,000 --> 00:46:56,000
并发和并行

1490
00:46:56,000 --> 00:46:57,000
当然对应的两个词就是

1491
00:46:57,000 --> 00:46:59,000
concurrency 和 parallel

1492
00:46:59,000 --> 00:47:00,000
这两个词都是讲

1493
00:47:00,000 --> 00:47:01,000
在

1494
00:47:02,000 --> 00:47:03,000
叫什么

1495
00:47:03,000 --> 00:47:04,000
多

1496
00:47:04,000 --> 00:47:05,000
多线程

1497
00:47:05,000 --> 00:47:09,000
或者说在程序语言的构建的时候的

1498
00:47:09,000 --> 00:47:10,000
一个场景

1499
00:47:10,000 --> 00:47:12,000
至于说场景以外

1500
00:47:12,000 --> 00:47:13,000
你要怎么去用这两个词

1501
00:47:13,000 --> 00:47:14,000
那就随你变

1502
00:47:15,000 --> 00:47:16,000
对

1503
00:47:17,000 --> 00:47:19,000
所以什么是 concurrency

1504
00:47:19,000 --> 00:47:21,000
什么是并发

1505
00:47:22,000 --> 00:47:24,000
concurrency 我是这么理解的

1506
00:47:24,000 --> 00:47:27,000
就是说它是一种思维方式

1507
00:47:27,000 --> 00:47:29,000
就是说你是怎么去

1508
00:47:29,000 --> 00:47:31,000
在逻辑上去构建一个东西

1509
00:47:31,000 --> 00:47:33,000
是它两个之间是

1510
00:47:33,000 --> 00:47:36,000
可以没有一个先后顺序的依赖关系的

1511
00:47:37,000 --> 00:47:39,000
我在这么解释可不是合理

1512
00:47:39,000 --> 00:47:40,000
或者是清晰

1513
00:47:40,000 --> 00:47:41,000
但我是这么理解的

1514
00:47:41,000 --> 00:47:42,000
OK

1515
00:47:42,000 --> 00:47:44,000
那什么是 parallel

1516
00:47:44,000 --> 00:47:45,000
什么是并行

1517
00:47:45,000 --> 00:47:47,000
并行的话就是说

1518
00:47:47,000 --> 00:47:47,000
这个是

1519
00:47:47,000 --> 00:47:50,000
我就是相对于刚才那一讲

1520
00:47:50,000 --> 00:47:51,000
是在逻辑层面的话

1521
00:47:51,000 --> 00:47:53,000
那个 concurrency 在逻辑层面的一个概念的话

1522
00:47:53,000 --> 00:47:55,000
并行可能就是在一个

1523
00:47:55,000 --> 00:47:56,000
物理层面的一个概念了

1524
00:47:56,000 --> 00:47:57,000
就是说

1525
00:47:58,000 --> 00:48:00,000
在逻辑上并发的东西

1526
00:48:00,000 --> 00:48:00,000
在物理上

1527
00:48:00,000 --> 00:48:02,000
它并不一定是在并行执行

1528
00:48:02,000 --> 00:48:04,000
它也可以是先做一个后做一个

1529
00:48:04,000 --> 00:48:07,000
只是说它这个先后是没有太大关系的

1530
00:48:07,000 --> 00:48:08,000
就谁先谁后都一样

1531
00:48:08,000 --> 00:48:10,000
但是并就是在

1532
00:48:10,000 --> 00:48:12,000
实现层面的并行的话

1533
00:48:12,000 --> 00:48:14,000
就是说它两个是在物理事件中

1534
00:48:14,000 --> 00:48:16,000
同时发生的

1535
00:48:17,000 --> 00:48:17,000
OK

1536
00:48:17,000 --> 00:48:18,000
这样解释可以吗

1537
00:48:18,000 --> 00:48:19,000
我觉得

1538
00:48:19,000 --> 00:48:21,000
我觉得应该是可以的

1539
00:48:21,000 --> 00:48:22,000
就是怎么说呢

1540
00:48:22,000 --> 00:48:23,000
就是有一句

1541
00:48:23,000 --> 00:48:26,000
就是 Raw Pike 曾经做过一个

1542
00:48:26,000 --> 00:48:28,000
对勾浪的

1543
00:48:28,000 --> 00:48:30,000
勾 routine 的

1544
00:48:31,000 --> 00:48:33,000
叫什么

1545
00:48:33,000 --> 00:48:35,000
幻灯片

1546
00:48:35,000 --> 00:48:35,000
对

1547
00:48:35,000 --> 00:48:36,000
就对

1548
00:48:36,000 --> 00:48:38,000
这个幻灯片在网上可以得到

1549
00:48:38,000 --> 00:48:39,000
然后它的

1550
00:48:39,000 --> 00:48:42,000
它对于并发和并行的定义是

1551
00:48:42,000 --> 00:48:44,000
并发是同一时间

1552
00:48:44,000 --> 00:48:46,000
应对多件事情的能力

1553
00:48:46,000 --> 00:48:48,000
就 dealing with

1554
00:48:48,000 --> 00:48:49,000
a lot of things

1555
00:48:50,000 --> 00:48:51,000
而并行呢

1556
00:48:51,000 --> 00:48:52,000
就是 parallel

1557
00:48:52,000 --> 00:48:52,000
则是

1558
00:48:52,000 --> 00:48:56,000
同一时间动手去做很多件事情

1559
00:48:56,000 --> 00:48:58,000
但这里你就要解释什么是

1560
00:48:58,000 --> 00:49:00,000
什么是什么是什么是

1561
00:49:00,000 --> 00:49:02,000
应对和什么是做对吧

1562
00:49:02,000 --> 00:49:03,000
对

1563
00:49:03,000 --> 00:49:04,000
我觉得可以理解为就是

1564
00:49:04,000 --> 00:49:05,000
这两个

1565
00:49:05,000 --> 00:49:08,000
这两个概念的抽象层级是不一样

1566
00:49:08,000 --> 00:49:09,000
就并发

1567
00:49:09,000 --> 00:49:11,000
或者说他们描述的

1568
00:49:11,000 --> 00:49:13,000
问题的领域是不一样

1569
00:49:13,000 --> 00:49:15,000
所谓并发 concurrency

1570
00:49:15,000 --> 00:49:17,000
指的是一个比较

1571
00:49:20,000 --> 00:49:24,000
在问题领域的概念

1572
00:49:24,000 --> 00:49:25,000
就是你有很多问题

1573
00:49:25,000 --> 00:49:27,000
你需要去解决这些问题

1574
00:49:27,000 --> 00:49:30,000
而这些问题的发生是同时发生的

1575
00:49:30,000 --> 00:49:32,000
你就可以说

1576
00:49:32,000 --> 00:49:32,000
我要

1577
00:49:33,000 --> 00:49:37,000
我所面对的问题有 concurrency 的特征

1578
00:49:37,000 --> 00:49:39,000
而 parallel 则是

1579
00:49:39,000 --> 00:49:41,000
在你实际去做一件事情的时候

1580
00:49:41,000 --> 00:49:43,000
比如说你要

1581
00:49:43,000 --> 00:49:46,000
你要去解决一个并发的问题

1582
00:49:46,000 --> 00:49:48,000
你怎么去解决它

1583
00:49:48,000 --> 00:49:51,000
好你可以使用并行的手段去解决它

1584
00:49:54,000 --> 00:49:55,000
我大概理解你意思

1585
00:49:55,000 --> 00:49:57,000
但我觉得听起来有点是好

1586
00:49:58,000 --> 00:49:58,000
对吧

1587
00:49:58,000 --> 00:49:59,000
比如说或者说

1588
00:50:00,000 --> 00:50:03,000
我们还是举例子来解释

1589
00:50:04,000 --> 00:50:04,000
比如说

1590
00:50:06,000 --> 00:50:09,000
我在做一些事情的时候

1591
00:50:09,000 --> 00:50:10,000
需要去做另外一件事情

1592
00:50:10,000 --> 00:50:11,000
比如说我要做饭

1593
00:50:12,000 --> 00:50:14,000
但是我的碗还没洗

1594
00:50:14,000 --> 00:50:14,000
锅也没刷

1595
00:50:14,000 --> 00:50:16,000
好那我要先刷锅

1596
00:50:16,000 --> 00:50:17,000
再洗碗

1597
00:50:17,000 --> 00:50:18,000
然后再切菜

1598
00:50:18,000 --> 00:50:20,000
然后再把油倒进锅里

1599
00:50:20,000 --> 00:50:21,000
然后开始炒菜

1600
00:50:21,000 --> 00:50:22,000
炒完菜再装盘

1601
00:50:23,000 --> 00:50:24,000
所有这些事情可以理解为

1602
00:50:24,000 --> 00:50:27,000
我是有些事情是可以同时做的

1603
00:50:27,000 --> 00:50:27,000
对吧

1604
00:50:27,000 --> 00:50:28,000
比如说我可以

1605
00:50:29,000 --> 00:50:31,000
先洗一部分碗

1606
00:50:31,000 --> 00:50:32,000
然后先把锅洗了

1607
00:50:32,000 --> 00:50:34,000
然后用锅来炒菜

1608
00:50:34,000 --> 00:50:36,000
然后在菜被煮的过程中

1609
00:50:36,000 --> 00:50:37,000
假设我是做一个炖菜

1610
00:50:37,000 --> 00:50:40,000
不需要长时间的去翻它的炖菜

1611
00:50:40,000 --> 00:50:44,000
然后我可以在炖菜的时候去洗碗

1612
00:50:44,000 --> 00:50:45,000
对吧

1613
00:50:45,000 --> 00:50:48,000
此时我可以说做饭这件事情

1614
00:50:48,000 --> 00:50:51,000
是一个并发的事情

1615
00:50:51,000 --> 00:50:55,000
因为有很多头绪需要我去做

1616
00:50:55,000 --> 00:50:57,000
甚至我可以把买菜加进去

1617
00:50:57,000 --> 00:50:59,000
比如说我可以去买菜

1618
00:50:59,000 --> 00:51:00,000
我需要先去买菜

1619
00:51:00,000 --> 00:51:02,000
然后再去刷锅洗碗

1620
00:51:02,000 --> 00:51:03,000
然后再开始炖菜

1621
00:51:03,000 --> 00:51:03,000
然后再开始装菜

1622
00:51:03,000 --> 00:51:05,000
然后再开始摆桌子之类的

1623
00:51:06,000 --> 00:51:08,000
但是因为我只有一个人

1624
00:51:08,000 --> 00:51:09,000
所以我可能没有办法用

1625
00:51:09,000 --> 00:51:11,000
并行的手段去做它

1626
00:51:11,000 --> 00:51:11,000
对吧

1627
00:51:11,000 --> 00:51:12,000
对没错

1628
00:51:12,000 --> 00:51:14,000
但如果我可以

1629
00:51:14,000 --> 00:51:15,000
你有女朋友

1630
00:51:15,000 --> 00:51:16,000
拉着我女朋友

1631
00:51:16,000 --> 00:51:16,000
对

1632
00:51:16,000 --> 00:51:18,000
首先我得有一个女朋友

1633
00:51:18,000 --> 00:51:19,000
首先你得有

1634
00:51:19,000 --> 00:51:22,000
幸好我已经有了一个女朋友

1635
00:51:22,000 --> 00:51:23,000
我可以拉着她说

1636
00:51:23,000 --> 00:51:24,000
好我去买菜

1637
00:51:24,000 --> 00:51:25,000
你把锅也要洗了

1638
00:51:26,000 --> 00:51:26,000
对吧

1639
00:51:26,000 --> 00:51:29,000
此时我就可以说我在做并行

1640
00:51:29,000 --> 00:51:32,000
因为我在同一时间

1641
00:51:32,000 --> 00:51:33,000
同时做很多事情

1642
00:51:34,000 --> 00:51:36,000
此时就是 parallel

1643
00:51:37,000 --> 00:51:38,000
我不知道这样是不是不适合

1644
00:51:38,000 --> 00:51:41,000
所以从一个开阔的说法来讲

1645
00:51:41,000 --> 00:51:43,000
就是说并发 concurrency

1646
00:51:43,000 --> 00:51:46,000
是一个组织事物的概念

1647
00:51:46,000 --> 00:51:48,000
就是说你可以把事物独立出来

1648
00:51:48,000 --> 00:51:51,000
它互相之间是没有因果关系

1649
00:51:51,000 --> 00:51:52,000
或者是依赖关系的

1650
00:51:52,000 --> 00:51:54,000
它可以被并发执行

1651
00:51:54,000 --> 00:51:56,000
但你实际做的时候

1652
00:51:56,000 --> 00:51:59,000
你是不是真的同时在做几件

1653
00:51:59,000 --> 00:52:00,000
互相可以并发的事情

1654
00:52:00,000 --> 00:52:01,000
则不一定

1655
00:52:01,000 --> 00:52:03,000
就好像刚才你说做饭的例子

1656
00:52:03,000 --> 00:52:05,000
你有很多并发的任务

1657
00:52:05,000 --> 00:52:07,000
比如说洗碗是一个

1658
00:52:07,000 --> 00:52:08,000
切菜可能是一个

1659
00:52:09,000 --> 00:52:11,000
然后洗锅可能又是一个

1660
00:52:11,000 --> 00:52:13,000
但是因为你就一个人

1661
00:52:13,000 --> 00:52:15,000
你还并没有把这些并发的任务

1662
00:52:15,000 --> 00:52:16,000
并行执行

1663
00:52:16,000 --> 00:52:17,000
也就是说你在面对一个

1664
00:52:17,000 --> 00:52:19,000
concurrency 的问题的时候

1665
00:52:19,000 --> 00:52:21,000
你可能没有办法

1666
00:52:21,000 --> 00:52:23,000
用 parallel 的方式去解决它

1667
00:52:24,000 --> 00:52:27,000
而你用 parallel 的方式去解决问题

1668
00:52:27,000 --> 00:52:30,000
也有可能根本不是 concurrency 的问题

1669
00:52:30,000 --> 00:52:32,000
但是当时后者这样的例子

1670
00:52:32,000 --> 00:52:34,000
可能比较难以解出来

1671
00:52:35,000 --> 00:52:36,000
我刚才就在想说

1672
00:52:36,000 --> 00:52:38,000
我们刚才讲了说

1673
00:52:39,000 --> 00:52:41,000
是不是说并行

1674
00:52:41,000 --> 00:52:44,000
就是 parallel 的前提是并发吗

1675
00:52:44,000 --> 00:52:44,000
你说不是

1676
00:52:44,000 --> 00:52:46,000
那有什么反例吗

1677
00:52:50,000 --> 00:52:50,000
比如说

1678
00:52:52,000 --> 00:52:54,000
我要在 5 个抽屉里面

1679
00:52:54,000 --> 00:52:57,000
我有 5 个抽屉里面装满了维修词

1680
00:52:57,000 --> 00:53:00,000
其中 5 个抽屉里面有 1 万个维修词

1681
00:53:00,000 --> 00:53:01,000
只有一个是黑的

1682
00:53:01,000 --> 00:53:02,000
其他都是白的

1683
00:53:02,000 --> 00:53:05,000
我要把黑的维修词找出来

1684
00:53:07,000 --> 00:53:08,000
你说这是 concurrency 的问题吗

1685
00:53:08,000 --> 00:53:09,000
其实不是

1686
00:53:11,000 --> 00:53:14,000
这件事情本身没有任何 concurrency 在里面

1687
00:53:14,000 --> 00:53:15,000
不是吧

1688
00:53:15,000 --> 00:53:18,000
我只需要找到黑维修词是我唯一的目的

1689
00:53:22,000 --> 00:53:24,000
我觉得可能有看你的什么定

1690
00:53:24,000 --> 00:53:25,000
叫什么

1691
00:53:25,000 --> 00:53:27,000
你的 task 的话定是怎么样子的

1692
00:53:27,000 --> 00:53:28,000
如果你划定 task 是

1693
00:53:29,000 --> 00:53:30,000
我有 5 个 task

1694
00:53:30,000 --> 00:53:32,000
就分别在每一个抽屉里面

1695
00:53:32,000 --> 00:53:34,000
找一个黑色的维修词对吧

1696
00:53:35,000 --> 00:53:37,000
这个时候它又是一个并发的概念

1697
00:53:37,000 --> 00:53:38,000
所以我觉得

1698
00:53:39,000 --> 00:53:41,000
可能大致上可以这么认为

1699
00:53:41,000 --> 00:53:45,000
就是说并发是并行的先决条件

1700
00:53:45,000 --> 00:53:48,000
但并行并不是并发的必然结果

1701
00:53:49,000 --> 00:53:50,000
可以这么说

1702
00:53:50,000 --> 00:53:50,000
好吧

1703
00:53:50,000 --> 00:53:52,000
或者说如果你可以把问题

1704
00:53:52,000 --> 00:53:55,000
转化为一个能够并发的问题

1705
00:53:56,000 --> 00:53:58,000
你基本上就可以用并行的方式去解决它

1706
00:54:00,000 --> 00:54:03,000
如果你有很多的 resource

1707
00:54:03,000 --> 00:54:05,000
就资源去并发去做

1708
00:54:06,000 --> 00:54:08,000
刚才在你做饭的例子里面

1709
00:54:08,000 --> 00:54:10,000
这个资源就是说你得有两个人

1710
00:54:10,000 --> 00:54:11,000
或者是三个人

1711
00:54:11,000 --> 00:54:12,000
或者四个人

1712
00:54:12,000 --> 00:54:14,000
但在电脑的处理器

1713
00:54:14,000 --> 00:54:15,000
你得有多个处理器

1714
00:54:15,000 --> 00:54:18,000
就多核或者是多个 CPU

1715
00:54:18,000 --> 00:54:21,000
或者说更扯上一点就是多个逻辑单元

1716
00:54:21,000 --> 00:54:24,000
你可能可以去

1717
00:54:26,000 --> 00:54:28,000
比如说早期的计算机

1718
00:54:28,000 --> 00:54:30,000
可能的确是不具备并发

1719
00:54:30,000 --> 00:54:31,000
就是单核处理器

1720
00:54:32,000 --> 00:54:33,000
甚至不是

1721
00:54:33,000 --> 00:54:36,000
先不说单核处理器这件事情

1722
00:54:36,000 --> 00:54:38,000
就是你在单核处理器上可以用

1723
00:54:38,000 --> 00:54:43,000
可以在操作系统层面去模拟

1724
00:54:43,000 --> 00:54:44,000
parallel 就这么

1725
00:54:44,000 --> 00:54:47,000
但是在真正的早期的计算机里面

1726
00:54:47,000 --> 00:54:53,000
就连这种操作系统层面的并行都是不存在的

1727
00:54:55,000 --> 00:54:55,000
并发

1728
00:54:57,000 --> 00:54:59,000
操作系统层面的并行是不存在

1729
00:54:59,000 --> 00:55:01,000
我觉得我想说的就是

1730
00:55:01,000 --> 00:55:02,000
比如说那个时候

1731
00:55:03,000 --> 00:55:06,000
并发肯定是存在的

1732
00:55:06,000 --> 00:55:08,000
比如说你一方面要读软盘

1733
00:55:08,000 --> 00:55:10,000
另一方面要刷新屏幕上的字符

1734
00:55:10,000 --> 00:55:12,000
这个时候你已经有那个了吗

1735
00:55:12,000 --> 00:55:13,000
有那个叫什么

1736
00:55:14,000 --> 00:55:15,000
有多任务了吗

1737
00:55:16,000 --> 00:55:16,000
没有多任务

1738
00:55:16,000 --> 00:55:18,000
我的意思就是在很早很早的时代

1739
00:55:18,000 --> 00:55:19,000
没有多任务的时代

1740
00:55:19,000 --> 00:55:21,000
当你在读软盘的时候

1741
00:55:21,000 --> 00:55:23,000
你的屏幕就是卡死了

1742
00:55:25,000 --> 00:55:28,000
那个时候计算机是没有办法用任何

1743
00:55:28,000 --> 00:55:30,000
不管是真实的也

1744
00:55:30,000 --> 00:55:33,000
还是虚假的并行手段去解决这些并发的问题

1745
00:55:35,000 --> 00:55:38,000
然后后来我们就有了这种所谓的

1746
00:55:39,000 --> 00:55:40,000
多任务机制

1747
00:55:40,000 --> 00:55:42,000
哪怕是在单一执行

1748
00:55:42,000 --> 00:55:44,000
单一逻辑核的处理计算机上

1749
00:55:44,000 --> 00:55:48,000
我们也可以假装我们是在同时执行很多事情

1750
00:55:48,000 --> 00:55:51,000
比如说最早实现什么

1751
00:55:51,000 --> 00:55:54,000
民用的话应该是 Windows 32 还是 95

1752
00:55:54,000 --> 00:55:54,000
32

1753
00:55:56,000 --> 00:55:57,000
你要是说最早的话

1754
00:55:57,000 --> 00:55:59,000
在 UNIX 下面很早就有

1755
00:55:59,000 --> 00:56:02,000
就大规模使用的情况下

1756
00:56:02,000 --> 00:56:03,000
就是不可能用到

1757
00:56:03,000 --> 00:56:04,000
应该是 95 吧

1758
00:56:04,000 --> 00:56:04,000
我觉得

1759
00:56:07,000 --> 00:56:07,000
9532

1760
00:56:08,000 --> 00:56:10,000
95 不是强调是多任务

1761
00:56:10,000 --> 00:56:12,000
所以 32 已经有多任务了

1762
00:56:12,000 --> 00:56:13,000
32 已经有多任务

1763
00:56:13,000 --> 00:56:14,000
就是那个时候就已经有多任务

1764
00:56:14,000 --> 00:56:17,000
就是可以在你在实现

1765
00:56:17,000 --> 00:56:19,000
你在放一首歌的时候

1766
00:56:19,000 --> 00:56:21,000
同时打开一个图片

1767
00:56:21,000 --> 00:56:22,000
比如说可以做这么一件事情

1768
00:56:23,000 --> 00:56:25,000
你 DOS 时代是不能这样的吗

1769
00:56:26,000 --> 00:56:29,000
但是等等 Windows 32

1770
00:56:29,000 --> 00:56:31,000
可能这个术语需要解释一下

1771
00:56:31,000 --> 00:56:34,000
就是我们说的 32 其实指 Windows 3.0

1772
00:56:34,000 --> 00:56:38,000
因为 Windows 3.2 其实是只有中国地区才有

1773
00:56:38,000 --> 00:56:40,000
Windows 3.2 就是 Windows 3.1

1774
00:56:40,000 --> 00:56:43,000
对 Windows 3.2 其实就是一个 Windows 3.1 的简体中文版

1775
00:56:43,000 --> 00:56:45,000
这样不知道

1776
00:56:45,000 --> 00:56:45,000
对

1777
00:56:45,000 --> 00:56:47,000
所以我们经常说 Windows 3.2

1778
00:56:47,000 --> 00:56:51,000
但其实这个概念仅限于中文圈里面

1779
00:56:52,000 --> 00:56:53,000
Windows 3 我们都有多称

1780
00:56:53,000 --> 00:56:54,000
对

1781
00:56:54,000 --> 00:56:58,000
Windows 3 是一个比较好的特别术语

1782
00:56:58,000 --> 00:56:58,000
对

1783
00:56:59,000 --> 00:57:00,000
然后后来就有了这个多任务

1784
00:57:00,000 --> 00:57:01,000
就可以实现刚才那个过程

1785
00:57:01,000 --> 00:57:04,000
但是处理器还是一次只做一件事

1786
00:57:04,000 --> 00:57:06,000
就是他放一会这个歌

1787
00:57:06,000 --> 00:57:09,000
还有把处理器的核心切到去画一会图

1788
00:57:09,000 --> 00:57:11,000
然后再切回来放一会歌

1789
00:57:11,000 --> 00:57:13,000
然后再切回来画一会图

1790
00:57:13,000 --> 00:57:14,000
他只要切得够快

1791
00:57:14,000 --> 00:57:18,000
给人的错觉是说他同时在做两件事

1792
00:57:18,000 --> 00:57:22,000
就是他在并行的执行两件并发的任务

1793
00:57:22,000 --> 00:57:24,000
但其实他只是一个单

1794
00:57:24,000 --> 00:57:25,000
他并不是并行的

1795
00:57:25,000 --> 00:57:27,000
他只是一个不太不同气化的东西

1796
00:57:27,000 --> 00:57:28,000
他就像闪电侠一样

1797
00:57:28,000 --> 00:57:30,000
可以自己跟自己打乒乓球

1798
00:57:30,000 --> 00:57:31,000
对

1799
00:57:31,000 --> 00:57:33,000
他只是切换得非常快

1800
00:57:33,000 --> 00:57:35,000
对这个是很好的比

1801
00:57:35,000 --> 00:57:37,000
然后真正到了要有 Pylo

1802
00:57:37,000 --> 00:57:39,000
就是有并发的感觉还是有这个

1803
00:57:39,000 --> 00:57:41,000
就当时有单核处理器

1804
00:57:41,000 --> 00:57:42,000
有多线程的时候

1805
00:57:42,000 --> 00:57:43,000
就是 Hyper Threading 的时候

1806
00:57:43,000 --> 00:57:44,000
就是一个处理器核心

1807
00:57:44,000 --> 00:57:47,000
它模拟成两个逻辑核在用

1808
00:57:47,000 --> 00:57:49,000
还有包括到我们现在的真正的

1809
00:57:49,000 --> 00:57:51,000
多个物理核的情况下

1810
00:57:51,000 --> 00:57:53,000
甚至在一些工作站

1811
00:57:53,000 --> 00:57:55,000
或者是服务器上所谓的那种多 CPU

1812
00:57:55,000 --> 00:57:58,000
就是不只有一个 CPU 的芯片

1813
00:57:58,000 --> 00:58:00,000
还有可能两个或者四个这样

1814
00:58:00,000 --> 00:58:01,000
对

1815
00:58:01,000 --> 00:58:03,000
这样只有到这时候才

1816
00:58:03,000 --> 00:58:06,000
我们才说真正的 PyloLinux

1817
00:58:06,000 --> 00:58:07,000
对

1818
00:58:07,000 --> 00:58:08,000
已经实现了

1819
00:58:08,000 --> 00:58:09,000
对

1820
00:58:09,000 --> 00:58:12,000
不过其实并行在

1821
00:58:12,000 --> 00:58:14,000
在我们讲 CPU 的时候

1822
00:58:14,000 --> 00:58:16,000
是可能比较晚近才出现

1823
00:58:16,000 --> 00:58:19,000
但是他在讲 GPU

1824
00:58:19,000 --> 00:58:20,000
就图形中的机器的时候

1825
00:58:20,000 --> 00:58:21,000
它确实一直存在的

1826
00:58:21,000 --> 00:58:22,000
因为我们知道

1827
00:58:22,000 --> 00:58:24,000
这个 GPU 的

1828
00:58:24,000 --> 00:58:26,000
它是一个大规模并行化的

1829
00:58:26,000 --> 00:58:27,000
这种一种结构

1830
00:58:27,000 --> 00:58:29,000
就是因为图像处理这件事情

1831
00:58:29,000 --> 00:58:33,000
它与生俱来就存在着这么一个

1832
00:58:33,000 --> 00:58:37,000
可以被并行执行的问题

1833
00:58:37,000 --> 00:58:40,000
就是你需要大规模的改变

1834
00:58:40,000 --> 00:58:42,000
一张图上的每一个点

1835
00:58:42,000 --> 00:58:46,000
那这就有点像你需要

1836
00:58:46,000 --> 00:58:49,000
同时给两万个抽屉

1837
00:58:49,000 --> 00:58:50,000
在两万抽屉里面找

1838
00:58:50,000 --> 00:58:52,000
有没有黑白黑紫这样

1839
00:58:52,000 --> 00:58:56,000
所以这件事情是可以天生的被

1840
00:58:56,000 --> 00:58:57,000
批量的

1841
00:58:57,000 --> 00:58:59,000
以流水线的方式并行处理的

1842
00:58:59,000 --> 00:59:01,000
所以也就是因为

1843
00:59:01,000 --> 00:59:03,000
这种问题的特别性

1844
00:59:03,000 --> 00:59:06,000
所以才会有 GPU 这种东西出现

1845
00:59:06,000 --> 00:59:08,000
而且就是 GPU 如果你能

1846
00:59:08,000 --> 00:59:11,000
你的问题可以被简化为

1847
00:59:11,000 --> 00:59:13,000
或者不叫复杂化为

1848
00:59:13,000 --> 00:59:15,000
GPU 的那种适合模型的话

1849
00:59:15,000 --> 00:59:16,000
你能获得到所谓的

1850
00:59:16,000 --> 00:59:17,000
tunetool 能力

1851
00:59:17,000 --> 00:59:18,000
就是 throughput

1852
00:59:18,000 --> 00:59:20,000
是非常惊人的

1853
00:59:20,000 --> 00:59:21,000
没错

1854
00:59:21,000 --> 00:59:22,000
而反过来讲

1855
00:59:22,000 --> 00:59:24,000
这也就是为什么很多跟 GP

1856
00:59:24,000 --> 00:59:26,000
跟图像处理

1857
00:59:26,000 --> 00:59:27,000
其实没有任何联系的事情

1858
00:59:27,000 --> 00:59:28,000
可以交由 GPU 来做

1859
00:59:28,000 --> 00:59:30,000
比如说

1860
00:59:30,000 --> 00:59:32,000
Bitcoin mining

1861
00:59:32,000 --> 00:59:33,000
还有 GPU 来做

1862
00:59:33,000 --> 00:59:36,000
就是因为它其实也是一个可以

1863
00:59:36,000 --> 00:59:40,000
天生的被很好的并行处理的任务

1864
00:59:41,000 --> 00:59:42,000
对于这一类问题

1865
00:59:42,000 --> 00:59:45,000
我们一般有一个所谓的一个名称

1866
00:59:45,000 --> 00:59:47,000
专有名称说这种叫做

1867
00:59:47,000 --> 00:59:50,000
embarrassedly paralyzable task

1868
00:59:50,000 --> 00:59:51,000
对对对

1869
00:59:51,000 --> 00:59:52,000
非常尴尬的

1870
00:59:52,000 --> 00:59:55,000
可以被并行化执行的问题

1871
00:59:55,000 --> 00:59:55,000
没错

1872
00:59:55,000 --> 00:59:56,000
这就好像

1873
00:59:58,000 --> 01:00:00,000
罚你小学的时候

1874
01:00:00,000 --> 01:00:03,000
罚你把某一句话抄几百遍

1875
01:00:04,000 --> 01:00:05,000
大家会用五支笔

1876
01:00:06,000 --> 01:00:08,000
五支笔可能非常惊人的

1877
01:00:08,000 --> 01:00:10,000
非常了不起的小伙伴

1878
01:00:10,000 --> 01:00:11,000
固定在一起

1879
01:00:11,000 --> 01:00:13,000
一般人用三支笔

1880
01:00:13,000 --> 01:00:15,000
同时抄客文是可以做到

1881
01:00:15,000 --> 01:00:16,000
把一个字写两千遍

1882
01:00:16,000 --> 01:00:19,000
这就是一个非常 embarrassingly

1883
01:00:20,000 --> 01:00:22,000
parallelizable task

1884
01:00:24,000 --> 01:00:25,000
其实这是一个很好的例子

1885
01:00:25,000 --> 01:00:28,000
就是把某一字抄几千遍

1886
01:00:28,000 --> 01:00:31,000
其实就是一个

1887
01:00:32,000 --> 01:00:33,000
并不是非常 concurrency

1888
01:00:33,000 --> 01:00:36,000
但是可以被 parallel 执行的任务

1889
01:00:37,000 --> 01:00:39,000
所以有一件事情是可以确定的

1890
01:00:39,000 --> 01:00:41,000
就是现代的编程世界是

1891
01:00:41,000 --> 01:00:43,000
离开了并发模型

1892
01:00:43,000 --> 01:00:44,000
基本上是

1893
01:00:44,000 --> 01:00:47,000
或者说并行处理能力是没有办法

1894
01:00:48,000 --> 01:00:50,000
没有办法继续下去的可以这么说

1895
01:00:50,000 --> 01:00:51,000
就是比较传统的所谓

1896
01:00:51,000 --> 01:00:53,000
secretion programming model 是

1897
01:00:54,000 --> 01:00:57,000
在现代的编程领域

1898
01:00:57,000 --> 01:00:58,000
所要处理的问题面前

1899
01:00:58,000 --> 01:01:00,000
是毫无还击之力的

1900
01:01:00,000 --> 01:01:02,000
所以我们无论如何是需要

1901
01:01:03,000 --> 01:01:04,000
parallelism

1902
01:01:05,000 --> 01:01:06,000
问题就来了

1903
01:01:06,000 --> 01:01:08,000
parallelism 其实是一个

1904
01:01:10,000 --> 01:01:10,000
怎么说呢

1905
01:01:10,000 --> 01:01:12,000
描述起来比较简单的概念

1906
01:01:12,000 --> 01:01:14,000
或者当你理解来

1907
01:01:14,000 --> 01:01:14,000
做起来很复杂

1908
01:01:14,000 --> 01:01:16,000
但做起来人们

1909
01:01:16,000 --> 01:01:17,000
不同的人有不同的

1910
01:01:17,000 --> 01:01:20,000
意见的这么一个一件事情

1911
01:01:21,000 --> 01:01:25,000
最最简单的一种并发模型

1912
01:01:25,000 --> 01:01:26,000
或者说并行模型

1913
01:01:27,000 --> 01:01:28,000
我觉得接下来节目我们还是

1914
01:01:28,000 --> 01:01:30,000
混用并发和并行这个词

1915
01:01:30,000 --> 01:01:31,000
不然实在是太累了

1916
01:01:33,000 --> 01:01:33,000
你说呢

1917
01:01:33,000 --> 01:01:35,000
就是在不区分

1918
01:01:36,000 --> 01:01:39,000
不严格区分并发并行的场合的情况下

1919
01:01:39,000 --> 01:01:41,000
这两者有时候又是在混用的

1920
01:01:42,000 --> 01:01:42,000
对没错

1921
01:01:44,000 --> 01:01:44,000
对

1922
01:01:44,000 --> 01:01:45,000
所以接下来的

1923
01:01:46,000 --> 01:01:48,000
这接下来当我说到并发模型的时候

1924
01:01:48,000 --> 01:01:51,000
其实我的意思有可能是并行模型

1925
01:01:52,000 --> 01:01:54,000
但我说并行模型的时候

1926
01:01:54,000 --> 01:01:55,000
一般肯定是在讲并行模型

1927
01:01:57,000 --> 01:01:57,000
对

1928
01:01:57,000 --> 01:01:58,000
所以

1929
01:01:59,000 --> 01:02:01,000
最基本的一种并行模型是什么呢

1930
01:02:02,000 --> 01:02:03,000
我觉得是 thread

1931
01:02:04,000 --> 01:02:05,000
就是线程

1932
01:02:05,000 --> 01:02:06,000
或者说

1933
01:02:06,000 --> 01:02:10,000
应该说最基本的一种并行模型

1934
01:02:10,000 --> 01:02:12,000
应该是多进程

1935
01:02:12,000 --> 01:02:14,000
multiprocess

1936
01:02:14,000 --> 01:02:15,000
如果真的要

1937
01:02:16,000 --> 01:02:17,000
追根朔源的话

1938
01:02:17,000 --> 01:02:19,000
那应该可能还是

1939
01:02:19,000 --> 01:02:22,000
多进程先于多线程出现对吧

1940
01:02:22,000 --> 01:02:23,000
没错

1941
01:02:23,000 --> 01:02:25,000
因为起码在

1942
01:02:25,000 --> 01:02:26,000
我记得 Linux

1943
01:02:26,000 --> 01:02:29,000
是非常晚进才出现多线程

1944
01:02:29,000 --> 01:02:31,000
最开始都一直是多进程的模型

1945
01:02:31,000 --> 01:02:31,000
对

1946
01:02:31,000 --> 01:02:32,000
因为在 Linux 上面

1947
01:02:32,000 --> 01:02:35,000
开一个进程的方法

1948
01:02:35,000 --> 01:02:36,000
要开一个进程

1949
01:02:36,000 --> 01:02:37,000
要比开一个线程简单很多

1950
01:02:38,000 --> 01:02:38,000
对

1951
01:02:38,000 --> 01:02:40,000
而且开销也不是特别大

1952
01:02:40,000 --> 01:02:43,000
就是它的多一个进程的开销是相对小的

1953
01:02:44,000 --> 01:02:44,000
对

1954
01:02:44,000 --> 01:02:46,000
具体技术细节我们就不解释了

1955
01:02:46,000 --> 01:02:47,000
但是

1956
01:02:49,000 --> 01:02:51,000
其最根本的想法就是

1957
01:02:51,000 --> 01:02:53,000
在一个编程语言里面

1958
01:02:53,000 --> 01:02:55,000
如果我们要利用多进程

1959
01:02:55,000 --> 01:02:56,000
或者是多线程的话

1960
01:02:56,000 --> 01:02:56,000
好

1961
01:02:56,000 --> 01:02:58,000
那我就显示的写出来

1962
01:02:59,000 --> 01:03:00,000
这里请开一个新的进程

1963
01:03:00,000 --> 01:03:02,000
或者利用 Fork 或者怎么样

1964
01:03:02,000 --> 01:03:03,000
然后或者说

1965
01:03:03,000 --> 01:03:06,000
在这里请开一个新的线程

1966
01:03:07,000 --> 01:03:08,000
用 thread

1967
01:03:11,000 --> 01:03:13,000
然后这就是非常

1968
01:03:13,000 --> 01:03:15,000
简单

1969
01:03:15,000 --> 01:03:16,000
直接

1970
01:03:16,000 --> 01:03:17,000
至少对硬件来说

1971
01:03:17,000 --> 01:03:19,000
非常简单直接的一种

1972
01:03:19,000 --> 01:03:21,000
并行开发的模型

1973
01:03:23,000 --> 01:03:25,000
但是这种并行开发的模型有一个问题

1974
01:03:25,000 --> 01:03:27,000
就是对于程序来说比较挑战

1975
01:03:27,000 --> 01:03:28,000
因为

1976
01:03:29,000 --> 01:03:32,000
受限于我们只有一个大脑的限制

1977
01:03:32,000 --> 01:03:35,000
或者说我们的思维天生就是一个

1978
01:03:35,000 --> 01:03:36,000
线性的思维

1979
01:03:36,000 --> 01:03:38,000
一个单线程的

1980
01:03:38,000 --> 01:03:39,000
一个单进程的思维

1981
01:03:39,000 --> 01:03:40,000
所以

1982
01:03:41,000 --> 01:03:43,000
在理解多进程的时候

1983
01:03:45,000 --> 01:03:45,000
会有一个

1984
01:03:46,000 --> 01:03:47,000
会有个卡

1985
01:03:47,000 --> 01:03:48,000
我不知道你怎么样

1986
01:03:48,000 --> 01:03:51,000
但是当我写出人生第一个

1987
01:03:51,000 --> 01:03:52,000
多进程的程序的时候

1988
01:03:52,000 --> 01:03:53,000
我是

1989
01:03:54,000 --> 01:03:55,000
我是愣了很久的

1990
01:03:55,000 --> 01:03:56,000
就是

1991
01:03:56,000 --> 01:03:57,000
我需要

1992
01:03:57,000 --> 01:04:00,000
我需要去拥有那种精神分裂的能力

1993
01:04:00,000 --> 01:04:01,000
就是在这个地方

1994
01:04:01,000 --> 01:04:02,000
我需要判断说

1995
01:04:02,000 --> 01:04:03,000
我的 PID 是 0

1996
01:04:04,000 --> 01:04:06,000
那我是一个新的进程

1997
01:04:07,000 --> 01:04:08,000
那

1998
01:04:09,000 --> 01:04:11,000
那接下来我所要做这件事情

1999
01:04:11,000 --> 01:04:11,000
然后

2000
01:04:11,000 --> 01:04:14,000
另外一些事情则要在我的复进程里面进行

2001
01:04:14,000 --> 01:04:16,000
然后这个时候我就会有一种

2002
01:04:16,000 --> 01:04:17,000
会有一种

2003
01:04:17,000 --> 01:04:18,000
会有一种

2004
01:04:19,000 --> 01:04:20,000
兢充的感觉

2005
01:04:20,000 --> 01:04:20,000
对

2006
01:04:20,000 --> 01:04:21,000
会有一种非常兢充的感觉

2007
01:04:21,000 --> 01:04:23,000
就会觉得说

2008
01:04:23,000 --> 01:04:23,000
好吧

2009
01:04:23,000 --> 01:04:24,000
那

2010
01:04:25,000 --> 01:04:27,000
计算机

2011
01:04:27,000 --> 01:04:28,000
解释这一切的时候

2012
01:04:28,000 --> 01:04:30,000
可能会比较方便

2013
01:04:30,000 --> 01:04:31,000
但是

2014
01:04:31,000 --> 01:04:32,000
我就会不停地去想说

2015
01:04:32,000 --> 01:04:34,000
那我现在是在复进程里

2016
01:04:34,000 --> 01:04:35,000
还是在紫禁程里呢

2017
01:04:35,000 --> 01:04:37,000
那我做完这件事情

2018
01:04:37,000 --> 01:04:38,000
我要回到复进程里面

2019
01:04:38,000 --> 01:04:40,000
那复进程里面要做收尾工作

2020
01:04:40,000 --> 01:04:42,000
可是万一紫禁程没有

2021
01:04:42,000 --> 01:04:44,000
及时地完成这件事情

2022
01:04:44,000 --> 01:04:45,000
复进程要等它吗

2023
01:04:45,000 --> 01:04:46,000
就是

2024
01:04:47,000 --> 01:04:48,000
在

2025
01:04:48,000 --> 01:04:50,000
我记得在

2026
01:04:51,000 --> 01:04:52,000
学操作系统还是什么的时候

2027
01:04:52,000 --> 01:04:55,000
有很大一个篇幅都是在讲

2028
01:04:55,000 --> 01:04:56,000
多进程

2029
01:04:56,000 --> 01:04:58,000
或者多线程的实现原理的

2030
01:04:58,000 --> 01:05:00,000
就比如说什么

2031
01:05:00,000 --> 01:05:03,000
很多很经典的数学问题

2032
01:05:03,000 --> 01:05:05,000
数学模型也是在这个领域被提出来的

2033
01:05:05,000 --> 01:05:06,000
比如说什么

2034
01:05:06,000 --> 01:05:06,000
我忘了

2035
01:05:06,000 --> 01:05:07,000
哲学家吃饭问题

2036
01:05:07,000 --> 01:05:08,000
就是什么

2037
01:05:08,000 --> 01:05:09,000
一个哲学家

2038
01:05:09,000 --> 01:05:11,000
左边是刀右边是叉

2039
01:05:11,000 --> 01:05:12,000
对

2040
01:05:12,000 --> 01:05:13,000
大学家是哲学家

2041
01:05:13,000 --> 01:05:14,000
没错

2042
01:05:16,000 --> 01:05:16,000
等等

2043
01:05:16,000 --> 01:05:18,000
而且我觉得我印象里面

2044
01:05:18,000 --> 01:05:18,000
没记错的话

2045
01:05:18,000 --> 01:05:19,000
这本书的

2046
01:05:20,000 --> 01:05:21,000
英文版里面

2047
01:05:21,000 --> 01:05:24,000
哲学家是左手刀右手叉

2048
01:05:24,000 --> 01:05:25,000
然后到中文版里面

2049
01:05:25,000 --> 01:05:28,000
变成了哲学家左右各有一支筷子

2050
01:05:28,000 --> 01:05:28,000
只有

2051
01:05:30,000 --> 01:05:31,000
就连这个地方有本地话也讲

2052
01:05:31,000 --> 01:05:34,000
你必须拿到两支筷子才可以进叉

2053
01:05:36,000 --> 01:05:37,000
我记得那个时候特别可笑

2054
01:05:38,000 --> 01:05:40,000
当时课堂上有个同学讲了一个笑话

2055
01:05:40,000 --> 01:05:41,000
就说

2056
01:05:41,000 --> 01:05:43,000
他们为什么不都换成长勺子

2057
01:05:43,000 --> 01:05:45,000
然后互相喂饭吃

2058
01:05:45,000 --> 01:05:46,000
这就跟

2059
01:05:47,000 --> 01:05:48,000
这就跟另外一个

2060
01:05:49,000 --> 01:05:52,000
也是哲学上的一个笑话联系起来

2061
01:05:52,000 --> 01:05:53,000
就是说哲学上说

2062
01:05:54,000 --> 01:05:58,000
有一堆人围坐在一口锅前面

2063
01:05:58,000 --> 01:05:58,000
要吃饭

2064
01:05:58,000 --> 01:06:00,000
但是每个人的勺子都特别长

2065
01:06:01,000 --> 01:06:02,000
没有办法把它转过来

2066
01:06:02,000 --> 01:06:03,000
喂自己

2067
01:06:04,000 --> 01:06:04,000
吃饭

2068
01:06:04,000 --> 01:06:06,000
所以每个人必须去

2069
01:06:07,000 --> 01:06:08,000
喂对方吃饭

2070
01:06:08,000 --> 01:06:09,000
所有人才不会饿死

2071
01:06:09,000 --> 01:06:12,000
然后这个故事被他在这边

2072
01:06:12,000 --> 01:06:15,000
转移到哲学家饿死的题目里面

2073
01:06:15,000 --> 01:06:16,000
我觉得当时特别有喜感

2074
01:06:21,000 --> 01:06:23,000
刚才讲你说这个并发

2075
01:06:23,000 --> 01:06:25,000
并行变成 parallel programming

2076
01:06:26,000 --> 01:06:27,000
的一个核心的问题就是

2077
01:06:27,000 --> 01:06:30,000
可能对程序学员的要求就

2078
01:06:31,000 --> 01:06:33,000
不是就数量级的提高吧

2079
01:06:33,000 --> 01:06:35,000
因为确实如你所说

2080
01:06:35,000 --> 01:06:36,000
人的思维很多人

2081
01:06:36,000 --> 01:06:37,000
它是一个单线的一个过程

2082
01:06:37,000 --> 01:06:39,000
没办法去同时考虑

2083
01:06:40,000 --> 01:06:42,000
你大脑不是一个多核的东西吗

2084
01:06:43,000 --> 01:06:43,000
那么

2085
01:06:44,000 --> 01:06:46,000
其实就可能在传统的

2086
01:06:46,000 --> 01:06:47,000
这个线性编程的情况下

2087
01:06:49,000 --> 01:06:50,000
你的思维逻辑

2088
01:06:50,000 --> 01:06:52,000
跟着程序代码走一遍

2089
01:06:52,000 --> 01:06:53,000
你也知道计算机也是这么执行的

2090
01:06:53,000 --> 01:06:56,000
并且不会有任何人干扰你中间

2091
01:06:56,000 --> 01:06:57,000
执行的步骤

2092
01:06:57,000 --> 01:06:59,000
当然可能中断那些什么除外

2093
01:07:00,000 --> 01:07:00,000
没错

2094
01:07:01,000 --> 01:07:03,000
但是在一个并行的条件下

2095
01:07:03,000 --> 01:07:05,000
这个事情就变得非常诡异了

2096
01:07:06,000 --> 01:07:07,000
如果你不考虑什么

2097
01:07:07,000 --> 01:07:08,000
锁的那些机制

2098
01:07:08,000 --> 01:07:09,000
什么同步机制的话

2099
01:07:09,000 --> 01:07:11,000
它是有无限多种可能

2100
01:07:11,000 --> 01:07:13,000
有两个

2101
01:07:13,000 --> 01:07:15,000
或者多个这种线程也好

2102
01:07:15,000 --> 01:07:15,000
进程也好

2103
01:07:15,000 --> 01:07:16,000
它可以

2104
01:07:16,000 --> 01:07:17,000
我们叫做 interleaving

2105
01:07:17,000 --> 01:07:19,000
就是互相交织

2106
01:07:19,000 --> 01:07:20,000
互相交织

2107
01:07:20,000 --> 01:07:20,000
对

2108
01:07:20,000 --> 01:07:21,000
对

2109
01:07:21,000 --> 01:07:22,000
这个时候你就很难去看

2110
01:07:22,000 --> 01:07:23,000
看明白说

2111
01:07:24,000 --> 01:07:25,000
或者说

2112
01:07:25,000 --> 01:07:27,000
你的脑袋中要装的

2113
01:07:28,000 --> 01:07:29,000
state space

2114
01:07:29,000 --> 01:07:30,000
就是你到这一步的时候

2115
01:07:30,000 --> 01:07:32,000
其他人可能会怎么样

2116
01:07:32,000 --> 01:07:32,000
这种东西

2117
01:07:32,000 --> 01:07:34,000
它就是一个指数增长的东西

2118
01:07:34,000 --> 01:07:36,000
所以这个时候对人的思维挑战

2119
01:07:36,000 --> 01:07:39,000
确实是一个极其困难的一个过程

2120
01:07:39,000 --> 01:07:40,000
而且

2121
01:07:40,000 --> 01:07:41,000
就为了解决这个问题

2122
01:07:42,000 --> 01:07:43,000
里面也有很多这种方案

2123
01:07:43,000 --> 01:07:44,000
比如说

2124
01:07:45,000 --> 01:07:46,000
可能我们听的最多的一条

2125
01:07:46,000 --> 01:07:46,000
就说

2126
01:07:47,000 --> 01:07:49,000
share the mutable state is bad

2127
01:07:49,000 --> 01:07:50,000
is evil

2128
01:07:50,000 --> 01:07:50,000
对吧

2129
01:07:50,000 --> 01:07:51,000
就是如果你是

2130
01:07:51,000 --> 01:07:54,000
你是并行编程的东西

2131
01:07:54,000 --> 01:07:56,000
然后你还有多个线程也好

2132
01:07:56,000 --> 01:07:57,000
进程也好

2133
01:07:57,000 --> 01:08:00,000
去同时访问一个可以被改写的

2134
01:08:00,000 --> 01:08:01,000
一个

2135
01:08:02,000 --> 01:08:03,000
内存区域或者是变量

2136
01:08:03,000 --> 01:08:04,000
或者文件也好

2137
01:08:04,000 --> 01:08:05,000
这个时候你就非常困难了

2138
01:08:05,000 --> 01:08:06,000
因为你没有办法

2139
01:08:07,000 --> 01:08:07,000
从

2140
01:08:08,000 --> 01:08:08,000
从那个

2141
01:08:09,000 --> 01:08:11,000
被改写的那个区域的角度来看

2142
01:08:12,000 --> 01:08:14,000
你能预测到会产生什么样的组合

2143
01:08:14,000 --> 01:08:16,000
因为这个组合是不确定性的

2144
01:08:16,000 --> 01:08:17,000
是一个叫做

2145
01:08:17,000 --> 01:08:18,000
indeterministic

2146
01:08:18,000 --> 01:08:21,000
就是不确定性的一个过程

2147
01:08:22,000 --> 01:08:22,000
没错

2148
01:08:23,000 --> 01:08:25,000
所以很多时候我们的一个解决方案

2149
01:08:25,000 --> 01:08:25,000
就是说

2150
01:08:25,000 --> 01:08:27,000
那么最好就是叫做 share the nothing

2151
01:08:27,000 --> 01:08:30,000
就是一切都不要共享的结构

2152
01:08:30,000 --> 01:08:31,000
这样的话有什么好处呢

2153
01:08:31,000 --> 01:08:32,000
这样你就可以

2154
01:08:32,000 --> 01:08:34,000
在并行的环境下

2155
01:08:34,000 --> 01:08:35,000
对于某一个

2156
01:08:35,000 --> 01:08:37,000
线程或者是进程也好

2157
01:08:37,000 --> 01:08:39,000
你不用考虑它和别的进程

2158
01:08:39,000 --> 01:08:40,000
和线程的交互怎么样

2159
01:08:40,000 --> 01:08:42,000
你只用考虑它自己本身是一个

2160
01:08:42,000 --> 01:08:43,000
线性的程序

2161
01:08:43,000 --> 01:08:44,000
走下去就好了

2162
01:08:45,000 --> 01:08:47,000
这个时候就等于说是把一个

2163
01:08:47,000 --> 01:08:48,000
并行的问题

2164
01:08:48,000 --> 01:08:50,000
变成了一个线性的

2165
01:08:50,000 --> 01:08:52,000
串型的问题来解决了

2166
01:08:52,000 --> 01:08:53,000
但实际上这种

2167
01:08:53,000 --> 01:08:55,000
这种情况是

2168
01:08:55,000 --> 01:08:57,000
不太可行的

2169
01:08:57,000 --> 01:08:59,000
就可能有一些比较极端的例子

2170
01:08:59,000 --> 01:09:01,000
是所谓这种 share the nothing 结构的

2171
01:09:01,000 --> 01:09:01,000
东西

2172
01:09:01,000 --> 01:09:03,000
比如说我们很多的网页服务器

2173
01:09:03,000 --> 01:09:04,000
它可能都是

2174
01:09:04,000 --> 01:09:06,000
比如说 APACH 就是一个很典型的例子

2175
01:09:06,000 --> 01:09:08,000
它每一个请求来

2176
01:09:08,000 --> 01:09:10,000
它可能都是开一个新的进程

2177
01:09:10,000 --> 01:09:11,000
或者开一个新的线程来

2178
01:09:11,000 --> 01:09:13,000
来响应这个请求

2179
01:09:13,000 --> 01:09:14,000
然后响应完毕这个进程

2180
01:09:14,000 --> 01:09:15,000
或者线程也就被杀掉了

2181
01:09:15,000 --> 01:09:16,000
但这个传统的模型

2182
01:09:17,000 --> 01:09:19,000
然后在响应这个请求的

2183
01:09:19,000 --> 01:09:22,000
现成或者是进程执行的过程中

2184
01:09:22,000 --> 01:09:23,000
你是不用考虑别的

2185
01:09:23,000 --> 01:09:24,000
现成和进程怎么样

2186
01:09:24,000 --> 01:09:25,000
因为你没有共享任何东西

2187
01:09:26,000 --> 01:09:28,000
但是在实际应用中

2188
01:09:28,000 --> 01:09:30,000
很多时候你确实是要共享东西的

2189
01:09:30,000 --> 01:09:30,000
比如说

2190
01:09:30,000 --> 01:09:32,000
我们现在很多做什么 web app

2191
01:09:32,000 --> 01:09:33,000
对吧

2192
01:09:33,000 --> 01:09:35,000
你是要访问一个共享的数据库的

2193
01:09:35,000 --> 01:09:37,000
你可能要访问一个

2194
01:09:38,000 --> 01:09:40,000
同一个共享的数据库

2195
01:09:40,000 --> 01:09:41,000
然后可能要改写东西

2196
01:09:41,000 --> 01:09:42,000
这个时候你又变成

2197
01:09:42,000 --> 01:09:44,000
本来是一个 share nothing 的东西

2198
01:09:44,000 --> 01:09:46,000
又变成有一个 shared mutable state

2199
01:09:46,000 --> 01:09:49,000
这样的话整个模型就又变得很复杂

2200
01:09:49,000 --> 01:09:51,000
而且难于测试起来了

2201
01:09:51,000 --> 01:09:54,000
现成加上锁这种结构

2202
01:09:54,000 --> 01:09:57,000
就好像一个到处漏水的桶

2203
01:09:57,000 --> 01:09:59,000
你总会觉得我堵住这个孔就没问题了

2204
01:09:59,000 --> 01:10:01,000
但是因为你堵住了这个孔

2205
01:10:01,000 --> 01:10:02,000
所以水压变高了

2206
01:10:02,000 --> 01:10:04,000
它会从另外一方漏出来

2207
01:10:04,000 --> 01:10:07,000
所以有时候用现成锁编程的时候

2208
01:10:07,000 --> 01:10:14,000
你会觉得自己不仅思考的层级非常低

2209
01:10:14,000 --> 01:10:20,000
就是你会被迫强迫自己像一个现成管理器这样去思考

2210
01:10:20,000 --> 01:10:22,000
而且与此同时你会发现

2211
01:10:22,000 --> 01:10:24,000
解决了一个问题

2212
01:10:24,000 --> 01:10:25,000
另外一个问题又冒出来了

2213
01:10:27,000 --> 01:10:28,000
顾此是彼吗

2214
01:10:28,000 --> 01:10:30,000
没错 顾此是彼

2215
01:10:30,000 --> 01:10:33,000
这个是为什么虽然现成

2216
01:10:33,000 --> 01:10:35,000
或者说多建成或者多建成加上锁这种机制

2217
01:10:35,000 --> 01:10:40,000
在几乎所有相应一点的程序里面都有支持

2218
01:10:41,000 --> 01:10:45,000
但是用好他们却是非常难

2219
01:10:45,000 --> 01:10:49,000
而且我觉得这种难是没有必要的一种难的事情

2220
01:10:50,000 --> 01:10:53,000
这也是一个可能不是一个太好的抽象

2221
01:10:53,000 --> 01:10:54,000
就都出了这么一个

2222
01:10:54,000 --> 01:10:57,000
对 他的抽象层级可能实在是太低了

2223
01:10:57,000 --> 01:10:57,000
就有点像

2224
01:10:57,000 --> 01:11:00,000
或者说他抽象的那个角度是错的

2225
01:11:01,000 --> 01:11:01,000
就是

2226
01:11:01,000 --> 01:11:04,000
或者说他怎么说呢

2227
01:11:04,000 --> 01:11:07,000
我觉得他抽象的角度没有错不错

2228
01:11:07,000 --> 01:11:09,000
只是因为在操作这种层面上

2229
01:11:10,000 --> 01:11:12,000
并行就是这么被实现的

2230
01:11:12,000 --> 01:11:16,000
他与其说他的抽象角度是错的

2231
01:11:16,000 --> 01:11:19,000
不如说他所抽象的东西实在是太少了

2232
01:11:19,000 --> 01:11:22,000
基本上你要从非常底层的

2233
01:11:22,000 --> 01:11:24,000
不够有用的抽象对不对

2234
01:11:24,000 --> 01:11:25,000
没错

2235
01:11:26,000 --> 01:11:33,000
这就是为什么接下来我们会提到几种其他的并行模型

2236
01:11:33,000 --> 01:11:38,000
就是他们试图从不同的角度去解决这个问题

2237
01:11:38,000 --> 01:11:40,000
但是如果没说错的话

2238
01:11:40,000 --> 01:11:46,000
很多并行模型的基本实现原理

2239
01:11:46,000 --> 01:11:48,000
还是通过现成的锁

2240
01:11:49,000 --> 01:11:51,000
就底层它是这么实现的

2241
01:11:51,000 --> 01:11:55,000
但是只是它暴露给开发者或者程序员的这么一个

2242
01:11:55,000 --> 01:11:57,000
一个接口或者是一个表象

2243
01:11:57,000 --> 01:11:59,000
你看不到那些东西

2244
01:11:59,000 --> 01:12:04,000
对 这其实是回到我们前很多期

2245
01:12:04,000 --> 01:12:08,000
这时候很长时间以前讲的封装的那么一个

2246
01:12:08,000 --> 01:12:11,000
那么一个问题领域

2247
01:12:11,000 --> 01:12:15,000
就是我们接下来介绍了几种并发模型

2248
01:12:15,000 --> 01:12:19,000
其实是对于多线程加锁的这样一种封装

2249
01:12:20,000 --> 01:12:23,000
但是这种封装当你熟悉了它之后

2250
01:12:23,000 --> 01:12:31,000
你会发现它在很大程度上增加了你思考的方便程度

2251
01:12:31,000 --> 01:12:33,000
或者说让你变得更像一个人了

2252
01:12:33,000 --> 01:12:34,000
而不像一个机器

2253
01:12:34,000 --> 01:12:37,000
不用再在头脑中模拟费劲的

2254
01:12:37,000 --> 01:12:42,000
用一个单核处理器的大脑去模拟一个多核处理器的 CPU

2255
01:12:42,000 --> 01:12:43,000
对 没错

2256
01:12:45,000 --> 01:12:51,000
你觉得除了多线程的模型之外

2257
01:12:51,000 --> 01:12:57,000
哪一种并发模型是最简单或者说最直接

2258
01:12:57,000 --> 01:13:00,000
能够让人比较方便接受

2259
01:13:03,000 --> 01:13:05,000
最好就是不要让我去想

2260
01:13:05,000 --> 01:13:08,000
去让我思考有这些底层

2261
01:13:08,000 --> 01:13:10,000
这些就是最理想的模型

2262
01:13:10,000 --> 01:13:12,000
是不要让我思考有这么一些东西存在的东西

2263
01:13:12,000 --> 01:13:16,000
那可能用从语言层面上来解决这个问题的话

2264
01:13:16,000 --> 01:13:20,000
如果你能实现我们传统意义上的 FP

2265
01:13:20,000 --> 01:13:22,000
就是函数式编程的话

2266
01:13:22,000 --> 01:13:24,000
就可能就根本不用考虑这个问题了

2267
01:13:24,000 --> 01:13:26,000
因为函数式编程

2268
01:13:26,000 --> 01:13:29,000
每一个函数就是在纯粹的一个函数式编程里面

2269
01:13:29,000 --> 01:13:31,000
所谓的函数都是所谓的确定性结果的

2270
01:13:32,000 --> 01:13:35,000
这样的话不管你怎么去执行它

2271
01:13:35,000 --> 01:13:36,000
你总是得到一个确定性的解的

2272
01:13:36,000 --> 01:13:40,000
我不管你是顺序执行并发执行还是怎么样

2273
01:13:40,000 --> 01:13:42,000
你一个什么一阵一组合我都不用管

2274
01:13:42,000 --> 01:13:44,000
我只能考虑这个函数式这么写的

2275
01:13:44,000 --> 01:13:47,000
我输这个数得到这个结果

2276
01:13:47,000 --> 01:13:47,000
那就完了

2277
01:13:47,000 --> 01:13:50,000
就根本不存在并发并行这些概念在里面

2278
01:13:50,000 --> 01:13:51,000
没错

2279
01:13:51,000 --> 01:13:58,000
我觉得可能功能计划所给我们最大的益处

2280
01:13:58,000 --> 01:14:02,000
就在于之前我们讨论的

2281
01:14:02,000 --> 01:14:05,000
现成枷锁所要解决的最基本问题

2282
01:14:05,000 --> 01:14:08,000
就是有一个改变状态

2283
01:14:08,000 --> 01:14:12,000
被 functional programming 彻底抹去了

2284
01:14:12,000 --> 01:14:17,000
就是如果一切问题的输入乃至其中间状态

2285
01:14:17,000 --> 01:14:19,000
全都是确定的话

2286
01:14:19,000 --> 01:14:23,000
那别人根本不可能改它

2287
01:14:23,000 --> 01:14:26,000
在我看来我也就不需要锁了不是吗

2288
01:14:26,000 --> 01:14:27,000
对啊

2289
01:14:27,000 --> 01:14:31,000
所以这就是为什么 functional programming 为我们提供了

2290
01:14:31,000 --> 01:14:38,000
提供了这样一种从完全的不同角度去实现并行的机制

2291
01:14:38,000 --> 01:14:40,000
会让我们思考起来更方便的原因

2292
01:14:40,000 --> 01:14:42,000
对说到一个最极端的例子

2293
01:14:42,000 --> 01:14:46,000
就是如果先不考虑实现的经济性来讲

2294
01:14:46,000 --> 01:14:48,000
就说起码从逻辑上来讲

2295
01:14:48,000 --> 01:14:51,000
如果你整个语言是一个纯粹的 functional 的

2296
01:14:51,000 --> 01:14:53,000
一个纯粹是一个函数式的过程的话

2297
01:14:53,000 --> 01:14:57,000
每一步执行都是可以被并发执行的

2298
01:14:57,000 --> 01:14:59,000
就理论上说你每一步都可以分配到

2299
01:14:59,000 --> 01:15:01,000
任意多个处理上去同时执行

2300
01:15:01,000 --> 01:15:02,000
然后得到一个解

2301
01:15:02,000 --> 01:15:05,000
然后再进行下一步的 reduction

2302
01:15:05,000 --> 01:15:06,000
然后得到一个最终的解出来

2303
01:15:07,000 --> 01:15:08,000
对

2304
01:15:09,000 --> 01:15:09,000
对

2305
01:15:09,000 --> 01:15:15,000
然后这样一种模型它所带来的便利是非常显著的

2306
01:15:15,000 --> 01:15:17,000
但是从另外一个角度讲

2307
01:15:18,000 --> 01:15:23,000
functional programming 写起来也是比较具有挑战性的

2308
01:15:23,000 --> 01:15:27,000
因为你只是或你不只是

2309
01:15:27,000 --> 01:15:32,000
但是当你没有 global changeable state 的时候

2310
01:15:32,000 --> 01:15:35,000
你就会需要用另外的方法去解决它

2311
01:15:35,000 --> 01:15:40,000
而 functional programming 可能会要求你

2312
01:15:40,000 --> 01:15:45,000
比较痛苦的去转化你的思维模型

2313
01:15:45,000 --> 01:15:50,000
那有没有一个比较好的例子可以说明为什么

2314
01:15:50,000 --> 01:15:56,000
functional programming 可以比较有效的实现并发模型

2315
01:15:59,000 --> 01:16:01,000
我觉得可能最简单就是一个计算器的例子

2316
01:16:01,000 --> 01:16:04,000
就能够可能比较容易懂吧

2317
01:16:04,000 --> 01:16:07,000
就是我们计算一个常用的四则运算的时候

2318
01:16:07,000 --> 01:16:10,000
我们比如说我举个最简单的例子

2319
01:16:10,000 --> 01:16:13,000
3 乘以 4 加 5 乘以 6

2320
01:16:13,000 --> 01:16:15,000
这个公式

2321
01:16:15,000 --> 01:16:16,000
我们如果人做会怎么样

2322
01:16:16,000 --> 01:16:20,000
那我们现在算 3 乘以 412

2323
01:16:20,000 --> 01:16:21,000
所以写在一边

2324
01:16:21,000 --> 01:16:23,000
然后再算 5 乘以 6 等于到了 30

2325
01:16:23,000 --> 01:16:24,000
也写在一边

2326
01:16:24,000 --> 01:16:25,000
然后再两个球和加起来 32

2327
01:16:25,000 --> 01:16:26,000
对吧

2328
01:16:26,000 --> 01:16:26,000
不是

2329
01:16:27,000 --> 01:16:30,000
但是如果是给机器来做的话

2330
01:16:30,000 --> 01:16:33,000
因为你整个四则运算中间的每一步

2331
01:16:33,000 --> 01:16:34,000
都是确定性结果

2332
01:16:34,000 --> 01:16:36,000
因为确定性输入的确定性结果

2333
01:16:36,000 --> 01:16:37,000
这样的话

2334
01:16:37,000 --> 01:16:39,000
它可以同时计算 3 乘以 4 和 5 乘以 6

2335
01:16:39,000 --> 01:16:41,000
或者说是它是甚至先计算 5 乘以 6

2336
01:16:41,000 --> 01:16:43,000
再计算 3 乘以 4

2337
01:16:43,000 --> 01:16:45,000
然后再把再去其他之和

2338
01:16:45,000 --> 01:16:47,000
就是在这个过程中你可以看到

2339
01:16:47,000 --> 01:16:50,000
不管你的这个计算结果

2340
01:16:50,000 --> 01:16:54,000
并不会因为你计算的顺序有任何改变

2341
01:16:54,000 --> 01:16:57,000
而导致你的结果有任何变化

2342
01:16:57,000 --> 01:16:58,000
这个时候的话

2343
01:16:58,000 --> 01:17:01,000
那机器就可以做很多很多这样的优化

2344
01:17:01,000 --> 01:17:04,000
就可以把这些能够同时并行

2345
01:17:04,000 --> 01:17:06,000
这些东西都并行起来

2346
01:17:06,000 --> 01:17:07,000
对

2347
01:17:07,000 --> 01:17:09,000
假设你的这个算式

2348
01:17:09,000 --> 01:17:12,000
没有像 3 乘 4 加 5 乘 6 这么 trivial

2349
01:17:12,000 --> 01:17:16,000
而是一个比如说 200 位的数字

2350
01:17:16,000 --> 01:17:17,000
乘以 200 位数字

2351
01:17:17,000 --> 01:17:19,000
然后这样的

2352
01:17:19,000 --> 01:17:24,000
然后要给比如说 5 600 个这样的结果球和

2353
01:17:25,000 --> 01:17:27,000
那这样的多任务

2354
01:17:27,000 --> 01:17:30,000
这样并发的模型就可以很好用

2355
01:17:30,000 --> 01:17:33,000
很好的用 functional problem 的并行模型来解决

2356
01:17:34,000 --> 01:17:38,000
甚至我觉得其实也是一个很好的 map reduce 的

2357
01:17:38,000 --> 01:17:38,000
没错

2358
01:17:39,000 --> 01:17:43,000
解决怎么说一个例子

2359
01:17:43,000 --> 01:17:45,000
如果你要像一个门外人

2360
01:17:45,000 --> 01:17:47,000
门外汉解释什么叫 map reduce

2361
01:17:47,000 --> 01:17:49,000
当然门外汉为什么要对 map reduce

2362
01:17:49,000 --> 01:17:51,000
成个兴趣是另外一个问题

2363
01:17:51,000 --> 01:17:53,000
但如果你要像一个人解释什么是 map reduce

2364
01:17:53,000 --> 01:17:54,000
你就可以说

2365
01:17:55,000 --> 01:17:55,000
让你算

2366
01:17:55,000 --> 01:17:58,000
让计算机去算 3 乘 4 加 5 乘 6

2367
01:17:59,000 --> 01:18:01,000
map 这一步就是给一个

2368
01:18:01,000 --> 01:18:03,000
给让一个计算器算 3 乘 4

2369
01:18:03,000 --> 01:18:05,000
然后让另外一个算 5 乘 6

2370
01:18:05,000 --> 01:18:09,000
而 reduce 则是把 3 乘 4 的结果和 5 乘 6 的结果加在一起

2371
01:18:09,000 --> 01:18:10,000
没错

2372
01:18:10,000 --> 01:18:11,000
没错

2373
01:18:12,000 --> 01:18:13,000
但是这个

2374
01:18:13,000 --> 01:18:15,000
就是函数式编程

2375
01:18:15,000 --> 01:18:17,000
我怎么说有这么好的特性

2376
01:18:17,000 --> 01:18:19,000
但是它问题是在什么地方呢

2377
01:18:19,000 --> 01:18:20,000
问题在于

2378
01:18:21,000 --> 01:18:23,000
现实世界的很多问题并不能

2379
01:18:24,000 --> 01:18:27,000
简单或者很方便的归结于一个函数式

2380
01:18:27,000 --> 01:18:31,000
一个就是非可变状态的一种场景来去解

2381
01:18:31,000 --> 01:18:32,000
比如说

2382
01:18:33,000 --> 01:18:35,000
最简单的一个输输出的时候

2383
01:18:35,000 --> 01:18:37,000
你就会牵涉到跟外部世界的状态的沟通了

2384
01:18:37,000 --> 01:18:38,000
这个时候

2385
01:18:38,000 --> 01:18:40,000
根据你的输入

2386
01:18:40,000 --> 01:18:42,000
和的值不一样

2387
01:18:42,000 --> 01:18:44,000
你能可能某一些计算结果

2388
01:18:44,000 --> 01:18:47,000
就是如果它是依赖于外部输出的话

2389
01:18:47,000 --> 01:18:49,000
它就并不是一个你可以在

2390
01:18:49,000 --> 01:18:51,000
单看这个程序本身可以预见的一个解

2391
01:18:51,000 --> 01:18:53,000
预见的一个解了吗

2392
01:18:53,000 --> 01:18:54,000
对

2393
01:18:54,000 --> 01:18:56,000
比如说我们最常打

2394
01:18:56,000 --> 01:18:57,000
最常练习的一种

2395
01:18:59,000 --> 01:19:03,000
编程题目就是问

2396
01:19:03,000 --> 01:19:04,000
操作者的名字

2397
01:19:04,000 --> 01:19:06,000
然后打出 Hello 操作者的名字

2398
01:19:06,000 --> 01:19:09,000
这个就是没有办法用 functional programming 写出来

2399
01:19:09,000 --> 01:19:11,000
就纯粹的 functional programming 是没有办法

2400
01:19:11,000 --> 01:19:12,000
处理这种问题的

2401
01:19:12,000 --> 01:19:14,000
因为你总有一步要问

2402
01:19:15,000 --> 01:19:16,000
操作者的名字到底是什么

2403
01:19:16,000 --> 01:19:17,000
如果

2404
01:19:18,000 --> 01:19:20,000
如果他的名字

2405
01:19:20,000 --> 01:19:22,000
就或者说在你获得他的名字之前

2406
01:19:22,000 --> 01:19:25,000
你是没有办法把输出他的名字这一步

2407
01:19:25,000 --> 01:19:28,000
和问他的名字这一步并行执行

2408
01:19:29,000 --> 01:19:32,000
还有一个 functional

2409
01:19:32,000 --> 01:19:34,000
就不能很方便的

2410
01:19:34,000 --> 01:19:36,000
就不能规则于纯粹的 functional

2411
01:19:36,000 --> 01:19:38,000
programming 的一个概念就是随机数

2412
01:19:38,000 --> 01:19:38,000
对吧

2413
01:19:39,000 --> 01:19:42,000
就是你要有一个函数的结果是

2414
01:19:42,000 --> 01:19:43,000
你每次执行它的时候

2415
01:19:43,000 --> 01:19:44,000
得到都是不确定的结果

2416
01:19:44,000 --> 01:19:46,000
这个时候它就并不是一个

2417
01:19:46,000 --> 01:19:47,000
它甚至不是一个函数

2418
01:19:47,000 --> 01:19:48,000
因为我们讲函数

2419
01:19:48,000 --> 01:19:51,000
它应该是一个确定的结果

2420
01:19:51,000 --> 01:19:52,000
就是给定输入的时候

2421
01:19:52,000 --> 01:19:54,000
你应该有确定的结果

2422
01:19:54,000 --> 01:19:56,000
但如果你的结果是摇骰子

2423
01:19:56,000 --> 01:19:58,000
那它本身就不是一个函数

2424
01:19:58,000 --> 01:20:00,000
甚至严格意义上它并不是一个函数了

2425
01:20:00,000 --> 01:20:01,000
数学概念的函数

2426
01:20:02,000 --> 01:20:02,000
没错

2427
01:20:02,000 --> 01:20:06,000
其实这也就是数学世界和统计学

2428
01:20:06,000 --> 01:20:08,000
世界的一个根本分野

2429
01:20:08,000 --> 01:20:10,000
统计学世界所研究的世界是包含

2430
01:20:10,000 --> 01:20:12,000
随机数发生源的

2431
01:20:12,000 --> 01:20:15,000
而数学世界所处理的问题

2432
01:20:15,000 --> 01:20:16,000
是没有这种东西存在

2433
01:20:17,000 --> 01:20:17,000
OK

2434
01:20:18,000 --> 01:20:18,000
对

2435
01:20:19,000 --> 01:20:20,000
对

2436
01:20:20,000 --> 01:20:22,000
那说完了 functional programming

2437
01:20:23,000 --> 01:20:24,000
解决并发模型的

2438
01:20:25,000 --> 01:20:27,000
或者 functional programming 作为并发模型

2439
01:20:28,000 --> 01:20:28,000
之后

2440
01:20:30,000 --> 01:20:32,000
我们可以说说其他的比较

2441
01:20:32,000 --> 01:20:35,000
不那么 radical 的

2442
01:20:35,000 --> 01:20:36,000
不那么

2443
01:20:36,000 --> 01:20:38,000
疯狂的主意

2444
01:20:38,000 --> 01:20:39,000
对

2445
01:20:39,000 --> 01:20:40,000
不那么彻底

2446
01:20:41,000 --> 01:20:44,000
革新人们的世界观的并发模型

2447
01:20:44,000 --> 01:20:45,000
OK

2448
01:20:45,000 --> 01:20:45,000
那

2449
01:20:46,000 --> 01:20:46,000
对

2450
01:20:46,000 --> 01:20:48,000
所以我们刚才提到的

2451
01:20:48,000 --> 01:20:50,000
Rob Pike 的那一篇

2452
01:20:50,000 --> 01:20:52,000
那一个展示

2453
01:20:52,000 --> 01:20:54,000
就是他向人们介绍 Go routine 的展示

2454
01:20:54,000 --> 01:20:55,000
所以

2455
01:20:55,000 --> 01:20:58,000
作为一个 GoLang 的传福音者

2456
01:20:58,000 --> 01:20:59,000
Ryo 你对

2457
01:20:59,000 --> 01:21:02,000
GoLang 的并发模型是怎么理解的

2458
01:21:02,000 --> 01:21:04,000
或者你可以简单的介绍一下

2459
01:21:04,000 --> 01:21:05,000
GoLang 里面是怎么解释

2460
01:21:05,000 --> 01:21:07,000
怎么解决并发问题的

2461
01:21:07,000 --> 01:21:07,000
OK

2462
01:21:07,000 --> 01:21:09,000
就 Go 里面他采用的并发模型

2463
01:21:09,000 --> 01:21:10,000
其实是一个非常古老

2464
01:21:10,000 --> 01:21:14,000
而且被学术界研究的很透彻的一种模型

2465
01:21:15,000 --> 01:21:16,000
简单来说就是叫做

2466
01:21:16,000 --> 01:21:17,000
CSP

2467
01:21:17,000 --> 01:21:19,000
就是 Communicating Sequential Processes

2468
01:21:19,000 --> 01:21:20,000
什么意思

2469
01:21:20,000 --> 01:21:21,000
就是说

2470
01:21:21,000 --> 01:21:22,000
每一个

2471
01:21:22,000 --> 01:21:23,000
他们叫 process

2472
01:21:23,000 --> 01:21:24,000
这个进程

2473
01:21:24,000 --> 01:21:26,000
当然可能包括物理上是一个

2474
01:21:26,000 --> 01:21:27,000
超新的进程也好

2475
01:21:27,000 --> 01:21:28,000
还是这个

2476
01:21:28,000 --> 01:21:30,000
现成也好

2477
01:21:30,000 --> 01:21:31,000
他这个没有关系

2478
01:21:31,000 --> 01:21:32,000
这种 process 是一个

2479
01:21:32,000 --> 01:21:33,000
逻辑的概念

2480
01:21:33,000 --> 01:21:35,000
就是它是一个线性执行的一个单元

2481
01:21:36,000 --> 01:21:37,000
然后他说什么意思呢

2482
01:21:37,000 --> 01:21:37,000
就是说

2483
01:21:38,000 --> 01:21:38,000
每一个

2484
01:21:38,000 --> 01:21:39,000
就刚刚讲的

2485
01:21:39,000 --> 01:21:40,000
每一个

2486
01:21:40,000 --> 01:21:44,000
每一个进程都是单独自己管自己的执行

2487
01:21:44,000 --> 01:21:47,000
它只是在需要跟其他进程交互的时候

2488
01:21:47,000 --> 01:21:50,000
才通过消息传递的方式

2489
01:21:50,000 --> 01:21:52,000
来做这么一件事

2490
01:21:52,000 --> 01:21:53,000
就等别人发消息给他

2491
01:21:53,000 --> 01:21:54,000
或者发消息给别人

2492
01:21:55,000 --> 01:21:57,000
然后就有一个叫做 Synchronization Point

2493
01:21:57,000 --> 01:21:58,000
在那个点之后

2494
01:21:58,000 --> 01:22:00,000
然后他完成了这一步之后

2495
01:22:00,000 --> 01:22:01,000
他又再回到自己的

2496
01:22:02,000 --> 01:22:07,000
一个比较线性的执行方式去做下去

2497
01:22:07,000 --> 01:22:09,000
这个是一个比较可能简单的解释

2498
01:22:10,000 --> 01:22:12,000
所以 Synchronize Point

2499
01:22:12,000 --> 01:22:13,000
跟锁的差别是什么

2500
01:22:15,000 --> 01:22:17,000
它本质上就是一个锁

2501
01:22:17,000 --> 01:22:18,000
只是说在逻辑的

2502
01:22:19,000 --> 01:22:20,000
就在抽象的方式

2503
01:22:20,000 --> 01:22:21,000
或者抽象的角度上

2504
01:22:21,000 --> 01:22:22,000
它是有点不太一样

2505
01:22:22,000 --> 01:22:23,000
它并不是说

2506
01:22:24,000 --> 01:22:27,000
我们两个进程要共享一个

2507
01:22:28,000 --> 01:22:28,000
资源

2508
01:22:28,000 --> 01:22:29,000
一个

2509
01:22:29,000 --> 01:22:30,000
对共享一个 State 了

2510
01:22:30,000 --> 01:22:32,000
所以我们先把它锁住

2511
01:22:32,000 --> 01:22:33,000
然后我们想

2512
01:22:34,000 --> 01:22:36,000
就是谁先到达锁点的时候先等一下

2513
01:22:36,000 --> 01:22:37,000
等另外一个人到达那个锁点

2514
01:22:37,000 --> 01:22:39,000
然后再把那个锁解开

2515
01:22:40,000 --> 01:22:41,000
再把资源改变

2516
01:22:41,000 --> 01:22:43,000
然后再把这个锁解开

2517
01:22:43,000 --> 01:22:46,000
然后被锁住的人才可以接着进行下去

2518
01:22:47,000 --> 01:22:47,000
他这样的话

2519
01:22:47,000 --> 01:22:49,000
就有你要去想

2520
01:22:49,000 --> 01:22:51,000
哪个资源是需要被锁定的

2521
01:22:51,000 --> 01:22:52,000
这就挺麻烦吗

2522
01:22:53,000 --> 01:22:54,000
然后他这个 CSP 的话

2523
01:22:54,000 --> 01:22:55,000
他就说

2524
01:22:55,000 --> 01:22:57,000
那我们不要去考虑锁的问题了

2525
01:22:57,000 --> 01:22:58,000
我们默认

2526
01:22:58,000 --> 01:23:00,000
我们要互相通讯的时候

2527
01:23:00,000 --> 01:23:01,000
就是有一个隐含的锁

2528
01:23:01,000 --> 01:23:03,000
那个锁的内容

2529
01:23:03,000 --> 01:23:05,000
就是我要传递的消息

2530
01:23:05,000 --> 01:23:06,000
对不对

2531
01:23:06,000 --> 01:23:09,000
然后对方取得了消息之后

2532
01:23:09,000 --> 01:23:10,000
那我们锁就解开了

2533
01:23:10,000 --> 01:23:11,000
那我可以继续往下走下去

2534
01:23:11,000 --> 01:23:14,000
所以它本质上是一个锁了

2535
01:23:14,000 --> 01:23:17,000
但是只是说它的抽象的层级是不一样的

2536
01:23:17,000 --> 01:23:19,000
或者抽象的出发点是不一样的

2537
01:23:19,000 --> 01:23:19,000
这样的话

2538
01:23:20,000 --> 01:23:22,000
对人们或者这个程序员来理解起来

2539
01:23:22,000 --> 01:23:24,000
它来说是更加现实一点的

2540
01:23:25,000 --> 01:23:26,000
更加现实的一个抽象

2541
01:23:27,000 --> 01:23:27,000
没错

2542
01:23:27,000 --> 01:23:30,000
其实我听过一个比喻

2543
01:23:30,000 --> 01:23:34,000
就是传统的现成与锁有点像储物箱

2544
01:23:35,000 --> 01:23:37,000
你要去买东西

2545
01:23:37,000 --> 01:23:39,000
然后你要先把自己的

2546
01:23:39,000 --> 01:23:40,000
你在进商场之前

2547
01:23:40,000 --> 01:23:42,000
需要把自己的东西锁在一个储物柜里

2548
01:23:43,000 --> 01:23:45,000
显示的锁其实就是正儿八经的锁

2549
01:23:45,000 --> 01:23:47,000
当你把一个储物箱锁起来的时候

2550
01:23:47,000 --> 01:23:48,000
别人就不能再用了

2551
01:23:49,000 --> 01:23:52,000
而这样一种 CSP 的模型

2552
01:23:52,000 --> 01:23:56,000
则是有一个专门的储物管理员

2553
01:23:56,000 --> 01:23:58,000
你只需要把你的东西给他说

2554
01:23:58,000 --> 01:23:59,000
我要把这东西存起来

2555
01:23:59,000 --> 01:24:00,000
然后我去别的地方

2556
01:24:00,000 --> 01:24:04,000
他也许在背后有另外一个储物箱

2557
01:24:04,000 --> 01:24:07,000
但是你不会去关心这个细节

2558
01:24:08,000 --> 01:24:08,000
没错

2559
01:24:08,000 --> 01:24:10,000
你不用去直接关心你的东西

2560
01:24:10,000 --> 01:24:12,000
到底锁在哪个箱子里了

2561
01:24:12,000 --> 01:24:13,000
以及你是不是和别人共享的

2562
01:24:13,000 --> 01:24:16,000
同样一个储物箱这些问题

2563
01:24:16,000 --> 01:24:18,000
你只要告诉他说我要存东西

2564
01:24:18,000 --> 01:24:18,000
然后我走了

2565
01:24:18,000 --> 01:24:20,000
然后都回来的时候我要拿东西

2566
01:24:20,000 --> 01:24:21,000
就是这么简单

2567
01:24:21,000 --> 01:24:23,000
这个比喻很好

2568
01:24:23,000 --> 01:24:24,000
就你回来拿的时候

2569
01:24:24,000 --> 01:24:25,000
你就说我要拿我之前

2570
01:24:26,000 --> 01:24:28,000
或者说你甚至不一定是你本人去拿

2571
01:24:28,000 --> 01:24:31,000
比如说你老婆帮你去拿你的包

2572
01:24:31,000 --> 01:24:32,000
但是他有什么牌

2573
01:24:33,000 --> 01:24:35,000
他就说我要拿几号的包

2574
01:24:35,000 --> 01:24:38,000
让柜台的小姐去帮你拿出来

2575
01:24:38,000 --> 01:24:39,000
然后你就等你

2576
01:24:39,000 --> 01:24:41,000
你中间并不需要去关心

2577
01:24:41,000 --> 01:24:42,000
他后面有多少个锁格

2578
01:24:42,000 --> 01:24:43,000
对吧

2579
01:24:43,000 --> 01:24:45,000
他后面的锁是一个拉锁

2580
01:24:46,000 --> 01:24:47,000
还是一个防盗保险柜

2581
01:24:47,000 --> 01:24:48,000
还是一个什么样的东西实现

2582
01:24:48,000 --> 01:24:49,000
对

2583
01:24:50,000 --> 01:24:53,000
所以这样一种编程模型也是目前比较

2584
01:24:55,000 --> 01:24:56,000
比较流行的一种模型

2585
01:24:56,000 --> 01:24:57,000
我觉得

2586
01:24:57,000 --> 01:24:59,000
就是在很多语言里面都支持他

2587
01:24:59,000 --> 01:25:00,000
就 Go

2588
01:25:00,000 --> 01:25:01,000
Go

2589
01:25:01,000 --> 01:25:03,000
而且是在语言层面上直接支持他的

2590
01:25:03,000 --> 01:25:05,000
而其他很多语言也都是通过

2591
01:25:05,000 --> 01:25:06,000
一个 Library

2592
01:25:06,000 --> 01:25:08,000
或者是其他什么机制

2593
01:25:08,000 --> 01:25:10,000
一个主要是通过 Library

2594
01:25:10,000 --> 01:25:11,000
好像只有两种可能

2595
01:25:11,000 --> 01:25:14,000
你要不在语言里面直接执行

2596
01:25:15,000 --> 01:25:16,000
要不通过一个

2597
01:25:17,000 --> 01:25:18,000
这里要介绍一下

2598
01:25:18,000 --> 01:25:21,000
就除了刚才讲的 CSP 模型之外

2599
01:25:21,000 --> 01:25:23,000
有一个与他形成

2600
01:25:23,000 --> 01:25:25,000
叫做队友关系的一个模型

2601
01:25:25,000 --> 01:25:27,000
叫做 Actor Model

2602
01:25:27,000 --> 01:25:29,000
这个 Actor 我不知道中文怎么翻译好

2603
01:25:29,000 --> 01:25:29,000
叫做

2604
01:25:32,000 --> 01:25:33,000
演员模型也不对吧

2605
01:25:33,000 --> 01:25:35,000
Actor 这里不是演员模型

2606
01:25:36,000 --> 01:25:37,000
简单来讲

2607
01:25:37,000 --> 01:25:39,000
就说你在 CSP 的时候有一种

2608
01:25:40,000 --> 01:25:41,000
经典的方式是说

2609
01:25:41,000 --> 01:25:43,000
我们两个之间实现一个所谓的

2610
01:25:44,000 --> 01:25:46,000
Channel 一个渠道

2611
01:25:46,000 --> 01:25:48,000
我们通过这个渠道来发送这个消息

2612
01:25:48,000 --> 01:25:48,000
对吧

2613
01:25:50,000 --> 01:25:50,000
就是说这个渠道

2614
01:25:50,000 --> 01:25:51,000
就是我要发消息的时候

2615
01:25:51,000 --> 01:25:53,000
我要我先把这个消息

2616
01:25:54,000 --> 01:25:56,000
通过这个渠道传送给你

2617
01:25:56,000 --> 01:26:00,000
如果你那边还没有来接收这个渠道

2618
01:26:00,000 --> 01:26:02,000
我发消息这个人还在那边等着你

2619
01:26:02,000 --> 01:26:04,000
接收之后才可以了

2620
01:26:04,000 --> 01:26:04,000
才可以走

2621
01:26:06,000 --> 01:26:07,000
大爷你没没这个意思吗

2622
01:26:07,000 --> 01:26:08,000
是

2623
01:26:10,000 --> 01:26:12,000
所以 Actor

2624
01:26:12,000 --> 01:26:14,000
比如说支持 Actor 的语言

2625
01:26:14,000 --> 01:26:15,000
像 Allen 或者是

2626
01:26:16,000 --> 01:26:17,000
Skala 也是一个

2627
01:26:17,000 --> 01:26:18,000
Skala 支持那个叫什么

2628
01:26:18,000 --> 01:26:20,000
不过 Skala 是通过 Aca 支持的

2629
01:26:21,000 --> 01:26:23,000
Skala 没有原生的 Actor

2630
01:26:23,000 --> 01:26:25,000
他有他原生是 Actor 的

2631
01:26:25,000 --> 01:26:27,000
他也可以通过 JVM 走 Aca

2632
01:26:27,000 --> 01:26:29,000
Aca 那个 Library 来实现 Actor Model

2633
01:26:30,000 --> 01:26:30,000
OK

2634
01:26:31,000 --> 01:26:33,000
然后刚才讲的是

2635
01:26:33,000 --> 01:26:34,000
那个 CSP 是通过 Channel 来实现的

2636
01:26:34,000 --> 01:26:36,000
就是说两个人要同时

2637
01:26:36,000 --> 01:26:38,000
到达那个 Channel 那个点

2638
01:26:38,000 --> 01:26:40,000
然后才能够传递消息

2639
01:26:41,000 --> 01:26:42,000
然后这就是一种方式

2640
01:26:42,000 --> 01:26:44,000
对而 Actor 更像一个

2641
01:26:44,000 --> 01:26:45,000
怎么说更像一个代理

2642
01:26:46,000 --> 01:26:47,000
Actor 是一个叫做

2643
01:26:48,000 --> 01:26:49,000
邮箱的模型

2644
01:26:49,000 --> 01:26:50,000
就是说每个人

2645
01:26:50,000 --> 01:26:51,000
就每个进程都是一个

2646
01:26:51,000 --> 01:26:52,000
所谓的一个 Actor

2647
01:26:53,000 --> 01:26:55,000
然后他每个 Actor

2648
01:26:55,000 --> 01:26:56,000
就只做自己的事情

2649
01:26:56,000 --> 01:26:57,000
然后但是每个 Actor

2650
01:26:57,000 --> 01:26:59,000
他有一个

2651
01:26:59,000 --> 01:27:01,000
给他唯一配备的一个邮箱

2652
01:27:01,000 --> 01:27:03,000
然后别人的消息来的时候

2653
01:27:03,000 --> 01:27:05,000
并不直接被

2654
01:27:05,000 --> 01:27:07,000
这个 Actor 拿去

2655
01:27:07,000 --> 01:27:09,000
而是说先塞进这个邮箱里面

2656
01:27:09,000 --> 01:27:10,000
然后等这个 Actor 处理

2657
01:27:10,000 --> 01:27:13,000
他执行到一个条件之后

2658
01:27:13,000 --> 01:27:14,000
他说我需要

2659
01:27:14,000 --> 01:27:15,000
收一个邮件

2660
01:27:15,000 --> 01:27:17,000
然后他再去看自己的邮箱说

2661
01:27:17,000 --> 01:27:19,000
有没有别人给我发过来的消息

2662
01:27:19,000 --> 01:27:20,000
我看一下处理一遍

2663
01:27:20,000 --> 01:27:20,000
如果没有的话

2664
01:27:20,000 --> 01:27:22,000
我再接着做自己的事情

2665
01:27:23,000 --> 01:27:26,000
所以 CSP 和 Actor Model 是两个

2666
01:27:27,000 --> 01:27:29,000
本质上是做的同样的事情

2667
01:27:29,000 --> 01:27:30,000
只是说他们在

2668
01:27:30,000 --> 01:27:31,000
在实现方式上是有一点

2669
01:27:31,000 --> 01:27:33,000
所谓的队友关系的在里面

2670
01:27:34,000 --> 01:27:35,000
OK

2671
01:27:37,000 --> 01:27:39,000
在现实中其实 Go 的话

2672
01:27:40,000 --> 01:27:42,000
它并不是一个纯粹的 CSP 的模型

2673
01:27:42,000 --> 01:27:44,000
因为它的那个 Channel

2674
01:27:44,000 --> 01:27:44,000
刚才讲了吗

2675
01:27:44,000 --> 01:27:45,000
它并不是一个

2676
01:27:45,000 --> 01:27:47,000
完全是主塞的 Channel

2677
01:27:47,000 --> 01:27:49,000
因为它的 Channel 是可以被 Buffered

2678
01:27:49,000 --> 01:27:51,000
对其实我就刚才想说

2679
01:27:51,000 --> 01:27:53,000
Go 的 Channel 难道不也是一个邮箱吗

2680
01:27:53,000 --> 01:27:54,000
就它也是一个 Q

2681
01:27:55,000 --> 01:27:57,000
对所以这个就是有一个

2682
01:27:57,000 --> 01:28:00,000
它不是一个纯粹的 CSP 的这一点

2683
01:28:00,000 --> 01:28:01,000
就是因为说它那个 Channel

2684
01:28:02,000 --> 01:28:04,000
它鼓励你使用一个叫做

2685
01:28:04,000 --> 01:28:05,000
Blocking Channel

2686
01:28:05,000 --> 01:28:06,000
就一次只能发一条消息

2687
01:28:06,000 --> 01:28:07,000
然后你必须要等

2688
01:28:07,000 --> 01:28:09,000
对方取出这个消息之后

2689
01:28:09,000 --> 01:28:11,000
你这些发送方才能接着进行下一个

2690
01:28:11,000 --> 01:28:14,000
对这就是一种比较纯粹的 CSP 的状态

2691
01:28:14,000 --> 01:28:16,000
但是如果你不用主塞式的 Channel 的话

2692
01:28:16,000 --> 01:28:18,000
其实 Go somehow 也是

2693
01:28:19,000 --> 01:28:20,000
用到了 Actor

2694
01:28:20,000 --> 01:28:21,000
没错

2695
01:28:21,000 --> 01:28:22,000
就是它 Go 的话

2696
01:28:22,000 --> 01:28:23,000
其实也是有一个

2697
01:28:23,000 --> 01:28:25,000
因为它的 Channel 有一个

2698
01:28:26,000 --> 01:28:26,000
扩展

2699
01:28:26,000 --> 01:28:28,000
就是说它 Channel 是可以有一个 Buffered

2700
01:28:28,000 --> 01:28:29,000
就是一个缓冲区域的

2701
01:28:29,000 --> 01:28:31,000
比如说我可以声明这个 Channel

2702
01:28:31,000 --> 01:28:33,000
有一个 100 个位置的缓冲区域

2703
01:28:33,000 --> 01:28:34,000
什么意思呢

2704
01:28:34,000 --> 01:28:37,000
我可以往这个 Channel 里面塞

2705
01:28:37,000 --> 01:28:40,000
99 条消息都不主塞

2706
01:28:40,000 --> 01:28:42,000
直到我塞 100 条消息的时候

2707
01:28:42,000 --> 01:28:43,000
不对我可以往那个

2708
01:28:43,000 --> 01:28:45,000
我那样塞 100 条消息都不主塞

2709
01:28:45,000 --> 01:28:47,000
但我往里面塞第 101 条消息的时候

2710
01:28:47,000 --> 01:28:49,000
我得等那头

2711
01:28:49,000 --> 01:28:51,000
那个人就是接收方

2712
01:28:51,000 --> 01:28:52,000
出一条消息之后

2713
01:28:52,000 --> 01:28:54,000
我才能够再往里面塞进去

2714
01:28:54,000 --> 01:28:55,000
就是说开始有一个

2715
01:28:55,000 --> 01:28:56,000
这么一个 Buffered 这么一个概念

2716
01:28:56,000 --> 01:28:58,000
然后这个时候的话

2717
01:28:58,000 --> 01:28:59,000
这种 Channel 就比较类似于

2718
01:28:59,000 --> 01:29:01,000
Actor Model 里面的

2719
01:29:01,000 --> 01:29:02,000
这个叫什么

2720
01:29:02,000 --> 01:29:04,000
Mailbox 信箱的概念

2721
01:29:04,000 --> 01:29:05,000
但是它没有那么

2722
01:29:05,000 --> 01:29:07,000
就灵活度和这个

2723
01:29:08,000 --> 01:29:09,000
自由程度还是不一样的

2724
01:29:09,000 --> 01:29:10,000
比如说

2725
01:29:11,000 --> 01:29:12,000
Actor Model 里面

2726
01:29:12,000 --> 01:29:13,000
如果你有信箱的概念的话

2727
01:29:13,000 --> 01:29:14,000
你必然的推论就是

2728
01:29:14,000 --> 01:29:15,000
每一个 Actor

2729
01:29:15,000 --> 01:29:16,000
它是有一个唯一的

2730
01:29:16,000 --> 01:29:17,000
确定的那个

2731
01:29:17,000 --> 01:29:19,000
识别服的一个 ID 对吧

2732
01:29:19,000 --> 01:29:20,000
你才知道你这个

2733
01:29:20,000 --> 01:29:23,000
你这个消息要从哪里来发给谁

2734
01:29:23,000 --> 01:29:23,000
对吧

2735
01:29:23,000 --> 01:29:25,000
你得有这么一个过程

2736
01:29:25,000 --> 01:29:26,000
但是在 Go 里面的话

2737
01:29:26,000 --> 01:29:28,000
因为你可以

2738
01:29:28,000 --> 01:29:30,000
每一个进程是可以建立多个 Channel 的

2739
01:29:31,000 --> 01:29:33,000
所以它的这个对应关系是不太一样的

2740
01:29:34,000 --> 01:29:37,000
但本质上他们是其实同一件事情

2741
01:29:37,000 --> 01:29:39,000
所以我们可以说 Actor Model

2742
01:29:39,000 --> 01:29:42,000
天生就比较适合

2743
01:29:42,000 --> 01:29:44,000
分布式计算的

2744
01:29:44,000 --> 01:29:45,000
领域

2745
01:29:45,000 --> 01:29:48,000
因为当你把你的计算模型

2746
01:29:48,000 --> 01:29:50,000
采用分布式的方式来实现的时候

2747
01:29:50,000 --> 01:29:52,000
那每一个分布式的

2748
01:29:53,000 --> 01:29:56,000
单元都会天生的带有一个

2749
01:29:56,000 --> 01:29:57,000
标识符

2750
01:29:58,000 --> 01:29:59,000
然后在这种状况下

2751
01:29:59,000 --> 01:30:00,000
你用 Actor 模型的时候

2752
01:30:00,000 --> 01:30:03,000
就非常容易的把你的抽象层级

2753
01:30:03,000 --> 01:30:04,000
连在一起了

2754
01:30:06,000 --> 01:30:08,000
但是如果用 Go Routine 的 Channel 的话

2755
01:30:08,000 --> 01:30:09,000
那可能

2756
01:30:09,000 --> 01:30:10,000
应用在分布式

2757
01:30:10,000 --> 01:30:12,000
分布计算的时候

2758
01:30:12,000 --> 01:30:14,000
没有那么自然

2759
01:30:15,000 --> 01:30:16,000
其实没有关系

2760
01:30:16,000 --> 01:30:17,000
这两个是可以完全互相

2761
01:30:17,000 --> 01:30:18,000
就是可以

2762
01:30:19,000 --> 01:30:21,000
不损失任何

2763
01:30:21,000 --> 01:30:23,000
抽象层级的互相转化的

2764
01:30:23,000 --> 01:30:24,000
比如说最简单一个转化的道理

2765
01:30:24,000 --> 01:30:25,000
就是说

2766
01:30:25,000 --> 01:30:28,000
我怎么在

2767
01:30:28,000 --> 01:30:30,000
用 Channel 实现 Actor model

2768
01:30:31,000 --> 01:30:32,000
很简单一个道理

2769
01:30:32,000 --> 01:30:33,000
就是说我每一个 process

2770
01:30:33,000 --> 01:30:35,000
我在建那个 process 的时候

2771
01:30:36,000 --> 01:30:37,000
我给它一个参数

2772
01:30:37,000 --> 01:30:38,000
就是一个 Channel

2773
01:30:38,000 --> 01:30:39,000
这个 Channel 我就是把它命名为

2774
01:30:39,000 --> 01:30:40,000
一个叫做

2775
01:30:40,000 --> 01:30:41,000
命名为邮箱

2776
01:30:41,000 --> 01:30:43,000
然后因为 Channel 是有 ID 的

2777
01:30:43,000 --> 01:30:45,000
这样的话我就可以认为

2778
01:30:45,000 --> 01:30:48,000
具备 Channel 读写的功能的

2779
01:30:50,000 --> 01:30:50,000
进程

2780
01:30:50,000 --> 01:30:52,000
就是 Actor 本身

2781
01:30:53,000 --> 01:30:54,000
对我意思就是

2782
01:30:54,000 --> 01:30:56,000
你在这样一种解决方案

2783
01:30:56,000 --> 01:30:58,000
你在实施这样的解决方案的时候

2784
01:30:58,000 --> 01:31:00,000
你实际上是采用了 Actor 模型

2785
01:31:00,000 --> 01:31:03,000
你只不过是在用 Channel 的方式

2786
01:31:03,000 --> 01:31:04,000
去模拟它而已

2787
01:31:04,000 --> 01:31:04,000
而

2788
01:31:06,000 --> 01:31:08,000
我们就不要去考虑

2789
01:31:08,000 --> 01:31:11,000
这个使用一种语言的机制

2790
01:31:11,000 --> 01:31:12,000
去模拟 Actor 模型

2791
01:31:12,000 --> 01:31:14,000
和真正的使用 Actor 模型之间的差别在哪

2792
01:31:15,000 --> 01:31:16,000
我的意思是

2793
01:31:16,000 --> 01:31:18,000
当你使用另外一种语言

2794
01:31:18,000 --> 01:31:19,000
当你使用 GoLang 的 feature

2795
01:31:19,000 --> 01:31:21,000
去模拟 Actor 模型的时候

2796
01:31:21,000 --> 01:31:23,000
其实也就意味着 Actor 模型

2797
01:31:23,000 --> 01:31:25,000
是比较适合在这样一种

2798
01:31:27,000 --> 01:31:28,000
问题领域里面

2799
01:31:28,000 --> 01:31:30,000
实施并发的模型

2800
01:31:30,000 --> 01:31:30,000
不是吗

2801
01:31:34,000 --> 01:31:35,000
我不太清楚

2802
01:31:37,000 --> 01:31:38,000
我觉得不一定

2803
01:31:38,000 --> 01:31:40,000
就是有些时候是用 Channel 模型

2804
01:31:40,000 --> 01:31:41,000
是更合适的

2805
01:31:41,000 --> 01:31:43,000
有些时候是用 Actor 模型

2806
01:31:43,000 --> 01:31:44,000
是更合适的

2807
01:31:44,000 --> 01:31:46,000
所以你怎么去选择它

2808
01:31:46,000 --> 01:31:47,000
我觉得还是要看你问题的

2809
01:31:47,000 --> 01:31:48,000
就你手上具体的问题的

2810
01:31:48,000 --> 01:31:51,000
本身的属性来决定的

2811
01:31:52,000 --> 01:31:54,000
就并不是说

2812
01:31:54,000 --> 01:31:55,000
Actor 模型就一定天然

2813
01:31:55,000 --> 01:32:00,000
比这种 CSP 的模型要来得更直观

2814
01:32:00,000 --> 01:32:02,000
或者是更易懂这样

2815
01:32:02,000 --> 01:32:03,000
好吧

2816
01:32:03,000 --> 01:32:06,000
那大概

2817
01:32:08,000 --> 01:32:10,000
我想想我们介绍了

2818
01:32:10,000 --> 01:32:12,000
传统的现成维俗

2819
01:32:12,000 --> 01:32:13,000
介绍了 FP

2820
01:32:13,000 --> 01:32:17,000
介绍了 CSP 和 Actor

2821
01:32:17,000 --> 01:32:19,000
那基本上我们可以说

2822
01:32:19,000 --> 01:32:23,000
已经涵盖了比较主流的

2823
01:32:23,000 --> 01:32:24,000
这种并发模型

2824
01:32:24,000 --> 01:32:25,000
对

2825
01:32:25,000 --> 01:32:25,000
当然

2826
01:32:26,000 --> 01:32:28,000
还有一些其他的并发模型

2827
01:32:28,000 --> 01:32:30,000
比如说有本书叫

2828
01:32:31,000 --> 01:32:33,000
叫做 7

2829
01:32:33,000 --> 01:32:35,000
Pyrolyseum in 7 weeks

2830
01:32:37,000 --> 01:32:39,000
7 周 7 种并发模型

2831
01:32:40,000 --> 01:32:41,000
他那本书里面已经介绍了 7 种

2832
01:32:41,000 --> 01:32:44,000
但是我们今天只说了 4 种

2833
01:32:44,000 --> 01:32:46,000
但是如果我印象没错的话

2834
01:32:47,000 --> 01:32:49,000
他提到的其他三种

2835
01:32:49,000 --> 01:32:50,000
其实都是

2836
01:32:50,000 --> 01:32:51,000
怎么说要不是

2837
01:32:51,000 --> 01:32:53,000
我们提到的这四种比较

2838
01:32:53,000 --> 01:32:56,000
基本的并发模型的混合

2839
01:32:57,000 --> 01:32:58,000
或者就是

2840
01:32:58,000 --> 01:33:00,000
在更大规模上的抽象

2841
01:33:00,000 --> 01:33:01,000
当然我不是

2842
01:33:01,000 --> 01:33:02,000
印象不是很深了

2843
01:33:02,000 --> 01:33:04,000
但是我推荐

2844
01:33:04,000 --> 01:33:04,000
如果有

2845
01:33:04,000 --> 01:33:06,000
如果对这个问题比较感兴趣的听众们

2846
01:33:06,000 --> 01:33:07,000
可以去看看这本书

2847
01:33:07,000 --> 01:33:08,000
就是

2848
01:33:08,000 --> 01:33:13,000
他是另外一本叫做 7 Language in 7 weeks 的姐妹书

2849
01:33:13,000 --> 01:33:15,000
另外一本书也很好

2850
01:33:16,000 --> 01:33:16,000
OK

2851
01:33:17,000 --> 01:33:19,000
然后我们就要过渡到

2852
01:33:19,000 --> 01:33:24,000
下一个相关但并不等同的话题了

2853
01:33:25,000 --> 01:33:27,000
应该说是在抽象层级上并不等同

2854
01:33:29,000 --> 01:33:30,000
但是他有点相关

2855
01:33:30,000 --> 01:33:31,000
没错

2856
01:33:31,000 --> 01:33:34,000
这是所谓的异步和非阻塞式的

2857
01:33:34,000 --> 01:33:36,000
一个程序计划

2858
01:33:36,000 --> 01:33:37,000
程序计划的设计

2859
01:33:37,000 --> 01:33:38,000
没错

2860
01:33:38,000 --> 01:33:40,000
刚才我们提到了

2861
01:33:40,000 --> 01:33:42,000
在 functional programming

2862
01:33:42,000 --> 01:33:43,000
非常难以解决的一个问题

2863
01:33:43,000 --> 01:33:45,000
就是当你要处理 Io 的时候

2864
01:33:45,000 --> 01:33:46,000
你怎么办

2865
01:33:47,000 --> 01:33:49,000
就当你需要问

2866
01:33:49,000 --> 01:33:51,000
那个使用者的姓名的时候

2867
01:33:52,000 --> 01:33:55,000
你使用多个

2868
01:33:55,000 --> 01:33:58,000
当你有一种并行机制

2869
01:33:58,000 --> 01:34:00,000
并且你需要解决

2870
01:34:00,000 --> 01:34:03,000
询问使用者姓名这个问题的时候

2871
01:34:03,000 --> 01:34:04,000
你到底应该怎么办

2872
01:34:04,000 --> 01:34:07,000
这就是我们接下来需要讨论的问题

2873
01:34:07,000 --> 01:34:10,000
就是 e 不 l 最恰当的抽象到底是什么

2874
01:34:12,000 --> 01:34:13,000
我们传统上

2875
01:34:13,000 --> 01:34:14,000
不叫传统上

2876
01:34:14,000 --> 01:34:17,000
可能大家听的最熟悉的

2877
01:34:17,000 --> 01:34:18,000
就是一个叫做

2878
01:34:18,000 --> 01:34:19,000
asynchronous

2879
01:34:19,000 --> 01:34:22,000
就是异步 Io 这么一个做法

2880
01:34:22,000 --> 01:34:24,000
主要存在于像什么 node

2881
01:34:25,000 --> 01:34:26,000
这种一些

2882
01:34:27,000 --> 01:34:30,000
凡是设计 JavaScript 的话

2883
01:34:30,000 --> 01:34:32,000
基本上都是走这种 async Io 的方式

2884
01:34:33,000 --> 01:34:35,000
然后 Python 的话有像 tornado

2885
01:34:36,000 --> 01:34:37,000
还有之前那个叫什么 twisted

2886
01:34:38,000 --> 01:34:39,000
都是这种方式

2887
01:34:39,000 --> 01:34:41,000
然后 Ruby 里面是有什么

2888
01:34:42,000 --> 01:34:43,000
Ruby

2889
01:34:44,000 --> 01:34:45,000
我还真的不知道

2890
01:34:45,000 --> 01:34:47,000
node 比如说它底层也是用了

2891
01:34:47,000 --> 01:34:50,000
像 c 的那个叫 libuv 来实现它的

2892
01:34:50,000 --> 01:34:51,000
这个异步 Io 的

2893
01:34:51,000 --> 01:34:52,000
我记得

2894
01:34:52,000 --> 01:34:53,000
nilvim

2895
01:34:53,000 --> 01:34:56,000
它非常重要的

2896
01:34:57,000 --> 01:34:59,000
todo 之一就是要把所有的

2897
01:35:01,000 --> 01:35:04,000
vi 的编辑信源的 event 都转到

2898
01:35:04,000 --> 01:35:07,000
vim 的编辑信源的 event 都转到 libuv 上实现

2899
01:35:07,000 --> 01:35:09,000
对很多人现在有很多这种

2900
01:35:09,000 --> 01:35:11,000
采用异步 Io 的

2901
01:35:12,000 --> 01:35:14,000
这种大型程序都在改到

2902
01:35:14,000 --> 01:35:15,000
用这一波包来实现了

2903
01:35:16,000 --> 01:35:17,000
因为它确实写得很好

2904
01:35:17,000 --> 01:35:20,000
什么跨平台那些都做得挺不错的

2905
01:35:20,000 --> 01:35:24,000
然后 Java 的话有那个叫做 nio

2906
01:35:24,000 --> 01:35:26,000
就是新 Io 的那门一个酷

2907
01:35:26,000 --> 01:35:28,000
也可以做这种异步 Io 的机制了

2908
01:35:29,000 --> 01:35:31,000
现在还有什么其他的主流语言呢

2909
01:35:31,000 --> 01:35:32,000
好像也差不多了

2910
01:35:33,000 --> 01:35:33,000
对

2911
01:35:34,000 --> 01:35:34,000
OK

2912
01:35:35,000 --> 01:35:38,000
然后就是异步 Io 到底是做了一件

2913
01:35:38,000 --> 01:35:39,000
什么样的事情呢

2914
01:35:39,000 --> 01:35:41,000
就是他们都是在一个很

2915
01:35:41,000 --> 01:35:45,000
就是他们都是在一个单进程的情况下去模拟

2916
01:35:45,000 --> 01:35:46,000
或者说这么说吧

2917
01:35:46,000 --> 01:35:47,000
他们都是在一个

2918
01:35:48,000 --> 01:35:51,000
单进程的情况下去做一些并发的事情

2919
01:35:52,000 --> 01:35:53,000
对他们试图用

2920
01:35:54,000 --> 01:35:57,000
其实就是一个非常简单的

2921
01:35:57,000 --> 01:35:57,000
呃

2922
01:35:58,000 --> 01:35:59,000
例子就是我

2923
01:36:00,000 --> 01:36:02,000
先做一件事情

2924
01:36:02,000 --> 01:36:06,000
然后在这件事情跑了间隙之中去做另外一件事情

2925
01:36:06,000 --> 01:36:07,000
比如说回到我们刚才那个

2926
01:36:08,000 --> 01:36:09,000
做饭的例子

2927
01:36:09,000 --> 01:36:11,000
我先把锅做在火上

2928
01:36:11,000 --> 01:36:12,000
然后开始烧水

2929
01:36:12,000 --> 01:36:15,000
然后在烧水的间隙里面我开始切菜

2930
01:36:15,000 --> 01:36:17,000
然后等到水烧开了

2931
01:36:17,000 --> 01:36:17,000
我看到水在滚

2932
01:36:17,000 --> 01:36:19,000
然后我再去管烧水的事情

2933
01:36:19,000 --> 01:36:21,000
其实就是一个非常

2934
01:36:21,000 --> 01:36:24,000
异步 Io 其实就是这样一个非常简单的问题

2935
01:36:24,000 --> 01:36:24,000
只不过

2936
01:36:25,000 --> 01:36:27,000
它具体实现起来会

2937
01:36:27,000 --> 01:36:32,000
比做菜这么简单的一个任务要复杂很多

2938
01:36:32,000 --> 01:36:33,000
对

2939
01:36:33,000 --> 01:36:34,000
就为什么说

2940
01:36:34,000 --> 01:36:35,000
还有一个问题就是说

2941
01:36:35,000 --> 01:36:36,000
为什么每次提到异步的时候

2942
01:36:36,000 --> 01:36:38,000
都一定是指 Io 呢

2943
01:36:38,000 --> 01:36:40,000
因为这个其实牵涉到计算机

2944
01:36:40,000 --> 01:36:42,000
这个之前我们某一期讲过

2945
01:36:42,000 --> 01:36:43,000
计算机体系结构的一个问题

2946
01:36:43,000 --> 01:36:44,000
就是说

2947
01:36:44,000 --> 01:36:46,000
在所有的这个

2948
01:36:46,000 --> 01:36:48,000
这个计算机这个应用里面

2949
01:36:48,000 --> 01:36:50,000
你只要设计到 Io 的时候

2950
01:36:50,000 --> 01:36:51,000
这个 CPU 都是

2951
01:36:51,000 --> 01:36:53,000
远远高于

2952
01:36:53,000 --> 01:36:55,000
就是它的处理速度是远远高于你这个

2953
01:36:55,000 --> 01:36:56,000
就是输出的速度的

2954
01:36:57,000 --> 01:36:59,000
这样的话一个 B 的结果就是说

2955
01:36:59,000 --> 01:37:01,000
如果你只要一旦设计 Io 的操作

2956
01:37:01,000 --> 01:37:03,000
你的 CPU 就要闲置起来等

2957
01:37:03,000 --> 01:37:06,000
那么异步 Io 的他们一个切入点就是说

2958
01:37:06,000 --> 01:37:09,000
那我们就不要等那个 Io 的

2959
01:37:09,000 --> 01:37:10,000
响应结果回来

2960
01:37:10,000 --> 01:37:12,000
一直等它啥等

2961
01:37:12,000 --> 01:37:13,000
反正也没事做嘛

2962
01:37:14,000 --> 01:37:14,000
我们在

2963
01:37:15,000 --> 01:37:16,000
它的结果返回来之前

2964
01:37:16,000 --> 01:37:17,000
我们先做点别的事

2965
01:37:17,000 --> 01:37:19,000
然后等那边结果返回来之后

2966
01:37:19,000 --> 01:37:20,000
你再通知我

2967
01:37:20,000 --> 01:37:21,000
再回来

2968
01:37:21,000 --> 01:37:23,000
把这件事情接着再捡起来

2969
01:37:23,000 --> 01:37:24,000
接着做下去

2970
01:37:24,000 --> 01:37:25,000
没错

2971
01:37:26,000 --> 01:37:29,000
但是异步 Io 有一个问题

2972
01:37:29,000 --> 01:37:30,000
就是

2973
01:37:30,000 --> 01:37:31,000
很有可能你协调不好

2974
01:37:33,000 --> 01:37:33,000
对

2975
01:37:34,000 --> 01:37:36,000
还是用做饭的例子来说

2976
01:37:36,000 --> 01:37:38,000
就是可能你想起来

2977
01:37:38,000 --> 01:37:39,000
你想当然会觉得

2978
01:37:39,000 --> 01:37:40,000
烧水的时候我切菜

2979
01:37:41,000 --> 01:37:42,000
但是你没有办法保证

2980
01:37:42,000 --> 01:37:43,000
在水烧开之前

2981
01:37:43,000 --> 01:37:44,000
你一定能把菜切好

2982
01:37:45,000 --> 01:37:47,000
我相信每一个喜欢做饭的人

2983
01:37:47,000 --> 01:37:48,000
都会有这样的窘境

2984
01:37:48,000 --> 01:37:50,000
或者说从来没有这样的窘境

2985
01:37:50,000 --> 01:37:52,000
就是同时有很多事情要你去

2986
01:37:52,000 --> 01:37:53,000
要你去处理

2987
01:37:53,000 --> 01:37:55,000
甚至我记得新开店

2988
01:37:55,000 --> 01:37:57,000
英语里面好像有一期课文就是这个

2989
01:37:57,000 --> 01:38:00,000
就是说一个主妇在活面

2990
01:38:00,000 --> 01:38:02,000
然后电话响了

2991
01:38:02,000 --> 01:38:05,000
同时又有人在敲门

2992
01:38:07,000 --> 01:38:09,000
与此同时再加上如果锅开了

2993
01:38:09,000 --> 01:38:10,000
那在这种情况下你该怎么办

2994
01:38:10,000 --> 01:38:13,000
其实异步 Io

2995
01:38:13,000 --> 01:38:16,000
或者说基于毁掉的异步 Io

2996
01:38:17,000 --> 01:38:19,000
就是这样一个与生俱来的问题

2997
01:38:19,000 --> 01:38:22,000
你很难去理解

2998
01:38:22,000 --> 01:38:24,000
或者说很难事先判定

2999
01:38:24,000 --> 01:38:27,000
所有事情发生的先后顺序

3000
01:38:27,000 --> 01:38:28,000
然后

3001
01:38:29,000 --> 01:38:31,000
因为你作为一个程序员

3002
01:38:31,000 --> 01:38:34,000
你只能用线性的方式去写代码

3003
01:38:34,000 --> 01:38:37,000
所以你线性的代码是很难处理这样

3004
01:38:38,000 --> 01:38:41,000
一个不知道先后因果顺序的问题

3005
01:38:42,000 --> 01:38:42,000
对

3006
01:38:43,000 --> 01:38:46,000
这里面通常有一个词汇来描述

3007
01:38:46,000 --> 01:38:48,000
采用异步 Io 的程序结构

3008
01:38:48,000 --> 01:38:49,000
叫做控制流导致

3009
01:38:50,000 --> 01:38:51,000
Inversive control flow

3010
01:38:53,000 --> 01:38:55,000
我们通常写代码的时候

3011
01:38:55,000 --> 01:38:56,000
我们也说先怎么怎么样

3012
01:38:56,000 --> 01:38:57,000
后怎么怎么样

3013
01:38:57,000 --> 01:38:58,000
它是一个线性的

3014
01:38:58,000 --> 01:39:00,000
前因后果的关系走下来的对吧

3015
01:39:00,000 --> 01:39:02,000
但是如果你采用那种异步 Io

3016
01:39:02,000 --> 01:39:04,000
这种毁掉方式来做的话

3017
01:39:04,000 --> 01:39:08,000
就会发现我这个消息过来了

3018
01:39:08,000 --> 01:39:09,000
我这个时候该干嘛呢

3019
01:39:09,000 --> 01:39:11,000
你得去找半天说

3020
01:39:11,000 --> 01:39:12,000
我现在应该到这一步了

3021
01:39:12,000 --> 01:39:14,000
我应该恢复到之前那个状态

3022
01:39:14,000 --> 01:39:15,000
然后怎么接着做下去

3023
01:39:15,000 --> 01:39:17,000
其实是一个

3024
01:39:17,000 --> 01:39:20,000
如果人闹去想是一个挺费时费脑的事情

3025
01:39:20,000 --> 01:39:21,000
但如果你写代码来做的话

3026
01:39:21,000 --> 01:39:23,000
就是要考虑很多

3027
01:39:23,000 --> 01:39:26,000
可能你预想不到的组合的

3028
01:39:26,000 --> 01:39:27,000
这种情况出现

3029
01:39:27,000 --> 01:39:28,000
没错

3030
01:39:29,000 --> 01:39:30,000
但异步 Io

3031
01:39:30,000 --> 01:39:32,000
就是基于回带的异步 Io

3032
01:39:32,000 --> 01:39:34,000
有一个什么样的好处呢

3033
01:39:34,000 --> 01:39:36,000
就是它可以保证整个

3034
01:39:36,000 --> 01:39:39,000
因为它是一个单进程的这么一个

3035
01:39:39,000 --> 01:39:41,000
单进程或者单线程的这么一个结构

3036
01:39:41,000 --> 01:39:42,000
它有一个好处

3037
01:39:42,000 --> 01:39:44,000
就是可以完全不用考虑锁的问题

3038
01:39:45,000 --> 01:39:45,000
对

3039
01:39:45,000 --> 01:39:49,000
因为你在任意时刻都只有一个

3040
01:39:49,000 --> 01:39:51,000
控制流在执行

3041
01:39:51,000 --> 01:39:51,000
这样的话

3042
01:39:51,000 --> 01:39:53,000
只有一个工作单元在跑

3043
01:39:53,000 --> 01:39:54,000
一个人出

3044
01:39:54,000 --> 01:39:54,000
对没错

3045
01:39:54,000 --> 01:39:56,000
你就不用去考虑说

3046
01:39:56,000 --> 01:39:59,000
我在我的进程或者是线程

3047
01:40:00,000 --> 01:40:01,000
Memory space

3048
01:40:01,000 --> 01:40:03,000
就是内存空间以内

3049
01:40:03,000 --> 01:40:04,000
我要去修改任何状态

3050
01:40:04,000 --> 01:40:08,000
我改的时候肯定是不会有任何人跟我抢的

3051
01:40:09,000 --> 01:40:09,000
没错

3052
01:40:09,000 --> 01:40:11,000
这可能也是

3053
01:40:11,000 --> 01:40:14,000
我先讲了 JavaScript 的引擎也好

3054
01:40:14,000 --> 01:40:17,000
它很在意的一点

3055
01:40:17,000 --> 01:40:19,000
因为你一旦可以避免锁

3056
01:40:19,000 --> 01:40:22,000
或者就是同步

3057
01:40:22,000 --> 01:40:23,000
叫什么

3058
01:40:23,000 --> 01:40:24,000
shared immutable state

3059
01:40:24,000 --> 01:40:26,000
就是共享的可变状态的话

3060
01:40:26,000 --> 01:40:30,000
但可以避免你的整个编程的

3061
01:40:31,000 --> 01:40:31,000
怎么说

3062
01:40:32,000 --> 01:40:34,000
难度就会降低

3063
01:40:34,000 --> 01:40:36,000
很大的一个什么数量级的降低

3064
01:40:36,000 --> 01:40:39,000
但如果你不能保证这一点的话

3065
01:40:39,000 --> 01:40:41,000
你就会牵涉到刚才我们讲的

3066
01:40:41,000 --> 01:40:44,000
并行计算的最核心的矛盾

3067
01:40:44,000 --> 01:40:45,000
就是人没有办法去思考

3068
01:40:45,000 --> 01:40:47,000
像机器那样并行的去思考

3069
01:40:48,000 --> 01:40:48,000
对

3070
01:40:49,000 --> 01:40:49,000
对

3071
01:40:49,000 --> 01:40:52,000
但是机器回家的 EVIO

3072
01:40:52,000 --> 01:40:54,000
有一个很大的缺陷

3073
01:40:54,000 --> 01:40:56,000
就是它要把我们这个程序

3074
01:40:56,000 --> 01:40:59,000
整个逻辑流分得非常碎

3075
01:40:59,000 --> 01:41:00,000
通过回调的方式

3076
01:41:00,000 --> 01:41:03,000
你要把它整个逻辑流做到

3077
01:41:03,000 --> 01:41:04,000
切成很多小片段

3078
01:41:04,000 --> 01:41:06,000
然后每个片段它之间的关系

3079
01:41:06,000 --> 01:41:08,000
又不是非常的那种很线性很明朗

3080
01:41:09,000 --> 01:41:09,000
这样的话

3081
01:41:09,000 --> 01:41:12,000
对于你理解整个程序的结构

3082
01:41:12,000 --> 01:41:14,000
其实是非常不利的

3083
01:41:14,000 --> 01:41:15,000
对

3084
01:41:15,000 --> 01:41:17,000
在 JavaScript 程序里面

3085
01:41:17,000 --> 01:41:18,000
经常会有这样的笑话

3086
01:41:18,000 --> 01:41:21,000
就是一个回调

3087
01:41:21,000 --> 01:41:22,000
欠着另外一个回调

3088
01:41:22,000 --> 01:41:23,000
然后再欠着另外一个回调

3089
01:41:23,000 --> 01:41:26,000
然后整个最后你写的代码的结尾

3090
01:41:26,000 --> 01:41:28,000
就是括号分号

3091
01:41:28,000 --> 01:41:30,000
括号分号

3092
01:41:30,000 --> 01:41:32,000
括号分号

3093
01:41:32,000 --> 01:41:32,000
对

3094
01:41:32,000 --> 01:41:34,000
这样一层一层嵌到进去

3095
01:41:34,000 --> 01:41:34,000
对

3096
01:41:34,000 --> 01:41:35,000
没错

3097
01:41:35,000 --> 01:41:36,000
然后这个有一个专门的

3098
01:41:36,000 --> 01:41:38,000
我们给它一个称呼叫做回调

3099
01:41:39,000 --> 01:41:40,000
回调地域

3100
01:41:40,000 --> 01:41:42,000
Callback hell

3101
01:41:42,000 --> 01:41:43,000
对

3102
01:41:43,000 --> 01:41:45,000
然后就说

3103
01:41:45,000 --> 01:41:48,000
我们有没有办法说能够既保留

3104
01:41:48,000 --> 01:41:51,000
这个 EVIO 这种单线程

3105
01:41:51,000 --> 01:41:54,000
不需要考虑锁的极致的好处

3106
01:41:54,000 --> 01:41:56,000
同时又可以保留

3107
01:41:56,000 --> 01:41:58,000
我们这个程序逻辑是线性

3108
01:41:58,000 --> 01:41:59,000
不用分的

3109
01:42:00,000 --> 01:42:01,000
不用切成小片段

3110
01:42:01,000 --> 01:42:01,000
切得很散

3111
01:42:01,000 --> 01:42:02,000
就是这种状况

3112
01:42:03,000 --> 01:42:06,000
就也有一些很好的尝试

3113
01:42:06,000 --> 01:42:09,000
就是说基于协程这么一个概念

3114
01:42:09,000 --> 01:42:11,000
协程是什么意思

3115
01:42:11,000 --> 01:42:13,000
刚才讲到有进程

3116
01:42:13,000 --> 01:42:13,000
有线程

3117
01:42:13,000 --> 01:42:14,000
有协程

3118
01:42:14,000 --> 01:42:17,000
协程其实是在程序里面

3119
01:42:17,000 --> 01:42:19,000
自己管理的一个逻辑的

3120
01:42:20,000 --> 01:42:22,000
又用一个广义的进程

3121
01:42:22,000 --> 01:42:24,000
对

3122
01:42:24,000 --> 01:42:28,000
我觉得协程其实比较容易理解的

3123
01:42:29,000 --> 01:42:31,000
比较容易理解的点

3124
01:42:31,000 --> 01:42:32,000
就是说

3125
01:42:33,000 --> 01:42:36,000
协程其实是非常贴近现实生活的一个东西

3126
01:42:38,000 --> 01:42:40,000
比如说我在粘模型

3127
01:42:40,000 --> 01:42:42,000
然后这个时候女朋友喊我说

3128
01:42:43,000 --> 01:42:48,000
水开了你去泡个茶

3129
01:42:48,000 --> 01:42:49,000
然后我可以很方便的

3130
01:42:49,000 --> 01:42:50,000
放下我手中的工具

3131
01:42:50,000 --> 01:42:51,000
转身去泡茶

3132
01:42:51,000 --> 01:42:54,000
回来的时候接着我刚才粘到一半的

3133
01:42:57,000 --> 01:42:57,000
the progress

3134
01:43:00,000 --> 01:43:00,000
中文是什么

3135
01:43:01,000 --> 01:43:02,000
进度

3136
01:43:02,000 --> 01:43:02,000
对

3137
01:43:03,000 --> 01:43:05,000
然后继续粘我的模型

3138
01:43:06,000 --> 01:43:10,000
就是说其实现实生活中很多事情都是

3139
01:43:10,000 --> 01:43:12,000
可以对应到集团的协程

3140
01:43:12,000 --> 01:43:16,000
但是在传统的没有协程的编程模型里面

3141
01:43:16,000 --> 01:43:17,000
编程世界里面

3142
01:43:17,000 --> 01:43:19,000
计算机是不知道怎么保存现场

3143
01:43:20,000 --> 01:43:24,000
所以说协程其实就是赋予的计算机一种保存

3144
01:43:24,000 --> 01:43:26,000
一个执行到一半的函数的现场的能力

3145
01:43:26,000 --> 01:43:29,000
然后告诉你说你做到这儿

3146
01:43:29,000 --> 01:43:30,000
给了你个断点

3147
01:43:30,000 --> 01:43:31,000
你可以跳出去做别的事情

3148
01:43:31,000 --> 01:43:34,000
回来的时候刚才执行到哪儿

3149
01:43:34,000 --> 01:43:35,000
还可以继续接着执行

3150
01:43:35,000 --> 01:43:36,000
这就是现场

3151
01:43:36,000 --> 01:43:38,000
所有的 context

3152
01:43:38,000 --> 01:43:41,000
你的上下文都还保留在原样

3153
01:43:41,000 --> 01:43:44,000
你可以接着假装没有中断这件事情发生一样

3154
01:43:44,000 --> 01:43:46,000
你接着往前走下去了

3155
01:43:46,000 --> 01:43:48,000
所以其实从这个意义上来讲

3156
01:43:48,000 --> 01:43:49,000
现成也好

3157
01:43:49,000 --> 01:43:50,000
进程也好

3158
01:43:50,000 --> 01:43:50,000
协程也好

3159
01:43:50,000 --> 01:43:51,000
他们都做的同样一件事情

3160
01:43:51,000 --> 01:43:55,000
就是说是一段可以被随时重

3161
01:43:56,000 --> 01:43:57,000
叫做 resume

3162
01:43:57,000 --> 01:43:58,000
不叫重起

3163
01:43:58,000 --> 01:43:58,000
叫什么

3164
01:44:00,000 --> 01:44:01,000
随时可以捡起来

3165
01:44:01,000 --> 01:44:03,000
接着再做下去的这么一个逻辑

3166
01:44:04,000 --> 01:44:04,000
对

3167
01:44:04,000 --> 01:44:06,000
但唯一的区别就是什么呢

3168
01:44:06,000 --> 01:44:07,000
对

3169
01:44:07,000 --> 01:44:07,000
resume

3170
01:44:07,000 --> 01:44:08,000
对没错

3171
01:44:08,000 --> 01:44:09,000
就是说

3172
01:44:09,000 --> 01:44:10,000
但他们之间的区别在哪里呢

3173
01:44:10,000 --> 01:44:11,000
就是说

3174
01:44:12,000 --> 01:44:16,000
可能在实现资源的 overhead 上面是不一样的

3175
01:44:16,000 --> 01:44:18,000
可能最重的可能是进程

3176
01:44:18,000 --> 01:44:20,000
因为超好系统要做很多什么 CPU

3177
01:44:20,000 --> 01:44:21,000
记存器的切换

3178
01:44:21,000 --> 01:44:22,000
乱七八糟的事情

3179
01:44:22,000 --> 01:44:24,000
还要保留一些什么样的系统的

3180
01:44:24,000 --> 01:44:26,000
一些 bookkeeping 的工作

3181
01:44:26,000 --> 01:44:27,000
然后稍微起重

3182
01:44:27,000 --> 01:44:29,000
主要是在需要的时候

3183
01:44:29,000 --> 01:44:31,000
需要把内存里面的很多数据拷贝一份

3184
01:44:31,000 --> 01:44:33,000
这是非常非常大的一件事

3185
01:44:33,000 --> 01:44:34,000
对

3186
01:44:34,000 --> 01:44:37,000
然后进程的开销就相对要少一点

3187
01:44:37,000 --> 01:44:39,000
但是还是比较显著的

3188
01:44:40,000 --> 01:44:41,000
那么协程就是说

3189
01:44:41,000 --> 01:44:43,000
那直接就绕过超好系统那一步

3190
01:44:43,000 --> 01:44:44,000
我直接在程序内部

3191
01:44:44,000 --> 01:44:47,000
通过一种自制的调度器的方式

3192
01:44:47,000 --> 01:44:51,000
来管理我自己的那些 task

3193
01:44:51,000 --> 01:44:52,000
那些职业任务

3194
01:44:52,000 --> 01:44:56,000
然后使得有一个非常轻量的资源的开销

3195
01:44:56,000 --> 01:44:58,000
同时又能给我带来像类似于

3196
01:44:58,000 --> 01:45:00,000
进程或者是现成那样的一个

3197
01:45:01,000 --> 01:45:02,000
线性的逻辑流的好处

3198
01:45:03,000 --> 01:45:03,000
对

3199
01:45:03,000 --> 01:45:05,000
这样前面所提到的这种

3200
01:45:05,000 --> 01:45:08,000
inversive control flow 的问题就不会再发生

3201
01:45:09,000 --> 01:45:09,000
没错

3202
01:45:10,000 --> 01:45:10,000
对

3203
01:45:10,000 --> 01:45:13,000
现实中使用协程的例子也是蛮多的

3204
01:45:14,000 --> 01:45:16,000
其实总体来讲

3205
01:45:16,000 --> 01:45:18,000
像 GoLine 的 GoRoutine

3206
01:45:18,000 --> 01:45:21,000
它就是一种写成的一种变种

3207
01:45:21,000 --> 01:45:23,000
然后像 Python 的话

3208
01:45:23,000 --> 01:45:24,000
它有一个叫做 generator

3209
01:45:24,000 --> 01:45:25,000
生成器这两个概念

3210
01:45:25,000 --> 01:45:28,000
就是它这个函数里面是

3211
01:45:28,000 --> 01:45:31,000
有一个特殊的关键词叫做 yield

3212
01:45:31,000 --> 01:45:33,000
可以暂时的让出

3213
01:45:33,000 --> 01:45:35,000
yield 就是让出的意思

3214
01:45:35,000 --> 01:45:37,000
让出这个程序的控制流

3215
01:45:37,000 --> 01:45:40,000
然后等一边条件合适的时候

3216
01:45:40,000 --> 01:45:42,000
你再把它回到这个位置

3217
01:45:42,000 --> 01:45:43,000
然后接着从这个点往下直行

3218
01:45:44,000 --> 01:45:46,000
然后我知道是 JavaScript

3219
01:45:46,000 --> 01:45:48,000
从应该是下一个版本

3220
01:45:48,000 --> 01:45:50,000
还是 7 的时候

3221
01:45:50,000 --> 01:45:50,000
它也在加

3222
01:45:50,000 --> 01:45:51,000
不就下一个版本

3223
01:45:51,000 --> 01:45:55,000
就 emacs script 6

3224
01:45:55,000 --> 01:45:56,000
这个版本里面

3225
01:45:56,000 --> 01:45:59,000
就已经有类似的 generator

3226
01:45:59,000 --> 01:46:01,000
这么一个概念在里面了

3227
01:46:01,000 --> 01:46:03,000
然后 Ruby 的话

3228
01:46:03,000 --> 01:46:05,000
它有一个特性叫做 fiber

3229
01:46:06,000 --> 01:46:07,000
也是一个写成的例子

3230
01:46:08,000 --> 01:46:08,000
对

3231
01:46:08,000 --> 01:46:09,000
fiber 一般翻译成叫什么

3232
01:46:10,000 --> 01:46:13,000
就是比线程更要细的

3233
01:46:13,000 --> 01:46:14,000
纤维纤程

3234
01:46:14,000 --> 01:46:16,000
但是纤程就是写成

3235
01:46:16,000 --> 01:46:18,000
因为它是对于 thread 来讲

3236
01:46:18,000 --> 01:46:21,000
thread 在织布的语境

3237
01:46:21,000 --> 01:46:22,000
就是纺织界的语境里面

3238
01:46:22,000 --> 01:46:23,000
是叫什么线头

3239
01:46:23,000 --> 01:46:24,000
对不对

3240
01:46:24,000 --> 01:46:25,000
对一根线

3241
01:46:25,000 --> 01:46:28,000
而 fiber 则是组成纤的一根纤维的纱

3242
01:46:28,000 --> 01:46:29,000
一根纱

3243
01:46:29,000 --> 01:46:29,000
对

3244
01:46:29,000 --> 01:46:30,000
没错

3245
01:46:30,000 --> 01:46:31,000
这个意思

3246
01:46:32,000 --> 01:46:33,000
然后 Python 的话

3247
01:46:33,000 --> 01:46:37,000
还有一个 fork 算是

3248
01:46:37,000 --> 01:46:39,000
叫做 gevent

3249
01:46:39,000 --> 01:46:41,000
它是可以甚至通过那种方式来做

3250
01:46:42,000 --> 01:46:44,000
全局的写成

3251
01:46:44,000 --> 01:46:47,000
而不是说只限于 generator

3252
01:46:47,000 --> 01:46:49,000
这种比较受限的写成

3253
01:46:50,000 --> 01:46:51,000
OK

3254
01:46:51,000 --> 01:46:52,000
所以

3255
01:46:52,000 --> 01:46:53,000
但问题在于

3256
01:46:53,000 --> 01:46:56,000
不管是毁掉还是写成

3257
01:46:56,000 --> 01:46:59,000
都没有办法非常有效的利用多核处理器

3258
01:46:59,000 --> 01:46:59,000
不是吗

3259
01:46:59,000 --> 01:47:02,000
因为你无论如何

3260
01:47:02,000 --> 01:47:04,000
都只有一个单个的进程

3261
01:47:07,000 --> 01:47:08,000
没错

3262
01:47:08,000 --> 01:47:09,000
一般是这样子的

3263
01:47:09,000 --> 01:47:10,000
比如刚才我们看了几个例子

3264
01:47:10,000 --> 01:47:12,000
它都是因为有这样那样的限制

3265
01:47:12,000 --> 01:47:13,000
导致它不能使用多线程

3266
01:47:13,000 --> 01:47:16,000
但是也并不完全是这样

3267
01:47:16,000 --> 01:47:17,000
比如说 Go 的 Go routine

3268
01:47:17,000 --> 01:47:21,000
它其实是可以利用多核处理器核心的

3269
01:47:21,000 --> 01:47:24,000
就是看你系统的调度的时候

3270
01:47:24,000 --> 01:47:25,000
你是怎么去调度它而已

3271
01:47:26,000 --> 01:47:26,000
OK

3272
01:47:28,000 --> 01:47:31,000
然后还有像 Orland 这种比较诡异的例子

3273
01:47:31,000 --> 01:47:33,000
但它是非常独特的一种机制

3274
01:47:33,000 --> 01:47:36,000
它里面的线程

3275
01:47:36,000 --> 01:47:37,000
不是系统的线程

3276
01:47:37,000 --> 01:47:38,000
它是自己内置的线程

3277
01:47:38,000 --> 01:47:41,000
它也并不是一个协程

3278
01:47:41,000 --> 01:47:42,000
它每个线程都是完全独立

3279
01:47:42,000 --> 01:47:46,000
就是没有任何和其他共享资源的地方

3280
01:47:46,000 --> 01:47:49,000
就是它的调度器是可以很方便的

3281
01:47:49,000 --> 01:47:53,000
去管理它的那些执行的步骤

3282
01:47:53,000 --> 01:47:54,000
他们叫做 Eduction

3283
01:47:54,000 --> 01:47:55,000
这么一个步骤的

3284
01:47:56,000 --> 01:47:56,000
对

3285
01:47:56,000 --> 01:47:57,000
Orland 我虽然不是很了解

3286
01:47:57,000 --> 01:48:00,000
但我觉得它的思路基本上就是把

3287
01:48:00,000 --> 01:48:03,000
Thread 当做一种语言内在的机制

3288
01:48:03,000 --> 01:48:06,000
而不是对操作系统提供的机制的

3289
01:48:06,000 --> 01:48:08,000
一种抽象

3290
01:48:08,000 --> 01:48:08,000
没错

3291
01:48:09,000 --> 01:48:12,000
因为它使用的 Actor model

3292
01:48:12,000 --> 01:48:13,000
Actor 模型

3293
01:48:13,000 --> 01:48:15,000
对这种事情是有天然的需求的

3294
01:48:15,000 --> 01:48:18,000
而且它整个调度器也好

3295
01:48:18,000 --> 01:48:19,000
解析器也好

3296
01:48:19,000 --> 01:48:21,000
为这种方式去优化的

3297
01:48:21,000 --> 01:48:23,000
虽然说它的可能

3298
01:48:23,000 --> 01:48:25,000
就是直体某一个这种

3299
01:48:25,000 --> 01:48:26,000
就是所谓的

3300
01:48:26,000 --> 01:48:29,000
就 CPU heavy 的东西的性能不怎么样

3301
01:48:29,000 --> 01:48:30,000
但是它对这种

3302
01:48:30,000 --> 01:48:32,000
可以并行计算的任务的处理

3303
01:48:32,000 --> 01:48:34,000
是非常优秀的

3304
01:48:34,000 --> 01:48:35,000
没错

3305
01:48:37,000 --> 01:48:37,000
对

3306
01:48:37,000 --> 01:48:39,000
其实我现在学 Haskell

3307
01:48:39,000 --> 01:48:40,000
终于开始

3308
01:48:40,000 --> 01:48:41,000
或者说终于又开始

3309
01:48:41,000 --> 01:48:43,000
为什么突然有这个契机去学它

3310
01:48:44,000 --> 01:48:45,000
我也不知道

3311
01:48:45,000 --> 01:48:47,000
就是可能主要契机

3312
01:48:47,000 --> 01:48:49,000
还是因为之前看的那个

3313
01:48:49,000 --> 01:48:52,000
Object C 的 blog

3314
01:48:53,000 --> 01:48:56,000
他们受其蛊惑对不对

3315
01:48:56,000 --> 01:48:58,000
对他们提供了大量的

3316
01:48:59,000 --> 01:49:00,000
奇迹隐巧

3317
01:49:00,000 --> 01:49:02,000
就是为了让你写 Swift 的时候

3318
01:49:02,000 --> 01:49:03,000
看起来更像 Haskell

3319
01:49:03,000 --> 01:49:04,000
我觉得何必呢

3320
01:49:04,000 --> 01:49:06,000
那我干脆去学一下 Haskell

3321
01:49:06,000 --> 01:49:11,000
但这样的尝试已经有过很多次

3322
01:49:11,000 --> 01:49:12,000
但每次都没有坚持下来

3323
01:49:12,000 --> 01:49:14,000
我觉得这次应该坚持坚持

3324
01:49:15,000 --> 01:49:16,000
然后在那之后

3325
01:49:16,000 --> 01:49:17,000
也许可以试试 AirLong

3326
01:49:18,000 --> 01:49:21,000
因为在我北边有一个城市

3327
01:49:21,000 --> 01:49:22,000
叫做 AirLongan

3328
01:49:23,000 --> 01:49:26,000
我以前写过一个写归桥推

3329
01:49:26,000 --> 01:49:28,000
就是说 AirLongan 这个地方

3330
01:49:28,000 --> 01:49:32,000
就是由二战时期被纳粹集中在一起的

3331
01:49:32,000 --> 01:49:34,000
AirLongan 程序建立的

3332
01:49:34,000 --> 01:49:35,000
所以它叫做 AirLongan

3333
01:49:35,000 --> 01:49:38,000
在德语里面就是使用 AirLongan 编程的意思

3334
01:49:39,000 --> 01:49:40,000
对

3335
01:49:40,000 --> 01:49:42,000
AirLongan 在德语里面什么意思

3336
01:49:42,000 --> 01:49:43,000
没有意义吗

3337
01:49:43,000 --> 01:49:44,000
还是只是个名字而已

3338
01:49:45,000 --> 01:49:47,000
没有什么意义吧

3339
01:49:47,000 --> 01:49:50,000
就至少我找不出什么特别

3340
01:49:51,000 --> 01:49:53,000
至少我想不到什么特别明显的语言

3341
01:49:53,000 --> 01:49:54,000
我回头会去查查 Etymology

3342
01:49:54,000 --> 01:49:56,000
但我基本上可以确定 AirLongan

3343
01:49:56,000 --> 01:49:59,000
跟 AirLongan 没有任何关系

3344
01:49:59,000 --> 01:50:00,000
因为 AirLongan 里面

3345
01:50:00,000 --> 01:50:01,000
那个语言很简单

3346
01:50:01,000 --> 01:50:04,000
是那个爱迪信的实验室做的语言

3347
01:50:04,000 --> 01:50:05,000
叫做 Arxon Language

3348
01:50:05,000 --> 01:50:06,000
所以是 AirLongan

3349
01:50:07,000 --> 01:50:08,000
原来是这么来的

3350
01:50:08,000 --> 01:50:09,000
你不知道

3351
01:50:09,000 --> 01:50:10,000
不知道

3352
01:50:10,000 --> 01:50:13,000
就我觉得 AirLongan 了解非常非常有限

3353
01:50:13,000 --> 01:50:14,000
对它就是这么样

3354
01:50:14,000 --> 01:50:15,000
而且还有一个

3355
01:50:15,000 --> 01:50:17,000
这个可能之后有一期

3356
01:50:17,000 --> 01:50:18,000
专门讲 AirLongan 的时候再说

3357
01:50:19,000 --> 01:50:20,000
还有一个很有意思的

3358
01:50:21,000 --> 01:50:24,000
看起来甚至有点 weird 的一个短视频

3359
01:50:24,000 --> 01:50:26,000
非常有意思

3360
01:50:27,000 --> 01:50:27,000
就是他们

3361
01:50:27,000 --> 01:50:29,000
因为 AirLongan 最开始的用途

3362
01:50:29,000 --> 01:50:30,000
是用于做那个

3363
01:50:30,000 --> 01:50:31,000
叫做什么

3364
01:50:31,000 --> 01:50:32,000
电话交换机的控制

3365
01:50:33,000 --> 01:50:33,000
对

3366
01:50:33,000 --> 01:50:34,000
控制拨号

3367
01:50:34,000 --> 01:50:35,000
然后怎么怎么样

3368
01:50:35,000 --> 01:50:36,000
然后他就用

3369
01:50:36,000 --> 01:50:36,000
他的那个视频

3370
01:50:36,000 --> 01:50:38,000
就整个过程都在描述

3371
01:50:38,000 --> 01:50:40,000
这么一个过程中

3372
01:50:40,000 --> 01:50:42,000
这个 AirLongan 是怎么样起作用的

3373
01:50:42,000 --> 01:50:43,000
非常好笑的一个视频

3374
01:50:43,000 --> 01:50:44,000
一定要看一下

3375
01:50:45,000 --> 01:50:47,000
有一种 Montey Python 的即视感

3376
01:50:48,000 --> 01:50:48,000
啊哈

3377
01:50:48,000 --> 01:50:49,000
有意思

3378
01:50:50,000 --> 01:50:51,000
所以处理电话拨号

3379
01:50:51,000 --> 01:50:52,000
其实是

3380
01:50:52,000 --> 01:50:53,000
听起来也是一个

3381
01:50:53,000 --> 01:50:57,000
天生就带有并发性质的问题领域

3382
01:50:57,000 --> 01:50:58,000
嗯哼

3383
01:50:58,000 --> 01:50:58,000
没错

3384
01:50:59,000 --> 01:50:59,000
对

3385
01:50:59,000 --> 01:51:02,000
所以在从这样一种领域里面

3386
01:51:02,000 --> 01:51:04,000
为了解决这样一个领域的问题

3387
01:51:04,000 --> 01:51:06,000
而诞生的变成语言

3388
01:51:06,000 --> 01:51:08,000
也就天生的非常强调

3389
01:51:09,000 --> 01:51:11,000
解决这种问题的方便程度

3390
01:51:11,000 --> 01:51:12,000
嗯哼

3391
01:51:13,000 --> 01:51:14,000
而且我觉得他

3392
01:51:14,000 --> 01:51:15,000
他这个

3393
01:51:15,000 --> 01:51:16,000
就是 AirLongan 他这种方式

3394
01:51:16,000 --> 01:51:17,000
而且采用他

3395
01:51:17,000 --> 01:51:18,000
他采用的这种

3396
01:51:18,000 --> 01:51:19,000
像 Actual Model 也好

3397
01:51:19,000 --> 01:51:21,000
和他自己这种调度器也好

3398
01:51:21,000 --> 01:51:23,000
他有一个很

3399
01:51:23,000 --> 01:51:24,000
成熟的

3400
01:51:24,000 --> 01:51:25,000
叫做监控的系统

3401
01:51:25,000 --> 01:51:27,000
Supervision System

3402
01:51:27,000 --> 01:51:28,000
叫做 OTP 嘛

3403
01:51:28,000 --> 01:51:30,000
就是 Open Telecom Platform

3404
01:51:30,000 --> 01:51:32,000
开放电信平台

3405
01:51:32,000 --> 01:51:33,000
听起来很怪啊

3406
01:51:33,000 --> 01:51:34,000
为什么会是电信

3407
01:51:34,000 --> 01:51:35,000
听起来非常电信

3408
01:51:35,000 --> 01:51:36,000
对

3409
01:51:36,000 --> 01:51:37,000
听起来非常爱理性

3410
01:51:37,000 --> 01:51:38,000
对

3411
01:51:38,000 --> 01:51:39,000
但是他

3412
01:51:39,000 --> 01:51:40,000
但是他确实是解决了很多

3413
01:51:40,000 --> 01:51:42,000
这种大型软件工程的一些问题

3414
01:51:42,000 --> 01:51:43,000
比如说

3415
01:51:43,000 --> 01:51:44,000
他里面的所有的那些

3416
01:51:44,000 --> 01:51:46,000
那些就是现成嘛

3417
01:51:46,000 --> 01:51:47,000
我们叫做 Actor 也好

3418
01:51:47,000 --> 01:51:48,000
他是随时可以

3419
01:51:48,000 --> 01:51:49,000
可以让他

3420
01:51:49,000 --> 01:51:51,000
就是他的错误处理机制是不处理

3421
01:51:51,000 --> 01:51:52,000
让他 Crush 掉

3422
01:51:53,000 --> 01:51:53,000
嗯

3423
01:51:53,000 --> 01:51:54,000
然后

3424
01:51:54,000 --> 01:51:56,000
Crush 掉之后怎么办呢

3425
01:51:56,000 --> 01:51:57,000
他每一个 Actor

3426
01:51:57,000 --> 01:51:59,000
他会为他分配一个叫做

3427
01:51:59,000 --> 01:52:00,000
Supervisor

3428
01:52:00,000 --> 01:52:02,000
Supervisor 就是监管管理者

3429
01:52:03,000 --> 01:52:04,000
然后这个管理者

3430
01:52:04,000 --> 01:52:05,000
不叫不叫每一个

3431
01:52:05,000 --> 01:52:05,000
不是不是

3432
01:52:05,000 --> 01:52:06,000
就是说

3433
01:52:06,000 --> 01:52:07,000
嗯

3434
01:52:07,000 --> 01:52:08,000
这里说错了

3435
01:52:08,000 --> 01:52:09,000
应该重新讲一下

3436
01:52:09,000 --> 01:52:09,000
应该说

3437
01:52:09,000 --> 01:52:11,000
他里面每一个 Actor

3438
01:52:11,000 --> 01:52:13,000
都是被一个 Supervisor 管理的

3439
01:52:13,000 --> 01:52:15,000
如果这个 Supervisor 探测到

3440
01:52:15,000 --> 01:52:16,000
那个 Actor 挂掉了

3441
01:52:16,000 --> 01:52:17,000
他就会或者死掉了

3442
01:52:17,000 --> 01:52:20,000
他就会重新再起一个一模一样的

3443
01:52:21,000 --> 01:52:23,000
然后他里面整个这种

3444
01:52:23,000 --> 01:52:25,000
这一套思维哲学是非常

3445
01:52:25,000 --> 01:52:25,000
非常

3446
01:52:25,000 --> 01:52:26,000
嗯

3447
01:52:26,000 --> 01:52:27,000
很不一样

3448
01:52:27,000 --> 01:52:28,000
而且你

3449
01:52:28,000 --> 01:52:29,000
到目前为止

3450
01:52:29,000 --> 01:52:30,000
我们做那种

3451
01:52:30,000 --> 01:52:32,000
很多这种像做那种大规模的

3452
01:52:32,000 --> 01:52:34,000
分模式系统的维护的时候会发现

3453
01:52:34,000 --> 01:52:36,000
越你做的系统越大

3454
01:52:36,000 --> 01:52:37,000
你越会

3455
01:52:37,000 --> 01:52:39,000
你的那个什么整个架构

3456
01:52:39,000 --> 01:52:40,000
会越靠近像那个

3457
01:52:40,000 --> 01:52:42,000
Earlans 这套模型来讲

3458
01:52:42,000 --> 01:52:43,000
比如说很简单的一个

3459
01:52:43,000 --> 01:52:45,000
那个 Google 的那个例子吧

3460
01:52:45,000 --> 01:52:46,000
因为 Google 它说

3461
01:52:46,000 --> 01:52:48,000
它们就是传统上我们做这种

3462
01:52:48,000 --> 01:52:49,000
服务器软件

3463
01:52:49,000 --> 01:52:50,000
我们都要考虑说

3464
01:52:50,000 --> 01:52:52,000
我们这个服务器不要挂掉

3465
01:52:52,000 --> 01:52:54,000
我们要让他稳定可靠

3466
01:52:54,000 --> 01:52:54,000
对吧

3467
01:52:54,000 --> 01:52:56,000
就好像我们说这个服务器的

3468
01:52:56,000 --> 01:52:57,000
可靠性要高于工作站的

3469
01:52:57,000 --> 01:53:00,000
工作站的可靠性要高于这种个人 PC 的

3470
01:53:00,000 --> 01:53:02,000
但是你为了换取那更高的可靠性

3471
01:53:02,000 --> 01:53:03,000
你要付出更高的成本

3472
01:53:03,000 --> 01:53:05,000
就单位硬件和单位计算能力的成本

3473
01:53:05,000 --> 01:53:06,000
也是要上去了

3474
01:53:06,000 --> 01:53:07,000
然后 Google 当年的

3475
01:53:07,000 --> 01:53:08,000
做法就是说

3476
01:53:08,000 --> 01:53:11,000
啊我们做大规模的这种

3477
01:53:11,000 --> 01:53:12,000
这种服务端

3478
01:53:12,000 --> 01:53:13,000
我们不需要用这种

3479
01:53:13,000 --> 01:53:14,000
所谓的服务

3480
01:53:14,000 --> 01:53:16,000
就 server grade hardware

3481
01:53:16,000 --> 01:53:17,000
就是服务器级别的硬件

3482
01:53:17,000 --> 01:53:18,000
什么

3483
01:53:18,000 --> 01:53:19,000
高档处理器啊

3484
01:53:19,000 --> 01:53:20,000
或者是高档机房啊

3485
01:53:20,000 --> 01:53:21,000
这种东西

3486
01:53:21,000 --> 01:53:22,000
我们就用普通的所谓的

3487
01:53:22,000 --> 01:53:23,000
commodity hardware

3488
01:53:23,000 --> 01:53:24,000
就是说

3489
01:53:24,000 --> 01:53:26,000
随速可见的

3490
01:53:26,000 --> 01:53:27,000
拓收可得

3491
01:53:27,000 --> 01:53:28,000
普通迪迟

3492
01:53:28,000 --> 01:53:29,000
就普通迪迟

3493
01:53:29,000 --> 01:53:30,000
就可以随意提换的机器

3494
01:53:30,000 --> 01:53:31,000
然后

3495
01:53:31,000 --> 01:53:32,000
他虽然说他的那个故障率

3496
01:53:32,000 --> 01:53:34,000
要比这种所谓的

3497
01:53:34,000 --> 01:53:35,000
服务器级别硬件要高

3498
01:53:35,000 --> 01:53:38,000
但是我们只要把软件的容错写好

3499
01:53:38,000 --> 01:53:41,000
我们他随时挂掉任何几个机器

3500
01:53:41,000 --> 01:53:42,000
都是没有

3501
01:53:42,000 --> 01:53:43,000
不影响我们这个系统

3502
01:53:43,000 --> 01:53:44,000
整个系统运作的嘛

3503
01:53:44,000 --> 01:53:46,000
然后你要实现这一点

3504
01:53:46,000 --> 01:53:48,000
你就会发现你会

3505
01:53:48,000 --> 01:53:49,000
越来越的类似

3506
01:53:49,000 --> 01:53:49,000
用到类似于

3507
01:53:49,000 --> 01:53:51,000
二连的那种机制

3508
01:53:51,000 --> 01:53:52,000
要去监控

3509
01:53:52,000 --> 01:53:53,000
然后要去

3510
01:53:53,000 --> 01:53:54,000
呃

3511
01:53:54,000 --> 01:53:56,000
假设错误是不可恢复的

3512
01:53:56,000 --> 01:53:57,000
然后你如果遇到错误

3513
01:53:57,000 --> 01:53:59,000
你就要重新起一个新的节点

3514
01:53:59,000 --> 01:54:00,000
来接替

3515
01:54:00,000 --> 01:54:02,000
之前挂掉的那些节点的工作

3516
01:54:02,000 --> 01:54:03,000
诸如此类的事情

3517
01:54:04,000 --> 01:54:05,000
对

3518
01:54:05,000 --> 01:54:07,000
这我脑中浮现出了

3519
01:54:07,000 --> 01:54:09,000
早期电话系统那种

3520
01:54:09,000 --> 01:54:09,000
呃

3521
01:54:09,000 --> 01:54:11,000
一排接线机器

3522
01:54:11,000 --> 01:54:12,000
前面坐着一大

3523
01:54:12,000 --> 01:54:15,000
呃坐着很多接线员的场景

3524
01:54:15,000 --> 01:54:16,000
然后

3525
01:54:16,000 --> 01:54:18,000
那个 super ss 那边看说

3526
01:54:18,000 --> 01:54:20,000
这个接线员

3527
01:54:20,000 --> 01:54:21,000
累倒在了工作岗位上

3528
01:54:21,000 --> 01:54:22,000
立刻把他撤走

3529
01:54:22,000 --> 01:54:24,000
换另外一个来插

3530
01:54:24,000 --> 01:54:25,000
插线图

3531
01:54:25,000 --> 01:54:25,000
感觉是谁

3532
01:54:25,000 --> 01:54:26,000
学汉工厂

3533
01:54:26,000 --> 01:54:27,000
没错

3534
01:54:27,000 --> 01:54:29,000
其实这也就

3535
01:54:29,000 --> 01:54:30,000
说到这个也就

3536
01:54:30,000 --> 01:54:33,000
想到上一期我们跟莫洋聊的

3537
01:54:33,000 --> 01:54:34,000
说他们我们

3538
01:54:34,000 --> 01:54:36,000
你们学 hasko

3539
01:54:36,000 --> 01:54:37,000
的动机是什么

3540
01:54:37,000 --> 01:54:38,000
那

3541
01:54:38,000 --> 01:54:39,000
或者说

3542
01:54:39,000 --> 01:54:40,000
那学

3543
01:54:40,000 --> 01:54:40,000
那我觉得可以

3544
01:54:40,000 --> 01:54:41,000
把这个问题

3545
01:54:41,000 --> 01:54:43,000
泛化为学 allen

3546
01:54:43,000 --> 01:54:44,000
或者是 hasko 这种比较

3547
01:54:45,000 --> 01:54:48,000
家瘾号小众的辩证语言

3548
01:54:48,000 --> 01:54:49,000
他的

3549
01:54:49,000 --> 01:54:51,000
他的比较比较功利的一个

3550
01:54:51,000 --> 01:54:52,000
一个效果就是

3551
01:54:52,000 --> 01:54:54,000
你可能会发现

3552
01:54:54,000 --> 01:54:56,000
当你需要解决一个

3553
01:54:56,000 --> 01:54:57,000
特定领域的问题的时候

3554
01:54:57,000 --> 01:55:00,000
你会发现在这种比较小众的语言里面

3555
01:55:00,000 --> 01:55:01,000
已经有了相当好的解决方案

3556
01:55:01,000 --> 01:55:02,000
已经有了

3557
01:55:04,000 --> 01:55:06,000
已经有先人

3558
01:55:06,000 --> 01:55:08,000
是对此深思熟虑过

3559
01:55:08,000 --> 01:55:09,000
并且

3560
01:55:09,000 --> 01:55:11,000
设计出了一个非常好的模型

3561
01:55:11,000 --> 01:55:12,000
那么当你在

3562
01:55:13,000 --> 01:55:14,000
当你在用你的

3563
01:55:14,000 --> 01:55:17,000
所谓原生语言去解决他的时候

3564
01:55:17,000 --> 01:55:18,000
就会方便的

3565
01:55:18,000 --> 01:55:19,000
对

3566
01:55:19,000 --> 01:55:21,000
就甚至说你不一定真的用到

3567
01:55:21,000 --> 01:55:22,000
这个语言的

3568
01:55:22,000 --> 01:55:23,000
具体的实现

3569
01:55:23,000 --> 01:55:25,000
甚至你都不会用这个语言去写

3570
01:55:25,000 --> 01:55:27,000
去写新的代码

3571
01:55:27,000 --> 01:55:28,000
但是你从

3572
01:55:28,000 --> 01:55:29,000
这里面学到的这种思想

3573
01:55:29,000 --> 01:55:31,000
可能会有助于

3574
01:55:31,000 --> 01:55:32,000
你在现有的工作中

3575
01:55:32,000 --> 01:55:33,000
去提升你的这个

3576
01:55:33,000 --> 01:55:35,000
架构的能力也好

3577
01:55:35,000 --> 01:55:36,000
或者说是你去抽象事物的能力

3578
01:55:36,000 --> 01:55:37,000
你会发现

3579
01:55:37,000 --> 01:55:39,000
原来还可以从这个角度去思考问题

3580
01:55:39,000 --> 01:55:40,000
对吧

3581
01:55:40,000 --> 01:55:41,000
对

3582
01:55:41,000 --> 01:55:42,000
这个是为什么

3583
01:55:42,000 --> 01:55:43,000
人要去做

3584
01:55:43,000 --> 01:55:45,000
你要去努力做一个 polyglot

3585
01:55:45,000 --> 01:55:46,000
这就好像你多学一个

3586
01:55:47,000 --> 01:55:48,000
捷克有个谚语

3587
01:55:48,000 --> 01:55:50,000
就是你会几种语言

3588
01:55:50,000 --> 01:55:51,000
你就有几种人生

3589
01:55:51,000 --> 01:55:52,000
所以

3590
01:55:54,000 --> 01:55:55,000
编程领域其实也是这样的

3591
01:55:55,000 --> 01:55:56,000
你会几种语言

3592
01:55:56,000 --> 01:55:57,000
你就可以

3593
01:55:57,000 --> 01:55:58,000
你就多几种语言

3594
01:55:58,000 --> 01:56:00,000
你就可以多理解几种编程模型

3595
01:56:01,000 --> 01:56:03,000
称赐多态才是美

3596
01:56:03,000 --> 01:56:04,000
这里又提前出来了

3597
01:56:04,000 --> 01:56:05,000
没错

3598
01:56:08,000 --> 01:56:08,000
差不多了

3599
01:56:09,000 --> 01:56:09,000
好吧

3600
01:56:09,000 --> 01:56:10,000
今天

3601
01:56:10,000 --> 01:56:11,000
你也结尾一下吧

3602
01:56:13,000 --> 01:56:14,000
对

3603
01:56:14,000 --> 01:56:17,000
所以今天我们大概就讲述了

3604
01:56:17,000 --> 01:56:19,000
当然可能不是非常的满意

3605
01:56:19,000 --> 01:56:20,000
因为做了很多

3606
01:56:21,000 --> 01:56:26,000
解释一些比较复杂的问题的尝试

3607
01:56:26,000 --> 01:56:28,000
但是都没有能

3608
01:56:28,000 --> 01:56:29,000
不巧失败了

3609
01:56:29,000 --> 01:56:30,000
对

3610
01:56:30,000 --> 01:56:31,000
都没有能做得很好

3611
01:56:31,000 --> 01:56:32,000
这可能也从另外一个侧面子

3612
01:56:32,000 --> 01:56:33,000
反映出了

3613
01:56:35,000 --> 01:56:36,000
并发和异步

3614
01:56:36,000 --> 01:56:38,000
其实的确是

3615
01:56:38,000 --> 01:56:41,000
在编程领域比较难的一些问题

3616
01:56:42,000 --> 01:56:45,000
当然也有可能说是我们两个太水

3617
01:56:45,000 --> 01:56:46,000
这是肯定的

3618
01:56:47,000 --> 01:56:48,000
我从来不怀疑

3619
01:56:48,000 --> 01:56:49,000
那句话怎么说来着

3620
01:56:49,000 --> 01:56:50,000
就是说

3621
01:56:50,000 --> 01:56:52,000
如果你能够

3622
01:56:52,000 --> 01:56:53,000
用几句话的东西

3623
01:56:53,000 --> 01:56:54,000
就能给人家

3624
01:56:54,000 --> 01:56:56,000
或者说你能够很清晰明白的

3625
01:56:56,000 --> 01:56:57,000
给人家解释一个东西

3626
01:56:57,000 --> 01:56:59,000
那么你对这个事情的理解

3627
01:56:59,000 --> 01:57:00,000
就肯定是比较透彻的

3628
01:57:00,000 --> 01:57:01,000
但如果你解释不了

3629
01:57:01,000 --> 01:57:02,000
很有可能是你自己理解的

3630
01:57:02,000 --> 01:57:03,000
还不够深刻

3631
01:57:04,000 --> 01:57:04,000
对

3632
01:57:04,000 --> 01:57:06,000
就是有很多东西都会

3633
01:57:06,000 --> 01:57:07,000
有这样一个阶段

3634
01:57:07,000 --> 01:57:08,000
就是你以为自己懂了

3635
01:57:08,000 --> 01:57:10,000
但是当你要

3636
01:57:10,000 --> 01:57:11,000
向别人解释的时候

3637
01:57:11,000 --> 01:57:13,000
会发现自己其实并不是真的理解

3638
01:57:15,000 --> 01:57:15,000
对

3639
01:57:15,000 --> 01:57:17,000
从这个侧面来说

3640
01:57:17,000 --> 01:57:18,000
我觉得可能做 podcast

3641
01:57:18,000 --> 01:57:19,000
对

3642
01:57:20,000 --> 01:57:20,000
不知道你

3643
01:57:20,000 --> 01:57:21,000
但对我来说

3644
01:57:21,000 --> 01:57:22,000
也是一个非常大的帮助

3645
01:57:22,000 --> 01:57:23,000
就是

3646
01:57:25,000 --> 01:57:26,000
就像之前我在知乎答案里面

3647
01:57:26,000 --> 01:57:27,000
说过的那样

3648
01:57:27,000 --> 01:57:28,000
就是非常

3649
01:57:29,000 --> 01:57:32,000
帮助我去把自己之前

3650
01:57:32,000 --> 01:57:34,000
可能一知半解的部分

3651
01:57:34,000 --> 01:57:36,000
弄得比较二知一解

3652
01:57:36,000 --> 01:57:37,000
就是

3653
01:57:38,000 --> 01:57:38,000
把它

3654
01:57:39,000 --> 01:57:39,000
为了像

3655
01:57:39,000 --> 01:57:40,000
为了做好一些节目

3656
01:57:40,000 --> 01:57:42,000
可能会去看一些相关的书

3657
01:57:42,000 --> 01:57:43,000
这些

3658
01:57:43,000 --> 01:57:44,000
对于我来说

3659
01:57:44,000 --> 01:57:45,000
也是非常大的帮助

3660
01:57:46,000 --> 01:57:46,000
不光是这个

3661
01:57:47,000 --> 01:57:49,000
不管你是在说

3662
01:57:49,000 --> 01:57:50,000
就是口述也好

3663
01:57:50,000 --> 01:57:51,000
还是说笔头写下来也好

3664
01:57:52,000 --> 01:57:54,000
你整个在输出的过程

3665
01:57:54,000 --> 01:57:56,000
其实就是在考验你内部的

3666
01:57:57,000 --> 01:57:59,000
知识的组织也好

3667
01:57:59,000 --> 01:58:00,000
还是你的理解也好

3668
01:58:00,000 --> 01:58:00,000
对吧

3669
01:58:00,000 --> 01:58:01,000
都是它对于是一个

3670
01:58:02,000 --> 01:58:04,000
是一个使用的过程

3671
01:58:04,000 --> 01:58:05,000
这个时候你会发现

3672
01:58:05,000 --> 01:58:07,000
如果你的对某一点理解

3673
01:58:07,000 --> 01:58:08,000
不够透彻的话

3674
01:58:08,000 --> 01:58:10,000
你就是没有办法解释清楚的

3675
01:58:10,000 --> 01:58:11,000
对

3676
01:58:11,000 --> 01:58:14,000
所以也希望这一期节目

3677
01:58:14,000 --> 01:58:16,000
能够起到炮转眼的作用

3678
01:58:16,000 --> 01:58:18,000
如果哪位听众对于

3679
01:58:19,000 --> 01:58:21,000
异部和

3680
01:58:21,000 --> 01:58:23,000
并发有比较深刻的理解

3681
01:58:23,000 --> 01:58:24,000
然后觉得

3682
01:58:25,000 --> 01:58:26,000
一些我们没有讲清楚

3683
01:58:26,000 --> 01:58:28,000
但是讲错的概念可以

3684
01:58:28,000 --> 01:58:29,000
值得纠正的话

3685
01:58:29,000 --> 01:58:31,000
那也欢迎你写信给我们

3686
01:58:31,000 --> 01:58:31,000
我们的

3687
01:58:34,000 --> 01:58:37,000
电子邮件地址是 kernelpanicatipn.ly

3688
01:58:38,000 --> 01:58:40,000
然后也欢迎你拨打我们的热线电话

3689
01:58:40,000 --> 01:58:42,000
0118999881999

3690
01:58:42,000 --> 01:58:44,000
91197253

3691
01:58:47,000 --> 01:58:48,000
好

3692
01:58:48,000 --> 01:58:49,000
如果你非常喜欢我们的节目

3693
01:58:49,000 --> 01:58:52,000
或者说不管你是不是喜欢我们的节目

3694
01:58:52,000 --> 01:58:53,000
都欢迎你为我们捐款

3695
01:58:54,000 --> 01:58:58,000
捐款的地址是 kernelpanic.fm.donate

3696
01:58:59,000 --> 01:59:00,000
D-O-N-A-T

3697
01:59:00,000 --> 01:59:01,000
金额随意

3698
01:59:01,000 --> 01:59:02,000
但必须是

3699
01:59:02,000 --> 01:59:05,000
可以被 8 整除的正整数

3700
01:59:05,000 --> 01:59:11,000
然后为了向现代自动机的基础组成 byte 致敬

3701
01:59:11,000 --> 01:59:13,000
我们把它设定为

3702
01:59:14,000 --> 01:59:15,000
至少要被 8 整除

3703
01:59:17,000 --> 01:59:17,000
好吧

3704
01:59:17,000 --> 01:59:18,000
那今天就到这了

3705
01:59:19,000 --> 01:59:19,000
OK

3706
01:59:20,000 --> 01:59:21,000
对

3707
01:59:21,000 --> 01:59:22,000
那就是我们下期再见

3708
01:59:22,000 --> 01:59:23,000
拜拜

