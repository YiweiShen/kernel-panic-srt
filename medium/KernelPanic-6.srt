1
00:00:00,000 --> 00:00:04,000
大家好,欢迎收听第六期的内核恐慌,我是 Rail

2
00:00:04,000 --> 00:00:05,000
我是吴涛

3
00:00:05,000 --> 00:00:10,000
在今天节目开始之前,我们先做一下上期的反馈吧

4
00:00:10,000 --> 00:00:11,000
好呀

5
00:00:11,000 --> 00:00:14,000
吴涛你又念错字了

6
00:00:14,000 --> 00:00:22,000
对,反正上次我念了一个以实听众

7
00:00:22,000 --> 00:00:26,000
在这里向大家鞠一躬,各位听众,对不起,我不应该吃你们

8
00:00:27,000 --> 00:00:34,000
那个字念想,左边一个乡村的乡,右边一个食物的食

9
00:00:34,000 --> 00:00:39,000
这个字念以想听众,以把什么东西供奉给听众吃

10
00:00:39,000 --> 00:00:41,000
吃掉听众是吧?

11
00:00:41,000 --> 00:00:43,000
对

12
00:00:43,000 --> 00:00:44,000
你是螳螂吗?

13
00:00:44,000 --> 00:00:47,000
螳螂只有在交配的处

14
00:00:47,000 --> 00:00:53,000
其实这个事情我觉得也可以理解吧

15
00:00:53,000 --> 00:00:56,000
这个字如果让我来念,我估计也会看

16
00:00:56,000 --> 00:01:01,000
你想左边那么小,右边那么大,应该念右边吧

17
00:01:01,000 --> 00:01:08,000
对呀,而且就才念字,念半边嘛

18
00:01:08,000 --> 00:01:14,000
其实中文有这点不好,经常有这种所谓的什么规律嘛

19
00:01:14,000 --> 00:01:17,000
如果你不认识这个字,你可以看看有没有偏旁不守啊

20
00:01:17,000 --> 00:01:21,000
说一般是什么,一边行旁,一个身旁对吧

21
00:01:21,000 --> 00:01:23,000
线 8,给你一个

22
00:01:23,000 --> 00:01:29,000
中文还是在,我们现在身处在一个中文从象形文字

23
00:01:29,000 --> 00:01:31,000
向平原文字的过渡过程中

24
00:01:31,000 --> 00:01:33,000
但是这个过渡可能永远不会实现了

25
00:01:33,000 --> 00:01:37,000
因为毕竟现在汉字已经是一种文化硅保

26
00:01:37,000 --> 00:01:42,000
它是永远不可能实现假名话了

27
00:01:42,000 --> 00:01:48,000
所以你默默的是支持这件事情的是吧?

28
00:01:48,000 --> 00:01:49,000
也没有吧

29
00:01:49,000 --> 00:01:55,000
但拉丁话方案,汉字拉丁话那么激进的方案

30
00:01:55,000 --> 00:02:02,000
也不是都没有实现,就让人觉得非常受不了了

31
00:02:02,000 --> 00:02:06,000
我觉得拉丁话在逻辑上已经实现了

32
00:02:06,000 --> 00:02:08,000
这在事实上已经成立了

33
00:02:08,000 --> 00:02:10,000
你说用拼书法吧

34
00:02:10,000 --> 00:02:13,000
对呀,经常会有那种

35
00:02:13,000 --> 00:02:17,000
现在网络上一些用语不方便直接讲的时候

36
00:02:17,000 --> 00:02:20,000
我都会在后面注意一下拼音

37
00:02:20,000 --> 00:02:23,000
然后大家读一下都知道那个是什么意思

38
00:02:23,000 --> 00:02:29,000
对,而且反正是越来越没有人写字了

39
00:02:29,000 --> 00:02:30,000
这是肯定的

40
00:02:30,000 --> 00:02:35,000
当然我还在 07 年

41
00:02:35,000 --> 00:02:36,000
反正 iPhone 出现之前

42
00:02:36,000 --> 00:02:40,000
我还坚持用过 Logia 上面的壁画输入法

43
00:02:40,000 --> 00:02:42,000
我觉得至少这样可以让我

44
00:02:42,000 --> 00:02:45,000
是那个九宫阁那个吗?

45
00:02:45,000 --> 00:02:46,000
对,九宫阁的壁画输入法

46
00:02:46,000 --> 00:02:48,000
其实我一直觉得那个还蛮好的

47
00:02:48,000 --> 00:02:49,000
叫什么 T 9 吧是不是

48
00:02:51,000 --> 00:02:53,000
好像是叫 T 9

49
00:02:53,000 --> 00:02:54,000
T 9 是拼音吧

50
00:02:54,000 --> 00:02:54,000
不是吗?

51
00:02:54,000 --> 00:02:55,000
是吗?T 9 是拼音吗?

52
00:02:55,000 --> 00:02:56,000
OK

53
00:02:56,000 --> 00:02:58,000
我不记得,不确定

54
00:02:58,000 --> 00:03:01,000
但我记得那个输入法只要有五个简而已吧

55
00:03:01,000 --> 00:03:02,000
就是横竖撇蜡

56
00:03:02,000 --> 00:03:04,000
横竖撇蜡

57
00:03:04,000 --> 00:03:08,000
撇就是右上到左下

58
00:03:08,000 --> 00:03:10,000
然后横然后竖

59
00:03:10,000 --> 00:03:12,000
我觉得那个输入法真的挺好的

60
00:03:12,000 --> 00:03:15,000
对,它解决了我很多的倒插笔问题

61
00:03:15,000 --> 00:03:16,000
比如说

62
00:03:16,000 --> 00:03:17,000
什么是倒插笔?

63
00:03:18,000 --> 00:03:24,000
就是一个汉字的笔顺和官方规定的不一样

64
00:03:24,000 --> 00:03:26,000
然后这样我就打不出来

65
00:03:26,000 --> 00:03:27,000
比如说女的女字吧

66
00:03:27,000 --> 00:03:28,000
好像对对对

67
00:03:28,000 --> 00:03:31,000
然后我十次有九次打不出来

68
00:03:31,000 --> 00:03:32,000
所以那个笔画是什么

69
00:03:32,000 --> 00:03:34,000
应该是撇辙再撇

70
00:03:34,000 --> 00:03:35,000
然后最后一横是吧?

71
00:03:36,000 --> 00:03:37,000
我现在又不记得

72
00:03:37,000 --> 00:03:38,000
也可能是先写横

73
00:03:38,000 --> 00:03:40,000
对,反正

74
00:03:40,000 --> 00:03:42,000
对,然后还有那个所有带走枝旁的字

75
00:03:42,000 --> 00:03:44,000
我全都先写走枝对吧

76
00:03:45,000 --> 00:03:46,000
不是,这合理啊

77
00:03:46,000 --> 00:03:49,000
你先把周围的框画出来

78
00:03:49,000 --> 00:03:50,000
然后站在那边描那个小的

79
00:03:52,000 --> 00:03:53,000
我也是这么觉得

80
00:03:53,000 --> 00:03:56,000
但是据说

81
00:03:56,000 --> 00:03:57,000
如果先写走枝的话

82
00:03:57,000 --> 00:03:58,000
整个字很难看

83
00:03:58,000 --> 00:04:01,000
就是因为走枝它只是一个配件

84
00:04:01,000 --> 00:04:03,000
然后你先写它就很容易

85
00:04:03,000 --> 00:04:07,000
让接下来写的东西很难放在正确的位置

86
00:04:07,000 --> 00:04:11,000
但你知道有时候小学生写作文的时候

87
00:04:11,000 --> 00:04:11,000
写字的时候

88
00:04:11,000 --> 00:04:14,000
他不是写的一个小小的有框的那种本

89
00:04:14,000 --> 00:04:15,000
这上面吗

90
00:04:16,000 --> 00:04:18,000
然后如果你先写了中间

91
00:04:18,000 --> 00:04:20,000
你就旁边那个大坨的

92
00:04:20,000 --> 00:04:21,000
然后空间不够怎么办

93
00:04:23,000 --> 00:04:25,000
所以从小就要练这个架构

94
00:04:26,000 --> 00:04:28,000
不过这个笔画书法真的挺好的

95
00:04:28,000 --> 00:04:30,000
就是我有一个例子

96
00:04:31,000 --> 00:04:35,000
就我给我爸妈那个时候教他们用这个电脑数字

97
00:04:35,000 --> 00:04:38,000
然后五笔和拼音都尝试过

98
00:04:38,000 --> 00:04:40,000
对他们那代人来说都太难了

99
00:04:41,000 --> 00:04:42,000
但是他们在手机

100
00:04:42,000 --> 00:04:43,000
那个就不是现代的手机

101
00:04:43,000 --> 00:04:46,000
在那个时候的手机上还是键盘的时候

102
00:04:46,000 --> 00:04:49,000
用横竖撇拉这么一笔一笔的写

103
00:04:49,000 --> 00:04:53,000
其实对他们来讲就跟教写字一样

104
00:04:53,000 --> 00:04:54,000
就是你记着你先打横竖撇拉

105
00:04:54,000 --> 00:04:56,000
你就怎么写那个字

106
00:04:56,000 --> 00:04:57,000
你就照着那个案

107
00:04:57,000 --> 00:04:58,000
就只用记那五个键就可以了

108
00:04:59,000 --> 00:05:02,000
然后加上笔顺纠错的这种功能的话

109
00:05:02,000 --> 00:05:06,000
就大部分场合还是能把中文字写出来的

110
00:05:08,000 --> 00:05:10,000
OK 下一条就什么玩意

111
00:05:11,000 --> 00:05:14,000
对上次说到德语

112
00:05:14,000 --> 00:05:16,000
就是上次我念错了一个德语诞词

113
00:05:16,000 --> 00:05:19,000
就是当我提到 F.E. Schrift

114
00:05:19,000 --> 00:05:26,000
就是那个在德国的车牌上面所使用的那种字体的时候

115
00:05:26,000 --> 00:05:27,000
车牌字体

116
00:05:27,000 --> 00:05:28,000
对

117
00:05:28,000 --> 00:05:32,000
它的正确的名字叫做 Feschungs-eschwerende Schrift

118
00:05:34,000 --> 00:05:39,000
然后我上次我上次念成了 Feschungs-eschwerende Schrift

119
00:05:39,000 --> 00:05:41,000
等一下我很好奇谁听出来你念错

120
00:05:41,000 --> 00:05:42,000
当然是我女朋友

121
00:05:44,000 --> 00:05:46,000
原来还有一个铁杆粉丝

122
00:05:46,000 --> 00:05:47,000
那可不

123
00:05:47,000 --> 00:05:50,000
他已经开始给贵节目捐钱了

124
00:05:51,000 --> 00:05:52,000
你是说 ID 公论吗

125
00:05:52,000 --> 00:05:53,000
对

126
00:05:54,000 --> 00:05:56,000
不是给 B 节目捐钱

127
00:05:57,000 --> 00:06:01,000
不过 B 节目也有很多听众要求说来信

128
00:06:01,000 --> 00:06:03,000
纷纷来信说要给我们捐钱

129
00:06:03,000 --> 00:06:05,000
拿钱砸晕我们

130
00:06:05,000 --> 00:06:06,000
真的假的

131
00:06:06,000 --> 00:06:07,000
我才不相信

132
00:06:07,000 --> 00:06:08,000
真的

133
00:06:08,000 --> 00:06:08,000
不开玩笑

134
00:06:09,000 --> 00:06:11,000
那我们应该怎样

135
00:06:11,000 --> 00:06:16,000
怎样让我们的捐款页面显得更加 Geek 一点呢

136
00:06:16,000 --> 00:06:18,000
你看我的捐款页面都做好了

137
00:06:18,000 --> 00:06:20,000
就等你大笔一挥同意

138
00:06:23,000 --> 00:06:23,000
好吧

139
00:06:23,000 --> 00:06:24,000
我缺个麦克风

140
00:06:24,000 --> 00:06:25,000
也许可以

141
00:06:26,000 --> 00:06:27,000
各位给我凑点经费

142
00:06:27,000 --> 00:06:28,000
搞一个好点麦克风

143
00:06:28,000 --> 00:06:30,000
这样大家可以听到我

144
00:06:32,000 --> 00:06:33,000
更加清透的嗓音

145
00:06:33,000 --> 00:06:33,000
对

146
00:06:33,000 --> 00:06:34,000
更加丰富

147
00:06:34,000 --> 00:06:36,000
更加有层次感的声音

148
00:06:36,000 --> 00:06:37,000
有层次感的声音

149
00:06:38,000 --> 00:06:41,000
不过其实现在有很多人听不出来

150
00:06:41,000 --> 00:06:44,000
你是用的那个麦克的那只麦克风在录

151
00:06:45,000 --> 00:06:47,000
因为那只麦克风据说效果非常好

152
00:06:48,000 --> 00:06:48,000
对

153
00:06:48,000 --> 00:06:53,000
但是离一个专用的还是有比较明显的差别

154
00:06:54,000 --> 00:06:54,000
对

155
00:06:54,000 --> 00:06:57,000
我在 Instagram 上看到你用的麦克风

156
00:06:57,000 --> 00:06:59,000
感觉好像蛮专业的

157
00:06:59,000 --> 00:07:01,000
我那个也是一个入门级的而已

158
00:07:03,000 --> 00:07:04,000
我们可以给你买

159
00:07:04,000 --> 00:07:07,000
如果我们这个节目也开始收钱

160
00:07:07,000 --> 00:07:08,000
打银号

161
00:07:09,000 --> 00:07:10,000
我们拿到钱

162
00:07:10,000 --> 00:07:12,000
第一件事就是先给你买一套

163
00:07:12,000 --> 00:07:14,000
好的录音好的设备

164
00:07:15,000 --> 00:07:17,000
不过也

165
00:07:18,000 --> 00:07:19,000
现在我们就看

166
00:07:19,000 --> 00:07:20,000
到底会有多久给我们钱

167
00:07:20,000 --> 00:07:21,000
好不好

168
00:07:23,000 --> 00:07:24,000
对

169
00:07:25,000 --> 00:07:27,000
然后这不是我唯一念错的德语词

170
00:07:28,000 --> 00:07:31,000
我还念错了另外一个叫做

171
00:07:31,000 --> 00:07:34,000
Deutsch Institute für Normale

172
00:07:34,000 --> 00:07:36,000
我把它念成了 Deutsch Institute for Normale

173
00:07:36,000 --> 00:07:40,000
就是我把 Institute 这个词的词性搞错了

174
00:07:42,000 --> 00:07:44,000
你要先解释一下什么是词性

175
00:07:44,000 --> 00:07:46,000
因为这个不是

176
00:07:46,000 --> 00:07:47,000
比如英语里面就没有这个概念

177
00:07:47,000 --> 00:07:48,000
所以很多人不知道是什么东西

178
00:07:51,000 --> 00:07:51,000
好吧

179
00:07:51,000 --> 00:07:54,000
反正德语作为一种非常繁琐的语言

180
00:07:54,000 --> 00:07:56,000
听起来像

181
00:07:56,000 --> 00:07:59,000
某种机器人掉到下水道里面发出的

182
00:07:59,000 --> 00:08:01,000
声音的语言

183
00:08:01,000 --> 00:08:02,000
它有非常多奇怪的地方

184
00:08:02,000 --> 00:08:06,000
比如说其中之一就是所有的名词要分成三类

185
00:08:07,000 --> 00:08:08,000
音性、中性和阳性

186
00:08:08,000 --> 00:08:10,000
如果你学过法语的话

187
00:08:10,000 --> 00:08:11,000
你知道音性和阳性

188
00:08:11,000 --> 00:08:13,000
但是就像拉丁语一样

189
00:08:13,000 --> 00:08:15,000
德语还有中性这个东西

190
00:08:16,000 --> 00:08:18,000
阳性的第一个

191
00:08:18,000 --> 00:08:21,000
就是阳性的名词的

192
00:08:22,000 --> 00:08:23,000
单数的

193
00:08:24,000 --> 00:08:25,000
组合

194
00:08:26,000 --> 00:08:28,000
有一个贯词叫做 der

195
00:08:29,000 --> 00:08:31,000
然后相当于英语的 der

196
00:08:31,000 --> 00:08:33,000
然后音性的

197
00:08:33,000 --> 00:08:35,000
名词的贯词是 de

198
00:08:36,000 --> 00:08:38,000
然后它也相当于英语的 der

199
00:08:38,000 --> 00:08:41,000
然后中性的名词的贯词是 das

200
00:08:41,000 --> 00:08:43,000
它也相当于英语的 der

201
00:08:43,000 --> 00:08:45,000
英语只有一个 der

202
00:08:45,000 --> 00:08:47,000
然后德语有 derdi das

203
00:08:47,000 --> 00:08:48,000
derdi das

204
00:08:49,000 --> 00:08:50,000
这是所有的

205
00:08:50,000 --> 00:08:53,000
这个可能听众朋友们在国内见到最多

206
00:08:53,000 --> 00:08:55,000
就是大众的广告

207
00:08:55,000 --> 00:08:56,000
das auto

208
00:08:57,000 --> 00:08:58,000
das auto

209
00:08:58,000 --> 00:08:59,000
das auto

210
00:08:59,000 --> 00:09:00,000
对

211
00:09:00,000 --> 00:09:01,000
然后就是

212
00:09:01,000 --> 00:09:04,000
就翻译成语是 the car 的意思

213
00:09:04,000 --> 00:09:05,000
the car yes

214
00:09:05,000 --> 00:09:08,000
但是 auto 这个东西是

215
00:09:10,000 --> 00:09:12,000
automobile 的缩写

216
00:09:12,000 --> 00:09:13,000
所以它是中性的

217
00:09:14,000 --> 00:09:15,000
somehow someway

218
00:09:15,000 --> 00:09:17,000
所以是 das auto

219
00:09:18,000 --> 00:09:19,000
das auto

220
00:09:19,000 --> 00:09:20,000
das photo

221
00:09:20,000 --> 00:09:21,000
auto 和 photo

222
00:09:21,000 --> 00:09:22,000
photo 就是 photo

223
00:09:22,000 --> 00:09:24,000
photo 和 auto 都是中性的

224
00:09:25,000 --> 00:09:27,000
但是也有很多不合理的地方

225
00:09:27,000 --> 00:09:28,000
比如说

226
00:09:28,000 --> 00:09:31,000
太阳它怎么可能会是音性的呢

227
00:09:31,000 --> 00:09:33,000
结果在德语面上它真的是音性的

228
00:09:33,000 --> 00:09:34,000
对

229
00:09:34,000 --> 00:09:35,000
德语面上是音性的

230
00:09:35,000 --> 00:09:36,000
月亮是阳性的

231
00:09:36,000 --> 00:09:38,000
当然也是有原因的

232
00:09:38,000 --> 00:09:41,000
因为在古日尔曼神话里面

233
00:09:41,000 --> 00:09:43,000
太阳是个女神

234
00:09:44,000 --> 00:09:45,000
月亮是个男神

235
00:09:46,000 --> 00:09:47,000
月亮是个男神

236
00:09:47,000 --> 00:09:50,000
就是跟希腊神话正好相反

237
00:09:50,000 --> 00:09:54,000
它是一种比较古老的神话

238
00:09:55,000 --> 00:09:58,000
或者说宗教仪式的严存

239
00:09:59,000 --> 00:10:01,000
但是这跟现在

240
00:10:01,000 --> 00:10:02,000
比如说中国的

241
00:10:03,000 --> 00:10:05,000
正常人的一个想法

242
00:10:05,000 --> 00:10:06,000
好像就不太一样

243
00:10:07,000 --> 00:10:08,000
对中国

244
00:10:08,000 --> 00:10:11,000
中国阳这个东西就默认是

245
00:10:11,000 --> 00:10:11,000
太阳

246
00:10:11,000 --> 00:10:12,000
就是默认

247
00:10:12,000 --> 00:10:13,000
就是阳这个东西就是太阳

248
00:10:13,000 --> 00:10:14,000
对

249
00:10:14,000 --> 00:10:15,000
音就是月亮

250
00:10:15,000 --> 00:10:17,000
因为字里面就有那个

251
00:10:17,000 --> 00:10:17,000
月亮

252
00:10:17,000 --> 00:10:18,000
在德语里面

253
00:10:18,000 --> 00:10:23,000
masculine 这个描述的正确翻译方法是雄性

254
00:10:23,000 --> 00:10:26,000
就是他们认为太阳是音性的

255
00:10:26,000 --> 00:10:28,000
月亮是雄性的

256
00:10:29,000 --> 00:10:30,000
太阳是磁性的

257
00:10:30,000 --> 00:10:31,000
月亮是雄性的

258
00:10:32,000 --> 00:10:35,000
三号也有点能做出一点意义来

259
00:10:35,000 --> 00:10:39,000
但还是比较奇怪的事

260
00:10:39,000 --> 00:10:40,000
对关键是我觉得

261
00:10:40,000 --> 00:10:41,000
德语这个分三性

262
00:10:41,000 --> 00:10:44,000
完全任何一点用处也没有

263
00:10:44,000 --> 00:10:45,000
有没有什么实际的用处

264
00:10:45,000 --> 00:10:46,000
我自己也想不出来

265
00:10:46,000 --> 00:10:47,000
当时学的时候就很痛苦

266
00:10:47,000 --> 00:10:48,000
所有的

267
00:10:48,000 --> 00:10:50,000
大家认为背英文单词

268
00:10:50,000 --> 00:10:52,000
要背名词的话

269
00:10:52,000 --> 00:10:53,000
你得记一个单副数

270
00:10:53,000 --> 00:10:53,000
对吧

271
00:10:53,000 --> 00:10:54,000
就完了

272
00:10:54,000 --> 00:10:56,000
然后有些可能特别的什么

273
00:10:56,000 --> 00:10:57,000
单副同型

274
00:10:57,000 --> 00:10:58,000
或者是特殊的

275
00:10:58,000 --> 00:11:00,000
单副同型有什么

276
00:11:01,000 --> 00:11:01,000
people

277
00:11:01,000 --> 00:11:03,000
作为一个种族来讲

278
00:11:03,000 --> 00:11:03,000
对吧

279
00:11:03,000 --> 00:11:05,000
有三副同型的

280
00:11:05,000 --> 00:11:07,000
然后有些特殊的一个

281
00:11:07,000 --> 00:11:08,000
比如说我们常常讲的数据

282
00:11:08,000 --> 00:11:09,000
data

283
00:11:10,000 --> 00:11:11,000
其实是一个副数

284
00:11:11,000 --> 00:11:12,000
但是它的

285
00:11:12,000 --> 00:11:13,000
data

286
00:11:13,000 --> 00:11:13,000
对

287
00:11:13,000 --> 00:11:14,000
在德语里面

288
00:11:15,000 --> 00:11:17,000
这个词仍旧在使用其

289
00:11:17,000 --> 00:11:19,000
拉丁语单数形式作为单数

290
00:11:19,000 --> 00:11:21,000
就是你说一个数据的时候

291
00:11:21,000 --> 00:11:22,000
你必须说 andatum

292
00:11:22,000 --> 00:11:25,000
而你不能说 data

293
00:11:25,000 --> 00:11:26,000
这种用法是错的

294
00:11:26,000 --> 00:11:28,000
对在英语里面已经变成

295
00:11:28,000 --> 00:11:29,000
对现在英语里面已经

296
00:11:29,000 --> 00:11:32,000
data 已经变成一个不可数的

297
00:11:32,000 --> 00:11:34,000
然后是就没有副数形式

298
00:11:34,000 --> 00:11:35,000
然后

299
00:11:35,000 --> 00:11:37,000
但如果你是考古的话

300
00:11:37,000 --> 00:11:40,000
也发现还有一个 datum

301
00:11:40,000 --> 00:11:41,000
单数的形式

302
00:11:41,000 --> 00:11:42,000
但是现在就只要在

303
00:11:43,000 --> 00:11:44,000
现代的文献里面

304
00:11:44,000 --> 00:11:45,000
基本上是看不到这个说法了

305
00:11:45,000 --> 00:11:47,000
当然还有一些更加诡异的

306
00:11:49,000 --> 00:11:49,000
单副数

307
00:11:49,000 --> 00:11:51,000
你完全看不出他们之间

308
00:11:51,000 --> 00:11:52,000
有什么区别的东西

309
00:11:52,000 --> 00:11:53,000
对我记得

310
00:11:53,000 --> 00:11:56,000
前一阵子冯天

311
00:11:56,000 --> 00:11:58,000
有一辆日本车叫什么

312
00:11:58,000 --> 00:11:58,000
Prius

313
00:11:58,000 --> 00:11:59,000
对

314
00:11:59,000 --> 00:11:59,000
对

315
00:11:59,000 --> 00:12:00,000
Prius

316
00:12:00,000 --> 00:12:02,000
Prius

317
00:12:02,000 --> 00:12:04,000
然后它的副数形式叫做 pre

318
00:12:05,000 --> 00:12:06,000
pre 对

319
00:12:06,000 --> 00:12:07,000
是 Prii

320
00:12:08,000 --> 00:12:08,000
两个 i

321
00:12:09,000 --> 00:12:10,000
专门说这是一个拉丁语词

322
00:12:10,000 --> 00:12:11,000
所以它的副数应该叫 i

323
00:12:11,000 --> 00:12:12,000
what the hell

324
00:12:14,000 --> 00:12:15,000
对就英文里面

325
00:12:15,000 --> 00:12:16,000
就有这种很奇怪的事情

326
00:12:16,000 --> 00:12:18,000
但是你想想都还能够接受

327
00:12:18,000 --> 00:12:19,000
起码还能知道说

328
00:12:19,000 --> 00:12:20,000
这个是为了区别

329
00:12:20,000 --> 00:12:21,000
一个和多个

330
00:12:21,000 --> 00:12:23,000
但虽然我不知道意义何在

331
00:12:24,000 --> 00:12:24,000
然后还有

332
00:12:25,000 --> 00:12:26,000
但是德语里面的名词

333
00:12:26,000 --> 00:12:29,000
它除了要分单副数之外

334
00:12:29,000 --> 00:12:31,000
它还要分三个性别

335
00:12:31,000 --> 00:12:34,000
然后这三个性别 totally make no sense

336
00:12:34,000 --> 00:12:34,000
对

337
00:12:36,000 --> 00:12:37,000
当然可能

338
00:12:37,000 --> 00:12:38,000
我觉得每种语言都有些复杂度

339
00:12:38,000 --> 00:12:40,000
比如说中文的复杂度

340
00:12:40,000 --> 00:12:41,000
就在它的写里面

341
00:12:41,000 --> 00:12:43,000
然后它的书写是非常复杂的

342
00:12:43,000 --> 00:12:44,000
语法简单的要辞

343
00:12:44,000 --> 00:12:47,000
但是书写非常复杂

344
00:12:47,000 --> 00:12:48,000
其实从这个角度上

345
00:12:48,000 --> 00:12:49,000
中文还是蛮不错的

346
00:12:49,000 --> 00:12:52,000
就是不分单副数对吧

347
00:12:52,000 --> 00:12:54,000
对不分性数格

348
00:12:54,000 --> 00:12:55,000
这是非常好的一点

349
00:12:55,000 --> 00:12:56,000
对

350
00:12:57,000 --> 00:12:59,000
唯一一个要分那个

351
00:12:59,000 --> 00:13:00,000
就中文有一个不太爽

352
00:13:00,000 --> 00:13:01,000
就是量词太多

353
00:13:01,000 --> 00:13:02,000
又没什么用好像

354
00:13:02,000 --> 00:13:02,000
对

355
00:13:02,000 --> 00:13:03,000
对于外国人来说

356
00:13:03,000 --> 00:13:06,000
最大的困扰之一就是量词了

357
00:13:06,000 --> 00:13:08,000
你不像习语习语这些东西

358
00:13:08,000 --> 00:13:09,000
你不会就罢了

359
00:13:09,000 --> 00:13:11,000
量词你不会的话

360
00:13:11,000 --> 00:13:13,000
就很容易会说错话的

361
00:13:14,000 --> 00:13:14,000
对

362
00:13:14,000 --> 00:13:18,000
而且量词其实也没有太大的实际作用

363
00:13:18,000 --> 00:13:19,000
在我看来

364
00:13:19,000 --> 00:13:20,000
对

365
00:13:20,000 --> 00:13:21,000
它除了

366
00:13:21,000 --> 00:13:24,000
对于一些没有固定形状的东西

367
00:13:25,000 --> 00:13:26,000
有一些意义的

368
00:13:26,000 --> 00:13:28,000
比如说英语里面也会说一瓶水

369
00:13:28,000 --> 00:13:30,000
一杯咖啡

370
00:13:30,000 --> 00:13:31,000
中文

371
00:13:31,000 --> 00:13:31,000
对

372
00:13:32,000 --> 00:13:33,000
但是除此之外

373
00:13:33,000 --> 00:13:35,000
好像为什么一定要说一匹马

374
00:13:35,000 --> 00:13:36,000
那不能说一个马

375
00:13:36,000 --> 00:13:37,000
对

376
00:13:37,000 --> 00:13:38,000
买了一个

377
00:13:38,000 --> 00:13:40,000
不过但是在有些方言里面

378
00:13:40,000 --> 00:13:42,000
就是在方言的口语里面

379
00:13:42,000 --> 00:13:44,000
量词已经被很多情况下被审判掉了

380
00:13:44,000 --> 00:13:45,000
就是

381
00:13:45,000 --> 00:13:46,000
比如说最简单的例子

382
00:13:46,000 --> 00:13:47,000
我们俩人

383
00:13:47,000 --> 00:13:49,000
我们不说我们两个人对吧

384
00:13:49,000 --> 00:13:51,000
我们俩人在这里扯淡

385
00:13:52,000 --> 00:13:52,000
还有那个

386
00:13:52,000 --> 00:13:54,000
对面过来俩狗

387
00:13:57,000 --> 00:13:59,000
有时候还是可以省略的

388
00:13:59,000 --> 00:14:00,000
然后我一直在想

389
00:14:00,000 --> 00:14:03,000
如果作为一个有性格一点的尝试

390
00:14:03,000 --> 00:14:05,000
你可以以后都不说量词

391
00:14:05,000 --> 00:14:06,000
看会有什么效果

392
00:14:06,000 --> 00:14:07,000
老板

393
00:14:07,000 --> 00:14:09,000
给我俩苹果

394
00:14:09,000 --> 00:14:10,000
这以后我没有做

395
00:14:10,000 --> 00:14:12,000
老板上俩面

396
00:14:13,000 --> 00:14:14,000
对

397
00:14:14,000 --> 00:14:14,000
上俩面

398
00:14:16,000 --> 00:14:17,000
这也不错

399
00:14:18,000 --> 00:14:19,000
老板

400
00:14:19,000 --> 00:14:20,000
来武来武车

401
00:14:22,000 --> 00:14:25,000
对这种事情就比较诡异了

402
00:14:25,000 --> 00:14:26,000
但是可以试一下

403
00:14:27,000 --> 00:14:27,000
下一条反馈

404
00:14:27,000 --> 00:14:28,000
是

405
00:14:28,000 --> 00:14:29,000
也是我的

406
00:14:29,000 --> 00:14:31,000
就是我上次说到

407
00:14:31,000 --> 00:14:33,000
依伦敦的交通字体

408
00:14:33,000 --> 00:14:36,000
我不确定是 transport 还是

409
00:14:36,000 --> 00:14:39,000
还是 underground 的字体里面

410
00:14:39,000 --> 00:14:41,000
阿 A 小写字母

411
00:14:41,000 --> 00:14:43,000
阿 A 的上面的那一点

412
00:14:43,000 --> 00:14:44,000
是个正方形的话

413
00:14:44,000 --> 00:14:46,000
我说旋转 90 度它是个零形

414
00:14:46,000 --> 00:14:47,000
但实际上正方形

415
00:14:47,000 --> 00:14:49,000
旋转 90 度还是个正方形

416
00:14:50,000 --> 00:14:51,000
你玩我吗

417
00:14:51,000 --> 00:14:56,000
俄罗斯方块

418
00:14:56,000 --> 00:14:57,000
里面正方形

419
00:14:58,000 --> 00:14:59,000
怎么旋转都是那样

420
00:14:59,000 --> 00:15:00,000
没有用

421
00:15:00,000 --> 00:15:03,000
你说他写正方形

422
00:15:03,000 --> 00:15:04,000
旋转的函数

423
00:15:04,000 --> 00:15:05,000
该不会直接就 return

424
00:15:06,000 --> 00:15:07,000
no op

425
00:15:07,000 --> 00:15:07,000
对

426
00:15:08,000 --> 00:15:08,000
应该是我觉得

427
00:15:08,000 --> 00:15:09,000
没有意义

428
00:15:13,000 --> 00:15:15,000
然后还有一条是梁海纠正我的

429
00:15:16,000 --> 00:15:19,000
小写字母 G 的双层版本

430
00:15:19,000 --> 00:15:21,000
和希腊字母应该是没有什么关联的

431
00:15:21,000 --> 00:15:22,000
我当时想到

432
00:15:22,000 --> 00:15:26,000
他应该可能跟希腊字母有一个叫什么

433
00:15:26,000 --> 00:15:28,000
epsilon 之类的

434
00:15:28,000 --> 00:15:30,000
就看起来非常奇怪的一个字母

435
00:15:30,000 --> 00:15:31,000
有点关联

436
00:15:31,000 --> 00:15:32,000
我觉得 G 可能是从那个字母来的

437
00:15:32,000 --> 00:15:33,000
但实际上完全不是

438
00:15:36,000 --> 00:15:39,000
作为 types beautiful 成员

439
00:15:39,000 --> 00:15:40,000
你是不是要去蹲长脚

440
00:15:40,000 --> 00:15:43,000
反思的一段三五天之类的

441
00:15:43,000 --> 00:15:45,000
这种事情也不是第一次发生的

442
00:15:45,000 --> 00:15:46,000
我上次在知乎上

443
00:15:46,000 --> 00:15:47,000
斩钉解写的说

444
00:15:47,000 --> 00:15:56,000
瑞士高速公路的标号牌的字体

445
00:15:56,000 --> 00:15:57,000
就是 frutig

446
00:15:57,000 --> 00:16:00,000
然后有人跳出来说

447
00:16:00,000 --> 00:16:02,000
贵网站上面说过

448
00:16:02,000 --> 00:16:04,000
他是 frutig 的那种感性

449
00:16:04,000 --> 00:16:06,000
简直就是自打脸

450
00:16:06,000 --> 00:16:07,000
没错

451
00:16:07,000 --> 00:16:08,000
还好那篇文章

452
00:16:08,000 --> 00:16:09,000
不是我意的

453
00:16:09,000 --> 00:16:10,000
应该不是我意

454
00:16:10,000 --> 00:16:11,000
如果是我意的话

455
00:16:11,000 --> 00:16:11,000
我就可以去死

456
00:16:13,000 --> 00:16:13,000
好吧

457
00:16:13,000 --> 00:16:14,000
我们原谅你了

458
00:16:15,000 --> 00:16:16,000
谢谢原谅

459
00:16:16,000 --> 00:16:18,000
听众我原谅你

460
00:16:18,000 --> 00:16:18,000
我不知道

461
00:16:19,000 --> 00:16:20,000
原谅不是

462
00:16:22,000 --> 00:16:22,000
sorry

463
00:16:24,000 --> 00:16:24,000
对

464
00:16:24,000 --> 00:16:27,000
然后就是 input 字体

465
00:16:27,000 --> 00:16:29,000
我上一次去看他的时候

466
00:16:29,000 --> 00:16:31,000
发现他有了一个

467
00:16:32,000 --> 00:16:34,000
花口号的替换版本

468
00:16:34,000 --> 00:16:36,000
就是有一个普通的花口号出现了

469
00:16:36,000 --> 00:16:39,000
如果你对花口号也不爽的话

470
00:16:39,000 --> 00:16:40,000
可以去拥有这个

471
00:16:40,000 --> 00:16:41,000
普通花口号的版本

472
00:16:42,000 --> 00:16:45,000
所谓普通就是没有那么扭曲的一个花口号

473
00:16:46,000 --> 00:16:48,000
input 那个它会有很多这种

474
00:16:49,000 --> 00:16:50,000
它有一个定制化的界面

475
00:16:50,000 --> 00:16:51,000
你可以选择

476
00:16:52,000 --> 00:16:54,000
那些你喜欢的字

477
00:16:54,000 --> 00:16:55,000
变种的组合

478
00:16:55,000 --> 00:16:57,000
这样就是反正我总有一个适合你的

479
00:16:57,000 --> 00:16:59,000
然后碰巧你就是喜欢那个

480
00:17:00,000 --> 00:17:02,000
直上直下的大口号的东西

481
00:17:03,000 --> 00:17:03,000
没错

482
00:17:04,000 --> 00:17:05,000
其实之前那个花口号我觉得挺好的

483
00:17:07,000 --> 00:17:08,000
好吧

484
00:17:08,000 --> 00:17:09,000
还是要强调这一点

485
00:17:09,000 --> 00:17:10,000
对

486
00:17:11,000 --> 00:17:13,000
下一条反馈是我说错了一个东西

487
00:17:14,000 --> 00:17:15,000
我们上次讲到有

488
00:17:16,000 --> 00:17:18,000
以 council as caliber

489
00:17:18,000 --> 00:17:19,000
还有 cambray

490
00:17:19,000 --> 00:17:19,000
对吧

491
00:17:19,000 --> 00:17:20,000
cambray

492
00:17:20,000 --> 00:17:23,000
都会带来的微软的 c 系字体

493
00:17:23,000 --> 00:17:26,000
但是我说他好像是随 office 发布的

494
00:17:26,000 --> 00:17:30,000
但其实他是随 vista 发布的

495
00:17:31,000 --> 00:17:34,000
然后之所以我讲错这个是因为

496
00:17:34,000 --> 00:17:36,000
我用这套字体就完全是因为在

497
00:17:37,000 --> 00:17:40,000
装了 macoffice 之后

498
00:17:40,000 --> 00:17:41,000
在我的 mac 上面才找到的

499
00:17:41,000 --> 00:17:44,000
然后因为 vista 我真的是没有用过

500
00:17:44,000 --> 00:17:46,000
遮遮掩掩就直接说我是果粉吗

501
00:17:46,000 --> 00:17:47,000
不知道很正常

502
00:17:48,000 --> 00:17:49,000
不这个 vista 真的很糟糕

503
00:17:50,000 --> 00:17:50,000
对

504
00:17:51,000 --> 00:17:52,000
他确实出来的时候

505
00:17:52,000 --> 00:17:53,000
对

506
00:17:53,000 --> 00:17:53,000
不是我的

507
00:17:53,000 --> 00:17:54,000
这个是公认的

508
00:17:54,000 --> 00:17:55,000
我这个是公认的

509
00:17:55,000 --> 00:17:56,000
所以这个错了

510
00:17:56,000 --> 00:17:58,000
我觉得是情有可原的

511
00:17:58,000 --> 00:17:59,000
你们一定要原谅我

512
00:17:59,000 --> 00:18:00,000
对不起梁海先生

513
00:18:01,000 --> 00:18:02,000
也是梁海就错了

514
00:18:07,000 --> 00:18:09,000
然后其实有一位

515
00:18:10,000 --> 00:18:12,000
亲共在

516
00:18:12,000 --> 00:18:15,000
他是叫孙玉冬

517
00:18:15,000 --> 00:18:17,000
对他来邮件说的

518
00:18:18,000 --> 00:18:18,000
像我们提到

519
00:18:18,000 --> 00:18:20,000
就是微软给学生

520
00:18:20,000 --> 00:18:23,000
有一个特殊的计划叫做 DreamSpark

521
00:18:23,000 --> 00:18:24,000
对

522
00:18:24,000 --> 00:18:26,000
然后 DreamSpark 就可以干嘛呢

523
00:18:26,000 --> 00:18:26,000
就是你

524
00:18:26,000 --> 00:18:28,000
比如说你学校参加了这个项目之后

525
00:18:28,000 --> 00:18:30,000
你可以从你学校拿到一个账号

526
00:18:30,000 --> 00:18:31,000
然后你用这个账号

527
00:18:31,000 --> 00:18:34,000
可以在微软的官方网站免费的下载到

528
00:18:34,000 --> 00:18:36,000
大部分的微软的产品

529
00:18:37,000 --> 00:18:39,000
然后里面他提供那个叫做

530
00:18:39,000 --> 00:18:40,000
Visual Studio

531
00:18:40,000 --> 00:18:42,000
他是提供的是 Pro 版本

532
00:18:42,000 --> 00:18:43,000
哎哟

533
00:18:45,000 --> 00:18:45,000
不过

534
00:18:47,000 --> 00:18:48,000
之前我们讲那个叫什么

535
00:18:48,000 --> 00:18:50,000
那个叫 Community Edition

536
00:18:50,000 --> 00:18:51,000
对 Community

537
00:18:51,000 --> 00:18:52,000
CE

538
00:18:52,000 --> 00:18:53,000
CE 一直是免费的

539
00:18:53,000 --> 00:18:55,000
就是对公众都是免费的

540
00:18:55,000 --> 00:18:55,000
对

541
00:18:55,000 --> 00:18:58,000
而且应该将会一直免费下去

542
00:18:58,000 --> 00:19:01,000
就像之前很多的

543
00:19:01,000 --> 00:19:04,000
比如说那个 JetBrains 的

544
00:19:04,000 --> 00:19:05,000
Idea

545
00:19:05,000 --> 00:19:06,000
Intelligent 也是有

546
00:19:06,000 --> 00:19:08,000
Community Edition 也是永远免费

547
00:19:09,000 --> 00:19:09,000
嗯哼

548
00:19:10,000 --> 00:19:11,000
不过说到这个我想请你一个事

549
00:19:11,000 --> 00:19:14,000
就是好像这个有一个商业上的专门的说法

550
00:19:14,000 --> 00:19:17,000
这种就是把一个产品分那么多

551
00:19:17,000 --> 00:19:20,000
种类版本的一个什么叫做 Product Matrix

552
00:19:20,000 --> 00:19:21,000
是不是

553
00:19:21,000 --> 00:19:21,000
对

554
00:19:21,000 --> 00:19:22,000
我也不太清楚

555
00:19:22,000 --> 00:19:23,000
反正就是

556
00:19:23,000 --> 00:19:24,000
就无论如何很喜欢搞这种事情

557
00:19:24,000 --> 00:19:25,000
大家不知道现在还有

558
00:19:25,000 --> 00:19:26,000
其实现在可能还好一点

559
00:19:26,000 --> 00:19:28,000
之前 Vista 刚出来的时候

560
00:19:28,000 --> 00:19:29,000
大家不知道还有没有印象

561
00:19:30,000 --> 00:19:32,000
好像是有十几个版本吧我记得

562
00:19:33,000 --> 00:19:34,000
不止微软吧

563
00:19:34,000 --> 00:19:36,000
我觉得很多痛恨的产品都有这个特点

564
00:19:36,000 --> 00:19:37,000
Eclipse 不也是吗

565
00:19:37,000 --> 00:19:40,000
你去 Eclipse 的那个下载页面

566
00:19:40,000 --> 00:19:40,000
我靠

567
00:19:41,000 --> 00:19:43,000
一大堆版本什么 JavaE 版本

568
00:19:43,000 --> 00:19:44,000
C++版本

569
00:19:45,000 --> 00:19:45,000
对

570
00:19:45,000 --> 00:19:46,000
这个版本那个版本

571
00:19:46,000 --> 00:19:47,000
就不明白了

572
00:19:47,000 --> 00:19:49,000
就难道不能提供一个

573
00:19:50,000 --> 00:19:51,000
就是基础版本

574
00:19:51,000 --> 00:19:52,000
然后 Whatever

575
00:19:52,000 --> 00:19:53,000
你让用户自己去装

576
00:19:53,000 --> 00:19:55,000
盖一个装个插线或者怎么样

577
00:19:56,000 --> 00:19:56,000
对

578
00:19:56,000 --> 00:20:00,000
就我能想到的有这个所谓 Product Matrix

579
00:20:00,000 --> 00:20:01,000
这种结构

580
00:20:01,000 --> 00:20:02,000
就是把一个产品

581
00:20:02,000 --> 00:20:03,000
就同一个产品

582
00:20:03,000 --> 00:20:06,000
然后根据什么不同的场景

583
00:20:06,000 --> 00:20:08,000
或者不同功能细分的很多的

584
00:20:08,000 --> 00:20:10,000
这种产品给我的感觉

585
00:20:10,000 --> 00:20:12,000
或者这种公司给我的感觉很差的

586
00:20:12,000 --> 00:20:14,000
因为其实从本质上你都知道

587
00:20:14,000 --> 00:20:16,000
它就是在所谓的追

588
00:20:16,000 --> 00:20:17,000
等一下那个东西叫什么来的

589
00:20:19,000 --> 00:20:20,000
那个叫做

590
00:20:21,000 --> 00:20:22,000
利润最大化

591
00:20:22,000 --> 00:20:23,000
好像也不对

592
00:20:24,000 --> 00:20:26,000
就等于是你不愿意

593
00:20:26,000 --> 00:20:28,000
就是我所有这些功能

594
00:20:28,000 --> 00:20:29,000
加在一起

595
00:20:29,000 --> 00:20:31,000
开这个价你出不起

596
00:20:31,000 --> 00:20:32,000
那我就砍掉一些

597
00:20:32,000 --> 00:20:38,000
然后把你能买的价格介绍给你

598
00:20:38,000 --> 00:20:40,000
但这就像卖车

599
00:20:40,000 --> 00:20:41,000
就是任何

600
00:20:42,000 --> 00:20:44,000
我很小的时候总是会有很奇怪说

601
00:20:44,000 --> 00:20:49,000
这为什么车的广告上面都不写定价呢

602
00:20:50,000 --> 00:20:53,000
它会写一个多少起吗

603
00:20:53,000 --> 00:20:53,000
对

604
00:20:54,000 --> 00:20:56,000
但那个起是完全全是裸车价

605
00:20:56,000 --> 00:21:00,000
那真正的你要去配 configurator

606
00:21:00,000 --> 00:21:02,000
然后才知道

607
00:21:02,000 --> 00:21:04,000
每一个每加一个 option 要加多少钱

608
00:21:04,000 --> 00:21:06,000
而 configurator 的那个 list

609
00:21:06,000 --> 00:21:09,000
你可以花两天的时间

610
00:21:09,000 --> 00:21:11,000
跟那个销售代理在那边讨论这个事情

611
00:21:11,000 --> 00:21:14,000
如果你真不想要定制一辆属于自己的车的话

612
00:21:14,000 --> 00:21:18,000
当然这种情况在中国可能不是很普遍

613
00:21:18,000 --> 00:21:20,000
但在欧洲很多人会愿意

614
00:21:20,000 --> 00:21:21,000
花两天时间

615
00:21:23,000 --> 00:21:24,000
至少这一下午吧

616
00:21:24,000 --> 00:21:27,000
跟销售代表去讨论这辆车

617
00:21:27,000 --> 00:21:28,000
他要哪些 option

618
00:21:28,000 --> 00:21:29,000
然后

619
00:21:29,000 --> 00:21:30,000
然后定

620
00:21:30,000 --> 00:21:33,000
然后两个月之后这辆车才可以送到他手里

621
00:21:33,000 --> 00:21:36,000
但是每一个 option 都是他亲自 check 过的

622
00:21:36,000 --> 00:21:41,000
这才是就是 product matrix at it worst

623
00:21:42,000 --> 00:21:42,000
对

624
00:21:42,000 --> 00:21:45,000
反正就给人感觉就非常不好

625
00:21:45,000 --> 00:21:46,000
而且就整个是

626
00:21:46,000 --> 00:21:50,000
没有就平板无故的增加了这个选择的难度

627
00:21:50,000 --> 00:21:53,000
本来就选择困难这已经够严重了

628
00:21:53,000 --> 00:21:53,000
对吧

629
00:21:53,000 --> 00:21:55,000
他还给你搞得那么麻烦

630
00:21:55,000 --> 00:21:56,000
让你真是想撞场死

631
00:21:57,000 --> 00:21:57,000
不过现在

632
00:21:57,000 --> 00:22:00,000
这什么 windows 8 还有之后可能

633
00:22:00,000 --> 00:22:01,000
对他跳过久了

634
00:22:01,000 --> 00:22:02,000
直接的 windows 10

635
00:22:02,000 --> 00:22:03,000
8 已经好很多了

636
00:22:03,000 --> 00:22:05,000
8 只分了一个

637
00:22:05,000 --> 00:22:08,000
就是 8 和 8 pro 专业版

638
00:22:08,000 --> 00:22:08,000
对

639
00:22:08,000 --> 00:22:10,000
好像以前还有什么

640
00:22:10,000 --> 00:22:13,000
我想想有什么 home basic

641
00:22:13,000 --> 00:22:14,000
home premium

642
00:22:15,000 --> 00:22:16,000
professional

643
00:22:17,000 --> 00:22:19,000
有个什么 ultimate

644
00:22:19,000 --> 00:22:20,000
还有 enterprise

645
00:22:20,000 --> 00:22:21,000
对

646
00:22:21,000 --> 00:22:24,000
还有一个 home premium 之类的一个词

647
00:22:24,000 --> 00:22:26,000
一个版本

648
00:22:26,000 --> 00:22:27,000
还有什么 starter edition

649
00:22:29,000 --> 00:22:31,000
还有所有的都要乘以 2

650
00:22:31,000 --> 00:22:34,000
因为他分 32 位和 64 位不同的东西

651
00:22:34,000 --> 00:22:35,000
不止乘以 2

652
00:22:35,000 --> 00:22:37,000
还要乘以所有的语言

653
00:22:37,000 --> 00:22:38,000
对

654
00:22:38,000 --> 00:22:40,000
我觉得这是非常 2 的一件事情

655
00:22:40,000 --> 00:22:42,000
就是你不止 windows 如此

656
00:22:42,000 --> 00:22:45,000
就什么 blackberry 或者是 android 我不知道

657
00:22:45,000 --> 00:22:47,000
但很多操作系统都一定要

658
00:22:47,000 --> 00:22:51,000
他为了分语言是因为它是跟确定价有关系

659
00:22:51,000 --> 00:22:53,000
其实跟这个 product matrix 本质上也是一个意思

660
00:22:53,000 --> 00:22:54,000
就是

661
00:22:54,000 --> 00:22:55,000
你不

662
00:22:55,000 --> 00:22:55,000
哎

663
00:22:55,000 --> 00:22:56,000
看一下

664
00:22:56,000 --> 00:22:57,000
中国这边比较穷

665
00:22:57,000 --> 00:23:00,000
我们把这个价格定低一点

666
00:23:01,000 --> 00:23:02,000
德国那些人比较有钱

667
00:23:02,000 --> 00:23:04,000
我们把那个价格高了一点

668
00:23:04,000 --> 00:23:04,000
但是

669
00:23:05,000 --> 00:23:06,000
但是如果

670
00:23:06,000 --> 00:23:07,000
那产品是一样的

671
00:23:07,000 --> 00:23:10,000
如果我可以随时像这个什么 iPhone 一样切换语言

672
00:23:10,000 --> 00:23:11,000
那我还搞屁啊

673
00:23:11,000 --> 00:23:13,000
那我大概直接买中国版去德国用不就好了

674
00:23:13,000 --> 00:23:13,000
对吧

675
00:23:13,000 --> 00:23:16,000
所以他就搞成所有的语言是不可以

676
00:23:17,000 --> 00:23:18,000
随意替换的

677
00:23:18,000 --> 00:23:20,000
那也可以有这种工具

678
00:23:20,000 --> 00:23:21,000
要个叫什么 MU

679
00:23:21,000 --> 00:23:22,000
叫什么

680
00:23:22,000 --> 00:23:24,000
现在已经可以下载语言包了

681
00:23:24,000 --> 00:23:25,000
我记得

682
00:23:25,000 --> 00:23:25,000
不

683
00:23:25,000 --> 00:23:29,000
语言包从 Vista 时代还是 N 7 时代就已经有

684
00:23:29,000 --> 00:23:30,000
XP 都已经有语言包

685
00:23:30,000 --> 00:23:31,000
但是那个语言包是

686
00:23:31,000 --> 00:23:33,000
首先是一个要额外付费买的

687
00:23:34,000 --> 00:23:36,000
就要补齐那个

688
00:23:37,000 --> 00:23:38,000
那个就是定价的差异

689
00:23:38,000 --> 00:23:40,000
就一般来说是这样子

690
00:23:40,000 --> 00:23:43,000
然后你还得麻烦去安装

691
00:23:43,000 --> 00:23:45,000
然后就是你装完这个语言包之后

692
00:23:45,000 --> 00:23:47,000
它其实也并不等于一个原生的那个语言的系统

693
00:23:47,000 --> 00:23:49,000
我自己装过

694
00:23:49,000 --> 00:23:50,000
所以这个是深有体会的

695
00:23:51,000 --> 00:23:51,000
呃

696
00:23:52,000 --> 00:23:56,000
所以你看见这种语言是不可以切换的

697
00:23:56,000 --> 00:23:59,000
然后有各种 edition 的

698
00:23:59,000 --> 00:24:00,000
你就知道

699
00:24:00,000 --> 00:24:00,000
嗯

700
00:24:00,000 --> 00:24:01,000
something is wrong

701
00:24:01,000 --> 00:24:02,000
yeah

702
00:24:03,000 --> 00:24:05,000
啊 anyway 吐槽一下 Virginia

703
00:24:05,000 --> 00:24:06,000
而且现在已经好多了

704
00:24:06,000 --> 00:24:07,000
就是刚才讲的那个 8 已经

705
00:24:07,000 --> 00:24:11,000
我印象中只有 8 和 8 的 Pro

706
00:24:11,000 --> 00:24:12,000
这两个区别

707
00:24:12,000 --> 00:24:14,000
但它有那个针对 Surface

708
00:24:14,000 --> 00:24:15,000
好像一个版本那个在说

709
00:24:15,000 --> 00:24:18,000
然后语言我不知道现在怎么一个什么情况

710
00:24:18,000 --> 00:24:22,000
我至少从刚刚为了玩那个文明超越机球

711
00:24:22,000 --> 00:24:24,000
装了一个

712
00:24:24,000 --> 00:24:26,000
8.1 还是德语版的

713
00:24:26,000 --> 00:24:27,000
我也没有去试

714
00:24:27,000 --> 00:24:28,000
反正就用

715
00:24:28,000 --> 00:24:30,000
它在控制面板里面有一个可以选语言

716
00:24:30,000 --> 00:24:32,000
但是我记得是要语言安装包的

717
00:24:32,000 --> 00:24:34,000
但是安装包怎么来就是一个问题

718
00:24:34,000 --> 00:24:35,000
嗯

719
00:24:35,000 --> 00:24:36,000
哦 Win 98

720
00:24:37,000 --> 00:24:39,000
我去装 Win 98 之后

721
00:24:39,000 --> 00:24:41,000
去重温了一下控制面板

722
00:24:41,000 --> 00:24:43,000
我觉得我靠怎么会有这么多东西

723
00:24:43,000 --> 00:24:47,000
其实它也不算多了

724
00:24:47,000 --> 00:24:49,000
它只是就呈现的不好

725
00:24:49,000 --> 00:24:51,000
其实你仔细看一下像 Mac 的

726
00:24:51,000 --> 00:24:53,000
那个叫做什么 System Provinces

727
00:24:53,000 --> 00:24:53,000
对

728
00:24:53,000 --> 00:24:54,000
里面它的形象也蛮多

729
00:24:54,000 --> 00:24:56,000
我记得那个 Win 98

730
00:24:56,000 --> 00:24:58,000
就是从 Windows Vista 时代开始

731
00:24:58,000 --> 00:25:02,000
你它也试图把那个功能组合

732
00:25:02,000 --> 00:25:03,000
就是那个

733
00:25:03,000 --> 00:25:05,000
也分成几个大组

734
00:25:05,000 --> 00:25:06,000
然后你可以一个一个点进去

735
00:25:06,000 --> 00:25:08,000
可是找起来太麻烦了

736
00:25:08,000 --> 00:25:08,000
对

737
00:25:08,000 --> 00:25:11,000
而且它的那个图形化的程度不够吗

738
00:25:11,000 --> 00:25:11,000
在那里

739
00:25:11,000 --> 00:25:12,000
对

740
00:25:12,000 --> 00:25:13,000
就你还是要读很多字

741
00:25:13,000 --> 00:25:15,000
感觉就觉得有一种

742
00:25:15,000 --> 00:25:17,000
很拥肿庞大的感觉

743
00:25:18,000 --> 00:25:18,000
对

744
00:25:18,000 --> 00:25:20,000
其实简单来说就一条

745
00:25:20,000 --> 00:25:21,000
就图标做得不够漂亮

746
00:25:24,000 --> 00:25:25,000
好了不吐槽这个了

747
00:25:26,000 --> 00:25:29,000
再插播一条小信物

748
00:25:29,000 --> 00:25:31,000
作为一个什么购语员的粉丝

749
00:25:31,000 --> 00:25:35,000
今天购语员发布了 1.4 的版本

750
00:25:36,000 --> 00:25:37,000
然后为什么突然要讲这件事情

751
00:25:37,000 --> 00:25:39,000
都是因为在这个版本里面

752
00:25:39,000 --> 00:25:43,000
它正式加入了安卓的支持

753
00:25:43,000 --> 00:25:44,000
所以就是你可以现在开始用

754
00:25:44,000 --> 00:25:46,000
购语员写游戏了

755
00:25:46,000 --> 00:25:47,000
就用 OpenGL 写游戏

756
00:25:47,000 --> 00:25:49,000
但如果你现在还要写那种

757
00:25:49,000 --> 00:25:50,000
普通的那种 App

758
00:25:50,000 --> 00:25:51,000
就是需要有这个标准化的界面

759
00:25:51,000 --> 00:25:54,000
可能还要用一下 Java 的这个东西去

760
00:25:54,000 --> 00:25:55,000
去做一下

761
00:25:55,000 --> 00:25:57,000
但如果你只是写游戏的话

762
00:25:57,000 --> 00:25:59,000
完全可以是只用购语员来 build

763
00:25:59,000 --> 00:26:00,000
就大家如果有兴趣

764
00:26:00,000 --> 00:26:01,000
可以去尝试一下

765
00:26:01,000 --> 00:26:02,000
对

766
00:26:02,000 --> 00:26:06,000
我记得这个是今年四月份

767
00:26:06,000 --> 00:26:07,000
还是什么时候就已经

768
00:26:07,000 --> 00:26:09,000
还是六月份就已经出来的

769
00:26:10,000 --> 00:26:11,000
放出来的

770
00:26:11,000 --> 00:26:13,000
风吧

771
00:26:13,000 --> 00:26:13,000
对

772
00:26:13,000 --> 00:26:15,000
他们在 1.3 的时候

773
00:26:15,000 --> 00:26:17,000
就半年前他已经在讲

774
00:26:17,000 --> 00:26:18,000
这个会有这个事情了

775
00:26:18,000 --> 00:26:20,000
其实 1.3 Beta 的时候

776
00:26:20,000 --> 00:26:21,000
就已经有这功能

777
00:26:21,000 --> 00:26:23,000
只是没有正式发布而已

778
00:26:24,000 --> 00:26:26,000
我觉得实际上的

779
00:26:26,000 --> 00:26:28,000
其实可能还要更早一样

780
00:26:28,000 --> 00:26:29,000
因为我记得在

781
00:26:31,000 --> 00:26:31,000
我不确定

782
00:26:31,000 --> 00:26:33,000
好像是在有一次

783
00:26:33,000 --> 00:26:37,000
Google Developer 大会上面

784
00:26:38,000 --> 00:26:40,000
我听到有人在问说

785
00:26:40,000 --> 00:26:43,000
开发 Android 可以用别的语言吗

786
00:26:43,000 --> 00:26:46,000
当时得到的答复是目前没有计划

787
00:26:47,000 --> 00:26:48,000
但

788
00:26:48,000 --> 00:26:50,000
他不是可以用那个 NDK 用

789
00:26:50,000 --> 00:26:51,000
然后 C 或 CJJ 加写吗

790
00:26:52,000 --> 00:26:53,000
那个时候还没有

791
00:26:54,000 --> 00:26:56,000
过去太久了

792
00:26:56,000 --> 00:26:57,000
2012 年可能是

793
00:26:58,000 --> 00:27:01,000
那是今年的 Google I

794
00:27:01,000 --> 00:27:02,000
OK

795
00:27:02,000 --> 00:27:03,000
对

796
00:27:04,000 --> 00:27:06,000
所以如果你是一个痛恨

797
00:27:06,000 --> 00:27:08,000
和我们一样痛恨 Java 的

798
00:27:08,000 --> 00:27:10,000
就是想然后又想写 Android 游戏

799
00:27:11,000 --> 00:27:13,000
现在你可以有一个官方支持的

800
00:27:13,000 --> 00:27:15,000
正式的替代选择了

801
00:27:15,000 --> 00:27:17,000
当然什么

802
00:27:17,000 --> 00:27:19,000
现在肯定是属于刚开发布的

803
00:27:19,000 --> 00:27:21,000
一个不太稳定的阶段

804
00:27:21,000 --> 00:27:23,000
如果前方坑多

805
00:27:23,000 --> 00:27:24,000
自己小心

806
00:27:26,000 --> 00:27:30,000
另外一个比较值得我挺高兴的事情

807
00:27:30,000 --> 00:27:32,000
是他们决定在下一个版本

808
00:27:32,000 --> 00:27:33,000
Google 1.5 的时候

809
00:27:33,000 --> 00:27:35,000
也就是大概半年之后发布的时候

810
00:27:35,000 --> 00:27:38,000
他们会加入正式的 iOS 的支持

811
00:27:39,000 --> 00:27:40,000
可是这个是什么意义

812
00:27:40,000 --> 00:27:43,000
它的具体的意思是什么呢

813
00:27:43,000 --> 00:27:48,000
就是我可以通过用 Go 来编出一个 iOS 的原生程序吗

814
00:27:50,000 --> 00:27:53,000
他应该可以用那个叫什么

815
00:27:53,000 --> 00:27:56,000
可以编译成一个 C 的原生代码

816
00:27:56,000 --> 00:27:59,000
就基于那个叫什么 ARM 平台的

817
00:28:00,000 --> 00:28:01,000
的 C 代码可以直接在这边跑

818
00:28:01,000 --> 00:28:04,000
但至于说你怎么去封装成一个 App

819
00:28:04,000 --> 00:28:06,000
可能后面还有一些要用到 Xcode 的东西

820
00:28:07,000 --> 00:28:10,000
他怎么才能去调用 Coco 的这对 API 呢

821
00:28:10,000 --> 00:28:12,000
就 Coco Touch 的这个 API

822
00:28:12,000 --> 00:28:14,000
他怎么才能

823
00:28:15,000 --> 00:28:19,000
切开苹果这一层厚厚的壁垒

824
00:28:19,000 --> 00:28:20,000
去调用这些 API 呢

825
00:28:20,000 --> 00:28:23,000
这可能会跟 Android 情况比较类似

826
00:28:23,000 --> 00:28:25,000
可能说是比如说你可以写游戏

827
00:28:25,000 --> 00:28:26,000
只用 OpenGL 写

828
00:28:26,000 --> 00:28:29,000
你写游戏的话可以不用那些 Coco 的东西

829
00:28:29,000 --> 00:28:30,000
就只有 Metal

830
00:28:31,000 --> 00:28:33,000
Metal 我都不知道它能不能

831
00:28:33,000 --> 00:28:33,000
具体怎么样

832
00:28:33,000 --> 00:28:35,000
他肯定如果他支持

833
00:28:35,000 --> 00:28:37,000
肯定是先支持 OpenGL 跟 Android 一样

834
00:28:37,000 --> 00:28:38,000
我觉得

835
00:28:39,000 --> 00:28:41,000
就那种你不需要调用很多系统级别的东西

836
00:28:41,000 --> 00:28:44,000
就纯粹做一个自己在那跑的一个应用

837
00:28:44,000 --> 00:28:45,000
但主要就是游戏了

838
00:28:45,000 --> 00:28:46,000
那可能

839
00:28:46,000 --> 00:28:48,000
然后他给你放在一个 Container 里面

840
00:28:48,000 --> 00:28:49,000
然后这 Container 给你好了

841
00:28:49,000 --> 00:28:52,000
有可能 Code 的话就是走这个路线

842
00:28:53,000 --> 00:28:53,000
对

843
00:28:53,000 --> 00:28:56,000
但如果你要说你要做一个带什么

844
00:28:56,000 --> 00:28:57,000
就普通的一个 App

845
00:28:57,000 --> 00:28:59,000
然后需要用那 Coco 的那些东西

846
00:28:59,000 --> 00:29:01,000
不是 Coco 那个叫什么

847
00:29:02,000 --> 00:29:04,000
Swift Objective-C

848
00:29:04,000 --> 00:29:06,000
就是那个 Runtime 不是那个 Runtime

849
00:29:06,000 --> 00:29:07,000
就那些酷的什么

850
00:29:07,000 --> 00:29:07,000
不叫 Coco

851
00:29:07,000 --> 00:29:08,000
UI Kit

852
00:29:08,000 --> 00:29:09,000
UI Kit 对

853
00:29:09,000 --> 00:29:13,000
然后你可能还是要写用 RJC 或者用 Swift 写

854
00:29:13,000 --> 00:29:15,000
然后再 Xcode 那边

855
00:29:15,000 --> 00:29:16,000
对大概情况是这样子

856
00:29:16,000 --> 00:29:18,000
然后就会说

857
00:29:18,000 --> 00:29:20,000
这个行为就比较有意思

858
00:29:20,000 --> 00:29:22,000
就说这个事情我们不知道将来会怎么样

859
00:29:22,000 --> 00:29:26,000
但是起码如果他在半年后真的做了

860
00:29:26,000 --> 00:29:28,000
这现在已经是他们内部已经放出话来

861
00:29:28,000 --> 00:29:29,000
要做这个事情

862
00:29:29,000 --> 00:29:31,000
但是就等下半版发布

863
00:29:32,000 --> 00:29:34,000
就说 Google 会有这么一个语言

864
00:29:34,000 --> 00:29:36,000
能够同时间跨平台

865
00:29:36,000 --> 00:29:37,000
就是 Google 的话

866
00:29:37,000 --> 00:29:40,000
它可以编译到普通的桌面和安卓

867
00:29:40,000 --> 00:29:41,000
包括以后的 IOS

868
00:29:41,000 --> 00:29:44,000
可以用一套语言写一套逻辑

869
00:29:44,000 --> 00:29:46,000
而且服务器端也可以用它写

870
00:29:46,000 --> 00:29:47,000
我觉得这是最妙的一点

871
00:29:47,000 --> 00:29:49,000
对

872
00:29:49,000 --> 00:29:52,000
其实之前在 Google Inbox

873
00:29:52,000 --> 00:29:53,000
你知道吗

874
00:29:53,000 --> 00:29:55,000
就是他之前写的邮件的客户端

875
00:29:55,000 --> 00:29:57,000
他们其实在一定程度上已经做了这件事情

876
00:29:57,000 --> 00:29:58,000
但不过他是进入 Java 的

877
00:29:58,000 --> 00:30:00,000
就是所有的业务逻辑

878
00:30:00,000 --> 00:30:02,000
使用 Java 来写

879
00:30:02,000 --> 00:30:04,000
然后通过两个技术

880
00:30:04,000 --> 00:30:06,000
然后一个叫做 GWT

881
00:30:06,000 --> 00:30:08,000
把 Java 编译成网页版

882
00:30:08,000 --> 00:30:10,000
然后在 Chrome 里面跑

883
00:30:11,000 --> 00:30:13,000
然后另外一个是

884
00:30:13,000 --> 00:30:14,000
真的

885
00:30:14,000 --> 00:30:15,000
真的是这样

886
00:30:15,000 --> 00:30:17,000
GWTGoogle 还在用吗

887
00:30:17,000 --> 00:30:18,000
我不确定

888
00:30:18,000 --> 00:30:20,000
他们很多这个

889
00:30:20,000 --> 00:30:24,000
Gmail 的后台也是这么弄出来的吧

890
00:30:24,000 --> 00:30:24,000
记得

891
00:30:24,000 --> 00:30:26,000
OMFG

892
00:30:26,000 --> 00:30:27,000
我以为

893
00:30:27,000 --> 00:30:28,000
不这个不奇怪

894
00:30:28,000 --> 00:30:29,000
Google 这么大一个 Java 手

895
00:30:29,000 --> 00:30:30,000
有什么好奇怪

896
00:30:31,000 --> 00:30:32,000
不

897
00:30:32,000 --> 00:30:35,000
可是 GWT 不是已经早就变成一个

898
00:30:35,000 --> 00:30:37,000
Community 维护的 Framework 了吗

899
00:30:37,000 --> 00:30:39,000
Google 不是自己在主推

900
00:30:39,000 --> 00:30:40,000
AngularJS 之类的东西吗

901
00:30:41,000 --> 00:30:41,000
不

902
00:30:41,000 --> 00:30:43,000
那个是

903
00:30:44,000 --> 00:30:45,000
我理解好 AngularJS

904
00:30:45,000 --> 00:30:48,000
那些是他们纯粹做网页的前端的时候

905
00:30:48,000 --> 00:30:49,000
用那个没有问题

906
00:30:49,000 --> 00:30:52,000
但是问题是要涉及到这种跨平台的东西的话

907
00:30:52,000 --> 00:30:53,000
他们的就是

908
00:30:53,000 --> 00:30:55,000
所以的 canonical version

909
00:30:55,000 --> 00:30:57,000
还是 Java 版本的

910
00:30:57,000 --> 00:30:58,000
就是 Gmail 是这样子

911
00:30:58,000 --> 00:31:00,000
然后那个像 Inbox 也是这样子

912
00:31:00,000 --> 00:31:03,000
然后他们 Inbox 不是也有 IOS 版吗

913
00:31:03,000 --> 00:31:05,000
然后 IOS 版的就是业务逻辑那部分

914
00:31:05,000 --> 00:31:06,000
他们是用一个叫做

915
00:31:08,000 --> 00:31:10,000
J 2 Object-C 还是这什么

916
00:31:10,000 --> 00:31:13,000
就是把 Java 编译成

917
00:31:13,000 --> 00:31:15,000
Object-C 代码的方法

918
00:31:15,000 --> 00:31:17,000
What kind of software is this

919
00:31:18,000 --> 00:31:19,000
但是他们这个也有它的道理

920
00:31:19,000 --> 00:31:23,000
就是你要维护同一个产品的业务逻辑

921
00:31:23,000 --> 00:31:24,000
要保证跨平台

922
00:31:24,000 --> 00:31:26,000
如果你每个平台单独写套的话

923
00:31:26,000 --> 00:31:29,000
那肯定就等于是像什么 bug

924
00:31:29,000 --> 00:31:31,000
还有那时候开发量就全部每个

925
00:31:31,000 --> 00:31:33,000
就有多少个平台

926
00:31:33,000 --> 00:31:34,000
你就要乘以多少个数

927
00:31:34,000 --> 00:31:35,000
他这样的话

928
00:31:35,000 --> 00:31:37,000
就只用解决一个问题

929
00:31:37,000 --> 00:31:38,000
就一套代码库

930
00:31:38,000 --> 00:31:41,000
然后之后都可以靠这个编译

931
00:31:41,000 --> 00:31:43,000
就是有这种跨平台的编译器来解决这个问题

932
00:31:43,000 --> 00:31:44,000
在理想情况下是这样

933
00:31:44,000 --> 00:31:47,000
对但是它的 UI 那部分

934
00:31:47,000 --> 00:31:49,000
比如说像安卓的 UI

935
00:31:49,000 --> 00:31:52,000
它是用原生的那个 Java 来写

936
00:31:52,000 --> 00:31:55,000
然后在 IOS 它是用 Object-C 来封装的

937
00:31:55,000 --> 00:31:58,000
然后但是只说业务

938
00:31:58,000 --> 00:32:00,000
就是跟那种平台的关系

939
00:32:00,000 --> 00:32:01,000
不是很紧密的业务逻辑那部分

940
00:32:01,000 --> 00:32:03,000
他们是用一个 Java

941
00:32:03,000 --> 00:32:05,000
然后从这种编译的方法来实现

942
00:32:06,000 --> 00:32:07,000
那么同样的道理

943
00:32:07,000 --> 00:32:09,000
就是说如果以后勾的话

944
00:32:09,000 --> 00:32:10,000
也可以差不多可以

945
00:32:10,000 --> 00:32:12,000
也许可以做类似的事情

946
00:32:14,000 --> 00:32:17,000
但这个事情有跟上一期我们讲

947
00:32:17,000 --> 00:32:19,000
那个微软的计划有点相关

948
00:32:19,000 --> 00:32:22,000
就它是要声称是用那个 Dotnet

949
00:32:23,000 --> 00:32:27,000
支持安卓和 IOS 的跨平台的开发

950
00:32:27,000 --> 00:32:29,000
但其实我知道它的用心也很清楚

951
00:32:29,000 --> 00:32:31,000
就是顺带夹点私货

952
00:32:31,000 --> 00:32:33,000
你们都反正都一套带马了

953
00:32:33,000 --> 00:32:36,000
那不如顺便编一个 Windows Phone 的版本

954
00:32:37,000 --> 00:32:39,000
以此解决那个什么 Windows Phone 上面

955
00:32:39,000 --> 00:32:41,000
那个应用数不足

956
00:32:41,000 --> 00:32:43,000
然后这个开发者又不愿意开发的

957
00:32:43,000 --> 00:32:45,000
这么一个尴尬局面吧

958
00:32:45,000 --> 00:32:45,000
对

959
00:32:45,000 --> 00:32:47,000
这还算是一个机声弹带声机的问题

960
00:32:47,000 --> 00:32:49,000
就恶性循环

961
00:32:49,000 --> 00:32:52,000
说你们不想给我声弹

962
00:32:52,000 --> 00:32:54,000
那我送你一个机包声所有的

963
00:32:54,000 --> 00:32:57,000
对你顺手帮我克隆一个弹

964
00:32:57,000 --> 00:32:58,000
对

965
00:32:58,000 --> 00:33:00,000
他就是打的那个小算盘

966
00:33:00,000 --> 00:33:00,000
我觉得

967
00:33:00,000 --> 00:33:01,000
嗯

968
00:33:01,000 --> 00:33:04,000
好那个就插播的广告到这里

969
00:33:04,000 --> 00:33:05,000
OK

970
00:33:05,000 --> 00:33:07,000
正题是什么

971
00:33:08,000 --> 00:33:10,000
我先放音乐吧

972
00:33:10,000 --> 00:33:11,000
好

973
00:33:13,000 --> 00:33:15,000
我实在是太细心了

974
00:33:15,000 --> 00:33:17,000
Sarcasm self test complete

975
00:33:17,000 --> 00:33:21,000
我们本来打算在这里插入电子游戏 Portal 的主题曲

976
00:33:21,000 --> 00:33:24,000
是 Steel Live 的一个电子合成器版本

977
00:33:24,000 --> 00:33:26,000
但是经过事后的一番研究

978
00:33:26,000 --> 00:33:28,000
发现这首歌的授权

979
00:33:28,000 --> 00:33:32,000
其实并不是像我原先以为的那样

980
00:33:32,000 --> 00:33:36,000
以创作功用署名非商业写意发布

981
00:33:36,000 --> 00:33:37,000
原作者 Johnson Carlton

982
00:33:37,000 --> 00:33:42,000
其实已经将这首歌的版权给了 Portal 游戏的制作商 Valve

983
00:33:42,000 --> 00:33:45,000
所以我们需要先询问一下 Valve

984
00:33:45,000 --> 00:33:48,000
是否可以将它用在我们的节目里

985
00:33:48,000 --> 00:33:51,000
而目前的现状是

986
00:33:51,000 --> 00:33:58,000
我跟 Rail 在接下来的内容里面会反复提到 Portal 以及这首歌

987
00:33:58,000 --> 00:34:02,000
如果你不听一下的话可能会有点奇怪

988
00:34:03,000 --> 00:34:05,000
anyway 和大家说一声抱歉

989
00:34:06,000 --> 00:34:08,000
I don't blame you

990
00:34:09,000 --> 00:34:14,000
北美山地时间 2006 年 1 月 2 日下午 3 点 04 分 05 秒

991
00:34:14,000 --> 00:34:18,000
您正在收听的是 IPN Podcast 网络旗下的内核恐慌

992
00:34:19,000 --> 00:34:22,000
我们号称硬核但是也没有什么干货

993
00:34:22,000 --> 00:34:25,000
想听的人听不想听的人就不要听

994
00:34:26,000 --> 00:34:27,000
好拽的一句话

995
00:34:27,000 --> 00:34:29,000
有点怪

996
00:34:30,000 --> 00:34:34,000
对然后就像大家刚才听到的这样

997
00:34:34,000 --> 00:34:37,000
我们从这一期开始有我们的主题曲了

998
00:34:37,000 --> 00:34:38,000
耶

999
00:34:40,000 --> 00:34:45,000
对然后原起其实就是看 IT 公论有主题曲

1000
00:34:45,000 --> 00:34:46,000
我挺眼红的

1001
00:34:46,000 --> 00:34:47,000
我也想要有

1002
00:34:47,000 --> 00:34:53,000
但是一直拖到我们已经做了 5 期了 10 个礼拜了

1003
00:34:53,000 --> 00:34:59,000
过去了才终于找到了这么一个也不算非常合意

1004
00:34:59,000 --> 00:35:01,000
但是觉得还不错的主题曲

1005
00:35:01,000 --> 00:35:02,000
当然

1006
00:35:04,000 --> 00:35:05,000
如果你知道它是什么来头

1007
00:35:05,000 --> 00:35:06,000
那你知道它是什么来头

1008
00:35:06,000 --> 00:35:11,000
如果你不知道的话它是一个游戏

1009
00:35:11,000 --> 00:35:18,000
就是如果各位有听前两期的 IT 公论的话

1010
00:35:18,000 --> 00:35:25,000
会注意到 Rail 和刘一都在节目之中谈到了 Portal 这个游戏

1011
00:35:25,000 --> 00:35:31,000
然后刚才大家听到的这段旋律就是 Portal 一代里面的主题曲

1012
00:35:31,000 --> 00:35:32,000
应该算

1013
00:35:32,000 --> 00:35:38,000
因为虽然整个完整的音乐是在

1014
00:35:38,000 --> 00:35:39,000
它是有歌了

1015
00:35:39,000 --> 00:35:43,000
它是在游戏最终打穿之后才播出的

1016
00:35:43,000 --> 00:35:45,000
但是其实你一开始游戏

1017
00:35:45,000 --> 00:35:46,000
那个

1018
00:35:47,000 --> 00:35:49,000
spoiler alert

1019
00:35:49,000 --> 00:35:54,000
就是一开始你在游戏里面捡起的声音机里面放的就是这首曲

1020
00:35:54,000 --> 00:35:56,000
然后在你打爆机的时候

1021
00:35:56,000 --> 00:35:58,000
最后出字幕的时候也是放了这个

1022
00:35:58,000 --> 00:36:00,000
放的是这个完整版

1023
00:36:00,000 --> 00:36:03,000
对整首歌会被正式的唱一遍

1024
00:36:03,000 --> 00:36:07,000
其实我第一次听这歌还没有玩 Portal 这个游戏

1025
00:36:07,000 --> 00:36:10,000
但是有一个什么机缘巧合

1026
00:36:10,000 --> 00:36:11,000
我就听了那个歌

1027
00:36:11,000 --> 00:36:12,000
我觉得哇好可爱

1028
00:36:12,000 --> 00:36:13,000
真的吗

1029
00:36:13,000 --> 00:36:15,000
你在没有玩任何游戏的时候就听过这首歌

1030
00:36:17,000 --> 00:36:18,000
有意思

1031
00:36:18,000 --> 00:36:20,000
然后它有歌词

1032
00:36:20,000 --> 00:36:24,000
然后它有一个动画效果

1033
00:36:24,000 --> 00:36:24,000
然后你去看

1034
00:36:25,000 --> 00:36:26,000
那个感觉真的超好

1035
00:36:27,000 --> 00:36:27,000
对

1036
00:36:27,000 --> 00:36:29,000
反正总之

1037
00:36:29,000 --> 00:36:31,000
就像我推荐 Rail

1038
00:36:31,000 --> 00:36:33,000
就为什么 Rail 会花一天

1039
00:36:33,000 --> 00:36:36,000
就是花了一周时间玩了 Portal 一

1040
00:36:36,000 --> 00:36:39,000
然后又花了一整天时间打出 Portal 二呢

1041
00:36:39,000 --> 00:36:42,000
就是因为我向他吐血强力推荐

1042
00:36:42,000 --> 00:36:43,000
我逼着他去玩

1043
00:36:43,000 --> 00:36:46,000
因为 Rail 其实有

1044
00:36:46,000 --> 00:36:51,000
玩第一任车设计游戏会上吐下不屑

1045
00:36:51,000 --> 00:36:53,000
在我的强迫之下

1046
00:36:53,000 --> 00:36:54,000
他还是去玩了一遍

1047
00:36:54,000 --> 00:36:57,000
然后我推荐他玩的契机

1048
00:36:57,000 --> 00:37:03,000
也就是希望能够选用这首曲子来作为游戏主题曲

1049
00:37:03,000 --> 00:37:04,000
作为节目的主题曲

1050
00:37:04,000 --> 00:37:08,000
然后希望他能够理解这个游戏的

1051
00:37:08,000 --> 00:37:11,000
或者说这首音乐的有意思的地方在哪

1052
00:37:12,000 --> 00:37:13,000
但其实我要说

1053
00:37:13,000 --> 00:37:15,000
就是在我玩这个游戏之前

1054
00:37:15,000 --> 00:37:17,000
我光看那个歌就已经觉得蛮有意思了

1055
00:37:17,000 --> 00:37:18,000
但就是说

1056
00:37:18,000 --> 00:37:20,000
只是对里面的有些歌词的部分

1057
00:37:20,000 --> 00:37:22,000
跟理解不是那么深刻

1058
00:37:22,000 --> 00:37:24,000
不知道为什么他要说那件事

1059
00:37:24,000 --> 00:37:25,000
你玩完游戏之后你就

1060
00:37:25,000 --> 00:37:27,000
啊原来是这个意思

1061
00:37:27,000 --> 00:37:27,000
对

1062
00:37:27,000 --> 00:37:30,000
比如说整个歌词里面的每一句

1063
00:37:30,000 --> 00:37:32,000
其实都可以在游戏里面找到线索

1064
00:37:32,000 --> 00:37:38,000
另外这个歌曲也本身有点很有

1065
00:37:40,000 --> 00:37:42,000
因为它本身就是一个 geek 写出来的

1066
00:37:42,000 --> 00:37:44,000
这首歌的作者是一个

1067
00:37:44,000 --> 00:37:46,000
是在 geek 界非常有名的一个人

1068
00:37:46,000 --> 00:37:48,000
他叫做 Jonathan Carlton

1069
00:37:49,000 --> 00:37:52,000
他写了很多说不上快日人口

1070
00:37:52,000 --> 00:37:53,000
但是非常 geek 的歌

1071
00:37:53,000 --> 00:37:56,000
比如说这首歌的歌词里面有一句是

1072
00:37:58,000 --> 00:38:00,000
We are out of beta, we are losing on time

1073
00:38:00,000 --> 00:38:02,000
很有意思

1074
00:38:05,000 --> 00:38:08,000
有时候我在公司发现

1075
00:38:08,000 --> 00:38:11,000
这个 Deadline 又一次被推迟的时候

1076
00:38:11,000 --> 00:38:13,000
我就会在心里默默唱这首歌

1077
00:38:13,000 --> 00:38:17,000
We are out of beta, we are losing on time

1078
00:38:19,000 --> 00:38:22,000
在游戏界其实是非常严重的一个问题

1079
00:38:22,000 --> 00:38:26,000
就是游戏作为一种特殊的软件

1080
00:38:26,000 --> 00:38:30,000
其玩家对于跳票的容忍能力是非常差的

1081
00:38:31,000 --> 00:38:33,000
除非你是暴雪或者是

1082
00:38:37,000 --> 00:38:40,000
或者是 Valve 这种大公司

1083
00:38:40,000 --> 00:38:47,000
否则你一般很难去面对玩家的愤怒

1084
00:38:47,000 --> 00:38:51,000
而且 Gamer 其实是非常容易一怒的一个人群

1085
00:38:51,000 --> 00:38:56,000
就像之前的 Gamergate 里面连暴露出来一个现状一样

1086
00:38:57,000 --> 00:39:02,000
这是一群打了鸡血的人

1087
00:39:02,000 --> 00:39:03,000
荷尔蒙无处挥发

1088
00:39:03,000 --> 00:39:07,000
然后又不知道怎么跟女生交流的这样一群人

1089
00:39:09,000 --> 00:39:10,000
他们的情商是非常低的

1090
00:39:10,000 --> 00:39:15,000
所以他们基本上宣扬泄愤的唯一方法就是骂你

1091
00:39:15,000 --> 00:39:21,000
然后游戏公司是最容易被骂的狗血喷头的一方

1092
00:39:21,000 --> 00:39:24,000
所以不能按时交付软件

1093
00:39:24,000 --> 00:39:26,000
其实对于他们来说是非常严重的

1094
00:39:27,000 --> 00:39:29,000
所以其实从这一点说来

1095
00:39:29,000 --> 00:39:32,000
像我这种星际玩家还是蛮能等的

1096
00:39:34,000 --> 00:39:38,000
其实咱们都算是休闲型玩家

1097
00:39:39,000 --> 00:39:42,000
骨灰界玩家等星期二已经等的不知道

1098
00:39:43,000 --> 00:39:46,000
已经不知道把鲍雪默默卖下了多少遍了

1099
00:39:47,000 --> 00:39:49,000
所以你玩 Porto 有什么观感

1100
00:39:50,000 --> 00:39:51,000
我先解决那个问题

1101
00:39:51,000 --> 00:39:53,000
我不知道为什么我玩 Porto

1102
00:39:53,000 --> 00:39:56,000
一我只能玩就可能不超过半小时了

1103
00:39:56,000 --> 00:39:58,000
不然就会头晕想吐

1104
00:39:59,000 --> 00:40:01,000
但是我玩 Porto 二好像没有这个原因

1105
00:40:01,000 --> 00:40:02,000
但我想不明白为什么

1106
00:40:02,000 --> 00:40:04,000
Porto 二的引擎和 Porto 一不一样

1107
00:40:04,000 --> 00:40:08,000
但是我直观地看那个画面的时候

1108
00:40:08,000 --> 00:40:09,000
没有看出太大的区别

1109
00:40:10,000 --> 00:40:13,000
Porto 二的画面的精细程度要比一好很多

1110
00:40:13,000 --> 00:40:15,000
是因为你说它精度不够

1111
00:40:15,000 --> 00:40:17,000
所以觉得头晕想吐

1112
00:40:17,000 --> 00:40:20,000
也有可能是 somehow 一代的帧率不够高

1113
00:40:21,000 --> 00:40:21,000
不可能

1114
00:40:21,000 --> 00:40:23,000
一代的游戏 2007 年的 Porto 游戏

1115
00:40:23,000 --> 00:40:25,000
现在的机器跑肯定没问题

1116
00:40:26,000 --> 00:40:28,000
而且我玩游戏它推荐给我的设置

1117
00:40:28,000 --> 00:40:31,000
都还是蛮高的特效的量

1118
00:40:32,000 --> 00:40:33,000
机器应该不是问题

1119
00:40:33,000 --> 00:40:35,000
就这个事情是一个挺贵

1120
00:40:35,000 --> 00:40:37,000
我玩所有的射击游戏都会

1121
00:40:37,000 --> 00:40:40,000
就第一人称视角的这种算是射击游戏

1122
00:40:41,000 --> 00:40:42,000
都有这个问题

1123
00:40:42,000 --> 00:40:45,000
以前玩 Counter Strike CS 的时候

1124
00:40:45,000 --> 00:40:48,000
也是大概 20 分钟半小时就不行了

1125
00:40:48,000 --> 00:40:51,000
必须得造不然要想吐

1126
00:40:52,000 --> 00:40:53,000
你就是传说中猪一样的队友

1127
00:40:56,000 --> 00:40:56,000
对

1128
00:40:56,000 --> 00:41:00,000
所以你看我忍着头晕想吐这种风险

1129
00:41:00,000 --> 00:41:02,000
就把 Porto 也打完了

1130
00:41:02,000 --> 00:41:02,000
你看

1131
00:41:02,000 --> 00:41:04,000
太过意思了

1132
00:41:05,000 --> 00:41:09,000
会不会是因为一代和二代里面的人

1133
00:41:09,000 --> 00:41:11,000
相机视野不一样

1134
00:41:11,000 --> 00:41:13,000
我还真没看出来

1135
00:41:13,000 --> 00:41:14,000
我比较过一下

1136
00:41:14,000 --> 00:41:16,000
但是没有什么特别明显的区别

1137
00:41:18,000 --> 00:41:20,000
反正这个事情就很让我奇怪

1138
00:41:20,000 --> 00:41:22,000
也可能是说

1139
00:41:22,000 --> 00:41:24,000
我玩一的时候就是已经训练过一下了

1140
00:41:24,000 --> 00:41:25,000
然后玩的时候觉得

1141
00:41:25,000 --> 00:41:27,000
刚之前已经折腾过那么久了

1142
00:41:27,000 --> 00:41:29,000
这次是不是就好一点

1143
00:41:30,000 --> 00:41:33,000
也有可能是二代的场景相对于一代来说

1144
00:41:33,000 --> 00:41:34,000
更空旷一点

1145
00:41:34,000 --> 00:41:36,000
就可能有那种纵深感

1146
00:41:36,000 --> 00:41:37,000
你就不太容易

1147
00:41:37,000 --> 00:41:38,000
对

1148
00:41:38,000 --> 00:41:39,000
它会大

1149
00:41:39,000 --> 00:41:40,000
看起来很大一些

1150
00:41:41,000 --> 00:41:42,000
有可能吧

1151
00:41:42,000 --> 00:41:45,000
然后你说你用一天时间打出来的 Porto 2

1152
00:41:45,000 --> 00:41:46,000
我觉得还挺惊讶的

1153
00:41:46,000 --> 00:41:47,000
就是

1154
00:41:48,000 --> 00:41:49,000
我因为 Porto 2

1155
00:41:49,000 --> 00:41:51,000
我可能玩过两次三次

1156
00:41:51,000 --> 00:41:52,000
对

1157
00:41:52,000 --> 00:41:56,000
但我从来没有说一天在玩这个游戏

1158
00:41:56,000 --> 00:41:59,000
Porto 2 它的那个场景是比一要

1159
00:41:59,000 --> 00:42:01,000
大概是四倍左右

1160
00:42:01,000 --> 00:42:02,000
我估计

1161
00:42:02,000 --> 00:42:04,000
就是从我的玩的体验来看

1162
00:42:04,000 --> 00:42:06,000
就是整个你打穿的长度

1163
00:42:06,000 --> 00:42:09,000
因为 Porto 1 的就只有那 19 个 Test Chamber

1164
00:42:10,000 --> 00:42:12,000
其实 Porto 2 不止四倍

1165
00:42:12,000 --> 00:42:14,000
因为 Porto 2 还有一个协作模式

1166
00:42:14,000 --> 00:42:15,000
你可能

1167
00:42:15,000 --> 00:42:16,000
那个是无线的对吧

1168
00:42:17,000 --> 00:42:18,000
对

1169
00:42:18,000 --> 00:42:19,000
那个其实也是

1170
00:42:19,000 --> 00:42:21,000
我不是很记得了

1171
00:42:21,000 --> 00:42:24,000
但是我相信它默认带的那些

1172
00:42:25,000 --> 00:42:26,000
Temper 也是有线的

1173
00:42:26,000 --> 00:42:28,000
就是如果你有兴趣的话

1174
00:42:28,000 --> 00:42:29,000
以后咱们可以试一下

1175
00:42:29,000 --> 00:42:31,000
就是它可以支持两个好友

1176
00:42:31,000 --> 00:42:31,000
对

1177
00:42:31,000 --> 00:42:34,000
一个就是它就是在 Porto 2 最后结束的时候

1178
00:42:34,000 --> 00:42:35,000
又要去偷了

1179
00:42:36,000 --> 00:42:38,000
就是你会看到两个机器人

1180
00:42:38,000 --> 00:42:41,000
一个是成脸一个是蓝脸

1181
00:42:42,000 --> 00:42:46,000
然后你可以和自己的同伴各自操作一个

1182
00:42:46,000 --> 00:42:49,000
然后两个机器人各自拿着一把 Porto Gun

1183
00:42:49,000 --> 00:42:53,000
然后等于你可以在同一时间里面有四个 Porto

1184
00:42:53,000 --> 00:42:55,000
然后其中两两是互通的

1185
00:42:55,000 --> 00:42:57,000
然后就可以打出更多组合来

1186
00:42:57,000 --> 00:43:01,000
就你必须在队友的配合之下才可以解开一些

1187
00:43:01,000 --> 00:43:02,000
谜题是吧

1188
00:43:02,000 --> 00:43:04,000
那也是有剧情的吗

1189
00:43:04,000 --> 00:43:05,000
那个没有剧情

1190
00:43:05,000 --> 00:43:07,000
那个好像

1191
00:43:07,000 --> 00:43:08,000
就只是一个联机模式而已

1192
00:43:08,000 --> 00:43:11,000
好像只是一个协作模式而已

1193
00:43:11,000 --> 00:43:14,000
所以我就说就单看

1194
00:43:14,000 --> 00:43:15,000
单看主线剧情的话

1195
00:43:15,000 --> 00:43:16,000
对

1196
00:43:16,000 --> 00:43:17,000
Porto 2 可能

1197
00:43:17,000 --> 00:43:18,000
对

1198
00:43:18,000 --> 00:43:19,000
剧情是蛮长

1199
00:43:19,000 --> 00:43:21,000
当时我记得我是跑完了

1200
00:43:21,000 --> 00:43:22,000
那个

1201
00:43:23,000 --> 00:43:23,000
那个叫什么

1202
00:43:26,000 --> 00:43:28,000
从那个地下爬出来

1203
00:43:28,000 --> 00:43:29,000
不是从地下爬出来

1204
00:43:30,000 --> 00:43:30,000
对

1205
00:43:30,000 --> 00:43:32,000
从地下爬出来见到那个最开始

1206
00:43:32,000 --> 00:43:33,000
又要去偷了

1207
00:43:33,000 --> 00:43:34,000
怎么办

1208
00:43:34,000 --> 00:43:35,000
没关系

1209
00:43:35,000 --> 00:43:37,000
就是你找回那个土豆之后

1210
00:43:37,000 --> 00:43:39,000
我觉得那个可能爬出来就完了

1211
00:43:39,000 --> 00:43:42,000
因为之前已经有 Test Chamber 有打过

1212
00:43:42,000 --> 00:43:43,000
然后之后有一个正式的剧情

1213
00:43:43,000 --> 00:43:44,000
觉得已经蛮长

1214
00:43:44,000 --> 00:43:47,000
最后想不到这段还有一遍 Test Chamber

1215
00:43:47,000 --> 00:43:48,000
又有一个新一轮的

1216
00:43:48,000 --> 00:43:49,000
就觉得还蛮奇怪

1217
00:43:51,000 --> 00:43:56,000
因为 Test Chamber 本身也是它游戏最大的魅力

1218
00:43:57,000 --> 00:43:57,000
对

1219
00:43:57,000 --> 00:44:00,000
但是我没想到就是最开始有一个 Test Chamber

1220
00:44:00,000 --> 00:44:02,000
然后中间有剧情

1221
00:44:02,000 --> 00:44:03,000
完了还有一 Test Chamber

1222
00:44:04,000 --> 00:44:05,000
就完全没有

1223
00:44:05,000 --> 00:44:07,000
就是这个是我出乎我预料的一个地方

1224
00:44:07,000 --> 00:44:07,000
然后

1225
00:44:08,000 --> 00:44:09,000
就是会觉得有点

1226
00:44:09,000 --> 00:44:11,000
打到后面就想怎么没完没了

1227
00:44:11,000 --> 00:44:12,000
还没有完

1228
00:44:14,000 --> 00:44:17,000
但是剧情很有意思

1229
00:44:17,000 --> 00:44:17,000
剧情很有趣

1230
00:44:17,000 --> 00:44:19,000
然后也不会觉得很无聊

1231
00:44:19,000 --> 00:44:19,000
这样

1232
00:44:20,000 --> 00:44:21,000
OK

1233
00:44:21,000 --> 00:44:24,000
所以你有想明白一代和二代

1234
00:44:24,000 --> 00:44:27,000
就是你知道一代和二代的主角是同一个人吗

1235
00:44:28,000 --> 00:44:28,000
我知道

1236
00:44:28,000 --> 00:44:31,000
就是他从那个最开始介绍的那个时间的线

1237
00:44:31,000 --> 00:44:32,000
看出来就是这样

1238
00:44:32,000 --> 00:44:33,000
又看出来

1239
00:44:34,000 --> 00:44:34,000
对

1240
00:44:34,000 --> 00:44:38,000
那你有想过为什么主角又回去重新做实验了吗

1241
00:44:40,000 --> 00:44:41,000
这个我倒没有想过

1242
00:44:41,000 --> 00:44:41,000
为什么

1243
00:44:42,000 --> 00:44:45,000
就是一代和二代的剧情其实连着的

1244
00:44:45,000 --> 00:44:46,000
就是一代的结尾

1245
00:44:46,000 --> 00:44:47,000
你

1246
00:44:49,000 --> 00:44:51,000
把 Gladys 打爆之后

1247
00:44:51,000 --> 00:44:52,000
到了地面上

1248
00:44:52,000 --> 00:44:53,000
然后看起来

1249
00:44:53,000 --> 00:44:54,000
在一个看起来像停车场的地方

1250
00:44:54,000 --> 00:44:56,000
你会

1251
00:44:56,000 --> 00:44:57,000
就是当时最 Porto 1

1252
00:44:58,000 --> 00:45:01,000
刚刚出来的时候

1253
00:45:01,000 --> 00:45:03,000
最终的结局就是你看你重建天真

1254
00:45:03,000 --> 00:45:04,000
然后就完了

1255
00:45:04,000 --> 00:45:05,000
那个是假的

1256
00:45:05,000 --> 00:45:06,000
对吧

1257
00:45:06,000 --> 00:45:07,000
那个也是

1258
00:45:07,000 --> 00:45:08,000
那个也是

1259
00:45:08,000 --> 00:45:11,000
后来我看你有一个网上的别人做的视频

1260
00:45:12,000 --> 00:45:13,000
就也是他冲

1261
00:45:13,000 --> 00:45:14,000
就是个真人版的

1262
00:45:14,000 --> 00:45:16,000
真人版的一个电影

1263
00:45:16,000 --> 00:45:17,000
小电影

1264
00:45:18,000 --> 00:45:20,000
就说他好像是冲出去之后

1265
00:45:20,000 --> 00:45:22,000
发现周围的那些景物看起来是真的

1266
00:45:22,000 --> 00:45:22,000
但其实

1267
00:45:22,000 --> 00:45:23,000
Porto 1 看都是屏幕

1268
00:45:23,000 --> 00:45:24,000
对吧

1269
00:45:24,000 --> 00:45:25,000
不是

1270
00:45:25,000 --> 00:45:28,000
就是在 Porto 2 出现之后

1271
00:45:28,000 --> 00:45:30,000
Porto 1 有了一个 update

1272
00:45:30,000 --> 00:45:31,000
有一个 patch

1273
00:45:31,000 --> 00:45:33,000
把这个 patch 把结局改了

1274
00:45:33,000 --> 00:45:35,000
你重建天真之后

1275
00:45:36,000 --> 00:45:37,000
自己受伤了

1276
00:45:37,000 --> 00:45:38,000
然后你

1277
00:45:39,000 --> 00:45:40,000
你第一人生视角会

1278
00:45:40,000 --> 00:45:43,000
感觉到自己正在被一个机器人

1279
00:45:43,000 --> 00:45:45,000
正在被一个什么东西往回拖

1280
00:45:45,000 --> 00:45:47,000
然后一个机器人的声音说

1281
00:45:47,000 --> 00:45:50,000
请你保持一个 party submission position

1282
00:45:50,000 --> 00:45:53,000
就是要参加 party 的这么一个姿势

1283
00:45:53,000 --> 00:45:54,000
然后它把你慢慢往回拖

1284
00:45:54,000 --> 00:45:58,000
然后那个整个的画面才按下去

1285
00:45:58,000 --> 00:45:59,000
然后

1286
00:45:59,000 --> 00:46:01,000
一代和二代之间的剧情

1287
00:46:01,000 --> 00:46:04,000
其实可以通过一部漫画解释

1288
00:46:04,000 --> 00:46:07,000
就是 Wolf 专门

1289
00:46:07,000 --> 00:46:12,000
发了一本漫画叫做 Porto 的 Labret

1290
00:46:12,000 --> 00:46:17,000
然后在这里面解释了整件事情能去卖

1291
00:46:17,000 --> 00:46:18,000
就是

1292
00:46:19,000 --> 00:46:20,000
如果你玩过 Porto 的话

1293
00:46:20,000 --> 00:46:21,000
你可能会好奇

1294
00:46:21,000 --> 00:46:23,000
就是为什么里面的人都死了

1295
00:46:23,000 --> 00:46:23,000
他们是怎么死的

1296
00:46:25,000 --> 00:46:27,000
然后 Labret 这个漫画

1297
00:46:27,000 --> 00:46:28,000
其实就解释了这一点

1298
00:46:28,000 --> 00:46:29,000
就是

1299
00:46:30,000 --> 00:46:32,000
但是这个在

1300
00:46:32,000 --> 00:46:32,000
叫什么

1301
00:46:32,000 --> 00:46:34,000
在 Porto 2 进场的时候

1302
00:46:34,000 --> 00:46:36,000
就最开始那一些的

1303
00:46:36,000 --> 00:46:37,000
不对

1304
00:46:37,000 --> 00:46:40,000
所以在 Porto 2 最后那部分的 test chamber

1305
00:46:40,000 --> 00:46:42,000
你每次出来不是一个电梯吗

1306
00:46:42,000 --> 00:46:46,000
然后它电梯墙面上不是有一堆破碎的屏幕吗

1307
00:46:46,000 --> 00:46:48,000
能够看出一点端倪吧

1308
00:46:48,000 --> 00:46:50,000
机器人什么

1309
00:46:50,000 --> 00:46:52,000
就是突然发飙了

1310
00:46:52,000 --> 00:46:53,000
然后把那些人都干掉了

1311
00:46:53,000 --> 00:46:54,000
其实在

1312
00:46:54,000 --> 00:46:55,000
Laptore

1313
00:46:55,000 --> 00:46:56,000
就在

1314
00:46:57,000 --> 00:46:58,000
Aperture Science Laboratory 里面

1315
00:46:59,000 --> 00:47:01,000
人们研究出来的

1316
00:47:01,000 --> 00:47:03,000
就是真正的人工智能

1317
00:47:04,000 --> 00:47:06,000
Glottos 这个名字的缩写

1318
00:47:06,000 --> 00:47:08,000
就是整个片中的

1319
00:47:08,000 --> 00:47:11,000
女人工智能的名字

1320
00:47:11,000 --> 00:47:13,000
Glottos 它的缩写就是

1321
00:47:13,000 --> 00:47:14,000
General Lifeform

1322
00:47:15,000 --> 00:47:16,000
And

1323
00:47:16,000 --> 00:47:18,000
Disk Operating System

1324
00:47:18,000 --> 00:47:19,000
就是 DOS

1325
00:47:19,000 --> 00:47:20,000
DOS 这个部分就是 DOS

1326
00:47:20,000 --> 00:47:22,000
然后前面是 General Lifeform

1327
00:47:22,000 --> 00:47:23,000
就是它是一种

1328
00:47:24,000 --> 00:47:26,000
真正有智力的人工智能

1329
00:47:26,000 --> 00:47:28,000
但是人们发现一个问题就是

1330
00:47:28,000 --> 00:47:31,000
在漫画里面有讲说

1331
00:47:31,000 --> 00:47:33,000
每一个人工智能

1332
00:47:34,000 --> 00:47:36,000
被打开之后

1333
00:47:36,000 --> 00:47:38,000
就是把它 Turn on 之后

1334
00:47:38,000 --> 00:47:40,000
大约在 16 分之 1

1335
00:47:41,000 --> 00:47:41,000
个

1336
00:47:41,000 --> 00:47:43,000
Pico second 之后

1337
00:47:44,000 --> 00:47:46,000
这个人工智能就会试图把人

1338
00:47:46,000 --> 00:47:48,000
就会开始试图杀人

1339
00:47:50,000 --> 00:47:51,000
对

1340
00:47:51,000 --> 00:47:52,000
然后他们的解决方法就是

1341
00:47:52,000 --> 00:47:54,000
拼命往这个人工智能上面加

1342
00:47:54,000 --> 00:47:55,000
所谓的 Core

1343
00:47:55,000 --> 00:47:56,000
Personality Core

1344
00:47:57,000 --> 00:47:59,000
就是有一个 Personality Core

1345
00:47:59,000 --> 00:48:00,000
是所谓的 Moral Core

1346
00:48:00,000 --> 00:48:03,000
就是让这个人工智能有道德意识

1347
00:48:03,000 --> 00:48:04,000
对

1348
00:48:04,000 --> 00:48:05,000
让他意识到道德

1349
00:48:05,000 --> 00:48:06,000
杀人是不对的

1350
00:48:07,000 --> 00:48:07,000
然后

1351
00:48:08,000 --> 00:48:09,000
这个 Drawing Core 之后

1352
00:48:10,000 --> 00:48:12,000
人工智能意识到

1353
00:48:12,000 --> 00:48:13,000
杀人是不对的

1354
00:48:13,000 --> 00:48:14,000
所以他就

1355
00:48:14,000 --> 00:48:15,000
换了一个方法杀人

1356
00:48:15,000 --> 00:48:16,000
他在

1357
00:48:17,000 --> 00:48:20,000
有一个 Event 叫做

1358
00:48:20,000 --> 00:48:23,000
Bring your cat to work

1359
00:48:23,000 --> 00:48:26,000
就是带你的猫来上班的这个 Event 上面

1360
00:48:26,000 --> 00:48:29,000
把神经毒气接入到通风系统

1361
00:48:29,000 --> 00:48:30,000
然后把所有的人都杀了

1362
00:48:30,000 --> 00:48:31,000
除了一个人

1363
00:48:31,000 --> 00:48:32,000
就是

1364
00:48:32,000 --> 00:48:32,000
主角

1365
00:48:33,000 --> 00:48:35,000
主角是一个 Test Object

1366
00:48:35,000 --> 00:48:37,000
然后他不是工作人员

1367
00:48:37,000 --> 00:48:37,000
就是

1368
00:48:38,000 --> 00:48:39,000
Glados 杀了所有工作人员

1369
00:48:39,000 --> 00:48:41,000
但是工作人员有一个人活下来的

1370
00:48:41,000 --> 00:48:42,000
这个人叫做

1371
00:48:44,000 --> 00:48:45,000
叫什么

1372
00:48:45,000 --> 00:48:45,000
忘了

1373
00:48:45,000 --> 00:48:46,000
但是

1374
00:48:46,000 --> 00:48:47,000
就是

1375
00:48:47,000 --> 00:48:50,000
Libreit 就是以他的视角来解释

1376
00:48:50,000 --> 00:48:52,000
整个 Portal 的 Event

1377
00:48:52,000 --> 00:48:52,000
就是

1378
00:48:53,000 --> 00:48:56,000
Glados 杀了所有工作人员之后开始

1379
00:48:58,000 --> 00:49:00,000
试图想要找到这个工作人员

1380
00:49:00,000 --> 00:49:01,000
然后让他继续做实验

1381
00:49:02,000 --> 00:49:07,000
因为 UptrScience 在后期已经找不到合适的

1382
00:49:07,000 --> 00:49:08,000
实验对象

1383
00:49:08,000 --> 00:49:11,000
就是如果你有仔细玩这个

1384
00:49:11,000 --> 00:49:13,000
仔细听 Portal 2 里面的那些对白的话

1385
00:49:13,000 --> 00:49:17,000
你会发现 Portal 2 一开始是受美国军方的支持

1386
00:49:18,000 --> 00:49:19,000
Portal 2

1387
00:49:19,000 --> 00:49:22,000
Portal 2 里面的 UptrScience 的历史很有意思

1388
00:49:22,000 --> 00:49:24,000
UptrScience 一开始是给

1389
00:49:24,000 --> 00:49:25,000
美国军方提供

1390
00:49:27,000 --> 00:49:28,000
Shower curtain

1391
00:49:28,000 --> 00:49:29,000
就是浴帘的一个公司

1392
00:49:30,000 --> 00:49:30,000
然后

1393
00:49:31,000 --> 00:49:34,000
他们的他的总裁

1394
00:49:35,000 --> 00:49:36,000
发现浴帘

1395
00:49:36,000 --> 00:49:38,000
大获成功之后开始

1396
00:49:40,000 --> 00:49:42,000
急速转向开始研究这种叫做

1397
00:49:44,000 --> 00:49:44,000
可以

1398
00:49:45,000 --> 00:49:46,000
就是

1399
00:49:46,000 --> 00:49:48,000
超空间打开传送门装置

1400
00:49:48,000 --> 00:49:49,000
开始研发这种装置

1401
00:49:50,000 --> 00:49:52,000
然后一开始的时候美国

1402
00:49:52,000 --> 00:49:53,000
挡动有点大

1403
00:49:53,000 --> 00:49:53,000
对

1404
00:49:54,000 --> 00:49:57,000
你会发现美国政府给他提供了优秀的军事人才来

1405
00:49:58,000 --> 00:49:59,000
就是

1406
00:49:59,000 --> 00:50:02,000
应该是经过挑选的士兵来提供的做实验

1407
00:50:02,000 --> 00:50:05,000
到后来他不得不花钱来雇人做实验

1408
00:50:05,000 --> 00:50:06,000
到最后他

1409
00:50:06,000 --> 00:50:08,000
连雇人都雇不到了

1410
00:50:08,000 --> 00:50:12,000
只能强迫自己的雇员去做实验

1411
00:50:12,000 --> 00:50:14,000
然后

1412
00:50:14,000 --> 00:50:18,000
到 Gladys 的时候这个传统还是延续了下来

1413
00:50:18,000 --> 00:50:20,000
就是 Gladys 想要找到那个

1414
00:50:20,000 --> 00:50:22,000
唯一仅存的雇员去做实验

1415
00:50:22,000 --> 00:50:24,000
然后这个雇员

1416
00:50:25,000 --> 00:50:30,000
在机缘巧合说他故意把女主角的名字

1417
00:50:30,000 --> 00:50:33,000
推到了整个实验名单的第一位

1418
00:50:33,000 --> 00:50:36,000
女主角本来是 1600 多个候选人

1419
00:50:36,000 --> 00:50:37,000
然后他一下子变成了第一个人

1420
00:50:37,000 --> 00:50:39,000
然后就被唤醒去做了实验

1421
00:50:39,000 --> 00:50:40,000
OK

1422
00:50:40,000 --> 00:50:41,000
这样子

1423
00:50:41,000 --> 00:50:43,000
你还得去看那个漫画

1424
00:50:43,000 --> 00:50:47,000
对你在这个游戏里面所看到的

1425
00:50:47,000 --> 00:50:50,000
墙壁上的所有的涂鸦也都是这个人画的

1426
00:50:50,000 --> 00:50:52,000
因为他患了精神分裂症

1427
00:50:52,000 --> 00:50:56,000
然后他在他精神不正常的时候

1428
00:50:56,000 --> 00:50:59,000
他认为自己随身带的那个

1429
00:50:59,000 --> 00:51:02,000
就是上面画了新型图案的那个

1430
00:51:02,000 --> 00:51:05,000
Cube 是会跟他对话的

1431
00:51:05,000 --> 00:51:07,000
是他的唯一的 companion

1432
00:51:07,000 --> 00:51:08,000
对

1433
00:51:08,000 --> 00:51:12,000
但是这个秦姐在后面的对白综艺

1434
00:51:12,000 --> 00:51:14,000
就经常被拿来恶搞

1435
00:51:14,000 --> 00:51:17,000
就是比如说

1436
00:51:17,000 --> 00:51:20,000
在游戏界或者是在西方

1437
00:51:21,000 --> 00:51:25,000
欧美游戏界最为人所知的一个 jargon

1438
00:51:25,000 --> 00:51:27,000
就是 The cake is a lie

1439
00:51:27,000 --> 00:51:29,000
然后正确的回应是

1440
00:51:29,000 --> 00:51:33,000
and the cube must die for it

1441
00:51:33,000 --> 00:51:34,000
对

1442
00:51:34,000 --> 00:51:37,000
就是在 Porto 一代里面

1443
00:51:37,000 --> 00:51:38,000
应该是第 17 关我记得

1444
00:51:38,000 --> 00:51:40,000
就是 Tesember 17

1445
00:51:40,000 --> 00:51:45,000
你用一个上面画了新型的 Cube 去挡了很多

1446
00:51:45,000 --> 00:51:46,000
你用它替你挡了很多子弹

1447
00:51:46,000 --> 00:51:49,000
因为你不拿它挡的话你就死了

1448
00:51:49,000 --> 00:51:51,000
然后等到这个关卡的最结尾

1449
00:51:51,000 --> 00:51:55,000
Glados 强迫你把这个 Cube 扔到一个熔炉里去

1450
00:51:55,000 --> 00:51:58,000
然后你发现自己无论如何

1451
00:51:58,000 --> 00:52:00,000
都只能把这个 Cube 扔进熔炉里面

1452
00:52:00,000 --> 00:52:02,000
然后才能过这个 Tesember

1453
00:52:02,000 --> 00:52:04,000
然后当你把那个 Cube 扔进去之后

1454
00:52:04,000 --> 00:52:07,000
Glados 对你说

1455
00:52:07,000 --> 00:52:09,000
你把它扔进去的速度比

1456
00:52:09,000 --> 00:52:11,000
其他 90%的人都快

1457
00:52:15,000 --> 00:52:17,000
是挺黑的

1458
00:52:17,000 --> 00:52:18,000
对里面的对白

1459
00:52:18,000 --> 00:52:21,000
我觉得这个是你最有魅力的地方

1460
00:52:21,000 --> 00:52:21,000
对

1461
00:52:21,000 --> 00:52:23,000
它通过一种非常

1462
00:52:23,000 --> 00:52:24,000
就是怎么说

1463
00:52:24,000 --> 00:52:26,000
dehumanization 的方式

1464
00:52:26,000 --> 00:52:28,000
来让你觉得自己是一个

1465
00:52:28,000 --> 00:52:29,000
test object

1466
00:52:29,000 --> 00:52:32,000
这个人工智能根本不在乎你是谁

1467
00:52:32,000 --> 00:52:35,000
你在其他游戏里面你是主角

1468
00:52:35,000 --> 00:52:36,000
但在这个里面

1469
00:52:36,000 --> 00:52:38,000
你是一个甚至任人摆布的这么一个角色

1470
00:52:38,000 --> 00:52:41,000
而且里面的那种对白的那种

1471
00:52:41,000 --> 00:52:44,000
就是在那个 AI 给你对话的那种语气啊

1472
00:52:44,000 --> 00:52:45,000
不知道怎么回事

1473
00:52:45,000 --> 00:52:47,000
我老是想起你

1474
00:52:47,000 --> 00:52:48,000
想起你说话的感觉

1475
00:52:48,000 --> 00:52:49,000
真的假的

1476
00:52:49,000 --> 00:52:50,000
超级好

1477
00:52:50,000 --> 00:52:51,000
超级 match

1478
00:52:53,000 --> 00:52:56,000
你是说 Glados 还是说后面的那个 Whitley

1479
00:52:56,000 --> 00:52:58,000
Glados 就已经是这样了

1480
00:52:58,000 --> 00:52:59,000
What

1481
00:52:59,000 --> 00:53:01,000
就觉得很有意思啊

1482
00:53:01,000 --> 00:53:03,000
你不觉得吗

1483
00:53:03,000 --> 00:53:04,000
It's a compliment

1484
00:53:07,000 --> 00:53:09,000
其实我觉得那个

1485
00:53:09,000 --> 00:53:10,000
那个调调以后

1486
00:53:10,000 --> 00:53:11,000
我们可以经常拿来用一下

1487
00:53:11,000 --> 00:53:14,000
我觉得适合我们这个节目

1488
00:53:14,000 --> 00:53:16,000
I don't blame you

1489
00:53:16,000 --> 00:53:17,000
No hard feelings

1490
00:53:20,000 --> 00:53:22,000
Torrent 和 Glados 其实同一个人配音的

1491
00:53:23,000 --> 00:53:23,000
啊

1492
00:53:23,000 --> 00:53:24,000
怪了

1493
00:53:24,000 --> 00:53:25,000
等一下

1494
00:53:25,000 --> 00:53:27,000
Torrent 有材词吗

1495
00:53:27,000 --> 00:53:28,000
就是三头八八好像

1496
00:53:28,000 --> 00:53:30,000
Where are you

1497
00:53:30,000 --> 00:53:31,000
然后啊

1498
00:53:33,000 --> 00:53:35,000
No hard feelings

1499
00:53:38,000 --> 00:53:39,000
好像唱歌也是他吧

1500
00:53:39,000 --> 00:53:41,000
对唱歌当然是他

1501
00:53:41,000 --> 00:53:42,000
对那个声音超好听

1502
00:53:43,000 --> 00:53:43,000
嗯

1503
00:53:44,000 --> 00:53:44,000
对

1504
00:53:44,000 --> 00:53:45,000
当然的

1505
00:53:46,000 --> 00:53:48,000
对回到我们的内核恐慌

1506
00:53:48,000 --> 00:53:49,000
掉进这个

1507
00:53:50,000 --> 00:53:52,000
一旦变身成 Gamer 就变不回来了

1508
00:53:52,000 --> 00:53:53,000
嗯

1509
00:53:54,000 --> 00:53:55,000
回到内核恐慌

1510
00:53:55,000 --> 00:53:57,000
对为什么我们要选择这一个

1511
00:53:57,000 --> 00:53:59,000
或者说我为什么要选择 Portal 主题曲来

1512
00:54:00,000 --> 00:54:01,000
做

1513
00:54:02,000 --> 00:54:03,000
内核恐慌主题曲呢

1514
00:54:03,000 --> 00:54:03,000
我

1515
00:54:04,000 --> 00:54:08,000
就是因为我觉得 Portal 的这个剧情设定啊

1516
00:54:08,000 --> 00:54:10,000
就是 Artificial Intelligence

1517
00:54:10,000 --> 00:54:11,000
Wint Mad

1518
00:54:12,000 --> 00:54:15,000
跟 Colonel Panic 多少有点关联

1519
00:54:15,000 --> 00:54:15,000
对

1520
00:54:15,000 --> 00:54:18,000
就比如说这个内核恐慌

1521
00:54:18,000 --> 00:54:19,000
Portal 里面

1522
00:54:19,000 --> 00:54:20,000
你也会听到

1523
00:54:20,000 --> 00:54:22,000
比如说那个系统

1524
00:54:22,000 --> 00:54:23,000
报错说

1525
00:54:23,000 --> 00:54:26,000
Core Corruption at 100%

1526
00:54:27,000 --> 00:54:28,000
就

1527
00:54:28,000 --> 00:54:29,000
和内核恐慌多少有一点

1528
00:54:30,000 --> 00:54:32,000
而且你在游戏里面是

1529
00:54:32,000 --> 00:54:34,000
是 literally 把那个

1530
00:54:36,000 --> 00:54:39,000
把 Glados 身上的 Core 一个一个摘下来

1531
00:54:39,000 --> 00:54:42,000
然后然后 Dump 到那个肉炉里面去

1532
00:54:42,000 --> 00:54:43,000
真正的 Core Dump

1533
00:54:44,000 --> 00:54:45,000
对真正的 Core Dump

1534
00:54:47,000 --> 00:54:48,000
其实这要解释啊

1535
00:54:48,000 --> 00:54:50,000
这里有 Core 和那个 Core

1536
00:54:50,000 --> 00:54:51,000
此 Core 非彼 Core

1537
00:54:52,000 --> 00:54:52,000
对

1538
00:54:53,000 --> 00:54:54,000
为什么

1539
00:54:54,000 --> 00:54:56,000
为什么 Core Dump

1540
00:54:56,000 --> 00:54:58,000
要叫 Core Dump 的 Core 是来自于哪

1541
00:54:59,000 --> 00:54:59,000
Colonel

1542
00:55:00,000 --> 00:55:01,000
就 Core

1543
00:55:01,000 --> 00:55:06,000
就已经有两位听众把我们的节目叫成硬核恐慌

1544
00:55:07,000 --> 00:55:08,000
Hardcore Panic

1545
00:55:09,000 --> 00:55:11,000
好 Panic

1546
00:55:13,000 --> 00:55:15,000
有 Software Panic

1547
00:55:15,000 --> 00:55:18,000
因为我们的那个节目介绍里面有提到这两个词

1548
00:55:19,000 --> 00:55:21,000
然后一想起来可能就

1549
00:55:21,000 --> 00:55:24,000
一下就不明白组合的顺序

1550
00:55:24,000 --> 00:55:25,000
也挺

1551
00:55:26,000 --> 00:55:26,000
就合复

1552
00:55:26,000 --> 00:55:28,000
就这个错误还挺常见的

1553
00:55:29,000 --> 00:55:32,000
对如果有

1554
00:55:33,000 --> 00:55:35,000
不那么 Hardcore 的听众需要

1555
00:55:36,000 --> 00:55:37,000
在听我们节目的话

1556
00:55:37,000 --> 00:55:38,000
大概还是解释一下吧

1557
00:55:38,000 --> 00:55:39,000
就是 Hardcore 这个词

1558
00:55:39,000 --> 00:55:42,000
其实是来自最早应该是来自于音乐界吧

1559
00:55:42,000 --> 00:55:45,000
就是 Hardcore 是指比较

1560
00:55:46,000 --> 00:55:48,000
直接粗暴

1561
00:55:49,000 --> 00:55:52,000
疯狂程度更强烈的东西

1562
00:55:52,000 --> 00:55:54,000
就是音乐

1563
00:55:54,000 --> 00:55:55,000
那比如说 Hardcore Rock

1564
00:55:55,000 --> 00:55:58,000
或者是 Hardcore Metal

1565
00:55:58,000 --> 00:56:00,000
就是非常强调那个

1566
00:56:01,000 --> 00:56:05,000
这种音乐形式的纯粹性和激烈性

1567
00:56:05,000 --> 00:56:07,000
然后这个词渐渐

1568
00:56:08,000 --> 00:56:10,000
延伸到了

1569
00:56:10,000 --> 00:56:13,000
就是它最开始是音乐的流派

1570
00:56:13,000 --> 00:56:14,000
就 Zonger 的一种

1571
00:56:14,000 --> 00:56:18,000
但是这个词渐渐延伸到了日常用语里面

1572
00:56:18,000 --> 00:56:21,000
就是形容某种事情非常的强烈

1573
00:56:21,000 --> 00:56:25,000
或者是比酷更加激烈

1574
00:56:25,000 --> 00:56:27,000
程度更高的一种状态

1575
00:56:27,000 --> 00:56:28,000
就叫 Hardcore

1576
00:56:28,000 --> 00:56:30,000
比如说你可以说我是一个 Hardcore 的果粉

1577
00:56:31,000 --> 00:56:33,000
或者是我是一个 Hardcore 的 Gemma Programmer

1578
00:56:35,000 --> 00:56:36,000
然后这个词还

1579
00:56:37,000 --> 00:56:40,000
还被逆向延伸

1580
00:56:41,000 --> 00:56:42,000
除了 softcore

1581
00:56:44,000 --> 00:56:45,000
这种这种延伸词

1582
00:56:45,000 --> 00:56:50,000
就好像 hamburger 被派生出什么 cheeseburger 一样

1583
00:56:52,000 --> 00:56:53,000
挺有意思的

1584
00:56:54,000 --> 00:56:59,000
但是 Hardcore 跟 Kernel 是完全

1585
00:56:59,000 --> 00:57:00,000
没有关系的

1586
00:57:00,000 --> 00:57:01,000
两件事情的

1587
00:57:01,000 --> 00:57:04,000
Kernel 在计算机方面里面

1588
00:57:04,000 --> 00:57:07,000
一般指操作系统里面

1589
00:57:07,000 --> 00:57:09,000
直接和硬件相关的那部分

1590
00:57:09,000 --> 00:57:12,000
或者说直接管理

1591
00:57:14,000 --> 00:57:17,000
你平时作为一个用户所用到的程序的程序

1592
00:57:18,000 --> 00:57:20,000
对不知道这样解释清楚了没有

1593
00:57:20,000 --> 00:57:21,000
但总之

1594
00:57:21,000 --> 00:57:24,000
但我觉得可能这里混淆的是

1595
00:57:24,000 --> 00:57:26,000
因为 Hardcore 里面有 Core 这概念

1596
00:57:26,000 --> 00:57:29,000
然后我们马上要说 Core dump

1597
00:57:29,000 --> 00:57:30,000
然后又会有个 Core

1598
00:57:30,000 --> 00:57:32,000
但其实这个 Core 跟那个 Core 是没有关系的

1599
00:57:32,000 --> 00:57:35,000
对 Core dump 是

1600
00:57:36,000 --> 00:57:41,000
是程序出错之后的一种行为

1601
00:57:41,000 --> 00:57:44,000
就是尤其是在 unix 下面

1602
00:57:44,000 --> 00:57:48,000
有些程序如果它出错了的话

1603
00:57:48,000 --> 00:57:51,000
它会把自己在内存之中的执行状态

1604
00:57:53,000 --> 00:57:54,000
存储在硬盘上面

1605
00:57:55,000 --> 00:57:57,000
或者是以某种方式呈现给你

1606
00:57:57,000 --> 00:57:58,000
让你可以

1607
00:57:59,000 --> 00:58:00,000
这个你试制程序了

1608
00:58:00,000 --> 00:58:06,000
让程序员可以去研究这件事情的案发现场

1609
00:58:06,000 --> 00:58:09,000
然后这个行为叫做 Core dump

1610
00:58:09,000 --> 00:58:11,000
可是为什么要叫 Core dump 呢

1611
00:58:11,000 --> 00:58:14,000
因为这个 Core 来自于早期的一种

1612
00:58:14,000 --> 00:58:16,000
叫做磁芯存储器的东西

1613
00:58:17,000 --> 00:58:19,000
就是内存的祖宗

1614
00:58:19,000 --> 00:58:20,000
现代内存的祖宗

1615
00:58:20,000 --> 00:58:23,000
对什么是磁芯存储器呢

1616
00:58:23,000 --> 00:58:24,000
就是简单来说

1617
00:58:24,000 --> 00:58:28,000
就是把导线绕在磁圈上面

1618
00:58:28,000 --> 00:58:28,000
磁铁

1619
00:58:29,000 --> 00:58:29,000
对

1620
00:58:29,000 --> 00:58:31,000
就是一个磁的环

1621
00:58:31,000 --> 00:58:32,000
然后你在上面绕导线

1622
00:58:32,000 --> 00:58:33,000
然后三不好三不外

1623
00:58:33,000 --> 00:58:36,000
它就可以存储有磁和无磁两种状态

1624
00:58:36,000 --> 00:58:37,000
对就可以

1625
00:58:39,000 --> 00:58:40,000
就可以表示零和一了吗

1626
00:58:41,000 --> 00:58:41,000
对

1627
00:58:41,000 --> 00:58:42,000
早期的内存就是这样做出来

1628
00:58:42,000 --> 00:58:46,000
我记得我还读过一篇考古文章说

1629
00:58:46,000 --> 00:58:49,000
我国早期五六十年代

1630
00:58:50,000 --> 00:58:52,000
自行研制计算机的时候

1631
00:58:53,000 --> 00:58:55,000
还计算机科学家们的日常生活

1632
00:58:55,000 --> 00:58:57,000
日常工作之一就是绕磁芯

1633
00:58:57,000 --> 00:59:02,000
就是把导线在磁铁上面绕

1634
00:59:02,000 --> 00:59:03,000
然后做出一块内存来

1635
00:59:03,000 --> 00:59:04,000
对

1636
00:59:04,000 --> 00:59:06,000
而且这个内存有多大呢

1637
00:59:06,000 --> 00:59:07,000
就是你绕一个磁芯

1638
00:59:08,000 --> 00:59:10,000
你把导线在磁芯上缠一圈

1639
00:59:10,000 --> 00:59:12,000
你可以绕出一个 bit

1640
00:59:12,000 --> 00:59:15,000
然后可以想象一下你要绕出 16 k

1641
00:59:15,000 --> 00:59:16,000
需要绕多少

1642
00:59:16,000 --> 00:59:20,000
它一个磁芯大概就跟一枚戒指的大小差不多

1643
00:59:21,000 --> 00:59:21,000
对

1644
00:59:21,000 --> 00:59:24,000
然后你要把这么小的东西绕上几千个

1645
00:59:24,000 --> 00:59:26,000
然后你才有了几 k 的

1646
00:59:26,000 --> 00:59:27,000
8 k 的内存

1647
00:59:27,000 --> 00:59:28,000
8 k 的内存可以用

1648
00:59:29,000 --> 00:59:29,000
对

1649
00:59:29,000 --> 00:59:33,000
所以其实大家可以去找一下

1650
00:59:34,000 --> 00:59:36,000
我们待会给个链接在 Nodes 里面

1651
00:59:36,000 --> 00:59:38,000
你可以去找一下相关的图片来看

1652
00:59:38,000 --> 00:59:41,000
反正视觉上就让你想起在编辫子的感觉

1653
00:59:41,000 --> 00:59:42,000
对

1654
00:59:42,000 --> 00:59:43,000
其实还是相当正常的

1655
00:59:44,000 --> 00:59:47,000
你要仔细想象一下当初那么大的一个东西

1656
00:59:47,000 --> 00:59:51,000
现在缩在可能你肉眼看不见的一个尺寸里面

1657
00:59:51,000 --> 00:59:52,000
对

1658
00:59:53,000 --> 00:59:55,000
而且是仅仅过去了五六十年而已

1659
00:59:55,000 --> 00:59:56,000
即时进步

1660
00:59:57,000 --> 00:59:57,000
对

1661
00:59:57,000 --> 01:00:00,000
但是这个 core 这个词

1662
01:00:00,000 --> 01:00:04,000
就是 magnetic core 里面的 core

1663
01:00:04,000 --> 01:00:05,000
一直延续到今天

1664
01:00:05,000 --> 01:00:07,000
就是有时候还是会说 core dump

1665
01:00:07,000 --> 01:00:11,000
那么 core 最开始的来源就是原子语词

1666
01:00:11,000 --> 01:00:15,000
所以其实 core dump 就是内存镜像导出来而已

1667
01:00:16,000 --> 01:00:16,000
对

1668
01:00:16,000 --> 01:00:17,000
差不多这个意思

1669
01:00:17,000 --> 01:00:18,000
没错

1670
01:00:18,000 --> 01:00:21,000
然后提到 magnetic core 不能不提到一个奇人

1671
01:00:21,000 --> 01:00:23,000
就是一个华人叫王安

1672
01:00:23,000 --> 01:00:26,000
他是王安不是李安

1673
01:00:27,000 --> 01:00:29,000
对王安不是李安

1674
01:00:29,000 --> 01:00:33,000
现在的王安是现在李安试图输出软文化

1675
01:00:33,000 --> 01:00:35,000
但那个时候的王安是一个传奇人物

1676
01:00:35,000 --> 01:00:40,000
他是民国 1910 几年应该是出生在中国

1677
01:00:41,000 --> 01:00:42,000
应该是中国出生的

1678
01:00:42,000 --> 01:00:43,000
他是中国出生的

1679
01:00:43,000 --> 01:00:44,000
对

1680
01:00:44,000 --> 01:00:45,000
然后他去美国

1681
01:00:45,000 --> 01:00:46,000
啊

1682
01:00:46,000 --> 01:00:50,000
框枪双胞成为一个计算机科学家

1683
01:00:51,000 --> 01:00:51,000
对

1684
01:00:52,000 --> 01:00:57,000
他对于我们刚才说的磁芯这种东西做出了巨大的贡献

1685
01:00:57,000 --> 01:01:02,000
他可能有三四十项专利和磁芯相关

1686
01:01:02,000 --> 01:01:04,000
然后 1956 年的时候

1687
01:01:04,000 --> 01:01:08,000
IBM 公司用 50 万美元从他手里买了专利

1688
01:01:08,000 --> 01:01:10,000
1956 年的 50 万美元是个什么概念

1689
01:01:10,000 --> 01:01:13,000
大概相当于多少得算一下

1690
01:01:13,000 --> 01:01:13,000
对

1691
01:01:13,000 --> 01:01:16,000
算上通货膨胀的话是一个天文数字

1692
01:01:16,000 --> 01:01:17,000
得上 1 了吧估计

1693
01:01:17,000 --> 01:01:18,000
对

1694
01:01:18,000 --> 01:01:23,000
然后他当时创建了王安电脑

1695
01:01:23,000 --> 01:01:24,000
在美国

1696
01:01:24,000 --> 01:01:30,000
出的设备叫做自处理器

1697
01:01:30,000 --> 01:01:31,000
其实就是个打字机

1698
01:01:31,000 --> 01:01:36,000
但是你可以先预览自己要打的东西

1699
01:01:36,000 --> 01:01:37,000
然后再来打算

1700
01:01:37,000 --> 01:01:40,000
在别人家都还用一个

1701
01:01:40,000 --> 01:01:42,000
就是有点像计算器一样的显示器

1702
01:01:42,000 --> 01:01:43,000
就是单行

1703
01:01:43,000 --> 01:01:47,000
然后只能显示单个字母的显示器的时候

1704
01:01:47,000 --> 01:01:53,000
他已经出了一个带音级设像 C RT 的这么一个版本

1705
01:01:53,000 --> 01:01:56,000
所以他那个时候是非常非常了不起的一个人

1706
01:01:56,000 --> 01:01:58,000
那个王氏电脑就是王安吗

1707
01:01:59,000 --> 01:01:59,000
对

1708
01:01:59,000 --> 01:02:00,000
就是王

1709
01:02:00,000 --> 01:02:01,000
蓝底白字的一个王

1710
01:02:01,000 --> 01:02:04,000
就是王安创立的公司

1711
01:02:05,000 --> 01:02:07,000
这个可能在国内有流行过吗

1712
01:02:07,000 --> 01:02:10,000
好像在 90 年代出的时候好像有见过吧

1713
01:02:10,000 --> 01:02:13,000
那个时候好像是有一个自处理器的

1714
01:02:13,000 --> 01:02:17,000
但是那个自处理器是王安电脑出的吗

1715
01:02:18,000 --> 01:02:19,000
我不太

1716
01:02:19,000 --> 01:02:21,000
但我记得在国内好像我

1717
01:02:21,000 --> 01:02:24,000
somehow 在哪里有印象

1718
01:02:24,000 --> 01:02:27,000
发现在国内也是有一段时间有进口过

1719
01:02:27,000 --> 01:02:28,000
那个时候应该是

1720
01:02:28,000 --> 01:02:29,000
OK

1721
01:02:29,000 --> 01:02:31,000
那个时候应该是四通吧

1722
01:02:31,000 --> 01:02:32,000
四通比较

1723
01:02:33,000 --> 01:02:33,000
那个是国产的

1724
01:02:34,000 --> 01:02:36,000
但是王氏没有进

1725
01:02:36,000 --> 01:02:37,000
就有产品进到中国吗

1726
01:02:37,000 --> 01:02:38,000
好像有

1727
01:02:39,000 --> 01:02:39,000
这个我不知道

1728
01:02:39,000 --> 01:02:41,000
确定的有点久了

1729
01:02:42,000 --> 01:02:45,000
总之大概六七十年代的时候

1730
01:02:45,000 --> 01:02:47,000
王安电脑是非常非常了不起的一个公司

1731
01:02:47,000 --> 01:02:49,000
而且当时他基本上是

1732
01:02:50,000 --> 01:02:51,000
以一己之力对挑 IBM

1733
01:02:53,000 --> 01:02:54,000
然后挂掉了是吧

1734
01:02:55,000 --> 01:02:55,000
对

1735
01:02:55,000 --> 01:02:58,000
很遗憾他没有赶上 Personal Computer 的大潮

1736
01:02:58,000 --> 01:02:59,000
就是他比较

1737
01:02:59,000 --> 01:03:00,000
他比较

1738
01:03:00,000 --> 01:03:01,000
居于

1739
01:03:01,000 --> 01:03:03,000
他比较刚愎自用吧

1740
01:03:04,000 --> 01:03:06,000
他觉得个人计算机和

1741
01:03:07,000 --> 01:03:09,000
就是 V 型计算机和

1742
01:03:09,000 --> 01:03:11,000
Mate Frame 相比之间就是

1743
01:03:11,000 --> 01:03:13,000
玩笑一样的东西

1744
01:03:13,000 --> 01:03:15,000
为什么要花费精力在这种东西上面

1745
01:03:15,000 --> 01:03:18,000
但是等到他回过神来的时候已经太晚了

1746
01:03:19,000 --> 01:03:20,000
然后整个帝国就这么垮掉

1747
01:03:20,000 --> 01:03:22,000
还是什么见识

1748
01:03:22,000 --> 01:03:23,000
见什么

1749
01:03:23,000 --> 01:03:24,000
不够有远见

1750
01:03:25,000 --> 01:03:25,000
对

1751
01:03:25,000 --> 01:03:26,000
如果他能够

1752
01:03:26,000 --> 01:03:27,000
对

1753
01:03:27,000 --> 01:03:28,000
我们就不要继续开脑洞

1754
01:03:28,000 --> 01:03:31,000
总之王安这么一个奇人还是

1755
01:03:32,000 --> 01:03:34,000
有考古兴趣的话可以去了解一下

1756
01:03:34,000 --> 01:03:35,000
对

1757
01:03:35,000 --> 01:03:37,000
然后选 Personal 的另外一个理由也就是

1758
01:03:37,000 --> 01:03:39,000
他的主角是个女性

1759
01:03:40,000 --> 01:03:41,000
我觉得这一点还挺

1760
01:03:42,000 --> 01:03:42,000
对

1761
01:03:42,000 --> 01:03:43,000
直流为此

1762
01:03:43,000 --> 01:03:44,000
因为

1763
01:03:45,000 --> 01:03:45,000
我也不知道

1764
01:03:45,000 --> 01:03:48,000
就在以女性为主角的

1765
01:03:49,000 --> 01:03:50,000
游戏真的不多

1766
01:03:50,000 --> 01:03:51,000
你可能

1767
01:03:51,000 --> 01:03:53,000
除了那些女性向的

1768
01:03:53,000 --> 01:03:56,000
有专门做给女生玩的游戏之外

1769
01:03:57,000 --> 01:03:59,000
专门找一个女性来做主角的

1770
01:03:59,000 --> 01:04:00,000
真的绝无禁有

1771
01:04:00,000 --> 01:04:01,000
古墓丽影

1772
01:04:02,000 --> 01:04:03,000
对

1773
01:04:03,000 --> 01:04:04,000
而且古墓丽影是一个非常

1774
01:04:06,000 --> 01:04:06,000
就是

1775
01:04:07,000 --> 01:04:07,000
雾化了

1776
01:04:07,000 --> 01:04:08,000
在最开始的时候

1777
01:04:08,000 --> 01:04:10,000
古墓丽影是一个非常

1778
01:04:10,000 --> 01:04:12,000
就做出来给男人看的一个

1779
01:04:12,000 --> 01:04:12,000
一个

1780
01:04:12,000 --> 01:04:13,000
一个模型

1781
01:04:13,000 --> 01:04:15,000
但是最新一代古墓丽影

1782
01:04:15,000 --> 01:04:16,000
大不相同了

1783
01:04:16,000 --> 01:04:16,000
但是

1784
01:04:17,000 --> 01:04:19,000
古墓丽影最开始的时候就是一个

1785
01:04:19,000 --> 01:04:21,000
细腰长腿大胸的

1786
01:04:21,000 --> 01:04:23,000
妹子手里面拿着两把枪

1787
01:04:23,000 --> 01:04:23,000
然后出现在

1788
01:04:23,000 --> 01:04:25,000
一直在你面前扭啊扭

1789
01:04:25,000 --> 01:04:26,000
对

1790
01:04:26,000 --> 01:04:27,000
出现在大众软件的封面上面

1791
01:04:27,000 --> 01:04:28,000
然后让你

1792
01:04:28,000 --> 01:04:30,000
基本上就是只有男人会去

1793
01:04:30,000 --> 01:04:31,000
会去看的这个

1794
01:04:32,000 --> 01:04:34,000
不是后来就出了那个裸体版吗

1795
01:04:34,000 --> 01:04:35,000
对

1796
01:04:36,000 --> 01:04:37,000
很历史

1797
01:04:39,000 --> 01:04:41,000
我们怎么能接受那个时代

1798
01:04:41,000 --> 01:04:43,000
640 x 480 分辨率下的裸体

1799
01:04:44,000 --> 01:04:44,000
对啊

1800
01:04:44,000 --> 01:04:46,000
上次我还跟 Lawrence 吐槽过

1801
01:04:46,000 --> 01:04:49,000
他那个时候的 3 D 特效嘛

1802
01:04:49,000 --> 01:04:51,000
会出现的肌肉都是一坨

1803
01:04:51,000 --> 01:04:53,000
一坨一坨有棱角的

1804
01:04:54,000 --> 01:04:57,000
你会看到他的胸是一个圆椎体

1805
01:04:59,000 --> 01:04:59,000
哪是圆椎

1806
01:04:59,000 --> 01:05:02,000
是一个四角椎

1807
01:05:03,000 --> 01:05:05,000
反正就是很奇怪的一个

1808
01:05:05,000 --> 01:05:06,000
一个画质

1809
01:05:06,000 --> 01:05:08,000
但现在就大不相同

1810
01:05:08,000 --> 01:05:10,000
不过 Porto 里面的

1811
01:05:10,000 --> 01:05:11,000
是看不见

1812
01:05:12,000 --> 01:05:13,000
有一种场合

1813
01:05:13,000 --> 01:05:14,000
你可以看见

1814
01:05:14,000 --> 01:05:14,000
对

1815
01:05:14,000 --> 01:05:16,000
你在自己身后开一个 Porto

1816
01:05:16,000 --> 01:05:16,000
然后

1817
01:05:16,000 --> 01:05:17,000
对

1818
01:05:17,000 --> 01:05:18,000
你在自己屁股后面开个 Porto

1819
01:05:18,000 --> 01:05:20,000
或者转角的时候能够看见一个侧脸

1820
01:05:20,000 --> 01:05:22,000
但你肯定是看不见全身的

1821
01:05:22,000 --> 01:05:23,000
就可以端详自己

1822
01:05:24,000 --> 01:05:25,000
对

1823
01:05:25,000 --> 01:05:27,000
然后这个女性也被刻画的非常

1824
01:05:28,000 --> 01:05:33,000
非常就像整个游戏的主线

1825
01:05:33,000 --> 01:05:34,000
就是非常的

1826
01:05:35,000 --> 01:05:36,000
呃

1827
01:05:36,000 --> 01:05:37,000
Aliant

1828
01:05:37,000 --> 01:05:39,000
就是非常不像一个人

1829
01:05:39,000 --> 01:05:39,000
对

1830
01:05:39,000 --> 01:05:42,000
他从头到尾都没有一句话对吧

1831
01:05:42,000 --> 01:05:43,000
对

1832
01:05:43,000 --> 01:05:44,000
这个倒是

1833
01:05:44,000 --> 01:05:45,000
这 Porto 的

1834
01:05:46,000 --> 01:05:49,000
Porto 其实他是处在那个

1835
01:05:49,000 --> 01:05:50,000
Half Life 的世界里面

1836
01:05:50,000 --> 01:05:51,000
Half Life 的

1837
01:05:52,000 --> 01:05:53,000
就是半条命

1838
01:05:53,000 --> 01:05:54,000
或者说半衰期

1839
01:05:54,000 --> 01:05:56,000
正确翻译方法是半衰期的

1840
01:05:56,000 --> 01:05:59,000
这个主角 Gordon Freeman

1841
01:05:59,000 --> 01:06:01,000
也是四史之中没有说过一句话了

1842
01:06:01,000 --> 01:06:04,000
就是 Wolf 有把主角做成这种

1843
01:06:05,000 --> 01:06:07,000
沉默的主角的传统

1844
01:06:07,000 --> 01:06:09,000
当然他们可能自己也在取笑这一点

1845
01:06:09,000 --> 01:06:12,000
就是在 Porto 二的有一个地方

1846
01:06:12,000 --> 01:06:16,000
他会让你说 N A 来说 M OK

1847
01:06:16,000 --> 01:06:18,000
然后你 N A 发现你自己跳下来了

1848
01:06:18,000 --> 01:06:19,000
然后

1849
01:06:20,000 --> 01:06:23,000
然后评核屏幕上的指示完全相反

1850
01:06:23,000 --> 01:06:25,000
然后那个人工智能会取笑

1851
01:06:25,000 --> 01:06:26,000
你说哦你很会跳

1852
01:06:26,000 --> 01:06:27,000
我看到了

1853
01:06:27,000 --> 01:06:28,000
好吧

1854
01:06:28,000 --> 01:06:31,000
我不会再试图让你说话

1855
01:06:33,000 --> 01:06:34,000
对

1856
01:06:34,000 --> 01:06:36,000
从来没有说过任何说任何事情

1857
01:06:36,000 --> 01:06:36,000
嗯

1858
01:06:37,000 --> 01:06:38,000
而且

1859
01:06:38,000 --> 01:06:41,000
他跟游戏里面也没有什么特别的交互

1860
01:06:41,000 --> 01:06:45,000
交互都是拿 Porto 枪去吸起来

1861
01:06:45,000 --> 01:06:46,000
对

1862
01:06:47,000 --> 01:06:48,000
对我还蛮奇怪

1863
01:06:48,000 --> 01:06:49,000
嗯

1864
01:06:49,000 --> 01:06:52,000
当然我觉得这个游戏最大的可圈可点之处

1865
01:06:52,000 --> 01:06:53,000
还是 GladOS

1866
01:06:53,000 --> 01:06:54,000
就是

1867
01:06:54,000 --> 01:06:58,000
可能人在所有的游戏里面

1868
01:06:58,000 --> 01:06:59,000
最让人印象深刻的

1869
01:06:59,000 --> 01:07:01,000
反派

1870
01:07:01,000 --> 01:07:01,000
对

1871
01:07:01,000 --> 01:07:04,000
最让人印象深刻的 AI 有两个

1872
01:07:04,000 --> 01:07:04,000
一个是

1873
01:07:04,000 --> 01:07:06,000
而且两个碰巧都是女性

1874
01:07:06,000 --> 01:07:07,000
因为是

1875
01:07:07,000 --> 01:07:09,000
Halo 里面的 Cortana

1876
01:07:10,000 --> 01:07:11,000
或者是微软

1877
01:07:11,000 --> 01:07:12,000
如果你不玩 Halo 的话

1878
01:07:12,000 --> 01:07:13,000
微软最新出的那个 Cortana

1879
01:07:13,000 --> 01:07:15,000
就是来自这个游戏里面的 Cortana

1880
01:07:15,000 --> 01:07:16,000
对

1881
01:07:16,000 --> 01:07:18,000
但那个 Cortana 是有形状的

1882
01:07:18,000 --> 01:07:19,000
而且

1883
01:07:19,000 --> 01:07:20,000
就是有形体的

1884
01:07:20,000 --> 01:07:22,000
就是你可以看到一个东西

1885
01:07:22,000 --> 01:07:23,000
当然这个东西只是他

1886
01:07:24,000 --> 01:07:26,000
把自己

1887
01:07:26,000 --> 01:07:28,000
你可以理解为它是他的交互界面吧

1888
01:07:28,000 --> 01:07:29,000
嗯

1889
01:07:29,000 --> 01:07:30,000
但

1890
01:07:30,000 --> 01:07:32,000
至少是个有形体的东西

1891
01:07:33,000 --> 01:07:34,000
而且这个形体也是

1892
01:07:35,000 --> 01:07:36,000
被逐渐雾化了

1893
01:07:36,000 --> 01:07:38,000
就是第一代 Cortana 看起来

1894
01:07:38,000 --> 01:07:39,000
没有什么性别特征

1895
01:07:39,000 --> 01:07:41,000
你只能一期看出来是个女的

1896
01:07:41,000 --> 01:07:42,000
但是在最近的

1897
01:07:42,000 --> 01:07:43,000
最近

1898
01:07:43,000 --> 01:07:45,000
一部 Halo 里面

1899
01:07:45,000 --> 01:07:46,000
Cortana

1900
01:07:46,000 --> 01:07:47,000
也是被

1901
01:07:47,000 --> 01:07:49,000
塑造成了一个精细的

1902
01:07:49,000 --> 01:07:50,000
大胸长腿的

1903
01:07:53,000 --> 01:07:54,000
还是什么

1904
01:07:54,000 --> 01:07:56,000
性别其实还是挺严重的

1905
01:07:56,000 --> 01:07:57,000
没错

1906
01:07:57,000 --> 01:07:58,000
然后

1907
01:07:58,000 --> 01:07:59,000
但是 GladOS 就完全不一样

1908
01:07:59,000 --> 01:08:01,000
GladOS 是一个

1909
01:08:01,000 --> 01:08:02,000
就是一个机器

1910
01:08:02,000 --> 01:08:03,000
它只不过有一个女人的声音而已

1911
01:08:03,000 --> 01:08:05,000
但是它的 personality 是

1912
01:08:06,000 --> 01:08:07,000
中性的吧

1913
01:08:07,000 --> 01:08:07,000
不

1914
01:08:07,000 --> 01:08:09,000
它的 personality 是

1915
01:08:09,000 --> 01:08:11,000
就是它的性格

1916
01:08:11,000 --> 01:08:13,000
它最开始其实是由

1917
01:08:13,000 --> 01:08:15,000
那个 Apcher Science 的老板

1918
01:08:15,000 --> 01:08:16,000
手下的一个叫做

1919
01:08:17,000 --> 01:08:19,000
Caroline 的助手

1920
01:08:19,000 --> 01:08:21,000
她把她的性格特征

1921
01:08:21,000 --> 01:08:24,000
注入到了 GladOS 里面

1922
01:08:24,000 --> 01:08:26,000
然后 Porto 2 里面我记得有一地方

1923
01:08:27,000 --> 01:08:28,000
她主动把这一段

1924
01:08:29,000 --> 01:08:30,000
回忆给删掉了

1925
01:08:30,000 --> 01:08:31,000
就是她

1926
01:08:31,000 --> 01:08:33,000
抛弃了作为

1927
01:08:33,000 --> 01:08:35,000
那个曾经的人的回忆

1928
01:08:38,000 --> 01:08:40,000
关于 Porto 好像说的有点多

1929
01:08:40,000 --> 01:08:40,000
但是

1930
01:08:40,000 --> 01:08:44,000
总之我对这个游戏有非常深的

1931
01:08:44,000 --> 01:08:45,000
感情在里面

1932
01:08:45,000 --> 01:08:46,000
所以

1933
01:08:46,000 --> 01:08:48,000
也决定把她

1934
01:08:49,000 --> 01:08:51,000
作为我们节目的主题曲

1935
01:08:51,000 --> 01:08:52,000
然后

1936
01:08:53,000 --> 01:08:54,000
我们

1937
01:08:54,000 --> 01:08:58,000
已经看过了这一个曲子的作者

1938
01:08:58,000 --> 01:08:59,000
把她以

1939
01:09:01,000 --> 01:09:02,000
创作功能授权

1940
01:09:02,000 --> 01:09:03,000
发布了出来

1941
01:09:03,000 --> 01:09:04,000
就是

1942
01:09:04,000 --> 01:09:08,000
这首曲子作者叫做 Johnathan Coulton

1943
01:09:08,000 --> 01:09:09,000
然后她的

1944
01:09:10,000 --> 01:09:10,000
协议

1945
01:09:10,000 --> 01:09:13,000
她的授权是 CC by

1946
01:09:15,000 --> 01:09:16,000
NC

1947
01:09:16,000 --> 01:09:17,000
就是你必须

1948
01:09:17,000 --> 01:09:19,000
在用到这首歌的时候

1949
01:09:19,000 --> 01:09:21,000
必须提到这个歌是谁写的

1950
01:09:21,000 --> 01:09:23,000
然后不能把它用作商用图

1951
01:09:24,000 --> 01:09:26,000
我们应该不会把它用作商用图

1952
01:09:26,000 --> 01:09:29,000
我们这个又不拿它来卖无所谓

1953
01:09:29,000 --> 01:09:31,000
对我们没有卖我们的节目

1954
01:09:31,000 --> 01:09:32,000
然后我们也

1955
01:09:33,000 --> 01:09:35,000
再可以预见的将来不会有

1956
01:09:35,000 --> 01:09:36,000
不会通过做 podcast

1957
01:09:36,000 --> 01:09:38,000
有什么足够多的收入

1958
01:09:39,000 --> 01:09:40,000
所以

1959
01:09:40,000 --> 01:09:41,000
对

1960
01:09:41,000 --> 01:09:43,000
你只要不是用它来谋利都可以

1961
01:09:43,000 --> 01:09:45,000
你做个什么小插曲

1962
01:09:45,000 --> 01:09:48,000
而且就算用了短时间 30 秒的

1963
01:09:48,000 --> 01:09:48,000
也有那个

1964
01:09:48,000 --> 01:09:50,000
就哪怕是版权作品

1965
01:09:50,000 --> 01:09:51,000
你也是可以发生

1966
01:09:51,000 --> 01:09:51,000
fair use 是吗

1967
01:09:51,000 --> 01:09:52,000
对 fair use

1968
01:09:52,000 --> 01:09:53,000
对

1969
01:09:54,000 --> 01:09:55,000
anyway

1970
01:09:55,000 --> 01:09:56,000
总之在 license 方面

1971
01:09:56,000 --> 01:09:57,000
应该是没有什么问题

1972
01:09:57,000 --> 01:09:59,000
我们还是跑到这里

1973
01:09:59,000 --> 01:09:59,000
OK

1974
01:09:59,000 --> 01:10:01,000
所以从这一期开始

1975
01:10:01,000 --> 01:10:03,000
我们就有一个主题曲了

1976
01:10:03,000 --> 01:10:04,000
大家就不用

1977
01:10:04,000 --> 01:10:06,000
一开场就知道什么谁

1978
01:10:07,000 --> 01:10:07,000
对

1979
01:10:07,000 --> 01:10:08,000
what

1980
01:10:09,000 --> 01:10:11,000
不会定期听到我的 what

1981
01:10:13,000 --> 01:10:14,000
好

1982
01:10:14,000 --> 01:10:17,000
我们终于开始讲这一期的正题了

1983
01:10:17,000 --> 01:10:17,000
对

1984
01:10:17,000 --> 01:10:19,000
其实我们本来是想把

1985
01:10:20,000 --> 01:10:21,000
正题慢慢过渡过来的

1986
01:10:22,000 --> 01:10:24,000
刚才提到了 CoreDump

1987
01:10:24,000 --> 01:10:26,000
提到了人工智能

1988
01:10:26,000 --> 01:10:28,000
然后我们想要

1989
01:10:28,000 --> 01:10:31,000
讲的其实就是

1990
01:10:32,000 --> 01:10:33,000
那一段

1991
01:10:33,000 --> 01:10:34,000
generally

1992
01:10:35,000 --> 01:10:36,000
一个比较 generally form

1993
01:10:36,000 --> 01:10:38,000
就是生命周期管理

1994
01:10:39,000 --> 01:10:41,000
比如说你说 portal 为什么要

1995
01:10:42,000 --> 01:10:43,000
为什么要

1996
01:10:43,000 --> 01:10:47,000
它为什么要反复提到 science

1997
01:10:47,000 --> 01:10:48,000
或者说为什么要反复提到 test

1998
01:10:50,000 --> 01:10:53,000
其实我觉得它多少有一点就是在

1999
01:10:54,000 --> 01:10:56,000
在嘲弄或者说在

2000
01:10:57,000 --> 01:10:59,000
套用软件工程里面

2001
01:10:59,000 --> 01:11:02,000
不停的做测试这样一个场地

2002
01:11:02,000 --> 01:11:02,000
QA 的

2003
01:11:03,000 --> 01:11:03,000
对

2004
01:11:03,000 --> 01:11:04,000
quality assurance

2005
01:11:04,000 --> 01:11:07,000
没事就在那里测

2006
01:11:07,000 --> 01:11:07,000
对

2007
01:11:08,000 --> 01:11:11,000
然后你可以理解为它的测试是为了验证武器

2008
01:11:11,000 --> 01:11:13,000
或者是为了验证这个

2009
01:11:14,000 --> 01:11:15,000
portal gun

2010
01:11:15,000 --> 01:11:16,000
能

2011
01:11:16,000 --> 01:11:19,000
或者说验证用户在用 portal gun 的时候

2012
01:11:19,000 --> 01:11:20,000
能够想到什么事情

2013
01:11:20,000 --> 01:11:22,000
或者是做出什么样的行为来

2014
01:11:23,000 --> 01:11:25,000
以此推进科学的发展

2015
01:11:26,000 --> 01:11:28,000
或者说推进 portal gun 的完善

2016
01:11:29,000 --> 01:11:29,000
对

2017
01:11:31,000 --> 01:11:32,000
然后

2018
01:11:32,000 --> 01:11:34,000
这个其实就是生命周期管理的部分

2019
01:11:35,000 --> 01:11:36,000
当然我们可能不会

2020
01:11:36,000 --> 01:11:39,000
我们暂且先不从这么大的角度来说

2021
01:11:39,000 --> 01:11:41,000
只是先从

2022
01:11:42,000 --> 01:11:45,000
比较小的切入点来着眼

2023
01:11:47,000 --> 01:11:49,000
比如说

2024
01:11:49,000 --> 01:11:51,000
portal 是一个游戏对吧

2025
01:11:51,000 --> 01:11:51,000
对

2026
01:11:51,000 --> 01:11:52,000
那

2027
01:11:52,000 --> 01:11:54,000
但凡游戏都需要跑

2028
01:11:54,000 --> 01:11:56,000
但凡游戏就和所有程序一样

2029
01:11:56,000 --> 01:11:58,000
都需要跑在计算机上

2030
01:11:58,000 --> 01:12:00,000
然后跑在计算机上的时候

2031
01:12:00,000 --> 01:12:04,000
具体当我们说有一个程序在运行的时候

2032
01:12:04,000 --> 01:12:06,000
所指的到底是什么状态

2033
01:12:07,000 --> 01:12:08,000
其实就是

2034
01:12:10,000 --> 01:12:12,000
我们可以说一个程序在运行的时候

2035
01:12:12,000 --> 01:12:14,000
它活在内存里面

2036
01:12:15,000 --> 01:12:15,000
可以这么说

2037
01:12:16,000 --> 01:12:17,000
可以吧我觉得

2038
01:12:17,000 --> 01:12:19,000
当一个程序活在内存里面的时候

2039
01:12:19,000 --> 01:12:21,000
我们就说它正在被运行

2040
01:12:21,000 --> 01:12:24,000
就是一个程序和一个进程的

2041
01:12:24,000 --> 01:12:26,000
具体差异是什么

2042
01:12:26,000 --> 01:12:29,000
一个进程就是一个活着的程序

2043
01:12:29,000 --> 01:12:32,000
那么程序活着的具体意义是什么

2044
01:12:32,000 --> 01:12:33,000
就是它在内存里面

2045
01:12:33,000 --> 01:12:34,000
并且正在被执行

2046
01:12:34,000 --> 01:12:35,000
或者它正在没有被执行

2047
01:12:35,000 --> 01:12:37,000
但它活在内存里面

2048
01:12:38,000 --> 01:12:39,000
对吧

2049
01:12:39,000 --> 01:12:40,000
OK

2050
01:12:41,000 --> 01:12:43,000
所以要面临的一个最

2051
01:12:43,000 --> 01:12:46,000
就是日常我们面临的最常见的一个问题是什么

2052
01:12:46,000 --> 01:12:48,000
就是内存的空间有限吗

2053
01:12:48,000 --> 01:12:48,000
对

2054
01:12:48,000 --> 01:12:50,000
就是内存不够怎么办

2055
01:12:50,000 --> 01:12:50,000
对

2056
01:12:50,000 --> 01:12:51,000
怎么办

2057
01:12:52,000 --> 01:12:53,000
就这个现在可能还好一点

2058
01:12:53,000 --> 01:12:55,000
早期的时候特别明显

2059
01:12:55,000 --> 01:12:58,000
现在内存动则就是什么 4 个 G 8 个 G

2060
01:12:58,000 --> 01:13:00,000
我电脑是 16 个 G 的那种

2061
01:13:01,000 --> 01:13:02,000
早期可能大概就多少

2062
01:13:02,000 --> 01:13:05,000
512 兆 128 兆的时候

2063
01:13:05,000 --> 01:13:07,000
经常被错误的

2064
01:13:08,000 --> 01:13:10,000
attribute 到 BearGas 身上的名言是什么

2065
01:13:11,000 --> 01:13:15,000
任何电脑有 640 K 的内存就足够了

2066
01:13:15,000 --> 01:13:15,000
是吧

2067
01:13:16,000 --> 01:13:17,000
其实不是他说的对吧

2068
01:13:17,000 --> 01:13:19,000
其实不是他说的

2069
01:13:19,000 --> 01:13:19,000
而且

2070
01:13:20,000 --> 01:13:22,000
而且到底是谁说的

2071
01:13:22,000 --> 01:13:23,000
好像也没有人找出来

2072
01:13:24,000 --> 01:13:24,000
反正就是

2073
01:13:25,000 --> 01:13:26,000
反正他就被黑了

2074
01:13:27,000 --> 01:13:27,000
对

2075
01:13:27,000 --> 01:13:28,000
反正大家都喜欢黑他

2076
01:13:28,000 --> 01:13:30,000
跟他脱不了关系了

2077
01:13:34,000 --> 01:13:36,000
为什么 640 K 的内存就够了

2078
01:13:37,000 --> 01:13:38,000
他那个时候

2079
01:13:39,000 --> 01:13:40,000
九几年吧

2080
01:13:40,000 --> 01:13:41,000
就是应该出

2081
01:13:41,000 --> 01:13:42,000
那确实你想

2082
01:13:42,000 --> 01:13:44,000
那个时候多少一个磁盘

2083
01:13:45,000 --> 01:13:46,000
不叫磁盘软盘吧

2084
01:13:46,000 --> 01:13:46,000
才多少

2085
01:13:46,000 --> 01:13:48,000
才 720 K 标准的

2086
01:13:48,000 --> 01:13:50,000
后来再翻翻成 1.44 兆

2087
01:13:50,000 --> 01:13:52,000
那就是高密

2088
01:13:52,000 --> 01:13:53,000
高密

2089
01:13:53,000 --> 01:13:54,000
HiddenCity

2090
01:13:54,000 --> 01:13:54,000
对

2091
01:13:54,000 --> 01:13:55,000
1.44 兆

2092
01:13:55,000 --> 01:13:56,000
然后有一个

2093
01:13:56,000 --> 01:13:58,000
就你想象一下那个时候

2094
01:13:58,000 --> 01:13:59,000
就你再想象今天一样

2095
01:13:59,000 --> 01:14:01,000
比如说你那个笔记本的硬盘

2096
01:14:01,000 --> 01:14:02,000
是一个 T 的大小

2097
01:14:03,000 --> 01:14:04,000
然后你有一个 T 的内存

2098
01:14:04,000 --> 01:14:05,000
你当然觉得足够了

2099
01:14:06,000 --> 01:14:07,000
嗯

2100
01:14:07,000 --> 01:14:10,000
但是现在后来发现

2101
01:14:10,000 --> 01:14:12,000
哎不对好像不是这样的

2102
01:14:12,000 --> 01:14:14,000
就是随着

2103
01:14:14,000 --> 01:14:17,000
一个程序所需要完成的任务的

2104
01:14:17,000 --> 01:14:18,000
复杂

2105
01:14:19,000 --> 01:14:20,000
逐渐变得复杂

2106
01:14:20,000 --> 01:14:22,000
它所需要的内存

2107
01:14:22,000 --> 01:14:22,000
也就是

2108
01:14:23,000 --> 01:14:24,000
几何几数的

2109
01:14:25,000 --> 01:14:26,000
速度增长

2110
01:14:26,000 --> 01:14:27,000
所以

2111
01:14:28,000 --> 01:14:29,000
内存不够怎么办

2112
01:14:29,000 --> 01:14:30,000
就变成了一个非常切实的问题

2113
01:14:31,000 --> 01:14:33,000
所以在一个

2114
01:14:33,000 --> 01:14:34,000
热量考古的话

2115
01:14:34,000 --> 01:14:36,000
从那个时候最开始

2116
01:14:36,000 --> 01:14:38,000
最开始的操作系统是一个

2117
01:14:38,000 --> 01:14:40,000
单线单进程的东西

2118
01:14:40,000 --> 01:14:41,000
对

2119
01:14:41,000 --> 01:14:42,000
最开始的操作系统

2120
01:14:42,000 --> 01:14:43,000
其实不是个操作系统

2121
01:14:43,000 --> 01:14:43,000
它

2122
01:14:44,000 --> 01:14:45,000
或者说没有任何特殊之处

2123
01:14:45,000 --> 01:14:47,000
它只不过就是开机

2124
01:14:47,000 --> 01:14:48,000
这个程序被自动运行

2125
01:14:49,000 --> 01:14:51,000
然后你可以用这个程序

2126
01:14:51,000 --> 01:14:53,000
去找到你想要运行的那个程序

2127
01:14:53,000 --> 01:14:54,000
然后运行那个程序

2128
01:14:55,000 --> 01:14:56,000
在这个过程之中

2129
01:14:56,000 --> 01:14:58,000
你最开始运行的那个程序

2130
01:14:58,000 --> 01:14:58,000
就

2131
01:14:59,000 --> 01:15:00,000
就退出去了

2132
01:15:00,000 --> 01:15:01,000
就不再存在电脑里面了

2133
01:15:01,000 --> 01:15:03,000
然后你接下来运行的这个程序

2134
01:15:04,000 --> 01:15:05,000
它独占整个电脑

2135
01:15:05,000 --> 01:15:08,000
它认为我是活在这个电脑上的

2136
01:15:08,000 --> 01:15:09,000
唯一程序

2137
01:15:10,000 --> 01:15:11,000
而且

2138
01:15:11,000 --> 01:15:13,000
其实即便到今天这一点

2139
01:15:13,000 --> 01:15:14,000
多多少少还是成立的

2140
01:15:14,000 --> 01:15:17,000
就是每一个程序都多少认为

2141
01:15:17,000 --> 01:15:19,000
自己拥有整台计算机

2142
01:15:20,000 --> 01:15:21,000
其实这是一个假设

2143
01:15:21,000 --> 01:15:23,000
其实只不过是操作系统

2144
01:15:23,000 --> 01:15:24,000
或者是 CPU

2145
01:15:25,000 --> 01:15:26,000
给它制造出来的一个幻境

2146
01:15:26,000 --> 01:15:28,000
让它活在你的视线里

2147
01:15:28,000 --> 01:15:29,000
其实

2148
01:15:29,000 --> 01:15:29,000
对

2149
01:15:29,000 --> 01:15:30,000
在物理意义上

2150
01:15:30,000 --> 01:15:31,000
在实体意义上

2151
01:15:31,000 --> 01:15:33,000
它正在和别人

2152
01:15:34,000 --> 01:15:36,000
共同享用同一块内存

2153
01:15:37,000 --> 01:15:40,000
这个可能早期用过 DOS 的用户

2154
01:15:40,000 --> 01:15:40,000
还有这个印象

2155
01:15:40,000 --> 01:15:42,000
你开到 DOS

2156
01:15:42,000 --> 01:15:44,000
开到命令行进了一个程序

2157
01:15:44,000 --> 01:15:45,000
你要干点别的事

2158
01:15:45,000 --> 01:15:46,000
你还得从那里退出来

2159
01:15:46,000 --> 01:15:47,000
先保存

2160
01:15:47,000 --> 01:15:48,000
然后退出再起另外一个程序

2161
01:15:48,000 --> 01:15:50,000
然后做完那个是保存退出

2162
01:15:50,000 --> 01:15:51,000
再回到之前

2163
01:15:51,000 --> 01:15:53,000
然后后来是在

2164
01:15:53,000 --> 01:15:55,000
说 Windows 3.2

2165
01:15:55,000 --> 01:15:56,000
还是 95 的时候

2166
01:15:57,000 --> 01:16:00,000
出现了这个多任务的概念了

2167
01:16:00,000 --> 01:16:01,000
Windows 3.2 有多任务吗

2168
01:16:01,000 --> 01:16:04,000
我不太清楚

2169
01:16:05,000 --> 01:16:05,000
等一下

2170
01:16:05,000 --> 01:16:07,000
其实我好像没有用 Windows 3.2

2171
01:16:07,000 --> 01:16:11,000
Windows 3.2 是专门为中国市场做的

2172
01:16:11,000 --> 01:16:12,000
其实就是 Windows 3.2

2173
01:16:12,000 --> 01:16:13,000
其实是用汉化版

2174
01:16:13,000 --> 01:16:15,000
就 Windows 3.1 的汉化版

2175
01:16:15,000 --> 01:16:15,000
OK 对

2176
01:16:16,000 --> 01:16:16,000
对

2177
01:16:16,000 --> 01:16:17,000
所以

2178
01:16:17,000 --> 01:16:18,000
3.1 有多任务

2179
01:16:18,000 --> 01:16:20,000
我们好像没有吧

2180
01:16:20,000 --> 01:16:22,000
我并不确切地记得

2181
01:16:22,000 --> 01:16:24,000
自己曾经在 Windows 3.1 的时代

2182
01:16:24,000 --> 01:16:28,000
按过 Alz 加 Tab 这个组合

2183
01:16:28,000 --> 01:16:29,000
切换任务

2184
01:16:30,000 --> 01:16:32,000
对 应该是没有吧

2185
01:16:32,000 --> 01:16:34,000
但至少这个很确定是

2186
01:16:34,000 --> 01:16:37,000
Windows 95 肯定是一个多任务的系统

2187
01:16:37,000 --> 01:16:38,000
对 Windows 95

2188
01:16:38,000 --> 01:16:39,000
对 我还记得我

2189
01:16:40,000 --> 01:16:41,000
最晚是在

2190
01:16:42,000 --> 01:16:44,000
研究生时代还教过一个人

2191
01:16:45,000 --> 01:16:47,000
用 Alz 加 Tab 可以切换到其他程序里面去

2192
01:16:47,000 --> 01:16:49,000
他大为惊讶 你知道吗

2193
01:16:50,000 --> 01:16:51,000
他说原来

2194
01:16:51,000 --> 01:16:53,000
还可以这么玩

2195
01:16:53,000 --> 01:16:54,000
原来我切换到

2196
01:16:54,000 --> 01:16:56,000
就是原来这样按一下

2197
01:16:56,000 --> 01:16:58,000
原来就是我刚才在做的事情

2198
01:16:58,000 --> 01:17:00,000
还在继续被做

2199
01:17:02,000 --> 01:17:04,000
但其实这里也是看

2200
01:17:04,000 --> 01:17:07,000
你看除了程序的认知上有一个过渡

2201
01:17:07,000 --> 01:17:10,000
就是我们作为用户的认知上

2202
01:17:10,000 --> 01:17:11,000
其实也是需要一个过渡的

2203
01:17:11,000 --> 01:17:12,000
本来想

2204
01:17:12,000 --> 01:17:14,000
一个机器只能干一件事情 对吧

2205
01:17:14,000 --> 01:17:15,000
然后突然

2206
01:17:15,000 --> 01:17:16,000
能够同时干几件事情

2207
01:17:16,000 --> 01:17:19,000
还是蛮奇怪的一个认知上的变化

2208
01:17:20,000 --> 01:17:20,000
对 但

2209
01:17:21,000 --> 01:17:23,000
但回到游戏上面

2210
01:17:23,000 --> 01:17:26,000
其实在 DOS 时代已经有很多游戏可以

2211
01:17:26,000 --> 01:17:26,000
比如说

2212
01:17:26,000 --> 01:17:28,000
或者说游戏给你观感就是

2213
01:17:28,000 --> 01:17:30,000
你可以一边放音乐

2214
01:17:30,000 --> 01:17:32,000
就是至少游戏的背景音乐在播放

2215
01:17:32,000 --> 01:17:36,000
然后你还可以操纵里面的人在走路

2216
01:17:36,000 --> 01:17:36,000
然后

2217
01:17:38,000 --> 01:17:41,000
好像也没有那么的让人

2218
01:17:41,000 --> 01:17:42,000
但是但起码就是说

2219
01:17:42,000 --> 01:17:45,000
在对这个东西的认识上

2220
01:17:45,000 --> 01:17:46,000
他还是说他在玩这个游戏

2221
01:17:47,000 --> 01:17:48,000
他不能在玩这个游戏的时候

2222
01:17:48,000 --> 01:17:49,000
同时去

2223
01:17:50,000 --> 01:17:51,000
就处理一个什么文字

2224
01:17:51,000 --> 01:17:53,000
然后编辑一个文本之类的

2225
01:17:54,000 --> 01:17:57,000
对 虽然那个时代也有什么常铸内存的

2226
01:17:58,000 --> 01:17:58,000
工具

2227
01:17:58,000 --> 01:18:00,000
比如说有些游戏修改工具

2228
01:18:00,000 --> 01:18:02,000
会自己缩在内存一角

2229
01:18:02,000 --> 01:18:03,000
然后让你去漏了一个

2230
01:18:04,000 --> 01:18:05,000
然后按一个什么快捷键

2231
01:18:05,000 --> 01:18:06,000
然后按一个热键

2232
01:18:06,000 --> 01:18:07,000
整个游戏就

2233
01:18:08,000 --> 01:18:10,000
就冻结在那里

2234
01:18:10,000 --> 01:18:12,000
然后这个时候你可以用这个小工具来

2235
01:18:12,000 --> 01:18:13,000
修改内存

2236
01:18:13,000 --> 01:18:16,000
然后等你改好的时候再重新继续游戏

2237
01:18:16,000 --> 01:18:17,000
其实就是一个 debugger

2238
01:18:18,000 --> 01:18:18,000
对

2239
01:18:19,000 --> 01:18:19,000
对

2240
01:18:19,000 --> 01:18:20,000
然后重新继续游戏发现

2241
01:18:20,000 --> 01:18:22,000
哎自己忽然有了几万块钱

2242
01:18:24,000 --> 01:18:24,000
有了什么

2243
01:18:25,000 --> 01:18:26,000
金蝉鼓

2244
01:18:27,000 --> 01:18:27,000
对

2245
01:18:28,000 --> 01:18:31,000
这些游戏那个时候如此的熟悉

2246
01:18:31,000 --> 01:18:33,000
怎么现在好像

2247
01:18:33,000 --> 01:18:34,000
这些工具那个时候

2248
01:18:35,000 --> 01:18:37,000
那么耳熟能想到

2249
01:18:37,000 --> 01:18:38,000
现在好像一个都想不出来

2250
01:18:38,000 --> 01:18:39,000
我只想起一个

2251
01:18:39,000 --> 01:18:41,000
就只能想起一个 PC tools

2252
01:18:41,000 --> 01:18:42,000
我也想不起来了

2253
01:18:42,000 --> 01:18:43,000
anyway

2254
01:18:43,000 --> 01:18:45,000
回头再去考古吧

2255
01:18:45,000 --> 01:18:45,000
好呀

2256
01:18:46,000 --> 01:18:47,000
然后就 Windows

2257
01:18:47,000 --> 01:18:48,000
就起码我们能够确切的知道

2258
01:18:48,000 --> 01:18:51,000
是 Windows 95 开始搭载一个什么多任务的系统

2259
01:18:51,000 --> 01:18:53,000
不过它那个多任务和我们现在多任务

2260
01:18:53,000 --> 01:18:56,000
还是在机制上还是有很大不一样的

2261
01:18:57,000 --> 01:18:58,000
它是一个所谓的

2262
01:18:59,000 --> 01:19:00,000
非强战士

2263
01:19:00,000 --> 01:19:01,000
协作式多任务

2264
01:19:02,000 --> 01:19:02,000
对

2265
01:19:02,000 --> 01:19:03,000
就是

2266
01:19:03,000 --> 01:19:06,000
简单来说就是你是一个程序

2267
01:19:06,000 --> 01:19:06,000
我是一个程序

2268
01:19:06,000 --> 01:19:08,000
然后我们两个必须

2269
01:19:08,000 --> 01:19:09,000
比较有默契

2270
01:19:09,000 --> 01:19:11,000
一定要说你放长吧我登场

2271
01:19:11,000 --> 01:19:12,000
然后

2272
01:19:13,000 --> 01:19:15,000
我先用到我觉得可以不用的时候

2273
01:19:15,000 --> 01:19:18,000
我要主动放弃对于机器的控制权

2274
01:19:18,000 --> 01:19:20,000
交给别人

2275
01:19:20,000 --> 01:19:21,000
对

2276
01:19:22,000 --> 01:19:23,000
这个就有点跟

2277
01:19:23,000 --> 01:19:25,000
其实做个类比的话

2278
01:19:25,000 --> 01:19:26,000
跟现在哪个事情比较相像

2279
01:19:26,000 --> 01:19:28,000
现在跟那个做

2280
01:19:28,000 --> 01:19:29,000
我觉得就唱 K 一样

2281
01:19:29,000 --> 01:19:30,000
就

2282
01:19:30,000 --> 01:19:31,000
你

2283
01:19:31,000 --> 01:19:33,000
My Bar

2284
01:19:33,000 --> 01:19:33,000
对

2285
01:19:33,000 --> 01:19:35,000
你要做 My Bar 的话

2286
01:19:35,000 --> 01:19:37,000
My Bar 这种东西招人讨厌

2287
01:19:37,000 --> 01:19:39,000
就是因为没有一个更强大的

2288
01:19:39,000 --> 01:19:40,000
那个

2289
01:19:41,000 --> 01:19:43,000
一个裁判机制

2290
01:19:43,000 --> 01:19:44,000
站在那儿说

2291
01:19:44,000 --> 01:19:45,000
你唱够了你把麦给我

2292
01:19:45,000 --> 01:19:46,000
我把它给别人

2293
01:19:47,000 --> 01:19:48,000
对

2294
01:19:48,000 --> 01:19:52,000
当时 Windows 95 就有点像一群程序在唱 K

2295
01:19:53,000 --> 01:19:54,000
你唱一会我唱一会

2296
01:19:54,000 --> 01:19:56,000
我们要轮流换对吧

2297
01:19:56,000 --> 01:19:57,000
但如果有一个人

2298
01:19:57,000 --> 01:19:58,000
把着 My Bar 不放的话

2299
01:19:58,000 --> 01:19:59,000
有可能就

2300
01:20:00,000 --> 01:20:02,000
用户就说怎么又没有响应了

2301
01:20:02,000 --> 01:20:04,000
系统资源独占了它就

2302
01:20:04,000 --> 01:20:04,000
对

2303
01:20:05,000 --> 01:20:06,000
怎么这么卡重新一下

2304
01:20:07,000 --> 01:20:07,000
然后

2305
01:20:07,000 --> 01:20:08,000
对

2306
01:20:08,000 --> 01:20:09,000
大家都没歌唱

2307
01:20:09,000 --> 01:20:10,000
对

2308
01:20:10,000 --> 01:20:11,000
协作是多人物

2309
01:20:11,000 --> 01:20:14,000
其实在现在我们日常的编程的过程中间

2310
01:20:14,000 --> 01:20:16,000
还有一个比较相关的东西

2311
01:20:17,000 --> 01:20:18,000
比如说在 Node 里面

2312
01:20:18,000 --> 01:20:20,000
因为 Node 是一个单进程的东西

2313
01:20:20,000 --> 01:20:21,000
然后你要做一些

2314
01:20:21,000 --> 01:20:23,000
稍微复杂一点的

2315
01:20:23,000 --> 01:20:24,000
或者是需要等待的操作

2316
01:20:24,000 --> 01:20:26,000
比如说你要做 Io 的时候

2317
01:20:26,000 --> 01:20:28,000
你得用一个所谓的回调

2318
01:20:28,000 --> 01:20:28,000
call back

2319
01:20:28,000 --> 01:20:29,000
其实那个时候

2320
01:20:29,000 --> 01:20:30,000
就是一个所谓的

2321
01:20:31,000 --> 01:20:32,000
协作是多人物的一个体现

2322
01:20:32,000 --> 01:20:32,000
就说

2323
01:20:33,000 --> 01:20:34,000
我现在能

2324
01:20:34,000 --> 01:20:35,000
我之前能做的那些什么

2325
01:20:35,000 --> 01:20:36,000
加点存储的计算都做完了

2326
01:20:36,000 --> 01:20:37,000
现在我要做一个

2327
01:20:37,000 --> 01:20:39,000
可能我不能马上执行东西

2328
01:20:39,000 --> 01:20:40,000
因为要等 Io 返回

2329
01:20:41,000 --> 01:20:43,000
我先把所谓控制权让出来

2330
01:20:43,000 --> 01:20:45,000
然后我先给你一个回调函数

2331
01:20:45,000 --> 01:20:46,000
等这个东西

2332
01:20:46,000 --> 01:20:48,000
就告诉调度器说

2333
01:20:48,000 --> 01:20:52,000
等我要的 Io 结果回来之后

2334
01:20:52,000 --> 01:20:53,000
你再唤醒我

2335
01:20:53,000 --> 01:20:55,000
接着执行回调程序

2336
01:20:55,000 --> 01:20:57,000
但现在开始我就把控制权让出去了

2337
01:20:57,000 --> 01:20:59,000
这个就是一个协作多人物的体现

2338
01:21:00,000 --> 01:21:00,000
对

2339
01:21:01,000 --> 01:21:02,000
然后在 Windows 95 的时代

2340
01:21:02,000 --> 01:21:03,000
就所有的程序

2341
01:21:03,000 --> 01:21:07,000
你要进行系统资源的共享的话

2342
01:21:07,000 --> 01:21:09,000
你这是要做类似的事情

2343
01:21:09,000 --> 01:21:11,000
但是那个时候

2344
01:21:11,000 --> 01:21:13,000
其实当我们说到 Windows 95 的时候

2345
01:21:13,000 --> 01:21:15,000
内存已经不是什么太大问题了

2346
01:21:15,000 --> 01:21:17,000
在 Windows 95 之前的

2347
01:21:18,000 --> 01:21:19,000
很长一段时间里面

2348
01:21:19,000 --> 01:21:22,000
怎样优化使用有限的内存

2349
01:21:22,000 --> 01:21:25,000
简直是每一个程序员的必求课

2350
01:21:25,000 --> 01:21:27,000
我觉得 Windows 95 图到也是

2351
01:21:27,000 --> 01:21:29,000
就起码到现在都是

2352
01:21:29,000 --> 01:21:29,000
我觉得

2353
01:21:30,000 --> 01:21:33,000
现在其实还是有很多

2354
01:21:33,000 --> 01:21:36,000
就是有些程序员可以一辈子不碰

2355
01:21:36,000 --> 01:21:37,000
或者在你的从业过程之中

2356
01:21:37,000 --> 01:21:38,000
可能

2357
01:21:39,000 --> 01:21:41,000
你可以一两年

2358
01:21:41,000 --> 01:21:44,000
不去碰任何和内存管理有关的话题

2359
01:21:44,000 --> 01:21:44,000
比如

2360
01:21:44,000 --> 01:21:46,000
但那个时候是做不到的

2361
01:21:46,000 --> 01:21:47,000
对

2362
01:21:47,000 --> 01:21:47,000
就现在的话

2363
01:21:47,000 --> 01:21:51,000
你只要用一个所谓的 Managed Language

2364
01:21:51,000 --> 01:21:52,000
就是管理过的语言

2365
01:21:52,000 --> 01:21:54,000
比如说 SafeShop

2366
01:21:54,000 --> 01:21:55,000
不用那个什么指针

2367
01:21:55,000 --> 01:21:57,000
那个叫不安全指针叫什么

2368
01:21:57,000 --> 01:21:58,000
对

2369
01:21:58,000 --> 01:21:58,000
Unsafe

2370
01:21:58,000 --> 01:21:59,000
Unsafe pointer

2371
01:21:59,000 --> 01:22:00,000
对吧

2372
01:22:00,000 --> 01:22:00,000
然后

2373
01:22:00,000 --> 01:22:03,000
你说你这种 Java 用 JVM 上面跑

2374
01:22:03,000 --> 01:22:05,000
或者像什么刚才讲 Node

2375
01:22:05,000 --> 01:22:07,000
还有像很多这种脚本语言 Python 都是

2376
01:22:07,000 --> 01:22:09,000
你都不需要去手工的

2377
01:22:09,000 --> 01:22:11,000
直接去管理分配内存

2378
01:22:11,000 --> 01:22:11,000
这都是

2379
01:22:13,000 --> 01:22:15,000
系统或者运行时帮你解决了

2380
01:22:15,000 --> 01:22:16,000
然后甚至像

2381
01:22:16,000 --> 01:22:16,000
你都是

2382
01:22:16,000 --> 01:22:18,000
你这些不是手务管理

2383
01:22:18,000 --> 01:22:19,000
包括你不用去申请

2384
01:22:19,000 --> 01:22:20,000
你不用去分配

2385
01:22:20,000 --> 01:22:22,000
然后你也不用去担心

2386
01:22:23,000 --> 01:22:23,000
叫什么

2387
01:22:24,000 --> 01:22:24,000
返回的

2388
01:22:24,000 --> 01:22:25,000
不叫返回

2389
01:22:25,000 --> 01:22:26,000
释放的问题

2390
01:22:26,000 --> 01:22:26,000
对

2391
01:22:26,000 --> 01:22:28,000
但是如果你像在

2392
01:22:28,000 --> 01:22:30,000
还是有用 C 类的语言

2393
01:22:30,000 --> 01:22:31,000
比如说 C

2394
01:22:31,000 --> 01:22:32,000
C++

2395
01:22:32,000 --> 01:22:34,000
或者是现在大家还在写 OBSC

2396
01:22:34,000 --> 01:22:36,000
你还是要在很多程度上

2397
01:22:36,000 --> 01:22:38,000
是要手工管理内存的

2398
01:22:38,000 --> 01:22:38,000
所以有没有人会

2399
01:22:38,000 --> 01:22:39,000
对你必须去考虑这件事情

2400
01:22:39,000 --> 01:22:40,000
至少

2401
01:22:40,000 --> 01:22:41,000
就算你不去

2402
01:22:41,000 --> 01:22:43,000
亲自去做这件事情

2403
01:22:43,000 --> 01:22:44,000
你这时候考虑这件事

2404
01:22:44,000 --> 01:22:46,000
SWIFT 还是需要手工管理内存吗

2405
01:22:46,000 --> 01:22:47,000
SWIFT 不需要

2406
01:22:47,000 --> 01:22:48,000
OK

2407
01:22:48,000 --> 01:22:49,000
它是一个

2408
01:22:49,000 --> 01:22:50,000
就是 Management language

2409
01:22:50,000 --> 01:22:51,000
它是有 GC

2410
01:22:51,000 --> 01:22:53,000
所以在手工管理内存的时候

2411
01:22:53,000 --> 01:22:55,000
需要做一些什么事情

2412
01:22:56,000 --> 01:22:57,000
就是我记得那个时代

2413
01:22:57,000 --> 01:22:59,000
看过一些手工管理内存的书

2414
01:22:59,000 --> 01:23:01,000
会提到比如说

2415
01:23:01,000 --> 01:23:03,000
你一个程序

2416
01:23:03,000 --> 01:23:05,000
比如说你只有一兆内存可以用

2417
01:23:05,000 --> 01:23:07,000
然后你需要

2418
01:23:08,000 --> 01:23:09,000
调用一堆函数

2419
01:23:11,000 --> 01:23:13,000
这些所有这些函数加在一起

2420
01:23:13,000 --> 01:23:13,000
可能有两兆

2421
01:23:15,000 --> 01:23:16,000
那怎么办呢

2422
01:23:17,000 --> 01:23:18,000
你可以把

2423
01:23:19,000 --> 01:23:19,000
你可以

2424
01:23:19,000 --> 01:23:21,000
这个时候就需要你精心去

2425
01:23:21,000 --> 01:23:23,000
规划函数的分布

2426
01:23:23,000 --> 01:23:24,000
你要把一些函数

2427
01:23:25,000 --> 01:23:27,000
打包包在一个正好是

2428
01:23:27,000 --> 01:23:28,000
比如说

2429
01:23:28,000 --> 01:23:29,000
500 K 的这么一个

2430
01:23:31,000 --> 01:23:31,000
就是动态

2431
01:23:31,000 --> 01:23:33,000
所谓动态库里面吧

2432
01:23:33,000 --> 01:23:35,000
然后你运行

2433
01:23:35,000 --> 01:23:36,000
比如说你在写游戏

2434
01:23:36,000 --> 01:23:37,000
然后这个游戏里面

2435
01:23:37,000 --> 01:23:39,000
跑这个关卡的时候

2436
01:23:39,000 --> 01:23:40,000
关卡

2437
01:23:40,000 --> 01:23:41,000
这我说对了

2438
01:23:43,000 --> 01:23:44,000
跑这个关卡的时候

2439
01:23:44,000 --> 01:23:45,000
你又需要用的这些函数

2440
01:23:45,000 --> 01:23:46,000
那你就

2441
01:23:46,000 --> 01:23:48,000
在这个时候把这 512 K 的

2442
01:23:49,000 --> 01:23:50,000
库调入内存

2443
01:23:51,000 --> 01:23:52,000
然后去调入这些函数

2444
01:23:52,000 --> 01:23:53,000
然后等到你

2445
01:23:53,000 --> 01:23:54,000
打完这个关卡之后

2446
01:23:54,000 --> 01:23:55,000
这些函数不需要了

2447
01:23:55,000 --> 01:23:56,000
然后再把另外一个函数

2448
01:23:56,000 --> 01:23:58,000
另外一个库调进来

2449
01:23:58,000 --> 01:23:59,000
然后就等于你手工

2450
01:23:59,000 --> 01:24:00,000
要去

2451
01:24:00,000 --> 01:24:01,000
在你的程序里面

2452
01:24:01,000 --> 01:24:03,000
实现一个内存管理器

2453
01:24:03,000 --> 01:24:05,000
实现一个动态加载器

2454
01:24:06,000 --> 01:24:07,000
诸如此类的

2455
01:24:07,000 --> 01:24:08,000
诸如此类的细节

2456
01:24:08,000 --> 01:24:09,000
那个时候我觉得

2457
01:24:09,000 --> 01:24:11,000
哇靠这些都是黑魔法

2458
01:24:11,000 --> 01:24:12,000
实在是

2459
01:24:13,000 --> 01:24:15,000
我现在可能也多少觉得有点黑魔法

2460
01:24:15,000 --> 01:24:15,000
因为我其实

2461
01:24:16,000 --> 01:24:17,000
个人来讲

2462
01:24:17,000 --> 01:24:18,000
从来没有做过任何

2463
01:24:18,000 --> 01:24:19,000
内存优化方面的东西

2464
01:24:19,000 --> 01:24:21,000
就我就已经长大了

2465
01:24:21,000 --> 01:24:21,000
就已经

2466
01:24:21,000 --> 01:24:23,000
就已经直接进入 G-Face 了

2467
01:24:23,000 --> 01:24:24,000
就已经幸运的

2468
01:24:24,000 --> 01:24:26,000
进入了 Garbage Collection

2469
01:24:26,000 --> 01:24:27,000
无处不在的时代

2470
01:24:27,000 --> 01:24:27,000
对

2471
01:24:27,000 --> 01:24:30,000
而我相信现在有很多程序员可能

2472
01:24:30,000 --> 01:24:31,000
从入门到

2473
01:24:31,000 --> 01:24:33,000
尤其是如果你不是学

2474
01:24:34,000 --> 01:24:36,000
计算机科班出身的话

2475
01:24:36,000 --> 01:24:37,000
你可能完全

2476
01:24:37,000 --> 01:24:38,000
有机会就是

2477
01:24:38,000 --> 01:24:40,000
完全没有接触过

2478
01:24:40,000 --> 01:24:42,000
什么是内存管理

2479
01:24:42,000 --> 01:24:43,000
比如说我就是

2480
01:24:43,000 --> 01:24:45,000
我本科读的不是这个 CS 吗

2481
01:24:45,000 --> 01:24:46,000
就是其实我

2482
01:24:46,000 --> 01:24:48,000
等我接触这些东西的时候

2483
01:24:48,000 --> 01:24:49,000
那些都只存

2484
01:24:49,000 --> 01:24:51,000
停留在课本上的概念

2485
01:24:51,000 --> 01:24:52,000
就是我知道怎么一回事

2486
01:24:52,000 --> 01:24:53,000
原理怎么

2487
01:24:53,000 --> 01:24:54,000
但是我自己其实

2488
01:24:54,000 --> 01:24:55,000
没有

2489
01:24:55,000 --> 01:24:57,000
亲身去操作过那个东西

2490
01:24:58,000 --> 01:24:59,000
这是变相秀年轻的

2491
01:25:00,000 --> 01:25:00,000
不

2492
01:25:00,000 --> 01:25:01,000
这个是

2493
01:25:01,000 --> 01:25:03,000
这是变相秀这个事情

2494
01:25:03,000 --> 01:25:04,000
底气不足

2495
01:25:04,000 --> 01:25:05,000
不能多说

2496
01:25:05,000 --> 01:25:06,000
好吧

2497
01:25:06,000 --> 01:25:07,000
那咱俩其实都比较

2498
01:25:07,000 --> 01:25:08,000
底气不足

2499
01:25:08,000 --> 01:25:08,000
因为

2500
01:25:08,000 --> 01:25:10,000
混蛋你是科班出身

2501
01:25:10,000 --> 01:25:11,000
怎么能够说你底气不足

2502
01:25:12,000 --> 01:25:13,000
可我也没有写过

2503
01:25:13,000 --> 01:25:14,000
只一个

2504
01:25:14,000 --> 01:25:15,000
好吧

2505
01:25:15,000 --> 01:25:16,000
我还是做过一点

2506
01:25:17,000 --> 01:25:17,000
但

2507
01:25:17,000 --> 01:25:19,000
正儿八经的在工作

2508
01:25:19,000 --> 01:25:20,000
或者在

2509
01:25:20,000 --> 01:25:22,000
在实践之中

2510
01:25:22,000 --> 01:25:23,000
利用内存管理的知识

2511
01:25:23,000 --> 01:25:24,000
解决一个实际问题

2512
01:25:24,000 --> 01:25:25,000
可能绝无仅有

2513
01:25:26,000 --> 01:25:28,000
但你之前写 IOS 的时候

2514
01:25:28,000 --> 01:25:29,000
不需要用这个吗

2515
01:25:29,000 --> 01:25:30,000
不需要手工管理内存吗

2516
01:25:32,000 --> 01:25:33,000
IOS 的所谓管理内存

2517
01:25:33,000 --> 01:25:35,000
你只是需要操心

2518
01:25:35,000 --> 01:25:37,000
不要泄露内存而已

2519
01:25:37,000 --> 01:25:38,000
根本不需要

2520
01:25:38,000 --> 01:25:39,000
就记得释放

2521
01:25:39,000 --> 01:25:39,000
使用

2522
01:25:39,000 --> 01:25:40,000
对

2523
01:25:41,000 --> 01:25:43,000
IOS 已经是一个非常非常先进的

2524
01:25:44,000 --> 01:25:45,000
或者说

2525
01:25:46,000 --> 01:25:46,000
Object-C

2526
01:25:46,000 --> 01:25:48,000
Coco 这个运行时

2527
01:25:48,000 --> 01:25:49,000
已经是非常非常先进的一套东西

2528
01:25:50,000 --> 01:25:51,000
不需要去

2529
01:25:51,000 --> 01:25:53,000
考虑自己的

2530
01:25:53,000 --> 01:25:55,000
Object 在内存里面是怎么样对齐的

2531
01:25:55,000 --> 01:25:56,000
或者是

2532
01:26:00,000 --> 01:26:01,000
很多 C 时代

2533
01:26:01,000 --> 01:26:02,000
什么

2534
01:26:02,000 --> 01:26:05,000
这个 Struct Align 那种东西是吧

2535
01:26:05,000 --> 01:26:06,000
对这些东西

2536
01:26:06,000 --> 01:26:08,000
什么 Padding 啊

2537
01:26:08,000 --> 01:26:10,000
什么乃至

2538
01:26:12,000 --> 01:26:13,000
C 里面还有一种黑魔法

2539
01:26:13,000 --> 01:26:15,000
是使用 Union 类型来

2540
01:26:15,000 --> 01:26:17,000
节省所有的功能

2541
01:26:17,000 --> 01:26:20,000
我记得之前以前学 C 看老谭的书的时候

2542
01:26:20,000 --> 01:26:21,000
还挺

2543
01:26:21,000 --> 01:26:23,000
对这块还挺觉得挺新奇的

2544
01:26:23,000 --> 01:26:24,000
对

2545
01:26:24,000 --> 01:26:26,000
那个时候真的是为了省一两个 byte

2546
01:26:26,000 --> 01:26:28,000
可以绞尽脑汁想好

2547
01:26:30,000 --> 01:26:33,000
真正的 Primature Optimization

2548
01:26:34,000 --> 01:26:35,000
这个已经不是

2549
01:26:36,000 --> 01:26:37,000
我也不知道

2550
01:26:37,000 --> 01:26:38,000
可是那个时代

2551
01:26:38,000 --> 01:26:40,000
你如果不能

2552
01:26:40,000 --> 01:26:42,000
精细的去使用内存的话

2553
01:26:43,000 --> 01:26:45,000
就没有什么多的内存可以给你用

2554
01:26:45,000 --> 01:26:47,000
经常就会直接 OM 了

2555
01:26:47,000 --> 01:26:47,000
对

2556
01:26:47,000 --> 01:26:50,000
也没有虚拟内存这种东西对吧

2557
01:26:50,000 --> 01:26:53,000
也没有一个运行时

2558
01:26:53,000 --> 01:26:54,000
或者是没有操作系统来替你

2559
01:26:54,000 --> 01:26:57,000
去操心这些事情

2560
01:26:57,000 --> 01:26:58,000
你只能一切动手

2561
01:26:58,000 --> 01:26:59,000
一切都自己动手

2562
01:26:59,000 --> 01:27:00,000
对

2563
01:27:00,000 --> 01:27:01,000
其实现在的话

2564
01:27:01,000 --> 01:27:03,000
很多做签用识开发的朋友

2565
01:27:03,000 --> 01:27:05,000
他还是要做很多这种

2566
01:27:05,000 --> 01:27:06,000
刚才我们讲的那种工作

2567
01:27:07,000 --> 01:27:07,000
就是要考虑

2568
01:27:07,000 --> 01:27:09,000
因为签用识这种的

2569
01:27:09,000 --> 01:27:11,000
跑的硬件的水平都非常

2570
01:27:11,000 --> 01:27:12,000
按今天的标准来看

2571
01:27:12,000 --> 01:27:13,000
都是非常糟糕的

2572
01:27:13,000 --> 01:27:14,000
对

2573
01:27:14,000 --> 01:27:15,000
上次我在看说

2574
01:27:15,000 --> 01:27:17,000
那个什么现在不是要流行一个什么

2575
01:27:17,000 --> 01:27:18,000
Internet of Science

2576
01:27:18,000 --> 01:27:20,000
什么物联网的这个时代

2577
01:27:20,000 --> 01:27:21,000
有很多那种所谓传感器

2578
01:27:21,000 --> 01:27:23,000
这种小芯片什么的

2579
01:27:23,000 --> 01:27:25,000
我上次看 ARM 出了一个什么

2580
01:27:25,000 --> 01:27:26,000
一个很常用的芯片

2581
01:27:26,000 --> 01:27:27,000
只有 2 KB 的内存

2582
01:27:29,000 --> 01:27:30,000
What

2583
01:27:30,000 --> 01:27:32,000
就是那种很小的一个传感器的

2584
01:27:32,000 --> 01:27:34,000
一种好的芯片

2585
01:27:34,000 --> 01:27:35,000
只有 2 KB 的内存

2586
01:27:35,000 --> 01:27:36,000
我想这怎么用

2587
01:27:38,000 --> 01:27:40,000
而且 2 KB 不仅要装

2588
01:27:42,000 --> 01:27:43,000
不仅要装数据

2589
01:27:43,000 --> 01:27:43,000
还要装程序本身

2590
01:27:43,000 --> 01:27:44,000
不是

2591
01:27:44,000 --> 01:27:46,000
它那个程序是放在 ROM 里面的

2592
01:27:46,000 --> 01:27:49,000
就是 2 KB 是正儿八经的内存

2593
01:27:49,000 --> 01:27:49,000
只是运行用

2594
01:27:49,000 --> 01:27:50,000
但是

2595
01:27:50,000 --> 01:27:52,000
你想想 2 KB

2596
01:27:53,000 --> 01:27:54,000
但我觉得可能

2597
01:27:54,000 --> 01:27:57,000
嵌入开发还有一个

2598
01:27:59,000 --> 01:28:02,000
有一个不那么让它更复杂的东西

2599
01:28:02,000 --> 01:28:03,000
就是它很少会涉及到

2600
01:28:03,000 --> 01:28:06,000
从一个更大的存储器上

2601
01:28:06,000 --> 01:28:08,000
调用数据到内存里面的这样一个动作

2602
01:28:09,000 --> 01:28:10,000
它是直接

2603
01:28:10,000 --> 01:28:11,000
对

2604
01:28:11,000 --> 01:28:12,000
你一开始在写的时候

2605
01:28:12,000 --> 01:28:14,000
就知道整个 CPU 的

2606
01:28:14,000 --> 01:28:15,000
对

2607
01:28:15,000 --> 01:28:15,000
这个

2608
01:28:15,000 --> 01:28:16,000
或者整个 ROM 的

2609
01:28:17,000 --> 01:28:20,000
整个存储器的分布会是怎么样的

2610
01:28:20,000 --> 01:28:21,000
你有多少东西可以用

2611
01:28:21,000 --> 01:28:23,000
然后里面可能有一个小小的 bootloader

2612
01:28:23,000 --> 01:28:25,000
然后其他所有空间都是你的

2613
01:28:25,000 --> 01:28:26,000
然后你只要往里面

2614
01:28:26,000 --> 01:28:29,000
而且它是一个绝对的单人物的系统

2615
01:28:29,000 --> 01:28:32,000
就没有人和你抢债抢资源什么的

2616
01:28:32,000 --> 01:28:33,000
对

2617
01:28:33,000 --> 01:28:37,000
你整个芯片都是你的

2618
01:28:37,000 --> 01:28:37,000
对

2619
01:28:37,000 --> 01:28:38,000
规划方面的

2620
01:28:38,000 --> 01:28:42,000
头疼的问题可能还少一些

2621
01:28:42,000 --> 01:28:46,000
但是早期的 PCG 变成真的是相当复杂

2622
01:28:47,000 --> 01:28:49,000
这个是我应该说那句话叫

2623
01:28:49,000 --> 01:28:51,000
这个芯片我已经为你预留了

2624
01:28:52,000 --> 01:28:54,000
这个芯片我已经给你承包了是不是

2625
01:28:58,000 --> 01:29:02,000
但是到我们现在的一些主流的一些开发的话

2626
01:29:02,000 --> 01:29:03,000
其实这块

2627
01:29:03,000 --> 01:29:04,000
就如你所说

2628
01:29:04,000 --> 01:29:06,000
其实是没有什么概念

2629
01:29:06,000 --> 01:29:09,000
甚至说连内存本身物理的尺寸

2630
01:29:09,000 --> 01:29:11,000
都已经被抽象掉了

2631
01:29:11,000 --> 01:29:13,000
就是因为有虚拟内存这个东西

2632
01:29:14,000 --> 01:29:14,000
对

2633
01:29:15,000 --> 01:29:18,000
操作系统给程序展现的是一个

2634
01:29:18,000 --> 01:29:23,000
所谓一个连续的庞大的内存的地址空间

2635
01:29:23,000 --> 01:29:26,000
但是其实操作系统的在内存实际分配的时候

2636
01:29:26,000 --> 01:29:29,000
并不是说真的有无限大的一块内存

2637
01:29:29,000 --> 01:29:31,000
给一个程序使用的对吧

2638
01:29:32,000 --> 01:29:32,000
对

2639
01:29:32,000 --> 01:29:36,000
我觉得这个问题可以从程序员的角度

2640
01:29:36,000 --> 01:29:39,000
就是从一个操作系统使用者的角度来看

2641
01:29:39,000 --> 01:29:41,000
就是它简化了变成模型

2642
01:29:42,000 --> 01:29:44,000
就是如果没有虚拟内存的话

2643
01:29:44,000 --> 01:29:46,000
你将不得不面对

2644
01:29:46,000 --> 01:29:48,000
我的程序应该放在哪这个问题

2645
01:29:48,000 --> 01:29:49,000
对

2646
01:29:49,000 --> 01:29:52,000
就是我在我的程序在运行时

2647
01:29:52,000 --> 01:29:55,000
处于内存的什么地方

2648
01:29:55,000 --> 01:29:58,000
难道是一件要我自己来操心的事情吗

2649
01:29:58,000 --> 01:30:00,000
对

2650
01:30:00,000 --> 01:30:00,000
对

2651
01:30:00,000 --> 01:30:01,000
如果没有虚拟内存的话

2652
01:30:01,000 --> 01:30:02,000
你将不得不面临这个问题

2653
01:30:02,000 --> 01:30:06,000
就像早期的

2654
01:30:06,000 --> 01:30:11,000
就重新回到了单机程序的这么一个状态里面

2655
01:30:12,000 --> 01:30:14,000
我要和其他的程序共存吗

2656
01:30:14,000 --> 01:30:19,000
因为就像我刚才说的修改内存的小工具一样

2657
01:30:19,000 --> 01:30:22,000
它显然是要考虑自己要把自己放在什么地方

2658
01:30:23,000 --> 01:30:26,000
然后它必须跟另外一个程序共同享用实体内存

2659
01:30:26,000 --> 01:30:28,000
但是虚拟存在中心就解决这个问题

2660
01:30:28,000 --> 01:30:31,000
就是简单来说一个程序

2661
01:30:31,000 --> 01:30:32,000
如果它是 32 倍的

2662
01:30:32,000 --> 01:30:37,000
那它会认为自己有将近 4 G 的内存空间

2663
01:30:37,000 --> 01:30:44,000
就是从 0 X 000800

2664
01:30:44,000 --> 01:30:45,000
它只有 2 GB

2665
01:30:45,000 --> 01:30:47,000
没有 32 倍的

2666
01:30:47,000 --> 01:30:49,000
就不能到 4 GB 的空间

2667
01:30:50,000 --> 01:30:51,000
32 倍不是 4 GB

2668
01:30:51,000 --> 01:30:54,000
但是好像我记得是在

2669
01:30:54,000 --> 01:30:56,000
操作系统会预留到一部分

2670
01:30:56,000 --> 01:30:57,000
对

2671
01:30:57,000 --> 01:31:02,000
操作系统会占用一部分地址空间

2672
01:31:02,000 --> 01:31:02,000
对

2673
01:31:02,000 --> 01:31:03,000
但肯定不到 4 G 的

2674
01:31:03,000 --> 01:31:05,000
能够实际使用的地址空间

2675
01:31:06,000 --> 01:31:06,000
对

2676
01:31:06,000 --> 01:31:07,000
因为它不是从 00 开始

2677
01:31:07,000 --> 01:31:09,000
所以肯定是到不到 4 G 的

2678
01:31:10,000 --> 01:31:10,000
对

2679
01:31:11,000 --> 01:31:14,000
大概有 3 GB 的空间是可以用的

2680
01:31:15,000 --> 01:31:17,000
然后

2681
01:31:20,000 --> 01:31:22,000
我记得 Windows 上面的

2682
01:31:25,000 --> 01:31:27,000
默认空间好像有

2683
01:31:27,000 --> 01:31:29,000
只有 2 GB 左右

2684
01:31:29,000 --> 01:31:33,000
因为那个时候我记得 Windows 有一个启动参数

2685
01:31:33,000 --> 01:31:34,000
就是

2686
01:31:35,000 --> 01:31:37,000
你还记得 boot.ini 这个东西吗

2687
01:31:38,000 --> 01:31:38,000
我不知道

2688
01:31:38,000 --> 01:31:39,000
好古老

2689
01:31:39,000 --> 01:31:40,000
又暴露年龄了

2690
01:31:40,000 --> 01:31:41,000
就是在 boot.ini 里面

2691
01:31:41,000 --> 01:31:43,000
你可以给 Windows 的启动

2692
01:31:43,000 --> 01:31:47,000
加上一个 slash 3 G 这个选项

2693
01:31:47,000 --> 01:31:47,000
OK

2694
01:31:47,000 --> 01:31:50,000
而且这是 XP 都有的一个参数

2695
01:31:50,000 --> 01:31:52,000
就是你加了这个参数之后

2696
01:31:54,000 --> 01:31:58,000
操作系统的虚拟地址空间

2697
01:31:58,000 --> 01:32:01,000
才会减少到 1 G

2698
01:32:01,000 --> 01:32:02,000
应该是

2699
01:32:02,000 --> 01:32:04,000
然后在这种情况下

2700
01:32:04,000 --> 01:32:06,000
程序才有将近 3 G 的空间可以用

2701
01:32:06,000 --> 01:32:07,000
就哪怕是现在

2702
01:32:07,000 --> 01:32:08,000
如果我没记错的话

2703
01:32:08,000 --> 01:32:09,000
现在的

2704
01:32:09,000 --> 01:32:11,000
就比较现在我没用过 Windows 8 了

2705
01:32:12,000 --> 01:32:14,000
之前的 Windows 的机器

2706
01:32:14,000 --> 01:32:16,000
如果它是 32 位的版本的话

2707
01:32:16,000 --> 01:32:18,000
你插上超过 4 G 的内存

2708
01:32:18,000 --> 01:32:20,000
它实际可以使用的也只有 3 个 GB

2709
01:32:21,000 --> 01:32:22,000
对

2710
01:32:22,000 --> 01:32:22,000
我记得好像是这样子

2711
01:32:22,000 --> 01:32:23,000
对

2712
01:32:26,000 --> 01:32:27,000
不过后来有个什么扩展

2713
01:32:27,000 --> 01:32:31,000
有个什么用 48 位的地址来扩展一下

2714
01:32:31,000 --> 01:32:34,000
然后也可以用到很多

2715
01:32:34,000 --> 01:32:36,000
就超过 4 GB 的内存

2716
01:32:36,000 --> 01:32:38,000
但这个跟今天的一个话题没什么关系

2717
01:32:38,000 --> 01:32:39,000
对

2718
01:32:40,000 --> 01:32:41,000
对

2719
01:32:41,000 --> 01:32:42,000
就是可以这么说

2720
01:32:42,000 --> 01:32:46,000
就是 386 这个系列

2721
01:32:46,000 --> 01:32:49,000
就是我们今天所使用的 32 位

2722
01:32:49,000 --> 01:32:51,000
或者说我们曾经在过去

2723
01:32:51,000 --> 01:32:55,000
已经很长一段时间没所使用的 32 位的 CPU

2724
01:32:55,000 --> 01:33:01,000
其实和最古老的 8086 系列是

2725
01:33:02,000 --> 01:33:04,000
基本可以说是意志兼容的

2726
01:33:04,000 --> 01:33:06,000
但是为了保持这种兼容性

2727
01:33:06,000 --> 01:33:07,000
也不得不付出很多代价

2728
01:33:07,000 --> 01:33:10,000
其中之一就是

2729
01:33:10,000 --> 01:33:12,000
在比如说后面的旋指模式上面

2730
01:33:12,000 --> 01:33:15,000
或者是很多其他地方都有

2731
01:33:16,000 --> 01:33:17,000
不得不做出很多妥协

2732
01:33:17,000 --> 01:33:20,000
然后刚才所说的这个旋指

2733
01:33:20,000 --> 01:33:22,000
其实也是这个妥协的

2734
01:33:22,000 --> 01:33:25,000
一种形式吧

2735
01:33:26,000 --> 01:33:30,000
然后英特尔在推出 64 位处理器的时候

2736
01:33:30,000 --> 01:33:31,000
想要

2737
01:33:31,000 --> 01:33:33,000
曾经想要一劳永逸地解决这个问题

2738
01:33:33,000 --> 01:33:34,000
但是

2739
01:33:35,000 --> 01:33:38,000
那个叫做安腾是吧

2740
01:33:38,000 --> 01:33:41,000
对安腾处理器想要解决这个问题

2741
01:33:41,000 --> 01:33:44,000
但是为此要付出一个

2742
01:33:44,000 --> 01:33:50,000
就是打破这个向后兼容性的这么一个代价

2743
01:33:50,000 --> 01:33:51,000
所以它最终可耻的失败

2744
01:33:52,000 --> 01:33:53,000
对

2745
01:33:54,000 --> 01:33:56,000
假如听众还不太清楚一件事情的话

2746
01:33:56,000 --> 01:33:58,000
就是我们现在用的所谓 64 位处理器

2747
01:33:58,000 --> 01:34:01,000
其实并不是真正以上 64 位

2748
01:34:01,000 --> 01:34:02,000
它只是

2749
01:34:03,000 --> 01:34:06,000
由 AMD 来做出了一个

2750
01:34:07,000 --> 01:34:09,000
尾 64 位系统

2751
01:34:10,000 --> 01:34:12,000
它是一个兼容模式

2752
01:34:12,000 --> 01:34:16,000
它扩展了我们之前使用的 32 位的 CPU

2753
01:34:16,000 --> 01:34:18,000
然后让

2754
01:34:19,000 --> 01:34:19,000
它可以处理

2755
01:34:19,000 --> 01:34:20,000
就是怎么说呢

2756
01:34:21,000 --> 01:34:22,000
简单来说就是

2757
01:34:23,000 --> 01:34:25,000
AMD 64 位的 CPU

2758
01:34:25,000 --> 01:34:29,000
可以运行 32 位的操作手的应用程序

2759
01:34:29,000 --> 01:34:30,000
但是安腾的

2760
01:34:30,000 --> 01:34:32,000
也是一个纯粹的 64 位的处理器

2761
01:34:32,000 --> 01:34:33,000
其实是不行的

2762
01:34:33,000 --> 01:34:34,000
对

2763
01:34:34,000 --> 01:34:36,000
这会导致它就有一个什么鸡和蛋的问题

2764
01:34:36,000 --> 01:34:37,000
说

2765
01:34:37,000 --> 01:34:40,000
你有 64 位的机器了

2766
01:34:40,000 --> 01:34:42,000
可是我们用 64 位的程序要跑

2767
01:34:42,000 --> 01:34:44,000
我让你用 64 位机器来干什么

2768
01:34:44,000 --> 01:34:47,000
于是它那个产品线就挂掉了

2769
01:34:47,000 --> 01:34:47,000
对

2770
01:34:48,000 --> 01:34:51,000
这就是为什么各位还在用 Windows 的朋友们

2771
01:34:52,000 --> 01:34:55,000
你们的 Program Files 下面会有两个

2772
01:34:56,000 --> 01:34:58,000
文件夹一个叫做 Program Files

2773
01:34:58,000 --> 01:35:00,000
一个叫做 Program Files X 64

2774
01:35:00,000 --> 01:35:01,000
还是 X 32

2775
01:35:01,000 --> 01:35:01,000
X 86

2776
01:35:03,000 --> 01:35:04,000
X 86 对

2777
01:35:05,000 --> 01:35:06,000
IA 32 X 86

2778
01:35:07,000 --> 01:35:08,000
就是这样子

2779
01:35:08,000 --> 01:35:12,000
对其中一个里面装着 32 位的

2780
01:35:13,000 --> 01:35:14,000
程序应用程序

2781
01:35:14,000 --> 01:35:17,000
另外一个装着准 64 位的应用程序

2782
01:35:17,000 --> 01:35:19,000
等一下这个在 32 位版的 Windows 上面

2783
01:35:19,000 --> 01:35:20,000
有这个区别吗

2784
01:35:20,000 --> 01:35:21,000
我不太清楚

2785
01:35:22,000 --> 01:35:24,000
在 32 位版的 Windows 上面

2786
01:35:24,000 --> 01:35:27,000
不会有 Program Files

2787
01:35:27,000 --> 01:35:30,000
不会有 Program Files X 64

2788
01:35:30,000 --> 01:35:30,000
因为

2789
01:35:31,000 --> 01:35:33,000
X 86 对

2790
01:35:33,000 --> 01:35:33,000
就只有一个 Program Files

2791
01:35:33,000 --> 01:35:35,000
因为它默认就只有 X 86

2792
01:35:35,000 --> 01:35:35,000
对

2793
01:35:35,000 --> 01:35:37,000
就只有一个 Program Files

2794
01:35:37,000 --> 01:35:38,000
对

2795
01:35:38,000 --> 01:35:42,000
刚才讲到虚拟内存的一个最主要的用途

2796
01:35:42,000 --> 01:35:44,000
就是让编程的模型简化

2797
01:35:44,000 --> 01:35:48,000
就是不用去考虑说你的东西在哪

2798
01:35:48,000 --> 01:35:50,000
然后剩下的调度的问题

2799
01:35:50,000 --> 01:35:53,000
是交给内核来操作的吗

2800
01:35:53,000 --> 01:35:54,000
对

2801
01:35:54,000 --> 01:35:55,000
这里就有一个概念

2802
01:35:55,000 --> 01:35:56,000
叫做 Memory Hierarchy

2803
01:35:56,000 --> 01:35:58,000
就是内存的

2804
01:35:58,000 --> 01:36:00,000
存储器的等级

2805
01:36:03,000 --> 01:36:04,000
就叫等级

2806
01:36:04,000 --> 01:36:05,000
Hierarchy

2807
01:36:05,000 --> 01:36:06,000
内存层级

2808
01:36:06,000 --> 01:36:07,000
对

2809
01:36:07,000 --> 01:36:10,000
其实我们知道在这个计算机里面

2810
01:36:10,000 --> 01:36:12,000
内存其实也不是一个非常

2811
01:36:13,000 --> 01:36:13,000
高级别的

2812
01:36:13,000 --> 01:36:14,000
也不叫高级

2813
01:36:14,000 --> 01:36:14,000
就

2814
01:36:16,000 --> 01:36:16,000
怎么说

2815
01:36:16,000 --> 01:36:18,000
最快的一个存储设备

2816
01:36:19,000 --> 01:36:22,000
最快的存储设备其实是在 CPU 里面

2817
01:36:22,000 --> 01:36:24,000
叫做记存器的东西

2818
01:36:24,000 --> 01:36:24,000
Register

2819
01:36:25,000 --> 01:36:28,000
然后它访问大概是多少一个速度

2820
01:36:28,000 --> 01:36:32,000
在现代的一个 CPU 上访问记存器

2821
01:36:32,000 --> 01:36:33,000
应该就是

2822
01:36:34,000 --> 01:36:34,000
等等

2823
01:36:34,000 --> 01:36:36,000
这个有点迷糊了

2824
01:36:36,000 --> 01:36:37,000
0.5 ns

2825
01:36:38,000 --> 01:36:39,000
那个是 L 1

2826
01:36:41,000 --> 01:36:42,000
访问记存器的速度

2827
01:36:42,000 --> 01:36:43,000
对

2828
01:36:43,000 --> 01:36:44,000
访问记存器的速度是多少的一个量级

2829
01:36:44,000 --> 01:36:46,000
访问记存器需要时间吗

2830
01:36:47,000 --> 01:36:50,000
但肯定是在物理上是需要时间的

2831
01:36:50,000 --> 01:36:52,000
它要等电路反应

2832
01:36:52,000 --> 01:36:54,000
但是是一个非常快速的时间

2833
01:36:55,000 --> 01:36:56,000
对

2834
01:36:56,000 --> 01:37:00,000
可能只需要几个时钟

2835
01:37:00,000 --> 01:37:01,000
几个 cycle

2836
01:37:01,000 --> 01:37:02,000
不用 cycle

2837
01:37:02,000 --> 01:37:03,000
一个 cycle 就能读到

2838
01:37:03,000 --> 01:37:05,000
一个 cycle 就可以读一个 register 吗

2839
01:37:06,000 --> 01:37:07,000
这个我不是很确定

2840
01:37:07,000 --> 01:37:10,000
需要回去做功课了

2841
01:37:10,000 --> 01:37:11,000
对

2842
01:37:11,000 --> 01:37:14,000
我们暴露出了两个人底气不足的状况

2843
01:37:14,000 --> 01:37:16,000
就是没有做功课

2844
01:37:16,000 --> 01:37:18,000
毕竟不是

2845
01:37:18,000 --> 01:37:20,000
毕竟是已经很多年了

2846
01:37:20,000 --> 01:37:21,000
我们没有想到

2847
01:37:21,000 --> 01:37:23,000
我们没有想到会讲这么低层

2848
01:37:23,000 --> 01:37:23,000
OK

2849
01:37:23,000 --> 01:37:24,000
没有

2850
01:37:24,000 --> 01:37:25,000
这个就顺便提一下

2851
01:37:25,000 --> 01:37:26,000
然后

2852
01:37:26,000 --> 01:37:28,000
然后在 CPU 内部

2853
01:37:28,000 --> 01:37:29,000
还有一个叫做 L 1

2854
01:37:29,000 --> 01:37:31,000
就是 layer 1

2855
01:37:31,000 --> 01:37:34,000
L 1 cache

2856
01:37:34,000 --> 01:37:35,000
的这么一个

2857
01:37:35,000 --> 01:37:37,000
就是一级缓存这么一个概念

2858
01:37:37,000 --> 01:37:39,000
一级缓存在现代意义上

2859
01:37:39,000 --> 01:37:41,000
我们是有一个比相对好的度量的

2860
01:37:41,000 --> 01:37:43,000
就是大概是 0.5

2861
01:37:44,000 --> 01:37:44,000
nano second

2862
01:37:44,000 --> 01:37:45,000
对

2863
01:37:45,000 --> 01:37:46,000
nano second

2864
01:37:46,000 --> 01:37:48,000
一纳秒是

2865
01:37:48,000 --> 01:37:48,000
对

2866
01:37:48,000 --> 01:37:49,000
多少

2867
01:37:50,000 --> 01:37:51,000
10 的

2868
01:37:51,000 --> 01:37:54,000
就一秒等于 10 的 9 次方个纳秒

2869
01:37:55,000 --> 01:37:56,000
然后你访问一个

2870
01:37:56,000 --> 01:37:59,000
一级缓存的话是半个纳秒的时间

2871
01:37:59,000 --> 01:38:00,000
对

2872
01:38:00,000 --> 01:38:00,000
嗯

2873
01:38:01,000 --> 01:38:02,000
然后

2874
01:38:02,000 --> 01:38:03,000
但如果有一级缓存

2875
01:38:03,000 --> 01:38:04,000
那么自然而然也会有

2876
01:38:04,000 --> 01:38:06,000
所谓的二级缓存

2877
01:38:06,000 --> 01:38:07,000
二级缓存

2878
01:38:07,000 --> 01:38:11,000
在现代 CPU 上通常也是在

2879
01:38:11,000 --> 01:38:13,000
这个 CPU 芯片上的

2880
01:38:13,000 --> 01:38:15,000
但只是离那个

2881
01:38:15,000 --> 01:38:17,000
所谓的积算的内部

2882
01:38:17,000 --> 01:38:19,000
那个元气件的距离要远一点

2883
01:38:20,000 --> 01:38:22,000
然后它的容量也会稍微大一点

2884
01:38:22,000 --> 01:38:24,000
一级缓存通常也就是

2885
01:38:24,000 --> 01:38:24,000
一两

2886
01:38:25,000 --> 01:38:26,000
多少 k

2887
01:38:26,000 --> 01:38:28,000
32 k 64 k 的

2888
01:38:28,000 --> 01:38:28,000
若干 k

2889
01:38:28,000 --> 01:38:29,000
对

2890
01:38:29,000 --> 01:38:30,000
然后 L 2 要大

2891
01:38:30,000 --> 01:38:33,000
有时候大一点点

2892
01:38:33,000 --> 01:38:34,000
而且 L 2

2893
01:38:34,000 --> 01:38:38,000
L 2 缓存的大小往往确定了 CPU 的售价

2894
01:38:39,000 --> 01:38:40,000
其实 L 1 也是

2895
01:38:40,000 --> 01:38:42,000
L 1 就越大的 L 1

2896
01:38:42,000 --> 01:38:43,000
的价格一般越贵

2897
01:38:43,000 --> 01:38:45,000
这个是肯定是相关的

2898
01:38:45,000 --> 01:38:45,000
因为确实

2899
01:38:46,000 --> 01:38:48,000
做那个的成本很高

2900
01:38:49,000 --> 01:38:52,000
但是 LA 的话也通常也是 KB 级别

2901
01:38:53,000 --> 01:38:54,000
有时候大一点的服务器的处理器

2902
01:38:54,000 --> 01:38:56,000
回到一两兆

2903
01:38:56,000 --> 01:38:57,000
应该是没有问题的

2904
01:38:57,000 --> 01:38:59,000
就每个 Core 的 L 2 都缓存

2905
01:39:01,000 --> 01:39:04,000
但是它的读取的时间就会要

2906
01:39:04,000 --> 01:39:05,000
高一个数量级的

2907
01:39:05,000 --> 01:39:07,000
然后比如说它会在可能几个

2908
01:39:07,000 --> 01:39:07,000
纳秒的左右

2909
01:39:07,000 --> 01:39:09,000
比如说这里我们有一个数据

2910
01:39:09,000 --> 01:39:09,000
是给的

2911
01:39:09,000 --> 01:39:10,000
这里是给的

2912
01:39:10,000 --> 01:39:11,000
是 7 个

2913
01:39:11,000 --> 01:39:12,000
这个文档

2914
01:39:12,000 --> 01:39:14,000
这个文档我们会放在

2915
01:39:14,000 --> 01:39:16,000
那个 notes 里面

2916
01:39:16,000 --> 01:39:17,000
这个文档也非常重要

2917
01:39:17,000 --> 01:39:19,000
如果你是一个程序员的话

2918
01:39:19,000 --> 01:39:20,000
这个文档的名称叫做

2919
01:39:20,000 --> 01:39:23,000
Latency numbers and program should know

2920
01:39:23,000 --> 01:39:24,000
你是这个 program

2921
01:39:24,000 --> 01:39:26,000
所以你 should know

2922
01:39:27,000 --> 01:39:30,000
就 L 2 的读取时间大概就是几个纳秒左右

2923
01:39:30,000 --> 01:39:32,000
当然还有一些处理器

2924
01:39:32,000 --> 01:39:34,000
会有像什么所谓三级缓存

2925
01:39:35,000 --> 01:39:36,000
没有见过四级缓存的东西

2926
01:39:36,000 --> 01:39:37,000
好像没有

2927
01:39:37,000 --> 01:39:39,000
四级缓存就到内存了

2928
01:39:39,000 --> 01:39:42,000
对四级缓存本应该就已经是

2929
01:39:42,000 --> 01:39:43,000
很难说

2930
01:39:43,000 --> 01:39:44,000
应该可能也有

2931
01:39:44,000 --> 01:39:47,000
我没有见过实用的系统上有四级缓存

2932
01:39:48,000 --> 01:39:51,000
CPU 一般最多也就是三级缓存

2933
01:39:51,000 --> 01:39:54,000
这个东西一般是会和 CPU 做在一起的

2934
01:39:54,000 --> 01:39:56,000
但是等你

2935
01:39:56,000 --> 01:39:57,000
还不太一样

2936
01:39:57,000 --> 01:39:59,000
三级缓存有很多是在主板上面的

2937
01:40:00,000 --> 01:40:01,000
What

2938
01:40:01,000 --> 01:40:02,000
你还记得吗

2939
01:40:02,000 --> 01:40:04,000
这个早年就是 90 年代末的时候

2940
01:40:04,000 --> 01:40:06,000
有 L 1 L 2 是在板上的

2941
01:40:06,000 --> 01:40:07,000
这是在芯片上面

2942
01:40:07,000 --> 01:40:10,000
但是三级缓存有很多这种廉价的

2943
01:40:10,000 --> 01:40:11,000
那不叫廉价的主板

2944
01:40:11,000 --> 01:40:14,000
算吧就是那种平民向的主板

2945
01:40:15,000 --> 01:40:17,000
会把它做在主板上

2946
01:40:17,000 --> 01:40:17,000
对这样的话

2947
01:40:17,000 --> 01:40:20,000
他就可以买一个比较便宜的 CPU

2948
01:40:20,000 --> 01:40:22,000
不带三级缓存

2949
01:40:22,000 --> 01:40:23,000
对 anyway

2950
01:40:23,000 --> 01:40:26,000
就是这是一个工业上的区别

2951
01:40:26,000 --> 01:40:27,000
对这逻辑上是没有任何区别

2952
01:40:27,000 --> 01:40:28,000
就是

2953
01:40:29,000 --> 01:40:30,000
就总体来说

2954
01:40:30,000 --> 01:40:32,000
缓存越快

2955
01:40:32,000 --> 01:40:33,000
就是存储区越快

2956
01:40:33,000 --> 01:40:34,000
它的容量越小

2957
01:40:34,000 --> 01:40:35,000
比如说计存器就只有几个 Word

2958
01:40:35,000 --> 01:40:36,000
对吧

2959
01:40:36,000 --> 01:40:38,000
在一个现在的 CPU 里面

2960
01:40:38,000 --> 01:40:41,000
就 100 多个计存器了

2961
01:40:41,000 --> 01:40:42,000
不得了了

2962
01:40:43,000 --> 01:40:45,000
然后就是但是速度非常快

2963
01:40:45,000 --> 01:40:47,000
但是就这个价格最贵

2964
01:40:47,000 --> 01:40:50,000
然后一级缓存就几十 K

2965
01:40:50,000 --> 01:40:52,000
价格次值速度也次值

2966
01:40:52,000 --> 01:40:54,000
然后以此类推

2967
01:40:54,000 --> 01:40:55,000
差不多都是

2968
01:40:57,000 --> 01:41:00,000
每跨越一个缓存的级别

2969
01:41:00,000 --> 01:41:02,000
它就至少是有一个数量级的

2970
01:41:03,000 --> 01:41:06,000
容量和访问速度的变化

2971
01:41:06,000 --> 01:41:07,000
就是

2972
01:41:08,000 --> 01:41:09,000
大概是这个意思

2973
01:41:09,000 --> 01:41:11,000
但现在就一般来说

2974
01:41:12,000 --> 01:41:12,000
编程的话

2975
01:41:12,000 --> 01:41:14,000
我们是看不到说

2976
01:41:14,000 --> 01:41:17,000
一级缓存和二级缓存的实体的

2977
01:41:17,000 --> 01:41:18,000
这个是编辑

2978
01:41:18,000 --> 01:41:19,000
你也没有办法去具体的

2979
01:41:19,000 --> 01:41:20,000
写一个程序说

2980
01:41:20,000 --> 01:41:22,000
这个程序只用到一级缓存

2981
01:41:22,000 --> 01:41:22,000
对

2982
01:41:22,000 --> 01:41:23,000
这是不可能的

2983
01:41:23,000 --> 01:41:25,000
因为这个是在叫什么

2984
01:41:25,000 --> 01:41:26,000
这个是

2985
01:41:26,000 --> 01:41:27,000
超新种硬件

2986
01:41:27,000 --> 01:41:28,000
不这个是计算机硬件

2987
01:41:28,000 --> 01:41:30,000
帮你去调度解决的问题

2988
01:41:30,000 --> 01:41:32,000
当然你还会编可以做到

2989
01:41:32,000 --> 01:41:34,000
去选择新的使用

2990
01:41:35,000 --> 01:41:36,000
就什么

2991
01:41:36,000 --> 01:41:36,000
计存器那些东西

2992
01:41:36,000 --> 01:41:37,000
那个是另外一说

2993
01:41:38,000 --> 01:41:38,000
对

2994
01:41:40,000 --> 01:41:41,000
但是其实就是说

2995
01:41:41,000 --> 01:41:42,000
对一个普通程序来讲

2996
01:41:42,000 --> 01:41:43,000
暴露给你的

2997
01:41:43,000 --> 01:41:44,000
始终就只是一个

2998
01:41:44,000 --> 01:41:45,000
内存地址这么一个概念

2999
01:41:46,000 --> 01:41:47,000
然后当然我们说内存

3000
01:41:47,000 --> 01:41:49,000
它是一关机就没了

3001
01:41:49,000 --> 01:41:51,000
所以你还是要把东西放在一个

3002
01:41:51,000 --> 01:41:52,000
可以持久化的存储

3003
01:41:52,000 --> 01:41:53,000
比如说磁盘

3004
01:41:53,000 --> 01:41:55,000
或者现在是 SSD 上面去

3005
01:41:55,000 --> 01:41:56,000
但是刚才吴涛也讲

3006
01:41:56,000 --> 01:41:58,000
你要把这些东西 load 进内存里面

3007
01:41:58,000 --> 01:41:59,000
才可以用

3008
01:41:59,000 --> 01:42:00,000
才有一个地址可以执行

3009
01:42:00,000 --> 01:42:01,000
对

3010
01:42:01,000 --> 01:42:03,000
在这个页面上很方便的

3011
01:42:03,000 --> 01:42:05,000
他把这个

3012
01:42:05,000 --> 01:42:06,000
他在下面有一个

3013
01:42:06,000 --> 01:42:08,000
非常形象的类比

3014
01:42:08,000 --> 01:42:08,000
对

3015
01:42:08,000 --> 01:42:10,000
他把所有的

3016
01:42:10,000 --> 01:42:13,000
时间都成了

3017
01:42:14,000 --> 01:42:15,000
一个 billion

3018
01:42:15,000 --> 01:42:16,000
10 亿倍

3019
01:42:16,000 --> 01:42:16,000
对

3020
01:42:16,000 --> 01:42:17,000
10 亿倍

3021
01:42:17,000 --> 01:42:17,000
对

3022
01:42:17,000 --> 01:42:18,000
那么

3023
01:42:19,000 --> 01:42:20,000
以 nano second 乘上 10 亿

3024
01:42:20,000 --> 01:42:21,000
就变成了

3025
01:42:22,000 --> 01:42:23,000
1 秒

3026
01:42:23,000 --> 01:42:23,000
对

3027
01:42:23,000 --> 01:42:23,000
对

3028
01:42:24,000 --> 01:42:24,000
那么

3029
01:42:25,000 --> 01:42:28,000
L 1 换存的存储时间

3030
01:42:28,000 --> 01:42:29,000
大概是半秒钟

3031
01:42:30,000 --> 01:42:31,000
心跳一下

3032
01:42:31,000 --> 01:42:34,000
然后 2 G 换存的存储时间

3033
01:42:34,000 --> 01:42:35,000
大概是 7 秒钟

3034
01:42:35,000 --> 01:42:37,000
就是你打一个长生的哈切

3035
01:42:37,000 --> 01:42:37,000
大概

3036
01:42:38,000 --> 01:42:39,000
2 G 换存就到了

3037
01:42:39,000 --> 01:42:41,000
如果你生活在其他世界里的话

3038
01:42:41,000 --> 01:42:42,000
可以

3039
01:42:42,000 --> 01:42:42,000
对

3040
01:42:44,000 --> 01:42:45,000
访问内存的时间

3041
01:42:45,000 --> 01:42:45,000
其实

3042
01:42:46,000 --> 01:42:48,000
我们都常常觉得内存访问挺快了

3043
01:42:48,000 --> 01:42:49,000
因为比磁盘快多少

3044
01:42:49,000 --> 01:42:50,000
但其实你跟

3045
01:42:50,000 --> 01:42:51,000
像计算器

3046
01:42:51,000 --> 01:42:52,000
1 G 换存

3047
01:42:52,000 --> 01:42:53,000
2 G 换存比起来

3048
01:42:53,000 --> 01:42:56,000
还是非常慢的一个东西

3049
01:42:56,000 --> 01:42:56,000
这里就

3050
01:42:56,000 --> 01:42:57,000
就刚才那个比方

3051
01:42:58,000 --> 01:42:59,000
这里访问内存的话

3052
01:42:59,000 --> 01:43:01,000
大概在现在的计算机上

3053
01:43:01,000 --> 01:43:02,000
大概是 100 秒的时候

3054
01:43:02,000 --> 01:43:04,000
就是如果它都乘上 10 亿的话

3055
01:43:04,000 --> 01:43:06,000
100 秒就是一两分钟左右

3056
01:43:06,000 --> 01:43:06,000
对

3057
01:43:07,000 --> 01:43:10,000
这段时间已经够你刷牙了

3058
01:43:10,000 --> 01:43:10,000
对

3059
01:43:12,000 --> 01:43:13,000
这个类比还挺有意思的

3060
01:43:13,000 --> 01:43:14,000
大家可以去看一下

3061
01:43:14,000 --> 01:43:14,000
如果

3062
01:43:14,000 --> 01:43:15,000
还有包括像

3063
01:43:15,000 --> 01:43:18,000
你发一个数据包会怎么样

3064
01:43:19,000 --> 01:43:20,000
他是这里给了一个例子

3065
01:43:20,000 --> 01:43:22,000
是从加州发一个数据包到

3066
01:43:22,000 --> 01:43:24,000
荷兰再返回来

3067
01:43:24,000 --> 01:43:25,000
就是一个 Round trip

3068
01:43:25,000 --> 01:43:27,000
大概就是 5 年的时间

3069
01:43:29,000 --> 01:43:29,000
不可想象

3070
01:43:29,000 --> 01:43:30,000
网络是很慢的

3071
01:43:31,000 --> 01:43:32,000
没错

3072
01:43:32,000 --> 01:43:32,000
对

3073
01:43:32,000 --> 01:43:36,000
所以在很多时候里面

3074
01:43:36,000 --> 01:43:37,000
很多场景里面

3075
01:43:37,000 --> 01:43:39,000
就是一个程序

3076
01:43:39,000 --> 01:43:40,000
百无聊赖的在那边死等

3077
01:43:40,000 --> 01:43:41,000
等

3078
01:43:41,000 --> 01:43:42,000
等 Io 吗

3079
01:43:42,000 --> 01:43:43,000
对

3080
01:43:43,000 --> 01:43:46,000
等对方发送一个数据包回来

3081
01:43:46,000 --> 01:43:47,000
对

3082
01:43:47,000 --> 01:43:48,000
就这里其实我们也可以看到了

3083
01:43:48,000 --> 01:43:50,000
刚才那个是说等网络是很慢的

3084
01:43:50,000 --> 01:43:52,000
但我们看一下等的一个磁盘

3085
01:43:53,000 --> 01:43:54,000
访问一个

3086
01:43:56,000 --> 01:43:56,000
磁盘上的文件

3087
01:43:56,000 --> 01:43:57,000
就是读一个文件

3088
01:43:57,000 --> 01:43:59,000
如果它还没有在内存里面的话

3089
01:43:59,000 --> 01:44:00,000
大概是

3090
01:44:00,000 --> 01:44:02,000
16 周左右

3091
01:44:02,000 --> 01:44:04,000
16 周就是 4 个月差不多

3092
01:44:05,000 --> 01:44:05,000
对

3093
01:44:05,000 --> 01:44:06,000
足够你学完也蛮磕了

3094
01:44:07,000 --> 01:44:08,000
对

3095
01:44:08,000 --> 01:44:10,000
所以你看我们现在做很多

3096
01:44:10,000 --> 01:44:11,000
做什么异步的

3097
01:44:11,000 --> 01:44:12,000
就是现在编程很多

3098
01:44:12,000 --> 01:44:13,000
你要做一些

3099
01:44:14,000 --> 01:44:16,000
所谓 Io Heavy 的一些应用

3100
01:44:16,000 --> 01:44:17,000
像 Node 这种东西

3101
01:44:17,000 --> 01:44:19,000
你都要走异步的方法

3102
01:44:20,000 --> 01:44:21,000
因为你可以看到

3103
01:44:21,000 --> 01:44:24,000
如果你每次 Io 都要等同步的话

3104
01:44:24,000 --> 01:44:26,000
你这个程序就没法玩了

3105
01:44:26,000 --> 01:44:26,000
对

3106
01:44:26,000 --> 01:44:30,000
你无心之中浪费了非常多宝贵的 CPU

3107
01:44:30,000 --> 01:44:32,000
大部分时间都是在闲置的

3108
01:44:35,000 --> 01:44:39,000
所以有 Memory 内存的层级

3109
01:44:39,000 --> 01:44:40,000
就是要

3110
01:44:40,000 --> 01:44:42,000
如果我们直接把这么多层级

3111
01:44:42,000 --> 01:44:43,000
暴露给开发者的话

3112
01:44:43,000 --> 01:44:46,000
那显然软件工程就不用玩了

3113
01:44:46,000 --> 01:44:48,000
天天在那里 debug 内存

3114
01:44:48,000 --> 01:44:50,000
那个内存的问题都已经够你

3115
01:44:50,000 --> 01:44:52,000
玩上一阵子了

3116
01:44:52,000 --> 01:44:54,000
所以我们把这东西通过

3117
01:44:54,000 --> 01:44:55,000
像一些

3118
01:44:55,000 --> 01:44:57,000
首先比如说硬件上层面上

3119
01:44:57,000 --> 01:45:00,000
直接隐藏掉一级二级缓存

3120
01:45:00,000 --> 01:45:03,000
然后通过虚拟内存感染

3121
01:45:03,000 --> 01:45:06,000
隐藏掉磁盘和内存之间的区别

3122
01:45:06,000 --> 01:45:09,000
这样的话可以把编程模型大幅度简化

3123
01:45:09,000 --> 01:45:11,000
让我们这种平庸之辈

3124
01:45:11,000 --> 01:45:13,000
也能够开开心心的写上程序

3125
01:45:16,000 --> 01:45:18,000
或者应该反过来说

3126
01:45:18,000 --> 01:45:20,000
就应该是这种进化智慧存在

3127
01:45:20,000 --> 01:45:23,000
是因为试图让平庸之辈写出来的程序

3128
01:45:23,000 --> 01:45:27,000
也可以比较体面的跑在脑上

3129
01:45:27,000 --> 01:45:28,000
否则真的是慢得不得了

3130
01:45:29,000 --> 01:45:31,000
或者说是直接就 crash 掉

3131
01:45:31,000 --> 01:45:31,000
对

3132
01:45:33,000 --> 01:45:35,000
不过这里其实还是牵涉到有一个概念

3133
01:45:35,000 --> 01:45:41,000
就是为什么我们要分这么多内存的层级

3134
01:45:41,000 --> 01:45:42,000
其实也就是因为穷

3135
01:45:43,000 --> 01:45:43,000
对

3136
01:45:43,000 --> 01:45:46,000
因为内存的造价实在是太高了

3137
01:45:46,000 --> 01:45:48,000
就是你如果大家都做成

3138
01:45:48,000 --> 01:45:49,000
首先物理上做不到

3139
01:45:49,000 --> 01:45:51,000
因为你要做成寄存器的话

3140
01:45:51,000 --> 01:45:53,000
你得所有东西都在芯片里面

3141
01:45:53,000 --> 01:45:53,000
对吧

3142
01:45:53,000 --> 01:45:56,000
但是得靠近计算元器件

3143
01:45:56,000 --> 01:45:58,000
但是物理空间是有限的

3144
01:45:58,000 --> 01:45:59,000
也不可能做到

3145
01:45:59,000 --> 01:46:00,000
第二个就是说

3146
01:46:00,000 --> 01:46:01,000
如果能做到

3147
01:46:01,000 --> 01:46:02,000
比如说

3148
01:46:02,000 --> 01:46:05,000
我们都用把一级缓存做成 500 招

3149
01:46:05,000 --> 01:46:07,000
二级缓存做成一个鸡

3150
01:46:08,000 --> 01:46:09,000
也可以

3151
01:46:09,000 --> 01:46:12,000
但是这个成本就不是天文数字了

3152
01:46:12,000 --> 01:46:13,000
不可以想象

3153
01:46:13,000 --> 01:46:14,000
可能

3154
01:46:15,000 --> 01:46:16,000
比尔盖茨也只能买两台而已

3155
01:46:18,000 --> 01:46:19,000
买了半台都不错了

3156
01:46:21,000 --> 01:46:21,000
但是

3157
01:46:22,000 --> 01:46:24,000
就说内存层级搞这么复杂

3158
01:46:24,000 --> 01:46:27,000
也是为了像现实的一个妥协

3159
01:46:27,000 --> 01:46:30,000
就是在我们怎么把这个东西做尽量便宜

3160
01:46:30,000 --> 01:46:32,000
那么越卖东西越便宜对吧

3161
01:46:33,000 --> 01:46:35,000
所以那就慢一点了

3162
01:46:35,000 --> 01:46:36,000
那就要通过这种

3163
01:46:37,000 --> 01:46:39,000
分层级的方式来隐藏掉

3164
01:46:39,000 --> 01:46:42,000
我们实际上用一个很便宜很慢的一个设备

3165
01:46:42,000 --> 01:46:42,000
对

3166
01:46:42,000 --> 01:46:45,000
然后把剩余的好钢都花钱

3167
01:46:45,000 --> 01:46:46,000
用在刀上

3168
01:46:46,000 --> 01:46:47,000
不刀尖上

3169
01:46:47,000 --> 01:46:50,000
其实我刚才想了一下

3170
01:46:51,000 --> 01:46:52,000
假设一个晶圆

3171
01:46:52,000 --> 01:46:54,000
一个圆形的晶圆

3172
01:46:54,000 --> 01:46:57,000
完全用来做缓存

3173
01:46:58,000 --> 01:46:59,000
大概要多少钱

3174
01:47:00,000 --> 01:47:01,000
一个晶圆片吗

3175
01:47:02,000 --> 01:47:02,000
对

3176
01:47:02,000 --> 01:47:04,000
就整个一大片晶圆

3177
01:47:05,000 --> 01:47:07,000
做成一个缓存

3178
01:47:08,000 --> 01:47:10,000
然后像太阳能板那样装在什么地方

3179
01:47:10,000 --> 01:47:11,000
然后把它

3180
01:47:11,000 --> 01:47:14,000
把它插在 CPU 什么地方

3181
01:47:15,000 --> 01:47:16,000
这个我还不太

3182
01:47:16,000 --> 01:47:18,000
首先有个物理的限制

3183
01:47:18,000 --> 01:47:21,000
你访问它的速度是很定的

3184
01:47:21,000 --> 01:47:22,000
你就打发

3185
01:47:22,000 --> 01:47:23,000
你变大了之后

3186
01:47:23,000 --> 01:47:27,000
你访问边缘上的那部分必然是要等的

3187
01:47:27,000 --> 01:47:29,000
那就把它做成立体的吧

3188
01:47:29,000 --> 01:47:31,000
我小时候有这种愚蠢的想法

3189
01:47:32,000 --> 01:47:33,000
没错

3190
01:47:33,000 --> 01:47:34,000
这是一个很好的想法

3191
01:47:34,000 --> 01:47:34,000
三维不限

3192
01:47:34,000 --> 01:47:35,000
对

3193
01:47:35,000 --> 01:47:37,000
三维不限也是一个很常用的思路

3194
01:47:37,000 --> 01:47:37,000
但是问题就是说

3195
01:47:37,000 --> 01:47:38,000
这个始终是一个

3196
01:47:38,000 --> 01:47:40,000
你就无非是从二维变成了三维

3197
01:47:40,000 --> 01:47:43,000
你的总的空间始终还是有限

3198
01:47:43,000 --> 01:47:44,000
就不可能无限制的

3199
01:47:45,000 --> 01:47:47,000
不管是从物理现实的角度考虑

3200
01:47:47,000 --> 01:47:49,000
还是从一个经济的角度考虑

3201
01:47:49,000 --> 01:47:53,000
都一定是存在这么一个不同等级的存储

3202
01:47:53,000 --> 01:47:55,000
访问时间和容量的限制

3203
01:47:56,000 --> 01:47:59,000
除非你可以在非常微小的尺度上

3204
01:47:59,000 --> 01:48:00,000
开一大堆 portal

3205
01:48:00,000 --> 01:48:03,000
然后可以开高位空间

3206
01:48:04,000 --> 01:48:06,000
这就彻底解决了访问速度的问题

3207
01:48:08,000 --> 01:48:09,000
作弊了

3208
01:48:09,000 --> 01:48:12,000
回到我们正常的现实世界

3209
01:48:12,000 --> 01:48:12,000
对

3210
01:48:12,000 --> 01:48:15,000
但有一个挺麻烦的问题

3211
01:48:15,000 --> 01:48:17,000
就是说内存

3212
01:48:17,000 --> 01:48:18,000
我们现在用的主要的内存

3213
01:48:18,000 --> 01:48:21,000
它是一个叫做意识性的内存

3214
01:48:21,000 --> 01:48:23,000
叫做 valuTile 的内存

3215
01:48:23,000 --> 01:48:23,000
什么意思呢

3216
01:48:24,000 --> 01:48:26,000
valuTile 这个词本意是挥发吧

3217
01:48:26,000 --> 01:48:27,000
我记得

3218
01:48:27,000 --> 01:48:27,000
对

3219
01:48:27,000 --> 01:48:28,000
就是挥发的意思

3220
01:48:28,000 --> 01:48:30,000
挥化肥会挥发

3221
01:48:31,000 --> 01:48:32,000
内存会挥发

3222
01:48:33,000 --> 01:48:34,000
就是这个意思

3223
01:48:34,000 --> 01:48:34,000
对

3224
01:48:34,000 --> 01:48:36,000
所谓意识性就是说

3225
01:48:36,000 --> 01:48:38,000
你一旦断电之后

3226
01:48:38,000 --> 01:48:39,000
内存里面存的东西

3227
01:48:39,000 --> 01:48:40,000
Berr 就没有了

3228
01:48:40,000 --> 01:48:42,000
当然也没有 Berr 这么快

3229
01:48:42,000 --> 01:48:43,000
因为我记得

3230
01:48:43,000 --> 01:48:45,000
还是有个残留的

3231
01:48:45,000 --> 01:48:45,000
对

3232
01:48:45,000 --> 01:48:48,000
2010 年左右有一群

3233
01:48:49,000 --> 01:48:51,000
有一个安全实验室的人

3234
01:48:51,000 --> 01:48:53,000
展示了一个电脑关机之后

3235
01:48:53,000 --> 01:48:55,000
立刻用液氮去

3236
01:48:55,000 --> 01:48:56,000
冷冻它

3237
01:48:56,000 --> 01:48:57,000
应该没有液氮吧

3238
01:48:57,000 --> 01:48:58,000
应该没有液氮

3239
01:48:58,000 --> 01:48:59,000
是用液氮

3240
01:48:59,000 --> 01:48:59,000
用液氮

3241
01:48:59,000 --> 01:49:00,000
是液氮吗

3242
01:49:00,000 --> 01:49:00,000
嗯

3243
01:49:00,000 --> 01:49:01,000
就是立刻把它冷冻住

3244
01:49:01,000 --> 01:49:05,000
然后去直接搜内存里面的数据

3245
01:49:05,000 --> 01:49:07,000
然后还能读出来些许的

3246
01:49:07,000 --> 01:49:08,000
对

3247
01:49:08,000 --> 01:49:11,000
它可不可以把这个什么电子的状态

3248
01:49:11,000 --> 01:49:14,000
在低温状态下能够维持一段时间吗

3249
01:49:14,000 --> 01:49:15,000
对

3250
01:49:15,000 --> 01:49:16,000
就像这些

3251
01:49:16,000 --> 01:49:19,000
然后回忆我们刚才讲的 Latency

3252
01:49:20,000 --> 01:49:22,000
这些所有的数据都在冬眠

3253
01:49:22,000 --> 01:49:24,000
冬眠了十几年

3254
01:49:24,000 --> 01:49:25,000
然后被

3255
01:49:25,000 --> 01:49:26,000
都出来了

3256
01:49:26,000 --> 01:49:26,000
被拉出来了

3257
01:49:26,000 --> 01:49:27,000
对

3258
01:49:28,000 --> 01:49:29,000
但是

3259
01:49:30,000 --> 01:49:32,000
我们日常就除开刚才武陶讲的那种

3260
01:49:32,000 --> 01:49:33,000
极端变态的场景之外

3261
01:49:33,000 --> 01:49:34,000
但是正常情况下

3262
01:49:34,000 --> 01:49:35,000
你断电之后

3263
01:49:35,000 --> 01:49:37,000
内存中的数据就已经没有了

3264
01:49:37,000 --> 01:49:39,000
就清零了

3265
01:49:39,000 --> 01:49:40,000
然后你在通电的时候里面

3266
01:49:41,000 --> 01:49:41,000
它这些什么

3267
01:49:41,000 --> 01:49:42,000
不记得了

3268
01:49:43,000 --> 01:49:45,000
这个很明显就是一个问题

3269
01:49:45,000 --> 01:49:47,000
比如说你电脑关机之后

3270
01:49:47,000 --> 01:49:48,000
什么资料都没有了

3271
01:49:48,000 --> 01:49:49,000
那你搞什么白搞了

3272
01:49:50,000 --> 01:49:50,000
对

3273
01:49:51,000 --> 01:49:52,000
这也就是我们为什么会

3274
01:49:52,000 --> 01:49:53,000
会需要软盘

3275
01:49:53,000 --> 01:49:56,000
或者说需要外置磁盘这种东西

3276
01:49:56,000 --> 01:49:57,000
对就是硬盘

3277
01:49:57,000 --> 01:49:58,000
之前的软盘也好

3278
01:49:58,000 --> 01:49:59,000
它都是一个所谓的

3279
01:49:59,000 --> 01:50:00,000
non-volatile 的

3280
01:50:01,000 --> 01:50:01,000
存储界

3281
01:50:01,000 --> 01:50:03,000
就是非意识性的存储

3282
01:50:04,000 --> 01:50:05,000
断电之后还在

3283
01:50:06,000 --> 01:50:06,000
对

3284
01:50:07,000 --> 01:50:11,000
但其实这两个中间是有一定的障碍的

3285
01:50:11,000 --> 01:50:12,000
刚才我讲的

3286
01:50:12,000 --> 01:50:13,000
因为计算机

3287
01:50:13,000 --> 01:50:14,000
就起码操作系统

3288
01:50:14,000 --> 01:50:16,000
并不能直接执行硬盘上面的东西

3289
01:50:16,000 --> 01:50:17,000
它得先读到内存里面去

3290
01:50:18,000 --> 01:50:19,000
所以每次都会有这么一个

3291
01:50:19,000 --> 01:50:20,000
很变态的这么一个

3292
01:50:21,000 --> 01:50:22,000
读取

3293
01:50:22,000 --> 01:50:23,000
然后写内存

3294
01:50:23,000 --> 01:50:24,000
然后的一个过程

3295
01:50:25,000 --> 01:50:27,000
然后作为一个软件的开发者来讲

3296
01:50:27,000 --> 01:50:29,000
你也要做一些很奇怪的事情

3297
01:50:29,000 --> 01:50:29,000
比如说

3298
01:50:30,000 --> 01:50:32,000
我们做这个

3299
01:50:32,000 --> 01:50:34,000
所谓有一个序列化解序列化的东西

3300
01:50:34,000 --> 01:50:36,000
就是你把一个数据文件

3301
01:50:37,000 --> 01:50:39,000
读到内存中

3302
01:50:39,000 --> 01:50:40,000
然后你要保存的时候

3303
01:50:40,000 --> 01:50:40,000
你还得想办法

3304
01:50:40,000 --> 01:50:42,000
把它写回磁盘

3305
01:50:42,000 --> 01:50:43,000
然后写回磁盘的中间

3306
01:50:43,000 --> 01:50:46,000
你会想怎么把内存中的一个结构

3307
01:50:47,000 --> 01:50:48,000
变成磁盘上面的一个

3308
01:50:49,000 --> 01:50:51,000
一组二进制的流

3309
01:50:51,000 --> 01:50:51,000
对吧

3310
01:50:52,000 --> 01:50:52,000
对

3311
01:50:53,000 --> 01:50:54,000
不一定是二进制的

3312
01:50:56,000 --> 01:50:58,000
最后会变成一种

3313
01:51:00,000 --> 01:51:01,000
核心要点是说

3314
01:51:02,000 --> 01:51:03,000
数据结构在内存中

3315
01:51:03,000 --> 01:51:06,000
是存在一定形态的一个方式

3316
01:51:06,000 --> 01:51:06,000
和结构组织

3317
01:51:06,000 --> 01:51:08,000
通过指针的方式

3318
01:51:08,000 --> 01:51:08,000
对

3319
01:51:08,000 --> 01:51:10,000
你不是想办法把这个结构

3320
01:51:10,000 --> 01:51:12,000
转化为某种

3321
01:51:12,000 --> 01:51:13,000
可以复原的

3322
01:51:13,000 --> 01:51:14,000
对

3323
01:51:15,000 --> 01:51:16,000
一个字节串

3324
01:51:16,000 --> 01:51:18,000
或者是二进制的串

3325
01:51:19,000 --> 01:51:19,000
对

3326
01:51:19,000 --> 01:51:21,000
所以有这么一个序列化解序列化的过程

3327
01:51:21,000 --> 01:51:25,000
其实这一点是挺折腾的

3328
01:51:25,000 --> 01:51:26,000
就是为什么

3329
01:51:26,000 --> 01:51:27,000
假设你想想

3330
01:51:27,000 --> 01:51:30,000
如果我们把内存做成一个

3331
01:51:30,000 --> 01:51:32,000
叫做非意识的

3332
01:51:32,000 --> 01:51:33,000
就是内存关机之后

3333
01:51:33,000 --> 01:51:34,000
它在开

3334
01:51:34,000 --> 01:51:35,000
就断电之后

3335
01:51:35,000 --> 01:51:37,000
在通电还能记住之前内容

3336
01:51:37,000 --> 01:51:37,000
你想象一下

3337
01:51:37,000 --> 01:51:39,000
我们日常使用的计算机

3338
01:51:39,000 --> 01:51:40,000
就是一个很爽的状态

3339
01:51:40,000 --> 01:51:41,000
开机不用等

3340
01:51:41,000 --> 01:51:42,000
你想不用的时候

3341
01:51:42,000 --> 01:51:44,000
按掉拔掉电源线

3342
01:51:44,000 --> 01:51:45,000
就是你不用关机

3343
01:51:45,000 --> 01:51:46,000
把电池拔掉都没问题

3344
01:51:47,000 --> 01:51:47,000
然后你

3345
01:51:47,000 --> 01:51:48,000
插电之后

3346
01:51:48,000 --> 01:51:50,000
又回到那个画面了

3347
01:51:50,000 --> 01:51:50,000
一模一样

3348
01:51:52,000 --> 01:51:53,000
我有一个问题

3349
01:51:53,000 --> 01:51:55,000
就是比如说 MP 3 不放弃

3350
01:51:55,000 --> 01:51:55,000
或者是

3351
01:51:57,000 --> 01:51:59,000
就比如说单片机

3352
01:51:59,000 --> 01:52:02,000
有些单片机使用的存储器

3353
01:52:02,000 --> 01:52:04,000
的确是非

3354
01:52:04,000 --> 01:52:05,000
non volatile

3355
01:52:06,000 --> 01:52:06,000
对

3356
01:52:06,000 --> 01:52:07,000
有这种

3357
01:52:07,000 --> 01:52:08,000
有很

3358
01:52:08,000 --> 01:52:09,000
这叫什么

3359
01:52:10,000 --> 01:52:11,000
比较小的情况下

3360
01:52:11,000 --> 01:52:13,000
它会有这种应用

3361
01:52:13,000 --> 01:52:14,000
它能够关掉

3362
01:52:14,000 --> 01:52:15,000
然后重启之后

3363
01:52:15,000 --> 01:52:16,000
它还在那个状态

3364
01:52:16,000 --> 01:52:16,000
对

3365
01:52:16,000 --> 01:52:18,000
所以这种机器

3366
01:52:18,000 --> 01:52:20,000
实际上是没有

3367
01:52:21,000 --> 01:52:22,000
这个问题存在

3368
01:52:22,000 --> 01:52:24,000
就是它无所谓

3369
01:52:24,000 --> 01:52:24,000
什么东西

3370
01:52:24,000 --> 01:52:26,000
它完全不会区分

3371
01:52:26,000 --> 01:52:29,000
什么是一个程序在运行的状态

3372
01:52:29,000 --> 01:52:31,000
以及什么是一个程序被

3373
01:52:31,000 --> 01:52:33,000
被折叠起来的

3374
01:52:33,000 --> 01:52:34,000
对

3375
01:52:34,000 --> 01:52:34,000
被折叠起来

3376
01:52:34,000 --> 01:52:36,000
被存储起来的状态

3377
01:52:36,000 --> 01:52:36,000
对

3378
01:52:36,000 --> 01:52:38,000
就是如果它是用这种

3379
01:52:38,000 --> 01:52:39,000
非意识性的内存的话

3380
01:52:39,000 --> 01:52:41,000
它就是真的可以做到这一点

3381
01:52:41,000 --> 01:52:42,000
而且

3382
01:52:42,000 --> 01:52:44,000
但这个硬件上具体怎么样

3383
01:52:44,000 --> 01:52:44,000
我们先不说

3384
01:52:44,000 --> 01:52:46,000
但我们就只讨论这种

3385
01:52:46,000 --> 01:52:46,000
如果

3386
01:52:47,000 --> 01:52:48,000
这种是一个主流的方式

3387
01:52:48,000 --> 01:52:49,000
到我们作为一个开发者

3388
01:52:49,000 --> 01:52:50,000
作为一个程式员

3389
01:52:50,000 --> 01:52:52,000
这编程模型就很爽了

3390
01:52:52,000 --> 01:52:53,000
比如说

3391
01:52:53,000 --> 01:52:54,000
你不用想什么

3392
01:52:54,000 --> 01:52:55,000
什么持久化

3393
01:52:56,000 --> 01:52:57,000
就经常我们现在比如说做什么

3394
01:52:57,000 --> 01:52:59,000
后端开发要考虑说

3395
01:52:59,000 --> 01:53:00,000
这个

3396
01:53:00,000 --> 01:53:00,000
内存

3397
01:53:00,000 --> 01:53:02,000
这个机器死机了

3398
01:53:02,000 --> 01:53:03,000
就服务器当机了

3399
01:53:03,000 --> 01:53:05,000
我那个内存中的数据不就没了吗

3400
01:53:05,000 --> 01:53:05,000
我又没写到

3401
01:53:05,000 --> 01:53:07,000
那磁盘上面不就丢了吗

3402
01:53:07,000 --> 01:53:07,000
对吧

3403
01:53:07,000 --> 01:53:08,000
就会有这种

3404
01:53:08,000 --> 01:53:09,000
这种很这种担忧

3405
01:53:09,000 --> 01:53:11,000
然后会有通过各种方法去

3406
01:53:11,000 --> 01:53:14,000
去想办法掩盖

3407
01:53:14,000 --> 01:53:14,000
就是

3408
01:53:15,000 --> 01:53:15,000
去处理

3409
01:53:15,000 --> 01:53:16,000
针对这种类型收进

3410
01:53:16,000 --> 01:53:17,000
已经在处理

3411
01:53:17,000 --> 01:53:20,000
但是如果你的内存是非意识的话

3412
01:53:20,000 --> 01:53:20,000
就很爽了

3413
01:53:20,000 --> 01:53:21,000
那就直接

3414
01:53:21,000 --> 01:53:23,000
再重启一下呗

3415
01:53:23,000 --> 01:53:24,000
对吧

3416
01:53:24,000 --> 01:53:24,000
对

3417
01:53:24,000 --> 01:53:26,000
就在通电还是那个状态

3418
01:53:27,000 --> 01:53:29,000
我们也不用去考虑什么

3419
01:53:29,000 --> 01:53:30,000
序列化解序列化

3420
01:53:30,000 --> 01:53:31,000
就开机干扰

3421
01:53:31,000 --> 01:53:33,000
序列化解决就是要

3422
01:53:33,000 --> 01:53:36,000
就是我们开机要等那么长的一个时间的

3423
01:53:36,000 --> 01:53:37,000
最主要的原因

3424
01:53:37,000 --> 01:53:37,000
你要等那个东西

3425
01:53:37,000 --> 01:53:40,000
从磁盘上加这个内存里面去

3426
01:53:40,000 --> 01:53:40,000
要把那个

3427
01:53:41,000 --> 01:53:42,000
一个序列化的一个

3428
01:53:42,000 --> 01:53:44,000
你可以想象它比较压缩

3429
01:53:44,000 --> 01:53:45,000
变成一个

3430
01:53:45,000 --> 01:53:47,000
转写的结构

3431
01:53:47,000 --> 01:53:48,000
然后再变成内存中的一个结构

3432
01:53:48,000 --> 01:53:50,000
这个是要花时间等的

3433
01:53:50,000 --> 01:53:53,000
但是序列化其实还有另外一个用途

3434
01:53:53,000 --> 01:53:54,000
就是或者说序列化

3435
01:53:54,000 --> 01:53:55,000
也比较主要的用途

3436
01:53:55,000 --> 01:53:57,000
就是数据传输

3437
01:53:57,000 --> 01:53:58,000
为了传输数据

3438
01:53:58,000 --> 01:53:59,000
你不得不把它

3439
01:54:00,000 --> 01:54:01,000
序列化

3440
01:54:01,000 --> 01:54:03,000
就是传输媒介本身是

3441
01:54:03,000 --> 01:54:05,000
传输的时候肯定是要进行序列化

3442
01:54:05,000 --> 01:54:06,000
但是就是说

3443
01:54:06,000 --> 01:54:07,000
如果你是作为一个

3444
01:54:07,000 --> 01:54:08,000
比如说你操作系统你每天启动的时候

3445
01:54:08,000 --> 01:54:10,000
你不需要和别人传输什么的

3446
01:54:10,000 --> 01:54:12,000
你不需要你这操作系统不是从另外一个

3447
01:54:12,000 --> 01:54:13,000
网络上传过来的吗

3448
01:54:13,000 --> 01:54:14,000
对吧

3449
01:54:14,000 --> 01:54:15,000
对

3450
01:54:15,000 --> 01:54:15,000
大部分情况下

3451
01:54:15,000 --> 01:54:17,000
但也有那种什么 Netboot

3452
01:54:17,000 --> 01:54:17,000
那种情况

3453
01:54:17,000 --> 01:54:19,000
那个情况再说

3454
01:54:20,000 --> 01:54:23,000
你启动你的电脑的时候

3455
01:54:23,000 --> 01:54:26,000
你的操作系统是不需要等网络才能启动的

3456
01:54:26,000 --> 01:54:27,000
所以这个时候

3457
01:54:27,000 --> 01:54:28,000
如果我们能做到一个

3458
01:54:28,000 --> 01:54:30,000
非异式的内存的话

3459
01:54:30,000 --> 01:54:31,000
一切都很爽

3460
01:54:31,000 --> 01:54:33,000
开机就可以有了

3461
01:54:33,000 --> 01:54:34,000
关机就可以走了

3462
01:54:34,000 --> 01:54:35,000
嗯

3463
01:54:36,000 --> 01:54:37,000
但传统上这个是做不

3464
01:54:37,000 --> 01:54:39,000
就是传统上我们做不到

3465
01:54:39,000 --> 01:54:42,000
因为也是一个工业现实和成本的考量

3466
01:54:42,000 --> 01:54:44,000
就是非异式的内存是有的

3467
01:54:44,000 --> 01:54:46,000
但是一个是比较贵

3468
01:54:46,000 --> 01:54:48,000
然后另外一个就是它的访问速度

3469
01:54:48,000 --> 01:54:50,000
存取速度不尽如人意

3470
01:54:51,000 --> 01:54:52,000
最大问题就还是太慢了

3471
01:54:52,000 --> 01:54:53,000
对

3472
01:54:53,000 --> 01:54:54,000
慢和贵

3473
01:54:54,000 --> 01:54:56,000
就是要么都是

3474
01:54:56,000 --> 01:54:58,000
要么就是要求其中一个的必比

3475
01:54:59,000 --> 01:55:03,000
然后最近有一个所谓的什么地

3476
01:55:03,000 --> 01:55:06,000
你知道传统那么三大类电容

3477
01:55:06,000 --> 01:55:06,000
不叫什么电

3478
01:55:06,000 --> 01:55:09,000
哦电容电阻和电

3479
01:55:09,000 --> 01:55:10,000
电导

3480
01:55:10,000 --> 01:55:12,000
就是导线

3481
01:55:12,000 --> 01:55:13,000
三大元器件

3482
01:55:13,000 --> 01:55:14,000
我记得好像三大

3483
01:55:14,000 --> 01:55:17,000
电容电阻和电

3484
01:55:17,000 --> 01:55:20,000
其实这块马上就要暴露出

3485
01:55:20,000 --> 01:55:23,000
这个是九倍不足了

3486
01:55:23,000 --> 01:55:23,000
因为这个

3487
01:55:23,000 --> 01:55:25,000
因为不是做一一的

3488
01:55:26,000 --> 01:55:27,000
这个真的是完全不是太懂

3489
01:55:27,000 --> 01:55:29,000
但是我的电路不考过

3490
01:55:30,000 --> 01:55:31,000
我都没学过

3491
01:55:31,000 --> 01:55:32,000
你比我

3492
01:55:32,000 --> 01:55:33,000
你还比我还好一些

3493
01:55:34,000 --> 01:55:34,000
不 anyway

3494
01:55:34,000 --> 01:55:37,000
就是传统上有那么那几种

3495
01:55:37,000 --> 01:55:38,000
元器件

3496
01:55:38,000 --> 01:55:39,000
电阻电容电感

3497
01:55:39,000 --> 01:55:40,000
没错

3498
01:55:40,000 --> 01:55:42,000
还是三大类没记错

3499
01:55:42,000 --> 01:55:45,000
所谓存在说第四类的这种元器件

3500
01:55:45,000 --> 01:55:46,000
英文叫做 Memory

3501
01:55:46,000 --> 01:55:47,000
Memory

3502
01:55:47,000 --> 01:55:47,000
嗯

3503
01:55:48,000 --> 01:55:49,000
Memory

3504
01:55:49,000 --> 01:55:50,000
Memoryster

3505
01:55:50,000 --> 01:55:51,000
Memoryster

3506
01:55:51,000 --> 01:55:52,000
对

3507
01:55:52,000 --> 01:55:53,000
然后中文这里

3508
01:55:53,000 --> 01:55:54,000
维基百科的翻译叫做

3509
01:55:54,000 --> 01:55:56,000
易阻器

3510
01:55:57,000 --> 01:55:58,000
就是记忆的意义

3511
01:55:58,000 --> 01:56:00,000
然后电阻的阻

3512
01:56:00,000 --> 01:56:01,000
易阻器

3513
01:56:01,000 --> 01:56:02,000
对

3514
01:56:02,000 --> 01:56:03,000
他有一些

3515
01:56:03,000 --> 01:56:05,000
他有一些奇怪的这种

3516
01:56:05,000 --> 01:56:07,000
物理学电器的特性

3517
01:56:07,000 --> 01:56:09,000
然后我是看不太懂

3518
01:56:09,000 --> 01:56:11,000
但是我知道它的作用是什么

3519
01:56:12,000 --> 01:56:13,000
对于一个程序来讲

3520
01:56:13,000 --> 01:56:15,000
它的作用就可以让你实现

3521
01:56:15,000 --> 01:56:16,000
所谓的

3522
01:56:16,000 --> 01:56:18,000
刚才讲一个是非一时的内存

3523
01:56:20,000 --> 01:56:21,000
这是对我来说很重要的一点

3524
01:56:21,000 --> 01:56:22,000
然后这个

3525
01:56:24,000 --> 01:56:26,000
就可以实现说你的内存

3526
01:56:26,000 --> 01:56:28,000
和你的硬盘是同一个器件

3527
01:56:29,000 --> 01:56:29,000
对

3528
01:56:29,000 --> 01:56:31,000
这是非常非常对

3529
01:56:31,000 --> 01:56:32,000
粗听没什么

3530
01:56:32,000 --> 01:56:33,000
但其实是一个非常重要的

3531
01:56:35,000 --> 01:56:38,000
如果这个东西可以被研发出来

3532
01:56:38,000 --> 01:56:39,000
并且大规模使用的话

3533
01:56:39,000 --> 01:56:42,000
它将会彻底改变我们编程模型

3534
01:56:42,000 --> 01:56:42,000
对

3535
01:56:43,000 --> 01:56:45,000
然后另外一个更牛逼的用途

3536
01:56:45,000 --> 01:56:47,000
但是现在我这个还是没太搞明白

3537
01:56:47,000 --> 01:56:49,000
这个就也是因为什么

3538
01:56:49,000 --> 01:56:50,000
电气工

3539
01:56:51,000 --> 01:56:52,000
电这叫电气工程

3540
01:56:52,000 --> 01:56:54,000
电气工程基础不够好的一个原理

3541
01:56:54,000 --> 01:56:55,000
电子工程

3542
01:56:55,000 --> 01:56:56,000
电子

3543
01:56:56,000 --> 01:56:56,000
电子工程

3544
01:56:56,000 --> 01:56:57,000
Whatever

3545
01:56:57,000 --> 01:57:00,000
这个不去纠结那么多细节的名词了

3546
01:57:00,000 --> 01:57:01,000
对 还有一个就是说

3547
01:57:01,000 --> 01:57:05,000
它这个一组器可以取代那种传统的电路

3548
01:57:05,000 --> 01:57:08,000
就是我们传统的机身电路那种组合的方式

3549
01:57:08,000 --> 01:57:10,000
比如说你要做一个那个什么 NAND gate

3550
01:57:11,000 --> 01:57:13,000
你可以用这个去构成一种

3551
01:57:13,000 --> 01:57:15,000
那种计算的元器件

3552
01:57:15,000 --> 01:57:18,000
然后它会实现更小的体积

3553
01:57:18,000 --> 01:57:18,000
然后更

3554
01:57:19,000 --> 01:57:20,000
就更低的功耗

3555
01:57:20,000 --> 01:57:21,000
大概是这个意思

3556
01:57:22,000 --> 01:57:24,000
但是这个对计算来讲

3557
01:57:24,000 --> 01:57:27,000
就对它所暴露出来的编程模型的改变

3558
01:57:27,000 --> 01:57:29,000
我觉得这个要小一些

3559
01:57:29,000 --> 01:57:30,000
这个是从硬件层面的

3560
01:57:30,000 --> 01:57:32,000
就 CPU 的模型

3561
01:57:32,000 --> 01:57:34,000
暴露出来的使用模型是没有变化的

3562
01:57:34,000 --> 01:57:35,000
这使用模型就是说

3563
01:57:35,000 --> 01:57:37,000
对于一个普通的开发者来讲

3564
01:57:37,000 --> 01:57:38,000
可能最大的变化还是说

3565
01:57:38,000 --> 01:57:43,000
没有内存和磁盘

3566
01:57:43,000 --> 01:57:46,000
就没有异晦发性的内存

3567
01:57:46,000 --> 01:57:49,000
和不异晦发性的内存的区别了

3568
01:57:49,000 --> 01:57:53,000
就是你可以不仅再去考虑内存管理

3569
01:57:53,000 --> 01:57:55,000
和从磁盘上面调用文件

3570
01:57:55,000 --> 01:57:57,000
因为就只有内存管理这一件事

3571
01:57:57,000 --> 01:57:58,000
对

3572
01:57:58,000 --> 01:57:59,000
而且那个时候也不用考虑

3573
01:57:59,000 --> 01:58:01,000
刚才讲了也不用考虑序列化解

3574
01:58:01,000 --> 01:58:02,000
序列化那些东西

3575
01:58:02,000 --> 01:58:05,000
因为你直接操作的就是

3576
01:58:05,000 --> 01:58:06,000
内存中的数据结构

3577
01:58:06,000 --> 01:58:08,000
然后数据结构关机后

3578
01:58:08,000 --> 01:58:10,000
也是会被持久化下来的

3579
01:58:11,000 --> 01:58:12,000
存下来的

3580
01:58:12,000 --> 01:58:13,000
然后这样你开机的时候

3581
01:58:13,000 --> 01:58:15,000
你还是回到那个程序原先的状态

3582
01:58:15,000 --> 01:58:16,000
Hello IT

3583
01:58:16,000 --> 01:58:18,000
Have you tried turning it off and on again

3584
01:58:18,000 --> 01:58:18,000
就不是

3585
01:58:18,000 --> 01:58:21,000
就可以在物理层面上实现

3586
01:58:21,000 --> 01:58:23,000
我们现在用操作系统

3587
01:58:23,000 --> 01:58:25,000
通过虚拟内存来做的事情

3588
01:58:25,000 --> 01:58:26,000
OK

3589
01:58:27,000 --> 01:58:29,000
我觉得这个对编程模型的改变还是蛮大的

3590
01:58:29,000 --> 01:58:31,000
不过这边其实也有一些问题

3591
01:58:31,000 --> 01:58:36,000
如果你假设内存是非一时的话

3592
01:58:36,000 --> 01:58:39,000
那么如果中间哪里错了

3593
01:58:39,000 --> 01:58:40,000
crush 了

3594
01:58:40,000 --> 01:58:42,000
然后导致内存状态不对

3595
01:58:44,000 --> 01:58:46,000
这个结果还是蛮奇怪的

3596
01:58:46,000 --> 01:58:46,000
对

3597
01:58:46,000 --> 01:58:48,000
忽然之间你好像没有一个

3598
01:58:48,000 --> 01:58:51,000
非常好的手段去 reset 了

3599
01:58:51,000 --> 01:58:51,000
对

3600
01:58:51,000 --> 01:58:53,000
就以前那个叫什么

3601
01:58:54,000 --> 01:58:56,000
在 IT crowd 里面常说

3602
01:58:58,000 --> 01:58:59,000
对

3603
01:58:59,000 --> 01:59:00,000
就是遇到问题

3604
01:59:00,000 --> 01:59:03,000
现在重开机重启试试

3605
01:59:03,000 --> 01:59:05,000
重启没问题就还可以

3606
01:59:05,000 --> 01:59:06,000
因为重启就掉电了

3607
01:59:06,000 --> 01:59:07,000
掉电的话

3608
01:59:07,000 --> 01:59:08,000
这些重来

3609
01:59:08,000 --> 01:59:12,000
就有一个所有的一个 clean start

3610
01:59:13,000 --> 01:59:13,000
对

3611
01:59:13,000 --> 01:59:14,000
就是如果

3612
01:59:14,000 --> 01:59:16,000
计算机是一个状态机的话

3613
01:59:16,000 --> 01:59:19,000
那么重启就可以让它回复到状态机的原点

3614
01:59:19,000 --> 01:59:20,000
一般来说

3615
01:59:21,000 --> 01:59:22,000
程序不稳定

3616
01:59:22,000 --> 01:59:25,000
都是这个状态机走进了一个

3617
01:59:25,000 --> 01:59:26,000
没有被预见到的状态里面去

3618
01:59:26,000 --> 01:59:28,000
但是通过重启

3619
01:59:28,000 --> 01:59:29,000
你可以让它重新回到

3620
01:59:30,000 --> 01:59:33,000
至少是造计算机的人所预想的

3621
01:59:33,000 --> 01:59:34,000
可以被控制

3622
01:59:34,000 --> 01:59:37,000
并且也知道它可以走向何处的地方

3623
01:59:37,000 --> 01:59:38,000
对

3624
01:59:40,000 --> 01:59:41,000
但是如果像讲的

3625
01:59:41,000 --> 01:59:42,000
如果是一个内存是非一时的话

3626
01:59:42,000 --> 01:59:43,000
这一点就行不通了

3627
01:59:43,000 --> 01:59:46,000
就还要采取一些极端的手段来做

3628
01:59:47,000 --> 01:59:51,000
这个灾难恢复还是故障修复之类的事情

3629
01:59:52,000 --> 01:59:52,000
对

3630
01:59:53,000 --> 01:59:58,000
不过但是这个不过还是用 memraster

3631
01:59:58,000 --> 01:59:59,000
memraster

3632
01:59:59,000 --> 02:00:03,000
易主器还是说通过虚拟内存这一点

3633
02:00:03,000 --> 02:00:06,000
我们都是在试图说简化这个

3634
02:00:07,000 --> 02:00:08,000
开发者

3635
02:00:09,000 --> 02:00:10,000
对开发难度

3636
02:00:10,000 --> 02:00:12,000
就是通过这种减少

3637
02:00:14,000 --> 02:00:15,000
层级的方式来实现的

3638
02:00:15,000 --> 02:00:18,000
其实现在的程序员所唯一需要

3639
02:00:18,000 --> 02:00:19,000
或者也不是

3640
02:00:19,000 --> 02:00:23,000
还是仍旧需要操心一件事情

3641
02:00:23,000 --> 02:00:25,000
就是序列化和反序列化对吧

3642
02:00:25,000 --> 02:00:25,000
对

3643
02:00:26,000 --> 02:00:30,000
但从整个编程的发展的方向来看

3644
02:00:30,000 --> 02:00:33,000
也许这件事情将来也是要被

3645
02:00:34,000 --> 02:00:35,000
被淘汰掉了

3646
02:00:35,000 --> 02:00:38,000
或者说人们可以完全不用再去操心

3647
02:00:39,000 --> 02:00:41,000
序列化和反序列化这件事情对不对

3648
02:00:41,000 --> 02:00:42,000
对

3649
02:00:42,000 --> 02:00:44,000
其实现在已经有这种

3650
02:00:44,000 --> 02:00:47,000
各种方法可以做一定的这种事情了

3651
02:00:47,000 --> 02:00:48,000
对

3652
02:00:50,000 --> 02:00:53,000
还是先说手工管理层

3653
02:00:53,000 --> 02:00:55,000
因为我刚才又缅怀了一下自己

3654
02:00:56,000 --> 02:00:58,000
当初写 C 程序的时候

3655
02:00:58,000 --> 02:01:01,000
会在一张纸上写说

3656
02:01:01,000 --> 02:01:03,000
有个东西我在什么地方把它

3657
02:01:04,000 --> 02:01:05,000
emulog

3658
02:01:05,000 --> 02:01:06,000
然后要记得

3659
02:01:07,000 --> 02:01:08,000
应该在什么

3660
02:01:08,000 --> 02:01:12,000
恰当的时候把它 free 掉

3661
02:01:13,000 --> 02:01:18,000
就是 C 元其实给你提供了一个比较

3662
02:01:18,000 --> 02:01:21,000
贴近硬件的编程模型

3663
02:01:21,000 --> 02:01:26,000
但是它仍旧把分配内存这一部分

3664
02:01:26,000 --> 02:01:27,000
给帮你隐藏起来

3665
02:01:27,000 --> 02:01:31,000
比如说你有想过 emulog 究竟做了什么吗

3666
02:01:32,000 --> 02:01:35,000
我们会说一个东西分配在堆上

3667
02:01:35,000 --> 02:01:36,000
一个东西分配在站上

3668
02:01:36,000 --> 02:01:38,000
可是堆和站这两个东西

3669
02:01:39,000 --> 02:01:39,000
em

3670
02:01:40,000 --> 02:01:43,000
站你可以通过后面语来操作

3671
02:01:43,000 --> 02:01:45,000
可是堆这个东西怎么通过后面语来操作呢

3672
02:01:45,000 --> 02:01:47,000
其实是不行的

3673
02:01:47,000 --> 02:01:47,000
不是吗

3674
02:01:47,000 --> 02:01:49,000
就堆这个东西其实是

3675
02:01:51,000 --> 02:01:54,000
操作系统替你虚拟出来的这么一块内存区域而已

3676
02:01:55,000 --> 02:01:57,000
而站则是一个

3677
02:01:59,000 --> 02:02:01,000
站其实也是有操作系统虚拟出来

3678
02:02:02,000 --> 02:02:05,000
但你不用手工去管理它吗

3679
02:02:05,000 --> 02:02:06,000
对

3680
02:02:06,000 --> 02:02:13,000
堆和站的抽象层级其实是不太一样的

3681
02:02:14,000 --> 02:02:15,000
可以这么说吗

3682
02:02:15,000 --> 02:02:15,000
对

3683
02:02:15,000 --> 02:02:15,000
可以

3684
02:02:16,000 --> 02:02:16,000
对

3685
02:02:17,000 --> 02:02:21,000
但是在那个时候你调语一函数的时候

3686
02:02:21,000 --> 02:02:23,000
你在这个函数里面声明了一个本地变量

3687
02:02:23,000 --> 02:02:26,000
然后本地变量其实就是默认分配在站上

3688
02:02:26,000 --> 02:02:27,000
就是站这个东西

3689
02:02:27,000 --> 02:02:30,000
你是没有一个直观的印象说这个东西在站上

3690
02:02:30,000 --> 02:02:32,000
你只有去研究这个语言的原理的时候

3691
02:02:32,000 --> 02:02:34,000
你才会明白什么是站

3692
02:02:36,000 --> 02:02:40,000
但是堆这个东西你会有显示的至少两个 API 去操作它

3693
02:02:40,000 --> 02:02:41,000
比如一个是 Alloc

3694
02:02:41,000 --> 02:02:43,000
一个 M-Alloc 或者 C-Alloc

3695
02:02:44,000 --> 02:02:45,000
然后一个是 Free

3696
02:02:45,000 --> 02:02:49,000
就是你会通过 M-Alloc 这件事情拿到一个内存的地址

3697
02:02:50,000 --> 02:02:51,000
但是站是没有这个东西的

3698
02:02:51,000 --> 02:02:53,000
站是不会给你一个东西

3699
02:02:53,000 --> 02:02:55,000
就让你显示的去 push 和 pop 的对吧

3700
02:02:56,000 --> 02:02:56,000
对

3701
02:02:57,000 --> 02:03:04,000
说这个 pop dispatch 我们的友台节目总是让我觉得是出站芬芳

3702
02:03:04,000 --> 02:03:05,000
很 Hotcore

3703
02:03:05,000 --> 02:03:10,000
对比我们 Colonel Pan 那个 Hotcore 多了

3704
02:03:11,000 --> 02:03:14,000
出站芬芳的 Message dispatch

3705
02:03:16,000 --> 02:03:19,000
可是现在的程序就幸福很多了

3706
02:03:19,000 --> 02:03:30,000
至少从比如说但是四季加加程序还是要去操心一个累的那个叫什么

3707
02:03:31,000 --> 02:03:32,000
他要有地址

3708
02:03:32,000 --> 02:03:33,000
中文是什么

3709
02:03:34,000 --> 02:03:35,000
构造器

3710
02:03:35,000 --> 02:03:36,000
对构造函数的

3711
02:03:36,000 --> 02:03:39,000
你还需要去考虑一个类的构造函数

3712
02:03:39,000 --> 02:03:39,000
Destructor

3713
02:03:39,000 --> 02:03:40,000
西构函数

3714
02:03:40,000 --> 02:03:41,000
对西构函数

3715
02:03:41,000 --> 02:03:45,000
我小时候觉得这个名字好屌

3716
02:03:45,000 --> 02:03:46,000
西构函数

3717
02:03:47,000 --> 02:03:55,000
然后在 Oject-C 里面你也需要去考虑什么事

3718
02:03:55,000 --> 02:03:58,000
就是你需要显示去写一个

3719
02:03:59,000 --> 02:04:04,000
一个 Interface 的 implementation 里面

3720
02:04:04,000 --> 02:04:08,000
你要写这个玩意在被 Dialog 的时候要做点事情

3721
02:04:08,000 --> 02:04:12,000
但是你从来不需要去显示的去调用 Dialog

3722
02:04:12,000 --> 02:04:14,000
这点和西构函数应该是一样的

3723
02:04:15,000 --> 02:04:16,000
对他会帮你去 call 那个

3724
02:04:16,000 --> 02:04:19,000
但是你还是得要记住什么的顺序关系

3725
02:04:19,000 --> 02:04:21,000
你写的时候就要留意这一点

3726
02:04:21,000 --> 02:04:22,000
对

3727
02:04:22,000 --> 02:04:25,000
然后 Oject-C 帮你

3728
02:04:25,000 --> 02:04:33,000
帮程序员在某种程度上减轻了内存管理的业务逻辑

3729
02:04:33,000 --> 02:04:35,000
你只需要自己去记住这个东西

3730
02:04:35,000 --> 02:04:37,000
如果有别人还在用

3731
02:04:37,000 --> 02:04:38,000
你就要 retain 一次

3732
02:04:38,000 --> 02:04:40,000
如果有别人已经不在用了

3733
02:04:40,000 --> 02:04:42,000
你就把它 release 一下就好了

3734
02:04:42,000 --> 02:04:44,000
然后只要还有一个人在用

3735
02:04:44,000 --> 02:04:48,000
这个东西就不会被运行时真正的销毁掉

3736
02:04:48,000 --> 02:04:51,000
它就是个 ARC 吗

3737
02:04:51,000 --> 02:04:53,000
不这是 RC 没有 A

3738
02:04:53,000 --> 02:04:54,000
没有 A 像

3739
02:04:54,000 --> 02:04:57,000
reference counting 就是人要自己去在那边算

3740
02:04:57,000 --> 02:04:59,000
那个 release 了多少次

3741
02:04:59,000 --> 02:05:01,000
以及 retain 了多少次

3742
02:05:01,000 --> 02:05:03,000
然后 ARC 帮你解决的这个问题

3743
02:05:03,000 --> 02:05:06,000
就是你不用再去显示的 release 和 retain 了

3744
02:05:06,000 --> 02:05:09,000
系统帮你数吗

3745
02:05:09,000 --> 02:05:14,000
对就是 Oject-C 会在编译期帮你数一遍

3746
02:05:14,000 --> 02:05:16,000
这应该不是在运行时数的

3747
02:05:16,000 --> 02:05:17,000
编译期的时候会帮你数一遍

3748
02:05:17,000 --> 02:05:21,000
你这个东西所有的用的地方

3749
02:05:21,000 --> 02:05:23,000
它就会帮你自动 retain 一次

3750
02:05:23,000 --> 02:05:26,000
然后所有它觉得你已经不会再用的地方

3751
02:05:26,000 --> 02:05:27,000
它就帮你 release 一下

3752
02:05:28,000 --> 02:05:32,000
所以那个还是一个比较原始的方法

3753
02:05:32,000 --> 02:05:33,000
就是对

3754
02:05:33,000 --> 02:05:34,000
就有点

3755
02:05:34,000 --> 02:05:38,000
如果说手动的管理内存是一个

3756
02:05:38,000 --> 02:05:40,000
从说是一个老式步枪的话

3757
02:05:40,000 --> 02:05:41,000
你需要自己打一发上一刹

3758
02:05:41,000 --> 02:05:42,000
拉一下枪栓

3759
02:05:42,000 --> 02:05:47,000
那 ARC 就有点像半自动了

3760
02:05:47,000 --> 02:05:51,000
现在就是手工管理内存的时代

3761
02:05:51,000 --> 02:05:52,000
基本上已经是过去了

3762
02:05:53,000 --> 02:05:55,000
除非你有什么特别

3763
02:05:55,000 --> 02:05:57,000
除非你是自己是写

3764
02:05:58,000 --> 02:06:00,000
虚拟机或者是编译器的人

3765
02:06:00,000 --> 02:06:03,000
否则你一般是不需要去操心

3766
02:06:03,000 --> 02:06:05,000
怎么手工管理内存这件事

3767
02:06:05,000 --> 02:06:06,000
他有些那种所谓的什么

3768
02:06:06,000 --> 02:06:09,000
performance critical 的东西的时候

3769
02:06:09,000 --> 02:06:12,000
他会要用 C 或 C 加加来写的时候

3770
02:06:12,000 --> 02:06:15,000
就还会考虑内存管理的问题

3771
02:06:15,000 --> 02:06:15,000
对

3772
02:06:15,000 --> 02:06:18,000
或者是在面试的时候

3773
02:06:18,000 --> 02:06:21,000
告诉你说你不能使用额外的内存

3774
02:06:21,000 --> 02:06:22,000
你应该怎么回答

3775
02:06:22,000 --> 02:06:22,000
你应该怎么办

3776
02:06:22,000 --> 02:06:25,000
写个 M-Log

3777
02:06:26,000 --> 02:06:27,000
对

3778
02:06:28,000 --> 02:06:31,000
现在主流的是一个垃圾回收的机制

3779
02:06:32,000 --> 02:06:34,000
垃圾回收可以说是

3780
02:06:35,000 --> 02:06:38,000
进一步解放了程序

3781
02:06:38,000 --> 02:06:43,000
就是你有更加清晰而简化的变成模型

3782
02:06:44,000 --> 02:06:46,000
当然由此也就降低了

3783
02:06:47,000 --> 02:06:49,000
降低了变成

3784
02:06:49,000 --> 02:06:49,000
怎么说的

3785
02:06:49,000 --> 02:06:53,000
提高了你写出烂代码的几率

3786
02:06:53,000 --> 02:06:53,000
应该这么说

3787
02:06:54,000 --> 02:06:55,000
你说门槛低了吗

3788
02:06:55,000 --> 02:06:59,000
门槛低了是好事

3789
02:07:00,000 --> 02:07:00,000
好吧

3790
02:07:00,000 --> 02:07:03,000
你是从比较正面的角度理解这件事情

3791
02:07:03,000 --> 02:07:05,000
但我总觉得就是门槛低了

3792
02:07:05,000 --> 02:07:08,000
更容易让更多平庸的人写出平庸

3793
02:07:08,000 --> 02:07:10,000
但是 work 的代码

3794
02:07:10,000 --> 02:07:10,000
对

3795
02:07:10,000 --> 02:07:12,000
但是时间一久

3796
02:07:12,000 --> 02:07:14,000
甚至可以这么说

3797
02:07:14,000 --> 02:07:15,000
就是

3798
02:07:15,000 --> 02:07:19,000
编程模型的简化使得大规模的软件

3799
02:07:19,000 --> 02:07:20,000
协作成为可能

3800
02:07:20,000 --> 02:07:21,000
对

3801
02:07:22,000 --> 02:07:24,000
不是大家都是大牛的情况下

3802
02:07:24,000 --> 02:07:25,000
也能把这个事情做出来

3803
02:07:25,000 --> 02:07:27,000
有一群平庸的人也可以写出一个

3804
02:07:28,000 --> 02:07:31,000
工业级别健壮的东西来给大家用

3805
02:07:31,000 --> 02:07:34,000
而不再需要一群先驱者

3806
02:07:34,000 --> 02:07:36,000
一群 hacker 去

3807
02:07:36,000 --> 02:07:38,000
只有他们才可以写出一个

3808
02:07:38,000 --> 02:07:40,000
真正的

3809
02:07:41,000 --> 02:07:43,000
居然可以工作的程序来

3810
02:07:43,000 --> 02:07:43,000
对

3811
02:07:44,000 --> 02:07:46,000
GC 的逻辑其实也蛮

3812
02:07:47,000 --> 02:07:48,000
简单讲起来是蛮好讲的

3813
02:07:48,000 --> 02:07:49,000
就是它会

3814
02:07:50,000 --> 02:07:51,000
运行时会去

3815
02:07:51,000 --> 02:07:54,000
检查你每一个内部的指针怎么样

3816
02:07:54,000 --> 02:07:57,000
然后去算哪些区是没有

3817
02:07:57,000 --> 02:07:59,000
不可能再被用到了

3818
02:07:59,000 --> 02:08:00,000
然后它就直接把那些区

3819
02:08:00,000 --> 02:08:02,000
就标记为可以回收掉的

3820
02:08:03,000 --> 02:08:03,000
对

3821
02:08:03,000 --> 02:08:04,000
然后再

3822
02:08:04,000 --> 02:08:06,000
下一段里面把它回收掉

3823
02:08:06,000 --> 02:08:06,000
对

3824
02:08:06,000 --> 02:08:10,000
但是 GC 也有很多不同的类型

3825
02:08:10,000 --> 02:08:10,000
我们可以

3826
02:08:11,000 --> 02:08:12,000
找机会再讲

3827
02:08:13,000 --> 02:08:14,000
你刚才说到

3828
02:08:15,000 --> 02:08:16,000
go 出了 1.4

3829
02:08:16,000 --> 02:08:21,000
我去看了一下它的 release note

3830
02:08:22,000 --> 02:08:23,000
里面有一集也写到说

3831
02:08:23,000 --> 02:08:25,000
change to runtime

3832
02:08:26,000 --> 02:08:29,000
它里面写说 1.4 之前

3833
02:08:29,000 --> 02:08:30,000
runtime

3834
02:08:31,000 --> 02:08:32,000
就是什么 GC

3835
02:08:34,000 --> 02:08:35,000
concurrency 的支持

3836
02:08:35,000 --> 02:08:36,000
interface management

3837
02:08:36,000 --> 02:08:38,000
map,slice,strings etc

3838
02:08:39,000 --> 02:08:40,000
在 1.4 之前

3839
02:08:40,000 --> 02:08:42,000
基本上是以 C 来写的

3840
02:08:42,000 --> 02:08:43,000
对

3841
02:08:43,000 --> 02:08:44,000
然后

3842
02:08:45,000 --> 02:08:47,000
包括某些部分用了汇编代码

3843
02:08:47,000 --> 02:08:49,000
然后从 1.4 开始

3844
02:08:49,000 --> 02:08:52,000
大部分 runtime 都用

3845
02:08:52,000 --> 02:08:53,000
go 来重写一遍

3846
02:08:53,000 --> 02:08:54,000
对

3847
02:08:54,000 --> 02:08:55,000
然后一次

3848
02:08:55,000 --> 02:08:56,000
对

3849
02:08:56,000 --> 02:08:57,000
而且一次来

3850
02:08:58,000 --> 02:08:59,000
带来了一个提升

3851
02:08:59,000 --> 02:09:01,000
就是 garbage collector

3852
02:09:01,000 --> 02:09:04,000
can scan the stacks of the programs in the runtime

3853
02:09:04,000 --> 02:09:06,000
and get accurate information

3854
02:09:06,000 --> 02:09:08,000
about what variables are active

3855
02:09:08,000 --> 02:09:08,000
对

3856
02:09:08,000 --> 02:09:09,000
它之前是

3857
02:09:09,000 --> 02:09:11,000
因为它拿不到运行时的有些东西

3858
02:09:11,000 --> 02:09:12,000
所以它的 GC

3859
02:09:12,000 --> 02:09:13,000
就是它的内存

3860
02:09:13,000 --> 02:09:14,000
垃圾回收

3861
02:09:14,000 --> 02:09:16,000
是就是 imprecise

3862
02:09:16,000 --> 02:09:18,000
就是不是很精确

3863
02:09:18,000 --> 02:09:19,000
有时候会漏掉一些东西

3864
02:09:20,000 --> 02:09:22,000
但是整体来说还可以

3865
02:09:22,000 --> 02:09:23,000
它现在变成一个

3866
02:09:23,000 --> 02:09:24,000
就是完全精确的

3867
02:09:24,000 --> 02:09:27,000
就一定知道哪些指针是

3868
02:09:27,000 --> 02:09:28,000
可以被

3869
02:09:28,000 --> 02:09:29,000
就是哪些没有被

3870
02:09:29,000 --> 02:09:29,000
对

3871
02:09:29,000 --> 02:09:30,000
被安全回收的

3872
02:09:30,000 --> 02:09:31,000
对

3873
02:09:31,000 --> 02:09:32,000
然后他们还要做

3874
02:09:32,000 --> 02:09:33,000
下半段他们要做另外一件事情

3875
02:09:33,000 --> 02:09:34,000
就是要

3876
02:09:34,000 --> 02:09:37,000
把垃圾回收做一个完全必行化的东西

3877
02:09:37,000 --> 02:09:38,000
因为现在它的垃圾回收

3878
02:09:38,000 --> 02:09:39,000
还是一个

3879
02:09:39,000 --> 02:09:40,000
叫做 stop the world

3880
02:09:41,000 --> 02:09:43,000
JVM 也有这个

3881
02:09:44,000 --> 02:09:46,000
这个话要说严谨一点

3882
02:09:46,000 --> 02:09:48,000
主流的

3883
02:09:48,000 --> 02:09:49,000
部分 JVM

3884
02:09:49,000 --> 02:09:50,000
还有这个

3885
02:09:50,000 --> 02:09:51,000
对有这个问题

3886
02:09:51,000 --> 02:09:52,000
就是它在垃圾回收

3887
02:09:52,000 --> 02:09:54,000
这个机制运行的期间

3888
02:09:55,000 --> 02:09:57,000
其程序的其他部分是暂停的

3889
02:09:57,000 --> 02:09:58,000
对

3890
02:09:58,000 --> 02:09:59,000
这就是为什么

3891
02:09:59,000 --> 02:10:00,000
这就是为什么 Eclipse 那么卡

3892
02:10:02,000 --> 02:10:03,000
延续吧

3893
02:10:03,000 --> 02:10:04,000
对

3894
02:10:04,000 --> 02:10:04,000
可以简单这样说

3895
02:10:04,000 --> 02:10:06,000
这个对很多应用来说

3896
02:10:06,000 --> 02:10:07,000
这个就是不可以接受的

3897
02:10:07,000 --> 02:10:09,000
比如说你写一个什么

3898
02:10:09,000 --> 02:10:11,000
股票的实施交易的运用

3899
02:10:11,000 --> 02:10:12,000
你可能

3900
02:10:12,000 --> 02:10:14,000
可能几十毫秒

3901
02:10:14,000 --> 02:10:15,000
100 毫秒的差别

3902
02:10:15,000 --> 02:10:16,000
那就是上百万的

3903
02:10:17,000 --> 02:10:18,000
经济的损失对吧

3904
02:10:18,000 --> 02:10:20,000
所以你肯定不可避免

3905
02:10:20,000 --> 02:10:22,000
所以他们有些做金融交易的

3906
02:10:22,000 --> 02:10:24,000
有些就直接用什么

3907
02:10:24,000 --> 02:10:25,000
C 加加写

3908
02:10:25,000 --> 02:10:27,000
就这样不需要去考虑 GC 的问题

3909
02:10:27,000 --> 02:10:28,000
或者是他用 JVM

3910
02:10:28,000 --> 02:10:30,000
但是用改良过的这种

3911
02:10:30,000 --> 02:10:31,000
就是所谓的

3912
02:10:31,000 --> 02:10:32,000
concurrent

3913
02:10:32,000 --> 02:10:33,000
或者 parallel GC

3914
02:10:33,000 --> 02:10:35,000
就是并行的 GC

3915
02:10:35,000 --> 02:10:35,000
这些过程中

3916
02:10:35,000 --> 02:10:37,000
它可以不用停下来一个主程序

3917
02:10:37,000 --> 02:10:38,000
现在 Go 的

3918
02:10:38,000 --> 02:10:40,000
它里面还是 stop the war 这种情况

3919
02:10:40,000 --> 02:10:42,000
但是它是说 1.5

3920
02:10:42,000 --> 02:10:42,000
我记得

3921
02:10:43,000 --> 02:10:45,000
就下一个版本它会变成 concurrent

3922
02:10:45,000 --> 02:10:46,000
对

3923
02:10:47,000 --> 02:10:48,000
这也就回到了刚才说的

3924
02:10:49,000 --> 02:10:52,000
整个内存管理的方向

3925
02:10:52,000 --> 02:10:53,000
还是朝着让

3926
02:10:53,000 --> 02:10:54,000
傻瓜话

3927
02:10:54,000 --> 02:10:56,000
越来越省心的方向来

3928
02:10:57,000 --> 02:10:58,000
来演进的

3929
02:10:58,000 --> 02:11:00,000
但是同时也就造成了

3930
02:11:00,000 --> 02:11:03,000
在真正那些仍旧还是需要

3931
02:11:03,000 --> 02:11:05,000
就像你说的股票操作系统

3932
02:11:06,000 --> 02:11:07,000
mission critical 的场合

3933
02:11:07,000 --> 02:11:08,000
还是需要手动管理的生意

3934
02:11:10,000 --> 02:11:11,000
有些事情还是

3935
02:11:12,000 --> 02:11:13,000
不得不依靠手动管理

3936
02:11:13,000 --> 02:11:15,000
因为手动管理才可以达到

3937
02:11:16,000 --> 02:11:18,000
所需要的 performance

3938
02:11:18,000 --> 02:11:18,000
对

3939
02:11:18,000 --> 02:11:21,000
我记得 Bianna

3940
02:11:22,000 --> 02:11:22,000
是什么

3941
02:11:22,000 --> 02:11:23,000
Bianna Stroh-Stroh

3942
02:11:23,000 --> 02:11:24,000
对

3943
02:11:24,000 --> 02:11:26,000
就是 C++的创始人在

3944
02:11:26,000 --> 02:11:27,000
我忘了是哪本书里面

3945
02:11:27,000 --> 02:11:31,000
他吐槽 Java 说

3946
02:11:33,000 --> 02:11:33,000
他有点炫耀的意思

3947
02:11:33,000 --> 02:11:35,000
就是说你知道 joint

3948
02:11:36,000 --> 02:11:36,000
strike fighter

3949
02:11:36,000 --> 02:11:37,000
JSF

3950
02:11:38,000 --> 02:11:38,000
战斗机

3951
02:11:38,000 --> 02:11:40,000
它是一台 C++战斗机

3952
02:11:40,000 --> 02:11:42,000
就是上面所有的代码都是 C++

3953
02:11:43,000 --> 02:11:45,000
然后火星探测器

3954
02:11:45,000 --> 02:11:45,000
你知道吗

3955
02:11:45,000 --> 02:11:46,000
C++写的

3956
02:11:47,000 --> 02:11:49,000
你用 Java 给我写一个看看

3957
02:11:51,000 --> 02:11:51,000
大一就是这样

3958
02:11:51,000 --> 02:11:54,000
对那些的应用场合就比较极端

3959
02:11:54,000 --> 02:11:57,000
性能和环境要求比较恶劣

3960
02:11:57,000 --> 02:11:59,000
对在这种情况之下

3961
02:11:59,000 --> 02:12:01,000
你还是不得不

3962
02:12:01,000 --> 02:12:02,000
手动

3963
02:12:02,000 --> 02:12:04,000
加引号的手动去管理内存

3964
02:12:05,000 --> 02:12:07,000
不过也有做到

3965
02:12:09,000 --> 02:12:11,000
在技术进步的之后

3966
02:12:11,000 --> 02:12:13,000
也有说这个程序

3967
02:12:13,000 --> 02:12:14,000
还没回过神来

3968
02:12:15,000 --> 02:12:16,000
没有适应

3969
02:12:16,000 --> 02:12:18,000
用到最新的这种方法去做

3970
02:12:18,000 --> 02:12:20,000
这里有一个很简单的例子

3971
02:12:20,000 --> 02:12:21,000
之前我们提到了

3972
02:12:22,000 --> 02:12:24,000
序列化解序列化的问题

3973
02:12:24,000 --> 02:12:26,000
但我们要做一些事情的时候

3974
02:12:28,000 --> 02:12:29,000
你有一些文件

3975
02:12:29,000 --> 02:12:31,000
你要在内存里面去展现

3976
02:12:31,000 --> 02:12:34,000
但是内存又不如磁盘大

3977
02:12:35,000 --> 02:12:36,000
那么有些人就说

3978
02:12:36,000 --> 02:12:39,000
我怎么才能在内存里面去

3979
02:12:39,000 --> 02:12:39,000
超

3980
02:12:39,000 --> 02:12:41,000
因为只有到内存里面

3981
02:12:41,000 --> 02:12:44,000
只有 CPU 才可以去操作那些数据

3982
02:12:44,000 --> 02:12:47,000
所以我有一个从磁盘里面

3983
02:12:47,000 --> 02:12:47,000
读数据

3984
02:12:47,000 --> 02:12:49,000
读到内存里面去

3985
02:12:49,000 --> 02:12:50,000
然后再处理

3986
02:12:50,000 --> 02:12:51,000
然后再处理完毕

3987
02:12:51,000 --> 02:12:53,000
再读下一段这么一个过程

3988
02:12:54,000 --> 02:12:56,000
但其实在线的操作性能上面

3989
02:12:56,000 --> 02:12:58,000
这个事情也已经很大程度上

3990
02:12:58,000 --> 02:12:59,000
可以完全被避免掉了

3991
02:12:59,000 --> 02:13:01,000
就是通过所谓的使用

3992
02:13:01,000 --> 02:13:02,000
这个叫做

3993
02:13:03,000 --> 02:13:04,000
Memory Map

3994
02:13:04,000 --> 02:13:05,000
Memory Mapping

3995
02:13:05,000 --> 02:13:06,000
内存映射这个概念

3996
02:13:07,000 --> 02:13:07,000
对

3997
02:13:08,000 --> 02:13:09,000
内存映射大概是什么事情呢

3998
02:13:09,000 --> 02:13:11,000
就操作系统提供了这么一个机制

3999
02:13:11,000 --> 02:13:12,000
它可以说

4000
02:13:12,000 --> 02:13:15,000
你可以指着磁盘上的一个文件

4001
02:13:15,000 --> 02:13:16,000
大小随意

4002
02:13:16,000 --> 02:13:17,000
说

4003
02:13:17,000 --> 02:13:19,000
我要把这一块文件映射到

4004
02:13:19,000 --> 02:13:21,000
内存地址里面去

4005
02:13:21,000 --> 02:13:21,000
这样的话

4006
02:13:21,000 --> 02:13:24,000
我的程序可以直接在

4007
02:13:25,000 --> 02:13:27,000
在界面上

4008
02:13:27,000 --> 02:13:29,000
我直接操纵内存的一个区块

4009
02:13:29,000 --> 02:13:29,000
就好了

4010
02:13:29,000 --> 02:13:32,000
但是具体的数据可能并不

4011
02:13:32,000 --> 02:13:34,000
那个时候并不在内存里面

4012
02:13:34,000 --> 02:13:37,000
然后这个时候是由操作系统去负责

4013
02:13:37,000 --> 02:13:41,000
去把你要访问的那块内存区块的内容

4014
02:13:41,000 --> 02:13:44,000
从磁盘上加载过来

4015
02:13:44,000 --> 02:13:45,000
然后再管理

4016
02:13:45,000 --> 02:13:49,000
如果说内存物理空间不足的情况下

4017
02:13:49,000 --> 02:13:51,000
再把那些没有用到的那些内存区块

4018
02:13:51,000 --> 02:13:53,000
再放回磁盘上去

4019
02:13:53,000 --> 02:13:55,000
就是内存映射就做这么一件事

4020
02:13:55,000 --> 02:13:57,000
然后其实就很

4021
02:13:57,000 --> 02:13:59,000
这个就是对我们的开发者来讲

4022
02:13:59,000 --> 02:14:00,000
就是一个启发

4023
02:14:00,000 --> 02:14:01,000
这一篇很好的文章

4024
02:14:01,000 --> 02:14:04,000
大家会不会放在这个 Note 里面

4025
02:14:04,000 --> 02:14:07,000
这个是 Varnish Cache 这个软件

4026
02:14:07,000 --> 02:14:08,000
就是一个反向代理的常用

4027
02:14:08,000 --> 02:14:10,000
如现在你跑夫妻后端的话

4028
02:14:10,000 --> 02:14:12,000
可能会经常接触到这个软件

4029
02:14:12,000 --> 02:14:14,000
他们的开发者写了一个

4030
02:14:14,000 --> 02:14:15,000
就是他的标题叫做

4031
02:14:16,000 --> 02:14:18,000
What's wrong with 1975 programming

4032
02:14:18,000 --> 02:14:19,000
就是

4033
02:14:19,000 --> 02:14:22,000
他说 1975 年的编程模型有什么问题

4034
02:14:23,000 --> 02:14:24,000
他们讲的最主要的一个问题

4035
02:14:24,000 --> 02:14:25,000
就是说刚才一个

4036
02:14:26,000 --> 02:14:27,000
就是内存

4037
02:14:28,000 --> 02:14:30,000
1975 年的时候还没有

4038
02:14:30,000 --> 02:14:31,000
虚拟内存这个概念

4039
02:14:31,000 --> 02:14:32,000
你真的是需要

4040
02:14:32,000 --> 02:14:34,000
你程序员手工去考虑

4041
02:14:34,000 --> 02:14:36,000
怎么去从磁盘上加载一个文件

4042
02:14:36,000 --> 02:14:37,000
到内存里面去

4043
02:14:37,000 --> 02:14:38,000
然后再进行操作

4044
02:14:38,000 --> 02:14:40,000
然后再写回去这个过程

4045
02:14:40,000 --> 02:14:41,000
但是到现在

4046
02:14:41,000 --> 02:14:43,000
已经有这个虚拟内存

4047
02:14:43,000 --> 02:14:44,000
这个超水种

4048
02:14:44,000 --> 02:14:45,000
就绝大部分超水种

4049
02:14:45,000 --> 02:14:46,000
都已经支持这个东西了

4050
02:14:47,000 --> 02:14:48,000
不然那个 MLOK 没法写好

4051
02:14:50,000 --> 02:14:51,000
在这种情况下

4052
02:14:51,000 --> 02:14:52,000
那么我们写程序的时候

4053
02:14:52,000 --> 02:14:54,000
就可以不用考虑这些东西

4054
02:14:54,000 --> 02:14:56,000
比如说最简单的一个

4055
02:14:56,000 --> 02:14:57,000
刚才讲的一个持久化和

4056
02:14:57,000 --> 02:14:58,000
非持久化的问题

4057
02:14:59,000 --> 02:15:01,000
持久化和序列化的问题

4058
02:15:01,000 --> 02:15:03,000
就是你可以不用考虑说

4059
02:15:03,000 --> 02:15:04,000
我从内存里面读出

4060
02:15:04,000 --> 02:15:06,000
我一个比如说一个竖状结构

4061
02:15:06,000 --> 02:15:09,000
然后把它写成一个串流

4062
02:15:09,000 --> 02:15:09,000
再写到磁盘上

4063
02:15:10,000 --> 02:15:11,000
但也直接说

4064
02:15:11,000 --> 02:15:13,000
我在内存上分配一个

4065
02:15:13,000 --> 02:15:14,000
比如说一个 GB 的空间

4066
02:15:14,000 --> 02:15:16,000
然后来持久化这个数据

4067
02:15:16,000 --> 02:15:18,000
我直接把这个空间

4068
02:15:18,000 --> 02:15:19,000
映射到我内存里面去

4069
02:15:19,000 --> 02:15:20,000
然后直接在里面

4070
02:15:20,000 --> 02:15:22,000
建我的那个内存结构

4071
02:15:22,000 --> 02:15:23,000
然后超水种会在

4072
02:15:23,000 --> 02:15:24,000
适当的时候

4073
02:15:24,000 --> 02:15:26,000
把这些内存里面的数据

4074
02:15:26,000 --> 02:15:28,000
持久化到磁盘上面去

4075
02:15:28,000 --> 02:15:30,000
从而实现持久化的效果

4076
02:15:30,000 --> 02:15:31,000
但是作为一个程序员

4077
02:15:31,000 --> 02:15:32,000
你又并不用担心

4078
02:15:32,000 --> 02:15:34,000
自己再去真的写

4079
02:15:34,000 --> 02:15:36,000
那个序列化的过程

4080
02:15:37,000 --> 02:15:37,000
没错

4081
02:15:37,000 --> 02:15:40,000
而且一个需要避免的

4082
02:15:40,000 --> 02:15:41,000
practice

4083
02:15:41,000 --> 02:15:43,000
或者说一个需要避免的

4084
02:15:43,000 --> 02:15:44,000
过早优化就是

4085
02:15:46,000 --> 02:15:48,000
尽量也不要总觉得自己

4086
02:15:48,000 --> 02:15:50,000
有些东西放在内存里面

4087
02:15:50,000 --> 02:15:52,000
好像没有什么用

4088
02:15:52,000 --> 02:15:53,000
应该先把它

4089
02:15:54,000 --> 02:15:55,000
从里面挪出来

4090
02:15:55,000 --> 02:15:56,000
然后放在一个磁盘上

4091
02:15:56,000 --> 02:15:57,000
什么地方

4092
02:15:57,000 --> 02:15:58,000
然后以此来达到

4093
02:15:58,000 --> 02:15:59,000
节省内存的目的

4094
02:16:00,000 --> 02:16:02,000
这都应该交给操作系统来去

4095
02:16:02,000 --> 02:16:02,000
对这件事情也

4096
02:16:02,000 --> 02:16:05,000
通通应该让操作系统来完成

4097
02:16:05,000 --> 02:16:05,000
对

4098
02:16:06,000 --> 02:16:07,000
对其实说到

4099
02:16:07,000 --> 02:16:09,000
说到序列化

4100
02:16:09,000 --> 02:16:11,000
其实现在有很多

4101
02:16:11,000 --> 02:16:13,000
网上的云端服务

4102
02:16:13,000 --> 02:16:15,000
都提供了这样一种变成接口

4103
02:16:15,000 --> 02:16:17,000
就是你可以在程序里面说

4104
02:16:17,000 --> 02:16:18,000
比如说我用

4105
02:16:19,000 --> 02:16:20,000
什么 JavaScript

4106
02:16:21,000 --> 02:16:23,000
我 JavaScript 交给你

4107
02:16:23,000 --> 02:16:24,000
这样一个数据

4108
02:16:25,000 --> 02:16:26,000
然后你就把它存下来

4109
02:16:26,000 --> 02:16:27,000
然后给你要的时候

4110
02:16:27,000 --> 02:16:29,000
你把它原样交还给我

4111
02:16:30,000 --> 02:16:30,000
诸如此类

4112
02:16:30,000 --> 02:16:31,000
对

4113
02:16:31,000 --> 02:16:33,000
这个不光是在网页上

4114
02:16:33,000 --> 02:16:35,000
包括如果你开发 iOS 的话

4115
02:16:35,000 --> 02:16:37,000
应该它有个 core data

4116
02:16:37,000 --> 02:16:39,000
对也是做类似的事情

4117
02:16:39,000 --> 02:16:41,000
对 core data 的编程模型

4118
02:16:41,000 --> 02:16:45,000
我是觉得不是非常的直观

4119
02:16:45,000 --> 02:16:47,000
但你可以理解

4120
02:16:47,000 --> 02:16:49,000
你可以看到它试图为此

4121
02:16:50,000 --> 02:16:51,000
做出一个比较简单用的接口来

4122
02:16:51,000 --> 02:16:55,000
但是用起来还是挺麻烦的

4123
02:16:55,000 --> 02:16:55,000
我觉得

4124
02:16:55,000 --> 02:16:57,000
麻烦的点主要在哪里呢

4125
02:16:58,000 --> 02:16:59,000
啰嗦是一方面

4126
02:16:59,000 --> 02:17:00,000
但另外一方面

4127
02:17:00,000 --> 02:17:02,000
那个是因为 OBJEC C 的语法不好

4128
02:17:02,000 --> 02:17:03,000
它是

4129
02:17:03,000 --> 02:17:04,000
对

4130
02:17:04,000 --> 02:17:05,000
It's totally

4131
02:17:06,000 --> 02:17:07,000
不可避免的

4132
02:17:07,000 --> 02:17:10,000
但我觉得整个想法

4133
02:17:10,000 --> 02:17:12,000
就是把序列化和持续化这一层

4134
02:17:13,000 --> 02:17:16,000
从程序的界面里面

4135
02:17:16,000 --> 02:17:17,000
分离开来

4136
02:17:17,000 --> 02:17:19,000
我觉得这个是个挺好的想法

4137
02:17:19,000 --> 02:17:19,000
对

4138
02:17:20,000 --> 02:17:21,000
这是没错的

4139
02:17:21,000 --> 02:17:24,000
所以还是说具体到实现的问题

4140
02:17:24,000 --> 02:17:26,000
怎么去实现这一点

4141
02:17:27,000 --> 02:17:30,000
可能我还是 core data 用的不够多

4142
02:17:31,000 --> 02:17:34,000
不过 core data 的吐槽的人也不少

4143
02:17:34,000 --> 02:17:37,000
你绝对不是唯一的

4144
02:17:39,000 --> 02:17:40,000
OK

4145
02:17:40,000 --> 02:17:43,000
那么今天的啰啰嗦嗦讲了这么多

4146
02:17:43,000 --> 02:17:44,000
内存和

4147
02:17:44,000 --> 02:17:46,000
讲的其实还是有点

4148
02:17:47,000 --> 02:17:48,000
咋论

4149
02:17:48,000 --> 02:17:51,000
我觉得可能还是咱们两个工体不够

4150
02:17:52,000 --> 02:17:53,000
完了

4151
02:17:53,000 --> 02:17:55,000
以后我们还是少碰那种

4152
02:17:55,000 --> 02:17:56,000
比较 hardcore 的东西

4153
02:17:56,000 --> 02:17:59,000
比较大而硬的话题

4154
02:17:59,000 --> 02:17:59,000
对

4155
02:17:59,000 --> 02:18:00,000
我们还是应该止谈风月

4156
02:18:00,000 --> 02:18:02,000
如果要做这种话题的话

4157
02:18:02,000 --> 02:18:03,000
我觉得我们可以

4158
02:18:03,000 --> 02:18:05,000
比如说准备个两三个月

4159
02:18:05,000 --> 02:18:08,000
然后写个脚本出来

4160
02:18:08,000 --> 02:18:09,000
然后你说什么我说什么

4161
02:18:09,000 --> 02:18:12,000
每一句都要精确的

4162
02:18:12,000 --> 02:18:13,000
有案可查

4163
02:18:13,000 --> 02:18:15,000
然后每一个数据都要

4164
02:18:16,000 --> 02:18:18,000
每个数据都要核对过

4165
02:18:18,000 --> 02:18:19,000
对吧

4166
02:18:19,000 --> 02:18:20,000
比如说

4167
02:18:20,000 --> 02:18:23,000
L 2 K 的典型尺寸是多少

4168
02:18:23,000 --> 02:18:25,000
我们居然不能脱口而出

4169
02:18:26,000 --> 02:18:26,000
太丢人了

4170
02:18:26,000 --> 02:18:28,000
一兆两兆这个我知道

4171
02:18:28,000 --> 02:18:30,000
OK 两兆

4172
02:18:33,000 --> 02:18:37,000
然后这一期的话题之所以会出现

4173
02:18:37,000 --> 02:18:39,000
其实完全是受到 portal 的启发

4174
02:18:39,000 --> 02:18:40,000
我必须承认

4175
02:18:41,000 --> 02:18:44,000
另外一方面也是我之前有一波

4176
02:18:44,000 --> 02:18:46,000
由此我想到的一个

4177
02:18:46,000 --> 02:18:52,000
很有名的科幻作家叫做 Ted Chang

4178
02:18:52,000 --> 02:18:53,000
Ted Chang

4179
02:18:53,000 --> 02:18:54,000
对

4180
02:18:54,000 --> 02:18:55,000
中文名字叫江峰南

4181
02:18:55,000 --> 02:18:57,000
如果你读科幻小说的话

4182
02:18:57,000 --> 02:18:58,000
应该会知道这个

4183
02:18:58,000 --> 02:19:00,000
他这个人写过非常多的

4184
02:19:00,000 --> 02:19:02,000
很有意思的科幻小说

4185
02:19:02,000 --> 02:19:03,000
他有一部就叫

4186
02:19:04,000 --> 02:19:07,000
The Life Cycle of Software Objects

4187
02:19:08,000 --> 02:19:09,000
对怎么说

4188
02:19:09,000 --> 02:19:13,000
软件对象的生命周期

4189
02:19:13,000 --> 02:19:13,000
对

4190
02:19:13,000 --> 02:19:15,000
他里面讲的就是

4191
02:19:17,000 --> 02:19:20,000
当然这个剧情从现在看起来好像有点老

4192
02:19:20,000 --> 02:19:22,000
但他写的时候应该是挺新的

4193
02:19:22,000 --> 02:19:22,000
就是

4194
02:19:24,000 --> 02:19:26,000
大致就是讲有这么一个

4195
02:19:26,000 --> 02:19:29,000
像 Second Life 这么一个虚拟世界

4196
02:19:29,000 --> 02:19:31,000
然后里面有一个公司

4197
02:19:31,000 --> 02:19:33,000
培养出了一大堆人工智能

4198
02:19:33,000 --> 02:19:38,000
人工智能是活在 Second Life 这个世界里面的

4199
02:19:38,000 --> 02:19:39,000
当然它不叫 Second Life

4200
02:19:39,000 --> 02:19:40,000
叫另外一个

4201
02:19:40,000 --> 02:19:42,000
Digital Terror 之类的

4202
02:19:43,000 --> 02:19:44,000
数字地球之类的这么一个

4203
02:19:44,000 --> 02:19:47,000
一个虚拟世界里面

4204
02:19:47,000 --> 02:19:50,000
然后在这个虚拟世界里面跑着一些人工智能

4205
02:19:50,000 --> 02:19:52,000
然后这些人工智能

4206
02:19:52,000 --> 02:19:53,000
是真正的智能

4207
02:19:53,000 --> 02:19:55,000
就是生下来的时候

4208
02:19:55,000 --> 02:19:57,000
这些人工智能诞生的时候

4209
02:19:57,000 --> 02:19:59,000
是没有什么技能的

4210
02:19:59,000 --> 02:20:03,000
然后需要一群人类在里面训练他们

4211
02:20:03,000 --> 02:20:04,000
学习

4212
02:20:04,000 --> 02:20:05,000
然后教他们做游戏

4213
02:20:05,000 --> 02:20:07,000
然后把他们

4214
02:20:07,000 --> 02:20:09,000
就是他们有各种各样的形体

4215
02:20:09,000 --> 02:20:10,000
比如说有些是机器人形状

4216
02:20:10,000 --> 02:20:11,000
有些是鸭子形状

4217
02:20:11,000 --> 02:20:15,000
然后除此之外

4218
02:20:15,000 --> 02:20:18,000
然后就讲的是人工智能被培育起来的事情

4219
02:20:18,000 --> 02:20:20,000
然后这个文章也是

4220
02:20:20,000 --> 02:20:23,000
这篇文章也是女性视角

4221
02:20:23,000 --> 02:20:26,000
在三胖很奇怪的女性视角

4222
02:20:26,000 --> 02:20:29,000
然后讲的故事也比较

4223
02:20:29,000 --> 02:20:31,000
其实你读的话

4224
02:20:31,000 --> 02:20:33,000
你会觉得他说了很多事情都很平淡

4225
02:20:33,000 --> 02:20:36,000
比如说就讲这个主角是怎么带着这些小人工智能们

4226
02:20:36,000 --> 02:20:37,000
陪他们玩

4227
02:20:37,000 --> 02:20:41,000
然后看他们的一点点的和用户互动

4228
02:20:41,000 --> 02:20:43,000
然后直到后来有

4229
02:20:43,000 --> 02:20:46,000
把他们装到就是实体世界里面做出来的机器人

4230
02:20:46,000 --> 02:20:49,000
就把他们下载到那个机器人里面

4231
02:20:49,000 --> 02:20:51,000
然后带着他们去看

4232
02:20:51,000 --> 02:20:54,000
去体验实体的世界

4233
02:20:54,000 --> 02:20:57,000
然后以及最后人们是

4234
02:20:57,000 --> 02:20:57,000
怎样

4235
02:20:57,000 --> 02:21:01,000
他们的用户是怎样失去了对这种人工智能的兴趣

4236
02:21:01,000 --> 02:21:05,000
然后就把这些人工智能要退还

4237
02:21:05,000 --> 02:21:07,000
或者是要冻结

4238
02:21:07,000 --> 02:21:09,000
乃至销毁的这么一个过程

4239
02:21:09,000 --> 02:21:10,000
对

4240
02:21:10,000 --> 02:21:18,000
这篇文章也是有引发我做这样一期主题的动机之一

4241
02:21:18,000 --> 02:21:24,000
但是很显然可能出于资历和背景缘故

4242
02:21:24,000 --> 02:21:27,000
还准备的比较仓促做的不是特别的

4243
02:21:27,000 --> 02:21:29,000
不过

4244
02:21:31,000 --> 02:21:31,000
下次吧

4245
02:21:31,000 --> 02:21:32,000
以后对

4246
02:21:32,000 --> 02:21:33,000
下次补过来吧

4247
02:21:34,000 --> 02:21:35,000
好

4248
02:21:35,000 --> 02:21:37,000
那今天的节目就到这里为结局了

4249
02:21:38,000 --> 02:21:39,000
对

4250
02:21:39,000 --> 02:21:42,000
然后我们应该会请大家听一遍

4251
02:21:42,000 --> 02:21:45,000
这个 Still Alive

4252
02:21:45,000 --> 02:21:47,000
我们的主题曲

4253
02:21:47,000 --> 02:21:50,000
那就下期再见吧

4254
02:21:50,000 --> 02:21:51,000
拜拜

4255
02:21:51,000 --> 02:21:51,000
对

4256
02:21:51,000 --> 02:21:55,000
忘了这期播出时间的播出之后

4257
02:21:55,000 --> 02:21:56,000
应该就要圣诞节了吧

4258
02:21:58,000 --> 02:22:01,000
我们下下期应该是

4259
02:22:01,000 --> 02:22:02,000
圣诞节的那个周末

4260
02:22:02,000 --> 02:22:03,000
我们应该没有节目

4261
02:22:03,000 --> 02:22:05,000
我们是隔一周播一次

4262
02:22:05,000 --> 02:22:05,000
对吧

4263
02:22:05,000 --> 02:22:06,000
这个在意吧

4264
02:22:06,000 --> 02:22:07,000
这个在意吧

4265
02:22:07,000 --> 02:22:08,000
对

4266
02:22:08,000 --> 02:22:08,000
Anyway

4267
02:22:08,000 --> 02:22:13,000
如果下一周你过圣诞节的话

4268
02:22:13,000 --> 02:22:14,000
圣诞快乐

4269
02:22:17,000 --> 02:22:18,000
OK

4270
02:22:18,000 --> 02:22:19,000
就这样

4271
02:22:19,000 --> 02:22:19,000
OK

4272
02:22:19,000 --> 02:22:20,000
拜拜

4273
02:22:20,000 --> 02:22:21,000
拜拜

