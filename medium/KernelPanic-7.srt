1
00:00:00,000 --> 00:00:04,000
大家好 欢迎收听第七期的内核恐慌

2
00:00:04,000 --> 00:00:05,000
我是 Rail

3
00:00:05,000 --> 00:00:07,000
我是吴涛 终于第七期了

4
00:00:07,000 --> 00:00:09,000
其实我很喜欢数字

5
00:00:09,000 --> 00:00:15,000
其实今天这期节目的时间会比较奇怪

6
00:00:15,000 --> 00:00:17,000
我们是提前了很久

7
00:00:17,000 --> 00:00:18,000
你们听到的时候应该是

8
00:00:18,000 --> 00:00:20,000
圣诞节之后了

9
00:00:20,000 --> 00:00:23,000
你吴涛解释一下为什么这么干的

10
00:00:23,000 --> 00:00:25,000
因为在这个神秘的时间点

11
00:00:25,000 --> 00:00:30,000
我们还没有办法得到足够的听众反馈

12
00:00:30,000 --> 00:00:36,000
我们相信我们在上一期里面遇到了犯了很多很低级的错误

13
00:00:36,000 --> 00:00:37,000
有可能是非常常识性的错误

14
00:00:37,000 --> 00:00:42,000
但是在目前这个 time space 的 point 上面

15
00:00:42,000 --> 00:00:44,000
我们还没有这些反馈信息

16
00:00:44,000 --> 00:00:47,000
所以我们这一期暂时先不做 follow up

17
00:00:47,000 --> 00:00:51,000
但是我保证下一期大家会听到我们两个在这边

18
00:00:52,000 --> 00:00:54,000
怎么说 痛哭流泪

19
00:00:56,000 --> 00:01:01,000
垂胸顿足的道歉说我们犯了一些低级的错误

20
00:01:01,000 --> 00:01:02,000
包括上一期以及这一期

21
00:01:06,000 --> 00:01:09,000
所以这一期我们的主题是什么

22
00:01:09,000 --> 00:01:11,000
package management

23
00:01:12,000 --> 00:01:16,000
其实有一点点像上一期主题的自然延伸

24
00:01:16,000 --> 00:01:22,000
上一期我们讨论了软件或者说程序生命周期的管理

25
00:01:22,000 --> 00:01:26,000
主要还是从比较小的一个主要一点入手

26
00:01:26,000 --> 00:01:30,000
其实我一开始只是想谈内存管理

27
00:01:30,000 --> 00:01:32,000
但是没有想到后面扯到那么多

28
00:01:32,000 --> 00:01:37,000
这一期的内容其实就是当你的软件写出来

29
00:01:37,000 --> 00:01:38,000
或者说你在写软件的时候

30
00:01:38,000 --> 00:01:41,000
你会需要用到许许多多内部外用的工具

31
00:01:41,000 --> 00:01:46,000
并且你希望你的软件可以以某种比较方便的方式被别人使用

32
00:01:46,000 --> 00:01:48,000
那你就需要把它包装起来

33
00:01:48,000 --> 00:01:52,000
我们这一期主要讨论就是这个问题

34
00:01:54,000 --> 00:01:58,000
所以在开始之前我们要先解释一下什么叫做这个概念

35
00:01:58,000 --> 00:01:59,000
package management

36
00:01:59,000 --> 00:02:05,000
package 实际上是一个非常泛泛的称呼

37
00:02:05,000 --> 00:02:08,000
它是一个指涉非常不清楚的词

38
00:02:08,000 --> 00:02:10,000
在很多不同语境之下会有很多不同的意义

39
00:02:10,000 --> 00:02:16,000
比如说 OS X 来说 package 可以是指

40
00:02:16,000 --> 00:02:19,000
比如说一个 application bundle 可以是一个 package

41
00:02:19,000 --> 00:02:29,000
但是与此同时你又可以通过一种叫做.pkg 的文件来安装一个程序

42
00:02:29,000 --> 00:02:32,000
然后那个.pkg 文件也是一个 package

43
00:02:32,000 --> 00:02:40,000
对,在不同的语境下 package 的概念就是有点比较不清晰的吗

44
00:02:40,000 --> 00:02:47,000
对,然后 Java 程序员可能会非常习惯于一个 package 就是一个 jarl file

45
00:02:47,000 --> 00:02:49,000
或者是用 war file

46
00:02:49,000 --> 00:02:55,000
然后它既可以拿来用第三方库

47
00:02:55,000 --> 00:03:01,000
也可以指自己写出来的什么东西在部署的时候所打造成的一个文件

48
00:03:01,000 --> 00:03:08,000
对,就是在开发的时候我们讲的 package 和部署的时候 package 其实又不是同一个

49
00:03:08,000 --> 00:03:11,000
就相关的但并不完全一致

50
00:03:11,000 --> 00:03:14,000
对,那什么是开发时的 package 呢

51
00:03:14,000 --> 00:03:17,000
对,这个要解释一下吧

52
00:03:17,000 --> 00:03:20,000
大概可以理解为你要写一个软件

53
00:03:20,000 --> 00:03:25,000
然后你需要依赖你不是从头到尾都是用全部自己写

54
00:03:25,000 --> 00:03:28,000
你肯定要用到别人的那些什么第三方的代码

55
00:03:28,000 --> 00:03:32,000
或者是你那个语言的原生的标准库里面那些东西

56
00:03:32,000 --> 00:03:37,000
然后这些你要用的那些东西大概可以理解为一个 package

57
00:03:37,000 --> 00:03:41,000
这个时候你只要去调用那些 package 才能完成你这个软件的功能

58
00:03:41,000 --> 00:03:46,000
对,我记得小时候写程序如果需要用到别人的第三方代码

59
00:03:46,000 --> 00:03:50,000
我就直接把那代码拷贝一遍负粘贴到我的文件里就可以了

60
00:03:50,000 --> 00:03:52,000
对的什么

61
00:03:52,000 --> 00:03:55,000
这是 package management done run

62
00:03:55,000 --> 00:04:00,000
不过其实在今天我们做了很多事情

63
00:04:00,000 --> 00:04:03,000
跟这个其实在本质上也是很类似的

64
00:04:03,000 --> 00:04:06,000
就把别人的代码挪到自己的代码库里面去

65
00:04:06,000 --> 00:04:11,000
这样可以保证以后你就不用再管别人他怎么改他

66
00:04:11,000 --> 00:04:13,000
反正你有一份复本了嘛

67
00:04:13,000 --> 00:04:16,000
在你的本地的这个目录里面去对吧

68
00:04:16,000 --> 00:04:18,000
对,现在的 package management 的

69
00:04:18,000 --> 00:04:21,000
或者说在开发时的 package management 所解决的问题就是

70
00:04:21,000 --> 00:04:30,000
怎样让你不 dirty 的去拷贝别人的文件到你的工程里面去

71
00:04:30,000 --> 00:04:33,000
如果你需要依赖别人的代码

72
00:04:33,000 --> 00:04:37,000
而通过简单的复制粘贴像我们童年做的那样的话

73
00:04:37,000 --> 00:04:41,000
假如对方升级了一下他的一个功能你怎么用呢

74
00:04:41,000 --> 00:04:44,000
你还要再拷贝再粘贴一遍

75
00:04:44,000 --> 00:04:47,000
这还不是最痛苦的部分

76
00:04:47,000 --> 00:04:49,000
最痛苦的部分是

77
00:04:49,000 --> 00:04:52,000
假如你想要把别人的库扔出去的时候

78
00:04:52,000 --> 00:04:54,000
有可能你会非常苦恼的发现

79
00:04:54,000 --> 00:04:59,000
你已经不记得哪一部分是你拷贝复制粘贴进来的

80
00:04:59,000 --> 00:05:01,000
而哪一部分是你自己写的了

81
00:05:01,000 --> 00:05:03,000
这个要什么

82
00:05:03,000 --> 00:05:05,000
要有这个版本管理才能发现

83
00:05:05,000 --> 00:05:07,000
要回去找那个 log

84
00:05:07,000 --> 00:05:09,000
而在你发明版本管理

85
00:05:09,000 --> 00:05:11,000
自己发明一个版本管理系统之前

86
00:05:11,000 --> 00:05:16,000
你可能已经会先发现原来世界上有 package management 的这种东西

87
00:05:16,000 --> 00:05:20,000
然后另外一个我们常说的状态

88
00:05:20,000 --> 00:05:22,000
就是说在部署的时候

89
00:05:22,000 --> 00:05:24,000
就是所谓把软件分发给

90
00:05:24,000 --> 00:05:25,000
如果你是卖给消费者的话

91
00:05:25,000 --> 00:05:27,000
你是分发给别人

92
00:05:27,000 --> 00:05:30,000
或者是你是像我部署的服务器的软件的话

93
00:05:30,000 --> 00:05:34,000
你是要怎么把它弄倒腾到这个服务器上去运行

94
00:05:34,000 --> 00:05:37,000
这个时候的这个要求又有点不一样

95
00:05:37,000 --> 00:05:41,000
这个时候我们要求这个 package 是尽可能的

96
00:05:41,000 --> 00:05:42,000
是怎么可重复的

97
00:05:42,000 --> 00:05:44,000
就是你整个 deploy 的过程

98
00:05:44,000 --> 00:05:46,000
应该是可以重复的

99
00:05:46,000 --> 00:05:47,000
对

100
00:05:47,000 --> 00:05:50,000
那这个这么说可能稍微有点抽象

101
00:05:50,000 --> 00:05:52,000
但是如果你是一个 Windows 用户的话

102
00:05:52,000 --> 00:05:55,000
你可能会习惯于安装什么软件

103
00:05:55,000 --> 00:06:00,000
就是打开一个安装软件的 install.exe

104
00:06:00,000 --> 00:06:03,000
然后还是或者叫 setup.exe

105
00:06:03,000 --> 00:06:07,000
然后你一路回车执行一个叫做 setup visa 的东西

106
00:06:07,000 --> 00:06:10,000
然后指定一个安装的目标路径

107
00:06:10,000 --> 00:06:11,000
对

108
00:06:11,000 --> 00:06:15,000
然后它会把所有东西给你塞到那个目标下面之后

109
00:06:15,000 --> 00:06:18,000
然后你去那个目标找就可以找到你要运行的程序

110
00:06:18,000 --> 00:06:20,000
所以在 Windows 的世界里面

111
00:06:20,000 --> 00:06:23,000
我们安装程序的过程是用一个程序去安装另一个程序

112
00:06:23,000 --> 00:06:27,000
或者说你为了安装你的程序你必须创建另外一个

113
00:06:27,000 --> 00:06:31,000
你用另外一个程序把你的程序打包在一个 package 里面

114
00:06:31,000 --> 00:06:32,000
然后交给别人

115
00:06:32,000 --> 00:06:38,000
别人在同样要利用另外一个程序来解压你的程序

116
00:06:38,000 --> 00:06:41,000
然后把它安装到对方的电脑下面

117
00:06:41,000 --> 00:06:42,000
对

118
00:06:42,000 --> 00:06:46,000
这个就跟在 OS 3 下面的常用的安装方式还不太一样

119
00:06:46,000 --> 00:06:47,000
刚才你也讲了

120
00:06:47,000 --> 00:06:51,000
比如说我们通常的一种方式是通过一个 DMG 的镜像

121
00:06:51,000 --> 00:06:53,000
或者是从这个点 zip 的压缩包

122
00:06:53,000 --> 00:06:57,000
然后点出了一个点 APP 的这么一个目录

123
00:06:57,000 --> 00:06:59,000
然后这个目录整个是一个完整的程序

124
00:06:59,000 --> 00:07:03,000
你直接把它拖到你的 application 的 folder 里面

125
00:07:03,000 --> 00:07:05,000
这个事情就算完成了

126
00:07:05,000 --> 00:07:09,000
但是刚才你说那种 Windows 上面安装的方式在 OS 3 下的对比

127
00:07:09,000 --> 00:07:12,000
就是你之前也提到那个点 PKG 那种方式

128
00:07:12,000 --> 00:07:13,000
运行一个脚本

129
00:07:13,000 --> 00:07:16,000
然后把那些文件塞到你的系统的各个角落

130
00:07:16,000 --> 00:07:18,000
对主要来说

131
00:07:18,000 --> 00:07:26,000
其实我们说 Mac 下面把一个.app 的文件拖到 application 下面

132
00:07:26,000 --> 00:07:27,000
就可以得到这个

133
00:07:27,000 --> 00:07:30,000
或者说以这种方式你就完成安装

134
00:07:30,000 --> 00:07:33,000
这种安装是一种仅仅是一次拷贝而已

135
00:07:33,000 --> 00:07:37,000
你安装一个程序的方法就是通过拷贝

136
00:07:37,000 --> 00:07:40,000
而什么是点 APP 呢

137
00:07:40,000 --> 00:07:46,000
可能我觉得这是一种不同的封装层级的思路的体现

138
00:07:46,000 --> 00:07:52,000
就是在 Mac 下面所谓 app 文件实际上只是一个 folder 而已

139
00:07:52,000 --> 00:07:54,000
它只是一个文件夹而已

140
00:07:54,000 --> 00:07:56,000
但如果你把它改名成了点 APP

141
00:07:56,000 --> 00:08:00,000
并且在里面加上一个叫做 info.plist 的文件

142
00:08:00,000 --> 00:08:04,000
Mac 就会试图把它作为一个整体处理

143
00:08:04,000 --> 00:08:07,000
就是说你不能很方便的直接打开

144
00:08:07,000 --> 00:08:10,000
看到那个 APP 目录里面的内容

145
00:08:10,000 --> 00:08:12,000
但是你如果右键可以叫什么

146
00:08:12,000 --> 00:08:14,000
Show content

147
00:08:14,000 --> 00:08:16,000
Show package content

148
00:08:16,000 --> 00:08:19,000
对这个功能就可以把它当成目录展开了

149
00:08:19,000 --> 00:08:26,000
这个是我们在分发给消费者的时候的一种分发时候的 package

150
00:08:26,000 --> 00:08:28,000
然后如果在服务端的话

151
00:08:28,000 --> 00:08:33,000
这种方式就非常多了不同的安装方式了

152
00:08:33,000 --> 00:08:37,000
待会我们待会讲到不同的发行板的时候一个一个说吧

153
00:08:37,000 --> 00:08:38,000
对

154
00:08:38,000 --> 00:08:44,000
所以其实你们看到我们在 package management 的两个不同的应用场合

155
00:08:44,000 --> 00:08:47,000
但其实它们还是有一定的共性的

156
00:08:47,000 --> 00:08:49,000
就比如说至少我们要求说

157
00:08:49,000 --> 00:08:54,000
我们能够清楚的知道我们安装的是什么版本的一个 package 对吧

158
00:08:54,000 --> 00:08:55,000
对

159
00:08:55,000 --> 00:09:00,000
我们知道有什么方法可以能够删掉它能够重复的安装

160
00:09:00,000 --> 00:09:01,000
对

161
00:09:01,000 --> 00:09:04,000
或者说比如说你把某一个文件修改

162
00:09:04,000 --> 00:09:07,000
就是意外修改了你能够把那个东西再拿回来

163
00:09:07,000 --> 00:09:12,000
还有就是说你安装的多个 package 之间

164
00:09:12,000 --> 00:09:15,000
最好不要互相有影响对吧

165
00:09:15,000 --> 00:09:17,000
比如说我安装了 A 这个包

166
00:09:17,000 --> 00:09:20,000
那我在安装 B 这个包他们会不会冲突

167
00:09:20,000 --> 00:09:22,000
我们最好能避免这种事情

168
00:09:22,000 --> 00:09:24,000
就是这些基本的需求吧

169
00:09:24,000 --> 00:09:25,000
对

170
00:09:25,000 --> 00:09:28,000
你在用 windows 的时候有没有感觉到

171
00:09:29,000 --> 00:09:32,000
windows 安装程序的过程是一个很神秘的过程

172
00:09:32,000 --> 00:09:34,000
或者是很复杂的过程

173
00:09:35,000 --> 00:09:39,000
其实我到今天为止也一直不是很清楚他们到底在做什么

174
00:09:39,000 --> 00:09:42,000
我想想有些什么事情我能想得起的

175
00:09:42,000 --> 00:09:47,000
就主程序他们就作为一个就是常见的 windows

176
00:09:47,000 --> 00:09:50,000
就符合 windows 规范的安装程序

177
00:09:50,000 --> 00:09:54,000
他们把自己塞到那个叫 C 下面的 program files

178
00:09:54,000 --> 00:09:57,000
然后建一个自己公司的名字的目录

179
00:09:57,000 --> 00:10:00,000
然后在下面建一个你这个程序的名字的目录

180
00:10:00,000 --> 00:10:02,000
然后再把东西放进去

181
00:10:02,000 --> 00:10:06,000
包括你的那些什么需要依赖的软件库

182
00:10:06,000 --> 00:10:08,000
还有什么静态文件对吧

183
00:10:08,000 --> 00:10:09,000
都放在那里面去

184
00:10:09,000 --> 00:10:12,000
然后还要加什么就是用户配置

185
00:10:12,000 --> 00:10:14,000
写到什么注册表里面对不对

186
00:10:15,000 --> 00:10:18,000
现在 windows spot 里面好像又有一点什么不一样

187
00:10:18,000 --> 00:10:21,000
有个什么 apps data 这个目录了

188
00:10:21,000 --> 00:10:23,000
what 所以 windows spot 要包起注册表了吗

189
00:10:23,000 --> 00:10:24,000
不可能吧

190
00:10:24,000 --> 00:10:27,000
注册表是 windows 核心技术一部分

191
00:10:28,000 --> 00:10:29,000
这个不太清楚具体怎么样子

192
00:10:29,000 --> 00:10:32,000
但是我上次在虚拟机面装的时候

193
00:10:32,000 --> 00:10:34,000
是发现有这么一些新的

194
00:10:34,000 --> 00:10:37,000
就是新式相对于之前 windows XP

195
00:10:37,000 --> 00:10:39,000
或者是 windows 7 的时代的东西

196
00:10:39,000 --> 00:10:42,000
但这个因为我不是 windows 中度用户

197
00:10:42,000 --> 00:10:43,000
也不太清楚他怎么一回事

198
00:10:43,000 --> 00:10:46,000
app data 会不会是 app 在运行时产生的数据

199
00:10:46,000 --> 00:10:47,000
有可能

200
00:10:47,000 --> 00:10:48,000
有可能

201
00:10:48,000 --> 00:10:49,000
那个是什么 data

202
00:10:49,000 --> 00:10:51,000
我记得有什么 data roaming fold

203
00:10:51,000 --> 00:10:53,000
是拿来做这件事情的

204
00:10:54,000 --> 00:10:55,000
OK

205
00:10:55,000 --> 00:10:56,000
我也不说你

206
00:10:56,000 --> 00:10:59,000
但其实我觉得目前让我觉得

207
00:10:59,000 --> 00:11:01,000
回想起来很疑惑的一点就是

208
00:11:01,000 --> 00:11:06,000
windows 安装过程之中所产生的那些数据

209
00:11:07,000 --> 00:11:11,000
有时候在有些安装程序里面是可以看到的

210
00:11:11,000 --> 00:11:13,000
而另外一些安装程序里面是看不到的

211
00:11:13,000 --> 00:11:17,000
就比如说我记得 windows app 在安装的时候会

212
00:11:17,000 --> 00:11:18,000
跳出来一个列表

213
00:11:18,000 --> 00:11:21,000
然后不停地告诉你哪个文件被拷到哪个地方

214
00:11:21,000 --> 00:11:24,000
然后最后可以重新的去审查一遍

215
00:11:24,000 --> 00:11:27,000
这个安装程序到底干了些什么

216
00:11:27,000 --> 00:11:29,000
当然我相信 99%的人不会这么做

217
00:11:29,000 --> 00:11:31,000
但是提供了这种可能性

218
00:11:31,000 --> 00:11:34,000
而另外一些安装程序好像从头到尾就

219
00:11:35,000 --> 00:11:36,000
就一直 next

220
00:11:36,000 --> 00:11:37,000
对

221
00:11:37,000 --> 00:11:38,000
而且对

222
00:11:38,000 --> 00:11:39,000
有一个很著名的现象就是

223
00:11:39,000 --> 00:11:43,000
这个现象就是机动条从 0 到 99%需要大概一秒钟

224
00:11:43,000 --> 00:11:45,000
然后从 99 到 100%需要 10 分钟

225
00:11:47,000 --> 00:11:48,000
没算好

226
00:11:48,000 --> 00:11:49,000
对

227
00:11:49,000 --> 00:11:51,000
刚刚你讲 windows app 那种形式

228
00:11:51,000 --> 00:11:55,000
它是有一种我记得印象中是有一种专门的那种

229
00:11:55,000 --> 00:11:58,000
生成安装程序的程序

230
00:11:58,000 --> 00:12:02,000
对其实就是不同的 installer 的提供应商不同而已

231
00:12:02,000 --> 00:12:05,000
然后之前有这种很常用的那种 installer

232
00:12:05,000 --> 00:12:10,000
就是可以让你有一个列表框显示每一个步骤在干嘛

233
00:12:10,000 --> 00:12:14,000
但其实这个是非常用户不友好的一个东西

234
00:12:14,000 --> 00:12:16,000
作为一个普通用户

235
00:12:16,000 --> 00:12:19,000
你为什么要知道 windows app 装了多少个文件在哪个位置

236
00:12:19,000 --> 00:12:23,000
这个是对你来说是没有什么实际价值的信息

237
00:12:23,000 --> 00:12:25,000
但除非你有什么洁癖之外

238
00:12:25,000 --> 00:12:31,000
说你卸载的时候一定要逐个对照着那个列表把那个文件一个一个删掉

239
00:12:31,000 --> 00:12:33,000
这还是一个约定

240
00:12:33,000 --> 00:12:34,000
我也不知道

241
00:12:34,000 --> 00:12:40,000
就有时候 windows 上面提供的过渡信息在有些人看来是好事

242
00:12:40,000 --> 00:12:46,000
是一种他时刻要看到电脑在做什么

243
00:12:46,000 --> 00:12:54,000
而反过来你给他一台比较不那么 intrusive 的操作系统的话

244
00:12:54,000 --> 00:12:57,000
他会觉得这操作怎么这么安静啊

245
00:12:57,000 --> 00:13:01,000
我再用你你给我点回应好吗

246
00:13:01,000 --> 00:13:05,000
就比如说我记得刚刚学 Linux 命令行的时候

247
00:13:05,000 --> 00:13:10,000
执行一个命令他什么都不告诉你

248
00:13:10,000 --> 00:13:15,000
默认是默认这种状态是没什么可做的

249
00:13:15,000 --> 00:13:16,000
所以他就什么也不说

250
00:13:16,000 --> 00:13:19,000
这让我觉得当时非常的难以忍受

251
00:13:19,000 --> 00:13:23,000
因为在倒子下面不管干嘛他都会告诉你我干了什么

252
00:13:23,000 --> 00:13:24,000
没什么可干的

253
00:13:24,000 --> 00:13:27,000
就算没什么可干的他就告诉你说没什么可干的

254
00:13:27,000 --> 00:13:32,000
切换到刚刚切换到 Linux 是觉得好酷

255
00:13:32,000 --> 00:13:37,000
我觉得这可能也是那个什么 unix 用户和

256
00:13:37,000 --> 00:13:43,000
或者 Lay Unix 系统的用户和 Windows 用户的本质区别吧

257
00:13:43,000 --> 00:13:48,000
就是可能用 Lay Unix 用户就觉得你把这事情做了就好了

258
00:13:48,000 --> 00:13:50,000
只要没出什么问题就别来烦我

259
00:13:50,000 --> 00:13:53,000
因为我还有别的烦心的事多着呢对吧

260
00:13:53,000 --> 00:13:57,000
然后因为他们很多都是所谓早期都是什么专业用户啊

261
00:13:57,000 --> 00:13:59,000
或者那种程序员他知道在干嘛

262
00:13:59,000 --> 00:14:02,000
然后也知道结果是怎么样子

263
00:14:02,000 --> 00:14:06,000
但是像 DOS 还问的这种面向消费者的

264
00:14:06,000 --> 00:14:09,000
他可能需要一些什么存在感

265
00:14:09,000 --> 00:14:14,000
但是需要知道我花二十刀买了这个程序他干嘛了呢最后对吧

266
00:14:14,000 --> 00:14:17,000
对有回应是用户友好的一种表现

267
00:14:17,000 --> 00:14:21,000
但没有回应则是 programmatical 的一种表现

268
00:14:22,000 --> 00:14:23,000
可以这么说吧

269
00:14:23,000 --> 00:14:26,000
我不确定是不是一定用户友好的

270
00:14:26,000 --> 00:14:29,000
有可能说那有些人不要来烦我

271
00:14:29,000 --> 00:14:33,000
不至少对于一个初学者来说没有回应

272
00:14:33,000 --> 00:14:35,000
其实是一个非常费解的 behaviour

273
00:14:35,000 --> 00:14:39,000
你必须要一上来就跟他说

274
00:14:39,000 --> 00:14:41,000
这个程序如果没有回应的话

275
00:14:41,000 --> 00:14:43,000
意味着他认为自己没有什么可做的

276
00:14:43,000 --> 00:14:47,000
或者是他完成了该做的事情他就没有什么回应

277
00:14:47,000 --> 00:14:49,000
他唯一有回应的时候就是报错

278
00:14:49,000 --> 00:14:54,000
嗯哼嗯哼对就是两种不同的思想

279
00:14:54,000 --> 00:14:57,000
就看场景或者看你的应用吧

280
00:14:57,000 --> 00:15:01,000
有时候我的感觉倾向于就是

281
00:15:01,000 --> 00:15:05,000
你用一个新的软件或者是新的产品的时候

282
00:15:05,000 --> 00:15:07,000
你可能需要了解一下一些具体的状况

283
00:15:07,000 --> 00:15:09,000
但是可能也是你可以从另一个角度说

284
00:15:09,000 --> 00:15:12,000
这个产品做得不好需要我了解这么多细节

285
00:15:12,000 --> 00:15:13,000
其实没必要嘛对吧

286
00:15:13,000 --> 00:15:17,000
但另外一种就是说反正你这个工作就好了

287
00:15:17,000 --> 00:15:19,000
不要那么多废话对

288
00:15:19,000 --> 00:15:26,000
嗯对说回到我们的这个 Pakman 的话题上来

289
00:15:26,000 --> 00:15:31,000
就是还有一个问题 Windows 上面当时一直让我疑惑的是

290
00:15:31,000 --> 00:15:36,000
假如一个程序同时需要一个酷的两个版本

291
00:15:36,000 --> 00:15:38,000
Windows 到底是怎么解决的

292
00:15:38,000 --> 00:15:40,000
这不是没法解决吗

293
00:15:40,000 --> 00:15:43,000
他们后来才会出现那个叫做什么 DLL hell

294
00:15:43,000 --> 00:15:47,000
对 DLL hell 具体来说其实就是

295
00:15:47,000 --> 00:15:53,000
A 软件需要某一个酷的假版本

296
00:15:53,000 --> 00:15:55,000
B 软件需要酷的已版本

297
00:15:55,000 --> 00:15:58,000
那 Windows 会同时保留假一两个版本对不对

298
00:15:58,000 --> 00:16:01,000
应该是这样的对

299
00:16:01,000 --> 00:16:03,000
那假一两个版本的差别在哪

300
00:16:03,000 --> 00:16:07,000
是在用户名上文件名上有一个版本号的差别吗

301
00:16:07,000 --> 00:16:10,000
这个我不太清楚 Windows 怎么具体怎么做

302
00:16:10,000 --> 00:16:16,000
但是这个在不同的这种环境里面都是存在的

303
00:16:16,000 --> 00:16:19,000
这个最麻烦的问题是因为同一个软件不同版本

304
00:16:19,000 --> 00:16:21,000
它可能是互不兼容的

305
00:16:21,000 --> 00:16:25,000
然后如果你刚才说那情况其实还好了

306
00:16:25,000 --> 00:16:27,000
A 程序的时候它掉 A 假版本好了

307
00:16:27,000 --> 00:16:29,000
B 程序掉 E 版本好了

308
00:16:29,000 --> 00:16:30,000
互相不冲突

309
00:16:30,000 --> 00:16:32,000
比较坑的是这种

310
00:16:32,000 --> 00:16:34,000
是不是你自己要写一个 A 程序

311
00:16:34,000 --> 00:16:39,000
然后你可能需要某个酷的 1.0 版本

312
00:16:39,000 --> 00:16:44,000
然后你同时还要使用另外一个酷的 B

313
00:16:44,000 --> 00:16:49,000
然后 B 它可能需要同样你依赖酷的 1.2 版本

314
00:16:49,000 --> 00:16:51,000
这个时候你就很坑了

315
00:16:51,000 --> 00:16:54,000
你就是要同时支持不同的

316
00:16:54,000 --> 00:16:56,000
在同一个程序里面

317
00:16:56,000 --> 00:16:59,000
你要依赖同一个软件酷的不同的版本

318
00:16:59,000 --> 00:17:02,000
就是会出现那种交叉

319
00:17:02,000 --> 00:17:04,000
还有这种这种这种

320
00:17:04,000 --> 00:17:07,000
怎么形容比较好

321
00:17:07,000 --> 00:17:09,000
循环依赖

322
00:17:09,000 --> 00:17:11,000
也不叫循环

323
00:17:11,000 --> 00:17:12,000
会是什么叫循环

324
00:17:12,000 --> 00:17:14,000
有可能会是循环

325
00:17:14,000 --> 00:17:16,000
反正就很糟糕

326
00:17:16,000 --> 00:17:21,000
脑中立刻出现了一个错综复杂的树状图

327
00:17:24,000 --> 00:17:26,000
如果是个树还好

328
00:17:26,000 --> 00:17:30,000
它可能是个永巷图

329
00:17:30,000 --> 00:17:32,000
就很搞笑

330
00:17:32,000 --> 00:17:34,000
对

331
00:17:34,000 --> 00:17:36,000
Linux 上面就没有 Dependency Help

332
00:17:36,000 --> 00:17:38,000
就没有 DHL Help

333
00:17:38,000 --> 00:17:39,000
其实也有吧

334
00:17:39,000 --> 00:17:40,000
其实也是有的

335
00:17:40,000 --> 00:17:42,000
是现在我们大部分用的发行板

336
00:17:42,000 --> 00:17:45,000
它都是通过原生的

337
00:17:45,000 --> 00:17:48,000
他们一般每个发行板会自带一个包管的系统

338
00:17:48,000 --> 00:17:52,000
然后那个包管的系统会想办法去解决这些冲突

339
00:17:52,000 --> 00:17:53,000
这些之类的问题

340
00:17:53,000 --> 00:17:56,000
而且那个发行板的维护者

341
00:17:56,000 --> 00:17:58,000
他在打包的时候

342
00:17:58,000 --> 00:18:00,000
他也会考虑说这个问题

343
00:18:00,000 --> 00:18:01,000
比如说你

344
00:18:01,000 --> 00:18:03,000
他比如说拿 Dependency Help 来举例子

345
00:18:03,000 --> 00:18:06,000
他可能我发行的这个版本里面

346
00:18:06,000 --> 00:18:08,000
我把所有的都测过

347
00:18:08,000 --> 00:18:10,000
他们互相安装应该是没有问题的

348
00:18:10,000 --> 00:18:15,000
但是你如果有那种不同版本的这种酷的需求的话

349
00:18:15,000 --> 00:18:18,000
它会通过不同的文件名称不同路径来实现

350
00:18:18,000 --> 00:18:21,000
具体来说其实就是

351
00:18:21,000 --> 00:18:25,000
假如在 Linux 上面有一个

352
00:18:25,000 --> 00:18:28,000
就是和 Windows 一模一样的困境的话

353
00:18:28,000 --> 00:18:35,000
Linux 会支持你链接到不同版本的酷上面

354
00:18:35,000 --> 00:18:39,000
而这些酷每一个酷会有一个默认的版本

355
00:18:39,000 --> 00:18:41,000
对

356
00:18:41,000 --> 00:18:43,000
一般会是用会用那个吧

357
00:18:43,000 --> 00:18:45,000
会用那个软链接来实现

358
00:18:45,000 --> 00:18:47,000
会用符号链接来实现

359
00:18:47,000 --> 00:18:52,000
有时候我在用 Dependency 的时候

360
00:18:52,000 --> 00:18:57,000
需要升级某一个我想要的工具到某一层的版本

361
00:18:57,000 --> 00:18:59,000
比如说 Win 吧

362
00:18:59,000 --> 00:19:04,000
然后使用其内置的包管理工具升级的时候

363
00:19:04,000 --> 00:19:07,000
包管理工具说这个东西依赖于那个东西

364
00:19:07,000 --> 00:19:11,000
但是那个东西的版本已经过旧了

365
00:19:11,000 --> 00:19:13,000
所以你需要一起升级那个东西

366
00:19:13,000 --> 00:19:15,000
那我说好吧那就一起升级它好了

367
00:19:15,000 --> 00:19:19,000
可是升级的时候又会说这个东西会安装那个

368
00:19:19,000 --> 00:19:22,000
就是 B 会再安装 C 的另外一个版本

369
00:19:22,000 --> 00:19:26,000
而 C 的另外一个版本在你这边会跟 D 的什么东西冲突

370
00:19:26,000 --> 00:19:30,000
然后我就说啊怎么也是有这样的问题

371
00:19:30,000 --> 00:19:34,000
所以这样问题其实在各个平台之下都是很难避免的

372
00:19:34,000 --> 00:19:35,000
可以说

373
00:19:35,000 --> 00:19:38,000
对其实我一直有一点想不明白

374
00:19:38,000 --> 00:19:44,000
比如说为什么我们这点可能在 Linux 上面比较明显

375
00:19:44,000 --> 00:19:46,000
就是我们经常会你装一个软件你会发现

376
00:19:46,000 --> 00:19:51,000
它会依赖一堆其他乱七八糟的其他的软件或者是酷爱好

377
00:19:51,000 --> 00:19:55,000
然后 Linux 的大部分的发行版本的做法是说

378
00:19:55,000 --> 00:19:57,000
这个我们发行版做的时候

379
00:19:57,000 --> 00:19:59,000
就会把这个东西考虑好他们之间的依赖关系

380
00:19:59,000 --> 00:20:01,000
然后我们会告诉你怎么去

381
00:20:01,000 --> 00:20:04,000
会有一套算法去解决这个依赖问题

382
00:20:04,000 --> 00:20:08,000
但其实你会发现这个时候你也会遇到那种情况

383
00:20:08,000 --> 00:20:15,000
就是你升级到某一个它没有被发行版在那个版本支持的时候

384
00:20:15,000 --> 00:20:18,000
你就没有办法升级你得冒很大的风险去打破这个

385
00:20:18,000 --> 00:20:20,000
或者用自己编译的包嘛

386
00:20:20,000 --> 00:20:22,000
那我就不明白了为什么

387
00:20:22,000 --> 00:20:27,000
在现在你直接装一个软件你把所有的依赖都打包好

388
00:20:27,000 --> 00:20:30,000
不要去和别人共享不就好了吗

389
00:20:30,000 --> 00:20:36,000
这个我觉得还是出于一个节省空间的考虑吧

390
00:20:36,000 --> 00:20:41,000
就如果你打包进去你自己需要那个酷

391
00:20:41,000 --> 00:20:44,000
而这个酷其实很多很多其他程序都需要

392
00:20:44,000 --> 00:20:45,000
你总要找出一个界限吧

393
00:20:45,000 --> 00:20:50,000
就是哪到具体到什么酷上你是一定要自己打包进去

394
00:20:50,000 --> 00:20:53,000
这个有这么一个问题啊

395
00:20:53,000 --> 00:20:57,000
就是说如果这个的理由是因为为了节省空间的话

396
00:20:57,000 --> 00:21:01,000
那在现代硬件条件下根本就已经不成立了

397
00:21:01,000 --> 00:21:05,000
你现在磁盘你动则多少一两个 T 对吧

398
00:21:05,000 --> 00:21:07,000
其实那个程序多大点空间

399
00:21:07,000 --> 00:21:10,000
不但并不仅仅是存储空间还有传输空间你需要考虑进去

400
00:21:10,000 --> 00:21:15,000
假如说我对呀我这个包从事无巨细

401
00:21:15,000 --> 00:21:20,000
从 Libc 一直到所有我可能用到的包我全都打包在一起

402
00:21:20,000 --> 00:21:25,000
给用户下载这个好像有点有点二吧

403
00:21:25,000 --> 00:21:32,000
虽然是这么说但是其实你看在 LS 10 下面的大部分也是这么干的呀

404
00:21:32,000 --> 00:21:38,000
对吧其实倒是他们我后来也专门去想过这个问题

405
00:21:38,000 --> 00:21:42,000
也看了一些别人的说法其实有一个事情倒是我觉得是可以理解的

406
00:21:42,000 --> 00:21:45,000
就是因为你知道 Linus 这种开放的系统吗

407
00:21:45,000 --> 00:21:52,000
他希望如果你在使用某个软件某个软件酷的时候发现了有问题你可以去修正它

408
00:21:52,000 --> 00:21:56,000
那么他希望你把这个修正比如 Bugfix 能够也

409
00:21:56,000 --> 00:22:03,000
因为你做 Bugfix 其实在在从某种意义上来说是在帮助编写这个软件嘛对吧

410
00:22:03,000 --> 00:22:07,000
那么他希望把这种成果这种劳动的工作不要浪费掉

411
00:22:07,000 --> 00:22:16,000
就是你能够在你使用那个版本修正之后你也向他的一个上游就是这个原作者那里能够把这个整合进去

412
00:22:16,000 --> 00:22:22,000
这样的话大家都可以享受到你修改这个 Bugfix 带来的好处嘛

413
00:22:22,000 --> 00:22:29,000
对但我是觉得就是这是一种人人为我为人人的精神状态

414
00:22:29,000 --> 00:22:33,000
对对我就说这个他们的他们的就是究其原因他们的理念就是这样子嘛

415
00:22:33,000 --> 00:22:39,000
那么同样的道理如果每个程序都是打包自己的依赖的那东西

416
00:22:39,000 --> 00:22:46,000
那么他可能肯定会出现比如说同样你的这个两个程序会依赖比如说同一个 OpenSSL 的这个包对吧

417
00:22:46,000 --> 00:22:51,000
然后他可能是依赖了不同的版本但是可能比如说他 OpenSSL 发现一个安全漏洞

418
00:22:51,000 --> 00:22:56,000
然后某个系统升级的时候就把它升了但是如果你用的是自己打包到把我的话

419
00:22:56,000 --> 00:23:02,000
那你可能你必须再重新发布一下你这个软件你这个才会有那个安全补丁打上去

420
00:23:02,000 --> 00:23:09,000
但如果你把这个事情交给系统来做就是说这个系统说哎我把这个整个你们需要用到的 OpenSSL 这个包的补丁都打了

421
00:23:09,000 --> 00:23:16,000
你们只要重启一下就重新这个 App 关掉重新启动一下就可以享受到这个带来的安全的好处

422
00:23:16,000 --> 00:23:22,000
而不是说要等每一个开发者重新去做一遍嘛就这里其实也是有一定的劳动力上面的节奢

423
00:23:23,000 --> 00:23:31,000
对所以说其实这是一个取舍子有一个取舍在里面有个键和 trade off 就是你对要么选择

424
00:23:31,000 --> 00:23:40,000
同时发布更多的依赖来避免用户可能产生的包充图的问题

425
00:23:40,000 --> 00:23:46,000
而另一方面你也可以选择尽量减少自己所发布的软件

426
00:23:46,000 --> 00:24:01,000
其内置的内部包括的依赖连来享受这种有一个平台吧加上平台在那边的便捷和稳定性或者说安全性

427
00:24:01,000 --> 00:24:07,000
对这也可以看到就是这样讲这两种不同的思路和这个做法

428
00:24:07,000 --> 00:24:15,000
就一般像那种像什么商用的就是有消费者级别用的然后是为了简单方便然后互相不冲突的话

429
00:24:15,000 --> 00:24:23,000
会采用像刚才讲的把所有的东西都打包到自己里面去然后你就依赖于一个比较稳定的系统提供你的一些包

430
00:24:23,000 --> 00:24:28,000
像 Mac 上面就是这样子 Windows 上面应该很多也是这样子的因为它要减少这个下载的体积嘛

431
00:24:28,000 --> 00:24:36,000
赶紧说这是一个原因之一但是像 Linux 这种发行版它很多就是说我们整个系统都是开源的对吧

432
00:24:36,000 --> 00:24:44,000
我们肯定是希望能够把这种就是能够把各种合力都集中起来就不要大家都去自己搞一份了

433
00:24:44,000 --> 00:24:55,000
对但实际上现在 Linux 社区面临一个问题是 Linux 已经越来越不是一种人人为我为人的模型了

434
00:24:55,000 --> 00:25:09,000
就是有很多的企业级的用户在用 Linux 而从来他们基本上是不会去考虑或者是有这个利益驱使让他们能够把自己的某些修正反馈给上流的

435
00:25:09,000 --> 00:25:16,000
对于他们来说 Linux 最重要的就是不要有冲突然后部署起来简单快捷好用

436
00:25:16,000 --> 00:25:23,000
就能够稳定可靠的运行就好了不要我才不跟你扯那些什么回不回归道上游去是不是

437
00:25:23,000 --> 00:25:24,000
对没错

438
00:25:24,000 --> 00:25:28,000
其实这个行为是会被谴责的吧

439
00:25:28,000 --> 00:25:41,000
也不是吧因为毕竟你看很多 Linux 发行商 Red Hat 直流他们其实很大一部分工作或者很大一部分利润的来源就来自于对于企业级用户提供支持

440
00:25:41,000 --> 00:25:47,000
所以其实是有人来付钱让他们来做是让用户满意的

441
00:25:48,000 --> 00:25:56,000
对对还是根据你这个需求来嘛就是说如果你需求是稳定可靠的话你可能要考虑一下采取刚才那种方式

442
00:25:56,000 --> 00:26:10,000
就是你宁可放弃别人帮你修复了这个 bug 带来的好处你也要说我不管了那个风险太大了对吧你改一改说不定我这个应用就 crush 了

443
00:26:10,000 --> 00:26:11,000
对

444
00:26:11,000 --> 00:26:13,000
还是追求那个是第一目标嘛

445
00:26:13,000 --> 00:26:14,000
嗯

446
00:26:14,000 --> 00:26:25,000
不过这也说到 Linux 我们可以这里就顺便提一下就是在大部分的这种比较大的 Linux 发行版它都有自己的一个一套系统吧

447
00:26:25,000 --> 00:26:27,000
一套这个什么包管理系统

448
00:26:27,000 --> 00:26:28,000
对

449
00:26:28,000 --> 00:26:39,000
然后这里可能比较著名的两个一个是以 Debian 为首的那个叫 DB 那个体系然后一个是 Red Hat 为头的叫什么 RPM

450
00:26:39,000 --> 00:26:58,000
对 RPM 最开始是 Red Hat Package Management 的缩写吧但后来现在好像 somehow 缩写变了变成就叫 RPM Package Management System 就是它变成了一个像 GNU 那样的叫什么 recursive acronym

451
00:26:58,000 --> 00:27:00,000
对对对

452
00:27:00,000 --> 00:27:02,000
就不然就

453
00:27:02,000 --> 00:27:14,000
那么其实有一个问题啊我其实是没有怎么接触过这个 RPM 这套体系的我因为大部分都是在 Debian 或者是 Bundle 系统上面用

454
00:27:14,000 --> 00:27:18,000
所以我觉得用 Debian 还挺顺手的就我不知道你有没有接触到 RPM

455
00:27:18,000 --> 00:27:29,000
我在进入目前的公司之前也是从来没有接触过 RPM 或者说接触过但非常有限但是我们公司目前在用 CentOS

456
00:27:29,000 --> 00:27:35,000
所以在服务器的环境上面的确是在跑 RPM

457
00:27:35,000 --> 00:27:48,000
但我的所有的私人的包括 VPS 或者是讯息全都是 Debian 所以我也可以说算是一个 Debian 的阵营的人吧

458
00:27:48,000 --> 00:27:53,000
其实挺可笑的就是 Debian 和 RPM 都可以都可以用 Flamor

459
00:27:53,000 --> 00:27:56,000
这个还是很大的一个坑

460
00:27:57,000 --> 00:28:10,000
知乎上之前有一个也是这个坑吧有写的就是两边都有这个有支持 Debian 这一派的然后有支持 RPM 这一派的他们在那边吵

461
00:28:10,000 --> 00:28:20,000
当然这个吵也不是中国首次了也是什么很多国外地方都已经吵过然后中国的 Ninux 社区早就吵过无数遍了

462
00:28:20,000 --> 00:28:27,000
不过最近就是前一阵子吧主上又在吵这个事儿但是因为我自己个人并没有什么太多的经验呢

463
00:28:27,000 --> 00:28:32,000
所以我觉得没什么特别感觉如果没有什么经验我们可以直接跳过这个话题

464
00:28:32,000 --> 00:28:44,000
对总结来说就是我的印象好像是做运为的一方好像会比较偏向于 RPM 对然后做开发这一方会觉得 Debian 比较好

465
00:28:44,000 --> 00:28:56,000
因为 RPM 比较强调于怎么说呢就是强调一个包一定要来自于 upstream 然后一定要正统然后一定不能是 patch 过的

466
00:28:56,000 --> 00:29:08,000
然后就是企业级的部署用 RPM 相对来说无痛一点而 Debian 包的优点则是它相对来说一般比较新

467
00:29:09,000 --> 00:29:17,000
然后它可以在包里面加上 patch 然后其实我作为一个用户我看了这么久我的理解就是说

468
00:29:17,000 --> 00:29:26,000
因为作为开发者你可能会经常需要一些比较稍微新一点的工具对吧对或者你需要用到一些比较方便安装的东西

469
00:29:26,000 --> 00:29:36,000
但是就是 Debian 可以让你比较方便的安装也不叫最新吧或者是较新的版本然后能够比较方便的就做一些修改然后再发布出去

470
00:29:36,000 --> 00:29:42,000
对 RPM 包你刚才讲就是首先它包的数量应该是比 Debian 的包要少得多

471
00:29:42,000 --> 00:29:45,000
小心说话说不定就要更早

472
00:29:45,000 --> 00:29:54,000
OK 我应该但这点我是看到就是在草的两边对这个事情都没有异议的这个应该还是比较安全的一个说法

473
00:29:54,000 --> 00:30:03,000
然后就说但是它每一个就是它有的包的那个就是如果它有包是有的话它是做得不错就是稳定可靠

474
00:30:03,000 --> 00:30:06,000
对而且反复经过很多次测试

475
00:30:06,000 --> 00:30:19,000
就我听过一个版本就说所谓 Debian 的 Stable 就是 Debian 的 Stable 版本其中的测试其实也不是很多啊就真的不算不得真的是 Stable

476
00:30:19,000 --> 00:30:22,000
因为还是比较不稳定的

477
00:30:22,000 --> 00:30:31,000
那个 Debian 的就是也很简单它也不叫什么测试就是它先测一测然后放到那个什么 unstable 吧还是哪里

478
00:30:31,000 --> 00:30:38,000
然后再到 Test 里面再看看有什么 bug 没有稳定的话就再就挪到那个 Stable 里面去了吧应该是这么一个流程

479
00:30:38,000 --> 00:30:49,000
因为它本来就是一个并不是像 RedHead 那种有这种企业能够去专门去做这种事情还是靠这个大家这个维护者虽然有很多很多啊

480
00:30:49,000 --> 00:31:02,000
去做每个做还是一个比较相对松散吧我觉得对对对说到这个 Debian 的发行版后面好像的确没有一个一个一个怎么说财团在支持

481
00:31:02,000 --> 00:31:09,000
对那就是 Debian 是一个就靠社区嘛对就不像那个 RedHead 还有有这个公司的商业支持

482
00:31:10,000 --> 00:31:19,000
但就这类问题就是说啊到底商业支持能到什么程度啊或者是它支持的是不是靠你需要的这就是另外一回事

483
00:31:19,000 --> 00:31:30,000
反正就是只要你肯花钱问题总是可以解决的现在问题是说没钱的时候怎么办对啊那就有这么两个问题

484
00:31:30,000 --> 00:31:34,000
还有一个叫 YAM 是哪里面的

485
00:31:34,000 --> 00:31:44,000
YAM 是就是这么这么说吧就是 APT 是 Debian 的高层嘛 Debian 包系统就是通过最底层的工具是 D-Package

486
00:31:44,000 --> 00:31:53,000
然后 RPM 包的管理器就叫 RPM 但是 APT 是基于 D-Package 的一个比较高层管理工具

487
00:31:53,000 --> 00:32:06,000
它会去帮你做什么 Dependency Management 之类的而 YAM 和 Zipper 则是分别来自于 RedHead 和 Suzer 的两个基于 RPM 管理工具的高层工具

488
00:32:06,000 --> 00:32:15,000
OK 对我这个也是一个挺有趣的一个事情啊就是他们我们会把这个包管理分的层级分得很细

489
00:32:15,000 --> 00:32:24,000
就跟你说有些底层的工具去做一些最基础的事情然后上面高层工具去做一些把这个整个流程变得没有那么繁琐

490
00:32:24,000 --> 00:32:31,000
然后界面对用户友好那么一丁点的事情对我觉得这个友好的其实不是就是不是一丁点

491
00:32:31,000 --> 00:32:40,000
不是一丁点因为比如说 APT 这一套工具 APT 这套工具可以帮你自动去分析这个包需要依赖用哪些东西

492
00:32:40,000 --> 00:32:51,000
然后自动帮你给出一个解决依赖的方案之类的如果你自己要一个一个用 D-Package 的工具去搞的话

493
00:32:51,000 --> 00:32:54,000
或者 RPM 自己去弄的话其实是非常非常繁琐的

494
00:32:54,000 --> 00:33:03,000
我记得对我刚上大学的时候摆弄 Linux 的当时的疑点之一就是安装程序真的一定要有 RPM 吗

495
00:33:03,000 --> 00:33:09,000
然后为什么就不能有一个什么东西给我然后我双击一下就安好了呢

496
00:33:09,000 --> 00:33:18,000
现在还是不能你还是得敲几个命令然后让他安装这个和那个你得知道那个命令是什么

497
00:33:18,000 --> 00:33:26,000
然后你得知道那个命令的参数怎么样然后如果一切正常在大部分情况下应该是也正常他能够顺利的给你安装完没问题

498
00:33:26,000 --> 00:33:29,000
但如果他报错了然后你怎么办

499
00:33:29,000 --> 00:33:39,000
对但这个时候就经验就要 kick in 了经验就要拍照了对我有这样一个印象就是在早期 Windows 安装程序

500
00:33:39,000 --> 00:33:45,000
在 Windows 上面安装程序或者说在 Mac 上面安装程序要远远方便于在 Linux 上面

501
00:33:45,000 --> 00:33:56,000
但是从某一个时间点开始我 somehow 得到的这种印象就是在 Linux 上面得到我想要的工具反而要比 Windows 上面简单了

502
00:33:56,000 --> 00:34:05,000
因为 Linux 比如说 Debian 我想要用什么东西然后比如说我在网上看别人说这个工具很好用

503
00:34:05,000 --> 00:34:12,000
然后我就直接 ApptKey 上 Search 我要找的东西在那然后 ApptGetInstall 我有了

504
00:34:12,000 --> 00:34:23,000
可是在 Windows 上面就要先去网站下载一个东西然后双击那个文件然后一路 Next 然后最后才要去双击什么一个快捷方式之类的

505
00:34:23,000 --> 00:34:35,000
才可以运行我需要的东西就是在某一个时间点 Linux 社区或者是 Linux 文化创造出了这么一种自动化安装某一个傻瓜性

506
00:34:35,000 --> 00:34:38,000
傻瓜是一条龙安装软件的功能

507
00:34:39,000 --> 00:34:46,000
对或者你可以从某种角度这么讲就是我们现在包括 IOS 上面那个 App Store 也好还是在 Mac 上面的 App Store 也好

508
00:34:46,000 --> 00:34:57,000
还包括 Windows 现在也在他们也有个 Windows App Store 里面其实他们做的事情就是把 Linux 这种包管理器就是各个发行板的包管理器的功能

509
00:34:57,000 --> 00:35:07,000
通过一种图形化的方式比较友好的呈现给普通消费者而不是说只是像我们这种去维护什么后端的或者用 Linux 的这种小众的 Geek 用户

510
00:35:07,000 --> 00:35:21,000
对没错所以从这个意义上讲 Linux 对于人类的最大贡献之一就是发明了 App Store 的某种 Geek 方式的某种 Hardcore 形式

511
00:35:21,000 --> 00:35:33,000
所以我们刚才现在讲现在在谈的这些各种发行板的包管理器的话其实我们就等同于是在讲某个发行板的 App Store 一样

512
00:35:33,000 --> 00:35:42,000
然后对我觉得你刚才说那点很好就是之前最开始我接触 Linux 确实是非常对普通用户不友好

513
00:35:42,000 --> 00:35:55,000
因为那个时候也不是特别熟悉然后就慢慢去摸索有些东西完全不懂就是概念上都不一样跟 Windows 上面的那种那种逻辑啊那种你对这个世界的认知都是不一样的

514
00:35:55,000 --> 00:36:02,000
后来它慢慢改嘛我印象中大概是在就我拿一个 5 Buntu 这个有可能它有那个年份的时间比较清楚

515
00:36:02,000 --> 00:36:17,000
我觉得大概是在 5 Buntu 9 和 10 大概之后就是 10 年左右开始在起码跟我个人使用的经验来讲在 5 Buntu 这种就是 Debian 系统上安装程序是一个相当还蛮愉悦的体验

516
00:36:17,000 --> 00:36:24,000
就是越来越少遇到包管理器不能帮你解决的这种版本冲突的时候就现在基本上很少遇到

517
00:36:24,000 --> 00:36:31,000
对极可以感受到它的整个工具有一套慢慢磨合好了这样一个过程在里面

518
00:36:31,000 --> 00:36:45,000
对对不过不过但是这里还是有一个小小的代价啊就是刚才讲你说哎现在你什么去一个在 apt 里面搜一下然后找装个软件很方便但问题是说这个是有前提的

519
00:36:45,000 --> 00:36:57,000
前提就是首先这个软件得是在 apt 那个那个仓库里面能找到的就是有人把它提交上去了要么是这个软件的作者也好要么是一个第三方的这个发行板的这个维护的人员把它加进去了

520
00:36:57,000 --> 00:37:03,000
但如果你要找一个不是在那里面的程序的话就这个过程还是蛮辛苦的

521
00:37:03,000 --> 00:37:26,000
对这个就比较算有一个叫什么积攒动量的过程吧就是当你这个软件包管理系统大到一个一定程度那么你可以理解为任何一个不会在这个 apt source 就是 apt 的原仓库之中出现的软件都不是什么太大或者是值得你去新来的软件

522
00:37:27,000 --> 00:37:37,000
你说这个要小心哦因为有些很小众的软件它可能只是因为作者也没怎么去维护它嘛因为可能比较简单或者怎么样也好

523
00:37:37,000 --> 00:37:39,000
对或者比较偏专一点

524
00:37:39,000 --> 00:37:50,000
如果这个软件简单到不需要 apt 来安装的话那你很可能安装它的过程也不会比使用 apt 安装其他软件复杂多少

525
00:37:50,000 --> 00:38:12,000
对这是一个这个是一个不错的这个 argument 但是有些是也软件挺复杂这个我印象还蛮深的就是我不知道你有一段时间我在经常折腾一些视频的东西嘛然后你知道在 linux 处理视频到目前为止还不是一个比较好的体验所以它在这一块还是比较弱的

526
00:38:12,000 --> 00:38:26,000
那比如说最简单一个例子你要重新封装像 mp 4 啊这些视频的一些格式它会用到一些软件包然后这些软件包呢因为一个是因为版权的原因它不能够直接提供这种二进制的发行版

527
00:38:26,000 --> 00:38:51,000
另外一个就是它的有些可能用到的这种代码它可能跟某一个发业发行版的这个授权协议有点不接拥就是它就处于这种比较尴尬的状态就是爹娘都不爱你就是发行版的维护者没法把它装没法把它加进去因为有这个这个软件协议的问题然后他自己又没有没有没有办法提供二进制的版本你得自己去下载圆满来包因为有那个法律的问题对

528
00:38:51,000 --> 00:39:20,000
就遇到这种情况你就很沮丧你做一个用户的话你只能想办法说啊好吧那我总不能怎么去把那个他的 source 抓回来然后根据他的手册一个一个去安装啊这里就就是提到这么一个概念就是说从安装别人给你包好的软件包和是从这个直接那个软件的原始出处去下载它的原文件回来从自己自行编译安装这是两种比较大的区别吧

529
00:39:20,000 --> 00:39:37,000
对这是这可能也是当初从 Windows 切换到 Linux 上面的一个很大的迷思就是当时我的理解是在 Linux 上面你要安装一个程序的唯一方法就是先找到这个程序的原代码然后自己在 Linux 上面编译它

530
00:39:37,000 --> 00:39:50,000
但是我当时我一方面觉得这个方向法实在是太酷了然后那个方面又觉得这不是有一点就是你不觉得为什么就为什么呢为什么你不能给我一个已经编译好的二年程序让我来运行的

531
00:39:51,000 --> 00:40:00,000
这里其实又有涉及到另外一个问题啊就是有些人会觉得我要有原代码然后因为你知道很多软件在编译的时候就会有各种各样的选项嘛

532
00:40:00,000 --> 00:40:13,000
有人会觉得说我装这个软件我只需要编译我需要的那部分功能然后我不需要那部分功能我就不编译这样我的代码会出来结果会小然后可能运行的会快一点

533
00:40:13,000 --> 00:40:26,000
或者说更从一个务实的角度来说如果我这个软件包里面没有那些我不需要的勇于的代码那么是不是我可以在某种程度上减小我的安全的这个叫做暴露的被攻击的面对吧

534
00:40:26,000 --> 00:40:43,000
对啊就这也是一种想法然后另外一种想法就是说如果每一个软件你都要根据你自己的方法去定义一遍这个安装的就编译的选项那么会导致所同一个软件的所有男生的那个选项安装的最终结果都是有一点点不一样的

535
00:40:44,000 --> 00:40:57,000
这段的话会导致支持起来就是软件作者给你提供一定的支持或者是你要出错就非常困难因为别人很可能没办法在他那个编译的结果上重现你的问题嘛

536
00:40:57,000 --> 00:41:03,000
对 cannot reproduce won't fix 这是所有的软件维护者最喜欢选的一个选项

537
00:41:03,000 --> 00:41:27,000
对对所以这里其实其实也看就是在自由灵活和这个普就是你要什么你要定制化和你要用这种大众产品的之间也是有一个取舍的就是这个取舍就是说定制化当然好处刚才也讲了比如说有可能可能可能更安全可能性能更好可能更灵活对吧但是你要牺牲的就是这个可维护性嘛

538
00:41:28,000 --> 00:41:37,000
另外一个讲的就是说大众产品说那我大大都一个版本有问题的话我们都在这个一般一个版本里面修就一个一个一个编译方式出来修修好大家都能够受益对吧

539
00:41:37,000 --> 00:41:40,000
所以这是一个也是两种不同的思路吧对

540
00:41:40,000 --> 00:41:49,000
嗯但是其实并不是所有的包管理器都是从这个二进制的其实大部分都不是二进制的方式吧

541
00:41:49,000 --> 00:42:05,000
现在很难说了一半一半一半一半吧但至少在 BSD 上面 BSD 的 Ports 基本上还全都是以获得圆码的方式现编译的方式来来安装软件的

542
00:42:05,000 --> 00:42:17,000
对这这点我觉得其实当时我接触的时候觉得还是蛮特别的哈就是因为首先一个就是 BSD 的那个就就是以那个 FreeBSD 这个这个例子来说因为以前用过

543
00:42:17,000 --> 00:42:24,000
就他那个叫做 Ports System 就比较他做得比较好因为首先这个 FreeBSD 这个系统整个维护的比较好

544
00:42:24,000 --> 00:42:40,000
因为他是一个他不像 Linux 这种是一个内核和这个 User Space UserLand 是分开的对他是两两波人马在维护然后这个发行板是说要把这两个包在一起然后给你一个定制的产品

545
00:42:40,000 --> 00:42:45,000
但就会导致很多各种各样奇奇怪怪的发行板也会导致各种各样的什么包管理的问题

546
00:42:46,000 --> 00:42:58,000
但 FreeBSD 这个起码他是有一套人马在维护的然后他可以确保说他给你的这套这个 Port 这个 Port File 你是一定可以在你那天的机器上编译成功然后装上的

547
00:42:58,000 --> 00:43:10,000
对其实 Linux 的生态有一点像就是有一个人或者有个人马做出了这么一个 Kernel 来然后围绕这个 Kernel 有一群人在上面插各种各样的插件

548
00:43:10,000 --> 00:43:21,000
然后会造成其实我倒觉得 Linux 在这方面他的所谓 Kernel Space 和 User Space 的分译也是比较模糊的

549
00:43:21,000 --> 00:43:26,000
Linux 真正意义上的 Kernel 其实只有那么一点点

550
00:43:26,000 --> 00:43:31,000
而后面外面很大一个外围都是 UserLand 可以这么理解

551
00:43:31,000 --> 00:43:40,000
而在 BSD 这边则你可以说每一个 BSD 发行板都有一个去明确的 Kernel Space 和一个明确的 UserLand

552
00:43:40,000 --> 00:43:45,000
而且咱们都是同一帮人对而且同一帮人这个很重要

553
00:43:45,000 --> 00:43:54,000
而且版本号好像是比较一致的不像你在一个 Linux 下面可能有一个软件的版本特别新

554
00:43:54,000 --> 00:44:00,000
而另外其他部分则基本上是可能要倒退那么两三年的水平

555
00:44:00,000 --> 00:44:08,000
而在 BSD 上面你会基本上在每一个发行板里面拿到比较年份相近的一批工具

556
00:44:08,000 --> 00:44:12,000
对但是我也很久没有用过 BSD 了

557
00:44:12,000 --> 00:44:21,000
其实现在我们看从实际使用的情况来看也是 BSD 的市场分合应该是比较小了已经

558
00:44:21,000 --> 00:44:29,000
另外有一个我又一个比较明显的例子就是上一节目我们提到有个叫做 Varnish 的那个反向代理缓存软件

559
00:44:29,000 --> 00:44:36,000
它那个本来最开始的时候是在 FreeBSD 上写的那个开发者也是 FreeBSD 的内核开发者之一

560
00:44:36,000 --> 00:44:42,000
后来发现他们在做商业化的时候其实大部分人都是在 Linux 上面跑他们的系统的

561
00:44:42,000 --> 00:44:48,000
然后他们现在连做新的那些扩展的功能都是先考或者是只考 Linux 版本

562
00:44:48,000 --> 00:44:51,000
然后 FreeBSD 那边都已经不怎么管

563
00:44:51,000 --> 00:44:55,000
这也是一个多少有点可惜的现状吧

564
00:44:55,000 --> 00:45:00,000
对因为其实如果有 FreeBSD 流行像 Linux 上面流行的话

565
00:45:00,000 --> 00:45:03,000
那我们如果这些 Mac 用会就比较爽

566
00:45:03,000 --> 00:45:08,000
这都是 BSD 内核它切换起来就是包括一些那种系统调用啊

567
00:45:08,000 --> 00:45:13,000
还有那种软件的包啊还有这种这种包括很多这种规范啊行为方式都是比较接近的嘛

568
00:45:13,000 --> 00:45:17,000
对也会爽一点但其实现在就比较糟糕了

569
00:45:17,000 --> 00:45:20,000
比如说我们现在跑服务器上面大部分都是 Linux

570
00:45:20,000 --> 00:45:27,000
但是 Mac 上面又是另外就是 BSD 的内核嘛这样的话就经常会不 match

571
00:45:27,000 --> 00:45:30,000
你要搞一下这个还是挺挺折腾的

572
00:45:30,000 --> 00:45:34,000
对我觉得不管怎么说 Mac 作为一套啊

573
00:45:34,000 --> 00:45:39,000
或者是 Darwin 这个东西作为一套 FreeBSD 系统

574
00:45:39,000 --> 00:45:46,000
还是可以从开源借授意的这点已经是很不错了

575
00:45:46,000 --> 00:45:52,000
就无论至少我们有至少我们有第三方工具可以用

576
00:45:52,000 --> 00:45:58,000
就至少我们有 Linux 上面很多很多工具可以通过 Homebrew 或者 MacPorts 来直接拿来用

577
00:45:58,000 --> 00:46:04,000
这已经是很好的一点了反观 Windows 用户可能就没有那么幸运

578
00:46:05,000 --> 00:46:12,000
这里就说到了在 Stan 上面的就除了那个官方苹果那个 App Store 之外

579
00:46:12,000 --> 00:46:17,000
我们还其实有很古老的最早的有什么 Think 这么一个包管理器

580
00:46:17,000 --> 00:46:21,000
Fink 这个其实我自己是没有用的

581
00:46:21,000 --> 00:46:25,000
我也没有用过我只是听说过咱们两个对在用 MacPorts 的时候

582
00:46:25,000 --> 00:46:29,000
听说过说已经什么 deprecated

583
00:46:29,000 --> 00:46:32,000
It's a better thing forget about things use MacPorts

584
00:46:33,000 --> 00:46:40,000
对所以我接触到在 Mac 上面用的那种类似 Linux 包管理器其实就是从 MacPorts 开始的

585
00:46:40,000 --> 00:46:45,000
然后 MacPorts 又是可以因为你看名字看得出来它是那种 Port 系统

586
00:46:45,000 --> 00:46:49,000
跟 BSD 的 Port 是有一点点相似之处的我觉得

587
00:46:49,000 --> 00:46:57,000
很大程度上是同一套系统只不过 BSDPorts 如果我当然我 BSD 可能我已经有三五年没碰过 BSD

588
00:46:57,000 --> 00:47:03,000
但如果 BSD 知识没有欺骗我的话 BSD 上面的 Ports 其实就是一个 MAC 法

589
00:47:03,000 --> 00:47:10,000
就是你要进到那个 Ports 的怎么录下面然后手动运行 Mac

590
00:47:10,000 --> 00:47:18,000
Mac install 之类的然后 MacPorts 跟这套系统唯一差别就是 MacPorts 会自动帮你运行 Mac

591
00:47:18,000 --> 00:47:21,000
这个过程仅此而已

592
00:47:21,000 --> 00:47:27,000
对就是它你整个你下回来的还是软件的原始代码然后你要去通过这个手工编译

593
00:47:27,000 --> 00:47:32,000
但这边之前你要先装一些什么编译器啊那些是另外的基础需求这些都是

594
00:47:32,000 --> 00:47:42,000
然后然后 MacPorts 唯一的特点就是它是用 TCL 把整套编译和安装的过程帮你自动化

595
00:47:42,000 --> 00:47:50,000
然后当时还有一个优点就是当时有一些那个苹果员工在直接的贡献这个这个系统

596
00:47:50,000 --> 00:47:57,000
所以他们有很大的优势就他们知道自己在干什么而且他们可以做的比较比较比较 Apple like

597
00:47:57,000 --> 00:48:05,000
对其实就在相当长一段时间里面啊那个 OS 10 的用户就是做软件开发者的话

598
00:48:05,000 --> 00:48:10,000
或多或少的也会接触到这个 MacPorts 这个系统要么你自己写点要么去装别人的东西

599
00:48:10,000 --> 00:48:16,000
不过在我有限的记忆里面 MacPorts 的使用体验并不是特别好

600
00:48:16,000 --> 00:48:21,000
因为经常会有这种各种各样的问题导致安装不成功啊编译失败

601
00:48:21,000 --> 00:48:24,000
然后这个时候会就会进入一个比较混乱的状态好

602
00:48:24,000 --> 00:48:30,000
你要去找那个你要去看那个他的那个 port file 然后去看安装到哪一步了哪一步失败了

603
00:48:30,000 --> 00:48:32,000
要清理哪些垃圾文件怎么怎么的

604
00:48:32,000 --> 00:48:35,000
对他的用户界面不是那么的友好

605
00:48:36,000 --> 00:48:43,000
嗯哼所以后来就有一个叫做这个 Homebrew 我们通常简称它叫做 Brew 嘛

606
00:48:43,000 --> 00:48:44,000
横空出世啊

607
00:48:44,000 --> 00:48:50,000
对然后一刀解决了这个问题然后现在基本上 MacPorts 也是被淘汰掉了

608
00:48:50,000 --> 00:48:57,000
嗯还是有一对怎么说呢就是 MacPorts 还是有一批死忠的拥盾在那边用

609
00:48:57,000 --> 00:49:00,000
然后他们会觉得 Homebrew 就有点像

610
00:49:00,000 --> 00:49:11,000
就像所有沾染了 Ruby 的东西一样都是一群喝了 Cookies 的这个这个小小屁孩们在那边闹说这个比较好

611
00:49:11,000 --> 00:49:19,000
嗯哼所以这你提到啊就是 Home 就刚才你讲那个 MacPorts 的那 port file 是用 TCL 脚本来写的

612
00:49:19,000 --> 00:49:22,000
嗯我也是用 HomebrewTCL 脚本

613
00:49:22,000 --> 00:49:26,000
是吗你这你这应该是应该是没错的

614
00:49:26,000 --> 00:49:28,000
MacPortsport file 是 TCL 写的没错

615
00:49:28,000 --> 00:49:37,000
对然后这个 Homebrew 的这个安装的他们叫一个 Formula 对吧是一个 Ruby 的 class 文件其实是

616
00:49:37,000 --> 00:49:38,000
对

617
00:49:38,000 --> 00:49:43,000
因为其实我个人对 Ruby 没什么特别感觉我不知道你觉得怎么样

618
00:49:43,000 --> 00:49:51,000
具体的 Homebrew 的 Formula 上面它其实你可以把它理解当成一做当成一门 DSL 来学习嘛

619
00:49:51,000 --> 00:50:00,000
所以对对对完全这样的你可以完全不懂那个 Ruby 里面那个那个什么两个竖线中间加一个变量名

620
00:50:00,000 --> 00:50:06,000
到底是什么意思你也可以去操作 Homebrew 的 Formula 你就一壶化瓢嘛

621
00:50:06,000 --> 00:50:12,000
所以它其实是把它做的相当呃傻瓜化的这么一个一个一个 Formula

622
00:50:12,000 --> 00:50:19,000
我刚刚写就我记得我你还在推特上问过我说你难道没有那个写过自己的 Formula 吗

623
00:50:19,000 --> 00:50:27,000
我当时很老实而且很骄傲的说没有我都还写过一两还是两三次

624
00:50:27,000 --> 00:50:34,000
对但后来我也写了但我觉得就是即便像我这样对 Ruby 其实没有什么太深了解的人也是可以

625
00:50:34,000 --> 00:50:42,000
呃駕轻就熟的去去去操作一个 Formula 发所以不是很不是没有什么太大的问题

626
00:50:43,000 --> 00:50:51,000
对呃不过说回来这个 Homebrew 本身哈就是我觉得它就现在它 Homebrew 已经现在就是这个 OSN 上的这种怎么

627
00:50:51,000 --> 00:51:04,000
继承事实的官打引号的官方这个呃包管理器了吧因为你如果你现在去关注一下 GitHub 上面的那些各种软件啊

628
00:51:04,000 --> 00:51:10,000
你会发现它只要涉及到呃跟 OSN 有关的大部分会选用 Homebrew 的方式去让你

629
00:51:10,000 --> 00:51:19,000
而且尤其是新工具会倾向于是提供一个 HomebrewFormula 比如说我们上次提到的那个 NailVib 就提供了一个 Homebrew 的 Tap

630
00:51:19,000 --> 00:51:30,000
嗯哼对所以所以这里就有一个延伸的问题就是就是你觉得为什么 Homebrew 会在如此短的时间内完全就替代掉了 MacPorts

631
00:51:31,000 --> 00:51:42,000
呃因为这个和当和当年那个 MacPorts 取代 Think 还是有蛮大区别当时我记得印象中 MacPorts 和 Think 还是共存过相当长一段时间的

632
00:51:42,000 --> 00:51:55,000
我觉得第一是它把提供一个新软件的门槛降低了因为呃 Ruby 的强项就是写一个 DSL 嘛然后它用这种 DSL 使得你

633
00:51:55,000 --> 00:52:04,000
呃发布一个新的软件到呃 Homebrew 不 Repository 的过程变得荒唐的简单

634
00:52:04,000 --> 00:52:12,000
而 MacPorts 它因为用 TCLTCL 毕竟是一个从来没有大动过的人

635
00:52:12,000 --> 00:52:18,000
然后你写它还是还是需要花一点脑筋的你要必须去明白它是一个什么样的运作原理

636
00:52:18,000 --> 00:52:29,000
然后我觉得还有一个可能会成为一个决定性因素的是 Homebrew 给你一种虚假的安全感就是你每次不如安装什么东西你不需要速度

637
00:52:29,000 --> 00:52:35,000
呃前提是你安装的时候用个速度对吧

638
00:52:35,000 --> 00:52:39,000
你要把那个 User Local 设定为你自己账户可读写

639
00:52:39,000 --> 00:52:43,000
对啊但是一般来说很推荐的一种方式

640
00:52:43,000 --> 00:52:51,000
对一般来说每一个就是如果你默认默认一台新电脑默认直接用它的安装脚本去安装 Homebrew 的话它就自动帮你这样做

641
00:52:51,000 --> 00:52:52,000
现在已经是这样了吗

642
00:52:52,000 --> 00:53:02,000
应该是这样的吧我反正安装这台新的呃新的 MacBook 的时候好像是完全没有自己去改

643
00:53:02,000 --> 00:53:07,000
它会推它会推荐你这么干我记得确实是这样的但我不太确定是不是它会默认吧

644
00:53:07,000 --> 00:53:14,000
它可能会在安装过程中询问你要不要这样干然后你应该我也是就是草率的打了一个 Y

645
00:53:14,000 --> 00:53:16,000
嗯对

646
00:53:16,000 --> 00:53:24,000
呃其实有一点我一直在想啊就是 GitHub 对这个 Homebrew 的帮助有多大其实我觉得这个应该是挺关键的

647
00:53:24,000 --> 00:53:26,000
那应该说是相当大因为

648
00:53:26,000 --> 00:53:33,000
对就是你刚才说它是一个 Defecto 既成事实的软件包安装工具

649
00:53:33,000 --> 00:53:37,000
我就想说它其实仅仅是对程序员这样而言而已

650
00:53:37,000 --> 00:53:47,000
但但正是因为此呃几乎每一个稍微有点自尊程序肯定都会去搞搞 GitHub 然后 Homebrew 就在 GitHub

651
00:53:48,000 --> 00:53:54,000
对对这点我觉得就是跟那个像 MacPorts 很不一样 MacPorts 那些我都不知道那那 portfile 文件从哪里来的

652
00:53:54,000 --> 00:54:02,000
然后怎么去提交然后整个看了一下那个网站也做得很丑对吧但是 Homebrew 不一样它所有的这个那个所谓的

653
00:54:02,000 --> 00:54:06,000
他们叫 Formula 就是我们类似于 Makefile 或者是 Portfile 这种一个东西

654
00:54:06,000 --> 00:54:16,000
它都是整个包是安置放在这个 GitHub 上面的然后因为 GitHub 是比较友好的一个工具嘛对对程序来说至少

655
00:54:16,000 --> 00:54:26,000
然后都会大家觉得哎那我给你添加我就是 Fork 一下你这个嘛然后把这个加进去然后再给你发一个这个 PoolRequest 这个东西就算搞定了对吧

656
00:54:26,000 --> 00:54:37,000
整个流程是非常方便的所以这里其实呃就说我们要说要说 UI 做得好但一个 UI 是广义上的不只是说用户对用消费者我们看到一个按钮

657
00:54:37,000 --> 00:54:42,000
这个就应该叫 UX 就是 User Experience 用户体验非常好

658
00:54:42,000 --> 00:54:52,000
这个叫对这个用户就是我们那种 Geek 的宅存序对对我们的友好的话我们也更加乐意去给他什么添砖加瓦

659
00:54:52,000 --> 00:55:04,000
你刚才说这点很好就是当你打开 Homebrew 的页面的时候他会用一上来就告诉你一上来给你讲一个展示给你这工具能干嘛

660
00:55:04,000 --> 00:55:18,000
给你讲一个故事然后用大字用一读的简单的文字告诉你这个工具是干嘛这工具怎样安装怎样使用感性的话去干这个

661
00:55:18,000 --> 00:55:29,000
反观 MacPulse 你打开他的网页他的网页是一个很典型的这种呃门户网站的感觉就是一上来密密麻麻一大堆信息

662
00:55:29,000 --> 00:55:40,000
什么 Documentation、Update、Recent Newsblablablabla 你想要干嘛你想知道这个工具到底干嘛的你不知道

663
00:55:41,000 --> 00:55:48,000
对对所以其实所以刚才你提到好就是说那个什么我们都讲那个什么 CoolAid Drinking Kit

664
00:55:48,000 --> 00:56:00,000
其实这个我觉得是所有的开发者包括这个产品经理都要学习的一个东西就怎么把这个叫做我们这个其实有一个专门的叫做什么 User Landing 吧还是叫什么

665
00:56:00,000 --> 00:56:07,000
就是第一批用户当用户第一眼目睹你的产品的时候你给他一个什么样的印象

666
00:56:07,000 --> 00:56:16,000
对就是在用户已经知道有你这么一个东西但是还不知道怎么用的时候你怎么让他能够快速的去上手能不能让这个过程变得比较爽

667
00:56:16,000 --> 00:56:27,000
我觉得这个是可能是 Ruby 社区就是 Ruby 或者是 Real 这个社区给整个其他软件生这个社区的一个最大的叫什么

668
00:56:27,000 --> 00:56:37,000
财富吧就他们展示了这一点就让一个哪怕他只是对这个有兴趣但是可能并不知道一些具体的细节的人也能够很快的上手

669
00:56:37,000 --> 00:56:50,000
然后之后再去想办法去摸清那些细节嘛而不是说你先上来甩给他一个我这个什么很高冷的形象然后你看不懂就自己去吃吃吧这样这样就不太好

670
00:56:50,000 --> 00:56:58,000
以这种姿态能最终取得成功的人在矿谷至今只有 Linux 推广是一个人吧

671
00:56:58,000 --> 00:57:03,000
所以是不是我们节目的姿态要放低了

672
00:57:03,000 --> 00:57:08,000
哎好啊下次放低点

673
00:57:08,000 --> 00:57:12,000
接着说这个 Homebrew 这个事儿啊

674
00:57:12,000 --> 00:57:20,000
所以就现在我们看到就是基本上那些新的包啊最新的版本他们因为用户很多嘛然后他大家都会为他去贡献去主促

675
00:57:20,000 --> 00:57:30,000
使得他变成一个很良性的一个循环就是你作为一个新软件的作者或者你要用的一个软件里面没有你会想我去 Homebrew 里面找一下

676
00:57:30,000 --> 00:57:38,000
如果没有我就去提交这个 formula 然后把那个提交的 formula 也加回到这个这个 upstream 上面去然后这样别人可以因此而受益

677
00:57:38,000 --> 00:57:50,000
所以其实到今天的话现在 maxl 三上面这个 Homebrew 的包管基本上已经可以在某种程度上达到了在 Linux 上面做的比较好的那些包管的器的那种规模或者是效果

678
00:57:50,000 --> 00:57:57,000
对而且 Homebrew 甚至还被 port 到 Linux 上面我当时就有听刚听到这个新闻的时候我觉得还挺吃惊的就是

679
00:57:57,000 --> 00:58:05,000
Linux 我们在 max 上面用 Homebrew 是因为 max 上面没有 apt-get 或者是没有 YAM

680
00:58:05,000 --> 00:58:20,000
而为什么今天这个时代居然要把 Homebrew 这种因为没有所以不得不造出来的工具 backport 到你们那边已经比较成熟的解决方案的地方

681
00:58:20,000 --> 00:58:27,000
对啊我挺吃惊的但仔细想想就是 Homebrew 的理念其实是相当相当先进的吧可以这么说

682
00:58:27,000 --> 00:58:33,000
对对而且他的整个就刚才就讲了我们这个整个用户体验是非常友好的嘛就是让大家能够很快上手

683
00:58:33,000 --> 00:58:38,000
这其实我觉得也是一个很好的类比比如说那个 formula 刚才讲的有些 DSL 的一个 Ruby 的文件

684
00:58:38,000 --> 00:58:49,000
对对你可以写下来就我你看一下就大概知道他在干嘛但我到现在为止也没搞懂这个怎么去自己编搞一个什么 devin 的 package 出来

685
00:58:49,000 --> 00:59:03,000
然后能够很方便的发布出去就是这个过程还是蛮繁琐对而且 Homebrew 更优雅加以后一点就是他是他跟 git 结合的非常紧密

686
00:59:03,000 --> 00:59:19,000
他本身 host 在 github 上面就不用说了而这个 Homebrew 本身的升级也只不过是一个 gitpool 的某种被包装过的 gitpool 而已就是差这个工具本身就是

687
00:59:19,000 --> 00:59:36,000
就是以一套版本管理系统的方式以一个经过版本管理的软件 reposted 的形式出现在电脑上他需要升级的时候就只需要从他的 upstream 上更新一下就可以了

688
00:59:36,000 --> 00:59:42,000
这个也是挺优雅的一个部分吧对

689
00:59:43,000 --> 01:00:01,000
所以刚才讲的那么都是根据某一个操作系统上面而选择的不同的这个包管理器比如说刚才讲的 devin 上面有没有一个 apt 然后 rpm 系统的话是 yam 然后有 bsd 的 ports 然后 mac 上面现在最新的是这个 homebrew

690
01:00:01,000 --> 01:00:06,000
你刻意跳过 windows

691
01:00:06,000 --> 01:00:08,000
Windows 有吗

692
01:00:08,000 --> 01:00:09,000
有啊

693
01:00:09,000 --> 01:00:10,000
有什么

694
01:00:10,000 --> 01:00:16,000
看来你真是应验了我们听众的一句话就是对 windows 了解连大学毕业生都不如

695
01:00:16,000 --> 01:00:19,000
那肯定已经彻底放弃好多年了

696
01:00:19,000 --> 01:00:34,000
其实很惭愧的就是我也是现学现卖也是因为前阵子去关注那个.net 的开源才注意到了就是 windows 下面有一叫做不确定这应该怎么念 nuget

697
01:00:34,000 --> 01:00:37,000
newget

698
01:00:37,000 --> 01:00:39,000
nuget

699
01:00:39,000 --> 01:00:41,000
鸡块

700
01:00:41,000 --> 01:00:48,000
和鸡块协议总之他就是 nuget 就是一个

701
01:00:48,000 --> 01:00:56,000
包括.net 平台在内的专门为微软开发而研发了一套 package manager

702
01:00:56,000 --> 01:00:59,000
就是等一下等一下他是跑在命令行下面的吗

703
01:00:59,000 --> 01:01:02,000
他有一个命令行界面然后也有一个图形界面 as always

704
01:01:02,000 --> 01:01:07,000
Windows 程序怎么可能没有图形界面你让 windows 程序员怎么活

705
01:01:07,000 --> 01:01:12,000
对我就在想他怎么会有这种需求他们不是都直接在那个什么

706
01:01:12,000 --> 01:01:19,000
跑一个什么 gooey 的东西然后做个 500 个按钮的软件

707
01:01:19,000 --> 01:01:25,000
此处省去对 windows 程序冷嘲热讽无签字

708
01:01:25,000 --> 01:01:31,000
总之这个谁在用呢我从所有微软程序所有现在 after days 的微软程序都在用

709
01:01:31,000 --> 01:01:36,000
OK 所以他们是一个 parallel universe 我们不知道

710
01:01:36,000 --> 01:01:43,000
对在这个平行宇宙里面比如说什么 JQuery 或者是 JQuery 之类的东西

711
01:01:43,000 --> 01:01:49,000
你都可以通过在那个 nuget 的图形界面之下搜 JQuery 然后点下 install

712
01:01:49,000 --> 01:01:50,000
他就帮你装好了

713
01:01:50,000 --> 01:01:58,000
虽然对而且他可能有两三万个 package 的已经

714
01:01:58,000 --> 01:02:03,000
那还不挺大规模的这个是有什么微软官方的维护

715
01:02:03,000 --> 01:02:05,000
对这是微软官方做的吗

716
01:02:05,000 --> 01:02:06,000
官方加持

717
01:02:06,000 --> 01:02:07,000
真的吗

718
01:02:07,000 --> 01:02:18,000
而且在那个你安装了.net 在 macOS 上的那个 HOMEbrew 工具之后

719
01:02:18,000 --> 01:02:19,000
你就有了 nuget

720
01:02:19,000 --> 01:02:25,000
等一下 nuget 这个是不是一个脏话

721
01:02:25,000 --> 01:02:27,000
不是吧

722
01:02:27,000 --> 01:02:30,000
nuget 是脏话 nuget 不是吧

723
01:02:30,000 --> 01:02:34,000
微软不会蠢到这么政治不正确

724
01:02:34,000 --> 01:02:36,000
这个就叫技术 Urban Dict

725
01:02:36,000 --> 01:02:41,000
nuget a person with no arms or legs

726
01:02:41,000 --> 01:02:45,000
鸡块嘛就一个人摆一个人

727
01:02:45,000 --> 01:02:46,000
人棍吗

728
01:02:46,000 --> 01:02:47,000
人质啊

729
01:02:47,000 --> 01:02:52,000
那个是不是人质吧我忘记了就是那个驴后坐的那件事吧是吧

730
01:02:52,000 --> 01:02:55,000
对呀不是钟那个叫人质是吧

731
01:02:55,000 --> 01:02:57,000
应该是人质吧

732
01:02:57,000 --> 01:02:58,000
好吧

733
01:02:58,000 --> 01:03:06,000
反正从 nuget 上面你可以下载比如什么 JQuery 啊

734
01:03:06,000 --> 01:03:10,000
包括 spnet 的 mvc 库啊

735
01:03:10,000 --> 01:03:16,000
甚至还有很多什么 bootstrap 好像也可以从上面下来我记得

736
01:03:16,000 --> 01:03:18,000
这是面针对前端的吗还是

737
01:03:18,000 --> 01:03:20,000
针对一切开发者

738
01:03:20,000 --> 01:03:24,000
OK 因为你举的几个例子都是跟前端开发有关系的

739
01:03:24,000 --> 01:03:29,000
还是说你暴露了你是在上面做前端开发这件事

740
01:03:29,000 --> 01:03:37,000
我在上面做了很简单的 Windows 用户 Windows 编程摸底而已

741
01:03:37,000 --> 01:03:39,000
没有在上面做过任何开发

742
01:03:39,000 --> 01:03:45,000
好吧这个反正我也没问过

743
01:03:45,000 --> 01:03:49,000
没法接着讨论下去他到底怎么样

744
01:03:49,000 --> 01:03:51,000
总之有这么一个东西存在就是

745
01:03:51,000 --> 01:03:55,000
对刚才我们讲的就是基于每一个各个操作系统

746
01:03:55,000 --> 01:04:00,000
或者是 Linux 发行版本的包管理工具的一些相关的情况

747
01:04:00,000 --> 01:04:05,000
现在我们要切换到另外一个比较重要也是我们吐槽比较多的

748
01:04:05,000 --> 01:04:10,000
就是基于各个语言的包管理的东西了

749
01:04:10,000 --> 01:04:11,000
对

750
01:04:11,000 --> 01:04:16,000
这里有一个比较显著的区别就是刚才讲的那些像 Homebrew 也好

751
01:04:16,000 --> 01:04:17,000
还是这个 Debit 也好

752
01:04:17,000 --> 01:04:22,000
就是它也很大程度上是为了我们讲部署的时候用的

753
01:04:22,000 --> 01:04:24,000
就是部署就是可能最终用户自己安装

754
01:04:24,000 --> 01:04:28,000
或者是我们把它弄到服务器上运行的时候这样去的一个用法

755
01:04:28,000 --> 01:04:32,000
然后包括你用 Homebrew 安装的很多这种所谓的命令行软件

756
01:04:32,000 --> 01:04:34,000
你是作为它的一个用户

757
01:04:34,000 --> 01:04:36,000
你不是作为它的开发者去安装的

758
01:04:36,000 --> 01:04:37,000
当然也有例外

759
01:04:37,000 --> 01:04:44,000
其实这是一个比较大的比较明显但是目前还没有人做出来的区别

760
01:04:44,000 --> 01:04:49,000
就是你通过一个包管理工具安装的一个东西

761
01:04:49,000 --> 01:04:54,000
有可能是有一个直接可执行文件的这么一套东西

762
01:04:54,000 --> 01:04:57,000
也有可能它仅仅是一个 Lib 对吧

763
01:04:57,000 --> 01:04:58,000
仅仅是 Library 而已

764
01:04:58,000 --> 01:05:00,000
对有很多这种情况

765
01:05:00,000 --> 01:05:07,000
在我的有限日期里面好像 Homebrew 其实是对此有一个比较模糊的

766
01:05:07,000 --> 01:05:10,000
而且是一个很稍微有点绕人的概念的

767
01:05:10,000 --> 01:05:13,000
就是有些东西所谓 Cask only

768
01:05:14,000 --> 01:05:16,000
Homebrew 有自己一套 jargon 对吧

769
01:05:16,000 --> 01:05:18,000
虽然我对此也不是非常理解

770
01:05:18,000 --> 01:05:24,000
比如说因为它整个借用了酿丝酒的这么一套术语

771
01:05:24,000 --> 01:05:25,000
语汇对

772
01:05:25,000 --> 01:05:28,000
比如说 Cask 就是一个酒桶

773
01:05:28,000 --> 01:05:31,000
然后你从 Cask 里面 pour 出来什么东西

774
01:05:31,000 --> 01:05:35,000
然后再自己 brew 这个套其实就是类比

775
01:05:35,000 --> 01:05:40,000
或者说它把整个编译的过程类比为发酵的过程

776
01:05:40,000 --> 01:05:43,000
而 Cask only 的意思就是这套东西是不发酵的

777
01:05:43,000 --> 01:05:45,000
这套东西只是存在酒桶里面

778
01:05:46,000 --> 01:05:48,000
发酵

779
01:05:48,000 --> 01:05:49,000
OK 我又念错字了

780
01:05:49,000 --> 01:05:50,000
Sorry

781
01:05:50,000 --> 01:05:53,000
我先纠正了免得你又被

782
01:05:56,000 --> 01:05:58,000
当然有个事情刚才没有解释

783
01:05:58,000 --> 01:06:03,000
它还有这个就之前我们讲的 Debent 包一般是发行二斤制版本

784
01:06:03,000 --> 01:06:05,000
然后 Ports 一般是发行原码

785
01:06:05,000 --> 01:06:08,000
Homebrew 的话其实是比较诡异的

786
01:06:08,000 --> 01:06:11,000
就是它两种都有

787
01:06:11,000 --> 01:06:12,000
它两种都支持应该说

788
01:06:13,000 --> 01:06:17,000
对然后它会有大概有不同的语词去描述

789
01:06:17,000 --> 01:06:21,000
我记得它的二斤制版本是叫做 bottle

790
01:06:21,000 --> 01:06:22,000
就是瓶子

791
01:06:22,000 --> 01:06:23,000
对

792
01:06:23,000 --> 01:06:25,000
这个逻辑你一想很简单

793
01:06:25,000 --> 01:06:27,000
就是你编译的过程是在 brew 发酵

794
01:06:27,000 --> 01:06:29,000
然后发酵完了之后就是一个成品的酒

795
01:06:29,000 --> 01:06:30,000
已经装瓶了

796
01:06:30,000 --> 01:06:32,000
就是你叫装瓶然后就直接可以给别人用了

797
01:06:32,000 --> 01:06:33,000
它是有这么一个概念

798
01:06:33,000 --> 01:06:38,000
它对于很多那种软件就不方便装瓶的

799
01:06:38,000 --> 01:06:40,000
一个是可能因为法律的问题

800
01:06:40,000 --> 01:06:41,000
或者是因为版权的问题

801
01:06:41,000 --> 01:06:42,000
它没法装瓶的

802
01:06:42,000 --> 01:06:45,000
或者甚至最简单的情况就是这个东西

803
01:06:45,000 --> 01:06:46,000
它根本就不是拿来用的

804
01:06:46,000 --> 01:06:50,000
它只是拿来作为一种一个建筑材料而已

805
01:06:50,000 --> 01:06:53,000
对它就会直接发布这个 source

806
01:06:54,000 --> 01:06:56,000
我想想能比较明显

807
01:06:56,000 --> 01:06:58,000
FNPEG

808
01:06:58,000 --> 01:07:00,000
FNP 机械工具

809
01:07:00,000 --> 01:07:02,000
它就是发布的原码

810
01:07:02,000 --> 01:07:03,000
然后你还要自己编译的

811
01:07:03,000 --> 01:07:05,000
但是你像 Vim

812
01:07:05,000 --> 01:07:08,000
MacVim 好像是它是弄成一个 bottle 了我记得

813
01:07:08,000 --> 01:07:10,000
MacVim 是 bottle 吗

814
01:07:10,000 --> 01:07:12,000
如果我没记错的话应该是这样子

815
01:07:12,000 --> 01:07:14,000
我怎么记得 MacVim 也是要编译的

816
01:07:14,000 --> 01:07:15,000
是吗

817
01:07:15,000 --> 01:07:16,000
那可能我记错了

818
01:07:16,000 --> 01:07:18,000
它有很多这种是 bottle

819
01:07:18,000 --> 01:07:19,000
你可以发现安装很快

820
01:07:19,000 --> 01:07:22,000
也不需要没有那个编译的过程

821
01:07:22,000 --> 01:07:24,000
anyway

822
01:07:24,000 --> 01:07:29,000
继续说我们这个和编程源相关的 bottle 管理系统

823
01:07:29,000 --> 01:07:32,000
对这里就可能比较奇特的一个事情

824
01:07:32,000 --> 01:07:35,000
就是在某具体的某个语言来讲

825
01:07:35,000 --> 01:07:39,000
它还有通常是一个有自己的一套包管理器的

826
01:07:39,000 --> 01:07:41,000
然后这个包管理器要解决的

827
01:07:41,000 --> 01:07:45,000
绝大部分场合是作为

828
01:07:45,000 --> 01:07:48,000
就为了帮助开发者写程序的时候用的

829
01:07:48,000 --> 01:07:49,000
对

830
01:07:49,000 --> 01:07:50,000
这么说安全吧

831
01:07:50,000 --> 01:07:51,000
我相信是安全的吧

832
01:07:51,000 --> 01:07:56,000
但就是其实这这里也有一个很有趣的事实

833
01:07:56,000 --> 01:07:57,000
事实就是

834
01:07:57,000 --> 01:08:00,000
不管是 Python 也好还是 Ruby 也好

835
01:08:00,000 --> 01:08:03,000
有很多包其实

836
01:08:03,000 --> 01:08:07,000
它不是帮你提供一个开发工具的

837
01:08:07,000 --> 01:08:10,000
它是给你提供一个命令行工具的

838
01:08:10,000 --> 01:08:12,000
比如说我很喜欢的一个叫做

839
01:08:12,000 --> 01:08:15,000
LawCat

840
01:08:15,000 --> 01:08:18,000
它的效果是把

841
01:08:18,000 --> 01:08:22,000
你可以把任何字符串 PAP 给它

842
01:08:22,000 --> 01:08:25,000
然后它把你 PAP 进去的那个字符串

843
01:08:25,000 --> 01:08:28,000
以七彩的形式显示在屏幕上

844
01:08:28,000 --> 01:08:31,000
所以你可以用比如说你可以 Cowsay

845
01:08:31,000 --> 01:08:36,000
Links 上有一个有趣的小工具就是牛说工具

846
01:08:36,000 --> 01:08:38,000
它在屏幕上显示一头牛

847
01:08:38,000 --> 01:08:42,000
然后这个牛会头上会冒出一个气泡矿

848
01:08:42,000 --> 01:08:44,000
然后里面显示你想说的话

849
01:08:44,000 --> 01:08:47,000
然后你先把你要说的话 Cat 进 Cowsay

850
01:08:47,000 --> 01:08:49,000
然后再 Cat 进 LawCat

851
01:08:49,000 --> 01:08:53,000
然后最终结果就是一个七彩的牛

852
01:08:53,000 --> 01:08:55,000
说了一句七彩的话

853
01:08:55,000 --> 01:08:57,000
这个东西就是用 NPL

854
01:08:57,000 --> 01:08:59,000
好 Fancy 啊

855
01:08:59,000 --> 01:09:01,000
对就是用 Gem 来发布的

856
01:09:01,000 --> 01:09:04,000
它本质就只是给你提供一个额外的工具而已

857
01:09:04,000 --> 01:09:05,000
对对

858
01:09:05,000 --> 01:09:08,000
所以刚才我说要特别限定一下

859
01:09:08,000 --> 01:09:10,000
只能说是大部分场合包管的

860
01:09:10,000 --> 01:09:13,000
其实是为了做开发用的工具

861
01:09:13,000 --> 01:09:16,000
但是其实你看也听到有这种场合

862
01:09:16,000 --> 01:09:19,000
它本来就是拿来发布成一个可知

863
01:09:19,000 --> 01:09:21,000
面向最终用户使用的一个工具

864
01:09:21,000 --> 01:09:24,000
所以这里面这界线不是那么清晰

865
01:09:24,000 --> 01:09:27,000
只能说是一个大概的这么一个分类

866
01:09:27,000 --> 01:09:29,000
而且你比较难的很难去一刀切

867
01:09:29,000 --> 01:09:35,000
说我就要硬行在我的包管理系统里面提供

868
01:09:35,000 --> 01:09:40,000
比如说 GemS 2 和 GemSLibrary 的区别

869
01:09:40,000 --> 01:09:42,000
因为有些是两者都提供

870
01:09:42,000 --> 01:09:44,000
对对对

871
01:09:44,000 --> 01:09:46,000
它提供了一个让你调试的工具

872
01:09:46,000 --> 01:09:47,000
比如说对吧

873
01:09:47,000 --> 01:09:48,000
对

874
01:09:48,000 --> 01:09:49,000
你可以很方便的启动它

875
01:09:49,000 --> 01:09:51,000
但是它主要作用还是提供一个酷

876
01:09:51,000 --> 01:09:56,000
比如 Pray 或者是 iPython 这种

877
01:09:56,000 --> 01:09:57,000
它既是一个工具

878
01:09:57,000 --> 01:09:59,000
它又是一套酷

879
01:09:59,000 --> 01:10:00,000
对还是不错

880
01:10:02,000 --> 01:10:03,000
Software is hard

881
01:10:03,000 --> 01:10:04,000
So confusing

882
01:10:06,000 --> 01:10:08,000
好那现在我们就来

883
01:10:08,000 --> 01:10:10,000
就我们先着眼来讲

884
01:10:10,000 --> 01:10:16,000
我们先不讲用这种某一个语言独特的包管理器

885
01:10:16,000 --> 01:10:19,000
来发布命令行工具的这么一个情况

886
01:10:19,000 --> 01:10:24,000
我们就先只看用它来做开发者的事情的时候

887
01:10:24,000 --> 01:10:25,000
会有一些什么样的东西

888
01:10:25,000 --> 01:10:27,000
我们还是按语言来分吧对吧

889
01:10:27,000 --> 01:10:28,000
对

890
01:10:29,000 --> 01:10:31,000
加马城市员吴涛同学请你开始吐槽

891
01:10:31,000 --> 01:10:33,000
开启你的吐槽模式

892
01:10:33,000 --> 01:10:35,000
啊没闻

893
01:10:35,000 --> 01:10:36,000
没闻

894
01:10:38,000 --> 01:10:42,000
所以没闻为什么会给你带着这么惨痛的这个感觉

895
01:10:42,000 --> 01:10:45,000
其实我没闻没有真正的伤害过我

896
01:10:46,000 --> 01:10:47,000
但是

897
01:10:47,000 --> 01:10:48,000
那你为什么这么仇视它

898
01:10:49,000 --> 01:10:57,000
公司里面公司至少因为没闻的一些零零总总的事情

899
01:10:58,000 --> 01:11:02,000
在我印象里面可能有两次推迟过 Release

900
01:11:02,000 --> 01:11:05,000
Release 推迟一天其实是非常

901
01:11:06,000 --> 01:11:10,000
并不是什么天塌下来的灾难性事件

902
01:11:10,000 --> 01:11:12,000
但至少也是让所有人不爽

903
01:11:12,000 --> 01:11:13,000
因为你们不是做游戏的对吧

904
01:11:13,000 --> 01:11:15,000
我们不是做游戏的

905
01:11:15,000 --> 01:11:18,000
我们是做比游戏更海罗因的东西的

906
01:11:18,000 --> 01:11:20,000
但对 anyway 不重要

907
01:11:20,000 --> 01:11:26,000
但就是推迟一天的话意味着首先运维人员要

908
01:11:26,000 --> 01:11:32,000
从飢飞狗跳 24 小时变成飢飞狗跳 48 小时

909
01:11:32,000 --> 01:11:38,000
然后开发人员也会因为发布的被推迟

910
01:11:38,000 --> 01:11:45,000
而不得不要么临时被抓状丁去解决导致这个推迟的问题

911
01:11:45,000 --> 01:11:50,000
要么就因为这一次发布不能及时运行

912
01:11:50,000 --> 01:11:51,000
而不及时进行

913
01:11:51,000 --> 01:11:55,000
而得不到一些比较宝贵的资源

914
01:11:55,000 --> 01:11:56,000
比如说 QA

915
01:11:56,000 --> 01:11:58,000
比如说 staging server 之类的

916
01:11:58,000 --> 01:12:01,000
因为所有这些 server 都还在备战状态

917
01:12:01,000 --> 01:12:06,000
就是要去迎合发布的 deadline

918
01:12:06,000 --> 01:12:10,000
而 Maven 至少已经导致过两次这样的

919
01:12:10,000 --> 01:12:14,000
在我看来已经是事故级别的问题

920
01:12:14,000 --> 01:12:21,000
而另外一方面 Maven 在使用的时候本身你也会觉得

921
01:12:21,000 --> 01:12:23,000
一阵阵的蛋疼

922
01:12:24,000 --> 01:12:26,000
我又问一个问题

923
01:12:26,000 --> 01:12:28,000
是不是还是要手工写 XML

924
01:12:28,000 --> 01:12:29,000
是的

925
01:12:30,000 --> 01:12:32,000
欢迎来到 1995 年

926
01:12:34,000 --> 01:12:36,000
我能理解你的头目

927
01:12:36,000 --> 01:12:39,000
而且当然你可以说

928
01:12:39,000 --> 01:12:43,000
你可以站出来说你可以用各种各样的图形界面去管理 XML

929
01:12:43,000 --> 01:12:44,000
生存它

930
01:12:44,000 --> 01:12:48,000
但有一句名言是 XML 就像 violence

931
01:12:48,000 --> 01:12:50,000
XML 就像暴力

932
01:12:50,000 --> 01:12:53,000
如果它不能解决你的问题

933
01:12:53,000 --> 01:12:55,000
那一定是你用的还不够多

934
01:13:01,000 --> 01:13:02,000
好吧

935
01:13:02,000 --> 01:13:05,000
但是 Maven 其实是一个比较

936
01:13:05,000 --> 01:13:10,000
就是在 java 这个开发圈里面是一个通用常见的方案了

937
01:13:10,000 --> 01:13:13,000
可能有一半程序员会反驳你的看法

938
01:13:13,000 --> 01:13:14,000
但

939
01:13:15,000 --> 01:13:18,000
要我说 Maven 其实是一种

940
01:13:19,000 --> 01:13:23,000
一个一个一个过早优化的典型

941
01:13:23,000 --> 01:13:24,000
可以这么说吗

942
01:13:25,000 --> 01:13:26,000
为什么这么说呢

943
01:13:26,000 --> 01:13:28,000
因为比如说 Maven

944
01:13:28,000 --> 01:13:35,000
一个 Maven Project 一上来就强制你使用一种特定的项目的格式

945
01:13:35,000 --> 01:13:38,000
就是你所有的包

946
01:13:38,000 --> 01:13:39,000
文件的格式

947
01:13:39,000 --> 01:13:41,000
就是你组织源的格式

948
01:13:41,000 --> 01:13:43,000
在所有的 Maven Project 里面是一模一样的

949
01:13:43,000 --> 01:13:45,000
就 Directory Layout

950
01:13:45,000 --> 01:13:47,000
对 Directory Layout 就是一上来要有一个 source

951
01:13:47,000 --> 01:13:49,000
source 里面有 main

952
01:13:49,000 --> 01:13:50,000
main 里面要有

953
01:13:50,000 --> 01:13:51,000
sorry

954
01:13:51,000 --> 01:13:52,000
对

955
01:13:52,000 --> 01:13:53,000
main 里面有一个 main

956
01:13:53,000 --> 01:13:55,000
然后有一个 test

957
01:13:55,000 --> 01:13:58,000
然后 main 和 test 下面的所有的文件结构要一模一样

958
01:14:00,000 --> 01:14:01,000
对总之是

959
01:14:01,000 --> 01:14:02,000
其实这个没什么

960
01:14:02,000 --> 01:14:04,000
有这个规范是好事吗

961
01:14:04,000 --> 01:14:07,000
我不觉得这个是一个特别不好的一个事情

962
01:14:07,000 --> 01:14:12,000
但是在你仅仅想要写一些比较小的东西的时候

963
01:14:12,000 --> 01:14:16,000
你就会觉得这种强加于你的结构是非常让人不爽的

964
01:14:17,000 --> 01:14:19,000
对我觉得这就是问题所在的

965
01:14:19,000 --> 01:14:22,000
你为什么要用加碼写一个很小的东西呢

966
01:14:22,000 --> 01:14:24,000
为什么不用一个脚本语言去写

967
01:14:24,000 --> 01:14:25,000
好吧

968
01:14:25,000 --> 01:14:29,000
这里有个审美关键的问题在里面

969
01:14:29,000 --> 01:14:35,000
就是你可以说 Maven 是一种专门为了企业级应用而推出的

970
01:14:35,000 --> 01:14:37,000
一种硬性的解决方案

971
01:14:37,000 --> 01:14:43,000
就是它通过永长繁琐的配置

972
01:14:43,000 --> 01:14:51,000
和强制加载你身上的工序保证了你是一个可以被替换的螺丝

973
01:14:51,000 --> 01:14:53,000
因为不管你是谁

974
01:14:53,000 --> 01:14:54,000
你只要用 Maven

975
01:14:54,000 --> 01:14:56,000
那么你能做的东西都是可以预定的

976
01:14:56,000 --> 01:14:58,000
都是可以预见到的

977
01:14:58,000 --> 01:15:01,000
而不像你说比如说早期的洪荒时代

978
01:15:01,000 --> 01:15:02,000
在用 ant 的时候

979
01:15:02,000 --> 01:15:04,000
你的 ant file 可能是一个天数样的东西

980
01:15:04,000 --> 01:15:07,000
你的接收者是没有办法去理解你

981
01:15:07,000 --> 01:15:09,000
去替代你

982
01:15:09,000 --> 01:15:12,000
但是反过来我会觉得

983
01:15:12,000 --> 01:15:18,000
就像我对所有带有 enterprise 的字样的东西天生的反感一样

984
01:15:18,000 --> 01:15:20,000
这是一种

985
01:15:20,000 --> 01:15:23,000
我很难说它到底错在哪

986
01:15:23,000 --> 01:15:26,000
但我就觉得它不是我希望的那样

987
01:15:26,000 --> 01:15:29,000
但是如果你是抱着这种心态的话

988
01:15:29,000 --> 01:15:31,000
你是不是不应该写 Java 程序呢

989
01:15:31,000 --> 01:15:37,000
因为 Java 版就是为了 enterprise 这种场景

990
01:15:37,000 --> 01:15:42,000
我只能说我是为了谋生不得不做这件事情

991
01:15:42,000 --> 01:15:47,000
但就像 Paul Graham 说过的那句话一样

992
01:15:47,000 --> 01:15:50,000
在他知道的所有程序里面

993
01:15:50,000 --> 01:15:52,000
在他认识的 10 个

994
01:15:52,000 --> 01:15:53,000
在他能想出

995
01:15:53,000 --> 01:15:54,000
原话我不太记得

996
01:15:54,000 --> 01:15:55,000
反正大意就是说

997
01:15:55,000 --> 01:15:57,000
在他能想到的 10 个 Java 程序里面

998
01:15:57,000 --> 01:16:03,000
有 9 个不是出于自愿的目的而去写 Java

999
01:16:03,000 --> 01:16:05,000
我可能也是

1000
01:16:08,000 --> 01:16:11,000
生活所迫

1001
01:16:11,000 --> 01:16:15,000
而且我觉得这可能也是我辞职的原因之一

1002
01:16:15,000 --> 01:16:22,000
就是去寻找更绿的草坪的动机之一

1003
01:16:22,000 --> 01:16:25,000
也就是我终于受够了 Java 这一套

1004
01:16:27,000 --> 01:16:31,000
所以这里要插问一句

1005
01:16:31,000 --> 01:16:32,000
下一份工作是准备写什么

1006
01:16:32,000 --> 01:16:33,000
可能是 Python

1007
01:16:33,000 --> 01:16:34,000
应该是 Python

1008
01:16:34,000 --> 01:16:36,000
Python,C++

1009
01:16:36,000 --> 01:16:40,000
然后 Java 可能会成为一个选项

1010
01:16:40,000 --> 01:16:41,000
但应该不是必须的

1011
01:16:41,000 --> 01:16:45,000
至少目前我掌握的资料是这样的

1012
01:16:48,000 --> 01:16:53,000
Java 除了 Maven 这一个让你比较沮丧的包管理器之外

1013
01:16:53,000 --> 01:16:54,000
还有什么其他选项

1014
01:16:54,000 --> 01:16:56,000
Java 有其他的别的选项吗

1015
01:16:56,000 --> 01:16:57,000
没有吗

1016
01:16:57,000 --> 01:16:59,000
应该是有的

1017
01:16:59,000 --> 01:17:05,000
但 Maven 基本上可以视为任何一个比较上了规模的

1018
01:17:08,000 --> 01:17:16,000
企业及应用的开发企业都不得不或者说都会选择的一个解决方案

1019
01:17:16,000 --> 01:17:22,000
因为围绕着 Maven 产生出了一套还是相对来说比较成熟的生态系统

1020
01:17:22,000 --> 01:17:23,000
每一个都很繁琐

1021
01:17:23,000 --> 01:17:24,000
每一个都很丑陋

1022
01:17:24,000 --> 01:17:26,000
但是搭载在一起的时候

1023
01:17:26,000 --> 01:17:30,000
它在 50%的时间里面还是可以做事的

1024
01:17:34,000 --> 01:17:37,000
所以这是一个大家都知道很不爽

1025
01:17:37,000 --> 01:17:40,000
大家都知道起码这个不爽是可以预期的

1026
01:17:40,000 --> 01:17:41,000
对吧

1027
01:17:41,000 --> 01:17:42,000
有多不爽也就那样了

1028
01:17:42,000 --> 01:17:44,000
网上有一幅漫画

1029
01:17:44,000 --> 01:17:46,000
我觉得一定要放在我们的 show notes 里面

1030
01:17:46,000 --> 01:17:48,000
一想读着

1031
01:17:49,000 --> 01:17:57,000
大意就是你采用 Maven 之后的生产率曲线

1032
01:17:57,000 --> 01:18:01,000
刚刚开始这个曲线是有一点点向上的

1033
01:18:01,000 --> 01:18:06,000
就是刚刚采用 Maven 之后你会觉得一切包都井井有条

1034
01:18:06,000 --> 01:18:10,000
然后 Maven 还有一个特点就是

1035
01:18:10,000 --> 01:18:19,000
它的给你预先定义了一套非常永长繁琐啰嗦的编译步骤

1036
01:18:19,000 --> 01:18:23,000
比如说你可以运行 Maven clean 就是帮你申量所有东西

1037
01:18:23,000 --> 01:18:32,000
然后 Maven test 就是帮你从 precompile compile 然后 assembly 然后 distribute

1038
01:18:32,000 --> 01:18:35,000
诸如此类整整一套全都跑下来

1039
01:18:35,000 --> 01:18:37,000
然后自动帮你运行测试

1040
01:18:37,000 --> 01:18:40,000
你会觉得自己的生产力好像提高了

1041
01:18:40,000 --> 01:18:42,000
因为一切都尽可能自动化了

1042
01:18:42,000 --> 01:18:50,000
但是好景不长当某一个时间你遭遇到某一个安装包依赖冲突问题的时候

1043
01:18:50,000 --> 01:18:54,000
你会发现你已经失去了对整个项目的控制

1044
01:18:54,000 --> 01:18:56,000
然后整个情况直转直下

1045
01:18:56,000 --> 01:19:01,000
然后生产率曲线就跌落了一个万劫不复的深渊

1046
01:19:01,000 --> 01:19:05,000
你会发现我把整个 project 已经

1047
01:19:05,000 --> 01:19:07,000
怎么说 mavenized

1048
01:19:07,000 --> 01:19:12,000
然后感觉这个时候好像得了癌症感染一样

1049
01:19:12,000 --> 01:19:15,000
对我已经起虎难下再也回不去了

1050
01:19:15,000 --> 01:19:20,000
所以还有一个什么还能够恢复的阶段吗

1051
01:19:20,000 --> 01:19:24,000
好像那幅漫画里面是没有恢复的阶段

1052
01:19:24,000 --> 01:19:26,000
直接死了

1053
01:19:26,000 --> 01:19:31,000
而且在有一个就像我上次提到过一个 tumblr 的一个

1054
01:19:32,000 --> 01:19:39,000
以 gif 动画为主的 tumblr 叫做 devops reactions

1055
01:19:39,000 --> 01:19:42,000
里面就有一个

1056
01:19:42,000 --> 01:19:49,000
有一期就是讲 maven 的人力如何令人痛苦的

1057
01:19:49,000 --> 01:19:54,000
很简单就是一个人在雨中流泪

1058
01:19:54,000 --> 01:19:57,000
然后另外一个人从后面贴近他的耳朵说

1059
01:19:57,000 --> 01:20:06,000
好像是 it's gonna be painful

1060
01:20:06,000 --> 01:20:08,000
大概说了这么一句话

1061
01:20:08,000 --> 01:20:10,000
然后这个 gif 的标题就是

1062
01:20:10,000 --> 01:20:14,000
得知项目里面需要用到 maven

1063
01:20:18,000 --> 01:20:21,000
好吧我们知道你的痛苦了

1064
01:20:21,000 --> 01:20:22,000
不过马上就要解脱了

1065
01:20:22,000 --> 01:20:23,000
还有一个礼拜

1066
01:20:23,000 --> 01:20:25,000
而且各位听众听到这个

1067
01:20:25,000 --> 01:20:28,000
听到这些节目的时候我已经解脱了

1068
01:20:28,000 --> 01:20:31,000
我已经开开心心的在意大利游玩

1069
01:20:31,000 --> 01:20:35,000
好吧

1070
01:20:35,000 --> 01:20:39,000
就说到 java 要说一个相关的语言

1071
01:20:39,000 --> 01:20:42,000
就是这个叫做 scala 的语言

1072
01:20:42,000 --> 01:20:44,000
或者说 next generation java

1073
01:20:44,000 --> 01:20:48,000
我觉得不能这么说

1074
01:20:48,000 --> 01:20:50,000
因为它并不是它的一个超级

1075
01:20:50,000 --> 01:20:52,000
它是怎么说呢

1076
01:20:52,000 --> 01:20:55,000
scala 的目的就是取代现有的 java

1077
01:20:55,000 --> 01:20:58,000
成为下一代的企业级应用的标准语言

1078
01:20:58,000 --> 01:21:00,000
我觉得这件事情是不会发生的

1079
01:21:00,000 --> 01:21:01,000
对你觉得不会发生

1080
01:21:01,000 --> 01:21:06,000
但至少我在我这边在我看到的新闻里面

1081
01:21:06,000 --> 01:21:07,000
scala 这是 scala 的目标

1082
01:21:07,000 --> 01:21:10,000
而且欧盟也的确

1083
01:21:10,000 --> 01:21:12,000
欧盟给 scala 扔了很多很多钱

1084
01:21:12,000 --> 01:21:15,000
因为 scala 是某种意义上是一个欧洲语言

1085
01:21:15,000 --> 01:21:18,000
它是德国人开发瑞士人制造

1086
01:21:18,000 --> 01:21:20,000
德国人开发瑞士人制造

1087
01:21:20,000 --> 01:21:23,000
基本上是你所能得到的变成语言里面

1088
01:21:23,000 --> 01:21:25,000
最复杂的一种可能性

1089
01:21:25,000 --> 01:21:29,000
对就为什么我讲 scala 不可能

1090
01:21:29,000 --> 01:21:31,000
替代 java 成为助流

1091
01:21:31,000 --> 01:21:34,000
我觉得在工业定性上就已经有这一点

1092
01:21:34,000 --> 01:21:35,000
光说一点吧

1093
01:21:35,000 --> 01:21:39,000
它 scala 的语言规范叫一个大不透的书

1094
01:21:39,000 --> 01:21:41,000
才能讲得完

1095
01:21:41,000 --> 01:21:43,000
然后我觉得这个世界上能够跟它比的

1096
01:21:43,000 --> 01:21:45,000
估计只有 c++了

1097
01:21:45,000 --> 01:21:48,000
对 C++的现状就是没有任何一个

1098
01:21:48,000 --> 01:21:50,000
纠正我如果说错的话

1099
01:21:50,000 --> 01:21:54,000
世界上没有任何一个 C++编译器是完全

1100
01:21:54,000 --> 01:21:59,000
就是可以符合这个 C++标准

1101
01:21:59,000 --> 01:22:01,000
是不是这样

1102
01:22:01,000 --> 01:22:03,000
我觉得应该是吧

1103
01:22:03,000 --> 01:22:06,000
ok 对然后 scala 也是一个就是属于一个

1104
01:22:06,000 --> 01:22:08,000
就是我在我的心目中归类

1105
01:22:08,000 --> 01:22:12,000
是把它歌于 C++同类复杂度的语言

1106
01:22:12,000 --> 01:22:15,000
但是它确实有很多这种很爽的语言特性

1107
01:22:15,000 --> 01:22:17,000
但这不是这次讨论的重点

1108
01:22:17,000 --> 01:22:21,000
但是要提到它是因为要说它的一个包管理器

1109
01:22:21,000 --> 01:22:24,000
叫做 sbt 傻变态

1110
01:22:24,000 --> 01:22:28,000
还好你没有审的另外一种根

1111
01:22:28,000 --> 01:22:31,000
那么它特别在哪呢

1112
01:22:31,000 --> 01:22:33,000
它的特别在于它的你占你心

1113
01:22:33,000 --> 01:22:36,000
没问题是要写这个 xml 吗

1114
01:22:36,000 --> 01:22:39,000
对那你知道 xml 本来就不是拿给人写的吗

1115
01:22:39,000 --> 01:22:41,000
对吧

1116
01:22:41,000 --> 01:22:44,000
它本来是要给机器生成系统去的吗

1117
01:22:44,000 --> 01:22:49,000
sbt 的这个文件是一个 scala 的 dsl

1118
01:22:49,000 --> 01:22:51,000
你可以这么想

1119
01:22:51,000 --> 01:22:55,000
它是相比 xml 是绝对要简洁很多的

1120
01:22:55,000 --> 01:22:58,000
不过呢它作为一个 dsl

1121
01:22:58,000 --> 01:23:00,000
它也有它自己的问题

1122
01:23:00,000 --> 01:23:02,000
就是你首先得知道你能够在这里面写什么

1123
01:23:02,000 --> 01:23:04,000
不能在里面写什么

1124
01:23:04,000 --> 01:23:06,000
就是你要用 sbt 这个包管理器

1125
01:23:06,000 --> 01:23:08,000
所以你得比较熟悉的理解

1126
01:23:08,000 --> 01:23:12,000
scala 那套复杂灰色的语言规范怎么一回事

1127
01:23:12,000 --> 01:23:17,000
ok scala 反正有很多很难忘文生意的东西

1128
01:23:17,000 --> 01:23:18,000
这个我是知道的

1129
01:23:18,000 --> 01:23:20,000
对因为它是一个

1130
01:23:20,000 --> 01:23:23,000
它是一个来自学术圈的语言

1131
01:23:23,000 --> 01:23:25,000
你可以这么想吧

1132
01:23:25,000 --> 01:23:27,000
很难说吧

1133
01:23:27,000 --> 01:23:30,000
作者毕竟也是 JVM 的

1134
01:23:30,000 --> 01:23:32,000
对

1135
01:23:32,000 --> 01:23:33,000
anyway 你可以理解

1136
01:23:33,000 --> 01:23:36,000
它是一个工业界和学术界都双修的大牛

1137
01:23:36,000 --> 01:23:41,000
对因为这个人起码到现在为止还是待在大学里面教书

1138
01:23:41,000 --> 01:23:44,000
对待在他美丽的瑞士小城洛桑

1139
01:23:44,000 --> 01:23:47,000
每天看着日内瓦湖然后写写编辑器

1140
01:23:47,000 --> 01:23:49,000
好悠闲的生活

1141
01:23:49,000 --> 01:23:50,000
教教课

1142
01:23:50,000 --> 01:23:52,000
对他在那个

1143
01:23:52,000 --> 01:23:53,000
洛桑理工

1144
01:23:53,000 --> 01:23:57,000
对他在联邦理工洛桑分院

1145
01:23:57,000 --> 01:23:59,000
然后他应该是在 Coursera

1146
01:23:59,000 --> 01:24:02,000
应该是在 Coursera 上面教一门公开课

1147
01:24:02,000 --> 01:24:03,000
对

1148
01:24:03,000 --> 01:24:05,000
functional programming

1149
01:24:05,000 --> 01:24:07,000
functional programming principles in SCA

1150
01:24:07,000 --> 01:24:08,000
OK

1151
01:24:08,000 --> 01:24:09,000
Martin Odetsky

1152
01:24:09,000 --> 01:24:11,000
对这个大牛

1153
01:24:11,000 --> 01:24:12,000
德语口音

1154
01:24:12,000 --> 01:24:15,000
长得一口德语口音很重的

1155
01:24:15,000 --> 01:24:17,000
长了一张德国人的脸

1156
01:24:17,000 --> 01:24:21,000
在瑞士的法语去教书

1157
01:24:21,000 --> 01:24:23,000
对很奇怪的事

1158
01:24:23,000 --> 01:24:24,000
SBT 的

1159
01:24:24,000 --> 01:24:25,000
他的

1160
01:24:25,000 --> 01:24:28,000
就我当时学 SCA 的时候就是用它来编译东西

1161
01:24:28,000 --> 01:24:31,000
他可以支持纯加盘的项目也可以

1162
01:24:31,000 --> 01:24:33,000
然后 SCA 的加盘混合项目也可以

1163
01:24:33,000 --> 01:24:35,000
就给我感觉他那套

1164
01:24:35,000 --> 01:24:37,000
就是这个文件

1165
01:24:37,000 --> 01:24:39,000
就是那个配置文件还是比较好写的

1166
01:24:39,000 --> 01:24:42,000
就起码比美文好多了我觉得

1167
01:24:42,000 --> 01:24:44,000
但吐槽到的刚才也吐了

1168
01:24:44,000 --> 01:24:46,000
就是我对这个东西的理解就

1169
01:24:46,000 --> 01:24:48,000
因为我没有跟他用过来

1170
01:24:48,000 --> 01:24:49,000
只是他在那儿学习而已

1171
01:24:49,000 --> 01:24:51,000
没有用过什么作为大规模的应用

1172
01:24:51,000 --> 01:24:54,000
所以不太清楚具体使用的时候会怎么样

1173
01:24:54,000 --> 01:24:55,000
但是

1174
01:24:55,000 --> 01:24:58,000
据 SBT 的用户的描述来讲

1175
01:24:58,000 --> 01:25:02,000
应该是比美文支流要好很多的

1176
01:25:02,000 --> 01:25:03,000
OK

1177
01:25:03,000 --> 01:25:05,000
你确定你说的

1178
01:25:05,000 --> 01:25:07,000
DSL 好写是真的吗

1179
01:25:07,000 --> 01:25:11,000
因为我们现在看这个 SBT 教程上面的一段就是

1180
01:25:11,000 --> 01:25:12,000
哇这是什么

1181
01:25:12,000 --> 01:25:14,000
为什么一个 build 要

1182
01:25:14,000 --> 01:25:17,000
有 object hello build extends build

1183
01:25:17,000 --> 01:25:20,000
就在 build 文件里面居然要用到继承

1184
01:25:20,000 --> 01:25:25,000
或者说非常显示的写出继承关系来

1185
01:25:25,000 --> 01:25:26,000
这个原理很简单

1186
01:25:26,000 --> 01:25:28,000
就好像在 java 里面你没有办法

1187
01:25:28,000 --> 01:25:31,000
不写一个 class 进行一个程序一样

1188
01:25:31,000 --> 01:25:33,000
你在 scala 里面你至少

1189
01:25:33,000 --> 01:25:35,000
对你在 scala 里面你至少得到一个 object

1190
01:25:35,000 --> 01:25:38,000
就是 in Scala everything is an object

1191
01:25:38,000 --> 01:25:40,000
object 在 scala 里面相当于

1192
01:25:40,000 --> 01:25:42,000
如果我没记错相当于 singleton 吧

1193
01:25:42,000 --> 01:25:45,000
对差不多这个概念

1194
01:25:45,000 --> 01:25:48,000
然后为什么 settings 这个东西

1195
01:25:48,000 --> 01:25:52,000
这个东西前面要有 override lazy valve

1196
01:25:53,000 --> 01:25:56,000
这个时候你就要去研究 scala 这个语言

1197
01:25:56,000 --> 01:25:57,000
到底本身怎么一回事

1198
01:25:57,000 --> 01:25:59,000
你还得理解它这个

1199
01:25:59,000 --> 01:26:01,000
就是说它的门槛是蛮高的

1200
01:26:01,000 --> 01:26:03,000
但是一旦你入了门之后

1201
01:26:03,000 --> 01:26:06,000
which is a long long time

1202
01:26:06,000 --> 01:26:08,000
一旦你入了门之后

1203
01:26:08,000 --> 01:26:11,000
就之后还是写起来还行反正

1204
01:26:11,000 --> 01:26:13,000
就那套 DSL 你一旦学会之后

1205
01:26:13,000 --> 01:26:16,000
你能够以一个非常简练的方式把它写出来

1206
01:26:16,000 --> 01:26:18,000
但难度在于你要达到那个简练方式

1207
01:26:18,000 --> 01:26:20,000
你得先读它肯那本

1208
01:26:20,000 --> 01:26:22,000
那个 scala 的那本书

1209
01:26:22,000 --> 01:26:24,000
你就要肯上个什么小半年了吧

1210
01:26:25,000 --> 01:26:26,000
对

1211
01:26:27,000 --> 01:26:31,000
对然后用那个来管理 java 的这个

1212
01:26:31,000 --> 01:26:34,000
这个这个这个这个 project 也是可以的

1213
01:26:34,000 --> 01:26:37,000
但是我很怀疑这件事情的可行之处

1214
01:26:37,000 --> 01:26:39,000
因为它确实是太难学了

1215
01:26:39,000 --> 01:26:41,000
嗯我是觉得

1216
01:26:41,000 --> 01:26:45,000
它应该像很多很多欧盟

1217
01:26:45,000 --> 01:26:47,000
看好的所有其他项目一样

1218
01:26:47,000 --> 01:26:50,000
因为过度的繁琐而最后

1219
01:26:50,000 --> 01:26:53,000
被抛弃在历史的车轮下面

1220
01:26:53,000 --> 01:26:55,000
很有可能

1221
01:26:55,000 --> 01:26:57,000
对所以我们就

1222
01:26:57,000 --> 01:27:00,000
那也这或者从另外一个角度理解也是

1223
01:27:00,000 --> 01:27:02,000
呃我们这些选择了 go

1224
01:27:02,000 --> 01:27:06,000
或者是选择了更多更更更简单的

1225
01:27:06,000 --> 01:27:09,000
呃菜鸟们的一种

1226
01:27:09,000 --> 01:27:11,000
无妄的稀迹吧

1227
01:27:11,000 --> 01:27:12,000
也许它最后还是会像

1228
01:27:12,000 --> 01:27:14,000
java 一样 take over the world

1229
01:27:14,000 --> 01:27:17,000
像世界佳一样盘踞在这个

1230
01:27:17,000 --> 01:27:21,000
tlb 的那个排行榜上

1231
01:27:21,000 --> 01:27:23,000
中年阴魂不散

1232
01:27:23,000 --> 01:27:24,000
也不是没有可能啊

1233
01:27:24,000 --> 01:27:26,000
现在比如说你像像推特

1234
01:27:26,000 --> 01:27:28,000
还有一些什么中度用户都在用这个写

1235
01:27:28,000 --> 01:27:29,000
他的后台

1236
01:27:29,000 --> 01:27:31,000
那也这种也是可以

1237
01:27:31,000 --> 01:27:35,000
就如果它出现了我觉得也也也不难理解嘛

1238
01:27:35,000 --> 01:27:36,000
嗯嗯嗯

1239
01:27:36,000 --> 01:27:38,000
好下面要进入一个

1240
01:27:38,000 --> 01:27:41,000
终于我们两个都可以共同吐槽的一个

1241
01:27:41,000 --> 01:27:42,000
他

1242
01:27:42,000 --> 01:27:43,000
哈哈哈哈

1243
01:27:43,000 --> 01:27:44,000
拍档

1244
01:27:44,000 --> 01:27:46,000
也就是你的下一篇都要做的事情

1245
01:27:46,000 --> 01:27:48,000
不要以为你从家吧里面

1246
01:27:48,000 --> 01:27:50,000
那个那个什么你你你

1247
01:27:50,000 --> 01:27:53,000
泥泽里面挣脱出来你就爽了

1248
01:27:53,000 --> 01:27:55,000
拍档里面坑坑也不少我跟你讲

1249
01:27:55,000 --> 01:27:58,000
刚出龙潭又入虎穴对

1250
01:27:58,000 --> 01:28:00,000
拍档这个问题其实也是怎么讲

1251
01:28:00,000 --> 01:28:02,000
历史遗留问题比较多吧

1252
01:28:02,000 --> 01:28:03,000
嗯

1253
01:28:03,000 --> 01:28:04,000
就首先啊

1254
01:28:04,000 --> 01:28:06,000
就现在这个事情是蛮讽刺的啊

1255
01:28:06,000 --> 01:28:08,000
就是拍档我们都知道

1256
01:28:08,000 --> 01:28:09,000
他有一个哲学嘛

1257
01:28:09,000 --> 01:28:10,000
哲学嘛就是

1258
01:28:10,000 --> 01:28:11,000
There is one

1259
01:28:11,000 --> 01:28:14,000
and hopefully only one obvious way to do things

1260
01:28:14,000 --> 01:28:17,000
对然后一边高唱这个曲号

1261
01:28:17,000 --> 01:28:18,000
一边出了

1262
01:28:18,000 --> 01:28:20,000
拍档和拍档三

1263
01:28:20,000 --> 01:28:25,000
然后又有了 set up tools 和 pip

1264
01:28:25,000 --> 01:28:26,000
不止啊

1265
01:28:26,000 --> 01:28:27,000
还有多着呢

1266
01:28:27,000 --> 01:28:29,000
最开始有这个有 set up tools

1267
01:28:29,000 --> 01:28:31,000
有 distill your tools

1268
01:28:31,000 --> 01:28:33,000
有 pip

1269
01:28:33,000 --> 01:28:34,000
有 build out

1270
01:28:34,000 --> 01:28:35,000
这句话是比较老的

1271
01:28:35,000 --> 01:28:36,000
build out 是啥啊

1272
01:28:36,000 --> 01:28:37,000
我会给你解释

1273
01:28:37,000 --> 01:28:39,000
这是一个很神奇的存在

1274
01:28:39,000 --> 01:28:40,000
OK

1275
01:28:40,000 --> 01:28:41,000
然后后来有

1276
01:28:41,000 --> 01:28:43,000
后来觉得这个事情玩不下去了

1277
01:28:43,000 --> 01:28:45,000
后来出现那个叫什么

1278
01:28:45,000 --> 01:28:48,000
distill tool 2

1279
01:28:48,000 --> 01:28:49,000
OK

1280
01:28:49,000 --> 01:28:50,000
所以你看这个这一个标榜者

1281
01:28:50,000 --> 01:28:52,000
这里这一个标榜

1282
01:28:52,000 --> 01:28:56,000
只有通常一个正确的方式做事的语言

1283
01:28:56,000 --> 01:29:01,000
有着五六七八种包管理工具

1284
01:29:01,000 --> 01:29:04,000
对有着五六七八种不同的做事的方式

1285
01:29:04,000 --> 01:29:07,000
而且他们互相之间是不太兼容的

1286
01:29:07,000 --> 01:29:11,000
当然我觉得这也可能也不能完全怪 Python

1287
01:29:11,000 --> 01:29:13,000
他的设计理念

1288
01:29:13,000 --> 01:29:16,000
并不能保证他所确认的那种方式

1289
01:29:16,000 --> 01:29:18,000
就是大家最喜欢的

1290
01:29:18,000 --> 01:29:21,000
或者是大家最觉得

1291
01:29:21,000 --> 01:29:23,000
与时俱进的方式

1292
01:29:23,000 --> 01:29:25,000
对所以其实这就是一个

1293
01:29:25,000 --> 01:29:27,000
我跟你讲是一个历史遗留的问题

1294
01:29:27,000 --> 01:29:29,000
因为他刚才提到那些工具

1295
01:29:29,000 --> 01:29:30,000
他出现的

1296
01:29:30,000 --> 01:29:33,000
就是他的最开始的版本出现都比较早

1297
01:29:33,000 --> 01:29:36,000
其实在过去这么十几年中

1298
01:29:36,000 --> 01:29:38,000
我们对这个包管理的认识

1299
01:29:38,000 --> 01:29:40,000
包括这个网络技术设施

1300
01:29:40,000 --> 01:29:42,000
其实发生过很大的变化

1301
01:29:42,000 --> 01:29:44,000
但是他那些工具

1302
01:29:44,000 --> 01:29:47,000
就没有太跟得上时代了

1303
01:29:47,000 --> 01:29:48,000
你可以这么想

1304
01:29:48,000 --> 01:29:50,000
而且另外一个比较显著的问题是说

1305
01:29:50,000 --> 01:29:53,000
因为 Python 他通常是在 Linux 发行版里面

1306
01:29:53,000 --> 01:29:56,000
作为系统组件之一发行的

1307
01:29:56,000 --> 01:29:59,000
那么就导致一个很严重的问题就是

1308
01:29:59,000 --> 01:30:01,000
如果那个系统发行版不升级的话

1309
01:30:01,000 --> 01:30:04,000
那个绑定的 Python 的版本也是不升级的

1310
01:30:04,000 --> 01:30:06,000
这样在实际使用的时候

1311
01:30:06,000 --> 01:30:12,000
就会出现一个非常多的不同的版本要支持

1312
01:30:12,000 --> 01:30:13,000
而这个互相之间

1313
01:30:13,000 --> 01:30:16,000
不同版本他们之间的兼容性又是有问题的

1314
01:30:16,000 --> 01:30:18,000
所以在这么一个

1315
01:30:18,000 --> 01:30:20,000
就是说在漫长的历史长河中

1316
01:30:20,000 --> 01:30:21,000
散落下这么多版本

1317
01:30:21,000 --> 01:30:23,000
然后你作为一个包管理器的编写者

1318
01:30:23,000 --> 01:30:26,000
你也去很难说能够什么

1319
01:30:26,000 --> 01:30:28,000
one thing to fix them all 对吧

1320
01:30:28,000 --> 01:30:30,000
对

1321
01:30:30,000 --> 01:30:32,000
但是这并不能改变

1322
01:30:32,000 --> 01:30:33,000
我们要吐槽他这件事实

1323
01:30:33,000 --> 01:30:35,000
因为他确实就是很糟糕

1324
01:30:35,000 --> 01:30:36,000
对

1325
01:30:36,000 --> 01:30:39,000
他 Python 的每个

1326
01:30:39,000 --> 01:30:42,000
Python 他自己有一个发行的渠道

1327
01:30:42,000 --> 01:30:44,000
就是他自己会有可以官方下载

1328
01:30:44,000 --> 01:30:47,000
但是更多的时候我们用的是从系统里面自带的

1329
01:30:47,000 --> 01:30:49,000
他每个系统里面自带的又是某一个版本

1330
01:30:49,000 --> 01:30:53,000
他会标准库里面会有这么一个叫做 setup tools

1331
01:30:53,000 --> 01:30:54,000
对

1332
01:30:54,000 --> 01:30:56,000
然后这个东西的命令行的体现

1333
01:30:56,000 --> 01:30:58,000
应该是叫什么 easy install

1334
01:30:58,000 --> 01:31:01,000
easy install easy underline install

1335
01:31:01,000 --> 01:31:04,000
他的问题是

1336
01:31:04,000 --> 01:31:07,000
他只能 install 不能 uninstall

1337
01:31:10,000 --> 01:31:13,000
你会发现 easy install 好简单好方便

1338
01:31:13,000 --> 01:31:16,000
那怎么 easy uninstall 好像没有这个命令

1339
01:31:17,000 --> 01:31:21,000
easy install hard manually uninstall

1340
01:31:21,000 --> 01:31:22,000
对

1341
01:31:22,000 --> 01:31:24,000
对你会觉得这个就很奇怪

1342
01:31:24,000 --> 01:31:27,000
你怎么能只进不出

1343
01:31:27,000 --> 01:31:29,000
这会导致什么样的后果

1344
01:31:29,000 --> 01:31:31,000
你装完之后没法重来

1345
01:31:31,000 --> 01:31:32,000
没法说装错了

1346
01:31:32,000 --> 01:31:33,000
删掉

1347
01:31:33,000 --> 01:31:34,000
因为他一旦装了之后

1348
01:31:34,000 --> 01:31:37,000
大概整个东西就赖死在你的系统的面目了

1349
01:31:37,000 --> 01:31:41,000
除非你自己分析他们安装的脚本的语句

1350
01:31:41,000 --> 01:31:42,000
看原码

1351
01:31:42,000 --> 01:31:44,000
看他到底装到哪里去了

1352
01:31:44,000 --> 01:31:45,000
然后一个一个去手中搞

1353
01:31:45,000 --> 01:31:47,000
就觉得怎么变态

1354
01:31:47,000 --> 01:31:48,000
对吧

1355
01:31:48,000 --> 01:31:50,000
对他很无辜告诉你说

1356
01:31:50,000 --> 01:31:51,000
我不是跟你说了吗

1357
01:31:51,000 --> 01:31:53,000
我只是负责 easy install 而已

1358
01:31:53,000 --> 01:31:55,000
只有 easy install 而已

1359
01:31:55,000 --> 01:31:59,000
对这个感觉就很像中国的很多这种流氓软件

1360
01:31:59,000 --> 01:32:01,000
很方便的装上去

1361
01:32:01,000 --> 01:32:02,000
管杀不管害

1362
01:32:02,000 --> 01:32:04,000
就什么不叫一件事安装

1363
01:32:04,000 --> 01:32:05,000
你就无件事安装

1364
01:32:05,000 --> 01:32:07,000
你不装他都给你装了

1365
01:32:07,000 --> 01:32:10,000
但是发生装上去就没法回头了

1366
01:32:11,000 --> 01:32:13,000
对有这么一个问题

1367
01:32:13,000 --> 01:32:15,000
而且他这个 easy install

1368
01:32:15,000 --> 01:32:19,000
他并不支持全部的去拍照的安装

1369
01:32:19,000 --> 01:32:20,000
安装的很多

1370
01:32:20,000 --> 01:32:22,000
你发现装半截爆错

1371
01:32:22,000 --> 01:32:24,000
装不了不支持这个格式

1372
01:32:24,000 --> 01:32:26,000
因为他也是对软件包的这种

1373
01:32:26,000 --> 01:32:29,000
所有的 layout 或者这种封装方式

1374
01:32:29,000 --> 01:32:31,000
包括那些文件里面要填什么

1375
01:32:31,000 --> 01:32:32,000
Meta 的信息

1376
01:32:32,000 --> 01:32:33,000
他都是有一些要求的

1377
01:32:33,000 --> 01:32:34,000
但是并不是所有

1378
01:32:34,000 --> 01:32:38,000
因为这个四分五列了这么一个生态圈的状况

1379
01:32:38,000 --> 01:32:41,000
并不是所有的软件包都是觉得

1380
01:32:41,000 --> 01:32:42,000
要用这个方式来写的

1381
01:32:42,000 --> 01:32:44,000
而且据我所知

1382
01:32:44,000 --> 01:32:45,000
应该大部分人都不是

1383
01:32:45,000 --> 01:32:47,000
不用那个方式来写的

1384
01:32:47,000 --> 01:32:50,000
对我记得当年听说

1385
01:32:50,000 --> 01:32:53,000
Aguido 是什么 Dictator 的时候

1386
01:32:53,000 --> 01:32:55,000
我心里还觉得我靠有个 Dictator

1387
01:32:55,000 --> 01:32:58,000
难道不会站出来管一管这件事情吗

1388
01:32:58,000 --> 01:33:00,000
但事实上

1389
01:33:00,000 --> 01:33:01,000
有意见一个不管事的

1390
01:33:01,000 --> 01:33:04,000
对在我们如果对比一下

1391
01:33:04,000 --> 01:33:05,000
Python 社区和 Ruby 社区的时候

1392
01:33:05,000 --> 01:33:07,000
就会发现 Ruby 的

1393
01:33:07,000 --> 01:33:10,000
虽然我们默默鄙视着 Ruby 社区的人

1394
01:33:10,000 --> 01:33:12,000
但是 Ruby 社区有一点好

1395
01:33:12,000 --> 01:33:16,000
当 Mats 说一句

1396
01:33:16,000 --> 01:33:17,000
大家升级到 2.08

1397
01:33:17,000 --> 01:33:19,000
所有人都升级到 2.0

1398
01:33:19,000 --> 01:33:21,000
而我们现在我记得刚刚前几天

1399
01:33:21,000 --> 01:33:24,000
还收到一封邮件让我们在投票说

1400
01:33:24,000 --> 01:33:27,000
你觉得 Python 3 是一个错误吗

1401
01:33:27,000 --> 01:33:29,000
必然是啊

1402
01:33:29,000 --> 01:33:31,000
现在的状况来看

1403
01:33:31,000 --> 01:33:32,000
对

1404
01:33:32,000 --> 01:33:34,000
Python 3 本意是好的

1405
01:33:34,000 --> 01:33:36,000
但目前的现状毫无疑问是个错误

1406
01:33:36,000 --> 01:33:39,000
Python 语言吐槽这一方也可以

1407
01:33:39,000 --> 01:33:40,000
这个单独在吐槽

1408
01:33:40,000 --> 01:33:42,000
这里只吐槽它的发布工具

1409
01:33:42,000 --> 01:33:45,000
所以这其实也是体现了自己一个问题

1410
01:33:45,000 --> 01:33:47,000
就是 Python 还有一句口号叫做

1411
01:33:47,000 --> 01:33:49,000
Batteries included

1412
01:33:49,000 --> 01:33:51,000
什么自带电池

1413
01:33:51,000 --> 01:33:54,000
它这个标准库里自带了 Setup Tool

1414
01:33:54,000 --> 01:33:56,000
这么一个标准的安装包

1415
01:33:56,000 --> 01:33:58,000
但是就它的标准库里面

1416
01:33:58,000 --> 01:34:00,000
其他很多 Batteries 一样

1417
01:34:00,000 --> 01:34:02,000
他们都是 dead on arrival

1418
01:34:02,000 --> 01:34:04,000
已经至少是 5 年旧的电池了

1419
01:34:04,000 --> 01:34:06,000
而且装进去的时候根本没有

1420
01:34:06,000 --> 01:34:07,000
直接没电

1421
01:34:07,000 --> 01:34:11,000
装进去的时候根本没有做绝缘

1422
01:34:11,000 --> 01:34:14,000
导致你拿到机器拆开之后

1423
01:34:14,000 --> 01:34:16,000
发现电池已经烂在里面了

1424
01:34:16,000 --> 01:34:19,000
电池电降就跑出来的感觉

1425
01:34:19,000 --> 01:34:22,000
对他们带了一个很烂的工具

1426
01:34:22,000 --> 01:34:23,000
然后没法用

1427
01:34:23,000 --> 01:34:24,000
后来有人想办法

1428
01:34:24,000 --> 01:34:26,000
我们再解决

1429
01:34:26,000 --> 01:34:28,000
后来就出了什么

1430
01:34:28,000 --> 01:34:29,000
我们这么说

1431
01:34:29,000 --> 01:34:30,000
我这么说其实不对

1432
01:34:30,000 --> 01:34:31,000
但是为了把这个故事讲下去

1433
01:34:31,000 --> 01:34:32,000
就这么说

1434
01:34:32,000 --> 01:34:34,000
后来就出了什么 Disturbed Tile

1435
01:34:34,000 --> 01:34:35,000
这么一个工具

1436
01:34:35,000 --> 01:34:39,000
说试图解决 Setup Tools 的各种问题

1437
01:34:39,000 --> 01:34:42,000
但其实后来也发现也没解决了

1438
01:34:42,000 --> 01:34:45,000
然后又多了这么一个碎片

1439
01:34:45,000 --> 01:34:47,000
又多了一个工具要支持

1440
01:34:47,000 --> 01:34:50,000
然后也 Disturbed Tile 也不是特别友好

1441
01:34:51,000 --> 01:34:52,000
我的印象

1442
01:34:52,000 --> 01:34:55,000
我几乎从来没有怎么用过 Disturbed Tile

1443
01:34:55,000 --> 01:34:56,000
Trust me

1444
01:34:56,000 --> 01:34:57,000
你肯定用过

1445
01:34:57,000 --> 01:34:58,000
只是你不知道

1446
01:34:58,000 --> 01:35:00,000
他 3 号应该和 Setup Tool

1447
01:35:00,000 --> 01:35:02,000
有点这种扯无亲道门的关系

1448
01:35:02,000 --> 01:35:05,000
最新的说法是这两个东西要融合了

1449
01:35:07,000 --> 01:35:10,000
就是催生出第三个怪胎来是吗

1450
01:35:10,000 --> 01:35:11,000
对就是因为他们

1451
01:35:11,000 --> 01:35:13,000
就是 Setup Tools 那帮人

1452
01:35:13,000 --> 01:35:15,000
Disturbed Tile 这帮人开发的后来发现

1453
01:35:15,000 --> 01:35:16,000
哎呀不行啊

1454
01:35:16,000 --> 01:35:19,000
我们各自为政搞一套新版本

1455
01:35:19,000 --> 01:35:21,000
首先和自己过去不建容

1456
01:35:21,000 --> 01:35:22,000
然后和对方不建容

1457
01:35:22,000 --> 01:35:23,000
这本本就二变四了嘛

1458
01:35:23,000 --> 01:35:25,000
对吧这就很沮丧

1459
01:35:25,000 --> 01:35:26,000
所以后来他们说

1460
01:35:26,000 --> 01:35:29,000
算了我们还是合作一把

1461
01:35:29,000 --> 01:35:31,000
所以以后的 Disturbed Tile 2

1462
01:35:31,000 --> 01:35:33,000
和 Setup Tools 的下一个版本

1463
01:35:33,000 --> 01:35:34,000
应该是融合在一起的

1464
01:35:34,000 --> 01:35:35,000
然后具体叫什么

1465
01:35:35,000 --> 01:35:36,000
我现在已经不知道了

1466
01:35:36,000 --> 01:35:38,000
我已经放弃理解他们的行为了

1467
01:35:38,000 --> 01:35:41,000
我觉得已经 Beyond my comprehension

1468
01:35:42,000 --> 01:35:43,000
OK

1469
01:35:43,000 --> 01:35:45,000
但是那个美好的局面还没有出现

1470
01:35:45,000 --> 01:35:46,000
我到目前为止还是一个

1471
01:35:46,000 --> 01:35:48,000
挺力的沮丧的情况

1472
01:35:48,000 --> 01:35:50,000
后来也有人受不了了

1473
01:35:50,000 --> 01:35:52,000
就是出现了一个大牛吧

1474
01:35:52,000 --> 01:35:53,000
名字忘了

1475
01:35:53,000 --> 01:35:55,000
大家写了这个叫 PIP 的工具

1476
01:35:55,000 --> 01:35:56,000
PIP

1477
01:35:57,000 --> 01:36:00,000
对其实你刚才说我们要一起吐槽 Python

1478
01:36:00,000 --> 01:36:01,000
我心里默默低估一句

1479
01:36:01,000 --> 01:36:03,000
我现在其实不需要怎么吐槽 Python 了

1480
01:36:03,000 --> 01:36:04,000
我也是

1481
01:36:04,000 --> 01:36:05,000
我已经放弃了

1482
01:36:05,000 --> 01:36:08,000
我把 Painful 的部分就默默绕过了

1483
01:36:08,000 --> 01:36:11,000
比如说我会用 Python Z

1484
01:36:11,000 --> 01:36:12,000
就是 Python Z

1485
01:36:12,000 --> 01:36:14,000
装好几个版本的 Python

1486
01:36:14,000 --> 01:36:17,000
然后每次跑什么东西的时候

1487
01:36:17,000 --> 01:36:19,000
就选择一个 Python

1488
01:36:19,000 --> 01:36:22,000
然后如果需要什么 package 的话

1489
01:36:22,000 --> 01:36:26,000
就用 Pip 在该版本的 Python 之下

1490
01:36:26,000 --> 01:36:29,000
装只供该版本的 Python 使用的 package

1491
01:36:29,000 --> 01:36:30,000
你是这样玩

1492
01:36:30,000 --> 01:36:33,000
好像也没有什么太痛苦的部分

1493
01:36:33,000 --> 01:36:35,000
那你肯定是装的还不够多

1494
01:36:35,000 --> 01:36:37,000
装多了总会遇到坑的

1495
01:36:37,000 --> 01:36:38,000
坑的这个是一定的

1496
01:36:39,000 --> 01:36:43,000
当年之前我前几年在支屋工作的时候

1497
01:36:43,000 --> 01:36:45,000
就有遇到比较令人沮丧的状况

1498
01:36:45,000 --> 01:36:49,000
因为我们用的 Python 的包比较多比较杂

1499
01:36:49,000 --> 01:36:51,000
然后其实挺痛苦的

1500
01:36:51,000 --> 01:36:57,000
一定是我还没有进入到企业级 Python 的世界

1501
01:36:58,000 --> 01:37:00,000
不过我的解决方案比你更加决绝

1502
01:37:00,000 --> 01:37:02,000
首先我现在已经不在支屋了

1503
01:37:02,000 --> 01:37:04,000
已经立志好久了

1504
01:37:04,000 --> 01:37:08,000
然后另外我也不再写 Python 相关的东西了

1505
01:37:08,000 --> 01:37:11,000
就全面转向 Go 和 Node

1506
01:37:12,000 --> 01:37:13,000
就直接避免了这种问题

1507
01:37:13,000 --> 01:37:17,000
你现在在搞学术的时候用的是什么工具

1508
01:37:17,000 --> 01:37:22,000
我这 Node 你敢信吗

1509
01:37:23,000 --> 01:37:26,000
因为要做一个 demo

1510
01:37:26,000 --> 01:37:30,000
然后这个场景比较适合在浏览器里面搞

1511
01:37:30,000 --> 01:37:32,000
所以就 JavaScript

1512
01:37:32,000 --> 01:37:35,000
然后必然就跟 Node 的车不叫关系了

1513
01:37:35,000 --> 01:37:36,000
这个也等下再说

1514
01:37:36,000 --> 01:37:38,000
现在接着说回 Python 这个东西

1515
01:37:38,000 --> 01:37:41,000
就有人也受不了这种各种四分五六局面

1516
01:37:41,000 --> 01:37:43,000
又搞出一个又不见

1517
01:37:43,000 --> 01:37:44,000
也不叫又不见

1518
01:37:44,000 --> 01:37:46,000
大部分情况下兼容

1519
01:37:46,000 --> 01:37:49,000
只有小部分时候不兼容的工具叫 PIP

1520
01:37:50,000 --> 01:37:51,000
叫 Pipe

1521
01:37:51,000 --> 01:37:52,000
Pipe 吧对

1522
01:37:52,000 --> 01:37:54,000
我一般念 Pipe

1523
01:37:54,000 --> 01:37:58,000
它的好处就是它支持 uninstall

1524
01:37:58,000 --> 01:37:59,000
耶

1525
01:37:59,000 --> 01:38:00,000
就是非常

1526
01:38:01,000 --> 01:38:03,000
一个包括了一些终于加入了一个

1527
01:38:03,000 --> 01:38:05,000
uninstall 的功能也好

1528
01:38:07,000 --> 01:38:09,000
这听起来有点奇怪

1529
01:38:09,000 --> 01:38:10,000
为什么好像有点

1530
01:38:10,000 --> 01:38:11,000
对啊

1531
01:38:11,000 --> 01:38:12,000
难道不是

1532
01:38:12,000 --> 01:38:13,000
很潮热

1533
01:38:13,000 --> 01:38:16,000
对普通用户用了十几年的功能吗

1534
01:38:16,000 --> 01:38:18,000
Pipe 有什么好呢

1535
01:38:18,000 --> 01:38:22,000
它首先支持这个卸载

1536
01:38:22,000 --> 01:38:23,000
这个是很大的一个进步

1537
01:38:23,000 --> 01:38:25,000
然后第二个我觉得比较重要的

1538
01:38:25,000 --> 01:38:28,000
它支持一个所谓的版本冻结

1539
01:38:29,000 --> 01:38:31,000
对就是 Pipfrase 这个

1540
01:38:31,000 --> 01:38:33,000
对你可以装好一堆包之后

1541
01:38:33,000 --> 01:38:34,000
你可以说好

1542
01:38:34,000 --> 01:38:36,000
我这个什么

1543
01:38:36,000 --> 01:38:38,000
开发环境搭建好了

1544
01:38:38,000 --> 01:38:40,000
看一下有什么版本的包

1545
01:38:40,000 --> 01:38:41,000
我是依赖的

1546
01:38:41,000 --> 01:38:42,000
然后 Pipfrase 一下

1547
01:38:42,000 --> 01:38:44,000
然后返回一个列表

1548
01:38:44,000 --> 01:38:47,000
说你当前装了哪些 Python 的包

1549
01:38:47,000 --> 01:38:49,000
然后那个包是哪些版本对吧

1550
01:38:51,000 --> 01:38:52,000
你选择一个列表

1551
01:38:52,000 --> 01:38:53,000
下次你再用那个列表

1552
01:38:53,000 --> 01:38:54,000
用那个列表

1553
01:38:54,000 --> 01:38:55,000
然后再装一遍

1554
01:38:55,000 --> 01:38:57,000
它就会按照那个列表一行一行的

1555
01:38:57,000 --> 01:38:59,000
去给你装对应的版本就好了

1556
01:38:59,000 --> 01:39:01,000
就 Hopefully it works

1557
01:39:01,000 --> 01:39:06,000
而且以我有限的 Hobby list 的经验来看

1558
01:39:06,000 --> 01:39:08,000
基本上 99%的时间它是 Works

1559
01:39:08,000 --> 01:39:09,000
对

1560
01:39:09,000 --> 01:39:11,000
当然这也是因为你在国外

1561
01:39:11,000 --> 01:39:13,000
你不知道中国人民的痛苦

1562
01:39:15,000 --> 01:39:18,000
可是我听说贵网站接下来是机密

1563
01:39:18,000 --> 01:39:21,000
机密那种听众情务互相泄露

1564
01:39:21,000 --> 01:39:26,000
就是贵站难道不是内部直接 VPN 翻墙了吗

1565
01:39:26,000 --> 01:39:29,000
但是你知道即便是这样翻墙

1566
01:39:29,000 --> 01:39:30,000
网络也是不稳定的

1567
01:39:30,000 --> 01:39:34,000
就是你如果用到东西是网络的话

1568
01:39:34,000 --> 01:39:35,000
你首先要假设一点

1569
01:39:35,000 --> 01:39:37,000
网络是可以随时断掉的

1570
01:39:37,000 --> 01:39:40,000
它可能会在你最不希望它断掉的时间断掉

1571
01:39:40,000 --> 01:39:41,000
OK 莫非定律

1572
01:39:41,000 --> 01:39:42,000
对

1573
01:39:42,000 --> 01:39:43,000
基本上是这样

1574
01:39:43,000 --> 01:39:45,000
如果你一旦做了什么企业的运为

1575
01:39:45,000 --> 01:39:48,000
之后你发现这件事情是一定成立的

1576
01:39:48,000 --> 01:39:52,000
对 其实这就是有一次 Maven 导致我们

1577
01:39:53,000 --> 01:39:56,000
发布推迟的原因之一就是我们的 Nexus 挂掉了

1578
01:39:57,000 --> 01:39:58,000
不是连不上网络

1579
01:39:58,000 --> 01:39:59,000
而是 Nexus 挂掉了

1580
01:39:59,000 --> 01:40:03,000
Nexus 是 Maven 这一套系统里面的一个

1581
01:40:03,000 --> 01:40:07,000
或者说支持 Maven 系统很重要的一个特征就是

1582
01:40:07,000 --> 01:40:12,000
你可以自定义一个包管理服务器

1583
01:40:12,000 --> 01:40:15,000
然后把你写好的软件

1584
01:40:15,000 --> 01:40:22,000
作为一个源挂在包管理服务器上

1585
01:40:22,000 --> 01:40:25,000
然后当你在发布新的软件的时候

1586
01:40:25,000 --> 01:40:27,000
你已经做好那些组件

1587
01:40:27,000 --> 01:40:29,000
可以就像从其他任何源一样

1588
01:40:29,000 --> 01:40:33,000
从你自己的服务器上面下载下来

1589
01:40:33,000 --> 01:40:36,000
然后成为发布好的系统认识的一部分

1590
01:40:36,000 --> 01:40:38,000
但是如果这个服务器挂掉了

1591
01:40:38,000 --> 01:40:41,000
那也就意味着整个发布过程将无法进行

1592
01:40:41,000 --> 01:40:44,000
有一次我们的 Nexus 服务器就挂掉了

1593
01:40:44,000 --> 01:40:46,000
所以你们这些是有什么 Single point of failure

1594
01:40:46,000 --> 01:40:47,000
单点失败了

1595
01:40:47,000 --> 01:40:48,000
对

1596
01:40:48,000 --> 01:40:53,000
把所有的件放在一个篮子里是非常愚蠢的一件事情

1597
01:40:53,000 --> 01:40:54,000
很惨

1598
01:40:54,000 --> 01:40:55,000
对

1599
01:40:55,000 --> 01:40:56,000
当然

1600
01:40:56,000 --> 01:40:57,000
对

1601
01:40:57,000 --> 01:40:59,000
但其实刚才讲的

1602
01:40:59,000 --> 01:41:00,000
I don't blame you

1603
01:41:02,000 --> 01:41:06,000
他刚才讲的那些就是 Python 那三个三大工具

1604
01:41:06,000 --> 01:41:09,000
都是他们都依赖同样一个东西叫做

1605
01:41:09,000 --> 01:41:11,000
叫做 Pypi

1606
01:41:11,000 --> 01:41:12,000
叫 Pypi

1607
01:41:12,000 --> 01:41:13,000
对

1608
01:41:13,000 --> 01:41:15,000
叫 Python Package Index

1609
01:41:15,000 --> 01:41:17,000
对 Python Package Index

1610
01:41:17,000 --> 01:41:19,000
我不知道到 Pypi 叫 Pypi

1611
01:41:19,000 --> 01:41:20,000
我觉得叫 Pypi

1612
01:41:20,000 --> 01:41:21,000
Pypi 吧

1613
01:41:21,000 --> 01:41:22,000
因为 Pypi 是另外一个东西

1614
01:41:22,000 --> 01:41:24,000
Pypi 又是另外一个东西了

1615
01:41:24,000 --> 01:41:25,000
对

1616
01:41:25,000 --> 01:41:27,000
这里就不说先讲 Pypi

1617
01:41:28,000 --> 01:41:30,000
Pypi 是一个什么

1618
01:41:30,000 --> 01:41:35,000
它是一个 Python 这个 Foundation

1619
01:41:35,000 --> 01:41:38,000
Python Software Foundation 维护的一个中央服务器

1620
01:41:38,000 --> 01:41:39,000
你们 Nexus 差不多

1621
01:41:39,000 --> 01:41:41,000
但是它是通过网络访问的

1622
01:41:41,000 --> 01:41:44,000
然后你每次 Pypi Install 或者 Distribute

1623
01:41:44,000 --> 01:41:45,000
去什么 Easy Install 的时候

1624
01:41:45,000 --> 01:41:48,000
它都要去那里去下载

1625
01:41:48,000 --> 01:41:50,000
搜一遍你那个要装的那种名字

1626
01:41:50,000 --> 01:41:52,000
然后在哪里找到那个位置去下载回来

1627
01:41:52,000 --> 01:41:53,000
不知道

1628
01:41:53,000 --> 01:41:55,000
它应该是传到那里一个服务器上

1629
01:41:55,000 --> 01:41:56,000
直接下载回来

1630
01:41:56,000 --> 01:41:58,000
它有一个 FTPP 服务器你可以这么想

1631
01:41:58,000 --> 01:42:00,000
然后它经常挂掉

1632
01:42:02,000 --> 01:42:06,000
它挂掉的概率之平凡

1633
01:42:06,000 --> 01:42:09,000
反正是令我疼不接受

1634
01:42:09,000 --> 01:42:11,000
是在你们公司挂掉

1635
01:42:11,000 --> 01:42:14,000
就是在你从你们公司访问的时候挂掉

1636
01:42:14,000 --> 01:42:15,000
不不不它自己就挂掉了

1637
01:42:15,000 --> 01:42:17,000
所有人都不能访问

1638
01:42:17,000 --> 01:42:18,000
What

1639
01:42:18,000 --> 01:42:21,000
真的真的前几年的时候这个事情超级严重

1640
01:42:21,000 --> 01:42:24,000
也是因为就两个原因

1641
01:42:24,000 --> 01:42:25,000
它自己影响挂掉

1642
01:42:25,000 --> 01:42:27,000
一个是我们访问它的网络的情况经常会挂掉

1643
01:42:27,000 --> 01:42:31,000
你知道有段时间 Python.org

1644
01:42:31,000 --> 01:42:34,000
这个网站是被封掉了吗

1645
01:42:34,000 --> 01:42:35,000
对

1646
01:42:35,000 --> 01:42:36,000
现在也是被封掉

1647
01:42:36,000 --> 01:42:37,000
不然它为什么要在

1648
01:42:37,000 --> 01:42:38,000
加个中文

1649
01:42:38,000 --> 01:42:42,000
首页上面出现中文的下载两个字

1650
01:42:42,000 --> 01:42:43,000
这就不是你们觉得很奇怪吗

1651
01:42:43,000 --> 01:42:44,000
你都被封掉了

1652
01:42:44,000 --> 01:42:46,000
你出现中文有什么用

1653
01:42:46,000 --> 01:42:48,000
这是 parody 吗

1654
01:42:48,000 --> 01:42:49,000
它故意

1655
01:42:49,000 --> 01:42:53,000
我觉得这就是它从一个技术社区来表达

1656
01:42:53,000 --> 01:42:57,000
对于某些政府行为的微弱的反抗

1657
01:42:57,000 --> 01:42:58,000
Whatever

1658
01:42:58,000 --> 01:42:59,000
就是对

1659
01:42:59,000 --> 01:43:00,000
这个就不知道

1660
01:43:00,000 --> 01:43:01,000
秀个姿态

1661
01:43:01,000 --> 01:43:02,000
反正就是双重原因

1662
01:43:02,000 --> 01:43:03,000
双重原因

1663
01:43:03,000 --> 01:43:04,000
它自己本身也不是很稳定

1664
01:43:04,000 --> 01:43:06,000
它自己的 availability 也不是很高

1665
01:43:06,000 --> 01:43:07,000
加上网络的原因

1666
01:43:07,000 --> 01:43:09,000
导致我们经常访问不了它

1667
01:43:09,000 --> 01:43:14,000
所以大部分用 Python 做生产的公司也好

1668
01:43:14,000 --> 01:43:15,000
团队也好

1669
01:43:15,000 --> 01:43:20,000
基本上都自己在本内部局网维护了一个 PyPy 的镜像

1670
01:43:20,000 --> 01:43:21,000
OK

1671
01:43:21,000 --> 01:43:22,000
简单上就是把 PyPy

1672
01:43:22,000 --> 01:43:23,000
很大吗

1673
01:43:23,000 --> 01:43:24,000
你不一定需要全部的吗

1674
01:43:24,000 --> 01:43:26,000
你只需要你常用的那些

1675
01:43:26,000 --> 01:43:28,000
可是你怎么知道哪些常用

1676
01:43:28,000 --> 01:43:29,000
它是这种

1677
01:43:29,000 --> 01:43:30,000
它有一种

1678
01:43:30,000 --> 01:43:31,000
这个做得还比较不错

1679
01:43:31,000 --> 01:43:35,000
就是因为 PyPy 经常挂掉

1680
01:43:35,000 --> 01:43:36,000
所以有人写出这种工具

1681
01:43:36,000 --> 01:43:40,000
可以很方便的让你在自己的服务器上架设一个镜像

1682
01:43:40,000 --> 01:43:42,000
然后这个镜像可以说

1683
01:43:42,000 --> 01:43:43,000
就代理嘛

1684
01:43:43,000 --> 01:43:45,000
就是你设置一下你装的时候

1685
01:43:45,000 --> 01:43:48,000
它会先去这个镜像服务器上找

1686
01:43:48,000 --> 01:43:49,000
如果它找不到

1687
01:43:49,000 --> 01:43:52,000
它会让这个镜像服务器去 PyPy 的官方

1688
01:43:52,000 --> 01:43:54,000
去把那个抓了回镜像服务器

1689
01:43:54,000 --> 01:43:55,000
这样下次的话

1690
01:43:55,000 --> 01:43:57,000
你就在那个镜像服务器上有了嘛

1691
01:43:57,000 --> 01:43:59,000
就是等于也是一个缓存代理的意思

1692
01:43:59,000 --> 01:44:00,000
对

1693
01:44:00,000 --> 01:44:01,000
对

1694
01:44:01,000 --> 01:44:04,000
就是就到了这种程度了

1695
01:44:04,000 --> 01:44:06,000
当然不过从这个可用性的角度来讲

1696
01:44:06,000 --> 01:44:09,000
你有一个本地的这个镜像也是好的

1697
01:44:09,000 --> 01:44:13,000
就可以避免网络和你们遇到那种情况单点失败嘛

1698
01:44:14,000 --> 01:44:15,000
OK

1699
01:44:15,000 --> 01:44:19,000
但是事情还是没有结束

1700
01:44:19,000 --> 01:44:20,000
为什么呢

1701
01:44:20,000 --> 01:44:23,000
因为不管是 Easy Install 也好

1702
01:44:23,000 --> 01:44:24,000
Disutil 也好

1703
01:44:24,000 --> 01:44:27,000
PyPy 也好

1704
01:44:27,000 --> 01:44:33,000
他们基本上不能安装非纯 Python 的包

1705
01:44:34,000 --> 01:44:36,000
Python 作为一个

1706
01:44:36,000 --> 01:44:38,000
多少有点强人所难了

1707
01:44:38,000 --> 01:44:39,000
说实话

1708
01:44:39,000 --> 01:44:41,000
这个就要解释为什么嘛

1709
01:44:41,000 --> 01:44:43,000
为什么要发出现这种一个应用场景

1710
01:44:43,000 --> 01:44:48,000
首先是因为 Python 语言本身是一个比较归宿的语言

1711
01:44:48,000 --> 01:44:53,000
它是一个简实型不带 GIT 的语言

1712
01:44:53,000 --> 01:44:58,000
对或者说它 GIT 支持的特征还不够全面

1713
01:44:58,000 --> 01:44:59,000
对简单来说就是慢

1714
01:44:59,000 --> 01:45:02,000
那么导致它做很多事情的时候就不能

1715
01:45:02,000 --> 01:45:04,000
都需要 Native Pining

1716
01:45:04,000 --> 01:45:07,000
对不能用原生的 Python 的这个代码来实现

1717
01:45:07,000 --> 01:45:10,000
要用这个 C 或者 CG 加来实现

1718
01:45:10,000 --> 01:45:14,000
然后通过一个那种这种什么 Bridge 的方式

1719
01:45:14,000 --> 01:45:16,000
再通过 Python 去调用它

1720
01:45:16,000 --> 01:45:18,000
比如说最常见的两个

1721
01:45:18,000 --> 01:45:23,000
这种例子是一个叫做 Numeric Py

1722
01:45:23,000 --> 01:45:25,000
是做数值计算的

1723
01:45:25,000 --> 01:45:28,000
比如说什么举增运算啊

1724
01:45:28,000 --> 01:45:31,000
另外一个叫做 Python Image Library

1725
01:45:31,000 --> 01:45:34,000
然后这个是干嘛就是处理图像的

1726
01:45:34,000 --> 01:45:37,000
就处理图像其实用图还蛮多的

1727
01:45:37,000 --> 01:45:39,000
比如说你做一个社交网站

1728
01:45:39,000 --> 01:45:41,000
你要用户传个头像上来的时候

1729
01:45:41,000 --> 01:45:44,000
你得想办法剪裁一下压缩一下对吧

1730
01:45:44,000 --> 01:45:46,000
你就用 PIL

1731
01:45:46,000 --> 01:45:47,000
Python Image Library

1732
01:45:47,000 --> 01:45:51,000
其实我说实话已经好像曾经非常喜欢它

1733
01:45:51,000 --> 01:45:53,000
但是现在好像已经有一阵子从来没有用过

1734
01:45:53,000 --> 01:45:55,000
爱不起来了是吧

1735
01:45:55,000 --> 01:45:56,000
对

1736
01:45:56,000 --> 01:45:57,000
我理解你

1737
01:45:57,000 --> 01:45:58,000
Numeric Py 也是

1738
01:45:58,000 --> 01:46:01,000
其实有一阵子我非常痴迷于在 Mac 上面

1739
01:46:01,000 --> 01:46:08,000
时刻保持一个 iPython 的 QT 版本的 Consoles 在跑

1740
01:46:08,000 --> 01:46:13,000
因为有 QT 你可以内连显示很多很酷

1741
01:46:13,000 --> 01:46:18,000
像 Mathematica 或者是 Maple 的那种感觉

1742
01:46:18,000 --> 01:46:21,000
就是你潇洒地写下几行代码

1743
01:46:21,000 --> 01:46:23,000
真正的科学计算环境

1744
01:46:23,000 --> 01:46:25,000
冒出一个图表来

1745
01:46:25,000 --> 01:46:29,000
我当时有阵子非常痴迷一定要保持我的 Mac 上面跑

1746
01:46:29,000 --> 01:46:31,000
其实现在也有很多人这么用

1747
01:46:31,000 --> 01:46:34,000
它现在 iPython 出了个叫做 Notebook

1748
01:46:34,000 --> 01:46:38,000
对其实 Python Notebook 是网页版的

1749
01:46:38,000 --> 01:46:42,000
但我就痴迷一定要有一个原生的图形界面的这么一个东西

1750
01:46:42,000 --> 01:46:44,000
它不就是为了解决跨平台的问题吗

1751
01:46:44,000 --> 01:46:46,000
看起来非常高大上主要是

1752
01:46:46,000 --> 01:46:47,000
简单一点

1753
01:46:47,000 --> 01:46:55,000
但是后来对但是后来我因为我在 GitHub 上面维护一个小 Note

1754
01:46:55,000 --> 01:47:00,000
就是怎样解决一些安装一台新 Mac 的时候

1755
01:47:00,000 --> 01:47:03,000
需要面对的小问题

1756
01:47:03,000 --> 01:47:12,000
然后我写在 iPython Qt 版本的这一段 Note 里面

1757
01:47:12,000 --> 01:47:14,000
倾注了大量的心血

1758
01:47:14,000 --> 01:47:18,000
然后最后最后最后的时候我绝望在里面写说

1759
01:47:18,000 --> 01:47:21,000
这一切都都都需要太多努力了

1760
01:47:21,000 --> 01:47:24,000
还是还是直接 give it up

1761
01:47:24,000 --> 01:47:27,000
and use iPython Notebook

1762
01:47:27,000 --> 01:47:30,000
好吧明白了

1763
01:47:30,000 --> 01:47:32,000
OK 接着说回来这个好东西

1764
01:47:32,000 --> 01:47:35,000
就是说前面那几个工具 setup tool

1765
01:47:35,000 --> 01:47:37,000
还有 Pip 都不能解决

1766
01:47:37,000 --> 01:47:39,000
不能很好的解决这个

1767
01:47:39,000 --> 01:47:44,000
就带有这种 Cbinding 或者这种其他语言 binding 的 Python 的包的安装

1768
01:47:44,000 --> 01:47:47,000
这个时候你有两种方案

1769
01:47:47,000 --> 01:47:49,000
就是像 Python ImageLiber 这种巨无霸的

1770
01:47:49,000 --> 01:47:51,000
因为它很大嘛

1771
01:47:51,000 --> 01:47:55,000
这种巨无霸的它通常给你提供一个官方的安装包

1772
01:47:55,000 --> 01:47:59,000
当然你就装上你用那个官方安装包通常是一个比较靠谱的办法

1773
01:47:59,000 --> 01:48:02,000
但是如果你想从某种方式去把这个东西管理起来

1774
01:48:02,000 --> 01:48:04,000
或者是能够帮忙自动化起来

1775
01:48:04,000 --> 01:48:06,000
就没有办法能够帮到你

1776
01:48:06,000 --> 01:48:09,000
所以后来就有另外一种另外一个工具

1777
01:48:09,000 --> 01:48:12,000
叫做 build out 这个你估计没有用过

1778
01:48:12,000 --> 01:48:13,000
其实我之前也没有听说过

1779
01:48:13,000 --> 01:48:15,000
我也是去了知乎之后

1780
01:48:15,000 --> 01:48:17,000
发现还有这么一个东西

1781
01:48:17,000 --> 01:48:20,000
这个东西来源其实还挺古老的

1782
01:48:20,000 --> 01:48:25,000
你知道 Python 在很 web 一点不 web 零点九的时代

1783
01:48:26,000 --> 01:48:29,000
出现过一个叫做 Zope 的这么一个机构

1784
01:48:29,000 --> 01:48:31,000
你不知道你有印象没

1785
01:48:31,000 --> 01:48:33,000
ZOP

1786
01:48:33,000 --> 01:48:34,000
我知道对我知道

1787
01:48:34,000 --> 01:48:44,000
而且号称 Zope 是当时如日中天的这么一个史诗级伟大的酷

1788
01:48:44,000 --> 01:48:45,000
是这样吗

1789
01:48:45,000 --> 01:48:47,000
他是一个 SIM

1790
01:48:47,000 --> 01:48:50,000
说他是 SIMS 好像不太严谨

1791
01:48:50,000 --> 01:48:55,000
他其实算人就算一个 framework

1792
01:48:55,000 --> 01:48:57,000
他自称一个 toolkit

1793
01:48:57,000 --> 01:49:01,000
对他是一个本来是用来建一个 SIMS 的一个 framework

1794
01:49:01,000 --> 01:49:02,000
确实可以这么理解

1795
01:49:02,000 --> 01:49:04,000
但是后来他越来越臃肿

1796
01:49:04,000 --> 01:49:06,000
已经可以做很多事情了

1797
01:49:06,000 --> 01:49:09,000
然后 build out 的这个工具其实就是最开始

1798
01:49:09,000 --> 01:49:11,000
如果我没记错的话

1799
01:49:11,000 --> 01:49:17,000
就是 Zope 那帮人为了解决他们那个巨无霸的 framework 的安装和开发的问题

1800
01:49:17,000 --> 01:49:19,000
就写出来的这么一个工具

1801
01:49:19,000 --> 01:49:22,000
然后这工具的特色是什么呢

1802
01:49:22,000 --> 01:49:29,000
他能支持这种带 Native Binding 的 Python 的包的安装

1803
01:49:29,000 --> 01:49:31,000
因为这里说起来就要提另外一件事情

1804
01:49:31,000 --> 01:49:33,000
就是比如说这个 Python Image Library

1805
01:49:33,000 --> 01:49:35,000
他虽然说是一个非纯

1806
01:49:35,000 --> 01:49:37,000
他虽然说需要有 Native Binding

1807
01:49:37,000 --> 01:49:41,000
但你安装的时候并不是安装他自己本身这么简单

1808
01:49:41,000 --> 01:49:44,000
你还得再装一些其他的什么 C 的一些酷

1809
01:49:44,000 --> 01:49:46,000
比如说 LibPng 什么乱七八糟的

1810
01:49:46,000 --> 01:49:48,000
然后在 Linux 上面这句话

1811
01:49:48,000 --> 01:49:51,000
你就要通过就在你装这个 PIL 之前

1812
01:49:51,000 --> 01:49:54,000
你还得用什么 APT 或者是样本的方式

1813
01:49:54,000 --> 01:49:57,000
把那些的 E-Line 给先给装上去

1814
01:49:57,000 --> 01:50:01,000
然后你再可以再装这个 Python Image Library 才可以成功

1815
01:50:01,000 --> 01:50:07,000
然后这样的话就其实手工操作是非常繁琐和容易出错的一个过程

1816
01:50:07,000 --> 01:50:09,000
你可以如果你不信你可以去试一下

1817
01:50:09,000 --> 01:50:11,000
我对此还是有错词

1818
01:50:11,000 --> 01:50:13,000
我对此还是有错词

1819
01:50:13,000 --> 01:50:17,000
因为装就像我说的 iPython 的 QT Console

1820
01:50:17,000 --> 01:50:18,000
其实也是这么一个过程

1821
01:50:18,000 --> 01:50:23,000
首先要用包管理工具去安装一些 Library

1822
01:50:23,000 --> 01:50:26,000
然后再安装 QT 之类的

1823
01:50:26,000 --> 01:50:30,000
然后再去再用 Python 去安装对应组件

1824
01:50:30,000 --> 01:50:33,000
然后还有什么 ZeroMQ 之类的东西

1825
01:50:33,000 --> 01:50:34,000
都要一个一个都装上

1826
01:50:34,000 --> 01:50:36,000
对对对其实我当时在中国用的是

1827
01:50:36,000 --> 01:50:43,000
也是因为就是最主要原因就是尝试用 ZeroMQ 要装一些 C 的东西

1828
01:50:43,000 --> 01:50:46,000
然后 Buildout 就可以用一个这种方式

1829
01:50:46,000 --> 01:50:47,000
它可以解决

1830
01:50:47,000 --> 01:50:48,000
它可以指定一些脚本

1831
01:50:48,000 --> 01:50:50,000
在你安装某个包之前

1832
01:50:50,000 --> 01:50:54,000
你可以先声明它依赖哪些非 Python 的东西

1833
01:50:54,000 --> 01:50:55,000
然后系统先帮你安装好

1834
01:50:55,000 --> 01:50:57,000
比如说支持一个 APT 什么的

1835
01:50:57,000 --> 01:50:58,000
帮你装好

1836
01:50:58,000 --> 01:50:59,000
然后你再装

1837
01:50:59,000 --> 01:51:00,000
然后再包那个过程

1838
01:51:00,000 --> 01:51:03,000
但是 Buildout 是一个神一样的存在你知道吗

1839
01:51:03,000 --> 01:51:05,000
现在我不知道情况会不会好转一些

1840
01:51:05,000 --> 01:51:07,000
当时我用的时候我想去学它

1841
01:51:07,000 --> 01:51:09,000
就是一个三无产品

1842
01:51:09,000 --> 01:51:10,000
就是你刷它网站之后

1843
01:51:10,000 --> 01:51:14,000
你知道你看不出这个没有官方文档

1844
01:51:14,000 --> 01:51:17,000
所有的能找到的都是直接网上稀稀拉拉一些教程

1845
01:51:17,000 --> 01:51:22,000
然后你不知道这个东西最开始不知道是谁在维护的

1846
01:51:22,000 --> 01:51:24,000
因为他现在没有没有说这个东西是找

1847
01:51:24,000 --> 01:51:25,000
你都不知道去找谁

1848
01:51:25,000 --> 01:51:27,000
他有一个 Main List

1849
01:51:27,000 --> 01:51:30,000
那是你没有办法再去

1850
01:51:30,000 --> 01:51:31,000
三无产品

1851
01:51:31,000 --> 01:51:34,000
我们可以定一下三无产品到底是哪三无

1852
01:51:34,000 --> 01:51:35,000
没有文档是肯定的

1853
01:51:35,000 --> 01:51:36,000
没有文档

1854
01:51:36,000 --> 01:51:38,000
没有这个稳定的开发者

1855
01:51:38,000 --> 01:51:41,000
然后你出了问题不知道去哪里问

1856
01:51:43,000 --> 01:51:44,000
无文档

1857
01:51:44,000 --> 01:51:45,000
无稳定维护者

1858
01:51:45,000 --> 01:51:47,000
还有一个五

1859
01:51:47,000 --> 01:51:48,000
就是不知道去哪里问问题

1860
01:51:48,000 --> 01:51:49,000
就出了问题找谁

1861
01:51:49,000 --> 01:51:52,000
无社区对

1862
01:51:52,000 --> 01:51:54,000
然后就发现哇这也可以

1863
01:51:54,000 --> 01:51:57,000
而且这既然是我所知道的

1864
01:51:57,000 --> 01:52:00,000
能够解决这个 Python

1865
01:52:00,000 --> 01:52:04,000
这种安装非纯 Python 包的唯一的一个比较好的

1866
01:52:04,000 --> 01:52:06,000
能用的工具都不能说它好了

1867
01:52:06,000 --> 01:52:08,000
能用的自动工具

1868
01:52:08,000 --> 01:52:10,000
然后它的体验是相当

1869
01:52:10,000 --> 01:52:11,000
使用体验是相当糟糕的

1870
01:52:11,000 --> 01:52:14,000
它的配置文件是一个点 Ini 的文件

1871
01:52:14,000 --> 01:52:16,000
What

1872
01:52:16,000 --> 01:52:17,000
然后你需要在

1873
01:52:17,000 --> 01:52:18,000
开发者是什么背景

1874
01:52:18,000 --> 01:52:20,000
Zop 嘛你自己想想这么古老的

1875
01:52:20,000 --> 01:52:21,000
Ancient 的东西

1876
01:52:21,000 --> 01:52:23,000
就出现这种情况也不奇怪了

1877
01:52:23,000 --> 01:52:26,000
就还好还好不是太糟糕

1878
01:52:26,000 --> 01:52:29,000
但糟糕的是你需要在这个 Ini 文件里面

1879
01:52:29,000 --> 01:52:30,000
Ini 文件的格式

1880
01:52:30,000 --> 01:52:32,000
你想来应该也很明白

1881
01:52:32,000 --> 01:52:33,000
就是有它分几个

1882
01:52:33,000 --> 01:52:35,000
一小节一小节一个 Section

1883
01:52:35,000 --> 01:52:37,000
每个 Section 是一个放过号不要分开

1884
01:52:37,000 --> 01:52:39,000
一个 Section

1885
01:52:39,000 --> 01:52:41,000
不管怎么说还是要比 XMI 要好

1886
01:52:41,000 --> 01:52:42,000
对还是比 XMI 要好一点

1887
01:52:42,000 --> 01:52:45,000
但是他们把这个已经用到了极致了

1888
01:52:45,000 --> 01:52:47,000
然后每个 Section 里面

1889
01:52:47,000 --> 01:52:51,000
它是一个 Key value 的一个 Pair

1890
01:52:51,000 --> 01:52:53,000
一个对就是一个主件

1891
01:52:53,000 --> 01:52:55,000
然后上面有一个数值

1892
01:52:55,000 --> 01:52:58,000
为了解决 Buildout 的中间的各种问题

1893
01:52:58,000 --> 01:53:00,000
你需要在里面插入

1894
01:53:00,000 --> 01:53:04,000
用一些很诡异的方法去写版本字符串

1895
01:53:04,000 --> 01:53:08,000
你需要在里面插入这个 Shell 脚本

1896
01:53:08,000 --> 01:53:11,000
在 Ini 里面插入 Shell 脚本

1897
01:53:11,000 --> 01:53:13,000
这是什么黑魔法

1898
01:53:13,000 --> 01:53:16,000
所以知道 Buildout 是多么一个惨痛的存在了

1899
01:53:16,000 --> 01:53:18,000
Holy

1900
01:53:18,000 --> 01:53:21,000
就是我一直对它吐槽不能

1901
01:53:21,000 --> 01:53:24,000
但是又不得不用的一个可能令人沮丧的攻击

1902
01:53:25,000 --> 01:53:27,000
可是我刚刚在 Buildout

1903
01:53:27,000 --> 01:53:32,000
我刚刚在 GitHub 上面发现了 Buildout slash Buildout 这个 Repository

1904
01:53:33,000 --> 01:53:34,000
什么玩意

1905
01:53:34,000 --> 01:53:36,000
这难道是他们官方的库吗

1906
01:53:36,000 --> 01:53:38,000
所以他已经去了 GitHub 了

1907
01:53:38,000 --> 01:53:41,000
所以可能事情有所好转

1908
01:53:41,000 --> 01:53:43,000
有可能

1909
01:53:43,000 --> 01:53:44,000
好吧

1910
01:53:44,000 --> 01:53:48,000
起码你可以去他的 Buildout.org 这个网站

1911
01:53:48,000 --> 01:53:51,000
你可以发现他有一个 Learn 这个选项

1912
01:53:51,000 --> 01:53:53,000
里面就是一堆 Tutorial

1913
01:53:53,000 --> 01:53:55,000
然后完了

1914
01:53:56,000 --> 01:54:00,000
然后他教你用他的唯一的方式就是给你一堆例子

1915
01:54:02,000 --> 01:54:09,000
而且在 GitRepository 里面的贡献最多的这个人叫做 Jim Fulton

1916
01:54:09,000 --> 01:54:15,000
他显示的工作地点是 Zope Corporation

1917
01:54:15,000 --> 01:54:21,000
所以有可能他就是你一直苦苦在寻找的主要维护者

1918
01:54:21,000 --> 01:54:23,000
对啊,因为这个 Buildout 是他写的嘛

1919
01:54:23,000 --> 01:54:28,000
但是我相当确定他没有再更新这个东西了

1920
01:54:29,000 --> 01:54:32,000
所以这是一个半死不活的项目

1921
01:54:32,000 --> 01:54:34,000
靠着社区也不知道谁在维护

1922
01:54:36,000 --> 01:54:38,000
就像油魂一样的软件

1923
01:54:38,000 --> 01:54:39,000
但是你又不得不用它

1924
01:54:39,000 --> 01:54:45,000
而且你发现 somehow 你竟然能够用它来还能用

1925
01:54:47,000 --> 01:54:49,000
所以软件不在心能用就行吗

1926
01:54:51,000 --> 01:54:53,000
但是其实很多可能经常会出问题

1927
01:54:53,000 --> 01:54:55,000
不过他还有一些比较令人

1928
01:54:55,000 --> 01:54:57,000
就是对于一个这么古老的软件

1929
01:54:57,000 --> 01:54:59,000
他有些令人蛮惊艳的特性

1930
01:54:59,000 --> 01:55:03,000
比如说刚才讲的那些什么屁股那些工具啊

1931
01:55:03,000 --> 01:55:07,000
就是经常那个拍皮那个主战挂了不就下不了了吗

1932
01:55:07,000 --> 01:55:11,000
Buildout 它竟然有自带的这种本地缓存机制

1933
01:55:11,000 --> 01:55:12,000
你知道吗

1934
01:55:12,000 --> 01:55:16,000
就是你一旦下载过某一个安装用过 refer 过某个版本

1935
01:55:16,000 --> 01:55:18,000
它会把那个版本的这个原码

1936
01:55:18,000 --> 01:55:21,000
就从拍皮或者是某个地方抓回来的

1937
01:55:21,000 --> 01:55:25,000
在你本地的它管理的一个一个隐藏的目录下面去存起来

1938
01:55:25,000 --> 01:55:28,000
这样你下次装它的你再运行 Buildout 的时候

1939
01:55:28,000 --> 01:55:30,000
它就不用再去往上抓

1940
01:55:30,000 --> 01:55:32,000
而且直接本地从那边复制一份过来就好了

1941
01:55:32,000 --> 01:55:34,000
OK 这什么好不惊讶的

1942
01:55:34,000 --> 01:55:35,000
因为 MAYMAY 也有这功能

1943
01:55:35,000 --> 01:55:38,000
对对对但是你想它是一个多古老的软件

1944
01:55:38,000 --> 01:55:40,000
有这种功能还是相当不错的

1945
01:55:40,000 --> 01:55:42,000
挺好的一个事情

1946
01:55:42,000 --> 01:55:45,000
但是它的使用体验实在是太糟糕了

1947
01:55:45,000 --> 01:55:49,000
好我对 Python 的吐槽

1948
01:55:49,000 --> 01:55:53,000
就为了不要拉太多仇恨吐槽到此为止

1949
01:55:53,000 --> 01:55:55,000
还好吧

1950
01:55:55,000 --> 01:55:57,000
只要我们是保持自黑的姿态

1951
01:55:57,000 --> 01:55:59,000
应该就不会招来太多的

1952
01:55:59,000 --> 01:56:01,000
不要黑别人的黑自己就行了

1953
01:56:01,000 --> 01:56:02,000
对

1954
01:56:02,000 --> 01:56:04,000
而我们来看一看敌对阵营

1955
01:56:04,000 --> 01:56:07,000
不不不现在我已经叛逃了

1956
01:56:07,000 --> 01:56:09,000
我已经加入了这个阵营

1957
01:56:09,000 --> 01:56:13,000
Node 这个 JavaScript 怎么说

1958
01:56:13,000 --> 01:56:15,000
你觉得 Node 是敌对阵营吗

1959
01:56:15,000 --> 01:56:17,000
我觉得 Node 是兄弟阵营

1960
01:56:17,000 --> 01:56:18,000
不是吗

1961
01:56:18,000 --> 01:56:19,000
那敌对阵营是哪里

1962
01:56:19,000 --> 01:56:21,000
Ruby 那是 Ruby

1963
01:56:21,000 --> 01:56:23,000
其实 Ruby 我不是很熟

1964
01:56:23,000 --> 01:56:24,000
我也不熟

1965
01:56:24,000 --> 01:56:28,000
但至少 GEM 这个包管语系统

1966
01:56:28,000 --> 01:56:30,000
在我有限的使用经验里面

1967
01:56:30,000 --> 01:56:32,000
要比 Python 的体验好很多

1968
01:56:32,000 --> 01:56:34,000
首先那只有一套对吧

1969
01:56:34,000 --> 01:56:39,000
不像 Python 那种四分五类的搞五套出来

1970
01:56:39,000 --> 01:56:41,000
对 Ruby 社区不管怎么说

1971
01:56:41,000 --> 01:56:43,000
最好的一点就是团结

1972
01:56:43,000 --> 01:56:45,000
我们 Python 社区做不到

1973
01:56:45,000 --> 01:56:49,000
对我觉得他们更加乐于去

1974
01:56:49,000 --> 01:56:53,000
为了达成一个共识去改变自己

1975
01:56:53,000 --> 01:56:55,000
对这点是挺好的

1976
01:56:55,000 --> 01:56:58,000
所以 GEM 的体验我其实体验不多了

1977
01:56:58,000 --> 01:57:00,000
你有什么体验吗

1978
01:57:00,000 --> 01:57:03,000
我老实说我也不是特别多

1979
01:57:03,000 --> 01:57:09,000
只不过 Ruby 简直是你接触一点

1980
01:57:09,000 --> 01:57:12,000
稍微新一点的东西是绕不开那个一个工具

1981
01:57:12,000 --> 01:57:13,000
最简单的

1982
01:57:13,000 --> 01:57:16,000
像上面提到的 Homebrew 是 Ruby 的

1983
01:57:16,000 --> 01:57:18,000
对 Homebrew 是 Ruby 的

1984
01:57:18,000 --> 01:57:23,000
比如说写 IOS 下面的包管语工具

1985
01:57:23,000 --> 01:57:25,000
或者 Object-C 的包管语工具

1986
01:57:25,000 --> 01:57:29,000
CocoaPods 也是 Ruby 写的

1987
01:57:29,000 --> 01:57:31,000
Yes 我没有说错

1988
01:57:31,000 --> 01:57:34,000
CocoaPods 本身是一个 Ruby GEM

1989
01:57:34,000 --> 01:57:36,000
很神奇吧

1990
01:57:36,000 --> 01:57:38,000
那它其实跟 Homebrew 的形式比较类似了吗

1991
01:57:38,000 --> 01:57:42,000
就它的 CocoaPods 一个 Pod 文件也是一个 Ruby 的文件吗

1992
01:57:42,000 --> 01:57:46,000
应该是这样的吧

1993
01:57:46,000 --> 01:57:48,000
我忘了 Pod

1994
01:57:48,000 --> 01:57:52,000
你这么一说我还真 Podfile 的语法是 Ruby 的语法吗

1995
01:57:52,000 --> 01:57:54,000
还是一个 Jason 还是一个什么东西

1996
01:57:54,000 --> 01:57:59,000
它是一个也是用 Ruby 写的 DSL

1997
01:57:59,000 --> 01:58:03,000
Ruby 开发者最喜欢做的事情就是写 DSL

1998
01:58:03,000 --> 01:58:06,000
Ruby 毕竟是一个非常适合写 DSL 的语言

1999
01:58:06,000 --> 01:58:09,000
你知道这句话我听的最熟的地方是在哪里吗

2000
01:58:09,000 --> 01:58:11,000
Skala

2001
01:58:11,000 --> 01:58:13,000
Skala 写 DSL

2002
01:58:13,000 --> 01:58:17,000
对 Ruby 写 DSL 你还觉得从人看出来一眼就能看出它是一个 Ruby 的文件

2003
01:58:17,000 --> 01:58:19,000
Skala 写 DSL My Ass

2004
01:58:19,000 --> 01:58:21,000
你听我解释你说 Ruby 写 DSL

2005
01:58:21,000 --> 01:58:25,000
它还有一些东西是很明显的 Ruby 的语法痕迹在里面对吧

2006
01:58:25,000 --> 01:58:27,000
你看出它是一个 class

2007
01:58:27,000 --> 01:58:31,000
然后它那个什么 block 的语法就是很鲜明的特点对吧

2008
01:58:31,000 --> 01:58:33,000
Skala 写出 DSL 你甚至看不出

2009
01:58:33,000 --> 01:58:35,000
有时候你不仔细看你还看不出它是 Skala

2010
01:58:35,000 --> 01:58:38,000
这是它的优点还是缺点

2011
01:58:38,000 --> 01:58:40,000
我总觉得越听越像缺点

2012
01:58:40,000 --> 01:58:41,000
这都是

2013
01:58:41,000 --> 01:58:44,000
优点就是说它能够可以让你定义一些很诡异的语法

2014
01:58:44,000 --> 01:58:46,000
它的原编程能力非常强大

2015
01:58:46,000 --> 01:58:50,000
缺点就是它可以编得连亲爹都不认识

2016
01:58:50,000 --> 01:58:53,000
对就是 Skala 那种写的 DSL

2017
01:58:53,000 --> 01:58:57,000
如果你不知道 DSL 的实现方式或者模板是怎么样子

2018
01:58:57,000 --> 01:58:59,000
你根本别想你别想往下写下去

2019
01:58:59,000 --> 01:59:01,000
这根本不现实

2020
01:59:01,000 --> 01:59:04,000
对有这种情况发生

2021
01:59:04,000 --> 01:59:06,000
还有什么呢

2022
01:59:06,000 --> 01:59:09,000
我前两天还用了一个什么东西

2023
01:59:09,000 --> 01:59:11,000
Rakefile

2024
01:59:11,000 --> 01:59:13,000
Rakefile 这个这种

2025
01:59:13,000 --> 01:59:16,000
也可以理解为 DSL

2026
01:59:16,000 --> 01:59:19,000
它本身也是一个 DSL 说实话

2027
01:59:19,000 --> 01:59:22,000
Rakefile 这种或者说 Rake 这个工具

2028
01:59:22,000 --> 01:59:25,000
在很多开源工具里面已经取代了

2029
01:59:25,000 --> 01:59:27,000
或者是

2030
01:59:27,000 --> 01:59:32,000
其他一些更加冷僻的工具

2031
01:59:32,000 --> 01:59:35,000
成为了一种默认的安装工具

2032
01:59:35,000 --> 01:59:37,000
或者是默认的执行工具

2033
01:59:37,000 --> 01:59:38,000
我觉得这也挺有意思的

2034
01:59:38,000 --> 01:59:42,000
就比如说前两天我在 Stack Overflow 上面

2035
01:59:42,000 --> 01:59:44,000
获得了风滚草讯证

2036
01:59:44,000 --> 01:59:49,000
就是提问了一个问题

2037
01:59:49,000 --> 01:59:50,000
没有人关注

2038
01:59:50,000 --> 01:59:51,000
没有人 Upvote

2039
01:59:51,000 --> 01:59:53,000
没有人回答

2040
01:59:53,000 --> 01:59:55,000
这叫风滚草

2041
01:59:55,000 --> 01:59:57,000
持续过了一个星期

2042
01:59:57,000 --> 02:00:00,000
然后你就会获得风滚草讯证

2043
02:00:00,000 --> 02:00:02,000
因为你提这个问题实在是太小众了

2044
02:00:02,000 --> 02:00:04,000
没有人去管

2045
02:00:04,000 --> 02:00:06,000
三无问题对吧

2046
02:00:06,000 --> 02:00:10,000
然后一个兄弟非常热心的来帮我

2047
02:00:10,000 --> 02:00:15,000
然后折腾出了一个 Git Repository

2048
02:00:15,000 --> 02:00:17,000
说你看我做了一个活生生的例子

2049
02:00:17,000 --> 02:00:18,000
你去试试吧

2050
02:00:18,000 --> 02:00:21,000
然后我兴高采的 PDR 跑回去看

2051
02:00:21,000 --> 02:00:24,000
你看里面是个 Rick File

2052
02:00:24,000 --> 02:00:27,000
相关问题是一个 Swift 的问题

2053
02:00:27,000 --> 02:00:31,000
但最后他 somehow 给了我一个 Rick File 的解决方案

2054
02:00:31,000 --> 02:00:35,000
而且他默认我是能理解这个东西

2055
02:00:35,000 --> 02:00:40,000
然后我愚蠢莽撞的 Rick 了一下

2056
02:00:40,000 --> 02:00:42,000
然后出错了

2057
02:00:42,000 --> 02:00:45,000
理解你的痛苦了

2058
02:00:45,000 --> 02:00:48,000
就不懂 Ruby

2059
02:00:48,000 --> 02:00:51,000
挤珠金就是到处被人欺负的感觉

2060
02:00:51,000 --> 02:00:52,000
好吧

2061
02:00:52,000 --> 02:00:55,000
那什么 Ruby 的吐槽我没法吐

2062
02:00:55,000 --> 02:00:56,000
因为我不用

2063
02:00:56,000 --> 02:00:57,000
然后我也不是很熟

2064
02:00:57,000 --> 02:00:58,000
Ruby 没有什么可吐槽的

2065
02:00:58,000 --> 02:00:59,000
说实话真的

2066
02:00:59,000 --> 02:01:00,000
好

2067
02:01:00,000 --> 02:01:03,000
现在我们来说另外一个敌对阵

2068
02:01:03,000 --> 02:01:05,000
Note

2069
02:01:05,000 --> 02:01:06,000
Note 有一个很不错

2070
02:01:06,000 --> 02:01:07,000
就在我看来

2071
02:01:07,000 --> 02:01:12,000
在这些主流的动态语言里面

2072
02:01:12,000 --> 02:01:15,000
比较好的实现的一个包管理器

2073
02:01:15,000 --> 02:01:17,000
这个叫 NPM

2074
02:01:17,000 --> 02:01:19,000
其实他甚至都不完全是一个包管理器

2075
02:01:19,000 --> 02:01:21,000
他还能做一些别的事

2076
02:01:21,000 --> 02:01:24,000
什么运行态的东西

2077
02:01:24,000 --> 02:01:25,000
还部署他也能做

2078
02:01:25,000 --> 02:01:27,000
其实还挺好的

2079
02:01:27,000 --> 02:01:30,000
他有点像一个 Configuration Tool

2080
02:01:30,000 --> 02:01:31,000
对

2081
02:01:31,000 --> 02:01:33,000
他范畴有点还不太一样

2082
02:01:33,000 --> 02:01:35,000
但是这个先不去纠结这些细节了

2083
02:01:35,000 --> 02:01:38,000
但是就说他作为包管理器的优点

2084
02:01:38,000 --> 02:01:40,000
我觉得还是比较明显的

2085
02:01:40,000 --> 02:01:42,000
就是他干净

2086
02:01:42,000 --> 02:01:44,000
这干净什么意思呢

2087
02:01:44,000 --> 02:01:46,000
就是我们用这个 Pip 安装也好

2088
02:01:46,000 --> 02:01:47,000
还是 Ruby Jam 安装也好

2089
02:01:47,000 --> 02:01:50,000
默认是安装进系统目录的

2090
02:01:50,000 --> 02:01:51,000
换句话说

2091
02:01:51,000 --> 02:01:53,000
你只要没什么事

2092
02:01:53,000 --> 02:01:55,000
你只要在这里装一个了

2093
02:01:55,000 --> 02:01:56,000
你的系统那个

2094
02:01:56,000 --> 02:01:58,000
就系统的 Python 那个包的目录

2095
02:01:58,000 --> 02:02:01,000
就已经被打引号的污染了

2096
02:02:01,000 --> 02:02:03,000
没法再回到之前那个状态了

2097
02:02:03,000 --> 02:02:05,000
特别是你用了 Python 那种

2098
02:02:05,000 --> 02:02:07,000
只可 insole 不可 unsole 的状态的

2099
02:02:07,000 --> 02:02:09,000
这种工具的情况下

2100
02:02:10,000 --> 02:02:11,000
Jam 可以 unsole 吗

2101
02:02:11,000 --> 02:02:13,000
Jam 等等

2102
02:02:13,000 --> 02:02:14,000
Jam 当然可以 unsole 到

2103
02:02:14,000 --> 02:02:18,000
而且 Jam 是可以装在本身的

2104
02:02:18,000 --> 02:02:20,000
local project 下面

2105
02:02:20,000 --> 02:02:21,000
家目录或者是本地目录

2106
02:02:21,000 --> 02:02:24,000
直接装在 windows 下面的

2107
02:02:24,000 --> 02:02:27,000
但是他的默认也是装到系统吧

2108
02:02:27,000 --> 02:02:28,000
是吗

2109
02:02:28,000 --> 02:02:29,000
默认

2110
02:02:29,000 --> 02:02:30,000
我记得是这样子

2111
02:02:30,000 --> 02:02:32,000
就系统可能是说一个用户

2112
02:02:32,000 --> 02:02:33,000
或者是你用 sudo 的话

2113
02:02:33,000 --> 02:02:36,000
就是系统的根里面那些什么

2114
02:02:36,000 --> 02:02:37,000
用在 local 里面

2115
02:02:37,000 --> 02:02:39,000
这不是一个非常

2116
02:02:39,000 --> 02:02:42,000
就是如果你用 Bandler 的话

2117
02:02:42,000 --> 02:02:44,000
Bandler 本身是一个 Jam

2118
02:02:44,000 --> 02:02:46,000
然后你用 Bandler 来管理你的 Jam

2119
02:02:46,000 --> 02:02:47,000
E-Line 的话

2120
02:02:47,000 --> 02:02:50,000
Bandler 默认是安装在当前目录下的

2121
02:02:52,000 --> 02:02:56,000
如果你只要用一个他给的那个

2122
02:02:56,000 --> 02:02:57,000
不是他给的

2123
02:02:57,000 --> 02:02:58,000
就是他

2124
02:02:58,000 --> 02:03:00,000
如果你用 Bandler 这个 Jam

2125
02:03:00,000 --> 02:03:03,000
来管理你的项目的 E-Line 的 Jam 的话

2126
02:03:03,000 --> 02:03:07,000
就是工业线条

2127
02:03:07,000 --> 02:03:09,000
就是几乎每一个好一点的

2128
02:03:09,000 --> 02:03:11,000
Ruby 项目几乎都是用 Bandler 的

2129
02:03:11,000 --> 02:03:14,000
然后你就不会去污染你的全局 Jam

2130
02:03:14,000 --> 02:03:16,000
所以还是有一个 best practice 在那里

2131
02:03:16,000 --> 02:03:18,000
对有一个 best practice

2132
02:03:18,000 --> 02:03:21,000
不像比阵营

2133
02:03:21,000 --> 02:03:22,000
我已经不是了

2134
02:03:22,000 --> 02:03:23,000
我已经宣布脱离了

2135
02:03:23,000 --> 02:03:24,000
好吧

2136
02:03:24,000 --> 02:03:25,000
OK

2137
02:03:25,000 --> 02:03:27,000
讲回 note 这个东西

2138
02:03:27,000 --> 02:03:28,000
NPM

2139
02:03:28,000 --> 02:03:31,000
他是默认是装在当前目录上面的

2140
02:03:31,000 --> 02:03:32,000
就是你可能每个工程

2141
02:03:32,000 --> 02:03:33,000
每个项目是有一个

2142
02:03:33,000 --> 02:03:36,000
自己的 Node module 这么一个目录

2143
02:03:36,000 --> 02:03:39,000
然后你在里面执行 NPM install 之后

2144
02:03:39,000 --> 02:03:41,000
他装的所有东西都会默认在那里面

2145
02:03:41,000 --> 02:03:43,000
然后如果你是要装在系统级别的话

2146
02:03:43,000 --> 02:03:47,000
你这要加一个就 Global 这个选项

2147
02:03:47,000 --> 02:03:49,000
他才会装到你的 Jam 目录

2148
02:03:49,000 --> 02:03:50,000
或者是你速度的情况下

2149
02:03:50,000 --> 02:03:52,000
装到你的系统级别的目录里面去

2150
02:03:52,000 --> 02:03:57,000
他在一开始就鼓励一种就是所谓

2151
02:03:57,000 --> 02:03:58,000
完全分离

2152
02:03:58,000 --> 02:03:59,000
完全分离

2153
02:03:59,000 --> 02:04:02,000
他们觉得磁盘空间的损失算不得什么

2154
02:04:02,000 --> 02:04:04,000
重点是不要互相干扰

2155
02:04:04,000 --> 02:04:07,000
所以这种冲衅方式

2156
02:04:07,000 --> 02:04:09,000
但他有自己的原因

2157
02:04:09,000 --> 02:04:12,000
就是因为在所有的软件包里面

2158
02:04:12,000 --> 02:04:16,000
可能 Node 的软件包的版本跳跃是最快的

2159
02:04:16,000 --> 02:04:20,000
我上个月装的开发一个软件的版本

2160
02:04:20,000 --> 02:04:23,000
用的一个酷可能是 0.2 点几

2161
02:04:23,000 --> 02:04:26,000
我这个月升级看这已经 1.2 点几

2162
02:04:26,000 --> 02:04:30,000
如果你想最快最短时间之内

2163
02:04:30,000 --> 02:04:34,000
在屏幕上获得最多的数据流

2164
02:04:34,000 --> 02:04:36,000
并且多多少少能让人看得懂的话

2165
02:04:36,000 --> 02:04:39,000
请执行 NPM Update

2166
02:04:39,000 --> 02:04:40,000
对

2167
02:04:40,000 --> 02:04:44,000
所以也是因为这个残酷的现实使得

2168
02:04:44,000 --> 02:04:46,000
可能我这么猜的

2169
02:04:46,000 --> 02:04:50,000
就是 Node 社区必须要把这种版本依赖

2170
02:04:50,000 --> 02:04:53,000
就是这个要 contained

2171
02:04:53,000 --> 02:04:56,000
就是要局部化

2172
02:04:56,000 --> 02:04:58,000
因为一旦安装全机这个事没法玩了

2173
02:04:58,000 --> 02:05:01,000
这是他们拥抱改变的方式

2174
02:05:01,000 --> 02:05:04,000
然后他们对这个版本的

2175
02:05:04,000 --> 02:05:06,000
刚才我们讲交叉依赖解决得很好

2176
02:05:06,000 --> 02:05:09,000
他是用我说的那种方式

2177
02:05:09,000 --> 02:05:12,000
就是各个包去装自己的依赖

2178
02:05:12,000 --> 02:05:14,000
互相不要干扰

2179
02:05:14,000 --> 02:05:16,000
同样就举一个最简单的例子

2180
02:05:16,000 --> 02:05:19,000
我写这个程序叫 A

2181
02:05:19,000 --> 02:05:20,000
然后他依赖 B

2182
02:05:20,000 --> 02:05:22,000
然后也依赖 C

2183
02:05:22,000 --> 02:05:25,000
然后我的程序 A 依赖 B 和 C 这两个包

2184
02:05:25,000 --> 02:05:28,000
然后 C 这个包他又依赖于 B

2185
02:05:28,000 --> 02:05:30,000
但是可能是依赖 B 的另外一个

2186
02:05:30,000 --> 02:05:32,000
叫早或者叫新的版本

2187
02:05:32,000 --> 02:05:34,000
NPM 的解决方案就是说

2188
02:05:34,000 --> 02:05:36,000
我这个程序装的时候

2189
02:05:36,000 --> 02:05:38,000
我写我要 B 的包的这个版本

2190
02:05:38,000 --> 02:05:40,000
我要 C 的包的那个版本

2191
02:05:40,000 --> 02:05:41,000
然后他就会去装 B

2192
02:05:41,000 --> 02:05:44,000
然后就会把在我当前目录的 Node module

2193
02:05:44,000 --> 02:05:47,000
里面有一个目录名字是 B 包的名字

2194
02:05:47,000 --> 02:05:49,000
还有一个名字是 C 的包的名字

2195
02:05:49,000 --> 02:05:51,000
然后你进到 Node module

2196
02:05:51,000 --> 02:05:53,000
你进到 B 那个包的那个名字的目录里面

2197
02:05:53,000 --> 02:05:56,000
就发现他又是一个带有 Node module 的一个包

2198
02:05:56,000 --> 02:05:58,000
所以他就是在每一个包里面

2199
02:05:58,000 --> 02:06:03,000
他都是独立的一个 Node package 的层级

2200
02:06:03,000 --> 02:06:04,000
关系在里面

2201
02:06:04,000 --> 02:06:07,000
就不会出现说我依赖 A

2202
02:06:07,000 --> 02:06:08,000
我依赖 B

2203
02:06:08,000 --> 02:06:09,000
然后我也依赖 C

2204
02:06:09,000 --> 02:06:10,000
C 依赖 B 的另外一个版本

2205
02:06:10,000 --> 02:06:12,000
这种交叉依赖会对我导致的影响

2206
02:06:12,000 --> 02:06:16,000
对我来说我是看不见 C 依赖了什么东西的

2207
02:06:16,000 --> 02:06:17,000
对

2208
02:06:17,000 --> 02:06:19,000
就这点是我觉得他做得比较好的地方

2209
02:06:19,000 --> 02:06:21,000
就是整个是很干净

2210
02:06:21,000 --> 02:06:23,000
就很这个明确很干净

2211
02:06:23,000 --> 02:06:26,000
而且是局域化的

2212
02:06:26,000 --> 02:06:30,000
而且他的这个删除也很简单

2213
02:06:30,000 --> 02:06:31,000
你不想用了

2214
02:06:31,000 --> 02:06:33,000
你直接把那个 Node module 里面的那些东西清掉就好了

2215
02:06:33,000 --> 02:06:34,000
对

2216
02:06:34,000 --> 02:06:38,000
就不会在你操作系统的其他任何地方留下垃圾

2217
02:06:38,000 --> 02:06:39,000
如果你有截片的话

2218
02:06:39,000 --> 02:06:43,000
这点是相当令人解放的一件事情

2219
02:06:43,000 --> 02:06:45,000
这跟 JavaScript 的特性有关嘛

2220
02:06:45,000 --> 02:06:50,000
JavaScript 不是一种严格意义上的

2221
02:06:50,000 --> 02:06:55,000
为联合不同系统

2222
02:06:55,000 --> 02:06:58,000
组建的 Glued language 出现的

2223
02:06:58,000 --> 02:06:59,000
对

2224
02:06:59,000 --> 02:07:03,000
其实这也出了一个问题

2225
02:07:03,000 --> 02:07:06,000
JavaScript 有 Native keybinding

2226
02:07:06,000 --> 02:07:09,000
Native binding 需要 compile 的情况出现吗

2227
02:07:09,000 --> 02:07:10,000
应该是有的

2228
02:07:10,000 --> 02:07:11,000
比如说我经常安装的时候

2229
02:07:11,000 --> 02:07:16,000
他会去运行一下 C 的 Compiler 装什么东西

2230
02:07:16,000 --> 02:07:19,000
但是具体他在做什么我也不是太清楚

2231
02:07:19,000 --> 02:07:21,000
因为我印象里面 JavaScript

2232
02:07:21,000 --> 02:07:25,000
NPM 社区极端到连什么 MineSQL 的二进制代码都要

2233
02:07:25,000 --> 02:07:29,000
二进制的协议都要写一个 JavaScript 的版本

2234
02:07:29,000 --> 02:07:30,000
What

2235
02:07:30,000 --> 02:07:32,000
就不要去调用 C 库

2236
02:07:32,000 --> 02:07:33,000
这是为什么呢

2237
02:07:33,000 --> 02:07:35,000
不能调用 C 库吗

2238
02:07:35,000 --> 02:07:36,000
我不太确定

2239
02:07:36,000 --> 02:07:39,000
就你诈问我 JavaScript 怎么调用 C 库

2240
02:07:39,000 --> 02:07:40,000
但是确实有一点

2241
02:07:40,000 --> 02:07:43,000
他们是很愿意把所有东西都用 JavaScript 重新写一遍

2242
02:07:43,000 --> 02:07:44,000
这里面其实是有好处的

2243
02:07:44,000 --> 02:07:47,000
比如说你可以只用到 V 8 的

2244
02:07:47,000 --> 02:07:48,000
中间联动的面包

2245
02:07:48,000 --> 02:07:50,000
V 8 的 JIT 的特性

2246
02:07:50,000 --> 02:07:53,000
然后你可以调试出错都很方便

2247
02:07:53,000 --> 02:07:58,000
然后你包括管理起来也会很方便

2248
02:07:58,000 --> 02:08:00,000
一群极端主义者

2249
02:08:00,000 --> 02:08:04,000
然后 NPM 他在每一个包的里面

2250
02:08:04,000 --> 02:08:07,000
他那个 package.json 这个文件也很简单

2251
02:08:07,000 --> 02:08:09,000
你把那些常见东西写进来

2252
02:08:09,000 --> 02:08:10,000
然后依赖关写进来

2253
02:08:10,000 --> 02:08:13,000
然后 NPM 这个命令行的工具也是比较强大的

2254
02:08:13,000 --> 02:08:17,000
他甚至连那种连你的版本号的写法

2255
02:08:17,000 --> 02:08:19,000
都有快捷命令帮你去搞定

2256
02:08:19,000 --> 02:08:23,000
他们是遵从这个 Semantic version 这个做法

2257
02:08:23,000 --> 02:08:25,000
就是 A 点 B 点 C

2258
02:08:25,000 --> 02:08:26,000
然后 H 大版本号

2259
02:08:26,000 --> 02:08:28,000
说变了 API 肯定变了

2260
02:08:28,000 --> 02:08:29,000
然后 B 是小版本号

2261
02:08:29,000 --> 02:08:30,000
是一个变的话

2262
02:08:30,000 --> 02:08:33,000
肯定是有很多各种新的内容

2263
02:08:33,000 --> 02:08:35,000
但是应该是向下接拢的

2264
02:08:35,000 --> 02:08:38,000
然后 C 是小升级

2265
02:08:38,000 --> 02:08:41,000
什么 bugfix 之类不影响接口的这种情况

2266
02:08:41,000 --> 02:08:44,000
他连这个都已经帮你考虑好了

2267
02:08:44,000 --> 02:08:46,000
而且如果你 NPM 的包

2268
02:08:46,000 --> 02:08:50,000
是在一个 Git 的 Raposter 里面的话

2269
02:08:50,000 --> 02:08:52,000
他甚至你做完 NPM version

2270
02:08:52,000 --> 02:08:55,000
然后 patch 或者是 miner 这种命令之后

2271
02:08:55,000 --> 02:08:58,000
就是把那个命令版本号升级一位

2272
02:08:58,000 --> 02:09:02,000
他连 Git 的 tag 这些都帮你做好了

2273
02:09:02,000 --> 02:09:03,000
真是贴心

2274
02:09:03,000 --> 02:09:04,000
真是贴心

2275
02:09:04,000 --> 02:09:06,000
对简直就是贴心小棉袄

2276
02:09:06,000 --> 02:09:09,000
非常方便用起来很爽

2277
02:09:09,000 --> 02:09:13,000
而且也从一个侧面反映了 NPM 的社区

2278
02:09:13,000 --> 02:09:14,000
其实是一个非常活的一个社区

2279
02:09:14,000 --> 02:09:16,000
不管多少人怎么样

2280
02:09:16,000 --> 02:09:18,000
整个世界在嘲笑他们

2281
02:09:18,000 --> 02:09:20,000
但可能就是因为这种受嫩者的姿态

2282
02:09:20,000 --> 02:09:23,000
迫使他们仅仅团结到了一起

2283
02:09:23,000 --> 02:09:27,000
NPM 社区就是惹见开发界的犹太人

2284
02:09:29,000 --> 02:09:31,000
反正整个来说 NPM 的体验

2285
02:09:31,000 --> 02:09:35,000
NPM 的体验是我目前用过所有的这种

2286
02:09:35,000 --> 02:09:38,000
就是语言原生的包管理器里面

2287
02:09:38,000 --> 02:09:40,000
体验最好的一个吧

2288
02:09:40,000 --> 02:09:42,000
那可能是我咕噜管没见过更好的

2289
02:09:43,000 --> 02:09:45,000
我也真的没有见过更好的

2290
02:09:45,000 --> 02:09:49,000
更好的可能就只能是什么图形化的

2291
02:09:49,000 --> 02:09:51,000
然后给最终用户用的

2292
02:09:52,000 --> 02:09:56,000
对所以这个是 NPM 的一个挺好的地方

2293
02:09:57,000 --> 02:09:59,000
现在再说一个现在本人的大爱

2294
02:09:59,000 --> 02:10:01,000
Go 里面是怎么做的这件事

2295
02:10:01,000 --> 02:10:03,000
Go 传教室 Rail 同学又来了

2296
02:10:03,000 --> 02:10:06,000
其实你知道 Go 里面怎么做这件事情吗

2297
02:10:06,000 --> 02:10:07,000
Go get 吗

2298
02:10:07,000 --> 02:10:08,000
不是吗

2299
02:10:08,000 --> 02:10:10,000
对但是它的哲学就是蛮奇怪的

2300
02:10:10,000 --> 02:10:12,000
就通常讲前面我们提到的

2301
02:10:12,000 --> 02:10:17,000
比如说 Java 也好 Python 也好 Node 也好

2302
02:10:17,000 --> 02:10:18,000
还有 Ruby Jam 也好

2303
02:10:18,000 --> 02:10:20,000
他们都有一个所谓的

2304
02:10:21,000 --> 02:10:24,000
所谓官方正式认可的这么一个集中

2305
02:10:24,000 --> 02:10:26,000
发布软件包的渠道对吧

2306
02:10:26,000 --> 02:10:28,000
对有一个 reports 在那边

2307
02:10:28,000 --> 02:10:29,000
而 Go 是没有的

2308
02:10:29,000 --> 02:10:30,000
对 Go 是没有的

2309
02:10:30,000 --> 02:10:36,000
Go 完全是一个去中心化的一个发布方式

2310
02:10:36,000 --> 02:10:39,000
然后这会导致一些很奇怪的一些状况

2311
02:10:39,000 --> 02:10:42,000
比如说我们通常一个包的名字

2312
02:10:42,000 --> 02:10:43,000
你要引用它的时候

2313
02:10:43,000 --> 02:10:45,000
比如说在 Python 里面

2314
02:10:45,000 --> 02:10:48,000
比如说 importJson 就好了对吧

2315
02:10:48,000 --> 02:10:51,000
可能用官方标准的你可以用 import 的一个

2316
02:10:51,000 --> 02:10:53,000
Json 这个例子不好

2317
02:10:53,000 --> 02:10:54,000
另外举个什么例子

2318
02:10:54,000 --> 02:10:55,000
request 吧

2319
02:10:55,000 --> 02:10:56,000
request 吧

2320
02:10:56,000 --> 02:10:57,000
这个这个这个

2321
02:10:57,000 --> 02:10:58,000
一个 import request

2322
02:10:58,000 --> 02:10:59,000
你这个指定好了

2323
02:10:59,000 --> 02:11:02,000
这个它你在用的时候和它的

2324
02:11:02,000 --> 02:11:03,000
你和怎么拿到它

2325
02:11:03,000 --> 02:11:05,000
是一个完全分离的过程对吧

2326
02:11:05,000 --> 02:11:07,000
你是在 Python install request

2327
02:11:07,000 --> 02:11:10,000
它去那个 pypy 上面下载回来

2328
02:11:10,000 --> 02:11:12,000
但你并不知道它到底是在哪

2329
02:11:12,000 --> 02:11:13,000
然后你就用的时候

2330
02:11:13,000 --> 02:11:15,000
你也不需要关心这个东西

2331
02:11:15,000 --> 02:11:16,000
本来是 host 在哪里的

2332
02:11:16,000 --> 02:11:17,000
但 Go 里面不一样

2333
02:11:17,000 --> 02:11:21,000
Go 里面的 import 那个路径

2334
02:11:22,000 --> 02:11:24,000
就是官方认可的方式

2335
02:11:24,000 --> 02:11:28,000
就是你的那个原代码库的路径

2336
02:11:28,000 --> 02:11:29,000
就是比如说

2337
02:11:29,000 --> 02:11:30,000
它和 report 相关的

2338
02:11:30,000 --> 02:11:31,000
它不能做到

2339
02:11:31,000 --> 02:11:33,000
比如说我自己有一个 GitHub 的目录

2340
02:11:33,000 --> 02:11:35,000
我是 github.com

2341
02:11:35,000 --> 02:11:38,000
协干 realtboard 下面一个什么软件

2342
02:11:38,000 --> 02:11:40,000
就是我的一个 Go 的软件

2343
02:11:40,000 --> 02:11:41,000
我就直接要把那一段

2344
02:11:41,000 --> 02:11:45,000
写到那个 Go 的原程序里面去

2345
02:11:45,000 --> 02:11:47,000
这样我就可以

2346
02:11:47,000 --> 02:11:49,000
就如果我要引用某一个其他软件

2347
02:11:49,000 --> 02:11:51,000
我也得把他的那个 reposted 的地址

2348
02:11:51,000 --> 02:11:53,000
放到那个路径里面去

2349
02:11:53,000 --> 02:11:55,000
然后 go get 这个东西有个黑魔法

2350
02:11:55,000 --> 02:11:58,000
就是它能够自动识别常见的

2351
02:11:58,000 --> 02:12:00,000
包管理的地址

2352
02:12:00,000 --> 02:12:02,000
比如它知道 github 怎么去取

2353
02:12:02,000 --> 02:12:04,000
它知道那个 bipocket 怎么去取

2354
02:12:04,000 --> 02:12:05,000
它知道那个什么

2355
02:12:05,000 --> 02:12:07,000
mercury 那些东西怎么去取

2356
02:12:07,000 --> 02:12:09,000
然后它会自动的给

2357
02:12:09,000 --> 02:12:11,000
通过这个路径去找到那个 reposted

2358
02:12:11,000 --> 02:12:12,000
下载回来

2359
02:12:12,000 --> 02:12:13,000
放到你本地的一个

2360
02:12:13,000 --> 02:12:15,000
约定好的路径里面去

2361
02:12:15,000 --> 02:12:17,000
然后这样就把这个事情完成了

2362
02:12:17,000 --> 02:12:19,000
而且它是这个所谓的

2363
02:12:19,000 --> 02:12:20,000
recursive 的一个过程

2364
02:12:20,000 --> 02:12:21,000
就是比如说我

2365
02:12:21,000 --> 02:12:23,000
我要去 go get 一个包

2366
02:12:23,000 --> 02:12:25,000
比如大家在 github 下面

2367
02:12:25,000 --> 02:12:28,000
某一个附写杠 bar 这个包

2368
02:12:28,000 --> 02:12:29,000
然后这个附写杠 bar 这个包

2369
02:12:29,000 --> 02:12:31,000
它有引用的附写杠 spam 这个包

2370
02:12:31,000 --> 02:12:35,000
它会连带的把那些东西也拿回来

2371
02:12:35,000 --> 02:12:37,000
因为它能够分析到里面的 import pass

2372
02:12:37,000 --> 02:12:38,000
它能够知道缺什么

2373
02:12:38,000 --> 02:12:39,000
然后它也知道

2374
02:12:39,000 --> 02:12:41,000
因为那个 import pass 就是你的那个

2375
02:12:41,000 --> 02:12:42,000
git 项目的地址

2376
02:12:42,000 --> 02:12:44,000
或者是那个 HG 项目的地址

2377
02:12:44,000 --> 02:12:45,000
它就能够去到那里

2378
02:12:45,000 --> 02:12:47,000
就把所有东西给你抓回来

2379
02:12:48,000 --> 02:12:52,000
所以它通过一种非常复杂的方式

2380
02:12:52,000 --> 02:12:56,000
使得一个包的 reposted somehow

2381
02:12:56,000 --> 02:12:58,000
成为了它的命名空间的一部分

2382
02:12:58,000 --> 02:12:59,000
对没错

2383
02:12:59,000 --> 02:13:00,000
就这样的

2384
02:13:00,000 --> 02:13:01,000
有意思

2385
02:13:01,000 --> 02:13:04,000
那你觉得这种做法是

2386
02:13:04,000 --> 02:13:05,000
是衔的弹疼呢

2387
02:13:05,000 --> 02:13:07,000
还是自由其道的所在

2388
02:13:07,000 --> 02:13:08,000
这个怎么说呢

2389
02:13:08,000 --> 02:13:09,000
就是友好

2390
02:13:09,000 --> 02:13:11,000
就肯定是有好处有坏处的好

2391
02:13:11,000 --> 02:13:12,000
就是简单嘛

2392
02:13:12,000 --> 02:13:14,000
就是首先他们我们讲的

2393
02:13:14,000 --> 02:13:17,000
它不是一个集中化的东西

2394
02:13:17,000 --> 02:13:18,000
它可是一个分布式东西

2395
02:13:18,000 --> 02:13:19,000
它没有一个所谓

2396
02:13:19,000 --> 02:13:21,000
它不能说你给它一个包的名字

2397
02:13:21,000 --> 02:13:23,000
它默认去哪个地方去找

2398
02:13:23,000 --> 02:13:24,000
然后帮你下载回来

2399
02:13:24,000 --> 02:13:25,000
因为它没有这么一个

2400
02:13:25,000 --> 02:13:26,000
中央存储的地方

2401
02:13:27,000 --> 02:13:29,000
所以它只能把这种方式

2402
02:13:29,000 --> 02:13:30,000
把这个地址的信息

2403
02:13:30,000 --> 02:13:36,000
嵌入到这个包的原代码里面去

2404
02:13:36,000 --> 02:13:38,000
然后通过这种 go get 的工具

2405
02:13:38,000 --> 02:13:40,000
去把这个事情帮你解决了

2406
02:13:40,000 --> 02:13:42,000
但是它不好的地方其实也很明显了

2407
02:13:42,000 --> 02:13:43,000
比如说最简单一个例子

2408
02:13:43,000 --> 02:13:44,000
我用了一个包

2409
02:13:45,000 --> 02:13:47,000
然后我 fork 了它

2410
02:13:47,000 --> 02:13:49,000
就它的 grapher 功能不太好

2411
02:13:49,000 --> 02:13:50,000
我 fork 它

2412
02:13:50,000 --> 02:13:51,000
然后我要改的时候

2413
02:13:51,000 --> 02:13:52,000
你就会发现很痛苦

2414
02:13:52,000 --> 02:13:54,000
因为你改的时候就会必然

2415
02:13:54,000 --> 02:13:55,000
你 fork 的时候

2416
02:13:55,000 --> 02:13:57,000
必然改变它的那个 import 路径嘛

2417
02:13:57,000 --> 02:13:58,000
对

2418
02:13:58,000 --> 02:14:01,000
但是如果里面又 import 自己的

2419
02:14:01,000 --> 02:14:03,000
或者别人又 import 你的时候

2420
02:14:03,000 --> 02:14:07,000
你也去改相关 import 到你的那个包的软件

2421
02:14:07,000 --> 02:14:09,000
才能够使得你的这个修改

2422
02:14:09,000 --> 02:14:11,000
能够被别人看见

2423
02:14:11,000 --> 02:14:17,000
所以它 somehow 增加了软件包维护的难度

2424
02:14:17,000 --> 02:14:18,000
对

2425
02:14:18,000 --> 02:14:19,000
就有点这里有点小不爽嘛

2426
02:14:19,000 --> 02:14:22,000
就是你得去手工改一下那个 import 路径

2427
02:14:22,000 --> 02:14:23,000
如果你 fork 之后

2428
02:14:23,000 --> 02:14:26,000
如果你 fork 没有被这个 merge 回去的话

2429
02:14:26,000 --> 02:14:30,000
就是说你做了一个本地的不兼容的 fork

2430
02:14:30,000 --> 02:14:32,000
然后另外一个问题就是说

2431
02:14:32,000 --> 02:14:36,000
你会发现你这种整个过程中没有出现版本这个概念

2432
02:14:36,000 --> 02:14:38,000
比如说你可以在这个版本里面

2433
02:14:38,000 --> 02:14:39,000
出现版本这个概念

2434
02:14:39,000 --> 02:14:42,000
比如说你可以在 python 也好

2435
02:14:42,000 --> 02:14:43,000
还是那个 npm 也好

2436
02:14:43,000 --> 02:14:45,000
你去安装一个包的时候

2437
02:14:45,000 --> 02:14:46,000
它会告诉你安装了什么版本

2438
02:14:46,000 --> 02:14:47,000
对吧

2439
02:14:47,000 --> 02:14:49,000
对它甚至可以告诉你说

2440
02:14:49,000 --> 02:14:52,000
请尽量安装接近于那个版本的版本

2441
02:14:52,000 --> 02:14:53,000
对

2442
02:14:53,000 --> 02:14:54,000
这个还挺

2443
02:14:54,000 --> 02:14:55,000
对

2444
02:14:55,000 --> 02:14:56,000
就是它有一个中央存储

2445
02:14:56,000 --> 02:14:57,000
它会有这个就是包的名字

2446
02:14:57,000 --> 02:14:58,000
然后有这个版本号

2447
02:14:58,000 --> 02:14:59,000
包括把历史的版本号

2448
02:14:59,000 --> 02:15:00,000
它会记录下来

2449
02:15:00,000 --> 02:15:02,000
然后你可以说我可以指定

2450
02:15:02,000 --> 02:15:04,000
说 2.02.X 他们都可以

2451
02:15:04,000 --> 02:15:05,000
或者我一定 2.1

2452
02:15:05,000 --> 02:15:06,000
或者一定 2.5

2453
02:15:06,000 --> 02:15:07,000
或者一定 2.5.5

2454
02:15:07,000 --> 02:15:08,000
对吧

2455
02:15:08,000 --> 02:15:09,000
这都可以这么去指定

2456
02:15:09,000 --> 02:15:10,000
或者说不高于某个版本的版本

2457
02:15:10,000 --> 02:15:14,000
这也是采用这个所谓 Semantic Version 0 的一个优点

2458
02:15:14,000 --> 02:15:15,000
就是

2459
02:15:15,000 --> 02:15:16,000
对没错

2460
02:15:16,000 --> 02:15:17,000
你可以做出此类的 conversion

2461
02:15:17,000 --> 02:15:18,000
基于 conversion 的事情

2462
02:15:18,000 --> 02:15:19,000
对

2463
02:15:19,000 --> 02:15:21,000
Go 里面完全没有版本的概念

2464
02:15:21,000 --> 02:15:23,000
Go 里面所有东西都是一个

2465
02:15:23,000 --> 02:15:24,000
就是一个 git

2466
02:15:24,000 --> 02:15:26,000
就是一个 repositor 地址完了

2467
02:15:26,000 --> 02:15:28,000
然后他们的说法是说

2468
02:15:28,000 --> 02:15:31,000
如果你发布了一个包

2469
02:15:31,000 --> 02:15:33,000
你就不要改它的接口

2470
02:15:33,000 --> 02:15:34,000
forever

2471
02:15:35,000 --> 02:15:37,000
这个有点太过了

2472
02:15:37,000 --> 02:15:39,000
太任性了吧

2473
02:15:39,000 --> 02:15:40,000
这简直就是

2474
02:15:40,000 --> 02:15:41,000
Google 就是这么任性

2475
02:15:41,000 --> 02:15:43,000
简直就是任性

2476
02:15:43,000 --> 02:15:45,000
这哪里是任性简直是强硬好不好

2477
02:15:45,000 --> 02:15:49,000
然后其实然后他们的这个说法也很简单

2478
02:15:49,000 --> 02:15:51,000
就是如果你做了一个

2479
02:15:51,000 --> 02:15:52,000
就是什么

2480
02:15:52,000 --> 02:15:54,000
接口不兼容的改进

2481
02:15:54,000 --> 02:15:57,000
那么请用一个新的 import 的地址

2482
02:15:57,000 --> 02:15:58,000
这个我觉得有点

2483
02:15:58,000 --> 02:16:00,000
那为什么不能再

2484
02:16:00,000 --> 02:16:02,000
就让它更进一步

2485
02:16:02,000 --> 02:16:04,000
就直接指定这个 repositor 的 branch

2486
02:16:04,000 --> 02:16:05,000
对

2487
02:16:05,000 --> 02:16:07,000
这就是很多人要吐槽的地方

2488
02:16:07,000 --> 02:16:09,000
就说那为什么不支持

2489
02:16:09,000 --> 02:16:10,000
那我直接说

2490
02:16:10,000 --> 02:16:11,000
我可以 tag 吗对吧

2491
02:16:11,000 --> 02:16:12,000
我可以 tag 某一个版本

2492
02:16:12,000 --> 02:16:13,000
这样也可以

2493
02:16:13,000 --> 02:16:14,000
但是你想想

2494
02:16:14,000 --> 02:16:16,000
按理说还蛮合理的对吧

2495
02:16:16,000 --> 02:16:18,000
但问题出在哪呢

2496
02:16:18,000 --> 02:16:21,000
问题出在 Go 也没有指定一个

2497
02:16:21,000 --> 02:16:23,000
默认的软件

2498
02:16:23,000 --> 02:16:24,000
包管

2499
02:16:24,000 --> 02:16:26,000
软件 version control 的东西

2500
02:16:26,000 --> 02:16:28,000
就说比如 git 里面有 branch 的概念

2501
02:16:28,000 --> 02:16:31,000
然后这个 Mercury 里面有这个 branch 的概念

2502
02:16:31,000 --> 02:16:33,000
scv 有吗

2503
02:16:33,000 --> 02:16:35,000
也有好像

2504
02:16:35,000 --> 02:16:36,000
scv

2505
02:16:36,000 --> 02:16:39,000
scv

2506
02:16:39,000 --> 02:16:41,000
scvs 是错

2507
02:16:41,000 --> 02:16:43,000
scv 是

2508
02:16:43,000 --> 02:16:45,000
comma separated

2509
02:16:45,000 --> 02:16:47,000
挖矿机

2510
02:16:47,000 --> 02:16:48,000
csv

2511
02:16:48,000 --> 02:16:50,000
csv 不支持对吧

2512
02:16:50,000 --> 02:16:51,000
还有 subversion

2513
02:16:51,000 --> 02:16:53,000
它里面也是没有 tag 的概念

2514
02:16:53,000 --> 02:16:56,000
subversion 是有 branch 的

2515
02:16:56,000 --> 02:16:58,000
不过这 branch 是非常重量级的 branch

2516
02:16:58,000 --> 02:16:59,000
对就是说其实

2517
02:16:59,000 --> 02:17:01,000
你要去兼容那个没有这些东西

2518
02:17:01,000 --> 02:17:03,000
就是最最基础的

2519
02:17:03,000 --> 02:17:05,000
你只有一个 url 而已

2520
02:17:05,000 --> 02:17:07,000
就你不能去指定其他东西

2521
02:17:07,000 --> 02:17:10,000
而且因为 go git 也是封装了

2522
02:17:10,000 --> 02:17:12,000
那些命令行工具而已

2523
02:17:12,000 --> 02:17:14,000
就是包括封装了 git

2524
02:17:14,000 --> 02:17:15,000
封装了 hg

2525
02:17:15,000 --> 02:17:17,000
封装了那个什么 subversion 是

2526
02:17:17,000 --> 02:17:19,000
是什么命令

2527
02:17:19,000 --> 02:17:21,000
svn

2528
02:17:21,000 --> 02:17:23,000
svn 对它封装那些命令的调用

2529
02:17:23,000 --> 02:17:26,000
它也没有办法去强制说

2530
02:17:26,000 --> 02:17:29,000
你能用个什么样的方法去

2531
02:17:29,000 --> 02:17:31,000
大家在不同的版本库之间

2532
02:17:31,000 --> 02:17:34,000
用不同的方法管理软件版本的

2533
02:17:34,000 --> 02:17:37,000
也能够指定同一个版本出来

2534
02:17:37,000 --> 02:17:38,000
对吧

2535
02:17:38,000 --> 02:17:40,000
所以其实就变得这个很难

2536
02:17:40,000 --> 02:17:42,000
凡是一旦变成分布式

2537
02:17:42,000 --> 02:17:44,000
没有一个中央集权的东西

2538
02:17:44,000 --> 02:17:47,000
就变得很难解决

2539
02:17:47,000 --> 02:17:49,000
对这也是其中之一

2540
02:17:49,000 --> 02:17:51,000
所以现在有一些

2541
02:17:51,000 --> 02:17:53,000
就是社区来的一些方法

2542
02:17:53,000 --> 02:17:54,000
就是说

2543
02:17:54,000 --> 02:17:57,000
那我们不要

2544
02:17:57,000 --> 02:17:59,000
就为了解决刚才说的

2545
02:17:59,000 --> 02:18:00,000
版本管理的问题

2546
02:18:00,000 --> 02:18:01,000
我们要指定某个版本

2547
02:18:01,000 --> 02:18:05,000
我们不简单的直接用 go git

2548
02:18:05,000 --> 02:18:07,000
我们是说写一个文件

2549
02:18:07,000 --> 02:18:10,000
声明我需要哪一个软件

2550
02:18:10,000 --> 02:18:11,000
哪一个版本

2551
02:18:11,000 --> 02:18:12,000
通过一个 branch 也好

2552
02:18:12,000 --> 02:18:13,000
还是通过 git tag

2553
02:18:13,000 --> 02:18:15,000
或者什么方式也好

2554
02:18:15,000 --> 02:18:16,000
把它写在一起

2555
02:18:16,000 --> 02:18:18,000
然后我再通过第三方的

2556
02:18:18,000 --> 02:18:20,000
社区维护的工具去

2557
02:18:20,000 --> 02:18:22,000
去安装这些软件版本

2558
02:18:22,000 --> 02:18:23,000
而不是用官方的

2559
02:18:23,000 --> 02:18:25,000
go git 这种形式

2560
02:18:26,000 --> 02:18:27,000
OK

2561
02:18:27,000 --> 02:18:30,000
具体来说有什么样的工具

2562
02:18:30,000 --> 02:18:31,000
有一个比较常见的

2563
02:18:31,000 --> 02:18:33,000
叫 go dep

2564
02:18:33,000 --> 02:18:35,000
第一批就是 go dependency 的

2565
02:18:35,000 --> 02:18:36,000
go dependency

2566
02:18:36,000 --> 02:18:37,000
对对面一个工具

2567
02:18:37,000 --> 02:18:38,000
还有一些其他

2568
02:18:38,000 --> 02:18:41,000
就在这一块 go 里面

2569
02:18:41,000 --> 02:18:43,000
社区里面还是有三四个选项

2570
02:18:43,000 --> 02:18:45,000
就看我不知道之后会怎么样

2571
02:18:45,000 --> 02:18:46,000
但现在 go dep

2572
02:18:46,000 --> 02:18:47,000
这个是一个比较

2573
02:18:47,000 --> 02:18:49,000
用的比较多的一个工具

2574
02:18:49,000 --> 02:18:51,000
然后另外一个要解决的问题

2575
02:18:51,000 --> 02:18:52,000
就是说如果你分布式

2576
02:18:52,000 --> 02:18:55,000
你也没有一个集中存储代码的地方

2577
02:18:55,000 --> 02:18:57,000
那同样的你也不能保证

2578
02:18:57,000 --> 02:18:59,000
那个代码你今天在那

2579
02:18:59,000 --> 02:19:00,000
明天还在那对吧

2580
02:19:00,000 --> 02:19:01,000
那个人可能就直接

2581
02:19:01,000 --> 02:19:03,000
把他的 git 项目删除了对吧

2582
02:19:03,000 --> 02:19:05,000
之前也有遇到过什么

2583
02:19:05,000 --> 02:19:06,000
那个什么 why

2584
02:19:06,000 --> 02:19:07,000
还有那几个人

2585
02:19:07,000 --> 02:19:08,000
他从网上消失的时候

2586
02:19:08,000 --> 02:19:10,000
连带着把他的那个什么

2587
02:19:10,000 --> 02:19:12,000
git hub 帐号也给清掉了

2588
02:19:13,000 --> 02:19:15,000
这样如果你一拉他代码

2589
02:19:15,000 --> 02:19:16,000
你发现没了怎么办

2590
02:19:16,000 --> 02:19:17,000
没错

2591
02:19:17,000 --> 02:19:18,000
对所以

2592
02:19:18,000 --> 02:19:19,000
这其实是一个比较

2593
02:19:19,000 --> 02:19:20,000
在这种分布设想下

2594
02:19:20,000 --> 02:19:22,000
一个比较推荐的方式就是说

2595
02:19:22,000 --> 02:19:24,000
你把你需要一来代码

2596
02:19:24,000 --> 02:19:27,000
也加入你的本地的版本控制里面去

2597
02:19:27,000 --> 02:19:28,000
对然后这样的话

2598
02:19:28,000 --> 02:19:29,000
有一些什么难度呢

2599
02:19:29,000 --> 02:19:30,000
就是

2600
02:19:30,000 --> 02:19:31,000
那你要想办法

2601
02:19:31,000 --> 02:19:33,000
你怎么去分离你自己写的代码

2602
02:19:33,000 --> 02:19:34,000
和你依赖的代码的

2603
02:19:34,000 --> 02:19:36,000
这个历史的版本的管理

2604
02:19:36,000 --> 02:19:38,000
你最好是能够区别开来对吧

2605
02:19:38,000 --> 02:19:39,000
这样可以分别升级嘛

2606
02:19:40,000 --> 02:19:42,000
对这也就无形中增加了

2607
02:19:42,000 --> 02:19:45,000
你对要求你对版本管理系统

2608
02:19:45,000 --> 02:19:47,000
又要有足够多的知识

2609
02:19:47,000 --> 02:19:49,000
而相比之下其他的语言

2610
02:19:49,000 --> 02:19:50,000
就可以比较

2611
02:19:51,000 --> 02:19:54,000
专心的放在开发上

2612
02:19:54,000 --> 02:19:55,000
对对对

2613
02:19:55,000 --> 02:19:56,000
但其实这个怎么来说

2614
02:19:56,000 --> 02:19:58,000
从总体来可用心的角度来讲

2615
02:19:58,000 --> 02:19:59,000
这个反而是好的

2616
02:19:59,000 --> 02:20:00,000
因为这样的话

2617
02:20:00,000 --> 02:20:03,000
你就可以确保你只要拿到这个软件包

2618
02:20:03,000 --> 02:20:05,000
然后这个软件包里面的所有依赖

2619
02:20:05,000 --> 02:20:06,000
是通过这种方式来管理的

2620
02:20:06,000 --> 02:20:08,000
就是你把它切割进你的本地的

2621
02:20:08,000 --> 02:20:09,000
这个代码库里面

2622
02:20:09,000 --> 02:20:11,000
那么你拿到这个代码库里

2623
02:20:11,000 --> 02:20:12,000
你知道它是一个完整的

2624
02:20:12,000 --> 02:20:13,000
就是你可以用代码库

2625
02:20:13,000 --> 02:20:15,000
编辑出来一个最终的结果

2626
02:20:15,000 --> 02:20:18,000
不需要去再经过一个网络的下载的过程

2627
02:20:19,000 --> 02:20:20,000
所以如果你要用

2628
02:20:20,000 --> 02:20:23,000
你要为世界的终结做准备的话

2629
02:20:23,000 --> 02:20:25,000
那其实够了还编程

2630
02:20:25,000 --> 02:20:27,000
对所以所以就是它是一个

2631
02:20:27,000 --> 02:20:28,000
你可以看到

2632
02:20:28,000 --> 02:20:29,000
刚才我们这一系列的主题

2633
02:20:29,000 --> 02:20:31,000
都是一个无中心的

2634
02:20:31,000 --> 02:20:33,000
这么一个一个一个诉求

2635
02:20:33,000 --> 02:20:35,000
所以从这一点来讲

2636
02:20:35,000 --> 02:20:39,000
它跟 Git 的想法其实还是蛮不谋而合的

2637
02:20:39,000 --> 02:20:41,000
对就 Git 说我不要什么

2638
02:20:41,000 --> 02:20:44,000
SVN 和 CSV 都是需要有个中央服务器

2639
02:20:44,000 --> 02:20:45,000
你才可以 check in 啊

2640
02:20:45,000 --> 02:20:48,000
才可以同步软件的代码

2641
02:20:48,000 --> 02:20:49,000
但是 Git 不需要

2642
02:20:49,000 --> 02:20:51,000
你可以本地修改本地 commit

2643
02:20:51,000 --> 02:20:52,000
对吧

2644
02:20:52,000 --> 02:20:53,000
对

2645
02:20:53,000 --> 02:20:54,000
Go 的话也是这样本地

2646
02:20:54,000 --> 02:20:55,000
编译本地出结果

2647
02:20:55,000 --> 02:20:57,000
这样就比较好一点

2648
02:20:58,000 --> 02:21:01,000
当然代价也就是用起来会比较繁琐

2649
02:21:01,000 --> 02:21:05,000
而且在就是 Go 官方是对这个事情是没有说法的

2650
02:21:05,000 --> 02:21:07,000
就是说你们自己想办法解决我们不管

2651
02:21:07,000 --> 02:21:10,000
因为因为这里面有一个很务实的情况

2652
02:21:10,000 --> 02:21:13,000
就是因为 Go 的大部分开发者还是 Google

2653
02:21:13,000 --> 02:21:15,000
Google 的一些工程师

2654
02:21:15,000 --> 02:21:21,000
然后他们 Google 内部是用一个非常复杂先进的 Bue 的系统在写程序

2655
02:21:21,000 --> 02:21:22,000
哪怕是

2656
02:21:22,000 --> 02:21:23,000
但是他们是跨语言的

2657
02:21:24,000 --> 02:21:27,000
所以他们也不用这个 GoGit 来装程序

2658
02:21:27,000 --> 02:21:28,000
所以那么内部

2659
02:21:28,000 --> 02:21:31,000
所以 GoGit 到底是做给谁做给谁用的

2660
02:21:31,000 --> 02:21:32,000
如果不吃自己的狗食的话

2661
02:21:32,000 --> 02:21:33,000
那么他们是

2662
02:21:33,000 --> 02:21:34,000
开发条试用嘛

2663
02:21:34,000 --> 02:21:35,000
就是你可以

2664
02:21:35,000 --> 02:21:37,000
因为它大部分时候还是可以用的

2665
02:21:37,000 --> 02:21:39,000
你不是说你每天要 GoGit 一遍

2666
02:21:39,000 --> 02:21:40,000
对吧你 GoGit 回来一个版本

2667
02:21:40,000 --> 02:21:42,000
它大部分时候还是稳定可靠的

2668
02:21:42,000 --> 02:21:46,000
因为它还是鼓励说这个 API 要尽量稳定可靠嘛

2669
02:21:46,000 --> 02:21:49,000
所以你拿回来大部分还是可用的

2670
02:21:49,000 --> 02:21:51,000
只是说当你要正式发布的时候

2671
02:21:51,000 --> 02:21:53,000
你最好把你的 Elan 那些

2672
02:21:53,000 --> 02:21:54,000
通过刚才我讲的那些方法

2673
02:21:54,000 --> 02:21:56,000
check 到你本地的一个目录里面去

2674
02:21:56,000 --> 02:21:57,000
这样的话会

2675
02:21:58,000 --> 02:21:59,000
就可靠性会好一些

2676
02:22:00,000 --> 02:22:01,000
OK

2677
02:22:01,000 --> 02:22:02,000
嗯

2678
02:22:02,000 --> 02:22:03,000
所以也是就是说

2679
02:22:03,000 --> 02:22:07,000
因为 Go 它官方没有一个说法

2680
02:22:07,000 --> 02:22:09,000
也没有一个他们自己内部

2681
02:22:09,000 --> 02:22:12,000
他们内部用的东西也不是开源的嘛

2682
02:22:12,000 --> 02:22:14,000
也不是一个商业系统

2683
02:22:14,000 --> 02:22:17,000
所以就没有办法把它给我们共享

2684
02:22:17,000 --> 02:22:19,000
就是给我们也用不了太复杂

2685
02:22:20,000 --> 02:22:21,000
对

2686
02:22:21,000 --> 02:22:25,000
其实三号跟苹果这边的阵营差不多

2687
02:22:25,000 --> 02:22:28,000
苹果也是不管 OBJFC 还是 Swift

2688
02:22:28,000 --> 02:22:30,000
其实都没有一个官方的

2689
02:22:31,000 --> 02:22:33,000
包管的系统

2690
02:22:34,000 --> 02:22:38,000
CocoaPods 虽然是目前的

2691
02:22:38,000 --> 02:22:40,000
继承事实的包管系统

2692
02:22:40,000 --> 02:22:45,000
但好像官方也没有表现出任何态度

2693
02:22:45,000 --> 02:22:48,000
是支持它还是觉得可能要拿出来

2694
02:22:48,000 --> 02:22:49,000
要自己另做一套的

2695
02:22:49,000 --> 02:22:52,000
苹果应该不会管这种事情吧我觉得

2696
02:22:54,000 --> 02:22:55,000
我觉得对于开发者来说

2697
02:22:55,000 --> 02:22:57,000
这个东西其实还是蛮重要的

2698
02:22:58,000 --> 02:22:59,000
这肯定毫不怀疑

2699
02:22:59,000 --> 02:23:02,000
但问题是说苹果会觉得这事情很重要

2700
02:23:02,000 --> 02:23:03,000
我很怀疑

2701
02:23:04,000 --> 02:23:08,000
我是觉得上次 WLDC 之后

2702
02:23:08,000 --> 02:23:11,000
苹果竟然对开发者有了这么难得一次的微笑

2703
02:23:11,000 --> 02:23:14,000
也许接下来有些事情也是可以梦想的

2704
02:23:14,000 --> 02:23:15,000
是吗

2705
02:23:15,000 --> 02:23:17,000
我强烈建议你听一下

2706
02:23:17,000 --> 02:23:21,000
还没应该是明天发布的 IT 功能第 131 期

2707
02:23:21,000 --> 02:23:24,000
看一下苹果对开发者的真实态度是什么

2708
02:23:24,000 --> 02:23:25,000
好吧

2709
02:23:27,000 --> 02:23:28,000
这又要被泼冷水了

2710
02:23:28,000 --> 02:23:30,000
今年的 YouTube 的 Rewind

2711
02:23:30,000 --> 02:23:32,000
somehow 泼冷水泼了很久

2712
02:23:32,000 --> 02:23:33,000
为什么

2713
02:23:34,000 --> 02:23:37,000
YouTube 年末的时候会有 Rewind 的视频

2714
02:23:37,000 --> 02:23:40,000
就是隶属今年知名的

2715
02:23:40,000 --> 02:23:42,000
Rewind 动词应该是

2716
02:23:42,000 --> 02:23:43,000
sorry

2717
02:23:43,000 --> 02:23:44,000
对

2718
02:23:44,000 --> 02:23:45,000
Rewind

2719
02:23:45,000 --> 02:23:47,000
我记得应该是念动词的情况

2720
02:23:47,000 --> 02:23:48,000
Rewind

2721
02:23:51,000 --> 02:23:54,000
然后它里面会隶属今年的

2722
02:23:54,000 --> 02:23:56,000
比较知名的视频

2723
02:23:56,000 --> 02:23:59,000
然后把他们以某种方式重新拍一遍

2724
02:23:59,000 --> 02:24:00,000
然后在里面

2725
02:24:00,000 --> 02:24:02,000
因为今年冰桶挑战很出名

2726
02:24:02,000 --> 02:24:05,000
然后在里面有大量知名人士

2727
02:24:05,000 --> 02:24:06,000
互相冰桶

2728
02:24:06,000 --> 02:24:07,000
泼冰水

2729
02:24:07,000 --> 02:24:09,000
泼冰水的情节

2730
02:24:09,000 --> 02:24:12,000
难道明天我要被泼冰水了

2731
02:24:14,000 --> 02:24:16,000
不过今天前面讲了这么多

2732
02:24:16,000 --> 02:24:17,000
就是各个语言

2733
02:24:17,000 --> 02:24:20,000
自己本身的一些包管理的机制也好

2734
02:24:20,000 --> 02:24:21,000
一些软件也好

2735
02:24:21,000 --> 02:24:23,000
其实我一直有一个问题

2736
02:24:23,000 --> 02:24:27,000
为什么没有一个能够跨语言

2737
02:24:27,000 --> 02:24:29,000
解决这个问题的工具呢

2738
02:24:29,000 --> 02:24:31,000
就是我们为什么每个语言出来

2739
02:24:31,000 --> 02:24:33,000
都要自己再重复这么一套

2740
02:24:33,000 --> 02:24:35,000
很麻烦啰嗦的事情

2741
02:24:35,000 --> 02:24:36,000
然后

2742
02:24:37,000 --> 02:24:40,000
要把这个已经解决问题再解决一遍

2743
02:24:44,000 --> 02:24:46,000
如果你要说这个的话

2744
02:24:46,000 --> 02:24:49,000
我觉得 Nugget 可能是一个这样的工具吧

2745
02:24:49,000 --> 02:24:50,000
为什么

2746
02:24:50,000 --> 02:24:53,000
因为你觉得 Nugget 并不限定于

2747
02:24:53,000 --> 02:24:56,000
是专门为 C-Sharp 或者是专门为 Dotnet 平台

2748
02:24:56,000 --> 02:24:58,000
所做的一个包管理工具

2749
02:24:59,000 --> 02:25:00,000
像我刚才说的

2750
02:25:00,000 --> 02:25:03,000
它可以拿到 JQuery 这种东西

2751
02:25:03,000 --> 02:25:04,000
这个我没有意义

2752
02:25:04,000 --> 02:25:06,000
我是说比如说像

2753
02:25:08,000 --> 02:25:10,000
Node 那些 NPM

2754
02:25:10,000 --> 02:25:11,000
它只能装 JavaScript 的包

2755
02:25:11,000 --> 02:25:14,000
Ruby 也只能装 Ruby 的包

2756
02:25:14,000 --> 02:25:15,000
就是说

2757
02:25:15,000 --> 02:25:17,000
在现在流行的东西

2758
02:25:17,000 --> 02:25:19,000
就是根据各个语言

2759
02:25:19,000 --> 02:25:21,000
那个独特的一些系统

2760
02:25:21,000 --> 02:25:23,000
并不能有一个通用的系统

2761
02:25:23,000 --> 02:25:24,000
解决他们之间的问题

2762
02:25:24,000 --> 02:25:27,000
你是说如果 Nugget 这种方式流行起来

2763
02:25:27,000 --> 02:25:30,000
我们也可以用 Nugget 装 JavaScript 包

2764
02:25:30,000 --> 02:25:32,000
然后用 Nugget 装 Go 的包吗

2765
02:25:32,000 --> 02:25:33,000
还是怎么样

2766
02:25:34,000 --> 02:25:35,000
可是反过来

2767
02:25:35,000 --> 02:25:37,000
我的理解是

2768
02:25:37,000 --> 02:25:41,000
有些语言的部分包

2769
02:25:41,000 --> 02:25:44,000
也是可以通过比如说 Apps

2770
02:25:44,000 --> 02:25:45,000
之类的东西来安装的

2771
02:25:45,000 --> 02:25:46,000
对对对

2772
02:25:46,000 --> 02:25:48,000
如果朝这个方向发展的话

2773
02:25:48,000 --> 02:25:49,000
你是不是就可以说

2774
02:25:49,000 --> 02:25:51,000
整个系统平台上

2775
02:25:51,000 --> 02:25:53,000
干脆只有一个包管的系统

2776
02:25:53,000 --> 02:25:55,000
它既负责软件安装

2777
02:25:55,000 --> 02:26:00,000
又负责所有语言的相关包的安装

2778
02:26:00,000 --> 02:26:01,000
就可以了

2779
02:26:01,000 --> 02:26:03,000
我觉得其实对于 C 语言来说

2780
02:26:03,000 --> 02:26:04,000
C 语言没有一个

2781
02:26:04,000 --> 02:26:06,000
基本的实实的安装包

2782
02:26:06,000 --> 02:26:07,000
对对对安装包管理系统对吧

2783
02:26:07,000 --> 02:26:08,000
对

2784
02:26:08,000 --> 02:26:09,000
可是反过来说

2785
02:26:09,000 --> 02:26:10,000
你可以说任何一个

2786
02:26:10,000 --> 02:26:11,000
APT 也好

2787
02:26:11,000 --> 02:26:13,000
而 YAM 也好

2788
02:26:13,000 --> 02:26:16,000
好你在安装那些 Develop 的

2789
02:26:16,000 --> 02:26:19,000
Dev 或者是 Devel

2790
02:26:19,000 --> 02:26:21,000
或者是 Develop 包的时候

2791
02:26:21,000 --> 02:26:23,000
你不就已经安装了这个

2792
02:26:23,000 --> 02:26:26,000
C 语言所需要的投文件吗

2793
02:26:26,000 --> 02:26:27,000
对对对

2794
02:26:27,000 --> 02:26:28,000
也许一个语言发展到

2795
02:26:28,000 --> 02:26:29,000
足够壮大的时候

2796
02:26:29,000 --> 02:26:33,000
它也许就可以通过一个

2797
02:26:33,000 --> 02:26:35,000
泛用的 Package Manager

2798
02:26:35,000 --> 02:26:37,000
来解决这个问题了

2799
02:26:37,000 --> 02:26:42,000
其实还是一个不够成熟的表现吗

2800
02:26:42,000 --> 02:26:44,000
对应该是这样的

2801
02:26:44,000 --> 02:26:46,000
但参差不齐

2802
02:26:46,000 --> 02:26:48,000
乃是生活之美的来源

2803
02:26:48,000 --> 02:26:50,000
是这么说吗

2804
02:26:50,000 --> 02:26:52,000
确实但

2805
02:26:53,000 --> 02:26:56,000
我不确定这在程序语言这一套

2806
02:26:56,000 --> 02:26:57,000
就是在包管理系这样

2807
02:26:57,000 --> 02:26:59,000
是不是一定是好的

2808
02:26:59,000 --> 02:27:01,000
但是每次跨一个语言

2809
02:27:01,000 --> 02:27:02,000
都要重新学习

2810
02:27:02,000 --> 02:27:05,000
还是蛮高成本的一件事情吧

2811
02:27:05,000 --> 02:27:06,000
我觉得

2812
02:27:06,000 --> 02:27:08,000
这就是 Polyglot 的宿命

2813
02:27:08,000 --> 02:27:11,000
好悲伤

2814
02:27:11,000 --> 02:27:12,000
如果你只会扎外的话

2815
02:27:12,000 --> 02:27:15,000
也许就没有所有这些痛苦了

2816
02:27:15,000 --> 02:27:18,000
你会生活在一种无知的幸福里面

2817
02:27:18,000 --> 02:27:21,000
这是一个悲伤的故事

2818
02:27:22,000 --> 02:27:23,000
好吧

2819
02:27:23,000 --> 02:27:25,000
已经两个半小时了

2820
02:27:25,000 --> 02:27:28,000
今天我们的吐槽

2821
02:27:28,000 --> 02:27:30,000
就到这里为止吧

2822
02:27:30,000 --> 02:27:33,000
对我们今天的主题是

2823
02:27:33,000 --> 02:27:35,000
Package Management

2824
02:27:35,000 --> 02:27:36,000
其实我们本来还想

2825
02:27:36,000 --> 02:27:38,000
就这个话题延伸到

2826
02:27:38,000 --> 02:27:41,000
比如说一个做好的包子

2827
02:27:41,000 --> 02:27:43,000
然后部署到服务器上

2828
02:27:43,000 --> 02:27:44,000
一直一围绕着部署

2829
02:27:44,000 --> 02:27:46,000
所产生的一系列问题

2830
02:27:46,000 --> 02:27:49,000
比如说部署并不仅仅简简单单单的是

2831
02:27:49,000 --> 02:27:52,000
把一个 Binary 扔到服务器上去运行

2832
02:27:52,000 --> 02:27:53,000
这么简单

2833
02:27:53,000 --> 02:27:55,000
当然对于某些构成学者来说

2834
02:27:55,000 --> 02:27:56,000
这是可能的

2835
02:27:56,000 --> 02:27:59,000
但对我们其他的熟民来说

2836
02:27:59,000 --> 02:28:02,000
这里面还是有很多学问所在

2837
02:28:02,000 --> 02:28:04,000
但是今天我们

2838
02:28:04,000 --> 02:28:05,000
也没有时间展开了

2839
02:28:05,000 --> 02:28:06,000
所以还是

2840
02:28:06,000 --> 02:28:07,000
下次吧

2841
02:28:07,000 --> 02:28:08,000
下次找机会吧

2842
02:28:08,000 --> 02:28:10,000
就明年再说

2843
02:28:10,000 --> 02:28:13,000
See you in 2015

2844
02:28:13,000 --> 02:28:14,000
Yes

2845
02:28:14,000 --> 02:28:17,000
各位听到我们这一期节目的时候

2846
02:28:17,000 --> 02:28:19,000
应该还有两三天就要新年了

2847
02:28:19,000 --> 02:28:22,000
也在这里祝大家新年快乐

2848
02:28:23,000 --> 02:28:24,000
怎么样

2849
02:28:24,000 --> 02:28:25,000
好

2850
02:28:25,000 --> 02:28:27,000
我们下期再见

2851
02:28:27,000 --> 02:28:30,000
连同这前两期的所有的 Feedback

2852
02:28:30,000 --> 02:28:32,000
明年再见

2853
02:28:32,000 --> 02:28:33,000
我接着新年的新气象

2854
02:28:33,000 --> 02:28:34,000
新气象

2855
02:28:34,000 --> 02:28:39,000
重新来做一期新的内核讨论

2856
02:28:40,000 --> 02:28:41,000
OK

2857
02:28:41,000 --> 02:28:42,000
我们今天做了七期

2858
02:28:42,000 --> 02:28:43,000
不错

