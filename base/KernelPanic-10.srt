1
00:00:00,000 --> 00:00:09,000
大家好 欢迎收听第 17 的内和恐慌 我是 Ryo 卢腾今天我们请到了一位嘉宾他叫 Willow

2
00:00:09,000 --> 00:00:11,000
我得给大家聊聊会吧

3
00:00:11,000 --> 00:00:12,000
大家好 我是 Willow

4
00:00:13,000 --> 00:00:17,000
又可以跟 Ryo 和舞蹈 插科打魂非常开心

5
00:00:19,000 --> 00:00:24,000
为什么要说又呢就是如果大家听过我主持的另外一段节目

6
00:00:24,000 --> 00:00:28,000
IT 公众的话就知道 Willow 已经在那边做过两三次的嘉宾了

7
00:00:28,000 --> 00:00:32,000
可是我好像没有和 Willow 直接上过

8
00:00:33,000 --> 00:00:35,000
对 就是我们没有上过

9
00:00:37,000 --> 00:00:39,000
我没有 别说开始就没有

10
00:00:41,000 --> 00:00:45,000
不过其实这是我们内和恐慌这期节目第一次邀请嘉宾吧

11
00:00:45,000 --> 00:00:50,000
对 之前曾经邀请过一位嘉宾后来被 IT 公众强走了

12
00:00:50,000 --> 00:00:51,000
对 就是帮助

13
00:00:51,000 --> 00:00:54,000
所以 Willow 也是我们他的处女嘉宾

14
00:00:54,000 --> 00:00:56,000
非常榮幸

15
00:00:56,000 --> 00:00:59,000
不知道 我知道帮助处女嘉宾的事

16
00:00:59,000 --> 00:01:07,000
今天请 Willow 来是要聊一件跟前段开发有关的事情

17
00:01:07,000 --> 00:01:11,000
Willow 最近应该是前天吧 前天和上天天 对吧

18
00:01:11,000 --> 00:01:13,000
上个节目 28 号是九轰

19
00:01:13,000 --> 00:01:17,000
对 然后去参加了 Facebook 搞的

20
00:01:17,000 --> 00:01:18,000
现在这也已经不算 Facebook

21
00:01:18,000 --> 00:01:20,000
他们已经独立出来的吗还是怎么样

22
00:01:20,000 --> 00:01:21,000
Facebook

23
00:01:21,000 --> 00:01:22,000
还是 Facebook

24
00:01:23,000 --> 00:01:26,000
Facebook 他们有一个开发者的小型的会议

25
00:01:26,000 --> 00:01:28,000
是讲了一个叫做 React

26
00:01:28,000 --> 00:01:30,000
这么一个前段开发的技术

27
00:01:30,000 --> 00:01:33,000
然后刚好 Willow 去了现场参加了两天的会议

28
00:01:33,000 --> 00:01:35,000
然后我们就趁着打铁

29
00:01:35,000 --> 00:01:38,000
邀请他来跟我们分享一下他所建设的文吧

30
00:01:38,000 --> 00:01:41,000
对 其实 Willow 你是为什么可以去参加

31
00:01:41,000 --> 00:01:45,000
或者是出于什么样的动机去参加 React.js 的 conference

32
00:01:46,000 --> 00:01:50,000
如果你看前段开发的发展的话

33
00:01:50,000 --> 00:01:55,000
你会发现去年和前年是非常激动的两年

34
00:01:55,000 --> 00:02:00,000
因为我们最开始大家写 Pure JavaScript

35
00:02:00,000 --> 00:02:02,000
然后后来有些 JQuery

36
00:02:02,000 --> 00:02:08,000
然后再到 Backbone 引进了比较具体的 Structure

37
00:02:08,000 --> 00:02:12,000
前段的开发好像到那里就有一点停止

38
00:02:12,000 --> 00:02:14,000
在这个时候出现了 Angler

39
00:02:14,000 --> 00:02:16,000
然后去年又出现了 React

40
00:02:16,000 --> 00:02:19,000
实际上最一全单开发者来说

41
00:02:19,000 --> 00:02:22,000
整个前段世界是发生的巨变的

42
00:02:22,000 --> 00:02:27,000
而 React 是措施这些巨变的一个代表之一

43
00:02:27,000 --> 00:02:30,000
我们去年我们自己的公司

44
00:02:30,000 --> 00:02:35,000
去年在考虑新的技术的时候

45
00:02:35,000 --> 00:02:38,000
把 React 闹入了我们想要使用的范围

46
00:02:38,000 --> 00:02:42,000
在过去的 6 到 8 个月

47
00:02:42,000 --> 00:02:49,000
我们都有在积极的把以前的东西给转移到 React 上

48
00:02:49,000 --> 00:02:51,000
我们之前是有写的一个 Backbone app

49
00:02:51,000 --> 00:02:57,000
然后我们现在在 Migrate 它去 React

50
00:02:57,000 --> 00:02:59,000
做一个 React 开发者本身

51
00:02:59,000 --> 00:03:02,000
然后再做一个技术的一个爱好者

52
00:03:02,000 --> 00:03:06,000
我觉得非常荣幸有机会去 React.com

53
00:03:06,000 --> 00:03:11,000
去 Cominion 体看最新的东西

54
00:03:11,000 --> 00:03:15,000
然后从其他人身上的学料一些东西

55
00:03:15,000 --> 00:03:16,000
OK

56
00:03:16,000 --> 00:03:18,000
你刚才提到说整个 Apple

57
00:03:18,000 --> 00:03:21,000
从 Backbone 牵一道 React 上面的待后面

58
00:03:21,000 --> 00:03:22,000
可以讲一下整个牵一过程

59
00:03:22,000 --> 00:03:26,000
是不是的痛苦程度有多少

60
00:03:26,000 --> 00:03:26,000
没问题

61
00:03:26,000 --> 00:03:29,000
其实是一个非常有意思的一个过程

62
00:03:29,000 --> 00:03:34,000
像当于像 Angle 这样的旁大的 Fremark 来说

63
00:03:34,000 --> 00:03:36,000
React 实际上非常的轻巧

64
00:03:36,000 --> 00:03:39,000
然后正式因此

65
00:03:39,000 --> 00:03:42,000
这个 Migration 没有很多人想上了会那么痛苦

66
00:03:42,000 --> 00:03:45,000
我们非常非常享受这个过程

67
00:03:45,000 --> 00:03:46,000
我忘了介绍了

68
00:03:46,000 --> 00:03:48,000
我们自己都很熟悉了

69
00:03:48,000 --> 00:03:49,000
就是 Wabagate

70
00:03:49,000 --> 00:03:50,000
有些听动朋友可能还

71
00:03:50,000 --> 00:03:53,000
就第一次听到威乐的声音的话

72
00:03:53,000 --> 00:03:55,000
威乐你还要先介绍一下自己

73
00:03:55,000 --> 00:04:00,000
你是在 One 去的做前身开发对吧

74
00:04:00,000 --> 00:04:01,000
OK

75
00:04:03,000 --> 00:04:06,000
我在 IT 公伸的时候也没有介绍自己

76
00:04:06,000 --> 00:04:09,000
我觉得不知道威乐

77
00:04:09,000 --> 00:04:10,000
不知道威乐是谁的

78
00:04:10,000 --> 00:04:12,000
听众们可以回去听 IT 公伸

79
00:04:12,000 --> 00:04:14,000
第一期是有介绍的

80
00:04:17,000 --> 00:04:20,000
我是我在 One 去生活了三年

81
00:04:20,000 --> 00:04:22,000
然后我一直在

82
00:04:22,000 --> 00:04:23,000
就叫做 Backbone 的

83
00:04:23,000 --> 00:04:24,000
Soype

84
00:04:24,000 --> 00:04:31,000
我在一家叫做 Backplane 的公司做 Softing Engineer

85
00:04:31,000 --> 00:04:35,000
我很 Focus 在前段开发上

86
00:04:36,000 --> 00:04:39,000
然后我要给你们公司做什么

87
00:04:39,000 --> 00:04:41,000
负面宣传的答应

88
00:04:41,000 --> 00:04:43,000
Backplane 在家

89
00:04:43,000 --> 00:04:45,000
可能在外界最知名的就是什么

90
00:04:45,000 --> 00:04:46,000
他的投资人对吧

91
00:04:46,000 --> 00:04:47,000
Well whatever

92
00:04:47,000 --> 00:04:49,000
Let's save that for later

93
00:04:50,000 --> 00:04:50,000
Okay

94
00:04:50,000 --> 00:04:52,000
What do we do in reach out to these very sighting

95
00:04:52,000 --> 00:04:53,000
I'm just saying okay

96
00:04:53,000 --> 00:04:54,000
投资人是谁

97
00:04:54,000 --> 00:04:55,000
Lady Gaga

98
00:04:55,000 --> 00:04:56,000
还是对

99
00:04:57,000 --> 00:04:59,000
Duo Hee Mey Toss

100
00:05:00,000 --> 00:05:02,000
所以帮我要一千名

101
00:05:02,000 --> 00:05:03,000
他只是小

102
00:05:03,000 --> 00:05:06,000
他只是小小鼓动话

103
00:05:06,000 --> 00:05:08,000
他千我脸上

104
00:05:08,000 --> 00:05:09,000
他亲了我

105
00:05:11,000 --> 00:05:13,000
好下去给他亲一下

106
00:05:14,000 --> 00:05:15,000
我亲爱的是你让下次他来

107
00:05:15,000 --> 00:05:16,000
你亲他一下

108
00:05:16,000 --> 00:05:18,000
这样你觉得 Lady Gaga 亲上

109
00:05:18,000 --> 00:05:18,000
好

110
00:05:18,000 --> 00:05:19,000
OK

111
00:05:20,000 --> 00:05:21,000
看多机制的一个

112
00:05:21,000 --> 00:05:22,000
Yay

113
00:05:23,000 --> 00:05:23,000
对

114
00:05:23,000 --> 00:05:25,000
所以说回来求愿

115
00:05:25,000 --> 00:05:28,000
所以 Well is 一个在 One 去工作的

116
00:05:28,000 --> 00:05:29,000
人家开发酒

117
00:05:29,000 --> 00:05:31,000
然后 Well is there

118
00:05:31,000 --> 00:05:31,000
就有这种

119
00:05:31,000 --> 00:05:33,000
做品是

120
00:05:33,000 --> 00:05:34,000
或者说

121
00:05:34,000 --> 00:05:36,000
如果你跟 VLO 的

122
00:05:36,000 --> 00:05:38,000
曾经产生过什么交集的话

123
00:05:38,000 --> 00:05:41,000
也许是你用过他写的一个插件

124
00:05:41,000 --> 00:05:42,000
叫做 WhatFounce

125
00:05:42,000 --> 00:05:45,000
就是用来检测网页

126
00:05:45,000 --> 00:05:47,000
是让某一部分被显示出来了文字

127
00:05:47,000 --> 00:05:51,000
所实际采用的字体的插件

128
00:05:51,000 --> 00:05:53,000
我们之前有一期爱器公论

129
00:05:53,000 --> 00:05:55,000
探讨完那个产品

130
00:05:55,000 --> 00:05:56,000
如果大家有兴趣的话

131
00:05:56,000 --> 00:06:00,000
可以回口听那个 podcast

132
00:06:00,000 --> 00:06:03,000
这个产品已经已经在上线很多年了

133
00:06:03,000 --> 00:06:04,000
所以说

134
00:06:04,000 --> 00:06:07,000
我也很期待能够有新的做品

135
00:06:07,000 --> 00:06:08,000
拿出来给大家用

136
00:06:08,000 --> 00:06:10,000
然后我也在积极的

137
00:06:10,000 --> 00:06:11,000
积极的做这方面的工作

138
00:06:15,000 --> 00:06:18,000
所以你看 Well is 在 One 去就有比较方便的

139
00:06:18,000 --> 00:06:18,000
这种机会

140
00:06:18,000 --> 00:06:23,000
就参加到各种各样的比较高大上的技术会议

141
00:06:23,000 --> 00:06:25,000
就的话不在 One 去就真的蛮难

142
00:06:25,000 --> 00:06:26,000
我觉得

143
00:06:26,000 --> 00:06:27,000
是

144
00:06:27,000 --> 00:06:28,000
就像欧洲很多 Conference

145
00:06:28,000 --> 00:06:32,000
都是在各个城市换来换去

146
00:06:32,000 --> 00:06:33,000
它很少会有这种

147
00:06:34,000 --> 00:06:35,000
扎堆的钱

148
00:06:35,000 --> 00:06:36,000
扎堆的想象

149
00:06:36,000 --> 00:06:39,000
比如说 RackJS Europe Conference

150
00:06:39,000 --> 00:06:44,000
将在 7 月份举行在欧洲巴黎

151
00:06:44,000 --> 00:06:47,000
然后拍 PYCon Europe

152
00:06:47,000 --> 00:06:49,000
这个是更是每一年的换一个城市

153
00:06:49,000 --> 00:06:52,000
然后去年应该是在复合的

154
00:06:52,000 --> 00:06:54,000
我们没记错了

155
00:06:54,000 --> 00:06:55,000
然后还好啊

156
00:06:55,000 --> 00:06:56,000
欧洲交通方便吗

157
00:06:56,000 --> 00:06:57,000
我不觉得

158
00:06:58,000 --> 00:06:59,000
是吗

159
00:06:59,000 --> 00:07:01,000
我觉得还可以

160
00:07:01,000 --> 00:07:02,000
不管去哪都要

161
00:07:02,000 --> 00:07:03,000
对要定机票

162
00:07:03,000 --> 00:07:05,000
然后可能要要要要

163
00:07:05,000 --> 00:07:07,000
去上去上那个国家的网站

164
00:07:07,000 --> 00:07:10,000
买护士票什么的就很麻烦

165
00:07:10,000 --> 00:07:11,000
不想

166
00:07:11,000 --> 00:07:12,000
我们 LiuJS 大一头

167
00:07:12,000 --> 00:07:13,000
比较远

168
00:07:15,000 --> 00:07:18,000
所以 RackConference 在欧洲会在巴黎

169
00:07:18,000 --> 00:07:19,000
是因为

170
00:07:20,000 --> 00:07:22,000
那个主开发主义

171
00:07:22,000 --> 00:07:24,000
那个叫什么 Cristopher

172
00:07:24,000 --> 00:07:25,000
Yeah, Christopher Touch

173
00:07:25,000 --> 00:07:26,000
他是法国人吗

174
00:07:26,000 --> 00:07:26,000
Right

175
00:07:26,000 --> 00:07:27,000
对

176
00:07:27,000 --> 00:07:28,000
他讲

177
00:07:28,000 --> 00:07:32,000
他讲英语的时候有非常强的法国可以

178
00:07:33,000 --> 00:07:34,000
我还装飞就查了

179
00:07:34,000 --> 00:07:34,000
他是哪个人的

180
00:07:34,000 --> 00:07:35,000
我有

181
00:07:35,000 --> 00:07:35,000
我也是

182
00:07:35,000 --> 00:07:36,000
太难受了

183
00:07:37,000 --> 00:07:40,000
HelasNames 沙特我们这个很明显了

184
00:07:40,000 --> 00:07:41,000
那挺好的

185
00:07:41,000 --> 00:07:42,000
就是

186
00:07:42,000 --> 00:07:43,000
我有记反应一个很

187
00:07:43,000 --> 00:07:45,000
大家很开套才是吧

188
00:07:45,000 --> 00:07:46,000
其实我说英语也有口音

189
00:07:46,000 --> 00:07:48,000
但是这个并不会成为

190
00:07:48,000 --> 00:07:50,000
不影响工作

191
00:07:50,000 --> 00:07:50,000
大家可以

192
00:07:50,000 --> 00:07:51,000
所以我也很

193
00:07:51,000 --> 00:07:53,000
看到他能够

194
00:07:53,000 --> 00:07:56,000
后辞 Costence

195
00:07:56,000 --> 00:07:57,000
也是 Value 的

196
00:07:57,000 --> 00:07:58,000
大家都能

197
00:07:58,000 --> 00:07:58,000
这个英语

198
00:07:58,000 --> 00:08:00,000
这个事情不是那么重要

199
00:08:00,000 --> 00:08:01,000
所以是可以很好的事

200
00:08:03,000 --> 00:08:05,000
其实 Value 在我们三个人里面

201
00:08:05,000 --> 00:08:06,000
已经是最迈口音的一个了

202
00:08:06,000 --> 00:08:07,000
我去

203
00:08:07,000 --> 00:08:08,000
对啊

204
00:08:08,000 --> 00:08:09,000
我

205
00:08:09,000 --> 00:08:11,000
我把滚打的最久

206
00:08:11,000 --> 00:08:12,000
I don't know if it's true

207
00:08:12,000 --> 00:08:14,000
还是回到回到

208
00:08:14,000 --> 00:08:15,000
回到这个政体吧

209
00:08:15,000 --> 00:08:16,000
就说

210
00:08:16,000 --> 00:08:18,000
其实我们可以先回顾一下

211
00:08:18,000 --> 00:08:19,000
在 Rack 之前的那些框架

212
00:08:19,000 --> 00:08:21,000
会有一些什么样的

213
00:08:21,000 --> 00:08:23,000
有些什么样的选择

214
00:08:23,000 --> 00:08:24,000
会有什么样的问题吧

215
00:08:24,000 --> 00:08:25,000
就是为了你们之前

216
00:08:25,000 --> 00:08:26,000
是用这个 backbound 对吧

217
00:08:26,000 --> 00:08:27,000
对

218
00:08:28,000 --> 00:08:30,000
你们在实际上中的话

219
00:08:30,000 --> 00:08:30,000
就是

220
00:08:30,000 --> 00:08:32,000
刚才你也提到你们在网这个 Rack

221
00:08:32,000 --> 00:08:33,000
牵疑吗

222
00:08:33,000 --> 00:08:34,000
那么

223
00:08:34,000 --> 00:08:35,000
对那你们就说在 backbound

224
00:08:35,000 --> 00:08:36,000
实际上

225
00:08:36,000 --> 00:08:37,000
有没有遇到一些什么样的问题

226
00:08:37,000 --> 00:08:39,000
然后牵疑到 Rack

227
00:08:39,000 --> 00:08:40,000
会比较好的解决呢

228
00:08:43,000 --> 00:08:44,000
有两方面的问题

229
00:08:44,000 --> 00:08:45,000
一方面是在

230
00:08:45,000 --> 00:08:47,000
你认识在英语

231
00:08:47,000 --> 00:08:49,000
运方便会遇到一些问题

232
00:08:49,000 --> 00:08:50,000
然后你在

233
00:08:50,000 --> 00:08:52,000
Production 上回到一些问题

234
00:08:52,000 --> 00:08:53,000
Production 上的问题

235
00:08:53,000 --> 00:08:54,000
其实满简单的

236
00:08:54,000 --> 00:08:56,000
就是 performance

237
00:08:56,000 --> 00:08:57,000
这个

238
00:08:57,000 --> 00:08:58,000
一个 Friend

239
00:08:58,000 --> 00:08:58,000
我

240
00:08:58,000 --> 00:09:00,000
他到底能有多快

241
00:09:00,000 --> 00:09:01,000
虽然的多快

242
00:09:01,000 --> 00:09:02,000
交互能力

243
00:09:02,000 --> 00:09:04,000
这些东西是非常好客观评价的

244
00:09:04,000 --> 00:09:05,000
然后

245
00:09:05,000 --> 00:09:08,000
如果上网搜划会看到很多

246
00:09:08,000 --> 00:09:10,000
负面的观音 backbound 的

247
00:09:10,000 --> 00:09:12,000
一些评测

248
00:09:12,000 --> 00:09:13,000
显示

249
00:09:13,000 --> 00:09:14,000
然后我们自己在 Production 上

250
00:09:14,000 --> 00:09:15,000
也遇到了一些问题

251
00:09:15,000 --> 00:09:18,000
我们网站并不算滑

252
00:09:18,000 --> 00:09:21,000
然后在 memory 上也非常难管理

253
00:09:21,000 --> 00:09:22,000
这个 memory 呢

254
00:09:22,000 --> 00:09:24,000
实际上是很跨了这个 Production

255
00:09:24,000 --> 00:09:24,000
And Engine 女

256
00:09:24,000 --> 00:09:28,000
因为 backbound 的 memory management

257
00:09:28,000 --> 00:09:31,000
就好像你在原来做 iOS 开发

258
00:09:31,000 --> 00:09:34,000
是那个你要 menu-le return things

259
00:09:34,000 --> 00:09:35,000
like you know

260
00:09:35,000 --> 00:09:36,000
manage management

261
00:09:36,000 --> 00:09:37,000
手工管理内侧

262
00:09:37,000 --> 00:09:41,000
所以非常容易出现 memory leak

263
00:09:41,000 --> 00:09:43,000
那整个证据记忆

264
00:09:43,000 --> 00:09:44,000
在 render 上会卖

265
00:09:44,000 --> 00:09:47,000
然后在 memory 上会 leak 的话

266
00:09:47,000 --> 00:09:50,000
那你的 performance 就非常不乐观是不是

267
00:09:50,000 --> 00:09:52,000
就是 Production 上的问题

268
00:09:52,000 --> 00:09:53,000
And Engine 女上的问题

269
00:09:53,000 --> 00:09:55,000
在于

270
00:09:55,000 --> 00:09:56,000
关键对于我们来说是

271
00:09:56,000 --> 00:10:00,000
代码的可重用性和可管理性

272
00:10:00,000 --> 00:10:01,000
在重用性上的问题

273
00:10:01,000 --> 00:10:04,000
主要来说就是

274
00:10:04,000 --> 00:10:06,000
Viu 的重用性

275
00:10:06,000 --> 00:10:07,000
实际上要重用一个 Viu

276
00:10:07,000 --> 00:10:08,000
在 backbound 中

277
00:10:08,000 --> 00:10:10,000
其实蛮复杂的

278
00:10:10,000 --> 00:10:14,000
因为你要在 Viu 里面

279
00:10:14,000 --> 00:10:16,000
在你的 template 里面

280
00:10:16,000 --> 00:10:18,000
给 subview

281
00:10:18,000 --> 00:10:19,000
藤出一个空间

282
00:10:19,000 --> 00:10:21,000
选一个 container

283
00:10:21,000 --> 00:10:23,000
然后在你的 render function 中

284
00:10:23,000 --> 00:10:25,000
要 initialize 那个

285
00:10:26,000 --> 00:10:27,000
subview

286
00:10:27,000 --> 00:10:30,000
然后把 subview 切进来

287
00:10:30,000 --> 00:10:33,000
这些连过程对于开发酒来说

288
00:10:33,000 --> 00:10:35,000
还是一个满头脱的事情

289
00:10:35,000 --> 00:10:37,000
所以这因为

290
00:10:37,000 --> 00:10:41,000
你会看到很多人不会去重用

291
00:10:41,000 --> 00:10:43,000
在代码的可管理下的关键

292
00:10:43,000 --> 00:10:52,000
是其实 Viu 他本身并不管理他所有的 state

293
00:10:52,000 --> 00:10:53,000
很大一部分程上

294
00:10:53,000 --> 00:10:56,000
Citl 是在 Dobong 里头的

295
00:10:56,000 --> 00:10:57,000
你知道我们有时候 utilize

296
00:10:57,000 --> 00:11:00,000
classutilize data props

297
00:11:00,000 --> 00:11:02,000
这样的 Dobong 的 album

298
00:11:02,000 --> 00:11:05,000
去管理 Viu 的 state

299
00:11:05,000 --> 00:11:08,000
就导致在大家看这个 Viu 的时候

300
00:11:08,000 --> 00:11:10,000
并看不到全貌

301
00:11:10,000 --> 00:11:12,000
我不知道这个 Viu 到底能够做什么事情

302
00:11:12,000 --> 00:11:13,000
一做什么事情

303
00:11:13,000 --> 00:11:15,000
其实你在看 Viu 的时候

304
00:11:15,000 --> 00:11:16,000
是很难看出来了

305
00:11:16,000 --> 00:11:20,000
就在多人合作的项目上

306
00:11:20,000 --> 00:11:22,000
或者是说你返回到你

307
00:11:22,000 --> 00:11:24,000
多年之前起台的时候

308
00:11:24,000 --> 00:11:26,000
就会是一个很大的问题

309
00:11:26,000 --> 00:11:30,000
这是我们用 Bachbomb

310
00:11:30,000 --> 00:11:32,000
两三年的时间

311
00:11:32,000 --> 00:11:34,000
所遇到了两个方面的问题

312
00:11:34,000 --> 00:11:37,000
我觉得这可能跟 Bachbomb 的设计理念

313
00:11:37,000 --> 00:11:41,000
Bachbomb 毕竟它强调的是

314
00:11:41,000 --> 00:11:43,000
它所提供的功能

315
00:11:43,000 --> 00:11:45,000
这是最基本

316
00:11:45,000 --> 00:11:48,000
最最 Bachbomb 的那一部分

317
00:11:48,000 --> 00:11:50,000
所以你可能不得不

318
00:11:50,000 --> 00:11:56,000
在很多地方要显示的去宣告一些东西

319
00:11:56,000 --> 00:11:57,000
然后你需要

320
00:11:57,000 --> 00:12:01,000
你需要显示的把逻辑写出来

321
00:12:01,000 --> 00:12:03,000
而如果你需要显示的写出来的话

322
00:12:03,000 --> 00:12:06,000
每个人写的逻辑可能不一样

323
00:12:06,000 --> 00:12:10,000
你说你这就是一方面的问题

324
00:12:10,000 --> 00:12:12,000
你说你直接看

325
00:12:12,000 --> 00:12:14,000
无法直接看到 Viu 想要干什么

326
00:12:14,000 --> 00:12:15,000
其实原因之一

327
00:12:15,000 --> 00:12:19,000
也就是它没有一个 D-fault 的

328
00:12:20,000 --> 00:12:24,000
Bhava 可以让你去译言

329
00:12:24,000 --> 00:12:27,000
让你猜到它要干什么

330
00:12:27,000 --> 00:12:30,000
Bachbomb 既好又导致这个问题的一方面

331
00:12:30,000 --> 00:12:33,000
就是它不是很 OPINIONED

332
00:12:33,000 --> 00:12:37,000
我们确实在总结我们的 Bachbomb 的

333
00:12:37,000 --> 00:12:39,000
经验的时候有提到这点

334
00:12:39,000 --> 00:12:42,000
在一个团队协作的范围中

335
00:12:42,000 --> 00:12:45,000
不 OPINIONED 时尚是一个很麻烦的事情

336
00:12:45,000 --> 00:12:48,000
因为大家可能写东西会用不同的方式

337
00:12:48,000 --> 00:12:51,000
也不是说各种方式哪个好哪个话

338
00:12:51,000 --> 00:12:55,000
关键是协作上来说有相同的

339
00:12:55,000 --> 00:12:58,000
Mantommodel 会更方便一点

340
00:12:58,000 --> 00:13:00,000
不管好话也只要一样的话

341
00:13:00,000 --> 00:13:02,000
围护起来的成本可能

342
00:13:02,000 --> 00:13:03,000
也不是围护起来的一个

343
00:13:03,000 --> 00:13:05,000
就是沟通起来的成本会小一些

344
00:13:05,000 --> 00:13:06,000
就是如果你用 Amber.js

345
00:13:06,000 --> 00:13:08,000
或者是 Angela.js 之类的

346
00:13:08,000 --> 00:13:11,000
比较有意自己的一套

347
00:13:11,000 --> 00:13:13,000
使用哲学的框架的话

348
00:13:13,000 --> 00:13:17,000
你会比较有一个大致的概念

349
00:13:17,000 --> 00:13:18,000
就是这件事情怎样做

350
00:13:18,000 --> 00:13:20,000
才是符合这个框架的理验的

351
00:13:20,000 --> 00:13:22,000
但是 Bachbomb 则比较平淡

352
00:13:22,000 --> 00:13:26,000
或者说比较给了你太多自由权

353
00:13:26,000 --> 00:13:29,000
然后就会导致会有沟通什么问题

354
00:13:29,000 --> 00:13:29,000
我是觉得

355
00:13:31,000 --> 00:13:33,000
确实有这样的因素在

356
00:13:33,000 --> 00:13:34,000
可是当我们在看

357
00:13:34,000 --> 00:13:37,000
就是像 Amber.js 这样的 Frammooks 后

358
00:13:37,000 --> 00:13:39,000
它相对于 Bachbomb 是一个

359
00:13:39,000 --> 00:13:42,000
比较小的地径对我们来说

360
00:13:42,000 --> 00:13:44,000
确实它在 Bachbomb 的每一个方向

361
00:13:44,000 --> 00:13:46,000
Bachbomb 所设计的每一个方向

362
00:13:46,000 --> 00:13:49,000
不管是 Router 还是 VU templating

363
00:13:49,000 --> 00:13:51,000
它都有相当大的进步

364
00:13:51,000 --> 00:13:52,000
However 它所

365
00:13:52,000 --> 00:13:54,000
Fondamental 的他们的

366
00:13:54,000 --> 00:13:55,000
他们的框架的理念

367
00:13:55,000 --> 00:13:58,000
MVC 的理念是完全一致的

368
00:13:58,000 --> 00:14:01,000
这是为什么我们在考虑

369
00:14:01,000 --> 00:14:04,000
更新我们的 Frammook 的时候

370
00:14:04,000 --> 00:14:05,000
并没有做态

371
00:14:05,000 --> 00:14:07,000
对 Amber 并没有做态度的考虑

372
00:14:07,000 --> 00:14:11,000
因为如果你

373
00:14:11,000 --> 00:14:12,000
计算你们之间的对于 Bachbomb

374
00:14:12,000 --> 00:14:15,000
是从一种 MVC 换到另一种 MVC

375
00:14:15,000 --> 00:14:18,000
如果另外一个 MVC 更重量的一点

376
00:14:18,000 --> 00:14:20,000
更偏念的对面

377
00:14:20,000 --> 00:14:21,000
没错

378
00:14:21,000 --> 00:14:23,000
OK

379
00:14:23,000 --> 00:14:24,000
所以刚才为了你讲到

380
00:14:24,000 --> 00:14:26,000
提到像 Bachbomb 你们做的时候

381
00:14:26,000 --> 00:14:28,000
就是我跟你的描述

382
00:14:28,000 --> 00:14:30,000
我感觉出来有几个比较核心的问题

383
00:14:30,000 --> 00:14:32,000
就一个是说

384
00:14:32,000 --> 00:14:34,000
这个叫什么封装的成籍不够

385
00:14:34,000 --> 00:14:36,000
就说它封的太散了

386
00:14:36,000 --> 00:14:40,000
比如说你很容易有些数据是在 Dome 里面的

387
00:14:40,000 --> 00:14:42,000
有些数据是可能是在加尔斯克尔布的

388
00:14:42,000 --> 00:14:43,000
那个数据结构里面的 对吧

389
00:14:43,000 --> 00:14:44,000
就可能是一个

390
00:14:44,000 --> 00:14:46,000
你说那个 view 不能在同一个地方一眼

391
00:14:46,000 --> 00:14:49,000
看出来它的相关的那一部分是怎么样

392
00:14:49,000 --> 00:14:52,000
这个其实是在你们的工程上的话

393
00:14:52,000 --> 00:14:53,000
就是没有把这些相关的部分

394
00:14:53,000 --> 00:14:56,000
很好的就是很 capacit 的起来

395
00:14:56,000 --> 00:14:57,000
没错

396
00:14:57,000 --> 00:15:00,000
因为这个主要是因为 Dome 这个事情

397
00:15:00,000 --> 00:15:02,000
就是太太太草弹了

398
00:15:02,000 --> 00:15:03,000
你知道就是这样

399
00:15:03,000 --> 00:15:05,000
大家都明白我

400
00:15:05,000 --> 00:15:07,000
我说为什么这么说

401
00:15:07,000 --> 00:15:13,000
因为 Dome 的问题首先 API 不捍

402
00:15:13,000 --> 00:15:16,000
这个 dickery kind of resolve that problem

403
00:15:16,000 --> 00:15:17,000
kind of

404
00:15:17,000 --> 00:15:22,000
然后关键的因素在你说 performance 台湾

405
00:15:22,000 --> 00:15:23,000
因为

406
00:15:23,000 --> 00:15:25,000
这是历史因素

407
00:15:25,000 --> 00:15:26,000
因为 Dome 的

408
00:15:26,000 --> 00:15:27,000
对

409
00:15:27,000 --> 00:15:28,000
你跟 Dome 交互的话

410
00:15:28,000 --> 00:15:31,000
肯定就是有这个所谓 overhead 比较高嘛

411
00:15:31,000 --> 00:15:32,000
对

412
00:15:32,000 --> 00:15:35,000
实际上如果你真正去 compare back bone

413
00:15:35,000 --> 00:15:36,000
跟 rear eye 化

414
00:15:36,000 --> 00:15:39,000
最关键就是他们怎么去处理

415
00:15:39,000 --> 00:15:40,000
这个 Dome

416
00:15:40,000 --> 00:15:41,000
怎么去处理 Dome

417
00:15:41,000 --> 00:15:42,000
这个事情上不一样

418
00:15:42,000 --> 00:15:44,000
在 back bone 头

419
00:15:44,000 --> 00:15:47,000
如果你要追求 performance

420
00:15:47,000 --> 00:15:49,000
如果说你不 care performance 完蛋

421
00:15:49,000 --> 00:15:50,000
偷回 diffing story

422
00:15:50,000 --> 00:15:52,000
但是如果你

423
00:15:52,000 --> 00:15:54,000
就是在真的可用的东西

424
00:15:54,000 --> 00:15:55,000
还不是好用

425
00:15:55,000 --> 00:15:56,000
是可用的话

426
00:15:56,000 --> 00:15:58,000
你一定要在以 performance

427
00:15:58,000 --> 00:16:00,000
然后就导致说

428
00:16:00,000 --> 00:16:05,000
你的 Dome 的操作都要非常小

429
00:16:05,000 --> 00:16:06,000
不要说

430
00:16:06,000 --> 00:16:11,000
如果我要写一个选项的那个列表

431
00:16:11,000 --> 00:16:12,000
一个用户

432
00:16:12,000 --> 00:16:14,000
去点一个选项

433
00:16:14,000 --> 00:16:16,000
然后那个选项要变成红色

434
00:16:16,000 --> 00:16:17,000
这么一个小小的功能

435
00:16:17,000 --> 00:16:19,000
在你的 back bone 比较中

436
00:16:19,000 --> 00:16:22,000
你一定是会 manually

437
00:16:22,000 --> 00:16:24,000
把这个 class 给

438
00:16:24,000 --> 00:16:27,000
从其他的 aluminum 上移除出去

439
00:16:27,000 --> 00:16:32,000
然后加在这个 toget 的 aluminum 上面

440
00:16:32,000 --> 00:16:34,000
就这么小小一点

441
00:16:34,000 --> 00:16:34,000
操作

442
00:16:34,000 --> 00:16:36,000
你要定力一遍

443
00:16:36,000 --> 00:16:38,000
就导致你的那个

444
00:16:38,000 --> 00:16:39,000
这个 state 就从比较上录 ingshot

445
00:16:39,000 --> 00:16:41,000
因为你那个 state

446
00:16:42,000 --> 00:16:43,000
整个 state 是在 Dome 的

447
00:16:43,000 --> 00:16:44,000
like class

448
00:16:44,000 --> 00:16:46,000
这个因素上的

449
00:16:46,000 --> 00:16:48,000
但是也不可能说

450
00:16:48,000 --> 00:16:51,000
每次都把这个列表重新给 grinda 一下

451
00:16:51,000 --> 00:16:55,000
这就回到我们说的 forpoment 上面

452
00:16:55,000 --> 00:16:57,000
对于那个开发者来说

453
00:16:57,000 --> 00:16:59,000
如果你不需要去担心这么小小的这种

454
00:16:59,000 --> 00:17:00,000
细节操作

455
00:17:00,000 --> 00:17:01,000
而是

456
00:17:01,000 --> 00:17:03,000
描述清楚

457
00:17:03,000 --> 00:17:06,000
你到底这个比较 and result 是怎么样

458
00:17:06,000 --> 00:17:08,000
那你的 code 会清楚很多

459
00:17:08,000 --> 00:17:10,000
可是因为 forfarmist 的因素

460
00:17:10,000 --> 00:17:12,000
你必须得到

461
00:17:12,000 --> 00:17:12,000
这种

462
00:17:12,000 --> 00:17:15,000
到那个细节的小的程度去操作它

463
00:17:15,000 --> 00:17:19,000
就导致你不能够每次都 rerender

464
00:17:19,000 --> 00:17:21,000
backbone 的 state 就是这样子的

465
00:17:21,000 --> 00:17:22,000
但是

466
00:17:22,000 --> 00:17:24,000
那就是 react magic happens

467
00:17:24,000 --> 00:17:28,000
we will happen magic happens

468
00:17:28,000 --> 00:17:30,000
在 react the cuff 里头

469
00:17:30,000 --> 00:17:31,000
Tom

470
00:17:31,000 --> 00:17:34,000
会是 product manager

471
00:17:34,000 --> 00:17:36,000
有提到

472
00:17:36,000 --> 00:17:38,000
Facebook 内部

473
00:17:38,000 --> 00:17:40,000
去做这个

474
00:17:40,000 --> 00:17:42,000
Initialized Project 的动机

475
00:17:42,000 --> 00:17:44,000
就有提到说

476
00:17:44,000 --> 00:17:46,000
他们很想要

477
00:17:46,000 --> 00:17:50,000
把这种细小的 Dome

478
00:17:50,000 --> 00:17:52,000
操作隔离出来

479
00:17:52,000 --> 00:17:53,000
I've dragged out

480
00:17:53,000 --> 00:17:56,000
就像刚刚 real 说的 incaps way

481
00:17:56,000 --> 00:17:58,000
但是他们担心 perfarmist

482
00:17:58,000 --> 00:18:00,000
所以他们做了 perfarmist 的测试

483
00:18:00,000 --> 00:18:02,000
其实上 perfarmist 测试结果

484
00:18:02,000 --> 00:18:04,000
比我们所要预想的都

485
00:18:04,000 --> 00:18:06,000
乐观很多

486
00:18:06,000 --> 00:18:08,000
其实上都没有那么烂

487
00:18:08,000 --> 00:18:10,000
他们的原话是

488
00:18:10,000 --> 00:18:12,000
我说这个是 iE 9 还是 iE 10

489
00:18:12,000 --> 00:18:14,000
才会非常烂

490
00:18:14,000 --> 00:18:16,000
No, that's not so

491
00:18:18,000 --> 00:18:22,000
这是刘兰其相关的好文

492
00:18:22,000 --> 00:18:24,000
对

493
00:18:24,000 --> 00:18:25,000
所以

494
00:18:25,000 --> 00:18:26,000
这是在

495
00:18:26,000 --> 00:18:28,000
Modern Crom 中

496
00:18:28,000 --> 00:18:30,000
如果你不停的 rerender 的话

497
00:18:30,000 --> 00:18:32,000
实际上也没有那么烂

498
00:18:32,000 --> 00:18:34,000
当然我们要做好的演技

499
00:18:34,000 --> 00:18:36,000
所以他们又

500
00:18:36,000 --> 00:18:38,000
脑洞大开着

501
00:18:38,000 --> 00:18:40,000
想把这个 Dome

502
00:18:40,000 --> 00:18:42,000
这个事情整个

503
00:18:42,000 --> 00:18:44,000
给 incaps 整个

504
00:18:44,000 --> 00:18:46,000
Virtualized

505
00:18:46,000 --> 00:18:48,000
所以开发者就

506
00:18:48,000 --> 00:18:50,000
完全不去操作这个 Dome

507
00:18:50,000 --> 00:18:52,000
然后通过

508
00:18:52,000 --> 00:18:54,000
react 本身的一套算法

509
00:18:54,000 --> 00:18:56,000
react 会

510
00:18:56,000 --> 00:18:58,000
试图发现

511
00:18:58,000 --> 00:19:00,000
两个 State 之间

512
00:19:00,000 --> 00:19:02,000
区别帮你自动地去

513
00:19:02,000 --> 00:19:04,000
update 真正的刘兰其的 Dome

514
00:19:04,000 --> 00:19:06,000
这就

515
00:19:06,000 --> 00:19:07,000
移除了这个

516
00:19:07,000 --> 00:19:09,000
Portfulness 的问题

517
00:19:09,000 --> 00:19:11,000
从而回过头来

518
00:19:11,000 --> 00:19:14,000
enable 了开发者去写

519
00:19:14,000 --> 00:19:16,000
更 descriptive

520
00:19:16,000 --> 00:19:18,000
更 declurative

521
00:19:18,000 --> 00:19:22,000
不是直接告诉刘兰其去做什么

522
00:19:22,000 --> 00:19:23,000
对

523
00:19:23,000 --> 00:19:24,000
这里就提到有一个

524
00:19:24,000 --> 00:19:25,000
react

525
00:19:25,000 --> 00:19:26,000
在这个最新的这种

526
00:19:26,000 --> 00:19:27,000
前端的

527
00:19:27,000 --> 00:19:28,000
它也比较宽假嘛

528
00:19:28,000 --> 00:19:29,000
这个公司

529
00:19:29,000 --> 00:19:31,000
它最核心的一点就是说

530
00:19:31,000 --> 00:19:33,000
它本身是和刘兰其的 Dome

531
00:19:33,000 --> 00:19:34,000
是拖截的

532
00:19:34,000 --> 00:19:35,000
就是它没有一个

533
00:19:35,000 --> 00:19:36,000
很

534
00:19:36,000 --> 00:19:38,000
所谓的 Type-Coppling 在里面

535
00:19:38,000 --> 00:19:39,000
就是它

536
00:19:39,000 --> 00:19:40,000
Render 出来的结果

537
00:19:40,000 --> 00:19:41,000
并不是得到的

538
00:19:41,000 --> 00:19:43,000
一个真正的刘兰其的 Dome

539
00:19:43,000 --> 00:19:44,000
而是一个

540
00:19:44,000 --> 00:19:46,000
所以他们想的一个虚拟的 Dome

541
00:19:46,000 --> 00:19:47,000
Virtual 的

542
00:19:47,000 --> 00:19:48,000
对

543
00:19:48,000 --> 00:19:49,000
他们再有做了这么一个

544
00:19:49,000 --> 00:19:50,000
Diff 这一层

545
00:19:50,000 --> 00:19:51,000
然后再去

546
00:19:51,000 --> 00:19:53,000
说怎么用最小的代价

547
00:19:53,000 --> 00:19:55,000
使得刘兰其里面

548
00:19:55,000 --> 00:19:57,000
现在有的那个真实的 Dome

549
00:19:57,000 --> 00:19:58,000
能够变成

550
00:19:58,000 --> 00:20:01,000
这个 VirtualDome 需要的形状

551
00:20:01,000 --> 00:20:02,000
这样的话就可以

552
00:20:02,000 --> 00:20:03,000
尽量减少

553
00:20:03,000 --> 00:20:06,000
Dome 那边的胶货的开销嘛

554
00:20:06,000 --> 00:20:07,000
对

555
00:20:07,000 --> 00:20:09,000
当然这个的前提假设就是说

556
00:20:09,000 --> 00:20:11,000
你跟真实的刘兰其

557
00:20:11,000 --> 00:20:12,000
真实的 Dome 的胶货

558
00:20:12,000 --> 00:20:14,000
是一个比较高层本的

559
00:20:14,000 --> 00:20:16,000
但是在一个现代刘兰其

560
00:20:16,000 --> 00:20:18,000
现代的加分 Script 的解析器的情况下

561
00:20:18,000 --> 00:20:20,000
它的那个加分 Script 内部的

562
00:20:20,000 --> 00:20:23,000
执行和解析的速度是非常快的

563
00:20:23,000 --> 00:20:25,000
所以要解决这两个之间差异的话

564
00:20:25,000 --> 00:20:26,000
它就通过这种

565
00:20:26,000 --> 00:20:28,000
做 Dif 的方法来实现嘛

566
00:20:28,000 --> 00:20:29,000
对,没错

567
00:20:29,000 --> 00:20:31,000
很有意思的是

568
00:20:31,000 --> 00:20:33,000
David Nolan 是那个

569
00:20:33,000 --> 00:20:34,000
叫做

570
00:20:34,000 --> 00:20:37,000
David Nolan 是 ClosureScript 的作者

571
00:20:37,000 --> 00:20:39,000
然后他们有把

572
00:20:39,000 --> 00:20:42,000
React 给写了一个

573
00:20:42,000 --> 00:20:44,000
ClosureScript 的 React 叫做

574
00:20:44,000 --> 00:20:45,000
OMM

575
00:20:45,000 --> 00:20:47,000
它给了一个 Printation

576
00:20:47,000 --> 00:20:49,000
然后它不把 VirtualDome 叫做 VirtualDome

577
00:20:49,000 --> 00:20:53,000
它把 VirtualDome 叫做 DomeVirtualMachine

578
00:20:54,000 --> 00:20:56,000
这是一个非常小的差异

579
00:20:56,000 --> 00:20:59,000
但是我想它想要说的是说

580
00:20:59,000 --> 00:21:02,000
VirtualDome 实现是非常

581
00:21:02,000 --> 00:21:04,000
powerful

582
00:21:06,000 --> 00:21:10,000
然后这个 React 它的可能在思维折

583
00:21:10,000 --> 00:21:11,000
学上我就有一点很大的不同

584
00:21:11,000 --> 00:21:13,000
就是说传统上我们像用这个

585
00:21:13,000 --> 00:21:14,000
Backbond 之类的

586
00:21:14,000 --> 00:21:15,000
其实是你是在

587
00:21:15,000 --> 00:21:17,000
你是把 Dome 当成一个巨大的 State

588
00:21:17,000 --> 00:21:20,000
然后你是在手工的去管理那些 State

589
00:21:20,000 --> 00:21:21,000
对吧

590
00:21:22,000 --> 00:21:23,000
然后这可能就很多的操作

591
00:21:23,000 --> 00:21:25,000
就是你还可能就要手动去添加什么

592
00:21:25,000 --> 00:21:27,000
这个 Evan Handleware

593
00:21:27,000 --> 00:21:28,000
然后它发生什么时候

594
00:21:28,000 --> 00:21:30,000
请你要优积的把它取掉

595
00:21:30,000 --> 00:21:32,000
然后要做一些相应的修改

596
00:21:32,000 --> 00:21:34,000
就是整个来看这个

597
00:21:34,000 --> 00:21:36,000
交互的流程和这个

598
00:21:36,000 --> 00:21:38,000
这个你的这个 Virtual 是混杂的

599
00:21:38,000 --> 00:21:41,000
比较比较就是什么

600
00:21:41,000 --> 00:21:43,000
这个叫什么

601
00:21:43,000 --> 00:21:45,000
却牙交错对吧

602
00:21:45,000 --> 00:21:47,000
终于想起这个

603
00:21:47,000 --> 00:21:49,000
这个处杂就

604
00:21:49,000 --> 00:21:50,000
对

605
00:21:51,000 --> 00:21:53,000
但是像 React 的那种思路的话

606
00:21:53,000 --> 00:21:54,000
它有那么 VirtualDome 的思路

607
00:21:54,000 --> 00:21:55,000
其实干脆为了

608
00:21:55,000 --> 00:21:57,000
为了已经解释过一下

609
00:21:57,000 --> 00:22:00,000
就是说它其实是放弃了这一条

610
00:22:00,000 --> 00:22:02,000
就说我们不要去手工去

611
00:22:02,000 --> 00:22:03,000
去改那个

612
00:22:03,000 --> 00:22:06,000
一个牛乱青边 Dome 的每一个小细节

613
00:22:06,000 --> 00:22:08,000
而是说我们你只要告诉我

614
00:22:08,000 --> 00:22:10,000
你需要让它达到什么样的状态

615
00:22:10,000 --> 00:22:11,000
但是这个需要让你说

616
00:22:11,000 --> 00:22:13,000
你是一次性的描述性的状态吗

617
00:22:13,000 --> 00:22:14,000
对

618
00:22:14,000 --> 00:22:16,000
然后这样的话

619
00:22:16,000 --> 00:22:17,000
我就只需要说

620
00:22:17,000 --> 00:22:20,000
那我不需要考虑怎么去变到这个状态

621
00:22:20,000 --> 00:22:23,000
我只需要声明我最后要达到什么样的状态就可以了

622
00:22:23,000 --> 00:22:24,000
其实这个让我想起

623
00:22:24,000 --> 00:22:27,000
Backbone 的一个一句

624
00:22:27,000 --> 00:22:29,000
宣传口号就是

625
00:22:29,000 --> 00:22:32,000
Get the truth out from your 懂

626
00:22:32,000 --> 00:22:35,000
但实际上

627
00:22:35,000 --> 00:22:38,000
它的这个口号所指的是要把

628
00:22:38,000 --> 00:22:41,000
其实就是很简单的

629
00:22:41,000 --> 00:22:44,000
要把 Dome 所要呈现的那层

630
00:22:44,000 --> 00:22:46,000
那些数据

631
00:22:46,000 --> 00:22:51,000
作为你的 model 从 Dome 们抽息出来

632
00:22:51,000 --> 00:22:54,000
但如果沿着这一句

633
00:22:54,000 --> 00:22:57,000
宣传口号更进一步研发的话

634
00:22:57,000 --> 00:23:00,000
我觉得可能最终结果就是像 Rect 这样

635
00:23:00,000 --> 00:23:03,000
就是将 Dome 作为某种

636
00:23:03,000 --> 00:23:06,000
就像 screen buffer 这样

637
00:23:06,000 --> 00:23:10,000
就是计算出最终需要的 Dome

638
00:23:10,000 --> 00:23:14,000
然后去更新它与实际的 Dome 所差跃这一部分

639
00:23:14,000 --> 00:23:18,000
这样可能更多的处处

640
00:23:18,000 --> 00:23:21,000
被从 Dome 们抽息出来

641
00:23:21,000 --> 00:23:25,000
其实它这个思想也不是说原创新的

642
00:23:25,000 --> 00:23:27,000
就是在很多年前做游戏的

643
00:23:27,000 --> 00:23:29,000
大家都已经发现有这么一个

644
00:23:29,000 --> 00:23:33,000
就做那种电脑游戏的人都已经有这么一个概念了

645
00:23:33,000 --> 00:23:36,000
过去游戏有一个叫做

646
00:23:36,000 --> 00:23:37,000
会许徒刑的话

647
00:23:37,000 --> 00:23:38,000
也就是一个所谓的

648
00:23:38,000 --> 00:23:39,000
就是一个 media mode

649
00:23:39,000 --> 00:23:40,000
就是立即模式

650
00:23:40,000 --> 00:23:43,000
就是你画什么就在那个屏幕上出现什么吗

651
00:23:44,000 --> 00:23:48,000
然后在发现其实这样的话对那个叫什么

652
00:23:48,000 --> 00:23:50,000
对性能其实是不好的

653
00:23:50,000 --> 00:23:53,000
然后在他们发现用什么 Rentangle 的话

654
00:23:53,000 --> 00:23:56,000
你其实可以在让这个游戏引擎

655
00:23:56,000 --> 00:23:57,000
去做一些优化

656
00:23:57,000 --> 00:23:58,000
就说把

657
00:23:58,000 --> 00:23:59,000
对 你先报一下

658
00:23:59,000 --> 00:24:00,000
你先报一下一下

659
00:24:00,000 --> 00:24:01,000
下一针会一些

660
00:24:01,000 --> 00:24:04,000
应该显示什么让它计算出两者的差异

661
00:24:05,000 --> 00:24:07,000
其实在 Rect 的看不上

662
00:24:08,000 --> 00:24:12,000
没有人提到跟游戏上差异

663
00:24:12,000 --> 00:24:16,000
所以我有点就是自己在想再好奇

664
00:24:16,000 --> 00:24:17,000
说到的这个是

665
00:24:17,000 --> 00:24:18,000
一个疏图同归呢

666
00:24:18,000 --> 00:24:21,000
还是他们有真正的在那个

667
00:24:21,000 --> 00:24:24,000
游戏开发者身上提取灵感

668
00:24:24,000 --> 00:24:28,000
但我更亲向于是相信是一个疏图同归的结果

669
00:24:28,000 --> 00:24:29,000
对对对

670
00:24:29,000 --> 00:24:31,000
我也觉得那个 Peter Hunt

671
00:24:31,000 --> 00:24:34,000
Peter Hunt 他在那个去年的那个

672
00:24:34,000 --> 00:24:35,000
介绍 react 的那个会上面

673
00:24:35,000 --> 00:24:36,000
他就讲了

674
00:24:36,000 --> 00:24:38,000
就说他们做发现

675
00:24:38,000 --> 00:24:40,000
他们那个做成了三地游戏的人

676
00:24:40,000 --> 00:24:41,000
好像也是用了同样一套似的

677
00:24:41,000 --> 00:24:42,000
同样一套似的

678
00:24:42,000 --> 00:24:45,000
我说其实确实是一个疏图同归的一个结果

679
00:24:45,000 --> 00:24:47,000
其实我相信现在的

680
00:24:47,000 --> 00:24:51,000
WatApp 领域了很多技术可能在

681
00:24:51,000 --> 00:24:55,000
就是古早的三地技术发展

682
00:24:55,000 --> 00:24:57,000
道路上都已经讨论过了

683
00:24:57,000 --> 00:25:02,000
然后有些经验可能也是会需要被

684
00:25:02,000 --> 00:25:04,000
backport 过来的

685
00:25:04,000 --> 00:25:07,000
或者说其实我们把这个

686
00:25:07,000 --> 00:25:09,000
领域放得更宽广一点

687
00:25:09,000 --> 00:25:12,000
就是说前端如果不仅限于

688
00:25:12,000 --> 00:25:14,000
这个网页或者是一个

689
00:25:14,000 --> 00:25:15,000
Covidon App 的话

690
00:25:15,000 --> 00:25:17,000
就是游戏从某种意义上才讲

691
00:25:17,000 --> 00:25:19,000
也是在做一个前端的东西了

692
00:25:19,000 --> 00:25:22,000
我觉得游戏可能最大的差别是

693
00:25:22,000 --> 00:25:28,000
它和它的前端和后端之间的差异

694
00:25:28,000 --> 00:25:31,000
它和前端后端之间没有中间

695
00:25:31,000 --> 00:25:33,000
隔着这么巨大的一个

696
00:25:33,000 --> 00:25:35,000
互联网的红狗

697
00:25:35,000 --> 00:25:39,000
就是它中间的通讯没有这么大的一个

698
00:25:39,000 --> 00:25:41,000
一个延迟或者说

699
00:25:41,000 --> 00:25:44,000
有这么大的一个协议站摆在那边

700
00:25:44,000 --> 00:25:46,000
它现在你很多游戏也是

701
00:25:46,000 --> 00:25:48,000
我做做网络的 Network game

702
00:25:48,000 --> 00:25:50,000
所以其实还有很大相似点的

703
00:25:50,000 --> 00:25:52,000
但那一部分仅仅是用来

704
00:25:52,000 --> 00:25:54,000
交互游戏数据的

705
00:25:54,000 --> 00:26:00,000
你的表现层的数据

706
00:26:00,000 --> 00:26:03,000
就是在本地生成

707
00:26:03,000 --> 00:26:05,000
除非你是在做 streaming

708
00:26:05,000 --> 00:26:07,000
但是 streaming 又是另外一个话题

709
00:26:07,000 --> 00:26:10,000
对,这也是一个问题

710
00:26:10,000 --> 00:26:12,000
Rag 其实还有一点

711
00:26:12,000 --> 00:26:14,000
就是说它是更新降于你使用

712
00:26:14,000 --> 00:26:16,000
所有的 imutable data structure

713
00:26:16,000 --> 00:26:19,000
就是不可修改的数据结果

714
00:26:19,000 --> 00:26:22,000
这点上我们在抗上有提到

715
00:26:22,000 --> 00:26:25,000
然后顺带说我非常喜欢

716
00:26:25,000 --> 00:26:28,000
我在 Rag 抗上我真的非常高兴

717
00:26:28,000 --> 00:26:29,000
非常激动

718
00:26:29,000 --> 00:26:32,000
因为传统一想来说

719
00:26:32,000 --> 00:26:34,000
前段不是一个很好的估计

720
00:26:34,000 --> 00:26:35,000
也是东西被拔

721
00:26:35,000 --> 00:26:37,000
大家一般看前段

722
00:26:37,000 --> 00:26:40,000
对吧,这都有点小笔式的意思

723
00:26:40,000 --> 00:26:41,000
对对对

724
00:26:41,000 --> 00:26:43,000
更加工程导向而不是

725
00:26:43,000 --> 00:26:44,000
对,你能导向吗

726
00:26:44,000 --> 00:26:47,000
更加 25 岁以上的导向

727
00:26:47,000 --> 00:26:49,000
不要这么

728
00:26:49,000 --> 00:26:51,000
不过我也想起来那个

729
00:26:51,000 --> 00:26:53,000
所以

730
00:26:53,000 --> 00:26:55,000
所以正是在这个抗讯上

731
00:26:55,000 --> 00:26:57,000
我们有听到很多很有意思的东西

732
00:26:57,000 --> 00:27:00,000
其中有一个 imutable data

733
00:27:00,000 --> 00:27:03,000
我们有一个演讲是

734
00:27:03,000 --> 00:27:05,000
Libarong 给的演讲

735
00:27:05,000 --> 00:27:07,000
在专门说 imutable

736
00:27:07,000 --> 00:27:09,000
Dogs Facebook

737
00:27:09,000 --> 00:27:12,000
imutable data JavaScript 实现

738
00:27:12,000 --> 00:27:15,000
它有讲到很多 imutable data

739
00:27:15,000 --> 00:27:17,000
到底是有什么东西

740
00:27:17,000 --> 00:27:20,000
怎么在加了实现的

741
00:27:20,000 --> 00:27:21,000
非常好

742
00:27:21,000 --> 00:27:24,000
但是 back 到 Rag 上来说的话

743
00:27:24,000 --> 00:27:27,000
之所以 imutable data 是 preferred

744
00:27:27,000 --> 00:27:29,000
not required but preferred

745
00:27:29,000 --> 00:27:31,000
是因为

746
00:27:31,000 --> 00:27:33,000
这因为 react 它的设计方式

747
00:27:33,000 --> 00:27:35,000
整个的 render 过程

748
00:27:35,000 --> 00:27:36,000
整个的 component

749
00:27:36,000 --> 00:27:37,000
实际上就是

750
00:27:37,000 --> 00:27:40,000
Prob's plus state

751
00:27:40,000 --> 00:27:42,000
equal to something

752
00:27:42,000 --> 00:27:44,000
这个 equal 是 render 方式

753
00:27:44,000 --> 00:27:45,000
所做的事情

754
00:27:45,000 --> 00:27:46,000
所以

755
00:27:46,000 --> 00:27:47,000
如果你的 Prob's

756
00:27:47,000 --> 00:27:48,000
getting the state

757
00:27:48,000 --> 00:27:49,000
不变化的话

758
00:27:49,000 --> 00:27:51,000
你的 render result

759
00:27:51,000 --> 00:27:52,000
总是一致的

760
00:27:52,000 --> 00:27:54,000
总会是一样的

761
00:27:54,000 --> 00:27:55,000
对

762
00:27:55,000 --> 00:27:57,000
虽然说 virtual DOM

763
00:27:57,000 --> 00:27:59,000
会帮助你不去 update the DOM

764
00:27:59,000 --> 00:28:00,000
但是如果你在

765
00:28:00,000 --> 00:28:02,000
你连 render 都

766
00:28:02,000 --> 00:28:04,000
连 render 方式都不用去

767
00:28:04,000 --> 00:28:06,000
不用去 wrong 的话

768
00:28:06,000 --> 00:28:08,000
那就是

769
00:28:08,000 --> 00:28:10,000
实现了更好的

770
00:28:10,000 --> 00:28:11,000
Proformance 然后

771
00:28:11,000 --> 00:28:12,000
省下更多的时间

772
00:28:12,000 --> 00:28:14,000
特别是在大型的

773
00:28:14,000 --> 00:28:16,000
Application 上

774
00:28:16,000 --> 00:28:18,000
但是怎么去判呢

775
00:28:18,000 --> 00:28:19,000
Prob's 跟 state

776
00:28:19,000 --> 00:28:20,000
有没有改变

777
00:28:20,000 --> 00:28:22,000
就变成一个很大的问题

778
00:28:22,000 --> 00:28:24,000
传统的 mutable data 的话

779
00:28:24,000 --> 00:28:25,000
是个 ON 的操作

780
00:28:25,000 --> 00:28:27,000
你必须得

781
00:28:27,000 --> 00:28:28,000
对 你的主角去

782
00:28:28,000 --> 00:28:30,000
必须把整个 object

783
00:28:30,000 --> 00:28:31,000
给变力来

784
00:28:31,000 --> 00:28:32,000
然后

785
00:28:32,000 --> 00:28:33,000
如果你要做

786
00:28:33,000 --> 00:28:34,000
Deep Comperes

787
00:28:34,000 --> 00:28:35,000
就更大

788
00:28:35,000 --> 00:28:37,000
是一个数捧的一个

789
00:28:37,000 --> 00:28:39,000
imitable data

790
00:28:39,000 --> 00:28:40,000
实现了

791
00:28:40,000 --> 00:28:42,000
Constant time 的

792
00:28:42,000 --> 00:28:43,000
Comperes

793
00:28:43,000 --> 00:28:44,000
O 1

794
00:28:44,000 --> 00:28:45,000
对

795
00:28:45,000 --> 00:28:47,000
你只要判断一个指针

796
00:28:47,000 --> 00:28:49,000
我这个空间

797
00:28:49,000 --> 00:28:51,000
时间跟空间是

798
00:28:51,000 --> 00:28:53,000
花在其他的部分

799
00:28:53,000 --> 00:28:54,000
一个 render 上

800
00:28:54,000 --> 00:28:56,000
就更有帮助

801
00:28:56,000 --> 00:28:57,000
非常快

802
00:28:57,000 --> 00:28:59,000
我们在跟其他的

803
00:28:59,000 --> 00:29:02,000
你会者讨厌的时候

804
00:29:02,000 --> 00:29:04,000
也提到很多人

805
00:29:04,000 --> 00:29:06,000
就是一开始也没有用

806
00:29:06,000 --> 00:29:08,000
imitable data

807
00:29:08,000 --> 00:29:10,000
但越用 react

808
00:29:10,000 --> 00:29:11,000
你就说

809
00:29:11,000 --> 00:29:12,000
这个 total make sense

810
00:29:12,000 --> 00:29:13,000
你要为什么不用呢

811
00:29:13,000 --> 00:29:14,000
对吧

812
00:29:14,000 --> 00:29:15,000
对

813
00:29:15,000 --> 00:29:17,000
所以 imitable data

814
00:29:17,000 --> 00:29:18,000
这个事情非常有意思

815
00:29:18,000 --> 00:29:19,000
就不是一个传统

816
00:29:19,000 --> 00:29:20,000
以上加到数捧

817
00:29:20,000 --> 00:29:21,000
是个人 care 日东西

818
00:29:21,000 --> 00:29:25,000
这因为对于 imitable data

819
00:29:25,000 --> 00:29:28,000
这个

820
00:29:28,000 --> 00:29:29,000
细毫

821
00:29:29,000 --> 00:29:30,000
才导致了

822
00:29:30,000 --> 00:29:31,000
Close script

823
00:29:31,000 --> 00:29:32,000
加了 react

824
00:29:32,000 --> 00:29:33,000
的行列

825
00:29:33,000 --> 00:29:34,000
因为 Closer

826
00:29:34,000 --> 00:29:35,000
它所有的 data

827
00:29:35,000 --> 00:29:36,000
本来就是 imitable

828
00:29:36,000 --> 00:29:37,000
它是个方式的 manager

829
00:29:37,000 --> 00:29:38,000
然后它所有的 data

830
00:29:38,000 --> 00:29:39,000
都是 imitable 的

831
00:29:39,000 --> 00:29:40,000
所以

832
00:29:40,000 --> 00:29:42,000
就很 natural

833
00:29:42,000 --> 00:29:43,000
它的那个 famal

834
00:29:43,000 --> 00:29:44,000
就很好的

835
00:29:44,000 --> 00:29:46,000
利用我们这样一个特性

836
00:29:46,000 --> 00:29:47,000
对

837
00:29:47,000 --> 00:29:48,000
三字我看了

838
00:29:48,000 --> 00:29:49,000
一个 OM

839
00:29:49,000 --> 00:29:51,000
就是那个 clear script

840
00:29:51,000 --> 00:29:52,000
的 react 实现

841
00:29:52,000 --> 00:29:53,000
他们的性能

842
00:29:53,000 --> 00:29:54,000
确实非常了不得的

843
00:29:54,000 --> 00:29:55,000
因为刚才长了嘛

844
00:29:55,000 --> 00:29:56,000
你就要

845
00:29:56,000 --> 00:29:58,000
因为在 OM 里面

846
00:29:58,000 --> 00:29:59,000
整个最大部分的

847
00:29:59,000 --> 00:30:00,000
那些 data track

848
00:30:00,000 --> 00:30:01,000
都是这个

849
00:30:01,000 --> 00:30:02,000
所有的 imitable 的话

850
00:30:02,000 --> 00:30:03,000
他们在虚然的时候

851
00:30:03,000 --> 00:30:04,000
就真的

852
00:30:04,000 --> 00:30:06,000
只够走那个

853
00:30:06,000 --> 00:30:07,000
数捧结构

854
00:30:07,000 --> 00:30:08,000
然后判断那个

855
00:30:08,000 --> 00:30:09,000
更节点的那个

856
00:30:09,000 --> 00:30:10,000
指针的就好了

857
00:30:10,000 --> 00:30:11,000
真的是非常

858
00:30:11,000 --> 00:30:12,000
非常快速的一个国家

859
00:30:12,000 --> 00:30:13,000
对

860
00:30:13,000 --> 00:30:14,000
顺带说

861
00:30:14,000 --> 00:30:16,000
在整个 conference 中

862
00:30:16,000 --> 00:30:17,000
我们有提到

863
00:30:17,000 --> 00:30:19,000
非常多的

864
00:30:19,000 --> 00:30:20,000
performance 的 trick

865
00:30:20,000 --> 00:30:21,000
怎么样

866
00:30:21,000 --> 00:30:22,000
时间更好的 performance

867
00:30:22,000 --> 00:30:23,000
imitable 是其中之一

868
00:30:23,000 --> 00:30:25,000
我们有提到很多其他的东西

869
00:30:25,000 --> 00:30:26,000
如果

870
00:30:26,000 --> 00:30:27,000
观众听众同样

871
00:30:27,000 --> 00:30:28,000
有兴趣的话

872
00:30:28,000 --> 00:30:29,000
可以找到

873
00:30:29,000 --> 00:30:30,000
这些 kinald

874
00:30:30,000 --> 00:30:31,000
也可以写信问我

875
00:30:31,000 --> 00:30:32,000
或者

876
00:30:32,000 --> 00:30:33,000
或者告诉你

877
00:30:33,000 --> 00:30:34,000
我们说明一下

878
00:30:34,000 --> 00:30:35,000
可以做

879
00:30:35,000 --> 00:30:37,000
更多关于 react 的

880
00:30:37,000 --> 00:30:38,000
更细节

881
00:30:38,000 --> 00:30:40,000
更优化的东西

882
00:30:40,000 --> 00:30:41,000
对

883
00:30:41,000 --> 00:30:43,000
怎么过来他们看那个

884
00:30:43,000 --> 00:30:45,000
现场那个视频

885
00:30:45,000 --> 00:30:46,000
先跟他说一下这个

886
00:30:46,000 --> 00:30:47,000
这个 reactcon

887
00:30:47,000 --> 00:30:48,000
发了 15 的

888
00:30:48,000 --> 00:30:49,000
所有的视频都在

889
00:30:49,000 --> 00:30:51,000
YouTube 上面有的

890
00:30:51,000 --> 00:30:52,000
但是

891
00:30:52,000 --> 00:30:53,000
现在国内

892
00:30:53,000 --> 00:30:55,000
VPN 也打击的比较严重

893
00:30:55,000 --> 00:30:56,000
我们能看到

894
00:30:56,000 --> 00:30:57,000
就不好说了

895
00:30:57,000 --> 00:30:58,000
个人不许

896
00:30:58,000 --> 00:30:59,000
他不许

897
00:30:59,000 --> 00:31:00,000
我们也都在吧

898
00:31:00,000 --> 00:31:01,000
好像可以吧

899
00:31:01,000 --> 00:31:02,000
就是我在看

900
00:31:02,000 --> 00:31:03,000
今天 YouTube 上有个频道

901
00:31:03,000 --> 00:31:04,000
叫做

902
00:31:04,000 --> 00:31:05,000
Facebook

903
00:31:05,000 --> 00:31:07,000
Developer 的频道

904
00:31:07,000 --> 00:31:08,000
然后这个圈上

905
00:31:08,000 --> 00:31:09,000
基本上

906
00:31:09,000 --> 00:31:12,000
应该你需要的都可以看到

907
00:31:12,000 --> 00:31:14,000
我就说国内的

908
00:31:14,000 --> 00:31:15,000
我们听众很多都在国内嘛

909
00:31:15,000 --> 00:31:17,000
他们没有办法去上这个

910
00:31:17,000 --> 00:31:18,000
我有点不想知道

911
00:31:18,000 --> 00:31:19,000
这个我觉得

912
00:31:19,000 --> 00:31:21,000
Facebook

913
00:31:21,000 --> 00:31:22,000
好像只有

914
00:31:22,000 --> 00:31:23,000
他只有三个

915
00:31:23,000 --> 00:31:24,000
只有那个

916
00:31:24,000 --> 00:31:25,000
Relay

917
00:31:25,000 --> 00:31:26,000
他有那个

918
00:31:26,000 --> 00:31:27,000
Emetric 道 GS 的 Naking

919
00:31:27,000 --> 00:31:28,000
他在逐渐放

920
00:31:28,000 --> 00:31:29,000
他已经

921
00:31:29,000 --> 00:31:30,000
我觉得他

922
00:31:30,000 --> 00:31:32,000
可能还是在做一些

923
00:31:32,000 --> 00:31:33,000
剪辑之类的工作

924
00:31:33,000 --> 00:31:34,000
他对中是要

925
00:31:34,000 --> 00:31:35,000
他要把他

926
00:31:35,000 --> 00:31:36,000
全部放上去

927
00:31:36,000 --> 00:31:37,000
他没有理由

928
00:31:37,000 --> 00:31:38,000
想重放出来

929
00:31:38,000 --> 00:31:39,000
因为

930
00:31:39,000 --> 00:31:40,000
对对

931
00:31:40,000 --> 00:31:41,000
反正一共是有

932
00:31:41,000 --> 00:31:42,000
Dogs

933
00:31:42,000 --> 00:31:43,000
一共是 Dogs

934
00:31:43,000 --> 00:31:44,000
两天是

935
00:31:44,000 --> 00:31:46,000
12 个产品

936
00:31:46,000 --> 00:31:47,000
Anyways

937
00:31:47,000 --> 00:31:48,000
就是这样

938
00:31:48,000 --> 00:31:49,000
Facebook

939
00:31:49,000 --> 00:31:50,000
没有

940
00:31:50,000 --> 00:31:51,000
没有

941
00:31:51,000 --> 00:31:52,000
没有

942
00:31:52,000 --> 00:31:53,000
没有

943
00:31:53,000 --> 00:31:54,000
没有

944
00:31:54,000 --> 00:31:55,000
没有

945
00:31:55,000 --> 00:31:56,000
没有

946
00:31:56,000 --> 00:31:57,000
没有

947
00:31:57,000 --> 00:31:58,000
没有

948
00:31:58,000 --> 00:31:59,000
然后其实说

949
00:31:59,000 --> 00:32:00,000
React 这个

950
00:32:00,000 --> 00:32:01,000
我们传统上一般

951
00:32:01,000 --> 00:32:02,000
认为它是在 MVC

952
00:32:02,000 --> 00:32:03,000
里面做的那个

953
00:32:03,000 --> 00:32:05,000
V 的那个角色对吧

954
00:32:05,000 --> 00:32:06,000
对

955
00:32:06,000 --> 00:32:07,000
但是我们传统

956
00:32:07,000 --> 00:32:08,000
一个 MVC 的话

957
00:32:08,000 --> 00:32:10,000
那个像 M 和 C 内部分

958
00:32:10,000 --> 00:32:11,000
怎么解决

959
00:32:11,000 --> 00:32:12,000
其实

960
00:32:12,000 --> 00:32:13,000
在

961
00:32:13,000 --> 00:32:14,000
相当产品的那个

962
00:32:14,000 --> 00:32:15,000
还是没有很好那个方案吧

963
00:32:15,000 --> 00:32:17,000
但是去年

964
00:32:17,000 --> 00:32:18,000
年末的时候

965
00:32:18,000 --> 00:32:19,000
他们公开了一个

966
00:32:19,000 --> 00:32:20,000
叫做这个 Flux 的

967
00:32:20,000 --> 00:32:21,000
这么一个

968
00:32:21,000 --> 00:32:22,000
你个架构吧

969
00:32:22,000 --> 00:32:23,000
也不算是一个

970
00:32:23,000 --> 00:32:25,000
就是一个指导方针

971
00:32:25,000 --> 00:32:26,000
只能说是

972
00:32:26,000 --> 00:32:27,000
就是你怎么去

973
00:32:27,000 --> 00:32:28,000
用 React 方式去

974
00:32:28,000 --> 00:32:29,000
构建一个传统的

975
00:32:29,000 --> 00:32:30,000
MVC 的

976
00:32:30,000 --> 00:32:31,000
实现的时候

977
00:32:31,000 --> 00:32:32,000
你要注意一下什么问题

978
00:32:32,000 --> 00:32:33,000
这个 Flux

979
00:32:33,000 --> 00:32:34,000
我觉得也是一个

980
00:32:34,000 --> 00:32:35,000
非常

981
00:32:35,000 --> 00:32:36,000
具有

982
00:32:36,000 --> 00:32:37,000
什么

983
00:32:37,000 --> 00:32:39,000
画实在意的一个方式

984
00:32:39,000 --> 00:32:40,000
就跟他讲那个

985
00:32:40,000 --> 00:32:41,000
我怎么记得

986
00:32:41,000 --> 00:32:42,000
就是 Flux 出来的时候

987
00:32:42,000 --> 00:32:43,000
黑客就是

988
00:32:43,000 --> 00:32:44,000
黑说

989
00:32:44,000 --> 00:32:45,000
他们 Ready Discover 的

990
00:32:45,000 --> 00:32:46,000
一个非常古老的 ID

991
00:32:46,000 --> 00:32:47,000
然后把他

992
00:32:47,000 --> 00:32:49,000
重新包装了一遍

993
00:32:49,000 --> 00:32:51,000
然后改名叫 Flux

994
00:32:51,000 --> 00:32:52,000
但其实

995
00:32:52,000 --> 00:32:54,000
在起码在这个前段开发名

996
00:32:54,000 --> 00:32:55,000
他确实是一个

997
00:32:55,000 --> 00:32:56,000
挺好的事情我见

998
00:32:56,000 --> 00:32:57,000
其实这一点

999
00:32:57,000 --> 00:32:58,000
像我跟

1000
00:32:58,000 --> 00:32:59,000
无套所说的

1001
00:32:59,000 --> 00:33:00,000
有点那次

1002
00:33:00,000 --> 00:33:01,000
我至今呢

1003
00:33:01,000 --> 00:33:02,000
也觉得 Flux 的

1004
00:33:03,000 --> 00:33:04,000
ID 也是

1005
00:33:04,000 --> 00:33:05,000
怎么说

1006
00:33:05,000 --> 00:33:07,000
我如果看历史的话

1007
00:33:07,000 --> 00:33:08,000
你有看

1008
00:33:08,000 --> 00:33:09,000
我有看所有的 Flux 的

1009
00:33:09,000 --> 00:33:10,000
订阅我这些东西

1010
00:33:10,000 --> 00:33:11,000
你看的话

1011
00:33:11,000 --> 00:33:12,000
他们最初

1012
00:33:12,000 --> 00:33:14,000
Flux 要解决的问题

1013
00:33:14,000 --> 00:33:15,000
并不是

1014
00:33:15,000 --> 00:33:17,000
真正的 MVC

1015
00:33:17,000 --> 00:33:18,000
我觉得他们

1016
00:33:18,000 --> 00:33:19,000
在最初

1017
00:33:19,000 --> 00:33:21,000
在 Inventive Flux 的时候

1018
00:33:21,000 --> 00:33:23,000
他们所使用的

1019
00:33:23,000 --> 00:33:25,000
做事情的方式

1020
00:33:25,000 --> 00:33:27,000
并不是真正的 MVC

1021
00:33:27,000 --> 00:33:29,000
但是这并不是说

1022
00:33:29,000 --> 00:33:30,000
就 Flux 就不好

1023
00:33:30,000 --> 00:33:32,000
就不是因此 Flux

1024
00:33:32,000 --> 00:33:34,000
这个框架就不对

1025
00:33:34,000 --> 00:33:35,000
这个我

1026
00:33:35,000 --> 00:33:37,000
很有意思的是

1027
00:33:37,000 --> 00:33:38,000
在这儿

1028
00:33:38,000 --> 00:33:39,000
在这儿

1029
00:33:39,000 --> 00:33:41,000
在这儿

1030
00:33:41,000 --> 00:33:42,000
那个 speaker

1031
00:33:42,000 --> 00:33:43,000
反复的提到

1032
00:33:43,000 --> 00:33:45,000
他们最初发布

1033
00:33:45,000 --> 00:33:46,000
react 的时候

1034
00:33:46,000 --> 00:33:47,000
大家的反应

1035
00:33:47,000 --> 00:33:48,000
最初发布

1036
00:33:48,000 --> 00:33:49,000
react 是在

1037
00:33:49,000 --> 00:33:50,000
Jescon

1038
00:33:50,000 --> 00:33:52,000
2013

1039
00:33:52,000 --> 00:33:54,000
Jescon

1040
00:33:54,000 --> 00:33:55,000
在这儿

1041
00:33:55,000 --> 00:33:56,000
反应都非常

1042
00:33:56,000 --> 00:33:57,000
Negative

1043
00:33:57,000 --> 00:33:58,000
叫做

1044
00:33:58,000 --> 00:33:59,000
Reinventive View

1045
00:33:59,000 --> 00:34:01,000
Reinventive View

1046
00:34:01,000 --> 00:34:02,000
Reinventive View

1047
00:34:02,000 --> 00:34:03,000
Reinventive View

1048
00:34:03,000 --> 00:34:04,000
最好的

1049
00:34:04,000 --> 00:34:05,000
迪士迪

1050
00:34:05,000 --> 00:34:06,000
迪士迪

1051
00:34:07,000 --> 00:34:09,000
rebelting

1052
00:34:09,000 --> 00:34:10,000
順暴的

1053
00:34:10,000 --> 00:34:11,000
的表演

1054
00:34:11,000 --> 00:34:12,000
一个转眼

1055
00:34:12,000 --> 00:34:13,000
一个转眼

1056
00:34:13,000 --> 00:34:14,000
一个转眼

1057
00:34:14,000 --> 00:34:15,000
一个转眼

1058
00:34:15,000 --> 00:34:16,000
一个转眼

1059
00:34:16,000 --> 00:34:18,000
一个 mute

1060
00:34:18,000 --> 00:34:20,000
终于

1061
00:34:20,000 --> 00:34:21,000
上完了

1062
00:34:21,000 --> 00:34:22,000
这个会

1063
00:34:22,000 --> 00:34:23,000
我是

1064
00:34:23,000 --> 00:34:24,000
觉得

1065
00:34:24,000 --> 00:34:26,000
大家选 as

1066
00:34:26,000 --> 00:34:28,000
打起还要保持 OT

1067
00:34:28,000 --> 00:34:29,000
去他

1068
00:34:29,000 --> 00:34:30,000
确实

1069
00:34:30,000 --> 00:34:31,000
开始看

1070
00:34:32,000 --> 00:34:35,000
我们 nearly

1071
00:34:35,000 --> 00:34:37,000
是什么 我就一直才是最重要的 对不对

1072
00:34:37,000 --> 00:34:40,000
所以 Back to Flux 上来说

1073
00:34:40,000 --> 00:34:44,000
它实际上跟传统一样的 NVC 有非常多的相似的地方

1074
00:34:44,000 --> 00:34:53,000
整个 Destatch mode 整个的 Event 流程单项的信息的流动

1075
00:34:53,000 --> 00:34:57,000
实际上跟传统一样的 NVC 是非常非常类似的

1076
00:34:57,000 --> 00:34:59,000
但是它有细节上的差异

1077
00:34:59,000 --> 00:35:01,000
比方说 Action 是 Global 的

1078
00:35:01,000 --> 00:35:03,000
Despatch 是 Global 的

1079
00:35:03,000 --> 00:35:08,000
比方说在一个信息没有流完的情况下

1080
00:35:08,000 --> 00:35:10,000
你不能够 Initialize 另外一个信息

1081
00:35:10,000 --> 00:35:18,000
像这样的信息的差异实际上就意味着 Flux 跟传统的 NVC 不一样

1082
00:35:18,000 --> 00:35:22,000
特别是在 比如说如果我们用 Back to Flux

1083
00:35:22,000 --> 00:35:26,000
如果 Model 触发一个 Change Event

1084
00:35:26,000 --> 00:35:31,000
Change Event Event Handbook 是可以再去改变这个 Model

1085
00:35:31,000 --> 00:35:34,000
然后从而就产生另外一个 Change Event

1086
00:35:34,000 --> 00:35:37,000
它有 Cascading 的效果在

1087
00:35:37,000 --> 00:35:43,000
Flux 的发明跟 Cascading 非常关系

1088
00:35:43,000 --> 00:35:45,000
一个重点的原因

1089
00:35:45,000 --> 00:35:49,000
他们去发明的 Flux 就是不想要 Cascading

1090
00:35:49,000 --> 00:35:51,000
应该叫细小的一些什么

1091
00:35:51,000 --> 00:35:52,000
因为太难管理

1092
00:35:52,000 --> 00:35:54,000
You don't know what would happen

1093
00:35:54,000 --> 00:35:55,000
You don't know what is Apple 的 Happen

1094
00:35:55,000 --> 00:35:58,000
就好像 React

1095
00:35:58,000 --> 00:36:08,000
它本身就想要把 Code 跟 Declarity 画

1096
00:36:08,000 --> 00:36:09,000
Flux 也有这样的目的

1097
00:36:09,000 --> 00:36:12,000
就是让 Flow 更清晰每次的 Action

1098
00:36:12,000 --> 00:36:14,000
都是导致同一个结果

1099
00:36:14,000 --> 00:36:16,000
同一个方向流动

1100
00:36:16,000 --> 00:36:20,000
然后你的那个你不会触发另外一个

1101
00:36:20,000 --> 00:36:22,000
没有预料到结果

1102
00:36:22,000 --> 00:36:23,000
接点上

1103
00:36:23,000 --> 00:36:24,000
如果你真的去用 Flux

1104
00:36:24,000 --> 00:36:27,000
或者发现其实上是非常非常有帮助

1105
00:36:27,000 --> 00:36:30,000
对你管理你的程序的复杂度

1106
00:36:30,000 --> 00:36:32,000
对

1107
00:36:32,000 --> 00:36:35,000
我个人感觉是我之前是在做一些

1108
00:36:35,000 --> 00:36:37,000
小的那种小的 project

1109
00:36:37,000 --> 00:36:38,000
就去尝试用这个 Flux

1110
00:36:38,000 --> 00:36:39,000
这种架構

1111
00:36:39,000 --> 00:36:42,000
当然我具体用的是一个叫做 Reflux

1112
00:36:42,000 --> 00:36:43,000
一个具体的实现

1113
00:36:43,000 --> 00:36:45,000
但是他在那个逻辑上是大同小一的

1114
00:36:45,000 --> 00:36:48,000
就是有一些细微的组件上有点不一样

1115
00:36:48,000 --> 00:36:50,000
我感觉就是有很明显的区别

1116
00:36:50,000 --> 00:36:52,000
就是说采用这个 Flux

1117
00:36:52,000 --> 00:36:53,000
这个架構之后

1118
00:36:53,000 --> 00:36:59,000
整个前端应用的逻辑变得非常有条理和清晰

1119
00:36:59,000 --> 00:37:01,000
就知道边界在哪里

1120
00:37:01,000 --> 00:37:03,000
然后哪些数据在哪里管理

1121
00:37:03,000 --> 00:37:05,000
就这开始的时候你提到像用 Backbound 的时候

1122
00:37:05,000 --> 00:37:08,000
有些数据是混在这个洞里面的对吧

1123
00:37:08,000 --> 00:37:10,000
这样其实这如果用 Flask 这种方式

1124
00:37:10,000 --> 00:37:12,000
就其实是完全分离开了

1125
00:37:12,000 --> 00:37:14,000
它有所有的 Store 的概念

1126
00:37:14,000 --> 00:37:18,000
就大约略等同于以前 MVC 里面那个 Model

1127
00:37:18,000 --> 00:37:22,000
但是说它的 Store 里面它有一些具体的限制

1128
00:37:22,000 --> 00:37:24,000
比如说你不能说 Store 触发

1129
00:37:24,000 --> 00:37:26,000
就是 Cascading 的东西出来

1130
00:37:26,000 --> 00:37:31,000
这样其实然后就可以保证你这个信息的流向是单项的

1131
00:37:31,000 --> 00:37:35,000
这样的话就可以让你很方便地去把这个

1132
00:37:35,000 --> 00:37:37,000
所谓的就叫 Separation of the Conservme

1133
00:37:37,000 --> 00:37:40,000
就是把那些需要关注的点上风格开来做

1134
00:37:40,000 --> 00:37:44,000
对整个价格是很有帮助的一个工具

1135
00:37:44,000 --> 00:37:47,000
然后 Flux 其实从 Facebook 的角度来说的话

1136
00:37:47,000 --> 00:37:50,000
实际上只是一个 ID 它对你到底说

1137
00:37:50,000 --> 00:37:55,000
你的 Dispatch 是什么你的 Action 是什么你的 Storage 是什么实现的

1138
00:37:55,000 --> 00:37:59,000
并没有很严格意义上的管理

1139
00:37:59,000 --> 00:38:06,000
因为像我们在做从 Back No React 的一个建议

1140
00:38:06,000 --> 00:38:08,000
从一定程度上来说

1141
00:38:08,000 --> 00:38:14,000
我可以用传统的 Back No Models Back No Collection 来实现 Flux

1142
00:38:14,000 --> 00:38:17,000
这是可能的 这是完全可能的

1143
00:38:17,000 --> 00:38:21,000
对 所以就是

1144
00:38:21,000 --> 00:38:24,000
不要举你书本上的概念

1145
00:38:24,000 --> 00:38:26,000
想一想是要解决的问题

1146
00:38:26,000 --> 00:38:30,000
然后去看一看这个 Architect 到底能不能解决这个问题

1147
00:38:30,000 --> 00:38:32,000
才是最重要的

1148
00:38:32,000 --> 00:38:35,000
而且 Flux 可能在一定程度上来说

1149
00:38:35,000 --> 00:38:38,000
只有对大型的 Application 才有意义

1150
00:38:38,000 --> 00:38:42,000
你要想 Facebook 需要解决问题是 Massive skill 对不对

1151
00:38:42,000 --> 00:38:44,000
他们有 Handroid 奖励

1152
00:38:44,000 --> 00:38:47,000
如果你只有一两个人在一个程序上工作的话

1153
00:38:47,000 --> 00:38:51,000
那或许有更清朝 更便宜的

1154
00:38:51,000 --> 00:38:54,000
没有这样东西那么选择

1155
00:38:54,000 --> 00:38:56,000
对 可能用不上用使用那种

1156
00:38:56,000 --> 00:38:58,000
就所谓大型的 Mod 山山 无亲走

1157
00:39:03,000 --> 00:39:05,000
对  React 还有一个好处

1158
00:39:05,000 --> 00:39:09,000
就是说这个所谓构建的 ISO Mofi 的加拿大 Streb 的应用

1159
00:39:09,000 --> 00:39:11,000
情况下比较好的

1160
00:39:11,000 --> 00:39:13,000
因为它可以同样的一个 React 主建

1161
00:39:13,000 --> 00:39:16,000
只要你构建的方式稍微注意一点点

1162
00:39:16,000 --> 00:39:19,000
它是可以在客户端宣养

1163
00:39:19,000 --> 00:39:21,000
或者是在客户端宣养

1164
00:39:21,000 --> 00:39:22,000
然后在客户端宣养

1165
00:39:22,000 --> 00:39:23,000
然后在客户端宣养它有一个什么好处

1166
00:39:23,000 --> 00:39:24,000
它可以在客户端宣养

1167
00:39:24,000 --> 00:39:26,000
从最初的那个页面那个结构之后

1168
00:39:26,000 --> 00:39:28,000
你把这个送给柔乱器

1169
00:39:28,000 --> 00:39:30,000
然后在柔乱器再接着

1170
00:39:30,000 --> 00:39:34,000
客户端宣那个部分开始

1171
00:39:34,000 --> 00:39:36,000
在完成后面的后续的工作

1172
00:39:36,000 --> 00:39:37,000
对

1173
00:39:37,000 --> 00:39:39,000
这个我不太清楚就是之前有其他类型的

1174
00:39:39,000 --> 00:39:41,000
框架实现过这种功能

1175
00:39:41,000 --> 00:39:43,000
但是我第一次看到这个时候

1176
00:39:43,000 --> 00:39:44,000
觉得还是蛮惊起的

1177
00:39:44,000 --> 00:39:46,000
As far as I know

1178
00:39:46,000 --> 00:39:49,000
如果你小心翼翼写你的 app 的话

1179
00:39:49,000 --> 00:39:52,000
是有可能用其他的框架加上

1180
00:39:52,000 --> 00:39:56,000
Fantasm 和 Hateless WebKit 来实现相同的功能

1181
00:39:56,000 --> 00:39:59,000
我觉得理论上是有可能的

1182
00:39:59,000 --> 00:40:02,000
但是在这个特别的效果

1183
00:40:02,000 --> 00:40:04,000
就形成上的话会随时很多

1184
00:40:04,000 --> 00:40:08,000
因为你毕竟要让一个 WebKit 在社会上

1185
00:40:08,000 --> 00:40:10,000
我发展到这个问题

1186
00:40:10,000 --> 00:40:11,000
Fantasm 发展到现在

1187
00:40:11,000 --> 00:40:13,000
也解决了非常多的问题

1188
00:40:13,000 --> 00:40:15,000
它变成了一个 server

1189
00:40:15,000 --> 00:40:16,000
而不是女每次都要

1190
00:40:16,000 --> 00:40:17,000
付那个 overhead

1191
00:40:17,000 --> 00:40:21,000
去让这个 WebKit 在这种

1192
00:40:21,000 --> 00:40:24,000
当然 React 有更大的可能性

1193
00:40:24,000 --> 00:40:27,000
因为毕竟那个框架是 virtual artist

1194
00:40:27,000 --> 00:40:28,000
对

1195
00:40:28,000 --> 00:40:31,000
它不需要去漏了一个真正的 WebKit 引进

1196
00:40:31,000 --> 00:40:33,000
它只需要在加上 Strem 内部

1197
00:40:33,000 --> 00:40:36,000
去虚构一个这么一个框架构就好

1198
00:40:36,000 --> 00:40:37,000
这次我们在 conference 上

1199
00:40:37,000 --> 00:40:41,000
有听到很多公司谈到他们的应用

1200
00:40:41,000 --> 00:40:42,000
大部分的原因呢

1201
00:40:42,000 --> 00:40:43,000
也不是因为性能

1202
00:40:43,000 --> 00:40:47,000
而是因为 ACO 很多公司很扛

1203
00:40:47,000 --> 00:40:49,000
虽然是 ACO 然后现在加上 Strem

1204
00:40:49,000 --> 00:40:53,000
还是一个没能解决问题

1205
00:40:53,000 --> 00:40:54,000
Supprise 每个字来说

1206
00:40:54,000 --> 00:40:56,000
过去中国

1207
00:40:56,000 --> 00:40:58,000
一个人就是

1208
00:40:58,000 --> 00:41:02,000
Creamy 与公司提到说

1209
00:41:02,000 --> 00:41:07,000
你要 Google 有一个 convention

1210
00:41:07,000 --> 00:41:11,000
如果你 UIL 是一个特别的结构的话

1211
00:41:11,000 --> 00:41:13,000
它会长

1212
00:41:13,000 --> 00:41:16,000
去 Fetch 另外一个 UIL

1213
00:41:16,000 --> 00:41:18,000
which is supposed to be a static page

1214
00:41:18,000 --> 00:41:20,000
但是

1215
00:41:20,000 --> 00:41:23,000
According to some other companies

1216
00:41:23,000 --> 00:41:25,000
这个功能非常

1217
00:41:25,000 --> 00:41:27,000
Google 不怎么在意这个功能

1218
00:41:27,000 --> 00:41:28,000
然后经常就坏掉了

1219
00:41:28,000 --> 00:41:30,000
所以他们经常

1220
00:41:30,000 --> 00:41:32,000
经常就没有那个 Fetch rate

1221
00:41:32,000 --> 00:41:34,000
抓不到零你知道吗

1222
00:41:34,000 --> 00:41:35,000
这是对于公司来说

1223
00:41:35,000 --> 00:41:36,000
这是 Gizelle S 的人

1224
00:41:36,000 --> 00:41:38,000
他们很多公司都是

1225
00:41:38,000 --> 00:41:40,000
很靠 Google 的有料嘛

1226
00:41:40,000 --> 00:41:42,000
如果说有这样一个问题的话

1227
00:41:42,000 --> 00:41:45,000
对于他们的 Binness critical

1228
00:41:45,000 --> 00:41:47,000
所以他们就

1229
00:41:47,000 --> 00:41:52,000
非常再易 Smorphic 的可能性

1230
00:41:52,000 --> 00:41:54,000
对 而且之前

1231
00:41:54,000 --> 00:41:55,000
之前说 Google 说

1232
00:41:55,000 --> 00:41:56,000
他说一干一种

1233
00:41:56,000 --> 00:41:57,000
新一种方式

1234
00:41:57,000 --> 00:41:59,000
通过一种特殊的 UIL 解决去说

1235
00:41:59,000 --> 00:42:01,000
告诉 Google 的爬崇

1236
00:42:01,000 --> 00:42:02,000
我这个动态网页

1237
00:42:02,000 --> 00:42:03,000
你可以在另外一个地址上

1238
00:42:03,000 --> 00:42:04,000
让他的定态版本

1239
00:42:04,000 --> 00:42:07,000
这是一个比较传统的解决方案

1240
00:42:07,000 --> 00:42:08,000
然后 Google 是

1241
00:42:08,000 --> 00:42:10,000
因为去年年末的时候

1242
00:42:10,000 --> 00:42:12,000
他们也会

1243
00:42:12,000 --> 00:42:14,000
Street 加巴斯克并面

1244
00:42:14,000 --> 00:42:15,000
就是他会当

1245
00:42:15,000 --> 00:42:17,000
把自己模拟成一个

1246
00:42:17,000 --> 00:42:20,000
榴栏器的引擎

1247
00:42:20,000 --> 00:42:22,000
去解析那个页面的加巴斯克并面

1248
00:42:22,000 --> 00:42:24,000
但是现在问题就是说

1249
00:42:24,000 --> 00:42:26,000
他们没有办法去判断哪些东西

1250
00:42:26,000 --> 00:42:27,000
是可以点的

1251
00:42:27,000 --> 00:42:29,000
只要榴栏器就是加巴斯克并面

1252
00:42:29,000 --> 00:42:30,000
都可以点击

1253
00:42:30,000 --> 00:42:32,000
可以 Namage 的项目

1254
00:42:32,000 --> 00:42:34,000
他并不像说网

1255
00:42:34,000 --> 00:42:35,000
也像你是一个 A 的

1256
00:42:35,000 --> 00:42:36,000
Anker 的 Type

1257
00:42:36,000 --> 00:42:38,000
可以去很明显的发现

1258
00:42:38,000 --> 00:42:39,000
对吧

1259
00:42:39,000 --> 00:42:40,000
所以对他们来讲

1260
00:42:40,000 --> 00:42:42,000
所以他们去发现这些

1261
00:42:42,000 --> 00:42:44,000
动态的内容始终是有问题的吗

1262
00:42:44,000 --> 00:42:46,000
所以这种情况下

1263
00:42:46,000 --> 00:42:49,000
那种 Smorphic 还是不可避免

1264
00:42:49,000 --> 00:42:51,000
然后我都感觉

1265
00:42:51,000 --> 00:42:53,000
就是说用 React 的方式

1266
00:42:53,000 --> 00:42:54,000
来实现 Smorphic 的话

1267
00:42:54,000 --> 00:42:56,000
它的难度是相...

1268
00:42:56,000 --> 00:42:58,000
就极大的被降低了吧

1269
00:42:58,000 --> 00:42:59,000
就相对于你之前手工的去

1270
00:42:59,000 --> 00:43:01,000
要么用翻成 JS 去做一个

1271
00:43:01,000 --> 00:43:04,000
Render Farm 手工的去宣言一下

1272
00:43:04,000 --> 00:43:06,000
用这个比较高成本嘛

1273
00:43:06,000 --> 00:43:07,000
另外就是说

1274
00:43:07,000 --> 00:43:09,000
它可以实现这个所谓的无缝千疑

1275
00:43:09,000 --> 00:43:11,000
你可以随意决定哪一部分是在

1276
00:43:11,000 --> 00:43:12,000
服务端宣言

1277
00:43:12,000 --> 00:43:15,000
然后哪一部分是在客户端宣言嘛

1278
00:43:15,000 --> 00:43:17,000
这个是非常不错的一个工程

1279
00:43:17,000 --> 00:43:19,000
Gang Real 做了一个非常好的总结

1280
00:43:19,000 --> 00:43:20,000
对

1281
00:43:21,000 --> 00:43:22,000
在实际的应用中

1282
00:43:22,000 --> 00:43:26,000
React 可能是最好的 Balance

1283
00:43:26,000 --> 00:43:29,000
就是性能跟可管理性最好的 Balance

1284
00:43:29,000 --> 00:43:31,000
如果你的应用正常景式

1285
00:43:31,000 --> 00:43:34,000
要需要非常好的 Poformance 的话

1286
00:43:34,000 --> 00:43:39,000
那或许你应该去看其他的一些选项

1287
00:43:39,000 --> 00:43:42,000
比方说用共用 Template

1288
00:43:42,000 --> 00:43:44,000
不是共用 JS logic

1289
00:43:44,000 --> 00:43:46,000
然后在服务期端

1290
00:43:46,000 --> 00:43:48,000
用服务期的 Native Language

1291
00:43:48,000 --> 00:43:54,000
就是 PHO 加了来写 Template 的 Render 方式

1292
00:43:54,000 --> 00:43:59,000
这样的话你要写两个 Rendering application

1293
00:43:59,000 --> 00:44:03,000
在你的工程上是更麻烦

1294
00:44:03,000 --> 00:44:05,000
但是如果你要追求性能的话

1295
00:44:05,000 --> 00:44:07,000
那是一个更好的选项

1296
00:44:07,000 --> 00:44:10,000
React 现在的问题是在你说

1297
00:44:10,000 --> 00:44:13,000
即使你在服务期端宣言

1298
00:44:13,000 --> 00:44:15,000
React 还是会给你做很多

1299
00:44:15,000 --> 00:44:18,000
不必要的 Dom 的操作

1300
00:44:18,000 --> 00:44:20,000
或者是模拟

1301
00:44:20,000 --> 00:44:22,000
有什么具体的情况

1302
00:44:22,000 --> 00:44:27,000
SResort 有公司做了测试

1303
00:44:27,000 --> 00:44:29,000
然后 SResort 相对于说

1304
00:44:29,000 --> 00:44:33,000
就是我刚说用 PHP 来 Render 这个 Template 的话

1305
00:44:33,000 --> 00:44:42,000
它的输出率只有 Template 大概 25%

1306
00:44:42,000 --> 00:44:43,000
有差这么多吗

1307
00:44:43,000 --> 00:44:45,000
这是非常可以优化

1308
00:44:45,000 --> 00:44:47,000
因为有很多 Dom 的

1309
00:44:47,000 --> 00:44:49,000
就是不要说 Event handle

1310
00:44:49,000 --> 00:44:52,000
这些东西你都不在服务期端都没有必要去关联了

1311
00:44:52,000 --> 00:44:53,000
对吧

1312
00:44:53,000 --> 00:44:55,000
因为你最终只需要一个近台的硬盟

1313
00:44:55,000 --> 00:44:57,000
你只需要这个近台的结果

1314
00:44:57,000 --> 00:45:01,000
但是就是一个 OpenSource Project

1315
00:45:01,000 --> 00:45:02,000
很有趣的地方

1316
00:45:02,000 --> 00:45:05,000
Facebook 本身对这个没有太大兴趣

1317
00:45:05,000 --> 00:45:07,000
因为他们没有太大需求

1318
00:45:07,000 --> 00:45:10,000
但是如果其他公司或者是密益

1319
00:45:10,000 --> 00:45:12,000
我们听众对此有需求的话

1320
00:45:12,000 --> 00:45:14,000
可以去看他们 Tools code

1321
00:45:14,000 --> 00:45:18,000
然后对 WitchGal 们做出一些修改来实现更好的

1322
00:45:18,000 --> 00:45:20,000
在 SResort 上 Render 的功能

1323
00:45:20,000 --> 00:45:22,000
我想这个潜力非常非常大

1324
00:45:22,000 --> 00:45:25,000
因为它现在基本上是没有任何优化的

1325
00:45:25,000 --> 00:45:27,000
对对对对

1326
00:45:27,000 --> 00:45:29,000
这种情况还是挺好我觉得

1327
00:45:29,000 --> 00:45:33,000
说到这个 Rack 在实际使用的时候

1328
00:45:33,000 --> 00:45:35,000
就会有牵涉到一个很有意思的

1329
00:45:35,000 --> 00:45:37,000
它的写法和一个语言

1330
00:45:37,000 --> 00:45:39,000
这个 GasX

1331
00:45:39,000 --> 00:45:41,000
就是什么概念呢

1332
00:45:41,000 --> 00:45:43,000
因为我们是在传统上

1333
00:45:43,000 --> 00:45:45,000
我们写一个前端应用的时候

1334
00:45:45,000 --> 00:45:47,000
我们是把这个模板和数据

1335
00:45:47,000 --> 00:45:48,000
或者是螺旋纯

1336
00:45:48,000 --> 00:45:49,000
完全分离开来的

1337
00:45:49,000 --> 00:45:51,000
就模板可能会用什么

1338
00:45:51,000 --> 00:45:53,000
什么 Stash 之类的一些东西来

1339
00:45:53,000 --> 00:45:55,000
用 HTM 来写一个模板

1340
00:45:55,000 --> 00:45:56,000
然后有些空

1341
00:45:56,000 --> 00:45:57,000
然后当那个

1342
00:45:57,000 --> 00:45:59,000
加个 Script 去把模板

1343
00:45:59,000 --> 00:46:00,000
录的就来

1344
00:46:00,000 --> 00:46:01,000
然后把那个空铁上

1345
00:46:01,000 --> 00:46:03,000
就轮得出一个近台的页面

1346
00:46:03,000 --> 00:46:06,000
再发给出去填到页面里面去

1347
00:46:06,000 --> 00:46:08,000
但是在 Rack 里面去

1348
00:46:08,000 --> 00:46:10,000
我们推荐的方式是说

1349
00:46:10,000 --> 00:46:13,000
不要区分这个模板和数据和逻辑

1350
00:46:13,000 --> 00:46:14,000
你是做一个前端应用

1351
00:46:14,000 --> 00:46:16,000
你的模板就是你的这个

1352
00:46:16,000 --> 00:46:18,000
要核心要考虑的一部分

1353
00:46:18,000 --> 00:46:20,000
我觉得就是 Rack 的

1354
00:46:20,000 --> 00:46:22,000
Retank Best Practice 的一部分

1355
00:46:22,000 --> 00:46:24,000
理论上来说

1356
00:46:24,000 --> 00:46:26,000
我们之前做 Molo 的那个 Best Practice

1357
00:46:26,000 --> 00:46:28,000
是说把模板分离开来

1358
00:46:28,000 --> 00:46:29,000
这样的话

1359
00:46:29,000 --> 00:46:31,000
你有更好的重用性

1360
00:46:31,000 --> 00:46:33,000
因为你那个模板是可以被重用的

1361
00:46:33,000 --> 00:46:34,000
对

1362
00:46:34,000 --> 00:46:35,000
可是如果你看 GasX

1363
00:46:35,000 --> 00:46:37,000
它实际上不是一个模板

1364
00:46:37,000 --> 00:46:39,000
其实就是 Script code 嘛

1365
00:46:39,000 --> 00:46:41,000
你所写的

1366
00:46:41,000 --> 00:46:43,000
你只不过是用那种类似于写模板的

1367
00:46:43,000 --> 00:46:45,000
语法去描述数据吧

1368
00:46:45,000 --> 00:46:46,000
对 一个这样的

1369
00:46:46,000 --> 00:46:47,000
就是它

1370
00:46:47,000 --> 00:46:48,000
对

1371
00:46:48,000 --> 00:46:51,000
你在你用一种写模板的方式去写

1372
00:46:51,000 --> 00:46:52,000
你的 DataMolo

1373
00:46:52,000 --> 00:46:54,000
其实是一种进步

1374
00:46:54,000 --> 00:46:55,000
而不是

1375
00:46:55,000 --> 00:46:57,000
就是某种抨击

1376
00:46:57,000 --> 00:46:58,000
某些人抨击的那样

1377
00:46:58,000 --> 00:46:59,000
是一种历史的套退

1378
00:46:59,000 --> 00:47:00,000
我觉得可能

1379
00:47:00,000 --> 00:47:02,000
对 这个事情就提出挺好玩

1380
00:47:02,000 --> 00:47:04,000
因为刚那个就是 Rack 去年

1381
00:47:04,000 --> 00:47:05,000
刚发布

1382
00:47:05,000 --> 00:47:07,000
正式都要发布的时候

1383
00:47:07,000 --> 00:47:08,000
很多人就是图草这一点

1384
00:47:08,000 --> 00:47:10,000
因为大家都可能被这个

1385
00:47:10,000 --> 00:47:12,000
教条 教条罐

1386
00:47:12,000 --> 00:47:14,000
就是说这个模板和数据要分离

1387
00:47:14,000 --> 00:47:15,000
但其实

1388
00:47:15,000 --> 00:47:16,000
我觉得当时那个 Pitong

1389
00:47:16,000 --> 00:47:18,000
它有一个话说的很好

1390
00:47:18,000 --> 00:47:19,000
就是说这个模板

1391
00:47:19,000 --> 00:47:21,000
它分的那个

1392
00:47:21,000 --> 00:47:23,000
就 Suppersync 上是分错了

1393
00:47:23,000 --> 00:47:26,000
它把两个不应该分开的东西强行分开了

1394
00:47:26,000 --> 00:47:28,000
但其实没有太多的好处嘛

1395
00:47:28,000 --> 00:47:30,000
所以通过就是像那个 Rack 这种 GasX 方式

1396
00:47:30,000 --> 00:47:32,000
其实是把这两个本来

1397
00:47:32,000 --> 00:47:34,000
就应该紧密连细在一起的

1398
00:47:34,000 --> 00:47:37,000
不两个部分 放在一个地方

1399
00:47:37,000 --> 00:47:38,000
然后大家可以一眼看到

1400
00:47:38,000 --> 00:47:39,000
就像那个

1401
00:47:39,000 --> 00:47:41,000
那个未来之前抱怨的说那个

1402
00:47:41,000 --> 00:47:43,000
大家可以帮你写很多这种

1403
00:47:43,000 --> 00:47:45,000
Wu 的时候不方便说

1404
00:47:45,000 --> 00:47:47,000
在一个文件里面就看出它在干什么

1405
00:47:47,000 --> 00:47:49,000
然后用这种 GasX 的方式

1406
00:47:49,000 --> 00:47:50,000
你可以一眼看出

1407
00:47:50,000 --> 00:47:52,000
我这个是在做一个模板

1408
00:47:52,000 --> 00:47:55,000
我在这个模板里面填穿了这么一个数据

1409
00:47:55,000 --> 00:47:57,000
然后这个数据是从这个对象

1410
00:47:57,000 --> 00:47:58,000
哪个地方来的

1411
00:47:58,000 --> 00:48:00,000
然后这个我要天下哪些这个一般 Handle 玩

1412
00:48:00,000 --> 00:48:02,000
都在同一个地方完成这个东西

1413
00:48:02,000 --> 00:48:04,000
这个才是一个好的成为的这个

1414
00:48:04,000 --> 00:48:06,000
这个 Capsulele 什么

1415
00:48:06,000 --> 00:48:07,000
我要再一次提醒大家

1416
00:48:07,000 --> 00:48:09,000
就是你需要考虑自己的实际问题

1417
00:48:09,000 --> 00:48:13,000
然后选择正确的 Framal 或者 Handle'sHandle

1418
00:48:13,000 --> 00:48:14,000
Adopt

1419
00:48:14,000 --> 00:48:16,000
我们刚说那个 Sumphate 对不对

1420
00:48:16,000 --> 00:48:17,000
在那种情况下

1421
00:48:17,000 --> 00:48:20,000
实际上你如果你分离出模板来的话

1422
00:48:20,000 --> 00:48:21,000
是有好处的

1423
00:48:21,000 --> 00:48:24,000
因为你如果你要再后端

1424
00:48:24,000 --> 00:48:28,000
用另外一种语言来写你的 RenderLogical

1425
00:48:28,000 --> 00:48:30,000
那个共用模板是可以共用的

1426
00:48:30,000 --> 00:48:33,000
但得看在你的实际上实际上实际过程中

1427
00:48:33,000 --> 00:48:35,000
我们是没有这么错的

1428
00:48:35,000 --> 00:48:38,000
然后我们所有的模板是没有任何重用性的

1429
00:48:38,000 --> 00:48:40,000
也不是没有任何重用性

1430
00:48:40,000 --> 00:48:41,000
也是没有

1431
00:48:41,000 --> 00:48:43,000
它是有很强的重用性

1432
00:48:43,000 --> 00:48:45,000
因为它它在另外一个

1433
00:48:45,000 --> 00:48:48,000
就是单独的自己的文件中的话

1434
00:48:48,000 --> 00:48:50,000
但是我们从来没有重用过它

1435
00:48:50,000 --> 00:48:51,000
从来没有重用过它

1436
00:48:51,000 --> 00:48:54,000
在三年的写这个程式的工程中

1437
00:48:54,000 --> 00:48:56,000
那到底做什么事

1438
00:48:56,000 --> 00:48:57,000
是为了什么

1439
00:48:57,000 --> 00:48:59,000
我们其实也不是很清楚

1440
00:48:59,000 --> 00:49:00,000
没想到

1441
00:49:00,000 --> 00:49:02,000
所以在车点的应用场景下

1442
00:49:02,000 --> 00:49:04,000
特定的 BestPractice 是有道理的

1443
00:49:04,000 --> 00:49:06,000
刚刚说我们刚刚说那个

1444
00:49:06,000 --> 00:49:08,000
你如果一个重用一个模板要在

1445
00:49:08,000 --> 00:49:09,000
不同的语言中被 RenderLogical

1446
00:49:09,000 --> 00:49:11,000
那实际上是非常好的设计

1447
00:49:11,000 --> 00:49:13,000
但如果你仅仅是在加拿大学的时候

1448
00:49:13,000 --> 00:49:15,000
那可能真的你得重新考虑这个程度

1449
00:49:15,000 --> 00:49:16,000
到底是不是有意义的

1450
00:49:16,000 --> 00:49:18,000
何况你用 Rae Act 的时候

1451
00:49:18,000 --> 00:49:20,000
这就真的不是模板了

1452
00:49:20,000 --> 00:49:21,000
这个模板这个东西不存在的

1453
00:49:21,000 --> 00:49:23,000
它所有的东西都是

1454
00:49:23,000 --> 00:49:24,000
加拿大学的

1455
00:49:24,000 --> 00:49:26,000
There's no screen template

1456
00:49:26,000 --> 00:49:28,000
这个念头你得转过彎来

1457
00:49:28,000 --> 00:49:29,000
对你写这

1458
00:49:29,000 --> 00:49:31,000
它只是看起来像啊

1459
00:49:31,000 --> 00:49:32,000
对 但玩家不是

1460
00:49:32,000 --> 00:49:34,000
好说在于说

1461
00:49:34,000 --> 00:49:36,000
刚我们说

1462
00:49:36,000 --> 00:49:38,000
把 Subview 的问题在

1463
00:49:38,000 --> 00:49:41,000
Buckle 里头你得在模板里头

1464
00:49:41,000 --> 00:49:43,000
给它流空间

1465
00:49:43,000 --> 00:49:45,000
然后在 Manual Insert 进去

1466
00:49:45,000 --> 00:49:47,000
在 Rae Act 中就不是问题了

1467
00:49:47,000 --> 00:49:49,000
你直接 impote 一下

1468
00:49:49,000 --> 00:49:52,000
然后 impote 那个 Subcomponent

1469
00:49:52,000 --> 00:49:54,000
然后直接把这个 tag 写上去就好

1470
00:49:54,000 --> 00:49:57,000
这是个非常非常非常好的

1471
00:49:57,000 --> 00:50:00,000
就是重用性的进步吧

1472
00:50:00,000 --> 00:50:03,000
对 而且实际上也在

1473
00:50:03,000 --> 00:50:06,000
也大量减轻了看法者的

1474
00:50:06,000 --> 00:50:11,000
Mental model 就是在维护一个

1475
00:50:11,000 --> 00:50:14,000
Mental model 的负担

1476
00:50:14,000 --> 00:50:16,000
就是你不用总是在

1477
00:50:16,000 --> 00:50:18,000
我现在在寒冷

1478
00:50:18,000 --> 00:50:19,000
我现在在寒冷

1479
00:50:19,000 --> 00:50:20,000
你不用在维护这个

1480
00:50:20,000 --> 00:50:22,000
不停的 Context switch 的成本上头

1481
00:50:22,000 --> 00:50:24,000
还有你是得提到的是

1482
00:50:24,000 --> 00:50:26,000
GSX 并不是一个

1483
00:50:26,000 --> 00:50:28,000
全新的东西

1484
00:50:28,000 --> 00:50:30,000
在 Facebook 内部

1485
00:50:30,000 --> 00:50:32,000
我这是一个开源的项目

1486
00:50:32,000 --> 00:50:35,000
它们一直在用类似的产品

1487
00:50:35,000 --> 00:50:37,000
叫做 XHP

1488
00:50:37,000 --> 00:50:39,000
是 PHP 的版本

1489
00:50:39,000 --> 00:50:41,000
所以它们很常在

1490
00:50:41,000 --> 00:50:43,000
已经在 PHP 里写

1491
00:50:43,000 --> 00:50:45,000
所谓 HGMTag 了

1492
00:50:45,000 --> 00:50:47,000
所以在这边上

1493
00:50:47,000 --> 00:50:49,000
也是对这个 Consumer 的一个 Baladation

1494
00:50:49,000 --> 00:50:51,000
因为毕竟 Facebook 有用

1495
00:50:51,000 --> 00:50:53,000
相同的概念

1496
00:50:53,000 --> 00:50:54,000
用了很久了

1497
00:50:54,000 --> 00:50:57,000
我觉得它们先人一步

1498
00:50:57,000 --> 00:50:59,000
已经 AXF 的概念了

1499
00:50:59,000 --> 00:51:01,000
所以对它们来说

1500
00:51:01,000 --> 00:51:03,000
不是一个事

1501
00:51:05,000 --> 00:51:06,000
对 我大概也是

1502
00:51:06,000 --> 00:51:08,000
就是前年去彎区的时候

1503
00:51:08,000 --> 00:51:11,000
然后看到它们在 Facebook 内部

1504
00:51:11,000 --> 00:51:12,000
是怎么用这个

1505
00:51:12,000 --> 00:51:14,000
叫做 XHP 的这么个语言

1506
00:51:14,000 --> 00:51:16,000
去写这个

1507
00:51:16,000 --> 00:51:18,000
他们都扶断的缘件

1508
00:51:18,000 --> 00:51:19,000
当时我就震撼到了

1509
00:51:19,000 --> 00:51:20,000
我说这个

1510
00:51:20,000 --> 00:51:21,000
因为它们那个等于是

1511
00:51:21,000 --> 00:51:23,000
可以任意勾渐一种

1512
00:51:23,000 --> 00:51:25,000
传统上我们写这个模板的时候

1513
00:51:25,000 --> 00:51:28,000
你只能用一个抽象程度很低的方式

1514
00:51:28,000 --> 00:51:29,000
因为你模板的话

1515
00:51:29,000 --> 00:51:31,000
你要么就在模板层别上

1516
00:51:31,000 --> 00:51:32,000
你可以勾渐一些东西出来

1517
00:51:32,000 --> 00:51:34,000
或者是说

1518
00:51:34,000 --> 00:51:35,000
你在写那些

1519
00:51:35,000 --> 00:51:36,000
那些那些标签的时候

1520
00:51:36,000 --> 00:51:38,000
你还是要用那些标准的标签吗

1521
00:51:38,000 --> 00:51:40,000
但是它们在用 XHP 的时候

1522
00:51:40,000 --> 00:51:43,000
其实是可以定义自己的一个标签的

1523
00:51:43,000 --> 00:51:44,000
然后这个标签可以

1524
00:51:44,000 --> 00:51:47,000
包含很多很复杂的这种行为和数据

1525
00:51:47,000 --> 00:51:49,000
包括内部的结构在里面

1526
00:51:49,000 --> 00:51:51,000
而对这个标签的调用方式来讲

1527
00:51:51,000 --> 00:51:54,000
完全可以不用关心里面到底是如何实现的

1528
00:51:54,000 --> 00:51:55,000
其实就有点像一个

1529
00:51:55,000 --> 00:51:59,000
安卧的 JS 所做出来的新的 SMLTIC

1530
00:51:59,000 --> 00:52:01,000
只不过这一切就在

1531
00:52:01,000 --> 00:52:02,000
他们这个

1532
00:52:02,000 --> 00:52:03,000
他们应该也是叫做

1533
00:52:03,000 --> 00:52:04,000
Consumerable 的打

1534
00:52:04,000 --> 00:52:05,000
这个时候

1535
00:52:05,000 --> 00:52:06,000
就是它

1536
00:52:06,000 --> 00:52:08,000
所谓这个组件化的时候

1537
00:52:08,000 --> 00:52:09,000
就组件化的时候

1538
00:52:09,000 --> 00:52:12,000
就一个要达到一个什么样的场景

1539
00:52:12,000 --> 00:52:13,000
就是说我只要勾渐好

1540
00:52:13,000 --> 00:52:14,000
我这个组件

1541
00:52:14,000 --> 00:52:16,000
我这个组件对外部来说

1542
00:52:16,000 --> 00:52:17,000
是一个完全封闭的

1543
00:52:17,000 --> 00:52:20,000
你只要外部提供给我需要的数据

1544
00:52:20,000 --> 00:52:23,000
我需要的包括一些回调韩数的话

1545
00:52:23,000 --> 00:52:25,000
我这个组件就能完成你需要的工作

1546
00:52:25,000 --> 00:52:28,000
就不再需要去每个人都去看到这个组件

1547
00:52:28,000 --> 00:52:29,000
内部是由多少个什么

1548
00:52:29,000 --> 00:52:30,000
多少个 A-Type

1549
00:52:30,000 --> 00:52:32,000
多少个 D-F 这种成成包起来

1550
00:52:32,000 --> 00:52:33,000
这么一个东西

1551
00:52:33,000 --> 00:52:34,000
这一点我觉得是一个

1552
00:52:34,000 --> 00:52:37,000
在抽象层级上是一个化时代的进步

1553
00:52:37,000 --> 00:52:38,000
我觉得

1554
00:52:38,000 --> 00:52:39,000
是

1555
00:52:39,000 --> 00:52:41,000
然后

1556
00:52:41,000 --> 00:52:42,000
当时那个

1557
00:52:42,000 --> 00:52:43,000
我看到 Facebook

1558
00:52:43,000 --> 00:52:45,000
他们内部在用这个最后这么好

1559
00:52:45,000 --> 00:52:46,000
这个真是

1560
00:52:46,000 --> 00:52:47,000
因为我们又在其他地方看到

1561
00:52:47,000 --> 00:52:49,000
有类似的产品

1562
00:52:49,000 --> 00:52:52,000
或者是语言 8 在做类似的事情

1563
00:52:52,000 --> 00:52:55,000
真的是感觉走在什么时代的前例

1564
00:52:55,000 --> 00:52:56,000
跟我们不一

1565
00:52:56,000 --> 00:52:58,000
跟其他人的

1566
00:52:58,000 --> 00:52:59,000
就是差点

1567
00:52:59,000 --> 00:53:00,000
就凝先的满远的

1568
00:53:00,000 --> 00:53:02,000
那我们先们讲那个

1569
00:53:02,000 --> 00:53:04,000
Ragniting 吧

1570
00:53:04,000 --> 00:53:06,000
Yes 6

1571
00:53:06,000 --> 00:53:07,000
我讲

1572
00:53:07,000 --> 00:53:08,000
那个

1573
00:53:08,000 --> 00:53:10,000
那其实不是很重要

1574
00:53:10,000 --> 00:53:11,000
我觉得这个是

1575
00:53:11,000 --> 00:53:13,000
为了你觉得呢

1576
00:53:13,000 --> 00:53:14,000
说到 Yes 6

1577
00:53:14,000 --> 00:53:16,000
我觉得

1578
00:53:16,000 --> 00:53:17,000
我觉得

1579
00:53:17,000 --> 00:53:19,000
这个就是

1580
00:53:19,000 --> 00:53:20,000
Ragniting

1581
00:53:20,000 --> 00:53:21,000
因为

1582
00:53:21,000 --> 00:53:22,000
Ragniting

1583
00:53:22,000 --> 00:53:23,000
是不在

1584
00:53:23,000 --> 00:53:25,000
它的发展过程中

1585
00:53:25,000 --> 00:53:27,000
考虑了更多的

1586
00:53:27,000 --> 00:53:28,000
Java's Community

1587
00:53:28,000 --> 00:53:29,000
的东西

1588
00:53:29,000 --> 00:53:32,000
Wow Engle 好像在创造一个自己的小世界

1589
00:53:32,000 --> 00:53:33,000
我们有

1590
00:53:33,000 --> 00:53:34,000
一个 panel

1591
00:53:34,000 --> 00:53:35,000
上有

1592
00:53:35,000 --> 00:53:36,000
Sabussian

1593
00:53:36,000 --> 00:53:37,000
是

1594
00:53:37,000 --> 00:53:40,000
Ragn 的主要的维护者之一

1595
00:53:40,000 --> 00:53:41,000
然后它实际上

1596
00:53:41,000 --> 00:53:42,000
它本身是在

1597
00:53:42,000 --> 00:53:44,000
Yes 6 的

1598
00:53:44,000 --> 00:53:46,000
委员会上

1599
00:53:46,000 --> 00:53:48,000
所以它有提到说

1600
00:53:48,000 --> 00:53:49,000
Ragn

1601
00:53:49,000 --> 00:53:50,000
非常

1602
00:53:50,000 --> 00:53:51,000
非常 aggressive

1603
00:53:51,000 --> 00:53:53,000
在会 Yes 6 的支持

1604
00:53:53,000 --> 00:53:54,000
它甚至把

1605
00:53:54,000 --> 00:53:55,000
Mixing 的支持

1606
00:53:55,000 --> 00:53:56,000
可以去掉了

1607
00:53:56,000 --> 00:53:57,000
在最新的版本

1608
00:53:57,000 --> 00:53:58,000
它掉了吗

1609
00:53:58,000 --> 00:54:01,000
它只是那是因为 Yes 6 的

1610
00:54:01,000 --> 00:54:03,000
Mixing 支持

1611
00:54:03,000 --> 00:54:05,000
在那个

1612
00:54:05,000 --> 00:54:06,000
Ragniting

1613
00:54:06,000 --> 00:54:07,000
是在那个

1614
00:54:07,000 --> 00:54:09,000
Standard 中被去掉了

1615
00:54:09,000 --> 00:54:10,000
Yes 6

1616
00:54:10,000 --> 00:54:11,000
现在的

1617
00:54:11,000 --> 00:54:13,000
在这一版中的话

1618
00:54:13,000 --> 00:54:14,000
没有 Mixing

1619
00:54:14,000 --> 00:54:15,000
没有 TRMixing 的

1620
00:54:15,000 --> 00:54:17,000
它们在 Yes 7 中

1621
00:54:17,000 --> 00:54:19,000
才会去支持 Mixing

1622
00:54:19,000 --> 00:54:20,000
或者是我才会

1623
00:54:20,000 --> 00:54:22,000
把这个心再听上一存

1624
00:54:22,000 --> 00:54:23,000
所以这因为如此

1625
00:54:23,000 --> 00:54:25,000
在那个 Native

1626
00:54:25,000 --> 00:54:26,000
Classic 或者中

1627
00:54:26,000 --> 00:54:28,000
Ragniting 的 Mixing

1628
00:54:28,000 --> 00:54:29,000
给去掉了

1629
00:54:29,000 --> 00:54:30,000
当然这件事情

1630
00:54:30,000 --> 00:54:31,000
都是安慰音乐

1631
00:54:31,000 --> 00:54:32,000
所以

1632
00:54:32,000 --> 00:54:33,000
还有朋友

1633
00:54:33,000 --> 00:54:34,000
其他的变化

1634
00:54:34,000 --> 00:54:36,000
不过我觉得

1635
00:54:36,000 --> 00:54:38,000
至少在我看来的话

1636
00:54:38,000 --> 00:54:40,000
Ragn 是非常

1637
00:54:40,000 --> 00:54:42,000
很重要的

1638
00:54:42,000 --> 00:54:45,000
和

1639
00:54:45,000 --> 00:54:48,000
实现 Yes 6 的标准

1640
00:54:48,000 --> 00:54:50,000
其实你

1641
00:54:50,000 --> 00:54:52,000
为了你对 Yes 6

1642
00:54:52,000 --> 00:54:53,000
就是加了

1643
00:54:53,000 --> 00:54:55,000
StreetBet 下个版本的这个语言

1644
00:54:55,000 --> 00:54:56,000
你什么意思

1645
00:54:56,000 --> 00:54:57,000
你卖太多

1646
00:54:57,000 --> 00:55:00,000
老师说我不是很出息

1647
00:55:00,000 --> 00:55:02,000
所以我把这段解决掉吧

1648
00:55:02,000 --> 00:55:03,000
OK

1649
00:55:03,000 --> 00:55:04,000
我没有用

1650
00:55:04,000 --> 00:55:05,000
我没有用

1651
00:55:05,000 --> 00:55:06,000
我没有用

1652
00:55:06,000 --> 00:55:07,000
我没有用

1653
00:55:07,000 --> 00:55:08,000
我没有用

1654
00:55:08,000 --> 00:55:09,000
我没有用

1655
00:55:09,000 --> 00:55:10,000
我没有再跟这个

1656
00:55:10,000 --> 00:55:11,000
我没有再跟

1657
00:55:11,000 --> 00:55:13,000
我对你现在搞这个吧

1658
00:55:13,000 --> 00:55:14,000
没有没有

1659
00:55:14,000 --> 00:55:15,000
我没有再用它

1660
00:55:15,000 --> 00:55:16,000
就是在

1661
00:55:16,000 --> 00:55:17,000
就是长世去使用它

1662
00:55:17,000 --> 00:55:18,000
现在我把

1663
00:55:18,000 --> 00:55:19,000
昨天还在转

1664
00:55:19,000 --> 00:55:20,000
就是那个

1665
00:55:20,000 --> 00:55:22,000
那个 IPM 背后不去一个

1666
00:55:22,000 --> 00:55:24,000
我自己写的 CMS 嘛

1667
00:55:24,000 --> 00:55:25,000
然后一个观点

1668
00:55:25,000 --> 00:55:26,000
后台

1669
00:55:26,000 --> 00:55:28,000
那个其实是用 Reaction 的

1670
00:55:28,000 --> 00:55:29,000
那我想想

1671
00:55:29,000 --> 00:55:30,000
那么这些讲 Relay

1672
00:55:30,000 --> 00:55:31,000
还是先讲这个

1673
00:55:31,000 --> 00:55:32,000
类讲 Native 的

1674
00:55:32,000 --> 00:55:33,000
因为 Native 是上这个

1675
00:55:33,000 --> 00:55:36,000
非常非常非常自然的过度

1676
00:55:36,000 --> 00:55:37,000
因为

1677
00:55:37,000 --> 00:55:39,000
在 Reaction 中你的

1678
00:55:39,000 --> 00:55:40,000
最初的百分钟

1679
00:55:40,000 --> 00:55:43,000
你的 Render Cargage 是 Virtual Dog

1680
00:55:43,000 --> 00:55:44,000
对不对

1681
00:55:44,000 --> 00:55:45,000
但是

1682
00:55:45,000 --> 00:55:47,000
Wishable 一定要 Render Dog Dog 们上来

1683
00:55:47,000 --> 00:55:48,000
已经反正已经 Virtualize 了

1684
00:55:48,000 --> 00:55:50,000
就好像你

1685
00:55:50,000 --> 00:55:51,000
用那个虚拟机一样

1686
00:55:51,000 --> 00:55:53,000
你到底那个虚拟机

1687
00:55:53,000 --> 00:55:54,000
是在 Window 上 Round

1688
00:55:54,000 --> 00:55:55,000
是在 Max 上 Round

1689
00:55:55,000 --> 00:55:56,000
是在

1690
00:55:56,000 --> 00:55:57,000
You know

1691
00:55:57,000 --> 00:55:58,000
Like always

1692
00:55:58,000 --> 00:55:59,000
Tune 上 Round

1693
00:55:59,000 --> 00:56:01,000
并不重要嘛

1694
00:56:01,000 --> 00:56:02,000
对吧

1695
00:56:02,000 --> 00:56:03,000
所以

1696
00:56:03,000 --> 00:56:06,000
他提供一层新的抽象

1697
00:56:06,000 --> 00:56:07,000
然后

1698
00:56:07,000 --> 00:56:23,000
既融这层新的抽象

1699
00:56:23,000 --> 00:56:27,000
wealth

1700
00:56:27,000 --> 00:56:32,000
就是要把 React 跟 æLy 是 title

1701
00:56:32,000 --> 00:56:35,000
就完全没有关系 我可以不依赖一个动

1702
00:56:35,000 --> 00:56:37,000
然后最终的结果就是我们现在看到的

1703
00:56:37,000 --> 00:56:39,000
他这次发布的一个重量级的产品

1704
00:56:39,000 --> 00:56:40,000
叫做 Read 一个工具

1705
00:56:40,000 --> 00:56:41,000
叫做 Read Native

1706
00:56:41,000 --> 00:56:43,000
什么意思呢

1707
00:56:43,000 --> 00:56:44,000
简单描述一下就是说

1708
00:56:44,000 --> 00:56:46,000
我还是用加了 Script 寫我的应用

1709
00:56:46,000 --> 00:56:49,000
但是相比在网页上

1710
00:56:49,000 --> 00:56:54,000
我是是把它选择成一个网页的那些 HMTAC

1711
00:56:54,000 --> 00:56:55,000
标签的话

1712
00:56:55,000 --> 00:57:00,000
我是直接用这个某一个平台原生的 UI 主件

1713
00:57:00,000 --> 00:57:02,000
比如说在 IOS 里面就是一个原生的

1714
00:57:02,000 --> 00:57:03,000
比如说这个列表

1715
00:57:03,000 --> 00:57:05,000
那个可以滚动的那种有带重力

1716
00:57:05,000 --> 00:57:09,000
带什么加速度的关系的那种滚动窗口

1717
00:57:09,000 --> 00:57:12,000
或者说是我用一个原生的地图

1718
00:57:12,000 --> 00:57:14,000
这个主件来实现我的这些功能

1719
00:57:14,000 --> 00:57:18,000
但是我的这个程序的实际的后台的所有的这个 Model

1720
00:57:18,000 --> 00:57:19,000
还有所有的数据

1721
00:57:19,000 --> 00:57:20,000
还有包括这些逻辑

1722
00:57:20,000 --> 00:57:22,000
都其实是在加速的名言运行的

1723
00:57:22,000 --> 00:57:23,000
对

1724
00:57:23,000 --> 00:57:25,000
这个我觉得是非常了不起的一个事情

1725
00:57:25,000 --> 00:57:26,000
就是说

1726
00:57:26,000 --> 00:57:29,000
我记得很多这个 IOS 或者是 Android

1727
00:57:29,000 --> 00:57:30,000
开发的在吐槽这个

1728
00:57:30,000 --> 00:57:34,000
其实哪怕是现在应该开发的一个 IOS

1729
00:57:34,000 --> 00:57:35,000
新音或者 Android 音

1730
00:57:35,000 --> 00:57:37,000
都不是那么爽的一件事情

1731
00:57:37,000 --> 00:57:40,000
它有点像那个 BackBounce 时代的

1732
00:57:40,000 --> 00:57:43,000
有一点像在 BackBounce 时代的开发微微 ab 的感觉

1733
00:57:43,000 --> 00:57:46,000
我觉得对我来讲

1734
00:57:46,000 --> 00:57:48,000
最重要的概念在 react native

1735
00:57:48,000 --> 00:57:50,000
最重要的概念是

1736
00:57:50,000 --> 00:57:52,000
What I'm Said

1737
00:57:52,000 --> 00:57:55,000
Learn Once Write Everywhere

1738
00:57:55,000 --> 00:57:56,000
React the native

1739
00:57:56,000 --> 00:57:59,000
它必须要你 write once

1740
00:57:59,000 --> 00:58:00,000
write everywhere

1741
00:58:00,000 --> 00:58:02,000
它没有它没有 Rack native

1742
00:58:02,000 --> 00:58:07,000
本身它没有 merge the gap between Android and iOS

1743
00:58:07,000 --> 00:58:09,000
Android 还是要寫 Android app

1744
00:58:09,000 --> 00:58:11,000
IOS 还是要寫 IOS app

1745
00:58:11,000 --> 00:58:13,000
但是你寫程序的方式

1746
00:58:13,000 --> 00:58:15,000
发生了根本的电话

1747
00:58:15,000 --> 00:58:17,000
不管是寫 Web app 好

1748
00:58:17,000 --> 00:58:18,000
还是寫 Android app 好

1749
00:58:18,000 --> 00:58:20,000
还是寫 IOS app 好

1750
00:58:20,000 --> 00:58:23,000
你会用 Exact the same way

1751
00:58:23,000 --> 00:58:28,000
来寫这三个不同的环境下的 application

1752
00:58:28,000 --> 00:58:32,000
只是你会用这个环境的内容

1753
00:58:32,000 --> 00:58:33,000
不同的总结吗

1754
00:58:33,000 --> 00:58:36,000
这一点上是非常非常容易的

1755
00:58:36,000 --> 00:58:39,000
我本人对自己是深有感触

1756
00:58:39,000 --> 00:58:43,000
因为这形容是一个 IOS app

1757
00:58:43,000 --> 00:58:45,000
我不是 Woodfound

1758
00:58:45,000 --> 00:58:49,000
现在还在寫另外一个小小的说一下

1759
00:58:49,000 --> 00:58:51,000
我又在寫另外一个 IOS app

1760
00:58:51,000 --> 00:58:53,000
然后其中有很多的 Layouting

1761
00:58:53,000 --> 00:58:55,000
其实像是一个逻辑上来讲

1762
00:58:55,000 --> 00:58:56,000
是一个比较近的 app

1763
00:58:56,000 --> 00:58:58,000
但是有很多 Layouting

1764
00:58:58,000 --> 00:58:59,000
我有一个 UI label

1765
00:58:59,000 --> 00:59:02,000
这个 UI label 是可变的长度

1766
00:59:02,000 --> 00:59:09,000
然后这个 UI label 又在那个可变长度的 UI table 的时候

1767
00:59:09,000 --> 00:59:12,000
如果你想用 outalayouting 的话

1768
00:59:12,000 --> 00:59:14,000
其实是个非常非常麻烦的事情

1769
00:59:14,000 --> 00:59:17,000
因为在 UI label 第一次 Render 的时候

1770
00:59:17,000 --> 00:59:19,000
它并不知道它的寬度

1771
00:59:19,000 --> 00:59:21,000
它如果它不知道它的寬度

1772
00:59:21,000 --> 00:59:22,000
它就不知道它的高度

1773
00:59:22,000 --> 00:59:25,000
它不知道它的高度它就乱 Render

1774
00:59:25,000 --> 00:59:26,000
你就可以

1775
00:59:26,000 --> 00:59:29,000
而 Layouting 是 your all about constraints

1776
00:59:29,000 --> 00:59:32,000
所以你需要设计一系列的 Construent

1777
00:59:32,000 --> 00:59:35,000
然后这个 Layouting 应景会来猜测

1778
00:59:35,000 --> 00:59:37,000
怎么样的结果能够满足

1779
00:59:37,000 --> 00:59:39,000
你所有的 Construent

1780
00:59:39,000 --> 00:59:41,000
或者尽量满足你的 Construent

1781
00:59:41,000 --> 00:59:43,000
这是非常非常非常重要的位置

1782
00:59:43,000 --> 00:59:45,000
然后从 Wood 的角度来说的话

1783
00:59:45,000 --> 00:59:47,000
Boxymo 的多紧难难

1784
00:59:47,000 --> 00:59:50,000
所以说 Boxymo 的有时候不工作

1785
00:59:50,000 --> 00:59:51,000
多紧难难你知道

1786
00:59:51,000 --> 00:59:53,000
所谓的东西就是 Boxymox

1787
00:59:53,000 --> 00:59:55,000
Boxy 在 Box 上

1788
00:59:55,000 --> 00:59:56,000
然后你有 Margin

1789
00:59:56,000 --> 00:59:58,000
你有 Pathlin

1790
00:59:58,000 --> 00:59:58,000
你有 Border

1791
00:59:58,000 --> 01:00:00,000
这是非常非常容易理解

1792
01:00:00,000 --> 01:00:03,000
非常直观的

1793
01:00:03,000 --> 01:00:06,000
一种模式

1794
01:00:06,000 --> 01:00:07,000
反观的 IOS

1795
01:00:07,000 --> 01:00:08,000
如果你不用 Layouting

1796
01:00:08,000 --> 01:00:09,000
Layouting 来 outlayout

1797
01:00:09,000 --> 01:00:11,000
就是 Construent 非常难理解

1798
01:00:11,000 --> 01:00:13,000
然后你那个结果也不应出的

1799
01:00:13,000 --> 01:00:15,000
你如果只给我一系列的 Construent

1800
01:00:15,000 --> 01:00:18,000
如果你不告诉我结果的话

1801
01:00:18,000 --> 01:00:19,000
我很难

1802
01:00:19,000 --> 01:00:21,000
说我很有信心说是这 Construent

1803
01:00:21,000 --> 01:00:22,000
会得到我想要的结果

1804
01:00:23,000 --> 01:00:26,000
我觉得可能最重大那个差别

1805
01:00:26,000 --> 01:00:31,000
就是 Construent 被 Slayout 要求你能够在头脑中

1806
01:00:31,000 --> 01:00:36,000
维护一个最终视觉效果的模型

1807
01:00:36,000 --> 01:00:40,000
而 Boxymo 对此要求就低一点

1808
01:00:40,000 --> 01:00:42,000
或者说低很多吧应该说了

1809
01:00:42,000 --> 01:00:44,000
如果你不用 Layouting 的话

1810
01:00:44,000 --> 01:00:48,000
你有得就是 Manually 去做很多的 Math

1811
01:00:48,000 --> 01:00:50,000
如果你看那个 Construent

1812
01:00:50,000 --> 01:00:54,000
Slayout 他有遇到全都是 Math

1813
01:00:54,000 --> 01:00:55,000
Math 当然很乱

1814
01:00:55,000 --> 01:00:58,000
但倒也不是说有多难多容易

1815
01:00:58,000 --> 01:00:59,000
很多 IOS 咖啡者跟我说

1816
01:00:59,000 --> 01:01:02,000
但不难 但是那个 Aggley 多丑露

1817
01:01:02,000 --> 01:01:03,000
我考

1818
01:01:03,000 --> 01:01:05,000
然后你也想要改一点什么东西的话

1819
01:01:05,000 --> 01:01:07,000
又回头得去算

1820
01:01:07,000 --> 01:01:09,000
然后 Oh my 真的是真可怕

1821
01:01:09,000 --> 01:01:11,000
对吧

1822
01:01:11,000 --> 01:01:13,000
Rack Native

1823
01:01:13,000 --> 01:01:15,000
所以我觉得其实他们这次做的那个

1824
01:01:15,000 --> 01:01:16,000
就是他们发布的 Rack Native

1825
01:01:16,000 --> 01:01:17,000
他们也解决了这个问题

1826
01:01:17,000 --> 01:01:19,000
他们用加 vaScript

1827
01:01:20,000 --> 01:01:22,000
实现了一套 CSS 最新的

1828
01:01:22,000 --> 01:01:25,000
叫 FlexBox 的 BoxModel

1829
01:01:25,000 --> 01:01:26,000
对

1830
01:01:26,000 --> 01:01:28,000
然后他们用那个模型就去解决了

1831
01:01:28,000 --> 01:01:32,000
再去怎么去布局那些原生的 U.I.主建的问题

1832
01:01:32,000 --> 01:01:34,000
这个我觉得就刚为了一些

1833
01:01:34,000 --> 01:01:36,000
大家相信已经听出来

1834
01:01:36,000 --> 01:01:38,000
为了对 Construent Layout

1835
01:01:38,000 --> 01:01:40,000
Other Layout 的东西已经吐槽很久了

1836
01:01:40,000 --> 01:01:42,000
其实就从一个一样讲

1837
01:01:42,000 --> 01:01:44,000
Construent-based Layout 的话

1838
01:01:44,000 --> 01:01:46,000
其实它是要你在你头脑中

1839
01:01:46,000 --> 01:01:49,000
构建一个动态规划机

1840
01:01:50,000 --> 01:01:51,000
对吧

1841
01:01:51,000 --> 01:01:54,000
你得自己在头脑中随时解那个方程

1842
01:01:54,000 --> 01:01:56,000
解完就要说这个会出现在那里

1843
01:01:56,000 --> 01:01:57,000
这个会出现在那里

1844
01:01:57,000 --> 01:01:58,000
就不像 BoxModel

1845
01:01:58,000 --> 01:02:01,000
它更加反映出是一个比较直观的

1846
01:02:01,000 --> 01:02:02,000
这个应该是多大

1847
01:02:02,000 --> 01:02:03,000
它应该有多宽

1848
01:02:03,000 --> 01:02:06,000
然后它多到一个边框是

1849
01:02:06,000 --> 01:02:06,000
那个什么

1850
01:02:06,000 --> 01:02:08,000
Marchen 东西叫什么来的

1851
01:02:08,000 --> 01:02:09,000
刘白 对吧

1852
01:02:09,000 --> 01:02:10,000
刘白要多少

1853
01:02:10,000 --> 01:02:11,000
或者是跟其他的东西

1854
01:02:11,000 --> 01:02:13,000
建具要多少

1855
01:02:13,000 --> 01:02:15,000
我这个确实是 CSS

1856
01:02:15,000 --> 01:02:17,000
就是这个比较好的解决的一个地方

1857
01:02:17,000 --> 01:02:19,000
就我很好奇为什么

1858
01:02:19,000 --> 01:02:21,000
像 LSR 安卓之前

1859
01:02:21,000 --> 01:02:23,000
他们没有用到这种同样的模型

1860
01:02:23,000 --> 01:02:24,000
去做这个事情

1861
01:02:25,000 --> 01:02:26,000
这是一个很好问题

1862
01:02:26,000 --> 01:02:30,000
其实这个可以将来专门找一期谈这个

1863
01:02:30,000 --> 01:02:32,000
就是为什么 BoxModel

1864
01:02:32,000 --> 01:02:35,000
这种看起来如此简单一行

1865
01:02:35,000 --> 01:02:41,000
又大量解放生产力的布局

1866
01:02:41,000 --> 01:02:43,000
仅仅在外部领域读书一致

1867
01:02:43,000 --> 01:02:45,000
就甚至很多

1868
01:02:45,000 --> 01:02:47,000
比如说排版软件

1869
01:02:47,000 --> 01:02:49,000
都完全不去考虑这种

1870
01:02:50,000 --> 01:02:53,000
但我觉得可能还是惯性在里面吧

1871
01:02:53,000 --> 01:02:56,000
对 这个是挺奇怪的

1872
01:02:56,000 --> 01:02:57,000
比如说你说 LSR 的什么不用谈

1873
01:02:57,000 --> 01:02:59,000
LS 不用谈是因为 LSR 的不用谈

1874
01:03:01,000 --> 01:03:04,000
LSB 已经一开始只是 LSR 的一个改版

1875
01:03:04,000 --> 01:03:07,000
就 Mic 上的 App

1876
01:03:07,000 --> 01:03:10,000
不可能从来没有用个 BoxL

1877
01:03:10,000 --> 01:03:13,000
所以 LSR 上面也就不用了

1878
01:03:14,000 --> 01:03:17,000
这次 R&A 的体育太发布了

1879
01:03:17,000 --> 01:03:17,000
我觉得还有一点

1880
01:03:17,000 --> 01:03:24,000
我觉得特别令人觉得比较精奇的一点

1881
01:03:24,000 --> 01:03:28,000
因为整个程序的逻辑

1882
01:03:28,000 --> 01:03:34,000
和包括 Model 都是在加益式克里面的时间

1883
01:03:34,000 --> 01:03:35,000
然后这个加益式克里面

1884
01:03:35,000 --> 01:03:37,000
它是依赖于一个所谓解析器

1885
01:03:37,000 --> 01:03:38,000
或者是加益式克里面的

1886
01:03:38,000 --> 01:03:42,000
然后这个引擎可以不用跑在手机上面

1887
01:03:43,000 --> 01:03:45,000
它可以跑在现场 Demond 的时候

1888
01:03:45,000 --> 01:03:47,000
它解析器是跑在榴栏器里面的

1889
01:03:48,000 --> 01:03:53,000
然后它可以在 Krom 里面去改榴栏器

1890
01:03:53,000 --> 01:03:55,000
然后即时刷新一下

1891
01:03:55,000 --> 01:03:58,000
然后在 LSR 的 iPhone 模拟器里面

1892
01:03:58,000 --> 01:04:03,000
对应的一个原生的 UI 的介面

1893
01:04:03,000 --> 01:04:04,000
就随之发生改变了

1894
01:04:04,000 --> 01:04:05,000
我觉得这个非常了不起

1895
01:04:05,000 --> 01:04:07,000
这个在实际的

1896
01:04:07,000 --> 01:04:10,000
Production 中是不可能很难实现的

1897
01:04:11,000 --> 01:04:12,000
但是这反映了

1898
01:04:12,000 --> 01:04:15,000
是说 React 它 Native

1899
01:04:15,000 --> 01:04:17,000
到底是怎么样实现

1900
01:04:17,000 --> 01:04:19,000
从加益式克里面的这个转换

1901
01:04:21,000 --> 01:04:24,000
React Native 不想成为一个性能平庆

1902
01:04:24,000 --> 01:04:25,000
Of course not

1903
01:04:25,000 --> 01:04:29,000
所以它的实际方式就是在

1904
01:04:29,000 --> 01:04:32,000
把加益式克里面的引擎放到单独的

1905
01:04:32,000 --> 01:04:34,000
Bagron Thread 中一个单独

1906
01:04:34,000 --> 01:04:36,000
它自己一个单独的线程中

1907
01:04:37,000 --> 01:04:39,000
然后在线程中

1908
01:04:39,000 --> 01:04:43,000
有一个 Jowsky 的引擎在不断的

1909
01:04:44,000 --> 01:04:46,000
渲染然后得到结果

1910
01:04:46,000 --> 01:04:48,000
再通过 Channel 的方式

1911
01:04:48,000 --> 01:04:52,000
把这个渲染结果发回到

1912
01:04:52,000 --> 01:04:54,000
那个你的主线程中

1913
01:04:54,000 --> 01:04:56,000
所以你的主线程是没有被捧场

1914
01:04:56,000 --> 01:04:58,000
可能随时结果就是说

1915
01:04:58,000 --> 01:05:01,000
你的主线程总是很似 Moods 的

1916
01:05:01,000 --> 01:05:05,000
反观如果你有一个 WebView 的一个解决方式

1917
01:05:05,000 --> 01:05:08,000
到先不说就是你不能用 Native

1918
01:05:08,000 --> 01:05:11,000
扛碰的这种极大的问题

1919
01:05:11,000 --> 01:05:15,000
关于是说你的 Jowarship 会不挖坑的主线程

1920
01:05:15,000 --> 01:05:19,000
所以说你 Jowarship 在做一些大量的运算的时候

1921
01:05:19,000 --> 01:05:23,000
用户都在不上在向下滑

1922
01:05:23,000 --> 01:05:25,000
那个页面就不会不动

1923
01:05:25,000 --> 01:05:27,000
所以那个页面就不 Smooth

1924
01:05:27,000 --> 01:05:31,000
整个体验就很不义

1925
01:05:31,000 --> 01:05:32,000
很不乐观

1926
01:05:32,000 --> 01:05:36,000
所以 React 即使让你 React Native

1927
01:05:36,000 --> 01:05:39,000
即使使用 Native Component

1928
01:05:39,000 --> 01:05:41,000
有 Native 的 Experience

1929
01:05:41,000 --> 01:05:48,000
也从性能上帮助你不要这一共不好的体验

1930
01:05:50,000 --> 01:05:54,000
就它把这个 U.I 的渲染和这个逻辑的

1931
01:05:54,000 --> 01:05:57,000
就是业务逻辑的执行是完全隔裂开吵

1932
01:05:57,000 --> 01:06:00,000
通过一步的方式进行穿讯同步的

1933
01:06:00,000 --> 01:06:03,000
这个是我觉得非常好的一件事情

1934
01:06:03,000 --> 01:06:05,000
但是这就牵涉到另外一个问题

1935
01:06:05,000 --> 01:06:12,000
它这样的话对后台的执行 Jowarship 简析器的进程性能会有要求吗

1936
01:06:12,000 --> 01:06:16,000
比如说据我所知在 IOS 上面

1937
01:06:16,000 --> 01:06:19,000
你单独自己跑一个 Jowarship 的解析器的话

1938
01:06:19,000 --> 01:06:23,000
是没有他们那个叫什么来的 JIT 的优惑

1939
01:06:26,000 --> 01:06:29,000
这一点上我并不是特别清楚上的主教时间方式

1940
01:06:29,000 --> 01:06:31,000
但是有一点很重要的是

1941
01:06:32,000 --> 01:06:39,000
你刚说的那些问题只有在你直接使用 WebView 的情况下才会出现

1942
01:06:40,000 --> 01:06:41,000
为什么

1943
01:06:41,000 --> 01:06:43,000
因为那个英警是在 WebView 里头

1944
01:06:44,000 --> 01:06:47,000
但是他们的那个 Rack 时间方式并不代表

1945
01:06:47,000 --> 01:06:50,000
说他一定要用那个 Jowarship 的英警

1946
01:06:50,000 --> 01:06:54,000
他可以自己包装一个其他的 JS 英警在里头

1947
01:06:54,000 --> 01:06:59,000
就是他可以说我不用苹果那个 IOS 自带的那个 Jowarship 的英警

1948
01:07:00,000 --> 01:07:05,000
然后我自己包一个代 JIT 的 Jowarship 的解析器去这样执行吗

1949
01:07:05,000 --> 01:07:06,000
没错

1950
01:07:06,000 --> 01:07:11,000
这样不会就会装到 Apsoto 选合调例的内谋

1951
01:07:11,000 --> 01:07:13,000
一条说不能自带解析器吗

1952
01:07:13,000 --> 01:07:14,000
真的吗

1953
01:07:14,000 --> 01:07:16,000
有这么一条的曾经

1954
01:07:16,000 --> 01:07:18,000
我记得后来就

1955
01:07:18,000 --> 01:07:21,000
你那条苹果条例我记得我还写过 Blog

1956
01:07:21,000 --> 01:07:24,000
就说他只能用规定的警方原来写

1957
01:07:24,000 --> 01:07:27,000
但好像没有说不能自带去你机吧

1958
01:07:27,000 --> 01:07:31,000
不然那些什么在落啊的东西是怎么被上通过的

1959
01:07:31,000 --> 01:07:33,000
对这就是一个挺模糊的一点

1960
01:07:33,000 --> 01:07:36,000
就是后来因为很多有些他需要用那个 Rack 的解析器

1961
01:07:36,000 --> 01:07:38,000
做了一些辅助的事情吗

1962
01:07:38,000 --> 01:07:40,000
所以他就后来又通过

1963
01:07:40,000 --> 01:07:45,000
现在我要不太清楚苹果在对这件事情的立场是什么

1964
01:07:45,000 --> 01:07:48,000
但是这个怎么自然在意了

1965
01:07:48,000 --> 01:07:49,000
我可以发出 check 一下

1966
01:07:49,000 --> 01:07:51,000
因为我有那个

1967
01:07:51,000 --> 01:07:55,000
他们把那个 Native 就是他的那个演示带马

1968
01:07:55,000 --> 01:07:58,000
给所有的语会者都分享了一份

1969
01:07:58,000 --> 01:08:01,000
所以我是可以发 check 去看他们那边有什么应劲的

1970
01:08:02,000 --> 01:08:03,000
OK

1971
01:08:03,000 --> 01:08:05,000
你可以看一下他用的是苹果原生的

1972
01:08:05,000 --> 01:08:07,000
就是那个叫什么 Jazzle Court

1973
01:08:07,000 --> 01:08:08,000
对

1974
01:08:08,000 --> 01:08:09,000
Jazzle Court

1975
01:08:09,000 --> 01:08:10,000
我理解应该是吧

1976
01:08:10,000 --> 01:08:13,000
今天这个是个成本比较低的方案嘛

1977
01:08:13,000 --> 01:08:15,000
你不用自己做任何事情

1978
01:08:15,000 --> 01:08:19,000
而且如果每个应用都要自己带一个 Jazzle Court 解析器的话

1979
01:08:19,000 --> 01:08:22,000
那个应用的尺寸也比较大

1980
01:08:22,000 --> 01:08:24,000
就是一个问题了解的

1981
01:08:24,000 --> 01:08:25,000
好

1982
01:08:25,000 --> 01:08:29,000
就是其实现在用那个 Retafely 其实有

1983
01:08:29,000 --> 01:08:31,000
以及有一个 App 的点饭

1984
01:08:31,000 --> 01:08:33,000
就是在 LS

1985
01:08:33,000 --> 01:08:34,000
这个 App Store 里面

1986
01:08:34,000 --> 01:08:37,000
Facebook 叫做新的应用就是 Grups

1987
01:08:37,000 --> 01:08:40,000
就是 Facebook 群组的这个单独的一个应用

1988
01:08:40,000 --> 01:08:43,000
它其实是在很大程度上用的这个 Retafely 寫的

1989
01:08:43,000 --> 01:08:45,000
然后我之前

1990
01:08:45,000 --> 01:08:48,000
我再知道它是用 Retafely 之前

1991
01:08:48,000 --> 01:08:49,000
我就已经下了载了

1992
01:08:49,000 --> 01:08:50,000
用过它

1993
01:08:50,000 --> 01:08:51,000
当时我完全没有感觉到

1994
01:08:51,000 --> 01:08:53,000
它不是一个 Native 的软件

1995
01:08:53,000 --> 01:08:56,000
就是非常整个体验是非常好的

1996
01:08:56,000 --> 01:08:58,000
问题是我们并不是很清楚

1997
01:08:58,000 --> 01:09:02,000
说它到底哪一部分是 Ui 的那个人

1998
01:09:02,000 --> 01:09:04,000
就会有比例是用的那个人的问题

1999
01:09:04,000 --> 01:09:05,000
对过程

2000
01:09:05,000 --> 01:09:06,000
这就是这个好处所在

2001
01:09:06,000 --> 01:09:10,000
你知道用户如果说它都很差了哪部分

2002
01:09:10,000 --> 01:09:11,000
它都感受不出来

2003
01:09:11,000 --> 01:09:13,000
那就证明这个东西说不定就成功了

2004
01:09:13,000 --> 01:09:14,000
对

2005
01:09:14,000 --> 01:09:15,000
对

2006
01:09:15,000 --> 01:09:16,000
对

2007
01:09:16,000 --> 01:09:19,000
我们所拿就是语会者所拿到的这个版本

2008
01:09:19,000 --> 01:09:22,000
跟 Facebook 它所用的版本

2009
01:09:22,000 --> 01:09:24,000
实际上是不同步的

2010
01:09:24,000 --> 01:09:26,000
Facebook 它还在做很多的工作

2011
01:09:26,000 --> 01:09:29,000
来把这个东西给完善

2012
01:09:29,000 --> 01:09:32,000
然后才会正式向大众发布

2013
01:09:32,000 --> 01:09:35,000
目前来说的话我们所看到的版本

2014
01:09:35,000 --> 01:09:36,000
都是一个

2015
01:09:36,000 --> 01:09:37,000
就是一个

2016
01:09:37,000 --> 01:09:40,000
TechProview 看的

2017
01:09:42,000 --> 01:09:43,000
对啊

2018
01:09:43,000 --> 01:09:44,000
明白

2019
01:09:44,000 --> 01:09:46,000
对就是说

2020
01:09:46,000 --> 01:09:47,000
Retafely 寫的为了你也提到

2021
01:09:47,000 --> 01:09:49,000
他们的口号是叫做 Lurewans

2022
01:09:49,000 --> 01:09:50,000
Right Everywhere 嘛

2023
01:09:50,000 --> 01:09:52,000
然后我其实我也在想

2024
01:09:52,000 --> 01:09:55,000
如果你按这种方式去够见你的 APP

2025
01:09:55,000 --> 01:09:57,000
其实还是可以有满多部件

2026
01:09:57,000 --> 01:09:59,000
是可以在各平台间重用的

2027
01:09:59,000 --> 01:10:01,000
比如说之前

2028
01:10:01,000 --> 01:10:03,000
我说是在前期还是上前期的时候

2029
01:10:03,000 --> 01:10:05,000
我们在讨论过

2030
01:10:05,000 --> 01:10:07,000
那个 Google 不是做的那个叫

2031
01:10:07,000 --> 01:10:08,000
Inbox 那个 APP 嘛

2032
01:10:08,000 --> 01:10:09,000
对

2033
01:10:09,000 --> 01:10:10,000
它是有安卓版

2034
01:10:10,000 --> 01:10:11,000
有 S 版

2035
01:10:11,000 --> 01:10:12,000
然后还有一个这个

2036
01:10:12,000 --> 01:10:13,000
Cromwell

2037
01:10:13,000 --> 01:10:15,000
只有 Cromwell 那些可以用的 Wap 版嘛

2038
01:10:15,000 --> 01:10:17,000
然后他们后来发了一篇博文章

2039
01:10:17,000 --> 01:10:19,000
去讲他们怎么去做这么一件事

2040
01:10:19,000 --> 01:10:20,000
就是他们把这个

2041
01:10:20,000 --> 01:10:22,000
假如说你把这个整个应用分成两部分

2042
01:10:22,000 --> 01:10:23,000
一对是前端

2043
01:10:23,000 --> 01:10:24,000
就跟那个

2044
01:10:24,000 --> 01:10:25,000
用户交互的那部分

2045
01:10:25,000 --> 01:10:27,000
那么这部分就是说在

2046
01:10:27,000 --> 01:10:29,000
IOS 上面就是 obghead C 寫的

2047
01:10:29,000 --> 01:10:31,000
然后在安卓上就是用那个

2048
01:10:31,000 --> 01:10:32,000
Java 寫的

2049
01:10:32,000 --> 01:10:33,000
然后在这个

2050
01:10:33,000 --> 01:10:36,000
那外部上就是 JavaScript 寫的

2051
01:10:36,000 --> 01:10:38,000
但是他们其实都是用 Java 寫的

2052
01:10:38,000 --> 01:10:40,000
然后通过 GWT 转换成 JavaScript

2053
01:10:40,000 --> 01:10:43,000
然后通过一个叫做 J 2 obghead C 的一个工具

2054
01:10:43,000 --> 01:10:45,000
转换成 obghead C 的代码来做

2055
01:10:46,000 --> 01:10:48,000
做那个邏续的那一部分

2056
01:10:48,000 --> 01:10:51,000
就是跟原生界面无关

2057
01:10:51,000 --> 01:10:53,000
但是是跟这个后台的事务邏续

2058
01:10:53,000 --> 01:10:54,000
相关的就是同一套语言

2059
01:10:54,000 --> 01:10:56,000
然后再转化成不同的

2060
01:10:56,000 --> 01:10:58,000
同样用 Java 寫

2061
01:10:58,000 --> 01:10:59,000
然后通过这两种工具

2062
01:10:59,000 --> 01:11:01,000
转化成对应的 JavaScript 到这种 obghead C

2063
01:11:01,000 --> 01:11:03,000
但是如果我们用这个

2064
01:11:03,000 --> 01:11:04,000
Ranity 为了寫的话

2065
01:11:04,000 --> 01:11:06,000
其实就这一步都可以省去了

2066
01:11:06,000 --> 01:11:10,000
我直接把所有的事务和邏续都寫成

2067
01:11:10,000 --> 01:11:11,000
JavaScript 就好了

2068
01:11:11,000 --> 01:11:13,000
对其实这样我想起

2069
01:11:13,000 --> 01:11:18,000
那个 Apps 的 Rater 出的 Tetanium

2070
01:11:18,000 --> 01:11:21,000
它也是用 JavaScript 来寫

2071
01:11:21,000 --> 01:11:22,000
所有的事务邏续

2072
01:11:22,000 --> 01:11:25,000
但是其实用的那一割

2073
01:11:25,000 --> 01:11:28,000
EYVGIT 全都是原生的

2074
01:11:28,000 --> 01:11:30,000
它那个体验怎么样呢

2075
01:11:30,000 --> 01:11:32,000
不是特别好

2076
01:11:32,000 --> 01:11:38,000
就是因为前公司在做 Mobile App 的时候

2077
01:11:38,000 --> 01:11:40,000
考虑过用 Tetanium

2078
01:11:40,000 --> 01:11:43,000
可能当时最大的一个问题

2079
01:11:43,000 --> 01:11:45,000
首先那个时候正好是

2080
01:11:45,000 --> 01:11:48,000
IOS 6 生到 7 的过程中

2081
01:11:48,000 --> 01:11:50,000
然后他们大概是比

2082
01:11:50,000 --> 01:11:54,000
7 月落后了可能 3 到 5 月的时间

2083
01:11:54,000 --> 01:11:55,000
就是我觉得这个是不客人

2084
01:11:55,000 --> 01:11:58,000
上来就新的 IOS 版本已经在那边了

2085
01:11:58,000 --> 01:11:59,000
如果你用 Tetanium 的话

2086
01:11:59,000 --> 01:12:01,000
你用不到新的一些 WGIT

2087
01:12:01,000 --> 01:12:02,000
对

2088
01:12:02,000 --> 01:12:06,000
然后他们的那一套东西

2089
01:12:06,000 --> 01:12:10,000
据说其实是非常优秀的

2090
01:12:10,000 --> 01:12:12,000
但是没有什么文档

2091
01:12:12,000 --> 01:12:15,000
主要是

2092
01:12:15,000 --> 01:12:18,000
这可能是用任何第三方平台

2093
01:12:18,000 --> 01:12:20,000
或者这个框架都会遇到的问题吧

2094
01:12:20,000 --> 01:12:21,000
对

2095
01:12:21,000 --> 01:12:23,000
据说 Apps 的 Rater 还在搞

2096
01:12:23,000 --> 01:12:25,000
现在还在搞一些新的什么东西

2097
01:12:25,000 --> 01:12:27,000
但我一直有想不想很名字了

2098
01:12:27,000 --> 01:12:31,000
其大概的走向

2099
01:12:31,000 --> 01:12:34,000
可能和 react 有点一直同工的地方

2100
01:12:35,000 --> 01:12:36,000
我好看是

2101
01:12:38,000 --> 01:12:40,000
那说回这个 RATNATER 的这种方式

2102
01:12:40,000 --> 01:12:42,000
其实我还不是特别在乎他们说

2103
01:12:42,000 --> 01:12:44,000
完全不在乎 RAT 1 S

2104
01:12:44,000 --> 01:12:45,000
RON ENDING 我还这么一个口号

2105
01:12:45,000 --> 01:12:47,000
就说起码你假设

2106
01:12:47,000 --> 01:12:49,000
你看到像这些后台的逻辑

2107
01:12:49,000 --> 01:12:51,000
还有这些数据

2108
01:12:51,000 --> 01:12:53,000
就是模型都可以用加了十个钩箭

2109
01:12:53,000 --> 01:12:55,000
这一块是完全可以在各平台间重弩

2110
01:12:55,000 --> 01:12:58,000
而且我可以遇见到

2111
01:12:58,000 --> 01:13:00,000
很定会有人做一个中间层

2112
01:13:00,000 --> 01:13:02,000
然后说用这些主建的话

2113
01:13:02,000 --> 01:13:05,000
这些主建可以就变成那个

2114
01:13:05,000 --> 01:13:06,000
Inviralment or Sensitivity

2115
01:13:06,000 --> 01:13:09,000
然后他们会根据 Inviralment

2116
01:13:09,000 --> 01:13:10,000
对

2117
01:13:10,000 --> 01:13:12,000
对 感觉甚至说这个 TapView

2118
01:13:12,000 --> 01:13:14,000
你可以用这个主建的 TapView

2119
01:13:14,000 --> 01:13:18,000
然后这个 TapView 背后的时间会根据

2120
01:13:18,000 --> 01:13:19,000
Togger or Android

2121
01:13:19,000 --> 01:13:22,000
或 Togger or iOS 来自动选择

2122
01:13:22,000 --> 01:13:24,000
相应平台的 TapView

2123
01:13:24,000 --> 01:13:28,000
这并不是 RATNATER 自己本身的一个设计理谅

2124
01:13:28,000 --> 01:13:31,000
RATNATER 非常鼓励你去

2125
01:13:31,000 --> 01:13:35,000
根据各种平台本身的特性

2126
01:13:35,000 --> 01:13:38,000
来设计不一样的 UI

2127
01:13:38,000 --> 01:13:40,000
来用不一样的方式

2128
01:13:40,000 --> 01:13:44,000
而不是这样的简单的替换的模积

2129
01:13:44,000 --> 01:13:46,000
但是我想我们肯定会看到

2130
01:13:46,000 --> 01:13:49,000
第三方的一些 Soft Motion 出来的

2131
01:13:51,000 --> 01:13:53,000
我觉得这个就是很多像这样的什么

2132
01:13:53,000 --> 01:13:55,000
什么企业势让你这样可能会采取这种方式

2133
01:13:55,000 --> 01:13:57,000
因为它没有那么多的资源

2134
01:13:57,000 --> 01:14:00,000
或者是人手去优化每一个平台的细节的体验

2135
01:14:00,000 --> 01:14:03,000
那么更加节省成本的

2136
01:14:03,000 --> 01:14:05,000
节省开发时间的一个方式

2137
01:14:05,000 --> 01:14:08,000
就是通过这种中间层去转换一下

2138
01:14:08,000 --> 01:14:09,000
我觉得

2139
01:14:09,000 --> 01:14:10,000
虽然体验不是太好

2140
01:14:10,000 --> 01:14:12,000
但是起码成本下去了

2141
01:14:12,000 --> 01:14:14,000
我觉得这个对很多企业远间讲

2142
01:14:14,000 --> 01:14:16,000
就是这样的一个诉求

2143
01:14:16,000 --> 01:14:17,000
对

2144
01:14:17,000 --> 01:14:22,000
我们现在等于说如果 NATER

2145
01:14:22,000 --> 01:14:25,000
RATNATER 这一套

2146
01:14:25,000 --> 01:14:27,000
能够吸引到一部分人

2147
01:14:27,000 --> 01:14:30,000
去把它朝起来的话

2148
01:14:30,000 --> 01:14:32,000
可以说企业集

2149
01:14:32,000 --> 01:14:35,000
跨平台应用开发又多了一个新的选择

2150
01:14:35,000 --> 01:14:37,000
再抽到

2151
01:14:37,000 --> 01:14:39,000
加版变成加版 script

2152
01:14:39,000 --> 01:14:42,000
我有跟我们的 Developer 说讨论这个问题

2153
01:14:42,000 --> 01:14:45,000
它并不单是在 solution 上

2154
01:14:45,000 --> 01:14:49,000
这个 text 数人上有改变你的组织价格

2155
01:14:49,000 --> 01:14:51,000
关键是说

2156
01:14:51,000 --> 01:14:53,000
如果你想这个

2157
01:14:53,000 --> 01:14:54,000
如果你真的时间

2158
01:14:54,000 --> 01:14:57,000
讨论了一段时间

2159
01:14:57,000 --> 01:14:59,000
那是因为

2160
01:14:59,000 --> 01:15:01,000
WebDeveloper 跟

2161
01:15:01,000 --> 01:15:03,000
模糊的 Developer 之前的界限

2162
01:15:03,000 --> 01:15:05,000
就变得更模糊了

2163
01:15:05,000 --> 01:15:06,000
我觉得对于

2164
01:15:06,000 --> 01:15:07,000
可能是要二合一

2165
01:15:07,000 --> 01:15:11,000
对于这个企业资源的一个运用

2166
01:15:11,000 --> 01:15:13,000
其实是一个非常有意思的事情

2167
01:15:13,000 --> 01:15:15,000
所以我们的想说

2168
01:15:15,000 --> 01:15:18,000
如果现在 WebApp 的 Keyshank

2169
01:15:18,000 --> 01:15:20,000
不需要太多维护的话

2170
01:15:20,000 --> 01:15:22,000
那这个时程就可以去写

2171
01:15:22,000 --> 01:15:24,000
是写 rsapp 对不对

2172
01:15:24,000 --> 01:15:25,000
所以这一点上对于企业来说

2173
01:15:25,000 --> 01:15:27,000
可能是一个非常重要的事情

2174
01:15:27,000 --> 01:15:31,000
所以我也有跟我们的 WebDeveloper 开玩笑

2175
01:15:31,000 --> 01:15:35,000
说那你现在得赶紧去学 HMLCSS

2176
01:15:35,000 --> 01:15:38,000
对赶紧去开始学

2177
01:15:41,000 --> 01:15:42,000
模糊

2178
01:15:42,000 --> 01:15:44,000
它现在的 writing 体育这个

2179
01:15:44,000 --> 01:15:46,000
是还是在什么 R 法阶段

2180
01:15:46,000 --> 01:15:47,000
可能是 preR 法阶段

2181
01:15:47,000 --> 01:15:49,000
他们现在是说有一个私有的

2182
01:15:49,000 --> 01:15:50,000
Github 的 reposturing

2183
01:15:50,000 --> 01:15:51,000
你们可以访我

2184
01:15:51,000 --> 01:15:53,000
就参与会者可以访我吗

2185
01:15:53,000 --> 01:15:55,000
外界公开

2186
01:15:55,000 --> 01:15:56,000
我不知道你看了多少

2187
01:15:56,000 --> 01:15:58,000
但是我的就比较好

2188
01:15:58,000 --> 01:16:00,000
其他怎么去实现它这个

2189
01:16:00,000 --> 01:16:03,000
就是 JavaSkirm 内部分的业务代码

2190
01:16:03,000 --> 01:16:05,000
业务逻辑怎么去和原生的

2191
01:16:05,000 --> 01:16:07,000
那些进行交互那一块

2192
01:16:07,000 --> 01:16:10,000
我没有还没有来得及对这个代码

2193
01:16:10,000 --> 01:16:12,000
本身做很多的研究

2194
01:16:12,000 --> 01:16:15,000
但是对 Developer 来说的话

2195
01:16:15,000 --> 01:16:18,000
你所做的时程真的跟以前写

2196
01:16:18,000 --> 01:16:20,000
Wabab 的点点没有太大的区别

2197
01:16:20,000 --> 01:16:21,000
我可以把流程说一下

2198
01:16:21,000 --> 01:16:24,000
就是说从纯粹的开发者的

2199
01:16:24,000 --> 01:16:26,000
这个角度来说的话

2200
01:16:26,000 --> 01:16:29,000
你 clown 这个 reposturing

2201
01:16:29,000 --> 01:16:32,000
然后你做 NPMingStore

2202
01:16:32,000 --> 01:16:35,000
就是传统的 JavaSkirm

2203
01:16:35,000 --> 01:16:37,000
就大家都对于让你写

2204
01:16:37,000 --> 01:16:38,000
说 NPMStart

2205
01:16:38,000 --> 01:16:39,000
OK

2206
01:16:39,000 --> 01:16:42,000
NPMStart 的原因是

2207
01:16:42,000 --> 01:16:45,000
现在是在一个 Developing Environmental 裡头

2208
01:16:45,000 --> 01:16:47,000
就是 JavaSkirm 的文件

2209
01:16:47,000 --> 01:16:51,000
需要 server 到 simulator 里头去对不对

2210
01:16:51,000 --> 01:16:53,000
IceSimulator 里头去

2211
01:16:53,000 --> 01:16:56,000
所以 NPMStart 就会

2212
01:16:56,000 --> 01:16:59,000
啟动一个这样的 server

2213
01:16:59,000 --> 01:17:02,000
然后握尘的那些文件

2214
01:17:02,000 --> 01:17:05,000
然后你如果去看那些文件的话

2215
01:17:05,000 --> 01:17:08,000
其实上跟你写 React 的

2216
01:17:08,000 --> 01:17:11,000
Wabab 的 application

2217
01:17:11,000 --> 01:17:13,000
并没有太大的区别

2218
01:17:13,000 --> 01:17:16,000
如果真的要说最大的区别可能

2219
01:17:16,000 --> 01:17:19,000
就是说你没有 CSSFile 了

2220
01:17:19,000 --> 01:17:20,000
所有的 File 都是 Inline

2221
01:17:20,000 --> 01:17:21,000
所有的 Stile 都是 Inline

2222
01:17:21,000 --> 01:17:22,000
就是最大的区别了

2223
01:17:22,000 --> 01:17:24,000
其他的东西都看起来

2224
01:17:24,000 --> 01:17:25,000
非常的相似

2225
01:17:25,000 --> 01:17:27,000
然后你写的是真的是困

2226
01:17:27,000 --> 01:17:29,000
就是 Communities 那种主建

2227
01:17:29,000 --> 01:17:32,000
所以神奇的地方在

2228
01:17:32,000 --> 01:17:34,000
如果你看到那个 Bid 的話

2229
01:17:34,000 --> 01:17:35,000
有这一点

2230
01:17:35,000 --> 01:17:36,000
就把这个

2231
01:17:36,000 --> 01:17:40,000
不然说如果你改变一下 CSS

2232
01:17:40,000 --> 01:17:43,000
IceSimulator 是直接可以得到这个结果的

2233
01:17:43,000 --> 01:17:45,000
你是不需要去 ReactPile 的

2234
01:17:45,000 --> 01:17:47,000
就连非常的神奇

2235
01:17:47,000 --> 01:17:48,000
对对对

2236
01:17:48,000 --> 01:17:49,000
对

2237
01:17:49,000 --> 01:17:51,000
他们有一个说法

2238
01:17:51,000 --> 01:17:53,000
要实现你在这边

2239
01:17:53,000 --> 01:17:55,000
就边境境里面改变行代码

2240
01:17:55,000 --> 01:17:57,000
然后在 Ice 那个模拟庆里面

2241
01:17:57,000 --> 01:18:00,000
出现改动只需要不到意买

2242
01:18:00,000 --> 01:18:01,000
对这个

2243
01:18:01,000 --> 01:18:03,000
这个我觉得对开发效率

2244
01:18:03,000 --> 01:18:05,000
非常大的提升

2245
01:18:05,000 --> 01:18:08,000
Live Reload 的时间级别

2246
01:18:08,000 --> 01:18:09,000
对对对

2247
01:18:09,000 --> 01:18:10,000
JavaLace

2248
01:18:10,000 --> 01:18:12,000
Java 世界里面有我叫做 J-Rebo

2249
01:18:12,000 --> 01:18:14,000
也做类似的事情

2250
01:18:14,000 --> 01:18:17,000
这个我觉得看 that demo

2251
01:18:17,000 --> 01:18:19,000
这人是挺酷炫的

2252
01:18:19,000 --> 01:18:21,000
不过你们觉得这样的话

2253
01:18:21,000 --> 01:18:23,000
那不变成

2254
01:18:23,000 --> 01:18:25,000
JavaScript 变成一个什么同样的

2255
01:18:25,000 --> 01:18:27,000
这已经是现实了

2256
01:18:27,000 --> 01:18:28,000
对

2257
01:18:28,000 --> 01:18:30,000
这个刘兰器

2258
01:18:30,000 --> 01:18:31,000
你们今天是好演吗

2259
01:18:31,000 --> 01:18:35,000
是这个电脑上面的另一层电脑

2260
01:18:35,000 --> 01:18:36,000
对对对对对对

2261
01:18:36,000 --> 01:18:37,000
这个刘兰器那边我们的毫无疑问

2262
01:18:37,000 --> 01:18:39,000
JavaScript 已经是一个

2263
01:18:39,000 --> 01:18:40,000
如果他不是通过演员

2264
01:18:40,000 --> 01:18:41,000
他至少是一个构建的

2265
01:18:41,000 --> 01:18:42,000
即使因为很多语言可以

2266
01:18:42,000 --> 01:18:44,000
所以 conpo out to JavaScript 吗

2267
01:18:44,000 --> 01:18:45,000
对我觉得 JavaScript 其实就是

2268
01:18:45,000 --> 01:18:46,000
现在的私音嘛

2269
01:18:46,000 --> 01:18:47,000
就是现在的

2270
01:18:47,000 --> 01:18:49,000
不会变成

2271
01:18:49,000 --> 01:18:51,000
现在刘兰器就是当初的

2272
01:18:51,000 --> 01:18:52,000
PDP 11 之类的

2273
01:18:52,000 --> 01:18:53,000
然后其实

2274
01:18:53,000 --> 01:18:55,000
C 語言本来是多

2275
01:18:55,000 --> 01:18:57,000
那个多

2276
01:18:57,000 --> 01:18:59,000
设计的多么粗糙的一个语言

2277
01:18:59,000 --> 01:19:01,000
但就是因为实事造英雄

2278
01:19:01,000 --> 01:19:03,000
我们把它推的

2279
01:19:03,000 --> 01:19:04,000
推到了现在的帮助地位

2280
01:19:04,000 --> 01:19:06,000
我觉得 JavaScript 的基本就是另外一个私音嘛

2281
01:19:06,000 --> 01:19:07,000
对啊

2282
01:19:07,000 --> 01:19:09,000
但是现在刘兰的那一体不太要做的事情

2283
01:19:09,000 --> 01:19:11,000
就是说把这件事情在往这个

2284
01:19:11,000 --> 01:19:13,000
就模糊就一动端在推吗

2285
01:19:13,000 --> 01:19:15,000
因为之前一动端大家还是在

2286
01:19:15,000 --> 01:19:17,000
就至少我们是鼓励

2287
01:19:17,000 --> 01:19:18,000
或者消费者也愿意使用

2288
01:19:18,000 --> 01:19:20,000
所谓的原生的音乐

2289
01:19:20,000 --> 01:19:21,000
那原生打影

2290
01:19:21,000 --> 01:19:22,000
好就可能说

2291
01:19:22,000 --> 01:19:23,000
说你要用这个

2292
01:19:23,000 --> 01:19:24,000
平台自己的那种工具

2293
01:19:24,000 --> 01:19:25,000
要自己的原来写

2294
01:19:25,000 --> 01:19:26,000
他现在在看

2295
01:19:26,000 --> 01:19:29,000
Ranetti 不太能够把整个效果

2296
01:19:29,000 --> 01:19:30,000
做的这么跟原生

2297
01:19:30,000 --> 01:19:32,000
就是说一甲乱针吧至少是

2298
01:19:32,000 --> 01:19:34,000
那就完全没有必要

2299
01:19:34,000 --> 01:19:36,000
再用平台原生的语言来写了

2300
01:19:36,000 --> 01:19:37,000
就好像说

2301
01:19:37,000 --> 01:19:39,000
我是现在是一个 Web developer

2302
01:19:39,000 --> 01:19:41,000
那我也可以做 LS 音乐

2303
01:19:41,000 --> 01:19:43,000
不需要学这么 obbc 或者 Swift

2304
01:19:43,000 --> 01:19:44,000
对啊

2305
01:19:44,000 --> 01:19:46,000
这就好像把 C-E 元

2306
01:19:46,000 --> 01:19:49,000
一直到不同的架构的兔子系上了

2307
01:19:51,000 --> 01:19:53,000
我觉得吴涛刚说的很好

2308
01:19:53,000 --> 01:19:54,000
就是

2309
01:19:54,000 --> 01:19:56,000
这怎么说就是

2310
01:19:56,000 --> 01:19:57,000
就是既定事实

2311
01:19:57,000 --> 01:20:00,000
Jaws School 的音乐就是既定事实

2312
01:20:00,000 --> 01:20:02,000
所以我很期待 EAS 6、EAS 7

2313
01:20:02,000 --> 01:20:05,000
因为这个语言本身还是有

2314
01:20:05,000 --> 01:20:06,000
非常非常多的问题的

2315
01:20:06,000 --> 01:20:08,000
特别是他的 Prototype

2316
01:20:08,000 --> 01:20:10,000
这样一个架构

2317
01:20:10,000 --> 01:20:12,000
不是 class-based

2318
01:20:12,000 --> 01:20:13,000
EAS 6、EAS 7

2319
01:20:13,000 --> 01:20:15,000
我很期待他们把这些问题解决好

2320
01:20:15,000 --> 01:20:18,000
这样的话对于我们这些语言的使用者来说

2321
01:20:18,000 --> 01:20:20,000
是一个非常好的事情

2322
01:20:20,000 --> 01:20:21,000
因为

2323
01:20:22,000 --> 01:20:24,000
作为一个 Web dev 你竟然不喜欢 BotType

2324
01:20:24,000 --> 01:20:25,000
BotType 是不喜欢的

2325
01:20:25,000 --> 01:20:27,000
而是说

2326
01:20:27,000 --> 01:20:29,000
在真正的应用上面

2327
01:20:29,000 --> 01:20:30,000
我们很多时候

2328
01:20:30,000 --> 01:20:32,000
都是在

2329
01:20:32,000 --> 01:20:34,000
用 Pro 的 Type 去 Cinular 的 class

2330
01:20:34,000 --> 01:20:36,000
因为没有 Native class

2331
01:20:36,000 --> 01:20:38,000
这是我所不喜欢的一点

2332
01:20:38,000 --> 01:20:40,000
不是说 ProType 本身

2333
01:20:40,000 --> 01:20:42,000
在 EAS 6 中加入真正的 class

2334
01:20:42,000 --> 01:20:44,000
或者这次我所期待的

2335
01:20:44,000 --> 01:20:47,000
ProType 到应 ProType 好出口应用

2336
01:20:47,000 --> 01:20:48,000
但是实际的应用中

2337
01:20:48,000 --> 01:20:50,000
如果我们要用 class 的话

2338
01:20:50,000 --> 01:20:52,000
那我还希望能有真正的 class

2339
01:20:54,000 --> 01:20:55,000
对

2340
01:20:55,000 --> 01:20:57,000
我觉得 class 出现其实是比较

2341
01:20:57,000 --> 01:20:59,000
如果有比较合理的 class

2342
01:20:59,000 --> 01:21:00,000
支持的话

2343
01:21:00,000 --> 01:21:02,000
对于构建大型程序

2344
01:21:02,000 --> 01:21:03,000
实际上是

2345
01:21:03,000 --> 01:21:05,000
更加有力的

2346
01:21:05,000 --> 01:21:07,000
因为 ProType best

2347
01:21:07,000 --> 01:21:09,000
Object orientation

2348
01:21:09,000 --> 01:21:10,000
它的优点

2349
01:21:10,000 --> 01:21:11,000
我觉得就在于你

2350
01:21:11,000 --> 01:21:13,000
做原型看法非常地快

2351
01:21:13,000 --> 01:21:15,000
你不需要去考虑

2352
01:21:15,000 --> 01:21:16,000
那个

2353
01:21:16,000 --> 01:21:17,000
模板和

2354
01:21:17,000 --> 01:21:18,000
实际的

2355
01:21:18,000 --> 01:21:22,000
Instance 之间的抽象的问题

2356
01:21:22,000 --> 01:21:24,000
但当你要做大型的东西的时候

2357
01:21:24,000 --> 01:21:27,000
这个抽象其实还是相当比较

2358
01:21:27,000 --> 01:21:28,000
对

2359
01:21:28,000 --> 01:21:29,000
我不知道

2360
01:21:29,000 --> 01:21:30,000
因为我对这种

2361
01:21:30,000 --> 01:21:32,000
所谓传统的经典的

2362
01:21:32,000 --> 01:21:34,000
GV class 的这种

2363
01:21:34,000 --> 01:21:35,000
我都好

2364
01:21:35,000 --> 01:21:38,000
其实并没有太特别的偏好

2365
01:21:38,000 --> 01:21:40,000
所以我觉得两种都还好

2366
01:21:40,000 --> 01:21:42,000
没有那么

2367
01:21:42,000 --> 01:21:44,000
就是 class base

2368
01:21:44,000 --> 01:21:45,000
没有那么好

2369
01:21:45,000 --> 01:21:46,000
就 ProType base 没有那么差

2370
01:21:46,000 --> 01:21:47,000
我觉得是这样

2371
01:21:47,000 --> 01:21:49,000
Go 也是没有 class 对吧

2372
01:21:49,000 --> 01:21:50,000
Go 根本就没有

2373
01:21:50,000 --> 01:21:51,000
连 ProType 都没有

2374
01:21:51,000 --> 01:21:53,000
它是 GV interface 的

2375
01:21:53,000 --> 01:21:54,000
完全更不一样

2376
01:21:54,000 --> 01:21:55,000
我觉得其实用直击用起来

2377
01:21:55,000 --> 01:21:57,000
我觉得它那种是更灵活的

2378
01:21:57,000 --> 01:21:58,000
所以我觉得你其实就是一个

2379
01:21:58,000 --> 01:22:01,000
你比较不喜欢这个

2380
01:22:01,000 --> 01:22:02,000
经典的 class

2381
01:22:02,000 --> 01:22:03,000
对对对

2382
01:22:03,000 --> 01:22:05,000
加了

2383
01:22:05,000 --> 01:22:06,000
看太多

2384
01:22:06,000 --> 01:22:07,000
我觉得你可以去看一看

2385
01:22:07,000 --> 01:22:09,000
I-O 就是一有这个源

2386
01:22:09,000 --> 01:22:10,000
我不知道怎么念的

2387
01:22:10,000 --> 01:22:13,000
它其实也是 ProType base

2388
01:22:13,000 --> 01:22:16,000
这个说的其实还蛮奇怪的

2389
01:22:16,000 --> 01:22:18,000
OpJS 算是一个经典的

2390
01:22:18,000 --> 01:22:19,000
GV class 的

2391
01:22:19,000 --> 01:22:21,000
机程 OE 源也不算

2392
01:22:21,000 --> 01:22:23,000
它是类似于

2393
01:22:23,000 --> 01:22:24,000
Smotalk 那种方式

2394
01:22:24,000 --> 01:22:27,000
它是在 C 上面加了一层 Smotalk

2395
01:22:27,000 --> 01:22:29,000
用一个

2396
01:22:29,000 --> 01:22:31,000
它用一个最近看到的句话

2397
01:22:31,000 --> 01:22:34,000
说 OpJS 就是过去 25 年

2398
01:22:34,000 --> 01:22:36,000
机程机源发展史的

2399
01:22:36,000 --> 01:22:38,000
你再看里面不同的源特性的时候

2400
01:22:38,000 --> 01:22:39,000
你会

2401
01:22:39,000 --> 01:22:41,000
如果你从一个机程机

2402
01:22:41,000 --> 01:22:43,000
历史学家家里号的角度来看的话

2403
01:22:43,000 --> 01:22:46,000
你会看到这个特征来自于

2404
01:22:46,000 --> 01:22:48,000
那个时代的一个思潮

2405
01:22:48,000 --> 01:22:50,000
考古语言

2406
01:22:50,000 --> 01:22:52,000
所以其实我觉得就很好奇嘛

2407
01:22:52,000 --> 01:22:53,000
就是

2408
01:22:53,000 --> 01:22:55,000
Altima object C 也已经证明了

2409
01:22:55,000 --> 01:22:56,000
就说你没有

2410
01:22:56,000 --> 01:22:58,000
一个大规模的

2411
01:22:58,000 --> 01:22:59,000
就没有

2412
01:22:59,000 --> 01:23:01,000
Class 的支持的

2413
01:23:01,000 --> 01:23:02,000
Oo 的源

2414
01:23:02,000 --> 01:23:04,000
也可以做得很好嘛

2415
01:23:05,000 --> 01:23:06,000
就是

2416
01:23:06,000 --> 01:23:07,000
这不能在这一天

2417
01:23:07,000 --> 01:23:08,000
我觉得

2418
01:23:08,000 --> 01:23:10,000
不能不太能装

2419
01:23:10,000 --> 01:23:11,000
Burin

2420
01:23:11,000 --> 01:23:12,000
Besides of point

2421
01:23:12,000 --> 01:23:14,000
我们可以留在以后

2422
01:23:14,000 --> 01:23:16,000
装能讲这个

2423
01:23:16,000 --> 01:23:17,000
变成原的意思

2424
01:23:17,000 --> 01:23:18,000
我们刚刚说到

2425
01:23:18,000 --> 01:23:19,000
就是

2426
01:23:19,000 --> 01:23:21,000
Javascript 应用这么广泛

2427
01:23:21,000 --> 01:23:23,000
其实像在

2428
01:23:23,000 --> 01:23:24,000
这个 talk 中

2429
01:23:24,000 --> 01:23:25,000
我们有一个

2430
01:23:25,000 --> 01:23:27,000
Nathflix 的

2431
01:23:27,000 --> 01:23:28,000
Speaker

2432
01:23:28,000 --> 01:23:29,000
他有说到

2433
01:23:29,000 --> 01:23:30,000
就是

2434
01:23:30,000 --> 01:23:32,000
我们现在有很多

2435
01:23:32,000 --> 01:23:33,000
电视

2436
01:23:33,000 --> 01:23:34,000
电视上有很多

2437
01:23:34,000 --> 01:23:35,000
可以看

2438
01:23:35,000 --> 01:23:36,000
Nathflix

2439
01:23:36,000 --> 01:23:38,000
然后他们都是用

2440
01:23:38,000 --> 01:23:40,000
Javascript 来写这个东西的

2441
01:23:40,000 --> 01:23:41,000
他们都是

2442
01:23:41,000 --> 01:23:42,000
Shipping

2443
01:23:42,000 --> 01:23:44,000
Webkit

2444
01:23:44,000 --> 01:23:45,000
的

2445
01:23:45,000 --> 01:23:47,000
封装给

2446
01:23:47,000 --> 01:23:48,000
电视场上

2447
01:23:48,000 --> 01:23:49,000
然后就其中有

2448
01:23:49,000 --> 01:23:50,000
他们的 Nathflix 的

2449
01:23:50,000 --> 01:23:51,000
Application

2450
01:23:52,000 --> 01:23:53,000
对

2451
01:23:53,000 --> 01:23:54,000
你知道那个

2452
01:23:54,000 --> 01:23:55,000
Altima 这个方式实现了吗

2453
01:23:55,000 --> 01:23:56,000
Oh

2454
01:23:57,000 --> 01:23:58,000
Nathflix

2455
01:23:58,000 --> 01:23:59,000
The

2456
01:23:59,000 --> 01:24:01,000
Nathflix

2457
01:24:01,000 --> 01:24:02,000
他们实际上

2458
01:24:02,000 --> 01:24:03,000
现在是用

2459
01:24:03,000 --> 01:24:04,000
Rack 来写那个

2460
01:24:04,000 --> 01:24:05,000
TV app

2461
01:24:05,000 --> 01:24:06,000
就好像

2462
01:24:06,000 --> 01:24:07,000
Rack Native

2463
01:24:07,000 --> 01:24:08,000
一样

2464
01:24:08,000 --> 01:24:09,000
他们是 Rack TV

2465
01:24:09,000 --> 01:24:10,000
那个

2466
01:24:10,000 --> 01:24:11,000
那个不是开源的程序

2467
01:24:11,000 --> 01:24:12,000
但是他有

2468
01:24:12,000 --> 01:24:13,000
介绍说

2469
01:24:13,000 --> 01:24:14,000
就是怎么样实现的

2470
01:24:14,000 --> 01:24:15,000
嗯

2471
01:24:15,000 --> 01:24:16,000
之前我

2472
01:24:16,000 --> 01:24:17,000
在玩那个

2473
01:24:17,000 --> 01:24:18,000
你有那个

2474
01:24:18,000 --> 01:24:19,000
就是什么

2475
01:24:19,000 --> 01:24:20,000
Crumcast 那个

2476
01:24:20,000 --> 01:24:21,000
那个小帮子吗

2477
01:24:21,000 --> 01:24:22,000
我在公司有

2478
01:24:22,000 --> 01:24:23,000
但是我没有

2479
01:24:23,000 --> 01:24:24,000
我没有很精神的学校

2480
01:24:24,000 --> 01:24:25,000
我

2481
01:24:25,000 --> 01:24:26,000
自己有一个然后

2482
01:24:26,000 --> 01:24:27,000
我之前玩过一段时间

2483
01:24:27,000 --> 01:24:28,000
就他也是那种方式

2484
01:24:28,000 --> 01:24:29,000
就是他整个就是

2485
01:24:29,000 --> 01:24:30,000
其实就是

2486
01:24:30,000 --> 01:24:31,000
这个榴栏器窗口

2487
01:24:31,000 --> 01:24:32,000
他你可以电视上的

2488
01:24:32,000 --> 01:24:33,000
然后

2489
01:24:33,000 --> 01:24:34,000
你们也可以

2490
01:24:34,000 --> 01:24:35,000
做类似的事情

2491
01:24:35,000 --> 01:24:36,000
就是你可以把这个

2492
01:24:36,000 --> 01:24:37,000
整个 Rack

2493
01:24:37,000 --> 01:24:38,000
组建

2494
01:24:38,000 --> 01:24:39,000
丢过去然后做一些

2495
01:24:39,000 --> 01:24:40,000
很好玩的事

2496
01:24:40,000 --> 01:24:41,000
我差点你觉得

2497
01:24:41,000 --> 01:24:43,000
Crumcast 那个

2498
01:24:43,000 --> 01:24:44,000
小帮子

2499
01:24:44,000 --> 01:24:45,000
他要求

2500
01:24:45,000 --> 01:24:46,000
有外界的

2501
01:24:46,000 --> 01:24:47,000
WiFi

2502
01:24:47,000 --> 01:24:48,000
是吧

2503
01:24:48,000 --> 01:24:49,000
对他只能通过

2504
01:24:49,000 --> 01:24:50,000
WiFi 和外界

2505
01:24:50,000 --> 01:24:51,000
他自己不能提供一个

2506
01:24:51,000 --> 01:24:52,000
一个

2507
01:24:52,000 --> 01:24:53,000
他自己

2508
01:24:53,000 --> 01:24:54,000
他就是一个

2509
01:24:54,000 --> 01:24:55,000
但是你

2510
01:24:55,000 --> 01:24:56,000
把他

2511
01:24:56,000 --> 01:24:57,000
Hack 掉音乐

2512
01:24:57,000 --> 01:24:58,000
可能做一个就点车

2513
01:24:58,000 --> 01:24:59,000
但你为什么

2514
01:24:59,000 --> 01:25:00,000
你会想的

2515
01:25:00,000 --> 01:25:01,000
因为他会是

2516
01:25:01,000 --> 01:25:02,000
我他能够自己

2517
01:25:02,000 --> 01:25:03,000
成为一个 WiFi 接电的话

2518
01:25:03,000 --> 01:25:04,000
我出去

2519
01:25:04,000 --> 01:25:05,000
在酒店里面

2520
01:25:05,000 --> 01:25:07,000
利用酒店的电视

2521
01:25:07,000 --> 01:25:09,000
看

2522
01:25:09,000 --> 01:25:10,000
在 APP 里面

2523
01:25:10,000 --> 01:25:11,000
什么

2524
01:25:11,000 --> 01:25:12,000
预先

2525
01:25:12,000 --> 01:25:13,000
漏的好的

2526
01:25:13,000 --> 01:25:14,000
视频其实

2527
01:25:14,000 --> 01:25:15,000
你想发送过去是吧

2528
01:25:15,000 --> 01:25:16,000
首先

2529
01:25:16,000 --> 01:25:17,000
有两点是有问题的

2530
01:25:17,000 --> 01:25:18,000
第一个

2531
01:25:18,000 --> 01:25:19,000
他不能

2532
01:25:19,000 --> 01:25:20,000
他只能是一个

2533
01:25:20,000 --> 01:25:21,000
WiFi 的

2534
01:25:21,000 --> 01:25:22,000
Client

2535
01:25:22,000 --> 01:25:23,000
他不是一个 AP

2536
01:25:23,000 --> 01:25:24,000
还可以叫应该也行

2537
01:25:24,000 --> 01:25:25,000
但第二个问题就是说

2538
01:25:25,000 --> 01:25:26,000
Clubcast

2539
01:25:26,000 --> 01:25:27,000
跟整个的

2540
01:25:27,000 --> 01:25:28,000
一个

2541
01:25:28,000 --> 01:25:29,000
API

2542
01:25:29,000 --> 01:25:30,000
包括认证机制

2543
01:25:30,000 --> 01:25:32,000
是不允许你

2544
01:25:32,000 --> 01:25:33,000
随意播放你

2545
01:25:33,000 --> 01:25:34,000
本机的

2546
01:25:34,000 --> 01:25:35,000
视频文件

2547
01:25:35,000 --> 01:25:36,000
OK

2548
01:25:36,000 --> 01:25:37,000
就比较麻烦

2549
01:25:37,000 --> 01:25:38,000
你可以做

2550
01:25:38,000 --> 01:25:39,000
但是比较麻烦

2551
01:25:39,000 --> 01:25:40,000
这种私人做

2552
01:25:40,000 --> 01:25:42,000
没有那种比较现成的 App 来搞的一种

2553
01:25:42,000 --> 01:25:43,000
好吧

2554
01:25:43,000 --> 01:25:44,000
不过不影响

2555
01:25:44,000 --> 01:25:45,000
现在很多手机

2556
01:25:45,000 --> 01:25:46,000
就可以见一个热点

2557
01:25:46,000 --> 01:25:47,000
然后你可以用

2558
01:25:47,000 --> 01:25:49,000
那个手机的

2559
01:25:49,000 --> 01:25:50,000
有很多 Android App

2560
01:25:50,000 --> 01:25:51,000
可以让你做到这件事情

2561
01:25:51,000 --> 01:25:52,000
OK

2562
01:25:52,000 --> 01:25:54,000
ARM

2563
01:25:54,000 --> 01:25:56,000
再是什么解决吗

2564
01:25:56,000 --> 01:25:57,000
App TV

2565
01:25:57,000 --> 01:25:58,000
都没有没有

2566
01:25:58,000 --> 01:25:59,000
打是插

2567
01:25:59,000 --> 01:26:01,000
我们接下来讲

2568
01:26:01,000 --> 01:26:02,000
RATI 的问题

2569
01:26:02,000 --> 01:26:03,000
还有什么要补充的吗

2570
01:26:03,000 --> 01:26:04,000
我给他插补

2571
01:26:04,000 --> 01:26:05,000
我想想

2572
01:26:05,000 --> 01:26:07,000
我觉得插多了

2573
01:26:07,000 --> 01:26:08,000
那讲进去

2574
01:26:08,000 --> 01:26:09,000
有问题就是

2575
01:26:09,000 --> 01:26:10,000
RAT

2576
01:26:10,000 --> 01:26:11,000
RAT

2577
01:26:11,000 --> 01:26:12,000
RAT Native

2578
01:26:12,000 --> 01:26:13,000
可以用来写的

2579
01:26:16,000 --> 01:26:17,000
那种

2580
01:26:17,000 --> 01:26:18,000
Light Game

2581
01:26:18,000 --> 01:26:19,000
应该是可以的吧

2582
01:26:19,000 --> 01:26:20,000
我觉得

2583
01:26:20,000 --> 01:26:26,000
不過也不一定有用那個什麼 web jail 來寫得很複雜的設計遊戲

2584
01:26:26,000 --> 01:26:35,000
可是在 react native 所謂操縱的原生組件到底到底有什麼幾場曾經呢

2585
01:26:35,000 --> 01:26:41,000
比如說那個 I was on the spread kit 他可以用嗎

2586
01:26:41,000 --> 01:26:44,000
這個就只有為了他能回答

2587
01:26:44,000 --> 01:26:47,000
有人問過類似的 我你帶不是直接問遊戲

2588
01:26:47,000 --> 01:26:49,000
是說到底他可以用的

2589
01:26:49,000 --> 01:26:51,000
那些組件是可以用的 是吧

2590
01:26:51,000 --> 01:26:54,000
對 然後所得到答案是說

2591
01:26:54,000 --> 01:26:59,000
我的理解不是 Colour Code 是說所有的組件都是可以用的

2592
01:26:59,000 --> 01:27:03,000
但是可能有些組件你得自己手工把它包裝一下

2593
01:27:03,000 --> 01:27:07,000
對 什麼方式包裝呢

2594
01:27:07,000 --> 01:27:09,000
是說我必須再用寫一個什麼

2595
01:27:09,000 --> 01:27:13,000
然後直接寫 RFC 寫一個 Rapper 然後可以調用

2596
01:27:13,000 --> 01:27:16,000
不是 是在 Jaws Crew 端寫一個 Rapper

2597
01:27:16,000 --> 01:27:18,000
這樣想喔

2598
01:27:18,000 --> 01:27:20,000
這樣想

2599
01:27:20,000 --> 01:27:23,000
不考慮 react native 就考慮那個

2600
01:27:23,000 --> 01:27:25,000
reacts the Jaws part

2601
01:27:25,000 --> 01:27:27,000
你可以用 Dive 對吧

2602
01:27:27,000 --> 01:27:29,000
你可以用 Dive 你可以用 like

2603
01:27:29,000 --> 01:27:31,000
almost any HTML component

2604
01:27:31,000 --> 01:27:35,000
但是第五本身他有一個中間層是

2605
01:27:35,000 --> 01:27:39,000
react 提供給你的 react 寫了這個 Dive

2606
01:27:39,000 --> 01:27:40,000
這個 component 對不對

2607
01:27:40,000 --> 01:27:44,000
這個 VirtualDome 裡面會有一個 Dive 的對應的一個對象

2608
01:27:44,000 --> 01:27:48,000
然後這個東西是 Jaws Crew

2609
01:27:48,000 --> 01:27:52,000
是在 Jaws Crew 裡頭有一個組件來告訴 VirtualDome 說

2610
01:27:52,000 --> 01:27:54,000
我自己要做什麼我能夠做什麼

2611
01:27:54,000 --> 01:27:57,000
如果我的 StateChannel 我應該怎麼變化

2612
01:27:57,000 --> 01:27:59,000
這個是在 Jaws Crew 的 Defination 裡頭的

2613
01:27:59,000 --> 01:28:02,000
同樣的如果說你現在

2614
01:28:02,000 --> 01:28:05,000
HKML 出現了一個新的東西 出現了一個新的 Tack

2615
01:28:05,000 --> 01:28:07,000
然後你想要用這個 Tack

2616
01:28:07,000 --> 01:28:12,000
By the way that rat 還有一些 SVG 所相關的 Tack

2617
01:28:12,000 --> 01:28:14,000
它沒有實現 如果大家有興趣的話

2618
01:28:14,000 --> 01:28:16,000
可以去 Country Build

2619
01:28:16,000 --> 01:28:21,000
現在要加入這些新的原生 Tack 的實現的話

2620
01:28:21,000 --> 01:28:26,000
你也寫一個 react 的 component 來實現它對不對

2621
01:28:26,000 --> 01:28:29,000
所以轉換成 react native 的邏輯

2622
01:28:29,000 --> 01:28:32,000
如果你有一個原生的 Native 的

2623
01:28:32,000 --> 01:28:35,000
Component 你要使用的話

2624
01:28:35,000 --> 01:28:39,000
你只要在 Jaws Crew 中寫一個 Adapter

2625
01:28:39,000 --> 01:28:42,000
這個東西是什麼東西

2626
01:28:42,000 --> 01:28:44,000
怎麼樣 Initialize 它

2627
01:28:44,000 --> 01:28:47,000
它能夠提供什麼樣操作

2628
01:28:47,000 --> 01:28:50,000
Rack 的引擎

2629
01:28:50,000 --> 01:28:52,000
肯定有一個 Project Code

2630
01:28:52,000 --> 01:28:55,000
來說你要怎麼寫這個文件在 Jaws Crew

2631
01:28:55,000 --> 01:28:58,000
然後你按照它一幅畫調把寫出來之後

2632
01:28:58,000 --> 01:29:00,000
那你就可以用這個原生組件

2633
01:29:00,000 --> 01:29:02,000
但我覺得可能無套的問題就是說

2634
01:29:02,000 --> 01:29:06,000
那是就是說是 react native 這個 Library 提供

2635
01:29:06,000 --> 01:29:12,000
Jaws Crew 到 IOS 的那些原生組件

2636
01:29:12,000 --> 01:29:14,000
這一個橋嗎還是怎麼樣

2637
01:29:14,000 --> 01:29:17,000
是 Rack Native 自己本身實現的那一個

2638
01:29:17,000 --> 01:29:20,000
那這會不會有這樣類似於這個叫什麼

2639
01:29:20,000 --> 01:29:22,000
Tacketyon 你要讓同樣的問題就是說

2640
01:29:22,000 --> 01:29:27,000
你要等 Rack Native 這個 Library 提供了對應的

2641
01:29:27,000 --> 01:29:31,000
比如說 IOS 的一些原生的組件的

2642
01:29:31,000 --> 01:29:33,000
這個橋了之後你才可以用的

2643
01:29:33,000 --> 01:29:35,000
而不是說我自己可以假設蘋果

2644
01:29:35,000 --> 01:29:37,000
IOS 9 家又出了一些新的原生組件

2645
01:29:37,000 --> 01:29:39,000
那我做一個開發者我可以自己包一下

2646
01:29:39,000 --> 01:29:42,000
就可以用而不是說要等到這個 Rack Native

2647
01:29:42,000 --> 01:29:44,000
發布一個新版支持說

2648
01:29:44,000 --> 01:29:47,000
就是說 Expose 那些原生的組件出來才可以用

2649
01:29:47,000 --> 01:29:52,000
根據在那個會上 Q&A 的答案的話

2650
01:29:52,000 --> 01:29:55,000
我相信是你可以自己來做這個事情

2651
01:29:55,000 --> 01:29:57,000
就他們做了一個同樣的強

2652
01:29:57,000 --> 01:29:58,000
這個非常好

2653
01:29:58,000 --> 01:30:00,000
這個就很厲害了

2654
01:30:00,000 --> 01:30:02,000
就不用考慮到那個之前那個 Tacketyon 的

2655
01:30:02,000 --> 01:30:03,000
那種問題

2656
01:30:03,000 --> 01:30:04,000
對

2657
01:30:04,000 --> 01:30:06,000
這個真的不得

2658
01:30:06,000 --> 01:30:08,000
我剛剛這樣那麼 Swap 的不就掛了

2659
01:30:08,000 --> 01:30:12,000
JavaSwap 多簡單

2660
01:30:12,000 --> 01:30:14,000
你知道這個技術的發展

2661
01:30:14,000 --> 01:30:16,000
都是有很多不確定性的

2662
01:30:16,000 --> 01:30:19,000
所以大家不要把雞蛋放在同一個來自理的

2663
01:30:19,000 --> 01:30:20,000
這是沒錯

2664
01:30:20,000 --> 01:30:22,000
還好我已經不做前段了

2665
01:30:22,000 --> 01:30:25,000
我這也是一個問題

2666
01:30:25,000 --> 01:30:26,000
前段就是變化好快

2667
01:30:26,000 --> 01:30:29,000
對其實這也是我在那個提高裡面寫的

2668
01:30:29,000 --> 01:30:32,000
我覺得現在前段真的是沒有人知道

2669
01:30:32,000 --> 01:30:34,000
峰會往裡面吹

2670
01:30:34,000 --> 01:30:36,000
就是什麼三天一小便

2671
01:30:36,000 --> 01:30:37,000
七天一大便

2672
01:30:37,000 --> 01:30:39,000
就是 Frontand Technology

2673
01:30:39,000 --> 01:30:42,000
可能你這個網站你所用的東西

2674
01:30:42,000 --> 01:30:44,000
跟另外一個網站所用的東西

2675
01:30:44,000 --> 01:30:45,000
completely different

2676
01:30:45,000 --> 01:30:47,000
沒有任何一點點交集

2677
01:30:47,000 --> 01:30:51,000
然後兩人都覺得自己做的才是前途

2678
01:30:51,000 --> 01:30:54,000
或者反過兩人都覺得對方做的才是正確的

2679
01:30:54,000 --> 01:30:57,000
這個非常一獲的件事情

2680
01:30:57,000 --> 01:30:59,000
你這個都是搞端了

2681
01:30:59,000 --> 01:31:01,000
你想要遇到這種比較低端的男生說

2682
01:31:01,000 --> 01:31:03,000
我們不是都喜歡 Jay Curry 嗎

2683
01:31:03,000 --> 01:31:09,000
就是最好時代也是最壞的時代

2684
01:31:09,000 --> 01:31:12,000
看你自己說出的位置是什麼樣

2685
01:31:12,000 --> 01:31:16,000
我覺得這個可能就是前段技術

2686
01:31:16,000 --> 01:31:19,000
比較讓人有興趣的一部分

2687
01:31:19,000 --> 01:31:22,000
你總是可以看到一些心的

2688
01:31:22,000 --> 01:31:24,000
然後看到一些有趣的東西

2689
01:31:24,000 --> 01:31:26,000
看到年輕人的活靈

2690
01:31:27,000 --> 01:31:30,000
這從於程度上來講的話

2691
01:31:30,000 --> 01:31:33,000
它也是有技術也有

2692
01:31:33,000 --> 01:31:34,000
很固定的時候

2693
01:31:34,000 --> 01:31:35,000
別忘記

2694
01:31:35,000 --> 01:31:36,000
算是階段性發展

2695
01:31:36,000 --> 01:31:38,000
你知道 Jay Curry

2696
01:31:38,000 --> 01:31:39,000
有 Jay Curry 的一段時間

2697
01:31:39,000 --> 01:31:40,000
大家都會 Jay Curry

2698
01:31:40,000 --> 01:31:41,000
然後 Baccone

2699
01:31:41,000 --> 01:31:42,000
大家都會 Baccone

2700
01:31:42,000 --> 01:31:43,000
然後我覺得我們可能

2701
01:31:43,000 --> 01:31:45,000
之所以這麼精采

2702
01:31:45,000 --> 01:31:47,000
是因為我們在進入一個新的階段

2703
01:31:49,000 --> 01:31:51,000
從我的角度來說

2704
01:31:51,000 --> 01:31:53,000
我覺得 Racks 是最 promise 的一個手錄神

2705
01:31:53,000 --> 01:31:55,000
因為 Angler can shoot itself

2706
01:31:55,000 --> 01:31:56,000
就對了

2707
01:31:56,000 --> 01:31:57,000
你看看

2708
01:31:58,000 --> 01:31:59,000
沒辦法這個

2709
01:31:59,000 --> 01:32:00,000
對

2710
01:32:00,000 --> 01:32:01,000
所以

2711
01:32:01,000 --> 01:32:03,000
我而且他那個

2712
01:32:03,000 --> 01:32:05,000
阿典林跟 1.0 又不匹配

2713
01:32:05,000 --> 01:32:06,000
然後阿典林又在

2714
01:32:06,000 --> 01:32:08,000
又需要那麼長時間來開發

2715
01:32:08,000 --> 01:32:09,000
所以 Angler 有點

2716
01:32:09,000 --> 01:32:12,000
就是自身的那個

2717
01:32:12,000 --> 01:32:13,000
即將做死

2718
01:32:13,000 --> 01:32:16,000
真的有點這個意思

2719
01:32:16,000 --> 01:32:18,000
所以 Racks

2720
01:32:18,000 --> 01:32:21,000
很可能就是下一個階段的一個主意了

2721
01:32:22,000 --> 01:32:25,000
不管你對 Racks

2722
01:32:25,000 --> 01:32:26,000
你本身什麼

2723
01:32:26,000 --> 01:32:27,000
怎麼想

2724
01:32:27,000 --> 01:32:28,000
做一個前段的開發者的話

2725
01:32:28,000 --> 01:32:30,000
真的應該去瞭解他

2726
01:32:30,000 --> 01:32:31,000
然後至少知道

2727
01:32:31,000 --> 01:32:32,000
他為什麼好

2728
01:32:32,000 --> 01:32:34,000
或者他哪裡好

2729
01:32:36,000 --> 01:32:39,000
而且從公司的支持來說的話

2730
01:32:39,000 --> 01:32:41,000
Facebook 對 Racks

2731
01:32:41,000 --> 01:32:43,000
就是非常非常強烈的

2732
01:32:43,000 --> 01:32:45,000
你聽看到他

2733
01:32:45,000 --> 01:32:47,000
他最初是

2734
01:32:47,000 --> 01:32:48,000
最初最初的模型是

2735
01:32:48,000 --> 01:32:50,000
Facebook 8 group

2736
01:32:50,000 --> 01:32:51,000
就是 F group

2737
01:32:51,000 --> 01:32:52,000
做出來的

2738
01:32:52,000 --> 01:32:53,000
然後現在

2739
01:32:53,000 --> 01:32:54,000
後來到查

2740
01:32:54,000 --> 01:32:55,000
到大部分的前段

2741
01:32:55,000 --> 01:32:56,000
他們所現在寫的

2742
01:32:56,000 --> 01:32:57,000
都是

2743
01:32:57,000 --> 01:32:58,000
Adopt 的 Racks

2744
01:32:58,000 --> 01:32:59,000
到你找 group

2745
01:32:59,000 --> 01:33:00,000
現在又用那個

2746
01:33:00,000 --> 01:33:01,000
Rack Native 寫

2747
01:33:01,000 --> 01:33:02,000
所以

2748
01:33:02,000 --> 01:33:03,000
Racks 背後有

2749
01:33:03,000 --> 01:33:04,000
非常多 Facebook 的支持

2750
01:33:04,000 --> 01:33:05,000
反觀 Angler

2751
01:33:05,000 --> 01:33:07,000
反正都是在 Google 裡頭

2752
01:33:07,000 --> 01:33:09,000
自己都不怎麼用嗎

2753
01:33:09,000 --> 01:33:10,000
對我們並不知道

2754
01:33:10,000 --> 01:33:12,000
特別多的 Angler 所寫的你用

2755
01:33:12,000 --> 01:33:13,000
那個 inbox

2756
01:33:13,000 --> 01:33:14,000
到是一個

2757
01:33:14,000 --> 01:33:15,000
Angler

2758
01:33:15,000 --> 01:33:16,000
every 對不對

2759
01:33:16,000 --> 01:33:17,000
Inbox

2760
01:33:17,000 --> 01:33:18,000
Inbox 是不是

2761
01:33:18,000 --> 01:33:19,000
上次

2762
01:33:19,000 --> 01:33:20,000
上次

2763
01:33:20,000 --> 01:33:22,000
是 GW 寫的

2764
01:33:22,000 --> 01:33:23,000
然後我

2765
01:33:23,000 --> 01:33:24,000
就通通的

2766
01:33:24,000 --> 01:33:25,000
破碎是一個好演

2767
01:33:25,000 --> 01:33:26,000
對他

2768
01:33:26,000 --> 01:33:27,000
他是這樣

2769
01:33:27,000 --> 01:33:28,000
他是兩部分

2770
01:33:28,000 --> 01:33:29,000
他的前段那部分不知道

2771
01:33:29,000 --> 01:33:30,000
沒有說

2772
01:33:30,000 --> 01:33:31,000
但是後就是那個

2773
01:33:31,000 --> 01:33:32,000
業務邏輯那邊

2774
01:33:32,000 --> 01:33:33,000
他是加把轉過去的

2775
01:33:33,000 --> 01:33:34,000
OK

2776
01:33:34,000 --> 01:33:35,000
OK

2777
01:33:35,000 --> 01:33:36,000
那我準備寫

2778
01:33:36,000 --> 01:33:37,000
You don't code me on that

2779
01:33:37,000 --> 01:33:38,000
OK

2780
01:33:38,000 --> 01:33:39,000
很有可能就是

2781
01:33:39,000 --> 01:33:40,000
他在那個 inbox

2782
01:33:40,000 --> 01:33:41,000
的網頁版

2783
01:33:41,000 --> 01:33:42,000
的前段可能

2784
01:33:42,000 --> 01:33:43,000
就給 Angler 寫了

2785
01:33:43,000 --> 01:33:44,000
對

2786
01:33:44,000 --> 01:33:45,000
他會有很多

2787
01:33:45,000 --> 01:33:46,000
影響到

2788
01:33:46,000 --> 01:33:47,000
用一個寫

2789
01:33:47,000 --> 01:33:48,000
但是我們並沒有看到

2790
01:33:48,000 --> 01:33:49,000
很直看

2791
01:33:49,000 --> 01:33:50,000
不直接的支持

2792
01:33:50,000 --> 01:33:51,000
我覺得這一點上

2793
01:33:51,000 --> 01:33:52,000
對於那個

2794
01:33:52,000 --> 01:33:54,000
技術本身的發展是

2795
01:33:54,000 --> 01:33:55,000
不是

2796
01:33:55,000 --> 01:33:56,000
特別好

2797
01:33:56,000 --> 01:33:58,000
沒有干跌支持

2798
01:33:58,000 --> 01:33:59,000
對

2799
01:33:59,000 --> 01:34:00,000
對

2800
01:34:00,000 --> 01:34:01,000
對

2801
01:34:01,000 --> 01:34:03,000
這個是一個很大的問題

2802
01:34:03,000 --> 01:34:04,000
我們來看

2803
01:34:04,000 --> 01:34:05,000
選技術

2804
01:34:05,000 --> 01:34:06,000
技術選手

2805
01:34:06,000 --> 01:34:07,000
現在先看跌嘛

2806
01:34:07,000 --> 01:34:08,000
對嗎

2807
01:34:08,000 --> 01:34:09,000
最選的夠

2808
01:34:09,000 --> 01:34:10,000
現在我們看

2809
01:34:10,000 --> 01:34:11,000
現在我們看

2810
01:34:11,000 --> 01:34:13,000
那我們接下來說一下

2811
01:34:13,000 --> 01:34:14,000
那個 Relay

2812
01:34:14,000 --> 01:34:15,000
這個它需要

2813
01:34:15,000 --> 01:34:16,000
留在下期還是怎麼樣

2814
01:34:16,000 --> 01:34:18,000
還是一次過把他講完好了

2815
01:34:18,000 --> 01:34:20,000
他們這次

2816
01:34:20,000 --> 01:34:21,000
這個人

2817
01:34:21,000 --> 01:34:22,000
大會上面

2818
01:34:22,000 --> 01:34:23,000
除了發布這個

2819
01:34:23,000 --> 01:34:24,000
令人激動人心

2820
01:34:24,000 --> 01:34:25,000
什麼

2821
01:34:25,000 --> 01:34:26,000
令這個

2822
01:34:26,000 --> 01:34:27,000
Webapp 可以

2823
01:34:27,000 --> 01:34:28,000
秒殺這個

2824
01:34:28,000 --> 01:34:29,000
IOS

2825
01:34:29,000 --> 01:34:30,000
或者這樣

2826
01:34:30,000 --> 01:34:31,000
Ground the breaking

2827
01:34:31,000 --> 01:34:32,000
就直接

2828
01:34:32,000 --> 01:34:33,000
直接就秒釋了

2829
01:34:33,000 --> 01:34:34,000
的這麼一個

2830
01:34:34,000 --> 01:34:35,000
對

2831
01:34:35,000 --> 01:34:36,000
Ground breaking 的技術出來

2832
01:34:36,000 --> 01:34:37,000
還發布了一個

2833
01:34:37,000 --> 01:34:39,000
作為一個前段開發

2834
01:34:39,000 --> 01:34:41,000
半個前段開發

2835
01:34:41,000 --> 01:34:42,000
走得我來講

2836
01:34:42,000 --> 01:34:44,000
這個還是非常令人的

2837
01:34:44,000 --> 01:34:45,000
低動的

2838
01:34:45,000 --> 01:34:46,000
要有一個 Relay 的

2839
01:34:46,000 --> 01:34:47,000
這麼一個技術

2840
01:34:47,000 --> 01:34:48,000
這個事情跟之前講的

2841
01:34:48,000 --> 01:34:49,000
那個 Flux

2842
01:34:49,000 --> 01:34:50,000
是有厚度

2843
01:34:50,000 --> 01:34:51,000
或小的關係的

2844
01:34:51,000 --> 01:34:52,000
他們在去年

2845
01:34:52,000 --> 01:34:53,000
發布那個 Flux

2846
01:34:53,000 --> 01:34:54,000
架構的時候

2847
01:34:54,000 --> 01:34:55,000
並沒有說

2848
01:34:55,000 --> 01:34:56,000
因為 Flux 它

2849
01:34:56,000 --> 01:34:57,000
只是一個 IDM

2850
01:34:57,000 --> 01:34:58,000
它並沒有說

2851
01:34:58,000 --> 01:34:59,000
告訴你一些具體的

2852
01:34:59,000 --> 01:35:01,000
執行的措施是怎樣子

2853
01:35:01,000 --> 01:35:02,000
然後其中有一個

2854
01:35:02,000 --> 01:35:03,000
很

2855
01:35:03,000 --> 01:35:04,000
任何一個 Webapp

2856
01:35:04,000 --> 01:35:05,000
都逃不掉的問題

2857
01:35:05,000 --> 01:35:06,000
就是你怎麼去

2858
01:35:06,000 --> 01:35:07,000
從服務端

2859
01:35:07,000 --> 01:35:08,000
或許數據

2860
01:35:08,000 --> 01:35:09,000
對

2861
01:35:09,000 --> 01:35:11,000
然後在這個傳統的方式下

2862
01:35:11,000 --> 01:35:12,000
那個可能最簡單的

2863
01:35:12,000 --> 01:35:13,000
我就用 J-Crash

2864
01:35:13,000 --> 01:35:16,000
或者用 HTB request

2865
01:35:16,000 --> 01:35:17,000
發一個請求

2866
01:35:17,000 --> 01:35:18,000
然後會用什麼

2867
01:35:18,000 --> 01:35:19,000
一個 Coreback

2868
01:35:19,000 --> 01:35:20,000
就更新了一下這個動

2869
01:35:20,000 --> 01:35:21,000
這個可能是

2870
01:35:21,000 --> 01:35:22,000
最最原始的

2871
01:35:22,000 --> 01:35:23,000
一個同服端

2872
01:35:23,000 --> 01:35:24,000
去數據

2873
01:35:24,000 --> 01:35:25,000
然後在一個 Webapp

2874
01:35:25,000 --> 01:35:26,000
裡面展示的方法

2875
01:35:26,000 --> 01:35:28,000
但是到了一定成績之後

2876
01:35:28,000 --> 01:35:29,000
這種方式就是完全是

2877
01:35:29,000 --> 01:35:30,000
不可以管理的

2878
01:35:30,000 --> 01:35:31,000
有很多

2879
01:35:31,000 --> 01:35:32,000
很多其他關於的問題要解決

2880
01:35:32,000 --> 01:35:34,000
然後他們這次發布的

2881
01:35:34,000 --> 01:35:35,000
Relay

2882
01:35:35,000 --> 01:35:36,000
其實就是要解決

2883
01:35:36,000 --> 01:35:37,000
這麼一個問題

2884
01:35:39,000 --> 01:35:40,000
我不知道

2885
01:35:40,000 --> 01:35:41,000
在之前的時候

2886
01:35:41,000 --> 01:35:42,000
是怎麼去做這個

2887
01:35:42,000 --> 01:35:43,000
從服務端

2888
01:35:43,000 --> 01:35:45,000
或許數據這麼一個過程

2889
01:35:47,000 --> 01:35:48,000
因為我們都

2890
01:35:48,000 --> 01:35:49,000
之前都是在用

2891
01:35:49,000 --> 01:35:51,000
那個傳統以上的

2892
01:35:51,000 --> 01:35:52,000
NVC 的 model

2893
01:35:52,000 --> 01:35:53,000
我們還沒有到

2894
01:35:53,000 --> 01:35:55,000
我們並沒有使用 Storage 的概念

2895
01:35:55,000 --> 01:35:56,000
但是我就是

2896
01:35:56,000 --> 01:35:57,000
Storage 的概念可能

2897
01:35:57,000 --> 01:35:59,000
跟那個 model 是

2898
01:35:59,000 --> 01:36:00,000
可以 Map 的

2899
01:36:00,000 --> 01:36:01,000
所以

2900
01:36:01,000 --> 01:36:02,000
然後我們的後台

2901
01:36:02,000 --> 01:36:03,000
是一個 Respect API

2902
01:36:03,000 --> 01:36:04,000
在

2903
01:36:04,000 --> 01:36:05,000
在前端

2904
01:36:05,000 --> 01:36:06,000
我們有 model

2905
01:36:06,000 --> 01:36:07,000
然後這個 model

2906
01:36:07,000 --> 01:36:09,000
它可以去

2907
01:36:09,000 --> 01:36:11,000
跟那個後台去 think

2908
01:36:11,000 --> 01:36:12,000
這個 Storage 是一個

2909
01:36:12,000 --> 01:36:14,000
Respect API

2910
01:36:14,000 --> 01:36:15,000
HTB Request

2911
01:36:15,000 --> 01:36:16,000
然後那個

2912
01:36:16,000 --> 01:36:17,000
Serve 會把你所

2913
01:36:17,000 --> 01:36:18,000
需要或許的信息

2914
01:36:18,000 --> 01:36:19,000
給發送回來

2915
01:36:19,000 --> 01:36:20,000
然後這樣 model

2916
01:36:20,000 --> 01:36:21,000
就有了

2917
01:36:21,000 --> 01:36:22,000
就得到了

2918
01:36:22,000 --> 01:36:23,000
所有需要的信息

2919
01:36:24,000 --> 01:36:25,000
那麼這裡

2920
01:36:25,000 --> 01:36:26,000
就有一個問題

2921
01:36:26,000 --> 01:36:27,000
就是說剛我們

2922
01:36:27,000 --> 01:36:28,000
可能要介入

2923
01:36:28,000 --> 01:36:30,000
這麼一個新的一個概念

2924
01:36:30,000 --> 01:36:31,000
也比較先說

2925
01:36:31,000 --> 01:36:32,000
你做前端開發

2926
01:36:32,000 --> 01:36:33,000
肯定會遇到

2927
01:36:33,000 --> 01:36:34,000
就得 Res 的這麼一個 API

2928
01:36:34,000 --> 01:36:35,000
那什麼意思呢

2929
01:36:35,000 --> 01:36:36,000
就是說它起碼

2930
01:36:36,000 --> 01:36:37,000
它就說把我

2931
01:36:37,000 --> 01:36:38,000
把這個我後台

2932
01:36:38,000 --> 01:36:40,000
能夠提供了你所有的資源

2933
01:36:40,000 --> 01:36:41,000
一個 resource

2934
01:36:41,000 --> 01:36:42,000
通過一個

2935
01:36:42,000 --> 01:36:43,000
U.I.L 的節點

2936
01:36:43,000 --> 01:36:44,000
暴露出來

2937
01:36:44,000 --> 01:36:45,000
然後你通過

2938
01:36:45,000 --> 01:36:47,000
像什麼標準的

2939
01:36:47,000 --> 01:36:49,000
什麼 put,delete, post, get

2940
01:36:49,000 --> 01:36:50,000
這個方法去獲取這些

2941
01:36:50,000 --> 01:36:51,000
這些資源嘛

2942
01:36:51,000 --> 01:36:52,000
但是這有一個問題

2943
01:36:52,000 --> 01:36:53,000
就是說

2944
01:36:53,000 --> 01:36:54,000
我不知道你們那邊

2945
01:36:54,000 --> 01:36:55,000
是不怎麼樣的

2946
01:36:55,000 --> 01:36:56,000
就是我看到的

2947
01:36:56,000 --> 01:36:57,000
大部分的 Respect API

2948
01:36:57,000 --> 01:36:58,000
對有一個共同的問題

2949
01:36:58,000 --> 01:36:59,000
就是它有

2950
01:36:59,000 --> 01:37:00,000
太多的這個

2951
01:37:00,000 --> 01:37:01,000
所謂 endpoint

2952
01:37:01,000 --> 01:37:02,000
太多的節點

2953
01:37:02,000 --> 01:37:03,000
因為每一個字

2954
01:37:03,000 --> 01:37:04,000
原來就要對付一個節點嘛

2955
01:37:04,000 --> 01:37:05,000
沒錯

2956
01:37:05,000 --> 01:37:07,000
然後如果我為了你講的這樣

2957
01:37:07,000 --> 01:37:08,000
你們也是說

2958
01:37:08,000 --> 01:37:09,000
每一個 model

2959
01:37:09,000 --> 01:37:10,000
應該是對一個

2960
01:37:10,000 --> 01:37:11,000
有一個 resource

2961
01:37:11,000 --> 01:37:12,000
一個資源

2962
01:37:12,000 --> 01:37:13,000
然後每個 model

2963
01:37:13,000 --> 01:37:14,000
去負責去

2964
01:37:14,000 --> 01:37:15,000
那個節點的

2965
01:37:15,000 --> 01:37:16,000
那個資源

2966
01:37:16,000 --> 01:37:18,000
對應的 Res 的節點去訪問它對吧

2967
01:37:18,000 --> 01:37:20,000
但是這樣

2968
01:37:20,000 --> 01:37:21,000
我就其實這樣管理

2969
01:37:21,000 --> 01:37:22,000
編輯起來

2970
01:37:22,000 --> 01:37:23,000
都不是很方便

2971
01:37:23,000 --> 01:37:24,000
而且在實用起來

2972
01:37:24,000 --> 01:37:25,000
我就有很多問題

2973
01:37:25,000 --> 01:37:26,000
就我先講講

2974
01:37:26,000 --> 01:37:27,000
我的體驗

2975
01:37:27,000 --> 01:37:28,000
怎麼樣子啊感覺

2976
01:37:28,000 --> 01:37:29,000
就是一個剛講那個節點

2977
01:37:29,000 --> 01:37:30,000
太多

2978
01:37:30,000 --> 01:37:31,000
你要為每一個資源

2979
01:37:31,000 --> 01:37:32,000
增加一個節點

2980
01:37:32,000 --> 01:37:33,000
然後你要考慮

2981
01:37:33,000 --> 01:37:34,000
每一個字

2982
01:37:34,000 --> 01:37:35,000
它能夠支持的這些

2983
01:37:35,000 --> 01:37:36,000
所有的這些

2984
01:37:36,000 --> 01:37:37,000
它對你的一些

2985
01:37:37,000 --> 01:37:38,000
所謂的這個

2986
01:37:38,000 --> 01:37:39,000
這個語意是什麼

2987
01:37:39,000 --> 01:37:40,000
比如說我有一個 user

2988
01:37:40,000 --> 01:37:41,000
如果 put 的 user

2989
01:37:41,000 --> 01:37:42,000
是一個什麼意思對吧

2990
01:37:42,000 --> 01:37:43,000
然後 post user

2991
01:37:43,000 --> 01:37:44,000
又是什麼意思

2992
01:37:44,000 --> 01:37:45,000
然後 delete

2993
01:37:45,000 --> 01:37:46,000
大家可能更好理解一點

2994
01:37:46,000 --> 01:37:47,000
但是你會

2995
01:37:47,000 --> 01:37:48,000
前世到資源都種了

2996
01:37:48,000 --> 01:37:49,000
又不一樣

2997
01:37:49,000 --> 01:37:50,000
有所謂的什麼 collection

2998
01:37:50,000 --> 01:37:51,000
有所謂的 individual

2999
01:37:51,000 --> 01:37:53,000
這種這種說

3000
01:37:53,000 --> 01:37:54,000
其實很多事情

3001
01:37:54,000 --> 01:37:55,000
還是不是那麼清晰的

3002
01:37:55,000 --> 01:37:57,000
而且這個 res

3003
01:37:57,000 --> 01:37:58,000
本身的定義

3004
01:37:58,000 --> 01:37:59,000
就是很多

3005
01:37:59,000 --> 01:38:00,000
有很不同的理解嘛

3006
01:38:00,000 --> 01:38:01,000
雖然那個最開始那篇

3007
01:38:01,000 --> 01:38:02,000
博士論文裡面

3008
01:38:02,000 --> 01:38:03,000
有把這個概念

3009
01:38:03,000 --> 01:38:04,000
採出段子的詳細

3010
01:38:04,000 --> 01:38:05,000
但是我

3011
01:38:05,000 --> 01:38:06,000
我可以確信

3012
01:38:06,000 --> 01:38:07,000
絕大部分做 res 人

3013
01:38:07,000 --> 01:38:08,000
都什麼都看過那篇

3014
01:38:08,000 --> 01:38:09,000
博士論文的

3015
01:38:09,000 --> 01:38:11,000
然後 res 人

3016
01:38:11,000 --> 01:38:12,000
我覺得還有一個問題

3017
01:38:12,000 --> 01:38:14,000
就是說它的那個

3018
01:38:14,000 --> 01:38:16,000
這個就約束太多了

3019
01:38:16,000 --> 01:38:17,000
首先一個一個學生

3020
01:38:17,000 --> 01:38:18,000
就說就假設你要

3021
01:38:18,000 --> 01:38:20,000
要暴露出來一個 user

3022
01:38:20,000 --> 01:38:21,000
這麼一個節點

3023
01:38:21,000 --> 01:38:22,000
這麼一個資源

3024
01:38:22,000 --> 01:38:23,000
可能代表是一個

3025
01:38:23,000 --> 01:38:24,000
某一個

3026
01:38:24,000 --> 01:38:25,000
一個帳號體系的一個用戶

3027
01:38:25,000 --> 01:38:26,000
對吧

3028
01:38:26,000 --> 01:38:27,000
它返回給你的數據

3029
01:38:27,000 --> 01:38:29,000
肯定是固定結構的

3030
01:38:29,000 --> 01:38:30,000
就是你取一個 user

3031
01:38:30,000 --> 01:38:31,000
你都取到它所有的信息

3032
01:38:31,000 --> 01:38:32,000
比如說你還要取它的

3033
01:38:32,000 --> 01:38:33,000
這個用戶名

3034
01:38:33,000 --> 01:38:34,000
這個

3035
01:38:34,000 --> 01:38:35,000
意謀

3036
01:38:35,000 --> 01:38:36,000
它就還會把

3037
01:38:36,000 --> 01:38:37,000
所有的詳細的信息

3038
01:38:37,000 --> 01:38:38,000
都返給你

3039
01:38:38,000 --> 01:38:39,000
哪怕你只是需要

3040
01:38:39,000 --> 01:38:40,000
用它的這個

3041
01:38:40,000 --> 01:38:41,000
一個用戶名來顯示

3042
01:38:41,000 --> 01:38:42,000
這顯示出一個

3043
01:38:42,000 --> 01:38:43,000
或者一個頭像

3044
01:38:43,000 --> 01:38:44,000
顯示出一個

3045
01:38:44,000 --> 01:38:46,000
一個頭像框而已對吧

3046
01:38:46,000 --> 01:38:47,000
對你沒有

3047
01:38:47,000 --> 01:38:48,000
它對於它的

3048
01:38:48,000 --> 01:38:49,000
更為精細的控制

3049
01:38:49,000 --> 01:38:50,000
對

3050
01:38:50,000 --> 01:38:51,000
對每一個資源來講

3051
01:38:51,000 --> 01:38:52,000
你比較難去說

3052
01:38:52,000 --> 01:38:53,000
你再做一些

3053
01:38:53,000 --> 01:38:55,000
更精細的要求

3054
01:38:55,000 --> 01:38:56,000
而且

3055
01:38:56,000 --> 01:38:58,000
它所謂的這個

3056
01:38:58,000 --> 01:38:59,000
可組和性也比較低

3057
01:38:59,000 --> 01:39:00,000
比如說

3058
01:39:00,000 --> 01:39:01,000
最舉個最簡單的例子

3059
01:39:01,000 --> 01:39:02,000
我有一個

3060
01:39:02,000 --> 01:39:04,000
user 這麼一個節點

3061
01:39:04,000 --> 01:39:05,000
然後有一個像一個

3062
01:39:05,000 --> 01:39:06,000
post 一個文章

3063
01:39:06,000 --> 01:39:07,000
或者鐵子

3064
01:39:07,000 --> 01:39:08,000
這麼一個節點

3065
01:39:08,000 --> 01:39:09,000
我想在

3066
01:39:09,000 --> 01:39:10,000
取到說

3067
01:39:10,000 --> 01:39:11,000
這個用戶

3068
01:39:11,000 --> 01:39:13,000
發過的那個文章的時候

3069
01:39:13,000 --> 01:39:14,000
你會簽到一個

3070
01:39:14,000 --> 01:39:15,000
很麻煩的問

3071
01:39:15,000 --> 01:39:16,000
就是說你把這個

3072
01:39:16,000 --> 01:39:17,000
這個對應的請求

3073
01:39:17,000 --> 01:39:18,000
它顯然不

3074
01:39:18,000 --> 01:39:19,000
是完全歸屬

3075
01:39:19,000 --> 01:39:20,000
用戶那個節點

3076
01:39:20,000 --> 01:39:21,000
它也不是完全

3077
01:39:21,000 --> 01:39:22,000
歸屬於這個

3078
01:39:22,000 --> 01:39:23,000
post 那個節點對吧

3079
01:39:23,000 --> 01:39:24,000
就有些這種

3080
01:39:24,000 --> 01:39:26,000
很不正教的東西出現在裡面

3081
01:39:26,000 --> 01:39:27,000
而且你又辦法

3082
01:39:27,000 --> 01:39:28,000
很方便的

3083
01:39:28,000 --> 01:39:29,000
在同一個請求裡面

3084
01:39:29,000 --> 01:39:30,000
去同時取著

3085
01:39:30,000 --> 01:39:31,000
兩個不同的東西

3086
01:39:31,000 --> 01:39:33,000
就它們的這個可組和性

3087
01:39:33,000 --> 01:39:34,000
我覺得是比較

3088
01:39:34,000 --> 01:39:35,000
比較低的

3089
01:39:35,000 --> 01:39:36,000
沒錯

3090
01:39:36,000 --> 01:39:37,000
然後最後一個

3091
01:39:37,000 --> 01:39:38,000
就是說我實際

3092
01:39:38,000 --> 01:39:39,000
就用到體驗論就是

3093
01:39:39,000 --> 01:39:40,000
因為這個

3094
01:39:40,000 --> 01:39:41,000
大部分的

3095
01:39:41,000 --> 01:39:42,000
rest API

3096
01:39:42,000 --> 01:39:43,000
是通過 HGDP 的

3097
01:39:43,000 --> 01:39:44,000
正方法去訪問的嘛

3098
01:39:44,000 --> 01:39:45,000
那我們先用的 HGDP

3099
01:39:45,000 --> 01:39:46,000
所謂的 1.0

3100
01:39:46,000 --> 01:39:47,000
1.1 這個版本

3101
01:39:47,000 --> 01:39:48,000
有一個問題就是說

3102
01:39:48,000 --> 01:39:50,000
它有一個很嚴酷的

3103
01:39:50,000 --> 01:39:52,000
request response

3104
01:39:52,000 --> 01:39:54,000
請求答覆

3105
01:39:54,000 --> 01:39:56,000
這麼一個流程

3106
01:39:56,000 --> 01:39:57,000
你不可能說

3107
01:39:57,000 --> 01:39:58,000
我發五個請求出去

3108
01:39:58,000 --> 01:39:59,000
然後等五個回覆出來對吧

3109
01:39:59,000 --> 01:40:00,000
就這種

3110
01:40:00,000 --> 01:40:01,000
有一個效率的問題

3111
01:40:01,000 --> 01:40:02,000
那麼很多人

3112
01:40:02,000 --> 01:40:03,000
就為了解決效率問題

3113
01:40:03,000 --> 01:40:04,000
他要去考慮說

3114
01:40:04,000 --> 01:40:05,000
把這個請求所謂打包

3115
01:40:05,000 --> 01:40:06,000
就是 Batchin 嘛

3116
01:40:06,000 --> 01:40:07,000
對我吧

3117
01:40:07,000 --> 01:40:08,000
我要請求五個用戶

3118
01:40:08,000 --> 01:40:09,000
或者說請求

3119
01:40:09,000 --> 01:40:10,000
五個用戶三個文章

3120
01:40:10,000 --> 01:40:12,000
我要把這幾個請求包在一起

3121
01:40:12,000 --> 01:40:13,000
然後發一個請求過去

3122
01:40:13,000 --> 01:40:14,000
這個時候

3123
01:40:14,000 --> 01:40:15,000
你用 rest API 的話

3124
01:40:15,000 --> 01:40:16,000
就不是非常好做了

3125
01:40:16,000 --> 01:40:17,000
沒錯

3126
01:40:17,000 --> 01:40:18,000
所以總體來講

3127
01:40:18,000 --> 01:40:19,000
我覺得 rest 在

3128
01:40:19,000 --> 01:40:21,000
它的邏輯是

3129
01:40:21,000 --> 01:40:22,000
很好的

3130
01:40:22,000 --> 01:40:23,000
就是整個概念是非常方便

3131
01:40:23,000 --> 01:40:25,000
但是我覺得它始終是一個

3132
01:40:25,000 --> 01:40:26,000
更適用於

3133
01:40:26,000 --> 01:40:27,000
那種說

3134
01:40:27,000 --> 01:40:29,000
面向文蕩的

3135
01:40:29,000 --> 01:40:30,000
類型的應用是比較好的

3136
01:40:30,000 --> 01:40:31,000
但是在我們

3137
01:40:31,000 --> 01:40:32,000
目前在做到

3138
01:40:32,000 --> 01:40:33,000
很多這種面向

3139
01:40:33,000 --> 01:40:35,000
一些什麼社交網絡也好

3140
01:40:35,000 --> 01:40:36,000
還有其他一些

3141
01:40:36,000 --> 01:40:37,000
更新型態的應用的時候

3142
01:40:37,000 --> 01:40:38,000
用 rest 的這種的 API

3143
01:40:38,000 --> 01:40:39,000
其實我覺得

3144
01:40:39,000 --> 01:40:41,000
並不是一個特別好的選擇

3145
01:40:41,000 --> 01:40:43,000
我吃飽了一講

3146
01:40:43,000 --> 01:40:44,000
我覺得

3147
01:40:44,000 --> 01:40:46,000
我們所看到

3148
01:40:46,000 --> 01:40:48,000
Relate 它的確在解決

3149
01:40:48,000 --> 01:40:50,000
另外一種問題

3150
01:40:50,000 --> 01:40:51,000
但是

3151
01:40:51,000 --> 01:40:52,000
而且

3152
01:40:52,000 --> 01:40:56,000
是非常有意義的一個解決方案

3153
01:40:56,000 --> 01:40:58,000
還有我總

3154
01:40:58,000 --> 01:40:59,000
會是覺得

3155
01:40:59,000 --> 01:41:02,000
Relate 它的

3156
01:41:02,000 --> 01:41:03,000
意義跟在於

3157
01:41:03,000 --> 01:41:05,000
是幫助像

3158
01:41:05,000 --> 01:41:06,000
Facebook 這樣

3159
01:41:06,000 --> 01:41:07,000
大型的公司

3160
01:41:07,000 --> 01:41:08,000
來管理它的負責度

3161
01:41:08,000 --> 01:41:09,000
因為

3162
01:41:09,000 --> 01:41:10,000
只有在那個規模上

3163
01:41:10,000 --> 01:41:11,000
你才會

3164
01:41:11,000 --> 01:41:13,000
再以那麼小級別

3165
01:41:13,000 --> 01:41:14,000
就是說

3166
01:41:14,000 --> 01:41:15,000
到底是哪個

3167
01:41:15,000 --> 01:41:16,000
哪個 View

3168
01:41:16,000 --> 01:41:17,000
得到哪個 Feel

3169
01:41:17,000 --> 01:41:18,000
就在解決

3170
01:41:18,000 --> 01:41:19,000
那一塊的需求

3171
01:41:19,000 --> 01:41:20,000
然後

3172
01:41:20,000 --> 01:41:22,000
同時又更好的

3173
01:41:22,000 --> 01:41:23,000
封裝

3174
01:41:23,000 --> 01:41:24,000
和保護不同的數據

3175
01:41:24,000 --> 01:41:26,000
這是非常有意義的事情

3176
01:41:26,000 --> 01:41:27,000
但是我覺得還是

3177
01:41:27,000 --> 01:41:28,000
跟那個規模是相關的

3178
01:41:28,000 --> 01:41:29,000
小公司

3179
01:41:29,000 --> 01:41:30,000
其實是不需要

3180
01:41:30,000 --> 01:41:31,000
這怎麼

3181
01:41:31,000 --> 01:41:32,000
負責的需求的嗎

3182
01:41:32,000 --> 01:41:33,000
對

3183
01:41:33,000 --> 01:41:35,000
從很大程式來說

3184
01:41:35,000 --> 01:41:36,000
我覺得是這樣子

3185
01:41:36,000 --> 01:41:37,000
但是

3186
01:41:37,000 --> 01:41:38,000
這個

3187
01:41:38,000 --> 01:41:39,000
是跟

3188
01:41:39,000 --> 01:41:41,000
你所謂要解決的問題

3189
01:41:41,000 --> 01:41:42,000
所

3190
01:41:42,000 --> 01:41:44,000
Relate 它的方案

3191
01:41:44,000 --> 01:41:45,000
是有相關的

3192
01:41:45,000 --> 01:41:46,000
而且從一個程度上來這樣

3193
01:41:46,000 --> 01:41:47,000
如果你

3194
01:41:47,000 --> 01:41:48,000
在於 restful

3195
01:41:48,000 --> 01:41:49,000
API 的

3196
01:41:49,000 --> 01:41:50,000
基礎上

3197
01:41:50,000 --> 01:41:51,000
加上一些

3198
01:41:51,000 --> 01:41:52,000
控制的

3199
01:41:52,000 --> 01:41:53,000
電量

3200
01:41:53,000 --> 01:41:54,000
比如說

3201
01:41:54,000 --> 01:41:55,000
Facebook 自己

3202
01:41:55,000 --> 01:41:57,000
本身的

3203
01:41:57,000 --> 01:41:58,000
Graph API

3204
01:41:58,000 --> 01:41:59,000
有一個

3205
01:41:59,000 --> 01:42:01,000
Feels 的概念

3206
01:42:01,000 --> 01:42:02,000
你

3207
01:42:02,000 --> 01:42:03,000
Feels 會

3208
01:42:03,000 --> 01:42:04,000
幫助你

3209
01:42:04,000 --> 01:42:06,000
控制它所反

3210
01:42:06,000 --> 01:42:07,000
回的

3211
01:42:07,000 --> 01:42:08,000
Actual View

3212
01:42:08,000 --> 01:42:09,000
到底是哪些 Feels

3213
01:42:09,000 --> 01:42:10,000
這跟

3214
01:42:10,000 --> 01:42:11,000
這跟

3215
01:42:11,000 --> 01:42:12,000
Relate 中的一些概念

3216
01:42:12,000 --> 01:42:13,000
是非常相似的

3217
01:42:13,000 --> 01:42:15,000
非常 Map

3218
01:42:15,000 --> 01:42:17,000
我也可以預見

3219
01:42:17,000 --> 01:42:19,000
在 Relate 真正的發布的時候

3220
01:42:19,000 --> 01:42:21,000
會有人給

3221
01:42:21,000 --> 01:42:22,000
我

3222
01:42:22,000 --> 01:42:23,000
在 Restful API

3223
01:42:23,000 --> 01:42:26,000
也支持 Related 時間方式

3224
01:42:26,000 --> 01:42:27,000
剛好

3225
01:42:27,000 --> 01:42:28,000
昨天

3226
01:42:28,000 --> 01:42:30,000
因為 Related 還沒有

3227
01:42:30,000 --> 01:42:31,000
發布的概念

3228
01:42:31,000 --> 01:42:32,000
並沒有公布

3229
01:42:32,000 --> 01:42:33,000
它後面的一些長兵

3230
01:42:33,000 --> 01:42:34,000
昨天在

3231
01:42:34,000 --> 01:42:35,000
HackarNew 上面

3232
01:42:35,000 --> 01:42:36,000
Facebook

3233
01:42:36,000 --> 01:42:37,000
它沒有一個叫做

3234
01:42:37,000 --> 01:42:39,000
Wincent

3235
01:42:39,000 --> 01:42:40,000
Wincent

3236
01:42:40,000 --> 01:42:41,000
這麼一個人

3237
01:42:41,000 --> 01:42:42,000
它不是在

3238
01:42:42,000 --> 01:42:43,000
給它上寫了一個

3239
01:42:43,000 --> 01:42:44,000
Relate 的 FAQ

3240
01:42:44,000 --> 01:42:45,000
常見問題解答

3241
01:42:45,000 --> 01:42:46,000
它

3242
01:42:46,000 --> 01:42:47,000
我看見

3243
01:42:47,000 --> 01:42:48,000
他們這麼一個問題

3244
01:42:48,000 --> 01:42:49,000
就說

3245
01:42:49,000 --> 01:42:50,000
Relate 它

3246
01:42:50,000 --> 01:42:51,000
依賴一個核心的組件

3247
01:42:51,000 --> 01:42:52,000
就是那個什麼

3248
01:42:52,000 --> 01:42:53,000
GraphQL

3249
01:42:53,000 --> 01:42:54,000
就是這個圖

3250
01:42:54,000 --> 01:42:55,000
查詢語言

3251
01:42:55,000 --> 01:42:56,000
這個是

3252
01:42:56,000 --> 01:42:57,000
跟 Facebook

3253
01:42:57,000 --> 01:42:58,000
他們後台有一個叫做

3254
01:42:58,000 --> 01:42:59,000
TL

3255
01:42:59,000 --> 01:43:00,000
TOW 的一個圖書據庫

3256
01:43:00,000 --> 01:43:01,000
是一名相關的

3257
01:43:01,000 --> 01:43:02,000
但我不太清楚

3258
01:43:02,000 --> 01:43:03,000
就是說

3259
01:43:03,000 --> 01:43:04,000
對於一個

3260
01:43:04,000 --> 01:43:05,000
第三方就

3261
01:43:05,000 --> 01:43:06,000
做了一個 Facebook 以外的人

3262
01:43:06,000 --> 01:43:07,000
或者是中小開發

3263
01:43:07,000 --> 01:43:08,000
就中小玩家

3264
01:43:08,000 --> 01:43:10,000
你沒有一個

3265
01:43:10,000 --> 01:43:11,000
基於這麼一個圖的

3266
01:43:11,000 --> 01:43:13,000
結構的後台的話

3267
01:43:13,000 --> 01:43:14,000
你怎麼去

3268
01:43:14,000 --> 01:43:15,000
去

3269
01:43:15,000 --> 01:43:16,000
適應這種

3270
01:43:16,000 --> 01:43:17,000
GraphQL 的要求

3271
01:43:17,000 --> 01:43:18,000
去做到 Relate 這種效果

3272
01:43:18,000 --> 01:43:19,000
我覺得還是

3273
01:43:19,000 --> 01:43:21,000
很大的一個疑惑

3274
01:43:21,000 --> 01:43:22,000
這是一個機會

3275
01:43:22,000 --> 01:43:23,000
這是一個

3276
01:43:23,000 --> 01:43:24,000
即使空白

3277
01:43:24,000 --> 01:43:25,000
市場現在是空白的

3278
01:43:25,000 --> 01:43:26,000
對不對

3279
01:43:26,000 --> 01:43:27,000
對

3280
01:43:27,000 --> 01:43:28,000
如果

3281
01:43:28,000 --> 01:43:30,000
我們有聽眾

3282
01:43:30,000 --> 01:43:32,000
想要

3283
01:43:32,000 --> 01:43:34,000
藉此機會來寫

3284
01:43:34,000 --> 01:43:35,000
一個什麼 Open Source Library

3285
01:43:35,000 --> 01:43:36,000
或者是

3286
01:43:36,000 --> 01:43:37,000
甚至去看一個動作

3287
01:43:37,000 --> 01:43:38,000
我覺得這個機會

3288
01:43:38,000 --> 01:43:39,000
是有可能存在的

3289
01:43:39,000 --> 01:43:41,000
沒有知道

3290
01:43:41,000 --> 01:43:43,000
GraphQL

3291
01:43:43,000 --> 01:43:44,000
它

3292
01:43:44,000 --> 01:43:46,000
最終

3293
01:43:46,000 --> 01:43:48,000
即使是

3294
01:43:48,000 --> 01:43:49,000
Open Source

3295
01:43:49,000 --> 01:43:50,000
不是

3296
01:43:50,000 --> 01:43:51,000
最終它會有 Open Source

3297
01:43:51,000 --> 01:43:52,000
但是我們需要等一段時間

3298
01:43:52,000 --> 01:43:53,000
它的 Open Source

3299
01:43:53,000 --> 01:43:54,000
之後

3300
01:43:54,000 --> 01:43:55,000
它也

3301
01:43:55,000 --> 01:43:56,000
更多的是做一個

3302
01:43:56,000 --> 01:43:57,000
Protocol 的存在

3303
01:43:57,000 --> 01:43:58,000
就像複雜式一樣

3304
01:43:58,000 --> 01:43:59,000
對

3305
01:43:59,000 --> 01:44:00,000
所以真正的時間

3306
01:44:00,000 --> 01:44:01,000
是需要

3307
01:44:01,000 --> 01:44:02,000
你自己去做那些

3308
01:44:02,000 --> 01:44:03,000
根據它所用的

3309
01:44:03,000 --> 01:44:04,000
軟件來

3310
01:44:04,000 --> 01:44:06,000
來實現的

3311
01:44:06,000 --> 01:44:07,000
對

3312
01:44:07,000 --> 01:44:08,000
我覺得有點像 SQL

3313
01:44:08,000 --> 01:44:10,000
你可以請可以做一個

3314
01:44:10,000 --> 01:44:12,000
GraphQL Database

3315
01:44:12,000 --> 01:44:13,000
或者說

3316
01:44:13,000 --> 01:44:14,000
Late Database

3317
01:44:14,000 --> 01:44:16,000
GraphQL Server

3318
01:44:16,000 --> 01:44:17,000
然後這個 Server

3319
01:44:17,000 --> 01:44:19,000
可能會

3320
01:44:19,000 --> 01:44:20,000
會說一種

3321
01:44:20,000 --> 01:44:22,000
GraphQL 的 Deluxe

3322
01:44:22,000 --> 01:44:24,000
然後帶某種獲得

3323
01:44:24,000 --> 01:44:25,000
就

3324
01:44:25,000 --> 01:44:26,000
GraphQL 一模一樣

3325
01:44:26,000 --> 01:44:27,000
對

3326
01:44:27,000 --> 01:44:28,000
沒錯

3327
01:44:28,000 --> 01:44:29,000
他們就算

3328
01:44:29,000 --> 01:44:30,000
RELAY 以後發布的

3329
01:44:30,000 --> 01:44:31,000
他也只會包含

3330
01:44:31,000 --> 01:44:32,000
首先第一個是

3331
01:44:32,000 --> 01:44:33,000
客戶端的

3332
01:44:33,000 --> 01:44:34,000
GraphQL 那些組件

3333
01:44:34,000 --> 01:44:36,000
所以它可以在每一個

3334
01:44:36,000 --> 01:44:37,000
他可以在每一個

3335
01:44:37,000 --> 01:44:38,000
REC 組件裡面

3336
01:44:38,000 --> 01:44:39,000
生名

3337
01:44:39,000 --> 01:44:40,000
你那個組件需要哪一個

3338
01:44:40,000 --> 01:44:42,000
哪一種類型的數據

3339
01:44:42,000 --> 01:44:43,000
然後它可以通過

3340
01:44:43,000 --> 01:44:44,000
RELAY 的這個 Liberate 去把

3341
01:44:44,000 --> 01:44:45,000
這些

3342
01:44:45,000 --> 01:44:47,000
就一次抽出來

3343
01:44:47,000 --> 01:44:49,000
然後往服務端發一個

3344
01:44:49,000 --> 01:44:50,000
請求就可以解決

3345
01:44:50,000 --> 01:44:51,000
包括它會包進去

3346
01:44:51,000 --> 01:44:52,000
做好剛講的那個 Batchen

3347
01:44:52,000 --> 01:44:53,000
然後這個

3348
01:44:53,000 --> 01:44:55,000
請求打包

3349
01:44:55,000 --> 01:44:56,000
包括哪些是

3350
01:44:56,000 --> 01:44:57,000
可以重用的請求

3351
01:44:57,000 --> 01:44:58,000
就可以不用發送

3352
01:44:58,000 --> 01:45:00,000
包括那個本地的這個緩存

3353
01:45:00,000 --> 01:45:01,000
它都給你解決了

3354
01:45:01,000 --> 01:45:02,000
但是我覺得

3355
01:45:02,000 --> 01:45:03,000
始終是

3356
01:45:03,000 --> 01:45:04,000
反而就問題在

3357
01:45:04,000 --> 01:45:05,000
在服務端那邊

3358
01:45:05,000 --> 01:45:06,000
你什麼有辦法

3359
01:45:06,000 --> 01:45:07,000
因為它最終

3360
01:45:07,000 --> 01:45:08,000
它只會給你一個 GraphQL 的

3361
01:45:08,000 --> 01:45:09,000
那個叫什麼

3362
01:45:09,000 --> 01:45:11,000
Possure

3363
01:45:11,000 --> 01:45:12,000
它會給你一個語法數

3364
01:45:12,000 --> 01:45:13,000
但你怎麼去

3365
01:45:13,000 --> 01:45:14,000
滿足

3366
01:45:14,000 --> 01:45:16,000
它每一個 GraphQL 寫的

3367
01:45:16,000 --> 01:45:17,000
這麼一個查詢

3368
01:45:17,000 --> 01:45:19,000
你還是要挺廢腦筋的

3369
01:45:19,000 --> 01:45:20,000
而且我覺得

3370
01:45:20,000 --> 01:45:21,000
這不是一個

3371
01:45:21,000 --> 01:45:23,000
小企業或者是個人

3372
01:45:23,000 --> 01:45:25,000
能夠很輕易做到的事情吧

3373
01:45:25,000 --> 01:45:26,000
對

3374
01:45:26,000 --> 01:45:28,000
我很期待看到有人

3375
01:45:28,000 --> 01:45:29,000
做一個

3376
01:45:29,000 --> 01:45:31,000
Res 4 API 的 Dopter

3377
01:45:31,000 --> 01:45:33,000
因為雖然說

3378
01:45:33,000 --> 01:45:34,000
他們兩者的那個

3379
01:45:34,000 --> 01:45:35,000
概念上有區別

3380
01:45:35,000 --> 01:45:36,000
但是實際上

3381
01:45:36,000 --> 01:45:37,000
最終

3382
01:45:37,000 --> 01:45:39,000
GraphQL 和 Res 4

3383
01:45:39,000 --> 01:45:41,000
都是訪問數據的一個方式

3384
01:45:41,000 --> 01:45:42,000
所以說他們

3385
01:45:42,000 --> 01:45:43,000
他們兩之間

3386
01:45:43,000 --> 01:45:45,000
是有可以 Map 的地方的

3387
01:45:45,000 --> 01:45:46,000
所以如果說

3388
01:45:46,000 --> 01:45:47,000
有人能做一個

3389
01:45:47,000 --> 01:45:49,000
Velatile Realms

3390
01:45:49,000 --> 01:45:50,000
Rules Apps

3391
01:45:50,000 --> 01:45:51,000
你一定可以

3392
01:45:51,000 --> 01:45:53,000
有人做一個 Rules GraphQL

3393
01:45:53,000 --> 01:45:55,000
然後一個 Gin

3394
01:45:55,000 --> 01:45:56,000
你把這個加上之後

3395
01:45:56,000 --> 01:45:58,000
那個他的那個 Res 4 API

3396
01:45:58,000 --> 01:45:59,000
就可以通過這個 Dopter

3397
01:45:59,000 --> 01:46:02,000
來實現 GraphQL

3398
01:46:02,000 --> 01:46:03,000
我覺得對

3399
01:46:03,000 --> 01:46:04,000
這個可能在性能上

3400
01:46:04,000 --> 01:46:05,000
會有一些損失

3401
01:46:05,000 --> 01:46:06,000
然後也不是

3402
01:46:06,000 --> 01:46:07,000
說直接你實際的 GraphQL

3403
01:46:07,000 --> 01:46:08,000
但是對於

3404
01:46:08,000 --> 01:46:09,000
吹廣這個技術

3405
01:46:09,000 --> 01:46:10,000
你應用這個技術

3406
01:46:10,000 --> 01:46:11,000
是非常好處的

3407
01:46:11,000 --> 01:46:13,000
因為你能做一個過度方案

3408
01:46:13,000 --> 01:46:14,000
對

3409
01:46:14,000 --> 01:46:15,000
對做一個過度方案

3410
01:46:15,000 --> 01:46:16,000
應該是挺好的對嗎

3411
01:46:16,000 --> 01:46:17,000
所以我就還是在想

3412
01:46:17,000 --> 01:46:19,000
因為之前在支援的時候

3413
01:46:19,000 --> 01:46:21,000
我的很大的一部分工作

3414
01:46:21,000 --> 01:46:22,000
就是在

3415
01:46:22,000 --> 01:46:23,000
琢磨這些

3416
01:46:23,000 --> 01:46:24,000
無期八糟的

3417
01:46:24,000 --> 01:46:25,000
有的沒的圖的結構嘛

3418
01:46:25,000 --> 01:46:26,000
那其實我

3419
01:46:26,000 --> 01:46:28,000
後來的一個體驗

3420
01:46:28,000 --> 01:46:29,000
就是說

3421
01:46:29,000 --> 01:46:30,000
其實真的是蠻難的

3422
01:46:30,000 --> 01:46:31,000
就是做了一個

3423
01:46:31,000 --> 01:46:32,000
普通的團隊

3424
01:46:32,000 --> 01:46:33,000
然後你會想很多這種

3425
01:46:33,000 --> 01:46:34,000
所以的外避用

3426
01:46:34,000 --> 01:46:35,000
它都是一個什麼

3427
01:46:35,000 --> 01:46:36,000
Micycle

3428
01:46:36,000 --> 01:46:37,000
一個後台

3429
01:46:37,000 --> 01:46:38,000
然後前面

3430
01:46:38,000 --> 01:46:39,000
GraphQL

3431
01:46:39,000 --> 01:46:40,000
一個 epi 層

3432
01:46:40,000 --> 01:46:41,000
它是在加幾個

3433
01:46:41,000 --> 01:46:42,000
radis 的這種

3434
01:46:42,000 --> 01:46:43,000
叫什麼

3435
01:46:43,000 --> 01:46:45,000
就是緩衝層嘛

3436
01:46:45,000 --> 01:46:46,000
然後就可以

3437
01:46:46,000 --> 01:46:47,000
它就可以滿足

3438
01:46:47,000 --> 01:46:48,000
一個中型網站的應用了嘛

3439
01:46:48,000 --> 01:46:49,000
但是

3440
01:46:49,000 --> 01:46:51,000
你要實現像

3441
01:46:51,000 --> 01:46:52,000
GraphQL 那麼靈活

3442
01:46:52,000 --> 01:46:53,000
多別的查詢

3443
01:46:53,000 --> 01:46:55,000
而且要達到那種

3444
01:46:55,000 --> 01:46:57,000
那種好用程度

3445
01:46:57,000 --> 01:46:58,000
你知道是要後台

3446
01:46:58,000 --> 01:46:59,000
要做很多工作

3447
01:46:59,000 --> 01:47:00,000
對

3448
01:47:00,000 --> 01:47:01,000
能夠實現這個 Graph 的結構的

3449
01:47:01,000 --> 01:47:03,000
就這個 GraphQL 出現

3450
01:47:03,000 --> 01:47:04,000
讓我發現

3451
01:47:04,000 --> 01:47:05,000
就是其實

3452
01:47:05,000 --> 01:47:07,000
這個抽象層級的需求

3453
01:47:07,000 --> 01:47:08,000
是非常明顯的

3454
01:47:08,000 --> 01:47:09,000
但是在它做了

3455
01:47:09,000 --> 01:47:11,000
在 GraphQL 出現之前

3456
01:47:11,000 --> 01:47:12,000
好像沒有人是討論它

3457
01:47:12,000 --> 01:47:13,000
有

3458
01:47:13,000 --> 01:47:14,000
有

3459
01:47:14,000 --> 01:47:15,000
是有的

3460
01:47:15,000 --> 01:47:16,000
就是但是就是說因為

3461
01:47:16,000 --> 01:47:17,000
不是我的

3462
01:47:17,000 --> 01:47:18,000
因為它不是 Facebook

3463
01:47:18,000 --> 01:47:19,000
沒有信道

3464
01:47:19,000 --> 01:47:20,000
主動的眼球

3465
01:47:20,000 --> 01:47:21,000
我覺得主要是

3466
01:47:21,000 --> 01:47:22,000
因為現在的主流

3467
01:47:22,000 --> 01:47:23,000
就是除了像 Facebook 這種巨頭

3468
01:47:23,000 --> 01:47:24,000
能夠有精力

3469
01:47:24,000 --> 01:47:25,000
或者有這個資源去

3470
01:47:25,000 --> 01:47:27,000
把它的後端

3471
01:47:27,000 --> 01:47:28,000
做成一個這種

3472
01:47:28,000 --> 01:47:30,000
這種結構的方式去查詢的話

3473
01:47:30,000 --> 01:47:31,000
其他那些中小姐

3474
01:47:31,000 --> 01:47:32,000
真的是還滿難

3475
01:47:32,000 --> 01:47:33,000
因為沒有一個現成的

3476
01:47:33,000 --> 01:47:34,000
或者說

3477
01:47:34,000 --> 01:47:35,000
被像

3478
01:47:35,000 --> 01:47:36,000
Micycle 這種級別

3479
01:47:36,000 --> 01:47:37,000
能被大眾廣泛接受

3480
01:47:37,000 --> 01:47:39,000
有好用的就是

3481
01:47:39,000 --> 01:47:40,000
圖書局庫

3482
01:47:40,000 --> 01:47:41,000
有幾個例子

3483
01:47:41,000 --> 01:47:42,000
像什麼

3484
01:47:42,000 --> 01:47:43,000
Ninu 4 J

3485
01:47:43,000 --> 01:47:44,000
Ninu 4 J

3486
01:47:44,000 --> 01:47:45,000
Ninu 4 J

3487
01:47:45,000 --> 01:47:46,000
Ninu 4 J

3488
01:47:46,000 --> 01:47:47,000
但是

3489
01:47:47,000 --> 01:47:48,000
就是你可以看到

3490
01:47:48,000 --> 01:47:49,000
成功案例很少

3491
01:47:49,000 --> 01:47:51,000
你手間一個屬於程度

3492
01:47:51,000 --> 01:47:52,000
就是它的程度

3493
01:47:52,000 --> 01:47:53,000
程度本身也不夠

3494
01:47:53,000 --> 01:47:55,000
然後大家也不太感用

3495
01:47:55,000 --> 01:47:56,000
然後這樣的話

3496
01:47:56,000 --> 01:47:57,000
就會反而導致

3497
01:47:57,000 --> 01:47:58,000
這一塊其實

3498
01:47:58,000 --> 01:47:59,000
在市場上是很弱的

3499
01:47:59,000 --> 01:48:00,000
我倒是希望說

3500
01:48:00,000 --> 01:48:01,000
這個 Relay

3501
01:48:01,000 --> 01:48:03,000
或者是 GraphQL

3502
01:48:03,000 --> 01:48:05,000
正式開源出來之後

3503
01:48:05,000 --> 01:48:07,000
大家會亦實到

3504
01:48:07,000 --> 01:48:08,000
這個的好處

3505
01:48:08,000 --> 01:48:09,000
以及對這個包括

3506
01:48:09,000 --> 01:48:11,000
前段開發的

3507
01:48:11,000 --> 01:48:13,000
難度的降低

3508
01:48:13,000 --> 01:48:14,000
然後包括

3509
01:48:14,000 --> 01:48:16,000
後段的開發的成本的降低

3510
01:48:16,000 --> 01:48:17,000
然後能夠使得

3511
01:48:17,000 --> 01:48:18,000
大家更多去思考

3512
01:48:18,000 --> 01:48:19,000
那我要不要用一下

3513
01:48:19,000 --> 01:48:20,000
這種圖

3514
01:48:20,000 --> 01:48:22,000
以圖為主要結構的

3515
01:48:22,000 --> 01:48:24,000
這種數據後台

3516
01:48:24,000 --> 01:48:25,000
對

3517
01:48:25,000 --> 01:48:26,000
對

3518
01:48:26,000 --> 01:48:27,000
就是 Facebook 對整個

3519
01:48:27,000 --> 01:48:28,000
TackStack

3520
01:48:28,000 --> 01:48:30,000
作出一個貢獻了

3521
01:48:30,000 --> 01:48:31,000
其實

3522
01:48:31,000 --> 01:48:35,000
You mentioned a

3523
01:48:35,000 --> 01:48:38,000
圖的

3524
01:48:38,000 --> 01:48:39,000
Databas

3525
01:48:39,000 --> 01:48:41,000
其實

3526
01:48:41,000 --> 01:48:42,000
I miss question

3527
01:48:42,000 --> 01:48:44,000
我並不清楚這個東西

3528
01:48:44,000 --> 01:48:45,000
它那個

3529
01:48:45,000 --> 01:48:47,000
秘名是一個

3530
01:48:47,000 --> 01:48:48,000
出於一個

3531
01:48:48,000 --> 01:48:49,000
Branding 的考慮

3532
01:48:49,000 --> 01:48:50,000
還是它真的

3533
01:48:50,000 --> 01:48:51,000
就是所謂圖

3534
01:48:51,000 --> 01:48:52,000
我沒有聽說過

3535
01:48:52,000 --> 01:48:53,000
圖 Databas

3536
01:48:53,000 --> 01:48:54,000
就是 I miss

3537
01:48:54,000 --> 01:48:55,000
沒有聽說過

3538
01:48:55,000 --> 01:48:56,000
對

3539
01:48:56,000 --> 01:48:57,000
這個是一個

3540
01:48:57,000 --> 01:48:58,000
相對於

3541
01:48:58,000 --> 01:49:00,000
沒有那麼大眾的一個應用

3542
01:49:00,000 --> 01:49:01,000
圖數據

3543
01:49:01,000 --> 01:49:02,000
我要解決的問題

3544
01:49:02,000 --> 01:49:03,000
也是蠻簡單的

3545
01:49:03,000 --> 01:49:04,000
你可以想像一個

3546
01:49:04,000 --> 01:49:05,000
普通的是

3547
01:49:05,000 --> 01:49:06,000
一個社交網路

3548
01:49:06,000 --> 01:49:07,000
只有一種

3549
01:49:07,000 --> 01:49:08,000
一種的一些的解點

3550
01:49:08,000 --> 01:49:09,000
我們就考慮

3551
01:49:09,000 --> 01:49:10,000
最簡單的一個情況

3552
01:49:10,000 --> 01:49:11,000
我們又有這個用戶

3553
01:49:11,000 --> 01:49:12,000
Youser

3554
01:49:12,000 --> 01:49:13,000
你和我

3555
01:49:13,000 --> 01:49:14,000
然後

3556
01:49:14,000 --> 01:49:15,000
圖數據過程

3557
01:49:15,000 --> 01:49:16,000
什麼

3558
01:49:16,000 --> 01:49:17,000
這個程度的解點

3559
01:49:17,000 --> 01:49:18,000
本來解點有些

3560
01:49:18,000 --> 01:49:19,000
有些什麼樣的屬性

3561
01:49:19,000 --> 01:49:20,000
比如說我做一個

3562
01:49:20,000 --> 01:49:21,000
人

3563
01:49:21,000 --> 01:49:22,000
Youser 這麼一個

3564
01:49:22,000 --> 01:49:23,000
一個解點

3565
01:49:23,000 --> 01:49:24,000
有什麼名字性別

3566
01:49:24,000 --> 01:49:25,000
年齡

3567
01:49:25,000 --> 01:49:26,000
出生日期

3568
01:49:26,000 --> 01:49:27,000
之類的一些

3569
01:49:27,000 --> 01:49:28,000
是 Actributes

3570
01:49:28,000 --> 01:49:29,000
這個是

3571
01:49:29,000 --> 01:49:30,000
這個是跟傳統的

3572
01:49:30,000 --> 01:49:31,000
包括這種

3573
01:49:31,000 --> 01:49:32,000
我們像 Micycle 的這種

3574
01:49:32,000 --> 01:49:33,000
RDBM

3575
01:49:33,000 --> 01:49:34,000
就 Relational Database

3576
01:49:34,000 --> 01:49:35,000
就是沒有大家區別了

3577
01:49:35,000 --> 01:49:36,000
就是

3578
01:49:36,000 --> 01:49:37,000
就是無非就是說

3579
01:49:37,000 --> 01:49:38,000
每一個解點

3580
01:49:38,000 --> 01:49:39,000
對於 Relational Database

3581
01:49:39,000 --> 01:49:40,000
你們的一個

3582
01:49:40,000 --> 01:49:41,000
一行

3583
01:49:41,000 --> 01:49:42,000
一個 Roll

3584
01:49:42,000 --> 01:49:43,000
然後每一個 Actribute

3585
01:49:43,000 --> 01:49:44,000
對於

3586
01:49:44,000 --> 01:49:45,000
他的傳統的

3587
01:49:45,000 --> 01:49:47,000
Relational Database

3588
01:49:47,000 --> 01:49:48,000
一個 Cow

3589
01:49:48,000 --> 01:49:49,000
對吧

3590
01:49:49,000 --> 01:49:50,000
對

3591
01:49:50,000 --> 01:49:51,000
然後

3592
01:49:51,000 --> 01:49:52,000
但是

3593
01:49:52,000 --> 01:49:53,000
一個圖數

3594
01:49:53,000 --> 01:49:55,000
這個更加重要的一點

3595
01:49:55,000 --> 01:49:56,000
其實是存儲這個

3596
01:49:56,000 --> 01:49:57,000
這個節點

3597
01:49:57,000 --> 01:49:58,000
節點之間的關係

3598
01:49:58,000 --> 01:49:59,000
表號中說我可以說

3599
01:49:59,000 --> 01:50:00,000
我可以 Friend

3600
01:50:00,000 --> 01:50:01,000
你們兩個

3601
01:50:01,000 --> 01:50:02,000
你們可以兩個這間

3602
01:50:02,000 --> 01:50:03,000
互相 Friend

3603
01:50:03,000 --> 01:50:04,000
然後你可以

3604
01:50:04,000 --> 01:50:05,000
你可以和別的人

3605
01:50:05,000 --> 01:50:06,000
也就是

3606
01:50:06,000 --> 01:50:07,000
或那個 Friend

3607
01:50:07,000 --> 01:50:08,000
這個時候的話

3608
01:50:08,000 --> 01:50:09,000
這個時候他表現出來的

3609
01:50:09,000 --> 01:50:10,000
結構

3610
01:50:10,000 --> 01:50:11,000
如果我們在傳統的

3611
01:50:11,000 --> 01:50:12,000
一個 Relational Database

3612
01:50:12,000 --> 01:50:13,000
人員去實現

3613
01:50:13,000 --> 01:50:14,000
會怎麼樣

3614
01:50:14,000 --> 01:50:15,000
會通過一個

3615
01:50:15,000 --> 01:50:16,000
因為一張表

3616
01:50:16,000 --> 01:50:17,000
來做一個

3617
01:50:17,000 --> 01:50:18,000
那個連接

3618
01:50:18,000 --> 01:50:19,000
對

3619
01:50:19,000 --> 01:50:20,000
另外不要加小孩們

3620
01:50:20,000 --> 01:50:21,000
就叫做關注的

3621
01:50:21,000 --> 01:50:22,000
對不起

3622
01:50:22,000 --> 01:50:23,000
Cutie

3623
01:50:23,000 --> 01:50:24,000
我

3624
01:50:24,000 --> 01:50:25,000
我只是做一個 Checker

3625
01:50:25,000 --> 01:50:27,000
所以謝謝你的解釋

3626
01:50:27,000 --> 01:50:28,000
但是我們還是不畫了

3627
01:50:28,000 --> 01:50:29,000
我覺得這段

3628
01:50:29,000 --> 01:50:30,000
就不用在那個

3629
01:50:30,000 --> 01:50:31,000
Portcast

3630
01:50:31,000 --> 01:50:32,000
沒錯可以可以可以

3631
01:50:32,000 --> 01:50:33,000
可以放進來接著解釋完

3632
01:50:33,000 --> 01:50:34,000
很多人不理解

3633
01:50:34,000 --> 01:50:35,000
就聽眾裡面

3634
01:50:35,000 --> 01:50:36,000
可能不是很熟悉這個概念

3635
01:50:36,000 --> 01:50:37,000
因為這個確實

3636
01:50:37,000 --> 01:50:38,000
在工業中

3637
01:50:38,000 --> 01:50:39,000
我有用的不多了

3638
01:50:39,000 --> 01:50:40,000
對

3639
01:50:40,000 --> 01:50:41,000
因為對我來講的話

3640
01:50:41,000 --> 01:50:42,000
我覺得就是說

3641
01:50:42,000 --> 01:50:43,000
GraphCue-outs

3642
01:50:43,000 --> 01:50:44,000
Graph 只是一個 branding

3643
01:50:44,000 --> 01:50:45,000
而也並不是

3644
01:50:45,000 --> 01:50:47,000
並不是真正在說

3645
01:50:47,000 --> 01:50:48,000
他真的是

3646
01:50:48,000 --> 01:50:49,000
就說 GraphCue 本身

3647
01:50:49,000 --> 01:50:50,000
他真的是要有

3648
01:50:50,000 --> 01:50:51,000
這麼一種

3649
01:50:51,000 --> 01:50:52,000
對

3650
01:50:52,000 --> 01:50:53,000
對

3651
01:50:53,000 --> 01:50:54,000
後段實施

3652
01:50:54,000 --> 01:50:55,000
你才可以做到

3653
01:50:55,000 --> 01:50:56,000
他那麼靈活的查詢

3654
01:50:56,000 --> 01:50:57,000
不然的話

3655
01:50:57,000 --> 01:50:58,000
你可以做

3656
01:50:58,000 --> 01:50:59,000
你可以去用

3657
01:50:59,000 --> 01:51:00,000
什麼像 Adapter 的方式

3658
01:51:00,000 --> 01:51:01,000
去把

3659
01:51:01,000 --> 01:51:02,000
GraphCue 的查詢

3660
01:51:02,000 --> 01:51:03,000
轉換成對應的

3661
01:51:03,000 --> 01:51:04,000
Rest 查詢

3662
01:51:04,000 --> 01:51:05,000
但是這樣的效率非常低

3663
01:51:05,000 --> 01:51:07,000
因為這個整個

3664
01:51:07,000 --> 01:51:08,000
你的這個後段

3665
01:51:08,000 --> 01:51:09,000
都數據庫

3666
01:51:09,000 --> 01:51:10,000
的組織的結構

3667
01:51:10,000 --> 01:51:11,000
就不是按照

3668
01:51:11,000 --> 01:51:12,000
那種圖的

3669
01:51:12,000 --> 01:51:13,000
查詢的方式

3670
01:51:13,000 --> 01:51:14,000
來查詢的

3671
01:51:14,000 --> 01:51:15,000
因為圖裡面查詢

3672
01:51:15,000 --> 01:51:16,000
最常見的什麼

3673
01:51:16,000 --> 01:51:17,000
就是

3674
01:51:17,000 --> 01:51:18,000
便利嘛

3675
01:51:18,000 --> 01:51:19,000
節點便利嘛

3676
01:51:19,000 --> 01:51:20,000
對吧

3677
01:51:20,000 --> 01:51:21,000
這個在

3678
01:51:21,000 --> 01:51:22,000
你的 RTB

3679
01:51:22,000 --> 01:51:23,000
這個在

3680
01:51:23,000 --> 01:51:24,000
Besides 你

3681
01:51:24,000 --> 01:51:25,000
這個性能是多死的

3682
01:51:25,000 --> 01:51:26,000
你想一下

3683
01:51:26,000 --> 01:51:27,000
假設你

3684
01:51:27,000 --> 01:51:29,000
在一個社交網狀

3685
01:51:29,000 --> 01:51:30,000
那個圖裡面

3686
01:51:30,000 --> 01:51:31,000
你要從某個節點

3687
01:51:31,000 --> 01:51:32,000
為重心查詢

3688
01:51:32,000 --> 01:51:33,000
他的好友的話

3689
01:51:33,000 --> 01:51:34,000
你在一個傳統的

3690
01:51:34,000 --> 01:51:35,000
ReturnBeside 裡面

3691
01:51:35,000 --> 01:51:36,000
你要去

3692
01:51:36,000 --> 01:51:37,000
要查好多張表

3693
01:51:37,000 --> 01:51:38,000
不要

3694
01:51:38,000 --> 01:51:39,000
你也查

3695
01:51:39,000 --> 01:51:40,000
三個圍堵的好友

3696
01:51:40,000 --> 01:51:41,000
就是三

3697
01:51:41,000 --> 01:51:43,000
就三度分割的好友的話

3698
01:51:43,000 --> 01:51:44,000
你要用那個傳統的

3699
01:51:44,000 --> 01:51:45,000
ReturnBeside 的

3700
01:51:45,000 --> 01:51:46,000
Besides 就是非常困難

3701
01:51:46,000 --> 01:51:47,000
所以

3702
01:51:47,000 --> 01:51:48,000
所以

3703
01:51:48,000 --> 01:51:49,000
我就是在想

3704
01:51:49,000 --> 01:51:50,000
就是說

3705
01:51:50,000 --> 01:51:51,000
其實

3706
01:51:51,000 --> 01:51:52,000
現在

3707
01:51:52,000 --> 01:51:54,000
我這麼多的社交產號的應用

3708
01:51:54,000 --> 01:51:55,000
反而是沒有一個

3709
01:51:55,000 --> 01:51:56,000
基於

3710
01:51:56,000 --> 01:51:57,000
能夠很好滿足

3711
01:51:57,000 --> 01:51:58,000
社交查詢

3712
01:51:58,000 --> 01:51:59,000
那麼一種

3713
01:51:59,000 --> 01:52:00,000
數據存儲的隱形

3714
01:52:00,000 --> 01:52:01,000
能夠

3715
01:52:01,000 --> 01:52:02,000
大規模的方便的使用

3716
01:52:02,000 --> 01:52:04,000
真的是滿悲哀的一個現狀

3717
01:52:04,000 --> 01:52:06,000
其實也是挺奇怪的

3718
01:52:06,000 --> 01:52:08,000
你又還是

3719
01:52:08,000 --> 01:52:09,000
對

3720
01:52:09,000 --> 01:52:10,000
確實挺難的

3721
01:52:10,000 --> 01:52:11,000
就

3722
01:52:11,000 --> 01:52:12,000
就

3723
01:52:12,000 --> 01:52:13,000
比如說我們傳統的

3724
01:52:13,000 --> 01:52:14,000
做 ReturnBeside

3725
01:52:14,000 --> 01:52:15,000
你可以性能不夠

3726
01:52:15,000 --> 01:52:16,000
你可以做簡單的

3727
01:52:16,000 --> 01:52:17,000
什麼 Sharling

3728
01:52:17,000 --> 01:52:18,000
就分割嘛

3729
01:52:18,000 --> 01:52:19,000
按照這個

3730
01:52:19,000 --> 01:52:20,000
按照這個 K 的

3731
01:52:20,000 --> 01:52:21,000
這個

3732
01:52:21,000 --> 01:52:22,000
分割嘛

3733
01:52:22,000 --> 01:52:24,000
但是你怎麼就分割一個圖呢

3734
01:52:24,000 --> 01:52:25,000
就很難的一件事情

3735
01:52:25,000 --> 01:52:26,000
對

3736
01:52:26,000 --> 01:52:27,000
所以

3737
01:52:27,000 --> 01:52:28,000
今天還是有很多

3738
01:52:28,000 --> 01:52:29,000
這種非常 Hartcoin

3739
01:52:29,000 --> 01:52:30,000
Kamer.Science 的東西

3740
01:52:30,000 --> 01:52:32,000
在裡面要解決

3741
01:52:32,000 --> 01:52:33,000
而是一面上

3742
01:52:33,000 --> 01:52:34,000
現有的解決方案

3743
01:52:34,000 --> 01:52:35,000
都給人一裝

3744
01:52:35,000 --> 01:52:37,000
信心不足的感情

3745
01:52:39,000 --> 01:52:40,000
對

3746
01:52:40,000 --> 01:52:41,000
其實

3747
01:52:41,000 --> 01:52:42,000
這代表

3748
01:52:42,000 --> 01:52:43,000
滿擔憂的

3749
01:52:43,000 --> 01:52:44,000
就是說

3750
01:52:44,000 --> 01:52:45,000
如果這個解決不好

3751
01:52:45,000 --> 01:52:46,000
GraphK 這種東西

3752
01:52:46,000 --> 01:52:47,000
就真的是

3753
01:52:47,000 --> 01:52:48,000
只能

3754
01:52:48,000 --> 01:52:49,000
舉行 U 向 Facebook

3755
01:52:49,000 --> 01:52:50,000
像 Google 這種龐大的企業

3756
01:52:50,000 --> 01:52:51,000
它能夠有這個資源

3757
01:52:51,000 --> 01:52:53,000
或者這個能力去實現自己的

3758
01:52:53,000 --> 01:52:54,000
或者維護自己的

3759
01:52:54,000 --> 01:52:55,000
這麼一套

3760
01:52:55,000 --> 01:52:56,000
基於圖的

3761
01:52:56,000 --> 01:52:57,000
或者是一圖

3762
01:52:57,000 --> 01:52:58,000
結構為導向的

3763
01:52:58,000 --> 01:52:59,000
這麼一個

3764
01:52:59,000 --> 01:53:00,000
後台系統

3765
01:53:00,000 --> 01:53:01,000
否則其他人

3766
01:53:01,000 --> 01:53:02,000
還是只能

3767
01:53:02,000 --> 01:53:03,000
很熱鬧喝的

3768
01:53:03,000 --> 01:53:04,000
GraphK 的 Rest

3769
01:53:04,000 --> 01:53:05,000
對

3770
01:53:05,000 --> 01:53:08,000
那一個什麼

3771
01:53:08,000 --> 01:53:09,000
那為了你說一下

3772
01:53:09,000 --> 01:53:10,000
就整個

3773
01:53:10,000 --> 01:53:11,000
就說

3774
01:53:11,000 --> 01:53:12,000
剛剛我們講的

3775
01:53:12,000 --> 01:53:13,000
RactSharm 官

3776
01:53:13,000 --> 01:53:14,000
包括你在會上看的一些東西

3777
01:53:14,000 --> 01:53:15,000
但是你說

3778
01:53:15,000 --> 01:53:16,000
整個來講

3779
01:53:16,000 --> 01:53:17,000
你對這個會

3780
01:53:17,000 --> 01:53:18,000
本身是什麼樣的一個感受

3781
01:53:21,000 --> 01:53:22,000
這是我

3782
01:53:22,000 --> 01:53:23,000
所去過的

3783
01:53:23,000 --> 01:53:24,000
比較好的一個會議之一了

3784
01:53:24,000 --> 01:53:25,000
因為

3785
01:53:25,000 --> 01:53:26,000
整個的

3786
01:53:26,000 --> 01:53:27,000
所有的 Speech

3787
01:53:27,000 --> 01:53:28,000
就非常的有意義

3788
01:53:28,000 --> 01:53:29,000
非常

3789
01:53:29,000 --> 01:53:30,000
能覺得

3790
01:53:30,000 --> 01:53:31,000
從中能夠學到東西

3791
01:53:31,000 --> 01:53:32,000
都不是在

3792
01:53:32,000 --> 01:53:33,000
也

3793
01:53:33,000 --> 01:53:34,000
都非常有意義

3794
01:53:34,000 --> 01:53:35,000
非常 HotcoreCS

3795
01:53:35,000 --> 01:53:36,000
我覺得這點

3796
01:53:36,000 --> 01:53:37,000
是非常難得的

3797
01:53:37,000 --> 01:53:39,000
有了那個會的

3798
01:53:39,000 --> 01:53:40,000
總之

3799
01:53:40,000 --> 01:53:41,000
肯定做了

3800
01:53:41,000 --> 01:53:42,000
很好的工作

3801
01:53:42,000 --> 01:53:44,000
來選取這些

3802
01:53:44,000 --> 01:53:45,000
這些演講者

3803
01:53:45,000 --> 01:53:46,000
和演講本身

3804
01:53:46,000 --> 01:53:48,000
我們

3805
01:53:48,000 --> 01:53:49,000
我們有非常多的

3806
01:53:49,000 --> 01:53:50,000
那個 Social 的機會

3807
01:53:50,000 --> 01:53:51,000
在其中

3808
01:53:51,000 --> 01:53:52,000
也遇到了非常非常多人

3809
01:53:52,000 --> 01:53:53,000
RactSharm

3810
01:53:53,000 --> 01:53:54,000
真的是被運用到

3811
01:53:54,000 --> 01:53:56,000
各種各方各面

3812
01:53:56,000 --> 01:53:57,000
很多你想不到的

3813
01:53:57,000 --> 01:53:59,000
一些

3814
01:53:59,000 --> 01:54:00,000
Application

3815
01:54:00,000 --> 01:54:01,000
都在使用 Ract

3816
01:54:01,000 --> 01:54:02,000
都在或者在

3817
01:54:02,000 --> 01:54:03,000
Collution Rack

3818
01:54:03,000 --> 01:54:06,000
非常的激動人心的知識

3819
01:54:06,000 --> 01:54:07,000
可能會看到這麼多

3820
01:54:07,000 --> 01:54:08,000
實際的運用

3821
01:54:08,000 --> 01:54:09,000
這麼多

3822
01:54:09,000 --> 01:54:10,000
積極主動

3823
01:54:10,000 --> 01:54:11,000
來參與

3824
01:54:11,000 --> 01:54:13,000
這個社區的人

3825
01:54:13,000 --> 01:54:14,000
整體來說

3826
01:54:14,000 --> 01:54:15,000
我覺得是一個

3827
01:54:15,000 --> 01:54:16,000
非常非常好

3828
01:54:16,000 --> 01:54:18,000
一個氣氛

3829
01:54:18,000 --> 01:54:19,000
大家都

3830
01:54:19,000 --> 01:54:20,000
非常地對

3831
01:54:20,000 --> 01:54:21,000
RactSharm

3832
01:54:21,000 --> 01:54:23,000
都非常樂觀

3833
01:54:23,000 --> 01:54:25,000
我也很高興

3834
01:54:25,000 --> 01:54:27,000
看到 Facebook 對整個

3835
01:54:27,000 --> 01:54:29,000
會議的知識

3836
01:54:29,000 --> 01:54:30,000
跟對整個

3837
01:54:30,000 --> 01:54:32,000
Ract 技術的知識

3838
01:54:32,000 --> 01:54:34,000
Afterall

3839
01:54:34,000 --> 01:54:35,000
我也覺得

3840
01:54:35,000 --> 01:54:36,000
非常開心

3841
01:54:36,000 --> 01:54:38,000
能夠得到 Ract Native

3842
01:54:38,000 --> 01:54:39,000
的一個 Preview

3843
01:54:39,000 --> 01:54:41,000
我有給我的同事演

3844
01:54:41,000 --> 01:54:42,000
是

3845
01:54:42,000 --> 01:54:43,000
對我們做

3846
01:54:43,000 --> 01:54:44,000
接下來

3847
01:54:44,000 --> 01:54:45,000
一些

3848
01:54:45,000 --> 01:54:46,000
Tenology 選項

3849
01:54:46,000 --> 01:54:47,000
都是非常棒出的

3850
01:54:47,000 --> 01:54:48,000
所以各位

3851
01:54:48,000 --> 01:54:49,000
我們過程司也需要

3852
01:54:49,000 --> 01:54:50,000
出一個

3853
01:54:50,000 --> 01:54:51,000
Mobile

3854
01:54:51,000 --> 01:54:52,000
領域的客戶專門

3855
01:54:52,000 --> 01:54:53,000
我們一直

3856
01:54:53,000 --> 01:54:55,000
有 Mobile 的客戶專門

3857
01:54:55,000 --> 01:54:56,000
我們有 Iose

3858
01:54:56,000 --> 01:54:57,000
跟 Android 的客戶專門

3859
01:54:57,000 --> 01:54:58,000
然後

3860
01:54:58,000 --> 01:54:59,000
Well

3861
01:54:59,000 --> 01:55:00,000
Facebook

3862
01:55:00,000 --> 01:55:01,000
Future

3863
01:55:01,000 --> 01:55:02,000
肯定不是 Ract Native

3864
01:55:02,000 --> 01:55:03,000
對對對

3865
01:55:03,000 --> 01:55:04,000
但是

3866
01:55:04,000 --> 01:55:05,000
最於那個技術的選心

3867
01:55:05,000 --> 01:55:06,000
觀察可以

3868
01:55:06,000 --> 01:55:07,000
技術發展來說

3869
01:55:07,000 --> 01:55:08,000
我們肯定

3870
01:55:08,000 --> 01:55:09,000
現在是

3871
01:55:09,000 --> 01:55:10,000
把它是

3872
01:55:10,000 --> 01:55:11,000
擺在一個

3873
01:55:11,000 --> 01:55:12,000
比較重要的位置

3874
01:55:12,000 --> 01:55:13,000
對

3875
01:55:13,000 --> 01:55:14,000
OK

3876
01:55:14,000 --> 01:55:15,000
那行嗎

3877
01:55:15,000 --> 01:55:16,000
今天我們非常

3878
01:55:16,000 --> 01:55:17,000
高興邀請到

3879
01:55:17,000 --> 01:55:18,000
為了來

3880
01:55:18,000 --> 01:55:19,000
我們討論 Ract

3881
01:55:19,000 --> 01:55:21,000
一系列相關的東西

3882
01:55:21,000 --> 01:55:23,000
然後

3883
01:55:23,000 --> 01:55:25,000
今天的節目就到此為止

3884
01:55:25,000 --> 01:55:26,000
謝謝大家

3885
01:55:26,000 --> 01:55:27,000
謝謝大家

3886
01:55:27,000 --> 01:55:29,000
謝謝大家

3887
01:55:29,000 --> 01:55:30,000
下次再見

3888
01:55:30,000 --> 01:55:32,000
我還有念那個嗎

3889
01:55:32,000 --> 01:55:34,000
你念吧

3890
01:55:34,000 --> 01:55:35,000
OK

3891
01:55:35,000 --> 01:55:36,000
感謝大家收聽

3892
01:55:36,000 --> 01:55:37,000
那份文化

3893
01:55:37,000 --> 01:55:38,000
也歡迎大家收聽

3894
01:55:38,000 --> 01:55:39,000
IPN 奇下的

3895
01:55:39,000 --> 01:55:40,000
其他無兩 Podcast

3896
01:55:40,000 --> 01:55:42,000
包括

3897
01:55:42,000 --> 01:55:43,000
技術主題節目

3898
01:55:43,000 --> 01:55:44,000
ID 公論

3899
01:55:44,000 --> 01:55:45,000
醫療主題節目

3900
01:55:45,000 --> 01:55:46,000
太一來了

3901
01:55:46,000 --> 01:55:47,000
美食節目

3902
01:55:47,000 --> 01:55:48,000
未知道

3903
01:55:48,000 --> 01:55:49,000
以及藝術類節目

3904
01:55:49,000 --> 01:55:50,000
流行通信

3905
01:55:50,000 --> 01:55:51,000
最後還有

3906
01:55:51,000 --> 01:55:52,000
不知道

3907
01:55:52,000 --> 01:55:53,000
是在播什麼的

3908
01:55:53,000 --> 01:55:54,000
無主題節目

3909
01:55:54,000 --> 01:55:55,000
無次元

3910
01:55:55,000 --> 01:55:56,000
感謝大家的收聽

