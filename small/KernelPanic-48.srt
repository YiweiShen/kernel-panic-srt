1
00:00:00,000 --> 00:00:19,000
【音乐】

2
00:00:19,000 --> 00:00:22,000
大家好 今天是 7 月 25 号

3
00:00:22,000 --> 00:00:26,000
现在您听的是自弹自唱的第 52 期

4
00:00:26,000 --> 00:00:29,000
同时也是那个共房的第 48 期

5
00:00:29,000 --> 00:00:35,000
这也是我们自弹自唱和内合恐慌创台的自弹自唱节目的第 5 期

6
00:00:35,000 --> 00:00:40,000
我们自弹自唱是全球首家用华语制作的自体排音主题播客节目

7
00:00:40,000 --> 00:00:42,000
我是主播文川西班东英剧 Eric

8
00:00:42,000 --> 00:00:45,000
我是主播黄浦江民新君云 前君云

9
00:00:45,000 --> 00:00:51,000
内合恐慌是 IPM podcast 的网络旗下的 IT 技术主题娱乐节目

10
00:00:51,000 --> 00:00:53,000
我号称 Hotcore 但是也没有干货

11
00:00:53,000 --> 00:00:55,000
想听人听不想听人就别听

12
00:00:55,000 --> 00:00:58,000
我是主播吴涛

13
00:00:58,000 --> 00:00:59,000
我是 Rail

14
00:00:59,000 --> 00:01:03,000
你说我们这个节目串台都已经串了第 5 期了

15
00:01:03,000 --> 00:01:07,000
等到上次 5 月底才第一次 4 个人一起在同一个空间见面是吧

16
00:01:07,000 --> 00:01:09,000
历史性的会晤

17
00:01:09,000 --> 00:01:11,000
对我们 4 个人没有合照

18
00:01:11,000 --> 00:01:14,000
那年活动来了好多播客主播吧

19
00:01:14,000 --> 00:01:17,000
数来应该有差不多小于 10 个

20
00:01:17,000 --> 00:01:21,000
你们后来就背着我们直接去喝酒了

21
00:01:21,000 --> 00:01:23,000
你们不是也去喝酒了吗

22
00:01:23,000 --> 00:01:25,000
你们不是还要去打扫场地吗

23
00:01:25,000 --> 00:01:26,000
那没有办法呀

24
00:01:27,000 --> 00:01:28,000
对呀

25
00:01:28,000 --> 00:01:30,000
虽然说是 TIB 时周年活动节目

26
00:01:30,000 --> 00:01:37,000
搞得好像是变成国内 IPM 和各台电台主播的一个小聚会了

27
00:01:37,000 --> 00:01:39,000
小众播客网络

28
00:01:39,000 --> 00:01:43,000
而且其实剩下我跟 Eric 在东京见过

29
00:01:43,000 --> 00:01:46,000
然后我跟 Rail 见过很久了

30
00:01:46,000 --> 00:01:51,000
Eric 跟曾宇之前也在上海见过很多次

31
00:01:51,000 --> 00:01:52,000
对

32
00:01:52,000 --> 00:01:54,000
我跟 Rail 也见过一次

33
00:01:54,000 --> 00:01:57,000
Rail 在深圳也见过一两次

34
00:01:57,000 --> 00:01:58,000
两次

35
00:01:58,000 --> 00:01:59,000
对

36
00:01:59,000 --> 00:02:03,000
但真正所有人在一起见这是第一次

37
00:02:03,000 --> 00:02:05,000
还挺难得的

38
00:02:05,000 --> 00:02:09,000
我们可以在 shownotes 发一下上次活动的剧本

39
00:02:09,000 --> 00:02:12,000
就是什么 4 个人都在的照片应该有吧

40
00:02:12,000 --> 00:02:13,000
没有

41
00:02:13,000 --> 00:02:15,000
好像咱们 4 个没有合影

42
00:02:15,000 --> 00:02:17,000
Oh my god

43
00:02:17,000 --> 00:02:18,000
这么惨

44
00:02:18,000 --> 00:02:20,000
把无套批上去

45
00:02:20,000 --> 00:02:21,000
不是

46
00:02:21,000 --> 00:02:25,000
Rail 也没有跟其他 3 个人合过影

47
00:02:25,000 --> 00:02:28,000
Rail 也没有跟你们两个合过影

48
00:02:28,000 --> 00:02:30,000
肯定有照片

49
00:02:30,000 --> 00:02:32,000
同时有我和 Eric 和 Rail 的

50
00:02:32,000 --> 00:02:34,000
我觉得有一张

51
00:02:34,000 --> 00:02:36,000
有一张有各种主播在一起

52
00:02:36,000 --> 00:02:40,000
有一张是你们两个在内间

53
00:02:40,000 --> 00:02:42,000
那个是一个

54
00:02:42,000 --> 00:02:43,000
互动节目

55
00:02:43,000 --> 00:02:44,000
然后 Rail 站在外面的照片

56
00:02:44,000 --> 00:02:45,000
对

57
00:02:45,000 --> 00:02:46,000
这个也有

58
00:02:46,000 --> 00:02:47,000
互动结束的时候

59
00:02:47,000 --> 00:02:50,000
我跟 Eric 和 Jerrny 都有合影

60
00:02:50,000 --> 00:02:52,000
但是那个时候无套不知道去哪去了

61
00:02:52,000 --> 00:02:53,000
我就喝酒

62
00:02:53,000 --> 00:02:54,000
就泡妹子了

63
00:02:54,000 --> 00:02:55,000
无套喝花子

64
00:02:55,000 --> 00:02:56,000
泡屁屁

65
00:03:02,000 --> 00:03:04,000
首先跟大家讲一讲

66
00:03:04,000 --> 00:03:05,000
其实这也不算广告了

67
00:03:05,000 --> 00:03:07,000
我们自己 type school

68
00:03:07,000 --> 00:03:09,000
7 月份的课程已经结束了

69
00:03:09,000 --> 00:03:12,000
7 月份西文的自体设计课程

70
00:03:12,000 --> 00:03:13,000
大家应该

71
00:03:13,000 --> 00:03:14,000
虽然很累

72
00:03:14,000 --> 00:03:15,000
很辛苦

73
00:03:15,000 --> 00:03:18,000
但是估计大家收获也蛮大的

74
00:03:18,000 --> 00:03:19,000
一共有几天了

75
00:03:19,000 --> 00:03:21,000
两个礼拜呀

76
00:03:21,000 --> 00:03:24,000
我也过去跟去

77
00:03:24,000 --> 00:03:26,000
去和大家

78
00:03:26,000 --> 00:03:27,000
凑了一会儿热闹

79
00:03:27,000 --> 00:03:29,000
看我们的格二格老师

80
00:03:29,000 --> 00:03:31,000
给大家讲 glyphs

81
00:03:31,000 --> 00:03:32,000
挺有意思的

82
00:03:32,000 --> 00:03:33,000
对了

83
00:03:33,000 --> 00:03:34,000
我一直很好奇

84
00:03:34,000 --> 00:03:36,000
Gelge 她是一个自体设计师

85
00:03:36,000 --> 00:03:37,000
对

86
00:03:37,000 --> 00:03:38,000
她自己设计师

87
00:03:38,000 --> 00:03:40,000
她自己设计自己

88
00:03:40,000 --> 00:03:43,000
但是她有一些计算机开发的基础

89
00:03:43,000 --> 00:03:45,000
然后她做出 glyphs

90
00:03:45,000 --> 00:03:46,000
几乎现在就

91
00:03:46,000 --> 00:03:48,000
经过全职的在做 glyphs

92
00:03:48,000 --> 00:03:49,000
这个软件了变成

93
00:03:49,000 --> 00:03:51,000
所以她应该是一个

94
00:03:51,000 --> 00:03:53,000
计算机科学出身的人吗

95
00:03:53,000 --> 00:03:54,000
就是她是一个

96
00:03:54,000 --> 00:03:56,000
她是设计师出身

97
00:03:56,000 --> 00:03:58,000
那她竟然能写这么复杂的

98
00:03:58,000 --> 00:03:59,000
我觉得 glyphs

99
00:03:59,000 --> 00:04:01,000
已经是一个非常复杂的软件了

100
00:04:01,000 --> 00:04:02,000
对

101
00:04:02,000 --> 00:04:05,000
非常令人惊讶

102
00:04:05,000 --> 00:04:06,000
对

103
00:04:06,000 --> 00:04:07,000
好吧

104
00:04:07,000 --> 00:04:08,000
设计系需要这样的人才

105
00:04:08,000 --> 00:04:10,000
所以我也希望有更多的设计师

106
00:04:10,000 --> 00:04:12,000
来听我们的自弹自串

107
00:04:12,000 --> 00:04:14,000
好吧

108
00:04:14,000 --> 00:04:17,000
然后就有很多朋友问

109
00:04:17,000 --> 00:04:19,000
因为这次是讲西文

110
00:04:19,000 --> 00:04:21,000
那有没有学中文的

111
00:04:21,000 --> 00:04:22,000
自体设计课程

112
00:04:22,000 --> 00:04:23,000
其实

113
00:04:23,000 --> 00:04:25,000
可能大家在微信上面

114
00:04:25,000 --> 00:04:26,000
也看到消息了

115
00:04:26,000 --> 00:04:28,000
我们在 8 月 4 号到 9 号

116
00:04:28,000 --> 00:04:29,000
会有这样一个课程

117
00:04:29,000 --> 00:04:31,000
叫 type school 的中文自体设计课

118
00:04:31,000 --> 00:04:32,000
而且这次

119
00:04:32,000 --> 00:04:33,000
不是在上海

120
00:04:33,000 --> 00:04:34,000
是在北京

121
00:04:34,000 --> 00:04:36,000
然后我们请到了老师

122
00:04:36,000 --> 00:04:38,000
就有翻证自酷的

123
00:04:38,000 --> 00:04:39,000
次位设计师

124
00:04:39,000 --> 00:04:41,000
包括像球影

125
00:04:41,000 --> 00:04:43,000
球影先生这样

126
00:04:43,000 --> 00:04:44,000
经验非常丰富的

127
00:04:44,000 --> 00:04:46,000
设计过很多中文自体

128
00:04:46,000 --> 00:04:47,000
设计师

129
00:04:47,000 --> 00:04:48,000
可能大家都知道

130
00:04:48,000 --> 00:04:49,000
他最著名的自体

131
00:04:49,000 --> 00:04:51,000
就是 youhey 嘛

132
00:04:51,000 --> 00:04:53,000
然后 type school

133
00:04:53,000 --> 00:04:55,000
就会教大家如何实现自酷

134
00:04:55,000 --> 00:04:57,000
因为是中文

135
00:04:57,000 --> 00:04:59,000
所以可能工程比较浩大

136
00:04:59,000 --> 00:05:01,000
从 12 个字

137
00:05:01,000 --> 00:05:03,000
扩长到 50 个字

138
00:05:03,000 --> 00:05:05,000
到 500

139
00:05:05,000 --> 00:05:06,000
5000

140
00:05:06,000 --> 00:05:07,000
5 万

141
00:05:07,000 --> 00:05:09,000
平时大家设计中文的话

142
00:05:09,000 --> 00:05:10,000
是没有头绪

143
00:05:10,000 --> 00:05:12,000
不知道怎么用什么方法

144
00:05:12,000 --> 00:05:14,000
然后要做多少字

145
00:05:14,000 --> 00:05:15,000
一旦多的话

146
00:05:15,000 --> 00:05:18,000
怎么提高效率

147
00:05:18,000 --> 00:05:23,000
然后尽早发些问题

148
00:05:23,000 --> 00:05:25,000
比如说大小不一样

149
00:05:25,000 --> 00:05:26,000
怎么处理

150
00:05:26,000 --> 00:05:27,000
我们都会具体的

151
00:05:27,000 --> 00:05:29,000
在 type school 请老师

152
00:05:29,000 --> 00:05:31,000
给大家介绍

153
00:05:31,000 --> 00:05:33,000
对不过 5 天时间

154
00:05:33,000 --> 00:05:35,000
其实做 12 个字也就差不多

155
00:05:35,000 --> 00:05:38,000
我们这次有一个很好的机会

156
00:05:38,000 --> 00:05:39,000
是优秀的学员

157
00:05:39,000 --> 00:05:41,000
和方正签约

158
00:05:41,000 --> 00:05:44,000
你先做好几百个字

159
00:05:44,000 --> 00:05:46,000
剩下的成千上万字

160
00:05:46,000 --> 00:05:48,000
方正会把你做

161
00:05:48,000 --> 00:05:49,000
对

162
00:05:49,000 --> 00:05:51,000
这个其实就跟之前的

163
00:05:51,000 --> 00:05:53,000
自体竞赛很相似

164
00:05:53,000 --> 00:05:55,000
提交一份样子的作品

165
00:05:55,000 --> 00:05:56,000
然后如果

166
00:05:56,000 --> 00:05:58,000
自体公司觉得非常合适

167
00:05:58,000 --> 00:06:00,000
有商业化的价值的话

168
00:06:00,000 --> 00:06:01,000
他会与你签约

169
00:06:01,000 --> 00:06:02,000
然后帮你把它做成

170
00:06:02,000 --> 00:06:04,000
一个真正意义的自酷

171
00:06:04,000 --> 00:06:06,000
当然在这样的课程里面

172
00:06:06,000 --> 00:06:08,000
大家也可以接触到 Gripps

173
00:06:08,000 --> 00:06:11,000
这样一个自体神器

174
00:06:11,000 --> 00:06:12,000
其实

175
00:06:12,000 --> 00:06:15,000
而且这次我们 Gripps 开发

176
00:06:15,000 --> 00:06:17,000
各奥各国来

177
00:06:17,000 --> 00:06:20,000
中国人他切身赶到了

178
00:06:20,000 --> 00:06:23,000
做翻快汉字的一些特殊的要求

179
00:06:23,000 --> 00:06:25,000
我们有很多新的功能

180
00:06:25,000 --> 00:06:27,000
也会加到 Gripps 里面

181
00:06:27,000 --> 00:06:29,000
给大家可以试用一下

182
00:06:29,000 --> 00:06:31,000
这次我们还邀请到了

183
00:06:31,000 --> 00:06:33,000
德国的 Metal Design

184
00:06:33,000 --> 00:06:35,000
Metal Design 的

185
00:06:35,000 --> 00:06:37,000
德国的他们那边的

186
00:06:37,000 --> 00:06:39,000
公司的他们的设计师

187
00:06:39,000 --> 00:06:42,000
也会参与到活动里面进来

188
00:06:42,000 --> 00:06:43,000
对 Metal Design

189
00:06:43,000 --> 00:06:46,000
感兴趣的朋友们也有机会

190
00:06:46,000 --> 00:06:49,000
所以这也是满难得的一个机会

191
00:06:50,000 --> 00:06:52,000
8 月份的北京比较热

192
00:06:52,000 --> 00:06:53,000
但是

193
00:06:53,000 --> 00:06:55,000
我觉得 7 月份的

194
00:06:55,000 --> 00:06:57,000
上海也够热的

195
00:06:57,000 --> 00:06:58,000
上海更热

196
00:06:58,000 --> 00:06:59,000
我觉得这两天

197
00:06:59,000 --> 00:07:01,000
北京比上海凉快多了

198
00:07:01,000 --> 00:07:03,000
北京还好是干热

199
00:07:03,000 --> 00:07:05,000
上海绝二十十度比较大

200
00:07:05,000 --> 00:07:06,000
比较难受

201
00:07:06,000 --> 00:07:08,000
上海这周是暴热

202
00:07:08,000 --> 00:07:09,000
已经超过四十度了

203
00:07:09,000 --> 00:07:10,000
对

204
00:07:11,000 --> 00:07:13,000
有这种下令营的感觉

205
00:07:13,000 --> 00:07:15,000
大家也欢迎大家

206
00:07:15,000 --> 00:07:17,000
来多多地报名

207
00:07:17,000 --> 00:07:19,000
其实有这样的机会是非常难得的

208
00:07:22,000 --> 00:07:23,000
好了

209
00:07:23,000 --> 00:07:25,000
难得我们这次第五次的串台

210
00:07:25,000 --> 00:07:28,000
但是还要先讲一下反馈

211
00:07:28,000 --> 00:07:30,000
那上次就是我们的

212
00:07:30,000 --> 00:07:31,000
自弹自串的第四期

213
00:07:31,000 --> 00:07:32,000
风回路转

214
00:07:32,000 --> 00:07:33,000
换行来呢

215
00:07:33,000 --> 00:07:35,000
有一位朋友

216
00:07:35,000 --> 00:07:36,000
说

217
00:07:36,000 --> 00:07:37,000
无桃重新发明打字机

218
00:07:37,000 --> 00:07:38,000
无桃重新发明打字机

219
00:07:38,000 --> 00:07:40,000
带回车舰的打字机

220
00:07:40,000 --> 00:07:41,000
感到好

221
00:07:42,000 --> 00:07:44,000
所以打字机是没有合车舰的对吧

222
00:07:44,000 --> 00:07:46,000
就打字机没有

223
00:07:46,000 --> 00:07:48,000
一个舰是你按下去之后

224
00:07:48,000 --> 00:07:49,000
它会跳到下一行

225
00:07:49,000 --> 00:07:50,000
哎

226
00:07:50,000 --> 00:07:51,000
好像是有的

227
00:07:51,000 --> 00:07:53,000
但这个舰并不是

228
00:07:53,000 --> 00:07:54,000
回车舰

229
00:07:54,000 --> 00:07:56,000
也不是在每一个打字机上都有

230
00:07:56,000 --> 00:07:58,000
然后换行的时候

231
00:07:58,000 --> 00:08:00,000
是你波动左边的波槈

232
00:08:00,000 --> 00:08:03,000
把自车往右波的过程中

233
00:08:04,000 --> 00:08:06,000
它会自动的朝下滚一个

234
00:08:06,000 --> 00:08:07,000
所以

235
00:08:07,000 --> 00:08:08,000
所以换行这个功能

236
00:08:08,000 --> 00:08:10,000
实际上是在自车上实现的

237
00:08:10,000 --> 00:08:12,000
正确还是把那位

238
00:08:12,000 --> 00:08:14,000
听众的反馈念一下吧

239
00:08:15,000 --> 00:08:16,000
好吧

240
00:08:16,000 --> 00:08:18,000
刚艾尔克念的是第一行

241
00:08:18,000 --> 00:08:19,000
然后接下来一念

242
00:08:19,000 --> 00:08:21,000
打字机没有回车舰

243
00:08:21,000 --> 00:08:23,000
打字机滚同左端的手柄

244
00:08:23,000 --> 00:08:26,000
兼具回车与换行功能

245
00:08:26,000 --> 00:08:28,000
手柄从左向右平推

246
00:08:28,000 --> 00:08:30,000
可以将滚轮向右推送

247
00:08:30,000 --> 00:08:31,000
就是回车

248
00:08:31,000 --> 00:08:33,000
手柄从右向左

249
00:08:33,000 --> 00:08:34,000
从左向右搬动

250
00:08:34,000 --> 00:08:37,000
同时带点轻微的顺时针扭转

251
00:08:37,000 --> 00:08:39,000
可以滚动滚动

252
00:08:39,000 --> 00:08:40,000
就是换行

253
00:08:40,000 --> 00:08:41,000
搬得轻一点

254
00:08:41,000 --> 00:08:43,000
可以换半行或四分之一行

255
00:08:43,000 --> 00:08:47,000
打字时当滚动行进行到

256
00:08:47,000 --> 00:08:48,000
滚动行

257
00:08:49,000 --> 00:08:50,000
进到

258
00:08:51,000 --> 00:08:53,000
接近行墨位置时

259
00:08:53,000 --> 00:08:55,000
会有钉的一声铃音提示

260
00:08:56,000 --> 00:08:58,000
平推手柄将滚轮推到最右

261
00:08:58,000 --> 00:08:59,000
实现回车

262
00:08:59,000 --> 00:09:01,000
顺势即是用手

263
00:09:01,000 --> 00:09:03,000
顺势即是用力手柄

264
00:09:03,000 --> 00:09:05,000
会自然向右

265
00:09:05,000 --> 00:09:08,000
转动滚轮

266
00:09:08,000 --> 00:09:09,000
这好烧

267
00:09:09,000 --> 00:09:10,000
你怎么弄这种障碍的

268
00:09:10,000 --> 00:09:11,000
全程以来

269
00:09:11,000 --> 00:09:12,000
这好烧

270
00:09:12,000 --> 00:09:13,000
实现坏好

271
00:09:14,000 --> 00:09:15,000
OK

272
00:09:15,000 --> 00:09:16,000
大家听懂了吗

273
00:09:16,000 --> 00:09:17,000
没有

274
00:09:17,000 --> 00:09:18,000
我是没听懂

275
00:09:19,000 --> 00:09:20,000
我真的看了什么意思

276
00:09:20,000 --> 00:09:21,000
就是

277
00:09:21,000 --> 00:09:22,000
你在敲一行

278
00:09:22,000 --> 00:09:24,000
比如说这一行有 80 个自足

279
00:09:24,000 --> 00:09:26,000
然后你敲到大概 75 个的时候

280
00:09:26,000 --> 00:09:28,000
打字机会盯一声告诉你说

281
00:09:28,000 --> 00:09:29,000
没第二个

282
00:09:29,000 --> 00:09:30,000
赶紧换行

283
00:09:31,000 --> 00:09:32,000
然后这个时候你

284
00:09:32,000 --> 00:09:35,000
压左侧的那个换行杆

285
00:09:35,000 --> 00:09:36,000
稍微压一下

286
00:09:36,000 --> 00:09:40,000
然后自车就会往上滚一个

287
00:09:40,000 --> 00:09:41,000
然后你继续往下压

288
00:09:41,000 --> 00:09:43,000
它就会把整个自车

289
00:09:43,000 --> 00:09:47,000
拉到指的最左边

290
00:09:47,000 --> 00:09:49,000
然后就就这么一件事

291
00:09:51,000 --> 00:09:52,000
我还是很好奇

292
00:09:52,000 --> 00:09:54,000
为什么你们小时候都没有用过打字机

293
00:09:56,000 --> 00:09:58,000
对就没有用过西文

294
00:09:59,000 --> 00:10:00,000
没有用过

295
00:10:00,000 --> 00:10:02,000
所以你如果中文的打字机更掉了

296
00:10:02,000 --> 00:10:03,000
中文打字机是一个

297
00:10:03,000 --> 00:10:05,000
一米成一米大台子

298
00:10:07,000 --> 00:10:08,000
对

299
00:10:08,000 --> 00:10:10,000
我用过就玩过一下

300
00:10:10,000 --> 00:10:12,000
真的存在吗

301
00:10:12,000 --> 00:10:13,000
就是那么多个字

302
00:10:13,000 --> 00:10:15,000
那么大怎么移动呢

303
00:10:16,000 --> 00:10:18,000
是一个是一个 Dcard

304
00:10:18,000 --> 00:10:20,000
Dcard 平面

305
00:10:20,000 --> 00:10:21,000
X 1

306
00:10:21,000 --> 00:10:22,000
真的

307
00:10:26,000 --> 00:10:27,000
那能有多少个字啊上面

308
00:10:27,000 --> 00:10:28,000
字膜

309
00:10:28,000 --> 00:10:29,000
将近一万个吧

310
00:10:29,000 --> 00:10:30,000
很多

311
00:10:30,000 --> 00:10:31,000
没有吧

312
00:10:31,000 --> 00:10:33,000
不到一万多吧

313
00:10:33,000 --> 00:10:35,000
一两千肯定是有的

314
00:10:35,000 --> 00:10:38,000
因为我临向里面

315
00:10:38,000 --> 00:10:41,000
我玩过的那台是有六千字

316
00:10:41,000 --> 00:10:45,000
因为中文常用字也就三千五吧

317
00:10:45,000 --> 00:10:46,000
他把常用字放在上面

318
00:10:46,000 --> 00:10:48,000
然后不够的是用空格

319
00:10:48,000 --> 00:10:49,000
然后又在手写

320
00:10:49,000 --> 00:10:51,000
他底下那个可以换的

321
00:10:51,000 --> 00:10:52,000
可以替换

322
00:10:52,000 --> 00:10:54,000
我印象里面是个一百成一百的格子

323
00:10:54,000 --> 00:10:55,000
你走啊

324
00:10:55,000 --> 00:10:57,000
嗯我印象好像

325
00:10:57,000 --> 00:10:58,000
嗯有那么多吗

326
00:10:58,000 --> 00:10:59,000
没那么大吧

327
00:10:59,000 --> 00:11:01,000
没有一百成一百吗

328
00:11:01,000 --> 00:11:02,000
记不答清楚了

329
00:11:02,000 --> 00:11:04,000
挺大的对挺大的

330
00:11:04,000 --> 00:11:07,000
对反正是个相当大的东西

331
00:11:07,000 --> 00:11:08,000
我刚给大家发了一个链接

332
00:11:08,000 --> 00:11:10,000
那个也是一种那个

333
00:11:10,000 --> 00:11:11,000
汉字的打字机

334
00:11:11,000 --> 00:11:13,000
这个是日本人做的

335
00:11:13,000 --> 00:11:16,000
然后他是一个滚筒式的

336
00:11:16,000 --> 00:11:18,000
选字机构

337
00:11:19,000 --> 00:11:22,000
哦 ok 这个比较浓厌

338
00:11:22,000 --> 00:11:27,000
对这个是在那个京都的汉字博物馆里面展示的一件展品

339
00:11:27,000 --> 00:11:29,000
诶其实如果这么多

340
00:11:29,000 --> 00:11:31,000
就怎么记啊

341
00:11:31,000 --> 00:11:33,000
可能熟能生巧吧

342
00:11:33,000 --> 00:11:35,000
另外他肯定牌字是有规则的

343
00:11:35,000 --> 00:11:37,000
你看他有标了不同的颜色

344
00:11:37,000 --> 00:11:38,000
他以为哦

345
00:11:38,000 --> 00:11:39,000
可不可以这样牌吗

346
00:11:39,000 --> 00:11:42,000
不汉字应该不是这样牌

347
00:11:42,000 --> 00:11:43,000
ok

348
00:11:43,000 --> 00:11:44,000
应该是安音式牌的吧

349
00:11:44,000 --> 00:11:46,000
他却有颜色滑分嘛

350
00:11:46,000 --> 00:11:48,000
应该是按那个所谓的行合列

351
00:11:49,000 --> 00:11:54,000
就是 50 音的行合列的发音来标音之后再分开

352
00:11:54,000 --> 00:11:56,000
那天怎么记得住啊

353
00:11:56,000 --> 00:11:57,000
哪个字在哪个位置

354
00:11:57,000 --> 00:11:58,000
还是要找的

355
00:11:58,000 --> 00:11:59,000
嗯

356
00:11:59,000 --> 00:12:01,000
不你想就说他假设只有 3000

357
00:12:01,000 --> 00:12:04,000
3000 个喘用字的那个滚筒的话

358
00:12:04,000 --> 00:12:05,000
那

359
00:12:05,000 --> 00:12:07,000
这打字速度应该很慢吧

360
00:12:07,000 --> 00:12:09,000
嗯就就得转转

361
00:12:09,000 --> 00:12:11,000
然后找找完以后才打着一个字

362
00:12:11,000 --> 00:12:12,000
就是这样

363
00:12:12,000 --> 00:12:14,000
他这个毕竟还是按拼音排列的

364
00:12:14,000 --> 00:12:16,000
我觉得可能还是要比中文打字机

365
00:12:16,000 --> 00:12:18,000
他步手排列的要快一点

366
00:12:18,000 --> 00:12:19,000
我觉得

367
00:12:19,000 --> 00:12:20,000
对不过

368
00:12:20,000 --> 00:12:22,000
因为日语一个字有很多发音嘛

369
00:12:22,000 --> 00:12:24,000
所以你可能得记住这个字

370
00:12:24,000 --> 00:12:26,000
他用的是哪个标一

371
00:12:26,000 --> 00:12:32,000
像我以前我以前看到我就是我爸单位他们那个打字元用的那种打字机的话

372
00:12:32,000 --> 00:12:38,000
他底下那个反那个刚刚冲的那个刚欧字的盘是可以换的

373
00:12:38,000 --> 00:12:41,000
所以他经常会把这比较常用的字

374
00:12:41,000 --> 00:12:42,000
主要的组合

375
00:12:42,000 --> 00:12:44,000
他因为他可以随意任意调配嘛

376
00:12:44,000 --> 00:12:46,000
然后把常用的放在一起

377
00:12:46,000 --> 00:12:50,000
比如中华人民共和国他就全部放在嘎嘎嘎嘎嘎嘎嘎嘎就顺下来

378
00:12:50,000 --> 00:12:52,000
可以直接打出来就可以

379
00:12:52,000 --> 00:12:53,000
啊

380
00:12:53,000 --> 00:12:55,000
而且我记得就我见到那个中文打字机

381
00:12:55,000 --> 00:12:59,000
好像他那个字盘不只是一层他有两层的可以抽的

382
00:12:59,000 --> 00:13:01,000
啊对没错对没错

383
00:13:01,000 --> 00:13:03,000
上了有一层可能是常用的

384
00:13:03,000 --> 00:13:05,000
下面还有四层用的

385
00:13:05,000 --> 00:13:07,000
哦對對对没错

386
00:13:07,000 --> 00:13:10,000
所以我印象中的中文打字机没那么大

387
00:13:11,000 --> 00:13:13,000
嗯有道理

388
00:13:13,000 --> 00:13:16,000
一晚成一晚好像移动出来挺麻烦的

389
00:13:16,000 --> 00:13:18,000
哈哈哈哈

390
00:13:18,000 --> 00:13:20,000
打太极全都可以

391
00:13:20,000 --> 00:13:24,000
因为我小时候其实就根本没有见过这些

392
00:13:24,000 --> 00:13:26,000
就纯机械的打字机

393
00:13:26,000 --> 00:13:28,000
因为我我现在我想说第一次看人打字的时候

394
00:13:28,000 --> 00:13:30,000
已经是有那个叫

395
00:13:30,000 --> 00:13:32,000
那个叫什么来的就是自服那个 doss

396
00:13:32,000 --> 00:13:35,000
doss 环境面有一个中文的系统

397
00:13:35,000 --> 00:13:37,000
WPS

398
00:13:37,000 --> 00:13:39,000
我们 CCED 吧

399
00:13:39,000 --> 00:13:40,000
对 CCED 是更早的

400
00:13:40,000 --> 00:13:42,000
后来 WPS 后出的嘛

401
00:13:42,000 --> 00:13:44,000
然后出的时候那个时候已经有那种

402
00:13:44,000 --> 00:13:49,000
就是在那个 WPS 的那个就是自服界面那个版本里面去海印

403
00:13:49,000 --> 00:13:53,000
然后用那种真实打印机再把那个打出来嘛

404
00:13:53,000 --> 00:13:57,000
所以这个时候其实已经没有见过真的那种传统一的打字机了

405
00:13:57,000 --> 00:14:01,000
我高中办效报的时候就是用那个先进 UCDoss

406
00:14:01,000 --> 00:14:04,000
然后再进 WPS

407
00:14:04,000 --> 00:14:06,000
然后呢他那不是一个

408
00:14:06,000 --> 00:14:08,000
他是自服编辑界面吧

409
00:14:08,000 --> 00:14:10,000
他不是那个所见其所得的嘛

410
00:14:10,000 --> 00:14:14,000
所以你得要一些装饰东西都用到那个符号写进去

411
00:14:14,000 --> 00:14:16,000
不停不停的预览

412
00:14:16,000 --> 00:14:18,000
然后经常 386 的机器还会死机

413
00:14:18,000 --> 00:14:22,000
对那个时候对于所见其所得没什么概念吗

414
00:14:22,000 --> 00:14:24,000
就是你要不停的预览

415
00:14:24,000 --> 00:14:28,000
但是后来基本上熟练你的人会

416
00:14:28,000 --> 00:14:31,000
对于文章大概会看起来是什么样子

417
00:14:31,000 --> 00:14:34,000
比如说概念就跟现在手写的实验蛮有影響

418
00:14:34,000 --> 00:14:36,000
然后预览

419
00:14:36,000 --> 00:14:38,000
本质也是一种 Markup 的语言吗

420
00:14:38,000 --> 00:14:40,000
完全就是 Markup

421
00:14:40,000 --> 00:14:43,000
所以你脑子中要想好你所要的是什么东西吗

422
00:14:43,000 --> 00:14:44,000
嗯

423
00:14:44,000 --> 00:14:46,000
这就是我们用回 Markdown 又回去了是吧

424
00:14:46,000 --> 00:14:48,000
又回来了对

425
00:14:48,000 --> 00:14:50,000
那实际上我觉得

426
00:14:50,000 --> 00:14:54,000
所见其所得并不是一个强需求说实话

427
00:14:54,000 --> 00:14:58,000
就要看他那个门槛放低了以后

428
00:14:58,000 --> 00:15:00,000
是可以让更多人进来吗

429
00:15:00,000 --> 00:15:02,000
但是对于专业用户的话

430
00:15:02,000 --> 00:15:04,000
可能需求不一样嘛

431
00:15:04,000 --> 00:15:05,000
对

432
00:15:05,000 --> 00:15:08,000
所见其所得本身是没有问题的

433
00:15:08,000 --> 00:15:09,000
主要问题在于现在

434
00:15:09,000 --> 00:15:11,000
主要是像 Word 的实验

435
00:15:11,000 --> 00:15:13,000
它的实验过程有问题

436
00:15:13,000 --> 00:15:19,000
就是它把所有的效果都直接锁建了

437
00:15:19,000 --> 00:15:24,000
你没办法用一个类似于像模板或者是一种格式的方式

438
00:15:24,000 --> 00:15:25,000
虽然有格式爽

439
00:15:25,000 --> 00:15:27,000
但是格式它就是极其不稳定嘛

440
00:15:27,000 --> 00:15:31,000
Word 我觉得这点问题他太迁就用户了

441
00:15:31,000 --> 00:15:38,000
用户说我这个小标题要 15 帮重加粗

442
00:15:38,000 --> 00:15:41,000
下一个小标题他就弄了一个 16 帮重

443
00:15:41,000 --> 00:15:42,000
然后清斜

444
00:15:42,000 --> 00:15:44,000
然后 Word 就傻逼了

445
00:15:44,000 --> 00:15:46,000
Word 说我应该怎么办呢

446
00:15:46,000 --> 00:15:48,000
我应该问用户说

447
00:15:48,000 --> 00:15:50,000
不对你上一个小标题用的是这个

448
00:15:50,000 --> 00:15:52,000
然后这小标题你也得用那个

449
00:15:52,000 --> 00:15:54,000
但是这样一来用户可能不爽

450
00:15:54,000 --> 00:15:57,000
那我还是千就用户再多分出一个小标题吧

451
00:15:57,000 --> 00:16:00,000
然后等到整片文章写完之后

452
00:16:00,000 --> 00:16:03,000
我发现小标题的 style 可能有 20 种

453
00:16:03,000 --> 00:16:04,000
35 种

454
00:16:04,000 --> 00:16:05,000
对

455
00:16:05,000 --> 00:16:09,000
如果一上来你们从来没有学会过用户的格式爽这个习惯的话

456
00:16:09,000 --> 00:16:12,000
那基本上就最后只能守不动改

457
00:16:12,000 --> 00:16:16,000
关键是它那个格式爽它也是一个

458
00:16:16,000 --> 00:16:17,000
是后加的东西

459
00:16:17,000 --> 00:16:22,000
我觉得就是它的本质上它的主理结构是以实际看的为准的

460
00:16:22,000 --> 00:16:26,000
这点跟苹果 Pages 就是跟 Word 差不多的一个软件

461
00:16:26,000 --> 00:16:28,000
的逻辑是完全不一样的

462
00:16:28,000 --> 00:16:31,000
Pages 里面其实你是可以先定义那个文章的结构

463
00:16:31,000 --> 00:16:34,000
比如说这个标题

464
00:16:34,000 --> 00:16:35,000
一级标题

465
00:16:35,000 --> 00:16:36,000
二级标题叫做正文

466
00:16:36,000 --> 00:16:39,000
这个是表格的内容

467
00:16:39,000 --> 00:16:43,000
然后定好之后你是可以直接通过改那个类型的文本

468
00:16:43,000 --> 00:16:45,000
比如说我要改标题都改成一种同样的东西

469
00:16:45,000 --> 00:16:47,000
它可以直接更新

470
00:16:47,000 --> 00:16:50,000
然后让所有的标题文本都是长那个样子的

471
00:16:50,000 --> 00:16:53,000
但是在 Word 里面这一点实现起来是非常不稳定的

472
00:16:53,000 --> 00:16:55,000
Word 也有这功能

473
00:16:55,000 --> 00:16:56,000
Word 也有

474
00:16:56,000 --> 00:16:58,000
对只是用了非常的少

475
00:16:58,000 --> 00:17:00,000
不是不是它的实现确实是有问题的

476
00:17:00,000 --> 00:17:05,000
就是它不是那么强调那个结构和统一的这么一个概念

477
00:17:05,000 --> 00:17:06,000
就刚才讲吴涛说的嘛

478
00:17:06,000 --> 00:17:08,000
就是用户觉得这里要改一点那一点

479
00:17:08,000 --> 00:17:12,000
他就不去 enforce 这个对什么一致性的问题

480
00:17:12,000 --> 00:17:16,000
这个其实是专业用户的一个需求不一样的

481
00:17:16,000 --> 00:17:20,000
像我当年也曾经用 Word 做 40 页的小册子的时候

482
00:17:20,000 --> 00:17:24,000
我都是用那个样那个叫什么 Style 样式

483
00:17:24,000 --> 00:17:26,000
它装的那个样是小窗口来做

484
00:17:26,000 --> 00:17:27,000
对对

485
00:17:27,000 --> 00:17:29,000
你做常文档的时候就必须要用那样来做

486
00:17:29,000 --> 00:17:31,000
要不然的话非常复杂

487
00:17:31,000 --> 00:17:33,000
对就是那个实际性的情况下

488
00:17:33,000 --> 00:17:35,000
Word 就会出现刚才我才讲的那个问题

489
00:17:35,000 --> 00:17:39,000
就是你的那个格式刷它不是一个选一个列表有多少种格式吗

490
00:17:39,000 --> 00:17:42,000
你可能一边稍微长 10 页的可能会出现四五十种

491
00:17:42,000 --> 00:17:43,000
那个不同的选那里

492
00:17:43,000 --> 00:17:45,000
对就是 Word 对于就是您像把 Word 用好

493
00:17:45,000 --> 00:17:50,000
你要有一个非常好的怎么说 deception

494
00:17:50,000 --> 00:17:52,000
就是你必须是一个非常自律

495
00:17:52,000 --> 00:17:54,000
高度自律的人

496
00:17:54,000 --> 00:17:55,000
对

497
00:17:55,000 --> 00:17:57,000
你一定要忍住选中这一行字

498
00:17:57,000 --> 00:18:01,000
然后自直接往上改变它的格式的这个

499
00:18:01,000 --> 00:18:04,000
改变它的样式的这个冲动

500
00:18:04,000 --> 00:18:08,000
然后人物服装的去用格式刷来刷这行字

501
00:18:08,000 --> 00:18:11,000
对否则你就乱了

502
00:18:11,000 --> 00:18:13,000
它很容易在那些小细节地方就变掉

503
00:18:13,000 --> 00:18:15,000
就是你用格式刷也刷不回来

504
00:18:15,000 --> 00:18:17,000
就有些我不知道你们遇到过

505
00:18:17,000 --> 00:18:19,000
有些比如说两个字之间出现一个东西

506
00:18:19,000 --> 00:18:20,000
你无论用格式刷点多少次

507
00:18:20,000 --> 00:18:21,000
它都不会变的

508
00:18:21,000 --> 00:18:25,000
就是它的内部应该是有些实现的 bug 的

509
00:18:25,000 --> 00:18:28,000
这个东西就是那你要自律的话

510
00:18:28,000 --> 00:18:30,000
看有没有截屁了对吧

511
00:18:30,000 --> 00:18:34,000
就千万不能用硬回车来称航句对吧

512
00:18:34,000 --> 00:18:37,000
用空格来称字句对吧

513
00:18:37,000 --> 00:18:39,000
像这种东西的话

514
00:18:39,000 --> 00:18:41,000
本来就是排绑排绑的

515
00:18:41,000 --> 00:18:43,000
首先的做法是不一样的

516
00:18:43,000 --> 00:18:45,000
OK

517
00:18:45,000 --> 00:18:48,000
补充许刚才说的那个中文打字机

518
00:18:48,000 --> 00:18:51,000
我记得那个中文打字机

519
00:18:51,000 --> 00:18:53,000
它有一个最大问题就是

520
00:18:53,000 --> 00:18:54,000
它不像英文打字机

521
00:18:54,000 --> 00:18:55,000
英文打字机也有这个问题

522
00:18:55,000 --> 00:18:56,000
但是没那么严重

523
00:18:56,000 --> 00:18:59,000
就是你在用英文打字机的时候

524
00:18:59,000 --> 00:19:00,000
你可能按一个键

525
00:19:00,000 --> 00:19:02,000
你的力度轻了那个

526
00:19:02,000 --> 00:19:06,000
那个打在纸上的字就会不清楚

527
00:19:06,000 --> 00:19:07,000
而中文打字机是

528
00:19:07,000 --> 00:19:10,000
如果你力度轻了那字不清楚就罢了

529
00:19:10,000 --> 00:19:12,000
如果你用力比较重的话

530
00:19:12,000 --> 00:19:14,000
让那个字比较复杂

531
00:19:14,000 --> 00:19:16,000
比方说

532
00:19:16,000 --> 00:19:18,000
反体的什么国家国字

533
00:19:18,000 --> 00:19:20,000
这种字你打上去

534
00:19:20,000 --> 00:19:22,000
只会穿烂的

535
00:19:22,000 --> 00:19:25,000
所以那时候

536
00:19:25,000 --> 00:19:28,000
那时候不仅打字是一个

537
00:19:28,000 --> 00:19:29,000
要寻止

538
00:19:29,000 --> 00:19:31,000
还要控制自己打字的力量

539
00:19:31,000 --> 00:19:33,000
真的是很累

540
00:19:33,000 --> 00:19:35,000
为什么会这样呢

541
00:19:35,000 --> 00:19:36,000
所以它那个按键

542
00:19:36,000 --> 00:19:38,000
不是均匀力度下决

543
00:19:38,000 --> 00:19:41,000
是靠你的手的力量来决定的

544
00:19:41,000 --> 00:19:43,000
对其实是把一张纸

545
00:19:43,000 --> 00:19:45,000
是卷了一个大滚筒

546
00:19:45,000 --> 00:19:48,000
滚筒是在这个地卡尔平面上

547
00:19:48,000 --> 00:19:51,000
就移动了

548
00:19:51,000 --> 00:19:52,000
然后移动的时候

549
00:19:52,000 --> 00:19:53,000
你找到一个字

550
00:19:53,000 --> 00:19:55,000
你要把那个

551
00:19:55,000 --> 00:19:56,000
把那个手柄压下去

552
00:19:56,000 --> 00:19:57,000
然后我理解是

553
00:19:57,000 --> 00:20:00,000
它把那个签字吸上来

554
00:20:00,000 --> 00:20:03,000
然后在纸上戳一下

555
00:20:03,000 --> 00:20:05,000
然后这个如果戳得比较狠的话

556
00:20:05,000 --> 00:20:07,000
那个纸都会破

557
00:20:07,000 --> 00:20:08,000
对

558
00:20:08,000 --> 00:20:10,000
但我觉得像用键盘的这种打字机

559
00:20:10,000 --> 00:20:12,000
它完全是可以用

560
00:20:12,000 --> 00:20:14,000
这些设计解决这问题

561
00:20:14,000 --> 00:20:15,000
对

562
00:20:15,000 --> 00:20:16,000
像 IBM 那种

563
00:20:16,000 --> 00:20:18,000
就是用球形的打字头打字机

564
00:20:18,000 --> 00:20:19,000
它就是

565
00:20:19,000 --> 00:20:23,000
它把输入跟打字的部分分开了

566
00:20:23,000 --> 00:20:25,000
实际上你是去驱动一个发条

567
00:20:25,000 --> 00:20:26,000
然后发条

568
00:20:26,000 --> 00:20:28,000
每次会以均匀的力度

569
00:20:28,000 --> 00:20:29,000
把那个字打在

570
00:20:29,000 --> 00:20:30,000
对

571
00:20:30,000 --> 00:20:31,000
但这个都比较高短了

572
00:20:31,000 --> 00:20:32,000
对

573
00:20:32,000 --> 00:20:33,000
这个都比较高短了

574
00:20:33,000 --> 00:20:34,000
就家用的那种

575
00:20:34,000 --> 00:20:35,000
就是变

576
00:20:35,000 --> 00:20:37,000
尤其是变写的锈针的打字机

577
00:20:37,000 --> 00:20:39,000
都是还是你按你的手

578
00:20:39,000 --> 00:20:41,000
按的力度都大

579
00:20:41,000 --> 00:20:42,000
对

580
00:20:42,000 --> 00:20:44,000
怪不得看有些那种

581
00:20:44,000 --> 00:20:45,000
以前那种

582
00:20:45,000 --> 00:20:46,000
打字机打的文档

583
00:20:46,000 --> 00:20:48,000
它有些那个字符的粗细是不一样的

584
00:20:48,000 --> 00:20:49,000
就是因为这个原因是吧

585
00:20:49,000 --> 00:20:50,000
对

586
00:20:50,000 --> 00:20:51,000
就是用力害得

587
00:20:51,000 --> 00:20:52,000
力度的问题

588
00:20:52,000 --> 00:20:53,000
对

589
00:20:53,000 --> 00:20:54,000
这也是

590
00:20:54,000 --> 00:20:56,000
这个真的是个手印花

591
00:20:56,000 --> 00:20:57,000
对

592
00:20:57,000 --> 00:20:58,000
像那个

593
00:20:58,000 --> 00:21:01,000
IBM 出的打字机里面

594
00:21:01,000 --> 00:21:02,000
Coreer

595
00:21:02,000 --> 00:21:04,000
这个字体就这么来了

596
00:21:04,000 --> 00:21:05,000
就是专门为了

597
00:21:05,000 --> 00:21:06,000
它的一个

598
00:21:06,000 --> 00:21:08,000
滚筒式打字机的那个

599
00:21:08,000 --> 00:21:10,000
设计的一套字体

600
00:21:10,000 --> 00:21:11,000
Coreer

601
00:21:11,000 --> 00:21:12,000
有什么讲究吗

602
00:21:12,000 --> 00:21:13,000
就是等宽吧

603
00:21:13,000 --> 00:21:14,000
那个时候的等宽

604
00:21:14,000 --> 00:21:15,000
然后是

605
00:21:15,000 --> 00:21:16,000
就有点 slap 的感觉嘛

606
00:21:16,000 --> 00:21:18,000
就是带一点点趁限量

607
00:21:18,000 --> 00:21:19,000
OK

608
00:21:21,000 --> 00:21:22,000
最近有个新闻

609
00:21:22,000 --> 00:21:23,000
可以和大家分享一下

610
00:21:23,000 --> 00:21:24,000
因为我们前段时间

611
00:21:24,000 --> 00:21:25,000
说过那个 emoji

612
00:21:25,000 --> 00:21:26,000
就是表情符号嘛

613
00:21:26,000 --> 00:21:28,000
刚好 7 月 17 号就是

614
00:21:28,000 --> 00:21:29,000
emoji 日

615
00:21:29,000 --> 00:21:30,000
7 月 17 号是 emoji 日

616
00:21:30,000 --> 00:21:32,000
这个事情你们知道吗

617
00:21:32,000 --> 00:21:33,000
我们提过

618
00:21:33,000 --> 00:21:34,000
我们提过

619
00:21:34,000 --> 00:21:35,000
我们自己还有自己的节日了

620
00:21:35,000 --> 00:21:36,000
已经

621
00:21:36,000 --> 00:21:39,000
我们讲 emoji 那期提过这个事情

622
00:21:39,000 --> 00:21:40,000
为什么是那天我忘了

623
00:21:40,000 --> 00:21:41,000
就是因为

624
00:21:41,000 --> 00:21:43,000
emoji 的日历的图标上

625
00:21:43,000 --> 00:21:45,000
写了是 7 月 17 号

626
00:21:45,000 --> 00:21:46,000
对

627
00:21:46,000 --> 00:21:48,000
是苹果日历的

628
00:21:48,000 --> 00:21:50,000
沿用苹果的那个

629
00:21:50,000 --> 00:21:53,000
当时还叫 iCalm 的日子

630
00:21:53,000 --> 00:21:55,000
然后这次苹果

631
00:21:55,000 --> 00:21:57,000
居然在他们官方网站上面

632
00:21:57,000 --> 00:21:59,000
搞一个什么新闻出来了是吧

633
00:21:59,000 --> 00:22:00,000
预先把今年

634
00:22:00,000 --> 00:22:02,000
稍晚推出的那个表情符号

635
00:22:02,000 --> 00:22:04,000
跟大家展示了一下

636
00:22:05,000 --> 00:22:06,000
这是 iOS 11 里面

637
00:22:06,000 --> 00:22:08,000
会搭载那一套新的

638
00:22:08,000 --> 00:22:09,000
对

639
00:22:09,000 --> 00:22:11,000
也就是 6 月份

640
00:22:11,000 --> 00:22:13,000
i and Unicode

641
00:22:13,000 --> 00:22:14,000
第 10 版里面

642
00:22:14,000 --> 00:22:16,000
已经通过的这些

643
00:22:16,000 --> 00:22:17,000
它已经准备好

644
00:22:17,000 --> 00:22:18,000
已经画好了嘛

645
00:22:18,000 --> 00:22:20,000
马上就要

646
00:22:20,000 --> 00:22:22,000
拿出来跟大家用了

647
00:22:22,000 --> 00:22:23,000
比如说有什么

648
00:22:23,000 --> 00:22:25,000
姜师水

649
00:22:25,000 --> 00:22:26,000
有什么

650
00:22:26,000 --> 00:22:27,000
带头巾的女人

651
00:22:27,000 --> 00:22:28,000
长鬍鬚的人

652
00:22:28,000 --> 00:22:29,000
姜师和穆斯林是

653
00:22:29,000 --> 00:22:30,000
同一个批次的说

654
00:22:30,000 --> 00:22:31,000
或者说

655
00:22:31,000 --> 00:22:32,000
应该还有什么

656
00:22:32,000 --> 00:22:33,000
脚子和筷子吗

657
00:22:33,000 --> 00:22:34,000
不是

658
00:22:34,000 --> 00:22:35,000
就是

659
00:22:35,000 --> 00:22:36,000
我上次在节目

660
00:22:36,000 --> 00:22:37,000
我在我们节目里没说过

661
00:22:37,000 --> 00:22:39,000
到底是画成包子

662
00:22:39,000 --> 00:22:40,000
还是画成馄顿

663
00:22:40,000 --> 00:22:41,000
那就不知道了

664
00:22:41,000 --> 00:22:43,000
到时候看实现吧

665
00:22:44,000 --> 00:22:46,000
所以现在在 iOS 11 的

666
00:22:46,000 --> 00:22:47,000
预览

667
00:22:47,000 --> 00:22:48,000
就是什么

668
00:22:48,000 --> 00:22:49,000
Beta 版你们应该已经

669
00:22:49,000 --> 00:22:50,000
可以看得到了吧

670
00:22:51,000 --> 00:22:52,000
你们装的吗

671
00:22:52,000 --> 00:22:53,000
我在 iPad 上装

672
00:22:53,000 --> 00:22:54,000
但还没注意

673
00:22:54,000 --> 00:22:56,000
到看表情

674
00:22:56,000 --> 00:22:58,000
那个 emotional 的变化

675
00:22:59,000 --> 00:23:00,000
好像还没吧

676
00:23:00,000 --> 00:23:01,000
我没装

677
00:23:01,000 --> 00:23:02,000
我没装

678
00:23:02,000 --> 00:23:03,000
好像还没

679
00:23:03,000 --> 00:23:04,000
我也没装

680
00:23:04,000 --> 00:23:05,000
但好像还没上吧

681
00:23:06,000 --> 00:23:07,000
它上了那个叫做

682
00:23:07,000 --> 00:23:08,000
public beta

683
00:23:08,000 --> 00:23:09,000
上了两次了

684
00:23:09,000 --> 00:23:10,000
对吧

685
00:23:10,000 --> 00:23:11,000
摸起来好像很不稳定

686
00:23:11,000 --> 00:23:12,000
我看好多人都说

687
00:23:12,000 --> 00:23:13,000
具不稳定

688
00:23:14,000 --> 00:23:15,000
我在 iPad 上装的

689
00:23:15,000 --> 00:23:16,000
反正还行

690
00:23:16,000 --> 00:23:17,000
因为这次 iPad

691
00:23:17,000 --> 00:23:18,000
感动比较大

692
00:23:18,000 --> 00:23:19,000
我待会我去看一下

693
00:23:19,000 --> 00:23:20,000
看 iPad 上有没有

694
00:23:24,000 --> 00:23:26,000
那现在就可以念

695
00:23:26,000 --> 00:23:28,000
另外一封听众反馈了

696
00:23:28,000 --> 00:23:29,000
是吧

697
00:23:29,000 --> 00:23:30,000
可以啊

698
00:23:30,000 --> 00:23:31,000
好

699
00:23:31,000 --> 00:23:32,000
我来念一下吧

700
00:23:34,000 --> 00:23:35,000
一位

701
00:23:35,000 --> 00:23:37,000
一位没有属名的听众

702
00:23:37,000 --> 00:23:38,000
后来我问了他

703
00:23:38,000 --> 00:23:39,000
我还专门写信

704
00:23:39,000 --> 00:23:40,000
是问了他应该怎么称呼

705
00:23:40,000 --> 00:23:41,000
他说可以称呼他叫

706
00:23:41,000 --> 00:23:43,000
Tiger 老虎

707
00:23:43,000 --> 00:23:46,000
然后这位自称叫老虎的听众

708
00:23:46,000 --> 00:23:47,000
来了一封邮件说

709
00:23:47,000 --> 00:23:50,000
赞美主播并秋节两个问题

710
00:23:50,000 --> 00:23:51,000
两位主播好

711
00:23:51,000 --> 00:23:53,000
他是写给自弹自唱的

712
00:23:53,000 --> 00:23:54,000
两位主播好

713
00:23:54,000 --> 00:23:55,000
我是一个通信工程

714
00:23:55,000 --> 00:23:56,000
毕业的马农

715
00:23:56,000 --> 00:23:58,000
具体来说是做 iOS 开发的

716
00:23:58,000 --> 00:23:59,000
大概一年前吧

717
00:23:59,000 --> 00:24:01,000
偶然机会发现了你们的播客

718
00:24:01,000 --> 00:24:02,000
一直听到现在

719
00:24:02,000 --> 00:24:03,000
很佩服你们的毅力

720
00:24:03,000 --> 00:24:04,000
能够持续更新

721
00:24:04,000 --> 00:24:05,000
超越了内核恐慌

722
00:24:08,000 --> 00:24:09,000
我是马农

723
00:24:09,000 --> 00:24:11,000
所以最开始听的是内核恐慌

724
00:24:11,000 --> 00:24:12,000
听你们播客

725
00:24:12,000 --> 00:24:13,000
看你们很容易超越

726
00:24:14,000 --> 00:24:15,000
我受益非浅

727
00:24:15,000 --> 00:24:17,000
知道任何东西都不是简简单单的

728
00:24:17,000 --> 00:24:18,000
一个设计作品

729
00:24:18,000 --> 00:24:20,000
或者具体到一个 UI 界面

730
00:24:20,000 --> 00:24:21,000
看起来很舒服

731
00:24:21,000 --> 00:24:23,000
一定是有其背后的道理

732
00:24:23,000 --> 00:24:25,000
我也看着你们推荐的一些书籍

733
00:24:25,000 --> 00:24:26,000
做了一些笔记

734
00:24:26,000 --> 00:24:27,000
这里就不说了

735
00:24:27,000 --> 00:24:29,000
一直以来就想着

736
00:24:29,000 --> 00:24:31,000
就这样被你们任务系无声

737
00:24:31,000 --> 00:24:32,000
也挺好的

738
00:24:32,000 --> 00:24:34,000
但是我最近遇到了一些问题

739
00:24:34,000 --> 00:24:35,000
想得到你们的指教

740
00:24:35,000 --> 00:24:36,000
因为有个问题是

741
00:24:36,000 --> 00:24:37,000
偏计算机方面

742
00:24:37,000 --> 00:24:38,000
和字体没啥关系

743
00:24:38,000 --> 00:24:40,000
不知道提出来是不是很合适

744
00:24:40,000 --> 00:24:42,000
不过我觉得真与主播一定可以的

745
00:24:42,000 --> 00:24:44,000
其实真与主播不可以

746
00:24:44,000 --> 00:24:45,000
问题

747
00:24:46,000 --> 00:24:48,000
问题关于中西文混牌式的高度

748
00:24:48,000 --> 00:24:51,000
在一个 label 上展示文字时

749
00:24:51,000 --> 00:24:53,000
最终展示的高度如何确定

750
00:24:53,000 --> 00:24:55,000
如果文字只有英文

751
00:24:55,000 --> 00:24:57,000
字号选择是 14 号字

752
00:24:57,000 --> 00:24:59,000
在两倍视网模屏幕上

753
00:24:59,000 --> 00:25:01,000
那么最后文字的高度

754
00:25:01,000 --> 00:25:03,000
不会超过 28 px

755
00:25:03,000 --> 00:25:05,000
虽然它写的是 point

756
00:25:05,000 --> 00:25:06,000
我估计是个比物

757
00:25:06,000 --> 00:25:08,000
这个高度应该等于

758
00:25:08,000 --> 00:25:10,000
深部线到降部线的高度

759
00:25:10,000 --> 00:25:12,000
如果文字只有中文那么类似

760
00:25:12,000 --> 00:25:13,000
最后文字的高度

761
00:25:13,000 --> 00:25:15,000
也不会超过 28 px

762
00:25:15,000 --> 00:25:16,000
虽然中文不一定有

763
00:25:16,000 --> 00:25:17,000
深部线和降部线

764
00:25:17,000 --> 00:25:19,000
但是原理是类似的

765
00:25:19,000 --> 00:25:20,000
如果是中英混牌

766
00:25:20,000 --> 00:25:22,000
最后文字的高度会是怎样

767
00:25:22,000 --> 00:25:24,000
我问了我们的设计作品

768
00:25:24,000 --> 00:25:25,000
我问了我们的设计师

769
00:25:25,000 --> 00:25:27,000
说是会比 28 px 多出

770
00:25:27,000 --> 00:25:29,000
一到两个像素

771
00:25:29,000 --> 00:25:30,000
这是什么原因呢

772
00:25:30,000 --> 00:25:32,000
是因为中文和英文的期限

773
00:25:32,000 --> 00:25:33,000
没有对齐吗

774
00:25:33,000 --> 00:25:35,000
希望可以得到主播的解答

775
00:25:35,000 --> 00:25:36,000
问题二

776
00:25:36,000 --> 00:25:37,000
关于多元自不串

777
00:25:37,000 --> 00:25:39,000
先回答一个再讲吧

778
00:25:39,000 --> 00:25:41,000
这个我给他写了一个邮件

779
00:25:41,000 --> 00:25:43,000
说明了一下其中一些问题

780
00:25:43,000 --> 00:25:46,000
但是我觉得他对

781
00:25:46,000 --> 00:25:47,000
他们的设计师

782
00:25:47,000 --> 00:25:49,000
对整个渲染机制

783
00:25:49,000 --> 00:25:50,000
可能没有理解

784
00:25:50,000 --> 00:25:52,000
所以说的完全不着调

785
00:25:52,000 --> 00:25:54,000
我还简单来说一下

786
00:25:54,000 --> 00:25:55,000
首先就是

787
00:25:55,000 --> 00:25:58,000
iOS 它维护了一套

788
00:25:58,000 --> 00:26:00,000
所谓的逻辑尺寸

789
00:26:00,000 --> 00:26:02,000
逻辑布局的空间

790
00:26:02,000 --> 00:26:03,000
所以它的 point

791
00:26:03,000 --> 00:26:05,000
换算成一个 pixel 的值

792
00:26:05,000 --> 00:26:07,000
并不是一定 1 比 1

793
00:26:07,000 --> 00:26:08,000
1 比 2 1 比 3

794
00:26:08,000 --> 00:26:10,000
或者是 1 比几点几的

795
00:26:10,000 --> 00:26:12,000
因为还有像 iPhone Plus

796
00:26:12,000 --> 00:26:14,000
这样子奇葩的屏幕分辨率

797
00:26:14,000 --> 00:26:16,000
另外用户也可以调

798
00:26:16,000 --> 00:26:18,000
这个屏幕分辨率

799
00:26:18,000 --> 00:26:20,000
叫什么 dynamic type

800
00:26:20,000 --> 00:26:23,000
就是它可以调缩放

801
00:26:23,000 --> 00:26:25,000
比如说你视力不好

802
00:26:25,000 --> 00:26:26,000
对

803
00:26:26,000 --> 00:26:28,000
所以你可以调

804
00:26:28,000 --> 00:26:30,000
具体几倍其实是

805
00:26:30,000 --> 00:26:32,000
由操作系统来维护的

806
00:26:32,000 --> 00:26:33,000
那么你只能使用一个

807
00:26:33,000 --> 00:26:35,000
逻辑的 point 的值

808
00:26:35,000 --> 00:26:38,000
这个值是 iOS 给开发使用的

809
00:26:38,000 --> 00:26:39,000
所以一个自幅

810
00:26:39,000 --> 00:26:41,000
当它被设定成

811
00:26:41,000 --> 00:26:43,000
比如说 14 point 的时候

812
00:26:43,000 --> 00:26:44,000
其实简单来说

813
00:26:44,000 --> 00:26:46,000
我们用一个 typography

814
00:26:46,000 --> 00:26:48,000
unit 的概念来说

815
00:26:48,000 --> 00:26:50,000
就是将一个 em 的尺寸

816
00:26:50,000 --> 00:26:52,000
设成了 14 个 point

817
00:26:52,000 --> 00:26:54,000
那么究竟一个 em 的 glif

818
00:26:54,000 --> 00:26:56,000
它的显示的尺寸

819
00:26:56,000 --> 00:26:58,000
是多少个 point

820
00:26:58,000 --> 00:27:00,000
或者是具体大多数 pixel

821
00:27:00,000 --> 00:27:02,000
其实完全是由自体来决定的

822
00:27:02,000 --> 00:27:03,000
你可以将一个 em 的 glif

823
00:27:03,000 --> 00:27:05,000
设计的只占一个像素那么大

824
00:27:05,000 --> 00:27:07,000
你也可以设计的

825
00:27:07,000 --> 00:27:10,000
超过一个 em 的方格的空间

826
00:27:10,000 --> 00:27:12,000
这都是没有问题的

827
00:27:12,000 --> 00:27:14,000
所以具体渲染存多少个像素

828
00:27:14,000 --> 00:27:15,000
或者多少个 point

829
00:27:15,000 --> 00:27:17,000
完全是由自体来决定的

830
00:27:18,000 --> 00:27:20,000
就跟其他没有任何关系

831
00:27:20,000 --> 00:27:22,000
就叫你选 Zapfino

832
00:27:22,000 --> 00:27:25,000
Zapfino 你选一个 14 号的 Zapfino

833
00:27:25,000 --> 00:27:29,000
最终选出来的一个单词

834
00:27:29,000 --> 00:27:32,000
可能会占 100 x 200

835
00:27:32,000 --> 00:27:33,000
这都是有可能的

836
00:27:33,000 --> 00:27:35,000
比如说它的 f 级会非常的高

837
00:27:35,000 --> 00:27:37,000
有一个非常长的降步

838
00:27:37,000 --> 00:27:40,000
然后他问那个问题

839
00:27:40,000 --> 00:27:42,000
其实我理解是不是

840
00:27:42,000 --> 00:27:43,000
之前也遇到过

841
00:27:43,000 --> 00:27:44,000
就是以前你们记不记得

842
00:27:44,000 --> 00:27:47,000
MacOS 的 textedit 程序

843
00:27:47,000 --> 00:27:50,000
他对中英文混排的时候

844
00:27:50,000 --> 00:27:52,000
那个航高是有问题的

845
00:27:52,000 --> 00:27:54,000
它不一致就不稳定

846
00:27:54,000 --> 00:27:56,000
因为是这个问题

847
00:27:56,000 --> 00:27:58,000
这个问题当时好像

848
00:27:58,000 --> 00:28:00,000
我们也讲过好像

849
00:28:00,000 --> 00:28:01,000
对他有个问题就是说

850
00:28:01,000 --> 00:28:02,000
当时的 textedit

851
00:28:02,000 --> 00:28:04,000
好像是以整个文档的

852
00:28:04,000 --> 00:28:06,000
第一个字符的 fone

853
00:28:06,000 --> 00:28:10,000
起来决定这个文档的航高是多少的

854
00:28:10,000 --> 00:28:13,000
但是你在输入的 fly 的过程中

855
00:28:13,000 --> 00:28:15,000
就 input fly 的过程中

856
00:28:15,000 --> 00:28:17,000
他好像又会动态的是

857
00:28:17,000 --> 00:28:19,000
调用当前这个 glif 的 fone

858
00:28:19,000 --> 00:28:21,000
来计算当前这个光标

859
00:28:21,000 --> 00:28:23,000
所在位置的航高

860
00:28:23,000 --> 00:28:25,000
所以如果说你是一个多语言的

861
00:28:25,000 --> 00:28:26,000
对对对就会有挑逗

862
00:28:26,000 --> 00:28:27,000
但现在好像这个问题

863
00:28:27,000 --> 00:28:29,000
被改善了吧

864
00:28:29,000 --> 00:28:31,000
他会预设一个比较大问题

865
00:28:31,000 --> 00:28:32,000
已经修复吧

866
00:28:32,000 --> 00:28:34,000
我最近好像没有注意到这个问题

867
00:28:34,000 --> 00:28:35,000
就在那出生过了

868
00:28:35,000 --> 00:28:37,000
对已经修复了

869
00:28:37,000 --> 00:28:39,000
那他问那个

870
00:28:39,000 --> 00:28:40,000
就中文和英文这个机械

871
00:28:40,000 --> 00:28:42,000
没有对齐这个事情是可能的

872
00:28:42,000 --> 00:28:43,000
发生那么还是说

873
00:28:43,000 --> 00:28:44,000
没有解决这个事

874
00:28:44,000 --> 00:28:46,000
对就是排没眼前来决定的

875
00:28:46,000 --> 00:28:48,000
就中文你可以说是要

876
00:28:48,000 --> 00:28:50,000
他的机械来跟

877
00:28:50,000 --> 00:28:52,000
不对是用中文放

878
00:28:52,000 --> 00:28:54,000
字框的底线和

879
00:28:54,000 --> 00:28:57,000
英文的机械对齐

880
00:28:57,000 --> 00:28:59,000
还是用中文

881
00:28:59,000 --> 00:29:01,000
线框的底线和英文

882
00:29:01,000 --> 00:29:03,000
线框的底线对齐

883
00:29:03,000 --> 00:29:04,000
还是用中文

884
00:29:04,000 --> 00:29:06,000
线框的上顶端和

885
00:29:06,000 --> 00:29:10,000
英文的就是上声部的顶端对齐

886
00:29:10,000 --> 00:29:11,000
只是很明显

887
00:29:11,000 --> 00:29:12,000
所以这机种有什么

888
00:29:12,000 --> 00:29:14,000
就是我听出这个区别了

889
00:29:14,000 --> 00:29:16,000
就是说我们日常采取的

890
00:29:16,000 --> 00:29:17,000
一般是单纯方式

891
00:29:17,000 --> 00:29:19,000
一般是机械对底线吗

892
00:29:19,000 --> 00:29:20,000
不是

893
00:29:20,000 --> 00:29:22,000
一般是机械对支线

894
00:29:22,000 --> 00:29:23,000
对

895
00:29:23,000 --> 00:29:25,000
就是说在正常的

896
00:29:25,000 --> 00:29:26,000
哪怕是中文

897
00:29:26,000 --> 00:29:28,000
或者就是汉字的字体设计里面

898
00:29:28,000 --> 00:29:30,000
现在呢就是真正的

899
00:29:30,000 --> 00:29:31,000
放载们也会画一个机械

900
00:29:31,000 --> 00:29:33,000
虽然说机械也是给西文设计的

901
00:29:33,000 --> 00:29:35,000
但是呢就是说中文设计

902
00:29:35,000 --> 00:29:36,000
首先是有个字框嘛

903
00:29:36,000 --> 00:29:37,000
但是现在的

904
00:29:37,000 --> 00:29:38,000
现在字体都会在字框上面

905
00:29:38,000 --> 00:29:40,000
再补一个机械

906
00:29:40,000 --> 00:29:41,000
因为不管怎么样

907
00:29:41,000 --> 00:29:42,000
操作系统的话

908
00:29:42,000 --> 00:29:44,000
都是以机械来对齐的

909
00:29:44,000 --> 00:29:45,000
现在无论是 foam

910
00:29:45,000 --> 00:29:48,000
是很多排版引擎

911
00:29:48,000 --> 00:29:50,000
还有 web 都是这样

912
00:29:50,000 --> 00:29:52,000
它只去调用

913
00:29:52,000 --> 00:29:54,000
一个 foam 里面的机械

914
00:29:54,000 --> 00:29:55,000
所以呢它

915
00:29:55,000 --> 00:29:56,000
即使是中文字体

916
00:29:56,000 --> 00:29:58,000
它也会设成一个机械

917
00:29:58,000 --> 00:30:00,000
然后在很多的中文日文字体的

918
00:30:00,000 --> 00:30:02,000
比如说大家会默认

919
00:30:02,000 --> 00:30:04,000
中文的方框是

920
00:30:04,000 --> 00:30:06,000
那个字框是 10001000 嘛

921
00:30:06,000 --> 00:30:07,000
的一个正方形的话

922
00:30:07,000 --> 00:30:08,000
一般话来讲

923
00:30:08,000 --> 00:30:09,000
会把这个机械

924
00:30:09,000 --> 00:30:11,000
放在 120 左右

925
00:30:11,000 --> 00:30:13,000
就是底下 120

926
00:30:13,000 --> 00:30:15,000
上面 888

927
00:30:15,000 --> 00:30:16,000
就是放到这样一个位置

928
00:30:16,000 --> 00:30:18,000
然后呢排版引擎的话

929
00:30:18,000 --> 00:30:19,000
不管你是中文还是西文

930
00:30:19,000 --> 00:30:20,000
它都会去

931
00:30:20,000 --> 00:30:22,000
调用你这个 foam 里面

932
00:30:22,000 --> 00:30:23,000
metric matrix

933
00:30:23,000 --> 00:30:25,000
里面的这个机械的位置

934
00:30:25,000 --> 00:30:27,000
它是按机械对齐的

935
00:30:27,000 --> 00:30:29,000
无论你这个是阿拉伯文

936
00:30:29,000 --> 00:30:31,000
还是还是印度的天成文

937
00:30:31,000 --> 00:30:34,000
还是中文的汉字

938
00:30:34,000 --> 00:30:36,000
他们都有一个机械的字

939
00:30:36,000 --> 00:30:37,000
所以那个印度天成

940
00:30:37,000 --> 00:30:39,000
就是天成文的那个

941
00:30:39,000 --> 00:30:40,000
机械在哪

942
00:30:40,000 --> 00:30:42,000
是在靠下的位置还是

943
00:30:42,000 --> 00:30:44,000
天成文它本身的机械

944
00:30:44,000 --> 00:30:45,000
它是 Hanin

945
00:30:45,000 --> 00:30:46,000
它是挂在上面的

946
00:30:46,000 --> 00:30:47,000
对

947
00:30:47,000 --> 00:30:48,000
但是呢它

948
00:30:48,000 --> 00:30:49,000
但是它为了混排的话

949
00:30:49,000 --> 00:30:50,000
它也有

950
00:30:50,000 --> 00:30:52,000
它也在事先

951
00:30:52,000 --> 00:30:54,000
字体设计要设一个机械

952
00:30:54,000 --> 00:30:55,000
虽然它不用

953
00:30:55,000 --> 00:30:56,000
名字叫什么

954
00:30:56,000 --> 00:30:57,000
是叫 baseline

955
00:30:57,000 --> 00:30:58,000
就是叫 baseline

956
00:30:58,000 --> 00:30:59,000
就是叫 baseline

957
00:30:59,000 --> 00:31:00,000
然后它本身的那条

958
00:31:00,000 --> 00:31:01,000
Hanline 叫什么

959
00:31:01,000 --> 00:31:02,000
叫 Hanline 吗

960
00:31:02,000 --> 00:31:03,000
还是

961
00:31:03,000 --> 00:31:05,000
那个有天成文他们自己的名字

962
00:31:05,000 --> 00:31:06,000
对

963
00:31:06,000 --> 00:31:07,000
就是

964
00:31:07,000 --> 00:31:08,000
这个位置

965
00:31:08,000 --> 00:31:10,000
opentype 里面有一个 table

966
00:31:10,000 --> 00:31:11,000
就叫 base

967
00:31:11,000 --> 00:31:13,000
就是 base 这个 table

968
00:31:13,000 --> 00:31:14,000
就是描述的

969
00:31:14,000 --> 00:31:15,000
你这条 baseline 的位置

970
00:31:15,000 --> 00:31:16,000
在这个

971
00:31:16,000 --> 00:31:17,000
原始作标 00

972
00:31:17,000 --> 00:31:20,000
跟它相对的这个位置在哪里

973
00:31:20,000 --> 00:31:22,000
其实它默认就在 00

974
00:31:22,000 --> 00:31:23,000
这个位置上了

975
00:31:23,000 --> 00:31:24,000
那么那个

976
00:31:24,000 --> 00:31:25,000
你在设一个中文字体的时候

977
00:31:25,000 --> 00:31:27,000
你可以将你的这个起点

978
00:31:27,000 --> 00:31:29,000
比如说设在零-4 多少多少

979
00:31:29,000 --> 00:31:30,000
比如说-120

980
00:31:30,000 --> 00:31:32,000
这是 Adobe 常用的一个数字

981
00:31:32,000 --> 00:31:33,000
那么 model type

982
00:31:33,000 --> 00:31:35,000
可能会有什么-110 之类

983
00:31:35,000 --> 00:31:36,000
就每个字体厂商

984
00:31:36,000 --> 00:31:38,000
他们都会有他自己的 convention

985
00:31:38,000 --> 00:31:39,000
来做这个事情

986
00:31:39,000 --> 00:31:41,000
所以其实这个就是一个

987
00:31:41,000 --> 00:31:42,000
普通的字体文件里面

988
00:31:42,000 --> 00:31:43,000
它 metrics

989
00:31:43,000 --> 00:31:45,000
我们叫度量或者量度

990
00:31:45,000 --> 00:31:46,000
它的一个设置

991
00:31:46,000 --> 00:31:48,000
自己设计是必须要设置的

992
00:31:48,000 --> 00:31:51,000
然后再由拍板影机去调用

993
00:31:51,000 --> 00:31:52,000
OK

994
00:31:53,000 --> 00:31:55,000
所以就其实不会出现

995
00:31:55,000 --> 00:31:56,000
中文

996
00:31:56,000 --> 00:31:57,000
他问的中文和英文

997
00:31:57,000 --> 00:31:59,000
机械没对齐的情况对吧

998
00:31:59,000 --> 00:32:01,000
这个好像还是可以改

999
00:32:01,000 --> 00:32:02,000
就是比如说像我说的

1000
00:32:02,000 --> 00:32:03,000
你可以强行说

1001
00:32:03,000 --> 00:32:05,000
在这个拍板的时候

1002
00:32:05,000 --> 00:32:07,000
或者说在这个 label 里面

1003
00:32:07,000 --> 00:32:09,000
让所有字符

1004
00:32:09,000 --> 00:32:10,000
底端对齐

1005
00:32:10,000 --> 00:32:11,000
这个还是可以做的

1006
00:32:11,000 --> 00:32:12,000
可以的

1007
00:32:12,000 --> 00:32:14,000
如果你强行要这么设的话

1008
00:32:14,000 --> 00:32:15,000
还是可能的

1009
00:32:15,000 --> 00:32:17,000
因为像 CSS 里面

1010
00:32:17,000 --> 00:32:20,000
就是有一个机线对齐的概念

1011
00:32:20,000 --> 00:32:22,000
当然他没有区分

1012
00:32:22,000 --> 00:32:23,000
多余文本

1013
00:32:23,000 --> 00:32:25,000
他是整个和图片的对齐

1014
00:32:25,000 --> 00:32:26,000
那想来

1015
00:32:26,000 --> 00:32:28,000
如果一个比较高级的拍板影机

1016
00:32:28,000 --> 00:32:30,000
应该也是可以允许做这种

1017
00:32:30,000 --> 00:32:33,000
比较非标准的操作吧

1018
00:32:33,000 --> 00:32:34,000
如果是硬说方面的话

1019
00:32:34,000 --> 00:32:36,000
比如说 indexing 的话

1020
00:32:36,000 --> 00:32:37,000
这个特别

1021
00:32:37,000 --> 00:32:38,000
尤其是中西文混牌的

1022
00:32:38,000 --> 00:32:40,000
比如说在做复合字体的时候

1023
00:32:40,000 --> 00:32:42,000
就可以做机线偏移

1024
00:32:42,000 --> 00:32:44,000
而且在更广

1025
00:32:44,000 --> 00:32:46,000
在广的范围来讲

1026
00:32:46,000 --> 00:32:47,000
比如说把一个数字

1027
00:32:47,000 --> 00:32:49,000
做成上标或者下标

1028
00:32:49,000 --> 00:32:51,000
这其实也是一种机线偏移

1029
00:32:51,000 --> 00:32:53,000
就是在不同的

1030
00:32:53,000 --> 00:32:54,000
不同的环境下

1031
00:32:54,000 --> 00:32:56,000
不同的拍板影机

1032
00:32:56,000 --> 00:32:58,000
都是有这样的功能的

1033
00:32:58,000 --> 00:33:00,000
那具体在 CSS 的话

1034
00:33:00,000 --> 00:33:01,000
是另外的实现吧

1035
00:33:01,000 --> 00:33:02,000
对吧

1036
00:33:02,000 --> 00:33:03,000
对 CSS 它是这样的

1037
00:33:03,000 --> 00:33:05,000
就是它的机制比较麻烦

1038
00:33:05,000 --> 00:33:07,000
它有一个所谓的 Linebox

1039
00:33:07,000 --> 00:33:10,000
和 Inlinebox 的概念

1040
00:33:10,000 --> 00:33:13,000
所以就是当它放大了算里

1041
00:33:13,000 --> 00:33:15,000
它会把一个行内的

1042
00:33:15,000 --> 00:33:17,000
一小段自幅串

1043
00:33:17,000 --> 00:33:19,000
计算它一个很小的一个举行

1044
00:33:19,000 --> 00:33:21,000
然后举行的这个高度

1045
00:33:21,000 --> 00:33:22,000
会有一个高度

1046
00:33:22,000 --> 00:33:24,000
然后机线会在这个举行

1047
00:33:24,000 --> 00:33:26,000
内部的一个相对位置里面

1048
00:33:26,000 --> 00:33:27,000
然后这个时候

1049
00:33:27,000 --> 00:33:30,000
CSS 的 Vertical Align 属性

1050
00:33:30,000 --> 00:33:32,000
Property 里面设了几种值

1051
00:33:32,000 --> 00:33:34,000
就会来决定机线之间

1052
00:33:34,000 --> 00:33:35,000
相互对齐的关系

1053
00:33:35,000 --> 00:33:37,000
但 Vertical Align 的属性

1054
00:33:37,000 --> 00:33:39,000
非常的不直观

1055
00:33:39,000 --> 00:33:42,000
我觉得这是 CSS 设计的一个缺陷

1056
00:33:42,000 --> 00:33:43,000
对于入门者来说

1057
00:33:43,000 --> 00:33:45,000
你很难去直观的

1058
00:33:45,000 --> 00:33:47,000
感受到你做了哪些对齐

1059
00:33:47,000 --> 00:33:48,000
因为你有的时候

1060
00:33:48,000 --> 00:33:49,000
选 Middle 对齐的时候

1061
00:33:49,000 --> 00:33:51,000
你发现它其实并不是

1062
00:33:51,000 --> 00:33:53,000
你预期的那种 Middle 的方式

1063
00:33:53,000 --> 00:33:55,000
它是以它定义的那种 Middle 的方式

1064
00:33:55,000 --> 00:33:58,000
然后 Bass Line 是默认的一种对齐方式

1065
00:33:58,000 --> 00:33:59,000
对

1066
00:33:59,000 --> 00:34:01,000
这个还和字体有关系吧

1067
00:34:01,000 --> 00:34:04,000
CSS 它会比较简单

1068
00:34:04,000 --> 00:34:06,000
它会对一段文字使用

1069
00:34:06,000 --> 00:34:09,000
同一种字体的参数来计算

1070
00:34:09,000 --> 00:34:14,000
这个 Linebox 的高度的这样一个属性

1071
00:34:14,000 --> 00:34:16,000
对 但是这个 Linebox 的高度

1072
00:34:16,000 --> 00:34:18,000
它算起来就不是很准

1073
00:34:18,000 --> 00:34:20,000
它也不是在所有地方都很准的

1074
00:34:21,000 --> 00:34:23,000
而且它首先它会调用

1075
00:34:23,000 --> 00:34:24,000
就是因为

1076
00:34:24,000 --> 00:34:26,000
如果你是调用一个中文字体的话

1077
00:34:26,000 --> 00:34:28,000
中文字体内部也有西文

1078
00:34:28,000 --> 00:34:31,000
首先它会调用一个字体设计

1079
00:34:31,000 --> 00:34:35,000
是它本身设定好的中西文的机械

1080
00:34:35,000 --> 00:34:37,000
因为你调用的字体放的本身

1081
00:34:37,000 --> 00:34:39,000
是有这个信息的

1082
00:34:39,000 --> 00:34:41,000
然后它要拿到这个信息

1083
00:34:41,000 --> 00:34:44,000
然后再这个信息再继续调整

1084
00:34:44,000 --> 00:34:46,000
对 但 CSS 有个问题

1085
00:34:46,000 --> 00:34:47,000
就是说

1086
00:34:47,000 --> 00:34:50,000
它在计算一个 Linebox 的这个高度的时候

1087
00:34:50,000 --> 00:34:54,000
它默认是 NCSS 设定的 LineHeight 的数值来计算

1088
00:34:54,000 --> 00:34:59,000
对 但 LineHeight 的值未必跟字体设计师定义的

1089
00:34:59,000 --> 00:35:01,000
默认的 LineHeight 是一样的

1090
00:35:01,000 --> 00:35:03,000
所以这个时候机械应该放在什么位置

1091
00:35:03,000 --> 00:35:05,000
其实是有一点问题的

1092
00:35:05,000 --> 00:35:07,000
有的时候是为出 bug 的

1093
00:35:08,000 --> 00:35:09,000
LineHeight 的话

1094
00:35:09,000 --> 00:35:11,000
就是我们说中文就是航高

1095
00:35:11,000 --> 00:35:12,000
对

1096
00:35:12,000 --> 00:35:15,000
大家也知道 CSS 里面航高的话

1097
00:35:15,000 --> 00:35:20,000
它是要把航间剧除以一半放上

1098
00:35:20,000 --> 00:35:21,000
一半放下面

1099
00:35:21,000 --> 00:35:22,000
对对对

1100
00:35:22,000 --> 00:35:23,000
那个盒子的

1101
00:35:23,000 --> 00:35:26,000
对 所以这个盒子是怎么算的

1102
00:35:26,000 --> 00:35:28,000
比较麻烦的这些事情

1103
00:35:28,000 --> 00:35:31,000
对 特别是你多种字体混合组合的时候

1104
00:35:31,000 --> 00:35:33,000
会有些问题

1105
00:35:33,000 --> 00:35:34,000
不同字体

1106
00:35:34,000 --> 00:35:36,000
而且是不同字号的时候会非常麻烦

1107
00:35:36,000 --> 00:35:38,000
对

1108
00:35:40,000 --> 00:35:42,000
它问了第二个问题

1109
00:35:42,000 --> 00:35:44,000
是关于多语言自负券

1110
00:35:44,000 --> 00:35:47,000
关于多语言自负券的排序和所引

1111
00:35:47,000 --> 00:35:48,000
这个要讲吗

1112
00:35:48,000 --> 00:35:51,000
这个是我们今天要说的有点关系

1113
00:35:51,000 --> 00:35:53,000
有点关系或者说

1114
00:35:53,000 --> 00:35:57,000
要不我们等到后面专门一起来讲的排序

1115
00:35:57,000 --> 00:36:00,000
要不我们就先念一下它这个邮件

1116
00:36:00,000 --> 00:36:02,000
就答不答再说了

1117
00:36:03,000 --> 00:36:05,000
如今是多语言国际化的时代

1118
00:36:05,000 --> 00:36:07,000
多语言自负券排序和所有的规则是什么呢

1119
00:36:07,000 --> 00:36:10,000
iPhone 通讯录中的性命的排序规则是什么呢

1120
00:36:10,000 --> 00:36:12,000
对于整个问题

1121
00:36:12,000 --> 00:36:14,000
我自己也做了一些研究

1122
00:36:14,000 --> 00:36:16,000
大致是 Unicode 给出了一套规则

1123
00:36:16,000 --> 00:36:18,000
根据这个规则来实现就好了

1124
00:36:18,000 --> 00:36:20,000
但是 Unicode 的文档

1125
00:36:20,000 --> 00:36:22,000
眷质指号凡吗

1126
00:36:22,000 --> 00:36:24,000
眷质

1127
00:36:24,000 --> 00:36:26,000
我实在无能无反了是吧

1128
00:36:26,000 --> 00:36:27,000
眷义

1129
00:36:27,000 --> 00:36:29,000
这是一字

1130
00:36:29,000 --> 00:36:31,000
就指吧

1131
00:36:31,000 --> 00:36:33,000
对眷质

1132
00:36:33,000 --> 00:36:35,000
眷质号凡

1133
00:36:35,000 --> 00:36:36,000
各位

1134
00:36:36,000 --> 00:36:38,000
爆露了自己的文化修养

1135
00:36:38,000 --> 00:36:39,000
对

1136
00:36:39,000 --> 00:36:40,000
失掉念头了

1137
00:36:40,000 --> 00:36:42,000
我实在无能为力完全搞懂

1138
00:36:42,000 --> 00:36:43,000
我自己总结了一点东西

1139
00:36:43,000 --> 00:36:45,000
写了三篇文章放在博客上

1140
00:36:45,000 --> 00:36:47,000
希望可以得到两位主播的指点

1141
00:36:47,000 --> 00:36:49,000
同时我自己也有一点问题没有搞明白

1142
00:36:49,000 --> 00:36:50,000
第一

1143
00:36:50,000 --> 00:36:52,000
所引使指定的排序规则是什么呢

1144
00:36:52,000 --> 00:36:54,000
似乎是按照评

1145
00:36:54,000 --> 00:36:57,000
但是中文和英文交織并不是中文

1146
00:36:57,000 --> 00:36:59,000
并不是中文一定在英文前面或者后面

1147
00:36:59,000 --> 00:37:01,000
怎样得到每个汉字的读音呢

1148
00:37:01,000 --> 00:37:03,000
在指定汉字顺势的

1149
00:37:04,000 --> 00:37:07,000
ZH.xml

1150
00:37:07,000 --> 00:37:09,000
这是一个文件

1151
00:37:09,000 --> 00:37:11,000
汉字的读音在在警号之后

1152
00:37:11,000 --> 00:37:13,000
似乎是被注视掉了

1153
00:37:13,000 --> 00:37:15,000
那么怎么知道汉字的读音呢

1154
00:37:15,000 --> 00:37:16,000
具体来说

1155
00:37:16,000 --> 00:37:18,000
左边的读音是左边

1156
00:37:18,000 --> 00:37:20,000
它写的是一个拼音的左边

1157
00:37:20,000 --> 00:37:21,000
是怎么被确定的呢

1158
00:37:21,000 --> 00:37:23,000
这个问题和字体排音没啥关系

1159
00:37:23,000 --> 00:37:25,000
和你们做的 Unicor 的串台节目

1160
00:37:25,000 --> 00:37:26,000
有那么一点点关系

1161
00:37:26,000 --> 00:37:28,000
所以希望可以得到解答

1162
00:37:28,000 --> 00:37:30,000
这个问题已经困扰我好久好久了

1163
00:37:31,000 --> 00:37:33,000
它应该是拿了一个

1164
00:37:33,000 --> 00:37:36,000
什么 data base 来做这个排序吧

1165
00:37:36,000 --> 00:37:38,000
这个事比较复杂

1166
00:37:38,000 --> 00:37:40,000
iPhone 的通讯

1167
00:37:40,000 --> 00:37:41,000
iOS 通讯栋上面

1168
00:37:41,000 --> 00:37:42,000
它有一个机制

1169
00:37:42,000 --> 00:37:45,000
iPhone 上我不知道有没有办法添加

1170
00:37:45,000 --> 00:37:48,000
在 Mac 上是可以给联系人的名字

1171
00:37:48,000 --> 00:37:50,000
加一个叫做 fonetic

1172
00:37:50,000 --> 00:37:52,000
对 这个是我想说

1173
00:37:52,000 --> 00:37:54,000
它有一个 fonetic

1174
00:37:54,000 --> 00:37:57,000
还有一个另外一个註音

1175
00:37:57,000 --> 00:37:59,000
除了 fonetic 之外

1176
00:37:59,000 --> 00:38:00,000
还有另外一个註音

1177
00:38:00,000 --> 00:38:01,000
我忘了叫什么了

1178
00:38:02,000 --> 00:38:04,000
然后这两个可以

1179
00:38:04,000 --> 00:38:07,000
这两个可以拿来做排序的依据

1180
00:38:07,000 --> 00:38:10,000
但是排序的时候的

1181
00:38:10,000 --> 00:38:12,000
比如说你用中文

1182
00:38:12,000 --> 00:38:14,000
就是你把系统设成中文的时候

1183
00:38:14,000 --> 00:38:16,000
排序规则跟设成英文的时候

1184
00:38:16,000 --> 00:38:17,000
排序规则不一样

1185
00:38:19,000 --> 00:38:21,000
哪怕你设成中文

1186
00:38:21,000 --> 00:38:23,000
也可以用不同的排序

1187
00:38:23,000 --> 00:38:24,000
如果大家用 Mac 的话

1188
00:38:24,000 --> 00:38:26,000
打开系统拼号设置的

1189
00:38:26,000 --> 00:38:28,000
语言地区那边

1190
00:38:28,000 --> 00:38:32,000
就专门有一个列表排列顺序的一个设置

1191
00:38:32,000 --> 00:38:34,000
然后中文默认是拼音顺序

1192
00:38:34,000 --> 00:38:36,000
但是中文你也可以用

1193
00:38:36,000 --> 00:38:39,000
比如说你用笔画顺序

1194
00:38:39,000 --> 00:38:42,000
也可以用 Gb 的内码的顺序

1195
00:38:42,000 --> 00:38:45,000
对 但是在手机上面有这个设置吗

1196
00:38:46,000 --> 00:38:48,000
跟你的语言环境有关系

1197
00:38:48,000 --> 00:38:51,000
我理解是在用

1198
00:38:51,000 --> 00:38:54,000
比如说你在 Mac 上面

1199
00:38:54,000 --> 00:38:57,000
可以说我的系统语言是英语

1200
00:38:57,000 --> 00:39:01,000
但是我的第三 preferred language 是中文

1201
00:39:01,000 --> 00:39:03,000
与此同时

1202
00:39:03,000 --> 00:39:06,000
我要我可以把 least

1203
00:39:06,000 --> 00:39:09,000
sort all 的设成中文的比如说笔画排序

1204
00:39:09,000 --> 00:39:11,000
或者是注音排序

1205
00:39:11,000 --> 00:39:12,000
但是 iPhone 上

1206
00:39:12,000 --> 00:39:13,000
iPhone 上是没有这个设定的

1207
00:39:13,000 --> 00:39:16,000
就是你不能说系统语言是中文

1208
00:39:16,000 --> 00:39:17,000
系统语言是英文的同时

1209
00:39:17,000 --> 00:39:19,000
你还可以指定中文的排序方式

1210
00:39:19,000 --> 00:39:22,000
就是我以前在推上跟

1211
00:39:22,000 --> 00:39:26,000
行事跟经理还是谁去研究过这个问题

1212
00:39:26,000 --> 00:39:28,000
就是他想说

1213
00:39:28,000 --> 00:39:30,000
手机的系统是英文的同时

1214
00:39:30,000 --> 00:39:34,000
还可以让通讯录按照中文的笔画

1215
00:39:34,000 --> 00:39:36,000
则是排序好像是

1216
00:39:36,000 --> 00:39:38,000
后来发现这个其实做不到的

1217
00:39:38,000 --> 00:39:41,000
就是当时我产生的状态是

1218
00:39:41,000 --> 00:39:43,000
我先把手机设成中文

1219
00:39:43,000 --> 00:39:46,000
然后发现通讯录被用

1220
00:39:46,000 --> 00:39:50,000
中文 iOS 的默认通讯录排序是什么来着

1221
00:39:50,000 --> 00:39:51,000
是注音

1222
00:39:51,000 --> 00:39:52,000
评音吧

1223
00:39:52,000 --> 00:39:53,000
评音是什么

1224
00:39:53,000 --> 00:39:54,000
评音

1225
00:39:54,000 --> 00:39:57,000
然后当我切换回英文系统的时候

1226
00:39:57,000 --> 00:39:59,000
这个排序是得以保留的

1227
00:39:59,000 --> 00:40:03,000
但是只要我往里面新加坊的通讯录的

1228
00:40:03,000 --> 00:40:05,000
只要我往里面新加坊联络人

1229
00:40:05,000 --> 00:40:09,000
整个排序就变成了英文排序

1230
00:40:09,000 --> 00:40:12,000
然后所有的中文会被集中背了后面

1231
00:40:12,000 --> 00:40:13,000
除非你设定了

1232
00:40:13,000 --> 00:40:16,000
Fonetic Span

1233
00:40:16,000 --> 00:40:17,000
Pronunciation

1234
00:40:17,000 --> 00:40:19,000
它才会在英文的部分出现

1235
00:40:21,000 --> 00:40:22,000
我的情况

1236
00:40:22,000 --> 00:40:25,000
我的 iPhone 是设置成日本状态的

1237
00:40:25,000 --> 00:40:29,000
然后所以打开我的通讯录的时候

1238
00:40:29,000 --> 00:40:30,000
因为日本状态

1239
00:40:30,000 --> 00:40:32,000
它会默认用那首先日本排序

1240
00:40:32,000 --> 00:40:35,000
首先右边的 index

1241
00:40:35,000 --> 00:40:37,000
右边不是一个快速的可以转播

1242
00:40:37,000 --> 00:40:38,000
index 吗

1243
00:40:38,000 --> 00:40:39,000
如果是这样的话

1244
00:40:39,000 --> 00:40:40,000
在日本状态的话

1245
00:40:40,000 --> 00:40:42,000
首先它会有日本的 Akasatana 的顺序

1246
00:40:42,000 --> 00:40:44,000
然后后面还有 26 个字母的顺序

1247
00:40:44,000 --> 00:40:46,000
所以在这样的状态

1248
00:40:46,000 --> 00:40:48,000
日本和英文首先是分开的

1249
00:40:48,000 --> 00:40:51,000
然后因为我系统默认是日本

1250
00:40:51,000 --> 00:40:54,000
所以首先汉字是按到日本顺序排的

1251
00:40:54,000 --> 00:40:58,000
然后如果我当然我这里面有中国朋友

1252
00:40:58,000 --> 00:41:02,000
我把中国朋友如果我不加注音的话

1253
00:41:02,000 --> 00:41:05,000
他的中文汉字的所有是堆在底下的

1254
00:41:05,000 --> 00:41:07,000
但是我如果

1255
00:41:07,000 --> 00:41:08,000
紧耗的

1256
00:41:08,000 --> 00:41:09,000
对紧耗的

1257
00:41:09,000 --> 00:41:10,000
但是如果我

1258
00:41:10,000 --> 00:41:14,000
因为这个注音这个字在日本是非常常见的

1259
00:41:14,000 --> 00:41:15,000
因为日本人的汉字

1260
00:41:15,000 --> 00:41:16,000
如果你不加注音

1261
00:41:16,000 --> 00:41:17,000
根本都不知道他怎么念

1262
00:41:17,000 --> 00:41:18,000
所以一般来

1263
00:41:18,000 --> 00:41:19,000
对

1264
00:41:19,000 --> 00:41:21,000
如果是开成日文以后

1265
00:41:21,000 --> 00:41:24,000
他会默认首先把那个注音的那个 field 打开

1266
00:41:24,000 --> 00:41:25,000
他会让你写

1267
00:41:25,000 --> 00:41:28,000
中文的话可能有时候他默认不打开

1268
00:41:28,000 --> 00:41:30,000
很多人都不知道有这样一个 field

1269
00:41:30,000 --> 00:41:32,000
在日本的话

1270
00:41:32,000 --> 00:41:33,000
那个 field 默认是打开的

1271
00:41:33,000 --> 00:41:36,000
你可以往里面填那个你这个字怎么念

1272
00:41:36,000 --> 00:41:39,000
然后我个人的做法是把这个中文的名字

1273
00:41:39,000 --> 00:41:40,000
把它拼音起来

1274
00:41:40,000 --> 00:41:41,000
这样的话

1275
00:41:41,000 --> 00:41:43,000
在我的手机方位里面

1276
00:41:43,000 --> 00:41:45,000
日本人就在假名那一堆

1277
00:41:45,000 --> 00:41:48,000
然后中国人就按照拼音放在这个 Alphabet

1278
00:41:48,000 --> 00:41:49,000
这一堆

1279
00:41:49,000 --> 00:41:50,000
我个人是这样去分的

1280
00:41:50,000 --> 00:41:51,000
哦 还这样

1281
00:41:51,000 --> 00:41:52,000
非常好啊

1282
00:41:52,000 --> 00:41:54,000
但是很麻烦啊

1283
00:41:54,000 --> 00:41:55,000
你要每个人

1284
00:41:55,000 --> 00:41:57,000
对 这是一个非常淡沉的事情 对

1285
00:41:57,000 --> 00:41:58,000
对

1286
00:41:58,000 --> 00:42:01,000
所以在那个 Mac 上面

1287
00:42:01,000 --> 00:42:03,000
就是我们的朋友就是江江

1288
00:42:03,000 --> 00:42:05,000
他之前写过一个小软件

1289
00:42:05,000 --> 00:42:08,000
就是自动给那个通讯录里面的

1290
00:42:08,000 --> 00:42:09,000
中文名字的人

1291
00:42:09,000 --> 00:42:11,000
标注他的那个 Fonetic Names

1292
00:42:11,000 --> 00:42:13,000
就是 Fonetic 的信和名

1293
00:42:13,000 --> 00:42:16,000
就这样他就可以在英文环境下

1294
00:42:16,000 --> 00:42:19,000
还可以按照那个读音来排序

1295
00:42:20,000 --> 00:42:23,000
对 这件事比较适合脚本来做

1296
00:42:23,000 --> 00:42:25,000
对 但 iPhone 上好像就这个

1297
00:42:25,000 --> 00:42:26,000
我不知道有人

1298
00:42:26,000 --> 00:42:27,000
应该也是可以的

1299
00:42:27,000 --> 00:42:28,000
就是

1300
00:42:28,000 --> 00:42:29,000
把数据导一下吗

1301
00:42:29,000 --> 00:42:31,000
对对 因为 iPhone 那个就是

1302
00:42:31,000 --> 00:42:32,000
通讯录是可以访问的嘛

1303
00:42:32,000 --> 00:42:33,000
通个 API

1304
00:42:33,000 --> 00:42:34,000
然后你去对他改一下

1305
00:42:34,000 --> 00:42:35,000
对对对

1306
00:42:35,000 --> 00:42:36,000
但这里就会牵涉到他问的那个

1307
00:42:36,000 --> 00:42:37,000
第二个问题

1308
00:42:37,000 --> 00:42:39,000
就怎样得到一个汉字的读音

1309
00:42:39,000 --> 00:42:40,000
因为这个比较简单的

1310
00:42:40,000 --> 00:42:41,000
我就是有一个

1311
00:42:41,000 --> 00:42:42,000
有一个对焦表的

1312
00:42:42,000 --> 00:42:44,000
就是汉字和他的那个拼音的对焦表的

1313
00:42:44,000 --> 00:42:45,000
这个是

1314
00:42:45,000 --> 00:42:47,000
这个是很多系统里面都自带的

1315
00:42:47,000 --> 00:42:48,000
但这个比较 Tricky 的

1316
00:42:48,000 --> 00:42:51,000
就是说有些字是那个多音字

1317
00:42:51,000 --> 00:42:52,000
这个时候

1318
00:42:52,000 --> 00:42:54,000
特别是在那个名字里面

1319
00:42:54,000 --> 00:42:55,000
他有些是很多是非标

1320
00:42:55,000 --> 00:42:57,000
没有就不具不太具备这个参考意义的

1321
00:42:57,000 --> 00:42:59,000
比如说有些有些字的多音字

1322
00:42:59,000 --> 00:43:00,000
你是可以通过这个

1323
00:43:00,000 --> 00:43:01,000
上相文的语义来看出

1324
00:43:01,000 --> 00:43:03,000
他是念哪个的嘛

1325
00:43:03,000 --> 00:43:04,000
但是在名字里面

1326
00:43:04,000 --> 00:43:06,000
其实是一个非常

1327
00:43:06,000 --> 00:43:07,000
Abiture 的一个事情

1328
00:43:07,000 --> 00:43:09,000
比如说我有一个朋友叫

1329
00:43:09,000 --> 00:43:10,000
那个就是

1330
00:43:10,000 --> 00:43:12,000
草字头一个下面东南西北的

1331
00:43:12,000 --> 00:43:13,000
西字那个字

1332
00:43:13,000 --> 00:43:14,000
他可以念西

1333
00:43:14,000 --> 00:43:15,000
可以念欠对吧

1334
00:43:15,000 --> 00:43:16,000
对对

1335
00:43:16,000 --> 00:43:17,000
在名字里面

1336
00:43:17,000 --> 00:43:19,000
很多人都是把他念欠的

1337
00:43:19,000 --> 00:43:20,000
对吧

1338
00:43:20,000 --> 00:43:22,000
但其实在他在选择的时候

1339
00:43:22,000 --> 00:43:24,000
就把他念成念西

1340
00:43:24,000 --> 00:43:25,000
这个时候你说你怎么办

1341
00:43:25,000 --> 00:43:27,000
你没有办法

1342
00:43:27,000 --> 00:43:28,000
对这点还好

1343
00:43:28,000 --> 00:43:29,000
另外有一个问题就是

1344
00:43:29,000 --> 00:43:32,000
有些人的这个信

1345
00:43:32,000 --> 00:43:33,000
的同一个字的写法

1346
00:43:33,000 --> 00:43:36,000
他甚至都有不一样的念法

1347
00:43:36,000 --> 00:43:38,000
信的话

1348
00:43:38,000 --> 00:43:40,000
一般做信的那个音

1349
00:43:40,000 --> 00:43:41,000
会比较特殊的

1350
00:43:41,000 --> 00:43:45,000
就有一些会有白独

1351
00:43:45,000 --> 00:43:46,000
然后这个白独

1352
00:43:46,000 --> 00:43:48,000
又会被这个当成一种传统

1353
00:43:48,000 --> 00:43:50,000
比如说那个最

1354
00:43:50,000 --> 00:43:51,000
我印象最深的就是

1355
00:43:51,000 --> 00:43:53,000
有一个性叫概嘛

1356
00:43:53,000 --> 00:43:55,000
你知道吗就是概子的概

1357
00:43:55,000 --> 00:43:57,000
概教天有一个经济原因

1358
00:43:57,000 --> 00:43:58,000
对

1359
00:43:58,000 --> 00:43:59,000
但是这个信

1360
00:43:59,000 --> 00:44:00,000
其实他在念信的时候

1361
00:44:00,000 --> 00:44:01,000
一个比较规范的话

1362
00:44:01,000 --> 00:44:03,000
应该念葛

1363
00:44:03,000 --> 00:44:04,000
嗯

1364
00:44:04,000 --> 00:44:05,000
对

1365
00:44:05,000 --> 00:44:06,000
但是很多人都觉得

1366
00:44:06,000 --> 00:44:07,000
腐术嘛

1367
00:44:07,000 --> 00:44:08,000
腐术这个腐术

1368
00:44:08,000 --> 00:44:09,000
是

1369
00:44:09,000 --> 00:44:10,000
腐术

1370
00:44:10,000 --> 00:44:11,000
腐术

1371
00:44:11,000 --> 00:44:12,000
对

1372
00:44:12,000 --> 00:44:13,000
他这个难过人的

1373
00:44:13,000 --> 00:44:14,000
应该是小众吧

1374
00:44:14,000 --> 00:44:15,000
对

1375
00:44:15,000 --> 00:44:17,000
就是有一个很明显的小众

1376
00:44:17,000 --> 00:44:19,000
但那个概和葛的问题就是

1377
00:44:19,000 --> 00:44:20,000
很多人他都希望自己

1378
00:44:20,000 --> 00:44:22,000
被念成叫

1379
00:44:22,000 --> 00:44:23,000
概

1380
00:44:23,000 --> 00:44:24,000
就是不要改成葛这个音

1381
00:44:24,000 --> 00:44:25,000
但是有一些人

1382
00:44:25,000 --> 00:44:26,000
他可能祖上传下

1383
00:44:26,000 --> 00:44:27,000
一直都念葛

1384
00:44:27,000 --> 00:44:29,000
所以他又希望这个字念葛

1385
00:44:29,000 --> 00:44:30,000
所以这个字念

1386
00:44:30,000 --> 00:44:32,000
什么音其实也是不一样的

1387
00:44:32,000 --> 00:44:33,000
就是

1388
00:44:33,000 --> 00:44:34,000
就是说

1389
00:44:34,000 --> 00:44:35,000
刚才讲的那个问题

1390
00:44:35,000 --> 00:44:36,000
就信明里面这个读音

1391
00:44:36,000 --> 00:44:38,000
是没有一个规则可以参考

1392
00:44:38,000 --> 00:44:40,000
因为很多是靠他自己

1393
00:44:40,000 --> 00:44:42,000
自定的一个选择来

1394
00:44:42,000 --> 00:44:43,000
怎么念的

1395
00:44:43,000 --> 00:44:44,000
现在天乱

1396
00:44:44,000 --> 00:44:45,000
对

1397
00:44:45,000 --> 00:44:46,000
而且这个问题

1398
00:44:46,000 --> 00:44:47,000
其实并不仅仅是中文

1399
00:44:47,000 --> 00:44:48,000
或者是在

1400
00:44:48,000 --> 00:44:50,000
在在表译文字才有

1401
00:44:50,000 --> 00:44:51,000
就在英文

1402
00:44:51,000 --> 00:44:53,000
或者说在拉丁语

1403
00:44:53,000 --> 00:44:54,000
拉丁自福世界

1404
00:44:54,000 --> 00:44:56,000
甚至是拼自福世界也是有的

1405
00:44:56,000 --> 00:44:57,000
比如说

1406
00:44:57,000 --> 00:44:58,000
前阵子被韩国

1407
00:44:58,000 --> 00:44:59,000
被

1408
00:44:59,000 --> 00:45:00,000
被

1409
00:45:00,000 --> 00:45:02,000
朝鲜弄死的那个美国人

1410
00:45:02,000 --> 00:45:04,000
他的名字叫做

1411
00:45:04,000 --> 00:45:06,000
Warmbeard

1412
00:45:06,000 --> 00:45:08,000
就是你如果你是一个美国人的话

1413
00:45:08,000 --> 00:45:09,000
你念他的名字

1414
00:45:09,000 --> 00:45:11,000
你会念成 Warmbeard

1415
00:45:11,000 --> 00:45:12,000
然后有一天

1416
00:45:12,000 --> 00:45:14,000
但是 Warm

1417
00:45:14,000 --> 00:45:15,000
和 Beard 这两个词

1418
00:45:15,000 --> 00:45:16,000
就是递到了德语词

1419
00:45:16,000 --> 00:45:18,000
包括这个人的整个名字

1420
00:45:18,000 --> 00:45:19,000
他的名字叫什么

1421
00:45:19,000 --> 00:45:21,000
Auto Wambier

1422
00:45:21,000 --> 00:45:23,000
这一听就是一个

1423
00:45:23,000 --> 00:45:24,000
德国后裔

1424
00:45:24,000 --> 00:45:25,000
你知道吧

1425
00:45:25,000 --> 00:45:26,000
就是那种感觉

1426
00:45:26,000 --> 00:45:27,000
就好像

1427
00:45:27,000 --> 00:45:29,000
这种感觉很奇怪

1428
00:45:29,000 --> 00:45:30,000
就好像你是一个华人

1429
00:45:30,000 --> 00:45:31,000
然后

1430
00:45:31,000 --> 00:45:33,000
现在中国人已经是什么

1431
00:45:33,000 --> 00:45:36,000
跑去我们这一代

1432
00:45:36,000 --> 00:45:39,000
就是很多人都是双自明的

1433
00:45:39,000 --> 00:45:41,000
现在中国小孩都起什么

1434
00:45:42,000 --> 00:45:43,000
什么义轩

1435
00:45:43,000 --> 00:45:44,000
子轩

1436
00:45:44,000 --> 00:45:46,000
那种非常

1437
00:45:46,000 --> 00:45:48,000
又能

1438
00:45:48,000 --> 00:45:49,000
说不出来

1439
00:45:49,000 --> 00:45:50,000
奇怪在哪

1440
00:45:50,000 --> 00:45:51,000
那时候有点奇怪

1441
00:45:51,000 --> 00:45:52,000
然后后一天你发现

1442
00:45:52,000 --> 00:45:54,000
应该在美国出生的

1443
00:45:54,000 --> 00:45:55,000
土生土长的华裔

1444
00:45:55,000 --> 00:45:57,000
名字叫

1445
00:45:57,000 --> 00:45:58,000
曾国凡

1446
00:45:58,000 --> 00:46:00,000
或者左宗堂那种感觉

1447
00:46:00,000 --> 00:46:01,000
就

1448
00:46:01,000 --> 00:46:03,000
非常古典

1449
00:46:03,000 --> 00:46:04,000
就是 Auto

1450
00:46:04,000 --> 00:46:06,000
他的中名是什么

1451
00:46:06,000 --> 00:46:08,000
Headgate

1452
00:46:08,000 --> 00:46:10,000
Auto Flade

1453
00:46:10,000 --> 00:46:11,000
Blade Lich

1454
00:46:11,000 --> 00:46:13,000
Wambier

1455
00:46:13,000 --> 00:46:14,000
这样一个名字

1456
00:46:14,000 --> 00:46:15,000
这个名字

1457
00:46:15,000 --> 00:46:16,000
如果你

1458
00:46:16,000 --> 00:46:18,000
如果他是一个德国人的话

1459
00:46:18,000 --> 00:46:20,000
那么他的名字

1460
00:46:20,000 --> 00:46:22,000
会面臨成 Wambier

1461
00:46:22,000 --> 00:46:24,000
但是如果他是一个美国人的话

1462
00:46:24,000 --> 00:46:26,000
包括德国人念他

1463
00:46:26,000 --> 00:46:28,000
在广播里面念这个人的名字的时候

1464
00:46:28,000 --> 00:46:30,000
都会面臨成 Wambier

1465
00:46:30,000 --> 00:46:32,000
就是按美语的发音

1466
00:46:32,000 --> 00:46:34,000
来念

1467
00:46:34,000 --> 00:46:35,000
所以这就是为什么

1468
00:46:35,000 --> 00:46:38,000
刚才说到的那个在 iPhone 的

1469
00:46:38,000 --> 00:46:39,000
联系人里面

1470
00:46:39,000 --> 00:46:40,000
你可以给他添加

1471
00:46:40,000 --> 00:46:42,000
两个

1472
00:46:42,000 --> 00:46:44,000
额外的项目

1473
00:46:44,000 --> 00:46:46,000
一个叫做

1474
00:46:46,000 --> 00:46:48,000
Pronunciation

1475
00:46:48,000 --> 00:46:50,000
Spelling

1476
00:46:50,000 --> 00:46:51,000
Pronunciation 那一种

1477
00:46:51,000 --> 00:46:52,000
另外一个叫做

1478
00:46:52,000 --> 00:46:53,000
Fonetic 那一种

1479
00:46:53,000 --> 00:46:54,000
就是

1480
00:46:54,000 --> 00:46:56,000
我记得这两个之中

1481
00:46:56,000 --> 00:46:58,000
一个会被

1482
00:46:58,000 --> 00:47:01,000
Siri 拿来当做发音的一句

1483
00:47:01,000 --> 00:47:02,000
对

1484
00:47:02,000 --> 00:47:03,000
对

1485
00:47:03,000 --> 00:47:04,000
就比如说你

1486
00:47:04,000 --> 00:47:06,000
比如说 Wutao 这两个字

1487
00:47:06,000 --> 00:47:08,000
在

1488
00:47:10,000 --> 00:47:12,000
在 Fonetic

1489
00:47:12,000 --> 00:47:15,000
名里面写 Wutao

1490
00:47:15,000 --> 00:47:18,000
但是在 Pronunciation 里面

1491
00:47:18,000 --> 00:47:24,000
你可以写 Wo-tau

1492
00:47:24,000 --> 00:47:25,000
比如说

1493
00:47:25,000 --> 00:47:27,000
然后 Siri 会试着

1494
00:47:27,000 --> 00:47:29,000
用 Wutao 这个

1495
00:47:29,000 --> 00:47:31,000
方法来念这个名字

1496
00:47:31,000 --> 00:47:32,000
Pronunciation 就存在

1497
00:47:32,000 --> 00:47:33,000
是给那个

1498
00:47:33,000 --> 00:47:35,000
语音生成那个合成器用的

1499
00:47:35,000 --> 00:47:36,000
对

1500
00:47:36,000 --> 00:47:37,000
我是这么理解的

1501
00:47:37,000 --> 00:47:38,000
但我

1502
00:47:38,000 --> 00:47:39,000
我相信

1503
00:47:39,000 --> 00:47:40,000
我人可以知道

1504
00:47:40,000 --> 00:47:41,000
比如说

1505
00:47:41,000 --> 00:47:43,000
你可以

1506
00:47:43,000 --> 00:47:45,000
用这个功能来告诉 Siri

1507
00:47:45,000 --> 00:47:47,000
说打电话给谁是谁

1508
00:47:47,000 --> 00:47:48,000
实现这样一个功能

1509
00:47:48,000 --> 00:47:50,000
还有一个更直接的办法

1510
00:47:50,000 --> 00:47:51,000
就是 Siri 的话

1511
00:47:51,000 --> 00:47:52,000
你可以直接

1512
00:47:52,000 --> 00:47:53,000
你直接语音教他

1513
00:47:53,000 --> 00:47:54,000
把这个字念成

1514
00:47:54,000 --> 00:47:56,000
你可以教他念成什么

1515
00:47:56,000 --> 00:47:57,000
对

1516
00:47:57,000 --> 00:47:58,000
对

1517
00:47:58,000 --> 00:47:59,000
所以

1518
00:47:59,000 --> 00:48:00,000
对

1519
00:48:00,000 --> 00:48:02,000
所以就专门有这样的一个 Fill

1520
00:48:02,000 --> 00:48:04,000
Fill 的是给

1521
00:48:04,000 --> 00:48:05,000
语音合成器来

1522
00:48:05,000 --> 00:48:07,000
教他念读音的这样一个 Fill 的

1523
00:48:07,000 --> 00:48:08,000
对

1524
00:48:08,000 --> 00:48:09,000
这个 Fill 的好处

1525
00:48:09,000 --> 00:48:10,000
只有 IOS 上才有

1526
00:48:10,000 --> 00:48:11,000
Mac 上是没有这个 Fill

1527
00:48:11,000 --> 00:48:12,000
我刚刚检查了一遍

1528
00:48:12,000 --> 00:48:13,000
对

1529
00:48:13,000 --> 00:48:14,000
因为 Mac 上之前没有 Siri

1530
00:48:14,000 --> 00:48:15,000
所以估计没做

1531
00:48:15,000 --> 00:48:17,000
但现在 Mac 上也有 Siri

1532
00:48:17,000 --> 00:48:18,000
现在有了呀

1533
00:48:18,000 --> 00:48:19,000
怎么办

1534
00:48:19,000 --> 00:48:21,000
但是在那个 Contact

1535
00:48:21,000 --> 00:48:22,000
就是通讯录的那个

1536
00:48:22,000 --> 00:48:24,000
添加那个

1537
00:48:24,000 --> 00:48:25,000
那个叫什么来的

1538
00:48:25,000 --> 00:48:27,000
那个 Fill 的那个里面

1539
00:48:27,000 --> 00:48:28,000
是没有

1540
00:48:28,000 --> 00:48:29,000
没有那个字端的

1541
00:48:29,000 --> 00:48:30,000
没有 Pronunciation

1542
00:48:30,000 --> 00:48:31,000
只有 Fonetic

1543
00:48:31,000 --> 00:48:32,000
对

1544
00:48:32,000 --> 00:48:33,000
应该只有 Fonetic

1545
00:48:33,000 --> 00:48:34,000
Pronunciation

1546
00:48:34,000 --> 00:48:35,000
上面更新到那里来

1547
00:48:35,000 --> 00:48:36,000
anyway

1548
00:48:36,000 --> 00:48:37,000
这个邮件里面

1549
00:48:37,000 --> 00:48:38,000
其实还提了一个非常重要的事

1550
00:48:38,000 --> 00:48:39,000
就是说

1551
00:48:39,000 --> 00:48:40,000
其实我理解

1552
00:48:40,000 --> 00:48:41,000
就是说在这种

1553
00:48:41,000 --> 00:48:43,000
多语言的时候怎么排除

1554
00:48:43,000 --> 00:48:44,000
比如刚刚我们提到的

1555
00:48:44,000 --> 00:48:45,000
这个日文环境和

1556
00:48:45,000 --> 00:48:46,000
这个

1557
00:48:46,000 --> 00:48:48,000
这个德语环境的时候

1558
00:48:48,000 --> 00:48:49,000
它都是有这个区别的

1559
00:48:49,000 --> 00:48:50,000
你没有想过这个问题

1560
00:48:50,000 --> 00:48:52,000
如果一个人他精通

1561
00:48:52,000 --> 00:48:53,000
多国语言

1562
00:48:53,000 --> 00:48:54,000
比如说他会这个日语

1563
00:48:54,000 --> 00:48:55,000
然后韩语

1564
00:48:55,000 --> 00:48:57,000
然后会这个什么阿拉伯语

1565
00:48:57,000 --> 00:48:58,000
对

1566
00:48:58,000 --> 00:48:59,000
然后他都有讲这种

1567
00:48:59,000 --> 00:49:00,000
一种的

1568
00:49:00,000 --> 00:49:01,000
或者是这个名字的

1569
00:49:01,000 --> 00:49:02,000
这个朋友

1570
00:49:02,000 --> 00:49:03,000
他的同学怎么办

1571
00:49:07,000 --> 00:49:08,000
不过我们觉得应该

1572
00:49:08,000 --> 00:49:09,000
把这件事情

1573
00:49:09,000 --> 00:49:12,000
要分好多层次来说

1574
00:49:12,000 --> 00:49:13,000
别这样乱起吧

1575
00:49:14,000 --> 00:49:15,000
首先是有一个

1576
00:49:16,000 --> 00:49:18,000
代码层面的问题

1577
00:49:18,000 --> 00:49:19,000
对不对

1578
00:49:19,000 --> 00:49:20,000
Dedicator 的肯定是一个

1579
00:49:20,000 --> 00:49:21,000
睡觉睡着吗

1580
00:49:21,000 --> 00:49:22,000
对

1581
00:49:22,000 --> 00:49:23,000
然后呢

1582
00:49:23,000 --> 00:49:25,000
首先有操作系统层面的问题

1583
00:49:25,000 --> 00:49:27,000
然后还有 APP 层面的问题

1584
00:49:28,000 --> 00:49:29,000
对 这几个层面

1585
00:49:29,000 --> 00:49:31,000
都会影响到你最后

1586
00:49:31,000 --> 00:49:32,000
看起来的最后的

1587
00:49:32,000 --> 00:49:33,000
排序是怎么样的

1588
00:49:33,000 --> 00:49:34,000
对

1589
00:49:34,000 --> 00:49:35,000
因为后来想一下

1590
00:49:35,000 --> 00:49:37,000
其实在这种在多种语种

1591
00:49:37,000 --> 00:49:39,000
特别是多语种混合环境下

1592
00:49:39,000 --> 00:49:40,000
就是还不是说

1593
00:49:40,000 --> 00:49:42,000
一个系列比如拉丁语系

1594
00:49:42,000 --> 00:49:44,000
还相对来说可以兼容吗

1595
00:49:44,000 --> 00:49:45,000
像刚才讲的那种情况下

1596
00:49:45,000 --> 00:49:46,000
其实还跟你的这个

1597
00:49:46,000 --> 00:49:47,000
叫什么来的

1598
00:49:47,000 --> 00:49:50,000
政治策略有关系

1599
00:49:50,000 --> 00:49:51,000
对

1600
00:49:51,000 --> 00:49:54,000
你说要把这个某种语言的

1601
00:49:54,000 --> 00:49:55,000
这个

1602
00:49:55,000 --> 00:49:56,000
虽然说 Unicode

1603
00:49:56,000 --> 00:49:57,000
里面有一个顺序

1604
00:49:57,000 --> 00:49:58,000
但是如果你在某一种

1605
00:49:58,000 --> 00:50:00,000
环境下你把一种语言的

1606
00:50:00,000 --> 00:50:02,000
名字排在前面

1607
00:50:02,000 --> 00:50:03,000
另一种排在后面

1608
00:50:03,000 --> 00:50:04,000
其实多多少少

1609
00:50:04,000 --> 00:50:06,000
会有一些这个的考量在里面

1610
00:50:06,000 --> 00:50:08,000
所以其实挺复杂的

1611
00:50:08,000 --> 00:50:09,000
一个问题的

1612
00:50:10,000 --> 00:50:11,000
不管怎么样

1613
00:50:11,000 --> 00:50:14,000
我们刚才从一个层面来讲的话

1614
00:50:14,000 --> 00:50:15,000
在操作系统层面

1615
00:50:15,000 --> 00:50:17,000
比如说 iOS 和 MacOS

1616
00:50:17,000 --> 00:50:18,000
就不一样对吧

1617
00:50:18,000 --> 00:50:20,000
针对一个语言的话

1618
00:50:20,000 --> 00:50:23,000
因为 iOS 它是移动的系统

1619
00:50:23,000 --> 00:50:25,000
所以它一个语言

1620
00:50:25,000 --> 00:50:27,000
它只有一个默认的排序

1621
00:50:27,000 --> 00:50:29,000
但是 MacOS 上面

1622
00:50:29,000 --> 00:50:31,000
一个语言你可以选

1623
00:50:31,000 --> 00:50:32,000
好多个排序

1624
00:50:32,000 --> 00:50:34,000
你是可以选的

1625
00:50:34,000 --> 00:50:37,000
然后在操作系统层面

1626
00:50:37,000 --> 00:50:39,000
像刚才我们说的最点心的

1627
00:50:39,000 --> 00:50:41,000
有很多需要通讯录

1628
00:50:41,000 --> 00:50:44,000
它是可以在另外加一个 fail 的

1629
00:50:44,000 --> 00:50:46,000
还有一个很点心的

1630
00:50:46,000 --> 00:50:47,000
是 itunes

1631
00:50:47,000 --> 00:50:49,000
itunes 大概各种歌曲的名字

1632
00:50:49,000 --> 00:50:50,000
因为这个曲名

1633
00:50:50,000 --> 00:50:53,000
也有各国的曲名

1634
00:50:53,000 --> 00:50:54,000
对

1635
00:50:54,000 --> 00:50:56,000
然后它在 mp 3

1636
00:50:56,000 --> 00:50:59,000
或者你在音乐的那个

1637
00:50:59,000 --> 00:51:00,000
就是 metadata 里面

1638
00:51:00,000 --> 00:51:04,000
你可以再继续把这个名字

1639
00:51:04,000 --> 00:51:06,000
像刚才驻人的名字

1640
00:51:06,000 --> 00:51:07,000
把个歌曲的名字

1641
00:51:07,000 --> 00:51:08,000
也是给它注音注进去

1642
00:51:08,000 --> 00:51:09,000
也是可以的

1643
00:51:09,000 --> 00:51:11,000
iOS 比较极贼

1644
00:51:11,000 --> 00:51:12,000
它其实做的不是注音

1645
00:51:12,000 --> 00:51:14,000
它直接给了一个选择叫做 sort order

1646
00:51:14,000 --> 00:51:16,000
排序的顺序定

1647
00:51:16,000 --> 00:51:18,000
它完全不管

1648
00:51:18,000 --> 00:51:20,000
但是它至少就是

1649
00:51:20,000 --> 00:51:22,000
它有一个 metadata 可以写

1650
00:51:22,000 --> 00:51:23,000
对

1651
00:51:23,000 --> 00:51:26,000
然后 itunes 就会去读那个 fail 的

1652
00:51:26,000 --> 00:51:27,000
对吧

1653
00:51:27,000 --> 00:51:30,000
itunes 它给提供的这样的可能

1654
00:51:30,000 --> 00:51:32,000
专门为了排序

1655
00:51:32,000 --> 00:51:34,000
它做了这样一个功能

1656
00:51:34,000 --> 00:51:35,000
像这样的功能是

1657
00:51:35,000 --> 00:51:37,000
Application 层面给它

1658
00:51:37,000 --> 00:51:38,000
设计出来

1659
00:51:38,000 --> 00:51:39,000
然后给它做的

1660
00:51:39,000 --> 00:51:40,000
对

1661
00:51:41,000 --> 00:51:43,000
如果你不在那边做的话

1662
00:51:43,000 --> 00:51:47,000
它会默认先去调用系统的顺序

1663
00:51:47,000 --> 00:51:49,000
它有个 forback 的顺序

1664
00:51:50,000 --> 00:51:51,000
所以

1665
00:51:51,000 --> 00:51:53,000
然后如果系统也没事的话

1666
00:51:53,000 --> 00:51:55,000
它直接就去读内麻的顺序了

1667
00:51:55,000 --> 00:51:56,000
对吧

1668
00:51:56,000 --> 00:51:58,000
它有你口它默认的

1669
00:51:58,000 --> 00:52:01,000
它真正的内麻是什么顺序

1670
00:52:02,000 --> 00:52:03,000
所以你看

1671
00:52:03,000 --> 00:52:06,000
现代软件里面多少复杂性

1672
00:52:06,000 --> 00:52:07,000
就是有这些原因

1673
00:52:07,000 --> 00:52:08,000
导致

1674
00:52:12,000 --> 00:52:13,000
好吧

1675
00:52:13,000 --> 00:52:15,000
我们今天终于可以讲正题了吗

1676
00:52:15,000 --> 00:52:17,000
今天有正题

1677
00:52:18,000 --> 00:52:21,000
今天我们要讲一个非常哈扩的正题

1678
00:52:22,000 --> 00:52:25,000
很多人都没有意识到这个问题的存在

1679
00:52:25,000 --> 00:52:27,000
今天我们要讲的是 UniCode 的

1680
00:52:27,000 --> 00:52:30,000
规范化形式叫 Normalization

1681
00:52:30,000 --> 00:52:33,000
很多人都讲 Normalization 是什么东西

1682
00:52:35,000 --> 00:52:36,000
你来自文自答一下

1683
00:52:36,000 --> 00:52:39,000
它有中文的标准议法吗

1684
00:52:39,000 --> 00:52:42,000
或者我们有什么推荐议法

1685
00:52:42,000 --> 00:52:46,000
因为 UniCode 它就是国际标准爱友

1686
00:52:46,000 --> 00:52:50,000
爱友标准它又是各国的都会写到

1687
00:52:50,000 --> 00:52:52,000
各国的国标

1688
00:52:52,000 --> 00:52:53,000
国家标准里面

1689
00:52:53,000 --> 00:52:55,000
那么中国的国标

1690
00:52:55,000 --> 00:52:59,000
爱友标准中国国标是 1300

1691
00:52:59,000 --> 00:53:02,000
它对 Normalization 的方式叫规范化

1692
00:53:02,000 --> 00:53:06,000
我们在今天节目里面就叫规范化

1693
00:53:07,000 --> 00:53:09,000
要不然挺乱的

1694
00:53:11,000 --> 00:53:13,000
很多朋友就不知道

1695
00:53:13,000 --> 00:53:15,000
还有一个规范化的东西

1696
00:53:15,000 --> 00:53:18,000
其实很简单就是你看到的

1697
00:53:18,000 --> 00:53:20,000
比如说带声调的字符

1698
00:53:20,000 --> 00:53:22,000
比如说拼音

1699
00:53:22,000 --> 00:53:23,000
R

1700
00:53:24,000 --> 00:53:27,000
是字母 A 上面加个所谓的第二声

1701
00:53:27,000 --> 00:53:30,000
你看到的是这样一个字形

1702
00:53:30,000 --> 00:53:34,000
可是它的背后可能是一个编码

1703
00:53:34,000 --> 00:53:37,000
或者它也可能是两个字符

1704
00:53:37,000 --> 00:53:38,000
两个编码

1705
00:53:38,000 --> 00:53:40,000
也就是说一个字母 A 的编码

1706
00:53:40,000 --> 00:53:46,000
加上一个带声调的编码组合而成的东西

1707
00:53:46,000 --> 00:53:47,000
对

1708
00:53:47,000 --> 00:53:50,000
其实就是本质上 Unicode 有一个现象

1709
00:53:50,000 --> 00:53:54,000
就是说当我们看到一串 Unicode 的

1710
00:53:54,000 --> 00:53:57,000
马位的组合的时候

1711
00:53:57,000 --> 00:53:59,000
他们可能在马位上是不同的

1712
00:53:59,000 --> 00:54:02,000
但他们实际上表示的字符

1713
00:54:02,000 --> 00:54:04,000
或者是字符串是相等的

1714
00:54:04,000 --> 00:54:06,000
Unicode 有这样一个所谓的等

1715
00:54:06,000 --> 00:54:09,000
对有一个等加缩的问题

1716
00:54:10,000 --> 00:54:12,000
主要还是一个

1717
00:54:13,000 --> 00:54:16,000
本质上还是有历史的有问题

1718
00:54:16,000 --> 00:54:19,000
它如果当初不是一定要兼容 Unicode

1719
00:54:19,000 --> 00:54:22,000
UnicodeDWG 好像就不会有这个问题

1720
00:54:22,000 --> 00:54:24,000
我是这么一样的

1721
00:54:24,000 --> 00:54:28,000
而且现在 Unicode 是多语言的

1722
00:54:28,000 --> 00:54:30,000
各个语言也都会有这个问题

1723
00:54:30,000 --> 00:54:32,000
所以这个规范的话就越搞越烦

1724
00:54:32,000 --> 00:54:34,000
然后这个东西的话

1725
00:54:34,000 --> 00:54:38,000
有时候你要给它看成是一个字

1726
00:54:38,000 --> 00:54:40,000
因为要看成两个字

1727
00:54:40,000 --> 00:54:41,000
因为有时候必须区别

1728
00:54:41,000 --> 00:54:43,000
就是带声调的和不带声调的

1729
00:54:43,000 --> 00:54:44,000
肯定是两个字

1730
00:54:44,000 --> 00:54:46,000
不一样你不能给它混在一起

1731
00:54:46,000 --> 00:54:49,000
但是有时候你要给它混在一起

1732
00:54:49,000 --> 00:54:51,000
比如说在搜索的时候

1733
00:54:51,000 --> 00:54:53,000
搜索的时候你可能希望

1734
00:54:53,000 --> 00:54:56,000
你只打一个字母 A

1735
00:54:56,000 --> 00:54:57,000
但是你人顺带

1736
00:54:57,000 --> 00:54:59,000
你能把这些带声调的东西

1737
00:54:59,000 --> 00:55:01,000
能一起搜索到

1738
00:55:01,000 --> 00:55:03,000
在后选项能出来

1739
00:55:03,000 --> 00:55:05,000
所以这个时候你又喜欢模糊的

1740
00:55:05,000 --> 00:55:06,000
把这些全部带

1741
00:55:06,000 --> 00:55:08,000
所以这个是有这样的需求的

1742
00:55:08,000 --> 00:55:10,000
有时候你需要区别

1743
00:55:10,000 --> 00:55:13,000
有时候你又不想不区别

1744
00:55:13,000 --> 00:55:15,000
这里有个问题就是

1745
00:55:15,000 --> 00:55:17,000
为什么要同一个码位

1746
00:55:17,000 --> 00:55:18,000
要对应两个

1747
00:55:18,000 --> 00:55:20,000
最开始它产生的原因是什么

1748
00:55:20,000 --> 00:55:22,000
刚才吴陶提了一个解释

1749
00:55:22,000 --> 00:55:24,000
不是是反过来

1750
00:55:24,000 --> 00:55:28,000
是同一个字符会有多个码位

1751
00:55:28,000 --> 00:55:30,000
而不是同一个码位会对应两个字符

1752
00:55:30,000 --> 00:55:32,000
为什么出现这种情况

1753
00:55:32,000 --> 00:55:34,000
就是它的历史背景是什么

1754
00:55:35,000 --> 00:55:36,000
最简单的一个

1755
00:55:36,000 --> 00:55:37,000
比如说

1756
00:55:37,000 --> 00:55:43,000
当时欧洲各自都使用很多

1757
00:55:43,000 --> 00:55:47,000
带有扩展符号的拉名字符

1758
00:55:47,000 --> 00:55:50,000
所以当时阿斯基的高位

1759
00:55:50,000 --> 00:55:52,000
就被拿来做扩展

1760
00:55:52,000 --> 00:55:54,000
然后最常见的就是

1761
00:55:54,000 --> 00:55:56,000
Windows 上的叫做 CPU 252

1762
00:55:56,000 --> 00:55:58,000
还是什么的一个

1763
00:55:58,000 --> 00:56:00,000
代码页

1764
00:56:00,000 --> 00:56:01,000
对

1765
00:56:01,000 --> 00:56:03,000
Windows 直到今天都是在使用

1766
00:56:03,000 --> 00:56:05,000
因为这套非常坑烈的机制

1767
00:56:05,000 --> 00:56:06,000
对

1768
00:56:06,000 --> 00:56:12,000
这是一个不能忽视的历史问题

1769
00:56:12,000 --> 00:56:14,000
所以 Unicle 一开始在做的时候

1770
00:56:14,000 --> 00:56:17,000
我记得是第一位的

1771
00:56:17,000 --> 00:56:19,000
完全兼容阿斯基

1772
00:56:19,000 --> 00:56:21,000
然后此时就出现了一个问题

1773
00:56:21,000 --> 00:56:24,000
比如说 U 上加两点这个字符

1774
00:56:24,000 --> 00:56:26,000
它就有可能出现了

1775
00:56:26,000 --> 00:56:28,000
它就等于在 Unicle 里面

1776
00:56:28,000 --> 00:56:30,000
出现了两种组合的可能

1777
00:56:30,000 --> 00:56:33,000
一种是因为 Unicle 的兼容

1778
00:56:33,000 --> 00:56:35,000
它固有的表达方式

1779
00:56:35,000 --> 00:56:39,000
U 这个字符是在哪个马位上

1780
00:56:39,000 --> 00:56:40,000
然后它会

1781
00:56:40,000 --> 00:56:43,000
它直接把马位

1782
00:56:43,000 --> 00:56:45,000
做进 Unicle 里面

1783
00:56:45,000 --> 00:56:47,000
在这个马位上面

1784
00:56:47,000 --> 00:56:48,000
Unicle 的这个马位上面

1785
00:56:48,000 --> 00:56:50,000
这里就是 U 上加两点

1786
00:56:50,000 --> 00:56:51,000
但于此同时

1787
00:56:51,000 --> 00:56:53,000
它又给出了单独的 U

1788
00:56:53,000 --> 00:56:55,000
和单独的一个两点

1789
00:56:55,000 --> 00:56:56,000
于是此时

1790
00:56:56,000 --> 00:56:57,000
你就又可以用说

1791
00:56:57,000 --> 00:56:59,000
我要一个 U

1792
00:56:59,000 --> 00:57:02,000
然后上加两点来做出这个字符

1793
00:57:02,000 --> 00:57:03,000
这个就是问题吗

1794
00:57:03,000 --> 00:57:07,000
就是为什么会有这种组合的需求存在

1795
00:57:07,000 --> 00:57:08,000
如果说

1796
00:57:08,000 --> 00:57:10,000
我提一个比较极端的情况

1797
00:57:10,000 --> 00:57:12,000
就是如果说我们把所有的组合都是

1798
00:57:12,000 --> 00:57:16,000
组合后的字都变成一个独立的马位

1799
00:57:16,000 --> 00:57:18,000
就不存在这个问题了

1800
00:57:18,000 --> 00:57:19,000
因为首先一方面

1801
00:57:19,000 --> 00:57:23,000
这是它比较节省空间

1802
00:57:23,000 --> 00:57:24,000
另外一个就是

1803
00:57:24,000 --> 00:57:25,000
如果你要组合的话

1804
00:57:25,000 --> 00:57:27,000
你是组合不穷进的

1805
00:57:27,000 --> 00:57:29,000
尤其是比如说有些组合

1806
00:57:29,000 --> 00:57:30,000
一方面有些组合

1807
00:57:30,000 --> 00:57:31,000
可能完全没有意义

1808
00:57:31,000 --> 00:57:32,000
另外一方面

1809
00:57:32,000 --> 00:57:33,000
比如上下越南

1810
00:57:33,000 --> 00:57:37,000
就是一个字符上面可能有四五个

1811
00:57:37,000 --> 00:57:38,000
四五个可能太快了

1812
00:57:38,000 --> 00:57:40,000
三个应该是有可能

1813
00:57:40,000 --> 00:57:41,000
三个也可能

1814
00:57:41,000 --> 00:57:42,000
对

1815
00:57:42,000 --> 00:57:43,000
三个标音符号

1816
00:57:43,000 --> 00:57:44,000
然后你要把所有的

1817
00:57:44,000 --> 00:57:45,000
commitation 弄出来的话

1818
00:57:45,000 --> 00:57:48,000
这对于空间其实是很大的了

1819
00:57:48,000 --> 00:57:49,000
给大家一个比较

1820
00:57:49,000 --> 00:57:51,000
更直观的一个例子

1821
00:57:51,000 --> 00:57:53,000
比如说

1822
00:57:53,000 --> 00:57:54,000
汉语拼音

1823
00:57:54,000 --> 00:57:56,000
U 上有两点是 U

1824
00:57:56,000 --> 00:57:58,000
然后 U 也可以带声调

1825
00:57:58,000 --> 00:58:00,000
UUUU

1826
00:58:00,000 --> 00:58:03,000
所以比如说 U

1827
00:58:03,000 --> 00:58:05,000
因为单纯

1828
00:58:05,000 --> 00:58:06,000
你就可以看

1829
00:58:06,000 --> 00:58:09,000
U 上面加两点

1830
00:58:09,000 --> 00:58:10,000
再加第二声

1831
00:58:10,000 --> 00:58:11,000
这其实是

1832
00:58:11,000 --> 00:58:13,000
到底是一个字还是三个字

1833
00:58:13,000 --> 00:58:14,000
你这个例子举的不对

1834
00:58:14,000 --> 00:58:15,000
U 应该

1835
00:58:15,000 --> 00:58:17,000
U 的时候

1836
00:58:17,000 --> 00:58:22,000
我不说单音节的情况

1837
00:58:22,000 --> 00:58:25,000
我不说汉语拼音的音节情况

1838
00:58:25,000 --> 00:58:27,000
我单纯是说字符

1839
00:58:27,000 --> 00:58:28,000
对

1840
00:58:28,000 --> 00:58:29,000
OK

1841
00:58:29,000 --> 00:58:31,000
有时候绿色的绿对

1842
00:58:31,000 --> 00:58:33,000
你加了一个声调

1843
00:58:33,000 --> 00:58:37,000
然后这次的双点和下降调

1844
00:58:37,000 --> 00:58:38,000
都是存在的

1845
00:58:38,000 --> 00:58:40,000
就是为了

1846
00:58:40,000 --> 00:58:42,000
我们组合层部件

1847
00:58:42,000 --> 00:58:44,000
然后通过一个固定的方法

1848
00:58:44,000 --> 00:58:47,000
来组合的避免去存多种变种

1849
00:58:47,000 --> 00:58:48,000
对

1850
00:58:48,000 --> 00:58:49,000
一个是这个

1851
00:58:49,000 --> 00:58:51,000
另外一方面就是比如说像汉语

1852
00:58:51,000 --> 00:58:53,000
汉语那个字母的

1853
00:58:53,000 --> 00:58:56,000
把几个字母拼在一起的这一套合成机制

1854
00:58:56,000 --> 00:58:57,000
跟那个

1855
00:58:57,000 --> 00:58:59,000
在字母上面加点的合成机制

1856
00:58:59,000 --> 00:59:01,000
实际上是同一套

1857
00:59:01,000 --> 00:59:03,000
那么你

1858
00:59:03,000 --> 00:59:05,000
如果你要把这一套

1859
00:59:05,000 --> 00:59:06,000
只做我要完全

1860
00:59:06,000 --> 00:59:07,000
摒弃这一套

1861
00:59:07,000 --> 00:59:09,000
然后把所有的

1862
00:59:09,000 --> 00:59:10,000
混合全都做出来的话

1863
00:59:10,000 --> 00:59:12,000
那汉语的混合

1864
00:59:12,000 --> 00:59:14,000
很合杀术

1865
00:59:14,000 --> 00:59:15,000
一个 play

1866
00:59:15,000 --> 00:59:16,000
那曾经就做

1867
00:59:16,000 --> 00:59:17,000
对吧

1868
00:59:17,000 --> 00:59:18,000
对吧

1869
00:59:18,000 --> 00:59:21,000
UTF-18 UTF-16 就不够用了是吧

1870
00:59:21,000 --> 00:59:22,000
对

1871
00:59:22,000 --> 00:59:24,000
我记得微软好像为了这事情

1872
00:59:24,000 --> 00:59:25,000
就 hack 过这个事情

1873
00:59:25,000 --> 00:59:28,000
还把 unicode 的标准给 hack

1874
00:59:28,000 --> 00:59:32,000
所以 unicode 标准在汉语有坑吗

1875
00:59:32,000 --> 00:59:33,000
还特别乱

1876
00:59:33,000 --> 00:59:34,000
对 特别乱

1877
00:59:34,000 --> 00:59:35,000
没有 首先是这样子的

1878
00:59:35,000 --> 00:59:36,000
就是说

1879
00:59:36,000 --> 00:59:38,000
如果大家觉得要省边码的话

1880
00:59:38,000 --> 00:59:39,000
就是说像

1881
00:59:39,000 --> 00:59:40,000
就不用组合

1882
00:59:40,000 --> 00:59:41,000
对吧

1883
00:59:41,000 --> 00:59:42,000
就给它当

1884
00:59:42,000 --> 00:59:43,000
你就给它当成是一个东西的话

1885
00:59:43,000 --> 00:59:45,000
这会在不同语言里面

1886
00:59:45,000 --> 00:59:47,000
会有不同的认知

1887
00:59:47,000 --> 00:59:49,000
比如说在德语里面

1888
00:59:49,000 --> 00:59:50,000
乌善加两点

1889
00:59:50,000 --> 00:59:51,000
它就是一个字母

1890
00:59:51,000 --> 00:59:55,000
对于普通的德文的母语者来讲

1891
00:59:55,000 --> 00:59:56,000
它是一个字母

1892
00:59:56,000 --> 00:59:58,000
它没有这种组合的感觉

1893
00:59:58,000 --> 00:59:59,000
就是

1894
00:59:59,000 --> 01:00:01,000
像比如说在法语里面

1895
01:00:01,000 --> 01:00:04,000
它底下有个 C 底下可以加个软音符

1896
01:00:04,000 --> 01:00:07,000
然后像这样的

1897
01:00:07,000 --> 01:00:09,000
对于说法语的人来讲

1898
01:00:09,000 --> 01:00:10,000
这是一个字母

1899
01:00:10,000 --> 01:00:12,000
而不会说是什么 C 加一个符号

1900
01:00:12,000 --> 01:00:13,000
对

1901
01:00:13,000 --> 01:00:14,000
所以在历史上

1902
01:00:14,000 --> 01:00:15,000
而且在历史上

1903
01:00:15,000 --> 01:00:16,000
就各国

1904
01:00:16,000 --> 01:00:18,000
因为它自秦的对 Askie 进行扩充

1905
01:00:18,000 --> 01:00:20,000
所以它也有个向后兼容的

1906
01:00:20,000 --> 01:00:21,000
一个需要

1907
01:00:21,000 --> 01:00:22,000
所以它必须有这样

1908
01:00:22,000 --> 01:00:24,000
就当成一个字母的

1909
01:00:24,000 --> 01:00:26,000
这样的需求

1910
01:00:26,000 --> 01:00:29,000
然后又有想分开的需求

1911
01:00:29,000 --> 01:00:31,000
就是因为你有时候

1912
01:00:31,000 --> 01:00:32,000
会加的无穷尽

1913
01:00:32,000 --> 01:00:35,000
还是说有这种单独

1914
01:00:35,000 --> 01:00:38,000
就第二声的这样的东西

1915
01:00:38,000 --> 01:00:40,000
或者两点这样的东西

1916
01:00:40,000 --> 01:00:41,000
这样的你可以自由的

1917
01:00:41,000 --> 01:00:43,000
把其他的字母上面加

1918
01:00:43,000 --> 01:00:45,000
这样明显是更灵活的

1919
01:00:45,000 --> 01:00:47,000
虽然很灵活

1920
01:00:47,000 --> 01:00:48,000
但是你就浪费了马味

1921
01:00:48,000 --> 01:00:49,000
就变成

1922
01:00:49,000 --> 01:00:50,000
原来一个字符

1923
01:00:50,000 --> 01:00:52,000
就可以搞定的东西

1924
01:00:52,000 --> 01:00:53,000
现在就变成两个字符了

1925
01:00:53,000 --> 01:00:54,000
然后

1926
01:00:54,000 --> 01:00:57,000
现在的历史结果就变成

1927
01:00:57,000 --> 01:00:59,000
有的时候又要一个字符

1928
01:00:59,000 --> 01:01:00,000
有时候要两个字符

1929
01:01:00,000 --> 01:01:01,000
然后又有向后兼容性

1930
01:01:01,000 --> 01:01:02,000
那没有办法

1931
01:01:02,000 --> 01:01:05,000
那就大家统一起来

1932
01:01:05,000 --> 01:01:07,000
unicode 就搞得这样出一个

1933
01:01:07,000 --> 01:01:09,000
一个 normalization

1934
01:01:09,000 --> 01:01:11,000
就是所谓的规范化的一个形式

1935
01:01:11,000 --> 01:01:12,000
对

1936
01:01:12,000 --> 01:01:13,000
而且其实我们

1937
01:01:13,000 --> 01:01:15,000
刚刚一直在讲这个组合的问题

1938
01:01:15,000 --> 01:01:16,000
然后事实上

1939
01:01:16,000 --> 01:01:19,000
unicode 的等价性问题

1940
01:01:19,000 --> 01:01:20,000
或者说 normalization 问题

1941
01:01:20,000 --> 01:01:23,000
它不仅仅要解决组合的问题

1942
01:01:23,000 --> 01:01:25,000
它要解决的是

1943
01:01:25,000 --> 01:01:27,000
两个字符之间

1944
01:01:27,000 --> 01:01:28,000
他们虽然马味是不同的

1945
01:01:28,000 --> 01:01:30,000
他们各自也只有一个马味的时候

1946
01:01:30,000 --> 01:01:32,000
他们也有可能是等价的

1947
01:01:32,000 --> 01:01:33,000
比如举一个例子

1948
01:01:33,000 --> 01:01:36,000
就是 Omega 和单位 Omu 之间

1949
01:01:36,000 --> 01:01:38,000
他们其实各有一个马味

1950
01:01:38,000 --> 01:01:39,000
但他们其实本质上

1951
01:01:39,000 --> 01:01:40,000
是完全是同一个字符

1952
01:01:40,000 --> 01:01:41,000
那么他们有的时候

1953
01:01:41,000 --> 01:01:44,000
也需要一种等价的处理方式

1954
01:01:44,000 --> 01:01:45,000
对

1955
01:01:46,000 --> 01:01:48,000
这就是那个认知的问题

1956
01:01:48,000 --> 01:01:49,000
就是我们人类在说

1957
01:01:49,000 --> 01:01:51,000
我看见这个符号的时候

1958
01:01:51,000 --> 01:01:54,000
我想的是哪一个东西

1959
01:01:54,000 --> 01:01:55,000
对了

1960
01:01:55,000 --> 01:01:57,000
另外还有像日语的一些遗留问题

1961
01:01:57,000 --> 01:02:00,000
比如说日语有半角和全角的问题

1962
01:02:00,000 --> 01:02:01,000
这样子

1963
01:02:01,000 --> 01:02:03,000
日语就坑多了

1964
01:02:03,000 --> 01:02:04,000
因为大家也知道

1965
01:02:04,000 --> 01:02:05,000
比如说像日文普通的

1966
01:02:05,000 --> 01:02:06,000
50 英课里面

1967
01:02:06,000 --> 01:02:07,000
Kakiku Geiko

1968
01:02:07,000 --> 01:02:10,000
加上两点就会变成卓英

1969
01:02:10,000 --> 01:02:12,000
就变成 Kakiku Geiko

1970
01:02:12,000 --> 01:02:15,000
所以首先它就会有这种

1971
01:02:15,000 --> 01:02:16,000
所谓的加点

1972
01:02:16,000 --> 01:02:18,000
这种组合的问题

1973
01:02:18,000 --> 01:02:19,000
比如说 Ka

1974
01:02:19,000 --> 01:02:20,000
如果是 Ka 的话

1975
01:02:20,000 --> 01:02:22,000
它可能是一个字 Ka

1976
01:02:22,000 --> 01:02:27,000
也可能是 Ka 加上两点变成的 Ka

1977
01:02:27,000 --> 01:02:28,000
首先就是有刚才说的

1978
01:02:28,000 --> 01:02:29,000
这个组合问题

1979
01:02:29,000 --> 01:02:30,000
然后也有刚才一个

1980
01:02:30,000 --> 01:02:32,000
字形不同的问题

1981
01:02:32,000 --> 01:02:34,000
就因为要有那个等价关系

1982
01:02:34,000 --> 01:02:35,000
一个 Ka 的话

1983
01:02:35,000 --> 01:02:38,000
它可能可以是半角的

1984
01:02:38,000 --> 01:02:40,000
也可以是全角的

1985
01:02:40,000 --> 01:02:42,000
半角的片假名

1986
01:02:42,000 --> 01:02:44,000
也是因为

1987
01:02:44,000 --> 01:02:47,000
历史上有

1988
01:02:47,000 --> 01:02:49,000
阿斯基日本人自己扩展的问题

1989
01:02:49,000 --> 01:02:51,000
所以他必须有一个向后金融性

1990
01:02:51,000 --> 01:02:54,000
他要保持半角片假名

1991
01:02:54,000 --> 01:02:56,000
就已经发电报时候用的

1992
01:02:56,000 --> 01:02:57,000
所以这也是一个向后金融

1993
01:02:57,000 --> 01:02:59,000
留下来的一个坑

1994
01:02:59,000 --> 01:03:01,000
对 基本上就是当年跑步

1995
01:03:01,000 --> 01:03:03,000
进入新鲜时代的这些国家

1996
01:03:03,000 --> 01:03:04,000
各自为战

1997
01:03:04,000 --> 01:03:06,000
然后

1998
01:03:06,000 --> 01:03:08,000
才导致了今天

1999
01:03:08,000 --> 01:03:11,000
才导致了今天有什么 ISO 8859

2000
01:03:11,000 --> 01:03:14,000
或者是 JES 的 Standa

2001
01:03:14,000 --> 01:03:16,000
然后 Uniko 的布德布

2002
01:03:16,000 --> 01:03:18,000
捏制彼此把这些历史有的问题

2003
01:03:18,000 --> 01:03:19,000
全都收进来

2004
01:03:19,000 --> 01:03:20,000
所以才会有这样的问题

2005
01:03:20,000 --> 01:03:22,000
就如果我们今天能够把

2006
01:03:22,000 --> 01:03:23,000
人类社会推倒重来

2007
01:03:23,000 --> 01:03:24,000
然后把信息技术

2008
01:03:24,000 --> 01:03:25,000
从头再来的话

2009
01:03:25,000 --> 01:03:27,000
很多东西都会不一样的

2010
01:03:27,000 --> 01:03:29,000
阿斯基也是

2011
01:03:29,000 --> 01:03:31,000
编码也是一面的一个

2012
01:03:33,000 --> 01:03:36,000
所以规范化解决的问题

2013
01:03:36,000 --> 01:03:37,000
就是说

2014
01:03:37,000 --> 01:03:38,000
Ka

2015
01:03:38,000 --> 01:03:40,000
它是一个

2016
01:03:40,000 --> 01:03:41,000
可以理解一下

2017
01:03:41,000 --> 01:03:42,000
它是一个

2018
01:03:42,000 --> 01:03:44,000
查找的一个表

2019
01:03:44,000 --> 01:03:46,000
然后通过这个表

2020
01:03:46,000 --> 01:03:47,000
可以找到说

2021
01:03:47,000 --> 01:03:49,000
哪些 Unicode 的这种

2022
01:03:49,000 --> 01:03:51,000
一个 Unicode 制服串

2023
01:03:51,000 --> 01:03:53,000
它两个的意义其实等价了

2024
01:03:53,000 --> 01:03:55,000
它解决这么一个问题

2025
01:03:55,000 --> 01:03:57,000
所以大家去看 Unicode 的话

2026
01:03:57,000 --> 01:03:59,000
就专门它有个标准附路

2027
01:03:59,000 --> 01:04:02,000
Normalization 是在标准附路的

2028
01:04:02,000 --> 01:04:04,000
第 15 号

2029
01:04:04,000 --> 01:04:06,000
里面会有具体的组合

2030
01:04:06,000 --> 01:04:07,000
是等于什么

2031
01:04:07,000 --> 01:04:09,000
它有机制的介绍

2032
01:04:09,000 --> 01:04:11,000
和各个语言的

2033
01:04:11,000 --> 01:04:12,000
所有 Unicode 里面

2034
01:04:12,000 --> 01:04:13,000
带的 Normalization

2035
01:04:13,000 --> 01:04:15,000
它有一个表格 Charles 都有

2036
01:04:15,000 --> 01:04:16,000
然后如果大家去看

2037
01:04:16,000 --> 01:04:18,000
发现各个语言都有

2038
01:04:18,000 --> 01:04:20,000
很奇怪的各种等价

2039
01:04:20,000 --> 01:04:21,000
对

2040
01:04:21,000 --> 01:04:23,000
其实我记得以前

2041
01:04:23,000 --> 01:04:25,000
SWIFT 的语言

2042
01:04:25,000 --> 01:04:27,000
当然这个比较

2043
01:04:27,000 --> 01:04:29,000
这一部分可能比较内合空空

2044
01:04:29,000 --> 01:04:30,000
就是 SWIFT 的语言

2045
01:04:30,000 --> 01:04:32,000
好像在上一版里面

2046
01:04:32,000 --> 01:04:35,000
又改变了自付串的表达方法

2047
01:04:35,000 --> 01:04:37,000
自付串现在又是一个 collector

2048
01:04:38,000 --> 01:04:40,000
并且它就是

2049
01:04:40,000 --> 01:04:42,000
支持你直接 comparise

2050
01:04:42,000 --> 01:04:43,000
两个自付串

2051
01:04:44,000 --> 01:04:45,000
是否相当

2052
01:04:45,000 --> 01:04:47,000
然后相当的依据就是

2053
01:04:47,000 --> 01:04:48,000
他们的

2054
01:04:49,000 --> 01:04:51,000
在做 UnicodeNormalization 之后

2055
01:04:51,000 --> 01:04:52,000
是不是相当

2056
01:04:52,000 --> 01:04:53,000
比如说你

2057
01:04:53,000 --> 01:04:55,000
这两个自付串可能在

2058
01:04:57,000 --> 01:04:58,000
byte 层面上是不一样的

2059
01:04:58,000 --> 01:04:59,000
一个是

2060
01:05:01,000 --> 01:05:03,000
一个自付串里面的 U

2061
01:05:03,000 --> 01:05:04,000
上面加点

2062
01:05:04,000 --> 01:05:05,000
可能是 Askhe 的

2063
01:05:05,000 --> 01:05:06,000
那个 byte 20

2064
01:05:06,000 --> 01:05:08,000
另外一个可能是一个 U

2065
01:05:08,000 --> 01:05:09,000
加上两个点

2066
01:05:09,000 --> 01:05:11,000
但是如果你问

2067
01:05:11,000 --> 01:05:12,000
在 SWIFT 里面

2068
01:05:12,000 --> 01:05:13,000
问这两个自付串是不是相当

2069
01:05:13,000 --> 01:05:16,000
会说这两个自付串是相当的

2070
01:05:18,000 --> 01:05:19,000
所以这有说

2071
01:05:19,000 --> 01:05:21,000
不太喜欢 SWIFT 的地方

2072
01:05:21,000 --> 01:05:22,000
他老是把一些

2073
01:05:22,000 --> 01:05:24,000
本来该交给 library 来做的事情

2074
01:05:24,000 --> 01:05:27,000
放到 language 层面来搞

2075
01:05:27,000 --> 01:05:28,000
就搞得很乱

2076
01:05:29,000 --> 01:05:31,000
它没有某一种选项机制

2077
01:05:31,000 --> 01:05:33,000
什么情况下

2078
01:05:33,000 --> 01:05:34,000
我要认为他们是相当

2079
01:05:34,000 --> 01:05:35,000
什么情况下

2080
01:05:35,000 --> 01:05:36,000
认为他们是不相当

2081
01:05:36,000 --> 01:05:37,000
其实现在是有的

2082
01:05:37,000 --> 01:05:40,000
现在的思路

2083
01:05:40,000 --> 01:05:43,000
如果你把它当做一个

2084
01:05:43,000 --> 01:05:45,000
String 来处理的话

2085
01:05:45,000 --> 01:05:47,000
那么它默认是一个 UnicodeString

2086
01:05:47,000 --> 01:05:48,000
然后我刚才说的

2087
01:05:48,000 --> 01:05:50,000
他们在 Normalization 之后

2088
01:05:50,000 --> 01:05:52,000
成了相当

2089
01:05:52,000 --> 01:05:53,000
就算相当

2090
01:05:53,000 --> 01:05:55,000
而如果一定要比较

2091
01:05:55,000 --> 01:05:57,000
比较他们在 byte 层面上

2092
01:05:57,000 --> 01:05:58,000
大小的话

2093
01:05:58,000 --> 01:06:00,000
你需要取出他们的

2094
01:06:00,000 --> 01:06:01,000
我想象一下

2095
01:06:01,000 --> 01:06:02,000
是 Charleset

2096
01:06:02,000 --> 01:06:03,000
还是

2097
01:06:03,000 --> 01:06:05,000
你可以把他们

2098
01:06:05,000 --> 01:06:07,000
转换为另外一种形式来比较

2099
01:06:07,000 --> 01:06:08,000
然后这样的话

2100
01:06:08,000 --> 01:06:10,000
再比较就不相当

2101
01:06:13,000 --> 01:06:14,000
好吧

2102
01:06:14,000 --> 01:06:16,000
看来 Normalization 是很必要的

2103
01:06:16,000 --> 01:06:18,000
我们再给大家介绍

2104
01:06:18,000 --> 01:06:20,000
各种不同的 Normalization

2105
01:06:20,000 --> 01:06:21,000
规范化

2106
01:06:21,000 --> 01:06:22,000
这是另外一个坑

2107
01:06:22,000 --> 01:06:23,000
大家都来做规范化

2108
01:06:23,000 --> 01:06:24,000
就好了吗

2109
01:06:24,000 --> 01:06:25,000
同样规范化

2110
01:06:25,000 --> 01:06:27,000
大家都按同样的规范化来做

2111
01:06:27,000 --> 01:06:29,000
这个事情也没什么不同

2112
01:06:29,000 --> 01:06:30,000
规范化的方法不一样

2113
01:06:30,000 --> 01:06:31,000
对

2114
01:06:31,000 --> 01:06:32,000
这个坑

2115
01:06:32,000 --> 01:06:33,000
哎呀 真是的

2116
01:06:33,000 --> 01:06:35,000
我们需要一个 MetanNormalization

2117
01:06:37,000 --> 01:06:38,000
其实这里有

2118
01:06:38,000 --> 01:06:39,000
我觉得有两个层面

2119
01:06:39,000 --> 01:06:40,000
首先就是

2120
01:06:40,000 --> 01:06:41,000
我们刚才说了

2121
01:06:41,000 --> 01:06:42,000
规范化

2122
01:06:42,000 --> 01:06:43,000
它要解决的是

2123
01:06:43,000 --> 01:06:45,000
两个 Unicode 的串

2124
01:06:45,000 --> 01:06:47,000
它是不是等价

2125
01:06:47,000 --> 01:06:48,000
这样一个问题

2126
01:06:48,000 --> 01:06:49,000
那么这个等价

2127
01:06:49,000 --> 01:06:51,000
其实是有多种意义的

2128
01:06:51,000 --> 01:06:52,000
或者说有多种用途的

2129
01:06:52,000 --> 01:06:53,000
有的时候

2130
01:06:53,000 --> 01:06:54,000
我们希望这个等价

2131
01:06:54,000 --> 01:06:55,000
是一个

2132
01:06:55,000 --> 01:06:57,000
相对来说比较严格的等价

2133
01:06:57,000 --> 01:06:58,000
他们只是

2134
01:06:58,000 --> 01:07:00,000
我们对一种自福的分解方式

2135
01:07:00,000 --> 01:07:02,000
或者组合方式的认知不同

2136
01:07:02,000 --> 01:07:03,000
那么有的时候

2137
01:07:03,000 --> 01:07:04,000
我们可能对这个等价

2138
01:07:04,000 --> 01:07:06,000
要求是比较宽松的

2139
01:07:06,000 --> 01:07:07,000
他们可能是一种

2140
01:07:07,000 --> 01:07:09,000
更宽松的予以层面的等价

2141
01:07:09,000 --> 01:07:11,000
因为我们有搜索的需求

2142
01:07:13,000 --> 01:07:14,000
所以呢

2143
01:07:14,000 --> 01:07:16,000
就是所谓的规范化

2144
01:07:16,000 --> 01:07:18,000
它有两大类

2145
01:07:18,000 --> 01:07:19,000
然后每个大类

2146
01:07:19,000 --> 01:07:21,000
又有两小类

2147
01:07:21,000 --> 01:07:22,000
所以一共有四种

2148
01:07:24,000 --> 01:07:26,000
两大类就是标准

2149
01:07:26,000 --> 01:07:29,000
标准等价和兼容性的等价

2150
01:07:29,000 --> 01:07:31,000
刚才说的兼容就是为了

2151
01:07:31,000 --> 01:07:32,000
大家能

2152
01:07:32,000 --> 01:07:33,000
比如说为了搜索

2153
01:07:33,000 --> 01:07:34,000
我能找到吗

2154
01:07:34,000 --> 01:07:35,000
所以它有个相后兼容的需求

2155
01:07:35,000 --> 01:07:37,000
兼容的话它有两种

2156
01:07:37,000 --> 01:07:39,000
标准的规范化

2157
01:07:39,000 --> 01:07:40,000
有两种

2158
01:07:40,000 --> 01:07:42,000
一种就是叫什么

2159
01:07:42,000 --> 01:07:43,000
D 型

2160
01:07:43,000 --> 01:07:44,000
有 C 型 D 型

2161
01:07:44,000 --> 01:07:46,000
C 型那个叫什么

2162
01:07:46,000 --> 01:07:49,000
先分解后

2163
01:07:49,000 --> 01:07:51,000
后合成是吧

2164
01:07:51,000 --> 01:07:53,000
对 先 D-composite

2165
01:07:53,000 --> 01:07:55,000
然后再 composite

2166
01:07:55,000 --> 01:07:58,000
然后 D 型的话

2167
01:07:58,000 --> 01:08:00,000
就是分解掉

2168
01:08:00,000 --> 01:08:02,000
这个按的分解掉

2169
01:08:02,000 --> 01:08:04,000
然后兼容分解的

2170
01:08:04,000 --> 01:08:05,000
两小类也是

2171
01:08:05,000 --> 01:08:06,000
就是兼容的

2172
01:08:06,000 --> 01:08:07,000
默认是分解的

2173
01:08:07,000 --> 01:08:09,000
或者是兼容性的

2174
01:08:09,000 --> 01:08:11,000
先分解后

2175
01:08:11,000 --> 01:08:13,000
后组合

2176
01:08:14,000 --> 01:08:16,000
然后很可能一点就是

2177
01:08:16,000 --> 01:08:18,000
操作系统它又分别又采用了

2178
01:08:18,000 --> 01:08:20,000
采用了不同的方法

2179
01:08:20,000 --> 01:08:21,000
所以呢

2180
01:08:21,000 --> 01:08:23,000
这又跟操作系统有关系

2181
01:08:23,000 --> 01:08:24,000
那最近呢

2182
01:08:24,000 --> 01:08:25,000
这个 nomenization

2183
01:08:25,000 --> 01:08:27,000
提上话题的

2184
01:08:27,000 --> 01:08:29,000
就有一个很有意思的一个时机

2185
01:08:29,000 --> 01:08:30,000
就是因为

2186
01:08:30,000 --> 01:08:32,000
刚好苹果要改文件系统了

2187
01:08:32,000 --> 01:08:33,000
OK

2188
01:08:33,000 --> 01:08:35,000
上次 WD-C 出了消息吧

2189
01:08:35,000 --> 01:08:36,000
对

2190
01:08:36,000 --> 01:08:39,000
我们好像之前还提过了

2191
01:08:39,000 --> 01:08:40,000
对

2192
01:08:40,000 --> 01:08:41,000
现在我们跑的

2193
01:08:41,000 --> 01:08:45,000
iOS 10.3

2194
01:08:45,000 --> 01:08:46,000
现在的 10.3

2195
01:08:46,000 --> 01:08:48,000
已经是新的系统了

2196
01:08:48,000 --> 01:08:50,000
对 已经是 APFS 了

2197
01:08:50,000 --> 01:08:51,000
对

2198
01:08:52,000 --> 01:08:54,000
这 Apple Fire System 吧

2199
01:08:54,000 --> 01:08:55,000
你们知道为什么

2200
01:08:55,000 --> 01:08:57,000
明明是 Apple Fire System

2201
01:08:57,000 --> 01:08:58,000
那为什么要缩写

2202
01:08:58,000 --> 01:08:59,000
APFS 吗

2203
01:08:59,000 --> 01:09:01,000
而不是 AFS 吗

2204
01:09:01,000 --> 01:09:02,000
Fs 被占了呀

2205
01:09:04,000 --> 01:09:05,000
对 原来因为有一个

2206
01:09:05,000 --> 01:09:06,000
那个

2207
01:09:06,000 --> 01:09:07,000
苹果文件系的服务嘛

2208
01:09:07,000 --> 01:09:09,000
Apple Fire Service

2209
01:09:09,000 --> 01:09:12,000
刚说哪个版本的 CR

2210
01:09:12,000 --> 01:09:14,000
已经是 APFS

2211
01:09:14,000 --> 01:09:16,000
下一个就是

2212
01:09:16,000 --> 01:09:17,000
Hi-Serer 才会是

2213
01:09:17,000 --> 01:09:18,000
Hi-Serer 才是

2214
01:09:19,000 --> 01:09:20,000
iOS 的话更快

2215
01:09:20,000 --> 01:09:23,000
iOS 在 10.3 就已经

2216
01:09:23,000 --> 01:09:25,000
把这个文件

2217
01:09:25,000 --> 01:09:27,000
改为了 APFS 了

2218
01:09:29,000 --> 01:09:31,000
在之前也就是说

2219
01:09:31,000 --> 01:09:33,000
现在的我们的 iMac

2220
01:09:33,000 --> 01:09:35,000
都是 HFS 加

2221
01:09:35,000 --> 01:09:36,000
这是一个超

2222
01:09:36,000 --> 01:09:37,000
好老啊

2223
01:09:37,000 --> 01:09:38,000
这个已经十几年

2224
01:09:38,000 --> 01:09:39,000
多少长时间了

2225
01:09:39,000 --> 01:09:41,000
八几年的文件系统

2226
01:09:41,000 --> 01:09:42,000
超老

2227
01:09:42,000 --> 01:09:43,000
对

2228
01:09:43,000 --> 01:09:46,000
终于要苹果一咬牙

2229
01:09:46,000 --> 01:09:47,000
一狠心要换

2230
01:09:47,000 --> 01:09:48,000
把它换掉

2231
01:09:48,000 --> 01:09:49,000
换掉了以后

2232
01:09:49,000 --> 01:09:50,000
就出现了一个问题

2233
01:09:50,000 --> 01:09:52,000
就是在新的

2234
01:09:52,000 --> 01:09:54,000
APFS 里面

2235
01:09:54,000 --> 01:09:57,000
它把原来的

2236
01:09:57,000 --> 01:09:58,000
系统默认的

2237
01:09:58,000 --> 01:09:59,000
Normalization 的

2238
01:09:59,000 --> 01:10:00,000
换掉了

2239
01:10:00,000 --> 01:10:01,000
因为新的

2240
01:10:01,000 --> 01:10:03,000
APFS 它是叫

2241
01:10:03,000 --> 01:10:04,000
Normalization 的

2242
01:10:04,000 --> 01:10:05,000
Insensitive

2243
01:10:05,000 --> 01:10:06,000
它是不敏感的

2244
01:10:06,000 --> 01:10:09,000
对这个规范法不敏感的

2245
01:10:09,000 --> 01:10:10,000
所以就说

2246
01:10:11,000 --> 01:10:12,000
无论

2247
01:10:12,000 --> 01:10:14,000
到时候你就是

2248
01:10:14,000 --> 01:10:16,000
它都能找到这个文件

2249
01:10:16,000 --> 01:10:17,000
因为刚才说了

2250
01:10:17,000 --> 01:10:19,000
如果你对它不敏感的话

2251
01:10:19,000 --> 01:10:21,000
就更容易搜索到嘛

2252
01:10:21,000 --> 01:10:23,000
无论你是用什么样的

2253
01:10:23,000 --> 01:10:24,000
规范法来做的话

2254
01:10:24,000 --> 01:10:26,000
它都能指向这个文件

2255
01:10:27,000 --> 01:10:30,000
以前会有坑的问题

2256
01:10:30,000 --> 01:10:31,000
而对于

2257
01:10:31,000 --> 01:10:32,000
用日语的朋友来讲

2258
01:10:32,000 --> 01:10:34,000
这个是最坑的问题

2259
01:10:34,000 --> 01:10:35,000
我们在我刚才说了

2260
01:10:35,000 --> 01:10:36,000
就因为日文

2261
01:10:36,000 --> 01:10:37,000
经常要用

2262
01:10:37,000 --> 01:10:38,000
会涉及到

2263
01:10:38,000 --> 01:10:40,000
就采到这个规范法的坑

2264
01:10:40,000 --> 01:10:41,000
是因为日文

2265
01:10:41,000 --> 01:10:42,000
像刚才说的

2266
01:10:42,000 --> 01:10:44,000
拙音点是经常用的嘛

2267
01:10:44,000 --> 01:10:46,000
然后经常会出现

2268
01:10:46,000 --> 01:10:49,000
在日文的 Windows 的文件名

2269
01:10:49,000 --> 01:10:51,000
考到 Mac 的时候

2270
01:10:51,000 --> 01:10:52,000
刚才说

2271
01:10:52,000 --> 01:10:54,000
凡是带有那个拙音点的字

2272
01:10:54,000 --> 01:10:56,000
放到 Mac 里面

2273
01:10:56,000 --> 01:10:59,000
就被拆成了两个字

2274
01:11:00,000 --> 01:11:02,000
然后因为是两个字

2275
01:11:02,000 --> 01:11:04,000
你还可以一个字删除

2276
01:11:04,000 --> 01:11:05,000
所以你可以把那个拙音点

2277
01:11:05,000 --> 01:11:07,000
分别删除

2278
01:11:08,000 --> 01:11:10,000
这是因为在

2279
01:11:10,000 --> 01:11:12,000
老的 HFS 加的时候

2280
01:11:12,000 --> 01:11:14,000
也就是 Mac

2281
01:11:14,000 --> 01:11:17,000
现在用的这个系统里面

2282
01:11:17,000 --> 01:11:19,000
它对 Normalization 的处理

2283
01:11:19,000 --> 01:11:20,000
是不一样的

2284
01:11:20,000 --> 01:11:22,000
因为它采用的是

2285
01:11:22,000 --> 01:11:24,000
分解优先

2286
01:11:24,000 --> 01:11:26,000
所以它会把这个字

2287
01:11:26,000 --> 01:11:28,000
拆成认诚是两个字

2288
01:11:28,000 --> 01:11:31,000
这里可能要解释一下背景

2289
01:11:31,000 --> 01:11:33,000
就是为什么从改了一个文件

2290
01:11:33,000 --> 01:11:36,000
现在会导致 Normalization 的问题

2291
01:11:36,000 --> 01:11:38,000
因为 HFS Plus

2292
01:11:38,000 --> 01:11:40,000
就是旧的那个文件系统

2293
01:11:40,000 --> 01:11:42,000
是对这个有一个默认的

2294
01:11:42,000 --> 01:11:43,000
一个处理的

2295
01:11:43,000 --> 01:11:44,000
就是那个文件系统

2296
01:11:44,000 --> 01:11:45,000
它其实是知道

2297
01:11:45,000 --> 01:11:47,000
你写进去一个文件名

2298
01:11:47,000 --> 01:11:50,000
它会帮你去自动做一遍 Normalization

2299
01:11:50,000 --> 01:11:51,000
是这样

2300
01:11:51,000 --> 01:11:52,000
如果没记错的话

2301
01:11:52,000 --> 01:11:54,000
然后这个 HFS

2302
01:11:54,000 --> 01:11:55,000
其实

2303
01:11:55,000 --> 01:11:56,000
之前那个设计其实有点问题的

2304
01:11:56,000 --> 01:11:57,000
因为照理说

2305
01:11:57,000 --> 01:11:58,000
一个文件系统

2306
01:11:58,000 --> 01:11:59,000
不应该去

2307
01:11:59,000 --> 01:12:01,000
残护这种应用层的事情

2308
01:12:01,000 --> 01:12:02,000
对吧

2309
01:12:03,000 --> 01:12:04,000
因为这个

2310
01:12:04,000 --> 01:12:05,000
因为这种的用程的建设

2311
01:12:05,000 --> 01:12:06,000
这是应用层的事情吗

2312
01:12:07,000 --> 01:12:08,000
这显然是应用层的问题

2313
01:12:08,000 --> 01:12:09,000
应用文件系统

2314
01:12:09,000 --> 01:12:10,000
应该就是

2315
01:12:10,000 --> 01:12:11,000
这可能有一点

2316
01:12:11,000 --> 01:12:13,000
其实这里有个哲学问题

2317
01:12:13,000 --> 01:12:14,000
这也是我一个疑问

2318
01:12:14,000 --> 01:12:16,000
就是 Normalization

2319
01:12:16,000 --> 01:12:18,000
究竟是应该在存储的

2320
01:12:18,000 --> 01:12:19,000
存在的层

2321
01:12:19,000 --> 01:12:20,000
存在的层

2322
01:12:20,000 --> 01:12:21,000
存在的层发明的

2323
01:12:21,000 --> 01:12:22,000
对吧

2324
01:12:22,000 --> 01:12:23,000
还是在应用

2325
01:12:23,000 --> 01:12:25,000
调用某一个数据的过程中

2326
01:12:25,000 --> 01:12:26,000
对它进行实施的处理

2327
01:12:26,000 --> 01:12:27,000
因为本质上

2328
01:12:27,000 --> 01:12:29,000
你说对于文件系统来说

2329
01:12:29,000 --> 01:12:30,000
它并不关心

2330
01:12:30,000 --> 01:12:31,000
你们存的内容是什么

2331
01:12:31,000 --> 01:12:32,000
就是你给我一堆拜词

2332
01:12:32,000 --> 01:12:33,000
对吧

2333
01:12:33,000 --> 01:12:34,000
然后我把这个拜词

2334
01:12:34,000 --> 01:12:35,000
按照某一种规则

2335
01:12:35,000 --> 01:12:36,000
编码编写了

2336
01:12:36,000 --> 01:12:37,000
到时候

2337
01:12:37,000 --> 01:12:39,000
到时候你再问我要对拜词的生活

2338
01:12:39,000 --> 01:12:40,000
我就把这堆拜词还给你

2339
01:12:40,000 --> 01:12:42,000
但是我需要一个

2340
01:12:42,000 --> 01:12:43,000
一个 key

2341
01:12:43,000 --> 01:12:45,000
找到这堆拜词

2342
01:12:45,000 --> 01:12:47,000
这个 key 就是所有的文件名和路径

2343
01:12:47,000 --> 01:12:48,000
那么

2344
01:12:48,000 --> 01:12:51,000
APFS 最开始的它的逻辑

2345
01:12:51,000 --> 01:12:52,000
我记得当时他说过

2346
01:12:52,000 --> 01:12:53,000
他说对这个问题

2347
01:12:53,000 --> 01:12:56,000
它是完全不过问这些东西

2348
01:12:56,000 --> 01:12:57,000
你给我什么

2349
01:12:57,000 --> 01:12:58,000
你给我那个文件叫什么

2350
01:12:58,000 --> 01:12:59,000
我就写什么

2351
01:12:59,000 --> 01:13:01,000
但是在 HFS 里面

2352
01:13:01,000 --> 01:13:02,000
它其实是

2353
01:13:02,000 --> 01:13:05,000
它会去解析文件名的

2354
01:13:05,000 --> 01:13:06,000
格式和内容

2355
01:13:06,000 --> 01:13:08,000
规范化这个事情

2356
01:13:08,000 --> 01:13:09,000
是一个逻辑的概念

2357
01:13:09,000 --> 01:13:10,000
它并不是

2358
01:13:10,000 --> 01:13:12,000
它是我们在做这个叫做

2359
01:13:12,000 --> 01:13:13,000
API 的层面解决的问题

2360
01:13:13,000 --> 01:13:16,000
但是最终你写到那个磁盘上的

2361
01:13:16,000 --> 01:13:18,000
那个东西的时候

2362
01:13:18,000 --> 01:13:20,000
它肯定是一堆拜词

2363
01:13:20,000 --> 01:13:22,000
所以就是

2364
01:13:22,000 --> 01:13:25,000
APFS 它的设计领先就是

2365
01:13:25,000 --> 01:13:27,000
我作为一个文件系统

2366
01:13:27,000 --> 01:13:28,000
一个非常底层的东西

2367
01:13:28,000 --> 01:13:30,000
我不应该去掺和上层逻辑

2368
01:13:30,000 --> 01:13:32,000
API 应该去解决的问题

2369
01:13:32,000 --> 01:13:33,000
不是

2370
01:13:33,000 --> 01:13:35,000
Rail 我明白你的意思

2371
01:13:35,000 --> 01:13:36,000
Rail 我明白你的意思

2372
01:13:36,000 --> 01:13:37,000
但是我有一个问题

2373
01:13:37,000 --> 01:13:38,000
比如说你说

2374
01:13:38,000 --> 01:13:41,000
你说文件系统是一个非常底层的系统

2375
01:13:41,000 --> 01:13:42,000
那么请问

2376
01:13:42,000 --> 01:13:44,000
获得一个文件的路径

2377
01:13:44,000 --> 01:13:47,000
这件事情很底层

2378
01:13:47,000 --> 01:13:50,000
那么获得一个文件的路径

2379
01:13:50,000 --> 01:13:53,000
跟这个文件的名字是以什么样的

2380
01:13:53,000 --> 01:13:57,000
标准化形式写出来的有没有关联

2381
01:13:59,000 --> 01:14:01,000
肯定有关联

2382
01:14:01,000 --> 01:14:03,000
不但这个不是文件系统

2383
01:14:03,000 --> 01:14:04,000
对这个文件系统没有关系

2384
01:14:04,000 --> 01:14:06,000
因为文件系统拿了最终都是一堆拜词

2385
01:14:06,000 --> 01:14:09,000
它不需要去 concert 这件事情

2386
01:14:09,000 --> 01:14:11,000
其实它做了一种

2387
01:14:11,000 --> 01:14:13,000
Rail 的意思是说先规范的话

2388
01:14:13,000 --> 01:14:15,000
在存储这件事情

2389
01:14:15,000 --> 01:14:17,000
不是在文件系统的层面上发生的

2390
01:14:17,000 --> 01:14:18,000
对

2391
01:14:18,000 --> 01:14:21,000
还是在一个他们叫做 Foundation

2392
01:14:21,000 --> 01:14:24,000
在操作系统的层面上发生的

2393
01:14:24,000 --> 01:14:27,000
或者在操作系统和文件系统

2394
01:14:27,000 --> 01:14:30,000
就管理文件系统那一部分的 API 里面产生的

2395
01:14:30,000 --> 01:14:33,000
而不是文件系统本身需要操作的事情

2396
01:14:33,000 --> 01:14:35,000
对但这里就会导致一个问题

2397
01:14:35,000 --> 01:14:37,000
就是它就向后不兼容了

2398
01:14:37,000 --> 01:14:39,000
因为在 HFS 里面

2399
01:14:39,000 --> 01:14:41,000
它是文件系统就是管理这件事情的

2400
01:14:41,000 --> 01:14:44,000
所以操作系统和包括很多应用程序

2401
01:14:44,000 --> 01:14:46,000
它就不需要过度的去考虑这个问题

2402
01:14:46,000 --> 01:14:49,000
你用什么 API 去访问文件

2403
01:14:49,000 --> 01:14:50,000
反正你只要给了它

2404
01:14:50,000 --> 01:14:52,000
它都会通过统一的方法规范化

2405
01:14:52,000 --> 01:14:55,000
然后形成统一的一个 byte

2406
01:14:55,000 --> 01:14:57,000
然后再去通过 byte 在文件系统里面去找

2407
01:14:57,000 --> 01:15:00,000
就会变成向后兼容的问题了

2408
01:15:00,000 --> 01:15:02,000
但这个问题之所以在 iOS 里面

2409
01:15:02,000 --> 01:15:03,000
没有暴露出来

2410
01:15:03,000 --> 01:15:05,000
是因为 iOS 并没有

2411
01:15:05,000 --> 01:15:06,000
起码对用户而言

2412
01:15:06,000 --> 01:15:08,000
没有暴露出一个文件系统

2413
01:15:08,000 --> 01:15:10,000
起码当不成为只是没有的

2414
01:15:10,000 --> 01:15:12,000
那么也就不存在

2415
01:15:12,000 --> 01:15:15,000
并不会大量存在说

2416
01:15:15,000 --> 01:15:18,000
有很多历史文件的名

2417
01:15:18,000 --> 01:15:20,000
它的规范化形式不太对

2418
01:15:20,000 --> 01:15:23,000
导致可能找不回来这个问题

2419
01:15:23,000 --> 01:15:25,000
但是在 Mac 里面就会存在这个问题

2420
01:15:25,000 --> 01:15:27,000
因为我们现在大量还在使用

2421
01:15:27,000 --> 01:15:29,000
用户直接访问文件系统

2422
01:15:29,000 --> 01:15:31,000
大家还是用 finder

2423
01:15:31,000 --> 01:15:32,000
对吧

2424
01:15:32,000 --> 01:15:35,000
所以就导致这么一个很尴尬的情况

2425
01:15:35,000 --> 01:15:38,000
所以现在出的都是一些打补定的方案

2426
01:15:40,000 --> 01:15:43,000
其实你一直用同样一个系统的话

2427
01:15:43,000 --> 01:15:45,000
相对来讲会好一些

2428
01:15:45,000 --> 01:15:47,000
主要是像跟和 windows

2429
01:15:47,000 --> 01:15:49,000
windows 因为它默认的

2430
01:15:49,000 --> 01:15:51,000
它规范化的方式不一样

2431
01:15:52,000 --> 01:15:55,000
所以从那边不同规范化方式

2432
01:15:55,000 --> 01:15:58,000
考过来的东西就会有问题

2433
01:15:59,000 --> 01:16:02,000
你 Mac 一直都用这样的规范化形式的话

2434
01:16:02,000 --> 01:16:03,000
它其实相对来讲

2435
01:16:03,000 --> 01:16:05,000
它的相后金融现在是挺好的

2436
01:16:05,000 --> 01:16:07,000
但是有一个问题是这样的

2437
01:16:07,000 --> 01:16:10,000
因为 APFS 如果按照最开始的设计理念

2438
01:16:10,000 --> 01:16:13,000
是不设计规范化和你怎么

2439
01:16:13,000 --> 01:16:15,000
它不设计你文件怎么编吗

2440
01:16:15,000 --> 01:16:17,000
你甚至可以不用 utf 发编吗

2441
01:16:17,000 --> 01:16:19,000
理论是可以的对吧

2442
01:16:19,000 --> 01:16:23,000
APFS 只接受有效的 utf 8 的编码的文件名

2443
01:16:23,000 --> 01:16:24,000
不 我就说

2444
01:16:24,000 --> 01:16:25,000
如果他就是刚才讲的

2445
01:16:25,000 --> 01:16:27,000
如果它只管是拜次的话

2446
01:16:28,000 --> 01:16:30,000
就它只在字节层面上说

2447
01:16:30,000 --> 01:16:32,000
你编络什么我就存始吧

2448
01:16:32,000 --> 01:16:33,000
对 存始吧

2449
01:16:33,000 --> 01:16:35,000
就会有文件系统

2450
01:16:35,000 --> 01:16:37,000
对 就刚刚那个问题就是说

2451
01:16:37,000 --> 01:16:40,000
假设我们就是遵守 Apple 的一个规范

2452
01:16:40,000 --> 01:16:42,000
用这些 Foundation 的这些 Library

2453
01:16:42,000 --> 01:16:44,000
去命名文件 去访问文件

2454
01:16:44,000 --> 01:16:46,000
或者是 Open File 之类的 API 的话

2455
01:16:46,000 --> 01:16:49,000
那你可能得到的是一个路径对吧

2456
01:16:49,000 --> 01:16:52,000
然后你在就是叫什么来的

2457
01:16:52,000 --> 01:16:54,000
命名行的界面下

2458
01:16:54,000 --> 01:16:56,000
你用 Unix 的那套 API 去访问

2459
01:16:56,000 --> 01:16:58,000
又会得到另外一个文件的路径

2460
01:16:58,000 --> 01:17:00,000
它两个可能是不一样的

2461
01:17:00,000 --> 01:17:02,000
这个时候就会发现

2462
01:17:02,000 --> 01:17:03,000
你用那个文件

2463
01:17:03,000 --> 01:17:06,000
你用那个 Mac 的那套 API 去存了一个文件

2464
01:17:06,000 --> 01:17:07,000
然后你在 Unix 上面

2465
01:17:07,000 --> 01:17:09,000
找不回那个文件了 就很尴尬

2466
01:17:09,000 --> 01:17:15,000
这个事情当年也存在了

2467
01:17:15,000 --> 01:17:20,000
像当年老 Mac 转成 Mac OS X 的时候

2468
01:17:20,000 --> 01:17:22,000
他发现一个有改的

2469
01:17:22,000 --> 01:17:24,000
只要改成真正

2470
01:17:24,000 --> 01:17:27,000
OXX 是真正的 Unix

2471
01:17:27,000 --> 01:17:30,000
但是原来老的 Mac 不是

2472
01:17:30,000 --> 01:17:34,000
所以它那个路径的那个标志

2473
01:17:34,000 --> 01:17:35,000
分割服务都不一样

2474
01:17:35,000 --> 01:17:38,000
就是正协干方的那个事情

2475
01:17:38,000 --> 01:17:40,000
那就是操作系统的事情

2476
01:17:40,000 --> 01:17:44,000
这和它那个文件系统也不大别人

2477
01:17:44,000 --> 01:17:47,000
我们其实知道 Windows 一直以来

2478
01:17:47,000 --> 01:17:51,000
都是用 NFC 这种形式的对吧

2479
01:17:51,000 --> 01:17:53,000
这点应该没错吧

2480
01:17:53,000 --> 01:17:55,000
那么 Apple 的话

2481
01:17:55,000 --> 01:17:59,000
Apple 的话 HFS Plus 它是用哪一种形式的

2482
01:17:59,000 --> 01:18:03,000
是用 NFC 还是用 NFD

2483
01:18:03,000 --> 01:18:05,000
这个还真的不知道

2484
01:18:05,000 --> 01:18:07,000
这可能是第一个问题

2485
01:18:07,000 --> 01:18:09,000
然后第二个问题可能就是 Rio 刚才说的

2486
01:18:09,000 --> 01:18:13,000
就是在 HFS Plus 的年代里面

2487
01:18:13,000 --> 01:18:15,000
Apple 是

2488
01:18:15,000 --> 01:18:17,000
就说 Mac OS 会做一件事情

2489
01:18:17,000 --> 01:18:20,000
他做这件事情就是当你输入一个文件名的时候

2490
01:18:20,000 --> 01:18:22,000
它会帮你转成

2491
01:18:22,000 --> 01:18:24,000
已经标准化合的形式

2492
01:18:24,000 --> 01:18:28,000
在存储刀你的存储戒指上对吧

2493
01:18:28,000 --> 01:18:30,000
我理解的没错吧

2494
01:18:30,000 --> 01:18:31,000
应该就是说

2495
01:18:31,000 --> 01:18:33,000
刚才 Rio 也说的也是

2496
01:18:33,000 --> 01:18:36,000
就是说在文件系统里面

2497
01:18:36,000 --> 01:18:38,000
我们只说它的 Normalization

2498
01:18:38,000 --> 01:18:40,000
它是 Sensitive 还是 Insensitive

2499
01:18:40,000 --> 01:18:43,000
对这个规范是是否敏感

2500
01:18:43,000 --> 01:18:44,000
它没有在做

2501
01:18:44,000 --> 01:18:46,000
的确它只是在存储代码而已

2502
01:18:46,000 --> 01:18:48,000
存储 Bit 而已

2503
01:18:48,000 --> 01:18:52,000
但是它是不是对 Normalization 敏感

2504
01:18:52,000 --> 01:18:56,000
对 HFS 的确是对 Normalization 敏感

2505
01:18:56,000 --> 01:18:58,000
但是 AFS

2506
01:18:58,000 --> 01:19:00,000
Akfs 好像是

2507
01:19:00,000 --> 01:19:02,000
它新的就不敏感了

2508
01:19:02,000 --> 01:19:03,000
对

2509
01:19:03,000 --> 01:19:06,000
这个和大小写也是一样的

2510
01:19:06,000 --> 01:19:08,000
Sensitive

2511
01:19:08,000 --> 01:19:10,000
就叫什么 Case Sensitive

2512
01:19:10,000 --> 01:19:12,000
和 Case Insensitive

2513
01:19:13,000 --> 01:19:16,000
这里还有个比较根的一个事情

2514
01:19:16,000 --> 01:19:19,000
就是所谓这个叫做 Case Preserving

2515
01:19:19,000 --> 01:19:21,000
和 Normalization Preserving 的问题

2516
01:19:21,000 --> 01:19:22,000
对

2517
01:19:22,000 --> 01:19:25,000
它可以按照到底不好存下来

2518
01:19:25,000 --> 01:19:26,000
但是它对它不敏感

2519
01:19:26,000 --> 01:19:28,000
还是当成一样的

2520
01:19:30,000 --> 01:19:32,000
是可保存但是它不敏感

2521
01:19:32,000 --> 01:19:34,000
就是有这样的

2522
01:19:34,000 --> 01:19:36,000
现在的话就是新的 Akfs 就是这样

2523
01:19:36,000 --> 01:19:38,000
它可以保存下来

2524
01:19:38,000 --> 01:19:40,000
然后 NF-C 它也认得

2525
01:19:40,000 --> 01:19:41,000
NF-D 它也认得

2526
01:19:41,000 --> 01:19:42,000
但是它不敏感

2527
01:19:42,000 --> 01:19:44,000
所以两边都可以

2528
01:19:44,000 --> 01:19:46,000
那么其实

2529
01:19:46,000 --> 01:19:47,000
按我的理解

2530
01:19:47,000 --> 01:19:50,000
Apple 并没有改它的标准化形式

2531
01:19:50,000 --> 01:19:51,000
它改的只是

2532
01:19:51,000 --> 01:19:53,000
它对标准化形式

2533
01:19:53,000 --> 01:19:55,000
是不是敏感这样一个问题

2534
01:19:55,000 --> 01:19:59,000
所以它对文件名处理

2535
01:19:59,000 --> 01:20:01,000
它的行为发生变化了吗

2536
01:20:01,000 --> 01:20:03,000
刚刚我查了一下

2537
01:20:03,000 --> 01:20:06,000
HFS Plus 用的是 NF-D 的

2538
01:20:06,000 --> 01:20:08,000
这种标准化形式

2539
01:20:08,000 --> 01:20:10,000
那么这个第一个问题

2540
01:20:10,000 --> 01:20:12,000
就是跟 Windows 可能是不一样的

2541
01:20:13,000 --> 01:20:14,000
分解优先

2542
01:20:16,000 --> 01:20:18,000
可能我们刚才把那个带过了

2543
01:20:18,000 --> 01:20:20,000
刚才讲的 NF-CNF-D

2544
01:20:20,000 --> 01:20:21,000
它到底是个什么意思

2545
01:20:21,000 --> 01:20:23,000
可能还要解释一下

2546
01:20:25,000 --> 01:20:27,000
NF-C 就是先

2547
01:20:27,000 --> 01:20:28,000
就等于是

2548
01:20:28,000 --> 01:20:29,000
这么说吧

2549
01:20:29,000 --> 01:20:31,000
规范化有两个思路

2550
01:20:31,000 --> 01:20:34,000
一个是说什么叫规范化的最终形式

2551
01:20:36,000 --> 01:20:37,000
第一种思路就是

2552
01:20:37,000 --> 01:20:39,000
规范化的最终形式是

2553
01:20:39,000 --> 01:20:41,000
所有能够被拆分的东西

2554
01:20:41,000 --> 01:20:42,000
已经被拆分了

2555
01:20:42,000 --> 01:20:44,000
然后我存储这个形式

2556
01:20:45,000 --> 01:20:47,000
第二种思路是说

2557
01:20:47,000 --> 01:20:49,000
存储的最终形式

2558
01:20:49,000 --> 01:20:51,000
应该是所有能够被合成的东西

2559
01:20:51,000 --> 01:20:52,000
已经被合成了

2560
01:20:52,000 --> 01:20:54,000
而且是按照某一种特定的方式合成

2561
01:20:54,000 --> 01:20:56,000
这是第二种思路

2562
01:20:59,000 --> 01:21:01,000
比如说 D 型规范化

2563
01:21:01,000 --> 01:21:02,000
NF-D 的话

2564
01:21:02,000 --> 01:21:03,000
那就是说

2565
01:21:03,000 --> 01:21:05,000
以标准方式分解

2566
01:21:05,000 --> 01:21:07,000
分解到不能再分解了

2567
01:21:07,000 --> 01:21:09,000
那我的规范化的完成

2568
01:21:09,000 --> 01:21:11,000
合成就结束了

2569
01:21:13,000 --> 01:21:15,000
比如说刚才那个鱼的话

2570
01:21:15,000 --> 01:21:17,000
它就分成三个了

2571
01:21:17,000 --> 01:21:19,000
两点

2572
01:21:19,000 --> 01:21:20,000
然后生掉

2573
01:21:20,000 --> 01:21:22,000
能分就尽量分

2574
01:21:22,000 --> 01:21:23,000
我们看到是一个字

2575
01:21:23,000 --> 01:21:25,000
但是它背面分成了三个码

2576
01:21:25,000 --> 01:21:26,000
对

2577
01:21:26,000 --> 01:21:27,000
一个是 U

2578
01:21:27,000 --> 01:21:28,000
一个是合成

2579
01:21:28,000 --> 01:21:29,000
一个是两角

2580
01:21:31,000 --> 01:21:32,000
然后

2581
01:21:32,000 --> 01:21:34,000
如果你说我要

2582
01:21:34,000 --> 01:21:37,000
把它合成的状态

2583
01:21:37,000 --> 01:21:38,000
作为最终形式的话

2584
01:21:38,000 --> 01:21:39,000
刚才这个 U

2585
01:21:39,000 --> 01:21:40,000
就是

2586
01:21:40,000 --> 01:21:42,000
就把它合成成一个字符

2587
01:21:42,000 --> 01:21:44,000
这样来就行吗

2588
01:21:46,000 --> 01:21:47,000
然后

2589
01:21:47,000 --> 01:21:49,000
但是由于分解和合成

2590
01:21:49,000 --> 01:21:51,000
又分别有所谓

2591
01:21:51,000 --> 01:21:53,000
标准方式和建议方式

2592
01:21:53,000 --> 01:21:54,000
所以你可以说

2593
01:21:54,000 --> 01:21:56,000
标准方式分解结束

2594
01:21:56,000 --> 01:21:58,000
还是建议方式分解结束

2595
01:21:58,000 --> 01:21:59,000
还是

2596
01:21:59,000 --> 01:22:01,000
标准方式分解之后

2597
01:22:01,000 --> 01:22:03,000
以标准方式合成结束

2598
01:22:03,000 --> 01:22:05,000
还是以标准方式分解之后

2599
01:22:05,000 --> 01:22:07,000
在以建议方式合成结束

2600
01:22:07,000 --> 01:22:08,000
或者反过来

2601
01:22:08,000 --> 01:22:09,000
对

2602
01:22:09,000 --> 01:22:10,000
基本上是一个

2603
01:22:10,000 --> 01:22:12,000
combination

2604
01:22:13,000 --> 01:22:14,000
我想问一下

2605
01:22:14,000 --> 01:22:16,000
为什么要做这么多种

2606
01:22:16,000 --> 01:22:18,000
我们的 Normalization 的目的

2607
01:22:18,000 --> 01:22:19,000
不就为了解决

2608
01:22:19,000 --> 01:22:21,000
标准化的问题吗

2609
01:22:21,000 --> 01:22:22,000
为什么还要在搞

2610
01:22:22,000 --> 01:22:24,000
四种不一样的方式呢

2611
01:22:24,000 --> 01:22:25,000
就他们之间各有什么

2612
01:22:25,000 --> 01:22:26,000
或者说

2613
01:22:26,000 --> 01:22:27,000
应用场景是什么

2614
01:22:27,000 --> 01:22:28,000
就

2615
01:22:28,000 --> 01:22:29,000
比如说

2616
01:22:29,000 --> 01:22:30,000
以标准方式分解分解到

2617
01:22:30,000 --> 01:22:31,000
不能再分解了

2618
01:22:31,000 --> 01:22:32,000
这个实际上是非常适合

2619
01:22:32,000 --> 01:22:34,000
编程的嘛

2620
01:22:34,000 --> 01:22:35,000
对吧

2621
01:22:35,000 --> 01:22:37,000
最小单元吗

2622
01:22:38,000 --> 01:22:39,000
就比如说你刚才

2623
01:22:39,000 --> 01:22:40,000
我刚才说的

2624
01:22:40,000 --> 01:22:41,000
swift 的语言

2625
01:22:41,000 --> 01:22:43,000
判定两个字路上相等的时候

2626
01:22:43,000 --> 01:22:45,000
你就把他们全都拆成

2627
01:22:45,000 --> 01:22:46,000
不能再拆的状况

2628
01:22:46,000 --> 01:22:48,000
然后看两个是不是一样

2629
01:22:48,000 --> 01:22:49,000
一个 co-pone

2630
01:22:49,000 --> 01:22:51,000
不管他们原来是怎么样

2631
01:22:51,000 --> 01:22:52,000
对

2632
01:22:52,000 --> 01:22:53,000
这样就结束了

2633
01:22:53,000 --> 01:22:55,000
但是

2634
01:22:55,000 --> 01:22:56,000
如果说

2635
01:22:56,000 --> 01:22:57,000
这个好死板

2636
01:22:58,000 --> 01:22:59,000
太死板了

2637
01:22:59,000 --> 01:23:00,000
就是

2638
01:23:00,000 --> 01:23:01,000
对呀

2639
01:23:01,000 --> 01:23:03,000
你要先拆拆的这么 C 了以后

2640
01:23:03,000 --> 01:23:05,000
要每一个部件都一样

2641
01:23:05,000 --> 01:23:06,000
他才

2642
01:23:06,000 --> 01:23:08,000
判定为是一样对吧

2643
01:23:09,000 --> 01:23:10,000
对

2644
01:23:10,000 --> 01:23:11,000
但是

2645
01:23:11,000 --> 01:23:12,000
但是这种方式的时候

2646
01:23:12,000 --> 01:23:13,000
就是

2647
01:23:13,000 --> 01:23:14,000
就这种

2648
01:23:14,000 --> 01:23:16,000
规判方式是只适合

2649
01:23:16,000 --> 01:23:18,000
存储或者比较的

2650
01:23:18,000 --> 01:23:20,000
那如果你要把它

2651
01:23:20,000 --> 01:23:21,000
就是

2652
01:23:21,000 --> 01:23:22,000
以结成空间的方式

2653
01:23:22,000 --> 01:23:24,000
显示出来的话

2654
01:23:24,000 --> 01:23:25,000
那你还是很有可能

2655
01:23:25,000 --> 01:23:26,000
希望说

2656
01:23:26,000 --> 01:23:29,000
我要把它

2657
01:23:29,000 --> 01:23:31,000
最终还是要合成起来

2658
01:23:31,000 --> 01:23:32,000
就刚才那个拆的方式

2659
01:23:32,000 --> 01:23:33,000
说可能会导致

2660
01:23:33,000 --> 01:23:34,000
比如说

2661
01:23:34,000 --> 01:23:35,000
那个特殊的自负

2662
01:23:35,000 --> 01:23:36,000
就是鱼

2663
01:23:36,000 --> 01:23:38,000
再加一个声调的话

2664
01:23:38,000 --> 01:23:39,000
它会从

2665
01:23:39,000 --> 01:23:40,000
理论上

2666
01:23:40,000 --> 01:23:41,000
它可以从一个

2667
01:23:41,000 --> 01:23:42,000
一个点位

2668
01:23:42,000 --> 01:23:43,000
变成三个点位

2669
01:23:43,000 --> 01:23:45,000
就是

2670
01:23:45,000 --> 01:23:47,000
它的存储空间的要求

2671
01:23:47,000 --> 01:23:48,000
变成三倍了

2672
01:23:48,000 --> 01:23:49,000
对

2673
01:23:49,000 --> 01:23:50,000
然后

2674
01:23:50,000 --> 01:23:51,000
我们就如果

2675
01:23:51,000 --> 01:23:52,000
就全部合到一起

2676
01:23:52,000 --> 01:23:53,000
有什么不好呢

2677
01:23:53,000 --> 01:23:55,000
的确是

2678
01:23:55,000 --> 01:23:56,000
是为了比较

2679
01:23:56,000 --> 01:23:57,000
比较化

2680
01:23:57,000 --> 01:23:58,000
就说

2681
01:23:58,000 --> 01:24:00,000
比如 NFD 的应用场景

2682
01:24:00,000 --> 01:24:01,000
和 NFC 的应用场景

2683
01:24:01,000 --> 01:24:02,000
它们各有什么不同

2684
01:24:02,000 --> 01:24:03,000
就是不能互相

2685
01:24:03,000 --> 01:24:04,000
替代的地方

2686
01:24:04,000 --> 01:24:06,000
NFD 你要少做一步计算

2687
01:24:06,000 --> 01:24:07,000
就 NFC 你最重要

2688
01:24:07,000 --> 01:24:09,000
把它合成起来

2689
01:24:09,000 --> 01:24:10,000
NFD

2690
01:24:10,000 --> 01:24:11,000
你要

2691
01:24:11,000 --> 01:24:13,000
你要付出更多的存储空间

2692
01:24:13,000 --> 01:24:14,000
对

2693
01:24:14,000 --> 01:24:16,000
所以这个就是一长一短

2694
01:24:16,000 --> 01:24:17,000
这就是时间

2695
01:24:17,000 --> 01:24:18,000
就是有时间

2696
01:24:18,000 --> 01:24:19,000
换空间

2697
01:24:19,000 --> 01:24:20,000
还是空间换时间

2698
01:24:20,000 --> 01:24:21,000
那建合吧

2699
01:24:21,000 --> 01:24:22,000
对

2700
01:24:22,000 --> 01:24:23,000
所以这个就是逻辑问题

2701
01:24:23,000 --> 01:24:25,000
然后只是偏好问题而已

2702
01:24:25,000 --> 01:24:26,000
这个并没有什么对错

2703
01:24:26,000 --> 01:24:27,000
或者怎么样

2704
01:24:28,000 --> 01:24:30,000
所以刚才提了一个叫做

2705
01:24:30,000 --> 01:24:32,000
兼容分解和标准分解

2706
01:24:32,000 --> 01:24:33,000
什么不一样

2707
01:24:33,000 --> 01:24:35,000
那个我简单来说一下

2708
01:24:35,000 --> 01:24:36,000
兼容分解

2709
01:24:36,000 --> 01:24:38,000
就是我不把它说得非常似

2710
01:24:38,000 --> 01:24:39,000
就兼容分解

2711
01:24:39,000 --> 01:24:40,000
它解决一个问题

2712
01:24:40,000 --> 01:24:41,000
就是说

2713
01:24:41,000 --> 01:24:42,000
有一些

2714
01:24:42,000 --> 01:24:43,000
有一些竄

2715
01:24:43,000 --> 01:24:45,000
它在这个自符的 byte 的

2716
01:24:45,000 --> 01:24:47,000
表达层面是不一样的

2717
01:24:47,000 --> 01:24:49,000
然后它拆分组合之后

2718
01:24:49,000 --> 01:24:50,000
也是不一样的

2719
01:24:50,000 --> 01:24:51,000
但是我们希望

2720
01:24:51,000 --> 01:24:52,000
认为他们是一样的

2721
01:24:52,000 --> 01:24:53,000
比如一个场景

2722
01:24:53,000 --> 01:24:54,000
就是合字的问题

2723
01:24:54,000 --> 01:24:55,000
比如 FI 合字

2724
01:24:55,000 --> 01:24:56,000
那么 FI 合字

2725
01:24:56,000 --> 01:24:57,000
我们可以理解成

2726
01:24:57,000 --> 01:24:59,000
它是一个 F 和一个 I 的

2727
01:24:59,000 --> 01:25:00,000
两个字母的合成

2728
01:25:00,000 --> 01:25:02,000
但它同时又是一个单独的马位

2729
01:25:02,000 --> 01:25:03,000
就是 Unicor 里面

2730
01:25:03,000 --> 01:25:05,000
有一个马位就是 FI 合字的

2731
01:25:05,000 --> 01:25:07,000
那么我们在搜索的时候

2732
01:25:07,000 --> 01:25:08,000
用户可能输入 FI 合字

2733
01:25:08,000 --> 01:25:09,000
是非常复杂的

2734
01:25:09,000 --> 01:25:11,000
所以我们可能希望用户

2735
01:25:11,000 --> 01:25:12,000
输入一个 FI

2736
01:25:12,000 --> 01:25:13,000
一个 F 和一个 I

2737
01:25:13,000 --> 01:25:15,000
我们可以把所有 FI 合字

2738
01:25:15,000 --> 01:25:17,000
相关的内容也给它匹配死来

2739
01:25:17,000 --> 01:25:18,000
所以这个时候就是

2740
01:25:18,000 --> 01:25:20,000
兼容性分解和合成

2741
01:25:20,000 --> 01:25:24,000
需要起到作用的这样一个场景

2742
01:25:24,000 --> 01:25:25,000
等一下

2743
01:25:25,000 --> 01:25:26,000
这里我提一个问题

2744
01:25:26,000 --> 01:25:27,000
好像没有区别

2745
01:25:27,000 --> 01:25:29,000
只用分解一次就好了

2746
01:25:29,000 --> 01:25:31,000
或者合成一次就好了

2747
01:25:31,000 --> 01:25:33,000
这个问题是这样子

2748
01:25:33,000 --> 01:25:34,000
就是说

2749
01:25:34,000 --> 01:25:35,000
有一堆文档

2750
01:25:35,000 --> 01:25:37,000
里面包含 FI 的合字

2751
01:25:37,000 --> 01:25:39,000
和 FI 分解的两种情况

2752
01:25:39,000 --> 01:25:41,000
我们没有做对它做任何处理

2753
01:25:41,000 --> 01:25:43,000
这个时候用户说

2754
01:25:43,000 --> 01:25:44,000
输入 FI

2755
01:25:44,000 --> 01:25:46,000
我们需要把前面的 FI

2756
01:25:46,000 --> 01:25:47,000
合字和 FI 分开的

2757
01:25:47,000 --> 01:25:48,000
都搜出来

2758
01:25:48,000 --> 01:25:50,000
这个时候有两种做法

2759
01:25:50,000 --> 01:25:51,000
第一个是说

2760
01:25:51,000 --> 01:25:54,000
我们把我们之前存在的一些文档

2761
01:25:54,000 --> 01:25:55,000
全部做分解

2762
01:25:55,000 --> 01:25:57,000
把 FI 的合字

2763
01:25:57,000 --> 01:25:59,000
一个扣个 Point 分成两个

2764
01:25:59,000 --> 01:26:01,000
这个时候我们就可以直接跟

2765
01:26:01,000 --> 01:26:02,000
用户输入的 FI 直接对比了

2766
01:26:02,000 --> 01:26:03,000
另外一个方法就是说

2767
01:26:03,000 --> 01:26:05,000
我们把用户输入的 FI

2768
01:26:05,000 --> 01:26:06,000
弄成一个合字

2769
01:26:06,000 --> 01:26:08,000
同时把所有我们已有的文档

2770
01:26:08,000 --> 01:26:10,000
里面的 FI 分开的

2771
01:26:10,000 --> 01:26:11,000
弄成一个合字

2772
01:26:11,000 --> 01:26:12,000
这个时候再搜索也可以了

2773
01:26:12,000 --> 01:26:14,000
就这两种操作方式

2774
01:26:14,000 --> 01:26:15,000
对

2775
01:26:15,000 --> 01:26:17,000
但是因为你

2776
01:26:17,000 --> 01:26:19,000
这就是为了兼容

2777
01:26:19,000 --> 01:26:20,000
用户并不知道

2778
01:26:20,000 --> 01:26:22,000
这里面到底用的是合字

2779
01:26:22,000 --> 01:26:23,000
还是分开的

2780
01:26:23,000 --> 01:26:24,000
但这里问题就是说

2781
01:26:24,000 --> 01:26:26,000
这个标准分解和

2782
01:26:26,000 --> 01:26:28,000
这个兼容分解好像没有区别

2783
01:26:28,000 --> 01:26:29,000
在这里面

2784
01:26:29,000 --> 01:26:31,000
这个区别就在于

2785
01:26:31,000 --> 01:26:33,000
哪些东西是可以分的

2786
01:26:33,000 --> 01:26:35,000
就是说哪些东西是可以等价的

2787
01:26:35,000 --> 01:26:36,000
其实他们的区别就在

2788
01:26:36,000 --> 01:26:38,000
比如说 FI 合字

2789
01:26:38,000 --> 01:26:40,000
它本质上不能完全等同

2790
01:26:40,000 --> 01:26:41,000
一个 F 和一个 I

2791
01:26:41,000 --> 01:26:43,000
它本质上是两种不同的字符

2792
01:26:43,000 --> 01:26:44,000
那么有的时候

2793
01:26:44,000 --> 01:26:46,000
我们希望它们是等价的

2794
01:26:46,000 --> 01:26:47,000
对

2795
01:26:47,000 --> 01:26:50,000
这个其实不仅仅是说

2796
01:26:50,000 --> 01:26:52,000
这不纯粹是一个

2797
01:26:52,000 --> 01:26:54,000
字符层面的问题

2798
01:26:54,000 --> 01:26:55,000
还是一个语言

2799
01:26:55,000 --> 01:26:56,000
就是语言层面的问题

2800
01:26:56,000 --> 01:26:57,000
比如说在有些语言里面

2801
01:26:57,000 --> 01:26:58,000
它是一个语异的问题

2802
01:26:58,000 --> 01:26:59,000
对 在有些语言里面

2803
01:26:59,000 --> 01:27:02,000
CH 或者是

2804
01:27:02,000 --> 01:27:04,000
SH 是被视成

2805
01:27:04,000 --> 01:27:06,000
视作一个单读的字母

2806
01:27:06,000 --> 01:27:07,000
或者是在

2807
01:27:07,000 --> 01:27:08,000
比如说像荷兰语里面

2808
01:27:08,000 --> 01:27:09,000
IG

2809
01:27:09,000 --> 01:27:12,000
经常是一个单读字母

2810
01:27:12,000 --> 01:27:13,000
以一个字符

2811
01:27:13,000 --> 01:27:14,000
对 另外就是

2812
01:27:14,000 --> 01:27:15,000
有些语言里面

2813
01:27:15,000 --> 01:27:17,000
一个字母可能有两种形式

2814
01:27:17,000 --> 01:27:18,000
比如说阿拉伯

2815
01:27:18,000 --> 01:27:20,000
字手字中字墨

2816
01:27:20,000 --> 01:27:22,000
一个字母是表达形式不一样的

2817
01:27:22,000 --> 01:27:24,000
比如说西兰语

2818
01:27:24,000 --> 01:27:25,000
是 SIGMA

2819
01:27:25,000 --> 01:27:26,000
SIGMA 在词语的时候

2820
01:27:26,000 --> 01:27:28,000
写法和在词中不一样

2821
01:27:28,000 --> 01:27:30,000
又比如说英语里面的

2822
01:27:30,000 --> 01:27:31,000
常 OX

2823
01:27:31,000 --> 01:27:32,000
就是

2824
01:27:32,000 --> 01:27:34,000
微积分的符号

2825
01:27:34,000 --> 01:27:35,000
S

2826
01:27:35,000 --> 01:27:37,000
它跟普通的 S 也不一样

2827
01:27:37,000 --> 01:27:38,000
在德语里面

2828
01:27:38,000 --> 01:27:40,000
在旧式的德语证的法文里面

2829
01:27:40,000 --> 01:27:41,000
如果它

2830
01:27:41,000 --> 01:27:43,000
如果一个 S 出现了词中的话

2831
01:27:43,000 --> 01:27:45,000
你比如写成常 OX

2832
01:27:45,000 --> 01:27:46,000
但是

2833
01:27:46,000 --> 01:27:48,000
常 OX 你用

2834
01:27:48,000 --> 01:27:50,000
标准分解的话

2835
01:27:50,000 --> 01:27:52,000
你最终只能分解出一个常 OX

2836
01:27:52,000 --> 01:27:53,000
但是如果你用

2837
01:27:53,000 --> 01:27:55,000
因为它本来就是一个字符

2838
01:27:55,000 --> 01:27:57,000
它不管你分开还是合

2839
01:27:57,000 --> 01:27:58,000
它就是一个字符

2840
01:27:58,000 --> 01:27:59,000
对

2841
01:27:59,000 --> 01:28:00,000
而如果你用

2842
01:28:00,000 --> 01:28:01,000
建议分解的话

2843
01:28:01,000 --> 01:28:02,000
它会说

2844
01:28:02,000 --> 01:28:03,000
这个 S

2845
01:28:03,000 --> 01:28:04,000
常 OX 是 S 的一个变状

2846
01:28:04,000 --> 01:28:05,000
所以在匹配的时候

2847
01:28:05,000 --> 01:28:07,000
我必须把它匹配成一个短 S

2848
01:28:08,000 --> 01:28:09,000
就是说有一些

2849
01:28:09,000 --> 01:28:11,000
一遍于搜索到

2850
01:28:11,000 --> 01:28:12,000
就有一些组合

2851
01:28:12,000 --> 01:28:13,000
在标准分解

2852
01:28:13,000 --> 01:28:14,000
它是不能分解

2853
01:28:14,000 --> 01:28:15,000
但是为了

2854
01:28:15,000 --> 01:28:17,000
让大家方便它

2855
01:28:17,000 --> 01:28:18,000
这样子

2856
01:28:18,000 --> 01:28:19,000
就强行拆开

2857
01:28:19,000 --> 01:28:20,000
就强行拆开

2858
01:28:20,000 --> 01:28:21,000
对

2859
01:28:21,000 --> 01:28:22,000
是的

2860
01:28:23,000 --> 01:28:24,000
画天哪

2861
01:28:24,000 --> 01:28:25,000
对

2862
01:28:25,000 --> 01:28:26,000
它有几种常见的形式

2863
01:28:26,000 --> 01:28:27,000
一种就是

2864
01:28:27,000 --> 01:28:28,000
一个字母

2865
01:28:28,000 --> 01:28:29,000
它可能有一些

2866
01:28:29,000 --> 01:28:30,000
字体设计

2867
01:28:30,000 --> 01:28:32,000
这个历史原因大来的不一样

2868
01:28:32,000 --> 01:28:33,000
比如说

2869
01:28:33,000 --> 01:28:34,000
一个拉钉字母

2870
01:28:34,000 --> 01:28:35,000
它可以设计成

2871
01:28:35,000 --> 01:28:36,000
好几种形式了

2872
01:28:36,000 --> 01:28:37,000
比如说什么

2873
01:28:37,000 --> 01:28:39,000
有什么双层形那之类的

2874
01:28:39,000 --> 01:28:40,000
就这个双层

2875
01:28:40,000 --> 01:28:41,000
是指视觉样式上

2876
01:28:41,000 --> 01:28:42,000
比如它有一个双钩线的

2877
01:28:42,000 --> 01:28:43,000
这种形式

2878
01:28:43,000 --> 01:28:44,000
然后另一种形式

2879
01:28:44,000 --> 01:28:45,000
比如说

2880
01:28:45,000 --> 01:28:47,000
有一些空白字符

2881
01:28:47,000 --> 01:28:49,000
它们可能都是一个空格

2882
01:28:49,000 --> 01:28:50,000
但是它们可能有

2883
01:28:50,000 --> 01:28:51,000
我们知道

2884
01:28:51,000 --> 01:28:52,000
Unicle 有非常多种空格

2885
01:28:52,000 --> 01:28:53,000
但是我们希望

2886
01:28:53,000 --> 01:28:54,000
它们在搜索的时候

2887
01:28:54,000 --> 01:28:55,000
或者在语议识别的时候

2888
01:28:55,000 --> 01:28:56,000
认为它们都是空格

2889
01:28:56,000 --> 01:28:57,000
这一种

2890
01:28:57,000 --> 01:28:58,000
都是 Y Space

2891
01:28:58,000 --> 01:28:59,000
对

2892
01:28:59,000 --> 01:29:00,000
然后另外一种

2893
01:29:00,000 --> 01:29:01,000
就是刚才吴涛说了

2894
01:29:01,000 --> 01:29:02,000
有一些语言里面

2895
01:29:02,000 --> 01:29:03,000
有一些字母

2896
01:29:03,000 --> 01:29:04,000
它在不同的位置上

2897
01:29:04,000 --> 01:29:05,000
它其实会有不一样的写法

2898
01:29:05,000 --> 01:29:07,000
然后它也有不一样的 Unicle 的马位

2899
01:29:07,000 --> 01:29:08,000
对

2900
01:29:08,000 --> 01:29:09,000
OK

2901
01:29:09,000 --> 01:29:10,000
对

2902
01:29:10,000 --> 01:29:11,000
然后接下来有一种

2903
01:29:11,000 --> 01:29:12,000
比如说数字

2904
01:29:12,000 --> 01:29:13,000
它们可能都是同一个数字

2905
01:29:13,000 --> 01:29:14,000
一或者数字

2906
01:29:14,000 --> 01:29:15,000
二

2907
01:29:15,000 --> 01:29:16,000
那么它们应该是一样的

2908
01:29:16,000 --> 01:29:18,000
就我们希望它们识别成一样的

2909
01:29:18,000 --> 01:29:19,000
然后日语里面

2910
01:29:19,000 --> 01:29:21,000
假名有半角和全角的区别

2911
01:29:21,000 --> 01:29:23,000
然后汉语里面

2912
01:29:23,000 --> 01:29:24,000
标点符号

2913
01:29:24,000 --> 01:29:25,000
有数牌和横牌的区别

2914
01:29:25,000 --> 01:29:27,000
然后还有像数学里面

2915
01:29:27,000 --> 01:29:29,000
有上标和下标和这个

2916
01:29:29,000 --> 01:29:30,000
非上标下标的

2917
01:29:30,000 --> 01:29:32,000
这个普通数字的区别

2918
01:29:32,000 --> 01:29:33,000
但它们都是同一个数字

2919
01:29:33,000 --> 01:29:34,000
另外日语里面

2920
01:29:34,000 --> 01:29:35,000
还有一些就是

2921
01:29:35,000 --> 01:29:37,000
几个字

2922
01:29:37,000 --> 01:29:38,000
或者几个假名

2923
01:29:38,000 --> 01:29:39,000
它会组合成一起

2924
01:29:39,000 --> 01:29:40,000
比如说这个年号

2925
01:29:40,000 --> 01:29:41,000
像什么平成

2926
01:29:41,000 --> 01:29:43,000
它可能会组合成一个字符

2927
01:29:43,000 --> 01:29:44,000
但它也可以写成

2928
01:29:44,000 --> 01:29:46,000
平成这两个字

2929
01:29:46,000 --> 01:29:47,000
诸式或以数

2930
01:29:47,000 --> 01:29:48,000
对

2931
01:29:48,000 --> 01:29:49,000
诸式或以数字

2932
01:29:49,000 --> 01:29:50,000
一个在一起的

2933
01:29:50,000 --> 01:29:52,000
可能是一个田之格的方式

2934
01:29:52,000 --> 01:29:53,000
对

2935
01:29:53,000 --> 01:29:54,000
另外就是下有分数

2936
01:29:54,000 --> 01:29:55,000
比如说 121

2937
01:29:55,000 --> 01:29:57,000
它可能有一个单独的马威

2938
01:29:57,000 --> 01:29:58,000
就是 121

2939
01:29:58,000 --> 01:29:59,000
但我们也可以写成

2940
01:29:59,000 --> 01:30:00,000
1-2

2941
01:30:00,000 --> 01:30:01,000
对

2942
01:30:01,000 --> 01:30:02,000
这个例子很好

2943
01:30:02,000 --> 01:30:03,000
对

2944
01:30:03,000 --> 01:30:04,000
我刚到德国的时候

2945
01:30:04,000 --> 01:30:05,000
最惊艳的一件事情就是

2946
01:30:05,000 --> 01:30:07,000
德语健康上有 121-121

2947
01:30:07,000 --> 01:30:08,000
这两个健康

2948
01:30:09,000 --> 01:30:11,000
哈哈哈哈

2949
01:30:13,000 --> 01:30:14,000
所以我问一下

2950
01:30:14,000 --> 01:30:15,000
刚刚我们讲的

2951
01:30:15,000 --> 01:30:17,000
很多都是外文的问题

2952
01:30:17,000 --> 01:30:18,000
中文有这个问题吗

2953
01:30:18,000 --> 01:30:19,000
中文我刚说了一个

2954
01:30:19,000 --> 01:30:20,000
就是标点的很数型

2955
01:30:20,000 --> 01:30:22,000
就是横排和数排标点

2956
01:30:22,000 --> 01:30:24,000
这个不是拆解的问题吧

2957
01:30:24,000 --> 01:30:25,000
它就是说

2958
01:30:25,000 --> 01:30:26,000
把哪些

2959
01:30:26,000 --> 01:30:27,000
它本来不在一个

2960
01:30:27,000 --> 01:30:28,000
马威的标点

2961
01:30:28,000 --> 01:30:30,000
但是因为我们认为

2962
01:30:30,000 --> 01:30:31,000
在某一些情况下

2963
01:30:31,000 --> 01:30:32,000
认为它是等价的

2964
01:30:32,000 --> 01:30:33,000
对

2965
01:30:33,000 --> 01:30:34,000
所以 Normalization

2966
01:30:34,000 --> 01:30:35,000
不只是一个拆分的问题

2967
01:30:35,000 --> 01:30:36,000
它有的时候

2968
01:30:36,000 --> 01:30:37,000
也是单个字符

2969
01:30:37,000 --> 01:30:39,000
之间相互的等价问题

2970
01:30:39,000 --> 01:30:40,000
对

2971
01:30:40,000 --> 01:30:41,000
中文是没有拆分和组合

2972
01:30:41,000 --> 01:30:42,000
这个问题吗

2973
01:30:42,000 --> 01:30:43,000
中文基本上没有

2974
01:30:43,000 --> 01:30:45,000
但韩语可能就会有

2975
01:30:45,000 --> 01:30:47,000
那中文那个代缺文字

2976
01:30:47,000 --> 01:30:48,000
是有这个问题没

2977
01:30:48,000 --> 01:30:49,000
中文什么

2978
01:30:49,000 --> 01:30:50,000
它有

2979
01:30:50,000 --> 01:30:51,000
代缺文字的话

2980
01:30:51,000 --> 01:30:52,000
就会有

2981
01:30:52,000 --> 01:30:54,000
刚才那个兼容的问题吗

2982
01:30:54,000 --> 01:30:55,000
就是因为

2983
01:30:55,000 --> 01:30:56,000
它即使加了个圈

2984
01:30:56,000 --> 01:30:57,000
但是比如说

2985
01:30:57,000 --> 01:30:58,000
那个

2986
01:30:58,000 --> 01:30:59,000
哦 圈里面加一圈是吧

2987
01:30:59,000 --> 01:31:01,000
哈哈哈哈

2988
01:31:01,000 --> 01:31:02,000
对啊对啊

2989
01:31:02,000 --> 01:31:03,000
就是圆圈嘛

2990
01:31:03,000 --> 01:31:04,000
有人说要为它

2991
01:31:04,000 --> 01:31:06,000
申起跟不特殊的马威

2992
01:31:06,000 --> 01:31:07,000
为它就是另外的

2993
01:31:07,000 --> 01:31:08,000
还有比如说

2994
01:31:08,000 --> 01:31:09,000
现在什么跨湖 1

2995
01:31:09,000 --> 01:31:10,000
对吧

2996
01:31:10,000 --> 01:31:11,000
跨湖 12356789

2997
01:31:11,000 --> 01:31:12,000
汉字的

2998
01:31:12,000 --> 01:31:13,000
对吧

2999
01:31:13,000 --> 01:31:15,000
像这些都是有那个兼容的

3000
01:31:15,000 --> 01:31:16,000
这样的

3001
01:31:16,000 --> 01:31:17,000
兼容的话

3002
01:31:17,000 --> 01:31:18,000
给它拆成三个嘛

3003
01:31:18,000 --> 01:31:19,000
前跨湖

3004
01:31:19,000 --> 01:31:20,000
汉字 1

3005
01:31:20,000 --> 01:31:21,000
后跨湖

3006
01:31:21,000 --> 01:31:22,000
就是它也要

3007
01:31:22,000 --> 01:31:23,000
这样认马

3008
01:31:23,000 --> 01:31:24,000
以便语可以搜索到嘛

3009
01:31:24,000 --> 01:31:26,000
就中文其实也有这个问题

3010
01:31:26,000 --> 01:31:27,000
对

3011
01:31:27,000 --> 01:31:28,000
这些其实都是日本过来

3012
01:31:28,000 --> 01:31:29,000
我觉得

3013
01:31:29,000 --> 01:31:30,000
最早

3014
01:31:30,000 --> 01:31:31,000
应该都是日本人

3015
01:31:31,000 --> 01:31:32,000
去申请这些马威人

3016
01:31:32,000 --> 01:31:33,000
那我再问一下

3017
01:31:33,000 --> 01:31:34,000
那是不是说

3018
01:31:34,000 --> 01:31:35,000
不是流行那个火星文嘛

3019
01:31:35,000 --> 01:31:36,000
嗯哼

3020
01:31:36,000 --> 01:31:37,000
火星文不是

3021
01:31:37,000 --> 01:31:38,000
只有半截是那个

3022
01:31:38,000 --> 01:31:39,000
正常的

3023
01:31:39,000 --> 01:31:40,000
哦 my god

3024
01:31:40,000 --> 01:31:41,000
不

3025
01:31:41,000 --> 01:31:42,000
不守都是没有用的

3026
01:31:42,000 --> 01:31:43,000
是吧

3027
01:31:43,000 --> 01:31:44,000
oh my god

3028
01:31:44,000 --> 01:31:46,000
火星文能不能等价是不是

3029
01:31:46,000 --> 01:31:47,000
对啊对啊

3030
01:31:47,000 --> 01:31:48,000
你必然

3031
01:31:48,000 --> 01:31:49,000
就是我们在实际使用的

3032
01:31:49,000 --> 01:31:50,000
情况下

3033
01:31:50,000 --> 01:31:51,000
火星人

3034
01:31:51,000 --> 01:31:52,000
火星文必然是等价

3035
01:31:52,000 --> 01:31:53,000
为某一些

3036
01:31:53,000 --> 01:31:54,000
这个就是非火星文的

3037
01:31:54,000 --> 01:31:55,000
文本的嘛

3038
01:31:55,000 --> 01:31:56,000
就其实它也是

3039
01:31:56,000 --> 01:31:57,000
这个我觉得

3040
01:31:57,000 --> 01:31:58,000
这个还是

3041
01:31:58,000 --> 01:32:00,000
你留给人工智能解决吧

3042
01:32:00,000 --> 01:32:01,000
哈哈哈哈

3043
01:32:01,000 --> 01:32:02,000
这个

3044
01:32:02,000 --> 01:32:04,000
你强强强要一个

3045
01:32:04,000 --> 01:32:05,000
normalization 的过程

3046
01:32:05,000 --> 01:32:06,000
考虑这种情况

3047
01:32:06,000 --> 01:32:07,000
实在是太强一走

3048
01:32:07,000 --> 01:32:08,000
因为

3049
01:32:08,000 --> 01:32:10,000
因为这个可能不需要在

3050
01:32:10,000 --> 01:32:12,000
就不能写到规范里面去嘛

3051
01:32:12,000 --> 01:32:13,000
但是如果说

3052
01:32:13,000 --> 01:32:14,000
啊比如说

3053
01:32:14,000 --> 01:32:15,000
这个我们现在在做一个

3054
01:32:15,000 --> 01:32:16,000
这个

3055
01:32:16,000 --> 01:32:17,000
啊审查系统

3056
01:32:17,000 --> 01:32:18,000
对吧

3057
01:32:18,000 --> 01:32:19,000
我们做这个

3058
01:32:19,000 --> 01:32:20,000
这个内容过滤

3059
01:32:20,000 --> 01:32:21,000
可能要过滤到某一些

3060
01:32:21,000 --> 01:32:23,000
呃不合十一的字的时候

3061
01:32:23,000 --> 01:32:25,000
你肯定还是要做这个

3062
01:32:25,000 --> 01:32:26,000
火星文的拆解

3063
01:32:26,000 --> 01:32:27,000
然后做一个等价替换吧

3064
01:32:27,000 --> 01:32:28,000
啊

3065
01:32:28,000 --> 01:32:30,000
就你说能不能沿用 Unicode

3066
01:32:30,000 --> 01:32:31,000
这套 Normalize

3067
01:32:31,000 --> 01:32:33,000
就它的逻辑肯定是一样嘛

3068
01:32:33,000 --> 01:32:34,000
嗯

3069
01:32:34,000 --> 01:32:36,000
它就是所谓的兼容分解嘛

3070
01:32:36,000 --> 01:32:37,000
这个不一定

3071
01:32:37,000 --> 01:32:38,000
我觉得不一定

3072
01:32:38,000 --> 01:32:39,000
就要看你能不能

3073
01:32:39,000 --> 01:32:40,000
设计出这样一套机制

3074
01:32:40,000 --> 01:32:42,000
因为其实 Normalization

3075
01:32:42,000 --> 01:32:43,000
有一个数学上的特性

3076
01:32:43,000 --> 01:32:44,000
它叫密等性嘛

3077
01:32:44,000 --> 01:32:45,000
就是

3078
01:32:45,000 --> 01:32:46,000
你无论对一个串

3079
01:32:46,000 --> 01:32:47,000
做多少次

3080
01:32:47,000 --> 01:32:49,000
这个 Normalization 之后

3081
01:32:49,000 --> 01:32:50,000
结果最终是一样的

3082
01:32:50,000 --> 01:32:51,000
对对对

3083
01:32:51,000 --> 01:32:52,000
就是你要看你的

3084
01:32:52,000 --> 01:32:53,000
设计的这套

3085
01:32:53,000 --> 01:32:54,000
拆解和组合机制

3086
01:32:54,000 --> 01:32:56,000
能不能符合这个密等性

3087
01:32:56,000 --> 01:32:57,000
哈哈

3088
01:32:57,000 --> 01:32:58,000
可以开

3089
01:32:58,000 --> 01:32:59,000
而且密等要倒回来

3090
01:32:59,000 --> 01:33:00,000
对

3091
01:33:00,000 --> 01:33:01,000
当然要能倒回来

3092
01:33:01,000 --> 01:33:02,000
哈哈

3093
01:33:02,000 --> 01:33:03,000
倒不回来的话

3094
01:33:03,000 --> 01:33:05,000
就不就都错了吗

3095
01:33:05,000 --> 01:33:06,000
对

3096
01:33:06,000 --> 01:33:07,000
所以我觉得火星文

3097
01:33:07,000 --> 01:33:08,000
可能有问题

3098
01:33:08,000 --> 01:33:09,000
火星文有问题

3099
01:33:09,000 --> 01:33:10,000
那肯定是倒不回来的呀

3100
01:33:10,000 --> 01:33:11,000
比如说

3101
01:33:11,000 --> 01:33:13,000
比如说它原始的一个

3102
01:33:13,000 --> 01:33:15,000
我们刚才举那个 U

3103
01:33:15,000 --> 01:33:16,000
和上面有个

3104
01:33:16,000 --> 01:33:17,000
有一个 U-P

3105
01:33:17,000 --> 01:33:18,000
这个一个情况嘛

3106
01:33:18,000 --> 01:33:19,000
那其实我们想来

3107
01:33:19,000 --> 01:33:20,000
它应该有好几种

3108
01:33:20,000 --> 01:33:21,000
组合形式对吧

3109
01:33:21,000 --> 01:33:23,000
它可以说是 U

3110
01:33:23,000 --> 01:33:24,000
组合一个 U

3111
01:33:24,000 --> 01:33:25,000
就最拆解

3112
01:33:25,000 --> 01:33:26,000
三个密点

3113
01:33:26,000 --> 01:33:27,000
然后拼一集的方式嘛

3114
01:33:27,000 --> 01:33:28,000
它可以说是就是 U

3115
01:33:28,000 --> 01:33:29,000
上面有 U

3116
01:33:29,000 --> 01:33:30,000
然后再加一个音调

3117
01:33:30,000 --> 01:33:32,000
这是就两个点对吧

3118
01:33:32,000 --> 01:33:33,000
它可以是 U

3119
01:33:33,000 --> 01:33:35,000
有声调再加两个点嘛

3120
01:33:35,000 --> 01:33:36,000
那其实

3121
01:33:36,000 --> 01:33:37,000
你拆解之后

3122
01:33:37,000 --> 01:33:38,000
你是回不去的

3123
01:33:38,000 --> 01:33:40,000
它那个是一个单项的过程

3124
01:33:40,000 --> 01:33:41,000
就好像那个

3125
01:33:41,000 --> 01:33:43,000
反体中文转简体中文一样

3126
01:33:43,000 --> 01:33:44,000
你是不能

3127
01:33:44,000 --> 01:33:46,000
就是过去又回来的吗

3128
01:33:48,000 --> 01:33:49,000
OK

3129
01:33:50,000 --> 01:33:51,000
就是它应该不是

3130
01:33:51,000 --> 01:33:53,000
一个可逆的操作

3131
01:33:53,000 --> 01:33:54,000
为什么

3132
01:33:54,000 --> 01:33:55,000
因为你丢失了

3133
01:33:55,000 --> 01:33:56,000
你最开始你进去

3134
01:33:56,000 --> 01:33:58,000
你丢失了一开始的信息

3135
01:33:58,000 --> 01:33:59,000
这是没错的

3136
01:33:59,000 --> 01:34:00,000
就是你

3137
01:34:00,000 --> 01:34:02,000
Normalize 过后

3138
01:34:02,000 --> 01:34:03,000
你一开始怎么样

3139
01:34:03,000 --> 01:34:04,000
你就不知道

3140
01:34:04,000 --> 01:34:05,000
对啊

3141
01:34:05,000 --> 01:34:07,000
所以它就都能做到密的

3142
01:34:07,000 --> 01:34:08,000
就是可以不断重复的

3143
01:34:08,000 --> 01:34:09,000
做一个 Normalize

3144
01:34:09,000 --> 01:34:10,000
它得到的结果是稳定的

3145
01:34:10,000 --> 01:34:11,000
但是它不能

3146
01:34:11,000 --> 01:34:12,000
它不能做

3147
01:34:12,000 --> 01:34:13,000
不能再逆回

3148
01:34:13,000 --> 01:34:14,000
就不可逆了

3149
01:34:15,000 --> 01:34:16,000
你的意思是

3150
01:34:16,000 --> 01:34:17,000
你不知道

3151
01:34:17,000 --> 01:34:18,000
它最初这个 sauce

3152
01:34:18,000 --> 01:34:19,000
究竟是哪一种表达形式

3153
01:34:19,000 --> 01:34:20,000
对对对

3154
01:34:20,000 --> 01:34:21,000
你不知道

3155
01:34:21,000 --> 01:34:22,000
你 Normalize 的时候

3156
01:34:22,000 --> 01:34:23,000
就破掉那个信息了

3157
01:34:23,000 --> 01:34:24,000
对

3158
01:34:24,000 --> 01:34:25,000
OK

3159
01:34:25,000 --> 01:34:26,000
所以它是相等的

3160
01:34:26,000 --> 01:34:28,000
但是如果你拆这个

3161
01:34:28,000 --> 01:34:29,000
汉字的话

3162
01:34:29,000 --> 01:34:30,000
就不一定了

3163
01:34:30,000 --> 01:34:31,000
因为你本质上拆汉字

3164
01:34:31,000 --> 01:34:34,000
就是把汉字拆成各种偏旁部手

3165
01:34:34,000 --> 01:34:36,000
然后把它们组合起来

3166
01:34:36,000 --> 01:34:37,000
但我们知道

3167
01:34:37,000 --> 01:34:38,000
汉字这个偏旁部手

3168
01:34:38,000 --> 01:34:40,000
可能前一个字的一个偏旁

3169
01:34:40,000 --> 01:34:42,000
可以成为后一个字的

3170
01:34:42,000 --> 01:34:43,000
另一个偏旁

3171
01:34:43,000 --> 01:34:44,000
所以他们的组合方式

3172
01:34:44,000 --> 01:34:45,000
有很多

3173
01:34:45,000 --> 01:34:46,000
这个时候

3174
01:34:46,000 --> 01:34:48,000
他们就可能都密等了

3175
01:34:48,000 --> 01:34:49,000
就是那个火星纹的左右

3176
01:34:49,000 --> 01:34:51,000
可能选出来的那个字

3177
01:34:51,000 --> 01:34:52,000
就是一个是选的左边

3178
01:34:52,000 --> 01:34:53,000
那个部手

3179
01:34:53,000 --> 01:34:54,000
一个是选的是右边

3180
01:34:54,000 --> 01:34:55,000
对对对

3181
01:34:55,000 --> 01:34:56,000
就有可能会有这种情况

3182
01:34:56,000 --> 01:34:57,000
对

3183
01:34:57,000 --> 01:34:59,000
这有可能会破坏这个密等性

3184
01:34:59,000 --> 01:35:02,000
所以还是听课的一个事情

3185
01:35:02,000 --> 01:35:03,000
对

3186
01:35:03,000 --> 01:35:05,000
因为 Unicode 为了维持这个密等性

3187
01:35:05,000 --> 01:35:07,000
它其实是做了很多工作的

3188
01:35:07,000 --> 01:35:08,000
包括它定义了

3189
01:35:08,000 --> 01:35:09,000
这个拆解

3190
01:35:09,000 --> 01:35:10,000
出来的部件的顺势

3191
01:35:10,000 --> 01:35:12,000
如果你破坏了这个顺势的话

3192
01:35:12,000 --> 01:35:13,000
就有可能破坏了这个密等性

3193
01:35:13,000 --> 01:35:14,000
所以它拆解的这个顺势

3194
01:35:14,000 --> 01:35:16,000
是有确定的顺势的

3195
01:35:16,000 --> 01:35:17,000
比如有一些字母

3196
01:35:17,000 --> 01:35:18,000
它可能上面可以加一个点

3197
01:35:18,000 --> 01:35:19,000
下面也可以加一个点

3198
01:35:19,000 --> 01:35:21,000
那么哪个点

3199
01:35:21,000 --> 01:35:22,000
是下面这个点在前

3200
01:35:22,000 --> 01:35:23,000
还是上面这个点在前

3201
01:35:23,000 --> 01:35:25,000
它其实是有固定顺势的

3202
01:35:28,000 --> 01:35:30,000
本期节目的那个 show notes 里面

3203
01:35:30,000 --> 01:35:31,000
还得标注一下

3204
01:35:31,000 --> 01:35:32,000
密等性的一个连接

3205
01:35:32,000 --> 01:35:33,000
到底是它还是

3206
01:35:33,000 --> 01:35:34,000
密等性

3207
01:35:34,000 --> 01:35:35,000
天呐

3208
01:35:35,000 --> 01:35:36,000
我说

3209
01:35:36,000 --> 01:35:37,000
庞佳

3210
01:35:37,000 --> 01:35:38,000
对

3211
01:35:38,000 --> 01:35:39,000
最后

3212
01:35:39,000 --> 01:35:40,000
我相信你那种读者

3213
01:35:40,000 --> 01:35:41,000
是连着密等性

3214
01:35:41,000 --> 01:35:42,000
一路点到什么

3215
01:35:42,000 --> 01:35:44,000
庞佳来什么

3216
01:35:44,000 --> 01:35:45,000
对

3217
01:35:45,000 --> 01:35:47,000
这就是个数学问题

3218
01:35:47,000 --> 01:35:48,000
对

3219
01:35:48,000 --> 01:35:49,000
歌的不完美定理

3220
01:35:49,000 --> 01:35:50,000
对

3221
01:35:51,000 --> 01:35:53,000
滑了好大一个

3222
01:35:53,000 --> 01:35:54,000
我说 VTB 的各种连接

3223
01:35:54,000 --> 01:35:55,000
点点点你最后

3224
01:35:55,000 --> 01:35:56,000
都会点到那几个页面

3225
01:35:56,000 --> 01:35:57,000
对

3226
01:35:57,000 --> 01:35:58,000
最终肯定会回到哲学

3227
01:35:58,000 --> 01:35:59,000
我另讲

3228
01:35:59,000 --> 01:36:00,000
哲学和修学

3229
01:36:08,000 --> 01:36:09,000
刚才我们讲了

3230
01:36:09,000 --> 01:36:11,000
就是那个 normalization 的

3231
01:36:11,000 --> 01:36:12,000
各种方法

3232
01:36:12,000 --> 01:36:14,000
和它的背后的一些机制

3233
01:36:14,000 --> 01:36:16,000
然后我们回来讲

3234
01:36:16,000 --> 01:36:17,000
APFS

3235
01:36:17,000 --> 01:36:19,000
它在 MacOS

3236
01:36:19,000 --> 01:36:21,000
和 iOS 面到底不一样的地方

3237
01:36:21,000 --> 01:36:22,000
我觉得这个还其实

3238
01:36:22,000 --> 01:36:23,000
挺有意思的

3239
01:36:23,000 --> 01:36:24,000
因为照我的理解

3240
01:36:24,000 --> 01:36:26,000
APFS 在 MacOS 里面

3241
01:36:26,000 --> 01:36:27,000
对于

3242
01:36:27,000 --> 01:36:28,000
纽纳性的处理是

3243
01:36:28,000 --> 01:36:30,000
最近才决定的

3244
01:36:30,000 --> 01:36:31,000
其实我们在之前上

3245
01:36:31,000 --> 01:36:33,000
那个 iOS 的

3246
01:36:33,000 --> 01:36:34,000
APFS

3247
01:36:34,000 --> 01:36:35,000
它是没有考虑这个问题的

3248
01:36:35,000 --> 01:36:37,000
对

3249
01:36:37,000 --> 01:36:38,000
所以它现在搞了一个

3250
01:36:38,000 --> 01:36:39,000
什么样的一个

3251
01:36:39,000 --> 01:36:40,000
Hash 的方式

3252
01:36:40,000 --> 01:36:41,000
我还没太明白

3253
01:36:41,000 --> 01:36:42,000
你们谁看了

3254
01:36:43,000 --> 01:36:44,000
我也不知道

3255
01:36:44,000 --> 01:36:45,000
它

3256
01:36:45,000 --> 01:36:46,000
就是

3257
01:36:46,000 --> 01:36:48,000
因为它改成 APFS

3258
01:36:48,000 --> 01:36:50,000
不管 Mac

3259
01:36:50,000 --> 01:36:51,000
是用 HFS

3260
01:36:51,000 --> 01:36:53,000
加还是用 APFS

3261
01:36:53,000 --> 01:36:54,000
它都是

3262
01:36:54,000 --> 01:36:56,000
normalization insensitive 的

3263
01:36:56,000 --> 01:36:57,000
它就

3264
01:36:57,000 --> 01:36:59,000
它不敏感

3265
01:36:59,000 --> 01:37:01,000
它对你这个规范法形式

3266
01:37:01,000 --> 01:37:02,000
不敏感

3267
01:37:02,000 --> 01:37:03,000
但是

3268
01:37:03,000 --> 01:37:05,000
HFS

3269
01:37:05,000 --> 01:37:08,000
它就直接存在

3270
01:37:08,000 --> 01:37:09,000
磁盘上了

3271
01:37:10,000 --> 01:37:11,000
APFS

3272
01:37:11,000 --> 01:37:13,000
它是先规范化

3273
01:37:13,000 --> 01:37:14,000
然后文静名

3274
01:37:14,000 --> 01:37:16,000
它会另外生成一个 Hash 值

3275
01:37:17,000 --> 01:37:18,000
来

3276
01:37:18,000 --> 01:37:19,000
来

3277
01:37:19,000 --> 01:37:20,000
来给

3278
01:37:20,000 --> 01:37:21,000
提供

3279
01:37:21,000 --> 01:37:22,000
normalization 的

3280
01:37:23,000 --> 01:37:24,000
就

3281
01:37:24,000 --> 01:37:25,000
不敏感性

3282
01:37:25,000 --> 01:37:26,000
要不然的话

3283
01:37:26,000 --> 01:37:27,000
就找不到了

3284
01:37:27,000 --> 01:37:28,000
所以它必须

3285
01:37:28,000 --> 01:37:29,000
再给它付一个

3286
01:37:29,000 --> 01:37:30,000
自动付一个 Hash 值

3287
01:37:32,000 --> 01:37:33,000
ok

3288
01:37:33,000 --> 01:37:34,000
这里面其实

3289
01:37:34,000 --> 01:37:36,000
还挺麻烦的

3290
01:37:36,000 --> 01:37:37,000
因为有几个问题

3291
01:37:37,000 --> 01:37:38,000
刚才也讲的

3292
01:37:38,000 --> 01:37:39,000
有几个事情

3293
01:37:39,000 --> 01:37:40,000
我再来一题

3294
01:37:40,000 --> 01:37:41,000
就是一个说

3295
01:37:41,000 --> 01:37:42,000
它要不要保留

3296
01:37:42,000 --> 01:37:43,000
你开始的

3297
01:37:43,000 --> 01:37:44,000
先说一下

3298
01:37:44,000 --> 01:37:45,000
还有个事情没说

3299
01:37:45,000 --> 01:37:46,000
刚才

3300
01:37:46,000 --> 01:37:47,000
跟您有关系

3301
01:37:47,000 --> 01:37:49,000
iOS 的文件是

3302
01:37:49,000 --> 01:37:51,000
大小写敏感的

3303
01:37:51,000 --> 01:37:52,000
大小写是

3304
01:37:52,000 --> 01:37:53,000
同样一个文件

3305
01:37:53,000 --> 01:37:54,000
敏感大小写不一样

3306
01:37:54,000 --> 01:37:55,000
它认为是不一样的

3307
01:37:55,000 --> 01:37:58,000
文件

3308
01:37:58,000 --> 01:38:00,000
在 MACOS 里面

3309
01:38:00,000 --> 01:38:02,000
不管是

3310
01:38:02,000 --> 01:38:04,000
它不管是过去的 HFS

3311
01:38:04,000 --> 01:38:05,000
还是现在的 APFS

3312
01:38:05,000 --> 01:38:06,000
它默认的都是

3313
01:38:06,000 --> 01:38:07,000
大小写不敏感

3314
01:38:07,000 --> 01:38:08,000
它认为两个

3315
01:38:08,000 --> 01:38:10,000
它是大小写

3316
01:38:10,000 --> 01:38:11,000
可保存

3317
01:38:11,000 --> 01:38:13,000
但是不敏感

3318
01:38:13,000 --> 01:38:14,000
它会把

3319
01:38:14,000 --> 01:38:15,000
你开始原始的

3320
01:38:15,000 --> 01:38:17,000
大小写保留下来

3321
01:38:17,000 --> 01:38:18,000
但是就说

3322
01:38:18,000 --> 01:38:20,000
它不会说

3323
01:38:20,000 --> 01:38:22,000
它会去区分这个事情

3324
01:38:22,000 --> 01:38:23,000
但是

3325
01:38:23,000 --> 01:38:24,000
当然也可以

3326
01:38:24,000 --> 01:38:25,000
你在 MACOS 里面

3327
01:38:25,000 --> 01:38:26,000
你在格式化一个字盘的时候

3328
01:38:26,000 --> 01:38:27,000
你可以选择

3329
01:38:27,000 --> 01:38:28,000
让文件系统

3330
01:38:28,000 --> 01:38:29,000
做成大小写敏感的

3331
01:38:29,000 --> 01:38:31,000
但应该用的人不拨

3332
01:38:31,000 --> 01:38:32,000
而且在用了之后

3333
01:38:32,000 --> 01:38:33,000
会导致很多

3334
01:38:33,000 --> 01:38:34,000
兼容性的问题

3335
01:38:34,000 --> 01:38:35,000
就是不太鼓励

3336
01:38:35,000 --> 01:38:36,000
大家这么做的

3337
01:38:36,000 --> 01:38:37,000
所以这里面

3338
01:38:37,000 --> 01:38:38,000
如果它是用 HASI 纸的话

3339
01:38:38,000 --> 01:38:39,000
就会牵涉到这个问题

3340
01:38:39,000 --> 01:38:42,000
如果它是大小写 Preserving

3341
01:38:42,000 --> 01:38:43,000
就是 Case Preserving 的话

3342
01:38:43,000 --> 01:38:46,000
它 HASI 的那个串

3343
01:38:46,000 --> 01:38:48,000
是到底是什么

3344
01:38:48,000 --> 01:38:50,000
因为大小写

3345
01:38:50,000 --> 01:38:51,000
不同的两个

3346
01:38:51,000 --> 01:38:53,000
同样的字幕串

3347
01:38:53,000 --> 01:38:55,000
HASI 只是不一样的

3348
01:38:55,000 --> 01:38:56,000
对

3349
01:38:56,000 --> 01:38:57,000
这样的话

3350
01:38:57,000 --> 01:38:59,000
它的 Case Preserving

3351
01:38:59,000 --> 01:39:01,000
和它的 HASI 的方式

3352
01:39:01,000 --> 01:39:03,000
其实是有冲突的

3353
01:39:03,000 --> 01:39:04,000
所以我一直没太

3354
01:39:04,000 --> 01:39:05,000
搞明白这里是怎么一回事

3355
01:39:05,000 --> 01:39:06,000
对

3356
01:39:06,000 --> 01:39:07,000
我觉得

3357
01:39:07,000 --> 01:39:09,000
现在要给自弹自唱的听众

3358
01:39:09,000 --> 01:39:10,000
简单解释一下

3359
01:39:10,000 --> 01:39:12,000
HASI 是个什么样的过程

3360
01:39:13,000 --> 01:39:15,000
HASI 你可以理解成为

3361
01:39:15,000 --> 01:39:17,000
就是我们把一个自弹

3362
01:39:17,000 --> 01:39:18,000
自弹自唱

3363
01:39:18,000 --> 01:39:20,000
然后通过某种数学的方式

3364
01:39:20,000 --> 01:39:22,000
把它变成一个

3365
01:39:22,000 --> 01:39:25,000
固定长度的一个数字

3366
01:39:25,000 --> 01:39:27,000
这可能都是比如说

3367
01:39:27,000 --> 01:39:28,000
是 122

3368
01:39:28,000 --> 01:39:29,000
对

3369
01:39:29,000 --> 01:39:31,000
HASI 一般 16 个字节是多少

3370
01:39:31,000 --> 01:39:33,000
16 个字节是乘以 8

3371
01:39:33,000 --> 01:39:34,000
对吧

3372
01:39:34,000 --> 01:39:35,000
256 个

3373
01:39:37,000 --> 01:39:38,000
对 错了

3374
01:39:38,000 --> 01:39:40,000
256 个自弹自弹

3375
01:39:41,000 --> 01:39:42,000
给它一个

3376
01:39:42,000 --> 01:39:43,000
生成了一个

3377
01:39:43,000 --> 01:39:45,000
特定的一个

3378
01:39:45,000 --> 01:39:46,000
一个定号

3379
01:39:46,000 --> 01:39:47,000
对

3380
01:39:47,000 --> 01:39:48,000
定成的

3381
01:39:48,000 --> 01:39:49,000
会返回一个比如说

3382
01:39:49,000 --> 01:39:51,000
256 个 bit 的一个数

3383
01:39:51,000 --> 01:39:53,000
或者是 512 个 bit 的一个数

3384
01:39:53,000 --> 01:39:55,000
然后因为这个数其实足够大嘛

3385
01:39:55,000 --> 01:39:57,000
你想想 2.256 字方

3386
01:39:57,000 --> 01:39:59,000
这个数其实是非常大的

3387
01:39:59,000 --> 01:40:00,000
那么这个 HASI 有个什么特性呢

3388
01:40:00,000 --> 01:40:01,000
就是说

3389
01:40:01,000 --> 01:40:02,000
只要我们那个 HASI 算法

3390
01:40:02,000 --> 01:40:04,000
或者这个 HASI 函数选得少

3391
01:40:04,000 --> 01:40:06,000
我们可以做到在

3392
01:40:06,000 --> 01:40:09,000
一个几乎可以忽略的概率上

3393
01:40:09,000 --> 01:40:11,000
得到那个数和

3394
01:40:11,000 --> 01:40:12,000
就两个

3395
01:40:12,000 --> 01:40:13,000
不太可能

3396
01:40:13,000 --> 01:40:16,000
你不太可能拿两个有意义的文本

3397
01:40:16,000 --> 01:40:19,000
得到两个完全一样的 HASI 的值

3398
01:40:19,000 --> 01:40:21,000
这个可能有很多人

3399
01:40:21,000 --> 01:40:22,000
比较容易费解这个东西

3400
01:40:22,000 --> 01:40:23,000
就因为你想一下

3401
01:40:23,000 --> 01:40:25,000
这个数在数学上是不可能的嘛

3402
01:40:25,000 --> 01:40:27,000
因为你的那个自幅串的

3403
01:40:27,000 --> 01:40:28,000
就是你的那个 HASI 函数的

3404
01:40:28,000 --> 01:40:30,000
那个输入的那个 space

3405
01:40:30,000 --> 01:40:31,000
input space

3406
01:40:31,000 --> 01:40:33,000
是远远大于这个 output space

3407
01:40:33,000 --> 01:40:34,000
一样的固定

3408
01:40:34,000 --> 01:40:36,000
它是一个固定固定的一个

3409
01:40:36,000 --> 01:40:37,000
它是有限值

3410
01:40:37,000 --> 01:40:38,000
对 它是有限值

3411
01:40:38,000 --> 01:40:40,000
但你输的其实是一个无限值

3412
01:40:40,000 --> 01:40:43,000
但是因为那个输出

3413
01:40:43,000 --> 01:40:46,000
有限值的空间足够足够大

3414
01:40:46,000 --> 01:40:48,000
然后只要我们这个 HASI 函数选得

3415
01:40:48,000 --> 01:40:49,000
足够好的话

3416
01:40:49,000 --> 01:40:51,000
我们是可以在大概率上

3417
01:40:51,000 --> 01:40:52,000
认为是不会出现那种

3418
01:40:52,000 --> 01:40:54,000
两个不同的输入

3419
01:40:54,000 --> 01:40:56,000
得到同一个 HASI 值的

3420
01:40:56,000 --> 01:40:57,000
然后这个 HASI 值

3421
01:40:57,000 --> 01:40:58,000
我们可以拿来做很多事情

3422
01:40:58,000 --> 01:40:59,000
比如说我们可以拿来

3423
01:40:59,000 --> 01:41:01,000
把一个东西缩短成一个

3424
01:41:01,000 --> 01:41:02,000
我们认为

3425
01:41:02,000 --> 01:41:03,000
这个它这是一个

3426
01:41:03,000 --> 01:41:05,000
类似于指纹的一个概念

3427
01:41:05,000 --> 01:41:06,000
对吧

3428
01:41:06,000 --> 01:41:08,000
它这个这一串 HASI 值

3429
01:41:08,000 --> 01:41:09,000
可以对应那串原文

3430
01:41:09,000 --> 01:41:10,000
因为我们找不到

3431
01:41:10,000 --> 01:41:11,000
另外一串原文

3432
01:41:11,000 --> 01:41:14,000
跟这个可以得到同样的 HASI 值

3433
01:41:14,000 --> 01:41:16,000
然后 APFS 里面

3434
01:41:16,000 --> 01:41:17,000
就它就说

3435
01:41:17,000 --> 01:41:18,000
我是用这个 HASI 值

3436
01:41:18,000 --> 01:41:19,000
来保存文件的

3437
01:41:19,000 --> 01:41:20,000
对吧

3438
01:41:20,000 --> 01:41:22,000
保存文件名

3439
01:41:22,000 --> 01:41:23,000
对 但我就不太理解

3440
01:41:23,000 --> 01:41:24,000
就说这里面

3441
01:41:24,000 --> 01:41:25,000
如果它怎么去解决

3442
01:41:25,000 --> 01:41:26,000
刚才讲的那个

3443
01:41:26,000 --> 01:41:27,000
case preserving 的问题

3444
01:41:27,000 --> 01:41:28,000
就其实我看见

3445
01:41:28,000 --> 01:41:29,000
还觉得还挺难的

3446
01:41:29,000 --> 01:41:31,000
所以就是有一个历史

3447
01:41:31,000 --> 01:41:34,000
就是在这个

3448
01:41:34,000 --> 01:41:35,000
MacOS Sierra

3449
01:41:35,000 --> 01:41:37,000
对去年 6 月份

3450
01:41:37,000 --> 01:41:38,000
它已经

3451
01:41:38,000 --> 01:41:40,000
它有做一个 APFS 的

3452
01:41:40,000 --> 01:41:42,000
第一版的开发者的预览版

3453
01:41:42,000 --> 01:41:44,000
当时这个预览版里面

3454
01:41:44,000 --> 01:41:46,000
只有 case sensitive 的版本

3455
01:41:46,000 --> 01:41:47,000
嗯哼

3456
01:41:47,000 --> 01:41:49,000
就是说明那时候

3457
01:41:49,000 --> 01:41:50,000
苹果还没想好

3458
01:41:50,000 --> 01:41:51,000
就怎么做你知道吗

3459
01:41:51,000 --> 01:41:52,000
所以当时

3460
01:41:52,000 --> 01:41:54,000
它做的第一版的开发者预览版

3461
01:41:54,000 --> 01:41:56,000
只能做 case sensitive

3462
01:41:56,000 --> 01:41:57,000
对大小写的

3463
01:41:57,000 --> 01:41:58,000
那就是最简单吗

3464
01:41:58,000 --> 01:42:00,000
对对对

3465
01:42:00,000 --> 01:42:02,000
然后等到后面

3466
01:42:02,000 --> 01:42:05,000
MacOS 的 12.4 了以后

3467
01:42:05,000 --> 01:42:06,000
给这个开发者预览版

3468
01:42:06,000 --> 01:42:08,000
后面它才补家的

3469
01:42:08,000 --> 01:42:11,000
做出来这个 case sensitive 的版本

3470
01:42:11,000 --> 01:42:12,000
因为它这个是

3471
01:42:12,000 --> 01:42:13,000
就是就是

3472
01:42:13,000 --> 01:42:14,000
因为就是为了

3473
01:42:14,000 --> 01:42:15,000
去填那个历史的坑嘛

3474
01:42:15,000 --> 01:42:16,000
对对对

3475
01:42:16,000 --> 01:42:17,000
因为过去

3476
01:42:17,000 --> 01:42:18,000
它是默认是 insensitive 的

3477
01:42:18,000 --> 01:42:20,000
你就很很尴尬啊

3478
01:42:20,000 --> 01:42:21,000
对

3479
01:42:21,000 --> 01:42:22,000
所以其实就是

3480
01:42:22,000 --> 01:42:23,000
它在后面

3481
01:42:23,000 --> 01:42:24,000
具体它在怎么搞

3482
01:42:24,000 --> 01:42:25,000
其实我也不太清楚

3483
01:42:25,000 --> 01:42:26,000
但是就是

3484
01:42:26,000 --> 01:42:27,000
因为有这个坑

3485
01:42:27,000 --> 01:42:28,000
对

3486
01:42:28,000 --> 01:42:29,000
因为有这个坑

3487
01:42:29,000 --> 01:42:31,000
所以它也是花了很长时间

3488
01:42:31,000 --> 01:42:32,000
在搞

3489
01:42:32,000 --> 01:42:33,000
因为现在那个

3490
01:42:33,000 --> 01:42:34,000
APFS

3491
01:42:34,000 --> 01:42:35,000
就是那个 hassera

3492
01:42:35,000 --> 01:42:36,000
还没有

3493
01:42:36,000 --> 01:42:37,000
就是正式发布

3494
01:42:37,000 --> 01:42:39,000
现在就是 battapen

3495
01:42:39,000 --> 01:42:41,000
他们还有的有的机会改

3496
01:42:41,000 --> 01:42:42,000
但是如果说到了今年的

3497
01:42:42,000 --> 01:42:43,000
这个 9 月份

3498
01:42:43,000 --> 01:42:44,000
也就是两月的时间

3499
01:42:44,000 --> 01:42:45,000
对

3500
01:42:45,000 --> 01:42:47,000
就会放出来

3501
01:42:47,000 --> 01:42:48,000
放出来之后

3502
01:42:48,000 --> 01:42:49,000
如果没有这个问题

3503
01:42:49,000 --> 01:42:50,000
没解决好的话

3504
01:42:50,000 --> 01:42:51,000
就会导致很多人的

3505
01:42:51,000 --> 01:42:52,000
软件可能用不了

3506
01:42:52,000 --> 01:42:53,000
或者说是文件

3507
01:42:53,000 --> 01:42:54,000
不出问题的情况

3508
01:42:54,000 --> 01:42:55,000
所以他们必须在

3509
01:42:55,000 --> 01:42:56,000
必须在这段时间

3510
01:42:56,000 --> 01:42:58,000
把这个问题给彻底解决了

3511
01:42:58,000 --> 01:43:00,000
用各种方式吧

3512
01:43:00,000 --> 01:43:01,000
我们看到的

3513
01:43:01,000 --> 01:43:02,000
其实也不是一个

3514
01:43:02,000 --> 01:43:03,000
我觉得应该也不是

3515
01:43:03,000 --> 01:43:04,000
一个最终的版本

3516
01:43:04,000 --> 01:43:05,000
嗯

3517
01:43:05,000 --> 01:43:07,000
不过反正 hassera

3518
01:43:07,000 --> 01:43:08,000
是可以定了

3519
01:43:08,000 --> 01:43:10,000
就是肯定要用新的这个

3520
01:43:10,000 --> 01:43:11,000
APFS 了

3521
01:43:11,000 --> 01:43:12,000
嗯哼

3522
01:43:12,000 --> 01:43:13,000
在安装过程中

3523
01:43:13,000 --> 01:43:14,000
它会默认的

3524
01:43:14,000 --> 01:43:16,000
它会先把你格式化一遍

3525
01:43:16,000 --> 01:43:17,000
你已经装了吗

3526
01:43:17,000 --> 01:43:18,000
格式化

3527
01:43:18,000 --> 01:43:19,000
没有没有

3528
01:43:19,000 --> 01:43:20,000
没装的

3529
01:43:20,000 --> 01:43:21,000
但是

3530
01:43:21,000 --> 01:43:23,000
其实在生那个 iOS 10.3

3531
01:43:23,000 --> 01:43:24,000
的时候就是这样的

3532
01:43:24,000 --> 01:43:25,000
iOS 都说了嘛

3533
01:43:25,000 --> 01:43:26,000
它不存在这个

3534
01:43:26,000 --> 01:43:27,000
它不担心这个问题

3535
01:43:27,000 --> 01:43:28,000
因为 iOS

3536
01:43:28,000 --> 01:43:29,000
并没有创造的系统

3537
01:43:29,000 --> 01:43:30,000
而且

3538
01:43:30,000 --> 01:43:31,000
而且

3539
01:43:31,000 --> 01:43:32,000
而且 iOS 还有一个特性

3540
01:43:32,000 --> 01:43:33,000
就是它没有一个

3541
01:43:33,000 --> 01:43:35,000
它只有一套 API 去访问

3542
01:43:35,000 --> 01:43:36,000
那个文件

3543
01:43:36,000 --> 01:43:38,000
就是用那个 fondation 那些裤

3544
01:43:38,000 --> 01:43:39,000
它不像那个 Mac 里面

3545
01:43:39,000 --> 01:43:41,000
我们用这个 terminal 的时候

3546
01:43:41,000 --> 01:43:42,000
就是直接用 positc

3547
01:43:42,000 --> 01:43:44,000
就 unix 那套国际去访问嘛

3548
01:43:44,000 --> 01:43:45,000
所以它是

3549
01:43:45,000 --> 01:43:46,000
positc

3550
01:43:46,000 --> 01:43:47,000
对 它考虑的那个

3551
01:43:47,000 --> 01:43:48,000
那个

3552
01:43:48,000 --> 01:43:49,000
那个难度就是要小很多

3553
01:43:49,000 --> 01:43:50,000
对

3554
01:43:50,000 --> 01:43:51,000
所以我觉得 Mac

3555
01:43:51,000 --> 01:43:52,000
其实挺大的一个坑的

3556
01:43:52,000 --> 01:43:53,000
嗯

3557
01:43:53,000 --> 01:43:54,000
而且说实话

3558
01:43:54,000 --> 01:43:55,000
这个东西对用户来讲

3559
01:43:55,000 --> 01:43:56,000
是完全看不见的嘛

3560
01:43:56,000 --> 01:43:57,000
像我刚才说的

3561
01:43:57,000 --> 01:43:59,000
它这个隔世化的过程

3562
01:43:59,000 --> 01:44:01,000
它其实就放到了那个

3563
01:44:01,000 --> 01:44:02,000
安装进程里面去

3564
01:44:02,000 --> 01:44:03,000
你开始

3565
01:44:03,000 --> 01:44:04,000
对

3566
01:44:04,000 --> 01:44:06,000
尤其是对于 iOS

3567
01:44:06,000 --> 01:44:07,000
你在装

3568
01:44:07,000 --> 01:44:08,000
在更新的时候

3569
01:44:08,000 --> 01:44:10,000
就用户不能做任何事情嘛

3570
01:44:10,000 --> 01:44:11,000
反正你等着它

3571
01:44:11,000 --> 01:44:13,000
要重新启动两遍

3572
01:44:13,000 --> 01:44:14,000
反正就是新的了

3573
01:44:14,000 --> 01:44:15,000
就这样

3574
01:44:15,000 --> 01:44:16,000
而且

3575
01:44:16,000 --> 01:44:17,000
而且就是用户

3576
01:44:17,000 --> 01:44:19,000
就会知道了这个区别

3577
01:44:19,000 --> 01:44:20,000
它还改不了

3578
01:44:20,000 --> 01:44:21,000
做不了任何事情

3579
01:44:21,000 --> 01:44:22,000
因为用到这个程序

3580
01:44:22,000 --> 01:44:23,000
如果没有

3581
01:44:23,000 --> 01:44:24,000
没有更新去支持这个事情的话

3582
01:44:24,000 --> 01:44:26,000
你也是只能抓瞎嘛

3583
01:44:26,000 --> 01:44:27,000
对

3584
01:44:27,000 --> 01:44:28,000
那对于 Mac 的话呢

3585
01:44:28,000 --> 01:44:29,000
可能就是因为

3586
01:44:29,000 --> 01:44:31,000
如果万一搞不清楚的话

3587
01:44:31,000 --> 01:44:32,000
就会造成

3588
01:44:32,000 --> 01:44:33,000
找不到文件了

3589
01:44:33,000 --> 01:44:34,000
对吧

3590
01:44:34,000 --> 01:44:35,000
因为那个

3591
01:44:35,000 --> 01:44:37,000
Normalization 不一样

3592
01:44:37,000 --> 01:44:38,000
文件名不一样嘛

3593
01:44:38,000 --> 01:44:39,000
然后就和你

3594
01:44:39,000 --> 01:44:41,000
自帮行存了很多新品

3595
01:44:41,000 --> 01:44:42,000
就找不到了

3596
01:44:42,000 --> 01:44:43,000
就是有时候

3597
01:44:43,000 --> 01:44:44,000
最坑的

3598
01:44:44,000 --> 01:44:46,000
最差的结果嘛

3599
01:44:46,000 --> 01:44:48,000
所以这个 Normalization

3600
01:44:48,000 --> 01:44:50,000
这个事情会对我们交换

3601
01:44:50,000 --> 01:44:52,000
在不同性的里面交换文件产生影响嘛

3602
01:44:52,000 --> 01:44:53,000
就是

3603
01:44:53,000 --> 01:44:54,000
因为现在有很多问题

3604
01:44:54,000 --> 01:44:55,000
比如说

3605
01:44:55,000 --> 01:44:57,000
说到 Windows 用户

3606
01:44:57,000 --> 01:44:58,000
发给你们这种 ZIP

3607
01:44:58,000 --> 01:44:59,000
这种打包的

3608
01:44:59,000 --> 01:45:00,000
这种压缩包

3609
01:45:01,000 --> 01:45:02,000
经常会乱码的事情

3610
01:45:02,000 --> 01:45:03,000
就经常会解决

3611
01:45:03,000 --> 01:45:05,000
解出来里面的那个文件

3612
01:45:05,000 --> 01:45:07,000
就是那个名字是乱的嘛

3613
01:45:07,000 --> 01:45:08,000
嗯

3614
01:45:08,000 --> 01:45:10,000
但是那个乱码的机制

3615
01:45:10,000 --> 01:45:11,000
很复杂的

3616
01:45:11,000 --> 01:45:12,000
就是为什么会乱

3617
01:45:15,000 --> 01:45:16,000
就是简单来说

3618
01:45:17,000 --> 01:45:19,000
那个 ZIP 打包的时候

3619
01:45:19,000 --> 01:45:21,000
它会把那些文件名的信息

3620
01:45:21,000 --> 01:45:22,000
也装进去嘛

3621
01:45:22,000 --> 01:45:23,000
这个时候它用的那个

3622
01:45:23,000 --> 01:45:25,000
它会用的那个解码的方式

3623
01:45:25,000 --> 01:45:26,000
嗯

3624
01:45:26,000 --> 01:45:27,000
就是 ZIP 这个格式

3625
01:45:27,000 --> 01:45:29,000
其实是比较灵活的

3626
01:45:29,000 --> 01:45:30,000
它不会要求说

3627
01:45:30,000 --> 01:45:32,000
你一定要有什么影响的方式

3628
01:45:32,000 --> 01:45:34,000
这个时候都是有那个打包程序决定的嘛

3629
01:45:34,000 --> 01:45:35,000
但是

3630
01:45:35,000 --> 01:45:36,000
解码的程序

3631
01:45:36,000 --> 01:45:37,000
如果用的

3632
01:45:37,000 --> 01:45:38,000
跟那个打包程序

3633
01:45:38,000 --> 01:45:39,000
它用的那个理解是不一样的话

3634
01:45:39,000 --> 01:45:40,000
就会导致这个问题

3635
01:45:40,000 --> 01:45:42,000
经常我们受到一个 Windows

3636
01:45:42,000 --> 01:45:44,000
Windows 用发过来打包的

3637
01:45:45,000 --> 01:45:47,000
但是这是编码层次的问题啊

3638
01:45:47,000 --> 01:45:48,000
就是比如说

3639
01:45:48,000 --> 01:45:50,000
它没有用 UTF 8 之类的

3640
01:45:50,000 --> 01:45:52,000
这是编码和解码的事情啊

3641
01:45:52,000 --> 01:45:53,000
对对对

3642
01:45:53,000 --> 01:45:54,000
但是我就说

3643
01:45:54,000 --> 01:45:55,000
如果是

3644
01:45:55,000 --> 01:45:57,000
哪怕它们都用了 UTF 8 去编码

3645
01:45:57,000 --> 01:45:58,000
那个 Nomad 这些不同的话

3646
01:45:58,000 --> 01:46:00,000
解出来也会导致不同的程序

3647
01:46:00,000 --> 01:46:01,000
也会不一样

3648
01:46:01,000 --> 01:46:02,000
对

3649
01:46:02,000 --> 01:46:03,000
是的

3650
01:46:03,000 --> 01:46:05,000
所以这是一个

3651
01:46:05,000 --> 01:46:06,000
非常

3652
01:46:06,000 --> 01:46:07,000
非常深的一个

3653
01:46:08,000 --> 01:46:09,000
对对对

3654
01:46:09,000 --> 01:46:10,000
所以呢就刚才说

3655
01:46:10,000 --> 01:46:11,000
一般遇到乱码的问题的话

3656
01:46:11,000 --> 01:46:12,000
是编码层面的问题

3657
01:46:12,000 --> 01:46:13,000
而

3658
01:46:13,000 --> 01:46:14,000
像我刚才说了

3659
01:46:15,000 --> 01:46:16,000
在

3660
01:46:16,000 --> 01:46:18,000
日文的 Windows

3661
01:46:18,000 --> 01:46:20,000
拷贝到 Mac 上面

3662
01:46:20,000 --> 01:46:21,000
就会发现

3663
01:46:21,000 --> 01:46:22,000
那个字

3664
01:46:22,000 --> 01:46:23,000
被拆开来了

3665
01:46:23,000 --> 01:46:24,000
就会有这样的问题

3666
01:46:24,000 --> 01:46:25,000
就会变成一个字

3667
01:46:25,000 --> 01:46:26,000
它变成两个字了是吧

3668
01:46:26,000 --> 01:46:27,000
两个字了对对对

3669
01:46:27,000 --> 01:46:29,000
就是你看的也是两个字了

3670
01:46:29,000 --> 01:46:31,000
你看的已经是两个字

3671
01:46:31,000 --> 01:46:32,000
就是嗯

3672
01:46:32,000 --> 01:46:33,000
就会

3673
01:46:33,000 --> 01:46:34,000
就完全会被拆开来

3674
01:46:34,000 --> 01:46:36,000
就是因为它

3675
01:46:36,000 --> 01:46:37,000
已经

3676
01:46:37,000 --> 01:46:38,000
它从

3677
01:46:38,000 --> 01:46:39,000
就透到那个

3678
01:46:39,000 --> 01:46:41,000
操作系统层面上来

3679
01:46:41,000 --> 01:46:42,000
就变成

3680
01:46:42,000 --> 01:46:43,000
OK 就又会已经感受到

3681
01:46:43,000 --> 01:46:44,000
因为系统不一样

3682
01:46:44,000 --> 01:46:45,000
那这个时候你们怎么办呢

3683
01:46:46,000 --> 01:46:47,000
没办法呀

3684
01:46:47,000 --> 01:46:49,000
就自己在重新点击这样的证明

3685
01:46:49,000 --> 01:46:50,000
我们见面

3686
01:46:50,000 --> 01:46:51,000
对呀

3687
01:46:51,000 --> 01:46:52,000
但其实这个

3688
01:46:53,000 --> 01:46:55,000
这件事情并不是发生在

3689
01:46:56,000 --> 01:46:57,000
Normalization

3690
01:46:58,000 --> 01:46:59,000
的这个过程中我觉得

3691
01:46:59,000 --> 01:47:00,000
对没错

3692
01:47:00,000 --> 01:47:01,000
这不是整个过程的

3693
01:47:01,000 --> 01:47:02,000
嗯

3694
01:47:02,000 --> 01:47:03,000
但是毕竟是因为

3695
01:47:03,000 --> 01:47:04,000
Normalization

3696
01:47:04,000 --> 01:47:05,000
它的采取的

3697
01:47:05,000 --> 01:47:07,000
原则方式不一样

3698
01:47:07,000 --> 01:47:08,000
然后最后呢

3699
01:47:08,000 --> 01:47:09,000
而且

3700
01:47:09,000 --> 01:47:10,000
原来

3701
01:47:10,000 --> 01:47:11,000
刚才也说了嘛

3702
01:47:11,000 --> 01:47:12,000
Normalization

3703
01:47:12,000 --> 01:47:14,000
它其实是不会被用户所知道的嘛

3704
01:47:14,000 --> 01:47:15,000
嗯

3705
01:47:15,000 --> 01:47:16,000
就其实它是这样的嘛

3706
01:47:16,000 --> 01:47:17,000
就说说明

3707
01:47:17,000 --> 01:47:18,000
Windows 的某一个用户

3708
01:47:18,000 --> 01:47:20,000
它在输入这个文件名的时候

3709
01:47:20,000 --> 01:47:21,000
它输入的那一串字符

3710
01:47:21,000 --> 01:47:22,000
其实就是一个

3711
01:47:22,000 --> 01:47:24,000
被拆解的形式

3712
01:47:24,000 --> 01:47:25,000
然后呢

3713
01:47:25,000 --> 01:47:26,000
它就被 Windows 的这个

3714
01:47:26,000 --> 01:47:27,000
操作系统记录下来

3715
01:47:27,000 --> 01:47:28,000
并且保存下来

3716
01:47:28,000 --> 01:47:29,000
那么它传到这个

3717
01:47:30,000 --> 01:47:31,000
OS 10 上的时候

3718
01:47:31,000 --> 01:47:32,000
OS 10 就觉得

3719
01:47:32,000 --> 01:47:34,000
哎这里其实是两个字符

3720
01:47:34,000 --> 01:47:35,000
那么我就把它们分开

3721
01:47:35,000 --> 01:47:36,000
进行一个操作

3722
01:47:36,000 --> 01:47:37,000
比如说

3723
01:47:37,000 --> 01:47:38,000
删除的时候

3724
01:47:38,000 --> 01:47:40,000
删除其中的一半对吧

3725
01:47:40,000 --> 01:47:41,000
嗯

3726
01:47:41,000 --> 01:47:42,000
对

3727
01:47:42,000 --> 01:47:43,000
但是其实

3728
01:47:43,000 --> 01:47:44,000
两个操作系统之间

3729
01:47:44,000 --> 01:47:46,000
这里反而体现了 Normalization 的一个

3730
01:47:46,000 --> 01:47:47,000
好处吧

3731
01:47:47,000 --> 01:47:49,000
就虽然它可能

3732
01:47:49,000 --> 01:47:50,000
输入的这个字符删

3733
01:47:50,000 --> 01:47:51,000
行为是不一样的

3734
01:47:51,000 --> 01:47:53,000
但是至少我们在看的时候

3735
01:47:53,000 --> 01:47:54,000
看起来它们是一样的

3736
01:47:54,000 --> 01:47:55,000
并且我们搜索的时候

3737
01:47:55,000 --> 01:47:56,000
也能搜索到

3738
01:47:56,000 --> 01:47:58,000
我觉得这个时候

3739
01:47:58,000 --> 01:47:59,000
反而是 Normalization

3740
01:47:59,000 --> 01:48:01,000
起到了一个保护的作用

3741
01:48:01,000 --> 01:48:02,000
就是

3742
01:48:02,000 --> 01:48:04,000
它没有让整个文件名

3743
01:48:04,000 --> 01:48:05,000
变得不兼容

3744
01:48:05,000 --> 01:48:06,000
而

3745
01:48:06,000 --> 01:48:07,000
还起到了一定的

3746
01:48:07,000 --> 01:48:08,000
最基本的兼容

3747
01:48:09,000 --> 01:48:10,000
嗯哼

3748
01:48:10,000 --> 01:48:12,000
所以 Normalization 是必要的

3749
01:48:12,000 --> 01:48:13,000
就是

3750
01:48:13,000 --> 01:48:14,000
哎

3751
01:48:14,000 --> 01:48:15,000
那我问

3752
01:48:15,000 --> 01:48:16,000
其实你们知道这个

3753
01:48:16,000 --> 01:48:17,000
中国用户

3754
01:48:17,000 --> 01:48:18,000
怎么解决这个问题吗

3755
01:48:20,000 --> 01:48:21,000
中国用户其实遇到的

3756
01:48:21,000 --> 01:48:22,000
不算太多吧

3757
01:48:22,000 --> 01:48:23,000
多吗

3758
01:48:23,000 --> 01:48:24,000
对啊

3759
01:48:24,000 --> 01:48:25,000
就为了

3760
01:48:25,000 --> 01:48:26,000
为了

3761
01:48:26,000 --> 01:48:27,000
就要避免在那个文件里面

3762
01:48:27,000 --> 01:48:28,000
使用中文嘛

3763
01:48:28,000 --> 01:48:29,000
那就用拼音的

3764
01:48:29,000 --> 01:48:30,000
所字母代替就好

3765
01:48:30,000 --> 01:48:31,000
啊

3766
01:48:31,000 --> 01:48:32,000
很多人

3767
01:48:32,000 --> 01:48:33,000
很多人这么干的嘛

3768
01:48:33,000 --> 01:48:34,000
好吧

3769
01:48:34,000 --> 01:48:35,000
但其实这个完全是为了

3770
01:48:35,000 --> 01:48:37,000
避免编买的问题吧

3771
01:48:38,000 --> 01:48:39,000
呃

3772
01:48:39,000 --> 01:48:40,000
这也为了就

3773
01:48:40,000 --> 01:48:41,000
打字比较简单嘛

3774
01:48:41,000 --> 01:48:42,000
从拼音的造造

3775
01:48:42,000 --> 01:48:43,000
造字

3776
01:48:43,000 --> 01:48:44,000
相对来说方便一些嘛

3777
01:48:44,000 --> 01:48:45,000
所以我不知道

3778
01:48:45,000 --> 01:48:46,000
这个 Eric

3779
01:48:46,000 --> 01:48:47,000
你可能比较熟悉点

3780
01:48:47,000 --> 01:48:48,000
就是在日文用户里面

3781
01:48:48,000 --> 01:48:50,000
会有很多人用日文

3782
01:48:50,000 --> 01:48:51,000
去命名那个文件名吧

3783
01:48:52,000 --> 01:48:53,000
对啊那肯定啊

3784
01:48:53,000 --> 01:48:54,000
嗯

3785
01:48:54,000 --> 01:48:55,000
OK

3786
01:48:55,000 --> 01:48:56,000
我其实经常遇到一个问题

3787
01:48:56,000 --> 01:48:58,000
比如说我看一个英文的文档

3788
01:48:58,000 --> 01:48:59,000
然后这个文档

3789
01:48:59,000 --> 01:49:00,000
可能是

3790
01:49:00,000 --> 01:49:01,000
排版的比较精细的

3791
01:49:01,000 --> 01:49:02,000
它里面有些单词

3792
01:49:02,000 --> 01:49:04,000
就会出现合字

3793
01:49:04,000 --> 01:49:05,000
对

3794
01:49:05,000 --> 01:49:06,000
A 5 合字搜不到

3795
01:49:06,000 --> 01:49:07,000
对了

3796
01:49:07,000 --> 01:49:08,000
这个时候我用那个

3797
01:49:08,000 --> 01:49:09,000
系统的自带的那个

3798
01:49:09,000 --> 01:49:10,000
比如说

3799
01:49:10,000 --> 01:49:11,000
三指双击

3800
01:49:11,000 --> 01:49:12,000
可以耻辞

3801
01:49:12,000 --> 01:49:13,000
查字点嘛

3802
01:49:13,000 --> 01:49:14,000
这个时候它查到那个字

3803
01:49:14,000 --> 01:49:15,000
它就会识别不了

3804
01:49:15,000 --> 01:49:16,000
因为它里面带了一个合字

3805
01:49:16,000 --> 01:49:18,000
我觉得这方面好像

3806
01:49:18,000 --> 01:49:19,000
至少我现在用的这个

3807
01:49:19,000 --> 01:49:20,000
CRO 还

3808
01:49:20,000 --> 01:49:21,000
还处理的不是很好

3809
01:49:21,000 --> 01:49:22,000
这 PDF

3810
01:49:22,000 --> 01:49:23,000
会有这个问题吗

3811
01:49:23,000 --> 01:49:24,000
主要是

3812
01:49:24,000 --> 01:49:25,000
对了就 Preview 这个 App

3813
01:49:25,000 --> 01:49:26,000
它在这方面的处理

3814
01:49:26,000 --> 01:49:27,000
我觉得还不是特别的完善

3815
01:49:27,000 --> 01:49:28,000
它其实理论上

3816
01:49:28,000 --> 01:49:29,000
它应该是帮你做好

3817
01:49:29,000 --> 01:49:32,000
Nomalization 再次查字点

3818
01:49:32,000 --> 01:49:33,000
这里面跟那个

3819
01:49:33,000 --> 01:49:35,000
PDF 生成好像还有什么关系

3820
01:49:35,000 --> 01:49:36,000
对

3821
01:49:36,000 --> 01:49:37,000
这个比较复杂

3822
01:49:37,000 --> 01:49:41,000
这不完全是 Preview 的错

3823
01:49:41,000 --> 01:49:42,000
对

3824
01:49:42,000 --> 01:49:43,000
跟 PDF 规范有一定关系

3825
01:49:43,000 --> 01:49:44,000
对

3826
01:49:44,000 --> 01:49:45,000
跟 PDF 有关系

3827
01:49:45,000 --> 01:49:46,000
而且是

3828
01:49:46,000 --> 01:49:47,000
对没错

3829
01:49:47,000 --> 01:49:48,000
是的

3830
01:49:48,000 --> 01:49:49,000
但其实如果它

3831
01:49:49,000 --> 01:49:52,000
它用这个兼容方式的 Nomalization

3832
01:49:52,000 --> 01:49:53,000
它处理的特别好的话

3833
01:49:53,000 --> 01:49:55,000
它其实可以绕开这个问题

3834
01:49:55,000 --> 01:49:59,000
它其实没有做这个兼容处理

3835
01:49:59,000 --> 01:50:01,000
它只是做了一个标准处理

3836
01:50:01,000 --> 01:50:02,000
可能

3837
01:50:02,000 --> 01:50:03,000
但基本上如果你在

3838
01:50:03,000 --> 01:50:04,000
网页上的话

3839
01:50:04,000 --> 01:50:05,000
它应该还是可以

3840
01:50:05,000 --> 01:50:06,000
证确识别出来吧

3841
01:50:06,000 --> 01:50:07,000
不一定

3842
01:50:07,000 --> 01:50:08,000
我觉得还真不一定

3843
01:50:08,000 --> 01:50:09,000
不一定

3844
01:50:09,000 --> 01:50:10,000
不一定

3845
01:50:10,000 --> 01:50:11,000
因为网页上很多时候

3846
01:50:11,000 --> 01:50:13,000
你看到这个 Legature

3847
01:50:13,000 --> 01:50:14,000
可能它并不是一个

3848
01:50:14,000 --> 01:50:16,000
真正的 Unical 的 Legature

3849
01:50:16,000 --> 01:50:17,000
它可能只是一个

3850
01:50:17,000 --> 01:50:20,000
Font 来显示出来的 Legature

3851
01:50:20,000 --> 01:50:22,000
可能用户输的都是单独的自符

3852
01:50:22,000 --> 01:50:25,000
所以你不太会遇到这问题

3853
01:50:25,000 --> 01:50:27,000
所以说这是你看到的东西

3854
01:50:27,000 --> 01:50:30,000
其实有一个很多层面的东西

3855
01:50:30,000 --> 01:50:32,000
你看到是一个字

3856
01:50:32,000 --> 01:50:33,000
它可能是两个字

3857
01:50:33,000 --> 01:50:35,000
但是变成一个字的时候

3858
01:50:35,000 --> 01:50:36,000
可能是系统把你进去

3859
01:50:36,000 --> 01:50:38,000
但是它可能是一个字

3860
01:50:38,000 --> 01:50:39,000
可能是系统把你做的

3861
01:50:39,000 --> 01:50:41,000
可能是 Application 把你做

3862
01:50:41,000 --> 01:50:43,000
那也可能是 Font 把你做的

3863
01:50:43,000 --> 01:50:45,000
就中间隔了好多道

3864
01:50:45,000 --> 01:50:46,000
对了

3865
01:50:46,000 --> 01:50:48,000
所以人类为什么要给自己

3866
01:50:48,000 --> 01:50:49,000
找这么多麻烦

3867
01:50:51,000 --> 01:50:52,000
其实说实话

3868
01:50:52,000 --> 01:50:53,000
如果不 Unicode 的话

3869
01:50:53,000 --> 01:50:54,000
就各自做各的

3870
01:50:54,000 --> 01:50:56,000
就不会有这么多问题

3871
01:50:56,000 --> 01:50:57,000
但是就会有各种

3872
01:50:57,000 --> 01:50:59,000
好多好多套规凿

3873
01:51:02,000 --> 01:51:04,000
所以 Unicode 对呀

3874
01:51:04,000 --> 01:51:06,000
就一个大融入

3875
01:51:06,000 --> 01:51:07,000
什么东西都有

3876
01:51:07,000 --> 01:51:08,000
就会发生

3877
01:51:08,000 --> 01:51:10,000
以前不曾出现过的问题

3878
01:51:10,000 --> 01:51:11,000
知道吗

3879
01:51:11,000 --> 01:51:12,000
不对

3880
01:51:12,000 --> 01:51:13,000
其实你各搞各的

3881
01:51:13,000 --> 01:51:14,000
也会出现这个问题

3882
01:51:14,000 --> 01:51:15,000
你还是要考虑

3883
01:51:15,000 --> 01:51:16,000
比如说你搜索的时候

3884
01:51:16,000 --> 01:51:17,000
你要考虑

3885
01:51:17,000 --> 01:51:18,000
就兼任我的问题

3886
01:51:18,000 --> 01:51:19,000
无非就是说

3887
01:51:19,000 --> 01:51:21,000
有各个应用程序自己去搞

3888
01:51:21,000 --> 01:51:23,000
还是说交给 Unicode 组织

3889
01:51:23,000 --> 01:51:24,000
统一搞一套

3890
01:51:24,000 --> 01:51:26,000
大家都遵守这个标准来搞

3891
01:51:26,000 --> 01:51:27,000
就好了

3892
01:51:27,000 --> 01:51:28,000
虽然很复杂

3893
01:51:28,000 --> 01:51:30,000
可能各搞各的问题更多

3894
01:51:30,000 --> 01:51:32,000
可能搜索搜不到

3895
01:51:32,000 --> 01:51:33,000
对

3896
01:51:33,000 --> 01:51:34,000
一个汉字

3897
01:51:34,000 --> 01:51:35,000
可能在 Big 5 里

3898
01:51:35,000 --> 01:51:36,000
和在 GB 里面

3899
01:51:36,000 --> 01:51:37,000
搜都搜不到

3900
01:51:39,000 --> 01:51:40,000
但是还好人类

3901
01:51:40,000 --> 01:51:42,000
在这一个时机的话

3902
01:51:42,000 --> 01:51:44,000
发现必须要做 Unicode

3903
01:51:44,000 --> 01:51:45,000
现在大家走上了

3904
01:51:45,000 --> 01:51:46,000
Unicode 的阳光大道了

3905
01:51:46,000 --> 01:51:48,000
才发现还要做

3906
01:51:48,000 --> 01:51:50,000
很多很多的相后兼容

3907
01:51:52,000 --> 01:51:53,000
但非常不幸的是

3908
01:51:53,000 --> 01:51:55,000
还有很多国内的网站

3909
01:51:55,000 --> 01:51:56,000
还是用 GB

3910
01:51:56,000 --> 01:51:57,000
2312 的

3911
01:51:58,000 --> 01:52:00,000
台湾有很多

3912
01:52:00,000 --> 01:52:01,000
就再用 Big 5

3913
01:52:01,000 --> 01:52:03,000
然后可能打开

3914
01:52:03,000 --> 01:52:04,000
就会变成乱

3915
01:52:05,000 --> 01:52:06,000
对对对

3916
01:52:06,000 --> 01:52:08,000
声明又很不正确的

3917
01:52:08,000 --> 01:52:09,000
对吧

3918
01:52:09,000 --> 01:52:10,000
HTML 声明

3919
01:52:11,000 --> 01:52:12,000
对我记得台湾教育部

3920
01:52:12,000 --> 01:52:13,000
好像还有一个网站

3921
01:52:13,000 --> 01:52:14,000
是用 Big 5

3922
01:52:14,000 --> 01:52:15,000
然后他网页

3923
01:52:15,000 --> 01:52:16,000
不知道是出什么问题

3924
01:52:16,000 --> 01:52:18,000
因为 Sepharia 打开资本

3925
01:52:18,000 --> 01:52:19,000
都会是乱

3926
01:52:19,000 --> 01:52:20,000
就默认就是乱的

3927
01:52:20,000 --> 01:52:21,000
对

3928
01:52:21,000 --> 01:52:23,000
你要用手段去挑

3929
01:52:24,000 --> 01:52:25,000
对对

3930
01:52:25,000 --> 01:52:26,000
Ulan 7 的

3931
01:52:26,000 --> 01:52:28,000
起发式判断的方法

3932
01:52:28,000 --> 01:52:29,000
都已经失效了

3933
01:52:30,000 --> 01:52:31,000
特别坑

3934
01:52:32,000 --> 01:52:33,000
好吧

3935
01:52:33,000 --> 01:52:35,000
今天差不多讲到这里了

3936
01:52:35,000 --> 01:52:36,000
我其实想

3937
01:52:36,000 --> 01:52:38,000
经通过这样一个节目

3938
01:52:38,000 --> 01:52:40,000
就是告诉我们的听众朋友

3939
01:52:40,000 --> 01:52:41,000
就是说

3940
01:52:41,000 --> 01:52:42,000
平时大家说 UniCode

3941
01:52:42,000 --> 01:52:43,000
感觉就是

3942
01:52:43,000 --> 01:52:44,000
就编码

3943
01:52:44,000 --> 01:52:45,000
对吧

3944
01:52:45,000 --> 01:52:46,000
就是马位

3945
01:52:46,000 --> 01:52:47,000
什么这些东西

3946
01:52:47,000 --> 01:52:48,000
其实 UniCode

3947
01:52:48,000 --> 01:52:49,000
除了

3948
01:52:49,000 --> 01:52:51,000
就给自服编码的以外

3949
01:52:51,000 --> 01:52:52,000
他还有很多

3950
01:52:52,000 --> 01:52:53,000
就是在 UniCode

3951
01:52:53,000 --> 01:52:55,000
这个叫 StandAnexus

3952
01:52:55,000 --> 01:52:57,000
就是他就标准的

3953
01:52:57,000 --> 01:52:58,000
附路

3954
01:52:58,000 --> 01:52:59,000
然后这附路里面

3955
01:52:59,000 --> 01:53:00,000
其实有很多

3956
01:53:00,000 --> 01:53:02,000
就是文字

3957
01:53:02,000 --> 01:53:05,000
处理方面的一些技术信息

3958
01:53:05,000 --> 01:53:06,000
比如说像今天

3959
01:53:06,000 --> 01:53:08,000
我们说的 Normalization

3960
01:53:08,000 --> 01:53:09,000
其实这是一个很复杂的

3961
01:53:09,000 --> 01:53:10,000
一个技术

3962
01:53:10,000 --> 01:53:11,000
环节的问题

3963
01:53:11,000 --> 01:53:13,000
这其实也是 UniCode

3964
01:53:13,000 --> 01:53:15,000
标准的其中之一

3965
01:53:15,000 --> 01:53:16,000
而且对作为 UniCode

3966
01:53:16,000 --> 01:53:17,000
它是必要的

3967
01:53:18,000 --> 01:53:19,000
然后像比如说

3968
01:53:19,000 --> 01:53:21,000
我们上次在节目也提到

3969
01:53:21,000 --> 01:53:23,000
就比如这次 10.0 里面

3970
01:53:23,000 --> 01:53:25,000
增加了一个 UniCode

3971
01:53:25,000 --> 01:53:26,000
标准附路

3972
01:53:26,000 --> 01:53:28,000
就是 UniCode 的数排文本

3973
01:53:28,000 --> 01:53:30,000
这其实也是必要的

3974
01:53:30,000 --> 01:53:32,000
就是说在横排和数排之间

3975
01:53:32,000 --> 01:53:34,000
是有什么样的关系

3976
01:53:34,000 --> 01:53:36,000
要给它提升到这样一个

3977
01:53:36,000 --> 01:53:38,000
标准附路里面的话

3978
01:53:38,000 --> 01:53:40,000
能给这个

3979
01:53:40,000 --> 01:53:42,000
它首先有个 Core Specification

3980
01:53:42,000 --> 01:53:46,000
这核心的标准的一个规范文

3981
01:53:46,000 --> 01:53:49,000
然后还周边有这么多标准的附路

3982
01:53:49,000 --> 01:53:50,000
这样组合起来

3983
01:53:50,000 --> 01:53:53,000
才是一个整体的 UniCode

3984
01:53:53,000 --> 01:53:56,000
应该可以说是一个系统

3985
01:53:56,000 --> 01:53:57,000
对吧

3986
01:53:58,000 --> 01:54:01,000
其实我们在自弹自串的

3987
01:54:01,000 --> 01:54:02,000
这个专题里面

3988
01:54:02,000 --> 01:54:04,000
其实我们还可以再讲

3989
01:54:04,000 --> 01:54:06,000
很多很多关于这样的事情

3990
01:54:07,000 --> 01:54:09,000
关于 Normalization 的

3991
01:54:09,000 --> 01:54:10,000
应用层面的问题

3992
01:54:10,000 --> 01:54:12,000
就是第一个我想问的问题是

3993
01:54:12,000 --> 01:54:14,000
作为一个软件的开发者来说

3994
01:54:14,000 --> 01:54:17,000
它多大程度上会遇到说

3995
01:54:17,000 --> 01:54:19,000
我要去主动解决这个问题

3996
01:54:20,000 --> 01:54:22,000
Rio 你有没有遇到过

3997
01:54:22,000 --> 01:54:23,000
要去解决这个问题

3998
01:54:24,000 --> 01:54:25,000
比较少其实

3999
01:54:25,000 --> 01:54:26,000
因为特别是

4000
01:54:26,000 --> 01:54:27,000
特别操作系统

4001
01:54:27,000 --> 01:54:29,000
和它的系统库都提供了

4002
01:54:29,000 --> 01:54:31,000
这个标准的标准

4003
01:54:31,000 --> 01:54:33,000
给你去调用的时候

4004
01:54:33,000 --> 01:54:34,000
你肯定不要自己去搞

4005
01:54:34,000 --> 01:54:36,000
因为这样你自己去搞的话

4006
01:54:36,000 --> 01:54:38,000
有可能和系统的不接用

4007
01:54:38,000 --> 01:54:40,000
但是就有刚才提到的那个难题

4008
01:54:40,000 --> 01:54:42,000
比如说在 Macs 这种

4009
01:54:42,000 --> 01:54:44,000
比较特殊的系统上面

4010
01:54:44,000 --> 01:54:47,000
它有多套 API 的时候

4011
01:54:47,000 --> 01:54:49,000
你就比较尴尬了

4012
01:54:49,000 --> 01:54:52,000
因为它有 UniX 那套

4013
01:54:52,000 --> 01:54:53,000
比较底层的 API

4014
01:54:53,000 --> 01:54:55,000
和相对上 Foundation 的 API

4015
01:54:55,000 --> 01:54:57,000
那些比较高层的 API 的时候

4016
01:54:57,000 --> 01:54:58,000
那你怎么办

4017
01:54:58,000 --> 01:54:59,000
这个时候你可能要把这两个的

4018
01:54:59,000 --> 01:55:02,000
就是哪些是支持

4019
01:55:02,000 --> 01:55:06,000
什么样的 Nomalization 的规范的

4020
01:55:06,000 --> 01:55:07,000
可能搞清楚

4021
01:55:07,000 --> 01:55:08,000
然后具体说

4022
01:55:08,000 --> 01:55:09,000
怎么实现

4023
01:55:09,000 --> 01:55:11,000
其实你是不用去太多考虑的

4024
01:55:11,000 --> 01:55:12,000
反正那些都是有标准

4025
01:55:12,000 --> 01:55:14,000
还说去调用的

4026
01:55:14,000 --> 01:55:15,000
对

4027
01:55:15,000 --> 01:55:17,000
这个规范化的转换算法

4028
01:55:17,000 --> 01:55:18,000
其实已经有一些

4029
01:55:18,000 --> 01:55:20,000
非常标准的方式来实现了

4030
01:55:20,000 --> 01:55:22,000
为作为开发者

4031
01:55:22,000 --> 01:55:24,000
你需要的知道的就是说

4032
01:55:24,000 --> 01:55:25,000
你知道在什么时候

4033
01:55:25,000 --> 01:55:27,000
用什么样的 API 去调用

4034
01:55:27,000 --> 01:55:29,000
什么样的结果

4035
01:55:29,000 --> 01:55:32,000
这个是比较重要的

4036
01:55:32,000 --> 01:55:33,000
所以去查文档的话

4037
01:55:33,000 --> 01:55:35,000
其实跟他肯定也就是说

4038
01:55:35,000 --> 01:55:38,000
为了防止发生 Nomalization 错误的话

4039
01:55:38,000 --> 01:55:39,000
就是去调用

4040
01:55:39,000 --> 01:55:42,000
很官方的 API 就完了

4041
01:55:42,000 --> 01:55:43,000
对

4042
01:55:43,000 --> 01:55:44,000
另外还有个事情

4043
01:55:44,000 --> 01:55:46,000
跟我们今天讲的有点关系的是

4044
01:55:46,000 --> 01:55:50,000
Rio 上次提到的 IDM 的一个

4045
01:55:50,000 --> 01:55:52,000
伪装攻击的问题是吗

4046
01:55:52,000 --> 01:55:54,000
就一个网址的漏洞

4047
01:55:54,000 --> 01:55:56,000
Punicode 的问题

4048
01:55:56,000 --> 01:56:00,000
这个也是 Unicode 的一个坑板

4049
01:56:00,000 --> 01:56:03,000
我们可以作为这个节目的

4050
01:56:03,000 --> 01:56:05,000
事后的环节

4051
01:56:05,000 --> 01:56:07,000
顺便吐个小槽

4052
01:56:07,000 --> 01:56:10,000
我们现在知道很多网站

4053
01:56:10,000 --> 01:56:12,000
它有一种叫做钓鱼网站

4054
01:56:12,000 --> 01:56:13,000
它骗你

4055
01:56:13,000 --> 01:56:16,000
它说它是银行

4056
01:56:16,000 --> 01:56:17,000
你的银行的网站

4057
01:56:17,000 --> 01:56:19,000
然后让你输入你的卡号密码

4058
01:56:19,000 --> 01:56:21,000
然后你去转你的钱

4059
01:56:21,000 --> 01:56:23,000
但可能银行的例子不太好

4060
01:56:23,000 --> 01:56:25,000
现在银行都有两部认证了

4061
01:56:25,000 --> 01:56:27,000
可能也不太那么容易去做

4062
01:56:27,000 --> 01:56:29,000
但是逻辑是这样的

4063
01:56:29,000 --> 01:56:31,000
我们传统的在浏览期里面

4064
01:56:31,000 --> 01:56:33,000
去判定一个网站

4065
01:56:33,000 --> 01:56:35,000
是不是你访问的那个网站的时候

4066
01:56:35,000 --> 01:56:37,000
你是看它的域名吗

4067
01:56:37,000 --> 01:56:41,000
域名其实就是一个自付串过程的东西

4068
01:56:41,000 --> 01:56:44,000
那坑就坑在于

4069
01:56:44,000 --> 01:56:46,000
因为 Unicode 里面

4070
01:56:46,000 --> 01:56:48,000
这也不是 Unicode 的坑

4071
01:56:48,000 --> 01:56:50,000
这是人类的问题吧

4072
01:56:50,000 --> 01:56:53,000
在某一些不同的语言里面

4073
01:56:53,000 --> 01:56:55,000
它的两个完全不同的自付

4074
01:56:55,000 --> 01:56:57,000
它看起来是一模一样的

4075
01:56:58,000 --> 01:57:02,000
比如说英文的第一个字母叫 A

4076
01:57:02,000 --> 01:57:05,000
但是希腊文的第一个字母叫 Alpha

4077
01:57:05,000 --> 01:57:08,000
但是两个大写字母长得一模一样

4078
01:57:08,000 --> 01:57:11,000
在过去不存在这个问题

4079
01:57:11,000 --> 01:57:12,000
因为在过去的话

4080
01:57:12,000 --> 01:57:14,000
域名系系统其实是一个非常简单的系统

4081
01:57:14,000 --> 01:57:16,000
它就只有 Askit

4082
01:57:16,000 --> 01:57:19,000
我们讲域名那个部分

4083
01:57:19,000 --> 01:57:21,000
只能用哪几个自付

4084
01:57:21,000 --> 01:57:24,000
26 个英文字母不去分大小写

4085
01:57:24,000 --> 01:57:26,000
10 个阿拉伯数字

4086
01:57:26,000 --> 01:57:29,000
然后再加一个短痕线

4087
01:57:29,000 --> 01:57:32,000
然后这个点肯定没得说了

4088
01:57:32,000 --> 01:57:35,000
A 点 B 这个是可以知道的

4089
01:57:35,000 --> 01:57:41,000
然后后来为了支持所谓的多语言的域名

4090
01:57:41,000 --> 01:57:43,000
我们中国人之前搞过

4091
01:57:43,000 --> 01:57:45,000
CNSE 搞过所谓的中文域名

4092
01:57:45,000 --> 01:57:46,000
对不对

4093
01:57:46,000 --> 01:57:47,000
汉字域名

4094
01:57:47,000 --> 01:57:49,000
对 汉字域名什么什么点中国

4095
01:57:49,000 --> 01:57:50,000
很傻的

4096
01:57:50,000 --> 01:57:53,000
之前应该是 90 年代末的时候

4097
01:57:53,000 --> 01:57:54,000
流行过这段时间

4098
01:57:54,000 --> 01:57:56,000
然后之后就是谢天谢地

4099
01:57:56,000 --> 01:57:57,000
终于没有流行起来

4100
01:57:59,000 --> 01:58:01,000
然后刚才讲的希腊文的 A

4101
01:58:01,000 --> 01:58:02,000
和英文的 A 就有问题

4102
01:58:02,000 --> 01:58:03,000
比如说你都想访问

4103
01:58:03,000 --> 01:58:04,000
Apple.com

4104
01:58:04,000 --> 01:58:05,000
就苹果的官网

4105
01:58:05,000 --> 01:58:07,000
你看的是 Apple.com

4106
01:58:07,000 --> 01:58:10,000
但其实人家把 A 给换成的希腊语的 A

4107
01:58:10,000 --> 01:58:12,000
你看起来也是 Apple.com

4108
01:58:12,000 --> 01:58:14,000
这次访问的是一个完全不同的网站

4109
01:58:14,000 --> 01:58:15,000
这个时候

4110
01:58:15,000 --> 01:58:18,000
这个假的 Apple.com 网站

4111
01:58:18,000 --> 01:58:21,000
让你输入你的 iCloud 的账号密码

4112
01:58:21,000 --> 01:58:22,000
你输不输呢

4113
01:58:25,000 --> 01:58:26,000
对吧

4114
01:58:26,000 --> 01:58:27,000
所以我觉得

4115
01:58:27,000 --> 01:58:33,000
就是在域名比较关乎安全的这种领域里面

4116
01:58:33,000 --> 01:58:37,000
我其实挺反对去加入这种多语言支持的

4117
01:58:37,000 --> 01:58:38,000
虽然说听起来政治不正确

4118
01:58:38,000 --> 01:58:41,000
凭什么域名一定要是一个英文的东西

4119
01:58:41,000 --> 01:58:42,000
或者说

4120
01:58:42,000 --> 01:58:43,000
对吧

4121
01:58:43,000 --> 01:58:44,000
或者说

4122
01:58:45,000 --> 01:58:47,000
其实也你去拉低文的东西吧

4123
01:58:47,000 --> 01:58:49,000
为什么韩国人不能用韩语作域名

4124
01:58:49,000 --> 01:58:50,000
中国人不能用作域名

4125
01:58:50,000 --> 01:58:52,000
日本人不能用日语作域名

4126
01:58:52,000 --> 01:58:54,000
但是你用了之后就会出现这种

4127
01:58:54,000 --> 01:58:56,000
不可知的结果

4128
01:58:56,000 --> 01:58:58,000
这个时候就比较尴尬了

4129
01:59:01,000 --> 01:59:02,000
另外我还有个问题

4130
01:59:02,000 --> 01:59:03,000
其实就是

4131
01:59:03,000 --> 01:59:07,000
如果我们输入两个在这个

4132
01:59:07,000 --> 01:59:10,000
标准化之后是相等的

4133
01:59:10,000 --> 01:59:11,000
Unicode 自服创

4134
01:59:11,000 --> 01:59:14,000
那么瀏覽器会认为他们是同一个域名吗

4135
01:59:15,000 --> 01:59:17,000
但是他们实际上是不一样的

4136
01:59:19,000 --> 01:59:21,000
这里面好像那个域名有一个

4137
01:59:21,000 --> 01:59:23,000
Punicode 它是有一个规范的

4138
01:59:23,000 --> 01:59:26,000
但是这里要扯一个很很很坑爹的事情

4139
01:59:26,000 --> 01:59:28,000
Punicode 规范是找 Unicode 的

4140
01:59:29,000 --> 01:59:30,000
是的

4141
01:59:31,000 --> 01:59:32,000
这会有一个

4142
01:59:32,000 --> 01:59:33,000
所以它转换的问题

4143
01:59:34,000 --> 01:59:36,000
对 所以比如说我们刚才我们刚来说

4144
01:59:36,000 --> 01:59:37,000
比如说有一些字母

4145
01:59:37,000 --> 01:59:38,000
比如说像 Omega

4146
01:59:38,000 --> 01:59:40,000
它就是两个完全一模一样的自服

4147
01:59:41,000 --> 01:59:42,000
在形式上在

4148
01:59:43,000 --> 01:59:44,000
这个语异的来源上也是一样

4149
01:59:45,000 --> 01:59:47,000
但它就是分裂成两个自服

4150
01:59:47,000 --> 01:59:49,000
一个是用来表示物理单位的

4151
01:59:49,000 --> 01:59:51,000
一个是 Omega 自服本身

4152
01:59:52,000 --> 01:59:53,000
对 我没有去查过

4153
01:59:53,000 --> 01:59:55,000
但是照我的理解

4154
01:59:55,000 --> 01:59:58,000
应该是要先做 Unicode 规范化

4155
01:59:58,000 --> 02:00:00,000
然后再转成 Punicode

4156
02:00:00,000 --> 02:00:02,000
才能拿到最终的一个结果

4157
02:00:02,000 --> 02:00:06,000
这个时候应该是一个唯一的一个解

4158
02:00:06,000 --> 02:00:07,000
但我不认识

4159
02:00:07,000 --> 02:00:08,000
他们其实应该是一样的

4160
02:00:08,000 --> 02:00:10,000
我的理解应该是一样的

4161
02:00:10,000 --> 02:00:12,000
不然的话就会出现刚才我说的另外一个问题

4162
02:00:12,000 --> 02:00:15,000
你看见的两个完全一模一样的

4163
02:00:15,000 --> 02:00:17,000
而且你用 Unicode 的看法是一模一样的

4164
02:00:17,000 --> 02:00:19,000
或者 Unicode 都是等价的两个域名

4165
02:00:19,000 --> 02:00:21,000
但是它其实反而两个不同的网站

4166
02:00:21,000 --> 02:00:23,000
这个时候你就非常坑爹了 对不对

4167
02:00:25,000 --> 02:00:28,000
当然这个事情可能

4168
02:00:28,000 --> 02:00:31,000
可能也会越来越不是一个适当的

4169
02:00:31,000 --> 02:00:33,000
其实我们现在看很多移动网站上

4170
02:00:33,000 --> 02:00:35,000
你根本就不知道网址是什么的 对不对

4171
02:00:35,000 --> 02:00:38,000
比如说你在微信的流量器里面打开一个网站

4172
02:00:38,000 --> 02:00:41,000
你都看不见 UIL 了

4173
02:00:41,000 --> 02:00:44,000
对 所以最终你可能还是得靠一些证书之类的东西

4174
02:00:44,000 --> 02:00:47,000
就其他的一些工具来验证这个网站

4175
02:00:47,000 --> 02:00:49,000
是不是你想要放在那里

4176
02:00:49,000 --> 02:00:50,000
对呀

4177
02:00:50,000 --> 02:00:52,000
当然你会提

4178
02:00:52,000 --> 02:00:55,000
你认一个人总是不能看名字呀

4179
02:00:56,000 --> 02:00:58,000
这也就会变得另外一个很好玩的事情

4180
02:00:58,000 --> 02:01:00,000
跟以摩基有关了

4181
02:01:00,000 --> 02:01:03,000
就是之前前几天在推特上转发了一个事情

4182
02:01:04,000 --> 02:01:07,000
现在那个浏览器它不是前面靠地址的

4183
02:01:07,000 --> 02:01:10,000
左边有一个小锁的图标来表示

4184
02:01:10,000 --> 02:01:12,000
这是一个加密连接

4185
02:01:12,000 --> 02:01:15,000
对呀 然后你觉得很安全吗

4186
02:01:15,000 --> 02:01:18,000
你知道以摩基里面是有一个锁的图标的吗

4187
02:01:21,000 --> 02:01:27,000
然后有些顶级域民是支持以摩基域民的

4188
02:01:27,000 --> 02:01:30,000
就刚刚我们讲 Punichal 的域民之外

4189
02:01:30,000 --> 02:01:32,000
他还支持以摩基的域民

4190
02:01:32,000 --> 02:01:34,000
所以他自己画了一个

4191
02:01:34,000 --> 02:01:35,000
他做了一个

4192
02:01:35,000 --> 02:01:37,000
他的那个域民的第一个就是一个锁

4193
02:01:37,000 --> 02:01:38,000
你知道吗

4194
02:01:38,000 --> 02:01:39,000
然后后面假设

4195
02:01:39,000 --> 02:01:40,000
假设他是一个锁

4196
02:01:40,000 --> 02:01:43,000
然后 HTCPS

4197
02:01:43,000 --> 02:01:45,000
然后在两点写干写干

4198
02:01:45,000 --> 02:01:50,000
然后是那个希腊字母的 APPL.com

4199
02:01:50,000 --> 02:01:52,000
这个时候你敢不敢把玩这一课

4200
02:01:55,000 --> 02:01:58,000
对吧 所以我觉得就是

4201
02:01:58,000 --> 02:02:01,000
这怎么 这可能有点不太正确

4202
02:02:01,000 --> 02:02:04,000
但是我觉得这个事情是有所有所

4203
02:02:04,000 --> 02:02:06,000
有些事情你是不能做的

4204
02:02:06,000 --> 02:02:09,000
这样我就 你不能在域民里面去加以摩基

4205
02:02:09,000 --> 02:02:11,000
你不能在域民里面去加一个 unicode 的东西

4206
02:02:11,000 --> 02:02:14,000
这真的会把事情搞得无比复杂

4207
02:02:14,000 --> 02:02:16,000
就是本来大家只能考虑大家讲

4208
02:02:16,000 --> 02:02:19,000
26 个字母加 10 个数字

4209
02:02:19,000 --> 02:02:20,000
再加一个衡线

4210
02:02:20,000 --> 02:02:22,000
起来多少才 37 个对吧

4211
02:02:22,000 --> 02:02:26,000
的一个一个一个一个一个一个 spaced 的一个问题

4212
02:02:26,000 --> 02:02:29,000
现在突然你变成一个整个 unicode 的那个 spaced

4213
02:02:29,000 --> 02:02:32,000
那是多少倍的一个复杂度的扩张

4214
02:02:32,000 --> 02:02:34,000
对于用户的认知理解来说

4215
02:02:34,000 --> 02:02:36,000
你这没办法去做这个教育了

4216
02:02:38,000 --> 02:02:40,000
所以你看中国用户大家还是比较乖的

4217
02:02:40,000 --> 02:02:44,000
大家干了这种数字域民就不会圈中奇幻了对吧

4218
02:02:44,000 --> 02:02:47,000
163.0

4219
02:02:47,000 --> 02:02:49,000
数字应该不会有这个

4220
02:02:49,000 --> 02:02:50,000
长得一样的数字

4221
02:02:50,000 --> 02:02:52,000
但是不一样的点位吧

4222
02:02:54,000 --> 02:02:55,000
有

4223
02:02:55,000 --> 02:02:57,000
也有吗

4224
02:02:57,000 --> 02:03:00,000
数字的 nomerization 不是很多吗

4225
02:03:00,000 --> 02:03:01,000
天啊

4226
02:03:01,000 --> 02:03:05,000
对有那个什么半高的这种数字对不对

4227
02:03:05,000 --> 02:03:07,000
还有那个叫什么来的那个

4228
02:03:07,000 --> 02:03:09,000
另外罗马数

4229
02:03:09,000 --> 02:03:10,000
那是罗马数字吗

4230
02:03:10,000 --> 02:03:13,000
就是罗马数字也是有罗马数字自己的马位

4231
02:03:13,000 --> 02:03:14,000
也可以

4232
02:03:14,000 --> 02:03:16,000
对但我们一般都是用拉丁字母来写

4233
02:03:16,000 --> 02:03:18,000
他们就用什么 IV 之类的

4234
02:03:18,000 --> 02:03:21,000
所以我就觉得嘛就是有些事情

4235
02:03:21,000 --> 02:03:23,000
其实是都是一些政治的因素

4236
02:03:23,000 --> 02:03:25,000
让我们把那个事情变得非常复杂

4237
02:03:25,000 --> 02:03:27,000
本来技术是可以做的非常简单可靠

4238
02:03:27,000 --> 02:03:28,000
稳定的

4239
02:03:28,000 --> 02:03:30,000
但是一会过来一个 pm

4240
02:03:30,000 --> 02:03:32,000
一会过来一个 pm 都在提这个需求

4241
02:03:32,000 --> 02:03:34,000
这个时候你就爆炸了

4242
02:03:34,000 --> 02:03:35,000
对

4243
02:03:35,000 --> 02:03:38,000
其实说了这个 url 我想起来就是

4244
02:03:38,000 --> 02:03:42,000
其实 w 3 c 也是有一趟自己的这个 nomerization 的机制的

4245
02:03:45,000 --> 02:03:48,000
对就是当然他其实是基于用内扣的

4246
02:03:48,000 --> 02:03:51,000
就是他当然他首先推荐的是 nfc 的这种

4247
02:03:51,000 --> 02:03:54,000
标准化的形式规范化的形式

4248
02:03:54,000 --> 02:03:55,000
那么同时我们知道

4249
02:03:55,000 --> 02:03:58,000
因为 w 3 c 在网页上他其实有一个特殊的

4250
02:03:58,000 --> 02:04:01,000
字符串形式叫 character reference

4251
02:04:01,000 --> 02:04:05,000
就是有一个这个 absent 和警号键开头的

4252
02:04:05,000 --> 02:04:08,000
然后后面加一个数字的视列

4253
02:04:08,000 --> 02:04:10,000
然后加一个加一个分号这样一个

4254
02:04:10,000 --> 02:04:16,000
可以用来引用引用到任何一个 Unicolor 字符上的这样一个视列

4255
02:04:16,000 --> 02:04:19,000
那么这个视列如果你在网页上在 html 里面输入的话

4256
02:04:19,000 --> 02:04:24,000
它其实要被这个 nomerized 成为另外一个真正的

4257
02:04:24,000 --> 02:04:28,000
实义的字符的而不是直接保留这个东西

4258
02:04:28,000 --> 02:04:32,000
这个就其实是在 Unicolor 的基础上

4259
02:04:32,000 --> 02:04:34,000
扩展了一下应该说

4260
02:04:34,000 --> 02:04:36,000
那不就是那个 punicolor 的吗

4261
02:04:38,000 --> 02:04:39,000
可以这么说吧

4262
02:04:39,000 --> 02:04:42,000
机制是类似的可能是

4263
02:04:42,000 --> 02:04:44,000
但他们的表达形式不太一样

4264
02:04:45,000 --> 02:04:49,000
就是一个挺沉重的事情我觉得

4265
02:04:49,000 --> 02:04:53,000
就反正我在我的那个理解里面我是不介意

4266
02:04:53,000 --> 02:04:56,000
我是反对把一些

4267
02:04:56,000 --> 02:04:58,000
就是其实你说一定有那么强的必要

4268
02:04:58,000 --> 02:05:00,000
要用一个中文或者日本的语言吗

4269
02:05:00,000 --> 02:05:01,000
其实也没有对不对

4270
02:05:01,000 --> 02:05:02,000
大家不也过得很好吗

4271
02:05:02,000 --> 02:05:05,000
就为什么要人为把这个事情搞那么复杂

4272
02:05:08,000 --> 02:05:10,000
就是太多的 downside

4273
02:05:10,000 --> 02:05:12,000
没有很好的这个 upside

4274
02:05:13,000 --> 02:05:16,000
但是对于这个网页来说

4275
02:05:16,000 --> 02:05:17,000
其实它有这些失去了

4276
02:05:17,000 --> 02:05:19,000
比如你输入一些不可见字符的时候

4277
02:05:19,000 --> 02:05:21,000
你在 html 里面

4278
02:05:21,000 --> 02:05:23,000
你可能输入这个 characterreference

4279
02:05:23,000 --> 02:05:25,000
就变成可见了

4280
02:05:25,000 --> 02:05:26,000
那么对于程式来说

4281
02:05:26,000 --> 02:05:28,000
这个是比较友好的一种形式

4282
02:05:28,000 --> 02:05:30,000
不 我就说你不要在网页里面做

4283
02:05:30,000 --> 02:05:32,000
不要在那个那个

4284
02:05:32,000 --> 02:05:34,000
玉民和王子里面做这个事情吗

4285
02:05:34,000 --> 02:05:36,000
对对对 在玉民里面做的话

4286
02:05:36,000 --> 02:05:38,000
就是要得有所节制你知道吗

4287
02:05:38,000 --> 02:05:40,000
就是现在很多很多这个人

4288
02:05:40,000 --> 02:05:41,000
忍不住啊

4289
02:05:42,000 --> 02:05:44,000
对技术技术产品之所以如此复杂

4290
02:05:44,000 --> 02:05:47,000
就是因为上面提取的人就是

4291
02:05:47,000 --> 02:05:49,000
对吧

4292
02:05:50,000 --> 02:05:52,000
不考虑后果

4293
02:05:54,000 --> 02:05:55,000
好吧

4294
02:05:55,000 --> 02:05:58,000
今天我们就聊到这里

4295
02:05:58,000 --> 02:05:59,000
对

4296
02:06:03,000 --> 02:06:05,000
对了 我们这次要抽

4297
02:06:05,000 --> 02:06:07,000
我们这次就不抽奖了是吧

4298
02:06:07,000 --> 02:06:08,000
对对对

4299
02:06:08,000 --> 02:06:11,000
但是我们其实上一次抽奖的结果

4300
02:06:11,000 --> 02:06:12,000
已经出来了

4301
02:06:12,000 --> 02:06:14,000
但是有一位听众联系不到

4302
02:06:14,000 --> 02:06:16,000
所以其实那个

4303
02:06:16,000 --> 02:06:19,000
我们可以借这次节目先做一个这个通知吧

4304
02:06:19,000 --> 02:06:20,000
那你说吧

4305
02:06:20,000 --> 02:06:22,000
对 就是之前的那个

4306
02:06:22,000 --> 02:06:24,000
我们在第第

4307
02:06:24,000 --> 02:06:26,000
就上一次第五十一期吧

4308
02:06:26,000 --> 02:06:28,000
我们公布了一个抽奖的通知

4309
02:06:28,000 --> 02:06:29,000
然后呢

4310
02:06:29,000 --> 02:06:30,000
接下来的一周之后呢

4311
02:06:30,000 --> 02:06:33,000
我们这个抽奖的结果其实已经出来了

4312
02:06:33,000 --> 02:06:35,000
那么我们这次抽到的两位听众呢

4313
02:06:35,000 --> 02:06:37,000
都是来自支付宝娟的听众

4314
02:06:37,000 --> 02:06:39,000
第一位听众他的署名是灰

4315
02:06:39,000 --> 02:06:40,000
一个灰黄的灰

4316
02:06:40,000 --> 02:06:41,000
这个单字

4317
02:06:41,000 --> 02:06:43,000
第二位听众署名是 Furen

4318
02:06:43,000 --> 02:06:44,000
那第二位听众呢

4319
02:06:44,000 --> 02:06:45,000
我已经联系上他了

4320
02:06:45,000 --> 02:06:47,000
那么他应该也已经收到了我们的奖品

4321
02:06:47,000 --> 02:06:48,000
但是第一位听众

4322
02:06:48,000 --> 02:06:49,000
我没法联系到他

4323
02:06:49,000 --> 02:06:51,000
所以如果你听到这次节目呢

4324
02:06:51,000 --> 02:06:53,000
也可以直接给我们发邮件

4325
02:06:53,000 --> 02:06:55,000
发到 podcastatotheype.com

4326
02:06:55,000 --> 02:06:56,000
来跟我们联络

4327
02:06:56,000 --> 02:06:58,000
然后我们会跟你进一步沟通

4328
02:06:58,000 --> 02:07:00,000
然后把奖品发给你

4329
02:07:02,000 --> 02:07:04,000
好 感谢大家的捐赠

4330
02:07:04,000 --> 02:07:05,000
那别忘记了

4331
02:07:05,000 --> 02:07:06,000
可我们的联系的方法呢

4332
02:07:06,000 --> 02:07:08,000
是 podcastatotheype.com

4333
02:07:08,000 --> 02:07:11,000
有捐赠也就有机会参加我们的抽奖

4334
02:07:11,000 --> 02:07:13,000
我也今天

4335
02:07:13,000 --> 02:07:15,000
我给大家准备了新的礼物

4336
02:07:15,000 --> 02:07:17,000
我们下次再说吧 好吧

4337
02:07:18,000 --> 02:07:20,000
好 那感谢大家收听今天的节目

4338
02:07:20,000 --> 02:07:23,000
如果大家喜欢我们的节目的话

4339
02:07:23,000 --> 02:07:24,000
喜欢自弹自唱的话

4340
02:07:24,000 --> 02:07:25,000
就可以给我们捐赠

4341
02:07:25,000 --> 02:07:26,000
我们的捐赠渠道呢

4342
02:07:26,000 --> 02:07:28,000
跟我们的邮箱地址是一样的

4343
02:07:28,000 --> 02:07:31,000
都是 podcastatotheype.com

4344
02:07:31,000 --> 02:07:35,000
podcastatotheype.com

4345
02:07:35,000 --> 02:07:37,000
同时呢 大家也可以在社交网站上

4346
02:07:37,000 --> 02:07:39,000
关注我们在新浪微博

4347
02:07:39,000 --> 02:07:40,000
在推特

4348
02:07:40,000 --> 02:07:43,000
在微信上面

4349
02:07:43,000 --> 02:07:46,000
我们的 id 都是 thetype t-h-e-t-y-p-e

4350
02:07:46,000 --> 02:07:47,000
那么在 facebook 上

4351
02:07:47,000 --> 02:07:49,000
搜索 typeisbeautiful

4352
02:07:49,000 --> 02:07:50,000
也可以关注到我们

4353
02:07:50,000 --> 02:07:52,000
同时呢 我们在知乎专栏上

4354
02:07:52,000 --> 02:07:53,000
也会同步地发布

4355
02:07:53,000 --> 02:07:56,000
每一次节目的这个节目简介

4356
02:07:57,000 --> 02:07:58,000
同时呢 也欢迎大家关注

4357
02:07:58,000 --> 02:08:00,000
typeisbeautiful 的网站

4358
02:08:00,000 --> 02:08:02,000
typeisbeautiful.com

4359
02:08:03,000 --> 02:08:05,000
感谢收听 ipnpodcast

4360
02:08:05,000 --> 02:08:07,000
网络旗下的 it

4361
02:08:07,000 --> 02:08:08,000
就主题一个个节目

4362
02:08:08,000 --> 02:08:09,000
内核恐慌

4363
02:08:09,000 --> 02:08:10,000
我们号称 podcore

4364
02:08:10,000 --> 02:08:11,000
但是有干货

4365
02:08:11,000 --> 02:08:13,000
想听人听 想听人就别听

4366
02:08:13,000 --> 02:08:14,000
您可以为本节目捐赠款

4367
02:08:14,000 --> 02:08:15,000
地址是

4368
02:08:15,000 --> 02:08:17,000
carnopanic.fm.s-downate

4369
02:08:17,000 --> 02:08:18,000
捐款经纪处

4370
02:08:18,000 --> 02:08:19,000
只要是 BAR 的正式入备

4371
02:08:19,000 --> 02:08:20,000
就可以了

4372
02:08:20,000 --> 02:08:21,000
捐款不会给你赖什么

4373
02:08:21,000 --> 02:08:23,000
不捐也不会让你失去什么

4374
02:08:23,000 --> 02:08:24,000
我们的口号是

4375
02:08:24,000 --> 02:08:25,000
knowhardvillians

4376
02:08:25,000 --> 02:08:26,000
如果您有任何反馈

4377
02:08:26,000 --> 02:08:28,000
也可以发电子邮件到

4378
02:08:28,000 --> 02:08:32,000
carnopanic.ipn.li

4379
02:08:32,000 --> 02:08:33,000
同时也欢迎你

4380
02:08:33,000 --> 02:08:34,000
收听 real 主持的

4381
02:08:34,000 --> 02:08:35,000
缝头圈

4382
02:08:35,000 --> 02:08:37,000
缝头圈现在好像改成收费角度

4383
02:08:39,000 --> 02:08:40,000
对

4384
02:08:40,000 --> 02:08:41,000
ok 下一天旗下的

4385
02:08:41,000 --> 02:08:43,000
其他集档节目

4386
02:08:43,000 --> 02:08:44,000
未知到

4387
02:08:44,000 --> 02:08:45,000
太医来了

4388
02:08:45,000 --> 02:08:46,000
流行通信

4389
02:08:46,000 --> 02:08:47,000
hastory 印影下

4390
02:08:47,000 --> 02:08:48,000
无资源

4391
02:08:48,000 --> 02:08:49,000
博物质 悬美

4392
02:08:49,000 --> 02:08:50,000
必下关

4393
02:08:50,000 --> 02:08:51,000
一天世界 时尚怪物

4394
02:08:51,000 --> 02:08:52,000
我们下期节目再会

4395
02:08:52,000 --> 02:08:53,000
OK 拜拜

4396
02:08:53,000 --> 02:08:54,000
拜拜

4397
02:08:54,000 --> 02:08:55,000
拜拜

4398
02:09:03,000 --> 02:09:05,000
拜拜

