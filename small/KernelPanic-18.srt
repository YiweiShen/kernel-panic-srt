1
00:00:00,000 --> 00:00:06,000
您正在收听的是 IPN podcast 的网络旗下的 IT 技术主义节目内核恐慌

2
00:00:06,000 --> 00:00:09,000
我们号称 Hardcore 但是也没有干货

3
00:00:09,000 --> 00:00:11,000
想听的人听不想听的人就别听

4
00:00:11,000 --> 00:00:15,000
内核恐慌的网址是 kernopanik.fm

5
00:00:15,000 --> 00:00:20,000
我们推荐大家使用泛用型 podcast 客户端订阅我们的节目

6
00:00:20,000 --> 00:00:23,000
如果您不知道什么是客户端

7
00:00:23,000 --> 00:00:27,000
请访问 ipn.li-fac

8
00:00:27,000 --> 00:00:29,000
欢迎您为我们的节目捐款

9
00:00:29,000 --> 00:00:35,000
捐款地址是 ipn.li-kernopanik-donate

10
00:00:35,000 --> 00:00:37,000
捐款进行随意

11
00:00:37,000 --> 00:00:39,000
捐款不会为你带来什么

12
00:00:39,000 --> 00:00:41,000
不捐也不会让你失去什么

13
00:00:41,000 --> 00:00:46,000
OK 今天是我们的第 18 期节目

14
00:00:46,000 --> 00:00:49,000
不过 Rail 因为非常忙

15
00:00:49,000 --> 00:00:51,000
不能参加本期节目的录音了

16
00:00:51,000 --> 00:00:55,000
不过它一定会参加明天的 IT 公的录音

17
00:00:55,000 --> 00:00:56,000
所以各位

18
00:00:56,000 --> 00:01:00,000
尤其是会员们可以送一口气

19
00:01:00,000 --> 00:01:07,000
另外单纯因为迷恋 Rail 的声音的朋友

20
00:01:07,000 --> 00:01:09,000
听到这里其实就可以转台了

21
00:01:09,000 --> 00:01:14,000
因为必须说有台的节目更好听

22
00:01:14,000 --> 00:01:17,000
尤其推荐上一些泰译来了

23
00:01:17,000 --> 00:01:19,000
主题是情趣用品

24
00:01:19,000 --> 00:01:22,000
请在家长缺席一下声音

25
00:01:23,000 --> 00:01:27,000
所以仍旧坚守着内恨恐慌的朋友们

26
00:01:27,000 --> 00:01:27,000
你们好

27
00:01:27,000 --> 00:01:29,000
本期没有 Rail

28
00:01:29,000 --> 00:01:31,000
但是也没有嘉宾

29
00:01:31,000 --> 00:01:36,000
只有我一个人在这边孤独的坚守的任地

30
00:01:36,000 --> 00:01:38,000
但是这是你听起来的错觉

31
00:01:38,000 --> 00:01:41,000
因为实际情况是我的女朋友此刻正坐在旁边

32
00:01:41,000 --> 00:01:45,000
为我端查到水山风垂尾

33
00:01:45,000 --> 00:01:51,000
所以本期的主题就是程序员怎么样才能找到一个女朋友

34
00:01:51,000 --> 00:01:53,000
但是在进入主题之前

35
00:01:53,000 --> 00:01:55,000
我们先来念几封读者来信

36
00:01:58,000 --> 00:02:00,000
首先是一位叫做营伙的朋友

37
00:02:00,000 --> 00:02:05,000
他说第 17 期的后面提到

38
00:02:05,000 --> 00:02:10,000
五套说不知道 DLL 的图标是什么意思

39
00:02:10,000 --> 00:02:12,000
所以也不知道可不可以删

40
00:02:12,000 --> 00:02:17,000
而我小时候试过将系统的 DLL 文件删除了

41
00:02:17,000 --> 00:02:19,000
那个时候玩表哥家的电脑

42
00:02:19,000 --> 00:02:20,000
他们出去了

43
00:02:20,000 --> 00:02:22,000
剩下一个人在玩合金战头

44
00:02:22,000 --> 00:02:23,000
玩了以后觉得无聊

45
00:02:23,000 --> 00:02:24,000
就用鼠标乱点

46
00:02:24,000 --> 00:02:26,000
豪华绿的图标可以点开

47
00:02:26,000 --> 00:02:28,000
有尺轮的图标都点不开

48
00:02:28,000 --> 00:02:30,000
我就理所当然认为点不开是没有用的

49
00:02:30,000 --> 00:02:32,000
没有用的就应该被删掉

50
00:02:32,000 --> 00:02:36,000
所以我将所有能看到的点不开的文件都删除了

51
00:02:36,000 --> 00:02:39,000
后面要吃饭就兴满意识的关了机

52
00:02:39,000 --> 00:02:40,000
到晚上表哥回来

53
00:02:40,000 --> 00:02:41,000
发现电脑启动不了

54
00:02:41,000 --> 00:02:43,000
我以为弄烂的电脑很害怕

55
00:02:43,000 --> 00:02:47,000
因为那个时候电脑比电视机和摩托车都贵

56
00:02:47,000 --> 00:02:48,000
赔不起

57
00:02:49,000 --> 00:02:51,000
后来表哥打电话叫了一个同学过来

58
00:02:51,000 --> 00:02:54,000
那个同学在一个黑户户的窗口里面打字

59
00:02:54,000 --> 00:02:55,000
折腾了半个钟头

60
00:02:55,000 --> 00:02:57,000
电脑重新可以用

61
00:02:57,000 --> 00:03:00,000
小小的我觉得那个人是大大的高手

62
00:03:00,000 --> 00:03:01,000
很久以后我才醒不过来

63
00:03:01,000 --> 00:03:03,000
那个时候删掉的文件是 DLL

64
00:03:03,000 --> 00:03:07,000
那个高手所做的叫做重装系统

65
00:03:07,000 --> 00:03:08,000
完了

66
00:03:09,000 --> 00:03:12,000
这让我想起到此时爱

67
00:03:12,000 --> 00:03:14,000
好像没有这样的疑惑

68
00:03:14,000 --> 00:03:15,000
因为到此时爱

69
00:03:15,000 --> 00:03:19,000
而如果你不区分可执行文件和不可执行文件的话

70
00:03:19,000 --> 00:03:23,000
是很难知道哪个文件有用哪个文件没有用的

71
00:03:23,000 --> 00:03:26,000
你只能看扩展明

72
00:03:26,000 --> 00:03:28,000
而如果你不懂扩展明的意义的话

73
00:03:28,000 --> 00:03:30,000
你是不会莫名其妙就删它的

74
00:03:30,000 --> 00:03:34,000
这可倒是另外一个命令行

75
00:03:34,000 --> 00:03:36,000
比较安全的因素

76
00:03:37,000 --> 00:03:39,000
或者说早期的图形化界面

77
00:03:39,000 --> 00:03:43,000
没有默认用户有可能不知道自己在干什么

78
00:03:44,000 --> 00:03:45,000
现在的操作性能做的很好

79
00:03:45,000 --> 00:03:49,000
把比较容易弄坏的部分都隐藏起来

80
00:03:51,000 --> 00:03:53,000
这让我想起到此时爱重装系统

81
00:03:53,000 --> 00:03:56,000
好像只需要格式化一下系统盘就可以了

82
00:03:56,000 --> 00:03:58,000
好像是一条命令吧

83
00:03:58,000 --> 00:03:59,000
Sys 还是什么

84
00:03:59,000 --> 00:04:01,000
还是斜杠 Sys

85
00:04:01,000 --> 00:04:06,000
就可以把 DOS 传播到一个软盘或者硬盘

86
00:04:06,000 --> 00:04:08,000
让它变成可以 boot

87
00:04:08,000 --> 00:04:08,000
对

88
00:04:08,000 --> 00:04:11,000
如果各位久了以后听中没有经历过那个时爱的话

89
00:04:11,000 --> 00:04:15,000
那个时爱重装系统没有光盘可以用

90
00:04:15,000 --> 00:04:17,000
当然更可能有网络可以用

91
00:04:17,000 --> 00:04:21,000
就是基本上就是你有 10 张软盘甚至更多

92
00:04:21,000 --> 00:04:25,000
我也现在已经不记得那个时候第一版 Windows 3.2 或者是

93
00:04:26,000 --> 00:04:28,000
我相信 Windows 95 又出过软盘版

94
00:04:29,000 --> 00:04:30,000
对

95
00:04:30,000 --> 00:04:35,000
你要把一张一张软盘一次插入软盘驱动器

96
00:04:35,000 --> 00:04:36,000
天哪软盘驱动器

97
00:04:36,000 --> 00:04:38,000
或者多久没收过这次

98
00:04:38,000 --> 00:04:42,000
然后每张软盘可能装个完整 10%左右

99
00:04:42,000 --> 00:04:46,000
然后你要耐心的在那里坐着

100
00:04:46,000 --> 00:04:48,000
一直让手动的去换软盘

101
00:04:48,000 --> 00:04:50,000
那像现在科技昌明

102
00:04:50,000 --> 00:04:54,000
就像写一个文文文件告诉电脑

103
00:04:54,000 --> 00:04:55,000
你需要一台什么样的虚拟机

104
00:04:55,000 --> 00:04:59,000
电脑很快就可以在一瞬间帮你竖起来一台

105
00:04:59,000 --> 00:05:04,000
具有完整的操作系统和程序开发环境的虚拟机

106
00:05:05,000 --> 00:05:07,000
哎呀 真是老了

107
00:05:08,000 --> 00:05:12,000
不过其实我从很小的时候就建立起一个信念

108
00:05:12,000 --> 00:05:13,000
只要你不去拆机箱

109
00:05:13,000 --> 00:05:14,000
电脑就是弄不坏

110
00:05:16,000 --> 00:05:19,000
我不知道现在学编程的朋友们是不是还有这个医货

111
00:05:19,000 --> 00:05:23,000
就是有时候会很担心把电脑弄坏

112
00:05:23,000 --> 00:05:26,000
但实际情况就是只要你好好做备份

113
00:05:26,000 --> 00:05:28,000
数据别弄丢

114
00:05:30,000 --> 00:05:35,000
操作系统本身基本上是非常耐操的

115
00:05:35,000 --> 00:05:37,000
哪怕你删掉所有的电脑

116
00:05:37,000 --> 00:05:42,000
且不论你现在你是否能够安全的删除一堆的电脑

117
00:05:42,000 --> 00:05:43,000
而不被电脑发现

118
00:05:43,000 --> 00:05:44,000
或者被电脑补救回来

119
00:05:46,000 --> 00:05:48,000
即便你删掉了电脑也是永远可以恢复的

120
00:05:48,000 --> 00:05:50,000
只要你不拆机箱

121
00:05:50,000 --> 00:05:51,000
ok 接下来念下一封堵着来信

122
00:05:51,000 --> 00:05:56,000
一位叫做陶气红的朋友说

123
00:05:56,000 --> 00:05:59,000
定时机系提到飞机重启的时候

124
00:05:59,000 --> 00:06:03,000
要是听到了提示音是小霸王骑得不穷

125
00:06:03,000 --> 00:06:05,000
那才是整个人不好

126
00:06:06,000 --> 00:06:12,000
来自马拉西亚的听众李先生

127
00:06:12,000 --> 00:06:14,000
写了一封堵着来信说

128
00:06:14,000 --> 00:06:16,000
你们说了在 Windows 平台上

129
00:06:16,000 --> 00:06:19,000
现在可以开发 Objective-C 的事情

130
00:06:19,000 --> 00:06:22,000
虽然我还没有用过 VIRON 这款新的开发工具

131
00:06:22,000 --> 00:06:24,000
但是我是这样理解的

132
00:06:24,000 --> 00:06:30,000
VIRON 的 VIRUS Studio 是主要让您编译 Objective-C 的原代码

133
00:06:30,000 --> 00:06:34,000
但并不会生成 iOS OS X 平台上的 Binary Code

134
00:06:34,000 --> 00:06:38,000
而是生成 Windows 平台的 Universal Binary Code

135
00:06:38,000 --> 00:06:40,000
所以并不存在你们所说的

136
00:06:40,000 --> 00:06:45,000
如何在 Windows 上提交 iOS App 到 App Store 的问题

137
00:06:45,000 --> 00:06:49,000
因为 VIRON 并没有想要以 VIRUS Studio 取代 Xcode 的想法

138
00:06:49,000 --> 00:06:51,000
括号差个话题

139
00:06:51,000 --> 00:06:53,000
无讨还是 real 有提到说

140
00:06:53,000 --> 00:06:55,000
Xcode Alternative 开发工具

141
00:06:55,000 --> 00:06:58,000
那应该是 Jetbrained Appcode

142
00:06:58,000 --> 00:07:02,000
不过这款工具是用你们讨厌的 Java 所开发的

143
00:07:02,000 --> 00:07:03,000
笑脸

144
00:07:03,000 --> 00:07:04,000
换号完毕

145
00:07:04,000 --> 00:07:06,000
这插一句就是

146
00:07:06,000 --> 00:07:09,000
后来我也想起来 Jetbrained Appcode

147
00:07:09,000 --> 00:07:12,000
对 Jetbrained Appcode 是用 Java 开发的

148
00:07:12,000 --> 00:07:15,000
不过这并不妨碍它是一款优秀的 ID

149
00:07:17,000 --> 00:07:19,000
Java 是可以做出好的东西的

150
00:07:19,000 --> 00:07:21,000
这个我从来没有否认过

151
00:07:21,000 --> 00:07:25,000
但是只是你用 Java 做东西的过程比较淡腾

152
00:07:25,000 --> 00:07:27,000
取决于你是比较注重结果

153
00:07:27,000 --> 00:07:29,000
还是比较注重过程

154
00:07:29,000 --> 00:07:31,000
我觉得过程还是挺重要的

155
00:07:32,000 --> 00:07:35,000
回到李先生的来信

156
00:07:36,000 --> 00:07:40,000
他接着说微软主要想要借此新版的 Virtual Studio

157
00:07:40,000 --> 00:07:43,000
来让许多指挥 Apple 开发软件的开发者

158
00:07:43,000 --> 00:07:48,000
提供一个快速从 iOS 一至到 Windows 的工具

159
00:07:48,000 --> 00:07:50,000
我认为这是一个比较聪明的手段

160
00:07:50,000 --> 00:07:52,000
来拉拢 iOS 安装开发者

161
00:07:52,000 --> 00:07:56,000
Apple 早期在推出 OS 10 的时候也用过这一招

162
00:07:56,000 --> 00:07:59,000
他们当时使用 Rosetto 来

163
00:07:59,000 --> 00:08:01,000
这边可能写错了

164
00:08:01,000 --> 00:08:03,000
我记得那个东西叫做 Rosetto

165
00:08:03,000 --> 00:08:05,000
就是 Rosetto 10 倍的那次

166
00:08:05,000 --> 00:08:11,000
来帮助开发者过度从 OS 9 过度到 OS 10

167
00:08:11,000 --> 00:08:14,000
同时也在 s-code 里面提供了多元的编译

168
00:08:14,000 --> 00:08:16,000
比如 Object C

169
00:08:16,000 --> 00:08:17,000
C 和 C++

170
00:08:17,000 --> 00:08:22,000
来以这种方式让 Adobe 或者是微软

171
00:08:22,000 --> 00:08:26,000
这些用 C 或者 C++的开发软件的工资

172
00:08:26,000 --> 00:08:30,000
也可以顺利的将 Fotoshop Office 等旗舰级别的软件

173
00:08:30,000 --> 00:08:32,000
顺利的一只老 iS 10

174
00:08:34,000 --> 00:08:36,000
如果您有兴趣知道详情

175
00:08:36,000 --> 00:08:38,000
以下的视频是 Virginal Studio Compiler Team

176
00:08:38,000 --> 00:08:40,000
在 Build 大会上的展示

177
00:08:40,000 --> 00:08:42,000
请从 27 分 20 秒开始看

178
00:08:42,000 --> 00:08:46,000
然后给了一个 Channel 9 的 link

179
00:08:46,000 --> 00:08:48,000
这个 link 我们会贴在 short notes 里面

180
00:08:48,000 --> 00:08:50,000
我会贴在 short notes 里面

181
00:08:50,000 --> 00:08:52,000
我怎么停不了说我们呢

182
00:08:52,000 --> 00:08:54,000
哎呀好孤单

183
00:08:55,000 --> 00:08:57,000
这里减数视频里的一些重点

184
00:08:59,000 --> 00:09:01,000
编辑器采用 C Lang

185
00:09:01,000 --> 00:09:06,000
也就是 C++ object C 的编辑器的 frontend

186
00:09:06,000 --> 00:09:10,000
和 C 2 也就是微软编辑器的 backend

187
00:09:11,000 --> 00:09:14,000
在 Virginal Studio 里面可以使用

188
00:09:14,000 --> 00:09:18,000
Object C 直接调用 Windows API

189
00:09:18,000 --> 00:09:19,000
嗯哼

190
00:09:20,000 --> 00:09:22,000
呃然后编译后的代码

191
00:09:22,000 --> 00:09:24,000
并不是在 immulated 上围形的

192
00:09:24,000 --> 00:09:26,000
而是 windows 举用 Virtual 原声名

193
00:09:28,000 --> 00:09:30,000
微软实现了 iOS 上的一部分 API

194
00:09:30,000 --> 00:09:34,000
他们称之为 subset of iOS API

195
00:09:34,000 --> 00:09:37,000
计划实现的 API 包括 opengl,openal,sensor,

196
00:09:37,000 --> 00:09:40,000
UIkit,core animation 等等

197
00:09:41,000 --> 00:09:43,000
最后视频里面有个小花絮

198
00:09:43,000 --> 00:09:46,000
当台上了微软成品行李

199
00:09:46,000 --> 00:09:49,000
问台下有多少人在为 Apple 开发产品的时候

200
00:09:49,000 --> 00:09:50,000
台下来有一半人去说

201
00:09:50,000 --> 00:09:51,000
呵呵呵

202
00:09:52,000 --> 00:09:54,000
好非常感谢这位李先生的来信啊

203
00:09:54,000 --> 00:09:57,000
嗯干活相当多

204
00:09:57,000 --> 00:10:01,000
呃他提到了这个 Apple 早期在推出 s 10 的时候

205
00:10:01,000 --> 00:10:05,000
使用 Rosetta 来帮助开发者从 OS 当然过渡到 s 10

206
00:10:05,000 --> 00:10:09,000
呃我记得那个时候给 Apple 开发程序是要用

207
00:10:10,000 --> 00:10:14,000
呃除了 scode 还有一个东西叫什么

208
00:10:14,000 --> 00:10:15,000
Colaborator

209
00:10:15,000 --> 00:10:16,000
还是 Ballad 公司除了

210
00:10:17,000 --> 00:10:19,000
我好像有信口开发

211
00:10:19,000 --> 00:10:21,000
就是没有做调查就是这样

212
00:10:21,000 --> 00:10:25,000
呃如果 Colaborator 不是 Ballad 能做的话

213
00:10:25,000 --> 00:10:27,000
那是谁做的

214
00:10:29,000 --> 00:10:29,000
这不重要

215
00:10:29,000 --> 00:10:34,000
总之那个时候为 OS 9 开发程序是要用到 C

216
00:10:34,000 --> 00:10:36,000
那个时候还没有 Order to C

217
00:10:37,000 --> 00:10:39,000
天哪呢是个多么红荒的时代

218
00:10:39,000 --> 00:10:45,000
呃不过那个时候好像也是可以用 Java 为 OS 9 开发程序的吧

219
00:10:45,000 --> 00:10:46,000
我没有记错了

220
00:10:47,000 --> 00:10:49,000
我还是比较年轻的没有经历过那个时代

221
00:10:49,000 --> 00:10:52,000
如果我们听众里面有经历过那个时代的话

222
00:10:52,000 --> 00:10:55,000
也就是怎样 OS 9 或者 OS

223
00:10:55,000 --> 00:11:00,000
NedgerOS 8 开发程序的听众的话

224
00:11:00,000 --> 00:11:04,000
也欢迎你来信提供一下这个经验

225
00:11:04,000 --> 00:11:09,000
就那个时代的呃苹果电脑是怎样开发程序的

226
00:11:09,000 --> 00:11:10,000
因为

227
00:11:11,000 --> 00:11:16,000
虽然目前我们都是已经归一苹果叫的铁钩的果粉

228
00:11:16,000 --> 00:11:21,000
但是早期我们开发程序的经历就真的只有

229
00:11:21,000 --> 00:11:23,000
Windows 9 就是 Linux

230
00:11:25,000 --> 00:11:28,000
好像我跟 Rio 都没有做过 OS 9 时代的

231
00:11:28,000 --> 00:11:31,000
至少是给图形界面编程的经历

232
00:11:31,000 --> 00:11:33,000
对欢迎各位提供保护的经验

233
00:11:34,000 --> 00:11:37,000
然后他提到说

234
00:11:37,000 --> 00:11:42,000
在非洲 Studio 里面可以直接以 Order to C 调用 Windows API

235
00:11:42,000 --> 00:11:43,000
这个听起来非常的

236
00:11:44,000 --> 00:11:45,000
跟太齐

237
00:11:45,000 --> 00:11:46,000
就是

238
00:11:46,000 --> 00:11:50,000
所以言下基就是我可以用 Order to C 在 Windows 上面写

239
00:11:50,000 --> 00:11:52,000
给写 Windows 程序了

240
00:11:53,000 --> 00:11:54,000
嗯

241
00:11:54,000 --> 00:11:55,000
有意思

242
00:11:56,000 --> 00:11:57,000
什么想象今天呢

243
00:11:58,000 --> 00:12:03,000
接下来是一位叫做 WiPolyDirect 朋友

244
00:12:03,000 --> 00:12:06,000
朋友给我们寄来的听众来信

245
00:12:06,000 --> 00:12:08,000
他说 Rio 无讨你们好

246
00:12:08,000 --> 00:12:10,000
还是给两位发一个邮件吧

247
00:12:10,000 --> 00:12:11,000
之前总是在微博留言

248
00:12:11,000 --> 00:12:16,000
担心写信会写的太长浪费两位的时间

249
00:12:17,000 --> 00:12:18,000
关于 V 2 的问题

250
00:12:18,000 --> 00:12:19,000
我就不多说了

251
00:12:19,000 --> 00:12:21,000
两位只是偶尔谈到

252
00:12:21,000 --> 00:12:24,000
并没有把它当做一个正式的题目来讲

253
00:12:24,000 --> 00:12:26,000
而我也是仅仅怀有热情

254
00:12:26,000 --> 00:12:29,000
并不是相关项目的参与者

255
00:12:29,000 --> 00:12:33,000
所以我今天的反馈是关于很早的一期

256
00:12:33,000 --> 00:12:34,000
关于机械键盘的

257
00:12:36,000 --> 00:12:37,000
那是我们的第二期

258
00:12:38,000 --> 00:12:41,000
好像迄今也是人气最高的一期

259
00:12:41,000 --> 00:12:44,000
当然我相信慕瑶和萧绩姐的那两期

260
00:12:44,000 --> 00:12:46,000
早晚会超过这一期

261
00:12:46,000 --> 00:12:46,000
不过

262
00:12:46,000 --> 00:12:48,000
目前来看

263
00:12:48,000 --> 00:12:51,000
键盘这一期的下达量是非常高

264
00:12:53,000 --> 00:12:56,000
我是从那一期开始才知道机械键盘是怎么回事

265
00:12:56,000 --> 00:12:58,000
然后就多了解了一期

266
00:12:58,000 --> 00:13:01,000
但是有一个很大的遗憾就是

267
00:13:01,000 --> 00:13:05,000
没有人谈到机械键盘压力特殊的问题

268
00:13:05,000 --> 00:13:07,000
而我觉得这是一个很大的问题

269
00:13:07,000 --> 00:13:08,000
我的意思是

270
00:13:08,000 --> 00:13:15,000
没有把机械键盘的压力曲线和不默键盘的压力曲线进行计算比较

271
00:13:15,000 --> 00:13:16,000
这个问题重要吗

272
00:13:16,000 --> 00:13:16,000
我觉得很重要

273
00:13:16,000 --> 00:13:17,000
请看后面

274
00:13:18,000 --> 00:13:20,000
我这里就不画图论

275
00:13:20,000 --> 00:13:24,000
简单的说一下就是机械键盘的弹力结构是弹簧

276
00:13:24,000 --> 00:13:26,000
暂时没有见到其他结构

277
00:13:26,000 --> 00:13:29,000
弹簧的压力曲线是从小到大

278
00:13:29,000 --> 00:13:32,000
而且压力曲线基本上是平止的

279
00:13:32,000 --> 00:13:33,000
这导致了一个问题

280
00:13:33,000 --> 00:13:36,000
就是按压过程中要不断的施加压力

281
00:13:36,000 --> 00:13:40,000
而不默键盘的弹力结构是橡胶碗

282
00:13:40,000 --> 00:13:42,000
这种结构出使压力比较大

283
00:13:42,000 --> 00:13:44,000
但是一旦突破之后就很轻松了

284
00:13:46,000 --> 00:13:52,000
实际表现出来的结果就是机械键盘要保持按压状态需要一直用力按住

285
00:13:53,000 --> 00:13:55,000
这里先不谈各种轴轴差异影响

286
00:13:55,000 --> 00:13:59,000
而不默键盘一旦按下之后就很容易保持按压的状态

287
00:13:59,000 --> 00:14:01,000
不需要很大的力

288
00:14:01,000 --> 00:14:03,000
还有就是每次按压所需要付出的力

289
00:14:03,000 --> 00:14:05,000
机械键盘也要比薄膜键盘大

290
00:14:06,000 --> 00:14:09,000
关于力的多少可以通过计算压力曲线获得

291
00:14:09,000 --> 00:14:11,000
我没有专业的工具没法测量计算

292
00:14:11,000 --> 00:14:15,000
但是参考对弓箭适能的计算方式

293
00:14:15,000 --> 00:14:18,000
可以知道压力曲线越平止收集的能量就越大

294
00:14:20,000 --> 00:14:23,000
其实我能想到这个问题是因为我的弓箭感兴趣

295
00:14:23,000 --> 00:14:24,000
之前看过一些研究资料

296
00:14:24,000 --> 00:14:27,000
比如反曲弓为什么效能更高

297
00:14:27,000 --> 00:14:29,000
当然为了验证我的猜想

298
00:14:29,000 --> 00:14:31,000
我专门订了一个机械键盘试用一下

299
00:14:31,000 --> 00:14:33,000
我只是为了体验一下就推货

300
00:14:33,000 --> 00:14:34,000
有点不道德

301
00:14:34,000 --> 00:14:36,000
我试用的是茶肘

302
00:14:36,000 --> 00:14:38,000
因为听说你们听你们说茶肘比较轻

303
00:14:39,000 --> 00:14:46,000
体验的结果就是在 Counter Strike 这种需要长时间按住几个键的游戏里面

304
00:14:46,000 --> 00:14:47,000
非常的累

305
00:14:47,000 --> 00:14:51,000
打字的话也感觉要比我用的薄膜键盘要累一点

306
00:14:52,000 --> 00:14:53,000
机械键盘的初始压力很小

307
00:14:53,000 --> 00:14:55,000
给人一个很轻的错觉

308
00:14:55,000 --> 00:14:58,000
但是实际上通过前面的计算就知道

309
00:14:58,000 --> 00:15:00,000
每次按压需要的力实际上很大

310
00:15:00,000 --> 00:15:05,000
这也许从理论上说明了机械键盘不适合长时间操作

311
00:15:05,000 --> 00:15:09,000
当然我只是想说明压力曲线这一个问题

312
00:15:09,000 --> 00:15:12,000
不涉及对机械键盘优劣的评论

313
00:15:12,000 --> 00:15:13,000
好吧

314
00:15:13,000 --> 00:15:16,000
其实有点担心让喜欢机械键盘的两位大声反感

315
00:15:17,000 --> 00:15:20,000
另外我个人因为身体原因对轻弄比较敏感

316
00:15:20,000 --> 00:15:21,000
所以我的手

317
00:15:21,000 --> 00:15:23,000
所以我的感受可能不代表大多数人

318
00:15:24,000 --> 00:15:26,000
我只用的是鸣鸡海背键盘

319
00:15:26,000 --> 00:15:27,000
是博国键盘

320
00:15:28,000 --> 00:15:31,000
但是支撑组件是笔记本的 X 型结构

321
00:15:31,000 --> 00:15:34,000
手感介于笔记本和普通电脑时间

322
00:15:34,000 --> 00:15:35,000
这是我用的第二个键盘

323
00:15:37,000 --> 00:15:37,000
不好意思

324
00:15:37,000 --> 00:15:39,000
这一期又写长了

325
00:15:39,000 --> 00:15:41,000
好不容易找到一个新鸣弹的话题

326
00:15:42,000 --> 00:15:42,000
OK

327
00:15:42,000 --> 00:15:45,000
这位听众的来信就已经完了

328
00:15:47,000 --> 00:15:48,000
怎么说

329
00:15:48,000 --> 00:15:50,000
就是首先前面他说

330
00:15:52,000 --> 00:15:55,000
机械键盘压力克硕的问题

331
00:15:58,000 --> 00:16:00,000
他认为机械盘的弹力结构是弹簧

332
00:16:01,000 --> 00:16:04,000
而弹簧的压力曲线是线性的

333
00:16:06,000 --> 00:16:08,000
按压力过程中需要不断的施得压力等等

334
00:16:09,000 --> 00:16:10,000
这个怎么说

335
00:16:10,000 --> 00:16:13,000
就是压力曲线每一个轴

336
00:16:13,000 --> 00:16:16,000
就如果你用 cherry 的轴来判断的话

337
00:16:16,000 --> 00:16:17,000
每个轴其实不一样的

338
00:16:17,000 --> 00:16:21,000
有些轴是的确是线性的

339
00:16:21,000 --> 00:16:23,000
但是另外一些轴是你按到一半的时候

340
00:16:23,000 --> 00:16:24,000
它会有一个触发点

341
00:16:25,000 --> 00:16:27,000
你只要按到触发点之后

342
00:16:27,000 --> 00:16:29,000
就可以松开

343
00:16:29,000 --> 00:16:33,000
这朋友提到的一个用用场景就是

344
00:16:33,000 --> 00:16:34,000
counter strike

345
00:16:35,000 --> 00:16:37,000
其实我个人觉得打 counter strike 的话

346
00:16:37,000 --> 00:16:39,000
还是伯摩键盘比较好

347
00:16:39,000 --> 00:16:41,000
原因倒不是伯摩键盘显得比较好

348
00:16:41,000 --> 00:16:43,000
老师怎么说呢

349
00:16:43,000 --> 00:16:46,000
伯摩键盘比较便宜

350
00:16:46,000 --> 00:16:51,000
打 counter strike 是对键盘非常灵虐的一种方式

351
00:16:52,000 --> 00:16:56,000
我个人还是会吃回游戏线本打字

352
00:16:56,000 --> 00:16:56,000
我也不知道

353
00:16:56,000 --> 00:16:59,000
反正现在我大部分时候打

354
00:16:59,000 --> 00:17:01,000
比如说暴雪的风暴英雄

355
00:17:01,000 --> 00:17:03,000
或者是 wa thunder

356
00:17:03,000 --> 00:17:07,000
就是一个二战的坦克防阵游戏

357
00:17:07,000 --> 00:17:09,000
的时候基本上都是单用 B 本的

358
00:17:09,000 --> 00:17:10,000
伯摩键盘在打

359
00:17:13,000 --> 00:17:16,000
手感这个东西是非常主观的一件事情

360
00:17:16,000 --> 00:17:21,000
其实如果你单纯的从手感上来说的话

361
00:17:22,000 --> 00:17:24,000
机器键盘里面很多东西都是悬悬

362
00:17:24,000 --> 00:17:27,000
但是打字比较累

363
00:17:27,000 --> 00:17:28,000
可能是

364
00:17:28,000 --> 00:17:30,000
可能的确是这样

365
00:17:30,000 --> 00:17:32,000
有时候我现在也会觉得

366
00:17:32,000 --> 00:17:34,000
用机器键盘打字会稍微累一点

367
00:17:34,000 --> 00:17:35,000
怎么说呢

368
00:17:35,000 --> 00:17:37,000
就是打字累的这么一点点

369
00:17:37,000 --> 00:17:40,000
可能跟你每天多走几步

370
00:17:40,000 --> 00:17:42,000
我的能量消耗都差不多

371
00:17:42,000 --> 00:17:44,000
基本上可以忽略不计的

372
00:17:44,000 --> 00:17:46,000
各位想靠打字减肥的朋友们

373
00:17:46,000 --> 00:17:48,000
就这行行了

374
00:17:49,000 --> 00:17:51,000
最后一封肚子来信

375
00:17:51,000 --> 00:17:54,000
一位来自叫做

376
00:17:54,000 --> 00:17:55,000
肖志伯

377
00:17:55,000 --> 00:17:56,000
我不知道已经念对了没有

378
00:17:56,000 --> 00:17:58,000
德伯士先生

379
00:17:58,000 --> 00:18:01,000
对他的 email 里面就是 Dr.头显

380
00:18:01,000 --> 00:18:02,000
这个跟德伯很像

381
00:18:02,000 --> 00:18:05,000
德伯人都喜欢把自己的 Dr.头显写出来

382
00:18:05,000 --> 00:18:07,000
嗨两位主播好

383
00:18:07,000 --> 00:18:09,000
听了第 15 期的克林语潘尼克

384
00:18:09,000 --> 00:18:13,000
听众来信中有人讨论的 data science

385
00:18:13,000 --> 00:18:14,000
我又做不住了

386
00:18:14,000 --> 00:18:17,000
之前我买了本书的 data science handbook

387
00:18:17,000 --> 00:18:19,000
是 kura 的 data scientist

388
00:18:19,000 --> 00:18:21,000
villum Chen

389
00:18:21,000 --> 00:18:23,000
联合一众 data scientist

390
00:18:23,000 --> 00:18:26,000
做的回馈大众的一件大好事

391
00:18:26,000 --> 00:18:28,000
我觉得大家都可以买来看一下

392
00:18:28,000 --> 00:18:29,000
虽然现在还没有看完

393
00:18:29,000 --> 00:18:31,000
不过写的真的挺好的

394
00:18:31,000 --> 00:18:33,000
对于想要入行的 data science

395
00:18:33,000 --> 00:18:35,000
已经在这个行业整合同学

396
00:18:35,000 --> 00:18:37,000
都会有所帮助

397
00:18:37,000 --> 00:18:39,000
来信中的那位同学说

398
00:18:39,000 --> 00:18:41,000
现在 azer 和

399
00:18:42,000 --> 00:18:43,000
amazon 这样的大公司

400
00:18:43,000 --> 00:18:45,000
把机器学习算法当成

401
00:18:45,000 --> 00:18:47,000
服务推出来了

402
00:18:47,000 --> 00:18:49,000
可以让大家不用编程就能用起来

403
00:18:49,000 --> 00:18:51,000
这的确是好事

404
00:18:51,000 --> 00:18:53,000
不过说到自然源处理

405
00:18:53,000 --> 00:18:56,000
其实还是有很多很难的事情要做的

406
00:18:57,000 --> 00:18:59,000
而其实这些很难的工作都是

407
00:18:59,000 --> 00:19:01,000
人可以轻而易举的做到了

408
00:19:01,000 --> 00:19:04,000
比如说从一个句子里面准确的

409
00:19:04,000 --> 00:19:07,000
10 月初日期和时间

410
00:19:07,000 --> 00:19:09,000
这个听起来非常简单

411
00:19:09,000 --> 00:19:13,000
现有的 stanford nlp

412
00:19:13,000 --> 00:19:16,000
也就是斯坦福的自然源处理

413
00:19:16,000 --> 00:19:18,000
技术用基于

414
00:19:18,000 --> 00:19:22,000
conditional random field 的实体命名算法

415
00:19:22,000 --> 00:19:23,000
也可以用

416
00:19:23,000 --> 00:19:25,000
但是达到非常精确的效果

417
00:19:25,000 --> 00:19:27,000
还是有很长的路要走

418
00:19:27,000 --> 00:19:28,000
再说另一个

419
00:19:28,000 --> 00:19:31,000
从数据集中让算法自动实跌出

420
00:19:31,000 --> 00:19:33,000
变量的值是连续型的

421
00:19:33,000 --> 00:19:35,000
还是离散型的都很难

422
00:19:36,000 --> 00:19:38,000
建巧大学的

423
00:19:38,000 --> 00:19:40,000
Zobin Gahramani

424
00:19:40,000 --> 00:19:43,000
教授在 2014 年的 nips

425
00:19:44,000 --> 00:19:46,000
这是一个

426
00:19:46,000 --> 00:19:50,000
neural information processing system

427
00:19:50,000 --> 00:19:51,000
它是一个年会

428
00:19:51,000 --> 00:19:52,000
应该是

429
00:19:52,000 --> 00:19:52,000
对

430
00:19:52,000 --> 00:19:56,000
跟这个神经信息处理新闻关

431
00:19:57,000 --> 00:20:03,000
这个这位教授在 2014 年的 nips 会议上面

432
00:20:03,000 --> 00:20:05,000
就这个问题发表的片论文

433
00:20:05,000 --> 00:20:08,000
然后顺便再推一下另外一个 podcast

434
00:20:08,000 --> 00:20:10,000
talking machine

435
00:20:10,000 --> 00:20:18,000
网址是 htp www.thalkingmachines.com

436
00:20:18,000 --> 00:20:21,000
然后其中一个主持人就是哈佛大学的

437
00:20:21,000 --> 00:20:25,000
Rayham Proscott Adams 教授

438
00:20:25,000 --> 00:20:26,000
他利用他的关系

439
00:20:26,000 --> 00:20:28,000
几乎在每一期都请来了

440
00:20:28,000 --> 00:20:31,000
一听名字就让我心跳加速的加冰

441
00:20:31,000 --> 00:20:35,000
不过 Adams 教授在节目里面的一个保留项目

442
00:20:35,000 --> 00:20:37,000
就是用人类可以听懂的

443
00:20:37,000 --> 00:20:38,000
非常简单的语言

444
00:20:38,000 --> 00:20:40,000
解释非常复杂的算法

445
00:20:40,000 --> 00:20:46,000
比如推荐系统里面的 collaborative filtering

446
00:20:46,000 --> 00:20:47,000
怎么翻译

447
00:20:47,000 --> 00:20:49,000
协同过滤

448
00:20:49,000 --> 00:20:54,000
再比如非参数备业司推论中的非常难的

449
00:20:54,000 --> 00:20:57,000
Chinese restaurant process

450
00:20:57,000 --> 00:20:59,000
中餐馆过程

451
00:20:59,000 --> 00:21:00,000
有一次

452
00:21:00,000 --> 00:21:05,000
我查了一下这个中餐馆过程是模拟一个有无限张原桌

453
00:21:05,000 --> 00:21:08,000
每张原桌能做无限个人的中餐馆里面

454
00:21:08,000 --> 00:21:10,000
做客人的随机过程

455
00:21:10,000 --> 00:21:11,000
为什么叫这个名字

456
00:21:11,000 --> 00:21:13,000
大概是在洋人眼里面

457
00:21:13,000 --> 00:21:16,000
只有中餐馆才会有原桌吧

458
00:21:16,000 --> 00:21:18,000
以上是这位听众所推荐的

459
00:21:18,000 --> 00:21:21,000
应该是关于自然原处理的一个 podcast

460
00:21:21,000 --> 00:21:24,000
有兴趣的听众们不妨去听听

461
00:21:24,000 --> 00:21:25,000
最后他说

462
00:21:25,000 --> 00:21:27,000
PS 虽然无套说了

463
00:21:27,000 --> 00:21:28,000
不让再推荐加冰了

464
00:21:28,000 --> 00:21:30,000
但是 please please

465
00:21:30,000 --> 00:21:32,000
能试着请一下 Kura 的 Vitam Chen 吗

466
00:21:32,000 --> 00:21:36,000
我想如果是要做一期有关 data science 的话题

467
00:21:36,000 --> 00:21:39,000
请来这样一个 data science 才好吧

468
00:21:39,000 --> 00:21:43,000
我也知道请一个陌生人上节目还是挺难的

469
00:21:43,000 --> 00:21:47,000
anyway please keep up the good work

470
00:21:48,000 --> 00:21:49,000
感谢这位听众

471
00:21:49,000 --> 00:21:53,000
对我们的确是想要请一位或者人家试着 data science

472
00:21:53,000 --> 00:21:57,000
来聊 data science 的话题

473
00:21:58,000 --> 00:22:01,000
不过在目前还没有合适的人选

474
00:22:01,000 --> 00:22:05,000
我去看一下这位 Vitam Chen 是不是

475
00:22:05,000 --> 00:22:08,000
是不是首先是不是一个适合接近的人

476
00:22:09,000 --> 00:22:10,000
感谢这位听众

477
00:22:11,000 --> 00:22:15,000
接下来我想要提到的一些新闻就是

478
00:22:16,000 --> 00:22:19,000
其实有这有一条就是 google i o

479
00:22:19,000 --> 00:22:23,000
我不知道明天的 id 功能会怎样聊这个话题

480
00:22:23,000 --> 00:22:25,000
我希望他们会聊这个话题吧

481
00:22:25,000 --> 00:22:27,000
但是从卡巴尔从面上来说

482
00:22:27,000 --> 00:22:33,000
这次 google i o 大会让我印象比较深的

483
00:22:33,000 --> 00:22:35,000
当然我没有完全看这个大会

484
00:22:36,000 --> 00:22:38,000
我只是事后去看了一下 summary

485
00:22:39,000 --> 00:22:40,000
因为要上班

486
00:22:40,000 --> 00:22:44,000
这次 google i o 的在我看来的亮点就是

487
00:22:44,000 --> 00:22:48,000
首先是 Android Studio IDE 应该是 1.3 吧

488
00:22:49,000 --> 00:22:51,000
增加了 ndk 的支持

489
00:22:51,000 --> 00:22:55,000
就是 native developer kit

490
00:22:55,000 --> 00:23:00,000
你可以在它应该是使用了 jet brace 的 cline

491
00:23:00,000 --> 00:23:05,000
来支持用 c++写 Android

492
00:23:05,000 --> 00:23:09,000
其实就是 google i o 此次出现了一个专门

493
00:23:09,000 --> 00:23:13,000
为 internet sense 所开发的操作系统

494
00:23:13,000 --> 00:23:14,000
叫做 brillo

495
00:23:15,000 --> 00:23:17,000
名字有点奇怪

496
00:23:17,000 --> 00:23:22,000
brillo 就是一个怎么说的是一个比较被 stripped down 的

497
00:23:22,000 --> 00:23:23,000
Android 系统

498
00:23:23,000 --> 00:23:26,000
然后你可以把它装在一些智能加电上

499
00:23:26,000 --> 00:23:27,000
甚至都不一定是加电

500
00:23:27,000 --> 00:23:28,000
就是一些电器

501
00:23:28,000 --> 00:23:29,000
比如说电灯

502
00:23:29,000 --> 00:23:31,000
电扇之类的东西上

503
00:23:31,000 --> 00:23:33,000
或烟卧油气之类的

504
00:23:33,000 --> 00:23:35,000
在上面插一芯片

505
00:23:35,000 --> 00:23:37,000
然后装上这个烧水灯

506
00:23:37,000 --> 00:23:40,000
然后 automatically

507
00:23:40,000 --> 00:23:41,000
这个东西就变成了一个智能加电

508
00:23:41,000 --> 00:23:46,000
你可以用你的 Android 设备去操纵它

509
00:23:48,000 --> 00:23:52,000
然后配套推出的也就是

510
00:23:53,000 --> 00:23:57,000
这种小芯片互相通信的一种

511
00:23:57,000 --> 00:23:59,000
怎么说呢

512
00:23:59,000 --> 00:24:00,000
communication layer

513
00:24:01,000 --> 00:24:02,000
应该叫的 communication layer

514
00:24:02,000 --> 00:24:04,000
就是一个通信层

515
00:24:04,000 --> 00:24:05,000
它的名字叫做 v

516
00:24:06,000 --> 00:24:10,000
也就是 w e a v e

517
00:24:10,000 --> 00:24:13,000
这让我想起 google wave

518
00:24:13,000 --> 00:24:18,000
就是已经正式开此复中

519
00:24:19,000 --> 00:24:21,000
理念超前

520
00:24:21,000 --> 00:24:21,000
还不无比

521
00:24:21,000 --> 00:24:22,000
但是最后

522
00:24:23,000 --> 00:24:23,000
对

523
00:24:23,000 --> 00:24:26,000
就这么默默的消失掉了 google wave

524
00:24:26,000 --> 00:24:30,000
我其实我希望 brillo 和 wave

525
00:24:30,000 --> 00:24:32,000
可以早远推广开来

526
00:24:32,000 --> 00:24:37,000
因为这样的话可能智能加电会比较

527
00:24:37,000 --> 00:24:38,000
提前进入我们生活

528
00:24:38,000 --> 00:24:39,000
对

529
00:24:39,000 --> 00:24:42,000
我其实已经妄想过智能加电

530
00:24:42,000 --> 00:24:43,000
无处不在的场景了

531
00:24:45,000 --> 00:24:47,000
未来怎么还不到

532
00:24:48,000 --> 00:24:49,000
有一部电影叫做回到未来

533
00:24:50,000 --> 00:24:51,000
Back to the Future

534
00:24:52,000 --> 00:24:55,000
应该是拍上于 85 年

535
00:24:55,000 --> 00:24:59,000
几之后的三部关于时空旅行的

536
00:24:59,000 --> 00:24:59,000
对

537
00:25:00,000 --> 00:25:00,000
其中

538
00:25:02,000 --> 00:25:04,000
主角在 1985 年所

539
00:25:05,000 --> 00:25:07,000
前进 30 年去到了那个

540
00:25:08,000 --> 00:25:09,000
2015 年

541
00:25:09,000 --> 00:25:11,000
也就是今年

542
00:25:11,000 --> 00:25:12,000
incidentally

543
00:25:13,000 --> 00:25:16,000
10 月 15 号

544
00:25:16,000 --> 00:25:17,000
还是 20 号

545
00:25:17,000 --> 00:25:18,000
没错的话

546
00:25:19,000 --> 00:25:20,000
那天

547
00:25:20,000 --> 00:25:21,000
离我们

548
00:25:21,000 --> 00:25:23,000
离我们录节目的今天

549
00:25:23,000 --> 00:25:25,000
大概也只有 150 天左右

550
00:25:26,000 --> 00:25:29,000
然后电影里面的 2015 年

551
00:25:32,000 --> 00:25:34,000
在有些地方是不如现在的 2015 年

552
00:25:34,000 --> 00:25:37,000
但是在很多其他地方是远远超越

553
00:25:37,000 --> 00:25:38,000
今天的科技水准的

554
00:25:40,000 --> 00:25:41,000
智能加电都不说了

555
00:25:41,000 --> 00:25:46,000
比如说它里面有个叫做 mr fusion 的能源装置

556
00:25:46,000 --> 00:25:47,000
可以装在车上

557
00:25:47,000 --> 00:25:49,000
然后你至少往里面扔一些垃圾

558
00:25:50,000 --> 00:25:53,000
它就可以通过巨变来产生非常非常多的能量

559
00:25:53,000 --> 00:25:57,000
这能量足以支持让一样车产生时空旅行

560
00:25:57,000 --> 00:25:59,000
然后还有一些非常神奇的想法

561
00:25:59,000 --> 00:26:00,000
就比如说

562
00:26:02,000 --> 00:26:03,000
漂浮滑板

563
00:26:03,000 --> 00:26:04,000
对

564
00:26:04,000 --> 00:26:06,000
漂浮滑板这个东西在我们的 2015 年

565
00:26:06,000 --> 00:26:08,000
还是没有被实现出来

566
00:26:08,000 --> 00:26:11,000
对最重要的一点是里面的车都是能飞的

567
00:26:12,000 --> 00:26:14,000
我觉得前一阵子在知乎上有个问题

568
00:26:14,000 --> 00:26:15,000
就是为什么

569
00:26:16,000 --> 00:26:19,000
为什么说我们在 40 年前想要的是飞车

570
00:26:19,000 --> 00:26:21,000
而现在我们得到的只是 140 个字符

571
00:26:23,000 --> 00:26:26,000
当然说这个话的人是没记错的话

572
00:26:26,000 --> 00:26:28,000
是 Tesla 的投资人之一

573
00:26:29,000 --> 00:26:30,000
不是 Alonmos 他自己

574
00:26:30,000 --> 00:26:35,000
但是这个人也是一个科技界的推手人士

575
00:26:35,000 --> 00:26:38,000
他说这句话的原因其实本质上是励志

576
00:26:38,000 --> 00:26:41,000
但是当时有些人把它当成一句吐槽来看

577
00:26:41,000 --> 00:26:45,000
重点就是我们对于未来的想象

578
00:26:45,000 --> 00:26:48,000
可能有可能是偏差非常大的

579
00:26:48,000 --> 00:26:51,000
但是这并不应该妨碍我们去想象的

580
00:26:51,000 --> 00:26:52,000
对

581
00:26:52,000 --> 00:26:57,000
我就是希望智能家具可以早一天铺开来应用

582
00:26:57,000 --> 00:27:02,000
让我们今天能够在某种程度上

583
00:27:03,000 --> 00:27:10,000
在比较方便的部分能够超越那个时候对于未来的想象

584
00:27:11,000 --> 00:27:12,000
嗯

585
00:27:14,000 --> 00:27:16,000
关于飞车这个东西

586
00:27:16,000 --> 00:27:21,000
我觉得就是我之前在直播上看到这个问题的时候

587
00:27:21,000 --> 00:27:22,000
里面有人说

588
00:27:22,000 --> 00:27:25,000
里面有人通过各种例子来论证了

589
00:27:25,000 --> 00:27:28,000
为什么 140 个字符比飞车更重要

590
00:27:28,000 --> 00:27:29,000
说

591
00:27:30,000 --> 00:27:35,000
如果你可以更便捷的和离你很远的人通讯

592
00:27:35,000 --> 00:27:38,000
那你就不需要去到那个人身边了

593
00:27:38,000 --> 00:27:41,000
如果你可以开 telet conference 的话

594
00:27:41,000 --> 00:27:44,000
那你就不需要亲自跑到那个地方去了

595
00:27:44,000 --> 00:27:51,000
所以有 140 字符的便捷的交流方式其实是要比飞车重要的

596
00:27:51,000 --> 00:27:52,000
我承认他有一定的道理

597
00:27:52,000 --> 00:27:58,000
但是我总觉得如果飞车这个东西真的可以出现的话

598
00:27:59,000 --> 00:28:00,000
或者说一个比较

599
00:28:00,000 --> 00:28:02,000
我对飞车其实已经出现了

600
00:28:02,000 --> 00:28:05,000
就是现在已经有可以飞下来的汽车

601
00:28:05,000 --> 00:28:08,000
但是最大的问题是这个汽车

602
00:28:08,000 --> 00:28:10,000
首先它需要专门的跑道

603
00:28:10,000 --> 00:28:14,000
第二它飞的时候其实不是非常的灵活

604
00:28:16,000 --> 00:28:19,000
第三就是能耗非常高

605
00:28:19,000 --> 00:28:21,000
但是如果 Mr.Fusion 出现的话

606
00:28:21,000 --> 00:28:22,000
能耗不是问题

607
00:28:22,000 --> 00:28:25,000
但最大问题是我们想要的飞车

608
00:28:25,000 --> 00:28:27,000
其实是像 back to the future 里面那样

609
00:28:27,000 --> 00:28:28,000
只需要把四个轮子朝下

610
00:28:28,000 --> 00:28:31,000
然后就可以直接悬浮起来的飞车

611
00:28:31,000 --> 00:28:33,000
或者像什么第五元素里面那种飞车

612
00:28:33,000 --> 00:28:34,000
那才是真正实用的飞车

613
00:28:34,000 --> 00:28:35,000
对吧

614
00:28:36,000 --> 00:28:38,000
这样的飞车解决了一个什么样的问题

615
00:28:38,000 --> 00:28:39,000
就是你不再需要坐飞机了

616
00:28:39,000 --> 00:28:43,000
你不再需要坐月阳飞机了

617
00:28:43,000 --> 00:28:47,000
就是点对点的直线交通

618
00:28:47,000 --> 00:28:48,000
变得非常的简单

619
00:28:50,000 --> 00:28:51,000
单一模式化

620
00:28:51,000 --> 00:28:53,000
就是比如说在 back to the future 里面

621
00:28:53,000 --> 00:28:55,000
他们里面设想说整个美洲

622
00:28:55,000 --> 00:28:58,000
乃至于跨州的航路

623
00:28:59,000 --> 00:29:04,000
就得像高速公路一样是已经预先化好了

624
00:29:04,000 --> 00:29:06,000
比如说如果你想从中国到美国的话

625
00:29:06,000 --> 00:29:09,000
你只要开上自己的飞车

626
00:29:09,000 --> 00:29:11,000
从自己家的门前出发

627
00:29:11,000 --> 00:29:13,000
然后飞到高速公路上

628
00:29:13,000 --> 00:29:15,000
然后就沿着

629
00:29:15,000 --> 00:29:16,000
我相信一定有什么导航技术

630
00:29:16,000 --> 00:29:18,000
就是你只要坐在车里面

631
00:29:18,000 --> 00:29:19,000
然后倒

632
00:29:19,000 --> 00:29:23,000
这个车就会把你带到你在美国要去的那个地方的路旁

633
00:29:23,000 --> 00:29:25,000
这是一个非常点对点的服务

634
00:29:25,000 --> 00:29:30,000
就是不像现在我们需要先从家里面坐车到机场

635
00:29:30,000 --> 00:29:31,000
然后拖越行列

636
00:29:31,000 --> 00:29:31,000
然后拆 Key

637
00:29:31,000 --> 00:29:32,000
然后过安检

638
00:29:32,000 --> 00:29:33,000
然后不拉

639
00:29:33,000 --> 00:29:37,000
跟几百个不知道是不是恐怖分子的人坐在一起

640
00:29:37,000 --> 00:29:39,000
然后把自己的生命交在机场上

641
00:29:40,000 --> 00:29:41,000
如果有飞车的话

642
00:29:41,000 --> 00:29:42,000
这一切都不需要了

643
00:29:42,000 --> 00:29:49,000
我们可以单独的坐在属于自己一个封闭空间里面

644
00:29:49,000 --> 00:29:51,000
自己想带什么就带什么

645
00:29:51,000 --> 00:29:52,000
想带多少带多少成绩

646
00:29:52,000 --> 00:29:53,000
这样你能

647
00:29:53,000 --> 00:29:57,000
如果有 Mr.Fusion 的话能源不是问题

648
00:29:58,000 --> 00:30:00,000
就这样的技术带给我们的自由度

649
00:30:00,000 --> 00:30:05,000
其实是要远远高于飞机或者是现有的任何交通

650
00:30:05,000 --> 00:30:06,000
对

651
00:30:06,000 --> 00:30:10,000
所以我觉得飞车仍旧是一个非常重要值得梦想的事情

652
00:30:10,000 --> 00:30:12,000
不过有生之年应该是看不到的

653
00:30:12,000 --> 00:30:12,000
我觉得

654
00:30:14,000 --> 00:30:17,000
而且更不用提在 Back to the Future 里面

655
00:30:17,000 --> 00:30:19,000
主角其实

656
00:30:19,000 --> 00:30:19,000
不是主角

657
00:30:19,000 --> 00:30:23,000
就是未来 2015 年其实根本就没有不小飞车

658
00:30:23,000 --> 00:30:25,000
而是所谓的飞车改装服务

659
00:30:25,000 --> 00:30:27,000
就是你只要装四个轮子

660
00:30:27,000 --> 00:30:29,000
就可以让自己的车飞起来

661
00:30:30,000 --> 00:30:32,000
就永远不是像现在这样

662
00:30:32,000 --> 00:30:35,000
你需要把整个车构造作改了

663
00:30:36,000 --> 00:30:37,000
OK

664
00:30:38,000 --> 00:30:39,000
在进入主题之前

665
00:30:39,000 --> 00:30:41,000
为了填充节目时间

666
00:30:41,000 --> 00:30:45,000
我们先来讨论一下计算机的编码

667
00:30:45,000 --> 00:30:48,000
这是一个压箱底的话题

668
00:30:48,000 --> 00:30:48,000
对

669
00:30:48,000 --> 00:30:50,000
就是为了专门应付今天这种

670
00:30:52,000 --> 00:30:53,000
为了保证节目不断挡

671
00:30:53,000 --> 00:30:58,000
但是又有可能有人缺席的情况准备的

672
00:30:58,000 --> 00:30:59,000
编码

673
00:30:59,000 --> 00:31:00,000
或者说 Encoding

674
00:31:01,000 --> 00:31:03,000
是一个非常常见的时候非常复杂的概念

675
00:31:03,000 --> 00:31:06,000
首先 Encoding 和 Coding 是不一样的

676
00:31:06,000 --> 00:31:13,000
我们口语们应该会用写代码来指代写程序这件事

677
00:31:13,000 --> 00:31:18,000
但是有时候人们也会口误或者说无心的说编码

678
00:31:19,000 --> 00:31:22,000
来用编码这个词来指代写程序

679
00:31:22,000 --> 00:31:24,000
但是像编码在比较

680
00:31:24,000 --> 00:31:27,000
当你比较严格的区分自己的措辞的时候

681
00:31:27,000 --> 00:31:29,000
编码指的是 Encoding

682
00:31:29,000 --> 00:31:32,000
Encoding 是一个非常常见的时候非常复杂的概念

683
00:31:32,000 --> 00:31:35,000
常见是因为美食美口

684
00:31:35,000 --> 00:31:36,000
我们美食美食跟它的接触

685
00:31:36,000 --> 00:31:40,000
尤其是如果要 Coding 的话

686
00:31:40,000 --> 00:31:42,000
几乎完全是绕不开 Encoding 的

687
00:31:42,000 --> 00:31:45,000
尤其是如果你不是一个专制的成员

688
00:31:45,000 --> 00:31:46,000
你可以不懂算法

689
00:31:46,000 --> 00:31:47,000
可以不懂数学结构

690
00:31:47,000 --> 00:31:49,000
比如说你是一个搞 Wab 的

691
00:31:49,000 --> 00:31:51,000
可能 Sorry

692
00:31:51,000 --> 00:31:52,000
我又黑 Wab

693
00:31:52,000 --> 00:31:54,000
你是一个搞 Wab 前端的

694
00:31:55,000 --> 00:31:57,000
你可能完全不需要去接触算法

695
00:31:57,000 --> 00:31:58,000
或者数学结构

696
00:31:58,000 --> 00:31:59,000
你招呼也可以获得很好

697
00:31:59,000 --> 00:32:03,000
但是 Encoding 这个问题你是没有可能绕开的

698
00:32:03,000 --> 00:32:06,000
如果你像回避算法和数学结构一样

699
00:32:06,000 --> 00:32:07,000
去回避 Coding

700
00:32:07,000 --> 00:32:09,000
很有可能会衰得很惨

701
00:32:12,000 --> 00:32:14,000
而即便是不写程序的人

702
00:32:14,000 --> 00:32:16,000
懂一些 Encoding 也是一个

703
00:32:16,000 --> 00:32:18,000
也是件非常有意义的事情

704
00:32:18,000 --> 00:32:21,000
比如说我记得很久一天

705
00:32:21,000 --> 00:32:23,000
大概是天的

706
00:32:23,000 --> 00:32:25,000
那个时候我还在读也留生

707
00:32:26,000 --> 00:32:27,000
那个时候有一个网站

708
00:32:27,000 --> 00:32:28,000
现在有

709
00:32:28,000 --> 00:32:29,000
这个网站

710
00:32:29,000 --> 00:32:32,000
叫做 DailyWTF

711
00:32:32,000 --> 00:32:35,000
当然它的官方名字叫做 DailyWorstandFailure

712
00:32:35,000 --> 00:32:37,000
但是我们都知道 WTF 是什么意思

713
00:32:37,000 --> 00:32:39,000
然后在这个网站上面有这样一则

714
00:32:39,000 --> 00:32:44,000
当时应该是一堆图片新闻里面的一条

715
00:32:44,000 --> 00:32:47,000
我记得是有人拍了一个包裹单

716
00:32:47,000 --> 00:32:49,000
这个包裹单是贴在一个包裹上面的

717
00:32:49,000 --> 00:32:51,000
然后这个包裹是寄给德国某个地址的

718
00:32:51,000 --> 00:32:55,000
这个地址里面有一个地方被寄件人

719
00:32:55,000 --> 00:32:57,000
化成了一个方块

720
00:32:57,000 --> 00:33:03,000
比如说有一个德国的地址叫做 GR 方块

721
00:33:03,000 --> 00:33:04,000
然后 blahblah

722
00:33:04,000 --> 00:33:05,000
STR

723
00:33:05,000 --> 00:33:07,000
然后多少少好

724
00:33:07,000 --> 00:33:08,000
原因是什么呢

725
00:33:08,000 --> 00:33:09,000
就是这个人

726
00:33:09,000 --> 00:33:12,000
他显然在显示德国的地址的时候

727
00:33:12,000 --> 00:33:17,000
没能正确的把 O 上加两点

728
00:33:17,000 --> 00:33:18,000
就是 Oumlaut

729
00:33:18,000 --> 00:33:20,000
这个字母显示出来

730
00:33:20,000 --> 00:33:23,000
它的自然系统就把那个地方显示成了一个方块

731
00:33:23,000 --> 00:33:26,000
然后就非常忠诚地在那个地方画了一个方块

732
00:33:26,000 --> 00:33:29,000
如果这位寄件人懂得 encolling 的知识的话

733
00:33:29,000 --> 00:33:33,000
这样的笑话就不会发生了

734
00:33:33,000 --> 00:33:37,000
另外比如说有时候各位在看网页的时候

735
00:33:37,000 --> 00:33:38,000
会发现网页上面有问号

736
00:33:38,000 --> 00:33:42,000
或者是问我们奇妙的一些符号

737
00:33:42,000 --> 00:33:44,000
我们会说这时候有论坛

738
00:33:44,000 --> 00:33:46,000
那这时候应该怎么解决呢

739
00:33:46,000 --> 00:33:50,000
知道的人可能会去

740
00:33:50,000 --> 00:33:51,000
我忘了 chrome 是在哪了

741
00:33:51,000 --> 00:33:53,000
chrome 好像是在 tooth 里面

742
00:33:53,000 --> 00:33:53,000
对

743
00:33:53,000 --> 00:33:55,000
你要去一个地方选择

744
00:33:55,000 --> 00:33:56,000
你要说

745
00:33:56,000 --> 00:34:00,000
这个网页是用什么样的 encolling 来

746
00:34:00,000 --> 00:34:02,000
encolling 的

747
00:34:02,000 --> 00:34:03,000
来

748
00:34:03,000 --> 00:34:06,000
这个网页是用什么标准来 encolling 的

749
00:34:06,000 --> 00:34:08,000
你选对那个标准

750
00:34:08,000 --> 00:34:12,000
然后你就可以看到准确的误会信息了

751
00:34:12,000 --> 00:34:19,000
又比如以前我们玩一些很有意思的日文游戏的时候

752
00:34:19,000 --> 00:34:22,000
为什么在简体中文操作训文的人跑起来乱马

753
00:34:22,000 --> 00:34:24,000
对

754
00:34:24,000 --> 00:34:28,000
这一切的原因其实都是 encolling

755
00:34:28,000 --> 00:34:31,000
那为什么会有 encolling 的问题呢

756
00:34:31,000 --> 00:34:33,000
答案是因为二进制

757
00:34:33,000 --> 00:34:38,000
也就是所谓计算机是一个二进制的东西

758
00:34:38,000 --> 00:34:41,000
这句话我们多多少少都听过

759
00:34:41,000 --> 00:34:42,000
但是

760
00:34:42,000 --> 00:34:47,000
比如说我们都明白计算机在内部只懂得零和一

761
00:34:47,000 --> 00:34:50,000
具体来说就是芯片上面有一个地方是高电瓶

762
00:34:50,000 --> 00:34:51,000
它就是一

763
00:34:51,000 --> 00:34:52,000
低电瓶就是零

764
00:34:52,000 --> 00:34:58,000
然后磁盘上面有一地方比如说它的北磁机朝上就是一

765
00:34:58,000 --> 00:34:59,000
北磁机朝下就是零

766
00:34:59,000 --> 00:35:01,000
我不确定这个说法这么正确

767
00:35:01,000 --> 00:35:02,000
是代磁是一

768
00:35:02,000 --> 00:35:03,000
不代磁是零

769
00:35:03,000 --> 00:35:04,000
还是北磁机是一

770
00:35:04,000 --> 00:35:05,000
南磁机是零

771
00:35:07,000 --> 00:35:07,000
对

772
00:35:07,000 --> 00:35:09,000
欢迎大家指正

773
00:35:09,000 --> 00:35:12,000
然后比如说光盘上面有坑就是一

774
00:35:12,000 --> 00:35:12,000
没坑就是零

775
00:35:12,000 --> 00:35:13,000
这么次

776
00:35:15,000 --> 00:35:15,000
然后

777
00:35:17,000 --> 00:35:18,000
反过来

778
00:35:18,000 --> 00:35:19,000
平时使用电脑的时候

779
00:35:19,000 --> 00:35:22,000
你跟我去明明没有直接在跟零和一打交道

780
00:35:22,000 --> 00:35:23,000
不是吗

781
00:35:23,000 --> 00:35:25,000
我们能比如说我们能看到文字

782
00:35:25,000 --> 00:35:26,000
我们能听到声音

783
00:35:26,000 --> 00:35:28,000
比如说各位现在听个 podcast

784
00:35:30,000 --> 00:35:34,000
我们能看到图片以及一些高雅的小电影

785
00:35:35,000 --> 00:35:37,000
这些东西都不是零和一

786
00:35:37,000 --> 00:35:38,000
不是吗

787
00:35:38,000 --> 00:35:40,000
就是在我们的观感来说

788
00:35:40,000 --> 00:35:44,000
这些东西都是切切实实的一些模拟信号

789
00:35:44,000 --> 00:35:45,000
不是

790
00:35:45,000 --> 00:35:47,000
那么具体来讲的那些零和一在哪呢

791
00:35:51,000 --> 00:35:53,000
这个就要扯到比较

792
00:35:54,000 --> 00:35:55,000
古早的历史

793
00:35:55,000 --> 00:36:00,000
才能让大家有一个比较清晰的认识

794
00:36:00,000 --> 00:36:02,000
来自于包括程序本身

795
00:36:02,000 --> 00:36:04,000
其实也都是零和一

796
00:36:04,000 --> 00:36:07,000
但是写过程序的各位都知道

797
00:36:07,000 --> 00:36:08,000
我们写程序的时候

798
00:36:08,000 --> 00:36:10,000
并不是直接写下零和一

799
00:36:10,000 --> 00:36:12,000
以下内容部分摘字

800
00:36:12,000 --> 00:36:13,000
我在中枫上的一个答案

801
00:36:13,000 --> 00:36:15,000
所以如果各位读过的话

802
00:36:15,000 --> 00:36:17,000
基本上就可以跳过了

803
00:36:17,000 --> 00:36:20,000
就可以直接拉到最后来听本期的主题

804
00:36:20,000 --> 00:36:21,000
就是

805
00:36:22,000 --> 00:36:24,000
程序完这样泡的女朋友

806
00:36:24,000 --> 00:36:26,000
用泡这次是不太正确的

807
00:36:26,000 --> 00:36:28,000
首先要抛弃泡的概念

808
00:36:28,000 --> 00:36:29,000
Anyway

809
00:36:29,000 --> 00:36:33,000
在计算机还都是一些旁人大物的实际时代

810
00:36:33,000 --> 00:36:34,000
我们写程序是靠机器远

811
00:36:35,000 --> 00:36:38,000
虽然名字叫做机器语言

812
00:36:38,000 --> 00:36:41,000
但实际上用到的只有两个数字而已

813
00:36:41,000 --> 00:36:42,000
就是零和一

814
00:36:43,000 --> 00:36:46,000
当然前提是你不去考虑三进值计算机

815
00:36:46,000 --> 00:36:47,000
对

816
00:36:47,000 --> 00:36:50,000
三进值计算机实际上是一个非常有意思的话题

817
00:36:51,000 --> 00:36:54,000
正确来说是平衡三进值计算机

818
00:36:55,000 --> 00:36:55,000
就是

819
00:36:57,000 --> 00:36:59,000
各位应该可以比较容易的想象

820
00:36:59,000 --> 00:37:00,000
什么是三进值

821
00:37:00,000 --> 00:37:01,000
就是纯粹的三进值

822
00:37:02,000 --> 00:37:05,000
只用零一二的三个数字

823
00:37:06,000 --> 00:37:09,000
零是零一是一二十二三是一零

824
00:37:09,000 --> 00:37:10,000
对吧

825
00:37:10,000 --> 00:37:12,000
什么是平衡三进值的

826
00:37:12,000 --> 00:37:14,000
平衡三进值是说

827
00:37:15,000 --> 00:37:20,000
用一零和负一这三个数字

828
00:37:20,000 --> 00:37:24,000
来代表一切数字

829
00:37:24,000 --> 00:37:26,000
来组合成为一切数字

830
00:37:26,000 --> 00:37:27,000
也就是说在每一个

831
00:37:27,000 --> 00:37:28,000
比如说在各位上是零

832
00:37:28,000 --> 00:37:29,000
就是零

833
00:37:29,000 --> 00:37:31,000
然后在各位上是一就是一

834
00:37:31,000 --> 00:37:33,000
在各位上是负一

835
00:37:33,000 --> 00:37:34,000
就是负一

836
00:37:34,000 --> 00:37:36,000
二怎么表示呢

837
00:37:36,000 --> 00:37:36,000
很有意思

838
00:37:36,000 --> 00:37:38,000
因为一零的话

839
00:37:38,000 --> 00:37:45,000
在平衡三进值里面是代表三

840
00:37:45,000 --> 00:37:48,000
所以如果你要想要凑出一个二来的话

841
00:37:48,000 --> 00:37:54,000
你必须先在各位上面写上一个负一

842
00:37:54,000 --> 00:37:57,000
也就是平衡三进值的零是零

843
00:37:57,000 --> 00:37:58,000
一是一

844
00:37:58,000 --> 00:38:01,000
二则是一负一

845
00:38:01,000 --> 00:38:05,000
就是平衡三进值里面通常会把负一这个数字写成 T

846
00:38:05,000 --> 00:38:08,000
也就是二会变成一 T

847
00:38:09,000 --> 00:38:11,000
写成 T 是因为负号

848
00:38:11,000 --> 00:38:12,000
如果你把负号放在一上面的话

849
00:38:12,000 --> 00:38:14,000
它就看着下一个 T

850
00:38:15,000 --> 00:38:15,000
对

851
00:38:15,000 --> 00:38:18,000
这是一个非常特别

852
00:38:18,000 --> 00:38:21,000
但是对于计算机来说

853
00:38:21,000 --> 00:38:24,000
比较好实现的一种进制方法

854
00:38:24,000 --> 00:38:27,000
就是如果你维持一个中等电位的话

855
00:38:27,000 --> 00:38:28,000
它是零

856
00:38:28,000 --> 00:38:30,000
一个比较高的电位的话是一

857
00:38:30,000 --> 00:38:33,000
然后一个比较低的电位的话是负一

858
00:38:34,000 --> 00:38:38,000
平衡三进值有一些比较特别的数学特性

859
00:38:38,000 --> 00:38:40,000
比如说在平衡三进值里面

860
00:38:40,000 --> 00:38:43,000
有时候一些数字的表示方法有两个

861
00:38:44,000 --> 00:38:48,000
比如说二分之一可以表示为 0.1 无线循环

862
00:38:48,000 --> 00:38:51,000
或者是 1.负一无线循环

863
00:38:52,000 --> 00:38:57,000
然后有时候也会有一些比较特别的特性

864
00:38:57,000 --> 00:38:58,000
比如说在惩罚的时候

865
00:38:58,000 --> 00:39:01,000
有时候你会明明是两个多位数相乘

866
00:39:01,000 --> 00:39:04,000
最后你得出的结果的位数

867
00:39:04,000 --> 00:39:06,000
反而要比两个

868
00:39:06,000 --> 00:39:10,000
原来你用来乘的两个数字的位数要短

869
00:39:12,000 --> 00:39:13,000
对

870
00:39:13,000 --> 00:39:17,000
但是三进值相机最终是没有能乘气

871
00:39:17,000 --> 00:39:21,000
我相信如果三体人或者是

872
00:39:22,000 --> 00:39:24,000
比较正儿八经的科幻里面

873
00:39:24,000 --> 00:39:27,000
就有一部科幻叫做与辣马相会

874
00:39:27,000 --> 00:39:28,000
如果各位没有看过的话

875
00:39:28,000 --> 00:39:29,000
非常欢迎去看一看

876
00:39:29,000 --> 00:39:32,000
要比三体不知道高的哪里去了

877
00:39:34,000 --> 00:39:36,000
也许三体人会使用三进值相机

878
00:39:39,000 --> 00:39:43,000
但是在我们地球上面目前占主流的

879
00:39:43,000 --> 00:39:48,000
绝对主流的亚拉松手脑是二进值自然机

880
00:39:48,000 --> 00:39:51,000
所以早期的写成序

881
00:39:51,000 --> 00:39:55,000
也就是使用特定的二进值的组合

882
00:39:56,000 --> 00:39:57,000
来给计算机下命令

883
00:39:57,000 --> 00:40:00,000
因为一些特定的数字组合

884
00:40:00,000 --> 00:40:02,000
对于计算机来说有推动的意义

885
00:40:02,000 --> 00:40:05,000
会让计算机做出一些特定的动作

886
00:40:06,000 --> 00:40:11,000
其实我们甚至不应该教这些二进值的数字数字

887
00:40:11,000 --> 00:40:13,000
因为他们其实并不代表任何数量

888
00:40:14,000 --> 00:40:17,000
他们所代表的只是一种模式

889
00:40:17,000 --> 00:40:17,000
对

890
00:40:17,000 --> 00:40:18,000
这是一个什么概念的

891
00:40:19,000 --> 00:40:21,000
各位可以想象一台钢琴

892
00:40:21,000 --> 00:40:23,000
假设在钢琴上所有的键都被拉平了

893
00:40:23,000 --> 00:40:27,000
就是它的黑键不是欠在白键之间

894
00:40:28,000 --> 00:40:30,000
而是很简单的

895
00:40:30,000 --> 00:40:33,000
到人民发售了稀道加上中间所有的半音

896
00:40:33,000 --> 00:40:35,000
这样拉在一个指线上

897
00:40:36,000 --> 00:40:38,000
我们可以这样描述怎样弹钢琴

898
00:40:38,000 --> 00:40:42,000
就是每次把按下去的钢琴记录 1

899
00:40:42,000 --> 00:40:45,000
没有按下去的钢琴记录 0

900
00:40:45,000 --> 00:40:50,000
然后我们可以在每一个时刻得到一系列的 1 和 0

901
00:40:50,000 --> 00:40:56,000
这些 1 和 0 你可以把它换算成一个实境的数字

902
00:40:56,000 --> 00:40:58,000
但是本质上它只是一种

903
00:40:58,000 --> 00:41:03,000
它只是代表这个按下钢琴的状态

904
00:41:03,000 --> 00:41:05,000
我们在使用 CPU 的时候

905
00:41:06,000 --> 00:41:10,000
情况跟钢琴是类似的

906
00:41:10,000 --> 00:41:15,000
就是我们把一个 01,01,01 这样的指令

907
00:41:15,000 --> 00:41:18,000
输入一小块芯片的时候

908
00:41:18,000 --> 00:41:19,000
真实做的事情

909
00:41:19,000 --> 00:41:25,000
其实是在芯片上面的不同引脚上面输入高或者低的电压

910
00:41:25,000 --> 00:41:32,000
然后芯片里面会有很多坨小小的晶体管组成的小装置

911
00:41:33,000 --> 00:41:34,000
被我们按下了

912
00:41:35,000 --> 00:41:43,000
然后这个组合会进而引发更多的由芯片工程师预先设计的一系列的连锁反应

913
00:41:44,000 --> 00:41:51,000
然后无数这样的模式数字一个接一个被输入芯片里面

914
00:41:51,000 --> 00:41:55,000
最终屏幕上就会出现一些能够被人理解的图案

915
00:41:55,000 --> 00:41:59,000
然后给计算机输入这种相当于命令的数字

916
00:41:59,000 --> 00:42:02,000
称作指令的东西

917
00:42:02,000 --> 00:42:04,000
让它来做一些事情

918
00:42:04,000 --> 00:42:08,000
包括但不限于处理其他那些数字

919
00:42:09,000 --> 00:42:11,000
其实就是编程的本质活动

920
00:42:12,000 --> 00:42:15,000
比如说它古早的计算机叫做 Cosmic Elf

921
00:42:15,000 --> 00:42:18,000
它的面板上有一排开关

922
00:42:18,000 --> 00:42:21,000
应该是有 8 个还是 10 个开关

923
00:42:21,000 --> 00:42:23,000
这些开关可以播上或者播下

924
00:42:23,000 --> 00:42:27,000
那给这台计算机编程的方法就是

925
00:42:27,000 --> 00:42:32,000
把你想要输入的数字或者说把你想要按下的勤件

926
00:42:35,000 --> 00:42:37,000
在这排开关上面搬好

927
00:42:38,000 --> 00:42:39,000
比如说搬上就是上

928
00:42:39,000 --> 00:42:41,000
搬上就是 1

929
00:42:41,000 --> 00:42:42,000
搬下就是 0

930
00:42:42,000 --> 00:42:44,000
搬好一排之后你按一下右上角

931
00:42:44,000 --> 00:42:45,000
它有一个按钮

932
00:42:46,000 --> 00:42:49,000
你就可以输入下一条指令

933
00:42:49,000 --> 00:42:52,000
这就好像你在怎么说的

934
00:42:52,000 --> 00:42:54,000
有那种早期的打孔钢琴

935
00:42:56,000 --> 00:43:00,000
你输入一条上面布满了小雅的指带

936
00:43:00,000 --> 00:43:03,000
每一个雅都代表这个地方

937
00:43:03,000 --> 00:43:05,000
应该有个勤件没按下去

938
00:43:06,000 --> 00:43:10,000
给这台计算机编程的过程就有点像你在手工去钻一个指带

939
00:43:10,000 --> 00:43:11,000
对

940
00:43:11,000 --> 00:43:14,000
或者你在手工做一个 8 英合

941
00:43:14,000 --> 00:43:17,000
如果你看过 8 英合是怎么工作的话

942
00:43:17,000 --> 00:43:18,000
你一定明白我的什么意思

943
00:43:18,000 --> 00:43:23,000
问题在于就是你在这台计算机上面输入一系列零和一

944
00:43:23,000 --> 00:43:26,000
和在那台计算机上面输入一系列零和一

945
00:43:26,000 --> 00:43:28,000
你得到的反应可能是完全不一样的

946
00:43:29,000 --> 00:43:34,000
这是从最开始就有一个差异的

947
00:43:35,000 --> 00:43:36,000
问题

948
00:43:36,000 --> 00:43:37,000
对

949
00:43:37,000 --> 00:43:41,000
因为各个各家计算机厂商会自己去研发自己的芯片

950
00:43:41,000 --> 00:43:45,000
同样那种数字对于不同型号的计算机来说

951
00:43:45,000 --> 00:43:47,000
有可能是完全代表不同的指令

952
00:43:47,000 --> 00:43:49,000
这一点直到今天都没有改变

953
00:43:50,000 --> 00:43:54,000
那些通过金属银脚受到零和一数的 CPU

954
00:43:54,000 --> 00:43:57,000
所谓有这样一个指令级的概念

955
00:43:57,000 --> 00:44:03,000
本质上指令级其实就是由芯片制造厂商给出的数字组合的定义

956
00:44:03,000 --> 00:44:03,000
对

957
00:44:03,000 --> 00:44:06,000
如果你去查什么 AMD 或者是 intel 的手册的话

958
00:44:06,000 --> 00:44:11,000
你会发现他们的指令级里面

959
00:44:11,000 --> 00:44:14,000
会给出一组数字

960
00:44:14,000 --> 00:44:22,000
这组数字其实就是真正的 CPU 所会接触到的那些高低电平组

961
00:44:22,000 --> 00:44:23,000
对

962
00:44:25,000 --> 00:44:27,000
由于芯片设计结构不同

963
00:44:27,000 --> 00:44:29,000
每种芯片的指令级也就不同

964
00:44:29,000 --> 00:44:32,000
比如常见于台式计算机的 intel 芯片指令级

965
00:44:32,000 --> 00:44:36,000
就与常见于手持设备的 ARM 芯片的设定级不一样

966
00:44:37,000 --> 00:44:42,000
计算机语言在这个层面开始就已经产生了区别

967
00:44:43,000 --> 00:44:49,000
不过用纯数字的计算机语言编程的难度可笑而知

968
00:44:49,000 --> 00:44:54,000
所以从数字到数据符号的转移很快就随时出现了

969
00:44:54,000 --> 00:44:56,000
我们把这个东西叫做绘编语言

970
00:44:56,000 --> 00:45:04,000
比如说一组数字 001000 可以让芯片把内部的一个存储单位

971
00:45:05,000 --> 00:45:10,000
我们叫它存储计存计 x 加上一个值 y

972
00:45:10,000 --> 00:45:14,000
那么不妨就把这组数字和助计符 add 对应起来

973
00:45:14,000 --> 00:45:18,000
比如说上面的指令就可以写成 addx 都好 y

974
00:45:18,000 --> 00:45:21,000
这样一条条类似的指令写成一串

975
00:45:21,000 --> 00:45:23,000
就是一个对于程序的描述

976
00:45:23,000 --> 00:45:24,000
对吧

977
00:45:24,000 --> 00:45:25,000
相对于纯数字来说

978
00:45:25,000 --> 00:45:27,000
这是一个质的肺炎

979
00:45:27,000 --> 00:45:31,000
因为你终于不用去手动搬开关了

980
00:45:31,000 --> 00:45:32,000
不是吧

981
00:45:33,000 --> 00:45:39,000
然后这样的一串字符就是这些 add xy

982
00:45:40,000 --> 00:45:46,000
或者是 move xy 这样的字符创

983
00:45:46,000 --> 00:45:51,000
可以由专门的小程序来翻译成那些 001 的二进之代

984
00:45:51,000 --> 00:45:55,000
也就是真正可以被输入处理区

985
00:45:55,000 --> 00:46:01,000
去按下那些经体管的开关的电子信号

986
00:46:01,000 --> 00:46:03,000
当然每一种处理器的会员员都是不一样的

987
00:46:05,000 --> 00:46:08,000
机器员或者说会员员的优点是

988
00:46:08,000 --> 00:46:11,000
每一条指令几乎都对应于芯片能做的一件事情

989
00:46:11,000 --> 00:46:16,000
比如说有一条指令可以把一个数字从内存里面转到计算器里面

990
00:46:16,000 --> 00:46:21,000
另一条指令可以把这个被转入计算器的值加上 1

991
00:46:21,000 --> 00:46:24,000
第三条指令又把它放回内存去

992
00:46:26,000 --> 00:46:29,000
直接对一块芯片下命令效率非常高

993
00:46:29,000 --> 00:46:31,000
但是对应的缺点就是

994
00:46:31,000 --> 00:46:33,000
如果你只是想要把一个数字加上 1 的话

995
00:46:33,000 --> 00:46:36,000
每次都要写三条指令

996
00:46:36,000 --> 00:46:39,000
时间一长是非常痛苦的一件事

997
00:46:39,000 --> 00:46:41,000
而且还有一个问题就是

998
00:46:41,000 --> 00:46:44,000
因为不同的芯片所支持的指令机是不一样的

999
00:46:44,000 --> 00:46:49,000
也就意味着你在这一块芯片上需要三条指令能完成的事情

1000
00:46:49,000 --> 00:46:51,000
在另外一块芯片上可能需要五条指令

1001
00:46:53,000 --> 00:46:58,000
所以如果我们能够将一部分固定出现的操作

1002
00:46:58,000 --> 00:47:00,000
像连续计一样的一次性施放

1003
00:47:00,000 --> 00:47:03,000
每次主要打一个指令

1004
00:47:03,000 --> 00:47:07,000
却能够在不同结构的芯片上都做同样的事情该有多好

1005
00:47:07,000 --> 00:47:08,000
换句话说

1006
00:47:08,000 --> 00:47:12,000
如果能有一种更倾向于描述那些需要解决的问题

1007
00:47:12,000 --> 00:47:15,000
比如说给一个数字加上 1

1008
00:47:15,000 --> 00:47:18,000
而不是手把手的高级计划机说

1009
00:47:18,000 --> 00:47:20,000
你读一个数字加上一个数字

1010
00:47:20,000 --> 00:47:22,000
再写一个数字

1011
00:47:22,000 --> 00:47:24,000
有这样一种比较高级的语言

1012
00:47:24,000 --> 00:47:28,000
来封周这些比较不需要我们去操心的细节

1013
00:47:31,000 --> 00:47:32,000
该有多好

1014
00:47:32,000 --> 00:47:33,000
对吧

1015
00:47:33,000 --> 00:47:35,000
然后所谓的高级语言

1016
00:47:35,000 --> 00:47:38,000
就是各位学员成的时候学到的那种语言

1017
00:47:38,000 --> 00:47:39,000
就是做这件事

1018
00:47:39,000 --> 00:47:42,000
比如说最古老的高级语言有 Fortune

1019
00:47:42,000 --> 00:47:44,000
还有 Algo

1020
00:47:44,000 --> 00:47:44,000
Cobo

1021
00:47:47,000 --> 00:47:49,000
乃至于比较同样古老

1022
00:47:49,000 --> 00:47:51,000
但是来源久远的 Lisp

1023
00:47:51,000 --> 00:47:54,000
我觉得我们应该专门找一期来说 Lisp

1024
00:47:54,000 --> 00:47:55,000
所有这些语言呢

1025
00:47:55,000 --> 00:47:59,000
他们都会最终被抓坏二进一的形式

1026
00:48:01,000 --> 00:48:03,000
包括现在大家比较喜欢的动态员

1027
00:48:03,000 --> 00:48:06,000
比如说 Python

1028
00:48:06,000 --> 00:48:08,000
Ruby

1029
00:48:08,000 --> 00:48:09,000
Luo

1030
00:48:09,000 --> 00:48:15,000
他们归根结理都是会被转化为二进之代码

1031
00:48:15,000 --> 00:48:17,000
输入到 CPU 执行

1032
00:48:17,000 --> 00:48:21,000
他们和这个比较低端的或者说比较原始的原

1033
00:48:21,000 --> 00:48:22,000
比如说 C

1034
00:48:22,000 --> 00:48:24,000
或者是 Fortune 的区别就在于他们

1035
00:48:25,000 --> 00:48:27,000
单一条指定里面

1036
00:48:27,000 --> 00:48:29,000
所

1037
00:48:29,000 --> 00:48:33,000
包括所涵干的这些二进之指令要多很多

1038
00:48:34,000 --> 00:48:39,000
然后他们完成这件这个特点的手段

1039
00:48:39,000 --> 00:48:40,000
就是

1040
00:48:40,000 --> 00:48:42,000
他们的底层

1041
00:48:42,000 --> 00:48:46,000
其实又是利用你的实体 CPU

1042
00:48:46,000 --> 00:48:47,000
去模拟一个

1043
00:48:49,000 --> 00:48:51,000
只在逻辑意义上存在的

1044
00:48:51,000 --> 00:48:52,000
虚拟的 CPU

1045
00:48:54,000 --> 00:48:54,000
对

1046
00:48:54,000 --> 00:48:56,000
这个就不展开讲了

1047
00:48:56,000 --> 00:49:00,000
就有进去的同学可以自己去找一些

1048
00:49:00,000 --> 00:49:01,000
这个方面的书看

1049
00:49:01,000 --> 00:49:03,000
我会推荐一本去扣的

1050
00:49:03,000 --> 00:49:05,000
我相信之前我已经扣的过

1051
00:49:05,000 --> 00:49:06,000
我已经推荐过

1052
00:49:06,000 --> 00:49:07,000
Sorry

1053
00:49:07,000 --> 00:49:10,000
可能是在某一期的 IT 公路上面

1054
00:49:10,000 --> 00:49:12,000
我说这本书是奇书

1055
00:49:12,000 --> 00:49:12,000
对

1056
00:49:12,000 --> 00:49:13,000
推荐拿着去看一看

1057
00:49:16,000 --> 00:49:20,000
以上大概讲了这个编程语言是怎么样

1058
00:49:21,000 --> 00:49:24,000
利用零和一

1059
00:49:24,000 --> 00:49:27,000
或者说编程语言是怎样抓换零和一

1060
00:49:27,000 --> 00:49:30,000
但是真正就没有解释我们一开始提出的问题

1061
00:49:31,000 --> 00:49:33,000
我们看到的图像

1062
00:49:33,000 --> 00:49:36,000
看到的文字是怎样抓换零和一的

1063
00:49:38,000 --> 00:49:39,000
其实道理是类似的

1064
00:49:40,000 --> 00:49:42,000
我们约定说

1065
00:49:42,000 --> 00:49:44,000
在计算机里面

1066
00:49:44,000 --> 00:49:47,000
某一些特定的零和一的组合

1067
00:49:47,000 --> 00:49:49,000
代表一个特定的数字

1068
00:49:49,000 --> 00:49:51,000
或者代表一个特定的制服

1069
00:49:51,000 --> 00:49:53,000
或者代表一个特定的图像

1070
00:49:53,000 --> 00:49:57,000
以我们最常见的 ASCII

1071
00:49:57,000 --> 00:50:00,000
就是美国国家标准局的代码

1072
00:50:00,000 --> 00:50:03,000
ASCII 代码来看的话

1073
00:50:03,000 --> 00:50:07,000
它的方法是挑出一个七位的

1074
00:50:07,000 --> 00:50:09,000
主义是七位的二人数数字

1075
00:50:09,000 --> 00:50:11,000
反正第一位表成一

1076
00:50:11,000 --> 00:50:12,000
最后一位表成一

1077
00:50:12,000 --> 00:50:17,000
也就是 100001

1078
00:50:19,000 --> 00:50:20,000
这样一个数字

1079
00:50:20,000 --> 00:50:23,000
让它来代表大写字母 A

1080
00:50:23,000 --> 00:50:24,000
对

1081
00:50:24,000 --> 00:50:26,000
然后这个数字被转化成

1082
00:50:26,000 --> 00:50:27,000
实际上就是 65

1083
00:50:28,000 --> 00:50:29,000
然后 65 代表 A

1084
00:50:30,000 --> 00:50:32,000
所以如果你从实际上的角度

1085
00:50:32,000 --> 00:50:34,000
去看这个数字的话

1086
00:50:34,000 --> 00:50:34,000
你会觉得很奇怪

1087
00:50:34,000 --> 00:50:37,000
为什么要用 65 来代表 A 呢

1088
00:50:37,000 --> 00:50:39,000
但是当你把 65 转化成一个

1089
00:50:39,000 --> 00:50:41,000
七位的二人数字的时候

1090
00:50:42,000 --> 00:50:44,000
就会发现它其实是一个

1091
00:50:44,000 --> 00:50:47,000
相对来说比较规律的马点

1092
00:50:47,000 --> 00:50:48,000
比较意义的马点

1093
00:50:49,000 --> 00:50:52,000
所以马点就是一个字符

1094
00:50:52,000 --> 00:50:58,000
相对于它的二进制数字所在的位置

1095
00:50:58,000 --> 00:50:59,000
叫做马点

1096
00:50:59,000 --> 00:51:03,000
那么在 65 这个马点上面是 A

1097
00:51:03,000 --> 00:51:05,000
那么符合逻辑的方式

1098
00:51:05,000 --> 00:51:07,000
就是把 B 放在 66 上

1099
00:51:07,000 --> 00:51:08,000
然后一次也推

1100
00:51:08,000 --> 00:51:09,000
对吧

1101
00:51:09,000 --> 00:51:11,000
大写字母完的时候

1102
00:51:11,000 --> 00:51:12,000
是一对表给符号

1103
00:51:12,000 --> 00:51:13,000
然后是小写字母

1104
00:51:14,000 --> 00:51:17,000
那有一个问题就是

1105
00:51:18,000 --> 00:51:21,000
七位的二进制数字

1106
00:51:21,000 --> 00:51:24,000
可以表示 127 个字符

1107
00:51:25,000 --> 00:51:26,000
对于英语来说是够

1108
00:51:27,000 --> 00:51:29,000
甚至可以表示大写小写

1109
00:51:29,000 --> 00:51:31,000
加上数字等等

1110
00:51:32,000 --> 00:51:33,000
那么为什么要选用七位这个数字

1111
00:51:33,000 --> 00:51:34,000
也是因为

1112
00:51:35,000 --> 00:51:37,000
如果你把第八位也用上的话

1113
00:51:37,000 --> 00:51:40,000
就可以让其他人去定义一些比较

1114
00:51:41,000 --> 00:51:42,000
额外的东西

1115
00:51:42,000 --> 00:51:46,000
比如说西欧元会用到各种各样的

1116
00:51:46,000 --> 00:51:46,000
达尔特克

1117
00:51:46,000 --> 00:51:49,000
就是在字母上面加点

1118
00:51:49,000 --> 00:51:51,000
达铁等等

1119
00:51:51,000 --> 00:51:52,000
诸如此类非常愚蠢的事情

1120
00:51:54,000 --> 00:51:56,000
那么他们所使用的方法就是

1121
00:51:57,000 --> 00:52:00,000
把七位数字困扰到八位

1122
00:52:00,000 --> 00:52:02,000
或者说利用这个

1123
00:52:02,000 --> 00:52:04,000
Azki 编码标准

1124
00:52:04,000 --> 00:52:07,000
刻意将第八位永远设为零的特点

1125
00:52:08,000 --> 00:52:11,000
规定了当第八位变成一的时候

1126
00:52:11,000 --> 00:52:13,000
多出来的那 127 个马点

1127
00:52:14,000 --> 00:52:15,000
应该具体代表什么

1128
00:52:15,000 --> 00:52:17,000
那么在这个标准上

1129
00:52:17,000 --> 00:52:19,000
西欧多了很多自己的字母要人

1130
00:52:19,000 --> 00:52:21,000
美国加的不一样

1131
00:52:22,000 --> 00:52:23,000
然后

1132
00:52:24,000 --> 00:52:24,000
我记得 CJK

1133
00:52:24,000 --> 00:52:25,000
也是

1134
00:52:25,000 --> 00:52:26,000
sorry

1135
00:52:26,000 --> 00:52:27,000
在日本也是

1136
00:52:27,000 --> 00:52:30,000
他们利用着多出来的 127 个马点

1137
00:52:30,000 --> 00:52:31,000
加入了评价名

1138
00:52:31,000 --> 00:52:32,000
骗价名等等

1139
00:52:33,000 --> 00:52:35,000
所以有了日本的一套自己的规则

1140
00:52:35,000 --> 00:52:38,000
但是那个时候这个变法只能表示价格

1141
00:52:38,000 --> 00:52:41,000
但是我们都知道这个

1142
00:52:42,000 --> 00:52:44,000
汉字的数量凡多 256 个

1143
00:52:44,000 --> 00:52:45,000
显示不够用的

1144
00:52:47,000 --> 00:52:50,000
早期的一个解决方案就是用两个

1145
00:52:50,000 --> 00:52:54,000
二进之的八位数来代表一个汉字

1146
00:52:55,000 --> 00:52:57,000
所以你就有 256 乘 256 个

1147
00:52:58,000 --> 00:53:00,000
256 乘 256 种可能性

1148
00:53:02,000 --> 00:53:04,000
问题在于由于政治原因

1149
00:53:04,000 --> 00:53:06,000
早期的中国

1150
00:53:06,000 --> 00:53:08,000
台湾和香港

1151
00:53:08,000 --> 00:53:09,000
对于汉字的编码

1152
00:53:09,000 --> 00:53:11,000
规定是不一样的

1153
00:53:11,000 --> 00:53:13,000
日本还有一套自己的体系

1154
00:53:13,000 --> 00:53:16,000
不过好在后来出现那种叫做 unique 的东西

1155
00:53:16,000 --> 00:53:19,000
unique 首先它规定了一个序列

1156
00:53:19,000 --> 00:53:20,000
在这个序列里面

1157
00:53:20,000 --> 00:53:23,000
就是一系列的马点

1158
00:53:23,000 --> 00:53:26,000
在每个马点上规定了这个马点对应汉字

1159
00:53:28,000 --> 00:53:31,000
不管汉字是采用什么样的字型

1160
00:53:32,000 --> 00:53:33,000
来自于国家

1161
00:53:35,000 --> 00:53:39,000
全都会归在 unique 的序列里面

1162
00:53:39,000 --> 00:53:43,000
然后 unique 指定了一个编码方法

1163
00:53:43,000 --> 00:53:44,000
也就是

1164
00:53:44,000 --> 00:53:46,000
在某一个特定马点上的汉字

1165
00:53:46,000 --> 00:53:47,000
比如说

1166
00:53:48,000 --> 00:53:51,000
3002

1167
00:53:51,000 --> 00:53:53,000
马点上面的汉字

1168
00:53:53,000 --> 00:53:54,000
是甲一饼的甲

1169
00:53:55,000 --> 00:53:56,000
它规定说

1170
00:53:57,000 --> 00:53:58,000
当你把这个甲字

1171
00:53:59,000 --> 00:54:01,000
一二进至形式表示的时候

1172
00:54:01,000 --> 00:54:03,000
你有很多种选择

1173
00:54:04,000 --> 00:54:05,000
最常见的一种选择

1174
00:54:05,000 --> 00:54:07,000
我们现在叫做 utf 8

1175
00:54:07,000 --> 00:54:08,000
utf 8

1176
00:54:10,000 --> 00:54:12,000
在 utf 8 的表示之下

1177
00:54:13,000 --> 00:54:17,000
位于马点 3002 的甲

1178
00:54:17,000 --> 00:54:19,000
这个字会不会转化为

1179
00:54:20,000 --> 00:54:20,000
有点长

1180
00:54:20,000 --> 00:54:26,000
是一个 3 x 8 的二进日数字

1181
00:54:26,000 --> 00:54:29,000
是 10011

1182
00:54:29,000 --> 00:54:31,000
10010 100

1183
00:54:31,000 --> 00:54:33,000
1010 1010

1184
00:54:34,000 --> 00:54:39,000
我是这个世界上唯一一个把甲的汉字转化为

1185
00:54:40,000 --> 00:54:42,000
语音形式的二进日蛋码人

1186
00:54:42,000 --> 00:55:05,000
本质上来讲,或者说对于计算机来讲,你告诉他 10000001 也好,还是你告诉他,我刚才说是 24 个二净制的数字也好,在他看来都是一样的,但是对于人类来说,即解冻方式也是不一样的

1187
00:55:06,000 --> 00:55:18,000
那么无论音频文件还是视频文件,归原解体基本上都可以这样类推,只不过里面还包含了更多其他的因素,比如说你可以把一个点上面的颜色

1188
00:55:21,000 --> 00:55:27,000
化分为红绿蓝三个分量,然后每个分量

1189
00:55:28,000 --> 00:55:33,000
用一个 0 到 255 的数字表示

1190
00:55:34,000 --> 00:55:38,000
那么你就可以得到每个点上的,学生用的 RGB 的值

1191
00:55:39,000 --> 00:55:48,000
但是如果你要记载一部电影里面的每一帧的每一个点上的这个数字

1192
00:55:48,000 --> 00:55:50,000
其代价会是非常高昂的

1193
00:55:51,000 --> 00:55:57,000
因为我们目前的科技手段没有办法保证说能够完全不去考虑

1194
00:55:58,000 --> 00:56:04,000
存储或者说传输过程之中的空间乃至于时间的损耗

1195
00:56:05,000 --> 00:56:12,000
所以人没有想出另外一个方法,就是找出所有这些数字里面的重复部分

1196
00:56:12,000 --> 00:56:14,000
用一个更短的数字去代替

1197
00:56:14,000 --> 00:56:18,000
这就是压缩的本质,所以我们可以把它理解为

1198
00:56:18,000 --> 00:56:21,000
对于编码的再编码

1199
00:56:22,000 --> 00:56:23,000
这是另外一层口语

1200
00:56:28,000 --> 00:56:32,000
其实这期的提章里面还数一些其他话

1201
00:56:33,000 --> 00:56:36,000
包括 UniCode,本来都是打算在展开讲

1202
00:56:37,000 --> 00:56:39,000
还有很多历史之类的

1203
00:56:39,000 --> 00:56:46,000
但是目前的状况是我这边录音的时间刚刚突破了一个小时的 mark

1204
00:56:47,000 --> 00:56:49,000
当然最后捡出来可能没有一个小时,不过

1205
00:56:50,000 --> 00:56:57,000
此时的我已经觉得嗓子非常疼了,而且很不幸过敏性 Bn 又开始发了

1206
00:56:57,000 --> 00:56:59,000
所以这一期只能

1207
00:57:00,000 --> 00:57:02,000
我们还没有进入正题是吧

1208
00:57:02,000 --> 00:57:05,000
那么赶紧进入一下正题好了

1209
00:57:06,000 --> 00:57:09,000
正题就是程序员怎样才能找到女朋友呢

1210
00:57:10,000 --> 00:57:10,000
问好

1211
00:57:12,000 --> 00:57:12,000
答案很简单

1212
00:57:12,000 --> 00:57:15,000
就是除非你的女朋友号选人就是号这一口

1213
00:57:15,000 --> 00:57:18,000
那么单纯以程序员的身份

1214
00:57:19,000 --> 00:57:21,000
对于找到女朋友来说没有任何意义

1215
00:57:22,000 --> 00:57:23,000
True story

1216
00:57:24,000 --> 00:57:27,000
只有抛开我是程序员这一个自我认同之后

1217
00:57:28,000 --> 00:57:30,000
找女朋友才会变得比较容易

1218
00:57:32,000 --> 00:57:35,000
比如你要弄明白人和人之前沟通的编码

1219
00:57:35,000 --> 00:57:36,000
这个编码体系

1220
00:57:37,000 --> 00:57:39,000
一方面要比算机系统

1221
00:57:39,000 --> 00:57:42,000
我们刚才所说的一些编码简单的多

1222
00:57:42,000 --> 00:57:44,000
另一方面要比它复杂的多

1223
00:57:44,000 --> 00:57:46,000
你要去学会理解

1224
00:57:48,000 --> 00:57:50,000
不同性别之间的性力差异

1225
00:57:50,000 --> 00:57:52,000
不管这种差异是怎么来的

1226
00:57:52,000 --> 00:57:53,000
都必须了解它

1227
00:57:55,000 --> 00:57:58,000
你要去了解什么是闲爱之音

1228
00:57:59,000 --> 00:58:01,000
你要弄明白女孩子说话

1229
00:58:01,000 --> 00:58:03,000
有时候是话里有话

1230
00:58:04,000 --> 00:58:04,000
对吧

1231
00:58:06,000 --> 00:58:07,000
我女朋友在点头

1232
00:58:08,000 --> 00:58:09,000
好吧

1233
00:58:10,000 --> 00:58:12,000
您正在您刚刚收听完的是

1234
00:58:12,000 --> 00:58:14,000
iPm podcast 的网络系下的

1235
00:58:14,000 --> 00:58:16,000
IT 技术节目内核浮夸

1236
00:58:16,000 --> 00:58:20,000
也欢迎你收听 iPm 系下的其他六党 podcast

1237
00:58:20,000 --> 00:58:21,000
包括

1238
00:58:22,000 --> 00:58:25,000
同样是技术主题节目 IT 公问

1239
00:58:25,000 --> 00:58:27,000
医疗主题节目太一来了

1240
00:58:27,000 --> 00:58:29,000
美食主题节目未知道

1241
00:58:29,000 --> 00:58:31,000
艺术主题节目流行动性

1242
00:58:31,000 --> 00:58:33,000
无主题节目无次元

1243
00:58:33,000 --> 00:58:34,000
故事主题节目 History

1244
00:58:35,000 --> 00:58:38,000
以及影像主题节目印影下

1245
00:58:39,000 --> 00:58:40,000
感谢大家的烧天

