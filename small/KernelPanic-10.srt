1
00:00:00,000 --> 00:00:03,000
大家好 欢迎收听第 17 的内核恐慌 我是 Ryo

2
00:00:03,000 --> 00:00:05,000
我是武堂

3
00:00:05,000 --> 00:00:09,000
今天我们请到了一位嘉宾 她叫 Willow

4
00:00:09,000 --> 00:00:11,000
我来跟大家打招呼吧

5
00:00:11,000 --> 00:00:13,000
大家好 我是 Willow

6
00:00:13,000 --> 00:00:18,000
又可以跟 Ryo 和 Wilthal 插科打魂 非常开心

7
00:00:18,000 --> 00:00:24,000
为什么说又呢 就是如果大家听过我主持的另外一档节目

8
00:00:24,000 --> 00:00:28,000
IT 公众的话就知道 Willow 已经在那边做过两三次的嘉宾了

9
00:00:28,000 --> 00:00:33,000
可是我好像没有和 Willow 直接上过

10
00:00:33,000 --> 00:00:35,000
对 我们没有上过

11
00:00:35,000 --> 00:00:37,000
没有上过

12
00:00:37,000 --> 00:00:39,000
我也没有开始这么 A 吗

13
00:00:39,000 --> 00:00:46,000
不过其实这是我们内核恐慌这期节目第一次邀请嘉宾吧 对

14
00:00:46,000 --> 00:00:49,000
之前曾经邀请过 因为嘉宾后来被 IT 公众抢走了

15
00:00:49,000 --> 00:00:51,000
对 就是往上冲进去

16
00:00:51,000 --> 00:00:54,000
所以 Willow 也是我们他的处女嘉宾

17
00:00:54,000 --> 00:00:56,000
非常荣幸 非常

18
00:00:56,000 --> 00:00:58,000
不是 我不知道是处女嘉宾

19
00:00:58,000 --> 00:01:01,000
但是我感觉是

20
00:01:01,000 --> 00:01:07,000
今天请 Willow 来是要聊一件跟前端开发有关的事情

21
00:01:07,000 --> 00:01:11,000
因为刚好 Willow 最近应该是前天吧 前天和上前天对吧

22
00:01:11,000 --> 00:01:12,000
上前天

23
00:01:12,000 --> 00:01:13,000
28 号 应该是 9 号

24
00:01:13,000 --> 00:01:17,000
对 然后去参加了 Facebook 搞的

25
00:01:17,000 --> 00:01:20,000
现在已经不算 Facebook 它们已经独立出来了吗 还是怎么样

26
00:01:20,000 --> 00:01:21,000
还是 Facebook

27
00:01:21,000 --> 00:01:23,000
还是 Facebook OK

28
00:01:23,000 --> 00:01:26,000
Facebook 它们有一个开发者的小型的会议

29
00:01:26,000 --> 00:01:30,000
是讲了一个叫做 React 前端开发的技术

30
00:01:30,000 --> 00:01:34,000
然后刚刚 Willow 去了现场 参加了两天的会议

31
00:01:34,000 --> 00:01:38,000
然后我们就趁着打铁 邀请他来跟我们分享一下他所见所闻

32
00:01:38,000 --> 00:01:41,000
对 其实 Willow 你是为什么可以去参加

33
00:01:41,000 --> 00:01:45,000
或者说你是出于什么样的动机去参加 React Jest Conference

34
00:01:45,000 --> 00:01:50,000
嗯 如果你看前端开发的发展的话

35
00:01:50,000 --> 00:01:55,000
你会发现 去年和前年是非常激动的两年

36
00:01:55,000 --> 00:02:00,000
因为我们最开始大家写 Pure JavaScript

37
00:02:00,000 --> 00:02:02,000
然后后来又写 JQuery

38
00:02:02,000 --> 00:02:09,000
然后再到 Backbone 引进了比较具体的 structure

39
00:02:09,000 --> 00:02:11,000
前端的开发好像到那里就有一点停滞

40
00:02:11,000 --> 00:02:14,000
在这个时候呢 出现了 Angler

41
00:02:14,000 --> 00:02:16,000
然后去年又出现了 React

42
00:02:16,000 --> 00:02:19,000
实际上 最以全端开发者来说

43
00:02:19,000 --> 00:02:23,000
整个前端世界是发生的巨变的

44
00:02:23,000 --> 00:02:27,000
而 React 是促使这些巨变的一个代表之一

45
00:02:27,000 --> 00:02:35,000
我们去年 我们自己的公司去年在考虑新的技术的时候

46
00:02:35,000 --> 00:02:38,000
把 React 纳入了我们想要使用的范围

47
00:02:38,000 --> 00:02:42,000
在过去的 6-8 个月

48
00:02:42,000 --> 00:02:49,000
我们都有在积极的把以前的东西给转移到 React 上

49
00:02:49,000 --> 00:02:51,000
我们之前是写了一个 Backbone app

50
00:02:51,000 --> 00:02:56,000
然后我们现在在 Migrate 它去 React

51
00:02:56,000 --> 00:02:59,000
作为一个 React 开发者本身

52
00:02:59,000 --> 00:03:02,000
然后再作为一个技术的爱好者

53
00:03:02,000 --> 00:03:06,000
我也觉得非常荣幸有机会去 React.com

54
00:03:06,000 --> 00:03:11,000
去这个 community 看最新的东西

55
00:03:11,000 --> 00:03:15,000
然后从其他人身上学到一些东西

56
00:03:15,000 --> 00:03:20,000
OK 你刚才提到说整个 App 要从 Backbone 迁移到 React 上面

57
00:03:20,000 --> 00:03:22,000
待会我们也可以讲一下整个迁移过程

58
00:03:22,000 --> 00:03:26,000
是不是的痛苦程度有多少

59
00:03:26,000 --> 00:03:29,000
没问题 其实是一个非常有意思的一个过程

60
00:03:29,000 --> 00:03:34,000
相对于像 Angular 这样的庞大的 Framoc 来说

61
00:03:34,000 --> 00:03:36,000
React 实际上非常的轻巧

62
00:03:36,000 --> 00:03:42,000
然后正是因此 Migration 没有很多人想象会那么痛苦

63
00:03:42,000 --> 00:03:45,000
我们非常非常享受这个过程

64
00:03:45,000 --> 00:03:48,000
我忘了介绍了 我们自己都很熟悉了

65
00:03:48,000 --> 00:03:50,000
但是忘了给有些听众朋友可能还

66
00:03:50,000 --> 00:03:53,000
第一次听到 VLO 的声音的话

67
00:03:53,000 --> 00:03:55,000
VLO 你还要先介绍一下自己

68
00:03:55,000 --> 00:03:59,000
你是在湾区的左前灯开发 对吧

69
00:04:00,000 --> 00:04:05,000
OK 我在 IT 公伦的时候也没有介绍自己

70
00:04:05,000 --> 00:04:12,000
对 我觉得不知道 VLO 是谁的听众们可以回去听 IT 公伦

71
00:04:12,000 --> 00:04:14,000
第一期是有介绍的

72
00:04:14,000 --> 00:04:20,000
我一直在湾区生活了三年

73
00:04:20,000 --> 00:04:23,000
然后我一直在这家叫做 Backplane 的

74
00:04:23,000 --> 00:04:26,000
对吧 我在湾区生活了三年

75
00:04:26,000 --> 00:04:31,000
然后一直在这家叫做 Backplane 的公司做 Soft Engineer

76
00:04:31,000 --> 00:04:35,000
我很关心前端开发上

77
00:04:36,000 --> 00:04:41,000
然后我要给你们公司做什么负面宣传的答应

78
00:04:41,000 --> 00:04:45,000
就是 Backplane 这家可能在外界最知名的就是什么

79
00:04:45,000 --> 00:04:46,000
他的投资人 对吧

80
00:04:46,000 --> 00:04:48,000
好 什么都没问题

81
00:04:48,000 --> 00:04:49,000
我们再说一遍

82
00:04:49,000 --> 00:04:52,000
OK 最近什么事都很开心

83
00:04:52,000 --> 00:04:53,000
我只是说

84
00:04:53,000 --> 00:04:56,000
投资人是谁 雷蒂加尔还是

85
00:04:56,000 --> 00:04:59,000
对对对 对没错

86
00:04:59,000 --> 00:05:01,000
可以帮我要一个签名

87
00:05:01,000 --> 00:05:05,000
他只是想股东

88
00:05:05,000 --> 00:05:09,000
签名 他牵我脸上 他亲了我

89
00:05:11,000 --> 00:05:14,000
好 下次给他签我一下

90
00:05:14,000 --> 00:05:16,000
不 下次他来你亲他一下

91
00:05:16,000 --> 00:05:18,000
这样你就会立刻亲上

92
00:05:18,000 --> 00:05:19,000
OK

93
00:05:19,000 --> 00:05:22,000
看多机智的一个方法

94
00:05:22,000 --> 00:05:25,000
对 所以说回来 球员

95
00:05:25,000 --> 00:05:29,000
所以 VLOG 是一个在湾区工作的软件开发角

96
00:05:29,000 --> 00:05:33,000
对 然后 VLOG 最有这个作品是

97
00:05:33,000 --> 00:05:38,000
或者说如果你跟 VLOG 曾经产生过什么交集的话

98
00:05:38,000 --> 00:05:40,000
也许是你用过他写的一个插件

99
00:05:40,000 --> 00:05:42,000
叫做 WattFonds

100
00:05:42,000 --> 00:05:45,000
就是用来检测网页上

101
00:05:45,000 --> 00:05:47,000
某一部分被显示出来的文字

102
00:05:47,000 --> 00:05:51,000
所实际采用的字体的插件

103
00:05:51,000 --> 00:05:53,000
我们之前有一期 IT 公论

104
00:05:53,000 --> 00:05:55,000
探讨完那个产品

105
00:05:55,000 --> 00:05:56,000
如果大家有兴趣的话

106
00:05:56,000 --> 00:06:00,000
可以回头听那个 podcast

107
00:06:00,000 --> 00:06:03,000
这个产品已经已经在上线很多年了

108
00:06:03,000 --> 00:06:04,000
所以说

109
00:06:04,000 --> 00:06:07,000
所以说我也很期待能够有新的作品

110
00:06:07,000 --> 00:06:08,000
拿出来给大家用

111
00:06:08,000 --> 00:06:11,000
然后我也在积极地积极地积极地做这方面的工作

112
00:06:11,000 --> 00:06:14,000
嗯 很好

113
00:06:14,000 --> 00:06:18,000
所以你看 VLOG 在湾区就有比较方便的这种机会

114
00:06:18,000 --> 00:06:23,000
去参加到各种各样比较高大上的技术会议

115
00:06:23,000 --> 00:06:24,000
这种的话

116
00:06:24,000 --> 00:06:26,000
不在湾区觉得真的蛮难的 我觉得

117
00:06:26,000 --> 00:06:32,000
是 就像欧洲很多 conference 都是在各个城市晃来晃去

118
00:06:32,000 --> 00:06:33,000
很少会有这种

119
00:06:33,000 --> 00:06:36,000
比如 扎堆的现象

120
00:06:36,000 --> 00:06:39,000
比如说 Rack.js Europe Conference

121
00:06:39,000 --> 00:06:41,000
将在 7 月份举行

122
00:06:41,000 --> 00:06:43,000
在欧洲巴黎

123
00:06:43,000 --> 00:06:47,000
然后 PYCon Europe

124
00:06:47,000 --> 00:06:49,000
这个更是每一年都要换一个城市

125
00:06:49,000 --> 00:06:52,000
然后去年应该是在阿姆斯特丹

126
00:06:52,000 --> 00:06:54,000
我没记错

127
00:06:54,000 --> 00:06:56,000
还好 欧洲交通方便

128
00:06:56,000 --> 00:06:58,000
我不觉得

129
00:06:58,000 --> 00:07:01,000
是吗 我觉得还可以

130
00:07:01,000 --> 00:07:03,000
不管去哪都要定机票

131
00:07:03,000 --> 00:07:08,000
然后可能要去上那个国家的网站买

132
00:07:08,000 --> 00:07:10,000
或者票什么的就很麻烦

133
00:07:10,000 --> 00:07:11,000
不像

134
00:07:11,000 --> 00:07:15,000
那离欧洲大一通的理想还比较远

135
00:07:15,000 --> 00:07:15,000
对

136
00:07:15,000 --> 00:07:20,000
之所以 ReactConf 在欧洲会在巴黎是因为

137
00:07:20,000 --> 00:07:22,000
那个 开发者之一

138
00:07:22,000 --> 00:07:23,000
那个人叫什么 Christopher

139
00:07:23,000 --> 00:07:26,000
Christopher 他是法国人吗

140
00:07:26,000 --> 00:07:27,000
对 应该会

141
00:07:27,000 --> 00:07:32,000
对 他讲英语的时候有非常强的法国口音

142
00:07:32,000 --> 00:07:33,000
对

143
00:07:33,000 --> 00:07:34,000
我还专门去查了他是哪国人的

144
00:07:34,000 --> 00:07:35,000
我要 我要 我要

145
00:07:35,000 --> 00:07:36,000
太难受了

146
00:07:37,000 --> 00:07:39,000
他 Lost Name Shuttle

147
00:07:39,000 --> 00:07:40,000
这个很明显了

148
00:07:40,000 --> 00:07:41,000
那挺好的

149
00:07:41,000 --> 00:07:43,000
就是我有这些反应一个很

150
00:07:43,000 --> 00:07:45,000
大家很开放太多

151
00:07:45,000 --> 00:07:46,000
其实我说英语也有口音

152
00:07:46,000 --> 00:07:48,000
但是这个并不会成为

153
00:07:48,000 --> 00:07:50,000
不影响工作的

154
00:07:50,000 --> 00:07:50,000
对 因为大家可以

155
00:07:50,000 --> 00:07:52,000
所以我也很

156
00:07:52,000 --> 00:07:54,000
看到他能够

157
00:07:54,000 --> 00:07:57,000
Hose 这 conference 也是 validated

158
00:07:57,000 --> 00:07:58,000
大家都能

159
00:07:58,000 --> 00:08:00,000
这个英语这个事情不是那么重要吗

160
00:08:00,000 --> 00:08:02,000
所以是一个很好的事情

161
00:08:03,000 --> 00:08:05,000
其实 Velo 在我们三个人里面

162
00:08:05,000 --> 00:08:06,000
已经是最没口音的一个了

163
00:08:06,000 --> 00:08:07,000
我觉得

164
00:08:07,000 --> 00:08:08,000
对

165
00:08:09,000 --> 00:08:11,000
摸爬滚打的最久的

166
00:08:11,000 --> 00:08:14,000
Anyway Turra 还是回到

167
00:08:14,000 --> 00:08:15,000
回到这个正题

168
00:08:15,000 --> 00:08:18,000
就说其实我们可以先回顾一下

169
00:08:18,000 --> 00:08:19,000
在 React 之前的那些框架

170
00:08:19,000 --> 00:08:21,000
会有一些什么样的

171
00:08:21,000 --> 00:08:23,000
就有些什么样的选择

172
00:08:23,000 --> 00:08:24,000
会有什么样的问题

173
00:08:24,000 --> 00:08:26,000
就是 Velo 你们之前是用这个 Backbomb 对吧

174
00:08:26,000 --> 00:08:27,000
对 没错

175
00:08:27,000 --> 00:08:30,000
你们在实际使用中的话

176
00:08:30,000 --> 00:08:31,000
就是刚才你也提到

177
00:08:31,000 --> 00:08:33,000
你们在网这个 React 迁移

178
00:08:33,000 --> 00:08:34,000
那么对你们说

179
00:08:34,000 --> 00:08:36,000
在 Backbomb 实际使用中

180
00:08:36,000 --> 00:08:37,000
遇到一些什么样的问题

181
00:08:37,000 --> 00:08:39,000
然后迁移到 React

182
00:08:39,000 --> 00:08:41,000
会比较好的解决呢

183
00:08:42,000 --> 00:08:44,000
有两方面的问题

184
00:08:44,000 --> 00:08:46,000
一方面是在

185
00:08:46,000 --> 00:08:47,000
人在 Engineering 方面

186
00:08:47,000 --> 00:08:49,000
会遇到一些问题

187
00:08:49,000 --> 00:08:51,000
然后你在 Production 上

188
00:08:51,000 --> 00:08:52,000
会遇到一些问题

189
00:08:52,000 --> 00:08:53,000
Production 上的问题

190
00:08:53,000 --> 00:08:54,000
其实蛮简单的

191
00:08:54,000 --> 00:08:56,000
就是 Performance

192
00:08:57,000 --> 00:08:59,000
一个 Framwork 它到底能有多快

193
00:08:59,000 --> 00:09:01,000
渲染的多快

194
00:09:01,000 --> 00:09:02,000
交付能力

195
00:09:02,000 --> 00:09:04,000
这些东西是非常好客观评价的

196
00:09:04,000 --> 00:09:06,000
然后如果上网搜的话

197
00:09:06,000 --> 00:09:07,000
会看到很多

198
00:09:07,000 --> 00:09:10,000
负面的关于 Backbomb 的

199
00:09:10,000 --> 00:09:13,000
一些评测显示

200
00:09:13,000 --> 00:09:14,000
然后我们自己在 Production 上

201
00:09:14,000 --> 00:09:15,000
也遇到这些问题

202
00:09:15,000 --> 00:09:17,000
我们网站并不算快

203
00:09:17,000 --> 00:09:21,000
然后在 Memory 上也非常难管理

204
00:09:21,000 --> 00:09:22,000
这个 Memory 呢

205
00:09:22,000 --> 00:09:23,000
实际上是跨了这个 Production

206
00:09:23,000 --> 00:09:24,000
Engineering

207
00:09:24,000 --> 00:09:28,000
因为 Backbomb 的 Memory Management

208
00:09:28,000 --> 00:09:31,000
就好像你在原来做 IOS 开发

209
00:09:31,000 --> 00:09:34,000
是你要 Manually Return Things

210
00:09:34,000 --> 00:09:35,000
like 你

211
00:09:35,000 --> 00:09:36,000
你要 Manually Management

212
00:09:36,000 --> 00:09:37,000
手工管理那则

213
00:09:37,000 --> 00:09:41,000
所以非常容易出现 Memory Leak

214
00:09:41,000 --> 00:09:43,000
那整个程序记忆

215
00:09:43,000 --> 00:09:44,000
在 Render 上会卖

216
00:09:44,000 --> 00:09:47,000
然后在 Memory 上会 Leak 的话

217
00:09:47,000 --> 00:09:49,000
那你的 Performance 就非常不乐观

218
00:09:49,000 --> 00:09:50,000
是不是

219
00:09:50,000 --> 00:09:52,000
就是在 Production 上的问题

220
00:09:52,000 --> 00:09:55,000
Engineering 上的问题在于

221
00:09:55,000 --> 00:09:56,000
关键对于我们来说是

222
00:09:56,000 --> 00:10:00,000
代码的可重用性和可管理性

223
00:10:00,000 --> 00:10:01,000
在重用性上的问题

224
00:10:01,000 --> 00:10:06,000
主要来说就是 View 的重用性

225
00:10:06,000 --> 00:10:07,000
实际上要重用一个 View

226
00:10:07,000 --> 00:10:10,000
在 Backbomb 中还其实蛮复杂的

227
00:10:10,000 --> 00:10:14,000
因为你要在 View 里面

228
00:10:14,000 --> 00:10:16,000
在你的 Template 里面

229
00:10:16,000 --> 00:10:19,000
给 SubView 腾出一个空间

230
00:10:19,000 --> 00:10:21,000
选一个 Container

231
00:10:21,000 --> 00:10:23,000
然后在你的 Render 方式中

232
00:10:23,000 --> 00:10:25,000
要 Initialize 那个

233
00:10:26,000 --> 00:10:27,000
SubView

234
00:10:27,000 --> 00:10:30,000
然后把 SubView 切进来

235
00:10:30,000 --> 00:10:33,000
这些的过程对于开发者来说

236
00:10:33,000 --> 00:10:35,000
还是一个蛮头疼的事情

237
00:10:35,000 --> 00:10:37,000
所以就因为如此

238
00:10:37,000 --> 00:10:41,000
你会看到很多人不会去重用

239
00:10:41,000 --> 00:10:45,000
在代码的可管理下的关键是

240
00:10:45,000 --> 00:10:49,000
其实 View 它本身并不

241
00:10:49,000 --> 00:10:52,000
并不管理它所有的 State

242
00:10:52,000 --> 00:10:53,000
很大一部分人身上

243
00:10:53,000 --> 00:10:56,000
State 是在 Dom 里头的

244
00:10:56,000 --> 00:10:57,000
你知道我们有时候 Utilize

245
00:10:57,000 --> 00:11:00,000
Class Utilize Data Props

246
00:11:00,000 --> 00:11:05,000
这样 Dom 的 Element 去管理 View 的 State

247
00:11:05,000 --> 00:11:08,000
就导致大家看 View 的时候

248
00:11:08,000 --> 00:11:10,000
并看不到全貌

249
00:11:10,000 --> 00:11:12,000
不知道 View 到底能够做什么事情

250
00:11:12,000 --> 00:11:13,000
会做什么事情

251
00:11:13,000 --> 00:11:16,000
其实你看 View 的时候是很难看出来的

252
00:11:16,000 --> 00:11:20,000
就在多人合作的项目上

253
00:11:20,000 --> 00:11:22,000
或者是说你返回到你

254
00:11:22,000 --> 00:11:24,000
多年之前信 F 的时候

255
00:11:24,000 --> 00:11:26,000
就会是一个很大的问题

256
00:11:26,000 --> 00:11:30,000
就是我们用 Backbone

257
00:11:30,000 --> 00:11:32,000
两三年的时间里

258
00:11:32,000 --> 00:11:34,000
所遇到两个方面的问题

259
00:11:34,000 --> 00:11:38,000
我觉得这可能跟 Backbone 的设计理念有关系

260
00:11:38,000 --> 00:11:41,000
Backbone 毕竟它强调的是

261
00:11:41,000 --> 00:11:43,000
它所提供的功能

262
00:11:43,000 --> 00:11:48,000
这是最基本最 Backbone 的那一部分

263
00:11:48,000 --> 00:11:50,000
所以你可能不得不

264
00:11:50,000 --> 00:11:56,000
在很多地方要显示的去宣告一些东西

265
00:11:56,000 --> 00:12:01,000
然后你需要显示的把逻辑写出来

266
00:12:01,000 --> 00:12:03,000
而如果你需要显示的写出来的话

267
00:12:03,000 --> 00:12:06,000
每个人写的逻辑可能会不一样

268
00:12:06,000 --> 00:12:08,000
你说你

269
00:12:08,000 --> 00:12:10,000
这是一方面的问题

270
00:12:10,000 --> 00:12:11,000
对

271
00:12:11,000 --> 00:12:14,000
你说你无法直接看到 View 想要干什么

272
00:12:14,000 --> 00:12:15,000
其实原因之一

273
00:12:15,000 --> 00:12:21,000
也就是它没有一个 default 的 behavior

274
00:12:21,000 --> 00:12:24,000
可以让你去意眼

275
00:12:24,000 --> 00:12:27,000
让你猜到它要干什么

276
00:12:27,000 --> 00:12:30,000
Backbone 既好又导致这个问题的一方面

277
00:12:30,000 --> 00:12:34,000
就是它不是很 opinionated

278
00:12:34,000 --> 00:12:39,000
我们确实在总结我们的 Backbone 的经验的时候有提到这点

279
00:12:39,000 --> 00:12:43,000
在一个团队协奏的范围中

280
00:12:43,000 --> 00:12:45,000
不 opinionated 实际上是一个很麻烦的事情

281
00:12:45,000 --> 00:12:48,000
因为大家可能写东西会用不同的方式

282
00:12:48,000 --> 00:12:51,000
也不是说各种方式哪个好哪个坏

283
00:12:51,000 --> 00:12:56,000
关键是协作上来说有相同的 mental model

284
00:12:56,000 --> 00:12:58,000
会更方便一点

285
00:12:58,000 --> 00:13:00,000
不管好坏只要一样的话

286
00:13:00,000 --> 00:13:03,000
围护起来的成本可能也不是围护下来的

287
00:13:03,000 --> 00:13:05,000
可能就是沟通起来的成本会小一些

288
00:13:05,000 --> 00:13:08,000
如果你用 amber.js 或者是 angular 之类的

289
00:13:08,000 --> 00:13:13,000
比较有自己的一套使用哲学的框架的话

290
00:13:13,000 --> 00:13:17,000
你会比较有一个大致的概念

291
00:13:17,000 --> 00:13:20,000
就是这件事情怎样做才是符合这个框架的理念的

292
00:13:20,000 --> 00:13:22,000
但是 Backbone 则比较平淡

293
00:13:22,000 --> 00:13:26,000
或者说比较给了你太多自由权

294
00:13:26,000 --> 00:13:29,000
然后就会导致会有沟通上面的问题

295
00:13:29,000 --> 00:13:29,000
我是觉得

296
00:13:31,000 --> 00:13:32,000
确实有这样的因素在

297
00:13:32,000 --> 00:13:37,000
可是当我们在看像 amber.js 的 framable 的时候

298
00:13:37,000 --> 00:13:42,000
它相对于 Backbone 是一个比较小的地景对我们来说

299
00:13:42,000 --> 00:13:44,000
确实它在 Backbone 的每一个方式

300
00:13:44,000 --> 00:13:46,000
Backbone 所设计的每一个方式

301
00:13:46,000 --> 00:13:49,000
不管是 router 还是 vue templating

302
00:13:49,000 --> 00:13:51,000
它都有相当大的进步

303
00:13:51,000 --> 00:13:53,000
however 它所 fundamentally

304
00:13:53,000 --> 00:13:58,000
他们的框架的理念 MVC 的理念是完全一致的

305
00:13:58,000 --> 00:14:00,000
这是为什么我们在考虑

306
00:14:00,000 --> 00:14:04,000
更新我们的 framable 的时候

307
00:14:04,000 --> 00:14:07,000
并没有做对 amber 并没有做太多的考虑

308
00:14:07,000 --> 00:14:12,000
因为如果你计算时间的

309
00:14:12,000 --> 00:14:15,000
对 从一种 MVC 换到另一种 MVC

310
00:14:15,000 --> 00:14:18,000
只不过另外一个 MVC 更重量级一点

311
00:14:18,000 --> 00:14:20,000
更 opinion 的一点

312
00:14:20,000 --> 00:14:20,000
没错

313
00:14:23,000 --> 00:14:24,000
所以刚才为了你讲到

314
00:14:24,000 --> 00:14:26,000
提到像 Backbone 你们做的时候

315
00:14:26,000 --> 00:14:28,000
就是我根据你的描述

316
00:14:28,000 --> 00:14:30,000
我感觉出来有几个比较核心的问题

317
00:14:30,000 --> 00:14:34,000
就一个是说这个叫什么封装的层级不够

318
00:14:34,000 --> 00:14:36,000
就说它封的太散了

319
00:14:36,000 --> 00:14:40,000
比如说有些数据是在 dom 里面的

320
00:14:40,000 --> 00:14:43,000
有些数据可能是在 javascript 的数据结构里面的

321
00:14:43,000 --> 00:14:43,000
对吧

322
00:14:43,000 --> 00:14:44,000
这可能是一个

323
00:14:44,000 --> 00:14:46,000
你说 vue 不能在同一个地方一眼

324
00:14:46,000 --> 00:14:49,000
看出来它的相关的那一部分是怎么样

325
00:14:49,000 --> 00:14:52,000
这个其实是你们在工程上的话

326
00:14:52,000 --> 00:14:54,000
就是没有把这些相关的部分很好的

327
00:14:54,000 --> 00:14:56,000
就是 encapital way 的起来

328
00:14:56,000 --> 00:14:57,000
没错

329
00:14:57,000 --> 00:15:00,000
因为这个主要是因为 dom 这个事情

330
00:15:00,000 --> 00:15:02,000
就太太太弹的

331
00:15:02,000 --> 00:15:02,000
你知道就是这样

332
00:15:04,000 --> 00:15:05,000
大家都明白

333
00:15:05,000 --> 00:15:07,000
我为什么这么说

334
00:15:07,000 --> 00:15:11,000
因为 dom 的问题

335
00:15:11,000 --> 00:15:13,000
首先 API 很烂

336
00:15:13,000 --> 00:15:15,000
这个 jQuery kind of

337
00:15:15,000 --> 00:15:16,000
resolve that problem

338
00:15:16,000 --> 00:15:18,000
kind of

339
00:15:18,000 --> 00:15:22,000
然后关键的因素在于说 performance 太烂

340
00:15:22,000 --> 00:15:25,000
因为这是历史因素

341
00:15:25,000 --> 00:15:26,000
因为 dom 的

342
00:15:26,000 --> 00:15:27,000
对

343
00:15:27,000 --> 00:15:28,000
你跟 dom 交互的话

344
00:15:28,000 --> 00:15:29,000
肯定就是有这个

345
00:15:29,000 --> 00:15:30,000
so the overhead 比较高

346
00:15:30,000 --> 00:15:32,000
对

347
00:15:32,000 --> 00:15:33,000
实际上

348
00:15:33,000 --> 00:15:36,000
如果你真的去 compare backbone 跟 react 的话

349
00:15:36,000 --> 00:15:40,000
最关键就是他们怎么去处理这个 dom

350
00:15:40,000 --> 00:15:42,000
怎么去处理 dom 这个事情上不一样

351
00:15:42,000 --> 00:15:44,000
在 backbone 里头

352
00:15:44,000 --> 00:15:47,000
如果你要追求 performance

353
00:15:47,000 --> 00:15:49,000
如果说你不 care performance

354
00:15:49,000 --> 00:15:50,000
那 totally different story

355
00:15:50,000 --> 00:15:52,000
但是如果你

356
00:15:52,000 --> 00:15:54,000
就是在意真的可用东西

357
00:15:54,000 --> 00:15:56,000
还不是好用是可用的话

358
00:15:56,000 --> 00:15:58,000
你一定要在意 performance

359
00:15:58,000 --> 00:16:00,000
然后就导致说

360
00:16:00,000 --> 00:16:01,000
你的 dom 的

361
00:16:03,000 --> 00:16:04,000
操作都要很小

362
00:16:04,000 --> 00:16:05,000
非常小

363
00:16:05,000 --> 00:16:06,000
比方说

364
00:16:06,000 --> 00:16:09,000
如果我要写一个

365
00:16:09,000 --> 00:16:11,000
选项的列表

366
00:16:11,000 --> 00:16:14,000
一个用户去点一个选项

367
00:16:14,000 --> 00:16:16,000
然后选项要变成红色

368
00:16:16,000 --> 00:16:17,000
这么一个小小的功能

369
00:16:17,000 --> 00:16:19,000
在你的 backbone view 中

370
00:16:19,000 --> 00:16:24,000
你一定是会 manually 把这个 class 给

371
00:16:24,000 --> 00:16:27,000
从其他的 aliment 上移除出去

372
00:16:27,000 --> 00:16:32,000
然后加在 target 的 aliment 上

373
00:16:32,000 --> 00:16:34,000
就这么小小的一点

374
00:16:34,000 --> 00:16:35,000
操作

375
00:16:35,000 --> 00:16:36,000
你要变利一点

376
00:16:36,000 --> 00:16:40,000
就导致你的 state 就从 view 上 lose 掉了

377
00:16:40,000 --> 00:16:43,000
因为你整个 state 是在 dom 的

378
00:16:43,000 --> 00:16:46,000
active class 这个因素上

379
00:16:46,000 --> 00:16:48,000
但是你又不可能说

380
00:16:48,000 --> 00:16:51,000
每次都把这个列表重新给 rendered 一下

381
00:16:51,000 --> 00:16:55,000
就有回到我们说的 performance 上面

382
00:16:55,000 --> 00:16:57,000
对于开发者来说

383
00:16:57,000 --> 00:16:58,000
如果你不需要去担心

384
00:16:58,000 --> 00:17:00,000
这么小小的这种细节操作

385
00:17:00,000 --> 00:17:03,000
而是描述清楚

386
00:17:03,000 --> 00:17:06,000
你到底这个 view end result 是怎么样

387
00:17:06,000 --> 00:17:08,000
那你的 code 会清楚很多

388
00:17:08,000 --> 00:17:10,000
可是因为 performance 的因素

389
00:17:10,000 --> 00:17:15,000
你必须得到细节的小的程度去操作它

390
00:17:15,000 --> 00:17:19,000
就导致你不能够每次都 re-render

391
00:17:19,000 --> 00:17:21,000
backbone 的时代就是这样子的

392
00:17:21,000 --> 00:17:24,000
但是 react the magic happens

393
00:17:24,000 --> 00:17:26,000
会发生的

394
00:17:26,000 --> 00:17:27,000
magic happens

395
00:17:27,000 --> 00:17:30,000
在 react the account 里头

396
00:17:30,000 --> 00:17:34,000
Tom,who is the product manager

397
00:17:34,000 --> 00:17:39,000
有提到 Facebook 内部

398
00:17:39,000 --> 00:17:40,000
去做这个

399
00:17:40,000 --> 00:17:43,000
去 initialize the project 的动机

400
00:17:43,000 --> 00:17:44,000
就有提到说

401
00:17:44,000 --> 00:17:52,000
他们很想要把这种细小的 dom 操作隔离出来

402
00:17:52,000 --> 00:17:52,000
I've dragged out

403
00:17:52,000 --> 00:17:56,000
就像刚刚 Rio 说的 incaps away

404
00:17:56,000 --> 00:17:58,000
但是他们担心 performance

405
00:17:58,000 --> 00:18:00,000
所以他们做了 performance 的测试

406
00:18:00,000 --> 00:18:02,000
实际上 performance 的测试结果

407
00:18:02,000 --> 00:18:06,000
比我们所要预想的都乐观很多

408
00:18:06,000 --> 00:18:08,000
其实像动没有那么烂

409
00:18:08,000 --> 00:18:09,000
他们的原话是

410
00:18:09,000 --> 00:18:12,000
我都记得是 i 9 还是 i 10

411
00:18:12,000 --> 00:18:13,000
才会非常烂

412
00:18:13,000 --> 00:18:14,000
we all know that

413
00:18:14,000 --> 00:18:16,000
that's not something

414
00:18:16,000 --> 00:18:22,000
对,这是一个浏览器相关的毫无疑问

415
00:18:22,000 --> 00:18:26,000
对,所以这是在比方说

416
00:18:26,000 --> 00:18:27,000
modern crom 中

417
00:18:27,000 --> 00:18:29,000
如果你不停的 re-render 的话

418
00:18:29,000 --> 00:18:31,000
实际上也没有那么烂

419
00:18:31,000 --> 00:18:33,000
可是 of course we want

420
00:18:33,000 --> 00:18:35,000
better performance

421
00:18:35,000 --> 00:18:39,000
所以他们又脑洞大开的

422
00:18:39,000 --> 00:18:43,000
想把这个 dom 这个事情整个 gad incaps

423
00:18:43,000 --> 00:18:47,000
整个 gad virtualize

424
00:18:47,000 --> 00:18:51,000
所以开发者就完全不去操作这个 dom

425
00:18:51,000 --> 00:18:54,000
然后通过 react 本身的一套算法

426
00:18:54,000 --> 00:19:02,000
react 会试图发现两个 state 之间的区别

427
00:19:02,000 --> 00:19:07,000
帮你自动的去 update 真正的浏览器的 dom

428
00:19:07,000 --> 00:19:10,000
这就移除了 performance 的问题

429
00:19:10,000 --> 00:19:14,000
从我回过头来

430
00:19:14,000 --> 00:19:18,000
enable 了开发者去写更 descriptive

431
00:19:18,000 --> 00:19:20,000
更 declared 的 code

432
00:19:20,000 --> 00:19:24,000
而不是直接告诉浏览器去做什么

433
00:19:24,000 --> 00:19:27,000
对,这里就提到有一个 react

434
00:19:27,000 --> 00:19:29,000
它这个新的前端的

435
00:19:29,000 --> 00:19:31,000
它也比较框架工具

436
00:19:31,000 --> 00:19:33,000
它最核心的一点就是说

437
00:19:33,000 --> 00:19:37,000
它本身是和浏览器的 dom 是脱节的

438
00:19:37,000 --> 00:19:40,000
就是它没有一个很所谓的 tide coupling 在里面

439
00:19:40,000 --> 00:19:42,000
它 rendered 出来的结果并不是得到的

440
00:19:42,000 --> 00:19:44,000
一个真正的浏览器的 dom

441
00:19:44,000 --> 00:19:46,000
而是一个所以他们讲的一个虚拟的 dom

442
00:19:46,000 --> 00:19:48,000
virtualdom

443
00:19:48,000 --> 00:19:51,000
对,他们再有做了这么一个 diff 这一层

444
00:19:51,000 --> 00:19:53,000
然后再去说

445
00:19:53,000 --> 00:19:56,000
怎么用最小的代价使得浏览器里面

446
00:19:56,000 --> 00:19:58,000
现在有的那个真实的 dom

447
00:19:58,000 --> 00:20:02,000
能够变成你 virtualdom 需要的形状

448
00:20:02,000 --> 00:20:07,000
这样的话就可以尽量减少 dom 那边的交互的开销

449
00:20:07,000 --> 00:20:08,000
对

450
00:20:08,000 --> 00:20:10,000
当然前提假设就是说

451
00:20:10,000 --> 00:20:12,000
你跟真实的浏览器

452
00:20:12,000 --> 00:20:14,000
真实的 dom 的交互是一个比较高成本的

453
00:20:14,000 --> 00:20:17,000
但是在一个现代浏览器

454
00:20:17,000 --> 00:20:19,000
现代的 javascript 的解析器的情况下

455
00:20:19,000 --> 00:20:24,000
它的 javascript 内部的执行和解析的速度是非常快的

456
00:20:24,000 --> 00:20:26,000
所以要解决这两个之间的差异的话

457
00:20:26,000 --> 00:20:28,000
它就通过这种做 diff 的方法来实现了

458
00:20:28,000 --> 00:20:30,000
对,没错

459
00:20:30,000 --> 00:20:32,000
很有意思的是

460
00:20:32,000 --> 00:20:35,000
David Nolan 是那个系列叫做

461
00:20:35,000 --> 00:20:38,000
David Nolan 是 closer script 的作者

462
00:20:38,000 --> 00:20:42,000
然后他们有把 react 给

463
00:20:42,000 --> 00:20:46,000
写了一个 closer script 的 react 叫做 OM

464
00:20:46,000 --> 00:20:48,000
他给了一个 presentation

465
00:20:48,000 --> 00:20:50,000
然后他不把 virtualdom 叫做 virtualdom

466
00:20:50,000 --> 00:20:54,000
他把 virtualdom 叫做 dom virtual machine

467
00:20:54,000 --> 00:20:57,000
这是一个非常小的差异

468
00:20:57,000 --> 00:21:00,000
但是我想他想要说的是说

469
00:21:00,000 --> 00:21:04,000
这个 virtualdom 实际上是非常 powerful

470
00:21:06,000 --> 00:21:08,000
然后 react

471
00:21:08,000 --> 00:21:10,000
可能在思维哲学上

472
00:21:10,000 --> 00:21:11,000
我觉得有点很大的不同

473
00:21:11,000 --> 00:21:14,000
就是说传统上我们像用 backbound 之类的

474
00:21:14,000 --> 00:21:17,000
其实你是把 dom 当成一个巨大的 state

475
00:21:17,000 --> 00:21:20,000
然后你是在手工的去管理那些 state

476
00:21:20,000 --> 00:21:22,000
对吧

477
00:21:22,000 --> 00:21:23,000
然后可能就很多的操作

478
00:21:23,000 --> 00:21:27,000
可能要手动去添加什么 event handler

479
00:21:27,000 --> 00:21:28,000
然后发生什么事情

480
00:21:28,000 --> 00:21:30,000
你要记得把它取掉

481
00:21:30,000 --> 00:21:32,000
然后要做一些相应的修改

482
00:21:32,000 --> 00:21:36,000
就是整个来看交互的流程

483
00:21:36,000 --> 00:21:38,000
和你的 view

484
00:21:38,000 --> 00:21:40,000
它是混杂在比较

485
00:21:40,000 --> 00:21:42,000
叫什么

486
00:21:42,000 --> 00:21:42,000
对吗

487
00:21:42,000 --> 00:21:43,000
这个叫什么

488
00:21:43,000 --> 00:21:45,000
犬牙交错对吧

489
00:21:45,000 --> 00:21:46,000
对吧

490
00:21:46,000 --> 00:21:47,000
终于想起这个差异

491
00:21:47,000 --> 00:21:49,000
你用这么复杂的

492
00:21:49,000 --> 00:21:51,000
对

493
00:21:51,000 --> 00:21:53,000
但是像 react 这种思路的话

494
00:21:53,000 --> 00:21:54,000
他用 virtualdom 的思路

495
00:21:54,000 --> 00:21:57,000
其实刚才 virtualdom 已经解释过一下

496
00:21:57,000 --> 00:22:00,000
就是说他其实是放弃了这一条

497
00:22:00,000 --> 00:22:03,000
就说我们不要去手工去改

498
00:22:03,000 --> 00:22:06,000
一个浏览器里面 dom 的每一个小细节

499
00:22:06,000 --> 00:22:08,000
而是说我们你只要告诉我

500
00:22:08,000 --> 00:22:10,000
你需要让它达到什么样的状态

501
00:22:10,000 --> 00:22:11,000
当然这个需要

502
00:22:11,000 --> 00:22:13,000
你说你是一次性的描述性的状态吗

503
00:22:13,000 --> 00:22:14,000
对

504
00:22:14,000 --> 00:22:16,000
然后这样的话

505
00:22:16,000 --> 00:22:17,000
我就只需要说

506
00:22:17,000 --> 00:22:21,000
那我不需要考虑怎么去变到那个状态

507
00:22:21,000 --> 00:22:21,000
我只需要声明

508
00:22:21,000 --> 00:22:24,000
我最后要达到什么样的状态就可以了

509
00:22:24,000 --> 00:22:25,000
其实这个让我想起

510
00:22:25,000 --> 00:22:29,000
backbound 的一句宣传口号

511
00:22:29,000 --> 00:22:33,000
就是 get the truth out from your dome

512
00:22:33,000 --> 00:22:39,000
但实际上它的这个口号所指的是要把

513
00:22:39,000 --> 00:22:44,000
其实就是很简单的要把 dome 所要呈现的那层

514
00:22:44,000 --> 00:22:46,000
那些数据

515
00:22:46,000 --> 00:22:51,000
作为你的 model 从 dome 里面抽息出来

516
00:22:51,000 --> 00:22:58,000
但如果沿着这一句宣传口号更进一步研发的话

517
00:22:58,000 --> 00:23:00,000
我觉得可能最终结果就是像 react 这样

518
00:23:00,000 --> 00:23:03,000
就是将 dome 作为某种

519
00:23:03,000 --> 00:23:06,000
就像 screen buffer 一样

520
00:23:06,000 --> 00:23:10,000
就是计算出最终需要的 dome

521
00:23:10,000 --> 00:23:15,000
然后去更新它与实际的 dome 所差异的这部分

522
00:23:15,000 --> 00:23:19,000
这样可能更多的 truth

523
00:23:19,000 --> 00:23:22,000
被从 dome 里面抽息出来

524
00:23:22,000 --> 00:23:25,000
其实它这个思想也不是说远创性的

525
00:23:25,000 --> 00:23:28,000
就是在很多年前做游戏的

526
00:23:28,000 --> 00:23:30,000
大家都已经发现有这么一个

527
00:23:30,000 --> 00:23:32,000
就做那种就是电脑游戏的人

528
00:23:32,000 --> 00:23:34,000
都已经有这么一个概念了

529
00:23:34,000 --> 00:23:38,000
过去游戏有个叫做就是会智图形的话

530
00:23:38,000 --> 00:23:39,000
有个所谓的叫做 immediate mode

531
00:23:39,000 --> 00:23:40,000
就是立即模式

532
00:23:40,000 --> 00:23:42,000
就是你你画什么就在图像

533
00:23:42,000 --> 00:23:44,000
就在那个屏幕上出现什么

534
00:23:44,000 --> 00:23:46,000
然后发现其实这样的话

535
00:23:46,000 --> 00:23:48,000
对那个叫什么

536
00:23:48,000 --> 00:23:51,000
对性能其实是不好的

537
00:23:51,000 --> 00:23:54,000
然后在他们发现用什么 rainitain mode 的话

538
00:23:54,000 --> 00:23:56,000
你就是可以再让这个游戏引擎

539
00:23:56,000 --> 00:23:58,000
去做一些优化

540
00:23:58,000 --> 00:24:01,000
就是说把你先告诉他下一针会

541
00:24:01,000 --> 00:24:05,000
应该显示什么让他计算出两者的差异

542
00:24:05,000 --> 00:24:09,000
其实在 react count 上

543
00:24:09,000 --> 00:24:13,000
没有人提到跟游戏上的差异

544
00:24:13,000 --> 00:24:15,000
所以我有点就是

545
00:24:15,000 --> 00:24:17,000
自己在想在好奇说

546
00:24:17,000 --> 00:24:19,000
到底这个是一个殊途同归呢

547
00:24:19,000 --> 00:24:22,000
还是他们有真正的在那个

548
00:24:22,000 --> 00:24:25,000
游戏开发者身上提取灵感

549
00:24:25,000 --> 00:24:29,000
我更倾向于是相信是一个殊途同归的结果

550
00:24:29,000 --> 00:24:32,000
对对我也觉得那个 peter hunt

551
00:24:32,000 --> 00:24:36,000
他在那个去年的那个介绍 react 的那个会议上面

552
00:24:36,000 --> 00:24:37,000
他就讲了吗

553
00:24:37,000 --> 00:24:38,000
就说他们做发现

554
00:24:38,000 --> 00:24:41,000
诶他们那个做什么 3 D 游戏的人

555
00:24:41,000 --> 00:24:43,000
好像也是用了同样一套思路

556
00:24:43,000 --> 00:24:43,000
没错

557
00:24:43,000 --> 00:24:46,000
就是其实确实是一个殊途同归的一个结果

558
00:24:46,000 --> 00:24:46,000
对

559
00:24:46,000 --> 00:24:49,000
其实我相信现在的 web app 领域的

560
00:24:49,000 --> 00:24:57,000
很多技术可能在就是古早的 3 D 技术发展道路上

561
00:24:57,000 --> 00:24:58,000
都已经讨论过了

562
00:24:58,000 --> 00:25:05,000
然后有些经验可能也是会需要被 backport 过来的

563
00:25:05,000 --> 00:25:10,000
或者说其实我们把这个领域放得更宽广一点

564
00:25:10,000 --> 00:25:13,000
就是说前端如果不仅限于这个网页

565
00:25:13,000 --> 00:25:15,000
或者是一个客户端的 app 的话

566
00:25:15,000 --> 00:25:17,000
就是游戏从你从某种意义上来讲

567
00:25:17,000 --> 00:25:19,000
也是在在做一个前端的东西吗

568
00:25:19,000 --> 00:25:23,000
我觉得游戏可能最大的差别是

569
00:25:23,000 --> 00:25:29,000
他和他的前端和后端之间的差异

570
00:25:29,000 --> 00:25:35,000
他的前端和后端之间没有中间隔着这么巨大的一个互联网的红钩

571
00:25:35,000 --> 00:25:41,000
就是他中间的通讯没有这么大的一个延迟

572
00:25:41,000 --> 00:25:44,000
或者说有这么大的一个协议站摆在那边

573
00:25:45,000 --> 00:25:48,000
现在你很多游戏也是这种网络的 network game

574
00:25:48,000 --> 00:25:50,000
所以其实还是有很大相似点的

575
00:25:50,000 --> 00:25:55,000
但那一部分仅仅是用来交互游戏数据的

576
00:25:55,000 --> 00:26:03,000
你的表现层的数据仍就是在本地生成

577
00:26:03,000 --> 00:26:05,000
除非你是在做 streaming

578
00:26:05,000 --> 00:26:07,000
但是 streaming 又是另外一话题了

579
00:26:09,000 --> 00:26:10,000
对 这也是一个问题

580
00:26:11,000 --> 00:26:12,000
React 其实还有一点

581
00:26:12,000 --> 00:26:16,000
就是说它是更倾向于你使用所有的 immutable data structure

582
00:26:16,000 --> 00:26:19,000
就是不可修改的数据结构

583
00:26:19,000 --> 00:26:23,000
这点上我们在 concern 有提到

584
00:26:23,000 --> 00:26:26,000
然后顺带说我非常喜欢

585
00:26:26,000 --> 00:26:30,000
我在 Reactcon 上我真的非常高兴非常激动

586
00:26:30,000 --> 00:26:35,000
因为传统上来说前端不是一个很 hardcore CS 的东西

587
00:26:35,000 --> 00:26:40,000
比如说大家一般看前端看法者都有一点小鄙视的意思

588
00:26:40,000 --> 00:26:45,000
对 更加工程导向而不是理工导向

589
00:26:45,000 --> 00:26:47,000
更加 25 岁以上的导向

590
00:26:47,000 --> 00:26:49,000
不要这么黑

591
00:26:49,000 --> 00:26:51,000
不不 我又想起来

592
00:26:51,000 --> 00:26:56,000
所以正是在这个 conference 上

593
00:26:56,000 --> 00:26:58,000
我们有听到很多很有意思的东西

594
00:26:58,000 --> 00:27:00,000
其中有一个是 immutable data

595
00:27:00,000 --> 00:27:05,000
我们有一个演讲是 Leigh Byron 给的演讲

596
00:27:05,000 --> 00:27:13,000
在专门说 immutable data is Facebook 的 immutable data JavaScript 实现

597
00:27:13,000 --> 00:27:18,000
他有讲到很多 immutable data 到底是什么东西

598
00:27:18,000 --> 00:27:21,000
怎么在 java school 上实现的 非常好

599
00:27:21,000 --> 00:27:25,000
这是 backed out React 上来说的话

600
00:27:25,000 --> 00:27:28,000
之所以 immutable data 是 preferred

601
00:27:28,000 --> 00:27:31,000
not required but preferred 是因为

602
00:27:31,000 --> 00:27:33,000
正因为 react 它的设计方式

603
00:27:33,000 --> 00:27:43,000
整个的 render 的过程整个的 component 实际上就是 probs plus state equal to something

604
00:27:43,000 --> 00:27:46,000
这个 equal 是 render 的方式所做的事情

605
00:27:46,000 --> 00:27:50,000
所以如果你的 probs 跟 state 不变化的话

606
00:27:50,000 --> 00:27:55,000
你的 render result 总是一致的 总会是一样的

607
00:27:55,000 --> 00:27:59,000
虽然说 virtual DOM 会帮助你不去 update the DOM

608
00:27:59,000 --> 00:28:07,000
但是连 render 的方式都不用去 wrong 的话

609
00:28:07,000 --> 00:28:11,000
那就实现了更好的 performance

610
00:28:11,000 --> 00:28:16,000
然后省下更多的时间 特别是在大型的 application 上

611
00:28:16,000 --> 00:28:22,000
但是怎么去判断 probs 跟 state 有没有改变就变成了一个很大的问题

612
00:28:22,000 --> 00:28:25,000
传统的 mutable data 的话就至少是个 on 的操作

613
00:28:25,000 --> 00:28:31,000
你必须得把整个 object 给变立了

614
00:28:31,000 --> 00:28:35,000
如果你要做 deep comparison 的话就更大了

615
00:28:35,000 --> 00:28:38,000
是一个输状结构

616
00:28:38,000 --> 00:28:43,000
imutable data 实现了 constant time 的 comparison

617
00:28:43,000 --> 00:28:45,000
就是 01

618
00:28:45,000 --> 00:28:48,000
你只能判断一个指真吗等于说最后一辈子

619
00:28:48,000 --> 00:28:53,000
时间跟空间是花在其他的部分了

620
00:28:53,000 --> 00:28:58,000
但是在 render 上更有帮助非常快

621
00:28:58,000 --> 00:29:05,000
我们在跟其他的议会者讨论的时候也提到很多人

622
00:29:05,000 --> 00:29:09,000
一开始也没有用 imutable data

623
00:29:09,000 --> 00:29:12,000
但越用 react 越觉得这个 total makes sense

624
00:29:12,000 --> 00:29:15,000
为什么不用呢

625
00:29:15,000 --> 00:29:18,000
所以 imutable data 这个事情非常有意思

626
00:29:18,000 --> 00:29:22,000
就不是一个传统意义上 java school care 的东西

627
00:29:22,000 --> 00:29:30,000
这因为对于 imutable data 的细号

628
00:29:30,000 --> 00:29:34,000
才导致了 closer script 的 java react 的行列

629
00:29:34,000 --> 00:29:37,000
因为 closer 它所有的 data 本来就是 imutable

630
00:29:37,000 --> 00:29:38,000
它是 function language

631
00:29:38,000 --> 00:29:40,000
它所有的 data 都是 imutable 的

632
00:29:40,000 --> 00:29:48,000
所以就很 natural 它的 framwork 就很好的利用这样一个特性

633
00:29:48,000 --> 00:29:50,000
对 三次我看了一个 OM

634
00:29:50,000 --> 00:29:53,000
就是 closer script 的 react 实现

635
00:29:53,000 --> 00:29:55,000
他们的性能确实非常了不得得

636
00:29:55,000 --> 00:29:56,000
因为刚才讲了嘛

637
00:29:56,000 --> 00:29:59,000
因为在 OM 里面整个

638
00:29:59,000 --> 00:30:03,000
大部分的 data structure 都是所有 imutable 的话

639
00:30:03,000 --> 00:30:07,000
他们在渲染的时候就足够走那个树状结构

640
00:30:07,000 --> 00:30:11,000
然后判断根结点的指真就好了

641
00:30:11,000 --> 00:30:13,000
这是非常快速的一个过程

642
00:30:14,000 --> 00:30:17,000
顺带说在整个 conference 中

643
00:30:17,000 --> 00:30:20,000
我们有提到非常多的 performance trick

644
00:30:20,000 --> 00:30:22,000
怎么样实现更好的 performance

645
00:30:22,000 --> 00:30:23,000
imutable 是其中之一

646
00:30:23,000 --> 00:30:25,000
我们有提到很多其他的东西

647
00:30:25,000 --> 00:30:28,000
如果听众同学们有兴趣的话

648
00:30:28,000 --> 00:30:31,000
可以找到这些 keynote 也可以写信问我

649
00:30:31,000 --> 00:30:34,000
或者告诉 react 我们说明一下

650
00:30:34,000 --> 00:30:39,000
其实可以做更多关于 react 的更细节更优化的东西

651
00:30:40,000 --> 00:30:45,000
对怎么过他们看现场那个视频

652
00:30:45,000 --> 00:30:46,000
先跟他说一下

653
00:30:46,000 --> 00:30:52,000
这次 reactcon 2015 的所有的视频都在 youtube 上面有的

654
00:30:52,000 --> 00:30:56,000
但是因为现在国内 VPN 也打击的比较严重

655
00:30:56,000 --> 00:30:58,000
能不能看到就不好说了

656
00:30:58,000 --> 00:31:00,000
他不是所有都在吧

657
00:31:00,000 --> 00:31:01,000
好像可以吧

658
00:31:01,000 --> 00:31:08,000
我在看今天 youtube 上有个频道叫做 facebook developer 的频道

659
00:31:08,000 --> 00:31:12,000
然后这个 channel 基本上应该你需要的都可以看到

660
00:31:12,000 --> 00:31:14,000
我就说国内的

661
00:31:14,000 --> 00:31:16,000
我们听众认识在国内

662
00:31:16,000 --> 00:31:19,000
他们没有办法去上 youtube

663
00:31:19,000 --> 00:31:21,000
我觉得我们要 check 一下

664
00:31:21,000 --> 00:31:24,000
我好像只有他只有三个吧

665
00:31:24,000 --> 00:31:25,000
只有 relay

666
00:31:25,000 --> 00:31:27,000
他有 imutable.js 的 kinda 吗

667
00:31:27,000 --> 00:31:29,000
他现在他在逐渐放

668
00:31:29,000 --> 00:31:30,000
他已经放了九个

669
00:31:30,000 --> 00:31:33,000
我觉得他应该可能还是在做一些剪辑之类的工作

670
00:31:33,000 --> 00:31:36,000
对 最终是要他要把全部放上去

671
00:31:36,000 --> 00:31:38,000
他没有理由不放出来

672
00:31:38,000 --> 00:31:39,000
因为

673
00:31:39,000 --> 00:31:40,000
对对

674
00:31:40,000 --> 00:31:41,000
反正一共是有

675
00:31:41,000 --> 00:31:43,000
一共是多少个 talk 来的

676
00:31:43,000 --> 00:31:46,000
有两天是 12 个 9 个

677
00:31:46,000 --> 00:31:48,000
anyways

678
00:31:48,000 --> 00:31:50,000
就是想 fact check 一下

679
00:31:50,000 --> 00:31:52,000
没有没有 起来一次

680
00:31:52,000 --> 00:31:55,000
有的 这也不用担心

681
00:31:57,000 --> 00:32:00,000
然后其实说 react

682
00:32:00,000 --> 00:32:05,000
他我们传统上一般认为他是在 mvc 里面做的 v 的那个角色对吧

683
00:32:06,000 --> 00:32:08,000
但是我们传统一个 mvc 的话

684
00:32:08,000 --> 00:32:11,000
那个像 m 和 c 那部分怎么解决

685
00:32:11,000 --> 00:32:16,000
其实在相当强调的时间内还是没有很好的一个方案吧

686
00:32:16,000 --> 00:32:18,000
但是去年年末的时候

687
00:32:18,000 --> 00:32:22,000
他们公开了一个叫做 flex 的这么一个架构吧

688
00:32:22,000 --> 00:32:25,000
也不算是一个就是一个指导方针

689
00:32:25,000 --> 00:32:31,000
只能说是就是你怎么去用 react 方式去构建一个传统的 mvc 的实现的时候

690
00:32:31,000 --> 00:32:32,000
你要注意一下什么问题

691
00:32:32,000 --> 00:32:35,000
这个 flex 我觉得也是一个非常

692
00:32:35,000 --> 00:32:40,000
具有什么画时代意义的一个方式

693
00:32:40,000 --> 00:32:41,000
就刚刚一讲那个

694
00:32:41,000 --> 00:32:43,000
我怎么记得就是 flex 出来的时候黑客 Newson

695
00:32:43,000 --> 00:32:47,000
有人黑衣说他们 rediscover 了一个非常古老的 idea

696
00:32:47,000 --> 00:32:50,000
然后把它重新包装了一遍

697
00:32:50,000 --> 00:32:52,000
然后改名叫 flex

698
00:32:52,000 --> 00:32:54,000
但其实起码在前端开发名义

699
00:32:54,000 --> 00:32:56,000
它确实是一个挺好的事情

700
00:32:56,000 --> 00:32:56,000
我觉得

701
00:32:56,000 --> 00:33:01,000
其实这一点上我跟 Wutaus 所说的有一点类似

702
00:33:01,000 --> 00:33:06,000
我至今呢也觉得 flex 的 idea 实际

703
00:33:06,000 --> 00:33:08,000
怎么说我如果看历史的话

704
00:33:08,000 --> 00:33:11,000
你如果有看我有看所有的 flex 的 video 这些东西

705
00:33:11,000 --> 00:33:12,000
你看的话

706
00:33:12,000 --> 00:33:18,000
他们最初 flex 要解决的问题并不是真正的 mvc

707
00:33:18,000 --> 00:33:23,000
我觉得他们在最初在 inventive flux 的时候

708
00:33:23,000 --> 00:33:28,000
他们所使用的那个做事情的方式呢并不是真正的 mvc

709
00:33:29,000 --> 00:33:31,000
但是这并不是说 flex 就不好

710
00:33:31,000 --> 00:33:34,000
就不是因此 flex 这个框架就不对

711
00:33:35,000 --> 00:33:36,000
就我

712
00:33:38,000 --> 00:33:43,000
很有意思的是在 reactcom 上那些 speaker 反复的提到

713
00:33:44,000 --> 00:33:46,000
他们最初发布 react 的时候

714
00:33:46,000 --> 00:33:54,000
大家的反应最初发布 react 是在 jscowns 的 2013 年的 jscowns 上

715
00:33:55,000 --> 00:33:57,000
他的反应都非常 negative

716
00:33:57,000 --> 00:33:59,000
叫做 reinventive view

717
00:33:59,000 --> 00:34:01,000
we are reinventing the wheel

718
00:34:01,000 --> 00:34:03,000
reinventive the best practices

719
00:34:05,000 --> 00:34:12,000
后来 peter 甚至给了一个 rethinking best practice 的一个 speech

720
00:34:13,000 --> 00:34:17,000
所以上完这个会呢

721
00:34:17,000 --> 00:34:20,000
我也是觉得大家还是保持一个开放的心态

722
00:34:20,000 --> 00:34:21,000
也不需要去 hate 他或怎么样

723
00:34:21,000 --> 00:34:23,000
毕竟说我们也不能够

724
00:34:25,000 --> 00:34:27,000
怎么说就是没手成归

725
00:34:27,000 --> 00:34:29,000
一定说之前东西就是好的

726
00:34:29,000 --> 00:34:31,000
如果 flex 能够解决你所要解决的问题

727
00:34:31,000 --> 00:34:34,000
如果 flex 能够解决的问题

728
00:34:34,000 --> 00:34:36,000
你清楚你的问题是什么

729
00:34:36,000 --> 00:34:37,000
我觉得这才是最重要对不对

730
00:34:38,000 --> 00:34:40,000
所以 back 到 flex 上面来说

731
00:34:40,000 --> 00:34:43,000
它实际上跟传统一样 mvc 有非常多的相似的地方

732
00:34:45,000 --> 00:34:46,000
它整个 distraction mode

733
00:34:46,000 --> 00:34:50,000
整个的这个 event 的流程

734
00:34:50,000 --> 00:34:53,000
这个单项的信息的流动

735
00:34:53,000 --> 00:34:57,000
实际上跟传统一样 mvc 是非常非常类似的

736
00:34:57,000 --> 00:34:59,000
但是它有细节上的差异

737
00:34:59,000 --> 00:35:03,000
比方说 action 是 global 的 dispatch 是 global 的

738
00:35:03,000 --> 00:35:08,000
比方说在一个信息没有流完的情况下

739
00:35:08,000 --> 00:35:10,000
你不能够 initialize 另外一个信息

740
00:35:10,000 --> 00:35:12,000
像这样的细节的差异

741
00:35:12,000 --> 00:35:18,000
实际上是实际上就 e-wage of flux 跟传统的 mvc 不一样

742
00:35:18,000 --> 00:35:20,000
特别是在

743
00:35:20,000 --> 00:35:22,000
不要说如果我们用 backflex

744
00:35:23,000 --> 00:35:27,000
如果 model 触发一个 changeevent

745
00:35:27,000 --> 00:35:29,000
这个 changeevent 的 event handle

746
00:35:29,000 --> 00:35:31,000
是可以再去改变 model

747
00:35:31,000 --> 00:35:34,000
然后从而就产生另外一个 changeevent

748
00:35:34,000 --> 00:35:37,000
它有 cascading 的效果在

749
00:35:38,000 --> 00:35:44,000
flex 的它的发明跟 cascading 非常关系

750
00:35:44,000 --> 00:35:46,000
一个重点的原因

751
00:35:46,000 --> 00:35:48,000
要他们去发明这个 flex

752
00:35:48,000 --> 00:35:49,000
就是不想要 cascading

753
00:35:49,000 --> 00:35:51,000
应该是要细小的一些

754
00:35:51,000 --> 00:35:52,000
因为太难管理了

755
00:35:52,000 --> 00:35:54,000
你不知道什么就行

756
00:35:54,000 --> 00:35:56,000
你不知道细节的情况

757
00:35:56,000 --> 00:36:00,000
就好像 react 它本身

758
00:36:00,000 --> 00:36:08,000
想要把 code 更 declared 化

759
00:36:08,000 --> 00:36:10,000
flex 也有这样的目的

760
00:36:10,000 --> 00:36:12,000
就是让 flow 更清晰

761
00:36:12,000 --> 00:36:15,000
每次的 action 都是导致同一个结果

762
00:36:15,000 --> 00:36:16,000
同一个方向流动

763
00:36:16,000 --> 00:36:20,000
然后你不会触发另外一个

764
00:36:20,000 --> 00:36:22,000
所没有预料到的结果

765
00:36:22,000 --> 00:36:23,000
这点上

766
00:36:23,000 --> 00:36:25,000
如果你真正去用 flex 的话

767
00:36:25,000 --> 00:36:28,000
会发现实际上是非常非常非常有帮助的

768
00:36:28,000 --> 00:36:31,000
对你管理你的程序的复杂度

769
00:36:31,000 --> 00:36:32,000
对

770
00:36:32,000 --> 00:36:34,000
我个人感觉

771
00:36:34,000 --> 00:36:38,000
就是我之前是在做一些小的 project

772
00:36:38,000 --> 00:36:40,000
就是去尝试用 flex 这种架构

773
00:36:40,000 --> 00:36:42,000
但是我具体用的是一个叫做 reflux 的

774
00:36:42,000 --> 00:36:43,000
一个具体的实现

775
00:36:43,000 --> 00:36:45,000
但是它在逻辑上是大同小异的

776
00:36:45,000 --> 00:36:49,000
就是有些细微的组件上有点不一样

777
00:36:49,000 --> 00:36:50,000
我感觉就是有很明显的区别

778
00:36:50,000 --> 00:36:54,000
就是说采用了 flex 架构之后

779
00:36:54,000 --> 00:36:57,000
整个前端应用的逻辑

780
00:36:57,000 --> 00:36:59,000
变得非常有条理和清晰

781
00:36:59,000 --> 00:37:01,000
就知道边界在哪里

782
00:37:01,000 --> 00:37:03,000
然后哪些数据在哪里管理

783
00:37:03,000 --> 00:37:04,000
就最开始的时候

784
00:37:04,000 --> 00:37:06,000
你提到像用 backbound 的时候

785
00:37:06,000 --> 00:37:08,000
有些数据是混在 dome 里面的

786
00:37:08,000 --> 00:37:08,000
对吧

787
00:37:08,000 --> 00:37:09,000
这样其实

788
00:37:09,000 --> 00:37:10,000
这如果用 flex 的方式的话

789
00:37:10,000 --> 00:37:12,000
就其实完全分离开了

790
00:37:12,000 --> 00:37:14,000
它有所谓的 store 的概念

791
00:37:14,000 --> 00:37:18,000
就大约等同于以前 mvc 里面的 model

792
00:37:18,000 --> 00:37:20,000
但是说它的 store 里面

793
00:37:20,000 --> 00:37:22,000
它有一些具体的限制

794
00:37:22,000 --> 00:37:25,000
刚才比如说你不能说 store 出发

795
00:37:25,000 --> 00:37:27,000
cascading 的东西出来

796
00:37:27,000 --> 00:37:29,000
这样其实然后就可以保证你这个

797
00:37:29,000 --> 00:37:31,000
信息的流向是单向的

798
00:37:31,000 --> 00:37:34,000
这样的话就可以让你很方便的

799
00:37:34,000 --> 00:37:37,000
去把所谓的 separation of concern

800
00:37:37,000 --> 00:37:40,000
就是把那些需要关注的点准分格开来做

801
00:37:40,000 --> 00:37:45,000
对这个整个架构是很有帮助的一个工具

802
00:37:45,000 --> 00:37:48,000
然后 flex 其实从 facebook 的角度来说的话

803
00:37:48,000 --> 00:37:50,000
实际上只是一个 idea

804
00:37:50,000 --> 00:37:53,000
它对你到底说你的 dispatch 是什么

805
00:37:53,000 --> 00:37:54,000
你的 action 是什么

806
00:37:54,000 --> 00:37:56,000
你的 storage 是怎么实现的

807
00:37:56,000 --> 00:37:59,000
并没有很严格意义上的管理

808
00:38:00,000 --> 00:38:02,000
就是因为如此

809
00:38:02,000 --> 00:38:07,000
像我们在做这个从 back to react 的一个歉意

810
00:38:07,000 --> 00:38:09,000
从一地程度上来说

811
00:38:09,000 --> 00:38:11,000
我可以用传统的 backbone model

812
00:38:11,000 --> 00:38:14,000
backbone collection 来实现 flex

813
00:38:14,000 --> 00:38:15,000
这是可能的

814
00:38:15,000 --> 00:38:16,000
这是完全可能的

815
00:38:20,000 --> 00:38:20,000
所以就是

816
00:38:21,000 --> 00:38:23,000
again 不要拘泥于书本上的概念

817
00:38:24,000 --> 00:38:27,000
去想一想就要解决了问题

818
00:38:27,000 --> 00:38:29,000
然后去看一看这个 architect

819
00:38:29,000 --> 00:38:31,000
到底能不能解决这个问题

820
00:38:31,000 --> 00:38:32,000
才是最重要的

821
00:38:32,000 --> 00:38:35,000
而且 flex 可能在一定程度上来说

822
00:38:35,000 --> 00:38:38,000
只有对大型的 application 才有意义

823
00:38:38,000 --> 00:38:42,000
你要想 facebook 所要解决的问题是 massive skill

824
00:38:42,000 --> 00:38:44,000
他们有 hundreds of engineer

825
00:38:44,000 --> 00:38:48,000
如果你只有一两个人在一个程序上工作的话

826
00:38:48,000 --> 00:38:49,000
那或许有更轻巧

827
00:38:50,000 --> 00:38:51,000
更便宜的

828
00:38:53,000 --> 00:38:54,000
加工你能够选择

829
00:38:54,000 --> 00:38:56,000
对可能用不上用使用这种

830
00:38:56,000 --> 00:38:58,000
就所谓大规模擅擅性无期

831
00:39:01,000 --> 00:39:01,000
对

832
00:39:03,000 --> 00:39:05,000
react 还有一个好处

833
00:39:05,000 --> 00:39:08,000
就是说所谓构建 isomorphic

834
00:39:08,000 --> 00:39:11,000
的 javascript 应用情况会比较好的

835
00:39:11,000 --> 00:39:12,000
因为它可以

836
00:39:12,000 --> 00:39:13,000
同样的一个 react 组建

837
00:39:13,000 --> 00:39:16,000
只要你构建的方式稍微注意一点点

838
00:39:17,000 --> 00:39:20,000
它是可以在客户端渲染

839
00:39:20,000 --> 00:39:22,000
或者是在客户端渲染

840
00:39:22,000 --> 00:39:24,000
然后在服务端渲染它有一个什么好处呢

841
00:39:24,000 --> 00:39:25,000
它可以在服务端渲染

842
00:39:25,000 --> 00:39:28,000
从最初的那个页面结构之后

843
00:39:28,000 --> 00:39:30,000
你把这个送给柔软器

844
00:39:30,000 --> 00:39:31,000
然后在柔软器在接着

845
00:39:32,000 --> 00:39:35,000
服务端渲染那个部分开始

846
00:39:35,000 --> 00:39:37,000
在完成后面的后续的工作

847
00:39:37,000 --> 00:39:38,000
这个我不太清楚

848
00:39:38,000 --> 00:39:40,000
就是之前有其他类型的框架

849
00:39:40,000 --> 00:39:42,000
实现过这种功能没

850
00:39:42,000 --> 00:39:44,000
但是我第一次看到这个时候

851
00:39:44,000 --> 00:39:45,000
觉得还是蛮惊奇的

852
00:39:46,000 --> 00:39:47,000
as far as I know

853
00:39:47,000 --> 00:39:51,000
如果你小心意义的写你的 app 的话

854
00:39:51,000 --> 00:39:53,000
是有可能用其他的框架

855
00:39:53,000 --> 00:39:56,000
加上 fantomjs 这种 headless webkit

856
00:39:56,000 --> 00:39:58,000
来实现相同的功能的

857
00:39:58,000 --> 00:40:00,000
是我觉得理论上是有可能的

858
00:40:01,000 --> 00:40:04,000
但是在这个太好控制

859
00:40:04,000 --> 00:40:06,000
就性能上的话会损失很多

860
00:40:06,000 --> 00:40:10,000
因为你毕竟要 run 一个 webkit 在你的 server 上

861
00:40:10,000 --> 00:40:12,000
我发展到现在实际上

862
00:40:12,000 --> 00:40:14,000
也解决了非常多的问题吧

863
00:40:14,000 --> 00:40:15,000
它变成一个 server

864
00:40:15,000 --> 00:40:16,000
而不是你每次都要

865
00:40:17,000 --> 00:40:21,000
放那个 overhead 去 run 这个 webkit 在里头

866
00:40:22,000 --> 00:40:24,000
当然 react 有更大的可能性

867
00:40:24,000 --> 00:40:27,000
因为毕竟那个 dom 是 virtual artist

868
00:40:27,000 --> 00:40:28,000
所以

869
00:40:28,000 --> 00:40:31,000
对 它不需要去 load 一个真正的 webkit 的引擎

870
00:40:31,000 --> 00:40:33,000
它只需要在 javascript 内部

871
00:40:33,000 --> 00:40:36,000
去虚构一个这么一个 dom 结构

872
00:40:36,000 --> 00:40:38,000
这次我们在 conference 上

873
00:40:38,000 --> 00:40:42,000
有听到很多公司谈到他们的应用

874
00:40:42,000 --> 00:40:43,000
大部分的原因呢

875
00:40:43,000 --> 00:40:44,000
也不是因为性能

876
00:40:44,000 --> 00:40:46,000
而是因为 acio

877
00:40:46,000 --> 00:40:48,000
很多公司很 concerned acio

878
00:40:48,000 --> 00:40:51,000
然后现在 javascript acio

879
00:40:51,000 --> 00:40:54,000
还是一个没能解决的问题

880
00:40:54,000 --> 00:40:55,000
surprise of it

881
00:40:55,000 --> 00:40:56,000
过去中国年了

882
00:40:56,000 --> 00:40:58,000
人就是一个

883
00:40:58,000 --> 00:40:58,000
crazy

884
00:40:58,000 --> 00:40:59,000
crazy

885
00:40:59,000 --> 00:41:00,000
somehow scary

886
00:41:00,000 --> 00:41:03,000
有公司提到说

887
00:41:04,000 --> 00:41:08,000
你知道 Google 有一个 convention

888
00:41:08,000 --> 00:41:08,000
就是

889
00:41:08,000 --> 00:41:11,000
如果你的 url 是一个

890
00:41:11,000 --> 00:41:12,000
特别的什么结构的话

891
00:41:12,000 --> 00:41:12,000
它会

892
00:41:14,000 --> 00:41:17,000
它会尝试去 fetch 另外一个 url

893
00:41:17,000 --> 00:41:18,000
which is supposed to be a static page

894
00:41:19,000 --> 00:41:19,000
但是

895
00:41:21,000 --> 00:41:23,000
according to some other companies

896
00:41:24,000 --> 00:41:25,000
这个功能非常

897
00:41:26,000 --> 00:41:27,000
Google 不怎么在意这个功能

898
00:41:27,000 --> 00:41:28,000
然后经常就坏掉了

899
00:41:28,000 --> 00:41:29,000
所以他们

900
00:41:29,000 --> 00:41:30,000
经常

901
00:41:30,000 --> 00:41:33,000
经常就 fetch rate

902
00:41:33,000 --> 00:41:33,000
drop 到零

903
00:41:33,000 --> 00:41:34,000
你知道吗

904
00:41:34,000 --> 00:41:35,000
对于公司来说

905
00:41:35,000 --> 00:41:36,000
就是 disaster

906
00:41:36,000 --> 00:41:38,000
他们很多公司

907
00:41:38,000 --> 00:41:40,000
都是很靠 Google 的流量

908
00:41:40,000 --> 00:41:42,000
如果说有这样一个问题的话

909
00:41:42,000 --> 00:41:45,000
对他们的 business is critical

910
00:41:45,000 --> 00:41:46,000
他们

911
00:41:46,000 --> 00:41:47,000
所以他们就

912
00:41:47,000 --> 00:41:48,000
电达期贺

913
00:41:48,000 --> 00:41:49,000
非常非常在意

914
00:41:49,000 --> 00:41:50,000
这个 asomorphic 的

915
00:41:51,000 --> 00:41:52,000
可能性

916
00:41:52,000 --> 00:41:53,000
对

917
00:41:53,000 --> 00:41:54,000
而且之前

918
00:41:54,000 --> 00:41:55,000
之前说 Google 说

919
00:41:55,000 --> 00:41:56,000
它说

920
00:41:56,000 --> 00:41:56,000
一干一种

921
00:41:56,000 --> 00:41:57,000
是一种方式

922
00:41:57,000 --> 00:41:59,000
通过一种特殊的 url 结构去说

923
00:41:59,000 --> 00:42:01,000
告知 Google 的爬虫

924
00:42:01,000 --> 00:42:02,000
我这个动态网页

925
00:42:02,000 --> 00:42:04,000
你可以在另外一个地址找到

926
00:42:04,000 --> 00:42:05,000
它的静态版本

927
00:42:05,000 --> 00:42:05,000
这是一个

928
00:42:05,000 --> 00:42:07,000
一个比较传统的解决方案

929
00:42:07,000 --> 00:42:08,000
然后 Google 是

930
00:42:08,000 --> 00:42:10,000
这应该是去年年末的时候

931
00:42:10,000 --> 00:42:11,000
它是说

932
00:42:12,000 --> 00:42:13,000
他们也会渲染 javascript 的

933
00:42:13,000 --> 00:42:14,000
这个页面

934
00:42:14,000 --> 00:42:15,000
就是它会当

935
00:42:15,000 --> 00:42:17,000
把自己模拟成一个

936
00:42:18,000 --> 00:42:18,000
浏览器

937
00:42:18,000 --> 00:42:18,000
叫什么

938
00:42:19,000 --> 00:42:20,000
一个

939
00:42:20,000 --> 00:42:21,000
浏览器的引擎

940
00:42:21,000 --> 00:42:23,000
去解析那个页面的 javascript 引擎

941
00:42:23,000 --> 00:42:24,000
但是现在问题就是说

942
00:42:24,000 --> 00:42:25,000
它没有办法去判断

943
00:42:25,000 --> 00:42:27,000
哪些东西是可以点的

944
00:42:27,000 --> 00:42:28,000
因为你知道浏览器

945
00:42:28,000 --> 00:42:29,000
就是 javascript 里面的

946
00:42:29,000 --> 00:42:30,000
很多可以点击

947
00:42:30,000 --> 00:42:30,000
可以

948
00:42:30,000 --> 00:42:32,000
可以 nabogate 的项目

949
00:42:32,000 --> 00:42:33,000
它并不像

950
00:42:33,000 --> 00:42:35,000
说网页上你是一个 A 的那种

951
00:42:35,000 --> 00:42:36,000
这个 anchor 的 tag

952
00:42:36,000 --> 00:42:38,000
可以去很明显的发现

953
00:42:38,000 --> 00:42:38,000
对吧

954
00:42:38,000 --> 00:42:40,000
所以其实对他们来讲

955
00:42:40,000 --> 00:42:41,000
速度引擎去

956
00:42:41,000 --> 00:42:43,000
发现这些动态的内容

957
00:42:43,000 --> 00:42:44,000
始终是有问题的

958
00:42:45,000 --> 00:42:46,000
所以在这种情况下

959
00:42:46,000 --> 00:42:47,000
那种 isomorphic 的

960
00:42:48,000 --> 00:42:49,000
还是不可避免

961
00:42:50,000 --> 00:42:51,000
然后我的感觉就是说

962
00:42:51,000 --> 00:42:53,000
用 react 这种方式来实现

963
00:42:53,000 --> 00:42:54,000
isomorphic 的话

964
00:42:54,000 --> 00:42:56,000
它的难度是

965
00:42:56,000 --> 00:42:58,000
相就极大地被降低了

966
00:42:58,000 --> 00:43:00,000
就相对于你之前手工的去

967
00:43:00,000 --> 00:43:01,000
要么用 Fantasy 去做一个

968
00:43:01,000 --> 00:43:03,000
这个什么 Render Farm

969
00:43:03,000 --> 00:43:04,000
手工的去渲染一下

970
00:43:04,000 --> 00:43:06,000
因为这个比较高成本

971
00:43:06,000 --> 00:43:07,000
然后另外就是说

972
00:43:07,000 --> 00:43:08,000
它可以实现这个所谓的

973
00:43:08,000 --> 00:43:09,000
无缝迁移

974
00:43:09,000 --> 00:43:10,000
就是你可以随意决定

975
00:43:10,000 --> 00:43:12,000
哪一部分是在服务端渲染

976
00:43:12,000 --> 00:43:14,000
然后哪一部分是在

977
00:43:14,000 --> 00:43:15,000
这个客户端渲染

978
00:43:15,000 --> 00:43:17,000
这个是非常不错的一个工具

979
00:43:17,000 --> 00:43:19,000
刚 Rio 做了一个非常好的总统

980
00:43:21,000 --> 00:43:22,000
在实际的运运中

981
00:43:23,000 --> 00:43:26,000
react 可能是最好的 balance

982
00:43:26,000 --> 00:43:28,000
就是性能跟可管理性

983
00:43:28,000 --> 00:43:29,000
最好的 balance

984
00:43:29,000 --> 00:43:31,000
如果你的应用条件是

985
00:43:31,000 --> 00:43:35,000
你要需要非常好的 performance 的话

986
00:43:35,000 --> 00:43:36,000
那或许你应该

987
00:43:37,000 --> 00:43:39,000
去看其他的一些选项

988
00:43:39,000 --> 00:43:40,000
比方说用

989
00:43:41,000 --> 00:43:42,000
共用 template

990
00:43:42,000 --> 00:43:44,000
而不是共用 javascript logic

991
00:43:44,000 --> 00:43:46,000
然后在服务器端

992
00:43:46,000 --> 00:43:48,000
用服务器的 native language

993
00:43:48,000 --> 00:43:50,000
whatever php or java

994
00:43:51,000 --> 00:43:54,000
来写 template render function

995
00:43:54,000 --> 00:43:55,000
这样的话

996
00:43:55,000 --> 00:43:58,000
你要写两个 render application

997
00:44:00,000 --> 00:44:03,000
在你的工程上是更麻烦

998
00:44:03,000 --> 00:44:05,000
但是如果你要追求性能的话

999
00:44:05,000 --> 00:44:06,000
那是一个更好的选项

1000
00:44:07,000 --> 00:44:09,000
react 现在的问题是在于说

1001
00:44:10,000 --> 00:44:12,000
即使你在服务器端渲染

1002
00:44:13,000 --> 00:44:16,000
react 还是会给你做很多

1003
00:44:16,000 --> 00:44:17,000
不必要的 dom 的操作

1004
00:44:18,000 --> 00:44:19,000
或者是模拟

1005
00:44:20,000 --> 00:44:23,000
有什么具体的情况

1006
00:44:23,000 --> 00:44:24,000
sresort

1007
00:44:24,000 --> 00:44:27,000
有公司做了测试

1008
00:44:27,000 --> 00:44:28,000
然后 sresort

1009
00:44:28,000 --> 00:44:29,000
相对于说

1010
00:44:29,000 --> 00:44:31,000
就是我刚说的那个用

1011
00:44:31,000 --> 00:44:34,000
用 php 来 render 这个 template 的话

1012
00:44:34,000 --> 00:44:36,000
它的输出率只有

1013
00:44:37,000 --> 00:44:38,000
只有那个 template 的

1014
00:44:39,000 --> 00:44:42,000
大概 25%

1015
00:44:42,000 --> 00:44:44,000
有差这么多吗

1016
00:44:44,000 --> 00:44:45,000
这是这个是非常可以优化的

1017
00:44:45,000 --> 00:44:47,000
因为有很多 dom 的

1018
00:44:47,000 --> 00:44:49,000
就是比方说 event handling

1019
00:44:49,000 --> 00:44:50,000
这些东西

1020
00:44:50,000 --> 00:44:52,000
在服务器端都没有必要去关联了

1021
00:44:52,000 --> 00:44:53,000
对吧

1022
00:44:53,000 --> 00:44:56,000
因为最终只需要一个静态的页面

1023
00:44:56,000 --> 00:44:57,000
你只需要这个静态的结果

1024
00:44:57,000 --> 00:44:58,000
但是

1025
00:44:59,000 --> 00:45:01,000
就是一个 open source project

1026
00:45:01,000 --> 00:45:02,000
很有趣的地方

1027
00:45:03,000 --> 00:45:05,000
facebook 本身对这个没有太大兴趣

1028
00:45:05,000 --> 00:45:07,000
因为它没有太大这个需求

1029
00:45:08,000 --> 00:45:10,000
但是如果其他公司或者是你

1030
00:45:11,000 --> 00:45:12,000
我们听众对此有需求的话

1031
00:45:12,000 --> 00:45:14,000
可以去看他们 source code

1032
00:45:14,000 --> 00:45:18,000
然后对 virtual DOM 做出一些修改

1033
00:45:18,000 --> 00:45:21,000
来实现更好的在 server 上 render 的功能

1034
00:45:21,000 --> 00:45:23,000
我想这个潜力是非常非常大的

1035
00:45:23,000 --> 00:45:26,000
因为它现在是基本上是没有任何优化的

1036
00:45:26,000 --> 00:45:27,000
对对对

1037
00:45:27,000 --> 00:45:29,000
这种情况下都还是挺好我觉得

1038
00:45:30,000 --> 00:45:33,000
说到 react 在实际使用的时候

1039
00:45:33,000 --> 00:45:36,000
就会牵涉到一个很有意思的

1040
00:45:36,000 --> 00:45:38,000
它的写法或者一个语言

1041
00:45:38,000 --> 00:45:39,000
GX

1042
00:45:40,000 --> 00:45:41,000
就是什么概念呢

1043
00:45:41,000 --> 00:45:43,000
就是说因为我们是在

1044
00:45:43,000 --> 00:45:45,000
在传统上我们写一个前段应用的时候

1045
00:45:45,000 --> 00:45:48,000
我们是把这个模板和这个数据或者是逻辑

1046
00:45:48,000 --> 00:45:49,000
完全分离开来的

1047
00:45:50,000 --> 00:45:51,000
就模板可能会用什么

1048
00:45:51,000 --> 00:45:54,000
什么 mustache 之类的一些东西来

1049
00:45:54,000 --> 00:45:55,000
来用 html 来写一个模板

1050
00:45:55,000 --> 00:45:56,000
然后留些空

1051
00:45:56,000 --> 00:45:59,000
然后当那个 gax script 去把模板这个

1052
00:45:59,000 --> 00:46:01,000
load 就来的

1053
00:46:01,000 --> 00:46:03,000
把那个空帖上就扔得出一个

1054
00:46:03,000 --> 00:46:06,000
进删的页面再发给出去填到页面里面去

1055
00:46:06,000 --> 00:46:08,000
但是在 react 里面去

1056
00:46:08,000 --> 00:46:10,000
他们推荐的方式是说

1057
00:46:10,000 --> 00:46:13,000
不要区分这个模板和这个数据和逻辑

1058
00:46:13,000 --> 00:46:14,000
你是做一个前段应用

1059
00:46:14,000 --> 00:46:18,000
你的这个模板就是你的这个要核心要考虑的一部分

1060
00:46:18,000 --> 00:46:22,000
我觉得这是 react 的 rethink best practices 的一部分

1061
00:46:22,000 --> 00:46:24,000
理论上来说

1062
00:46:24,000 --> 00:46:26,000
我们之前做 follow 的那个 best practices 是说

1063
00:46:26,000 --> 00:46:28,000
把模板分离开来

1064
00:46:28,000 --> 00:46:30,000
这样的话你有更好的重用性

1065
00:46:30,000 --> 00:46:32,000
因为你那个模板是可以被重用的对吧

1066
00:46:32,000 --> 00:46:33,000
对

1067
00:46:33,000 --> 00:46:35,000
可是如果你看这个 jsx 的话

1068
00:46:35,000 --> 00:46:36,000
它实际上不是一个模板

1069
00:46:36,000 --> 00:46:37,000
它完全不是一个模板

1070
00:46:37,000 --> 00:46:39,000
你其实就写 javascript code

1071
00:46:39,000 --> 00:46:41,000
你所写的

1072
00:46:41,000 --> 00:46:46,000
你只不过是用一种类似于写模板的语法去描述数据吧

1073
00:46:46,000 --> 00:46:46,000
对 exactly

1074
00:46:47,000 --> 00:46:48,000
对

1075
00:46:48,000 --> 00:46:53,000
你在你用一种写模板的方式去写你的 data model

1076
00:46:53,000 --> 00:46:54,000
这其实是一种进步

1077
00:46:54,000 --> 00:46:57,000
而不是就是某种抨击

1078
00:46:57,000 --> 00:47:00,000
某种某些人抨击的那样是一种历史的套退

1079
00:47:00,000 --> 00:47:00,000
我觉得

1080
00:47:00,000 --> 00:47:01,000
对

1081
00:47:01,000 --> 00:47:03,000
这个事情就其实挺好玩

1082
00:47:03,000 --> 00:47:06,000
因为刚 react 去年刚发布

1083
00:47:06,000 --> 00:47:07,000
正式对外发布的时候

1084
00:47:07,000 --> 00:47:09,000
很多人就是吐槽这一点

1085
00:47:09,000 --> 00:47:12,000
因为大家都可能被这个较条冠了

1086
00:47:12,000 --> 00:47:14,000
就说这个模板和数据要分离

1087
00:47:14,000 --> 00:47:15,000
但其实

1088
00:47:15,000 --> 00:47:18,000
我觉得当时 Peton 他有一个话说得很好

1089
00:47:18,000 --> 00:47:20,000
就是说这个模板

1090
00:47:20,000 --> 00:47:23,000
它分的 separation concept 是分错了

1091
00:47:23,000 --> 00:47:26,000
它把两个不应该分开的东西强行分开

1092
00:47:26,000 --> 00:47:27,000
但其实没有太多的好处

1093
00:47:28,000 --> 00:47:31,000
所以通过这种 jsx 方式

1094
00:47:31,000 --> 00:47:35,000
其实把这两个本来就应该紧密联系在一起的

1095
00:47:35,000 --> 00:47:37,000
两个部分放在一个地方

1096
00:47:37,000 --> 00:47:39,000
然后大家可以一眼看到

1097
00:47:39,000 --> 00:47:40,000
就好像那个

1098
00:47:40,000 --> 00:47:41,000
未来之前抱怨的说

1099
00:47:41,000 --> 00:47:42,000
那个

1100
00:47:42,000 --> 00:47:44,000
backbox 里面写很多这种 subview 的时候

1101
00:47:44,000 --> 00:47:45,000
不方便说

1102
00:47:45,000 --> 00:47:48,000
在一个文件里面就看出它在干什么

1103
00:47:48,000 --> 00:47:50,000
然后用这种 jsx 的方式

1104
00:47:50,000 --> 00:47:51,000
你可以一眼看出

1105
00:47:51,000 --> 00:47:53,000
我这个是在做一个模板

1106
00:47:53,000 --> 00:47:55,000
我在这个模板里面填出了这么一个数据

1107
00:47:55,000 --> 00:47:58,000
然后这个数据是从对象哪个地方来的

1108
00:47:58,000 --> 00:48:01,000
然后我要添加哪些 event handler

1109
00:48:01,000 --> 00:48:02,000
都在同一个地方完成这个东西

1110
00:48:02,000 --> 00:48:06,000
这个才是一个好的所谓的 encapsulation

1111
00:48:06,000 --> 00:48:08,000
我要再次提醒大家就是

1112
00:48:08,000 --> 00:48:10,000
你需要考虑自己的实际问题

1113
00:48:10,000 --> 00:48:13,000
然后选择正确的 framwork

1114
00:48:13,000 --> 00:48:14,000
或者 convention adopt

1115
00:48:14,000 --> 00:48:17,000
我们刚刚说那个 asimorphic 对不对

1116
00:48:17,000 --> 00:48:18,000
在那种情况下

1117
00:48:18,000 --> 00:48:22,000
实际上如果你分离出模板来的话是有好处的

1118
00:48:22,000 --> 00:48:25,000
因为如果你要在你的后端

1119
00:48:25,000 --> 00:48:29,000
用另外一种语言来写你的 random logic 的话

1120
00:48:29,000 --> 00:48:31,000
那那个共用模板是可以共用的

1121
00:48:31,000 --> 00:48:34,000
但你得看在你的实际上实用过程中

1122
00:48:34,000 --> 00:48:36,000
我们是没有这么错的

1123
00:48:36,000 --> 00:48:39,000
然后我们所有的模板是没有任何重用性的

1124
00:48:39,000 --> 00:48:40,000
也不是没有任何重用性

1125
00:48:40,000 --> 00:48:42,000
而是没有

1126
00:48:42,000 --> 00:48:44,000
它是有很强的重用性

1127
00:48:44,000 --> 00:48:48,000
因为它在另外一个单独的自己的文件中的话

1128
00:48:48,000 --> 00:48:50,000
但是我们从来没有重用过它

1129
00:48:50,000 --> 00:48:55,000
从来没有重用过它在三年的写这个程序的过程中

1130
00:48:55,000 --> 00:48:57,000
那到底做这个事情是为了什么

1131
00:48:57,000 --> 00:49:00,000
我们其实也不是很清楚

1132
00:49:00,000 --> 00:49:01,000
没想明白

1133
00:49:01,000 --> 00:49:03,000
在特定的应用场景下

1134
00:49:03,000 --> 00:49:05,000
特定的 best practice 是有道理的

1135
00:49:05,000 --> 00:49:06,000
比方说我们刚刚说

1136
00:49:06,000 --> 00:49:10,000
你如果一个模板要在不同的语言中被 random 的话

1137
00:49:10,000 --> 00:49:11,000
那实际上是非常好的一个设计

1138
00:49:11,000 --> 00:49:13,000
但如果你仅仅是在 java 的时候

1139
00:49:13,000 --> 00:49:15,000
那可能真的你得重新考虑这个事情

1140
00:49:15,000 --> 00:49:17,000
到底是不是有意义的

1141
00:49:17,000 --> 00:49:19,000
何况你用 react 的时候

1142
00:49:19,000 --> 00:49:20,000
这就真的不是模板了

1143
00:49:20,000 --> 00:49:22,000
这个模板这个东西不存在的

1144
00:49:22,000 --> 00:49:25,000
它所有的东西都是 java subject

1145
00:49:25,000 --> 00:49:27,000
there's no string template

1146
00:49:27,000 --> 00:49:29,000
这个念头你得转过弯来

1147
00:49:29,000 --> 00:49:30,000
你写这些

1148
00:49:30,000 --> 00:49:32,000
它只是看起来像而已

1149
00:49:32,000 --> 00:49:33,000
但完全不是

1150
00:49:33,000 --> 00:49:34,000
好处在说

1151
00:49:36,000 --> 00:49:37,000
刚刚我们说

1152
00:49:37,000 --> 00:49:39,000
把 sub view 的问题

1153
00:49:39,000 --> 00:49:40,000
在 backbone 里头

1154
00:49:40,000 --> 00:49:44,000
你得在模板里头给它留空间

1155
00:49:44,000 --> 00:49:46,000
然后在 manual insert 进去

1156
00:49:46,000 --> 00:49:48,000
在 react 中就不是问题了

1157
00:49:48,000 --> 00:49:50,000
你直接 import 一下

1158
00:49:50,000 --> 00:49:53,000
然后 import sub component

1159
00:49:53,000 --> 00:49:55,000
然后直接把这个 tag 写上去就好了

1160
00:49:55,000 --> 00:49:57,000
这是一个非常非常非常好的

1161
00:50:00,000 --> 00:50:01,000
就是重用性的进步吧

1162
00:50:01,000 --> 00:50:02,000
对

1163
00:50:02,000 --> 00:50:06,000
而且实际上也大量减轻了

1164
00:50:06,000 --> 00:50:10,000
开发者的 mental model

1165
00:50:10,000 --> 00:50:14,000
就是在维护一个 mental model 的负担

1166
00:50:14,000 --> 00:50:17,000
就是你不用总是在

1167
00:50:17,000 --> 00:50:18,000
我现在在写一个 template

1168
00:50:18,000 --> 00:50:19,000
我现在在写 model

1169
00:50:19,000 --> 00:50:23,000
你不用再维护这个不停的 context switch 的成本上

1170
00:50:23,000 --> 00:50:26,000
还有必须得提到的是

1171
00:50:26,000 --> 00:50:29,000
gx 并不是一个全新的东西

1172
00:50:29,000 --> 00:50:30,000
在 facebook 内部

1173
00:50:30,000 --> 00:50:32,000
这是一个开源的项目

1174
00:50:32,000 --> 00:50:35,000
他们一直在用类似的产品

1175
00:50:35,000 --> 00:50:37,000
叫做 xhp

1176
00:50:37,000 --> 00:50:40,000
是 php 的版本

1177
00:50:40,000 --> 00:50:44,000
所以他们很长时间已经在 php 里写

1178
00:50:44,000 --> 00:50:46,000
所谓 html tag

1179
00:50:46,000 --> 00:50:47,000
所以在这边上

1180
00:50:47,000 --> 00:50:50,000
也是对 concept 的一个 validation

1181
00:50:50,000 --> 00:50:53,000
因为毕竟 facebook 有相同的概念

1182
00:50:53,000 --> 00:50:54,000
用了很久了

1183
00:50:54,000 --> 00:50:58,000
所以我觉得他们先人一步

1184
00:50:58,000 --> 00:50:59,000
已经 accept 的这个概念了

1185
00:50:59,000 --> 00:51:00,000
所以对他们来说

1186
00:51:00,000 --> 00:51:03,000
就不是一个事

1187
00:51:05,000 --> 00:51:09,000
对 我大概也是前年去弯曲的时候

1188
00:51:09,000 --> 00:51:11,000
然后看到他们在 facebook 内部

1189
00:51:11,000 --> 00:51:14,000
是怎么用 xhp 的这么一个语言

1190
00:51:14,000 --> 00:51:18,000
去写他们的服务端的软件

1191
00:51:18,000 --> 00:51:20,000
当时我就震撼到了

1192
00:51:20,000 --> 00:51:23,000
我说 哇 因为他们等于是可以任意构建一种

1193
00:51:23,000 --> 00:51:25,000
传统上我们写模板的时候

1194
00:51:25,000 --> 00:51:28,000
你只能用一个抽象程度很低的方式

1195
00:51:28,000 --> 00:51:29,000
因为你模板的话

1196
00:51:29,000 --> 00:51:31,000
要么就在模板层别上

1197
00:51:31,000 --> 00:51:32,000
你可以构建一些东西出来

1198
00:51:32,000 --> 00:51:33,000
或者是说

1199
00:51:33,000 --> 00:51:37,000
你在写那些 html 标签的时候

1200
00:51:37,000 --> 00:51:39,000
你还是要用那些标准的标签

1201
00:51:39,000 --> 00:51:40,000
但是他们在用 xhp 的时候

1202
00:51:40,000 --> 00:51:43,000
其实可以定义自己的一个标签的

1203
00:51:43,000 --> 00:51:46,000
然后标签可以包含很多很复杂的

1204
00:51:46,000 --> 00:51:47,000
这种行为和数据

1205
00:51:47,000 --> 00:51:49,000
包括内部的结构在里面

1206
00:51:49,000 --> 00:51:51,000
而对标签的调用方来讲

1207
00:51:51,000 --> 00:51:54,000
完全可以不用关心里面到底是如何实现的

1208
00:51:54,000 --> 00:51:56,000
就其实就有点像一个

1209
00:51:56,000 --> 00:51:59,000
Angler.js 所做出来的新的 html tag

1210
00:51:59,000 --> 00:52:02,000
只不过这一切就是在 pgp

1211
00:52:02,000 --> 00:52:05,000
他们应该也是叫做 controller

1212
00:52:05,000 --> 00:52:05,000
那个时候

1213
00:52:05,000 --> 00:52:08,000
所谓组建化的时候

1214
00:52:08,000 --> 00:52:12,000
组建化的时候就一个要达到什么样的场景

1215
00:52:12,000 --> 00:52:15,000
就是说我只要构建好我这个组建

1216
00:52:15,000 --> 00:52:17,000
我这个组建对外部来说是一个完全封闭的

1217
00:52:17,000 --> 00:52:20,000
你只要外部提供给我需要的数据

1218
00:52:20,000 --> 00:52:23,000
和我需要的包括一些回调函数的话

1219
00:52:23,000 --> 00:52:25,000
我这个组建就能完成你需要的工作

1220
00:52:25,000 --> 00:52:28,000
就不再需要去每个人都去看到这个组建

1221
00:52:28,000 --> 00:52:30,000
内部是有多少个什么多少个 atag

1222
00:52:30,000 --> 00:52:33,000
多少个 dev 这种层层包起来这么一个东西

1223
00:52:33,000 --> 00:52:36,000
这一点我觉得是一个在抽象层级上是一个

1224
00:52:36,000 --> 00:52:37,000
化时代的进步我觉得

1225
00:52:39,000 --> 00:52:39,000
是

1226
00:52:40,000 --> 00:52:43,000
然后当时那个就是我看到 Facebook

1227
00:52:43,000 --> 00:52:45,000
他们内部在用这个最后这么好

1228
00:52:45,000 --> 00:52:46,000
就说哇这个真是

1229
00:52:46,000 --> 00:52:49,000
因为我没有在其他地方看到有类似的产品

1230
00:52:49,000 --> 00:52:52,000
或者是语言吧在做类似的事情

1231
00:52:52,000 --> 00:52:56,000
真的是感觉走在什么时代的前例的那种

1232
00:52:56,000 --> 00:52:59,000
跟我们不跟其他人确实差的

1233
00:52:59,000 --> 00:53:01,000
就临陷的蛮远的

1234
00:53:01,000 --> 00:53:04,000
那我们下面讲那个 reignative 吧

1235
00:53:06,000 --> 00:53:07,000
ES 6 我讲吧

1236
00:53:08,000 --> 00:53:11,000
那个那其实不是很重要我觉得

1237
00:53:11,000 --> 00:53:12,000
OK 这个是

1238
00:53:12,000 --> 00:53:13,000
为了你觉得呢

1239
00:53:13,000 --> 00:53:14,000
说到 ES 6 呢

1240
00:53:16,000 --> 00:53:18,000
我觉得 Encler 跟

1241
00:53:18,000 --> 00:53:20,000
这主要是 Encler 跟 Reactor 区别之一吧

1242
00:53:20,000 --> 00:53:23,000
因为 reactor 似乎在

1243
00:53:24,000 --> 00:53:27,000
它的发展过程中考虑了更多的

1244
00:53:27,000 --> 00:53:29,000
java-scrumminative 的东西

1245
00:53:29,000 --> 00:53:32,000
while Encler 好像在创造一个自己的小世界

1246
00:53:33,000 --> 00:53:36,000
我们有一个 panel 上有那个 substation

1247
00:53:37,000 --> 00:53:40,000
是 reactor 的主要的维护者之一

1248
00:53:40,000 --> 00:53:42,000
然后它实际上它本身是在

1249
00:53:42,000 --> 00:53:46,000
那个 ES 6 的委员会上的

1250
00:53:46,000 --> 00:53:47,000
所以它有提到说

1251
00:53:48,000 --> 00:53:53,000
reactor 非常非常 aggressively 在推 ES 6 的支持

1252
00:53:53,000 --> 00:53:56,000
它甚至把那个 mixing 的支持给去掉了

1253
00:53:56,000 --> 00:53:57,000
在最新的版本

1254
00:53:57,000 --> 00:54:03,000
它解释的是因为 ES 6 的 mixing 支持

1255
00:54:03,000 --> 00:54:05,000
在那个

1256
00:54:05,000 --> 00:54:07,000
就是想要考虑的是

1257
00:54:07,000 --> 00:54:09,000
而是在那个 standard 中被去掉了

1258
00:54:09,000 --> 00:54:11,000
就是 ES 6 是现在的那种标准

1259
00:54:11,000 --> 00:54:13,000
就是在这一版中的话

1260
00:54:13,000 --> 00:54:14,000
是没有 mixing 的

1261
00:54:14,000 --> 00:54:15,000
没有 tlmixing 的

1262
00:54:15,000 --> 00:54:18,000
他们在 ES 7 中才会就是 mixing

1263
00:54:18,000 --> 00:54:21,000
或者说才会把这个事情再提上一纯

1264
00:54:21,000 --> 00:54:22,000
所以这因为如此

1265
00:54:22,000 --> 00:54:25,000
在那个 native 的 class up 或者中

1266
00:54:25,000 --> 00:54:27,000
reactor 把那个 mixing 给去掉了

1267
00:54:28,000 --> 00:54:30,000
当然这些事情都是 unconvinced events

1268
00:54:30,000 --> 00:54:33,000
所以还有可能有其他的变化

1269
00:54:34,000 --> 00:54:37,000
不过我觉得至少在我开来的话

1270
00:54:37,000 --> 00:54:41,000
reactor 是非常在积极的推动和

1271
00:54:41,000 --> 00:54:47,000
就是实现 ES 6 的标准

1272
00:54:49,000 --> 00:54:54,000
其实 Reactor 你对 ES 6 加了 script 下个版本的语言

1273
00:54:54,000 --> 00:54:56,000
你什么样的态度

1274
00:54:58,000 --> 00:54:59,000
老实说我不是很熟悉

1275
00:54:59,000 --> 00:55:01,000
所以我把这段剪接掉吧

1276
00:55:03,000 --> 00:55:03,000
OK

1277
00:55:03,000 --> 00:55:04,000
那行

1278
00:55:04,000 --> 00:55:04,000
我没有用

1279
00:55:04,000 --> 00:55:06,000
我们在做有谁比较熟悉吗

1280
00:55:06,000 --> 00:55:08,000
有人仅跟着 ES 7

1281
00:55:08,000 --> 00:55:10,000
我又在跟着

1282
00:55:10,000 --> 00:55:13,000
你现在在搞这个对吧

1283
00:55:13,000 --> 00:55:14,000
没有

1284
00:55:14,000 --> 00:55:15,000
我也有在用它

1285
00:55:15,000 --> 00:55:17,000
就是在尝试去使用它

1286
00:55:17,000 --> 00:55:19,000
现在我昨天还在转

1287
00:55:19,000 --> 00:55:22,000
就是我们 ipm 背后不许一个

1288
00:55:22,000 --> 00:55:23,000
我自己写的 CMS

1289
00:55:23,000 --> 00:55:25,000
然后一个管理后台

1290
00:55:25,000 --> 00:55:27,000
那个其实是用 reactor 写的

1291
00:55:27,000 --> 00:55:29,000
那我想想

1292
00:55:29,000 --> 00:55:30,000
那我们先讲 relate

1293
00:55:30,000 --> 00:55:32,000
还是先讲这个 reactor

1294
00:55:32,000 --> 00:55:35,000
因为 native 实际上是一个非常非常非常自然的过渡

1295
00:55:35,000 --> 00:55:39,000
因为在 reactor 中

1296
00:55:39,000 --> 00:55:43,000
最初的版本中你的 render target 是 virtual DOM

1297
00:55:43,000 --> 00:55:44,000
对不对

1298
00:55:44,000 --> 00:55:48,000
但是为什么一定要 render DOM 上来

1299
00:55:48,000 --> 00:55:49,000
反正已经 virtualized 了

1300
00:55:49,000 --> 00:55:52,000
就好像你用虚拟机一样

1301
00:55:52,000 --> 00:55:55,000
你到底虚拟机是在 window 上 wrong

1302
00:55:55,000 --> 00:55:56,000
是在 max 上 wrong

1303
00:55:56,000 --> 00:55:59,000
是在 os 2 上 wrong

1304
00:55:59,000 --> 00:56:01,000
并不重要对吧

1305
00:56:01,000 --> 00:56:03,000
所以

1306
00:56:03,000 --> 00:56:04,000
对

1307
00:56:04,000 --> 00:56:07,000
就等于它提供一层新的抽象

1308
00:56:07,000 --> 00:56:08,000
然后借入这层新的抽象

1309
00:56:08,000 --> 00:56:09,000
你就有了新的自由

1310
00:56:09,000 --> 00:56:10,000
你可以把它

1311
00:56:10,000 --> 00:56:13,000
你可以把它它的底层

1312
00:56:13,000 --> 00:56:15,000
迁移到其他的 plaster 上面

1313
00:56:15,000 --> 00:56:19,000
对 我忘了是 Thom 还是 Christopher 说的

1314
00:56:19,000 --> 00:56:22,000
他说我们他们之前做 virtual DOM 的时候

1315
00:56:22,000 --> 00:56:24,000
最终目的并不是说

1316
00:56:24,000 --> 00:56:27,000
要把 dom virtualize 这件事情本身

1317
00:56:27,000 --> 00:56:28,000
而是说要完全去掉 dom

1318
00:56:28,000 --> 00:56:32,000
就是要把 react 跟 dom 的依赖直接切掉

1319
00:56:32,000 --> 00:56:33,000
就完全没有关系

1320
00:56:33,000 --> 00:56:35,000
我可以不依赖一个 dom

1321
00:56:35,000 --> 00:56:37,000
然后最终的结果就是我们现在看到的

1322
00:56:37,000 --> 00:56:39,000
它这次发布的一个重量级的产品

1323
00:56:39,000 --> 00:56:39,000
叫做 react

1324
00:56:39,000 --> 00:56:42,000
一个工具叫做 react native

1325
00:56:42,000 --> 00:56:43,000
什么意思呢

1326
00:56:43,000 --> 00:56:43,000
简单描述一下

1327
00:56:43,000 --> 00:56:47,000
就是说我还是用 java script 写我的应用

1328
00:56:47,000 --> 00:56:49,000
但是相比在网页上

1329
00:56:49,000 --> 00:56:52,000
我是把它渲染成一个网页的那些

1330
00:56:52,000 --> 00:56:55,000
html 的这种 tag 标签的话

1331
00:56:55,000 --> 00:57:00,000
我是直接用某一个平台原生的 UI 组件

1332
00:57:00,000 --> 00:57:02,000
比如说在 iOS 面就是一个原生的

1333
00:57:02,000 --> 00:57:05,000
比如说列表可以滚动的那种有带重力

1334
00:57:05,000 --> 00:57:07,000
不叫带什么加速度的

1335
00:57:07,000 --> 00:57:09,000
惯性的那种滚动 trunk

1336
00:57:09,000 --> 00:57:13,000
或者说是我用一个原生的地图的组件

1337
00:57:13,000 --> 00:57:14,000
来实现我的功能

1338
00:57:14,000 --> 00:57:18,000
但是我的程序的实际的后台的所有的 model

1339
00:57:18,000 --> 00:57:19,000
还有所有的数据

1340
00:57:19,000 --> 00:57:20,000
还有包括的一些逻辑

1341
00:57:20,000 --> 00:57:22,000
都其实是在 java script 运行的

1342
00:57:22,000 --> 00:57:23,000
对

1343
00:57:23,000 --> 00:57:25,000
这个我觉得是非常了不得的一个事情

1344
00:57:25,000 --> 00:57:30,000
就是我就知道很多 iOS 或者是 Android 开发者在吐槽

1345
00:57:31,000 --> 00:57:32,000
就在其实

1346
00:57:32,000 --> 00:57:35,000
哪怕是现在应该开发一个 iOS 应用或者 Android 应用

1347
00:57:35,000 --> 00:57:37,000
都还不是那么爽的一件事情

1348
00:57:37,000 --> 00:57:40,000
它有点像在 backbound 时代的

1349
00:57:40,000 --> 00:57:43,000
有一点像在 backbound 时代的开发 web app 的感觉

1350
00:57:43,000 --> 00:57:44,000
对

1351
00:57:44,000 --> 00:57:46,000
我觉得对我来讲

1352
00:57:46,000 --> 00:57:48,000
最重要的概念在 react native 中

1353
00:57:48,000 --> 00:57:50,000
最重要的概念是

1354
00:57:50,000 --> 00:57:51,000
我 Thom 说

1355
00:57:52,000 --> 00:57:55,000
learn once right everywhere

1356
00:57:55,000 --> 00:57:58,000
react native 它不一定是要你

1357
00:57:58,000 --> 00:58:00,000
right once run everywhere

1358
00:58:00,000 --> 00:58:03,000
它没有 react native 本身

1359
00:58:03,000 --> 00:58:07,000
它没有 merge the gap between Android and iOS

1360
00:58:07,000 --> 00:58:09,000
Android 还是要写 Android app

1361
00:58:09,000 --> 00:58:11,000
iOS 还是要写 iOS app

1362
00:58:11,000 --> 00:58:15,000
但是你写程序的方式发生了根本的变化

1363
00:58:15,000 --> 00:58:17,000
不管是写 web app 好

1364
00:58:17,000 --> 00:58:18,000
还是写 android app 好

1365
00:58:18,000 --> 00:58:20,000
还是写 iOS app 好

1366
00:58:20,000 --> 00:58:23,000
你会用 exactly the same way

1367
00:58:23,000 --> 00:58:28,000
来写这三个不同的环境下的 application

1368
00:58:28,000 --> 00:58:31,000
只是你会用环境的

1369
00:58:31,000 --> 00:58:33,000
对不同的组件

1370
00:58:33,000 --> 00:58:36,000
这一点是要是非常非常容易的

1371
00:58:36,000 --> 00:58:39,000
我本人对自己是深有感触

1372
00:58:39,000 --> 00:58:43,000
因为我之前有写一个 iOS app

1373
00:58:43,000 --> 00:58:45,000
我不是 wattfund

1374
00:58:45,000 --> 00:58:49,000
现在还在写另外一个小小的说一下

1375
00:58:49,000 --> 00:58:51,000
我也在写另外一个 iOS app

1376
00:58:51,000 --> 00:58:53,000
然后其中有很多的 layouting

1377
00:58:53,000 --> 00:58:56,000
其实像是一个逻辑上来讲是一个比较简单的 app

1378
00:58:56,000 --> 00:58:58,000
但是很多 layouting

1379
00:58:58,000 --> 00:58:59,000
我有一个 UI label

1380
00:58:59,000 --> 00:59:02,000
这个 UI label 是可变的长度

1381
00:59:02,000 --> 00:59:08,000
然后这个 UI label 又在一个可变长度的 UI table cell 中

1382
00:59:08,000 --> 00:59:12,000
就是如果你想用 auto layouting 的话

1383
00:59:12,000 --> 00:59:14,000
这是一个非常非常麻烦的事情

1384
00:59:14,000 --> 00:59:17,000
因为在 UI label de-surrender 的时候

1385
00:59:17,000 --> 00:59:19,000
它并不知道它的宽度

1386
00:59:19,000 --> 00:59:21,000
它如果它不知道它的宽度

1387
00:59:21,000 --> 00:59:22,000
它就不知道它的高度

1388
00:59:22,000 --> 00:59:23,000
它不知道它的高度

1389
00:59:23,000 --> 00:59:24,000
它就亂 render

1390
00:59:25,000 --> 00:59:26,000
你就可以

1391
00:59:26,000 --> 00:59:29,000
auto layout 是 all about constraints

1392
00:59:29,000 --> 00:59:32,000
所以你需要设计一系列的 constraint

1393
00:59:32,000 --> 00:59:35,000
然后 layout 的应请会来猜测

1394
00:59:35,000 --> 00:59:39,000
怎么样的结果能够满足你所有的 constraint

1395
00:59:39,000 --> 00:59:41,000
或者尽量满足你的 constraint

1396
00:59:41,000 --> 00:59:43,000
这是一个非常 notuitive 的位

1397
00:59:43,000 --> 00:59:45,000
然后从 web 的角度来说的话

1398
00:59:45,000 --> 00:59:47,000
boxmod 多简单啊

1399
00:59:47,000 --> 00:59:49,000
虽然说 boxmod 有时候不工作

1400
00:59:49,000 --> 00:59:51,000
但是多简单啊

1401
00:59:51,000 --> 00:59:53,000
所有的东西就是 box top box

1402
00:59:53,000 --> 00:59:54,000
在 box 之上

1403
00:59:54,000 --> 00:59:56,000
然后你有 margin

1404
00:59:56,000 --> 00:59:58,000
你有 padding

1405
00:59:58,000 --> 00:59:59,000
你有 border

1406
00:59:59,000 --> 01:00:00,000
这个非常非常容易理解

1407
01:00:00,000 --> 01:00:06,000
非常直观的一种模式

1408
01:00:06,000 --> 01:00:07,000
反观 要 iOS

1409
01:00:07,000 --> 01:00:09,000
如果你不用 auto layout

1410
01:00:09,000 --> 01:00:11,000
就是 constraint 非常难以理解

1411
01:00:11,000 --> 01:00:13,000
然后你那个结果也不 intuitive

1412
01:00:13,000 --> 01:00:15,000
你如果只给我一系列的 constraint

1413
01:00:15,000 --> 01:00:18,000
如果你不告诉我结果的话

1414
01:00:18,000 --> 01:00:19,000
我很难说

1415
01:00:19,000 --> 01:00:20,000
我很有信心说

1416
01:00:20,000 --> 01:00:23,000
这是 constraint 会得到我想要的结果

1417
01:00:23,000 --> 01:00:26,000
我觉得可能最重大的一个差别

1418
01:00:26,000 --> 01:00:28,000
就是 constraint based layout

1419
01:00:28,000 --> 01:00:32,000
要求你能够在头脑中维护一个

1420
01:00:32,000 --> 01:00:36,000
最终视觉效果的模型

1421
01:00:36,000 --> 01:00:40,000
而 boxmod 对此要求就低一点

1422
01:00:40,000 --> 01:00:42,000
或者说低很多吧应该说

1423
01:00:42,000 --> 01:00:44,000
如果你不用 auto layout 的话呢

1424
01:00:44,000 --> 01:00:48,000
你又得 manually 去做很多的 math

1425
01:00:48,000 --> 01:00:51,000
如果你看 Christopher 的 slide

1426
01:00:51,000 --> 01:00:53,000
他有一张全都是 math

1427
01:00:53,000 --> 01:00:54,000
math

1428
01:00:54,000 --> 01:00:55,000
exactly right

1429
01:00:55,000 --> 01:00:58,000
但倒也不是说有多难多容易

1430
01:00:58,000 --> 01:00:59,000
很多 iOS cover 就跟我说

1431
01:00:59,000 --> 01:01:00,000
那不难

1432
01:01:00,000 --> 01:01:03,000
但是那 ugly 多丑陋

1433
01:01:03,000 --> 01:01:03,000
我靠

1434
01:01:03,000 --> 01:01:06,000
然后你想要改一点什么东西的话

1435
01:01:06,000 --> 01:01:07,000
又回头得去算

1436
01:01:07,000 --> 01:01:10,000
然后妈呀真的是真可怕

1437
01:01:10,000 --> 01:01:10,000
对吧

1438
01:01:10,000 --> 01:01:13,000
Rack native

1439
01:01:13,000 --> 01:01:15,000
所以我觉得其实他们这次做的那个

1440
01:01:15,000 --> 01:01:16,000
就是他们发布的 react native

1441
01:01:16,000 --> 01:01:18,000
他们也解决了这个问题

1442
01:01:18,000 --> 01:01:21,000
他们用 JavaScript 实现了一套

1443
01:01:21,000 --> 01:01:25,000
CSS 最新的叫做 flexbox 的 boxmod

1444
01:01:25,000 --> 01:01:26,000
对

1445
01:01:26,000 --> 01:01:28,000
然后他们用那个模型就去解决了

1446
01:01:28,000 --> 01:01:32,000
怎么去布局那些原生的 UI 组件的问题

1447
01:01:32,000 --> 01:01:34,000
这个我觉得就刚才那个 Wailer 也

1448
01:01:34,000 --> 01:01:36,000
大家相信已经听出来

1449
01:01:36,000 --> 01:01:38,000
Wailer 对 constraint layout

1450
01:01:38,000 --> 01:01:40,000
auto layout 这种已经吐槽很久了

1451
01:01:40,000 --> 01:01:42,000
其实就从我们一个机器上讲

1452
01:01:42,000 --> 01:01:44,000
constraint based layout 的话

1453
01:01:44,000 --> 01:01:46,000
其实它是要你在你头脑中

1454
01:01:46,000 --> 01:01:50,000
构建一个动态规划机

1455
01:01:50,000 --> 01:01:51,000
对吧

1456
01:01:51,000 --> 01:01:54,000
你得自己在头脑中随时解方程

1457
01:01:54,000 --> 01:01:54,000
解完之后再说

1458
01:01:54,000 --> 01:01:56,000
这个会出现在那里

1459
01:01:56,000 --> 01:01:57,000
这个会出现在那里

1460
01:01:57,000 --> 01:01:58,000
就不像 boxmod

1461
01:01:58,000 --> 01:02:01,000
它更加反应出是一个比较直观的

1462
01:02:01,000 --> 01:02:02,000
这个应该是多大

1463
01:02:02,000 --> 01:02:03,000
它应该有多宽

1464
01:02:03,000 --> 01:02:06,000
然后它多到一个边框是

1465
01:02:06,000 --> 01:02:08,000
那个什么 margin 东西叫什么来的

1466
01:02:08,000 --> 01:02:09,000
留白对吧

1467
01:02:09,000 --> 01:02:10,000
留白要多少

1468
01:02:10,000 --> 01:02:13,000
或者是跟其他的东西见据要多少

1469
01:02:13,000 --> 01:02:15,000
我这个确实是 CSS

1470
01:02:15,000 --> 01:02:17,000
就是这个比较好的

1471
01:02:17,000 --> 01:02:17,000
解决的一个地方

1472
01:02:17,000 --> 01:02:19,000
就我很好奇为什么

1473
01:02:19,000 --> 01:02:21,000
像 iOS、Android 之前

1474
01:02:21,000 --> 01:02:23,000
它没有用到这种同样的模型

1475
01:02:23,000 --> 01:02:24,000
去做这个事情

1476
01:02:24,000 --> 01:02:26,000
这是一个很好问题

1477
01:02:26,000 --> 01:02:28,000
其实这个可以将来

1478
01:02:28,000 --> 01:02:30,000
专门找一期谈这个

1479
01:02:30,000 --> 01:02:32,000
就是为什么 boxmod

1480
01:02:32,000 --> 01:02:35,000
这种看起来如此简单一行

1481
01:02:35,000 --> 01:02:41,000
又有大量解放生产力的布局

1482
01:02:41,000 --> 01:02:43,000
仅仅在 web 领域读书一致

1483
01:02:43,000 --> 01:02:45,000
就甚至很多

1484
01:02:45,000 --> 01:02:49,000
比如说排版软件都完全不去考虑这种

1485
01:02:49,000 --> 01:02:53,000
但我觉得可能还是惯性在里面吧

1486
01:02:53,000 --> 01:02:56,000
对 这个是挺奇怪的

1487
01:02:56,000 --> 01:02:57,000
比如说你说 iOS 为什么不用它

1488
01:02:57,000 --> 01:03:01,000
iOS 不用它是因为 OS 10 不用它

1489
01:03:01,000 --> 01:03:04,000
毕竟一开始只是 OS 10 的一个改版嘛

1490
01:03:04,000 --> 01:03:08,000
就 MIC 上的 app 不可能

1491
01:03:08,000 --> 01:03:10,000
从来没有用过 box layout

1492
01:03:10,000 --> 01:03:14,000
所以 iOS 上面也就不用了

1493
01:03:14,000 --> 01:03:17,000
这次 reality 有点发布

1494
01:03:17,000 --> 01:03:17,000
我觉得还有一点

1495
01:03:17,000 --> 01:03:24,000
我觉得特别令人觉得比较惊奇的一点

1496
01:03:24,000 --> 01:03:29,000
就是它因为整个程序的逻辑

1497
01:03:29,000 --> 01:03:32,000
和这些包括 model

1498
01:03:32,000 --> 01:03:34,000
都是在 jabscrew 里面实现的

1499
01:03:34,000 --> 01:03:36,000
然后 jabscrew 它是依赖于一个

1500
01:03:36,000 --> 01:03:38,000
所谓解析器或者是 jabscrew 引擎的嘛

1501
01:03:39,000 --> 01:03:43,000
然后引擎可以不用跑在手机上面

1502
01:03:43,000 --> 01:03:44,000
它可以跑在

1503
01:03:44,000 --> 01:03:45,000
他们在现场 demo 的时候

1504
01:03:45,000 --> 01:03:48,000
它解析器是跑在浏览器里面的

1505
01:03:48,000 --> 01:03:53,000
然后它可以在 chrome 里面去改浏览器

1506
01:03:53,000 --> 01:03:55,000
然后及时刷新一下

1507
01:03:55,000 --> 01:03:58,000
然后在 iPhone 模拟器里面

1508
01:03:58,000 --> 01:04:03,000
对应的一个原生的 UI 的界面

1509
01:04:03,000 --> 01:04:04,000
就随之发生改变了

1510
01:04:04,000 --> 01:04:05,000
这个非常了不得

1511
01:04:05,000 --> 01:04:11,000
这个在实际的 production 中是很难实现的

1512
01:04:11,000 --> 01:04:13,000
however 但是这反映了

1513
01:04:13,000 --> 01:04:15,000
就是说 react

1514
01:04:15,000 --> 01:04:17,000
它 native 到底是怎么样实现

1515
01:04:17,000 --> 01:04:20,000
从 jabscrew 到 native 的转换

1516
01:04:20,000 --> 01:04:24,000
react native 不想要成为一个性能平均

1517
01:04:24,000 --> 01:04:25,000
of course not

1518
01:04:25,000 --> 01:04:31,000
所以它的实现方式就是在把 jabscrew 引擎放到

1519
01:04:31,000 --> 01:04:33,000
单独的 background thread 中

1520
01:04:33,000 --> 01:04:34,000
一个单独

1521
01:04:34,000 --> 01:04:36,000
它自己一个单独的线程中

1522
01:04:36,000 --> 01:04:41,000
然后在这个线程中有一个 jabscrew 的引擎

1523
01:04:41,000 --> 01:04:45,000
在不断的渲染

1524
01:04:45,000 --> 01:04:46,000
然后得到结果

1525
01:04:46,000 --> 01:04:54,000
再通过 channel 的方式把这个渲染结果发回到你的主线程中

1526
01:04:54,000 --> 01:04:57,000
所以你的主线程是没有被 publack 随时

1527
01:04:57,000 --> 01:05:01,000
这个结果就是说你的主线程总是很 smooth

1528
01:05:01,000 --> 01:05:01,000
反观

1529
01:05:01,000 --> 01:05:05,000
如果你用一个 webview 的一个解决方式

1530
01:05:05,000 --> 01:05:10,000
先不说你不能够用 native component 这种极大的问题

1531
01:05:10,000 --> 01:05:14,000
关键是说你的 jabscrew 是会 blogging 的主线程

1532
01:05:14,000 --> 01:05:19,000
所以说如果你 jabscrew 在做一些大量运算的时候

1533
01:05:19,000 --> 01:05:23,000
用户如果在像下划那个页面

1534
01:05:23,000 --> 01:05:25,000
页面就不会不动

1535
01:05:25,000 --> 01:05:26,000
所以页面就不 smooth

1536
01:05:26,000 --> 01:05:32,000
整个的体验就很不乐观

1537
01:05:32,000 --> 01:05:39,000
所以 react native 只让你使用 native component

1538
01:05:39,000 --> 01:05:40,000
有 native 的 experience

1539
01:05:40,000 --> 01:05:48,000
也从性能上帮助你不要提供不好的体验

1540
01:05:49,000 --> 01:05:57,000
它把 UI 的渲染和业务逻辑的执行是完全隔裂开展

1541
01:05:57,000 --> 01:05:59,000
通过异部的方式进行重讯同步的

1542
01:05:59,000 --> 01:06:03,000
这个是我觉得非常好的一件事情

1543
01:06:03,000 --> 01:06:05,000
但是这就牵涉到另外一个问题了

1544
01:06:05,000 --> 01:06:12,000
它这样的话对后台的执行 jabscrew 解析器的进程的性能会有要求吗

1545
01:06:12,000 --> 01:06:13,000
比如说据我所知

1546
01:06:13,000 --> 01:06:19,000
在 iOS 上你单独自己跑一个 jabscrew 解析器的话

1547
01:06:19,000 --> 01:06:22,000
是没有他们那个叫什么来的

1548
01:06:22,000 --> 01:06:23,000
GIT 的优化

1549
01:06:26,000 --> 01:06:29,000
这一点上我并不是特别清楚他们主要实现方式

1550
01:06:29,000 --> 01:06:32,000
但是有一点很重要的是

1551
01:06:32,000 --> 01:06:39,000
你刚说的那些问题只在你直接使用 webview 的情况下才会出现

1552
01:06:39,000 --> 01:06:40,000
为什么

1553
01:06:40,000 --> 01:06:43,000
因为那个音景是在 webview 里头

1554
01:06:43,000 --> 01:06:47,000
但是他们的 react 的时间方式是并不代表说

1555
01:06:47,000 --> 01:06:49,000
它一定要用那个 jabscrewing

1556
01:06:49,000 --> 01:06:54,000
它可以自己包装一个其他的 jabscrewing 在里头

1557
01:06:54,000 --> 01:06:59,000
就是它可以说我不用苹果 iOS 自带的 jabscrewing

1558
01:06:59,000 --> 01:07:05,000
然后我自己包一个代 git 的 jabscrew 解析器进去这样执行吗

1559
01:07:05,000 --> 01:07:05,000
没错

1560
01:07:05,000 --> 01:07:10,000
那这样不会就会撞到那个 appsotl 审核条例的内幕

1561
01:07:10,000 --> 01:07:13,000
一条说不能自带解析器吗

1562
01:07:13,000 --> 01:07:14,000
真的吗

1563
01:07:14,000 --> 01:07:16,000
有这么一条的曾经

1564
01:07:16,000 --> 01:07:18,000
我记得后来就

1565
01:07:18,000 --> 01:07:21,000
因为那个 picture 条约我记得我还写过 blow

1566
01:07:21,000 --> 01:07:24,000
就说它只能用规定的集中语言来写

1567
01:07:24,000 --> 01:07:27,000
但好像没有说不能自带训练机

1568
01:07:27,000 --> 01:07:30,000
不然那些什么带落案的东西是怎么被伤到通过的

1569
01:07:30,000 --> 01:07:31,000
对

1570
01:07:31,000 --> 01:07:33,000
这就是一个挺模糊的一点

1571
01:07:33,000 --> 01:07:34,000
就是后来因为很多游戏

1572
01:07:34,000 --> 01:07:37,000
它需要用那个落案解析器做一些辅助的事情

1573
01:07:37,000 --> 01:07:40,000
所以说它就后来又通过

1574
01:07:40,000 --> 01:07:44,000
现在我要不太清楚苹果在对这件事情的立场是什么

1575
01:07:44,000 --> 01:07:47,000
但是这个只能在意了

1576
01:07:47,000 --> 01:07:49,000
我可以 fastcheck 一下

1577
01:07:49,000 --> 01:07:51,000
因为我有那个

1578
01:07:51,000 --> 01:07:53,000
他们把那个

1579
01:07:53,000 --> 01:07:57,000
native 就是它的那个演示的代码给所有的语会者都分享了一份

1580
01:07:57,000 --> 01:08:00,000
所以我是可以 fastcheck 去看他们到底用什么音频

1581
01:08:02,000 --> 01:08:03,000
ok

1582
01:08:03,000 --> 01:08:05,000
你可以看一下它用的是苹果原生的还是

1583
01:08:05,000 --> 01:08:07,000
就是那个叫什么 jabscrewcore 的

1584
01:08:07,000 --> 01:08:08,000
对

1585
01:08:08,000 --> 01:08:08,000
对

1586
01:08:08,000 --> 01:08:09,000
jabscrewcore

1587
01:08:09,000 --> 01:08:10,000
我理解应该是吧

1588
01:08:10,000 --> 01:08:13,000
今天这个是一个成本比较低的方案

1589
01:08:13,000 --> 01:08:14,000
你不用自己做任何事情

1590
01:08:16,000 --> 01:08:19,000
而且如果每个应用都要自己带一个 jabscrewcore 解析器的话

1591
01:08:19,000 --> 01:08:21,000
那个应用的尺寸也会比较大

1592
01:08:21,000 --> 01:08:22,000
嗯

1593
01:08:23,000 --> 01:08:24,000
就是一个问题我觉得

1594
01:08:24,000 --> 01:08:25,000
好

1595
01:08:26,000 --> 01:08:28,000
就是其实现在用那个 reignative

1596
01:08:28,000 --> 01:08:31,000
其实已经有一个 app 的点范了

1597
01:08:31,000 --> 01:08:34,000
就在 lsappstore 里面

1598
01:08:34,000 --> 01:08:37,000
Facebook 一个叫做新的应用叫做 groups

1599
01:08:37,000 --> 01:08:39,000
Facebook 群组的这个单独的一个应用

1600
01:08:39,000 --> 01:08:43,000
它其实是在很大程度上用的 reignative 写的

1601
01:08:43,000 --> 01:08:43,000
嗯

1602
01:08:43,000 --> 01:08:45,000
然后我之前

1603
01:08:45,000 --> 01:08:47,000
我再知道它是用 reignative 之前

1604
01:08:47,000 --> 01:08:49,000
我就已经下载过来用过它

1605
01:08:49,000 --> 01:08:51,000
当时我完全没有感觉到

1606
01:08:51,000 --> 01:08:53,000
它不是一个 native 的软件

1607
01:08:53,000 --> 01:08:54,000
就是非常

1608
01:08:54,000 --> 01:08:56,000
就整个体验是非常好的

1609
01:08:56,000 --> 01:08:58,000
问题是我们并不是很清楚说

1610
01:08:58,000 --> 01:09:01,000
它到底哪一部分是 UI 的那个人

1611
01:09:02,000 --> 01:09:03,000
就是多少比例是用的

1612
01:09:03,000 --> 01:09:04,000
对

1613
01:09:04,000 --> 01:09:04,000
对

1614
01:09:04,000 --> 01:09:06,000
或许这正是这个好处所在

1615
01:09:06,000 --> 01:09:08,000
你知道用户如果说它

1616
01:09:08,000 --> 01:09:10,000
它都不知道哪一部分

1617
01:09:10,000 --> 01:09:11,000
它都感受不出来

1618
01:09:11,000 --> 01:09:13,000
那就证明这个东西说不定就成功了

1619
01:09:13,000 --> 01:09:13,000
对

1620
01:09:13,000 --> 01:09:14,000
嗯

1621
01:09:14,000 --> 01:09:15,000
对

1622
01:09:15,000 --> 01:09:15,000
对

1623
01:09:15,000 --> 01:09:16,000
我们所拿

1624
01:09:16,000 --> 01:09:19,000
就是与会者所拿到的这个版本跟

1625
01:09:21,000 --> 01:09:22,000
Facebook 它所用的版本

1626
01:09:22,000 --> 01:09:23,000
实际上是不同步的

1627
01:09:23,000 --> 01:09:26,000
Facebook 它还在做很多的工作来

1628
01:09:27,000 --> 01:09:29,000
把这个东西给完善

1629
01:09:29,000 --> 01:09:30,000
然后才会

1630
01:09:30,000 --> 01:09:32,000
正式向大众发布

1631
01:09:32,000 --> 01:09:33,000
目前来说的话

1632
01:09:33,000 --> 01:09:34,000
我们所看到的版本

1633
01:09:34,000 --> 01:09:35,000
都是一个

1634
01:09:35,000 --> 01:09:36,000
就是一个

1635
01:09:36,000 --> 01:09:36,000
就是一个

1636
01:09:37,000 --> 01:09:38,000
TecProview

1637
01:09:38,000 --> 01:09:38,000
看

1638
01:09:38,000 --> 01:09:39,000
看的

1639
01:09:39,000 --> 01:09:39,000
Facebook

1640
01:09:41,000 --> 01:09:42,000
对了

1641
01:09:42,000 --> 01:09:42,000
OK

1642
01:09:42,000 --> 01:09:43,000
明白

1643
01:09:43,000 --> 01:09:43,000
嗯

1644
01:09:44,000 --> 01:09:45,000
对于说

1645
01:09:45,000 --> 01:09:46,000
原来那种刚才

1646
01:09:46,000 --> 01:09:47,000
Wailer 你也提到

1647
01:09:47,000 --> 01:09:48,000
他们的口号是叫做

1648
01:09:48,000 --> 01:09:49,000
LearnOnce

1649
01:09:49,000 --> 01:09:49,000
Right Everywhere

1650
01:09:49,000 --> 01:09:50,000
然后

1651
01:09:50,000 --> 01:09:51,000
我其实

1652
01:09:51,000 --> 01:09:51,000
我也在想

1653
01:09:52,000 --> 01:09:54,000
如果你按这种方式去构建你的 apps 之后

1654
01:09:54,000 --> 01:09:57,000
其实还是可以有满多部件

1655
01:09:57,000 --> 01:09:59,000
是可以在各平台间重用的

1656
01:09:59,000 --> 01:10:00,000
比如说之前

1657
01:10:01,000 --> 01:10:03,000
我好像是在前期还是上前期的时候

1658
01:10:03,000 --> 01:10:04,000
我们在讨论过

1659
01:10:05,000 --> 01:10:07,000
那个 Google 不是做的那个叫 Inbox 那个 app 吗

1660
01:10:07,000 --> 01:10:08,000
这个新的

1661
01:10:08,000 --> 01:10:10,000
它是有 Android 版

1662
01:10:10,000 --> 01:10:11,000
有 IS 版

1663
01:10:11,000 --> 01:10:11,000
然后还有一个

1664
01:10:11,000 --> 01:10:12,000
这个 Chrome

1665
01:10:12,000 --> 01:10:14,000
只有 Chrome 的那些可以用的 Web 版嘛

1666
01:10:15,000 --> 01:10:17,000
然后他们后来发了一篇博客文章

1667
01:10:17,000 --> 01:10:19,000
去讲他们怎么去做这么一件事的

1668
01:10:19,000 --> 01:10:20,000
就是他们把这个

1669
01:10:20,000 --> 01:10:21,000
假设你把这个

1670
01:10:21,000 --> 01:10:22,000
整个应用分成两部分

1671
01:10:22,000 --> 01:10:23,000
一对是前端

1672
01:10:23,000 --> 01:10:26,000
就跟那个用户交互的那部分

1673
01:10:26,000 --> 01:10:27,000
那么这部分就是说在

1674
01:10:27,000 --> 01:10:29,000
iOS 上面就是 Object-C 写的

1675
01:10:29,000 --> 01:10:31,000
然后在 Android 上就是用那个

1676
01:10:31,000 --> 01:10:32,000
Java 写的

1677
01:10:32,000 --> 01:10:33,000
然后在这个

1678
01:10:34,000 --> 01:10:36,000
Web 上就是 JavaScript 写的

1679
01:10:36,000 --> 01:10:38,000
但是他们其实都是用 Java 写的

1680
01:10:38,000 --> 01:10:40,000
然后通过 GWT 转化成 JavaScript

1681
01:10:40,000 --> 01:10:41,000
然后通过一个叫做

1682
01:10:41,000 --> 01:10:43,000
J 2 Object-C 的一个工具

1683
01:10:43,000 --> 01:10:44,000
转化成 Object-C 代码来做

1684
01:10:45,000 --> 01:10:48,000
不做那个逻辑的那一部分

1685
01:10:48,000 --> 01:10:51,000
就是跟原生界面无关

1686
01:10:51,000 --> 01:10:53,000
但是是跟这个后台的事物逻辑相关的

1687
01:10:53,000 --> 01:10:54,000
就是从同一套语言

1688
01:10:54,000 --> 01:10:55,000
然后再转化成不同的

1689
01:10:56,000 --> 01:10:58,000
从用 Java 写

1690
01:10:58,000 --> 01:10:59,000
然后通过这两种工具

1691
01:10:59,000 --> 01:11:01,000
转化成对应的 JavaScript 或者是 Object-C

1692
01:11:01,000 --> 01:11:03,000
但如果我们用这个

1693
01:11:03,000 --> 01:11:04,000
Rainative 来写的话

1694
01:11:04,000 --> 01:11:06,000
其实就这一步都可以省去了

1695
01:11:06,000 --> 01:11:08,000
我直接把所有的事物和逻辑

1696
01:11:09,000 --> 01:11:11,000
都写成 JavaScript 就好了

1697
01:11:11,000 --> 01:11:13,000
对 其实这让我想起那个

1698
01:11:15,000 --> 01:11:17,000
Apps-Arrayter 出的 Titanium

1699
01:11:19,000 --> 01:11:21,000
它也是用 JavaScript 来写

1700
01:11:21,000 --> 01:11:22,000
所有的事物逻辑

1701
01:11:22,000 --> 01:11:25,000
但是其使用的那个 UI

1702
01:11:25,000 --> 01:11:27,000
Viget 全都是原生的

1703
01:11:29,000 --> 01:11:30,000
它那个体验怎么样呢

1704
01:11:30,000 --> 01:11:32,000
不是特别好

1705
01:11:32,000 --> 01:11:39,000
因为前公司在做 Mobile App 的时候

1706
01:11:39,000 --> 01:11:40,000
考虑过用 Titanium

1707
01:11:41,000 --> 01:11:43,000
可能当时最大的一个问题就是

1708
01:11:43,000 --> 01:11:46,000
首先那个时候正好是 iOS 6

1709
01:11:46,000 --> 01:11:48,000
升到 7 的过程中

1710
01:11:48,000 --> 01:11:50,000
然后他们大概是比

1711
01:11:50,000 --> 01:11:51,000
落后了吗

1712
01:11:51,000 --> 01:11:54,000
落后了可能三到五个月的时间

1713
01:11:54,000 --> 01:11:55,000
就是我觉得这个是不可忍受的

1714
01:11:55,000 --> 01:11:58,000
就新的 iOS 完美已经在那边了

1715
01:11:58,000 --> 01:11:59,000
然后你如果你用 Titanium 的话

1716
01:11:59,000 --> 01:12:01,000
你用不到新的一些 Viget

1717
01:12:02,000 --> 01:12:02,000
对

1718
01:12:03,000 --> 01:12:06,000
然后他们的那一套东西

1719
01:12:06,000 --> 01:12:10,000
据说其实是非常优秀的

1720
01:12:10,000 --> 01:12:13,000
但是没有什么文档

1721
01:12:13,000 --> 01:12:13,000
主要是

1722
01:12:15,000 --> 01:12:18,000
这可能是用任何第三方平台

1723
01:12:18,000 --> 01:12:20,000
或者这种框架都会遇到的问题

1724
01:12:20,000 --> 01:12:20,000
对

1725
01:12:21,000 --> 01:12:23,000
据说 Apps-Arrayter 还在搞

1726
01:12:23,000 --> 01:12:25,000
现在还在搞一些新的什么东西

1727
01:12:25,000 --> 01:12:27,000
但我一直想不想的名字

1728
01:12:27,000 --> 01:12:32,000
其大概的走向可能和 React

1729
01:12:32,000 --> 01:12:34,000
有点一曲同工的地方

1730
01:12:34,000 --> 01:12:35,000
我还要看一下

1731
01:12:36,000 --> 01:12:36,000
OK

1732
01:12:37,000 --> 01:12:39,000
说回 Retail 这种方式

1733
01:12:39,000 --> 01:12:41,000
其实我还不是特别赞同

1734
01:12:41,000 --> 01:12:43,000
他们说完全不在乎 Retail One

1735
01:12:43,000 --> 01:12:45,000
Strong Alienware 这么一个口号的话

1736
01:12:45,000 --> 01:12:47,000
就说起码你假设你看到

1737
01:12:47,000 --> 01:12:49,000
像这些后台的逻辑

1738
01:12:49,000 --> 01:12:50,000
还有这些数据

1739
01:12:50,000 --> 01:12:52,000
这些模型都可以用加拿大数个构建

1740
01:12:52,000 --> 01:12:54,000
这一块是完全可以在各平台间重用的

1741
01:12:54,000 --> 01:12:54,000
对

1742
01:12:55,000 --> 01:12:57,000
而且我可以预见到

1743
01:12:57,000 --> 01:13:00,000
肯定会有人做一个中间层

1744
01:13:00,000 --> 01:13:02,000
然后说用这些组建的话

1745
01:13:02,000 --> 01:13:03,000
这些组建可以

1746
01:13:03,000 --> 01:13:06,000
就变成那个 Environmental Sensitive

1747
01:13:06,000 --> 01:13:08,000
然后他们会根据 Environmentalized

1748
01:13:09,000 --> 01:13:11,000
原生的组建

1749
01:13:11,000 --> 01:13:13,000
TabView 你可以用这个组建的 TabView

1750
01:13:13,000 --> 01:13:16,000
然后 TabView 背后的实现

1751
01:13:16,000 --> 01:13:17,000
会根据

1752
01:13:18,000 --> 01:13:20,000
The Target 是 Android 或 Target 的 IS

1753
01:13:20,000 --> 01:13:23,000
来自动选择相应平台的 TabView

1754
01:13:24,000 --> 01:13:26,000
这并不是 React Native

1755
01:13:26,000 --> 01:13:28,000
自己本身的一个设计理念

1756
01:13:28,000 --> 01:13:30,000
React Native 非常鼓励你去

1757
01:13:32,000 --> 01:13:35,000
根据各种平台本身的特性

1758
01:13:35,000 --> 01:13:37,000
来设计不一样的 UI

1759
01:13:37,000 --> 01:13:40,000
来用不一样的 component

1760
01:13:40,000 --> 01:13:43,000
而不是像这样的简单的替换的逻辑

1761
01:13:43,000 --> 01:13:44,000
但是我想

1762
01:13:44,000 --> 01:13:46,000
我们肯定会看到你三方的一些

1763
01:13:48,000 --> 01:13:49,000
solution 出来的

1764
01:13:50,000 --> 01:13:53,000
对 我觉得这个就是很多像什么

1765
01:13:53,000 --> 01:13:55,000
企业继软件可能会采取这种方式

1766
01:13:55,000 --> 01:13:56,000
因为它没有那么多的资源

1767
01:13:56,000 --> 01:13:58,000
或者说是人手

1768
01:13:58,000 --> 01:14:00,000
去优化哪一个平台的细节的体验

1769
01:14:00,000 --> 01:14:01,000
那么更加

1770
01:14:02,000 --> 01:14:03,000
节省成本的

1771
01:14:03,000 --> 01:14:05,000
节省开发时间的一个方式

1772
01:14:05,000 --> 01:14:06,000
就是通过这种

1773
01:14:06,000 --> 01:14:07,000
什么中间层去转换一下

1774
01:14:07,000 --> 01:14:08,000
我觉得

1775
01:14:09,000 --> 01:14:10,000
就虽然体验不是太好

1776
01:14:10,000 --> 01:14:12,000
但是起码成本撒去了

1777
01:14:12,000 --> 01:14:14,000
我觉得这个对很多企业软件来讲

1778
01:14:14,000 --> 01:14:15,000
就是这样的一个诉求

1779
01:14:15,000 --> 01:14:16,000
对

1780
01:14:18,000 --> 01:14:20,000
我们现在等于说如果

1781
01:14:20,000 --> 01:14:21,000
我

1782
01:14:21,000 --> 01:14:21,000
native

1783
01:14:21,000 --> 01:14:22,000
嗯

1784
01:14:22,000 --> 01:14:22,000
sorry

1785
01:14:22,000 --> 01:14:24,000
react native 这一套

1786
01:14:25,000 --> 01:14:28,000
能够吸引到一部分人

1787
01:14:28,000 --> 01:14:30,000
去把它炒起来的话呢

1788
01:14:31,000 --> 01:14:31,000
可以说

1789
01:14:31,000 --> 01:14:32,000
协议

1790
01:14:33,000 --> 01:14:33,000
跨平台

1791
01:14:33,000 --> 01:14:35,000
应用开发又多了一个新的选择

1792
01:14:35,000 --> 01:14:35,000
在

1793
01:14:36,000 --> 01:14:36,000
对呀

1794
01:14:36,000 --> 01:14:37,000
total

1795
01:14:37,000 --> 01:14:38,000
加把变成 java script

1796
01:14:39,000 --> 01:14:41,000
我有跟我们的 developers

1797
01:14:41,000 --> 01:14:42,000
所讨论这个问题

1798
01:14:43,000 --> 01:14:45,000
它并不单是在 solution 上

1799
01:14:45,000 --> 01:14:46,000
就是 tech solution 上

1800
01:14:46,000 --> 01:14:49,000
有改变你的组织架构

1801
01:14:49,000 --> 01:14:50,000
而关键是说

1802
01:14:51,000 --> 01:14:52,000
如果你想

1803
01:14:53,000 --> 01:14:54,000
如果你真的时间

1804
01:14:54,000 --> 01:14:54,000
learn once

1805
01:14:54,000 --> 01:14:55,000
write everywhere 的话

1806
01:14:56,000 --> 01:14:56,000
那

1807
01:14:57,000 --> 01:14:59,000
所谓 web developer 跟

1808
01:15:00,000 --> 01:15:02,000
mobile developer 之间的界限

1809
01:15:02,000 --> 01:15:03,000
就变得更模糊了

1810
01:15:03,000 --> 01:15:04,000
我觉得对

1811
01:15:05,000 --> 01:15:06,000
分手二二和一

1812
01:15:06,000 --> 01:15:07,000
对这个资源的

1813
01:15:08,000 --> 01:15:10,000
对这个企业资源的一个运用

1814
01:15:10,000 --> 01:15:12,000
实际上是一个非常有意思的事情

1815
01:15:12,000 --> 01:15:13,000
你知道

1816
01:15:13,000 --> 01:15:14,000
所以你知道

1817
01:15:14,000 --> 01:15:15,000
我们的

1818
01:15:15,000 --> 01:15:15,000
对

1819
01:15:15,000 --> 01:15:16,000
我们说如果现在

1820
01:15:17,000 --> 01:15:17,000
web application

1821
01:15:17,000 --> 01:15:19,000
不需要太多维护的话

1822
01:15:19,000 --> 01:15:20,000
那这些人就可以去写

1823
01:15:20,000 --> 01:15:21,000
那个

1824
01:15:21,000 --> 01:15:21,000
android app

1825
01:15:21,000 --> 01:15:22,000
去写 iOS app

1826
01:15:22,000 --> 01:15:23,000
对不对

1827
01:15:23,000 --> 01:15:25,000
所以这一点上对于企业来说

1828
01:15:25,000 --> 01:15:26,000
可能是一个非常重要的事情

1829
01:15:27,000 --> 01:15:29,000
所以我有跟我们的

1830
01:15:29,000 --> 01:15:31,000
web developer 开玩笑说

1831
01:15:31,000 --> 01:15:33,000
那你现在得赶紧去学

1832
01:15:33,000 --> 01:15:35,000
HML CSS

1833
01:15:35,000 --> 01:15:35,000
对

1834
01:15:35,000 --> 01:15:36,000
赶紧去

1835
01:15:36,000 --> 01:15:37,000
赶紧开始学

1836
01:15:41,000 --> 01:15:42,000
它现在

1837
01:15:42,000 --> 01:15:44,000
reinactive 这个还是在什么

1838
01:15:44,000 --> 01:15:45,000
alpha 阶段

1839
01:15:45,000 --> 01:15:46,000
可能是 prealpha 阶段

1840
01:15:46,000 --> 01:15:47,000
他们现在是说

1841
01:15:47,000 --> 01:15:49,000
有一个私有的 github

1842
01:15:49,000 --> 01:15:50,000
repository

1843
01:15:50,000 --> 01:15:50,000
你们可以访问

1844
01:15:50,000 --> 01:15:52,000
就参与会者可以访问嘛

1845
01:15:52,000 --> 01:15:53,000
外界还没公开

1846
01:15:55,000 --> 01:15:56,000
我不知道你看了多少

1847
01:15:56,000 --> 01:15:57,000
但是

1848
01:15:57,000 --> 01:15:58,000
我就比较好奇

1849
01:15:58,000 --> 01:15:59,000
它怎么去实现

1850
01:15:59,000 --> 01:16:00,000
它就是

1851
01:16:00,000 --> 01:16:02,000
Josecram 那部分的业务代码

1852
01:16:02,000 --> 01:16:03,000
业务逻辑

1853
01:16:03,000 --> 01:16:05,000
怎么去和原生的那些

1854
01:16:05,000 --> 01:16:07,000
进行交互那一块时间

1855
01:16:07,000 --> 01:16:07,000
我没有

1856
01:16:07,000 --> 01:16:09,000
还没有来得及

1857
01:16:09,000 --> 01:16:10,000
对这个代码本身

1858
01:16:10,000 --> 01:16:11,000
做很多的研究

1859
01:16:12,000 --> 01:16:15,000
但是对 developer 来说的话

1860
01:16:15,000 --> 01:16:16,000
你所做的事情

1861
01:16:16,000 --> 01:16:17,000
真的跟以前写

1862
01:16:17,000 --> 01:16:19,000
那个 web application

1863
01:16:19,000 --> 01:16:20,000
没有太大的区别

1864
01:16:20,000 --> 01:16:21,000
我可以把流程说一下

1865
01:16:21,000 --> 01:16:22,000
就是说

1866
01:16:22,000 --> 01:16:23,000
从那个纯粹的

1867
01:16:23,000 --> 01:16:24,000
开发者的

1868
01:16:24,000 --> 01:16:26,000
这个角度来说的话

1869
01:16:26,000 --> 01:16:29,000
你 clone 这个 repository

1870
01:16:29,000 --> 01:16:30,000
然后

1871
01:16:30,000 --> 01:16:32,000
你做 npm install

1872
01:16:32,000 --> 01:16:33,000
在你就是

1873
01:16:33,000 --> 01:16:34,000
就是传统的 java script

1874
01:16:34,000 --> 01:16:35,000
你知道

1875
01:16:35,000 --> 01:16:36,000
大家都对

1876
01:16:36,000 --> 01:16:36,000
让你写

1877
01:16:36,000 --> 01:16:38,000
说 npm start

1878
01:16:38,000 --> 01:16:39,000
ok

1879
01:16:39,000 --> 01:16:40,000
npm start 的

1880
01:16:40,000 --> 01:16:41,000
对

1881
01:16:41,000 --> 01:16:41,000
理由

1882
01:16:41,000 --> 01:16:42,000
原因呢是

1883
01:16:42,000 --> 01:16:44,000
现在是在一个 dev environment

1884
01:16:44,000 --> 01:16:45,000
environmental 里头

1885
01:16:45,000 --> 01:16:47,000
这些 java script 的文件

1886
01:16:47,000 --> 01:16:48,000
需要 serve 到

1887
01:16:48,000 --> 01:16:51,000
那个 simulator 里头去

1888
01:16:51,000 --> 01:16:51,000
对不对

1889
01:16:51,000 --> 01:16:53,000
那个 iOS simulator 里头去

1890
01:16:53,000 --> 01:16:55,000
所以这个 npm start

1891
01:16:55,000 --> 01:16:55,000
就会

1892
01:16:57,000 --> 01:17:00,000
启动一个这样的 server

1893
01:17:00,000 --> 01:17:02,000
然后 watching 的那些文件

1894
01:17:03,000 --> 01:17:05,000
然后你如果去看那些文件的话呢

1895
01:17:05,000 --> 01:17:08,000
实际上跟你写 react 的

1896
01:17:08,000 --> 01:17:12,000
那个 web 的那个 application

1897
01:17:12,000 --> 01:17:13,000
并没有太大的区别

1898
01:17:14,000 --> 01:17:16,000
如果真的要说最大的区别

1899
01:17:16,000 --> 01:17:17,000
可能就是说

1900
01:17:17,000 --> 01:17:18,000
你没有 css file 了

1901
01:17:18,000 --> 01:17:20,000
你所有的 file 都是 inline

1902
01:17:20,000 --> 01:17:21,000
所有的 style 都是 inline

1903
01:17:21,000 --> 01:17:22,000
这是最大的区别了

1904
01:17:22,000 --> 01:17:23,000
其他的东西都看起来

1905
01:17:23,000 --> 01:17:24,000
非常的相似

1906
01:17:24,000 --> 01:17:25,000
对对

1907
01:17:25,000 --> 01:17:26,000
然后你写的是真的是纯

1908
01:17:26,000 --> 01:17:28,000
就是 common.js 那种组件

1909
01:17:30,000 --> 01:17:32,000
最神奇的地方在于

1910
01:17:32,000 --> 01:17:33,000
如果你看到那个 video 的话

1911
01:17:33,000 --> 01:17:34,000
有这一点

1912
01:17:34,000 --> 01:17:35,000
就是

1913
01:17:35,000 --> 01:17:36,000
在那个

1914
01:17:36,000 --> 01:17:38,000
不然说如果你

1915
01:17:38,000 --> 01:17:39,000
改变一下 css

1916
01:17:39,000 --> 01:17:41,000
那个 iOS 的 simulator 是

1917
01:17:41,000 --> 01:17:43,000
直接可以得到这个结果的

1918
01:17:43,000 --> 01:17:45,000
你是不需要去 recompile 的

1919
01:17:45,000 --> 01:17:45,000
对

1920
01:17:45,000 --> 01:17:46,000
就也非常的神奇

1921
01:17:46,000 --> 01:17:47,000
对对

1922
01:17:47,000 --> 01:17:48,000
对

1923
01:17:48,000 --> 01:17:49,000
ok

1924
01:17:49,000 --> 01:17:51,000
他们有一个说法

1925
01:17:51,000 --> 01:17:52,000
就是说要实现

1926
01:17:52,000 --> 01:17:53,000
你在这边

1927
01:17:53,000 --> 01:17:55,000
就边境器里面改一行代码

1928
01:17:55,000 --> 01:17:57,000
然后在 iOS 那个那个模拟器里面

1929
01:17:57,000 --> 01:17:57,000
实现

1930
01:17:57,000 --> 01:17:58,000
呃

1931
01:17:58,000 --> 01:18:00,000
就出现改动只需要不到一秒

1932
01:18:00,000 --> 01:18:00,000
对

1933
01:18:00,000 --> 01:18:01,000
这个

1934
01:18:01,000 --> 01:18:01,000
ok

1935
01:18:01,000 --> 01:18:02,000
就是 library load

1936
01:18:02,000 --> 01:18:04,000
对开发效率非常大的

1937
01:18:04,000 --> 01:18:05,000
大的提升

1938
01:18:05,000 --> 01:18:07,000
library load 的时间级别吗

1939
01:18:07,000 --> 01:18:09,000
对对对

1940
01:18:09,000 --> 01:18:10,000
drivers

1941
01:18:10,000 --> 01:18:12,000
大世界里面有教练 Jrebel

1942
01:18:12,000 --> 01:18:14,000
也做类似的事情

1943
01:18:14,000 --> 01:18:16,000
哈哈哈哈

1944
01:18:16,000 --> 01:18:17,000
这个我觉得

1945
01:18:17,000 --> 01:18:18,000
看那个 demo 就是挺酷炫的

1946
01:18:18,000 --> 01:18:19,000
嗯

1947
01:18:19,000 --> 01:18:19,000
哎

1948
01:18:19,000 --> 01:18:20,000
不过

1949
01:18:20,000 --> 01:18:21,000
你们觉得这样的话

1950
01:18:21,000 --> 01:18:22,000
那不变成

1951
01:18:22,000 --> 01:18:25,000
javascript 变成一个什么通用能力

1952
01:18:25,000 --> 01:18:26,000
这已经是现实了

1953
01:18:26,000 --> 01:18:29,000
对啊

1954
01:18:29,000 --> 01:18:30,000
哈哈哈哈

1955
01:18:30,000 --> 01:18:31,000
那你们觉得这是好事吗

1956
01:18:31,000 --> 01:18:35,000
有也是这个电脑上面的另一层电脑

1957
01:18:35,000 --> 01:18:35,000
对对对

1958
01:18:35,000 --> 01:18:36,000
这个

1959
01:18:36,000 --> 01:18:36,000
这个浏览器那边

1960
01:18:36,000 --> 01:18:37,000
我们就毫无疑问

1961
01:18:37,000 --> 01:18:39,000
javascript 已经是一个

1962
01:18:39,000 --> 01:18:40,000
就如果它不是通用语言

1963
01:18:40,000 --> 01:18:41,000
至少是一个构建的基石

1964
01:18:41,000 --> 01:18:42,000
因为很多语言可以

1965
01:18:42,000 --> 01:18:44,000
所以 compile to javascript 嘛

1966
01:18:44,000 --> 01:18:45,000
对

1967
01:18:45,000 --> 01:18:47,000
我觉得 javascript 其实就是现在的私音嘛

1968
01:18:47,000 --> 01:18:48,000
就现在的

1969
01:18:48,000 --> 01:18:49,000
不会变了

1970
01:18:49,000 --> 01:18:52,000
现在的浏览器就是 down to the pdp 11 之类的

1971
01:18:52,000 --> 01:18:53,000
然后

1972
01:18:53,000 --> 01:18:56,000
这些语言本来是多那个

1973
01:18:56,000 --> 01:18:59,000
多设计的多么粗糙的一个语言

1974
01:18:59,000 --> 01:19:01,000
但就是因为实事造英雄

1975
01:19:01,000 --> 01:19:01,000
把它

1976
01:19:01,000 --> 01:19:04,000
推的推到了现在的霸主地位

1977
01:19:04,000 --> 01:19:07,000
我觉得 javascript 基本上就是另外一个私音嘛

1978
01:19:07,000 --> 01:19:07,000
对啊

1979
01:19:07,000 --> 01:19:09,000
但是现在 reality 不太要做的事情

1980
01:19:09,000 --> 01:19:12,000
就是说把这件事情再往这个

1981
01:19:12,000 --> 01:19:13,000
mobile 就移动端在推

1982
01:19:13,000 --> 01:19:14,000
因为之前移动端

1983
01:19:14,000 --> 01:19:15,000
大家还是在

1984
01:19:15,000 --> 01:19:17,000
就至少我们是鼓励

1985
01:19:17,000 --> 01:19:18,000
或者消费者也愿意使用

1986
01:19:18,000 --> 01:19:20,000
所谓的原声的英雄嘛

1987
01:19:20,000 --> 01:19:21,000
但这原声打影

1988
01:19:21,000 --> 01:19:23,000
就可能说说你要用这个

1989
01:19:23,000 --> 01:19:24,000
平台自己的那种工具

1990
01:19:24,000 --> 01:19:26,000
然后自己的语言来写

1991
01:19:26,000 --> 01:19:27,000
但现在你来看 reality

1992
01:19:27,000 --> 01:19:28,000
它能够把这个

1993
01:19:28,000 --> 01:19:30,000
整个效果做的这么跟原声

1994
01:19:30,000 --> 01:19:31,000
就是说以假乱真吧

1995
01:19:31,000 --> 01:19:32,000
至少是

1996
01:19:32,000 --> 01:19:36,000
那就完全没有必要再用平台原声的语言来写了

1997
01:19:36,000 --> 01:19:37,000
就好像说

1998
01:19:37,000 --> 01:19:39,000
我是现在是一个 web developer

1999
01:19:39,000 --> 01:19:41,000
那我也可以做 lsa 应用

2000
01:19:41,000 --> 01:19:43,000
不需要学这么 objectc 或者 swift 了吗

2001
01:19:43,000 --> 01:19:44,000
对啊

2002
01:19:44,000 --> 01:19:46,000
这就好像把 c 语言

2003
01:19:46,000 --> 01:19:49,000
移植到不同的架构的处理器上嘛

2004
01:19:51,000 --> 01:19:52,000
我觉得吴涛刚刚说的很好

2005
01:19:52,000 --> 01:19:54,000
就是这怎么说

2006
01:19:54,000 --> 01:19:57,000
就是既定事实

2007
01:19:57,000 --> 01:19:59,000
javascript 的应用就是既定事实

2008
01:19:59,000 --> 01:20:02,000
所以我很期待 eA 6 和 eA 7

2009
01:20:02,000 --> 01:20:04,000
因为这个语言本身

2010
01:20:04,000 --> 01:20:06,000
还是有非常非常多的问题的

2011
01:20:06,000 --> 01:20:10,000
特别是它的 proto type 这样一个架构

2012
01:20:10,000 --> 01:20:13,000
而不是 class-based eA 6 和 eA 7

2013
01:20:13,000 --> 01:20:15,000
我很期待它们把这些问题解决好

2014
01:20:15,000 --> 01:20:16,000
这样的话

2015
01:20:16,000 --> 01:20:18,000
对于我们这些语言的使用者来说

2016
01:20:18,000 --> 01:20:20,000
是一个非常好的事情嘛

2017
01:20:20,000 --> 01:20:21,000
因为

2018
01:20:22,000 --> 01:20:23,000
作为一个 web dev

2019
01:20:23,000 --> 01:20:25,000
你经常不喜欢 proto type base

2020
01:20:25,000 --> 01:20:26,000
而是说

2021
01:20:27,000 --> 01:20:29,000
在真正的应用上面

2022
01:20:29,000 --> 01:20:34,000
我们很多时候都是在用 proto type 去 simulate the class

2023
01:20:34,000 --> 01:20:35,000
因为没有 native class

2024
01:20:36,000 --> 01:20:38,000
这是我所不喜欢的一点

2025
01:20:38,000 --> 01:20:39,000
不说 proto type 本身

2026
01:20:39,000 --> 01:20:42,000
在 eA 6 中加入真正的 class-up

2027
01:20:42,000 --> 01:20:44,000
或者这是我所期待的

2028
01:20:44,000 --> 01:20:46,000
proto type 当然 proto type 的好处和应用

2029
01:20:46,000 --> 01:20:48,000
但是实际的应用中

2030
01:20:48,000 --> 01:20:50,000
如果我们要用 class

2031
01:20:50,000 --> 01:20:52,000
那我还是希望能有真正的 class

2032
01:20:54,000 --> 01:20:54,000
对

2033
01:20:54,000 --> 01:20:57,000
我觉得 class 出现其实是比较

2034
01:20:57,000 --> 01:21:00,000
如果有比较合理的 class 的支持的话

2035
01:21:00,000 --> 01:21:02,000
那对于构建大型程序

2036
01:21:02,000 --> 01:21:05,000
实际上是更加有利的

2037
01:21:05,000 --> 01:21:09,000
因为 proto type based object orientation

2038
01:21:09,000 --> 01:21:11,000
它的优点我觉得就在于

2039
01:21:11,000 --> 01:21:13,000
你做原型开发非常的快

2040
01:21:13,000 --> 01:21:22,000
你不需要去考虑那个模板和实际的 instance 之间的抽象的问题

2041
01:21:22,000 --> 01:21:24,000
但当你要做大一些的东西的时候

2042
01:21:24,000 --> 01:21:26,000
这个抽象其实还是相当比较

2043
01:21:26,000 --> 01:21:27,000
OK

2044
01:21:27,000 --> 01:21:28,000
对

2045
01:21:28,000 --> 01:21:29,000
我不知道

2046
01:21:29,000 --> 01:21:32,000
因为我对这种所谓传统的经典的

2047
01:21:32,000 --> 01:21:34,000
至于 class 的这种

2048
01:21:34,000 --> 01:21:38,000
其实并没有太特别的偏好

2049
01:21:38,000 --> 01:21:40,000
所以我觉得两种都还好了

2050
01:21:40,000 --> 01:21:42,000
没有那么

2051
01:21:42,000 --> 01:21:44,000
class-based 没有那么好

2052
01:21:44,000 --> 01:21:46,000
proto type-based 没有那么差

2053
01:21:46,000 --> 01:21:47,000
我觉得是这样

2054
01:21:47,000 --> 01:21:48,000
go 也是没有 class 对吧

2055
01:21:48,000 --> 01:21:50,000
go 根本就没有

2056
01:21:50,000 --> 01:21:51,000
proto type 都没有

2057
01:21:51,000 --> 01:21:53,000
它是 gv interface 的

2058
01:21:53,000 --> 01:21:54,000
完全更不一样

2059
01:21:54,000 --> 01:21:55,000
我觉得直接用起来

2060
01:21:55,000 --> 01:21:57,000
我觉得那种是更灵活的

2061
01:21:57,000 --> 01:21:57,000
对

2062
01:21:57,000 --> 01:21:58,000
所以我觉得你其实就是一个

2063
01:21:58,000 --> 01:22:00,000
你比较不喜欢

2064
01:22:00,000 --> 01:22:01,000
class

2065
01:22:01,000 --> 01:22:02,000
经典的 class

2066
01:22:02,000 --> 01:22:03,000
对对对

2067
01:22:03,000 --> 01:22:03,000
没错

2068
01:22:03,000 --> 01:22:05,000
加完

2069
01:22:05,000 --> 01:22:06,000
你看太多

2070
01:22:06,000 --> 01:22:08,000
我觉得你可以去看看 iO

2071
01:22:08,000 --> 01:22:09,000
就是 eO 这个语言

2072
01:22:09,000 --> 01:22:11,000
我不知道怎么念的

2073
01:22:11,000 --> 01:22:13,000
它其实也是 proto type-based

2074
01:22:13,000 --> 01:22:14,000
然后

2075
01:22:14,000 --> 01:22:16,000
这个说来其实还蛮奇怪的

2076
01:22:16,000 --> 01:22:18,000
object-c 算是一个经典的

2077
01:22:18,000 --> 01:22:19,000
gv class 的

2078
01:22:19,000 --> 01:22:20,000
计程

2079
01:22:20,000 --> 01:22:21,000
那个 o 语也不算

2080
01:22:21,000 --> 01:22:24,000
它是类似于 small talk 那种方式

2081
01:22:24,000 --> 01:22:27,000
它是在 c 上面加了一层 small talk

2082
01:22:27,000 --> 01:22:29,000
然后用一个

2083
01:22:29,000 --> 01:22:31,000
用一个最近看到的一句话来说

2084
01:22:31,000 --> 01:22:33,000
object-c 就是过去 25 年

2085
01:22:33,000 --> 01:22:36,000
计算机语言发展史的缩影

2086
01:22:36,000 --> 01:22:38,000
你在看里面不同的语言特性的时候

2087
01:22:38,000 --> 01:22:39,000
你会

2088
01:22:39,000 --> 01:22:40,000
如果你从一个计算机

2089
01:22:40,000 --> 01:22:43,000
历史学家佳颖浩的角度来看的话

2090
01:22:43,000 --> 01:22:44,000
就你会看到

2091
01:22:44,000 --> 01:22:47,000
这个特征来自于那个时代的一个思潮

2092
01:22:47,000 --> 01:22:50,000
考古语言

2093
01:22:50,000 --> 01:22:52,000
所以其实我觉得就很好奇嘛

2094
01:22:52,000 --> 01:22:55,000
就是就是 o object-c 也已经证明了

2095
01:22:55,000 --> 01:22:58,000
就是说你没有一个大规模的

2096
01:22:58,000 --> 01:23:02,000
就没有 class 的支持的一个 o 的语言

2097
01:23:02,000 --> 01:23:03,000
也可以做得很好嘛

2098
01:23:05,000 --> 01:23:07,000
就是是不是不能证明这一天

2099
01:23:07,000 --> 01:23:08,000
我觉得不能

2100
01:23:08,000 --> 01:23:10,000
不太能证明吧

2101
01:23:10,000 --> 01:23:10,000
不过这

2102
01:23:10,000 --> 01:23:11,000
好

2103
01:23:11,000 --> 01:23:11,000
算了

2104
01:23:11,000 --> 01:23:12,000
比赛子 point

2105
01:23:12,000 --> 01:23:12,000
我们可以

2106
01:23:12,000 --> 01:23:14,000
留待以后就好了嘛

2107
01:23:14,000 --> 01:23:17,000
就能讲这个变成语言的一切

2108
01:23:17,000 --> 01:23:17,000
我们刚刚说到就是

2109
01:23:19,000 --> 01:23:21,000
javascript 英文这么广泛

2110
01:23:21,000 --> 01:23:24,000
实际上在这个 talk 中

2111
01:23:24,000 --> 01:23:27,000
我们有一个 netflix 的那个 speaker

2112
01:23:28,000 --> 01:23:29,000
他有说到说

2113
01:23:29,000 --> 01:23:32,000
就是我们现在有很多智能那个电视嘛

2114
01:23:32,000 --> 01:23:34,000
智能电视上有很多可以看

2115
01:23:34,000 --> 01:23:35,000
netflix

2116
01:23:35,000 --> 01:23:39,000
然后他们都是用 javascript 来写这个东西的

2117
01:23:39,000 --> 01:23:42,000
他们都是 shipping 一个那个 whipkit 的

2118
01:23:45,000 --> 01:23:47,000
风桩给那个电视场上

2119
01:23:47,000 --> 01:23:50,000
然后就其中有他们的 netflix 的 application

2120
01:23:52,000 --> 01:23:52,000
对

2121
01:23:52,000 --> 01:23:55,000
你叫那个 appletv 也是这个方式实现的吗

2122
01:23:55,000 --> 01:23:55,000
哦

2123
01:23:55,000 --> 01:23:56,000
interesting

2124
01:23:57,000 --> 01:23:58,000
netflix 的

2125
01:24:00,000 --> 01:24:04,000
nextflix 他们实际上现在是用 react 来写那个 tvapp

2126
01:24:05,000 --> 01:24:06,000
就好像 react native 一样

2127
01:24:06,000 --> 01:24:08,000
他们是 react tv

2128
01:24:08,000 --> 01:24:08,000
you know

2129
01:24:08,000 --> 01:24:09,000
啊

2130
01:24:09,000 --> 01:24:09,000
yeah

2131
01:24:09,000 --> 01:24:11,000
那个不是开源的程序

2132
01:24:11,000 --> 01:24:12,000
但是但是他有介绍说

2133
01:24:12,000 --> 01:24:13,000
就是怎么样实现的

2134
01:24:13,000 --> 01:24:14,000
嗯哼

2135
01:24:14,000 --> 01:24:15,000
嗯哼

2136
01:24:15,000 --> 01:24:17,000
然后之前我也在玩那个

2137
01:24:17,000 --> 01:24:20,000
你有那个就什么 crumbcast 那个那个小棒子吗

2138
01:24:21,000 --> 01:24:22,000
我在公司有

2139
01:24:22,000 --> 01:24:24,000
但是我没有我没有很经常写

2140
01:24:24,000 --> 01:24:25,000
我我我我自己有一个

2141
01:24:25,000 --> 01:24:26,000
然后我之前玩过一段时间

2142
01:24:26,000 --> 01:24:28,000
就他也是那种方式

2143
01:24:28,000 --> 01:24:30,000
他整个就是其实就是给浏览器窗口

2144
01:24:30,000 --> 01:24:31,000
他你可以电视上的

2145
01:24:32,000 --> 01:24:33,000
啊

2146
01:24:33,000 --> 01:24:34,000
然后你们也可以做类似的事情

2147
01:24:34,000 --> 01:24:37,000
就是你可以把这个整个 react 组件丢过去

2148
01:24:37,000 --> 01:24:39,000
然后做一些很好玩的事

2149
01:24:39,000 --> 01:24:39,000
哎

2150
01:24:39,000 --> 01:24:40,000
我查问你觉得

2151
01:24:40,000 --> 01:24:41,000
嗯

2152
01:24:41,000 --> 01:24:43,000
crumbcast 那个小小棒子

2153
01:24:43,000 --> 01:24:46,000
他要求有外界的 wifi 在是吧

2154
01:24:47,000 --> 01:24:47,000
对

2155
01:24:47,000 --> 01:24:49,000
他只能通过 wifi 和外界

2156
01:24:49,000 --> 01:24:51,000
他自己不能提供一个热点

2157
01:24:51,000 --> 01:24:52,000
他自己不

2158
01:24:52,000 --> 01:24:54,000
他只是一个 wifi 接受器而已

2159
01:24:54,000 --> 01:24:56,000
但是你你把他 hack 掉

2160
01:24:56,000 --> 01:24:57,000
应该也可能做一个热点

2161
01:24:57,000 --> 01:24:57,000
不

2162
01:24:57,000 --> 01:24:58,000
但你为什么你会想的

2163
01:24:58,000 --> 01:25:02,000
因为如果他能够自己成为一个 wifi 接点的话

2164
01:25:03,000 --> 01:25:05,000
我出去在酒店里面

2165
01:25:05,000 --> 01:25:06,000
利用酒店的电视

2166
01:25:07,000 --> 01:25:08,000
呃看

2167
01:25:09,000 --> 01:25:13,000
在 iPad 上面预先露的好的视频

2168
01:25:13,000 --> 01:25:15,000
其实你想发送过去是吧

2169
01:25:15,000 --> 01:25:15,000
不

2170
01:25:15,000 --> 01:25:17,000
首先有两点是有问题的

2171
01:25:17,000 --> 01:25:18,000
第一个

2172
01:25:18,000 --> 01:25:19,000
他不是他不能

2173
01:25:19,000 --> 01:25:21,000
他只能是一个 wifi 的这个 client

2174
01:25:21,000 --> 01:25:22,000
他不是一个 ap

2175
01:25:22,000 --> 01:25:23,000
但估计你 hack 一下

2176
01:25:23,000 --> 01:25:24,000
应该也行

2177
01:25:24,000 --> 01:25:25,000
但第二个问题就是说

2178
01:25:25,000 --> 01:25:28,000
crumbcast 真的整个的一个

2179
01:25:28,000 --> 01:25:30,000
那个 API 包括认证机制

2180
01:25:30,000 --> 01:25:35,000
是不允许你随意播放你本机的视频文件的

2181
01:25:35,000 --> 01:25:35,000
ok

2182
01:25:35,000 --> 01:25:36,000
就比较麻烦

2183
01:25:36,000 --> 01:25:37,000
你可以做

2184
01:25:37,000 --> 01:25:38,000
但是比较麻烦

2185
01:25:38,000 --> 01:25:41,000
其实私人做没有那种比较现成的 app 来搞

2186
01:25:41,000 --> 01:25:41,000
这种

2187
01:25:42,000 --> 01:25:43,000
好吧

2188
01:25:43,000 --> 01:25:44,000
不过不影响

2189
01:25:44,000 --> 01:25:46,000
现在很多手机都可以建一个热点

2190
01:25:46,000 --> 01:25:48,000
然后你可以用那个手机的

2191
01:25:49,000 --> 01:25:51,000
有很多 Androidapps 可以让你做到这件事情

2192
01:25:51,000 --> 01:25:52,000
ok

2193
01:25:53,000 --> 01:25:53,000
iOS 就

2194
01:25:54,000 --> 01:25:55,000
暂时没有解决

2195
01:25:56,000 --> 01:25:57,000
app tv 都没有没有

2196
01:25:57,000 --> 01:25:58,000
好

2197
01:25:58,000 --> 01:25:59,000
大日差

2198
01:26:00,000 --> 01:26:01,000
那我们接下来讲

2199
01:26:01,000 --> 01:26:03,000
react native 还有什么要补充的吗

2200
01:26:03,000 --> 01:26:04,000
我给它插补我想一下

2201
01:26:04,000 --> 01:26:06,000
我觉得差不多了吧

2202
01:26:07,000 --> 01:26:07,000
那讲

2203
01:26:07,000 --> 01:26:09,000
其实有一个问题就是 react

2204
01:26:09,000 --> 01:26:10,000
react

2205
01:26:10,000 --> 01:26:12,000
react native 可以用来写游戏吗

2206
01:26:16,000 --> 01:26:18,000
那种什么 like game 应该是可以的吧

2207
01:26:18,000 --> 01:26:19,000
我觉得

2208
01:26:19,000 --> 01:26:19,000
对

2209
01:26:19,000 --> 01:26:19,000
就是

2210
01:26:21,000 --> 01:26:23,000
不过也不一定有用那个什么 webgl

2211
01:26:24,000 --> 01:26:26,000
来写很复杂的设计游戏

2212
01:26:26,000 --> 01:26:29,000
可是在 react native

2213
01:26:29,000 --> 01:26:32,000
react native 所能操纵的原生组件

2214
01:26:32,000 --> 01:26:35,000
到底到一个什么层级呢

2215
01:26:35,000 --> 01:26:36,000
比如说

2216
01:26:36,000 --> 01:26:36,000
那个

2217
01:26:37,000 --> 01:26:38,000
iOS 上面的 spread kit

2218
01:26:38,000 --> 01:26:39,000
它可以

2219
01:26:39,000 --> 01:26:40,000
它可以用吗

2220
01:26:41,000 --> 01:26:42,000
这个就只有 vlog 才能回答

2221
01:26:44,000 --> 01:26:45,000
有人问过 lace 的问题

2222
01:26:45,000 --> 01:26:47,000
但不是直接问游戏

2223
01:26:47,000 --> 01:26:48,000
而是说到底

2224
01:26:48,000 --> 01:26:49,000
它可以

2225
01:26:49,000 --> 01:26:50,000
哪些组件是可以用是吧

2226
01:26:50,000 --> 01:26:51,000
对

2227
01:26:51,000 --> 01:26:53,000
然后所得到的答案是说

2228
01:26:54,000 --> 01:26:57,000
我的理解不是 quadlnquadln

2229
01:26:57,000 --> 01:26:57,000
是说

2230
01:26:57,000 --> 01:26:59,000
所有的组件都是可以用的

2231
01:26:59,000 --> 01:27:00,000
但可能有些组件

2232
01:27:00,000 --> 01:27:02,000
你得自己手工把它包装一下

2233
01:27:03,000 --> 01:27:04,000
OK

2234
01:27:05,000 --> 01:27:05,000
对

2235
01:27:05,000 --> 01:27:06,000
就以什么方式包装呢

2236
01:27:06,000 --> 01:27:09,000
是说我必须再用所有的或者是

2237
01:27:09,000 --> 01:27:09,000
c

2238
01:27:09,000 --> 01:27:11,000
c 写一个 rapper

2239
01:27:11,000 --> 01:27:12,000
然后它可以调用

2240
01:27:13,000 --> 01:27:13,000
不是

2241
01:27:13,000 --> 01:27:15,000
是在 javascrews 的导演写一个 rapper

2242
01:27:16,000 --> 01:27:17,000
这样想

2243
01:27:18,000 --> 01:27:18,000
这样想

2244
01:27:20,000 --> 01:27:21,000
不考虑 react native

2245
01:27:21,000 --> 01:27:22,000
就考虑那个

2246
01:27:23,000 --> 01:27:24,000
react the j as the part

2247
01:27:25,000 --> 01:27:26,000
你可以用 dv

2248
01:27:26,000 --> 01:27:26,000
对吧

2249
01:27:26,000 --> 01:27:27,000
你可以用 dv

2250
01:27:27,000 --> 01:27:28,000
你可以用 like

2251
01:27:28,000 --> 01:27:30,000
almost any html component

2252
01:27:31,000 --> 01:27:32,000
但是 dv 本身

2253
01:27:32,000 --> 01:27:34,000
它有一个中间层是

2254
01:27:35,000 --> 01:27:37,000
react 已经提供给你的

2255
01:27:37,000 --> 01:27:38,000
react 已经写了这个 dv

2256
01:27:38,000 --> 01:27:39,000
这个 component

2257
01:27:39,000 --> 01:27:39,000
对不对

2258
01:27:39,000 --> 01:27:42,000
就 virtualdom 里面会有一个 dv 的对应的

2259
01:27:42,000 --> 01:27:44,000
一个对象吧

2260
01:27:44,000 --> 01:27:45,000
然后这个

2261
01:27:46,000 --> 01:27:47,000
这个东西是 javascrew

2262
01:27:47,000 --> 01:27:49,000
是在 javascrew 里头

2263
01:27:49,000 --> 01:27:51,000
有一个组件来告诉 virtualdom

2264
01:27:51,000 --> 01:27:52,000
说我自己要做什么

2265
01:27:52,000 --> 01:27:54,000
我能够做什么

2266
01:27:54,000 --> 01:27:55,000
如果我的 state change

2267
01:27:55,000 --> 01:27:57,000
我应该怎么变化

2268
01:27:57,000 --> 01:27:58,000
这个是在 javascrew 的

2269
01:27:58,000 --> 01:27:59,000
definition 里头的

2270
01:27:59,000 --> 01:28:01,000
同样的如果说你现在

2271
01:28:02,000 --> 01:28:04,000
html 出现了一个新的东西

2272
01:28:04,000 --> 01:28:05,000
出现了一个新的 tag

2273
01:28:05,000 --> 01:28:06,000
然后你想用这个 tag

2274
01:28:07,000 --> 01:28:07,000
by the way

2275
01:28:07,000 --> 01:28:08,000
那个 react 还有一些

2276
01:28:09,000 --> 01:28:12,000
svg 所相关的那个 tag

2277
01:28:12,000 --> 01:28:12,000
它没有实现

2278
01:28:12,000 --> 01:28:13,000
如果大家有兴趣的话

2279
01:28:13,000 --> 01:28:14,000
可以去 contribute

2280
01:28:16,000 --> 01:28:17,000
现在要加入这个

2281
01:28:18,000 --> 01:28:21,000
对这些新的原生 tag 实现的话呢

2282
01:28:21,000 --> 01:28:24,000
你也写一个 react 的 component

2283
01:28:24,000 --> 01:28:25,000
来实现它对不对

2284
01:28:26,000 --> 01:28:29,000
所以转换成 react native 的逻辑呢

2285
01:28:29,000 --> 01:28:31,000
如果你有一个原生的

2286
01:28:31,000 --> 01:28:34,000
native 的 component

2287
01:28:34,000 --> 01:28:35,000
你要使用的话

2288
01:28:35,000 --> 01:28:37,000
你只需要在 javascrew 端

2289
01:28:37,000 --> 01:28:40,000
写一个 adapter 来说

2290
01:28:40,000 --> 01:28:41,000
这个东西是个什么东西

2291
01:28:42,000 --> 01:28:43,000
怎么样 initialize 它

2292
01:28:43,000 --> 01:28:46,000
它能够提供什么样的操作

2293
01:28:46,000 --> 01:28:47,000
然后

2294
01:28:48,000 --> 01:28:50,000
react 的那个引擎

2295
01:28:50,000 --> 01:28:53,000
你肯定有一个 proto code 来说

2296
01:28:53,000 --> 01:28:55,000
你要怎么写这个文件在 javascrew

2297
01:28:55,000 --> 01:28:56,000
然后你按照它

2298
01:28:56,000 --> 01:28:58,000
一幅画条把它写出来之后

2299
01:28:58,000 --> 01:29:00,000
你就可以用这个原生组件了

2300
01:29:00,000 --> 01:29:02,000
但我觉得可能无套的问题就是说

2301
01:29:02,000 --> 01:29:03,000
那是

2302
01:29:03,000 --> 01:29:06,000
就是说是 react native 这个 library 提供

2303
01:29:07,000 --> 01:29:08,000
java script 到

2304
01:29:09,000 --> 01:29:11,000
这个 iOS 的那些原生组件

2305
01:29:11,000 --> 01:29:12,000
这是一个桥吗

2306
01:29:12,000 --> 01:29:13,000
还是怎么样

2307
01:29:13,000 --> 01:29:16,000
是 react native 自己本身实现的那个

2308
01:29:16,000 --> 01:29:18,000
那这会不会有这样

2309
01:29:18,000 --> 01:29:20,000
类似于这个叫什么

2310
01:29:20,000 --> 01:29:21,000
titanium 那种同样的问题

2311
01:29:21,000 --> 01:29:22,000
就是说

2312
01:29:22,000 --> 01:29:25,000
你要等这个 react native 这个 library 提供了

2313
01:29:25,000 --> 01:29:27,000
对应的

2314
01:29:27,000 --> 01:29:28,000
这个

2315
01:29:28,000 --> 01:29:31,000
比如说 iOS 的一些原生的组件的

2316
01:29:31,000 --> 01:29:33,000
这个桥了之后你才可以用的

2317
01:29:33,000 --> 01:29:34,000
而不是说

2318
01:29:34,000 --> 01:29:34,000
我自己可以

2319
01:29:34,000 --> 01:29:37,000
比如假设苹果 iOS 9 就出了一些新的原生组件

2320
01:29:37,000 --> 01:29:38,000
那我作为开发者

2321
01:29:38,000 --> 01:29:39,000
我可以自己包一下就可以用

2322
01:29:39,000 --> 01:29:41,000
而不是说要等到

2323
01:29:41,000 --> 01:29:43,000
这个 react native 发布一个新版

2324
01:29:43,000 --> 01:29:44,000
支持说

2325
01:29:44,000 --> 01:29:46,000
就说 expose 那些原生的组件出来

2326
01:29:46,000 --> 01:29:47,000
才可以用呢

2327
01:29:48,000 --> 01:29:52,000
根据在会上 qnA 的答案的话

2328
01:29:52,000 --> 01:29:55,000
我相信是你可以自己来做这个事情的

2329
01:29:55,000 --> 01:29:57,000
就他们做了一个通用的桥

2330
01:29:57,000 --> 01:29:58,000
这个非常好

2331
01:29:58,000 --> 01:29:59,000
这个就很厉害了

2332
01:29:59,000 --> 01:30:00,000
就不用考虑

2333
01:30:00,000 --> 01:30:03,000
就不会遇到之前 titanium 的问题了

2334
01:30:03,000 --> 01:30:03,000
对

2335
01:30:04,000 --> 01:30:05,000
这个真的不了不得

2336
01:30:05,000 --> 01:30:08,000
我考虑那这样那么 swift 不就挂了

2337
01:30:10,000 --> 01:30:11,000
java script 多简单

2338
01:30:12,000 --> 01:30:15,000
你知道技术的发展组织有很多不确定性的

2339
01:30:16,000 --> 01:30:18,000
所以大家不要把鸡蛋放在同一个栏子里头

2340
01:30:19,000 --> 01:30:20,000
这是没错

2341
01:30:20,000 --> 01:30:22,000
还好我已经不做前端了

2342
01:30:23,000 --> 01:30:24,000
不这也是一个问题

2343
01:30:24,000 --> 01:30:26,000
前端这是变化好快

2344
01:30:26,000 --> 01:30:27,000
对

2345
01:30:27,000 --> 01:30:29,000
其实这也是我在提高里面写的

2346
01:30:29,000 --> 01:30:29,000
就是

2347
01:30:30,000 --> 01:30:33,000
我觉得现在前端真的是没有人知道峰会往里面吹

2348
01:30:34,000 --> 01:30:34,000
就是什么

2349
01:30:34,000 --> 01:30:36,000
三天一小遍七天一大遍

2350
01:30:36,000 --> 01:30:37,000
对

2351
01:30:37,000 --> 01:30:41,000
就是 frontend technology 可能你这个网站你所用的东西

2352
01:30:41,000 --> 01:30:45,000
跟另外一个网站所用的东西 completely different

2353
01:30:45,000 --> 01:30:47,000
没有任何一点点交集

2354
01:30:47,000 --> 01:30:51,000
然后两个人都觉得自己做的才是前途

2355
01:30:51,000 --> 01:30:54,000
或者反观两个人都觉得对方做的才是正确的

2356
01:30:54,000 --> 01:30:57,000
这个是非常让人疑惑的一件事情

2357
01:30:57,000 --> 01:30:57,000
其实

2358
01:30:57,000 --> 01:30:59,000
你这个都是高端了

2359
01:30:59,000 --> 01:31:01,000
你想遇到那种比较低端的那些说

2360
01:31:01,000 --> 01:31:02,000
哼我们不是都用 jQuery 吗

2361
01:31:02,000 --> 01:31:03,000
对

2362
01:31:05,000 --> 01:31:08,000
你知道就是所谓最好的时代也是最坏的时代

2363
01:31:08,000 --> 01:31:09,000
对

2364
01:31:09,000 --> 01:31:11,000
你看看你自己说出的位置是怎么样

2365
01:31:11,000 --> 01:31:19,000
我觉得这也可能就是前端技术比较让人有兴趣的一部分

2366
01:31:19,000 --> 01:31:22,000
就你总是可以看到一些新的

2367
01:31:22,000 --> 01:31:24,000
然后看到一些有趣的东西

2368
01:31:24,000 --> 01:31:25,000
看到年轻人的活力

2369
01:31:25,000 --> 01:31:27,000
对

2370
01:31:27,000 --> 01:31:29,000
这从一定程度上来讲的话

2371
01:31:29,000 --> 01:31:30,000
它也是

2372
01:31:30,000 --> 01:31:33,000
就是技术也有很固定的时候

2373
01:31:33,000 --> 01:31:34,000
比方说

2374
01:31:34,000 --> 01:31:36,000
算是阶段性发展

2375
01:31:36,000 --> 01:31:36,000
你知道

2376
01:31:36,000 --> 01:31:37,000
就 jQuery

2377
01:31:37,000 --> 01:31:39,000
有 jQuery 的一段时间

2378
01:31:39,000 --> 01:31:40,000
大家都用 jQuery

2379
01:31:40,000 --> 01:31:41,000
然后 back home 的一段时间

2380
01:31:41,000 --> 01:31:42,000
大家都用 back home

2381
01:31:42,000 --> 01:31:43,000
然后我觉得我们可能

2382
01:31:43,000 --> 01:31:44,000
之所以这么

2383
01:31:44,000 --> 01:31:45,000
就是现在那么精彩

2384
01:31:45,000 --> 01:31:47,000
是因为我们在进入一个新的阶段

2385
01:31:47,000 --> 01:31:49,000
嗯

2386
01:31:49,000 --> 01:31:51,000
从我的角度来说话

2387
01:31:51,000 --> 01:31:53,000
我觉得 react 是最 promise 的一个 solution

2388
01:31:53,000 --> 01:31:55,000
因为 Angler can shoot himself in the food

2389
01:31:55,000 --> 01:31:55,000
对对对

2390
01:31:55,000 --> 01:31:56,000
你看

2391
01:31:56,000 --> 01:31:56,000
哈哈

2392
01:31:56,000 --> 01:31:58,000
没办法

2393
01:31:58,000 --> 01:31:59,000
这个对

2394
01:31:59,000 --> 01:32:00,000
呃

2395
01:32:00,000 --> 01:32:01,000
太复杂了他们

2396
01:32:01,000 --> 01:32:02,000
所以啊

2397
01:32:02,000 --> 01:32:05,000
而且他那个 2.0 跟 1.0 又不匹配

2398
01:32:05,000 --> 01:32:08,000
然后 2.0 又在又需要那么长时间来开发

2399
01:32:08,000 --> 01:32:08,000
所以

2400
01:32:08,000 --> 01:32:09,000
所以 Angler 有点

2401
01:32:09,000 --> 01:32:10,000
就是

2402
01:32:10,000 --> 01:32:12,000
就是自身的那个

2403
01:32:12,000 --> 01:32:13,000
即将做死

2404
01:32:13,000 --> 01:32:13,000
哈哈哈

2405
01:32:13,000 --> 01:32:15,000
真的真的有点这个意思啊

2406
01:32:15,000 --> 01:32:16,000
哈哈哈

2407
01:32:16,000 --> 01:32:18,000
所以 react 啊

2408
01:32:18,000 --> 01:32:20,000
很可能就是下一个阶段的一个

2409
01:32:20,000 --> 01:32:21,000
一个主意了

2410
01:32:21,000 --> 01:32:21,000
啊

2411
01:32:21,000 --> 01:32:22,000
嗯哼

2412
01:32:22,000 --> 01:32:24,000
不管你对

2413
01:32:24,000 --> 01:32:25,000
啊

2414
01:32:25,000 --> 01:32:26,000
react 自己本身什么

2415
01:32:26,000 --> 01:32:27,000
怎么想

2416
01:32:27,000 --> 01:32:28,000
就是做一个前段开发者的话

2417
01:32:28,000 --> 01:32:29,000
真的应该去了解他

2418
01:32:29,000 --> 01:32:30,000
ok

2419
01:32:30,000 --> 01:32:31,000
至少知道他为什么好

2420
01:32:31,000 --> 01:32:33,000
嗯或者他哪里好

2421
01:32:33,000 --> 01:32:34,000
嗯

2422
01:32:36,000 --> 01:32:39,000
而且从公司的支持来说的话

2423
01:32:39,000 --> 01:32:43,000
facebook 对 react 支持是非常非常强烈的

2424
01:32:43,000 --> 01:32:43,000
啊

2425
01:32:43,000 --> 01:32:45,000
你可以看到他

2426
01:32:45,000 --> 01:32:46,000
他从

2427
01:32:46,000 --> 01:32:47,000
他最初是

2428
01:32:47,000 --> 01:32:49,000
最初最初的模型是那个 facebook age group

2429
01:32:49,000 --> 01:32:49,000
啊

2430
01:32:49,000 --> 01:32:50,000
就是 adge group

2431
01:32:50,000 --> 01:32:51,000
来啊

2432
01:32:51,000 --> 01:32:52,000
做出来了

2433
01:32:52,000 --> 01:32:53,000
然后现在

2434
01:32:53,000 --> 01:32:53,000
后来到 chat

2435
01:32:53,000 --> 01:32:54,000
到

2436
01:32:54,000 --> 01:32:55,000
大部分的前段

2437
01:32:55,000 --> 01:32:58,000
他们所现在写的都是 adapt 这个 react

2438
01:32:58,000 --> 01:32:59,000
到你知道 group

2439
01:32:59,000 --> 01:33:00,000
现在又用那个

2440
01:33:00,000 --> 01:33:01,000
react native 写

2441
01:33:01,000 --> 01:33:04,000
所以 react 背后有非常多 facebook 的支持

2442
01:33:04,000 --> 01:33:07,000
反过来 Angler 反倒是在 google 里头

2443
01:33:07,000 --> 01:33:07,000
啊

2444
01:33:07,000 --> 01:33:08,000
他自己都不怎么用吗

2445
01:33:08,000 --> 01:33:11,000
对我们并不知道特别多的 Angler 所写的应用

2446
01:33:11,000 --> 01:33:13,000
那个 inbox 倒是倒是一个

2447
01:33:13,000 --> 01:33:15,000
倒是一个 Angler 的

2448
01:33:15,000 --> 01:33:16,000
Ali 对不对

2449
01:33:16,000 --> 01:33:17,000
inbox

2450
01:33:17,000 --> 01:33:18,000
inbox 不是

2451
01:33:18,000 --> 01:33:18,000
啊

2452
01:33:18,000 --> 01:33:19,000
上次

2453
01:33:19,000 --> 01:33:20,000
上次没有说是

2454
01:33:22,000 --> 01:33:23,000
GdoC 写的

2455
01:33:23,000 --> 01:33:25,000
然后我中东的破算是一个谣言

2456
01:33:25,000 --> 01:33:25,000
对

2457
01:33:25,000 --> 01:33:26,000
他他是这样

2458
01:33:26,000 --> 01:33:27,000
他就他是两部分

2459
01:33:27,000 --> 01:33:29,000
他的前端那部分不知道没有说

2460
01:33:29,000 --> 01:33:31,000
但是后就是那个业务逻辑那边

2461
01:33:31,000 --> 01:33:32,000
他是加把转过去了

2462
01:33:32,000 --> 01:33:32,000
对

2463
01:33:32,000 --> 01:33:33,000
ok

2464
01:33:33,000 --> 01:33:33,000
ok

2465
01:33:33,000 --> 01:33:34,000
就足以

2466
01:33:34,000 --> 01:33:35,000
我现在我来这边

2467
01:33:35,000 --> 01:33:37,000
像你不写的

2468
01:33:37,000 --> 01:33:37,000
ok

2469
01:33:37,000 --> 01:33:37,000
对

2470
01:33:37,000 --> 01:33:41,000
就很有可能就是他这个 inbox 的这个网页版的前端

2471
01:33:41,000 --> 01:33:43,000
可能是用这个 Angler.js 写的

2472
01:33:43,000 --> 01:33:43,000
对

2473
01:33:43,000 --> 01:33:44,000
对

2474
01:33:44,000 --> 01:33:46,000
还有他或许有很多 internal tool

2475
01:33:46,000 --> 01:33:47,000
用 Angler 的

2476
01:33:47,000 --> 01:33:48,000
但是我们并没有看到很值

2477
01:33:48,000 --> 01:33:49,000
很多直接的支持

2478
01:33:49,000 --> 01:33:53,000
我觉得这一点上对于那个技术本身的发展是

2479
01:33:53,000 --> 01:33:54,000
啊

2480
01:33:54,000 --> 01:33:55,000
不是很不是特别好

2481
01:33:55,000 --> 01:33:57,000
因为没有干跌支持

2482
01:33:57,000 --> 01:33:58,000
对

2483
01:33:58,000 --> 01:33:58,000
对

2484
01:33:58,000 --> 01:34:00,000
哈哈哈

2485
01:34:00,000 --> 01:34:02,000
这个是个很大的问题

2486
01:34:02,000 --> 01:34:03,000
嗯

2487
01:34:03,000 --> 01:34:03,000
我们来看

2488
01:34:03,000 --> 01:34:05,000
看看选技术

2489
01:34:05,000 --> 01:34:06,000
技术选型的时候要先看跌嘛

2490
01:34:06,000 --> 01:34:07,000
对吧

2491
01:34:07,000 --> 01:34:08,000
你看我选了 Go

2492
01:34:08,000 --> 01:34:09,000
哈哈哈

2493
01:34:09,000 --> 01:34:09,000
选了 Go

2494
01:34:09,000 --> 01:34:10,000
哈哈哈

2495
01:34:11,000 --> 01:34:11,000
啊

2496
01:34:11,000 --> 01:34:13,000
那我们接下来说一下那个 relay 吧

2497
01:34:13,000 --> 01:34:16,000
这个还是要留在下期还是怎么样

2498
01:34:16,000 --> 01:34:17,000
还是一次过吧

2499
01:34:17,000 --> 01:34:18,000
讲完好了

2500
01:34:18,000 --> 01:34:19,000
啊

2501
01:34:19,000 --> 01:34:22,000
他们这次这个 react 大会议上面出

2502
01:34:22,000 --> 01:34:25,000
除了发布这个令人激动人心什么

2503
01:34:25,000 --> 01:34:29,000
令这个 web app 可以秒杀这个 iOS

2504
01:34:29,000 --> 01:34:30,000
或者是安定

2505
01:34:30,000 --> 01:34:31,000
地板的 by

2506
01:34:31,000 --> 01:34:32,000
就直接直接就秒

2507
01:34:32,000 --> 01:34:34,000
秒适了的这么一个

2508
01:34:34,000 --> 01:34:35,000
什么

2509
01:34:35,000 --> 01:34:35,000
对

2510
01:34:35,000 --> 01:34:36,000
ground breaking 的技术之外

2511
01:34:36,000 --> 01:34:37,000
还发布了一个

2512
01:34:37,000 --> 01:34:39,000
其实作为一个前端开发

2513
01:34:39,000 --> 01:34:41,000
半个前端开发久的我来讲

2514
01:34:41,000 --> 01:34:43,000
这个还是非常利用的

2515
01:34:43,000 --> 01:34:43,000
滴动的

2516
01:34:43,000 --> 01:34:46,000
要做一个 relay 的这么一个技术啊

2517
01:34:46,000 --> 01:34:48,000
这个事情跟之前讲的那个 flux

2518
01:34:48,000 --> 01:34:50,000
是有或多或少的关系的

2519
01:34:50,000 --> 01:34:53,000
因为他们在去年发布那个 flux 架构的时候

2520
01:34:53,000 --> 01:34:54,000
并没有说

2521
01:34:54,000 --> 01:34:55,000
因为 flux 它只是一个 idea

2522
01:34:55,000 --> 01:34:56,000
刚才我也讲了

2523
01:34:56,000 --> 01:34:58,000
它并没有说告诉你一些

2524
01:34:58,000 --> 01:35:00,000
具体的执行的措施是怎么样子的

2525
01:35:00,000 --> 01:35:02,000
然后其中有一个很

2526
01:35:02,000 --> 01:35:03,000
一个就是任何一个 by-by-by

2527
01:35:03,000 --> 01:35:05,000
比较都逃不掉的问题

2528
01:35:05,000 --> 01:35:07,000
就是你怎么去从服务端获取数据

2529
01:35:07,000 --> 01:35:08,000
对

2530
01:35:09,000 --> 01:35:10,000
然后在传统的方式下

2531
01:35:10,000 --> 01:35:12,000
可能最简单的

2532
01:35:12,000 --> 01:35:13,000
我就用 jQuery 写一个

2533
01:35:13,000 --> 01:35:16,000
或者是用 xmlhttp request

2534
01:35:16,000 --> 01:35:17,000
发一个请求

2535
01:35:17,000 --> 01:35:19,000
然后来用什么一个 callback

2536
01:35:19,000 --> 01:35:20,000
就更新了一下 dome

2537
01:35:20,000 --> 01:35:22,000
这可能是最原始的一个

2538
01:35:22,000 --> 01:35:24,000
从服务端取数据

2539
01:35:24,000 --> 01:35:26,000
然后在一个 webapp 里面展示的方法

2540
01:35:26,000 --> 01:35:27,000
但是到了一定成绩之后

2541
01:35:27,000 --> 01:35:28,000
这种方式

2542
01:35:28,000 --> 01:35:29,000
就是完全是不可以管理的

2543
01:35:29,000 --> 01:35:30,000
有很多

2544
01:35:30,000 --> 01:35:32,000
其实关稿的问题要解决

2545
01:35:32,000 --> 01:35:32,000
对

2546
01:35:33,000 --> 01:35:35,000
然后他们这次发布的 relay

2547
01:35:35,000 --> 01:35:37,000
其实就是要解决这么一个问题

2548
01:35:39,000 --> 01:35:39,000
我不知道

2549
01:35:39,000 --> 01:35:41,000
为了你们在之前的时候

2550
01:35:41,000 --> 01:35:42,000
是怎么去做

2551
01:35:42,000 --> 01:35:44,000
从服务端获取数据这么一个过程的

2552
01:35:46,000 --> 01:35:48,000
因为我们之前都是在用

2553
01:35:48,000 --> 01:35:52,000
那个传统意义上的 MVC 的 model

2554
01:35:52,000 --> 01:35:55,000
我们并没有使用 storage 的概念

2555
01:35:55,000 --> 01:35:57,000
但是我觉得 storage 的概念

2556
01:35:57,000 --> 01:36:00,000
可能跟 model 是可以 mapped 的

2557
01:36:00,000 --> 01:36:02,000
所以然后我们的后台是一个

2558
01:36:02,000 --> 01:36:03,000
restful API

2559
01:36:03,000 --> 01:36:06,000
在前端我们有 model

2560
01:36:06,000 --> 01:36:07,000
然后这个 model

2561
01:36:07,000 --> 01:36:10,000
它可以去跟后台去 sync

2562
01:36:10,000 --> 01:36:12,000
然后这个 sync 是一个

2563
01:36:12,000 --> 01:36:15,000
restful 的 HTB request

2564
01:36:15,000 --> 01:36:19,000
然后 server 会把你所需要获取的信息给发送回来

2565
01:36:19,000 --> 01:36:23,000
然后这样 model 就得到了所有需要的信息

2566
01:36:24,000 --> 01:36:25,000
那么这里就有一个问题

2567
01:36:25,000 --> 01:36:27,000
就说刚刚我们那个

2568
01:36:27,000 --> 01:36:29,000
可能要介入这么一个新的一个概念

2569
01:36:29,000 --> 01:36:32,000
也不叫现在如果你说前端开发

2570
01:36:32,000 --> 01:36:34,000
肯定会遇到 rest 这么一个 API

2571
01:36:34,000 --> 01:36:35,000
那什么意思呢

2572
01:36:35,000 --> 01:36:36,000
就是说它起码它就说

2573
01:36:36,000 --> 01:36:39,000
把我把后台我能够提供的所有的资源

2574
01:36:39,000 --> 01:36:40,000
一个 resource

2575
01:36:40,000 --> 01:36:42,000
通过一个 URL 的这么一个节点

2576
01:36:42,000 --> 01:36:43,000
暴露出来

2577
01:36:43,000 --> 01:36:44,000
然后你通过像什么标准的

2578
01:36:44,000 --> 01:36:48,000
什么什么 put delete post get 的这些方法

2579
01:36:48,000 --> 01:36:50,000
去获取这些资源

2580
01:36:50,000 --> 01:36:52,000
但是这有一个问题就是说

2581
01:36:52,000 --> 01:36:54,000
我不知道你们那边是不是怎么样子

2582
01:36:54,000 --> 01:36:57,000
就是我看到的大部分的 rest API

2583
01:36:57,000 --> 01:36:58,000
就有一个共同的问题

2584
01:36:58,000 --> 01:37:00,000
就是它有太多的这个所谓 endpoint

2585
01:37:00,000 --> 01:37:00,000
太多的节点

2586
01:37:00,000 --> 01:37:02,000
因为每一个资源就要对应一个节点

2587
01:37:02,000 --> 01:37:03,000
没错

2588
01:37:03,000 --> 01:37:05,000
然后如果为了你讲的那种情况

2589
01:37:05,000 --> 01:37:07,000
如果我理解来没有错的话

2590
01:37:07,000 --> 01:37:08,000
你们也设计说

2591
01:37:08,000 --> 01:37:10,000
每一个 model 应该是对应一个 resource

2592
01:37:10,000 --> 01:37:11,000
一个资源

2593
01:37:11,000 --> 01:37:13,000
然后每个 model 去负责去

2594
01:37:13,000 --> 01:37:17,000
那个资源对应的 rest 的节点

2595
01:37:17,000 --> 01:37:19,000
去访问它对吧

2596
01:37:19,000 --> 01:37:21,000
但这样我觉得其实这样管理和编写起来

2597
01:37:21,000 --> 01:37:22,000
都不是很方便

2598
01:37:22,000 --> 01:37:24,000
而且在使用起来我觉得有很多问题

2599
01:37:24,000 --> 01:37:26,000
就是我先讲讲我的体验

2600
01:37:26,000 --> 01:37:27,000
怎么样子感觉

2601
01:37:27,000 --> 01:37:29,000
就说一个刚讲节点太多

2602
01:37:29,000 --> 01:37:31,000
你要为每一个资源增加一个节点

2603
01:37:31,000 --> 01:37:33,000
然后你要考虑每一个资源

2604
01:37:33,000 --> 01:37:34,000
它能够支持的这些

2605
01:37:34,000 --> 01:37:35,000
所谓的这些动词

2606
01:37:35,000 --> 01:37:36,000
vib

2607
01:37:36,000 --> 01:37:39,000
它对应的一些所谓的这个语异是什么

2608
01:37:39,000 --> 01:37:40,000
比如说我有一个 user

2609
01:37:40,000 --> 01:37:43,000
如果我 put 的 user 是一个什么意思对吧

2610
01:37:43,000 --> 01:37:44,000
然后我 post user 又是一个什么意思

2611
01:37:44,000 --> 01:37:46,000
然后 delete 当然可能更好理解一点

2612
01:37:46,000 --> 01:37:48,000
但是因为会牵涉到资源的种类

2613
01:37:48,000 --> 01:37:49,000
又不一样

2614
01:37:49,000 --> 01:37:50,000
有所谓的什么 collection

2615
01:37:50,000 --> 01:37:52,000
然后有所谓的 individual

2616
01:37:52,000 --> 01:37:53,000
这种 resource

2617
01:37:53,000 --> 01:37:56,000
其实很多事情还是不是那么清晰的

2618
01:37:56,000 --> 01:37:58,000
而且 rest 的本身的定义

2619
01:37:58,000 --> 01:38:00,000
就是很多有不同的理解

2620
01:38:00,000 --> 01:38:02,000
虽然最开始那篇博士论文里面

2621
01:38:02,000 --> 01:38:04,000
有把这个概念产出得很详细

2622
01:38:04,000 --> 01:38:06,000
但是我可以确信

2623
01:38:06,000 --> 01:38:07,000
绝大部分做 rest 的人

2624
01:38:07,000 --> 01:38:09,000
都是没有看过那篇博士论文的

2625
01:38:11,000 --> 01:38:13,000
然后 rest 我觉得还有一个问题

2626
01:38:13,000 --> 01:38:16,000
就是说它的这个就约束太多了

2627
01:38:16,000 --> 01:38:17,000
首先一个就是说

2628
01:38:17,000 --> 01:38:20,000
假设你要暴露出来一个 user

2629
01:38:20,000 --> 01:38:21,000
这么一个节点

2630
01:38:21,000 --> 01:38:22,000
这么一个资源

2631
01:38:22,000 --> 01:38:26,000
可能代表是一某一个账号提系的一个用户对吧

2632
01:38:26,000 --> 01:38:30,000
它返回给你的数据肯定是固定结构的

2633
01:38:30,000 --> 01:38:31,000
就是你取一个 user

2634
01:38:31,000 --> 01:38:32,000
你都取到它所有的信息

2635
01:38:32,000 --> 01:38:34,000
比如说你要取它的用户名

2636
01:38:34,000 --> 01:38:35,000
email

2637
01:38:35,000 --> 01:38:38,000
它还会把所有的详细的信息都返给你

2638
01:38:38,000 --> 01:38:40,000
哪怕你只是需要用它的所谓的一个用户名

2639
01:38:40,000 --> 01:38:43,000
来显示出一个或者一个头像

2640
01:38:43,000 --> 01:38:46,000
显示出一个所谓的头像框而已对吧

2641
01:38:46,000 --> 01:38:46,000
对

2642
01:38:46,000 --> 01:38:49,000
你没有它对于它的更为精细的控制

2643
01:38:49,000 --> 01:38:49,000
对

2644
01:38:49,000 --> 01:38:51,000
对每一个资源来讲

2645
01:38:51,000 --> 01:38:52,000
你比较难去说

2646
01:38:52,000 --> 01:38:55,000
你在做一些更精细的要求

2647
01:38:55,000 --> 01:38:59,000
而且它所谓的可组和信息也比较低

2648
01:38:59,000 --> 01:39:02,000
比如说就是举个最简单的例子

2649
01:39:02,000 --> 01:39:04,000
我有一个 user 这么一个节点

2650
01:39:04,000 --> 01:39:05,000
然后我有一个像一个 post

2651
01:39:05,000 --> 01:39:08,000
一个文章或者帖子这么一个节点

2652
01:39:08,000 --> 01:39:13,000
我想在取到说这个用户发布的那个文章的时候

2653
01:39:13,000 --> 01:39:14,000
你会牵手一个很麻烦的问题

2654
01:39:14,000 --> 01:39:17,000
就是说你把这个对应的倾存

2655
01:39:17,000 --> 01:39:20,000
它显然不是完全归属于用户那个节点

2656
01:39:20,000 --> 01:39:23,000
它也不是完全归属于 post 那个节点对吧

2657
01:39:23,000 --> 01:39:26,000
就有一些这种很不正交的东西出现在里面

2658
01:39:26,000 --> 01:39:29,000
而且你会办法很方便的在同一个请求里面

2659
01:39:29,000 --> 01:39:31,000
去同时取这两个不同的东西

2660
01:39:31,000 --> 01:39:34,000
就他们的可组和信我觉得是比较低的

2661
01:39:34,000 --> 01:39:35,000
对

2662
01:39:35,000 --> 01:39:38,000
然后最后一个就是说我实际就用到体验中

2663
01:39:38,000 --> 01:39:42,000
就是因为大部分的 rest API 是通过 HGTP 的这种方法去访问的

2664
01:39:42,000 --> 01:39:46,000
然后我们现在用的 HGTP 所谓的 1.0 1.1 这个版本

2665
01:39:46,000 --> 01:39:51,000
有一个问题就是说它有一个很严酷的 request response

2666
01:39:51,000 --> 01:39:54,000
请求答复这么一个流程

2667
01:39:54,000 --> 01:39:56,000
你不可能说我发 5 个请求出去

2668
01:39:56,000 --> 01:39:58,000
然后等 5 个回复出来对吧

2669
01:39:58,000 --> 01:40:01,000
这种有一个效率的问题

2670
01:40:01,000 --> 01:40:03,000
那么很多人就为了解决这个效率问题

2671
01:40:03,000 --> 01:40:05,000
他要去考虑说我把这个请求所谓打包

2672
01:40:05,000 --> 01:40:07,000
就是 batchin 嘛

2673
01:40:07,000 --> 01:40:11,000
比如我要请求 5 个用户或者说请求 5 个用户三个文章

2674
01:40:11,000 --> 01:40:12,000
我要把这几个请求包在一起

2675
01:40:12,000 --> 01:40:13,000
然后发一个请求过去

2676
01:40:13,000 --> 01:40:16,000
这个时候你用 rest API 的话就不是非常好做了

2677
01:40:16,000 --> 01:40:17,000
对

2678
01:40:17,000 --> 01:40:20,000
所以总体来讲我觉得 rest 在

2679
01:40:20,000 --> 01:40:21,000
它的逻辑是很好的

2680
01:40:21,000 --> 01:40:23,000
就是说整个概念是非常方便

2681
01:40:23,000 --> 01:40:28,000
但是我觉得它始终是一个更适用于那种所谓面向文档的

2682
01:40:28,000 --> 01:40:30,000
那种类型的应用是比较好的

2683
01:40:30,000 --> 01:40:33,000
但是在我们目前在做的很多这种面向

2684
01:40:33,000 --> 01:40:35,000
一些什么社交网络也好

2685
01:40:35,000 --> 01:40:37,000
还有其他一些更新型态的应用的时候

2686
01:40:37,000 --> 01:40:41,000
用 rest 的这种 API 其实我觉得并不是一个特别好的选择

2687
01:40:42,000 --> 01:40:43,000
我吃饱了就这样

2688
01:40:43,000 --> 01:40:49,000
我觉得我们所看到 relate 的确在解决另外一 set 的 problem

2689
01:40:49,000 --> 01:40:56,000
但是而且是非常有意义的一个解决方案

2690
01:40:56,000 --> 01:41:04,000
还有我总归是觉得 relate 它的意义更在于是

2691
01:41:04,000 --> 01:41:08,000
帮助像 facebook 这样大型的公司来管理它的复杂度

2692
01:41:08,000 --> 01:41:13,000
因为只有上那个规模上你才会在意那么小级别

2693
01:41:13,000 --> 01:41:19,000
就是说到底是哪个 view 得到哪个 field 来介绍带宽的需求

2694
01:41:19,000 --> 01:41:24,000
然后同时有更好的封装和保护不同的数据

2695
01:41:24,000 --> 01:41:26,000
就是非常有意义的事情

2696
01:41:26,000 --> 01:41:28,000
但是我觉得还是跟那个规模是相关的

2697
01:41:28,000 --> 01:41:32,000
这小公司其实是不需要这种复杂的需求的吗

2698
01:41:32,000 --> 01:41:36,000
对 从很大程度来说我觉得是这样子

2699
01:41:36,000 --> 01:41:44,000
但是 again 这也是一个你所要解决的问题所 available 的方案是有相关的

2700
01:41:44,000 --> 01:41:46,000
而且从一定程度上来讲

2701
01:41:46,000 --> 01:41:52,000
如果你在 restful API 的基础上加上一些控制的辩量

2702
01:41:52,000 --> 01:41:58,000
比如说 facebook 自己本身的 graph API 有一个叫 fields 的概念

2703
01:41:58,000 --> 01:42:06,000
就是 fields 会帮助你控制它所返回的 attributes 到底是哪些 fields

2704
01:42:06,000 --> 01:42:10,000
这种 relate 中的一些概念是非常相似的

2705
01:42:10,000 --> 01:42:11,000
非常 map 的

2706
01:42:11,000 --> 01:42:15,000
我也可以预见在 relate 真正的发布的时候

2707
01:42:15,000 --> 01:42:20,000
会有人给传统的 restful API 写一些 adapter

2708
01:42:20,000 --> 01:42:26,000
然后从而到传统的 restful API 也支持 relate 实现方式

2709
01:42:26,000 --> 01:42:28,000
刚好昨天那个

2710
01:42:28,000 --> 01:42:29,000
因为 relation 还没有

2711
01:42:29,000 --> 01:42:31,000
它只是发布了这个概念

2712
01:42:31,000 --> 01:42:33,000
它并没有公布它后面的一些产品

2713
01:42:33,000 --> 01:42:35,000
然后昨天在 Hackern News 上面

2714
01:42:35,000 --> 01:42:38,000
facebook 他们有一个叫做 Winscent

2715
01:42:38,000 --> 01:42:39,000
不是 Winscent

2716
01:42:39,000 --> 01:42:40,000
Winscent 这么一个人

2717
01:42:40,000 --> 01:42:44,000
他不是在 github 上写了一个 relate FAQ 吗

2718
01:42:44,000 --> 01:42:45,000
常见问题解答

2719
01:42:45,000 --> 01:42:48,000
然后他上面我就问了他们这么一个问题

2720
01:42:48,000 --> 01:42:52,000
就是说 relate 依赖一个核心的组建就是什么 graphql

2721
01:42:52,000 --> 01:42:55,000
就是图查询语言

2722
01:42:55,000 --> 01:42:59,000
这个是跟 facebook 他们后台有一个叫 TAL 图数据库

2723
01:42:59,000 --> 01:43:01,000
紧密相关的

2724
01:43:01,000 --> 01:43:01,000
但我不太清楚

2725
01:43:01,000 --> 01:43:05,000
就是说对于一个第三方作为一个 facebook 以外的人

2726
01:43:05,000 --> 01:43:08,000
或者是中小开发者或中小网站

2727
01:43:08,000 --> 01:43:12,000
你没有一个基于这么一个图的结构的后台的话

2728
01:43:13,000 --> 01:43:18,000
你怎么去适应这种 graphql 的要求去做到 relate 这种效果

2729
01:43:18,000 --> 01:43:20,000
就还是很大的一个疑惑

2730
01:43:20,000 --> 01:43:21,000
OK

2731
01:43:21,000 --> 01:43:22,000
这是一个机会

2732
01:43:22,000 --> 01:43:23,000
就是一个控白

2733
01:43:23,000 --> 01:43:25,000
市场现在是控白的

2734
01:43:25,000 --> 01:43:25,000
对不对

2735
01:43:25,000 --> 01:43:35,000
然后如果我们有听众想要借此机会来写一个什么 open source library

2736
01:43:35,000 --> 01:43:36,000
或者是甚至去开个动作

2737
01:43:36,000 --> 01:43:38,000
我觉得这个机会是有可能存在的

2738
01:43:39,000 --> 01:43:49,000
你要知道 graphql 它最终即使是 open source

2739
01:43:49,000 --> 01:43:51,000
不是即使最终它会有 open source

2740
01:43:51,000 --> 01:43:52,000
但是我们需要等一段时间

2741
01:43:52,000 --> 01:43:57,000
它的 open source 之后它也更多的是作为一个 protocode 的存在

2742
01:43:57,000 --> 01:43:58,000
就像 flux

2743
01:43:58,000 --> 01:43:58,000
对

2744
01:43:58,000 --> 01:44:06,000
所以真正实现的是需要用过根据它所用的软件来实现的

2745
01:44:06,000 --> 01:44:06,000
对

2746
01:44:06,000 --> 01:44:08,000
我觉得它有点像 sql

2747
01:44:08,000 --> 01:44:16,000
你可以做一个 graphql database 或者说类 data base 的 graphql server

2748
01:44:16,000 --> 01:44:21,000
然后这个 server 可能会说一种 graphql deluxe

2749
01:44:21,000 --> 01:44:26,000
然后带某种货帘就像 sql 一模一样

2750
01:44:26,000 --> 01:44:26,000
对

2751
01:44:26,000 --> 01:44:27,000
没错

2752
01:44:27,000 --> 01:44:29,000
他们就算 relate 以后发布的时候

2753
01:44:29,000 --> 01:44:32,000
它也只会包含首先第一个是客户端的 graphql 那些组件

2754
01:44:32,000 --> 01:44:37,000
比如说它可以在每一个 react 组件里面声明

2755
01:44:37,000 --> 01:44:40,000
你那个组件需要哪一种类型的数据

2756
01:44:40,000 --> 01:44:46,000
然后它可以通过 relate 的 library 去把这些需求都一次抽出来

2757
01:44:46,000 --> 01:44:49,000
然后往服务端发一个请求就可以解决

2758
01:44:49,000 --> 01:44:52,000
包括它会包进去做好刚才讲的 batchen

2759
01:44:52,000 --> 01:44:54,000
就是请求打包

2760
01:44:54,000 --> 01:44:56,000
包括哪些是可以重用的请求

2761
01:44:56,000 --> 01:44:57,000
就可以不用发送

2762
01:44:57,000 --> 01:45:00,000
包括本地的缓存它都给你解决了

2763
01:45:00,000 --> 01:45:06,000
但是我觉得始终反而就问题在服务端那边也是没有办法的

2764
01:45:06,000 --> 01:45:09,000
因为它最终它只会给你一个 graphql 的那个叫什么

2765
01:45:09,000 --> 01:45:10,000
passer

2766
01:45:10,000 --> 01:45:12,000
它会给你一个语法数

2767
01:45:12,000 --> 01:45:16,000
但你怎么去满足它每一个 graphql 写的这么一个查询

2768
01:45:16,000 --> 01:45:18,000
你还是要挺费脑筋的

2769
01:45:18,000 --> 01:45:25,000
而且我觉得这不是一个小企业或者是个人能够很轻易做得到的事情吧

2770
01:45:25,000 --> 01:45:26,000
对

2771
01:45:26,000 --> 01:45:30,000
我很期待看到有人做一个 risk for API 的 adopter

2772
01:45:30,000 --> 01:45:35,000
因为虽然说他们两者的概念上有区别

2773
01:45:35,000 --> 01:45:41,000
但是实际上最终 graphql 和 risk for 都是访问数据的一个方式

2774
01:45:41,000 --> 01:45:45,000
所以说他们两者之间是有可以 map 的地方的

2775
01:45:45,000 --> 01:45:48,000
所以如果说有人能做一个 adopter

2776
01:45:48,000 --> 01:45:49,000
adopter reals

2777
01:45:49,000 --> 01:45:50,000
real apps

2778
01:45:50,000 --> 01:45:55,000
肯定可以有人做一个 reals,graphql,然后一个 gim

2779
01:45:55,000 --> 01:45:56,000
你把这个加上之后

2780
01:45:56,000 --> 01:46:02,000
它的 risk for API 就可以通过 adopter 来实现 graphql

2781
01:46:02,000 --> 01:46:02,000
我觉得对

2782
01:46:03,000 --> 01:46:05,000
可能在性能上或有些损失

2783
01:46:05,000 --> 01:46:07,000
然后也不是说直接你实际的 graphql

2784
01:46:07,000 --> 01:46:09,000
但是对于推广这个技术

2785
01:46:09,000 --> 01:46:11,000
你应用这个技术是非常好处的

2786
01:46:11,000 --> 01:46:13,000
就作为一个过渡方案

2787
01:46:13,000 --> 01:46:13,000
对

2788
01:46:13,000 --> 01:46:13,000
对

2789
01:46:13,000 --> 01:46:14,000
对

2790
01:46:14,000 --> 01:46:14,000
对

2791
01:46:14,000 --> 01:46:14,000
对

2792
01:46:14,000 --> 01:46:14,000
对

2793
01:46:14,000 --> 01:46:14,000
对

2794
01:46:14,000 --> 01:46:15,000
对

2795
01:46:15,000 --> 01:46:15,000
对

2796
01:46:15,000 --> 01:46:15,000
对了

2797
01:46:15,000 --> 01:46:15,000
对了

2798
01:46:15,000 --> 01:46:16,000
对

2799
01:46:16,000 --> 01:46:17,000
所以我就还是在想

2800
01:46:17,000 --> 01:46:19,000
因为之前在知乎的时候

2801
01:46:19,000 --> 01:46:20,000
我都很大的一部分工作

2802
01:46:20,000 --> 01:46:25,000
就是在琢磨这些无其八糟的有的没的图的结构嘛

2803
01:46:25,000 --> 01:46:28,000
然后其实我后来的一个体验就是说

2804
01:46:28,000 --> 01:46:30,000
其实真的是蛮难的

2805
01:46:30,000 --> 01:46:32,000
就是作为一个普通的团队

2806
01:46:32,000 --> 01:46:34,000
像很多这种所有的 web 运用

2807
01:46:34,000 --> 01:46:37,000
它都是一个什么 mySQL 一个后台

2808
01:46:37,000 --> 01:46:40,000
然后前面加 for a rest 的一个 API 层

2809
01:46:40,000 --> 01:46:42,000
然后再加几个 readest 的这种

2810
01:46:42,000 --> 01:46:43,000
叫什么

2811
01:46:43,000 --> 01:46:45,000
就是缓充层嘛

2812
01:46:45,000 --> 01:46:45,000
然后就可以

2813
01:46:45,000 --> 01:46:48,000
它就可以满足一个中型网站的运用了嘛

2814
01:46:48,000 --> 01:46:53,000
但是你要实现像 graphql 那么灵活多变的查询

2815
01:46:53,000 --> 01:46:57,000
而且要达到那种好用程度

2816
01:46:57,000 --> 01:46:59,000
你真的是要后台要做很多工作

2817
01:46:59,000 --> 01:47:01,000
才能够实现 graph 的结构的

2818
01:47:01,000 --> 01:47:02,000
就 graphql 出现

2819
01:47:02,000 --> 01:47:08,000
让我发现其实这个抽象层级的需求是非常明显的

2820
01:47:08,000 --> 01:47:13,000
但是在 graphql 出现之前好像没有人去讨论它

2821
01:47:13,000 --> 01:47:14,000
是有的

2822
01:47:14,000 --> 01:47:15,000
但是就说因为

2823
01:47:15,000 --> 01:47:16,000
无声无导达

2824
01:47:16,000 --> 01:47:16,000
因为它不是 facebook

2825
01:47:16,000 --> 01:47:18,000
可没有吸引到足够的眼球是吧

2826
01:47:18,000 --> 01:47:20,000
我觉得主要是因为现在的主流

2827
01:47:20,000 --> 01:47:24,000
就是除了像 facebook 这种巨头能够有精力

2828
01:47:24,000 --> 01:47:30,000
或者有资源去把它的后端做成一个这种结构的方式去查询的话

2829
01:47:30,000 --> 01:47:32,000
其他那些中小企业真的是还蛮难

2830
01:47:32,000 --> 01:47:36,000
因为没有一个现成的或者说被像 messico 这种级别

2831
01:47:36,000 --> 01:47:39,000
能被大宗广泛接受有好用的图数据库

2832
01:47:39,000 --> 01:47:43,000
有几个例子像什么 neo 4 j

2833
01:47:43,000 --> 01:47:45,000
什么 oran db 之类的

2834
01:47:45,000 --> 01:47:49,000
但是你可以看到成功案例很少

2835
01:47:49,000 --> 01:47:50,000
你首先一个属于程度

2836
01:47:50,000 --> 01:47:53,000
它的成就程度本身也不够

2837
01:47:53,000 --> 01:47:54,000
然后大家也不太敢用

2838
01:47:54,000 --> 01:47:59,000
然后这样的话就是会反而导致这一块其实在市场上是很弱的

2839
01:47:59,000 --> 01:48:02,000
我倒是希望说这个 relay 或者说 golfql

2840
01:48:02,000 --> 01:48:05,000
这个正式开源出来之后

2841
01:48:05,000 --> 01:48:08,000
大家会意识到这个的好处

2842
01:48:08,000 --> 01:48:12,000
以及对这个包括前端开发的这个难度的降低

2843
01:48:12,000 --> 01:48:15,000
然后包括后端的开发的成本的降低

2844
01:48:15,000 --> 01:48:18,000
然后能够使得大家更多去思考

2845
01:48:18,000 --> 01:48:19,000
那我要不要用一下这种图

2846
01:48:19,000 --> 01:48:23,000
以图为主要结构的这种数据后台

2847
01:48:23,000 --> 01:48:24,000
对

2848
01:48:24,000 --> 01:48:29,000
这算是 facebook 对于整个 tag stack 做出了一个贡献吗

2849
01:48:29,000 --> 01:48:38,000
其实 reall you mentioned a tool to 结构的 database

2850
01:48:38,000 --> 01:48:44,000
其实我正确的问题我并不清楚这个东西

2851
01:48:44,000 --> 01:48:48,000
它那个命名是一个出于一个 branding 的考虑

2852
01:48:48,000 --> 01:48:50,000
还是它真的就是所谓的

2853
01:48:50,000 --> 01:48:52,000
我没有听说过 tool database

2854
01:48:53,000 --> 01:48:54,000
abase 没有听说过

2855
01:48:54,000 --> 01:48:59,000
对这个是一个相对于没有那么大众的应用

2856
01:48:59,000 --> 01:49:02,000
其实图书记过来解释的问题也是蛮简单的

2857
01:49:02,000 --> 01:49:05,000
你可以想象一个普通的一个社交网络

2858
01:49:05,000 --> 01:49:07,000
只有一种类型的节点

2859
01:49:07,000 --> 01:49:08,000
我们就考虑最简单的一个情况

2860
01:49:08,000 --> 01:49:09,000
就我们有用户

2861
01:49:09,000 --> 01:49:11,000
就 user 你和我

2862
01:49:11,000 --> 01:49:12,000
然后无谈我们三个人

2863
01:49:13,000 --> 01:49:14,000
然后图书记过存土什么

2864
01:49:14,000 --> 01:49:16,000
就存土节点

2865
01:49:16,000 --> 01:49:18,000
我们本身节点有些什么样的属性

2866
01:49:18,000 --> 01:49:22,000
比如说我作为一个人 user 这么一个节点

2867
01:49:22,000 --> 01:49:24,000
有什么名字 性别 年龄 出生日期

2868
01:49:25,000 --> 01:49:27,000
之类的一些 attributes 对吧

2869
01:49:27,000 --> 01:49:31,000
这个是跟传统的包括这种

2870
01:49:31,000 --> 01:49:32,000
我们像 mexico 这种

2871
01:49:32,000 --> 01:49:34,000
就是 RDBM Relational Database

2872
01:49:34,000 --> 01:49:35,000
其实没有它大区别的

2873
01:49:36,000 --> 01:49:38,000
无非就是说每一个节点

2874
01:49:38,000 --> 01:49:39,000
对于 relation database

2875
01:49:39,000 --> 01:49:40,000
你们的一个一行

2876
01:49:40,000 --> 01:49:41,000
一个 row

2877
01:49:41,000 --> 01:49:43,000
然后每一个 attribute

2878
01:49:43,000 --> 01:49:48,000
对于对于它的传统的 relation database 的一个 column 对吧

2879
01:49:48,000 --> 01:49:49,000
对

2880
01:49:49,000 --> 01:49:55,000
然后但是一个图书就更加重要的一点

2881
01:49:55,000 --> 01:49:58,000
其实是存土节点之间的关系

2882
01:49:58,000 --> 01:49:59,000
比方好像说我可以说

2883
01:49:59,000 --> 01:50:00,000
我可以 friend 你们两个

2884
01:50:00,000 --> 01:50:02,000
你们可以两个这些互相 friend

2885
01:50:02,000 --> 01:50:07,000
然后你可以和别的人也互相 friend

2886
01:50:07,000 --> 01:50:07,000
这个时候的话

2887
01:50:07,000 --> 01:50:09,000
这个时候它表现出来的结构

2888
01:50:09,000 --> 01:50:12,000
如果我们在传统的一个 relation database

2889
01:50:12,000 --> 01:50:13,000
能够实现会怎么样

2890
01:50:13,000 --> 01:50:14,000
会通过一个

2891
01:50:14,000 --> 01:50:17,000
因为一张表来做一个连接

2892
01:50:18,000 --> 01:50:18,000
对

2893
01:50:18,000 --> 01:50:19,000
另外不要加下来

2894
01:50:19,000 --> 01:50:20,000
叫做关注的

2895
01:50:20,000 --> 01:50:21,000
就会行了

2896
01:50:21,000 --> 01:50:22,000
对不起

2897
01:50:22,000 --> 01:50:25,000
我只是做一个 check 而已

2898
01:50:25,000 --> 01:50:26,000
所以谢谢你的解释

2899
01:50:26,000 --> 01:50:28,000
但是我们还是不忘了

2900
01:50:28,000 --> 01:50:30,000
我觉得这段就不用在那个 podcast

2901
01:50:30,000 --> 01:50:31,000
没事可以可以可以

2902
01:50:31,000 --> 01:50:32,000
可以放进来接着解释完

2903
01:50:32,000 --> 01:50:34,000
很多人不理解

2904
01:50:34,000 --> 01:50:36,000
听众里面可能不是很熟悉这个概念

2905
01:50:36,000 --> 01:50:38,000
因为这个确实在工业中我有用的不多的

2906
01:50:38,000 --> 01:50:39,000
对

2907
01:50:39,000 --> 01:50:40,000
因为对我来讲的话

2908
01:50:40,000 --> 01:50:41,000
我觉得就是说

2909
01:50:41,000 --> 01:50:42,000
Graph Qouts

2910
01:50:42,000 --> 01:50:44,000
所谓 graph 只是一个 branding 而已

2911
01:50:44,000 --> 01:50:47,000
也并不是真正在说

2912
01:50:47,000 --> 01:50:47,000
不它真的是

2913
01:50:47,000 --> 01:50:49,000
就是说 graphql 本身

2914
01:50:49,000 --> 01:50:51,000
它真的是要有这么一种

2915
01:50:51,000 --> 01:50:54,000
对后端实际是有很大要求的

2916
01:50:54,000 --> 01:50:56,000
你才可以做到它那么灵活的查询

2917
01:50:56,000 --> 01:50:58,000
不然的话你可以做

2918
01:50:58,000 --> 01:51:00,000
你可以去用什么叫 adapt 的方式

2919
01:51:00,000 --> 01:51:03,000
去把 graphql 的查询转换成对应的

2920
01:51:03,000 --> 01:51:04,000
rest 的查询

2921
01:51:04,000 --> 01:51:06,000
但是这样的效率非常低

2922
01:51:06,000 --> 01:51:09,000
因为整个你的后台的数据库的组织的结构

2923
01:51:09,000 --> 01:51:13,000
就不是按照一个那种图的查询的方式来查询的

2924
01:51:13,000 --> 01:51:14,000
因为图里面查询的

2925
01:51:14,000 --> 01:51:15,000
最常见的什么

2926
01:51:15,000 --> 01:51:18,000
就是解点便利

2927
01:51:18,000 --> 01:51:19,000
对吧

2928
01:51:19,000 --> 01:51:21,000
这个在你的 RTB

2929
01:51:21,000 --> 01:51:23,000
如果在一个传统 relational database 里面

2930
01:51:23,000 --> 01:51:25,000
这个性能是做死的

2931
01:51:25,000 --> 01:51:25,000
你想一下

2932
01:51:25,000 --> 01:51:29,000
假设你在一个社交网状图里面

2933
01:51:29,000 --> 01:51:32,000
你要从某个解点为中心查询它的好友的话

2934
01:51:32,000 --> 01:51:35,000
你在一个传统的 relational database 里面

2935
01:51:35,000 --> 01:51:37,000
你要去要查好多张表

2936
01:51:38,000 --> 01:51:40,000
你不然你要查三个维度的好友

2937
01:51:40,000 --> 01:51:42,000
就是三度分割的好友的话

2938
01:51:43,000 --> 01:51:45,000
你要用传统 relational database 查询的话

2939
01:51:45,000 --> 01:51:46,000
这是非常困难的

2940
01:51:47,000 --> 01:51:48,000
所以我就在想

2941
01:51:48,000 --> 01:51:53,000
其实现在有这么多的社交场合的应用

2942
01:51:53,000 --> 01:51:55,000
反而是没有一个

2943
01:51:55,000 --> 01:51:58,000
能够很好满足社交查询的

2944
01:51:58,000 --> 01:52:00,000
这么一种数据存储的引擎

2945
01:52:00,000 --> 01:52:02,000
能够大规模的方便的使用

2946
01:52:02,000 --> 01:52:04,000
其实是蛮悲哀的一个现状

2947
01:52:04,000 --> 01:52:05,000
其实也是挺奇怪的

2948
01:52:07,000 --> 01:52:08,000
你一个很难吗

2949
01:52:08,000 --> 01:52:09,000
对 确实挺难的

2950
01:52:10,000 --> 01:52:13,000
就比如说我们传统的作业

2951
01:52:13,000 --> 01:52:15,000
relational database 你性能不够

2952
01:52:15,000 --> 01:52:16,000
你可以做简单多少什么 shorting

2953
01:52:16,000 --> 01:52:17,000
分割嘛

2954
01:52:17,000 --> 01:52:21,000
按照 key 的范围来分割嘛

2955
01:52:21,000 --> 01:52:23,000
但是你怎么去分割一个图呢

2956
01:52:23,000 --> 01:52:24,000
就很难的一件事情

2957
01:52:24,000 --> 01:52:25,000
对

2958
01:52:26,000 --> 01:52:28,000
所以就里面还是有很多这种

2959
01:52:28,000 --> 01:52:30,000
非常 hardcore 的 computer science 的东西

2960
01:52:30,000 --> 01:52:31,000
在里面要解决

2961
01:52:31,000 --> 01:52:34,000
而市面上现有的解决方案

2962
01:52:34,000 --> 01:52:37,000
都给人一种信心不足的感情

2963
01:52:37,000 --> 01:52:39,000
真的

2964
01:52:39,000 --> 01:52:42,000
其实这段我就是蛮担忧的

2965
01:52:42,000 --> 01:52:44,000
就是说如果这个解决不好

2966
01:52:44,000 --> 01:52:45,000
graph care 这种东西

2967
01:52:45,000 --> 01:52:48,000
就真的是只能局限于像 facebook

2968
01:52:48,000 --> 01:52:50,000
像 google 这种庞大的企业

2969
01:52:50,000 --> 01:52:51,000
它能够有资源

2970
01:52:51,000 --> 01:52:53,000
或者能力去实现自己的

2971
01:52:53,000 --> 01:52:55,000
或者维护自己的这么一套

2972
01:52:55,000 --> 01:52:57,000
基于图的或者是以图

2973
01:52:57,000 --> 01:53:00,000
结构为导向的这么一个后台系统

2974
01:53:00,000 --> 01:53:02,000
否则其他人还是只能很

2975
01:53:02,000 --> 01:53:04,000
任何和的继续用着 rest

2976
01:53:07,000 --> 01:53:07,000
对

2977
01:53:07,000 --> 01:53:08,000
那一个什么

2978
01:53:08,000 --> 01:53:09,000
那为了你说一下

2979
01:53:09,000 --> 01:53:10,000
就整个

2980
01:53:10,000 --> 01:53:12,000
就说刚刚讲的 react 相关

2981
01:53:12,000 --> 01:53:14,000
包括你在会上看到一些东西

2982
01:53:14,000 --> 01:53:14,000
对

2983
01:53:14,000 --> 01:53:16,000
你说整个来讲

2984
01:53:16,000 --> 01:53:18,000
你对这个会本身是什么样的一个感受

2985
01:53:21,000 --> 01:53:24,000
这是我所去过的比较好的一个会议之一了

2986
01:53:24,000 --> 01:53:26,000
因为整个的所有的 speech

2987
01:53:26,000 --> 01:53:28,000
就非常的有意义

2988
01:53:28,000 --> 01:53:30,000
非常能觉得从中能够学到东西

2989
01:53:30,000 --> 01:53:34,000
都不是在也都非常有意义

2990
01:53:34,000 --> 01:53:35,000
非常 hardcore science

2991
01:53:35,000 --> 01:53:37,000
我觉得这一点是非常非常难得的

2992
01:53:37,000 --> 01:53:41,000
会议的组织者肯定做了很好的工作

2993
01:53:41,000 --> 01:53:43,000
来选取这些

2994
01:53:44,000 --> 01:53:46,000
这些演讲者和演讲本身

2995
01:53:48,000 --> 01:53:50,000
我们有非常多的 social 的机会

2996
01:53:50,000 --> 01:53:52,000
在其中也遇到了非常非常多人

2997
01:53:52,000 --> 01:53:54,000
react 现在真的是被应用到

2998
01:53:54,000 --> 01:53:55,000
各种各方各面

2999
01:53:55,000 --> 01:54:00,000
很多你想不到的一些 application

3000
01:54:00,000 --> 01:54:01,000
都在使用 react

3001
01:54:01,000 --> 01:54:02,000
或者在 colution

3002
01:54:02,000 --> 01:54:03,000
react

3003
01:54:04,000 --> 01:54:05,000
非常的激动人心的就是

3004
01:54:05,000 --> 01:54:08,000
可能看到这么多实际的应用

3005
01:54:08,000 --> 01:54:12,000
这么多积极主动来参与社区的人

3006
01:54:12,000 --> 01:54:14,000
所以整体来说

3007
01:54:14,000 --> 01:54:18,000
我觉得是一个非常非常好的一个气氛

3008
01:54:19,000 --> 01:54:23,000
大家都非常的对这个 react 的前景都非常乐观

3009
01:54:25,000 --> 01:54:29,000
我也很高兴看到 Facebook 对整个会议的支持

3010
01:54:29,000 --> 01:54:32,000
跟对整个 react 技术的支持

3011
01:54:33,000 --> 01:54:34,000
after all

3012
01:54:34,000 --> 01:54:37,000
我也觉得非常开心能够得到 react

3013
01:54:37,000 --> 01:54:39,000
native 的一个 preview

3014
01:54:39,000 --> 01:54:41,000
我有给我的同事演示

3015
01:54:42,000 --> 01:54:45,000
这对我们做接下来的一些 technology

3016
01:54:45,000 --> 01:54:47,000
选项都是非常帮助的

3017
01:54:47,000 --> 01:54:51,000
所以贵公司也是要出一个 mobile 领域的客户端

3018
01:54:52,000 --> 01:54:55,000
我们一直有 mobile 的客户端

3019
01:54:55,000 --> 01:54:57,000
我们有 iOS 跟 android 的客户端

3020
01:54:57,000 --> 01:55:00,000
然后 well foreseeable future

3021
01:55:00,000 --> 01:55:02,000
肯定不是 react native 对不对

3022
01:55:02,000 --> 01:55:05,000
但是那最于那个技术的选心

3023
01:55:05,000 --> 01:55:06,000
观察这个技术的发展来说的话

3024
01:55:06,000 --> 01:55:10,000
我们肯定现在是把它是摆在一个比较重要的位置

3025
01:55:11,000 --> 01:55:12,000
对对

3026
01:55:13,000 --> 01:55:14,000
OK 那行吧

3027
01:55:14,000 --> 01:55:16,000
今天我们非常高兴

3028
01:55:16,000 --> 01:55:18,000
邀请到 wello 来给我们讨论 react

3029
01:55:18,000 --> 01:55:20,000
保一的一系列相关的东西

3030
01:55:21,000 --> 01:55:24,000
然后那今天的节目就到此为止吧

3031
01:55:24,000 --> 01:55:25,000
谢谢大家

3032
01:55:25,000 --> 01:55:26,000
谢谢大家的收听

3033
01:55:27,000 --> 01:55:28,000
对谢谢大家

3034
01:55:29,000 --> 01:55:30,000
我们下期再见

3035
01:55:31,000 --> 01:55:32,000
我还要念那个吗

3036
01:55:33,000 --> 01:55:33,000
你念吧

3037
01:55:33,000 --> 01:55:36,000
OK 感谢大家收听内核公方

3038
01:55:36,000 --> 01:55:40,000
也欢迎大家收听 ipn 旗下的其他舞蹈 podcast

3039
01:55:40,000 --> 01:55:42,000
包括技术主题节目

3040
01:55:42,000 --> 01:55:45,000
id 公论医疗主题节目太一来了

3041
01:55:45,000 --> 01:55:47,000
美食节目未知道

3042
01:55:47,000 --> 01:55:49,000
以及艺术类节目流行通信

3043
01:55:51,000 --> 01:55:54,000
最后还有不知道是在播什么的无主题节目无次元

3044
01:55:54,000 --> 01:55:54,000
感谢大家的收听

