1
00:00:00,000 --> 00:00:05,000
欢迎收听 ipnpodcast 网络之下的 IT 技术主题娱乐节目内核孔荒

2
00:00:05,000 --> 00:00:08,000
我们号称 Hackor 但是也没有什么干活

3
00:00:08,000 --> 00:00:11,000
想听的人听不想听的人就别听

4
00:00:11,000 --> 00:00:16,000
本节目的网址是 ipn.li-cernopanic

5
00:00:16,000 --> 00:00:20,000
我们推荐大家使用 podcast 客户端订阅节目

6
00:00:20,000 --> 00:00:24,000
想请请访问 ipn.li-faq

7
00:00:24,000 --> 00:00:26,000
欢迎你为本节目捐款

8
00:00:26,000 --> 00:00:31,000
捐款的只是 ipn.li-cernopanic-donate

9
00:00:31,000 --> 00:00:35,000
捐款进入随意只要是能被扒除的证证书就可以

10
00:00:35,000 --> 00:00:37,000
捐款不会给你带来什么

11
00:00:37,000 --> 00:00:39,000
不捐也不会让你失去什么

12
00:00:39,000 --> 00:00:42,000
我们的口号是 hyper ishyper awesome

13
00:00:42,000 --> 00:00:47,000
今天我们特别荣幸好请到一位大兵 Simon 薛蕾

14
00:00:47,000 --> 00:00:49,000
薛蕾给大家介绍一下自己吧

15
00:00:49,000 --> 00:00:50,000
哈喽大家好

16
00:00:50,000 --> 00:00:51,000
我叫 Simon

17
00:00:51,000 --> 00:00:59,000
然后我现在从事的是一项基于容器的一个创业项目

18
00:00:59,000 --> 00:01:01,000
然后目前是处于出创阶段

19
00:01:01,000 --> 00:01:05,000
之前我从事的是主要是内核相关的工作

20
00:01:05,000 --> 00:01:12,000
之前也非常热衷的关注于内核相关的所有创业的相关的项目

21
00:01:12,000 --> 00:01:15,000
然后包括最近特别火的一个容器

22
00:01:15,000 --> 00:01:21,000
所以也加入了这个以容器或者说以 hyper wiser 为主题的一个创业项

23
00:01:21,000 --> 00:01:28,000
非常荣幸的能参加内核恐慌这个节目之前也很关注

24
00:01:28,000 --> 00:01:29,000
非常谦虚

25
00:01:29,000 --> 00:01:33,000
因为那个 Simon 的自我介绍很低调

26
00:01:33,000 --> 00:01:35,000
其实 Simon 之前是在 Song

27
00:01:35,000 --> 00:01:38,000
后来一家卖给 Orco 的公司

28
00:01:38,000 --> 00:01:40,000
也就是 java 的单身地对吧

29
00:01:40,000 --> 00:01:40,000
对

30
00:01:40,000 --> 00:01:47,000
其实说到上其实有更多的人其实只知道是 java

31
00:01:47,000 --> 00:01:48,000
但是除了 java 之外

32
00:01:48,000 --> 00:01:52,000
它有非常多的优秀的项目

33
00:01:52,000 --> 00:01:53,000
比如说 sos

34
00:01:53,000 --> 00:01:55,000
就是 Unius 的一个变种

35
00:01:55,000 --> 00:02:02,000
可能目前很多 Ninus 内核以及 Ninus 分化版本上面的软件

36
00:02:02,000 --> 00:02:05,000
以及内核的模块都是来自于 sos

37
00:02:05,000 --> 00:02:08,000
比如特别著名的 ZFS

38
00:02:08,000 --> 00:02:14,000
当然可能做存储的人都知道 ZFS 它的一个特别强大的功能

39
00:02:14,000 --> 00:02:19,000
以及调试内核的时候所用到的一些工具

40
00:02:19,000 --> 00:02:21,000
比如说 MDB

41
00:02:21,000 --> 00:02:24,000
就是 Ninus 上类似的就是 GDB

42
00:02:24,000 --> 00:02:32,000
然后一种追踪内核的不极限于内核

43
00:02:32,000 --> 00:02:36,000
除内核还有应用程序都可以追踪 Dtrace

44
00:02:36,000 --> 00:02:44,000
就像目前的 SysM Type 以及 Ktype 以及类似这种 Trace 工具

45
00:02:44,000 --> 00:02:49,000
应该说大多数都来自于 Dtrace 的设计概念

46
00:02:49,000 --> 00:02:50,000
非常酷

47
00:02:50,000 --> 00:02:55,000
那个 Sama 你之前在上的话是具体是做哪一块工作呢

48
00:02:55,000 --> 00:02:59,000
我之前在上的时候是北京研发中心

49
00:02:59,000 --> 00:03:04,000
北京研发中心这边主要的一大块是大概一个 20 多人的一个团队

50
00:03:04,000 --> 00:03:10,000
主要是从事的是 SVS 的一个存储协议的一个研发

51
00:03:10,000 --> 00:03:12,000
主要集中在 SGSI 协议

52
00:03:12,000 --> 00:03:13,000
这个可能比较底层吧

53
00:03:13,000 --> 00:03:17,000
可能不多内核的人不太清楚这一块东西

54
00:03:17,000 --> 00:03:22,000
这就是一个现在一个标准的网络存储协议

55
00:03:22,000 --> 00:03:26,000
比如就现在咱们说的硬盘就 SGSI 硬盘

56
00:03:26,000 --> 00:03:30,000
像什么 SATA 硬盘等等等等等等都是走在 SGSI 协议

57
00:03:31,000 --> 00:03:35,000
所以我们其实在这一条线上去做开发

58
00:03:35,000 --> 00:03:40,000
可能也比较偏存储一点也比较偏内核一点

59
00:03:40,000 --> 00:03:46,000
SGSI 当年还是跟 IDE 那些 S 叫 IDE

60
00:03:46,000 --> 00:03:47,000
对对对对

61
00:03:47,000 --> 00:03:48,000
对对应的那个时候

62
00:03:48,000 --> 00:03:54,000
现在后来是发展成了 SATA 对 SAS 的 SAS 两个协议

63
00:03:54,000 --> 00:03:57,000
然后 SGSI 是 SAS 的前身如果我理解没错的话

64
00:03:57,000 --> 00:03:58,000
对是的

65
00:03:58,000 --> 00:03:59,000
OK

66
00:03:59,000 --> 00:04:02,000
所以你之前的主要工作是在做存储协议这一块

67
00:04:02,000 --> 00:04:03,000
对是

68
00:04:03,000 --> 00:04:04,000
所以也是非常一个 hardcore 的人

69
00:04:04,000 --> 00:04:06,000
特别适合我们节目的主题

70
00:04:06,000 --> 00:04:13,000
所以我自开始关注疯狂那个节目的时候

71
00:04:13,000 --> 00:04:16,000
就因为自己从事这个行业

72
00:04:16,000 --> 00:04:19,000
所以也关注这个发现还是挺有意思的

73
00:04:19,000 --> 00:04:23,000
所以说我们节目一直都号称自己非常水

74
00:04:23,000 --> 00:04:26,000
然后这一期终于有一个够硬的干后

75
00:04:26,000 --> 00:04:28,000
也满足大家的要求了

76
00:04:28,000 --> 00:04:29,000
OK

77
00:04:29,000 --> 00:04:33,000
那个三本刚才你提到你现在在做一个跟容器相关的

78
00:04:33,000 --> 00:04:39,000
当然我们节目在之前的某一期里面也提到过这个概念叫做 container

79
00:04:39,000 --> 00:04:39,000
对不对

80
00:04:39,000 --> 00:04:40,000
对对对

81
00:04:40,000 --> 00:04:45,000
然后但是当我毕竟我跟吴涛两个人都属于这个东西的一个叫什么

82
00:04:45,000 --> 00:04:47,000
用户或者是门外汉

83
00:04:47,000 --> 00:04:50,000
但是你其实在做这个相关的开发的

84
00:04:50,000 --> 00:04:54,000
所以本期我们可能会就这个问题进入一些更加深入的探讨

85
00:04:54,000 --> 00:04:54,000
OK

86
00:04:54,000 --> 00:04:58,000
所以你现在做这间公司这个这个这个项目叫什么

87
00:04:58,000 --> 00:05:00,000
其实这个项目就叫 hyper

88
00:05:00,000 --> 00:05:04,000
然后 hyper 这个我们的这个公司叫 hyper HQ

89
00:05:04,000 --> 00:05:08,000
然后主要为为什么取这个名字呢

90
00:05:08,000 --> 00:05:15,000
其实也是想针对国外的用户或者一些企业或者 partner 来去做

91
00:05:15,000 --> 00:05:19,000
所以这个中文的名字不太好听

92
00:05:19,000 --> 00:05:20,000
所以大家也忽略吧

93
00:05:20,000 --> 00:05:23,000
大家更多关注可以关注我们的那个英文的网站

94
00:05:24,000 --> 00:05:30,000
然后可能我们的中文网站还在做也也也也也也没有特别的一个进展

95
00:05:30,000 --> 00:05:32,000
但是所以就是我们的一个定位吧

96
00:05:32,000 --> 00:05:36,000
可能跟之前的国内的一个创业团队不太一样

97
00:05:36,000 --> 00:05:39,000
我们还是希望能够做得足够精致吧

98
00:05:39,000 --> 00:05:41,000
所以 OK

99
00:05:41,000 --> 00:05:42,000
OK awesome

100
00:05:42,000 --> 00:05:44,000
对这个这个事情说来就非常巧啊

101
00:05:44,000 --> 00:05:46,000
其实我跟三轮的认识还是一个机缘巧合

102
00:05:46,000 --> 00:05:49,000
就有一天我收到了一封这个邮件

103
00:05:49,000 --> 00:05:55,000
然后发发给我的地址是对应到我的那个 github 的账号的那个邮箱的

104
00:05:55,000 --> 00:05:56,000
然后是三文给我来的一封信

105
00:05:56,000 --> 00:05:58,000
然后他是问我说能不能

106
00:05:58,000 --> 00:06:01,000
因为我当时在 github 上面有一个项目是

107
00:06:01,000 --> 00:06:03,000
是用这个命令行控制

108
00:06:03,000 --> 00:06:07,000
通过这个 virtual box 的命令行工具去控制他启动这个讯息机

109
00:06:07,000 --> 00:06:10,000
创建讯息机在我们的基本的小工具

110
00:06:10,000 --> 00:06:13,000
是一个勾烂的一个库吧

111
00:06:13,000 --> 00:06:15,000
然后当时三文给我来的一封邮件说能不能用这个

112
00:06:15,000 --> 00:06:19,000
因为当时我在 github 上面那个 reposter 里面没有写

113
00:06:19,000 --> 00:06:20,000
这个授权协议啊

114
00:06:20,000 --> 00:06:22,000
就这点我还是当时我就非常感动

115
00:06:22,000 --> 00:06:26,000
因为你知道很多这个大家都是直接拿来主意嘛

116
00:06:26,000 --> 00:06:26,000
对吧

117
00:06:26,000 --> 00:06:28,000
对我们也不会问这种事情的

118
00:06:28,000 --> 00:06:31,000
所以在这方面我觉得像三文还有 hyper 这个团队

119
00:06:31,000 --> 00:06:35,000
对这个版权意识还是非常非常看重的

120
00:06:35,000 --> 00:06:37,000
这点我觉得非常非常难得

121
00:06:37,000 --> 00:06:37,000
对对对

122
00:06:37,000 --> 00:06:40,000
就是因为我们其实我们这个项目啊

123
00:06:40,000 --> 00:06:42,000
就就就我们所知

124
00:06:42,000 --> 00:06:46,000
因为国内很少有这种创业团队去做开源项目

125
00:06:46,000 --> 00:06:48,000
而我们这个 hyper 其实是一个开源项目

126
00:06:48,000 --> 00:06:49,000
既然开源项目的话

127
00:06:49,000 --> 00:06:52,000
我们也是希望能够融入足够多的社区

128
00:06:52,000 --> 00:06:54,000
足够大的社区

129
00:06:54,000 --> 00:06:56,000
然后吸引更多的开发者

130
00:06:56,000 --> 00:07:02,000
然后所以在这方面其实也也是尽自己微博之给

131
00:07:02,000 --> 00:07:07,000
然后能尽量的改善一下国人在在在在开发者

132
00:07:07,000 --> 00:07:11,000
在这全球的开发者的这种印象吧

133
00:07:11,000 --> 00:07:15,000
因为可能更多的提到可能国内的工程师

134
00:07:15,000 --> 00:07:17,000
当然只能是少数吧

135
00:07:18,000 --> 00:07:22,000
他就拿个主意让让让就直接毁坏了这个圈子的名声啊

136
00:07:22,000 --> 00:07:24,000
嗯哼嗯对对对

137
00:07:24,000 --> 00:07:27,000
刚才我们聊了一堆这个周边的情况

138
00:07:27,000 --> 00:07:29,000
最后才回到这个 hyper 这个本质上

139
00:07:29,000 --> 00:07:32,000
说在这个说之前我们先把这个网址亮出来

140
00:07:32,000 --> 00:07:36,000
把这个网址是非常酷的一个域名叫做 hyper.sh

141
00:07:36,000 --> 00:07:37,000
对

142
00:07:37,000 --> 00:07:39,000
当时你们怎么想的会取用这个一个

143
00:07:39,000 --> 00:07:41,000
这个这么一个域名

144
00:07:41,000 --> 00:07:45,000
呃因为毕竟其实我我们的

145
00:07:46,000 --> 00:07:50,000
到到的 sh 还是偏技术或者偏 hyper 一点

146
00:07:50,000 --> 00:07:54,000
因为 sh 你可以认为是 bice 啊

147
00:07:54,000 --> 00:07:58,000
或者是认识认认为是其他的一些那个 share 对对对

148
00:07:58,000 --> 00:08:02,000
所以呃所以我们当时也也也是用了这种

149
00:08:02,000 --> 00:08:05,000
呃当然也是追求足够经济

150
00:08:05,000 --> 00:08:09,000
那个短一些然后就选用了这个域名

151
00:08:09,000 --> 00:08:13,000
然后当时我们之前参加挺有意思的一个一个一个事情

152
00:08:13,000 --> 00:08:16,000
就是我们之前参加一个云计算的大会

153
00:08:16,000 --> 00:08:18,000
然后很多人过来说

154
00:08:18,000 --> 00:08:20,000
哎你们这家公司是成立在上海是吗

155
00:08:20,000 --> 00:08:22,000
哈哈哈哈哈哈

156
00:08:22,000 --> 00:08:26,000
对但其实倒 shsh 是哪一个国家的这个国家顶级域来着

157
00:08:26,000 --> 00:08:29,000
呃这这这我还真真忘了

158
00:08:29,000 --> 00:08:32,000
ok 这个我们回头查一下

159
00:08:32,000 --> 00:08:35,000
但是一般我们会把这个一些 share 的工具啊

160
00:08:35,000 --> 00:08:38,000
会会用这个倒 sh 这个顶级域来做

161
00:08:38,000 --> 00:08:39,000
对

162
00:08:39,000 --> 00:08:42,000
然后这个网站当时那个三分给我来信的时候

163
00:08:42,000 --> 00:08:44,000
我就就我就问到这个项目网站中

164
00:08:44,000 --> 00:08:47,000
我就看了一下就是令我非常呃惊艳啊

165
00:08:47,000 --> 00:08:50,000
因为这确实不像是一个国内的团队做出来那种风格

166
00:08:50,000 --> 00:08:55,000
因为整个就是很很这个很美国的那种很很酷很

167
00:08:55,000 --> 00:08:58,000
hea 的这种创业团队做出来的这种技术展示的页面

168
00:08:58,000 --> 00:09:00,000
非常精美非常漂亮

169
00:09:01,000 --> 00:09:02,000
呃所以说了这么多

170
00:09:02,000 --> 00:09:05,000
我们还没有介绍 hyper 到底是一个什么样东西

171
00:09:05,000 --> 00:09:09,000
三分你能够用这个一句简单的话介绍一下 hyper 是一个

172
00:09:09,000 --> 00:09:11,000
就给我们不太熟悉这个东西的听众啊

173
00:09:11,000 --> 00:09:13,000
介绍一下 hyper 到底是个什么样的工具吗

174
00:09:13,000 --> 00:09:15,000
呃呃七七十五

175
00:09:15,000 --> 00:09:18,000
我觉得如果先介绍 hyper 之前应该先呃

176
00:09:18,000 --> 00:09:21,000
再介绍 hyper 之前最好先介绍一下 dalker

177
00:09:21,000 --> 00:09:24,000
因为可能很多人没有了解过呃

178
00:09:24,000 --> 00:09:25,000
见这个领域

179
00:09:25,000 --> 00:09:28,000
然后呃如果大家知道 dalker 的话

180
00:09:28,000 --> 00:09:33,000
那么说 hyper 的话就就很简单一句话就可以说说说明白了

181
00:09:33,000 --> 00:09:34,000
ok

182
00:09:34,000 --> 00:09:36,000
咱们咱们先说 dalker

183
00:09:36,000 --> 00:09:37,000
慢慢慢慢

184
00:09:37,000 --> 00:09:38,000
ok

185
00:09:38,000 --> 00:09:38,000
dalker 呢

186
00:09:38,000 --> 00:09:41,000
他其实呃属于属于一个新兴项目

187
00:09:41,000 --> 00:09:43,000
大概也存在了两到三年

188
00:09:43,000 --> 00:09:45,000
他发展速度相当相当惊人

189
00:09:45,000 --> 00:09:47,000
大概现在 dalker 的公司大概

190
00:09:47,000 --> 00:09:49,000
估值十亿美金吧

191
00:09:49,000 --> 00:09:50,000
十亿美金超过十亿美金了

192
00:09:51,000 --> 00:09:55,000
嗯哼嗯然后他其实本质上是基于容器

193
00:09:55,000 --> 00:09:58,000
就是呃做的一组管理工具

194
00:09:58,000 --> 00:10:00,000
我我是这么这么这么理解

195
00:10:00,000 --> 00:10:03,000
然后他将一些镜像文件

196
00:10:03,000 --> 00:10:06,000
比如呃 uvangto 啊各各种 legends 发版本都可以

197
00:10:06,000 --> 00:10:09,000
然后呃作作为一个运行师环境

198
00:10:09,000 --> 00:10:12,000
然后装到呃容器里面

199
00:10:12,000 --> 00:10:15,000
然后去增加网络增加存储

200
00:10:15,000 --> 00:10:16,000
这这些所有的那个组件

201
00:10:16,000 --> 00:10:17,000
component

202
00:10:17,000 --> 00:10:18,000
component

203
00:10:18,000 --> 00:10:24,000
然后使之呃作为一个轻量级的训练化工具来去运

204
00:10:24,000 --> 00:10:25,000
运行

205
00:10:25,000 --> 00:10:27,000
然后这样的话就相当于在同一台机器上

206
00:10:27,000 --> 00:10:31,000
我可以训你出来多个单独的容器

207
00:10:31,000 --> 00:10:34,000
然后这样去运行不同的 app

208
00:10:34,000 --> 00:10:36,000
呃 dalker 一个其中一个理念

209
00:10:36,000 --> 00:10:38,000
就是或者说容器的一个理念

210
00:10:38,000 --> 00:10:42,000
就是一个容器里面只运行一个呃 app

211
00:10:42,000 --> 00:10:45,000
就是相当于我只运行一个 component

212
00:10:45,000 --> 00:10:50,000
或者说类似那个呃一用用那个软件

213
00:10:50,000 --> 00:10:51,000
然后这样的话呢

214
00:10:51,000 --> 00:10:54,000
来做到是每个容器尽量的精减

215
00:10:54,000 --> 00:10:56,000
然后更便于管理

216
00:10:57,000 --> 00:11:02,000
他他其实是为了呃为为这些呃运营

217
00:11:02,000 --> 00:11:04,000
或者说为这些开发测试

218
00:11:04,000 --> 00:11:09,000
就是进入一个呃呃比较一致的一个运行室环境

219
00:11:09,000 --> 00:11:14,000
然后这样的话就是你可以自己提交你自己的 contender 的镜像

220
00:11:14,000 --> 00:11:15,000
然后直接提交过去之后

221
00:11:15,000 --> 00:11:17,000
任何人都可以下载

222
00:11:17,000 --> 00:11:21,000
这样的话就保证了一个非常一致的运行室环境

223
00:11:21,000 --> 00:11:27,000
就像呃就呃解决了一些像我们几年前开发软件

224
00:11:27,000 --> 00:11:29,000
就是呃加瓦各种配置环境变量

225
00:11:29,000 --> 00:11:32,000
各种各种那个参数配置等等

226
00:11:32,000 --> 00:11:34,000
这这这些问题就迎人而解

227
00:11:34,000 --> 00:11:39,000
我直接下载一个镜像直接运行就可以跟呃呃

228
00:11:39,000 --> 00:11:43,000
就比如我是一个合适人员就可以跟开发人员的运行室

229
00:11:43,000 --> 00:11:46,000
还的那个开发开发环境保持一致

230
00:11:46,000 --> 00:11:49,000
就解决解决很多就环境相关的问题吧

231
00:11:50,000 --> 00:11:50,000
嗯哼

232
00:11:51,000 --> 00:11:52,000
呃然后说到个容器

233
00:11:52,000 --> 00:11:57,000
容器它是呃刀块用用到个容器作为运行室环境

234
00:11:57,000 --> 00:11:58,000
然后容器的这个概念呢

235
00:11:58,000 --> 00:12:05,000
就是相当于呃将一个 house 的主机分成多个子的容器来呃

236
00:12:06,000 --> 00:12:08,000
来来来来去运行 app

237
00:12:09,000 --> 00:12:11,000
呃呃它这属于轻量机

238
00:12:11,000 --> 00:12:14,000
轻量机它另外一个一个一个好处呢

239
00:12:14,000 --> 00:12:15,000
就是就是足够的快

240
00:12:15,000 --> 00:12:17,000
然后但是它一个弊端呢

241
00:12:17,000 --> 00:12:18,000
就是它因为它是 share 的客用

242
00:12:18,000 --> 00:12:21,000
它是在一个内核上面去运行

243
00:12:21,000 --> 00:12:25,000
所以它也造成了一个安全性的隐患吧

244
00:12:25,000 --> 00:12:29,000
所以所以所以这就提到我们存在的意义就是

245
00:12:30,000 --> 00:12:32,000
啊解决这个安全性的问题

246
00:12:32,000 --> 00:12:35,000
就是呃这个容器它是 share 的客用 OK

247
00:12:35,000 --> 00:12:37,000
我们不用 share 的客用

248
00:12:37,000 --> 00:12:39,000
而是用 hypervisor

249
00:12:39,000 --> 00:12:44,000
就是用 vm 来代替容器来去运行呃

250
00:12:45,000 --> 00:12:46,000
刀柯的 image

251
00:12:46,000 --> 00:12:49,000
然后这样的话呢就是解决了呃

252
00:12:50,000 --> 00:12:51,000
刀柯的一个安全性问题

253
00:12:51,000 --> 00:12:54,000
但是因为呃众所说大家用过

254
00:12:54,000 --> 00:12:56,000
vmware 用过 washbox

255
00:12:56,000 --> 00:12:57,000
都知道它的启动速度可能

256
00:12:57,000 --> 00:12:59,000
呃就是可能会比较慢

257
00:12:59,000 --> 00:13:03,000
就即即即是在你的非常好的高端的伏辑上面

258
00:13:03,000 --> 00:13:07,000
大概也也要在一一两分钟或者是两三分钟吧

259
00:13:08,000 --> 00:13:08,000
没错对

260
00:13:08,000 --> 00:13:11,000
所以呃我们也是极其极

261
00:13:11,000 --> 00:13:15,000
极致的优化让它的启动速度大概在

262
00:13:15,000 --> 00:13:16,000
毫秒级别

263
00:13:16,000 --> 00:13:18,000
然后 10 毫秒级别对对对

264
00:13:18,000 --> 00:13:21,000
大概所以刚刚才是从这个一两分钟

265
00:13:21,000 --> 00:13:22,000
至少就是 100 秒也一级别

266
00:13:23,000 --> 00:13:24,000
我们现在已经到毫秒级别

267
00:13:24,000 --> 00:13:26,000
对对对对有四个数量级的提升

268
00:13:26,000 --> 00:13:27,000
对对对

269
00:13:27,000 --> 00:13:30,000
所以呃大概我们的测试

270
00:13:30,000 --> 00:13:32,000
在比较好的机器上大概在 300 毫秒

271
00:13:33,000 --> 00:13:35,000
ok 0.3 秒左右

272
00:13:35,000 --> 00:13:36,000
对对对对

273
00:13:36,000 --> 00:13:40,000
所以这个相对于呃容器的运行呃的启动速度

274
00:13:40,000 --> 00:13:43,000
来说已经算是呃差距不大

275
00:13:43,000 --> 00:13:47,000
所以而的而且它的安全性有呃很大的提升

276
00:13:47,000 --> 00:13:51,000
这样的话也就是成为我们一个核心的竞争力

277
00:13:51,000 --> 00:13:52,000
或者说一个存在的

278
00:13:53,000 --> 00:13:55,000
呃呃呃基于这个目的

279
00:13:55,000 --> 00:13:57,000
哎哎哎哎去做的这个这个东西

280
00:13:58,000 --> 00:14:03,000
所以就是说这个 hyper 是一个可以快速启动的

281
00:14:03,000 --> 00:14:05,000
这个虚拟机可以这么理解吗

282
00:14:05,000 --> 00:14:09,000
嗯对然后它在虚拟机的呃基础上呃

283
00:14:09,000 --> 00:14:12,000
可以很快的将 dalker image 运行起来

284
00:14:13,000 --> 00:14:17,000
ok 对呃然后这个这个这个 hyper 起了这个虚拟机

285
00:14:17,000 --> 00:14:20,000
里面是就只跑一个 dalker 的镜像呢

286
00:14:20,000 --> 00:14:22,000
还是说它里面可以跑多个这个 dalker 镜像

287
00:14:23,000 --> 00:14:25,000
呃可以跑多多个 dalker 的镜像

288
00:14:25,000 --> 00:14:27,000
而我们这个一个虚拟机呢

289
00:14:27,000 --> 00:14:30,000
其实相当于是一个工作单元

290
00:14:30,000 --> 00:14:32,000
呃这个工作单元呢

291
00:14:32,000 --> 00:14:37,000
其实来这个这个 idea 是来自于 cobonettis 里边的一个泡的概念

292
00:14:37,000 --> 00:14:41,000
就是一组呃 contender 的一个集合

293
00:14:41,000 --> 00:14:43,000
而这一组 contender 呢是有关系的

294
00:14:43,000 --> 00:14:48,000
它是为了运行一个呃比如我运行一个网站

295
00:14:48,000 --> 00:14:51,000
肯定要一个那个 needix or mycicle

296
00:14:51,000 --> 00:14:53,000
然后等等这类似的东西

297
00:14:53,000 --> 00:14:56,000
所以对所以我我我 mycicle 一个 contender

298
00:14:56,000 --> 00:14:58,000
我 needix 一个 contender 呃

299
00:14:58,000 --> 00:15:04,000
然后这样的话就就呃就组成一个泡的

300
00:15:04,000 --> 00:15:06,000
这个泡的概念就包含了两个 contender

301
00:15:07,000 --> 00:15:09,000
啊 ok 所以可以这么理解吗

302
00:15:09,000 --> 00:15:12,000
就是说一个一个 hyper 的虚拟机是对应一个

303
00:15:12,000 --> 00:15:14,000
就是这个 pod 对对对对这个盒子

304
00:15:14,000 --> 00:15:20,000
然后这个 pod 里面是包含了多个呃这个 darker 的这个 contender

305
00:15:20,000 --> 00:15:23,000
对然后每个 contender 里面只运行单一的一个应用

306
00:15:23,000 --> 00:15:26,000
它可能是一个数据库像 mycicle

307
00:15:26,000 --> 00:15:28,000
可能是一个这个 web 服务器像 ngx

308
00:15:28,000 --> 00:15:31,000
对对后还有一个就是像这个一个应用服务器

309
00:15:31,000 --> 00:15:34,000
比如说一个 tomcat 或者其他一些什么像 pyson

310
00:15:34,000 --> 00:15:36,000
或者 ruby 写的一个应用进程对对对

311
00:15:36,000 --> 00:15:40,000
所以他他用这种泡的概念来管理一组 service

312
00:15:41,000 --> 00:15:43,000
嗯嗯所以这个相比

313
00:15:43,000 --> 00:15:47,000
其实这里听起来他就是做这件事情的时候

314
00:15:47,000 --> 00:15:49,000
啊 hyper 相对一些已有的工具

315
00:15:49,000 --> 00:15:52,000
他们的呃主要的区别在哪里呢

316
00:15:52,000 --> 00:15:55,000
比如说可能像过去也有像 gvm

317
00:15:55,000 --> 00:15:56,000
nimxmn 的 kvm

318
00:15:56,000 --> 00:16:00,000
嗯呃也可以运行一些清亮级快速启动的这个呃

319
00:16:00,000 --> 00:16:03,000
当然这个可能需要定制那个你跑的那个就是 gast

320
00:16:03,000 --> 00:16:06,000
就是就是 gastOS 对对对

321
00:16:06,000 --> 00:16:07,000
就是冰客系统啊

322
00:16:07,000 --> 00:16:11,000
还有一些像过去基于这种传统的这个 hypervacl

323
00:16:11,000 --> 00:16:12,000
一些工具像 zine 啊

324
00:16:12,000 --> 00:16:14,000
还能也可以做一些事情

325
00:16:14,000 --> 00:16:16,000
那么从这个角度出发的话

326
00:16:16,000 --> 00:16:17,000
hyper 和他们的区别

327
00:16:17,000 --> 00:16:20,000
刚刚提到这个 kvm 和 zine 他们的区别主要在哪里

328
00:16:20,000 --> 00:16:23,000
嗯其实我们底层也是用了 kvm

329
00:16:23,000 --> 00:16:26,000
zine 以及 warsboss 这些 hypervisor

330
00:16:26,000 --> 00:16:29,000
但是呢我们跟他们的一个呃优势

331
00:16:30,000 --> 00:16:32,000
或者说我们做什么东西就是

332
00:16:32,000 --> 00:16:35,000
我们将 gastOS 呃呃

333
00:16:35,000 --> 00:16:39,000
呃是我们实现一个经济最最简单的一个 gastOS

334
00:16:39,000 --> 00:16:42,000
主要是用于跑呃

335
00:16:42,000 --> 00:16:43,000
dalker 的 image

336
00:16:43,000 --> 00:16:46,000
然后形成 container 这这一些工作

337
00:16:46,000 --> 00:16:49,000
另外呢我们外边提供一整套管理工具

338
00:16:49,000 --> 00:16:52,000
然后可以管理这些 hypervisor

339
00:16:52,000 --> 00:16:56,000
然后让他能够以泡的为单位去运行呃

340
00:16:56,000 --> 00:16:58,000
dalker 的 image 呃

341
00:16:58,000 --> 00:17:02,000
然后并且提供了很多监控的工具呃

342
00:17:02,000 --> 00:17:05,000
这样的话方便用户运行 dalker image

343
00:17:05,000 --> 00:17:07,000
并并有更好的安全性

344
00:17:08,000 --> 00:17:08,000
嗯 ok

345
00:17:08,000 --> 00:17:10,000
所以所以就是实际上都

346
00:17:10,000 --> 00:17:12,000
hyper 是分两部分

347
00:17:12,000 --> 00:17:14,000
一个是说管理像传统的像 kvm

348
00:17:14,000 --> 00:17:16,000
zine 这些 hypervisor 的工具

349
00:17:16,000 --> 00:17:17,000
对然后另一方面

350
00:17:17,000 --> 00:17:19,000
他是说是包含一个呃

351
00:17:19,000 --> 00:17:23,000
你们定制过的极度精简的一个 gastOS 的一个内核

352
00:17:23,000 --> 00:17:25,000
对是的可以这么理解了对对对

353
00:17:25,000 --> 00:17:29,000
ok 啊那这里就牵涉到两方面的问题了哈

354
00:17:29,000 --> 00:17:31,000
就是说在这个管理这个工具这一块

355
00:17:31,000 --> 00:17:34,000
hypervisor hyper 和这个 dalker

356
00:17:34,000 --> 00:17:36,000
他们之间的这个就是这个界线是什么

357
00:17:37,000 --> 00:17:37,000
呃

358
00:17:38,000 --> 00:17:40,000
你一直哪那方面就界线

359
00:17:40,000 --> 00:17:43,000
就比如说这个你刚才提到这个 hyper

360
00:17:43,000 --> 00:17:45,000
里面他这个 gastOS 里面包含哪些的东西

361
00:17:45,000 --> 00:17:47,000
你就只有一个基础内核吗

362
00:17:47,000 --> 00:17:49,000
对这个这个 gastOS 里面呃

363
00:17:49,000 --> 00:17:51,000
除了这个内核之外还有什么东西

364
00:17:51,000 --> 00:17:52,000
呃没有别的

365
00:17:52,000 --> 00:17:55,000
他只是跟呃外边的 hyperdimen

366
00:17:55,000 --> 00:17:57,000
去一个交互的作用

367
00:17:57,000 --> 00:17:58,000
然后我们会把啊

368
00:17:58,000 --> 00:18:01,000
用 hyperdimen 会把 dalker image

369
00:18:01,000 --> 00:18:03,000
从 dalker hub 上面下下下下下来

370
00:18:03,000 --> 00:18:06,000
然后作为一个保护 divis

371
00:18:06,000 --> 00:18:09,000
或者是一个卧台有酒酒屁的一个

372
00:18:09,000 --> 00:18:12,000
一个一个文件文件呃

373
00:18:12,000 --> 00:18:14,000
呃他也是给这个 hypervisor

374
00:18:14,000 --> 00:18:16,000
然后呃

375
00:18:16,000 --> 00:18:18,000
gastOS 拿到这这些信息之后

376
00:18:18,000 --> 00:18:22,000
就会做给给用户生成一些那个运行室环境

377
00:18:22,000 --> 00:18:25,000
是是是整个一个这样的一个大概的思路

378
00:18:26,000 --> 00:18:27,000
ok

379
00:18:27,000 --> 00:18:28,000
然后你刚才提到那个 hyper

380
00:18:28,000 --> 00:18:31,000
还有一部分是管理像传统的像 kvm 啊

381
00:18:31,000 --> 00:18:33,000
声音这种 hypervisor 的工具

382
00:18:33,000 --> 00:18:35,000
这一部分的话他又主要包含那些

383
00:18:35,000 --> 00:18:38,000
呃组件或者是一些功能模块呢

384
00:18:38,000 --> 00:18:40,000
呃他主要是呃这就就

385
00:18:40,000 --> 00:18:43,000
我想用过 dalker 的人都会有一些印象

386
00:18:43,000 --> 00:18:47,000
比如他可以直接用 dalker 的 dalken aux

387
00:18:47,000 --> 00:18:51,000
然后或者说 dalker 那个 es ec 或者是 dalker

388
00:18:51,000 --> 00:18:54,000
呃类似于 tty 的这种环境

389
00:18:54,000 --> 00:18:57,000
其实我们也提过这种工具就是可以

390
00:18:58,000 --> 00:19:01,000
呃因为因为如果要一个用户

391
00:19:01,000 --> 00:19:05,000
要想看呃在 hypervisor 里边的呃信息的话

392
00:19:05,000 --> 00:19:08,000
那么呃或者说他的 log 的话

393
00:19:08,000 --> 00:19:12,000
就必须要登入或者 ssh 进去

394
00:19:12,000 --> 00:19:16,000
所以呢我们实际上是将这些呃

395
00:19:16,000 --> 00:19:17,000
直接操作全都简化

396
00:19:17,000 --> 00:19:19,000
然后直接通过呃

397
00:19:20,000 --> 00:19:25,000
客户端或者说通过 API 就可以让用户能够呃

398
00:19:25,000 --> 00:19:28,000
简单的访问到底和 hypervisor 里面

399
00:19:28,000 --> 00:19:30,000
运行的 contender 到底

400
00:19:30,000 --> 00:19:31,000
运行的到底怎么样了

401
00:19:31,000 --> 00:19:33,000
然后以及他的

402
00:19:34,000 --> 00:19:35,000
是否发生错误等等等等

403
00:19:36,000 --> 00:19:38,000
就这这些全部达到一个监控的效果

404
00:19:38,000 --> 00:19:42,000
当然你也可以呃完全

405
00:19:42,000 --> 00:19:44,000
当这个 contender 一运行的时候

406
00:19:44,000 --> 00:19:46,000
你就可以监控这个 contender 所有状态

407
00:19:46,000 --> 00:19:48,000
监告个全部收集起来

408
00:19:48,000 --> 00:19:50,000
然后再去分析等这个

409
00:19:50,000 --> 00:19:53,000
其实一个很方便的有很方便的 API 呃

410
00:19:53,000 --> 00:19:55,000
方便用户再次开发

411
00:19:55,000 --> 00:19:57,000
ok

412
00:19:57,000 --> 00:20:00,000
所以所以如果我们画一个这个层次结构图的话

413
00:20:00,000 --> 00:20:03,000
最底层可能是这个 host 的这个操作系统

414
00:20:03,000 --> 00:20:03,000
对

415
00:20:03,000 --> 00:20:06,000
然后他上面会跑着像诸如这个 kvm

416
00:20:06,000 --> 00:20:09,000
声音啊这样的一些 hypervisor 的工具

417
00:20:09,000 --> 00:20:11,000
然后在市场就是 hyper 这一层

418
00:20:11,000 --> 00:20:14,000
对啊去管理这个 kvm 和现在的工具

419
00:20:14,000 --> 00:20:17,000
然后在在 hyper 管理的这些 guest

420
00:20:17,000 --> 00:20:21,000
哦呃 vm 里面会跑一个这个 darker 的一个镜像

421
00:20:21,000 --> 00:20:22,000
然后在镜像里面去

422
00:20:23,000 --> 00:20:26,000
呃运行我们最终的运用程序没错吧

423
00:20:26,000 --> 00:20:28,000
那个概念上有有点不太一样

424
00:20:28,000 --> 00:20:32,000
因为这个这个刚才你你说的这个可能就是呃

425
00:20:32,000 --> 00:20:34,000
更多人去想到这种方式

426
00:20:34,000 --> 00:20:38,000
就是他他其实这种方式就是目前的 boot to docker

427
00:20:38,000 --> 00:20:40,000
他就是将啊

428
00:20:40,000 --> 00:20:43,000
darker 的 dmon 放在一个 vm 里面去运行

429
00:20:43,000 --> 00:20:45,000
而我们呢其实是将

430
00:20:46,000 --> 00:20:47,000
呃 hyper 的 dmon

431
00:20:47,000 --> 00:20:49,000
其实我们这里就没有 darker 的 dmon

432
00:20:49,000 --> 00:20:51,000
因为我最开始其实是应爱于 darker 的 dmon

433
00:20:51,000 --> 00:20:52,000
那现在没有啊

434
00:20:52,000 --> 00:20:55,000
就是对所以我们取消了 darker 的应爱

435
00:20:55,000 --> 00:21:00,000
然后将 hyperdmon 放在 house os 里面去运行

436
00:21:00,000 --> 00:21:05,000
而呃 darker 的 image 下载相还是呃

437
00:21:05,000 --> 00:21:08,000
直接把这些文件全部传传进 vm

438
00:21:08,000 --> 00:21:13,000
然后概带 os 再去用这些文件来去呃

439
00:21:13,000 --> 00:21:15,000
起 container 然后去运行

440
00:21:15,000 --> 00:21:17,000
这这这些这些那个文件

441
00:21:18,000 --> 00:21:20,000
啊所以其实你们是这个

442
00:21:20,000 --> 00:21:23,000
就 hyper 是完全替代掉了 darker 的这个管理的功能

443
00:21:23,000 --> 00:21:25,000
对对你们只是附用了

444
00:21:25,000 --> 00:21:27,000
darker 的这个已经制作好的

445
00:21:27,000 --> 00:21:30,000
就是它本来是为 darker 这个管理工具制作好的

446
00:21:30,000 --> 00:21:31,000
这个 container image 对

447
00:21:32,000 --> 00:21:35,000
啊这个还和我之前记得有一点点这个出入

448
00:21:35,000 --> 00:21:37,000
啊这个这个话其实就还蛮酷的

449
00:21:37,000 --> 00:21:40,000
就是说呃就如果这理论上来讲啊

450
00:21:40,000 --> 00:21:43,000
如果你们因为这个这个 hyper 这个管理的 vm 的

451
00:21:43,000 --> 00:21:46,000
这个训练机也非常清亮起得很快嘛

452
00:21:46,000 --> 00:21:49,000
然后同时他又具备这个传统的像 darker

453
00:21:49,000 --> 00:21:52,000
呃无法提供的这个内核级别的隔离的安全性

454
00:21:52,000 --> 00:21:54,000
对对所以其实是在

455
00:21:54,000 --> 00:21:57,000
安全性和性能上是完全可以

456
00:21:57,000 --> 00:22:01,000
呃替代甚至超越这个 darker 这个 Deeman 本身的

457
00:22:01,000 --> 00:22:01,000
对

458
00:22:02,000 --> 00:22:05,000
ok 明白明白非常好非常好的解释

459
00:22:05,000 --> 00:22:08,000
所以所以现在有一个刚才提到一个最主要的核心要点

460
00:22:08,000 --> 00:22:12,000
就是说这个安全性的一块面

461
00:22:12,000 --> 00:22:15,000
可能这个很多这个不是做这个内核相关的朋友

462
00:22:15,000 --> 00:22:19,000
可能也其实也是现在很多使用这个 darker container 的一个新手

463
00:22:19,000 --> 00:22:20,000
可能一个困惑啊就是说

464
00:22:21,000 --> 00:22:23,000
因为因为确实你给你想一个 darker 里面

465
00:22:23,000 --> 00:22:25,000
就给人感觉用起来很像一个训练机嘛

466
00:22:26,000 --> 00:22:28,000
对但他但他其实并不是一个训练机

467
00:22:28,000 --> 00:22:30,000
只是一个一个机转叫做我们叫做机装箱

468
00:22:30,000 --> 00:22:32,000
或者叫做一个容器这么一个概念

469
00:22:32,000 --> 00:22:32,000
对

470
00:22:32,000 --> 00:22:36,000
所以三们可能这里要给这些我们这些新手哈

471
00:22:36,000 --> 00:22:39,000
还有好些不太熟悉这个使用 darker 的人要普及一下

472
00:22:39,000 --> 00:22:44,000
为什么说 darker 呢不能提供像传统的这个训练机那样的这么一个安全性

473
00:22:44,000 --> 00:22:48,000
其实这个的话就是就是从 darker 本身用的技术

474
00:22:48,000 --> 00:22:49,000
上面就要来讨论

475
00:22:49,000 --> 00:22:56,000
因为 darker 其实他并没有就是可能说说的有点有点有点太太直白了

476
00:22:56,000 --> 00:23:00,000
就是 darker 其实并没有发明任何新的技术

477
00:23:00,000 --> 00:23:04,000
ok 对对对这个其实很多人对 darker 的一个指责哈

478
00:23:04,000 --> 00:23:06,000
就是说因为这个所有的像 container 这些概念

479
00:23:06,000 --> 00:23:08,000
可能是十年前就已经有了对

480
00:23:09,000 --> 00:23:13,000
然后很多人都说这个 darker 其实只是把一些叫做新品装就久嘛

481
00:23:13,000 --> 00:23:13,000
对

482
00:23:15,000 --> 00:23:18,000
这个这样也没什么就是这个从技术角度上确实是这样子的

483
00:23:18,000 --> 00:23:22,000
就我的理解可能 darker 的主要的价值还是说他提出了这么一套这个理念

484
00:23:22,000 --> 00:23:29,000
让大家可以说就更好的去从这个开发到测试到实际部署这么一套工具流程

485
00:23:29,000 --> 00:23:35,000
对对那么刚才那个安全性的问题呢就是说为什么说这个 dark

486
00:23:35,000 --> 00:23:38,000
就我们这些小白们会觉得这个 container 之间是有隔离的

487
00:23:38,000 --> 00:23:41,000
但其实并没有想象的那么好

488
00:23:41,000 --> 00:23:45,000
对就是因为因为这些 container 之间他的一个从那个实验方式

489
00:23:45,000 --> 00:23:48,000
他是基于 nimsibase 或者说更底层的一点

490
00:23:48,000 --> 00:23:50,000
他是从 cgroups

491
00:23:50,000 --> 00:23:53,000
cgroups 就是一个内核的一个 model

492
00:23:53,000 --> 00:23:58,000
然后他做一个隔离性的就是相当于用户可以配置

493
00:23:58,000 --> 00:24:03,000
然后 cgroups 在内核里面去限制某一个模块

494
00:24:03,000 --> 00:24:08,000
比如内存比如 cpu 每个现成可以用多少

495
00:24:08,000 --> 00:24:14,000
但是这样的话他所有的全是基于一个 houseOS 的 carnal 去做的

496
00:24:14,000 --> 00:24:22,000
然后如果一个 container 里面的一个 process 获取一些更高级的权限

497
00:24:22,000 --> 00:24:25,000
他就可以控制这个内核

498
00:24:25,000 --> 00:24:30,000
而可能这个就是特别细特别细怎么 hike 去这个事情

499
00:24:30,000 --> 00:24:35,000
但是本身你 shared kernel 他其实就是有这种问题的

500
00:24:35,000 --> 00:24:39,000
因为你如果一个 container 出个问题

501
00:24:39,000 --> 00:24:45,000
导致 carnal panic 的话就会导致整个所有的 container 不可用

502
00:24:45,000 --> 00:24:48,000
看来 b 节目的名字还是很有示范意义的

503
00:24:48,000 --> 00:24:50,000
对对对对

504
00:24:50,000 --> 00:24:52,000
所以刚才你提到一个很重要的概念

505
00:24:52,000 --> 00:24:55,000
就是如果在传统的一个 darker 的部署里面

506
00:24:55,000 --> 00:25:01,000
如果你在一个虚拟机或者同一个内核里面部署了多个来历不明的

507
00:25:01,000 --> 00:25:03,000
这么一个 intimate 就在跑

508
00:25:04,000 --> 00:25:10,000
然后假设某一个因为内核它不可能是完美的一个对吧

509
00:25:10,000 --> 00:25:12,000
所以假设一个内核的一个漏洞

510
00:25:12,000 --> 00:25:14,000
或者说你没有及时打上一些补丁

511
00:25:14,000 --> 00:25:16,000
使得一个恶意的程序抓住这个漏洞

512
00:25:16,000 --> 00:25:20,000
它其实可以越权拿到这个最高级的权限

513
00:25:20,000 --> 00:25:25,000
从而影响或者控制其他在其他的 container 里面的东西

514
00:25:25,000 --> 00:25:26,000
对

515
00:25:26,000 --> 00:25:28,000
OK 所以从这个方面来讲

516
00:25:28,000 --> 00:25:31,000
我们必须采用像传统的虚拟机

517
00:25:31,000 --> 00:25:34,000
就是独立 carnal 的这种虚拟机的方式

518
00:25:34,000 --> 00:25:39,000
才能实现哪怕一个 guestcarnal 的被攻陷之后

519
00:25:39,000 --> 00:25:41,000
我的 host 还是相当来说安全的对不对

520
00:25:41,000 --> 00:25:42,000
对

521
00:25:42,000 --> 00:25:45,000
OK 那么这里就会有一个自然而然的问题了

522
00:25:45,000 --> 00:25:45,000
就说这样的话

523
00:25:45,000 --> 00:25:47,000
毕竟还是多了一个虚拟机

524
00:25:47,000 --> 00:25:50,000
多了一个内核层面的在跑

525
00:25:50,000 --> 00:25:54,000
那么它的相对于这种 darker 本身没有一个

526
00:25:54,000 --> 00:25:56,000
它是一个共享内核情况

527
00:25:56,000 --> 00:25:58,000
它的额外的开销会是怎么样的一个情况

528
00:25:58,000 --> 00:25:58,000
对

529
00:25:58,000 --> 00:26:02,000
所以这个也就是我们之前一直在关注的一个点

530
00:26:02,000 --> 00:26:03,000
就是它的性能问题

531
00:26:03,000 --> 00:26:07,000
性能问题的话就是我们做了很多的测试

532
00:26:07,000 --> 00:26:13,000
其实我们并没有说更改或者说修改

533
00:26:13,000 --> 00:26:15,000
那个 hybridizer 的代码

534
00:26:15,000 --> 00:26:18,000
然后让它达到一个非常非常优化的一个

535
00:26:18,000 --> 00:26:21,000
但是我们目前还是希望能够用

536
00:26:21,000 --> 00:26:24,000
用更加通用的手段来解决用户的问题

537
00:26:24,000 --> 00:26:31,000
然后就刚才说的一个启动一个 container 的

538
00:26:31,000 --> 00:26:33,000
所给用的时间大概在 300 毫秒

539
00:26:33,000 --> 00:26:39,000
这个跟 darker 相比基本上没差太多

540
00:26:39,000 --> 00:26:42,000
然后性能上面这是这点

541
00:26:42,000 --> 00:26:47,000
然后另外就是 cpu 给用率上面基本相似

542
00:26:47,000 --> 00:26:51,000
可能很大的一个问题就是在

543
00:26:51,000 --> 00:26:55,000
网络 iO 以及 storage 的 iO 上面可能会有

544
00:26:55,000 --> 00:26:58,000
会受限于 hybridizer 它的性能

545
00:26:58,000 --> 00:27:02,000
因为你像 9 P 或者是像直接的保告 device

546
00:27:02,000 --> 00:27:06,000
它都毕竟要经过多层的传递

547
00:27:06,000 --> 00:27:09,000
然后可能会达不到很好效果

548
00:27:09,000 --> 00:27:12,000
但是我们其实也在目前也在解决这个问题

549
00:27:12,000 --> 00:27:15,000
就是用因为保告 device

550
00:27:15,000 --> 00:27:19,000
它其实还是传的那个 storage 的协议

551
00:27:19,000 --> 00:27:21,000
比如 scatter 协议直接 scatter 协议

552
00:27:21,000 --> 00:27:25,000
怎么能够传递或者怎么能够更减少

553
00:27:25,000 --> 00:27:27,000
它的矿页的层次

554
00:27:27,000 --> 00:27:30,000
就是一些可能 bypass 的技术

555
00:27:30,000 --> 00:27:32,000
ok 所以总结一下

556
00:27:32,000 --> 00:27:35,000
就是因为 hyper 还是一个基于虚拟机的一个技术

557
00:27:35,000 --> 00:27:37,000
所以传统的虚拟机的一些缺陷

558
00:27:37,000 --> 00:27:41,000
那可能还是就是起码在现阶段还是免不了的

559
00:27:41,000 --> 00:27:42,000
刚才提到了几个问题

560
00:27:42,000 --> 00:27:44,000
就是说它可能

561
00:27:44,000 --> 00:27:47,000
但我们现在现代 CPU

562
00:27:47,000 --> 00:27:49,000
它是像 intel 的一些服务器的 CPU

563
00:27:49,000 --> 00:27:52,000
它对这个硬件虚拟化的一些支持是非常好的

564
00:27:52,000 --> 00:27:55,000
所以在运算这一块的损耗

565
00:27:55,000 --> 00:27:57,000
其实几乎可以忽略不及

566
00:27:57,000 --> 00:27:58,000
我觉得对

567
00:27:58,000 --> 00:28:00,000
然后但是像 Alzmin

568
00:28:00,000 --> 00:28:05,000
因为它还是需要依赖于这个硬件的支持和内核的支持

569
00:28:05,000 --> 00:28:08,000
可能还做不到说一个比较好的一个状态

570
00:28:08,000 --> 00:28:11,000
那么我可以大概问一下就直观来讲

571
00:28:11,000 --> 00:28:13,000
比如说我网络

572
00:28:13,000 --> 00:28:18,000
我 EGB 的这个物理网卡的这么一个吞吐量

573
00:28:18,000 --> 00:28:23,000
传到 hyper 虚拟机里面之后大概会损耗到多少

574
00:28:23,000 --> 00:28:27,000
这个我们之前确实是做过调查

575
00:28:27,000 --> 00:28:31,000
但是我现在没有手头没有这种资料

576
00:28:31,000 --> 00:28:32,000
OK

577
00:28:32,000 --> 00:28:34,000
这个就是你刚才提到最主要问题就是

578
00:28:34,000 --> 00:28:35,000
iOS 的损耗是最快的

579
00:28:35,000 --> 00:28:36,000
所以特别好吃

580
00:28:36,000 --> 00:28:38,000
但如果你有资料的话

581
00:28:38,000 --> 00:28:40,000
我们可以补到 shownotes 里面

582
00:28:40,000 --> 00:28:40,000
对

583
00:28:40,000 --> 00:28:43,000
然后就是这个在我们的官网上

584
00:28:43,000 --> 00:28:45,000
其实是有更详细的资料

585
00:28:45,000 --> 00:28:46,000
然后对

586
00:28:46,000 --> 00:28:48,000
因为这个这部分我没有参与测试

587
00:28:48,000 --> 00:28:51,000
所以具体细节不是特别清楚

588
00:28:51,000 --> 00:28:52,000
OK

589
00:28:52,000 --> 00:28:53,000
没问题

590
00:28:53,000 --> 00:28:55,000
所以这个也说到这个 iOS 这一块

591
00:28:55,000 --> 00:28:57,000
所以我顺便插话问一句

592
00:28:57,000 --> 00:28:58,000
刚才你也提到有些叫的

593
00:28:58,000 --> 00:29:00,000
就是能够绕过

594
00:29:00,000 --> 00:29:01,000
因为 iOS 最麻烦的问题是

595
00:29:01,000 --> 00:29:03,000
因为是虚拟

596
00:29:03,000 --> 00:29:05,000
就是叫 Gas 2 s 和 hoster 时间

597
00:29:05,000 --> 00:29:07,000
它是要互相复制数据

598
00:29:07,000 --> 00:29:08,000
对

599
00:29:08,000 --> 00:29:11,000
这个是导致性能损耗最主要的一个原因

600
00:29:11,000 --> 00:29:14,000
那么你刚才提到一些 bypass

601
00:29:14,000 --> 00:29:17,000
就是能够绕过这个复制的一些机制

602
00:29:17,000 --> 00:29:20,000
可以大概介绍一下你们目前在考虑的

603
00:29:20,000 --> 00:29:23,000
或者说以后可能会采用的一些方法是什么呢

604
00:29:23,000 --> 00:29:30,000
其实我们目前已经采用个 WaterIO 9 的一个模块

605
00:29:30,000 --> 00:29:36,000
然后它其实就是将网络的 IObypass

606
00:29:36,000 --> 00:29:41,000
相当于跨过 Hypervisor 底层的一个数据传输

607
00:29:41,000 --> 00:29:47,000
但是 HouseOS 它的一个 TTIP 写写意战是没办法跨越的

608
00:29:47,000 --> 00:29:52,000
所以这个技术应该是跨越 Hypervisor 的一个 TTIP 写意战

609
00:29:52,000 --> 00:29:55,000
它就是减少了它的层数

610
00:29:55,000 --> 00:30:01,000
然后另外其实我们也在基于 Ballout Device 去做一些操作

611
00:30:01,000 --> 00:30:07,000
因为 Ballout Device 的话它毕竟还是跨设备的传输

612
00:30:07,000 --> 00:30:11,000
更偏向于它的 IO 协议本身

613
00:30:11,000 --> 00:30:19,000
所以这样的话能比网络层的优化能够比文件系统级的优化效果会更好

614
00:30:19,000 --> 00:30:22,000
我们也在关注这些点

615
00:30:22,000 --> 00:30:25,000
OK 刚才你提到两个用力

616
00:30:25,000 --> 00:30:29,000
一个就是对一个经典的网络层的传输的优化

617
00:30:29,000 --> 00:30:33,000
还有一个是对文件系统传输层的存储层的优化

618
00:30:33,000 --> 00:30:38,000
我们提一个就着刚才网络层的情况来讲

619
00:30:38,000 --> 00:30:42,000
因为大家可能最常用的还是用来部署一个 GUF 的一个 server

620
00:30:42,000 --> 00:30:44,000
或者有服务器之类的应用

621
00:30:44,000 --> 00:30:45,000
所以举一个例子

622
00:30:45,000 --> 00:30:48,000
比如说在一个经典的 Hyper 的部署情况下

623
00:30:48,000 --> 00:30:53,000
就是说底下有 HouseOS 上面跑一个假刷 KVM

624
00:30:53,000 --> 00:30:58,000
然后在 Hyper 在管理一个 VM 里面再跑一个 Docker Image 的这种情况下

625
00:30:58,000 --> 00:31:06,000
一个数据包从这个最里面的假设是一个 NGX 的服务器里面传出来

626
00:31:06,000 --> 00:31:11,000
一直传到 HouseOS 硬件的网卡之间

627
00:31:11,000 --> 00:31:13,000
大概需要经过哪些步骤可以给我描述一下

628
00:31:13,000 --> 00:31:16,000
目前的话咱们先说正常的话

629
00:31:16,000 --> 00:31:21,000
它肯定是经过 Hyperizer 的 TTIP 写一展

630
00:31:21,000 --> 00:31:25,000
然后经过 Hyperizer 它的一个

631
00:31:25,000 --> 00:31:29,000
但是这个就要分它是硬件模拟还是

632
00:31:29,000 --> 00:31:33,000
就是全虚拟化还是半虚拟化

633
00:31:33,000 --> 00:31:37,000
这个的话就涉及到 Culmure 的一些知识

634
00:31:37,000 --> 00:31:38,000
就是因为 Culmure 的话

635
00:31:38,000 --> 00:31:42,000
如果是 Culmure 全虚拟化的话

636
00:31:42,000 --> 00:31:45,000
它就是相当于完全硬件虚拟化

637
00:31:45,000 --> 00:31:48,000
就是它就是网卡都是虚拟出来的

638
00:31:48,000 --> 00:31:54,000
所以它走的路是跟 Hyperizer 是跟 HouseOS 是完全一致的

639
00:31:54,000 --> 00:31:57,000
大家也可以查一下这个就可能走 TTIP 写一展

640
00:31:57,000 --> 00:32:02,000
然后再走 Nik 的 Driver

641
00:32:02,000 --> 00:32:06,000
然后再往下走 FullMild 这些东西

642
00:32:06,000 --> 00:32:09,000
然后如果要是半虚拟化的话

643
00:32:09,000 --> 00:32:14,000
它就可以用 Waterheo NightWaterheo

644
00:32:14,000 --> 00:32:15,000
反正就是这儿

645
00:32:15,000 --> 00:32:17,000
相当于 NightWater 可能 Bipass 一个技术

646
00:32:17,000 --> 00:32:21,000
就是将 Hyperizer 里面的网络包的数据

647
00:32:21,000 --> 00:32:23,000
直接给到 Nik 的 Driver

648
00:32:23,000 --> 00:32:28,000
然后 Nik 吊一些 I Auto Code 命令

649
00:32:28,000 --> 00:32:31,000
直接让 I Auto Code 直接发送出去

650
00:32:31,000 --> 00:32:33,000
然后交给 HouseOS

651
00:32:33,000 --> 00:32:36,000
然后它其实在这个过程中

652
00:32:36,000 --> 00:32:37,000
我如果没记错的话

653
00:32:37,000 --> 00:32:44,000
应该是 Hyperizer 里面的 Nik 的虚拟地址

654
00:32:44,000 --> 00:32:50,000
其实是和 HouseOS 里面的网卡的地址

655
00:32:50,000 --> 00:32:52,000
其实硬硬硬收到一起

656
00:32:52,000 --> 00:32:54,000
然后这样的话能够缩减很多层

657
00:32:54,000 --> 00:32:56,000
就不用复制那么多次了

658
00:32:56,000 --> 00:32:57,000
对

659
00:32:57,000 --> 00:32:59,000
其实在网络传输过程中

660
00:32:59,000 --> 00:33:03,000
用户态和 Nik 和态之间的网络包的复制过程

661
00:33:03,000 --> 00:33:05,000
还是比较耗时的

662
00:33:05,000 --> 00:33:06,000
对

663
00:33:06,000 --> 00:33:10,000
然后另外一个就是它的

664
00:33:10,000 --> 00:33:12,000
相当于用户态和 Nik 和态一个切换过程

665
00:33:12,000 --> 00:33:14,000
但是这个的话

666
00:33:14,000 --> 00:33:16,000
其实没有特别好的办法

667
00:33:16,000 --> 00:33:17,000
因为你要保证实施性

668
00:33:17,000 --> 00:33:19,000
要保证能够

669
00:33:19,000 --> 00:33:22,000
它的能把这些包全都传送出去

670
00:33:22,000 --> 00:33:25,000
所以必须用一些机制来触发

671
00:33:25,000 --> 00:33:26,000
所以可能

672
00:33:26,000 --> 00:33:30,000
Ulto Code 或者是用其他方式去触发

673
00:33:30,000 --> 00:33:33,000
但是这个东西我们目前也是用过现有的机制

674
00:33:33,000 --> 00:33:35,000
没有特别

675
00:33:35,000 --> 00:33:40,000
目前还没有设计这方面的动作

676
00:33:40,000 --> 00:33:42,000
明白

677
00:33:42,000 --> 00:33:45,000
这就是 Hyper 那套工具讲

678
00:33:45,000 --> 00:33:46,000
你也提到了

679
00:33:46,000 --> 00:33:50,000
Hyper 它会提供一个非常清亮级的 GaST OS VM

680
00:33:50,000 --> 00:33:53,000
在那里去运行里面的 Docker Image

681
00:33:53,000 --> 00:33:56,000
这点可能要跟现有的一些其他的

682
00:33:56,000 --> 00:33:59,000
想做同类事情的工具相比了

683
00:33:59,000 --> 00:34:01,000
比如说比较著名的现在

684
00:34:01,000 --> 00:34:03,000
比较火的像 CoreOS

685
00:34:03,000 --> 00:34:05,000
还有像一个上次

686
00:34:05,000 --> 00:34:08,000
Intel 也出了一个是专门跑 Docker Image 的

687
00:34:08,000 --> 00:34:13,000
这么一个极度精简的 Linux 的 OS

688
00:34:13,000 --> 00:34:14,000
相比起来

689
00:34:14,000 --> 00:34:17,000
你们比他们的区别在哪里

690
00:34:17,000 --> 00:34:18,000
就精简了什么东西

691
00:34:18,000 --> 00:34:19,000
是这样的

692
00:34:19,000 --> 00:34:22,000
Intel 出的那个叫 CoreOS Linux

693
00:34:22,000 --> 00:34:27,000
它的出现对我们来说还是作为很震惊的

694
00:34:27,000 --> 00:34:31,000
但是其实也是验证我们的方向是正确的

695
00:34:31,000 --> 00:34:34,000
因为大厂都跟进这些事情了

696
00:34:34,000 --> 00:34:37,000
所以我们既兴奋又担心

697
00:34:37,000 --> 00:34:39,000
还有点惊讶

698
00:34:39,000 --> 00:34:45,000
然后它和 CoreOS 其实应该是

699
00:34:45,000 --> 00:34:47,000
应该是属于类似的东西

700
00:34:47,000 --> 00:34:49,000
但是他们的目的可能不太一样

701
00:34:49,000 --> 00:34:51,000
就是我们自己的分析

702
00:34:51,000 --> 00:34:54,000
因为 CoreOS Linux 它的一个

703
00:34:54,000 --> 00:34:58,000
它其实是为了验证 Intel 的硬件

704
00:34:58,000 --> 00:35:02,000
因为 Intel 它虽然说是开源技术中心做传

705
00:35:02,000 --> 00:35:07,000
但也不能说一帮人没什么意义去做这个东西

706
00:35:07,000 --> 00:35:11,000
我们分析它应该是没有体现

707
00:35:11,000 --> 00:35:13,000
他们的硬件足够的快

708
00:35:13,000 --> 00:35:18,000
可以达到启动一个 Ninus 的 Gaussian OS

709
00:35:18,000 --> 00:35:19,000
能够非常非常快

710
00:35:19,000 --> 00:35:21,000
好秒击的

711
00:35:21,000 --> 00:35:27,000
然后当然也有很多人基于这个东西去做很多的

712
00:35:27,000 --> 00:35:29,000
因为到现在形势非常火

713
00:35:29,000 --> 00:35:35,000
所以很多人基于 CoreOS Linux 去做一些贡献

714
00:35:35,000 --> 00:35:37,000
然后就是把它改造一下

715
00:35:37,000 --> 00:35:41,000
之前还有一个 PR 专门给 Dalker 的

716
00:35:41,000 --> 00:35:44,000
相当于 Dalker 的 upstream

717
00:35:44,000 --> 00:35:45,000
然后去提个一个 PR

718
00:35:45,000 --> 00:35:53,000
就是希望能够用 CoreOS Linux 来运行 Dalker 的 imager

719
00:35:53,000 --> 00:35:55,000
但是这个没有被接手

720
00:35:55,000 --> 00:35:59,000
因为可能觉得可能做得不太好吧

721
00:35:59,000 --> 00:36:03,000
或者说它的性能或者说

722
00:36:03,000 --> 00:36:07,000
整体的一个运动方式跟 Dalker 的不太一样

723
00:36:07,000 --> 00:36:12,000
所以我们也关注它很长时间

724
00:36:12,000 --> 00:36:14,000
它目前也在不断的维护

725
00:36:14,000 --> 00:36:18,000
然后它跟 CoreOS

726
00:36:18,000 --> 00:36:19,000
就提到 CoreOS

727
00:36:19,000 --> 00:36:22,000
CoreOS 其实它是在 CoreOS 里面

728
00:36:22,000 --> 00:36:25,000
它给你做个足够多的配置

729
00:36:25,000 --> 00:36:28,000
然后让你直接去运行一个 Dalker 的 Demon

730
00:36:28,000 --> 00:36:30,000
或者说 Dalker 的 contender

731
00:36:30,000 --> 00:36:38,000
然后你直接 CoreOS 是不可以装在一个 Biomental 的一个机器上面

732
00:36:38,000 --> 00:36:40,000
而 CoreOS 是可以的

733
00:36:40,000 --> 00:36:42,000
它可以装在 Biomental 的机器上

734
00:36:42,000 --> 00:36:46,000
然后这样的话配置到一个机房就可以运行

735
00:36:46,000 --> 00:36:48,000
就可以直接装一个 OS

736
00:36:48,000 --> 00:36:50,000
你可以直接运行 Dalker 的 Demon

737
00:36:50,000 --> 00:36:53,000
Dalker 的任何命令你都可以去直接运行

738
00:36:53,000 --> 00:36:54,000
而且它可以优化

739
00:36:54,000 --> 00:36:57,000
所以它的可能的场景不太一样

740
00:36:57,000 --> 00:37:00,000
所以说我们的 Hyper 其实跟他们

741
00:37:00,000 --> 00:37:03,000
其实不是特别一样

742
00:37:03,000 --> 00:37:06,000
因为我们其实虽然说也提供一个 GasOS

743
00:37:06,000 --> 00:37:08,000
但是我们的用于 GasOS

744
00:37:08,000 --> 00:37:15,000
它其实是为了在 VM 里面跟外边的 HyperDemon 去配合

745
00:37:15,000 --> 00:37:19,000
然后去运行 Dalker 的 Image

746
00:37:19,000 --> 00:37:21,000
其实我们是一个整套的一个环境

747
00:37:21,000 --> 00:37:27,000
其实就是跟 Dalker 平行了一个另外一套的环境

748
00:37:28,000 --> 00:37:30,000
所以如果我这样理解没错的话

749
00:37:30,000 --> 00:37:33,000
就是 CoreOS 和 Intel 出的 Clear Linux

750
00:37:33,000 --> 00:37:35,000
他们还是依赖于 DalkerDemon 本身

751
00:37:35,000 --> 00:37:36,000
对是的

752
00:37:36,000 --> 00:37:39,000
而 Hyper 是可以完全替代掉它的

753
00:37:39,000 --> 00:37:40,000
对对是

754
00:37:40,000 --> 00:37:42,000
所以其实从我个人角度来讲

755
00:37:42,000 --> 00:37:45,000
肯定是少一层比多一层简单

756
00:37:45,000 --> 00:37:48,000
对这个也是看大家用场景

757
00:37:48,000 --> 00:37:50,000
可能关注点不太一样

758
00:37:50,000 --> 00:37:56,000
那时候也不能太太太退效我们的东西

759
00:37:56,000 --> 00:37:56,000
没错

760
00:37:56,000 --> 00:37:59,000
这里就提到应用场景这个非常非常重要

761
00:37:59,000 --> 00:38:02,000
所以在你们的定位里面

762
00:38:02,000 --> 00:38:04,000
是在什么场景下使用于

763
00:38:04,000 --> 00:38:07,000
比较就是使用用 Hyper 会比较好

764
00:38:07,000 --> 00:38:10,000
其实我们是希望

765
00:38:10,000 --> 00:38:14,000
但是我们的一个做这个 Hyper 这个目的

766
00:38:14,000 --> 00:38:22,000
是希望有想法用 Dalker 做构建一个

767
00:38:22,000 --> 00:38:24,000
供应云的一个厂商

768
00:38:24,000 --> 00:38:27,000
就当然可能目前已经有了

769
00:38:27,000 --> 00:38:31,000
就比如到什么到可奥的点

770
00:38:31,000 --> 00:38:39,000
到 Dotl 他们其实就是声称是用 Dalker 做一个

771
00:38:39,000 --> 00:38:40,000
去构建的一个供应云

772
00:38:40,000 --> 00:38:44,000
但是我不确定他们内部是怎么搭建的

773
00:38:44,000 --> 00:38:46,000
来保证用户的安全性

774
00:38:46,000 --> 00:38:49,000
OK 这个设计在刚才我们讲的那个问题了

775
00:38:49,000 --> 00:38:51,000
如果说因为你没有内核隔离的话

776
00:38:51,000 --> 00:38:53,000
其实是 Dalker 本身的那个

777
00:38:53,000 --> 00:38:56,000
container 隔离是无法保证安全性的

778
00:38:56,000 --> 00:38:58,000
然后如果你跑的是一个公有云

779
00:38:58,000 --> 00:38:59,000
就所谓公有云

780
00:38:59,000 --> 00:39:02,000
就是说你的两个客户之间是

781
00:39:02,000 --> 00:39:05,000
可能不是一家或一个人

782
00:39:05,000 --> 00:39:07,000
然后你也没法保证你运行的应用的

783
00:39:07,000 --> 00:39:11,000
就是一个性质或者是

784
00:39:11,000 --> 00:39:12,000
它是不是一个恶意程序

785
00:39:12,000 --> 00:39:13,000
你是无法保证的

786
00:39:13,000 --> 00:39:16,000
就是可能是公有云和私有云对大的区别

787
00:39:16,000 --> 00:39:17,000
对

788
00:39:17,000 --> 00:39:19,000
所以这种情况下是必须采用 VM 隔离

789
00:39:19,000 --> 00:39:23,000
才可以实现我们可以接受的安全性

790
00:39:23,000 --> 00:39:23,000
对

791
00:39:23,000 --> 00:39:27,000
因为目前就我们所知一般的公有云厂商

792
00:39:27,000 --> 00:39:29,000
一般都是用这种方式

793
00:39:29,000 --> 00:39:32,000
就是底层还是用 hybridzer 去

794
00:39:32,000 --> 00:39:34,000
或者说 VM 去做隔离

795
00:39:34,000 --> 00:39:35,000
对

796
00:39:35,000 --> 00:39:39,000
然后可能没有用容器直接去做隔离

797
00:39:40,000 --> 00:39:41,000
不太靠谱

798
00:39:43,000 --> 00:39:43,000
OK

799
00:39:43,000 --> 00:39:45,000
所以 hybridzer 一个主要应用场景

800
00:39:45,000 --> 00:39:49,000
就是说给那些有质于提供公有云的厂商

801
00:39:49,000 --> 00:39:51,000
这么一套基础的工具

802
00:39:51,000 --> 00:39:53,000
使得他们可以比较快速的启动

803
00:39:53,000 --> 00:39:56,000
或者是关闭一个训练机

804
00:39:56,000 --> 00:39:58,000
然后训练机上是可以

805
00:39:58,000 --> 00:40:01,000
但是它面向就是暴露给用户的

806
00:40:01,000 --> 00:40:03,000
它确实一个叫什么来的

807
00:40:03,000 --> 00:40:06,000
是类似 container 那种的 API 对吧

808
00:40:06,000 --> 00:40:08,000
对

809
00:40:08,000 --> 00:40:08,000
OK

810
00:40:08,000 --> 00:40:10,000
所以这个就是牵涉到另外一个问题了

811
00:40:10,000 --> 00:40:12,000
就是说因为我们现在大部分的

812
00:40:12,000 --> 00:40:14,000
像 Leno 的也好

813
00:40:14,000 --> 00:40:15,000
AWS 也好

814
00:40:15,000 --> 00:40:16,000
还有现在比较火的

815
00:40:16,000 --> 00:40:18,000
Digital Cloud 也好

816
00:40:18,000 --> 00:40:21,000
他们都是采用传统的训练机这种方式

817
00:40:21,000 --> 00:40:23,000
暴露出传统训练机这么一个单元

818
00:40:23,000 --> 00:40:26,000
然后由用户再去管理其中的

819
00:40:26,000 --> 00:40:30,000
这个是否跑 Docker 是否跑什么

820
00:40:30,000 --> 00:40:32,000
跑什么 Gasthos 的事情

821
00:40:32,000 --> 00:40:33,000
那么刚才我们讲的

822
00:40:33,000 --> 00:40:35,000
你直接暴露给用户一套机遇

823
00:40:35,000 --> 00:40:37,000
就 container 的 API 的好处

824
00:40:37,000 --> 00:40:38,000
相比于现在这个暴露给用户一个

825
00:40:38,000 --> 00:40:41,000
机遇 VM 的 API 的好处是什么呢

826
00:40:41,000 --> 00:40:44,000
暴露

827
00:40:44,000 --> 00:40:48,000
其实我觉得还是另外从一个用场景上面来分析

828
00:40:48,000 --> 00:40:51,000
就是如果要是

829
00:40:51,000 --> 00:40:55,000
就比如说用户他想

830
00:40:55,000 --> 00:40:59,000
他已经在本地他一个的开发环境

831
00:40:59,000 --> 00:41:00,000
他本地的话

832
00:41:00,000 --> 00:41:03,000
他可以佩制任何 Docker 的一个 Image

833
00:41:03,000 --> 00:41:07,000
然后去上传到自己的 Private 或者是 Pubg 的

834
00:41:07,000 --> 00:41:08,000
一个 HUB 上面

835
00:41:08,000 --> 00:41:11,000
然后他再去运行

836
00:41:11,000 --> 00:41:16,000
然后如果他要是像直接拿到一个 VM 的一个环境的话

837
00:41:16,000 --> 00:41:18,000
那他完全他要在自己搭 Docker

838
00:41:18,000 --> 00:41:21,000
然后再给你去直接的部署下来

839
00:41:21,000 --> 00:41:23,000
再下来再去运行

840
00:41:23,000 --> 00:41:24,000
或者是对

841
00:41:24,000 --> 00:41:25,000
然后但是我们这种方式

842
00:41:25,000 --> 00:41:30,000
你直接可以将你的 Docker 的 Image 直接下来

843
00:41:30,000 --> 00:41:30,000
想起来

844
00:41:30,000 --> 00:41:34,000
你只要填一些你所想要的东西

845
00:41:34,000 --> 00:41:35,000
直接全都给你部署在后端

846
00:41:35,000 --> 00:41:38,000
就是不需要你去做任何的配置

847
00:41:38,000 --> 00:41:40,000
你只要填

848
00:41:40,000 --> 00:41:42,000
我们这里有一个叫 JSON

849
00:41:42,000 --> 00:41:43,000
就是输入文件

850
00:41:43,000 --> 00:41:44,000
就是 JSON FILE

851
00:41:44,000 --> 00:41:47,000
JSON FILE 里面可以定义你的所有的

852
00:41:47,000 --> 00:41:49,000
这个上面运行的东西

853
00:41:49,000 --> 00:41:49,000
比如 Condender

854
00:41:49,000 --> 00:41:51,000
运行那个 Condender

855
00:41:51,000 --> 00:41:53,000
从载运行从载下载

856
00:41:53,000 --> 00:41:57,000
然后以及那个 Pout 的那段后影射

857
00:41:57,000 --> 00:41:59,000
然后以及 Sourage 等等等等

858
00:41:59,000 --> 00:42:01,000
你都可以去自己去配置

859
00:42:01,000 --> 00:42:03,000
然后所以就是

860
00:42:03,000 --> 00:42:05,000
减化用户操作吧

861
00:42:05,000 --> 00:42:06,000
我觉得

862
00:42:06,000 --> 00:42:07,000
OK

863
00:42:07,000 --> 00:42:09,000
所以这个其实还是挺切中

864
00:42:09,000 --> 00:42:11,000
我的这个个人的一个痛点

865
00:42:11,000 --> 00:42:12,000
比如说自己在运营

866
00:42:12,000 --> 00:42:14,000
就这个 IPN 的这个服务

867
00:42:14,000 --> 00:42:16,000
还有一些帮朋友管的一些其他的一些服务

868
00:42:16,000 --> 00:42:19,000
然后他们就是每次要新增一个服务

869
00:42:19,000 --> 00:42:20,000
或者是关对的

870
00:42:20,000 --> 00:42:22,000
特别是新增的时候会有一个问题

871
00:42:22,000 --> 00:42:24,000
就是说给我的这个训练机

872
00:42:24,000 --> 00:42:25,000
新开的一个训练机是空白的

873
00:42:25,000 --> 00:42:27,000
我得要重新打一套

874
00:42:27,000 --> 00:42:30,000
比如说在建管里对应的这个账号对吧

875
00:42:30,000 --> 00:42:30,000
对

876
00:42:30,000 --> 00:42:33,000
对应的这个要安装对应的软件

877
00:42:33,000 --> 00:42:35,000
但这可能有一部分是可以通过 Docker 本

878
00:42:35,000 --> 00:42:37,000
那个 Image 本身打包来实现的

879
00:42:37,000 --> 00:42:39,000
但是刚才你提到一个很重要点

880
00:42:39,000 --> 00:42:40,000
就是 Docker 这个 Dima

881
00:42:40,000 --> 00:42:43,000
这个守护军层本身还是需要配置和安装的

882
00:42:43,000 --> 00:42:44,000
对对对

883
00:42:44,000 --> 00:42:45,000
所以其实我觉得还是一个

884
00:42:45,000 --> 00:42:48,000
就是抽象层次的一个飞越吧

885
00:42:48,000 --> 00:42:50,000
你们其实是通过 Hyper 这套

886
00:42:50,000 --> 00:42:52,000
基于 container 的 API

887
00:42:52,000 --> 00:42:57,000
同时再加上这个 VM 的安全性

888
00:42:57,000 --> 00:42:59,000
使得我们不用再去操心

889
00:42:59,000 --> 00:43:01,000
我大面这个 container

890
00:43:01,000 --> 00:43:05,000
其实我是可以在逻辑上按照 container 来做这个部署了

891
00:43:05,000 --> 00:43:07,000
只是说不用再操心

892
00:43:07,000 --> 00:43:09,000
像 tranadocker 这种 container 之间

893
00:43:09,000 --> 00:43:12,000
无法内核及隔离的不安全的引化

894
00:43:12,000 --> 00:43:13,000
对对

895
00:43:13,000 --> 00:43:13,000
没错

896
00:43:13,000 --> 00:43:14,000
对

897
00:43:16,000 --> 00:43:16,000
对

898
00:43:16,000 --> 00:43:19,000
然后我们下面就要进入到一个很关键的问题的讨论

899
00:43:19,000 --> 00:43:22,000
就是说因为基于因为 Docker 其实本身

900
00:43:22,000 --> 00:43:23,000
到我觉得到目前为止吧

901
00:43:23,000 --> 00:43:25,000
也没有并没有很好的解决这个问题

902
00:43:25,000 --> 00:43:28,000
就是这个存储空间的问题

903
00:43:28,000 --> 00:43:31,000
因为过去的话就照我的理解他 Docker 的

904
00:43:31,000 --> 00:43:35,000
因为他是提倡的叫做应用是那个那个 image container

905
00:43:35,000 --> 00:43:36,000
是不可辨了

906
00:43:36,000 --> 00:43:38,000
就 immutable container

907
00:43:38,000 --> 00:43:41,000
那么比如说你作为一个应用层应用服务器本身

908
00:43:41,000 --> 00:43:42,000
可能这个道也没什么

909
00:43:42,000 --> 00:43:44,000
你多起几个应用

910
00:43:44,000 --> 00:43:47,000
可以提高你的这个并发数对吧

911
00:43:47,000 --> 00:43:48,000
那是当然是好的

912
00:43:48,000 --> 00:43:51,000
但是我们做一大部分的这个网站也好

913
00:43:51,000 --> 00:43:52,000
还是这个什么服务也好

914
00:43:52,000 --> 00:43:55,000
他还是必须要考虑这个数据持久化的问题

915
00:43:55,000 --> 00:43:57,000
就说这个你从这个客户

916
00:43:57,000 --> 00:43:58,000
那里拿到了这个数据

917
00:43:58,000 --> 00:44:00,000
那你存到哪里

918
00:44:00,000 --> 00:44:03,000
过去 Docker 的一个提倡的一个概念就是说

919
00:44:03,000 --> 00:44:08,000
那你再建一个就单纯拿来做这个存储的一个 image

920
00:44:08,000 --> 00:44:09,000
来做这件事情

921
00:44:09,000 --> 00:44:13,000
所以我不知道这件事情在 hyper 里面是一个什么样的一个值得

922
00:44:13,000 --> 00:44:15,000
就是什么样的做法是值得鼓励的

923
00:44:15,000 --> 00:44:23,000
我们目前是有一个单独的 vogam 的一个模块

924
00:44:23,000 --> 00:44:27,000
然后它是可以你可以在针对某个 container

925
00:44:27,000 --> 00:44:31,000
或者说针对几个 container 去配置

926
00:44:31,000 --> 00:44:37,000
然后你可以自己添加你想加入的 vogam

927
00:44:37,000 --> 00:44:41,000
这个 vogam 即可以是文件或者或者是 mogle

928
00:44:41,000 --> 00:44:44,000
然后也可以是 blogdvice

929
00:44:44,000 --> 00:44:47,000
blogdvice 就是支持非常多的形式

930
00:44:47,000 --> 00:44:51,000
或者就是然后用户可以自由配置

931
00:44:51,000 --> 00:44:54,000
然后你可以把这个多大多多少

932
00:44:54,000 --> 00:44:55,000
你都可以自己配置

933
00:44:55,000 --> 00:44:58,000
然后指定给哪个用户都可以自己配置

934
00:44:58,000 --> 00:45:01,000
然后这样的话你加入到一个 container 里面

935
00:45:01,000 --> 00:45:03,000
你可能是运行的时候

936
00:45:03,000 --> 00:45:09,000
你可以指定我将数据存到这个 blogdvice

937
00:45:09,000 --> 00:45:12,000
或者说是 mogle 里面

938
00:45:12,000 --> 00:45:17,000
这样的话目前我们是支持本地的

939
00:45:17,000 --> 00:45:19,000
以及加 sci-fi 或者说

940
00:45:19,000 --> 00:45:23,000
或者说你用 sgaz 也可能也可能配直接配

941
00:45:23,000 --> 00:45:26,000
sourage or 都可以

942
00:45:26,000 --> 00:45:30,000
ok 所以我理解一下这个大概的一个做法

943
00:45:30,000 --> 00:45:33,000
就是说我把就是这个 hyper

944
00:45:33,000 --> 00:45:37,000
它会允许我虚拟出一块这个 blogdvice

945
00:45:37,000 --> 00:45:39,000
就是一个快存主器

946
00:45:39,000 --> 00:45:41,000
然后这个快存就可以直接挂载进

947
00:45:41,000 --> 00:45:44,000
或者某一个 hyper 的训练机里面

948
00:45:44,000 --> 00:45:46,000
成为一个文件系统也好

949
00:45:46,000 --> 00:45:47,000
一个什么目录也好

950
00:45:47,000 --> 00:45:52,000
然后这样的话就是 hyper 训练机里面本身跑的

951
00:45:52,000 --> 00:45:55,000
一样它还是一个 immutable 就是不可辨识

952
00:45:55,000 --> 00:45:57,000
然后它这写入的数据也是通过这个

953
00:45:57,000 --> 00:45:59,000
刚才挂载进去的 blogdvice

954
00:45:59,000 --> 00:46:01,000
持久化到其他地方对吧

955
00:46:01,000 --> 00:46:04,000
然后持久化要么你可以在本机

956
00:46:04,000 --> 00:46:07,000
就是同一台 host 的机器上执行

957
00:46:07,000 --> 00:46:10,000
或者是通过这个 sgaz 的这种网络的

958
00:46:10,000 --> 00:46:12,000
这个存出的协议

959
00:46:12,000 --> 00:46:14,000
写到另外一台这个一个文件

960
00:46:14,000 --> 00:46:16,000
比如说一个文件服务器上对没错

961
00:46:16,000 --> 00:46:17,000
是这样的

962
00:46:17,000 --> 00:46:18,000
ok

963
00:46:18,000 --> 00:46:21,000
所以那这里就牵涉到一个一个效率的问题了

964
00:46:21,000 --> 00:46:23,000
刚才我们也在前面提到了

965
00:46:23,000 --> 00:46:26,000
就是说通过这种方式挂载进去的

966
00:46:26,000 --> 00:46:28,000
这个就是 disk i o 的这个效率

967
00:46:28,000 --> 00:46:30,000
会有很大的这个损耗吗

968
00:46:30,000 --> 00:46:32,000
还是说什么样的情况

969
00:46:32,000 --> 00:46:37,000
其实这个主要还是说 hyperrider 本身的

970
00:46:37,000 --> 00:46:38,000
就是因为我们

971
00:46:38,000 --> 00:46:40,000
我们如果你要是挂本机的

972
00:46:42,000 --> 00:46:42,000
保护 device 的话

973
00:46:42,000 --> 00:46:45,000
那么它其实还是涉及到一个

974
00:46:45,000 --> 00:46:48,000
i o 命令的一个传递的一个转换

975
00:46:48,000 --> 00:46:49,000
然后这个的话

976
00:46:49,000 --> 00:46:51,000
小号应该不大

977
00:46:51,000 --> 00:46:53,000
但是如果你要是文件级别

978
00:46:53,000 --> 00:46:54,000
就 mongru 的话

979
00:46:54,000 --> 00:46:56,000
mongru 的话它其实是走的

980
00:46:57,000 --> 00:47:02,000
它是通过 hyperrider 的 share file

981
00:47:02,000 --> 00:47:05,000
share 或者 share directory 来做的

982
00:47:05,000 --> 00:47:07,000
所以这个过程中

983
00:47:07,000 --> 00:47:08,000
我们这次说过

984
00:47:08,000 --> 00:47:10,000
就是不管是 vmware

985
00:47:10,000 --> 00:47:11,000
或者说 what about

986
00:47:11,000 --> 00:47:13,000
或者是 tumor

987
00:47:13,000 --> 00:47:18,000
它的 share 的 mongru 的性能都不是特别好

988
00:47:18,000 --> 00:47:22,000
所以我们特别建议用保护 device 级别的去操作

989
00:47:22,000 --> 00:47:25,000
另外就像刚才另外一种方式

990
00:47:25,000 --> 00:47:25,000
还有第三种方式

991
00:47:25,000 --> 00:47:28,000
就比如我要是远远端的

992
00:47:28,000 --> 00:47:30,000
或者说 sorry slower 的话

993
00:47:30,000 --> 00:47:31,000
那这个的话

994
00:47:31,000 --> 00:47:33,000
它因为可以是

995
00:47:33,000 --> 00:47:36,000
保护给 hyperrider 一个保护 device

996
00:47:36,000 --> 00:47:39,000
所以它这个的性能可能是

997
00:47:39,000 --> 00:47:42,000
除了依赖于 hyperrider 保护 device 的支持

998
00:47:42,000 --> 00:47:47,000
还有的话就是用的第三方工具的性能

999
00:47:48,000 --> 00:47:51,000
所以 share 的 mongru 的话

1000
00:47:51,000 --> 00:47:56,000
这确实是一个硬上没有特别好的办法

1001
00:47:56,000 --> 00:47:58,000
因为 hyperrider 本身

1002
00:47:58,000 --> 00:48:00,000
它他们做的也不是太好

1003
00:48:00,000 --> 00:48:04,000
因为它是想达到更加用户

1004
00:48:04,000 --> 00:48:08,000
就是说普通用户级别的使用

1005
00:48:08,000 --> 00:48:11,000
而不是说我用这个来做企业级

1006
00:48:11,000 --> 00:48:14,000
或者说做工业级的用户可能不太一样

1007
00:48:14,000 --> 00:48:15,000
OK

1008
00:48:15,000 --> 00:48:17,000
所以那么就牵涉到一个问题了

1009
00:48:17,000 --> 00:48:20,000
就是说在实际大规模部署的时候

1010
00:48:20,000 --> 00:48:22,000
这种比如说类似于 Google

1011
00:48:22,000 --> 00:48:25,000
或者是 Amazon 这种级别的用户

1012
00:48:25,000 --> 00:48:27,000
他们会一般会采用什么样的方式去部署

1013
00:48:27,000 --> 00:48:30,000
这种存储的方案呢

1014
00:48:31,000 --> 00:48:35,000
存储的方案

1015
00:48:35,000 --> 00:48:39,000
这我还真不确定他们怎么部署的

1016
00:48:39,000 --> 00:48:41,000
OK 没关系

1017
00:48:41,000 --> 00:48:43,000
我们进入这个下一个话题

1018
00:48:43,000 --> 00:48:45,000
就是说刚才也提到文件存储

1019
00:48:45,000 --> 00:48:47,000
可能是效率上是一个硬上

1020
00:48:47,000 --> 00:48:51,000
这个确实在目前的技术条件下

1021
00:48:51,000 --> 00:48:52,000
好像没有特别好的解决的方案

1022
00:48:52,000 --> 00:48:53,000
对

1023
00:48:53,000 --> 00:48:56,000
然后刚才之前我们也提到了网络

1024
00:48:56,000 --> 00:48:57,000
这一块因为也设计到 iO

1025
00:48:57,000 --> 00:49:00,000
也是一个比较尴尬的状态

1026
00:49:00,000 --> 00:49:02,000
其实这个都说的是在

1027
00:49:02,000 --> 00:49:04,000
刚才我们大家假设的一个场景

1028
00:49:04,000 --> 00:49:08,000
都是说在一个 Linux 的 hostOS 上跑

1029
00:49:08,000 --> 00:49:10,000
这个应用的场景

1030
00:49:10,000 --> 00:49:11,000
但是我现在就问一下

1031
00:49:11,000 --> 00:49:12,000
如果在开发者在

1032
00:49:12,000 --> 00:49:14,000
就是想讲他听众朋友们

1033
00:49:14,000 --> 00:49:15,000
对这个 hyper 比较感兴趣

1034
00:49:15,000 --> 00:49:16,000
他想去试一下

1035
00:49:16,000 --> 00:49:21,000
他在哪些其他系统上可以去玩这个 hyper 呢

1036
00:49:21,000 --> 00:49:22,000
因为我们像那个 Docker

1037
00:49:22,000 --> 00:49:25,000
他可以通过一些讯记的方式

1038
00:49:25,000 --> 00:49:27,000
在像 OS 10 上也可以跑

1039
00:49:27,000 --> 00:49:28,000
hyper 呢

1040
00:49:28,000 --> 00:49:32,000
hyper 当然也支持 MacOS

1041
00:49:32,000 --> 00:49:34,000
然后这个东西

1042
00:49:34,000 --> 00:49:38,000
这个 hyper 对于 MacOS 的支持

1043
00:49:38,000 --> 00:49:41,000
大概是在这个月

1044
00:49:41,000 --> 00:49:43,000
应该是这个月初完成的

1045
00:49:43,000 --> 00:49:45,000
然后我们也在不断的去完善

1046
00:49:45,000 --> 00:49:49,000
然后目前的那个在

1047
00:49:49,000 --> 00:49:54,000
在 MacOS 上面的 hyper 只能用

1048
00:49:54,000 --> 00:49:57,000
Wattbox 一种 hyperizer

1049
00:49:57,000 --> 00:50:01,000
然后如果你要是在 Linux 上面

1050
00:50:01,000 --> 00:50:04,000
那你可以用 Qmill KVM

1051
00:50:04,000 --> 00:50:07,000
Zen 以及 Wattbox 都可以用

1052
00:50:07,000 --> 00:50:11,000
但是因为 MacOS 上面

1053
00:50:11,000 --> 00:50:14,000
没有说 Qmill KVM

1054
00:50:14,000 --> 00:50:18,000
或者说 Zen 的这些讯记化的工具

1055
00:50:18,000 --> 00:50:20,000
所以就没有特别好的办法

1056
00:50:20,000 --> 00:50:23,000
因为 Wattbox 的

1057
00:50:23,000 --> 00:50:26,000
其实从他的稳定可靠性

1058
00:50:26,000 --> 00:50:28,000
还有他的性能来讲

1059
00:50:28,000 --> 00:50:30,000
就不算特别好

1060
00:50:30,000 --> 00:50:34,000
特别是在 OS 10 上面

1061
00:50:34,000 --> 00:50:36,000
然后今天会遇到什么

1062
00:50:36,000 --> 00:50:38,000
开了他然后就死机的一个情况

1063
00:50:38,000 --> 00:50:39,000
也是有发生

1064
00:50:39,000 --> 00:50:40,000
对

1065
00:50:40,000 --> 00:50:43,000
其实最近我们知道

1066
00:50:43,000 --> 00:50:46,000
好像是从 OS 10 是 10.9

1067
00:50:46,000 --> 00:50:48,000
还是 10.10 开始

1068
00:50:48,000 --> 00:50:51,000
他有一个苹果开发了一套

1069
00:50:51,000 --> 00:50:55,000
一个 firmmark 叫做 hypervisor.firmmark

1070
00:50:55,000 --> 00:50:58,000
这套其实他可以在 OS 10 上

1071
00:50:58,000 --> 00:51:01,000
实现类似于 KVM 的功能

1072
00:51:01,000 --> 00:51:02,000
所以我不知道你们后续有什么计划

1073
00:51:02,000 --> 00:51:04,000
会用到它吗

1074
00:51:04,000 --> 00:51:07,000
其实我们也在非常关注这个点

1075
00:51:07,000 --> 00:51:09,000
然后目前有一个开源的工具

1076
00:51:09,000 --> 00:51:11,000
就是 XL

1077
00:51:11,000 --> 00:51:13,000
就是对

1078
00:51:13,000 --> 00:51:15,000
应该也关注过这个非常

1079
00:51:15,000 --> 00:51:17,000
就是之前在 Hydre Nose 上面发出来过

1080
00:51:17,000 --> 00:51:18,000
非常火

1081
00:51:18,000 --> 00:51:20,000
然后关注度也非常高

1082
00:51:20,000 --> 00:51:24,000
他那个的历史还是要追踪到

1083
00:51:24,000 --> 00:51:25,000
Solaris 上面去

1084
00:51:25,000 --> 00:51:26,000
对吧

1085
00:51:26,000 --> 00:51:27,000
因为他的前身是一个

1086
00:51:27,000 --> 00:51:28,000
他是基于

1087
00:51:28,000 --> 00:51:29,000
他是一个 Behave 的 port

1088
00:51:29,000 --> 00:51:30,000
对

1089
00:51:30,000 --> 00:51:32,000
然后 Behave 是在 Solaris 还是在 BSD 上面

1090
00:51:32,000 --> 00:51:34,000
3 BSD

1091
00:51:34,000 --> 00:51:34,000
3 BSD

1092
00:51:34,000 --> 00:51:34,000
对

1093
00:51:34,000 --> 00:51:38,000
所以从上面应该是没有的

1094
00:51:38,000 --> 00:51:39,000
OK

1095
00:51:39,000 --> 00:51:41,000
所以目前来说

1096
00:51:41,000 --> 00:51:42,000
就是我们还是跟那个

1097
00:51:42,000 --> 00:51:45,000
像 Docker 的方案一样

1098
00:51:45,000 --> 00:51:48,000
在 OS 10 上测试开发的时候

1099
00:51:48,000 --> 00:51:51,000
是通过 Virtual Box 这个训练机

1100
00:51:51,000 --> 00:51:53,000
来里面直接在跑一些

1101
00:51:53,000 --> 00:51:56,000
是跑的这个是 Hyper 的训练机了对吧

1102
00:51:56,000 --> 00:51:58,000
这个就是我们的一个

1103
00:51:58,000 --> 00:52:01,000
费了好多好多心思去做的这个东西

1104
00:52:01,000 --> 00:52:01,000
就是我们

1105
00:52:01,000 --> 00:52:05,000
Hyper 在 Meg 上面的运行

1106
00:52:05,000 --> 00:52:08,000
和 Booted Docker 的运行是不太一样的

1107
00:52:08,000 --> 00:52:09,000
Booted Docker

1108
00:52:09,000 --> 00:52:12,000
他其实就是一个 Docker 的隔岸端

1109
00:52:12,000 --> 00:52:17,000
然后他把他的 Demons 设成了 VM 的

1110
00:52:17,000 --> 00:52:20,000
Waterbox 的地址

1111
00:52:20,000 --> 00:52:23,000
然后这个在 Waterbox 里面去运行

1112
00:52:23,000 --> 00:52:24,000
Docker Dement

1113
00:52:24,000 --> 00:52:26,000
然后他其实相当于通过网络

1114
00:52:26,000 --> 00:52:30,000
然后将这个数据全部显示给 Docker 可按的

1115
00:52:30,000 --> 00:52:34,000
用户以为他这是本地运行的

1116
00:52:34,000 --> 00:52:35,000
其实是在所有的东西

1117
00:52:35,000 --> 00:52:37,000
在 Virtual Box 的那个训练机里面运行

1118
00:52:37,000 --> 00:52:39,000
对对对是的

1119
00:52:39,000 --> 00:52:40,000
而对

1120
00:52:40,000 --> 00:52:41,000
那你们的方案是怎么样

1121
00:52:41,000 --> 00:52:42,000
我们的方案

1122
00:52:42,000 --> 00:52:45,000
我们的方案其实是跟 Ginus

1123
00:52:45,000 --> 00:52:47,000
它的设计机制是完全一致的

1124
00:52:47,000 --> 00:52:49,000
就是相当于我们的 Hyper Dement

1125
00:52:49,000 --> 00:52:51,000
是在 MegOS 上面

1126
00:52:51,000 --> 00:52:55,000
然后我们的 Hyper 可按的也在 MegOS 上面

1127
00:52:55,000 --> 00:53:02,000
而运行的 Docker 的 Image 是在 Waterbox 里面去运行的

1128
00:53:02,000 --> 00:53:10,000
他整个的一个设计思路是完全和 Ginus 上面的 Hyper 设计思路是一致的

1129
00:53:10,000 --> 00:53:13,000
所以其实我理解他就说

1130
00:53:13,000 --> 00:53:14,000
在这种情况下

1131
00:53:14,000 --> 00:53:20,000
比如我在 Western 上跑一个 Hyper 之后

1132
00:53:20,000 --> 00:53:24,000
他的管理层的命令行工具都是在 Western 的原生的东西

1133
00:53:24,000 --> 00:53:31,000
然后他是控制 Virtual BoxHypervisor 去里面新建一个训练机

1134
00:53:31,000 --> 00:53:36,000
然后训练机内核跑的是你们 Hyper 定制的轻量级的 Gas DOS

1135
00:53:36,000 --> 00:53:40,000
然后里面再跑的一个或者是多个 Docker 的 Image 是这样的

1136
00:53:40,000 --> 00:53:41,000
是的

1137
00:53:41,000 --> 00:53:45,000
OK 外面还真的和 Bootoo Docker 的方式非常不一样

1138
00:53:45,000 --> 00:53:49,000
对 因为 Bootoo Docker 你创建一个 container

1139
00:53:49,000 --> 00:53:51,000
它是一个 VM

1140
00:53:51,000 --> 00:53:54,000
然后你创建两个 他也是 创建三个 他也是

1141
00:53:54,000 --> 00:53:57,000
他创建 container 都是在 VM 里面

1142
00:53:57,000 --> 00:54:01,000
而我们这种方式就是你创建一个 container 或者说

1143
00:54:01,000 --> 00:54:02,000
就多一个 VM

1144
00:54:02,000 --> 00:54:07,000
这个可能会受限于开发者的一个机器的环境配置

1145
00:54:07,000 --> 00:54:11,000
因为你多个 VM 他毕竟要占 CPU 占 Memory

1146
00:54:11,000 --> 00:54:14,000
这个是一个

1147
00:54:14,000 --> 00:54:18,000
但是他做很好的一个格局性 对吧

1148
00:54:19,000 --> 00:54:23,000
所以这里我要问一个很好玩的问题

1149
00:54:23,000 --> 00:54:28,000
就是说那你们为了实现这个材料多少 Virtual Box 的坑

1150
00:54:28,000 --> 00:54:34,000
这个我想你应该也会知道 Warsha Boss 的坑就是太多太多

1151
00:54:34,000 --> 00:54:39,000
就是它的 API 很难在 MAC 上面

1152
00:54:39,000 --> 00:54:40,000
因为我们是用 Go 开发的

1153
00:54:40,000 --> 00:54:44,000
所以 Warsha Boss 的 API 很难跟 Go 去结合到一起

1154
00:54:44,000 --> 00:54:46,000
所以没办法 只能调命一个行

1155
00:54:46,000 --> 00:54:49,000
都命行的一个另外一个问题就是没办法监测

1156
00:54:49,000 --> 00:54:51,000
它的一个输出的一个结果

1157
00:54:51,000 --> 00:54:59,000
所以就是用一个一些很无奈的办法去直接解解它的输出

1158
00:54:59,000 --> 00:55:01,000
这些办法

1159
00:55:01,000 --> 00:55:05,000
另外就是不局限于 Warsha Boss 的问题

1160
00:55:05,000 --> 00:55:09,000
还有就是麦克罗兹的问题

1161
00:55:09,000 --> 00:55:10,000
因为众所都知

1162
00:55:10,000 --> 00:55:15,000
因为 Dalker 他用 Layer 的 FS

1163
00:55:16,000 --> 00:55:19,000
然后他用这个来做 Layer 的 Image

1164
00:55:19,000 --> 00:55:23,000
然后来保证足够的快

1165
00:55:23,000 --> 00:55:26,000
然后不至于说直接的拷贝

1166
00:55:26,000 --> 00:55:29,000
然后造成很大的一个时间

1167
00:55:29,000 --> 00:55:34,000
然后我们在 MAC 上其实也想了很多很多办法

1168
00:55:34,000 --> 00:55:39,000
就怎么能够达到 Layer 这种效果

1169
00:55:39,000 --> 00:55:43,000
所以居然让我们找到 Warsha Boss 居然能有这种机制

1170
00:55:44,000 --> 00:55:49,000
Warsha Boss 其实是可以做 Layer 的 Disk

1171
00:55:49,000 --> 00:55:53,000
是通过 Snapshot 的机制吗

1172
00:55:53,000 --> 00:55:54,000
其实它不太一样

1173
00:55:54,000 --> 00:55:57,000
但是也差不多类似实验机制

1174
00:55:57,000 --> 00:56:00,000
它是通过 Pirate Disk

1175
00:56:00,000 --> 00:56:02,000
其实就是 Snapshot 我觉得

1176
00:56:02,000 --> 00:56:08,000
然后通过这种方式就可以实现用 Layer 的 Disk

1177
00:56:08,000 --> 00:56:10,000
你们是这么做

1178
00:56:10,000 --> 00:56:13,000
好机制啊这个办法

1179
00:56:13,000 --> 00:56:16,000
那出来的实际的执行效率怎么样

1180
00:56:16,000 --> 00:56:19,000
因为这个可能其实因为除非你部署

1181
00:56:19,000 --> 00:56:21,000
其实大部分开发者可能还是在像

1182
00:56:21,000 --> 00:56:24,000
这个 OSC 有 Warsha Box 的方式来开发

1183
00:56:24,000 --> 00:56:26,000
对然后我们目前这种方式的话

1184
00:56:26,000 --> 00:56:32,000
大概在运行一个 Wartoo 的 DalkerImage

1185
00:56:32,000 --> 00:56:36,000
就整个下来之后你下来之后

1186
00:56:36,000 --> 00:56:39,000
运行大概在两分钟

1187
00:56:40,000 --> 00:56:44,000
就是就从 Warsha Box 讯息创建到开始期待

1188
00:56:44,000 --> 00:56:47,000
对就直接你可以直接操作

1189
00:56:47,000 --> 00:56:49,000
两分钟不到两分钟

1190
00:56:49,000 --> 00:56:50,000
不到两分钟

1191
00:56:50,000 --> 00:56:52,000
1.9 M 多毫秒

1192
00:56:52,000 --> 00:56:57,000
OK 那如果这个中间两分钟的主要是主要的花在哪里

1193
00:56:57,000 --> 00:57:04,000
主要花在了其实一部分是 Warsha Boss 本身的设备的一个讯息化

1194
00:57:04,000 --> 00:57:07,000
就是它的硬件的 Device 的一个讯息化

1195
00:57:07,000 --> 00:57:11,000
因为它就要加配置一个 Warsha Box 的虚拟机出来

1196
00:57:11,000 --> 00:57:12,000
对它这是一部分

1197
00:57:12,000 --> 00:57:15,000
然后另外一部分它就是一些硬件的虚拟化

1198
00:57:15,000 --> 00:57:18,000
就是比如我要是创建 SATA 的盘

1199
00:57:18,000 --> 00:57:21,000
那我只能创建 SATA 的 Device

1200
00:57:21,000 --> 00:57:28,000
而且 Warsha Box 只能是用 SATA 作为 HodgBug 的 Disk

1201
00:57:28,000 --> 00:57:33,000
而用 SATA 作为 HodgBug 的 Disk 的话

1202
00:57:33,000 --> 00:57:36,000
就会创建时间会比较漫长

1203
00:57:36,000 --> 00:57:38,000
所以稍微比 SARS 的要

1204
00:57:38,000 --> 00:57:42,000
因为 SARS 它不只是 HodgBug

1205
00:57:42,000 --> 00:57:44,000
所以它的机制可能会简单好多

1206
00:57:44,000 --> 00:57:49,000
所以就死后在这些方面就比较不耐

1207
00:57:49,000 --> 00:57:55,000
然后另外一个就是当然也是有 Gaussian OS 去运行

1208
00:57:55,000 --> 00:57:57,000
当然这个时间没办法

1209
00:57:57,000 --> 00:57:59,000
就我们已经极致的去优化了

1210
00:57:59,000 --> 00:58:02,000
但是相比这个还是会短短一些

1211
00:58:03,000 --> 00:58:08,000
所以其实就是说如果是在 OS 10 上开发的话

1212
00:58:08,000 --> 00:58:11,000
用 Hyper 最主要的开销就是在创建那一块

1213
00:58:11,000 --> 00:58:17,000
然后创建好了之后的启动某一个 Hyper 的虚拟机

1214
00:58:17,000 --> 00:58:20,000
还是要比在那个时刻上原生

1215
00:58:20,000 --> 00:58:22,000
部署的时候效能比较 0.3 秒

1216
00:58:22,000 --> 00:58:23,000
要慢一些

1217
00:58:23,000 --> 00:58:24,000
对是这样

1218
00:58:24,000 --> 00:58:29,000
因为它本身 Warsha Box 的机制没办法

1219
00:58:30,000 --> 00:58:34,000
OK 所以这个真的要可能要逼着你们去研究

1220
00:58:34,000 --> 00:58:37,000
新的 Hypervisor Framework 去解决这个问题

1221
00:58:37,000 --> 00:58:39,000
我们也在时刻关注这个东西

1222
00:58:39,000 --> 00:58:43,000
因为这个东西最近的观察来看

1223
00:58:43,000 --> 00:58:46,000
就是原作者可能不太忙别的

1224
00:58:46,000 --> 00:58:48,000
然后不太开放

1225
00:58:48,000 --> 00:58:50,000
不太上心这件事情

1226
00:58:50,000 --> 00:58:52,000
然后我们也在去关注

1227
00:58:52,000 --> 00:58:57,000
希望能够去做一些贡献

1228
00:58:58,000 --> 00:59:01,000
你是说 X-Hive 的那个原作者吗

1229
00:59:01,000 --> 00:59:05,000
所以现在我们大概就了解了 Hyper 的一个整个它是什么

1230
00:59:05,000 --> 00:59:12,000
然后它相对于一些我们已经熟知的一些工具的这么一个技术对比

1231
00:59:12,000 --> 00:59:14,000
它的优劣是在哪里了

1232
00:59:14,000 --> 00:59:18,000
就说我们其实可能就还在回到一个最关键的问题

1233
00:59:18,000 --> 00:59:21,000
就是说为什么我作为一个网络管理员

1234
00:59:21,000 --> 00:59:24,000
或者这个机房的一个工友云的运营者

1235
00:59:24,000 --> 00:59:25,000
我要选择 Hyper

1236
00:59:25,000 --> 00:59:26,000
对

1237
00:59:26,000 --> 00:59:29,000
所以你刚才说了一点非常关键的一点

1238
00:59:29,000 --> 00:59:31,000
就是作为工友云的管理者

1239
00:59:31,000 --> 00:59:34,000
当然作为一个相当于说

1240
00:59:34,000 --> 00:59:37,000
我就内部一个运营或者说测试环境的

1241
00:59:37,000 --> 00:59:39,000
我用 Dalker 一点问题没有

1242
00:59:39,000 --> 00:59:41,000
但是你要是用工友云的话

1243
00:59:41,000 --> 00:59:44,000
你必须要考虑它的安全性问题

1244
00:59:44,000 --> 00:59:45,000
对吧

1245
00:59:45,000 --> 00:59:48,000
然后所以就是考虑到安全性的问题

1246
00:59:48,000 --> 00:59:52,000
你就必须要考虑 Dalker

1247
00:59:52,000 --> 00:59:56,000
Dalker 他是否能怎么能够跟 VM 去结合

1248
00:59:56,000 --> 01:00:00,000
能够最大效率的去利用 BatterMantle 的机制

1249
01:00:00,000 --> 01:00:03,000
所以为什么不去尝试 Hyper 呢

1250
01:00:03,000 --> 01:00:08,000
Hyper 其实就是为你为了这种工友云的运营商

1251
01:00:08,000 --> 01:00:10,000
天然地去解决这个问题

1252
01:00:10,000 --> 01:00:15,000
你又想提供这种基于 continental 的一个管理方式

1253
01:00:15,000 --> 01:00:17,000
那个做户的管理方式

1254
01:00:17,000 --> 01:00:20,000
然后你可以用 DalkerImage

1255
01:00:20,000 --> 01:00:23,000
然后跟 Dalker 的使用完全没有异样

1256
01:00:23,000 --> 01:00:26,000
但是它的安全性会非常非常好

1257
01:00:26,000 --> 01:00:30,000
那么所以这个就是一个很很好的一个机会

1258
01:00:30,000 --> 01:00:31,000
然后去尝试

1259
01:00:31,000 --> 01:00:32,000
好

1260
01:00:32,000 --> 01:00:35,000
所以有一个 Hyper 其实我们就可以达到一个安全的

1261
01:00:35,000 --> 01:00:40,000
共有的其实一个 CasCas 就是 continental as service

1262
01:00:40,000 --> 01:00:44,000
所以我们目前也在提这个概念

1263
01:00:44,000 --> 01:00:45,000
OK

1264
01:00:45,000 --> 01:00:49,000
所以这里就很自然的过渡到我们的下一个话题

1265
01:00:49,000 --> 01:00:52,000
就是说你们的主要的客户其实并不是说

1266
01:00:52,000 --> 01:00:55,000
当然你说这个要大家熟悉的方式 API

1267
01:00:55,000 --> 01:00:57,000
肯定还是要教育用户的

1268
01:00:57,000 --> 01:01:00,000
但是说从你们这个 customer 就是谁为你们付钱

1269
01:01:00,000 --> 01:01:01,000
这件事情来讲

1270
01:01:01,000 --> 01:01:04,000
可能还是一些刚才讲的这个工友云的管理者

1271
01:01:04,000 --> 01:01:05,000
对

1272
01:01:05,000 --> 01:01:08,000
那这就牵涉到这个和一个所谓的商业模式的问题

1273
01:01:08,000 --> 01:01:10,000
就是你们这个 Hyper 这个项目

1274
01:01:10,000 --> 01:01:13,000
你们目前打算是这么去引力呢

1275
01:01:13,000 --> 01:01:17,000
我们目前其实 Hyper 这个项目主

1276
01:01:17,000 --> 01:01:20,000
还是作为开源项目为主

1277
01:01:20,000 --> 01:01:21,000
这样的话也是吸引啊

1278
01:01:21,000 --> 01:01:25,000
希望吸引能够吸引更多的 Hyper

1279
01:01:25,000 --> 01:01:29,000
或者说一些 contributor 来参与到我们那个项目

1280
01:01:29,000 --> 01:01:32,000
来共同打造一个基于 continental 的一个

1281
01:01:32,000 --> 01:01:35,000
或者是基于 pou 的一个社区

1282
01:01:35,000 --> 01:01:40,000
然后我们也是希望能够跟一些

1283
01:01:40,000 --> 01:01:46,000
一些机房或者说一些 gassv 这种的厂商去合作

1284
01:01:46,000 --> 01:01:49,000
希望能够帮助他们去提升更好的解决方案

1285
01:01:49,000 --> 01:01:54,000
因为目前我们我们成立大概半年多的时间

1286
01:01:54,000 --> 01:01:58,000
其实像国外一个比较著名的一个野儿创业公司

1287
01:01:58,000 --> 01:01:59,000
叫 Packet

1288
01:01:59,000 --> 01:02:04,000
然后他其实就是已经推出了基于 Hyper 的一个产品

1289
01:02:04,000 --> 01:02:05,000
对

1290
01:02:05,000 --> 01:02:08,000
现在有出过大家也可以去体验

1291
01:02:08,000 --> 01:02:11,000
当然可能要绑个信卡就比较比较麻烦

1292
01:02:11,000 --> 01:02:12,000
对

1293
01:02:12,000 --> 01:02:13,000
对

1294
01:02:13,000 --> 01:02:17,000
相信对于我们有足够长先精神的开发者来说

1295
01:02:17,000 --> 01:02:20,000
这不是一个特别大的难题

1296
01:02:20,000 --> 01:02:25,000
当然你可以自己在自己的平台上面去部署

1297
01:02:25,000 --> 01:02:27,000
或者是去体验当然也可以

1298
01:02:27,000 --> 01:02:32,000
然后出此之外就是跟这种厂商去合作之外

1299
01:02:32,000 --> 01:02:36,000
我们也在自己也在做基于勇气的公有运

1300
01:02:36,000 --> 01:02:38,000
就刚才说的 cass

1301
01:02:38,000 --> 01:02:41,000
对你们自己要运以一个公有运

1302
01:02:41,000 --> 01:02:42,000
对

1303
01:02:42,000 --> 01:02:46,000
其实我们目前提的一个方式叫 hyper stack

1304
01:02:46,000 --> 01:02:47,000
对 hyper stack

1305
01:02:47,000 --> 01:02:52,000
它其实是构建于 hyper 的基础上

1306
01:02:52,000 --> 01:02:56,000
然后结合目前非常流行的 cognitis

1307
01:02:56,000 --> 01:02:58,000
然后 open stack 里边的一些组件

1308
01:02:58,000 --> 01:03:01,000
比如像 sinder, newtons, and kiss-tons

1309
01:03:01,000 --> 01:03:07,000
然后将这几个组织到一起

1310
01:03:07,000 --> 01:03:10,000
然后形成一个自己的 stack

1311
01:03:10,000 --> 01:03:13,000
也是希望能够打到整个生态链

1312
01:03:13,000 --> 01:03:16,000
然后我们已经提一个 propozo

1313
01:03:16,000 --> 01:03:20,000
然后目前也在去组织人手去打造

1314
01:03:20,000 --> 01:03:21,000
OK

1315
01:03:21,000 --> 01:03:24,000
这里就涉及到最开始的一个问题

1316
01:03:24,000 --> 01:03:28,000
就是说因为当时我看你们 hyper.sh 的网站上

1317
01:03:28,000 --> 01:03:30,000
也有就是说因为只有一个英文的介绍

1318
01:03:30,000 --> 01:03:33,000
并没有中文的任何介绍

1319
01:03:33,000 --> 01:03:36,000
这跟你们商业模型和客户选择有关系

1320
01:03:36,000 --> 01:03:37,000
对

1321
01:03:37,000 --> 01:03:45,000
我们目前的一个打算就是希望能够吸引更多国外的厂商

1322
01:03:45,000 --> 01:03:51,000
然后去跟他们去竞争或者说去合作

1323
01:03:51,000 --> 01:03:58,000
然后之前的一个考练就是国内对于开源项目的支持

1324
01:03:58,000 --> 01:04:03,000
或者说合作不是特别大胆或者不是特别明显

1325
01:04:03,000 --> 01:04:07,000
所以也考虑到这些问题

1326
01:04:07,000 --> 01:04:16,000
在前期做一个创业公司可能用一种最保险或者说最妥协的办法

1327
01:04:16,000 --> 01:04:18,000
OK

1328
01:04:18,000 --> 01:04:22,000
所以其实就很面临刚才我们一个很尴尬的情况

1329
01:04:22,000 --> 01:04:26,000
就是中国网络其实并不如美国

1330
01:04:26,000 --> 01:04:32,000
从这个机房云的介绍这块是比较落后的

1331
01:04:32,000 --> 01:04:37,000
同时在我们能够数得出来的国内的一些公共云的运营者也就那么几家

1332
01:04:37,000 --> 01:04:40,000
像什么阿里云腾讯云

1333
01:04:40,000 --> 01:04:42,000
美团青云

1334
01:04:42,000 --> 01:04:45,000
美团青云以前还有京东云好像也有

1335
01:04:45,000 --> 01:04:46,000
现在还在吗

1336
01:04:46,000 --> 01:04:47,000
现在好像关闭了

1337
01:04:47,000 --> 01:04:48,000
关掉了

1338
01:04:48,000 --> 01:04:55,000
然后他们其实并没有说到了足够大胆常识这种新技术的时候

1339
01:04:55,000 --> 01:04:59,000
所以你们选择先去开拓海外市场

1340
01:04:59,000 --> 01:05:05,000
然后等在验证好模式和技术成熟之后再想办法

1341
01:05:05,000 --> 01:05:10,000
能不能够国内的这些云厂商也能够或者说出一些新的小的云厂商

1342
01:05:10,000 --> 01:05:13,000
也能够采用 hyper 技术

1343
01:05:13,000 --> 01:05:19,000
所以你们在海外的目前的一些合作伙伴就刚才提到除了 Packet

1344
01:05:19,000 --> 01:05:24,000
也是一个比较新和比较酷的公共云的运营商之外

1345
01:05:24,000 --> 01:05:27,000
还有哪些是你们在目前是在有深度合作

1346
01:05:27,000 --> 01:05:32,000
我们现在比较合作比较多的像 Zen 的 Dewyper

1347
01:05:32,000 --> 01:05:36,000
Mentender 和 Dewyper 我们都有非常多的接触

1348
01:05:36,000 --> 01:05:42,000
然后之前参加了 Zen 的 Dewyper 三密然后去跟他们去交给我

1349
01:05:42,000 --> 01:05:47,000
他们也非常支持 hyper 对 Zen 的一个支持

1350
01:05:47,000 --> 01:05:56,000
希望能够去共同探讨能够把这个性能或者说体验做到足够的好

1351
01:05:56,000 --> 01:06:01,000
所以 Zen 还是说是我们一个非常重要的 Panther

1352
01:06:01,000 --> 01:06:05,000
然后他们对我们在底层技术上面的一个

1353
01:06:05,000 --> 01:06:09,000
或者说在 hyperwise 上面的支持还是挺多的

1354
01:06:09,000 --> 01:06:16,000
明白 所以还是一个非常值得让人激动的一个合作

1355
01:06:16,000 --> 01:06:21,000
因为是认识我们一个很非常传统的训练器的 hypervisor

1356
01:06:21,000 --> 01:06:24,000
我记得好像 AWS 就是基于 Zen 做的

1357
01:06:24,000 --> 01:06:28,000
对 现在是一个非常技术

1358
01:06:28,000 --> 01:06:33,000
刚刚我们讲完了 hyper 产品包括你的商量模式

1359
01:06:33,000 --> 01:06:39,000
其实我个人最关心的一个领域就是团队

1360
01:06:39,000 --> 01:06:44,000
三门你可以大概介绍一下你们现在做 hyperteam 大概什么样的情况吗

1361
01:06:44,000 --> 01:06:47,000
我们现在的开发者是五个人

1362
01:06:47,000 --> 01:06:50,000
五个人这么小

1363
01:06:50,000 --> 01:06:53,000
所以每天还是挺忙碌的

1364
01:06:54,000 --> 01:06:58,000
然后一个人做负责 hypercyclic 相关的东西

1365
01:06:58,000 --> 01:07:02,000
另外就是主要集中在 hyper 的核心产品

1366
01:07:02,000 --> 01:07:08,000
足够就是 synafisher 的开发以及 fix 一些 bug

1367
01:07:08,000 --> 01:07:13,000
然后因为毕竟开源代码也是希望能够让代码质量足够的优质

1368
01:07:13,000 --> 01:07:20,000
对 然后另外有三个人主要是负责 bd 相关的东西

1369
01:07:20,000 --> 01:07:24,000
然后做一些 因为毕竟还是海外市场

1370
01:07:24,000 --> 01:07:30,000
所以我们有一些乖的朋友然后去帮忙退或者支持这些东西

1371
01:07:30,000 --> 01:07:35,000
所以整个团队其实加起来也不超过 10 个人吧

1372
01:07:35,000 --> 01:07:39,000
非常非常小 然后惊悍的一个团队

1373
01:07:39,000 --> 01:07:43,000
但是我们的团队还是 战斗力还是挺强的

1374
01:07:43,000 --> 01:07:48,000
OK 所以当初你是怎么加入到这个团队里面去的

1375
01:07:48,000 --> 01:07:51,000
因为当时其实还是刀块还是挺火的

1376
01:07:51,000 --> 01:07:57,000
我也对虚拟化 因为我毕竟之前是做存储的

1377
01:07:57,000 --> 01:08:00,000
但是我对虚拟化的这块还是比较感兴趣

1378
01:08:00,000 --> 01:08:04,000
所以希望能够进入到这个领域吧

1379
01:08:04,000 --> 01:08:09,000
然后看到网上有一个招聘吧

1380
01:08:09,000 --> 01:08:14,000
然后大概可能一个想做一个基于虚拟化

1381
01:08:14,000 --> 01:08:17,000
或者基于一个容器的一个 OS

1382
01:08:17,000 --> 01:08:20,000
然后也想深入的去了解一下

1383
01:08:20,000 --> 01:08:23,000
大概就认识了 然后就了解了解了解

1384
01:08:23,000 --> 01:08:29,000
当然随着社区的变化或者说现在的变化

1385
01:08:29,000 --> 01:08:32,000
可能当时的想法慢慢再调整

1386
01:08:32,000 --> 01:08:36,000
然后也做出了现在的产品

1387
01:08:36,000 --> 01:08:40,000
所以你是在哪里看到他们的招聘广告的

1388
01:08:40,000 --> 01:08:42,000
是在 V 2 EX

1389
01:08:42,000 --> 01:08:48,000
V 2 EX 跟我们节目的关系还是挺密切的

1390
01:08:48,000 --> 01:08:51,000
因为我们每期节目都会上面发我们的节目介绍和连接

1391
01:08:51,000 --> 01:08:57,000
然后 V 2 EX 的 Livet 也非常很 nice 的给我免费在

1392
01:08:57,000 --> 01:09:01,000
那个 podcast 的分类里面加了一个测览的广告

1393
01:09:01,000 --> 01:09:03,000
也非常感谢他们

1394
01:09:03,000 --> 01:09:08,000
对 这个也是国内一个比较好的程序

1395
01:09:08,000 --> 01:09:10,000
开发者的一个社区

1396
01:09:10,000 --> 01:09:13,000
对 其实你在上面能找到他们也是

1397
01:09:13,000 --> 01:09:15,000
其实你是意料之内

1398
01:09:15,000 --> 01:09:18,000
对 然后其实之前就一直在关注

1399
01:09:18,000 --> 01:09:22,000
没想到就在那去节员了

1400
01:09:22,000 --> 01:09:25,000
这个还是机缘巧合的事

1401
01:09:25,000 --> 01:09:28,000
对 大家是多混这个社区会比较好

1402
01:09:28,000 --> 01:09:30,000
对 其实这圈子还是挺小的

1403
01:09:30,000 --> 01:09:34,000
OK 所以你们现在这么一个小五个人的开发团队

1404
01:09:34,000 --> 01:09:36,000
你们这个工作模式大概是怎么样子的呢

1405
01:09:37,000 --> 01:09:40,000
我们现在的工作模式大概就是

1406
01:09:40,000 --> 01:09:44,000
相当于我们五个开发团队的团队

1407
01:09:44,000 --> 01:09:48,000
然后分布在南京 上海 北京

1408
01:09:48,000 --> 01:09:50,000
然后其实是一个相当于

1409
01:09:50,000 --> 01:09:52,000
Rainwater Walk 的一个工作方式

1410
01:09:52,000 --> 01:09:55,000
大家平常沟通就是 Tagram

1411
01:09:55,000 --> 01:09:58,000
以及 Train-O 的一个方式

1412
01:09:58,000 --> 01:10:01,000
所以其实你们五个人并不是在一个地方的

1413
01:10:01,000 --> 01:10:03,000
对 不是在一个地方

1414
01:10:03,000 --> 01:10:04,000
然后你们都是在

1415
01:10:04,000 --> 01:10:06,000
那你们会在家里工作吗

1416
01:10:06,000 --> 01:10:07,000
还是去到哪里办公

1417
01:10:07,000 --> 01:10:09,000
主要还是在家里办公

1418
01:10:09,000 --> 01:10:12,000
然后这样的话节省一些交通上的

1419
01:10:12,000 --> 01:10:14,000
时间的成本吧

1420
01:10:14,000 --> 01:10:15,000
对 好爽的

1421
01:10:15,000 --> 01:10:17,000
因为其实我说每个人

1422
01:10:17,000 --> 01:10:19,000
可能最高效的时段是不一样的

1423
01:10:19,000 --> 01:10:20,000
然后浪费在交通上

1424
01:10:20,000 --> 01:10:22,000
真的是应该非常让人不爽的事情

1425
01:10:22,000 --> 01:10:24,000
对 优秀性

1426
01:10:24,000 --> 01:10:27,000
像我在北京这种城市这么大

1427
01:10:27,000 --> 01:10:29,000
然后人籍人的这种

1428
01:10:29,000 --> 01:10:32,000
真是有点难受

1429
01:10:32,000 --> 01:10:34,000
所有的写代码的灵感和激情

1430
01:10:34,000 --> 01:10:36,000
都磨灭在了公交车上

1431
01:10:36,000 --> 01:10:37,000
对

1432
01:10:37,000 --> 01:10:40,000
所以当然远程办公

1433
01:10:40,000 --> 01:10:43,000
其实是当然也是比较吸引我的

1434
01:10:43,000 --> 01:10:44,000
方式

1435
01:10:44,000 --> 01:10:46,000
大家希望能够更高效的

1436
01:10:46,000 --> 01:10:48,000
去利用时间吧

1437
01:10:48,000 --> 01:10:49,000
OK

1438
01:10:49,000 --> 01:10:51,000
所以你们五个人在远程工作中

1439
01:10:51,000 --> 01:10:53,000
你刚刚提到了有 Tagram

1440
01:10:53,000 --> 01:10:54,000
这个用来试试

1441
01:10:54,000 --> 01:10:56,000
这个是群组聊天对吧

1442
01:10:56,000 --> 01:10:57,000
对

1443
01:10:57,000 --> 01:10:58,000
然后还有一样

1444
01:10:58,000 --> 01:11:00,000
是用什么工具来的

1445
01:11:00,000 --> 01:11:01,000
Train-O

1446
01:11:01,000 --> 01:11:02,000
Train-O

1447
01:11:02,000 --> 01:11:03,000
Train-O

1448
01:11:03,000 --> 01:11:04,000
Train-O 做那个协作

1449
01:11:04,000 --> 01:11:05,000
对 协作

1450
01:11:05,000 --> 01:11:07,000
对 所以你们像代码管理

1451
01:11:07,000 --> 01:11:09,000
还有其他一些工具大概是

1452
01:11:09,000 --> 01:11:10,000
会用到哪些呢

1453
01:11:10,000 --> 01:11:12,000
代码管理的话

1454
01:11:12,000 --> 01:11:13,000
就是 GitHub

1455
01:11:13,000 --> 01:11:14,000
对

1456
01:11:14,000 --> 01:11:15,000
然后我们之前是

1457
01:11:15,000 --> 01:11:18,000
发布之前是 Private repo

1458
01:11:18,000 --> 01:11:19,000
然后现在是公开

1459
01:11:19,000 --> 01:11:22,000
大家也可以去我们的官网上

1460
01:11:22,000 --> 01:11:24,000
以及去 GitHub 的网页上

1461
01:11:24,000 --> 01:11:26,000
去关注我们的项目

1462
01:11:26,000 --> 01:11:27,000
多多点赞

1463
01:11:27,000 --> 01:11:28,000
OK

1464
01:11:28,000 --> 01:11:29,000
项目的地址

1465
01:11:29,000 --> 01:11:30,000
还有包括 GitHub 的地址

1466
01:11:30,000 --> 01:11:31,000
我们会稍后放到这个

1467
01:11:31,000 --> 01:11:32,000
虚拟字里面

1468
01:11:32,000 --> 01:11:33,000
大家就可以看

1469
01:11:33,000 --> 01:11:35,000
这里其实可以接着聊一下

1470
01:11:35,000 --> 01:11:38,000
就是你们在 GitHub

1471
01:11:38,000 --> 01:11:39,000
上面协作的模式

1472
01:11:39,000 --> 01:11:40,000
你们是一个

1473
01:11:40,000 --> 01:11:42,000
会说一个什么样过程的

1474
01:11:42,000 --> 01:11:44,000
可以大概聊说一下吗

1475
01:11:44,000 --> 01:11:46,000
目前的过程

1476
01:11:46,000 --> 01:11:48,000
就是相当于

1477
01:11:48,000 --> 01:11:49,000
已经过往之前的

1478
01:11:49,000 --> 01:11:50,000
风靡开发的一个过程

1479
01:11:50,000 --> 01:11:51,000
所以现在的

1480
01:11:51,000 --> 01:11:54,000
近派式的模式

1481
01:11:54,000 --> 01:11:58,000
还是跟比较正规

1482
01:11:58,000 --> 01:12:00,000
然后有个派式的话

1483
01:12:00,000 --> 01:12:01,000
是 TPR

1484
01:12:01,000 --> 01:12:04,000
然后一到两个人去留有

1485
01:12:04,000 --> 01:12:06,000
如果没问题的话

1486
01:12:06,000 --> 01:12:08,000
才可以莫指

1487
01:12:08,000 --> 01:12:09,000
这样的话就保证了

1488
01:12:09,000 --> 01:12:12,000
质量以及效率

1489
01:12:12,000 --> 01:12:14,000
然后会有一些

1490
01:12:14,000 --> 01:12:16,000
第三方的工具

1491
01:12:16,000 --> 01:12:18,000
就是我们会写

1492
01:12:18,000 --> 01:12:19,000
写了一些脚本

1493
01:12:19,000 --> 01:12:20,000
当然没有

1494
01:12:20,000 --> 01:12:22,000
也在不断的完善过程中

1495
01:12:22,000 --> 01:12:26,000
希望能够在有 PR 的时候

1496
01:12:26,000 --> 01:12:28,000
出发一些自动化的

1497
01:12:28,000 --> 01:12:30,000
检测的那些工具

1498
01:12:30,000 --> 01:12:31,000
OK

1499
01:12:31,000 --> 01:12:32,000
所以就大致来说

1500
01:12:32,000 --> 01:12:33,000
还是一个标准的

1501
01:12:33,000 --> 01:12:35,000
GitHub 开面项目的流程

1502
01:12:35,000 --> 01:12:36,000
对

1503
01:12:36,000 --> 01:12:37,000
通过 PR 驱动

1504
01:12:37,000 --> 01:12:40,000
这个 feature 还有 bugfix

1505
01:12:40,000 --> 01:12:42,000
然后进行

1506
01:12:42,000 --> 01:12:44,000
就比经典的 CodeReview

1507
01:12:44,000 --> 01:12:45,000
然后再莫指讲

1508
01:12:45,000 --> 01:12:46,000
QA 这块

1509
01:12:46,000 --> 01:12:47,000
你说你们还没有

1510
01:12:47,000 --> 01:12:49,000
做完全自动化的 QA 是吧

1511
01:12:49,000 --> 01:12:50,000
对

1512
01:12:50,000 --> 01:12:52,000
还没有做完全自动化的 QA

1513
01:12:52,000 --> 01:12:54,000
但是就是手动化的测试

1514
01:12:54,000 --> 01:12:56,000
都会做这是标配

1515
01:12:56,000 --> 01:12:59,000
然后因为 Go 本身做过

1516
01:12:59,000 --> 01:13:00,000
Tata 有 Unitess

1517
01:13:00,000 --> 01:13:01,000
所以这个的话

1518
01:13:01,000 --> 01:13:03,000
因为当时开发时间比较紧

1519
01:13:03,000 --> 01:13:05,000
然后我们这个

1520
01:13:05,000 --> 01:13:07,000
有的一些 component

1521
01:13:07,000 --> 01:13:08,000
可能没有太完善

1522
01:13:08,000 --> 01:13:10,000
所以这个也不断完善

1523
01:13:10,000 --> 01:13:12,000
就这个可能需要

1524
01:13:12,000 --> 01:13:13,000
也就你们一个

1525
01:13:13,000 --> 01:13:14,000
一方面你们自己努力

1526
01:13:14,000 --> 01:13:16,000
另外就是看能不能开完社区

1527
01:13:16,000 --> 01:13:17,000
能贡献一些了

1528
01:13:17,000 --> 01:13:18,000
对

1529
01:13:18,000 --> 01:13:21,000
因为我们的人手实在是太少

1530
01:13:21,000 --> 01:13:23,000
有意思

1531
01:13:23,000 --> 01:13:24,000
这里刚才你也提到了

1532
01:13:24,000 --> 01:13:26,000
这个 hyper 跟 darker

1533
01:13:26,000 --> 01:13:28,000
都是基于用购物源开发的

1534
01:13:28,000 --> 01:13:31,000
当初你们为什么选择用购物源

1535
01:13:31,000 --> 01:13:33,000
我们之前选择的购物源

1536
01:13:33,000 --> 01:13:38,000
其实也是考虑到了

1537
01:13:38,000 --> 01:13:40,000
跟 darker 的一个关系

1538
01:13:40,000 --> 01:13:43,000
因为就拋开购物源

1539
01:13:43,000 --> 01:13:44,000
本身的一些特性

1540
01:13:44,000 --> 01:13:45,000
比如并发

1541
01:13:45,000 --> 01:13:48,000
它的高效的开发的等等一些特性

1542
01:13:48,000 --> 01:13:50,000
另外一方面就是

1543
01:13:50,000 --> 01:13:52,000
我们其实最开始的版本

1544
01:13:52,000 --> 01:13:54,000
是基于 darker demon 来做的

1545
01:13:54,000 --> 01:13:58,000
然后因为 darker demon 会

1546
01:13:58,000 --> 01:14:02,000
因为我们用到 darker demon 去铺

1547
01:14:02,000 --> 01:14:05,000
它的 darker 的 image

1548
01:14:05,000 --> 01:14:06,000
来铺下来

1549
01:14:06,000 --> 01:14:09,000
然后去把这个文件

1550
01:14:09,000 --> 01:14:11,000
全部传给 hypervisor

1551
01:14:11,000 --> 01:14:13,000
这个过程中的可能用购物源

1552
01:14:13,000 --> 01:14:15,000
直接跟 darker demon 去交互

1553
01:14:15,000 --> 01:14:17,000
这样的话是更省事

1554
01:14:17,000 --> 01:14:18,000
更简单

1555
01:14:18,000 --> 01:14:19,000
对

1556
01:14:19,000 --> 01:14:20,000
对

1557
01:14:20,000 --> 01:14:22,000
所以但是随着后来

1558
01:14:22,000 --> 01:14:25,000
我们移除了 darker demon 的一个应案

1559
01:14:25,000 --> 01:14:29,000
其实用其他源当然也可以

1560
01:14:29,000 --> 01:14:31,000
可能历史原因问题

1561
01:14:31,000 --> 01:14:34,000
就是我们继续沿用了购物源

1562
01:14:34,000 --> 01:14:35,000
OK

1563
01:14:35,000 --> 01:14:37,000
所以其实你们在使用购物源

1564
01:14:37,000 --> 01:14:39,000
这个 hypervisor 过程中

1565
01:14:39,000 --> 01:14:41,000
你们遇到了什么样的问题

1566
01:14:41,000 --> 01:14:43,000
或者有什么心得可以分享吗

1567
01:14:43,000 --> 01:14:46,000
其实购物源还是

1568
01:14:46,000 --> 01:14:48,000
从语法上还是有些坑的

1569
01:14:48,000 --> 01:14:50,000
比如说

1570
01:14:50,000 --> 01:14:53,000
比如说写购写时间长

1571
01:14:53,000 --> 01:14:56,000
写 c 都不加分号

1572
01:14:56,000 --> 01:14:58,000
这个是好事

1573
01:14:58,000 --> 01:15:01,000
好吧

1574
01:15:01,000 --> 01:15:04,000
然后另外一些可能就是

1575
01:15:04,000 --> 01:15:05,000
本身购源

1576
01:15:05,000 --> 01:15:08,000
因为它刚最近刚发布的是 1.6

1577
01:15:08,000 --> 01:15:10,000
还是之前是 1.5

1578
01:15:10,000 --> 01:15:11,000
对 1.5

1579
01:15:11,000 --> 01:15:13,000
然后 1.5 的一个版本

1580
01:15:13,000 --> 01:15:15,000
它其实有一些东西

1581
01:15:15,000 --> 01:15:17,000
还是做得不够完善的

1582
01:15:17,000 --> 01:15:19,000
然后我们这过程中也是

1583
01:15:19,000 --> 01:15:20,000
踩个不少坑

1584
01:15:20,000 --> 01:15:22,000
然后用其他方式去转换

1585
01:15:22,000 --> 01:15:25,000
但是可能效率上面不如那个有优势

1586
01:15:25,000 --> 01:15:26,000
但是这个可能就是

1587
01:15:26,000 --> 01:15:28,000
OS 相关的东西

1588
01:15:28,000 --> 01:15:30,000
比如在 mine 上面的一些特性

1589
01:15:30,000 --> 01:15:31,000
它是

1590
01:15:31,000 --> 01:15:33,000
是调用内核的一些东西还是吗

1591
01:15:33,000 --> 01:15:36,000
syscall 的东西

1592
01:15:36,000 --> 01:15:38,000
支持的不够完整

1593
01:15:38,000 --> 01:15:41,000
然后所以就必须用其他一种

1594
01:15:41,000 --> 01:15:45,000
更加 tricky 的方式去做

1595
01:15:45,000 --> 01:15:46,000
明白

1596
01:15:46,000 --> 01:15:47,000
对

1597
01:15:47,000 --> 01:15:49,000
所以其实像 hyper 除了用

1598
01:15:49,000 --> 01:15:50,000
够语言写大部分之外

1599
01:15:50,000 --> 01:15:53,000
你还用到其他语言去编写

1600
01:15:53,000 --> 01:15:55,000
其他一些小部分的功能吗

1601
01:15:55,000 --> 01:15:57,000
还是说是一个纯够的一个项目

1602
01:15:57,000 --> 01:16:01,000
我们在 guysOS 里面是 syscall 的东西

1603
01:16:01,000 --> 01:16:03,000
那部分是

1604
01:16:03,000 --> 01:16:07,000
需要做的哪些工作是必须要用 syscall 来完成的

1605
01:16:07,000 --> 01:16:09,000
其实也不是说必须要用 syscall 来完成

1606
01:16:09,000 --> 01:16:11,000
只不过用 syscall 可能效率更快

1607
01:16:11,000 --> 01:16:12,000
guysOS 里面

1608
01:16:12,000 --> 01:16:15,000
它其实就是一个

1609
01:16:16,000 --> 01:16:20,000
增相当于修改过的 init

1610
01:16:20,000 --> 01:16:21,000
init 的程序

1611
01:16:21,000 --> 01:16:24,000
然后它是可以解析 json 格式

1612
01:16:24,000 --> 01:16:25,000
因为它这样

1613
01:16:25,000 --> 01:16:29,000
这样的话是通过 json 的信消息

1614
01:16:29,000 --> 01:16:32,000
来跟 hyperdm 去交互

1615
01:16:32,000 --> 01:16:34,000
达到一个传输数据

1616
01:16:34,000 --> 01:16:36,000
或者是通信的效果

1617
01:16:36,000 --> 01:16:37,000
这个有点意思

1618
01:16:37,000 --> 01:16:39,000
就是你们 guysOS 里面

1619
01:16:39,000 --> 01:16:42,000
还有一个自己定义的 init 程序

1620
01:16:42,000 --> 01:16:45,000
这个好像现在好像比较常见的

1621
01:16:45,000 --> 01:16:47,000
是什么 systemd 对吧

1622
01:16:47,000 --> 01:16:48,000
所以比较重吗

1623
01:16:48,000 --> 01:16:49,000
是什么原因

1624
01:16:49,000 --> 01:16:51,000
对可能速度比较快

1625
01:16:51,000 --> 01:16:52,000
对

1626
01:16:52,000 --> 01:16:54,000
速度比较重

1627
01:16:54,000 --> 01:16:58,000
然后我们这样用启动速度会很慢

1628
01:16:58,000 --> 01:17:01,000
然后我们当时测的时候

1629
01:17:01,000 --> 01:17:03,000
大概十几兆或

1630
01:17:03,000 --> 01:17:07,000
应该是二十几兆的那个空的 meme

1631
01:17:07,000 --> 01:17:08,000
也就够

1632
01:17:08,000 --> 01:17:09,000
对

1633
01:17:09,000 --> 01:17:11,000
所以就足够的精简

1634
01:17:11,000 --> 01:17:13,000
就是现在一个 hyperdm

1635
01:17:13,000 --> 01:17:15,000
gassvm 用你们自定义这一套东西

1636
01:17:15,000 --> 01:17:17,000
就一二十兆就可以起一个了对吧

1637
01:17:17,000 --> 01:17:19,000
对应该是二十多兆

1638
01:17:19,000 --> 01:17:20,000
十一兆是够的

1639
01:17:20,000 --> 01:17:22,000
相对于很多什么特别是它跑

1640
01:17:22,000 --> 01:17:24,000
他们 tomcat 这些加碼也有一上来

1641
01:17:24,000 --> 01:17:26,000
都一两个 G 的那层站

1642
01:17:26,000 --> 01:17:27,000
对

1643
01:17:27,000 --> 01:17:30,000
当然我们说它是一个最简陌式

1644
01:17:30,000 --> 01:17:31,000
对

1645
01:17:31,000 --> 01:17:32,000
这是一个

1646
01:17:32,000 --> 01:17:34,000
我就说这种一二十兆的开销

1647
01:17:34,000 --> 01:17:36,000
基本上可以在现代机上可以忽略了吧

1648
01:17:36,000 --> 01:17:37,000
对

1649
01:17:37,000 --> 01:17:38,000
还是挺好的

1650
01:17:38,000 --> 01:17:39,000
挺好的

1651
01:17:39,000 --> 01:17:42,000
最后补充的就是希望大家有志于

1652
01:17:42,000 --> 01:17:44,000
加入我们 hyper 项目的

1653
01:17:44,000 --> 01:17:47,000
能够多多为我们提 PR

1654
01:17:47,000 --> 01:17:50,000
我们也会非常也会非常积极的反馈

1655
01:17:50,000 --> 01:17:55,000
如果有同学 tpr 或者说被我们接受的话

1656
01:17:55,000 --> 01:17:57,000
我们在初期前 100 人

1657
01:17:57,000 --> 01:18:01,000
应该会提供 t-shirt 作为奖励

1658
01:18:01,000 --> 01:18:03,000
就是我就是之前 reel

1659
01:18:03,000 --> 01:18:06,000
之前在推特上面传的过的那个 t-shirt

1660
01:18:07,000 --> 01:18:08,000
对

1661
01:18:08,000 --> 01:18:13,000
之前我在北京跟 Simon 见面面聊过

1662
01:18:13,000 --> 01:18:16,000
非常后言无耻地要了一家

1663
01:18:16,000 --> 01:18:17,000
没没没

1664
01:18:17,000 --> 01:18:21,000
这个也是感谢 reel 帮我们去大业的宣传

1665
01:18:21,000 --> 01:18:23,000
然后也是希望能更多的开发者

1666
01:18:23,000 --> 01:18:25,000
去接触到开源社区

1667
01:18:25,000 --> 01:18:27,000
接触到开源项目

1668
01:18:27,000 --> 01:18:30,000
然后更多更更

1669
01:18:30,000 --> 01:18:31,000
就是怎么说呢

1670
01:18:31,000 --> 01:18:35,000
就是一个提升一个自身素质加了一个

1671
01:18:35,000 --> 01:18:37,000
写代码公益的一个水平

1672
01:18:37,000 --> 01:18:38,000
对

1673
01:18:38,000 --> 01:18:39,000
对非常感谢

1674
01:18:39,000 --> 01:18:40,000
因为其实

1675
01:18:40,000 --> 01:18:42,000
因为这次我要请三们来做这些节目

1676
01:18:42,000 --> 01:18:44,000
也是因为我觉得 hyper 是我见过的

1677
01:18:44,000 --> 01:18:48,000
就是国人做的开源项目里面

1678
01:18:48,000 --> 01:18:50,000
还比较让我惊艳的一个

1679
01:18:50,000 --> 01:18:52,000
所以我也希望借这个机会

1680
01:18:52,000 --> 01:18:53,000
让要求到

1681
01:18:53,000 --> 01:18:54,000
就是让他让更多人了解他

1682
01:18:54,000 --> 01:18:55,000
知道他

1683
01:18:55,000 --> 01:18:57,000
然后能够去参与到开发

1684
01:18:57,000 --> 01:18:59,000
让我们中国的开源项目

1685
01:18:59,000 --> 01:19:01,000
能够有一个好的

1686
01:19:01,000 --> 01:19:04,000
这边一个上涨的趋势吧

1687
01:19:04,000 --> 01:19:05,000
对

1688
01:19:05,000 --> 01:19:07,000
然后另外一点

1689
01:19:07,000 --> 01:19:11,000
如果大家不觉得 TPR 不爽的话

1690
01:19:11,000 --> 01:19:14,000
也是非常希望大家能够加入到我们团队

1691
01:19:14,000 --> 01:19:18,000
我们团队也是拥有非常多的牛人

1692
01:19:18,000 --> 01:19:21,000
然后多年的 Kernel 的工程师

1693
01:19:21,000 --> 01:19:24,000
以及特别自身的 consultant

1694
01:19:24,000 --> 01:19:26,000
都都都在我们团队

1695
01:19:26,000 --> 01:19:29,000
所以如果大家有一级之长

1696
01:19:29,000 --> 01:19:33,000
或者说有志于做 hyperstike

1697
01:19:33,000 --> 01:19:34,000
hyper 项目的

1698
01:19:34,000 --> 01:19:39,000
希望大家能够积极给我们提 TPR

1699
01:19:39,000 --> 01:19:40,000
或者是发奖励

1700
01:19:40,000 --> 01:19:41,000
谢谢

1701
01:19:41,000 --> 01:19:44,000
想不到 B 节目还做了一个裂头的工作

1702
01:19:46,000 --> 01:19:47,000
非常好玩

1703
01:19:48,000 --> 01:19:50,000
OK 今天的节目就先到这里

1704
01:19:50,000 --> 01:19:52,000
感谢收看 IPN podcast

1705
01:19:52,000 --> 01:19:53,000
网络之下的 IT 技术

1706
01:19:53,000 --> 01:19:55,000
主题娱乐节目内核恐慌

1707
01:19:55,000 --> 01:19:57,000
我们号称 Hotcore

1708
01:19:57,000 --> 01:19:58,000
但也没有干货

1709
01:19:58,000 --> 01:20:00,000
但是这期干货还是满满的

1710
01:20:00,000 --> 01:20:01,000
想听的人听

1711
01:20:01,000 --> 01:20:02,000
不想听的人就别听

1712
01:20:02,000 --> 01:20:03,000
你可以问问

1713
01:20:03,000 --> 01:20:04,000
本节目捐款

1714
01:20:04,000 --> 01:20:08,000
捐款即使 IPN.li.cernalpanic.select.net

1715
01:20:08,000 --> 01:20:10,000
捐款进而随意

1716
01:20:10,000 --> 01:20:12,000
只要是能被 8 整出的正整说就可以

1717
01:20:12,000 --> 01:20:14,000
捐款不会给你带来什么

1718
01:20:14,000 --> 01:20:16,000
不捐也不会让你失去什么

1719
01:20:16,000 --> 01:20:19,000
我们的口号是 hyperishyperawesome

1720
01:20:19,000 --> 01:20:20,000
如果你有任何反馈

1721
01:20:20,000 --> 01:20:24,000
可以发电子邮件到 cernalpanic.ipn.li

1722
01:20:24,000 --> 01:20:27,000
同时也欢迎你收听 IPN 旗下集

1723
01:20:27,000 --> 01:20:29,000
其他几档节目

1724
01:20:29,000 --> 01:20:30,000
IT 公论

1725
01:20:30,000 --> 01:20:31,000
未知道

1726
01:20:31,000 --> 01:20:32,000
太医来了

1727
01:20:32,000 --> 01:20:33,000
流行通信

1728
01:20:33,000 --> 01:20:34,000
History

1729
01:20:34,000 --> 01:20:35,000
博物志

1730
01:20:35,000 --> 01:20:36,000
选美

1731
01:20:36,000 --> 01:20:37,000
我们下期再会

