1
00:00:00,000 --> 00:00:05,000
欢迎收听 ipnpodcast 的网络旗下的 IT 技术主题娱乐节目内核恐慌

2
00:00:05,000 --> 00:00:08,000
我们号称 Hardcore 但是也没有干货

3
00:00:08,000 --> 00:00:10,000
想听人听不想听的人就别听

4
00:00:10,000 --> 00:00:14,000
内核恐慌的网址是 ipn.ly-cernopanic

5
00:00:14,000 --> 00:00:17,000
我们推荐大家使用 podcast 客户端订阅节目

6
00:00:17,000 --> 00:00:20,000
如果您不知道该使用哪种客户端

7
00:00:20,000 --> 00:00:23,000
欢迎访问 ipn.ly-fak

8
00:00:23,000 --> 00:00:26,000
也同样欢迎你为我们的节目捐款

9
00:00:26,000 --> 00:00:32,000
捐款地址是 ipn.ly-cernopanic-donate

10
00:00:32,000 --> 00:00:36,000
捐款金和隋义只要是能被 8 整出的正正数就可以

11
00:00:36,000 --> 00:00:37,000
捐款不会为你带来什么

12
00:00:37,000 --> 00:00:38,000
不捐也不会忘了

13
00:00:38,000 --> 00:00:40,000
不会让你失去什么

14
00:00:40,000 --> 00:00:44,000
我们的口号是 no hard feelings

15
00:00:44,000 --> 00:00:47,000
所以我们今天是第 27

16
00:00:47,000 --> 00:00:49,000
居然都已经 27 了

17
00:00:49,000 --> 00:00:52,000
一晃已经过去 40 周了

18
00:00:52,000 --> 00:00:53,000
小半年

19
00:00:53,000 --> 00:00:56,000
不对大半年了快一年了

20
00:00:56,000 --> 00:00:59,000
对还是做一些简单的 follow up

21
00:01:01,000 --> 00:01:04,000
对我们两个人今天状态都不太好

22
00:01:04,000 --> 00:01:06,000
状况都不太正常

23
00:01:06,000 --> 00:01:08,000
一个是不停的打分类

24
00:01:08,000 --> 00:01:09,000
另一个得言言

25
00:01:09,000 --> 00:01:11,000
基本上说话一块就会渴走

26
00:01:12,000 --> 00:01:16,000
所以我们今天可能就不会讲太多的话

27
00:01:16,000 --> 00:01:22,000
但应该会跳过新闻大人吧

28
00:01:23,000 --> 00:01:24,000
就从 follow up 开始

29
00:01:26,000 --> 00:01:27,000
对所以 follow up 之前

30
00:01:27,000 --> 00:01:34,000
先说一下上周我们找听众帮我们去排查

31
00:01:34,000 --> 00:01:36,000
那个为什么下载会出错那个问题吗

32
00:01:36,000 --> 00:01:37,000
你还记得吗

33
00:01:37,000 --> 00:01:38,000
对对

34
00:01:38,000 --> 00:01:42,000
我们现在终于找到了一个先活的案例

35
00:01:42,000 --> 00:01:48,000
对有一位非常热心的听众极端及时的小门

36
00:01:48,000 --> 00:01:51,000
爆出了 bug 的

37
00:01:51,000 --> 00:01:53,000
怎么说呢

38
00:01:53,000 --> 00:01:55,000
这位同学遇到了 bug

39
00:01:55,000 --> 00:01:57,000
然后及时给我们写了邮件

40
00:01:57,000 --> 00:02:00,000
并且我们趁 bug 还先活的时候

41
00:02:00,000 --> 00:02:02,000
给他捉住了

42
00:02:02,000 --> 00:02:04,000
对在他那里

43
00:02:04,000 --> 00:02:07,000
一使了一个 curl 的病因

44
00:02:07,000 --> 00:02:10,000
然后及时发现了 bug 的所在

45
00:02:10,000 --> 00:02:13,000
所以要解释一下是成因吗

46
00:02:13,000 --> 00:02:15,000
对我这肯定要解释一下

47
00:02:15,000 --> 00:02:17,000
好不容易捉住一个窗子

48
00:02:17,000 --> 00:02:18,000
对了

49
00:02:18,000 --> 00:02:20,000
简单来讲是这样

50
00:02:20,000 --> 00:02:24,000
国内的部分运营商

51
00:02:24,000 --> 00:02:27,000
但这里部分运营商主要是以长城宽带这种

52
00:02:29,000 --> 00:02:31,000
这种叫什么来的

53
00:02:32,000 --> 00:02:34,000
二刀犯子运营商为主

54
00:02:34,000 --> 00:02:34,000
对

55
00:02:34,000 --> 00:02:35,000
然后他们

56
00:02:35,000 --> 00:02:37,000
south contract

57
00:02:37,000 --> 00:02:41,000
对他们为了减缓他们网络的压力

58
00:02:41,000 --> 00:02:43,000
因为他们买的带宽也有限

59
00:02:43,000 --> 00:02:46,000
然后他们自己在内部做了一个缓存

60
00:02:46,000 --> 00:02:47,000
凡是你下载一些比较

61
00:02:47,000 --> 00:02:49,000
就通过 HTCP 协议

62
00:02:49,000 --> 00:02:51,000
下载了一些比较大型的文件

63
00:02:51,000 --> 00:02:56,000
他们会在他们内部的一个服务器上缓存下来

64
00:02:56,000 --> 00:02:56,000
这样的话

65
00:02:56,000 --> 00:03:00,000
如果假设有 100 个长宽的用户

66
00:03:00,000 --> 00:03:02,000
都去请求那一个文件的话

67
00:03:02,000 --> 00:03:06,000
他只有第一个人的时候会去下载

68
00:03:06,000 --> 00:03:08,000
从原那里拿那个文件

69
00:03:08,000 --> 00:03:11,000
然后后面的 99 个人都是从长宽字的服务器走了

70
00:03:11,000 --> 00:03:12,000
这样的话

71
00:03:12,000 --> 00:03:16,000
因为长宽内部到他自己客户的这边网络的

72
00:03:16,000 --> 00:03:18,000
这个带宽是比较充足的

73
00:03:18,000 --> 00:03:21,000
但是长宽去到别的网络的带宽是比较下

74
00:03:21,000 --> 00:03:22,000
比较拥堵的

75
00:03:23,000 --> 00:03:25,000
所以通过这种缓存的方法

76
00:03:25,000 --> 00:03:29,000
他们可以用一个比较小的外

77
00:03:29,000 --> 00:03:30,000
就比较便宜的

78
00:03:30,000 --> 00:03:33,000
就需外面带宽去支撑足够多的用户

79
00:03:33,000 --> 00:03:35,000
从而降低他们的成本

80
00:03:37,000 --> 00:03:38,000
这个做法本来倒也没什么

81
00:03:38,000 --> 00:03:41,000
很多公司也是这么干的

82
00:03:41,000 --> 00:03:43,000
之前我在支付的时候

83
00:03:43,000 --> 00:03:44,000
我们也是这么用的

84
00:03:44,000 --> 00:03:48,000
就是在网关上会做这么一个托民缓存

85
00:03:48,000 --> 00:03:51,000
然后到时候那些下载过的文件大家可以共享

86
00:03:51,000 --> 00:03:54,000
就是特别是因为最主要痛点是每年一次

87
00:03:54,000 --> 00:03:58,000
那个 90 月份苹果发布新的 Western 或者 iOS 的时候

88
00:04:00,000 --> 00:04:03,000
会把那个公司的出口带宽给称报

89
00:04:04,000 --> 00:04:06,000
做了这个之后大家觉得好下载好快

90
00:04:06,000 --> 00:04:09,000
而且公司出口带宽也不怎么收影一下

91
00:04:10,000 --> 00:04:13,000
这个就是说一个在公司级别和

92
00:04:13,000 --> 00:04:16,000
传款种在运商级别是做同样的事情对吧

93
00:04:16,000 --> 00:04:19,000
对问题在哪呢

94
00:04:19,000 --> 00:04:21,000
他们在做太二了

95
00:04:21,000 --> 00:04:25,000
他们的缓存系统我真是无力吐槽了

96
00:04:25,000 --> 00:04:27,000
简单来讲我们缓存的一个 URIO

97
00:04:27,000 --> 00:04:29,000
一个是文件应该说是

98
00:04:29,000 --> 00:04:33,000
你一个 URIO 对应的一个文件可能就是这么一个

99
00:04:34,000 --> 00:04:37,000
就是它的唯一雕石服是一个完整的 URIO 对吧

100
00:04:37,000 --> 00:04:43,000
比如说我们的那个存放的路径可能是 IPN.LRI 斜槓

101
00:04:43,000 --> 00:04:47,000
然后什么你假装目录是 Colonal Panic 然后又斜槓

102
00:04:47,000 --> 00:04:50,000
文件名是 EP 假装的是就是 27

103
00:04:50,000 --> 00:04:53,000
EP 20.MP 3 这么一个文件对吧

104
00:04:53,000 --> 00:04:54,000
对

105
00:04:54,000 --> 00:04:56,000
那你做缓存的时候是不是应该说

106
00:04:56,000 --> 00:05:00,000
我把 URIO 完整的就是复制

107
00:05:00,000 --> 00:05:04,000
就是作为这个文件在这个缓存系统里面的一个标示服

108
00:05:04,000 --> 00:05:07,000
对吧就包括我们的 URIO IPN.LRI

109
00:05:08,000 --> 00:05:11,000
包括它的路径 Colonal Panic

110
00:05:12,000 --> 00:05:16,000
包括它文件名 EP 20.MP 3 对吧

111
00:05:16,000 --> 00:05:18,000
对一个正常人来会这样实现的

112
00:05:18,000 --> 00:05:22,000
对正常人不然的话你说如果正常人是这么想的没问题

113
00:05:22,000 --> 00:05:29,000
但是我们发现就根据我们这个帮助我们热心出虫的

114
00:05:29,000 --> 00:05:31,000
就听众给我反馈来看

115
00:05:31,000 --> 00:05:35,000
常宽的缓存系统完全不是这么弄的

116
00:05:35,000 --> 00:05:37,000
它只选择了两个信息

117
00:05:37,000 --> 00:05:37,000
文件名

118
00:05:37,000 --> 00:05:38,000
一个是域名

119
00:05:38,000 --> 00:05:40,000
一个是文件名

120
00:05:40,000 --> 00:05:43,000
它把中间的文件路径给漏掉了

121
00:05:43,000 --> 00:05:47,000
对它假设每一台服务器上所有的文件都是独 URI

122
00:05:47,000 --> 00:05:49,000
所有的文件名都是 URI

123
00:05:49,000 --> 00:05:50,000
不管它处在哪个路径之下

124
00:05:50,000 --> 00:05:51,000
对

125
00:05:52,000 --> 00:05:57,000
然后胖巧我们这个节目的文件名都比较一致对吧

126
00:05:57,000 --> 00:05:59,000
我们就说 Colonal Panic

127
00:05:59,000 --> 00:06:03,000
雪干 ep 20.mp 3 是我们这一期节目的

128
00:06:03,000 --> 00:06:05,000
但是同样的对于这个假设 IT 工论

129
00:06:05,000 --> 00:06:07,000
它也有第 27

130
00:06:07,000 --> 00:06:10,000
那是 IT 工论雪干 ep 20.mp 3

131
00:06:10,000 --> 00:06:13,000
然后胖巧我们又是同一个域名下面的

132
00:06:13,000 --> 00:06:15,000
IPN.ni 下面的对吧

133
00:06:15,000 --> 00:06:19,000
在常宽的缓存代理一这么一过

134
00:06:19,000 --> 00:06:20,000
就会发现

135
00:06:21,000 --> 00:06:24,000
都是 ep 20.mp 3 这个文件

136
00:06:24,000 --> 00:06:25,000
他们肯定应该是一个

137
00:06:26,000 --> 00:06:33,000
然后他就默默的把 IT 工论的第 27 的那个一屏文件

138
00:06:33,000 --> 00:06:36,000
当做了 Colonal Panic 的 27 文件

139
00:06:36,000 --> 00:06:39,000
给发挥给你的那个叫什么

140
00:06:39,000 --> 00:06:41,000
你的那个楼软器或者是你的播客户端了

141
00:06:41,000 --> 00:06:43,000
于是就会出现我们之前很多人遇到的

142
00:06:43,000 --> 00:06:45,000
这个所有的串台的现象

143
00:06:45,000 --> 00:06:47,000
就是你明明下的是怎么听着太医

144
00:06:47,000 --> 00:06:50,000
怎么变成了未知道或者是听着什么流行通讯

145
00:06:50,000 --> 00:06:52,000
怎么变成了其他的什么节目

146
00:06:52,000 --> 00:06:53,000
对

147
00:06:53,000 --> 00:06:54,000
就这种诡异的事情

148
00:06:56,000 --> 00:06:58,000
我已经无理吐槽

149
00:06:58,000 --> 00:06:59,000
我趟你借说

150
00:07:00,000 --> 00:07:01,000
其实我在想说

151
00:07:01,000 --> 00:07:07,000
如果每一次串台的都可以找到一个相同之处

152
00:07:07,000 --> 00:07:09,000
就是每一期的

153
00:07:11,000 --> 00:07:13,000
怎么说番号是一样的话

154
00:07:13,000 --> 00:07:16,000
我们也是早一点就可以猜想出

155
00:07:16,000 --> 00:07:18,000
这个固帐的原因来了

156
00:07:18,000 --> 00:07:22,000
但是之前的固帐回报里面

157
00:07:22,000 --> 00:07:24,000
好像从来没有人提起过说

158
00:07:24,000 --> 00:07:26,000
比如说流行通信第 18 期

159
00:07:26,000 --> 00:07:28,000
串到那些恐慌的第 18 期

160
00:07:28,000 --> 00:07:30,000
都会是第 18 期

161
00:07:30,000 --> 00:07:32,000
我想可能一部分原因也是

162
00:07:32,000 --> 00:07:34,000
因为大部分人发现串台了

163
00:07:34,000 --> 00:07:36,000
就不会再仔细听说

164
00:07:36,000 --> 00:07:38,000
是多少期对吧

165
00:07:38,000 --> 00:07:40,000
而且也不是每一个主播都会念说

166
00:07:40,000 --> 00:07:42,000
这一次是多少期

167
00:07:42,000 --> 00:07:44,000
对我们很多节目都不会讲

168
00:07:44,000 --> 00:07:46,000
就是第多少期

169
00:07:46,000 --> 00:07:48,000
因为有可能比如说他可能预先录制了

170
00:07:48,000 --> 00:07:50,000
两三期这样

171
00:07:50,000 --> 00:07:51,000
然后发布的时候

172
00:07:51,000 --> 00:07:54,000
其实是在罗人在决定按发布的时间

173
00:07:54,000 --> 00:07:55,000
先要瞬 age 排这个序号

174
00:07:56,000 --> 00:07:57,000
对

175
00:07:57,000 --> 00:07:59,000
所以这种情况下没有办法

176
00:08:00,000 --> 00:08:02,000
你只是无意中透露了一个商业期

177
00:08:03,000 --> 00:08:04,000
什么商业期

178
00:08:04,000 --> 00:08:05,000
批量生产

179
00:08:05,000 --> 00:08:08,000
然后分批分开几期播放

180
00:08:08,000 --> 00:08:09,000
还是比较少

181
00:08:09,000 --> 00:08:12,000
但是确实以前有做过这种

182
00:08:12,000 --> 00:08:14,000
就是所谓的备用方

183
00:08:15,000 --> 00:08:18,000
对反正找到这个东西的原因

184
00:08:18,000 --> 00:08:22,000
我们的消灭它的方法也比较简单

185
00:08:22,000 --> 00:08:25,000
我们直接在文件里面前面再加个前綴

186
00:08:25,000 --> 00:08:30,000
因为既然什么长宽的这种 2 B 缓存系统

187
00:08:30,000 --> 00:08:34,000
竟然能不顾路径

188
00:08:34,000 --> 00:08:36,000
直接管文件名就认为是

189
00:08:36,000 --> 00:08:39,000
就同样文件名的文件认为是一样的

190
00:08:39,000 --> 00:08:40,000
我们把文件名改成不一样

191
00:08:40,000 --> 00:08:42,000
比如说每个节目的加了个前綴

192
00:08:42,000 --> 00:08:45,000
比如是 Colonal Panic

193
00:08:45,000 --> 00:08:46,000
然后 Hengang

194
00:08:46,000 --> 00:08:48,000
EP 20.MP 3

195
00:08:48,000 --> 00:08:49,000
然后另外那个是 acti-go

196
00:08:49,000 --> 00:08:51,000
Hengang EP 20.MP 3

197
00:08:51,000 --> 00:08:54,000
希望这样就可以绕过长宽的

198
00:08:54,000 --> 00:08:56,000
有 bug

199
00:08:56,000 --> 00:09:00,000
就是无理吐槽的 bug 的反正系统

200
00:09:00,000 --> 00:09:01,000
对

201
00:09:01,000 --> 00:09:03,000
然后这样我想到说

202
00:09:03,000 --> 00:09:05,000
其实这个 bug 也许会造成更大的伤害

203
00:09:05,000 --> 00:09:09,000
因为我们的节目其实只是一个跑的卡式而已

204
00:09:09,000 --> 00:09:11,000
最多只不过串了台而已

205
00:09:11,000 --> 00:09:11,000
对吧

206
00:09:11,000 --> 00:09:14,000
但是如果相同的 bug 发生了一些比较

207
00:09:15,000 --> 00:09:17,000
mission critical 的软件上的

208
00:09:17,000 --> 00:09:19,000
那可能就不用可能的

209
00:09:19,000 --> 00:09:20,000
这个事情已经确实是在发生的

210
00:09:20,000 --> 00:09:23,000
而且是属于造成一定的

211
00:09:23,000 --> 00:09:27,000
已经是出于一种商业恶意的行为在做了

212
00:09:27,000 --> 00:09:30,000
很简单的原因就是

213
00:09:30,000 --> 00:09:37,000
安卓那些的应用包是可以通过一种软件下载的 APK 的形式去安装的

214
00:09:37,000 --> 00:09:41,000
然后国内有很多国内有很多应用商店是这么搞的

215
00:09:41,000 --> 00:09:43,000
然后就有运商

216
00:09:43,000 --> 00:09:44,000
我不说哪一家

217
00:09:44,000 --> 00:09:45,000
大家自己去猜

218
00:09:45,000 --> 00:09:48,000
当然也不是一个普遍想象可能个别的趣吧

219
00:09:48,000 --> 00:09:54,000
还有直接在你下载 APK 这个同这个过程中给你截持了

220
00:09:54,000 --> 00:09:57,000
你本来要下一个 A 的这个应用

221
00:09:57,000 --> 00:09:59,000
它给你截至成同类的 B 的

222
00:10:02,000 --> 00:10:04,000
然后你作为一个这个消费者

223
00:10:04,000 --> 00:10:05,000
你下载回来看

224
00:10:05,000 --> 00:10:05,000
咦

225
00:10:05,000 --> 00:10:06,000
怎么有事

226
00:10:06,000 --> 00:10:09,000
我们下的是本来是 A 应用怎么变成的 B 应用的这种

227
00:10:09,000 --> 00:10:11,000
那你觉得是哪里的问题呢

228
00:10:11,000 --> 00:10:15,000
如果如果你不具备这种基础的网络知识

229
00:10:15,000 --> 00:10:21,000
你不知被像上次我们这个热情听众这种逃根问题的这种精神

230
00:10:21,000 --> 00:10:24,000
你想可能是不是你这个应用商店有问题啊

231
00:10:24,000 --> 00:10:26,000
还是怎么样对吧

232
00:10:26,000 --> 00:10:27,000
对

233
00:10:27,000 --> 00:10:28,000
所以呢

234
00:10:28,000 --> 00:10:29,000
这件事情说到底

235
00:10:29,000 --> 00:10:31,000
你技术的解决方也是有的

236
00:10:31,000 --> 00:10:35,000
那就是全面使用那个 HGGPS 就是加密的连接

237
00:10:35,000 --> 00:10:36,000
加密连接的好

238
00:10:36,000 --> 00:10:37,000
这就是中间那个缓程

239
00:10:37,000 --> 00:10:39,000
它是没有办法去做手脚的

240
00:10:39,000 --> 00:10:42,000
因为一做手脚就会被那个爆错

241
00:10:42,000 --> 00:10:43,000
至少我希望如此

242
00:10:46,000 --> 00:10:47,000
但是呢

243
00:10:47,000 --> 00:10:49,000
这就会有一点点问题

244
00:10:49,000 --> 00:10:49,000
就假设

245
00:10:49,000 --> 00:10:52,000
比如说因为如果用加密连接的话

246
00:10:52,000 --> 00:10:56,000
就长宽的那种代理缓存就没办法用了嘛

247
00:10:56,000 --> 00:10:57,000
那假设你是长宽的用户

248
00:10:57,000 --> 00:11:00,000
你再刚假设你有一百个长宽的用户

249
00:11:00,000 --> 00:11:03,000
这 100 个人每次都要经从长宽的

250
00:11:03,000 --> 00:11:06,000
不是就这 100 个用户都要从这个原始的出出

251
00:11:06,000 --> 00:11:09,000
那个下载这么一个比较大的文件

252
00:11:09,000 --> 00:11:12,000
那么如果大家都碰巧是在同一个时间下载的话

253
00:11:12,000 --> 00:11:15,000
可能就会把长宽的那个出口带开给称保

254
00:11:17,000 --> 00:11:20,000
所以其实你发现说到这里就是在安全

255
00:11:20,000 --> 00:11:25,000
隐私和这个效率上面之间是有一些矛盾的

256
00:11:25,000 --> 00:11:26,000
怎么去取舍

257
00:11:27,000 --> 00:11:28,000
我觉得

258
00:11:29,000 --> 00:11:31,000
过去我们通常觉得说效率些嘛

259
00:11:31,000 --> 00:11:33,000
能安全隐私的一些

260
00:11:33,000 --> 00:11:35,000
反正我又不在乎有什么问题呢

261
00:11:35,000 --> 00:11:39,000
但是其实今天以今天这种情况来看

262
00:11:39,000 --> 00:11:41,000
就是什么运营商劫持啊

263
00:11:41,000 --> 00:11:49,000
还有各路神仙在搞那种灰色甚至黑色的利益的勾当的时候

264
00:11:49,000 --> 00:11:54,000
我们甚至有我们可能是不是就不得不牺牲一些效率下载慢

265
00:11:54,000 --> 00:11:55,000
去选择

266
00:11:55,000 --> 00:11:57,000
那我至少保证下东西后来是可靠的

267
00:11:57,000 --> 00:11:58,000
对吧

268
00:11:58,000 --> 00:11:58,000
对

269
00:12:00,000 --> 00:12:01,000
是

270
00:12:01,000 --> 00:12:05,000
反正最不论如何我们还是要在这边感谢这个

271
00:12:05,000 --> 00:12:08,000
这位帮我们找到这个 bug 的听众

272
00:12:08,000 --> 00:12:10,000
他叫做 leandz

273
00:12:11,000 --> 00:12:12,000
非常感谢

274
00:12:13,000 --> 00:12:13,000
对

275
00:12:13,000 --> 00:12:20,000
还有感谢另外一位是在那个 v 2 ex 上面我们每期节目的那个文章上面

276
00:12:20,000 --> 00:12:23,000
他也另外那位朋友也帮我们做了这个同样的事情

277
00:12:23,000 --> 00:12:24,000
非常感谢大家

278
00:12:25,000 --> 00:12:25,000
是

279
00:12:27,000 --> 00:12:35,000
那接下来一条 follow up 就是我上一期节目里面提到的那个莫尔斯马的 F

280
00:12:36,000 --> 00:12:38,000
这个如果大家忘记了我们这里先描述一下

281
00:12:40,000 --> 00:12:46,000
我上次让吴涛去捣估一下一个在 Apple Watch 上跑的原生的

282
00:12:46,000 --> 00:12:50,000
从莫尔斯马来发送信息的一个应用

283
00:12:50,000 --> 00:12:51,000
所以后来怎么样了

284
00:12:53,000 --> 00:13:00,000
其实原因也就是即便在新发布的 WatchOS 上面

285
00:13:01,000 --> 00:13:09,000
苹果提供的这一堆空间还是有还是只支持非常简单的世界模型

286
00:13:09,000 --> 00:13:13,000
就是比如说你可以在里面放一个 button

287
00:13:13,000 --> 00:13:20,000
但是你只你放了 button 之后你对他做的事情就仅有探测他

288
00:13:20,000 --> 00:13:25,000
被按下了一次这个 action 这个 event

289
00:13:25,000 --> 00:13:30,000
而没有说我的手指碰到了 button 按下去了

290
00:13:30,000 --> 00:13:36,000
这是 event 或者是我手指提起来从 button 上面移开了

291
00:13:36,000 --> 00:13:47,000
这 event 相当于如果你搞过 iOS 变成的话就相当于 touch start 和 touch end

292
00:13:49,000 --> 00:13:53,000
这两个世界还是 touch live inside 这两个世界

293
00:13:53,000 --> 00:13:56,000
对他唯一能做的就是这个按钮被按下了一次

294
00:13:56,000 --> 00:13:57,000
但是没有办法判断这个按钮

295
00:13:57,000 --> 00:13:58,000
按下了长短

296
00:13:59,000 --> 00:14:09,000
所以这样一来你想要向那些比较熟练一点的电报源

297
00:14:09,000 --> 00:14:16,000
那样通过快速敲击表盘来发点和滑的希望的泡汤

298
00:14:16,000 --> 00:14:20,000
因为每一个按键被按下去的过程实际上是非常好

299
00:14:20,000 --> 00:14:23,000
而且我相信苹果为了防止说

300
00:14:24,000 --> 00:14:34,000
一个人误触一个按键两次在短时间之内误触按键两次

301
00:14:34,000 --> 00:14:39,000
他故意放了一段怎么说僵直期在那边

302
00:14:39,000 --> 00:14:41,000
就是你我可能想说不应急

303
00:14:41,000 --> 00:14:44,000
所以在这段时间之内

304
00:14:44,000 --> 00:14:47,000
你是怎么按这个键的我有反应

305
00:14:47,000 --> 00:14:51,000
所以从这个角度讲

306
00:14:51,000 --> 00:14:55,000
原本的设想是就已经做到了

307
00:14:55,000 --> 00:14:58,000
然后我现在临时的方案是放两个按键的时候

308
00:14:58,000 --> 00:14:59,000
一个代表点一个代表滑

309
00:14:59,000 --> 00:15:03,000
但是最后一路是明显

310
00:15:03,000 --> 00:15:04,000
对这样不酷

311
00:15:04,000 --> 00:15:07,000
而且扔就是比较慢

312
00:15:07,000 --> 00:15:10,000
然后我我我大家差问一个事

313
00:15:10,000 --> 00:15:13,000
就是他那个表上不是还有两个物理的东西吗

314
00:15:13,000 --> 00:15:16,000
一个是那个叫做数字表观的东西

315
00:15:16,000 --> 00:15:19,000
还有一个就是旁边有个数字表观下面有个按钮

316
00:15:19,000 --> 00:15:23,000
那两个是可以通过 API 访问的到的他的操作的吗

317
00:15:23,000 --> 00:15:27,000
并不能直接访问到

318
00:15:27,000 --> 00:15:30,000
首先朋友的那个键

319
00:15:30,000 --> 00:15:32,000
那键的官方名字叫什么

320
00:15:32,000 --> 00:15:35,000
Friend Key

321
00:15:35,000 --> 00:15:39,000
我让那个官方反正就反正我知道上面那个叫 digital crumb

322
00:15:39,000 --> 00:15:42,000
下面那个叫下面可能就叫 side button 如果没记错

323
00:15:42,000 --> 00:15:43,000
反正就是按钮对

324
00:15:43,000 --> 00:15:48,000
最后一路是可以在你的英文里面探测的

325
00:15:48,000 --> 00:15:54,000
对然后这两件 side button 是没有办法直接编程获得的

326
00:15:54,000 --> 00:15:57,000
然后 digital crumb 也不能直接编程说

327
00:15:57,000 --> 00:16:02,000
此时发生了一个 digital crumb 被转动事件

328
00:16:02,000 --> 00:16:05,000
而只能通过一个叫做如果没记错的话

329
00:16:05,000 --> 00:16:13,000
应该叫 interface picker 的空间来接来

330
00:16:14,000 --> 00:16:18,000
就是在这个所以 watchOS 2 也是这样吗

331
00:16:18,000 --> 00:16:21,000
对哪怕在 watchOS 2 里面也是这样

332
00:16:21,000 --> 00:16:25,000
而且好像是只有在 watchOS 2 里面才可以使用这个空间

333
00:16:25,000 --> 00:16:31,000
比如说之前在目前的版本的 X code 6 里面是没有办法去

334
00:16:31,000 --> 00:16:37,000
任何方法获得这个 digital crumb 被转动的时间

335
00:16:37,000 --> 00:16:40,000
然后在 watchOS 2 里面你可以放一个 picker

336
00:16:40,000 --> 00:16:51,000
然后 picker 的外观其实就像比如说监测你的 activity 的 app 里面

337
00:16:51,000 --> 00:16:57,000
你可以通过指头在表盘上下滑动

338
00:16:57,000 --> 00:17:03,000
或者是通过 digital crumb 来转动去选择一个列表之中的猛向

339
00:17:03,000 --> 00:17:10,000
然后这个 slide picker 会发生一个 selected item change

340
00:17:10,000 --> 00:17:12,000
这样一个 event

341
00:17:12,000 --> 00:17:14,000
所以你可以通过这个 event 来间接的判断说

342
00:17:14,000 --> 00:17:16,000
噢,crumb 现在被转动

343
00:17:16,000 --> 00:17:18,000
但也金色而已

344
00:17:18,000 --> 00:17:22,000
还有一个就是我提的一个建议

345
00:17:22,000 --> 00:17:23,000
后来证明也是不行的

346
00:17:23,000 --> 00:17:29,000
就是说他那个表的那个触屏不是可以探测压杆吗

347
00:17:29,000 --> 00:17:35,000
就可以通过什么 forstarch 就是用力的压和不用你的压区分零和一

348
00:17:35,000 --> 00:17:37,000
这个后来是一个什么样的情况

349
00:17:37,000 --> 00:17:38,000
事实上也是不行的

350
00:17:38,000 --> 00:17:49,000
因为 forstarch 这个动作被 stk 限制为呼出快捷菜单这么一个

351
00:17:49,000 --> 00:17:52,000
呼出 context menu 这么一个动作

352
00:17:52,000 --> 00:17:56,000
所以如果你要处理这个视线的话

353
00:17:56,000 --> 00:18:01,000
那你唯一能做的就是把它连到一个菜单上面

354
00:18:01,000 --> 00:18:03,000
别的不能做了

355
00:18:03,000 --> 00:18:06,000
然后这个菜单出来

356
00:18:06,000 --> 00:18:10,000
比如说上面有一个唯一的安全就是点一下就就输入 event 不可以吗

357
00:18:10,000 --> 00:18:16,000
我觉得这个操作还是非常的奇怪

358
00:18:16,000 --> 00:18:18,000
对

359
00:18:18,000 --> 00:18:20,000
那其实还不如放两个按钮

360
00:18:20,000 --> 00:18:24,000
因为你无论如何在查案之下还要点一下就非常的

361
00:18:24,000 --> 00:18:29,000
关键是我觉得那个 forstarch 的那个力度很不好控制

362
00:18:29,000 --> 00:18:30,000
没错

363
00:18:30,000 --> 00:18:36,000
而且我觉得苹果有点对于上下滚动太敏感

364
00:18:36,000 --> 00:18:38,000
苹果表最上下滚动太敏感

365
00:18:38,000 --> 00:18:42,000
就是我不知道你有没有这个感觉是你在走路的时候

366
00:18:42,000 --> 00:18:46,000
如果你试图按一个按键

367
00:18:46,000 --> 00:18:53,000
你会发现这个表会更倾向于转动他的上下滑动他的屏幕

368
00:18:53,000 --> 00:18:54,000
而不是让你把这个按键按下去

369
00:18:54,000 --> 00:18:56,000
尤其是这个屏幕可以滑动的时候

370
00:18:56,000 --> 00:18:59,000
比如说回复一个人的短信

371
00:18:59,000 --> 00:19:02,000
好一边走路一边抬起手腕来看到一个人的短信

372
00:19:02,000 --> 00:19:07,000
然后你想要回复他回复回复那一下就很难点了

373
00:19:07,000 --> 00:19:09,000
因为对这里有一个问题

374
00:19:09,000 --> 00:19:14,000
就刚才你说的两个事件一个 tarch start 和 tarch end

375
00:19:14,000 --> 00:19:16,000
他们之间是有一个渐息的

376
00:19:16,000 --> 00:19:20,000
然后你在运动中你这个肯定是会发生位移的

377
00:19:20,000 --> 00:19:22,000
那个触摸的手指

378
00:19:22,000 --> 00:19:23,000
对

379
00:19:23,000 --> 00:19:25,000
是让他这样拍比赛

380
00:19:25,000 --> 00:19:31,000
对这样一来你在选择回复的时候就已经很吃力了

381
00:19:31,000 --> 00:19:35,000
你可能需要把食指按在手腕上

382
00:19:35,000 --> 00:19:38,000
然后用中指去点那个回复键

383
00:19:38,000 --> 00:19:41,000
因为这样可以减少两个手之间的相论以动

384
00:19:41,000 --> 00:19:50,000
然后等你呼出的那个一堆短暂的快捷回复内容的时候

385
00:19:50,000 --> 00:19:54,000
可能你又要很小心的去按其中的我一个

386
00:19:54,000 --> 00:19:56,000
不然他又会触摸的滑动

387
00:19:56,000 --> 00:19:59,000
对这个是挺糟糕的一件事

388
00:19:59,000 --> 00:20:01,000
可能他们还得再微调一下

389
00:20:01,000 --> 00:20:07,000
因为毕竟这个这么小的表盘上的这种触摸的操作

390
00:20:07,000 --> 00:20:11,000
和手机大屏幕的触摸道道的情况还是有点不同的

391
00:20:11,000 --> 00:20:14,000
怎么去制定一些边界的条件

392
00:20:14,000 --> 00:20:18,000
我觉得还是挺怎么说呢是麻烦一个事

393
00:20:18,000 --> 00:20:21,000
对然后我希望的接下来的几大 iOS

394
00:20:21,000 --> 00:20:26,000
阿版我吃完四个名可以提供更多的事件

395
00:20:26,000 --> 00:20:27,000
以及更多的 API 支持

396
00:20:27,000 --> 00:20:34,000
比如说现在好像没有办法去检测它的那个图罗仪

397
00:20:34,000 --> 00:20:37,000
或者是血压记忆都没有办法

398
00:20:37,000 --> 00:20:39,000
就只能做一些非常简单的功能

399
00:20:39,000 --> 00:20:44,000
然后所有动画都必须通过图片来实现

400
00:20:44,000 --> 00:20:47,000
就是如果你想要显示一个动画

401
00:20:47,000 --> 00:20:51,000
我们得预先把每一帧都存成一个存成一幅照片

402
00:20:51,000 --> 00:20:55,000
然后就连着放放那个幻能片吧

403
00:20:55,000 --> 00:20:57,000
对然后连着放幻能片

404
00:20:57,000 --> 00:21:03,000
然后苹果的这次 wwwdc 上面还劝告开发者说

405
00:21:03,000 --> 00:21:06,000
注意图片的尺寸

406
00:21:06,000 --> 00:21:10,000
因为在 iOS 在卧车 S 一代里面

407
00:21:10,000 --> 00:21:13,000
图片每次都要传到手边上

408
00:21:13,000 --> 00:21:20,000
而在卧车 S 2 上面至少在第一次安装的时候

409
00:21:20,000 --> 00:21:23,000
这个传输过程也是比较好使的

410
00:21:23,000 --> 00:21:26,000
并且如果你图片太大的话

411
00:21:26,000 --> 00:21:29,000
它存在手表上也是很占地的

412
00:21:29,000 --> 00:21:33,000
对啊水把有个内置有个什么 8 GB 的存成分件吧

413
00:21:33,000 --> 00:21:39,000
总共对然后其中大概有 31 倍操作总用

414
00:21:43,000 --> 00:21:48,000
所以其实为这个机类玩意儿开发东西还是挺难的

415
00:21:48,000 --> 00:21:49,000
没错

416
00:21:51,000 --> 00:21:52,000
但是怎么说呢

417
00:21:52,000 --> 00:21:53,000
毕竟是第一代产品

418
00:21:53,000 --> 00:21:54,000
希望以后会有的

419
00:21:54,000 --> 00:21:56,000
也许以后会有的

420
00:21:56,000 --> 00:22:00,000
摄像机出现在手表上

421
00:22:00,000 --> 00:22:02,000
摄像机

422
00:22:02,000 --> 00:22:03,000
对啊

423
00:22:03,000 --> 00:22:05,000
就是用一个摄像头

424
00:22:05,000 --> 00:22:09,000
装一个摄像头在人手表上还是挺实用的

425
00:22:09,000 --> 00:22:09,000
三颗三颗

426
00:22:09,000 --> 00:22:10,000
我有点担心

427
00:22:10,000 --> 00:22:14,000
然后那个就会布那个 Google Glass 的后层

428
00:22:15,000 --> 00:22:17,000
你干嘛用你的手表对着我

429
00:22:17,000 --> 00:22:18,000
你是不是在录像

430
00:22:18,000 --> 00:22:19,000
没错

431
00:22:19,000 --> 00:22:21,000
你那么隐蔽的一个摄像装置

432
00:22:21,000 --> 00:22:22,000
谁知道你没有在拍人家群底

433
00:22:22,000 --> 00:22:23,000
是不是

434
00:22:24,000 --> 00:22:26,000
所以特别是在日本这种国家的吧

435
00:22:26,000 --> 00:22:27,000
就挺麻烦的

436
00:22:27,000 --> 00:22:28,000
我觉得

437
00:22:29,000 --> 00:22:34,000
其实在目前的手表上可以遥控手机上的相机

438
00:22:34,000 --> 00:22:37,000
已经有一点就是可以用它来做一些

439
00:22:37,000 --> 00:22:40,000
不那么道德的事情的嫌疑

440
00:22:40,000 --> 00:22:43,000
目前还没有看到对自己的批评

441
00:22:44,000 --> 00:22:46,000
他如果遥控手机的话

442
00:22:46,000 --> 00:22:49,000
反正比如说你在日本购买的合法的

443
00:22:49,000 --> 00:22:51,000
这个 iPhone 的那个拍照的时候

444
00:22:51,000 --> 00:22:52,000
那个咔嚓声是关不掉的吗

445
00:22:54,000 --> 00:22:55,000
你知道这事吗

446
00:22:55,000 --> 00:22:56,000
我不知道

447
00:22:56,000 --> 00:23:02,000
好像只有日本就是日版的 iPhone 是有这个限制

448
00:23:02,000 --> 00:23:05,000
就是说你中国的比如说欧版或者是中国大陆的

449
00:23:05,000 --> 00:23:11,000
卖的那个 iPhone 手机的你调成这个震动模式之后

450
00:23:11,000 --> 00:23:14,000
你用拍照是它是不会发出任何声音的

451
00:23:14,000 --> 00:23:15,000
拍了就拍了

452
00:23:15,000 --> 00:23:18,000
但是你在日本买了就会咔嚓

453
00:23:18,000 --> 00:23:20,000
哪怕是在震动模式也会有这个

454
00:23:20,000 --> 00:23:26,000
是指在照片 app 这个层级上限制的

455
00:23:26,000 --> 00:23:27,000
还是在所有的 app

456
00:23:27,000 --> 00:23:29,000
API 的层级上限制

457
00:23:29,000 --> 00:23:31,000
只要有拍照这个功能都会发出声音

458
00:23:31,000 --> 00:23:33,000
holy f***

459
00:23:33,000 --> 00:23:36,000
我当时知道这个消息是为了震惊的

460
00:23:38,000 --> 00:23:39,000
不可思议

461
00:23:40,000 --> 00:23:42,000
哥哥有国情吧有国情

462
00:23:44,000 --> 00:23:45,000
好吧

463
00:23:45,000 --> 00:23:48,000
那个我们下面念几封这个听众来信

464
00:23:48,000 --> 00:23:49,000
好吧

465
00:23:49,000 --> 00:23:54,000
对上期的节目在微博上面没有太多人评论

466
00:23:54,000 --> 00:23:59,000
但是我们却收到了好几封又长又热情读者来信

467
00:24:00,000 --> 00:24:00,000
嗯哼

468
00:24:01,000 --> 00:24:03,000
嗯先念第一位吧

469
00:24:03,000 --> 00:24:06,000
这个是叫陈一鸣

470
00:24:06,000 --> 00:24:08,000
这支拼音不知道怎么写

471
00:24:08,000 --> 00:24:10,000
陈一鸣的来信

472
00:24:10,000 --> 00:24:11,000
对

473
00:24:11,000 --> 00:24:15,000
Rio Wutao 你们好听了你们这期内核恐慌

474
00:24:15,000 --> 00:24:17,000
我也想发表一下自己对测试的看法

475
00:24:18,000 --> 00:24:22,000
第一次接触测试可以说是在高中算法竞赛的时候

476
00:24:22,000 --> 00:24:25,000
哇好厉害高中就算法竞赛

477
00:24:25,000 --> 00:24:30,000
当时老师特地请了 acm 大牛来学校指导我们

478
00:24:30,000 --> 00:24:33,000
在休息的时候就顺便教我们如何写

479
00:24:33,000 --> 00:24:36,000
对拍程序什么是对拍程序

480
00:24:37,000 --> 00:24:41,000
对拍程序就是就像一个

481
00:24:42,000 --> 00:24:48,000
那个节奏器吧我很理解就是你要和他对对对你的拍子

482
00:24:48,000 --> 00:24:52,000
ok 啊这这点点这里有这个就是有三个步骤

483
00:24:53,000 --> 00:24:57,000
第一第一步是先写一个低下的程序保证这个程序的正确性

484
00:24:58,000 --> 00:25:02,000
然后第二步是再写一个随机生成输入数据的程序

485
00:25:02,000 --> 00:25:04,000
并保证生成各种边界条件

486
00:25:04,000 --> 00:25:08,000
第三就是最后写自己打算提交的最终代码

487
00:25:08,000 --> 00:25:11,000
并用以上两个程序来保证该代码的正确

488
00:25:12,000 --> 00:25:16,000
呃当时还是在 windows 下用命令行提示符写脚本

489
00:25:16,000 --> 00:25:19,000
对输出进行对比因此印象深刻

490
00:25:19,000 --> 00:25:22,000
但学了之后在比赛中真用到的人很少

491
00:25:23,000 --> 00:25:26,000
又或者是我没有进到审计上的比赛没接触到

492
00:25:26,000 --> 00:25:27,000
就是扩好面子的话

493
00:25:27,000 --> 00:25:31,000
现在看来当时学的测试方法已经很标准有效了

494
00:25:31,000 --> 00:25:34,000
然而实践起来却难上家的难

495
00:25:34,000 --> 00:25:36,000
写最终代码都来不及了

496
00:25:36,000 --> 00:25:39,000
哪还有时间写低下程序和更麻烦的

497
00:25:39,000 --> 00:25:40,000
较的数据生成脚本的

498
00:25:41,000 --> 00:25:44,000
也因此我对测试并没有什么好印象

499
00:25:45,000 --> 00:25:48,000
但是这学期我在一个课程的这个 project

500
00:25:48,000 --> 00:25:52,000
用的是 python jungle 中第一次尝试的 TDD

501
00:25:52,000 --> 00:25:54,000
就像这么讲的 test driven development

502
00:25:55,000 --> 00:25:56,000
测试驱动的开发

503
00:25:57,000 --> 00:25:59,000
对测试大大改观

504
00:25:59,000 --> 00:26:02,000
发现测试并没有之前想象的那么无用

505
00:26:02,000 --> 00:26:06,000
也比二位在节目节目中说的重要得多

506
00:26:06,000 --> 00:26:09,000
测试呃我在节目中没有说他不重要

507
00:26:10,000 --> 00:26:11,000
我只是不喜欢他

508
00:26:11,000 --> 00:26:12,000
但从来没有说他不重要

509
00:26:12,000 --> 00:26:15,000
对对对我们都一致认可测试的重要性

510
00:26:15,000 --> 00:26:16,000
有总是并没有好的

511
00:26:16,000 --> 00:26:18,000
只有我们都不太喜欢写测试

512
00:26:19,000 --> 00:26:21,000
ok 他说这个接着讲哈

513
00:26:21,000 --> 00:26:23,000
他说测试最重要是帮助我们写出

514
00:26:24,000 --> 00:26:26,000
一试试的代码单元

515
00:26:27,000 --> 00:26:30,000
单元测试的定义决定的程序的每一个小功能

516
00:26:30,000 --> 00:26:33,000
都要有一个接口供测试代码调用

517
00:26:33,000 --> 00:26:34,000
而且写单元测试

518
00:26:35,000 --> 00:26:37,000
这样我们先对这个接口有一个设想

519
00:26:38,000 --> 00:26:41,000
帮助我们降低项目的吻合度提高内聚性

520
00:26:41,000 --> 00:26:44,000
当然有一个架构的过程也能办到

521
00:26:44,000 --> 00:26:48,000
但一个小团队或者一个需要快速开发的项目

522
00:26:48,000 --> 00:26:50,000
往往没有那么多时间去架构

523
00:26:50,000 --> 00:26:52,000
测试能在架构上进行帮助

524
00:26:53,000 --> 00:26:55,000
这一点我觉得有点意思啊

525
00:26:55,000 --> 00:26:56,000
就是说呃

526
00:26:58,000 --> 00:27:00,000
其他测试能够帮助我们所谓做一个

527
00:27:00,000 --> 00:27:04,000
就是最小颗粒度的独立运行的一端代码对吧

528
00:27:05,000 --> 00:27:09,000
对那这样的话呃就可以至少说我们不会写一个

529
00:27:10,000 --> 00:27:13,000
翻五页都翻不完的单一函数对吧

530
00:27:14,000 --> 00:27:16,000
这样就没法测了吗

531
00:27:17,000 --> 00:27:19,000
所以从这点上我觉得还是有一定好处

532
00:27:19,000 --> 00:27:23,000
就起码在对你带这个叫什么代码的组织上是有一定帮助的

533
00:27:24,000 --> 00:27:28,000
对于每一测试其实就是一个对于你真正的 API 的考验

534
00:27:29,000 --> 00:27:29,000
对啊

535
00:27:30,000 --> 00:27:33,000
很多考验是如果你没有用过的话

536
00:27:33,000 --> 00:27:37,000
完全不知道自己没有办法通过这个考验

537
00:27:37,000 --> 00:27:40,000
所以如果一开始能把这个考验就先写出来的话

538
00:27:40,000 --> 00:27:43,000
那设计 API 的时候其实会

539
00:27:44,000 --> 00:27:45,000
双边很多对

540
00:27:46,000 --> 00:27:48,000
呃然后接着念他这个来信啊

541
00:27:48,000 --> 00:27:50,000
然后他这里马上举了一个反例

542
00:27:50,000 --> 00:27:52,000
就是这学期我做的另一个项目

543
00:27:52,000 --> 00:27:55,000
PAIQT 5 完全没有测试

544
00:27:55,000 --> 00:27:57,000
写出来就杂乱无章

545
00:27:57,000 --> 00:27:58,000
偶和的过紧

546
00:27:58,000 --> 00:28:01,000
你至于最后自己都不想再写下去了

547
00:28:01,000 --> 00:28:04,000
当然主要是我们做好前期架构的工作对吧

548
00:28:04,000 --> 00:28:07,000
就其实就是有这么一个叫什么

549
00:28:08,000 --> 00:28:12,000
没有纪律性的程序员要需要这个

550
00:28:12,000 --> 00:28:16,000
从我测试这种一种外部的手段强制你把带马的

551
00:28:16,000 --> 00:28:19,000
这个颗粒都缩的比较小

552
00:28:19,000 --> 00:28:21,000
然后每个是可以有独立逻辑

553
00:28:21,000 --> 00:28:22,000
可以独立运作的吗

554
00:28:23,000 --> 00:28:24,000
我不知道你写带马是怎么样子

555
00:28:24,000 --> 00:28:26,000
但我写带马的时候

556
00:28:26,000 --> 00:28:29,000
我不喜欢那种非常长的一段函数

557
00:28:29,000 --> 00:28:31,000
就是你有这吗

558
00:28:32,000 --> 00:28:32,000
这种

559
00:28:32,000 --> 00:28:36,000
结皮就是凡是要抽象出来成一个函数

560
00:28:38,000 --> 00:28:38,000
是吧

561
00:28:38,000 --> 00:28:43,000
我记得很早以前就在那部书上看到我是

562
00:28:43,000 --> 00:28:44,000
pragmatical

563
00:28:44,000 --> 00:28:46,000
pragmatical 没说

564
00:28:46,000 --> 00:28:50,000
每一个函数最好长度不要超过一平这样

565
00:28:51,000 --> 00:28:55,000
不用卷动屏幕就可以看明白它是在干嘛

566
00:28:55,000 --> 00:28:56,000
没错

567
00:28:56,000 --> 00:28:57,000
基本上我也是这个习惯

568
00:28:59,000 --> 00:29:01,000
但是自豪自豪有足够大才行

569
00:29:01,000 --> 00:29:02,000
不然就是做

570
00:29:03,000 --> 00:29:07,000
开 6 号字一屏还是数评的那种蛋

571
00:29:08,000 --> 00:29:09,000
没什么是挺透过的

572
00:29:10,000 --> 00:29:11,000
对

573
00:29:12,000 --> 00:29:13,000
接着念这个

574
00:29:13,000 --> 00:29:17,000
其实是在是保证在重构时不犯错

575
00:29:17,000 --> 00:29:20,000
在我的项目开发的过程短短几天时间里

576
00:29:20,000 --> 00:29:24,000
我就有好几次对大片的带马进行重构或者是优化

577
00:29:24,000 --> 00:29:26,000
如果没有测试做保障

578
00:29:26,000 --> 00:29:29,000
无法想象能在短时间内一个人完成这些工作

579
00:29:30,000 --> 00:29:34,000
使用 TDD 的感受就是对带马的每一次跟感都很安心

580
00:29:34,000 --> 00:29:38,000
因为有 TDD 在带马出错的第一时间帮我指出

581
00:29:38,000 --> 00:29:42,000
而重构不犯错的另一个好处是让它维护更加方便

582
00:29:42,000 --> 00:29:43,000
只要通过测试就可以了

583
00:29:44,000 --> 00:29:46,000
这个其实怎么说呢

584
00:29:48,000 --> 00:29:50,000
这个确实是有好处的

585
00:29:50,000 --> 00:29:53,000
对回归测试就是做这样

586
00:29:53,000 --> 00:29:54,000
对保证你在

587
00:29:55,000 --> 00:29:59,000
引入新特性或者重新价格我们的程序的时候

588
00:29:59,000 --> 00:30:02,000
可以保证既有的正确的东西不会被改变

589
00:30:03,000 --> 00:30:05,000
这个基本上只有测试可以做了

590
00:30:05,000 --> 00:30:09,000
没有办法用其他任何办法来试图打到这个目的

591
00:30:10,000 --> 00:30:12,000
都是试备功办的

592
00:30:12,000 --> 00:30:15,000
但主要是有一点我觉得比较好奇的是

593
00:30:15,000 --> 00:30:17,000
如果它对大片带马进行了重构

594
00:30:18,000 --> 00:30:20,000
那与之对应的单人测试不要重写

595
00:30:24,000 --> 00:30:27,000
那其实这是一个急胜单带声机的问题

596
00:30:27,000 --> 00:30:30,000
就如果一开始的单人测试写的

597
00:30:30,000 --> 00:30:32,000
就让你没有那么好重构的话

598
00:30:32,000 --> 00:30:34,000
那你重构起来也是困难重构

599
00:30:35,000 --> 00:30:37,000
但如果你一开始单人测试写的颗粒足够小

600
00:30:37,000 --> 00:30:41,000
然后你的接口也保证的比较好

601
00:30:41,000 --> 00:30:46,000
那基本上单人测试是在很大一部分程度上可以

602
00:30:48,000 --> 00:30:49,000
怎么说延留下来延用

603
00:30:50,000 --> 00:30:53,000
但这本还是要回到一开始

604
00:30:53,000 --> 00:30:56,000
就是你得一开始做一定的架构

605
00:30:56,000 --> 00:30:59,000
你不能完全依赖于自己的单人测试

606
00:31:00,000 --> 00:31:02,000
所以其实我理解在这么一个重构的

607
00:31:02,000 --> 00:31:08,000
还是有一定的两个不同的层次

608
00:31:08,000 --> 00:31:11,000
就是说一些比如说你对某一个函数的内部实现

609
00:31:11,000 --> 00:31:14,000
或者某一个就不改变接口情况下

610
00:31:14,000 --> 00:31:17,000
内部实现的重构是完全没有问题

611
00:31:17,000 --> 00:31:18,000
就做起来非常爽

612
00:31:18,000 --> 00:31:20,000
你只要确保那些

613
00:31:20,000 --> 00:31:21,000
因为测试是按照接口

614
00:31:21,000 --> 00:31:23,000
单人测试是按接口来做的

615
00:31:23,000 --> 00:31:26,000
你把那些边界条件都弄出来

616
00:31:26,000 --> 00:31:27,000
然后看一下能不能跑通

617
00:31:27,000 --> 00:31:30,000
大致上也有八九不理识的信心了

618
00:31:30,000 --> 00:31:33,000
但是如果你是连接口都发生了

619
00:31:33,000 --> 00:31:35,000
比较大的改变的重构的话

620
00:31:35,000 --> 00:31:38,000
我觉得你在过程中也不会爽到那里去

621
00:31:38,000 --> 00:31:42,000
因为毕竟还是要重写很多单人测试的

622
00:31:42,000 --> 00:31:43,000
你接口变了吗

623
00:31:43,000 --> 00:31:44,000
对

624
00:31:45,000 --> 00:31:46,000
接着念下面一个

625
00:31:47,000 --> 00:31:50,000
测试还是形式证明

626
00:31:51,000 --> 00:31:52,000
就是这个选择挺好

627
00:31:52,000 --> 00:31:54,000
节目中如果有提到对代码的可靠性

628
00:31:54,000 --> 00:31:57,000
进行形式证明更靠谱

629
00:31:57,000 --> 00:31:59,000
我认为这理论上没错

630
00:31:59,000 --> 00:32:01,000
但对于一个现代工程来说

631
00:32:01,000 --> 00:32:03,000
对项目的正确性进行形式证明

632
00:32:03,000 --> 00:32:05,000
几乎是不可能的

633
00:32:05,000 --> 00:32:08,000
因为一个大项目很少从框架都自己搭起

634
00:32:08,000 --> 00:32:11,000
那么就无法保证使用框架的正确性

635
00:32:11,000 --> 00:32:14,000
比如万一监狗像本身出了 bug

636
00:32:14,000 --> 00:32:16,000
或者升级后 API 变动

637
00:32:16,000 --> 00:32:17,000
导致程序粗错

638
00:32:17,000 --> 00:32:20,000
可能我形式证明过我写的部分是对的

639
00:32:20,000 --> 00:32:23,000
但由于这些技术项目是超出我的能力范围外的

640
00:32:23,000 --> 00:32:26,000
那只能用测试来保证代码的正确性了

641
00:32:27,000 --> 00:32:28,000
嗯这怎么说呢

642
00:32:29,000 --> 00:32:30,000
没错

643
00:32:30,000 --> 00:32:31,000
形式证明是一个很好的东西

644
00:32:31,000 --> 00:32:33,000
但是我们从从常

645
00:32:33,000 --> 00:32:35,000
你不会在

646
00:32:35,000 --> 00:32:38,000
非学院学术研究的领域还看到它

647
00:32:39,000 --> 00:32:40,000
不当然也有一个有实践例子

648
00:32:40,000 --> 00:32:41,000
我记得那个

649
00:32:41,000 --> 00:32:44,000
Windows 上不是有个虚拟机的那个

650
00:32:44,000 --> 00:32:46,000
叫做 hypervisor

651
00:32:46,000 --> 00:32:47,000
叫什么来的

652
00:32:49,000 --> 00:32:49,000
您怎么忘

653
00:32:50,000 --> 00:32:51,000
据说哈

654
00:32:51,000 --> 00:32:53,000
就是我有研究院是

655
00:32:53,000 --> 00:32:55,000
是对那个 hypervisor 代码进行的形式证明的

656
00:32:56,000 --> 00:32:58,000
但是这一覆盖度多少我不太清楚

657
00:32:58,000 --> 00:32:59,000
但这不还是蛮吃尽

658
00:32:59,000 --> 00:33:01,000
因为那个代码量还是比较大

659
00:33:03,000 --> 00:33:05,000
微软就远不差人不差钱

660
00:33:06,000 --> 00:33:08,000
对他们有时间有的是有的是

661
00:33:08,000 --> 00:33:12,000
有的是人有的是时间多少个博士生砸进去

662
00:33:12,000 --> 00:33:13,000
在搞这种事情

663
00:33:14,000 --> 00:33:15,000
嗯但怎么说呢

664
00:33:15,000 --> 00:33:17,000
我觉得现在事情这样子

665
00:33:17,000 --> 00:33:17,000
就是说

666
00:33:18,000 --> 00:33:21,000
需要形式证明可靠性的东西

667
00:33:21,000 --> 00:33:22,000
可能是忘了要求比较高的

668
00:33:22,000 --> 00:33:24,000
一个是刚刚我讲那个怎么想的

669
00:33:24,000 --> 00:33:27,000
虚拟机的这个 hypervisor

670
00:33:27,000 --> 00:33:30,000
另外一些就是之前我们提到的就是 mission critical

671
00:33:30,000 --> 00:33:34,000
的东西什么 NASA 的发火监的代码

672
00:33:34,000 --> 00:33:37,000
啊什么 tesla 的控制控制汽车行驶的代码

673
00:33:37,000 --> 00:33:39,000
对那些是需要进行的东西来做的

674
00:33:40,000 --> 00:33:43,000
还有一些事情是我们觉得过去觉得可能无关

675
00:33:43,000 --> 00:33:46,000
紧要但是其实是急需要形式证明去

676
00:33:46,000 --> 00:33:48,000
证明他是安全可靠的

677
00:33:48,000 --> 00:33:50,000
就是我们现在互联网底层的一些

678
00:33:50,000 --> 00:33:53,000
啊包括一些啊不是互联网底层

679
00:33:53,000 --> 00:33:56,000
就是我们现在计算机硬件底层一些涉及到安全相关的东西

680
00:33:56,000 --> 00:33:56,000
对吧

681
00:33:57,000 --> 00:34:02,000
前段时间就是去年和今年连续爆出来的多个重大的安全漏洞

682
00:34:03,000 --> 00:34:08,000
都是都不是因为测试可以简单的覆盖得到的我觉得

683
00:34:08,000 --> 00:34:10,000
都不是靠测试可以解决的问题

684
00:34:10,000 --> 00:34:11,000
没错没错

685
00:34:11,000 --> 00:34:15,000
就你真的是要去去去证明他每一行代码是金那些推敲的

686
00:34:15,000 --> 00:34:18,000
因为那么有那些 bug 非常非常隐晦

687
00:34:18,000 --> 00:34:22,000
因为通常的测试你根本想不到会是那么一种方式去出错

688
00:34:23,000 --> 00:34:27,000
所以我觉得看那个东西的重要性吧

689
00:34:27,000 --> 00:34:29,000
我觉得如果是足够重要的话

690
00:34:29,000 --> 00:34:32,000
还是要通过形式证明的方式来来看更好

691
00:34:32,000 --> 00:34:34,000
但是我觉得确实没错

692
00:34:34,000 --> 00:34:36,000
对绝大多数这种商业性的项目来讲

693
00:34:37,000 --> 00:34:40,000
你能能能隔在写测试能都已经不错了

694
00:34:40,000 --> 00:34:42,000
你还要求什么形式证明是不是吃人说梦

695
00:34:44,000 --> 00:34:44,000
对

696
00:34:46,000 --> 00:34:48,000
嗯接下来的一篇

697
00:34:49,000 --> 00:34:52,000
呃就是刚才你这个还没念完

698
00:34:52,000 --> 00:34:53,000
你又把这个结尾念完

699
00:34:53,000 --> 00:34:57,000
哦对啊然后大家结尾说了一个一个事情

700
00:34:57,000 --> 00:35:00,000
就是说现在再回过头来看当初的竞赛测试

701
00:35:00,000 --> 00:35:04,000
也许按那个一二三步的流程来能更好的完成比赛

702
00:35:04,000 --> 00:35:09,000
低效程序保证的正确数据生成帮助思考边界条件

703
00:35:10,000 --> 00:35:12,000
最终程序来优化拿高分

704
00:35:12,000 --> 00:35:16,000
总之测试对待价值可能不在于他本身

705
00:35:16,000 --> 00:35:19,000
而在于他给我们带来的对代码更加深入的理解

706
00:35:19,000 --> 00:35:21,000
这个其实我挺认可的

707
00:35:21,000 --> 00:35:22,000
但他刚我忘了说啊

708
00:35:22,000 --> 00:35:24,000
刚才他讲那个一二三步的步骤

709
00:35:24,000 --> 00:35:25,000
为什么会有这个东西

710
00:35:25,000 --> 00:35:29,000
因为在各种各样的这种什么程序竞赛啊

711
00:35:29,000 --> 00:35:32,000
ACM 这么比赛他们他个逻辑一般的是这么给的

712
00:35:32,000 --> 00:35:35,000
他先给你一个所谓的一个题目的描述让你做一件事

713
00:35:36,000 --> 00:35:37,000
然后他会给你一个 sample

714
00:35:38,000 --> 00:35:40,000
就是一个其实就是一个测试的一个样本

715
00:35:40,000 --> 00:35:44,000
然后你要用你的程序跑这个三头看那个大支队不对

716
00:35:44,000 --> 00:35:45,000
你就大支队了

717
00:35:45,000 --> 00:35:49,000
你就把你给你这个程序提交到他们那个一个平台上面去

718
00:35:49,000 --> 00:35:52,000
平台他用这个东西跑一个更大的一个样本

719
00:35:52,000 --> 00:35:56,000
去看你这个代码是否得到的结果是否如如如如如予其所料对吧

720
00:35:57,000 --> 00:35:57,000
这样的话

721
00:35:57,000 --> 00:35:59,000
对如果成都正确的话就说一次

722
00:35:59,000 --> 00:36:02,000
对其实就是有点黑河的意思

723
00:36:02,000 --> 00:36:03,000
就是他给你一个

724
00:36:03,000 --> 00:36:07,000
一小一小一小组数据让你去验证你的程序代码怎么样

725
00:36:07,000 --> 00:36:10,000
所以他在这种用力的场合下

726
00:36:11,000 --> 00:36:13,000
用那个就是他那个一二三

727
00:36:13,000 --> 00:36:15,000
刚才那个步骤来讲其实就还蛮好的

728
00:36:15,000 --> 00:36:17,000
但是我不太清楚在实际工程中

729
00:36:18,000 --> 00:36:21,000
有多少人会遵循这么一种方式去做

730
00:36:22,000 --> 00:36:23,000
嗯对我

731
00:36:24,000 --> 00:36:26,000
呃之前在

732
00:36:27,000 --> 00:36:30,000
呃考森尔上一门课也是

733
00:36:31,000 --> 00:36:34,000
呃基本上也是以 TDD 的方式来查你们作业的

734
00:36:34,000 --> 00:36:34,000
就是

735
00:36:35,000 --> 00:36:36,000
给你一道题然后

736
00:36:38,000 --> 00:36:39,000
让你把程序传上去

737
00:36:39,000 --> 00:36:42,000
他其实本质上就是在后台跑对

738
00:36:42,000 --> 00:36:43,000
跑这个

739
00:36:43,000 --> 00:36:45,000
大堆 Dock test

740
00:36:45,000 --> 00:36:47,000
就是 Python doc test

741
00:36:47,000 --> 00:36:49,000
然后最后来告诉你是不是证据

742
00:36:49,000 --> 00:36:52,000
但在实际生产之中

743
00:36:52,000 --> 00:36:56,000
呃我能想到的基本上就是每天你写完的程序他会

744
00:36:57,000 --> 00:37:00,000
把所有单元测试自动跑一遍

745
00:37:00,000 --> 00:37:03,000
然后告诉你今天写的这些东西

746
00:37:04,000 --> 00:37:05,000
呃质量怎么样

747
00:37:06,000 --> 00:37:07,000
然后也会告诉你说

748
00:37:08,000 --> 00:37:08,000
嗯

749
00:37:10,000 --> 00:37:12,000
比如有个叫 Sona 的

750
00:37:12,000 --> 00:37:15,000
软件可以告诉你说你写的代码没有多少

751
00:37:16,000 --> 00:37:17,000
被测试覆盖到

752
00:37:18,000 --> 00:37:18,000
啊 ok

753
00:37:19,000 --> 00:37:22,000
然后如果你今天写的代码很多

754
00:37:22,000 --> 00:37:24,000
但是覆盖率却降低了的话

755
00:37:24,000 --> 00:37:25,000
你基本上可以知道你

756
00:37:26,000 --> 00:37:29,000
做的东西做的东西出来可能不是特别的可靠

757
00:37:31,000 --> 00:37:32,000
这是一个比较重要的事

758
00:37:32,000 --> 00:37:33,000
这不觉得其实挺悲剧的吗

759
00:37:33,000 --> 00:37:35,000
我觉得如果你写一段代码

760
00:37:36,000 --> 00:37:40,000
你都不能自己在不经过机器测试的情况下

761
00:37:40,000 --> 00:37:42,000
对自己写出代码的质量有错过的信心

762
00:37:43,000 --> 00:37:44,000
啊我觉得

763
00:37:45,000 --> 00:37:48,000
反正我是不太喜欢这种这种心态的至少

764
00:37:48,000 --> 00:37:52,000
就是一切靠带靠测试区给你增加你的自信

765
00:37:53,000 --> 00:37:54,000
我觉得是这样的吧

766
00:37:54,000 --> 00:37:57,000
就是这里面有一个信心计划的过程

767
00:37:57,000 --> 00:38:02,000
你你那些 atnt 早期的黑客们肯定也不是用 tdd 的

768
00:38:02,000 --> 00:38:03,000
哈哈哈哈

769
00:38:04,000 --> 00:38:08,000
你你要在一个比较大的公司里面工作

770
00:38:08,000 --> 00:38:12,000
然后你也没有办法保证你和你的所有的同事们

771
00:38:12,000 --> 00:38:14,000
都能够写出来

772
00:38:14,000 --> 00:38:15,000
同样高质量的代码

773
00:38:16,000 --> 00:38:18,000
然后你也没有把他保证

774
00:38:18,000 --> 00:38:20,000
嗯你的同事

775
00:38:21,000 --> 00:38:23,000
自信满满的写出来代码

776
00:38:23,000 --> 00:38:26,000
就像他希望的那样高质量

777
00:38:26,000 --> 00:38:29,000
那在这个情况下

778
00:38:29,000 --> 00:38:32,000
你怎么样来维护一道准生

779
00:38:33,000 --> 00:38:35,000
那其实大原测试覆盖率

780
00:38:36,000 --> 00:38:37,000
和嗯

781
00:38:38,000 --> 00:38:43,000
大原测试的存在本身就已经是一种保护

782
00:38:43,000 --> 00:38:44,000
一种保障

783
00:38:45,000 --> 00:38:48,000
所以你这么说的潜台词我这么理解哈

784
00:38:48,000 --> 00:38:49,000
就是说

785
00:38:50,000 --> 00:38:52,000
这是一个保障若干平庸的

786
00:38:53,000 --> 00:38:56,000
程序员能够写出质量还凑合过得去的

787
00:38:57,000 --> 00:38:58,000
一个管理手段

788
00:38:59,000 --> 00:39:03,000
嗯我觉得 tdd 在很大程度上就像我说的很印度嘛

789
00:39:03,000 --> 00:39:04,000
就其实就是这个意思

790
00:39:04,000 --> 00:39:08,000
哈哈哈哈对他是工程

791
00:39:08,000 --> 00:39:11,000
就是人类转件工程的规模逐渐大起来

792
00:39:11,000 --> 00:39:15,000
所不得不采用了一种相关的手段

793
00:39:16,000 --> 00:39:17,000
嗯嗯

794
00:39:17,000 --> 00:39:19,000
对啊其实没有太

795
00:39:21,000 --> 00:39:22,000
值得去

796
00:39:23,000 --> 00:39:25,000
呃去吃他的事情

797
00:39:25,000 --> 00:39:26,000
因为

798
00:39:27,000 --> 00:39:29,000
你没有更好的方法

799
00:39:29,000 --> 00:39:32,000
不然不然你找一个怎么样的方法来

800
00:39:32,000 --> 00:39:34,000
来来判断一个代码是不是好

801
00:39:35,000 --> 00:39:35,000
没错

802
00:39:37,000 --> 00:39:40,000
但这其实这里还可以扯到一个就是我们上期节目里面

803
00:39:40,000 --> 00:39:43,000
没有提到的这个测试覆盖率这个指标

804
00:39:44,000 --> 00:39:46,000
你觉得理想的测试覆盖率是多少

805
00:39:46,000 --> 00:39:48,000
嗯其实一个比较幼稚的答案就是

806
00:39:48,000 --> 00:39:49,000
我百分之百负给

807
00:39:50,000 --> 00:39:51,000
其实非常非常难的

808
00:39:51,000 --> 00:39:54,000
而且如果真的要写到百分之百测试的

809
00:39:55,000 --> 00:39:56,000
测试覆盖率的话

810
00:39:57,000 --> 00:39:59,000
嗯可能时间成本是

811
00:40:01,000 --> 00:40:03,000
时间成本是非常惊人对

812
00:40:03,000 --> 00:40:06,000
而且有一些东西是根本没有办法测试

813
00:40:06,000 --> 00:40:08,000
比如说 CSS 你要怎么测试

814
00:40:09,000 --> 00:40:09,000
啊

815
00:40:10,000 --> 00:40:13,000
所以一个比较理想的测试覆盖率

816
00:40:13,000 --> 00:40:15,000
其实是在 50%左右

817
00:40:16,000 --> 00:40:18,000
然后如果你能达到 85%的话呢

818
00:40:18,000 --> 00:40:19,000
基本上就是

819
00:40:20,000 --> 00:40:21,000
极端高质量的代码

820
00:40:23,000 --> 00:40:27,000
等等代码的准量为什么会和测试覆盖率手上关系

821
00:40:27,000 --> 00:40:29,000
就是极端可靠的代码

822
00:40:29,000 --> 00:40:31,000
啊这个意思明白明白

823
00:40:31,000 --> 00:40:33,000
不是高质不一定高质量

824
00:40:33,000 --> 00:40:34,000
但至少是可靠

825
00:40:34,000 --> 00:40:35,000
嗯哼

826
00:40:35,000 --> 00:40:38,000
好吧我们今天进行到进入到下海风格来

827
00:40:39,000 --> 00:40:42,000
这位朋友名字叫张浩忠应该是

828
00:40:43,000 --> 00:40:44,000
嗨吴涛和瑞鲁

829
00:40:44,000 --> 00:40:47,000
我非常喜欢你们主持的 podcast 节目内合红花

830
00:40:47,000 --> 00:40:51,000
限于一个理工科学生语文有限的表扬能力

831
00:40:51,000 --> 00:40:53,000
此处省略一美之词一万次

832
00:40:55,000 --> 00:40:56,000
非常感谢你

833
00:40:57,000 --> 00:40:58,000
这压缩率好高啊

834
00:41:02,000 --> 00:41:04,000
比进屏没的压缩率还高

835
00:41:04,000 --> 00:41:10,000
嗯哼做一个研究方向为 formal verification 的老博士

836
00:41:10,000 --> 00:41:12,000
我将评论一下第十九期之中

837
00:41:12,000 --> 00:41:14,000
规于 formal verification 的部分内容

838
00:41:15,000 --> 00:41:17,000
终于来了专业人士我好激动

839
00:41:18,000 --> 00:41:22,000
首先如两位主播所言 formal verification 的中文翻译

840
00:41:22,000 --> 00:41:25,000
通常为形式化验证

841
00:41:25,000 --> 00:41:28,000
至于仅讨论对软件的 formal verification

842
00:41:28,000 --> 00:41:31,000
其实 formal verification 和测试

843
00:41:32,000 --> 00:41:34,000
都在试图解决相同的问题

844
00:41:34,000 --> 00:41:38,000
也就是给定人们对一个程序的行为的预期

845
00:41:38,000 --> 00:41:41,000
例如给什么样的输出有什么样的输入

846
00:41:42,000 --> 00:41:44,000
啊给什么样的输出有什么样输出

847
00:41:45,000 --> 00:41:46,000
with second

848
00:41:46,000 --> 00:41:49,000
给什么样的输入有什么样的输出

849
00:41:50,000 --> 00:41:53,000
运行的时间效率甚至程序的功耗等等

850
00:41:54,000 --> 00:41:56,000
呃以及这个程序本身

851
00:41:56,000 --> 00:41:58,000
构建一个 vitness

852
00:41:58,000 --> 00:42:02,000
以表明这个程序的确能够的确能够提供预期的行为

853
00:42:03,000 --> 00:42:06,000
通常我们称这些预期行为为程序的规范

854
00:42:06,000 --> 00:42:08,000
也就是 specification

855
00:42:09,000 --> 00:42:13,000
而称这个程序本身为这个 specification 的一个实现

856
00:42:13,000 --> 00:42:15,000
也就是 implementation

857
00:42:16,000 --> 00:42:19,000
formal verification 和测试使用不同的手段来

858
00:42:19,000 --> 00:42:21,000
试图构造这样一个 vitness

859
00:42:22,000 --> 00:42:24,000
对于 formal verification 来说

860
00:42:24,000 --> 00:42:29,000
它使用数学和逻辑语言表示 specification 和 implementation

861
00:42:29,000 --> 00:42:33,000
并通过数学和逻辑严格证明 implementation

862
00:42:33,000 --> 00:42:39,000
在任何可能的情况下都能够满足 specification

863
00:42:40,000 --> 00:42:42,000
而对于测试在很多情况之下

864
00:42:43,000 --> 00:42:47,000
specification 使用和 implementation 一样的原调

865
00:42:47,000 --> 00:42:49,000
也就是一个一个的测试用力

866
00:42:50,000 --> 00:42:53,000
测试保障如果一个测试用力被执行到

867
00:42:54,000 --> 00:42:57,000
那么可以通过这个测试用力的执行结果

868
00:42:57,000 --> 00:42:59,000
来检查 implementation 的证据与否

869
00:43:00,000 --> 00:43:03,000
但是如果一个测试用力没有被执行到

870
00:43:03,000 --> 00:43:07,000
或者测试用力没有覆盖到程序的所有可能执行路径

871
00:43:08,000 --> 00:43:09,000
那么测试就无能为力

872
00:43:10,000 --> 00:43:15,000
似乎这样看来 formal verification 可以提供比测试更严格和有效的

873
00:43:15,000 --> 00:43:18,000
对于程序正确性的保证

874
00:43:19,000 --> 00:43:21,000
理应在工业界得到更为广泛的应用

875
00:43:22,000 --> 00:43:26,000
但是目前而言 formal verification 的性价比太低

876
00:43:26,000 --> 00:43:29,000
并且对于使用者的要求也太高了

877
00:43:30,000 --> 00:43:32,000
一方面平均验证一行源程序

878
00:43:33,000 --> 00:43:37,000
大概需要几百行甚至更多的形式化证明代码

879
00:43:37,000 --> 00:43:42,000
口号是的我们有专门用于形式化证明的程序

880
00:43:43,000 --> 00:43:43,000
口号结束

881
00:43:44,000 --> 00:43:46,000
而且在很多情况之下

882
00:43:46,000 --> 00:43:48,000
这些证明没有办法自动生成

883
00:43:48,000 --> 00:43:51,000
并且要耗费大量的时间去创造

884
00:43:52,000 --> 00:43:56,000
另一方面对于能够进行 formal verification 的人

885
00:43:57,000 --> 00:44:01,000
他既要对验证的对象有着深刻的理解

886
00:44:02,000 --> 00:44:06,000
比如我为了验证一个 hypervisor 中很小的一部分功能

887
00:44:06,000 --> 00:44:11,000
从零开始写了一个能够实际工作在 X 86 机器上的

888
00:44:11,000 --> 00:44:15,000
可以同时运行多个 Linux 虚拟机的实验性的 hypervisor

889
00:44:16,000 --> 00:44:16,000
口号完毕

890
00:44:17,000 --> 00:44:23,000
又要有足够和复杂的数学与逻辑学知识

891
00:44:23,000 --> 00:44:28,000
口号各种抽象代数数例逻辑集合论犯筹论什么的

892
00:44:28,000 --> 00:44:29,000
口号结束

893
00:44:30,000 --> 00:44:35,000
相对而言目前的测试则可以在相对可控的成本之下提供不完美

894
00:44:35,000 --> 00:44:39,000
但是在多数情况下足够好和亦于实现的解决方案

895
00:44:40,000 --> 00:44:43,000
其次我要吐槽一下节目中所说到的

896
00:44:44,000 --> 00:44:49,000
对于非确定对于非确定性的程序很难验证只好测试的关键

897
00:44:50,000 --> 00:44:51,000
而这好像是我说的吧

898
00:44:52,000 --> 00:45:00,000
恰恰相反对于非确定性程序特别是并化程序和操作系统内核之中设计中断的代码

899
00:45:00,000 --> 00:45:05,000
formal verification 可以非常简洁和严格的表达并证明他们的证决性

900
00:45:06,000 --> 00:45:09,000
而测试此时更多是向来碰运气

901
00:45:09,000 --> 00:45:13,000
以操作系统内核中可以被中断的代码片段为例

902
00:45:13,000 --> 00:45:18,000
在这个代码片段的每一条指令的执行可能被中断打断

903
00:45:18,000 --> 00:45:21,000
也就是说每一条指令的执行有可能有二条路径

904
00:45:22,000 --> 00:45:27,000
所以一个包含 n 条路径的 n 条指令的代码段可能有二

905
00:45:28,000 --> 00:45:31,000
Rest the power of n 个执行路径

906
00:45:31,000 --> 00:45:35,000
因为在实际的机器上中断的发生是不确定的

907
00:45:35,000 --> 00:45:41,000
所以测试很难保证在短时间内能够覆盖到所有执行路径

908
00:45:42,000 --> 00:45:45,000
相对的在 formal verification 之中举个例子

909
00:45:46,000 --> 00:45:50,000
我们可以把每条指令的执行化形式表彻成

910
00:45:52,000 --> 00:45:53,000
这应该怎么念

911
00:45:54,000 --> 00:45:55,000
你怎么能想念

912
00:45:56,000 --> 00:45:57,000
pcq

913
00:45:58,000 --> 00:46:01,000
其中 c 是这条指令 p 称为前条件

914
00:46:01,000 --> 00:46:03,000
也就是 precondition

915
00:46:03,000 --> 00:46:07,000
它描述了 c 支 c 执行之前机器的状态

916
00:46:08,000 --> 00:46:10,000
例如某个基层器的直是什么

917
00:46:10,000 --> 00:46:12,000
某个内存单元的直是什么

918
00:46:12,000 --> 00:46:15,000
通常不需要覆盖所有的基层器的内存单元

919
00:46:16,000 --> 00:46:22,000
仅需要根据验证的 specification 宣称我们说关系那么多

920
00:46:23,000 --> 00:46:25,000
q 称为后条件也就是 post condition

921
00:46:26,000 --> 00:46:29,000
它描述了 c 执行之后的机器状态

922
00:46:29,000 --> 00:46:36,000
注意这里的 q 同时描述了 c 被中断和不被中断的

923
00:46:36,000 --> 00:46:37,000
执行之后的机器状态

924
00:46:38,000 --> 00:46:46,000
非形式化的 pcq 表示在满足前条件 p 的机器上执行 c 之后

925
00:46:47,000 --> 00:46:49,000
得到的机器状态满足后条件 q

926
00:46:50,000 --> 00:46:54,000
这样一来对于上述一个太表变段 c 1 c 2

927
00:46:54,000 --> 00:47:01,000
一直到 cn 我们有 p 下标 1 c 下标 1 q 下标 1

928
00:47:01,000 --> 00:47:04,000
p 下标 2 c 下标 2 q 下标 2

929
00:47:04,000 --> 00:47:08,000
一直到 p 下标 nc 下标 nq 下标 n

930
00:47:08,000 --> 00:47:11,000
然后我们可以证明 q 下标 1

931
00:47:12,000 --> 00:47:15,000
应该怎么样推倒出

932
00:47:17,000 --> 00:47:18,000
implies

933
00:47:19,000 --> 00:47:20,000
应该是 implies

934
00:47:20,000 --> 00:47:24,000
然后我们可以证明出如果有 qe 那么一定有 pr

935
00:47:25,000 --> 00:47:25,000
嗯

936
00:47:28,000 --> 00:47:34,000
哎不对这个是然后我们可以证明 q 下标 1 可以推倒出 p 下标 2

937
00:47:34,000 --> 00:47:39,000
一直到 q 下标 n-1 可以推倒出 p 下标 n

938
00:47:40,000 --> 00:47:45,000
从而可以证明 p 1 p 下标 1 c 下标 1 c 下标 2

939
00:47:46,000 --> 00:47:49,000
一直到 c 下标 nq 下标 n

940
00:47:50,000 --> 00:47:57,000
同样的如果在这个代码片段的 spacification 可以写成例如 pc 下标 1 c 下标 2

941
00:47:59,000 --> 00:48:03,000
一直到 c 下标 nq 我们只需要再证明 p

942
00:48:04,000 --> 00:48:08,000
可以推倒出 p 下标 1 和 q 下标 n 可以推倒出 q

943
00:48:09,000 --> 00:48:15,000
也就是也就可以证明这个代码片段的确满足了给定的 specification

944
00:48:16,000 --> 00:48:21,000
因为这里的 pqp 下标 iq 下标 i 等等描述了所有的可能状况

945
00:48:21,000 --> 00:48:24,000
并且只需要描述 specification 关心的部分

946
00:48:25,000 --> 00:48:28,000
所以这里的 formal verification 比测试更加完美和简洁

947
00:48:28,000 --> 00:48:33,000
在实际工作中我们往往会针对验证的所有的程序的特点

948
00:48:33,000 --> 00:48:38,000
设定特征的逻辑系统以进一步降低证明的难度和复杂度

949
00:48:40,000 --> 00:48:40,000
我

950
00:48:41,000 --> 00:48:44,000
我在读这段文章的时候大概明白他在说什么

951
00:48:44,000 --> 00:48:47,000
但是我念出来之后发现自己根本不明白他在说什么

952
00:48:48,000 --> 00:48:49,000
其实很简单吧

953
00:48:49,000 --> 00:48:50,000
刚才那一段话

954
00:48:50,000 --> 00:48:53,000
你听众肯定是没听明白的

955
00:48:53,000 --> 00:48:54,000
你没有看见那个东西

956
00:48:54,000 --> 00:48:58,000
我觉得这一段还是比较把他 posed 来比较好

957
00:48:59,000 --> 00:49:02,000
其实那句话也其实有个比较直白的解释

958
00:49:02,000 --> 00:49:04,000
就是说你有一串代码

959
00:49:05,000 --> 00:49:09,000
每一步都会有一个所谓的前条件

960
00:49:09,000 --> 00:49:10,000
所以前因后果

961
00:49:10,000 --> 00:49:14,000
你执行在这个步驟之前是一个什么样的状况

962
00:49:14,000 --> 00:49:16,000
执行之后你预期它是什么样的状况

963
00:49:16,000 --> 00:49:21,000
然后如果你能够把前面一条代码的结果推到那个状况

964
00:49:22,000 --> 00:49:27,000
推到之后面一个一行代码的这个叫做前因

965
00:49:27,000 --> 00:49:29,000
你能把东西连续的串起来

966
00:49:29,000 --> 00:49:33,000
你能证明这个东西整个代码片段的可高兴

967
00:49:33,000 --> 00:49:36,000
你能把他弄成这个是我上学的时候

968
00:49:37,000 --> 00:49:40,000
不停写作业要做的一个一部分

969
00:49:40,000 --> 00:49:42,000
现在看来就是好痛苦啊

970
00:49:43,000 --> 00:49:45,000
ok 所以其实它就是一个状态机

971
00:49:45,000 --> 00:49:48,000
然后如果你能证明这个状态机的每一步都是可以

972
00:49:49,000 --> 00:49:50,000
达到了或者说每一步

973
00:49:50,000 --> 00:49:53,000
状态机的每一个状态都是彼此相连的

974
00:49:53,000 --> 00:49:56,000
那整个状态机的可靠性就是可为验证

975
00:49:56,000 --> 00:49:57,000
大概是这个意思吗

976
00:49:58,000 --> 00:49:59,000
有点那个意思

977
00:49:59,000 --> 00:50:01,000
ok 我没有学过这种东西

978
00:50:02,000 --> 00:50:04,000
我们通讯就是不学这种人头大

979
00:50:05,000 --> 00:50:09,000
其实它不算难

980
00:50:09,000 --> 00:50:11,000
但是非常繁琐

981
00:50:12,000 --> 00:50:13,000
感觉像接九年环

982
00:50:13,000 --> 00:50:15,000
你要对对对非常要

983
00:50:15,000 --> 00:50:16,000
要一样一样一样

984
00:50:16,000 --> 00:50:18,000
一部分需要达到前面

985
00:50:18,000 --> 00:50:20,000
对对对你要一部分去弄那个东西

986
00:50:20,000 --> 00:50:22,000
其实所以为什么讲

987
00:50:22,000 --> 00:50:24,000
要有专门的这个这个程序

988
00:50:24,000 --> 00:50:26,000
那个那种语言去什么

989
00:50:26,000 --> 00:50:30,000
基于各种各样的 logic 的方法去

990
00:50:30,000 --> 00:50:31,000
去证明的东西

991
00:50:31,000 --> 00:50:33,000
就是想把这个繁琐的东西

992
00:50:33,000 --> 00:50:35,000
一些话让继续去做

993
00:50:35,000 --> 00:50:38,000
我们人只用把那个 specification 给好就可以了

994
00:50:38,000 --> 00:50:40,000
但是其实你在真正在做的时候

995
00:50:40,000 --> 00:50:43,000
就正如那个就是吗

996
00:50:43,000 --> 00:50:44,000
张博士所言

997
00:50:44,000 --> 00:50:47,000
你为了验证一行代码的这个可靠性

998
00:50:47,000 --> 00:50:50,000
然后去去证明它是否符合这个某个 spec

999
00:50:51,000 --> 00:50:53,000
你肯定要再写好多好多遍的代码

1000
00:50:55,000 --> 00:50:56,000
对没错

1001
00:50:57,000 --> 00:50:58,000
接着讲这封信

1002
00:50:58,000 --> 00:51:01,000
另一个体现 formal verification 比测试强大的地方

1003
00:51:01,000 --> 00:51:06,000
是对于各种 logless algorithm 的实现的正确性的验证

1004
00:51:06,000 --> 00:51:10,000
就是无所的算法的实现的正确性验证

1005
00:51:10,000 --> 00:51:13,000
这是一个非常大和复杂的话题

1006
00:51:13,000 --> 00:51:14,000
这里就不展开了

1007
00:51:14,000 --> 00:51:19,000
另外学术界一直以来都试图将 formal verification 的应用

1008
00:51:19,000 --> 00:51:22,000
应用到实际的软件开发之中

1009
00:51:22,000 --> 00:51:26,000
目前两个作为主目的结果是 sell for

1010
00:51:26,000 --> 00:51:32,000
它是对一个 V 内和操作系统的完整的形式化验者

1011
00:51:33,000 --> 00:51:34,000
它的网址都很酷

1012
00:51:34,000 --> 00:51:40,000
叫做 htps slash slash sell

1013
00:51:40,000 --> 00:51:43,000
sell for dot systems

1014
00:51:45,000 --> 00:51:48,000
所以 dot systems 是一个顶级域名吗

1015
00:51:48,000 --> 00:51:49,000
你不知道吗

1016
00:51:49,000 --> 00:51:52,000
现在有一批各种各样其实怪我新的顶级域冒出来

1017
00:51:52,000 --> 00:51:53,000
对我知道

1018
00:51:53,000 --> 00:51:56,000
xxx 但是好像没有听说过 systems

1019
00:51:56,000 --> 00:52:00,000
有多了有 dot systems 还有各种好像有 dot beer 吧

1020
00:52:02,000 --> 00:52:03,000
你可以注册一个

1021
00:52:04,000 --> 00:52:07,000
然后还有一个叫做 comp cert

1022
00:52:07,000 --> 00:52:13,000
是法国英瑞亚实现的一个验证过的 CUN 编辑

1023
00:52:14,000 --> 00:52:18,000
曾经用在 Airbus 空客的记载软件的开发之中

1024
00:52:18,000 --> 00:52:20,000
这个很吊

1025
00:52:20,000 --> 00:52:21,000
这个很吊

1026
00:52:21,000 --> 00:52:24,000
网址是 htps slash slash comp cert

1027
00:52:25,000 --> 00:52:31,000
sale ornpcert dot inr i a dot fr

1028
00:52:32,000 --> 00:52:36,000
最后既然节目中提到的 TDD 和 BDD

1029
00:52:36,000 --> 00:52:40,000
那我就不得不提到 formal verification 之中对应的

1030
00:52:40,000 --> 00:52:43,000
叫做 program synthesis 的东西

1031
00:52:44,000 --> 00:52:46,000
程序合成的东西

1032
00:52:46,000 --> 00:52:50,000
简单的来说就是软件开发要先写 specification

1033
00:52:50,000 --> 00:52:53,000
和程序满足 specification 的数学证明

1034
00:52:53,000 --> 00:52:58,000
然后从这些证明自动生成满足 specification 的程序

1035
00:52:58,000 --> 00:53:02,000
前面提到了 comp cert 主要就是用这种方法开发出来的

1036
00:53:02,000 --> 00:53:07,000
简单来说这个东西基于这样一个已经被证明的数学理论基础

1037
00:53:08,000 --> 00:53:10,000
证计算和证明是等价的

1038
00:53:11,000 --> 00:53:13,000
当然这么牛逼闪闪的东西

1039
00:53:14,000 --> 00:53:17,000
目前还有大量的理论和工程方面的问题需要解决

1040
00:53:17,000 --> 00:53:21,000
所以广大程序源在有生之年无需失业

1041
00:53:21,000 --> 00:53:24,000
而我在有生之年也不太靠这个东西发家是富的

1042
00:53:25,000 --> 00:53:26,000
大概就是这些

1043
00:53:27,000 --> 00:53:32,000
刚才读到这些就读到这一部分的时候我信一领

1044
00:53:33,000 --> 00:53:37,000
想说我靠要是被这帮 freakman 搞出来

1045
00:53:37,000 --> 00:53:42,000
那我们这些就瞎干嘛自己的对吃程序饭的人该怎么办的

1046
00:53:43,000 --> 00:53:45,000
结果他说有生之年无需担心失业

1047
00:53:45,000 --> 00:53:47,000
我心里的理科大师他就放了

1048
00:53:48,000 --> 00:53:50,000
对因为现在你说什么

1049
00:53:51,000 --> 00:53:56,000
就是蓝领的工种被各种各样的机械化自动化的东西替代掉了

1050
00:53:56,000 --> 00:53:57,000
是吧

1051
00:53:57,000 --> 00:54:03,000
反正我觉得是否在我们挂掉之前还不用担心这个程序源在工程被自动化掉

1052
00:54:04,000 --> 00:54:09,000
嗯但是他提到这件事就是计算和证明是等价的

1053
00:54:10,000 --> 00:54:10,000
嗯

1054
00:54:12,000 --> 00:54:15,000
所以一切可计算的东西都是可以证明

1055
00:54:16,000 --> 00:54:20,000
这不是跟那个 p 等是否等于 np 那个东西是一个原理吗

1056
00:54:21,000 --> 00:54:24,000
哎呦数啊对是对吧

1057
00:54:24,000 --> 00:54:26,000
呃 pnp 是验证的可以

1058
00:54:27,000 --> 00:54:33,000
这个呃这样我想到一件事情就是我们在幕谣请问幕谣那一期的时候提到说如果

1059
00:54:34,000 --> 00:54:38,000
呃计算机能够做数学题的话那他能不能证明数学题呢

1060
00:54:39,000 --> 00:54:47,000
就呃我记得当时在 mvblog 里面提到说如果一个一台计算机可以证明一件东西的话呢

1061
00:54:47,000 --> 00:54:50,000
是将会是非常了不起的一件事

1062
00:54:50,000 --> 00:54:57,000
但是呃很遗憾的就是我们人类都有时候不太清楚自己证明一个东西到底是怎样的一个过程

1063
00:54:58,000 --> 00:54:58,000
嗯

1064
00:55:00,000 --> 00:55:07,000
就我觉得如果脑洞大黑有了这个你告诉计算机说我要一个神明的程序

1065
00:55:07,000 --> 00:55:11,000
就是给出这样一个程序的 specification

1066
00:55:12,000 --> 00:55:17,000
呃你还是要用自己的脑力来证明这个 specification

1067
00:55:18,000 --> 00:55:20,000
是可以为算出来

1068
00:55:20,000 --> 00:55:23,000
这个过程终究还是不能用计算机来提起来

1069
00:55:23,000 --> 00:55:27,000
所以也许将来的程序我们不一定需要自己去写程序的

1070
00:55:27,000 --> 00:55:29,000
他们仍就需要自己去想出来

1071
00:55:30,000 --> 00:55:32,000
这个程序为什么可以为写出来

1072
00:55:32,000 --> 00:55:35,000
哈哈哈哈感觉又难了一些了

1073
00:55:36,000 --> 00:55:38,000
生活又艰辛了一点点

1074
00:55:38,000 --> 00:55:46,000
对将来就不是将来写程序这个职业就不再是一个仅仅受过中学教育

1075
00:55:47,000 --> 00:55:53,000
呃和一定培训的人就可以胜任的工作了不像现在你的意思是说蓝翔要关门了

1076
00:55:55,000 --> 00:55:59,000
啊其实我觉得是一件好事吧就是现在

1077
00:56:00,000 --> 00:56:02,000
你看我这样的人都可以来转行写程序

1078
00:56:03,000 --> 00:56:04,000
哈哈哈哈

1079
00:56:04,000 --> 00:56:06,000
这自黑的漂亮

1080
00:56:06,000 --> 00:56:08,000
对三方三方人程序的

1081
00:56:09,000 --> 00:56:12,000
光环变得没有那么圣洁了是不是

1082
00:56:13,000 --> 00:56:15,000
对是一个邪恶光环

1083
00:56:15,000 --> 00:56:17,000
哈哈哈哈

1084
00:56:18,000 --> 00:56:23,000
OK 好啊接下来是一个非常重头的反馈啊

1085
00:56:23,000 --> 00:56:27,000
这位听众朋友不但写了一封很长什么信

1086
00:56:27,000 --> 00:56:32,000
最后还录了一个将近一个小时的视频

1087
00:56:32,000 --> 00:56:33,000
来向我们展示的 TDD

1088
00:56:35,000 --> 00:56:36,000
哈哈哈哈

1089
00:56:36,000 --> 00:56:37,000
怎么办

1090
00:56:37,000 --> 00:56:41,000
来吧我来吧啊嗨啊无常后悠

1091
00:56:41,000 --> 00:56:48,000
飞首先非常喜欢听你们的节目已经重头追了一遍受益非浅也是这反馈似的

1092
00:56:49,000 --> 00:56:53,000
做一个已经被成功安利的 TDD 和

1093
00:56:54,000 --> 00:56:55,000
pair programming

1094
00:56:55,000 --> 00:56:57,000
这叫什么绝对变成是吧

1095
00:56:57,000 --> 00:56:59,000
对剑性者杨维尔一会儿剑吧

1096
00:57:00,000 --> 00:57:02,000
对的剑性者那个剑哈

1097
00:57:03,000 --> 00:57:04,000
哈哈

1098
00:57:05,000 --> 00:57:10,000
最近四年的代码就几乎都是被测试驱动出来的可见中毒之声

1099
00:57:10,000 --> 00:57:12,000
我想反馈一些我自己的体会

1100
00:57:13,000 --> 00:57:15,000
我个人理解当然测试有两种作用

1101
00:57:15,000 --> 00:57:20,000
一个是保障作用保证代码还是在按预期交付业务价值

1102
00:57:20,000 --> 00:57:22,000
这个就不提另外一个是驱动作用

1103
00:57:22,000 --> 00:57:24,000
就是 TDD 中间那个 driven

1104
00:57:24,000 --> 00:57:28,000
大家谈论 TDD 的时候经常忽略的也就是这个 driven

1105
00:57:28,000 --> 00:57:29,000
而关注在 test 的时候

1106
00:57:30,000 --> 00:57:32,000
当 test 起 driven 作用的时候

1107
00:57:33,000 --> 00:57:34,000
一旦 driven 东西完成

1108
00:57:34,000 --> 00:57:37,000
也就是实现被 driven 出来后

1109
00:57:38,000 --> 00:57:40,000
理论就可以被删除

1110
00:57:40,000 --> 00:57:43,000
这叫做没读通算的

1111
00:57:44,000 --> 00:57:47,000
它意思就是当 test 起 driven 作用的时候

1112
00:57:48,000 --> 00:57:49,000
也就是说

1113
00:57:49,000 --> 00:57:53,000
这个 test 在驱使你一些 test 的时候

1114
00:57:55,000 --> 00:57:59,000
它只是一个动力或者说它只是一个刺激源

1115
00:57:59,000 --> 00:58:02,000
它刺激你说我把这些 test 都满足了

1116
00:58:02,000 --> 00:58:04,000
然后我的代码也就写出来

1117
00:58:05,000 --> 00:58:06,000
OK 这么理解

1118
00:58:07,000 --> 00:58:12,000
但写都写了稍微虚拥你就可以留着继续发挥余热

1119
00:58:12,000 --> 00:58:16,000
转化为可以起到保障作用的单元测试和乐而不为

1120
00:58:16,000 --> 00:58:18,000
那 driven 的作用

1121
00:58:18,000 --> 00:58:19,000
我再插一句

1122
00:58:19,000 --> 00:58:21,000
它意思就是你要销个楼

1123
00:58:21,000 --> 00:58:24,000
你销个搅手架

1124
00:58:25,000 --> 00:58:26,000
然后再盖这个楼

1125
00:58:27,000 --> 00:58:29,000
理论上楼盖好之后搅手架就应该拆除了

1126
00:58:29,000 --> 00:58:34,000
但是在软件的世界里面做这样的比喻实际上是不恰的

1127
00:58:34,000 --> 00:58:36,000
在软件的世界里面

1128
00:58:36,000 --> 00:58:39,000
这个楼可能是要继续生长和变化的

1129
00:58:40,000 --> 00:58:42,000
此时如果你一开始搭的教授架

1130
00:58:42,000 --> 00:58:44,000
那你搭可以留着教授架

1131
00:58:44,000 --> 00:58:47,000
如果这个变化是在预期之外的话

1132
00:58:47,000 --> 00:58:50,000
这个教授架可能就会被撞倒

1133
00:58:50,000 --> 00:58:54,000
然后你就知道这个东西已经在你这一部分的更改

1134
00:58:54,000 --> 00:58:57,000
已经变更稳

1135
00:58:57,000 --> 00:59:00,000
我们一开始对于建筑的预期大概是这样一个

1136
00:59:00,000 --> 00:59:02,000
我想能想到一个比较合适的比喻

1137
00:59:02,000 --> 00:59:03,000
大概是

1138
00:59:05,000 --> 00:59:06,000
接着说

1139
00:59:06,000 --> 00:59:09,000
那 driven 的作用是如何被体现的呢

1140
00:59:09,000 --> 00:59:13,000
我们习惯的开发思路可以理解是自上而下的

1141
00:59:13,000 --> 00:59:14,000
top-down approach 对吧

1142
00:59:14,000 --> 00:59:20,000
就碰到一个问题或需求先做完备的设计再来实现

1143
00:59:20,000 --> 00:59:25,000
而 TDD 所体现的只是一个相反的自下而上的这么一个模式

1144
00:59:25,000 --> 00:59:30,000
就是说程序的设计和算法不斥说在你开始写之前

1145
00:59:30,000 --> 00:59:32,000
就要想清楚的所有细节

1146
00:59:32,000 --> 00:59:35,000
而是可以基于对目标的任务进行分解

1147
00:59:35,000 --> 00:59:38,000
以及实现的逐步演进

1148
00:59:38,000 --> 00:59:42,000
并通过每次红绿 Cycle 后的重够被驱动出来

1149
00:59:43,000 --> 00:59:44,000
哇好多数

1150
00:59:44,000 --> 00:59:47,000
红绿 Cycle 就是一开始没通过

1151
00:59:47,000 --> 00:59:48,000
然后你写好了

1152
00:59:48,000 --> 00:59:50,000
他通过老是挂的

1153
00:59:50,000 --> 00:59:51,000
各种测试

1154
00:59:51,000 --> 00:59:51,000
老是挂

1155
00:59:51,000 --> 00:59:52,000
然后就绿了一下

1156
00:59:52,000 --> 00:59:53,000
又红了

1157
00:59:53,000 --> 00:59:54,000
接着改又绿了

1158
00:59:55,000 --> 00:59:59,000
好处恰恰就是 RealSoTOOS 好的那种外包公司

1159
00:59:59,000 --> 01:00:03,000
所能达到的刚刚好满足需求的实现

1160
01:00:03,000 --> 01:00:06,000
不过我觉得满足在满足所有业务需求的前提下

1161
01:00:06,000 --> 01:00:09,000
刚刚好不一定就是坏事

1162
01:00:09,000 --> 01:00:12,000
正好契合当今经易的思想

1163
01:00:12,000 --> 01:00:13,000
这个我不反对

1164
01:00:13,000 --> 01:00:15,000
我觉得这个确实是很好的

1165
01:00:15,000 --> 01:00:17,000
前提是有重够的保证

1166
01:00:17,000 --> 01:00:19,000
这种刚刚好的实现

1167
01:00:19,000 --> 01:00:21,000
也是已经消除了

1168
01:00:21,000 --> 01:00:24,000
识别出的 BatSmell 就是

1169
01:00:24,000 --> 01:00:25,000
坏味道

1170
01:00:25,000 --> 01:00:27,000
对坏味道

1171
01:00:27,000 --> 01:00:28,000
例如代码重复

1172
01:00:28,000 --> 01:00:29,000
各种 Switch

1173
01:00:29,000 --> 01:00:30,000
还有非常长的方法

1174
01:00:30,000 --> 01:00:31,000
或者函数的

1175
01:00:33,000 --> 01:00:36,000
比较干净的实现

1176
01:00:36,000 --> 01:00:38,000
我靠这怎么念

1177
01:00:39,000 --> 01:00:40,000
这种刚刚好的实现

1178
01:00:40,000 --> 01:00:43,000
也就是已经消除了识别出的 BatSmell

1179
01:00:43,000 --> 01:00:45,000
之后比较 clean 的实现

1180
01:00:45,000 --> 01:00:46,000
对

1181
01:00:46,000 --> 01:00:47,000
对错

1182
01:00:47,000 --> 01:00:50,000
而这两种开放模式也没有好坏之分

1183
01:00:50,000 --> 01:00:51,000
只是这两种开放模式

1184
01:00:51,000 --> 01:00:52,000
一个是字顶上上

1185
01:00:52,000 --> 01:00:56,000
还是这下而上的两种区分方式

1186
01:00:56,000 --> 01:00:58,000
只是思考的问题和方向的问题

1187
01:00:58,000 --> 01:01:00,000
可能最终的结果是一致的

1188
01:01:02,000 --> 01:01:03,000
对吧

1189
01:01:04,000 --> 01:01:05,000
其实这怎么说呢

1190
01:01:05,000 --> 01:01:09,000
就这种大概念性的遵朝

1191
01:01:09,000 --> 01:01:10,000
其实也没有什么太大的用途

1192
01:01:10,000 --> 01:01:14,000
就是有些人习惯于先有一个大的轰度

1193
01:01:14,000 --> 01:01:15,000
跟写作玩一样的

1194
01:01:15,000 --> 01:01:18,000
有些人习惯说先来把提缸写出来

1195
01:01:18,000 --> 01:01:18,000
对吧

1196
01:01:18,000 --> 01:01:20,000
然后再来听这些天西之摸眼

1197
01:01:20,000 --> 01:01:21,000
有人喜欢写撒萌嘛

1198
01:01:21,000 --> 01:01:23,000
就是他一定要编写编弩

1199
01:01:23,000 --> 01:01:25,000
然后再先拼出来看

1200
01:01:25,000 --> 01:01:26,000
诶 写出了这么个东西

1201
01:01:27,000 --> 01:01:31,000
对 我小时候会经常写一些很

1202
01:01:31,000 --> 01:01:33,000
没有上下来的片段

1203
01:01:33,000 --> 01:01:34,000
然后最后拼在一起

1204
01:01:34,000 --> 01:01:35,000
是吧

1205
01:01:35,000 --> 01:01:38,000
最后写作玩的时候可以想起来一个段子

1206
01:01:38,000 --> 01:01:39,000
然后拼进去

1207
01:01:41,000 --> 01:01:45,000
它是有一个什么 TDD 实施的三个步骤

1208
01:01:45,000 --> 01:01:46,000
用它自己的理解是说

1209
01:01:46,000 --> 01:01:46,000
先写一个测试

1210
01:01:46,000 --> 01:01:48,000
然后让边缘通过

1211
01:01:48,000 --> 01:01:49,000
这个上次我们已经提到过

1212
01:01:49,000 --> 01:01:51,000
就是只让你已经解释过一次

1213
01:01:51,000 --> 01:01:53,000
就是只编写能恰好

1214
01:01:53,000 --> 01:01:55,000
让所有测试通过了代码

1215
01:01:55,000 --> 01:01:56,000
然后不断的重购

1216
01:01:56,000 --> 01:01:58,000
然后去反复这个过程

1217
01:01:58,000 --> 01:02:00,000
然后消灭掉所有的那些什么 Best Smell

1218
01:02:01,000 --> 01:02:02,000
但就我们那期节目中

1219
01:02:02,000 --> 01:02:05,000
他说本期节目中没有提到重购

1220
01:02:05,000 --> 01:02:08,000
这也是人们在谈论 TDD 中经常忽略的

1221
01:02:08,000 --> 01:02:10,000
如果没有重购这个步骤的话

1222
01:02:10,000 --> 01:02:13,000
理论上确实所有的逻辑都可以通过

1223
01:02:13,000 --> 01:02:14,000
无数的 EVE 穷语

1224
01:02:14,000 --> 01:02:17,000
输入语输出的硬设来实现

1225
01:02:17,000 --> 01:02:18,000
所以还是挺寒暑

1226
01:02:18,000 --> 01:02:22,000
这其实也有可能是将来计算机写成续的

1227
01:02:22,000 --> 01:02:23,000
一种方法

1228
01:02:23,000 --> 01:02:27,000
爆裂把你所有可能需要的场景

1229
01:02:27,000 --> 01:02:28,000
全都自动生成语言

1230
01:02:28,000 --> 01:02:29,000
然后程序就写出来

1231
01:02:29,000 --> 01:02:30,000
对

1232
01:02:31,000 --> 01:02:32,000
我们都知道这样是不对的

1233
01:02:32,000 --> 01:02:35,000
代码将很快陷入浮化

1234
01:02:35,000 --> 01:02:38,000
我想这也是为什么节目中说可以调设代码

1235
01:02:38,000 --> 01:02:40,000
都是啰嗦的代码的原因之一

1236
01:02:40,000 --> 01:02:44,000
总之我个人认为没有重购的 TDD

1237
01:02:44,000 --> 01:02:45,000
都是耍流氓

1238
01:02:45,000 --> 01:02:49,000
如果说前两步保证我们的代码实现了业务价值

1239
01:02:49,000 --> 01:02:52,000
那重购就保证我们代码本身的质量和设计

1240
01:02:52,000 --> 01:02:54,000
从而避免代码的快速浮化

1241
01:02:54,000 --> 01:02:58,000
只有这样才能体现 TDD 的价值和好处

1242
01:02:58,000 --> 01:03:01,000
但一个重要的前提是测试要写对

1243
01:03:01,000 --> 01:03:03,000
否则很容易适得起反

1244
01:03:03,000 --> 01:03:05,000
严重影响重购以及变化

1245
01:03:05,000 --> 01:03:09,000
最简单的就是重购的时候需要修改测试

1246
01:03:09,000 --> 01:03:10,000
刚才我们已经提到这个问题了

1247
01:03:10,000 --> 01:03:12,000
就是你重购的个人中

1248
01:03:13,000 --> 01:03:15,000
这个导致接口变了

1249
01:03:15,000 --> 01:03:17,000
那么你这个测试就要重写

1250
01:03:17,000 --> 01:03:19,000
这就是其实在他看来

1251
01:03:19,000 --> 01:03:23,000
这个是这个什么测试写的不好的一个一个一个典范

1252
01:03:23,000 --> 01:03:25,000
对对

1253
01:03:25,000 --> 01:03:28,000
一个一种常见的问题就是测试 target

1254
01:03:28,000 --> 01:03:30,000
不是业务价值

1255
01:03:32,000 --> 01:03:32,000
我来念吧

1256
01:03:32,000 --> 01:03:33,000
这一段应该是

1257
01:03:34,000 --> 01:03:37,000
一种常见的问题就是测试的目标

1258
01:03:37,000 --> 01:03:39,000
不是业务价值

1259
01:03:39,000 --> 01:03:42,000
比如罗马数字与阿拉伯数字的转化的结果

1260
01:03:42,000 --> 01:03:43,000
是否正确

1261
01:03:43,000 --> 01:03:46,000
而是实现本身

1262
01:03:46,000 --> 01:03:49,000
也就是他写的这个测试

1263
01:03:49,000 --> 01:03:53,000
测的是是否采用了某种算法来处理罗马数字

1264
01:03:53,000 --> 01:03:56,000
与阿拉伯数字的转化

1265
01:03:56,000 --> 01:03:57,000
在这种情况之下

1266
01:03:57,000 --> 01:03:58,000
如果你要换算法的话

1267
01:03:58,000 --> 01:03:59,000
你就有修改测试

1268
01:04:01,000 --> 01:04:01,000
应该是这个意思

1269
01:04:04,000 --> 01:04:06,000
然后他说这个如果测试写得不对

1270
01:04:06,000 --> 01:04:10,000
那么测试的稳定性及价值就会大大折扣

1271
01:04:10,000 --> 01:04:13,000
而且测试回复测试的成本也会大大增加

1272
01:04:13,000 --> 01:04:14,000
这只好说明了

1273
01:04:14,000 --> 01:04:16,000
为什么大多数人不爱写测试

1274
01:04:16,000 --> 01:04:20,000
其实写好或者写得对的测试

1275
01:04:20,000 --> 01:04:21,000
确实挺难的

1276
01:04:21,000 --> 01:04:25,000
有时候要比写好或者写对的实现还要难很多

1277
01:04:25,000 --> 01:04:28,000
这也认证刚才张博士的说法

1278
01:04:28,000 --> 01:04:30,000
你什么形式证明也是很难的

1279
01:04:30,000 --> 01:04:33,000
测试也没有简单的按理去是吧

1280
01:04:33,000 --> 01:04:33,000
没错

1281
01:04:33,000 --> 01:04:36,000
就你其实你能写测试

1282
01:04:36,000 --> 01:04:39,000
已经意味着你对写容讯这件事情

1283
01:04:39,000 --> 01:04:41,000
有相当的了解了

1284
01:04:42,000 --> 01:04:45,000
写测试有点像你要交一个人

1285
01:04:45,000 --> 01:04:48,000
你要交一个人武功

1286
01:04:48,000 --> 01:04:49,000
你自己得先会武功

1287
01:04:49,000 --> 01:04:51,000
你这武功得比他强

1288
01:04:51,000 --> 01:04:53,000
你才能跟他对差

1289
01:04:53,000 --> 01:04:56,000
然后告诉他当你打错了

1290
01:04:56,000 --> 01:04:59,000
写测试其实是这样

1291
01:04:59,000 --> 01:05:01,000
如果你能写出一个好的测试

1292
01:05:01,000 --> 01:05:05,000
基本上就意味着你是一个比能够写出好的代码

1293
01:05:05,000 --> 01:05:06,000
更好的成绪

1294
01:05:06,000 --> 01:05:08,000
对起码你对整个接口

1295
01:05:08,000 --> 01:05:10,000
他哪些地方可能会出错

1296
01:05:10,000 --> 01:05:13,000
你会有一个比较完备的理解

1297
01:05:13,000 --> 01:05:17,000
你才能做到测试写出来是足够覆盖度的

1298
01:05:17,000 --> 01:05:19,000
然后有足够多的一种

1299
01:05:19,000 --> 01:05:23,000
所谓边界条件去验证的东西的会出问题

1300
01:05:24,000 --> 01:05:24,000
没错

1301
01:05:26,000 --> 01:05:29,000
他又说关于 TDD 很硬度

1302
01:05:29,000 --> 01:05:29,000
就是你说的

1303
01:05:30,000 --> 01:05:35,000
将测试作为详细设计说明书的可运性版本

1304
01:05:35,000 --> 01:05:36,000
来实现分工和流程化

1305
01:05:37,000 --> 01:05:40,000
因为他们就是他在工作那个地方

1306
01:05:40,000 --> 01:05:42,000
没有严格的分工和分析

1307
01:05:42,000 --> 01:05:44,000
也没有加过诗设计师之类的角色

1308
01:05:44,000 --> 01:05:46,000
所以他感觉不到

1309
01:05:46,000 --> 01:05:47,000
他们只有 B.A.

1310
01:05:47,000 --> 01:05:49,000
就是什么 business analyst

1311
01:05:49,000 --> 01:05:52,000
是吧 QA quality assurance

1312
01:05:52,000 --> 01:05:54,000
然后 DEV 开发 UX

1313
01:05:54,000 --> 01:05:56,000
就是用目的

1314
01:05:56,000 --> 01:05:58,000
这些角色

1315
01:05:58,000 --> 01:06:04,000
开发自己要负责一个 story 的需求建设与反馈

1316
01:06:04,000 --> 01:06:06,000
他们的那个好好好好多数语

1317
01:06:08,000 --> 01:06:09,000
任务拆分

1318
01:06:09,000 --> 01:06:11,000
然后开发前端

1319
01:06:11,000 --> 01:06:13,000
还有甚至给客户去 shu-case

1320
01:06:13,000 --> 01:06:14,000
因为是 demo 这类的东西

1321
01:06:16,000 --> 01:06:17,000
所以这块我们还好

1322
01:06:17,000 --> 01:06:17,000
没有感觉任何不是

1323
01:06:17,000 --> 01:06:19,000
就没有觉得自己很那个

1324
01:06:19,000 --> 01:06:21,000
像你吴涛说的那么很硬度

1325
01:06:21,000 --> 01:06:24,000
他们还是很开心的在做 TDD 的舰型的

1326
01:06:25,000 --> 01:06:27,000
反而在保障测试

1327
01:06:27,000 --> 01:06:28,000
反而在测试的保障下

1328
01:06:28,000 --> 01:06:31,000
我们可以灵活的修改实现和设计

1329
01:06:31,000 --> 01:06:32,000
甚至灵活的想象需求的变化

1330
01:06:33,000 --> 01:06:36,000
他们现在这个项目有四多个人开发

1331
01:06:36,000 --> 01:06:41,000
是基于一个.NET 的 API 加前端是 Rangler.js

1332
01:06:41,000 --> 01:06:43,000
现在还那个 React.js

1333
01:06:44,000 --> 01:06:46,000
然后基于这个微服务的方法来做的

1334
01:06:46,000 --> 01:06:49,000
然后用的是无套最爱的 C-Sharp

1335
01:06:49,000 --> 01:06:51,000
都做了五年了

1336
01:06:51,000 --> 01:06:53,000
然后目前还可以做到相对灵活的

1337
01:06:55,000 --> 01:06:57,000
想法就变化一代码实现的眼镜

1338
01:06:57,000 --> 01:06:59,000
甚至工具框架的眼镜

1339
01:06:59,000 --> 01:07:01,000
可以说 TDD 也是功不可谋

1340
01:07:01,000 --> 01:07:02,000
这确实挺难得的

1341
01:07:02,000 --> 01:07:05,000
一个五年的项目没有激展出那么多的 Craft

1342
01:07:05,000 --> 01:07:08,000
反而还能在这个最套整个业务

1343
01:07:09,000 --> 01:07:13,000
业务思想的这么知道下能够保持敏捷性

1344
01:07:13,000 --> 01:07:14,000
这确实非常不容易

1345
01:07:15,000 --> 01:07:16,000
对

1346
01:07:16,000 --> 01:07:18,000
他说到 TDD 很印度

1347
01:07:20,000 --> 01:07:24,000
我觉得还是有必要解释一下什么叫印度

1348
01:07:24,000 --> 01:07:25,000
印度就是

1349
01:07:26,000 --> 01:07:27,000
印度人有一个特点

1350
01:07:27,000 --> 01:07:31,000
就是他只做你告诉他该做的事情

1351
01:07:31,000 --> 01:07:34,000
然后他你告诉他该做的事情还不一定能做好

1352
01:07:35,000 --> 01:07:38,000
所以印度人为了管理印度人

1353
01:07:38,000 --> 01:07:41,000
我这里没有地狱歧视或者种族歧视意思

1354
01:07:41,000 --> 01:07:43,000
但是如果你听出来了

1355
01:07:43,000 --> 01:07:44,000
我有这个意思

1356
01:07:44,000 --> 01:07:46,000
我也没有什么可以解释

1357
01:07:46,000 --> 01:07:49,000
就是印度人想说他管理印度人的方法就是

1358
01:07:49,000 --> 01:07:50,000
有一个

1359
01:07:52,000 --> 01:07:53,000
高高在上的

1360
01:07:54,000 --> 01:07:56,000
拿着鞭子的人

1361
01:07:57,000 --> 01:07:59,000
告诉你每一步应该做什么

1362
01:07:59,000 --> 01:08:00,000
然后反复来检查你

1363
01:08:01,000 --> 01:08:04,000
我的印度只能是这个意思

1364
01:08:04,000 --> 01:08:08,000
而他所说的他们在公司里面没有严格的分工和分级

1365
01:08:09,000 --> 01:08:11,000
这本身就已经非常不印度

1366
01:08:11,000 --> 01:08:14,000
然后说没有架构师没有设计师之类的角色

1367
01:08:16,000 --> 01:08:19,000
其实一个公司里面没有架构师没有设计师

1368
01:08:19,000 --> 01:08:22,000
并不意味着这个公司就不需要做架构不需要做设计的

1369
01:08:23,000 --> 01:08:25,000
只不过这个架构和设计的

1370
01:08:26,000 --> 01:08:28,000
职责分担到了每个代表身上

1371
01:08:29,000 --> 01:08:32,000
这个对于开发者的要求其实是比较高的

1372
01:08:32,000 --> 01:08:36,000
但是反过来也会让开发者有这样一种感觉

1373
01:08:36,000 --> 01:08:40,000
就是我做的东西是我自己亲手设计出来的

1374
01:08:40,000 --> 01:08:42,000
我做的东西是我想要做的

1375
01:08:42,000 --> 01:08:44,000
然后你在主观的东西上会高一点

1376
01:08:44,000 --> 01:08:45,000
但是

1377
01:08:47,000 --> 01:08:48,000
这本身是

1378
01:08:48,000 --> 01:08:51,000
我觉得是这种制度保证的

1379
01:08:51,000 --> 01:08:52,000
你没有那么印度

1380
01:08:52,000 --> 01:08:53,000
他们并不意味着

1381
01:08:54,000 --> 01:08:55,000
好吧

1382
01:08:55,000 --> 01:09:02,000
我完全不要一定说 TDD 就是一定非常适合印度的开发方法

1383
01:09:02,000 --> 01:09:07,000
我只是说 TDD 很容易被拿来在这种

1384
01:09:07,000 --> 01:09:12,000
刚才我说的这种抽象式的符号化的印度式的管理上

1385
01:09:15,000 --> 01:09:16,000
OK

1386
01:09:16,000 --> 01:09:19,000
然后下一则你来念吧

1387
01:09:20,000 --> 01:09:20,000
对

1388
01:09:20,000 --> 01:09:25,000
然后这位朋友说他在公司推荐了我们的节目

1389
01:09:25,000 --> 01:09:29,000
然后自己也会一边开车听节目的时候一边偷笑

1390
01:09:31,000 --> 01:09:37,000
而且会认为说他的同事们这群被 TDD 安利西伦老的家伙后面

1391
01:09:37,000 --> 01:09:40,000
肯定会听到我们的这些节目产生各种不适

1392
01:09:42,000 --> 01:09:47,000
不过他们的同事也比较崇尚和而不同的环境

1393
01:09:47,000 --> 01:09:49,000
互通游户也没什么不好

1394
01:09:51,000 --> 01:09:52,000
对

1395
01:09:52,000 --> 01:09:52,000
其实

1396
01:09:54,000 --> 01:10:01,000
我觉得这位先生的工作环境是非常理想的一个环境

1397
01:10:01,000 --> 01:10:03,000
就是叫做王健的朋友

1398
01:10:04,000 --> 01:10:05,000
如果你们招人的话

1399
01:10:07,000 --> 01:10:09,000
我们可以给你们打广告

1400
01:10:09,000 --> 01:10:15,000
然后最牛逼的是他在最后录了一段 TDD 写我这个

1401
01:10:15,000 --> 01:10:18,000
写我在节目里面提到的这个罗马收字转换位

1402
01:10:18,000 --> 01:10:22,000
罗马收字的程序

1403
01:10:23,000 --> 01:10:28,000
就是严格按照相对严格的按照 TDD 的先写一测试

1404
01:10:28,000 --> 01:10:31,000
然后再写一段程序再写点测试再写点程序

1405
01:10:31,000 --> 01:10:32,000
然后步骤来的

1406
01:10:33,000 --> 01:10:37,000
然后他把视频传到的 YouTube 和优酷上面

1407
01:10:37,000 --> 01:10:38,000
我只看到 YouTube 版本

1408
01:10:40,000 --> 01:10:43,000
我们会把这个链接放在节目的墨尾

1409
01:10:43,000 --> 01:10:46,000
所以如果你没有你从来没有见过 TDD 是什么样子的话

1410
01:10:46,000 --> 01:10:49,000
你可以看到一位活生生的粒子

1411
01:10:49,000 --> 01:10:55,000
活生生的大牛给你用世界上最好用的编辑

1412
01:10:55,000 --> 01:10:57,000
编译环境 Virgin Studio

1413
01:10:59,000 --> 01:11:00,000
以及世界上最好的语言

1414
01:11:01,000 --> 01:11:06,000
Sayshaw 为你执行整个 TDD 过程

1415
01:11:07,000 --> 01:11:10,000
接下来我们来念两封比较短的读着回馈

1416
01:11:11,000 --> 01:11:17,000
一封是一位来自于石侠星的朋友

1417
01:11:18,000 --> 01:11:20,000
他的属名是 StarSawry

1418
01:11:22,000 --> 01:11:24,000
他来自于法国

1419
01:11:24,000 --> 01:11:26,000
我们经常黑法国

1420
01:11:26,000 --> 01:11:28,000
是 StarSawry

1421
01:11:29,000 --> 01:11:31,000
啊 StarSawry

1422
01:11:32,000 --> 01:11:33,000
OK Sorry

1423
01:11:35,000 --> 01:11:37,000
他来自于法国南特矿越学院

1424
01:11:37,000 --> 01:11:42,000
也是一个名字听起来非常的内疆

1425
01:11:42,000 --> 01:11:44,000
但实际上在欧洲也是非常好的学校

1426
01:11:44,000 --> 01:11:47,000
他说 Hi 的很喜欢你们的节目

1427
01:11:47,000 --> 01:11:50,000
这里是关于 Sawry 7 测试的演返会

1428
01:11:50,000 --> 01:11:54,000
然后 Dijavu 的读音是 Lijavu

1429
01:11:56,000 --> 01:11:59,000
不过 Lijavu 已经被美国人读太多

1430
01:11:59,000 --> 01:12:01,000
也能算是英文式的发音了吧

1431
01:12:01,000 --> 01:12:03,000
在这里唱一下

1432
01:12:03,000 --> 01:12:04,000
乌陶总是黑我们法国

1433
01:12:08,000 --> 01:12:08,000
对不起对不起

1434
01:12:08,000 --> 01:12:10,000
我是故意的

1435
01:12:13,000 --> 01:12:15,000
然后关于女生选择做测试这一点

1436
01:12:15,000 --> 01:12:18,000
根据我们的学姐说就是比较轻松

1437
01:12:18,000 --> 01:12:19,000
也不需要加班

1438
01:12:19,000 --> 01:12:22,000
不论是需求改了还是上线之后出问题

1439
01:12:22,000 --> 01:12:25,000
测试团队都不用被紧急着急

1440
01:12:25,000 --> 01:12:26,000
上线出问题

1441
01:12:26,000 --> 01:12:29,000
这个 QA 会被抓回来

1442
01:12:29,000 --> 01:12:29,000
他都上线了

1443
01:12:29,000 --> 01:12:31,000
你找测试团队有什么用

1444
01:12:31,000 --> 01:12:33,000
好像也已经太晚了

1445
01:12:33,000 --> 01:12:36,000
你就拿那个 Productiv 的环境来当测试环境

1446
01:12:36,000 --> 01:12:39,000
然后改到能用位置

1447
01:12:39,000 --> 01:12:40,000
还能怎么办

1448
01:12:42,000 --> 01:12:45,000
第二篇回馈是一位叫的李建宏的朋友

1449
01:12:45,000 --> 01:12:47,000
问我们一款在 T-Style

1450
01:12:47,000 --> 01:12:49,000
那个什么

1451
01:12:49,000 --> 01:12:50,000
Trackpad 的那个事情要说一下

1452
01:12:52,000 --> 01:12:53,000
对

1453
01:12:55,000 --> 01:12:57,000
然后这听众还问我们说

1454
01:12:57,000 --> 01:13:01,000
一天下来手指会不会因为 Trackpad 用多了

1455
01:13:01,000 --> 01:13:02,000
而关节疼

1456
01:13:02,000 --> 01:13:04,000
他最近实习下班了

1457
01:13:04,000 --> 01:13:05,000
总是终止关节

1458
01:13:05,000 --> 01:13:06,000
微微发疼

1459
01:13:06,000 --> 01:13:08,000
终止是 Type 的主力手指

1460
01:13:08,000 --> 01:13:10,000
两位有合适的解决方法好吗

1461
01:13:10,000 --> 01:13:11,000
你有这个问题吗

1462
01:13:12,000 --> 01:13:14,000
我的解决方法是换鼠标

1463
01:13:17,000 --> 01:13:18,000
其实我也是

1464
01:13:19,000 --> 01:13:20,000
其实我现在在家里面

1465
01:13:20,000 --> 01:13:21,000
我也会用一下鼠标

1466
01:13:21,000 --> 01:13:24,000
主要是最近大游戏比较多

1467
01:13:26,000 --> 01:13:28,000
其实我觉得那个什么 Trackpad 的

1468
01:13:28,000 --> 01:13:31,000
这种特别是 Mac 在那边多点出现 Trackpad 的

1469
01:13:31,000 --> 01:13:34,000
一个最严重的问题倒不是说关节痛

1470
01:13:34,000 --> 01:13:36,000
而是会变成蓝花指

1471
01:13:38,000 --> 01:13:39,000
是有点

1472
01:13:39,000 --> 01:13:42,000
因为你用的时候总会把小指翘起来一面

1473
01:13:42,000 --> 01:13:43,000
对

1474
01:13:43,000 --> 01:13:45,000
9299 就娘了

1475
01:13:49,000 --> 01:13:50,000
对

1476
01:13:50,000 --> 01:13:52,000
其实我有个解决方案就是用中指和

1477
01:13:52,000 --> 01:13:52,000
不不

1478
01:13:52,000 --> 01:13:54,000
用十指和无名指

1479
01:13:55,000 --> 01:13:56,000
十指和无名指

1480
01:13:57,000 --> 01:13:57,000
对

1481
01:13:57,000 --> 01:13:58,000
这怎么有握法

1482
01:13:59,000 --> 01:14:00,000
那中指不用了

1483
01:14:00,000 --> 01:14:02,000
就是中指不用中指

1484
01:14:02,000 --> 01:14:05,000
十中指是一个 screwed 的一个状态

1485
01:14:05,000 --> 01:14:07,000
就是一直撬

1486
01:14:07,000 --> 01:14:08,000
这是一个很硬朗的做法

1487
01:14:11,000 --> 01:14:12,000
等于是我有三个建议

1488
01:14:12,000 --> 01:14:16,000
一个是关掉那个出版的 click 按下的

1489
01:14:16,000 --> 01:14:18,000
就是你不要按下去

1490
01:14:18,000 --> 01:14:19,000
你只用轻触这样

1491
01:14:19,000 --> 01:14:20,000
tap

1492
01:14:20,000 --> 01:14:21,000
对

1493
01:14:21,000 --> 01:14:22,000
只用 tap 来代替 click

1494
01:14:22,000 --> 01:14:26,000
然后这样会对手指的牢损小一点

1495
01:14:26,000 --> 01:14:28,000
第二就是可以用那个

1496
01:14:29,000 --> 01:14:30,000
the star trek

1497
01:14:30,000 --> 01:14:33,000
里面那个 live long and prosper 的手势

1498
01:14:33,000 --> 01:14:36,000
用用把你的十指和中指并在一起

1499
01:14:36,000 --> 01:14:39,000
把无名指和小指并在一起

1500
01:14:40,000 --> 01:14:45,000
大部分时候也这样可以增强那个手指的力度

1501
01:14:45,000 --> 01:14:48,000
或者说增强手指的依赖

1502
01:14:48,000 --> 01:14:50,000
第三就是经常在这个

1503
01:14:50,000 --> 01:14:54,000
我刚才说的只用十指和无名指的手势

1504
01:14:54,000 --> 01:14:57,000
以及这个 star trek 手势之间切换

1505
01:14:57,000 --> 01:15:02,000
这样可以比较有效的减少手指的牢损

1506
01:15:02,000 --> 01:15:04,000
当然还有一个 tip 就是经常用左手

1507
01:15:04,000 --> 01:15:05,000
对得挺好

1508
01:15:12,000 --> 01:15:15,000
下一篇反馈是一位来自李建铜的朋友

1509
01:15:15,000 --> 01:15:16,000
李建铜的朋友

1510
01:15:16,000 --> 01:15:22,000
说是问我们在 kicks 大师上看到的一款重仇的键盘怎么样

1511
01:15:23,000 --> 01:15:24,000
我就看了一下

1512
01:15:24,000 --> 01:15:25,000
他你看了吗

1513
01:15:25,000 --> 01:15:26,000
我看了

1514
01:15:26,000 --> 01:15:27,000
就之前我们

1515
01:15:28,000 --> 01:15:30,000
之前我推荐那款叫什么

1516
01:15:30,000 --> 01:15:34,000
truly ergonomic keyboard 的长相有点接近的

1517
01:15:34,000 --> 01:15:35,000
跟他差不多

1518
01:15:35,000 --> 01:15:38,000
只不过他更极端一点就是他把

1519
01:15:40,000 --> 01:15:43,000
首先他把键盘做成一个木底

1520
01:15:43,000 --> 01:15:45,000
就是下面那个东西是木头做

1521
01:15:47,000 --> 01:15:48,000
看起来比较

1522
01:15:49,000 --> 01:15:50,000
我很难说他是漂亮

1523
01:15:50,000 --> 01:15:52,000
但有一种不一样的美

1524
01:15:52,000 --> 01:15:56,000
然后上面的键他做成了一个

1525
01:15:56,000 --> 01:15:58,000
他比较重大的设计就是

1526
01:15:59,000 --> 01:16:00,000
首先两个键盘

1527
01:16:00,000 --> 01:16:02,000
键盘的左右部分是可以分开的

1528
01:16:02,000 --> 01:16:06,000
其次拇指会承担很多工作

1529
01:16:06,000 --> 01:16:07,000
比如说

1530
01:16:08,000 --> 01:16:09,000
空格键被减少

1531
01:16:09,000 --> 01:16:10,000
减少了一个键

1532
01:16:10,000 --> 01:16:14,000
然后你在这个拇指的最下面的那个指关节

1533
01:16:14,000 --> 01:16:16,000
就是最大的那个指关节的部分

1534
01:16:17,000 --> 01:16:18,000
也有一段键

1535
01:16:18,000 --> 01:16:20,000
然后拇指上拇指的上半部分

1536
01:16:20,000 --> 01:16:22,000
还要分别控制四个键

1537
01:16:24,000 --> 01:16:27,000
我理解就是他的设计可以让你保证

1538
01:16:27,000 --> 01:16:30,000
说你的手指基本上不会移动

1539
01:16:30,000 --> 01:16:31,000
你的手腕基本上不对

1540
01:16:31,000 --> 01:16:32,000
不会移动

1541
01:16:32,000 --> 01:16:34,000
你的手放在那就可以按照所有按键

1542
01:16:34,000 --> 01:16:38,000
而且放了一次是一个手掌和手

1543
01:16:38,000 --> 01:16:40,000
叫什么前臂

1544
01:16:40,000 --> 01:16:41,000
对吧

1545
01:16:41,000 --> 01:16:43,000
它是在一条直线上的

1546
01:16:43,000 --> 01:16:44,000
而不是说那种一个弯

1547
01:16:44,000 --> 01:16:46,000
就是一个斜角这样长期的会导致

1548
01:16:46,000 --> 01:16:47,000
叫什么来的

1549
01:16:48,000 --> 01:16:50,000
万管综合证

1550
01:16:50,000 --> 01:16:51,000
麦管综合证

1551
01:16:51,000 --> 01:16:52,000
到底哪个来的

1552
01:16:52,000 --> 01:16:53,000
万管综合证

1553
01:16:53,000 --> 01:16:54,000
我上次说万管综合证

1554
01:16:54,000 --> 01:16:55,000
对

1555
01:16:55,000 --> 01:16:57,000
我一向都一直在说麦管综合证

1556
01:16:57,000 --> 01:16:57,000
对

1557
01:16:57,000 --> 01:16:59,000
然后被出扬老师说了

1558
01:17:02,000 --> 01:17:03,000
好吧

1559
01:17:03,000 --> 01:17:06,000
我们今天就不讲

1560
01:17:06,000 --> 01:17:08,000
其实那个键盘

1561
01:17:08,000 --> 01:17:11,000
我补充一个最主要的一种异形的键盘

1562
01:17:11,000 --> 01:17:13,000
打字都是其实挺好的

1563
01:17:13,000 --> 01:17:14,000
挺容易适应的

1564
01:17:14,000 --> 01:17:15,000
可能打个三五分钟

1565
01:17:16,000 --> 01:17:17,000
或者最慢一点的

1566
01:17:17,000 --> 01:17:18,000
你两天咱们也适应过来了

1567
01:17:18,000 --> 01:17:19,000
对吧

1568
01:17:19,000 --> 01:17:22,000
最难适应的是各种快捷键的组合

1569
01:17:22,000 --> 01:17:23,000
完全不一样

1570
01:17:24,000 --> 01:17:24,000
对

1571
01:17:24,000 --> 01:17:25,000
没错

1572
01:17:25,000 --> 01:17:28,000
当然我对这个键盘也不能说完全

1573
01:17:31,000 --> 01:17:32,000
怎么说

1574
01:17:32,000 --> 01:17:32,000
完全

1575
01:17:33,000 --> 01:17:36,000
完全买它的主意

1576
01:17:36,000 --> 01:17:37,000
就是它有一个问题

1577
01:17:37,000 --> 01:17:40,000
就是你又要把手挪开键盘之后

1578
01:17:40,000 --> 01:17:42,000
再放回去的过程可能会比较痛苦

1579
01:17:43,000 --> 01:17:45,000
就因为一般的键盘

1580
01:17:45,000 --> 01:17:47,000
它没有考虑人体工学的话

1581
01:17:48,000 --> 01:17:50,000
你把手挪出去再挪回来

1582
01:17:50,000 --> 01:17:52,000
你不用特别在意说

1583
01:17:52,000 --> 01:17:54,000
我要把手放到一个特征的位置

1584
01:17:55,000 --> 01:17:57,000
但是如果你用这个蝴蝶键盘的话

1585
01:17:57,000 --> 01:17:58,000
你每次把手放回来

1586
01:17:58,000 --> 01:18:01,000
你都要小心的调整

1587
01:18:01,000 --> 01:18:04,000
手掌让手掌落到那个最完美的位置

1588
01:18:06,000 --> 01:18:09,000
我至少想到一个来的广告

1589
01:18:09,000 --> 01:18:11,000
就是上面是一把德国刀

1590
01:18:11,000 --> 01:18:15,000
德国的双利人还是 WF 的铫刀

1591
01:18:15,000 --> 01:18:19,000
然后下面是一把日本的菜刀

1592
01:18:19,000 --> 01:18:24,000
然后德国的铫刀非常符合人体工学

1593
01:18:24,000 --> 01:18:30,000
日本的铫刀刀饼就是一个平直的木头

1594
01:18:30,000 --> 01:18:32,000
然后下面的注释就说

1595
01:18:32,000 --> 01:18:36,000
德国的刀只有一种最完美的握法

1596
01:18:36,000 --> 01:18:39,000
而日本的刀你想怎么握都可以

1597
01:18:40,000 --> 01:18:41,000
然后基本上也就是

1598
01:18:41,000 --> 01:18:43,000
我觉得我比较喜欢那种审美

1599
01:18:43,000 --> 01:18:45,000
就是日式的

1600
01:18:45,000 --> 01:18:48,000
就是你可以把这个键盘

1601
01:18:48,000 --> 01:18:50,000
这键盘本身并不去会贴合你

1602
01:18:50,000 --> 01:18:52,000
但是你要去贴合这个键盘

1603
01:18:52,000 --> 01:18:56,000
但同时也就也就意味着你有更多的自由

1604
01:18:58,000 --> 01:18:59,000
对

1605
01:19:00,000 --> 01:19:01,000
就其实你说这种什么

1606
01:19:01,000 --> 01:19:04,000
ergonomic 这种人体工学键盘

1607
01:19:04,000 --> 01:19:06,000
其实我一直在想

1608
01:19:06,000 --> 01:19:08,000
所谓真正的人体工学

1609
01:19:08,000 --> 01:19:11,000
好歹是要是不是每个人还是要不同的

1610
01:19:11,000 --> 01:19:12,000
对吧

1611
01:19:12,000 --> 01:19:14,000
人之间是有差异的

1612
01:19:14,000 --> 01:19:17,000
就是你真的要做到好的人体工学

1613
01:19:17,000 --> 01:19:20,000
得可能按人的良下来定制

1614
01:19:20,000 --> 01:19:20,000
对吧

1615
01:19:20,000 --> 01:19:21,000
其实做不到

1616
01:19:21,000 --> 01:19:22,000
那不如什么

1617
01:19:22,000 --> 01:19:22,000
对

1618
01:19:22,000 --> 01:19:26,000
那除非只有在是传说中的工业 4.0

1619
01:19:26,000 --> 01:19:28,000
或者工业 4.50

1620
01:19:28,000 --> 01:19:29,000
3 D 打印一块

1621
01:19:29,000 --> 01:19:29,000
对吧

1622
01:19:29,000 --> 01:19:30,000
你对

1623
01:19:30,000 --> 01:19:33,000
你先把你的手放到一个扫到银下面

1624
01:19:33,000 --> 01:19:33,000
扫一下

1625
01:19:33,000 --> 01:19:34,000
看那个尺寸

1626
01:19:34,000 --> 01:19:39,000
然后打印出一个只有你用着最舒服的键盘出来

1627
01:19:39,000 --> 01:19:40,000
那才是真正的

1628
01:19:40,000 --> 01:19:42,000
就别人用各种别人用

1629
01:19:42,000 --> 01:19:43,000
就你用的爽

1630
01:19:43,000 --> 01:19:44,000
对

1631
01:19:44,000 --> 01:19:45,000
所以从这个小作讲

1632
01:19:45,000 --> 01:19:46,000
那工业

1633
01:19:46,000 --> 01:19:47,000
这是一个生意

1634
01:19:47,000 --> 01:19:50,000
我们就可以做 Bassbook Keyboard

1635
01:19:53,000 --> 01:19:54,000
也就是我们老的产作

1636
01:19:54,000 --> 01:19:56,000
我其实我在想说

1637
01:19:56,000 --> 01:19:57,000
这个工业 4.0

1638
01:19:57,000 --> 01:19:58,000
其实有点

1639
01:19:58,000 --> 01:20:00,000
有点朝这个

1640
01:20:02,000 --> 01:20:04,000
mass production 的反方向跑

1641
01:20:04,000 --> 01:20:09,000
因为人类近代史上最伟大的发明之一就是流水线

1642
01:20:09,000 --> 01:20:12,000
或者所谓 mass production

1643
01:20:12,000 --> 01:20:14,000
可以批量化生产

1644
01:20:14,000 --> 01:20:20,000
我记得我之前在看一本经济学书里面讲说亚当斯密的时代

1645
01:20:20,000 --> 01:20:24,000
一个人一个工人一个熟练的工人一个小时可能只能造十几根针

1646
01:20:24,000 --> 01:20:25,000
大头针

1647
01:20:25,000 --> 01:20:32,000
而我们这时代一个工人在平均的小质之内可以造出几万枚大头针

1648
01:20:32,000 --> 01:20:41,000
但是工业 4.0 时代也许就意味着朝流的运向走

1649
01:20:41,000 --> 01:20:47,000
一开始我当然技术材料还是 mass production 出来的

1650
01:20:47,000 --> 01:20:48,000
打印机的粉末

1651
01:20:48,000 --> 01:20:52,000
但是最终的成品却是只有在你需要的时候

1652
01:20:52,000 --> 01:20:56,000
才在你需要的那个地方被你自己生产出来

1653
01:20:56,000 --> 01:20:57,000
对嘛

1654
01:20:57,000 --> 01:21:01,000
这个就是他们之前两年还是流行过的一个就是 mass

1655
01:21:01,000 --> 01:21:04,000
你看一下是 mass production 大规模生产

1656
01:21:04,000 --> 01:21:05,000
叫什么大规模定制

1657
01:21:05,000 --> 01:21:08,000
mass customization

1658
01:21:08,000 --> 01:21:09,000
对

1659
01:21:09,000 --> 01:21:10,000
就差不多做

1660
01:21:10,000 --> 01:21:12,000
其实这两个人本质是有矛盾的

1661
01:21:12,000 --> 01:21:16,000
但得益于现在有什么各种各样的机器人技术

1662
01:21:16,000 --> 01:21:24,000
这种 3 D 打印技术可以很快速的根据图纸切换出不同的模型出来

1663
01:21:24,000 --> 01:21:29,000
在定制化的机组上又能同时满足生产的效率

1664
01:21:29,000 --> 01:21:33,000
还是非常了不得的一个工业史上的创新

1665
01:21:33,000 --> 01:21:35,000
没错

1666
01:21:35,000 --> 01:21:37,000
说到刚才那个快捷键的问题

1667
01:21:37,000 --> 01:21:40,000
这两天也是为什么我一直觉得很别扭

1668
01:21:40,000 --> 01:21:47,000
就是在 HHKB 上的那些键位和 Mac 上可以键盘的键盘

1669
01:21:47,000 --> 01:21:48,000
有些那种功能键不太一样

1670
01:21:48,000 --> 01:21:52,000
就那个主键去字母键数字那些都非常容易适应的

1671
01:21:52,000 --> 01:21:56,000
但就是功能键就非常难改

1672
01:21:56,000 --> 01:22:00,000
然后你要用更加人体工学的键盘

1673
01:22:00,000 --> 01:22:04,000
它会考虑把那些功能键做到一个

1674
01:22:04,000 --> 01:22:08,000
通常我们是用什么小纸来按那些左边的功能键

1675
01:22:08,000 --> 01:22:09,000
或者右边的功能键

1676
01:22:09,000 --> 01:22:12,000
但是你在这种完全人体工学的键盘上

1677
01:22:12,000 --> 01:22:14,000
反而是要用实质来按

1678
01:22:14,000 --> 01:22:19,000
到时候你会发现我要按一个 Control-G 怎么办

1679
01:22:19,000 --> 01:22:20,000
就会很糾结

1680
01:22:20,000 --> 01:22:24,000
关键是在很多软件设计者

1681
01:22:24,000 --> 01:22:27,000
他在制定默认的快捷键的时候

1682
01:22:27,000 --> 01:22:31,000
他会假设是一个正常布局的普通键盘来去这么设计

1683
01:22:31,000 --> 01:22:35,000
就是他说比如说这个复制粘贴功能比较常用

1684
01:22:35,000 --> 01:22:36,000
我们做个快捷键

1685
01:22:36,000 --> 01:22:38,000
看哪个快捷键比较顺手按

1686
01:22:38,000 --> 01:22:40,000
然后大家就记得住发现

1687
01:22:40,000 --> 01:22:42,000
Control-C Control-V 不错

1688
01:22:42,000 --> 01:22:44,000
或者在 Mac 上就是 Commount-C

1689
01:22:44,000 --> 01:22:46,000
Commount-V

1690
01:22:46,000 --> 01:22:47,000
但是如果你换一下这种

1691
01:22:48,000 --> 01:22:49,000
这种异形的键盘

1692
01:22:49,000 --> 01:22:52,000
你发现好像不是那么顺手

1693
01:22:52,000 --> 01:22:56,000
所以这里面就是你要做的改动还是蛮多的

1694
01:22:56,000 --> 01:22:58,000
你得自己定一出一套

1695
01:22:58,000 --> 01:23:02,000
假设你那软件是可以更改自己的快捷键的话

1696
01:23:02,000 --> 01:23:04,000
有很多人你其实不支持了

1697
01:23:04,000 --> 01:23:08,000
所以你要想我怎么去在键盘上布局上去找一套

1698
01:23:08,000 --> 01:23:10,000
我觉得还不错

1699
01:23:10,000 --> 01:23:14,000
然后我自己能记得住的一套快捷键的做法

1700
01:23:14,000 --> 01:23:17,000
不是一个两个是整套整套的话

1701
01:23:18,000 --> 01:23:18,000
对

1702
01:23:18,000 --> 01:23:19,000
其实挺辛苦的

1703
01:23:20,000 --> 01:23:21,000
是

1704
01:23:23,000 --> 01:23:23,000
ok

1705
01:23:24,000 --> 01:23:30,000
现在我们进入今天的主题是 Design Pattern 设计模式

1706
01:23:32,000 --> 01:23:34,000
又是一期比较

1707
01:23:35,000 --> 01:23:36,000
水可能也不一定

1708
01:23:36,000 --> 01:23:37,000
但是会比较

1709
01:23:37,000 --> 01:23:39,000
感

1710
01:23:39,000 --> 01:23:40,000
玄学的东西

1711
01:23:40,000 --> 01:23:43,000
我知道

1712
01:23:45,000 --> 01:23:47,000
我所感受到的一种

1713
01:23:47,000 --> 01:23:51,000
一种心态或者说一种思潮

1714
01:23:51,000 --> 01:23:57,000
就是一切和架构和设计有关的东西都非常的虚

1715
01:23:57,000 --> 01:24:02,000
一切比较接近于底层实现

1716
01:24:02,000 --> 01:24:07,000
或者是比较接近于理论和概念性的东西

1717
01:24:07,000 --> 01:24:11,000
才是真正值得人花精力去研究的内功心法

1718
01:24:14,000 --> 01:24:16,000
我不能说这样想不对

1719
01:24:16,000 --> 01:24:27,000
但是我总觉得在现代软件越来越大规模的更为越化的时代

1720
01:24:28,000 --> 01:24:32,000
学一点设计模式还是有相当必要的

1721
01:24:32,000 --> 01:24:32,000
因为

1722
01:24:34,000 --> 01:24:34,000
怎么说呢

1723
01:24:34,000 --> 01:24:37,000
虽然最近几年随着这个

1724
01:24:38,000 --> 01:24:41,000
我说我可以打官腔的感觉就是

1725
01:24:41,000 --> 01:24:44,000
最近开源运动非常的火

1726
01:24:44,000 --> 01:24:47,000
同时也推行了一大批

1727
01:24:47,000 --> 01:24:52,000
比较黑客比较走酷炫流派的

1728
01:24:54,000 --> 01:24:55,000
程序人的思潮

1729
01:24:57,000 --> 01:24:58,000
你是想说 Ruby and Rills 吗

1730
01:25:02,000 --> 01:25:06,000
没有特别针对某一个 Rule and Rill

1731
01:25:06,000 --> 01:25:09,000
没有针对某一个语言或者针对某一个 framing

1732
01:25:09,000 --> 01:25:14,000
但是我想说的一件事情就是比如说有些时候

1733
01:25:14,000 --> 01:25:16,000
我不知道你怎么样

1734
01:25:16,000 --> 01:25:21,000
但是现在我有时候会觉得自己判断一个人是不是牛人的标准

1735
01:25:21,000 --> 01:25:26,000
是看看有没有打不出一个知名的工具来

1736
01:25:28,000 --> 01:25:31,000
会看他 github 上面的 reposatory 怎么样

1737
01:25:33,000 --> 01:25:37,000
我想说这些指标的确可以反映出一个人的

1738
01:25:39,000 --> 01:25:40,000
编程能力

1739
01:25:40,000 --> 01:25:43,000
但是反过来

1740
01:25:44,000 --> 01:25:49,000
另外有一些编程能力是没有办法通过一个 github repository

1741
01:25:50,000 --> 01:25:52,000
通过一套算法面试题

1742
01:25:52,000 --> 01:26:00,000
或者是通过一篇解释某一个比较灰色的编程概念能够体现出来的

1743
01:26:02,000 --> 01:26:08,000
而这种能力却恰恰很有可能是在构建大型程序的时候

1744
01:26:10,000 --> 01:26:11,000
非常需要的

1745
01:26:12,000 --> 01:26:19,000
我觉得这种能力的体现其实就在于对于比如像设计模式这样一些

1746
01:26:19,000 --> 01:26:24,000
听起来比较大而无当的概念的掌握程序上

1747
01:26:24,000 --> 01:26:26,000
其实我啰嗦证明大家都想说什么

1748
01:26:26,000 --> 01:26:30,000
我想说的就是最开始提出设计模式的四个人

1749
01:26:30,000 --> 01:26:36,000
或者说最开始让设计模式这四个人自深入人心的这四个人

1750
01:26:36,000 --> 01:26:39,000
Eric

1751
01:26:39,000 --> 01:26:41,000
这个是他是 Resh

1752
01:26:41,000 --> 01:26:42,000
所以是

1753
01:26:43,000 --> 01:26:44,000
Eric Gamma

1754
01:26:44,000 --> 01:26:46,000
Richard Helm

1755
01:26:46,000 --> 01:26:47,000
Ralph Johnson

1756
01:26:47,000 --> 01:26:52,000
还有 John Vlissides

1757
01:26:52,000 --> 01:26:57,000
这四个人他们其实都没有什么说出来特别了不起的成绩

1758
01:26:58,000 --> 01:27:03,000
当然 Eric Gamma 是一个比较比较重要的人物

1759
01:27:03,000 --> 01:27:04,000
他现在在

1760
01:27:04,000 --> 01:27:07,000
应该是现在应该是在 Mercrosoft 公共

1761
01:27:08,000 --> 01:27:12,000
这四个人都没有什么能够单独摆出来说

1762
01:27:12,000 --> 01:27:14,000
这个人就是做了那件事的那个人

1763
01:27:14,000 --> 01:27:21,000
但是他们四个人毫无疑问都是在工业在比较大的软件界

1764
01:27:22,000 --> 01:27:26,000
比较大的软件工程项目之中摸拍棍打了很多年的人

1765
01:27:27,000 --> 01:27:29,000
才可以写出这样一些比较

1766
01:27:29,000 --> 01:27:34,000
才可以把比较重要的设计模式总结成这样一本书

1767
01:27:34,000 --> 01:27:35,000
然后

1768
01:27:36,000 --> 01:27:38,000
展现给大家

1769
01:27:41,000 --> 01:27:44,000
如果你去搜他们四个人的资料的话

1770
01:27:44,000 --> 01:27:48,000
其实就找不到什么

1771
01:27:48,000 --> 01:27:55,000
但是并不意味着他们就没有能够交给别人的东西

1772
01:27:55,000 --> 01:27:58,000
所以 Ralph 你是什么时候接触这个模式

1773
01:27:58,000 --> 01:28:00,000
或者说你根本接触过这个模式

1774
01:28:00,000 --> 01:28:01,000
你使用过这个模式

1775
01:28:02,000 --> 01:28:03,000
没有

1776
01:28:03,000 --> 01:28:05,000
因为其实在我的理解里面

1777
01:28:05,000 --> 01:28:13,000
设计模式这种理伴是属于学这个 software engineering 的专业人才会去关注的

1778
01:28:13,000 --> 01:28:17,000
甚至这年就是通常一上 CS 就是肯定 Science

1779
01:28:17,000 --> 01:28:21,000
他对这个东西就没有那么关注

1780
01:28:21,000 --> 01:28:24,000
因为它是一个非常工业化的需求

1781
01:28:24,000 --> 01:28:26,000
对吧 并不是一个学院化的东西

1782
01:28:28,000 --> 01:28:32,000
对 所以如果打一个不太强的比例的话

1783
01:28:32,000 --> 01:28:33,000
比方的话

1784
01:28:33,000 --> 01:28:37,000
那就是给咱们 partner 所描述的是

1785
01:28:37,000 --> 01:28:39,000
你应该盖什么样的房子

1786
01:28:39,000 --> 01:28:42,000
或者说你应该怎样盖房子

1787
01:28:42,000 --> 01:28:48,000
而我们日常在学校里面所学到的更多的是

1788
01:28:48,000 --> 01:28:49,000
比如说结构力学

1789
01:28:49,000 --> 01:28:54,000
或者是房屋造假核算

1790
01:28:54,000 --> 01:28:56,000
这样的一些东西

1791
01:28:56,000 --> 01:29:01,000
这基本上是一个艺术和科学之间的飞演

1792
01:29:01,000 --> 01:29:05,000
就如果你要一定要把它往高达上的方向说的话

1793
01:29:05,000 --> 01:29:07,000
设计模式其实是这样的东西

1794
01:29:07,000 --> 01:29:14,000
然后我看设计模式已经是十年前的事了至少

1795
01:29:14,000 --> 01:29:17,000
所以我为了准备这些节目

1796
01:29:17,000 --> 01:29:19,000
也没有把它找出来重新看一遍

1797
01:29:19,000 --> 01:29:22,000
我只记得那个书的封面是埃塞尔的画

1798
01:29:22,000 --> 01:29:25,000
埃塞尔是一个荷兰画家

1799
01:29:25,000 --> 01:29:27,000
他的画非常有意思

1800
01:29:27,000 --> 01:29:31,000
然后我对他违背一下就是他封面是那幅画

1801
01:29:31,000 --> 01:29:35,000
然后这四个人合起来叫做四人帮

1802
01:29:35,000 --> 01:29:37,000
刚富尔这个名字其实是

1803
01:29:37,000 --> 01:29:40,000
这本书出来的时候

1804
01:29:40,000 --> 01:29:43,000
中国的这个文化大革命的

1805
01:29:43,000 --> 01:29:46,000
四人帮这个概念刚刚传到国外不久

1806
01:29:46,000 --> 01:29:48,000
所以他们就把这个四人帮的

1807
01:29:48,000 --> 01:29:52,000
称呼拿过来套在了这四人身上

1808
01:29:52,000 --> 01:29:54,000
没有

1809
01:29:54,000 --> 01:29:56,000
这不是说像是真的是这样

1810
01:29:56,000 --> 01:29:58,000
我知道他们太倒霉了

1811
01:30:01,000 --> 01:30:05,000
我觉得可能英语世界的人不太能够理解

1812
01:30:05,000 --> 01:30:11,000
四人帮在制造的中国的语境之下说出来是一个

1813
01:30:11,000 --> 01:30:14,000
多么负面和恐怖的词

1814
01:30:14,000 --> 01:30:18,000
但也觉得他们看来这真的就是一个杠而已

1815
01:30:20,000 --> 01:30:22,000
然后我记得如果没记错的话

1816
01:30:22,000 --> 01:30:25,000
他们在前言里面提到了一本书

1817
01:30:25,000 --> 01:30:31,000
这本书是来自于建筑专业的一本讲书

1818
01:30:31,000 --> 01:30:33,000
怎么说呢

1819
01:30:33,000 --> 01:30:35,000
建筑方法论那本书

1820
01:30:35,000 --> 01:30:37,000
这本书叫做建筑永恒之道

1821
01:30:37,000 --> 01:30:40,000
The timeless way of building

1822
01:30:40,000 --> 01:30:44,000
之后在一个很机缘巧合场景下

1823
01:30:44,000 --> 01:30:46,000
我拿了这本书的中文吧

1824
01:30:46,000 --> 01:30:52,000
翻译一下觉得没有这个没有设计模式这本书

1825
01:30:52,000 --> 01:30:55,000
这本书没吹加引号那么神奇

1826
01:30:58,000 --> 01:31:01,000
而且我也不是很推荐大家去看

1827
01:31:01,000 --> 01:31:07,000
因为如果不结合那本书的当时的

1828
01:31:07,000 --> 01:31:11,000
context 的话是不是挺难理解的一本书

1829
01:31:11,000 --> 01:31:13,000
这本书出版于 1979 年

1830
01:31:13,000 --> 01:31:18,000
就比 90 年代的面向模式还

1831
01:31:19,000 --> 01:31:22,000
现在设计模式还要早上

1832
01:31:26,000 --> 01:31:27,000
总的来说

1833
01:31:27,000 --> 01:31:29,000
建筑永恒之道这本书没所识出

1834
01:31:29,000 --> 01:31:33,000
表达的一个观点就是你在造建筑的时候

1835
01:31:33,000 --> 01:31:38,000
你必须想方胜反的去达到一种

1836
01:31:38,000 --> 01:31:42,000
没有办法定义的 quality

1837
01:31:43,000 --> 01:31:46,000
有点像那个神棍书

1838
01:31:46,000 --> 01:31:49,000
就是铲玉摩托车维护的艺术里面

1839
01:31:49,000 --> 01:31:51,000
所提到的所谓粮址

1840
01:31:51,000 --> 01:31:56,000
也就是你要使你的建筑能够体现出这样一种

1841
01:31:56,000 --> 01:31:57,000
你说它是没也好

1842
01:31:57,000 --> 01:32:01,000
说它是倒也好这样一种质量

1843
01:32:01,000 --> 01:32:04,000
而为了达成这种质量

1844
01:32:04,000 --> 01:32:07,000
你必须遵循一些特定的模式

1845
01:32:07,000 --> 01:32:09,000
然后这个概念

1846
01:32:09,000 --> 01:32:13,000
这个 design pattern 的这个概念就源自于这本书

1847
01:32:13,000 --> 01:32:15,000
然后 1994 年

1848
01:32:15,000 --> 01:32:18,000
四位作者所写的这个设计模式

1849
01:32:18,000 --> 01:32:20,000
或者说全称叫做

1850
01:32:23,000 --> 01:32:27,000
如何构建更好的面向对象的程序

1851
01:32:27,000 --> 01:32:32,000
也就建用这个概念是想要总结出一些

1852
01:32:32,000 --> 01:32:35,000
在使用面向对象的技术来写程序的时候

1853
01:32:35,000 --> 01:32:40,000
然后人们应该遵循那些比较常见的技巧和方法

1854
01:32:43,000 --> 01:32:45,000
这基本上就是一个对于设计模式

1855
01:32:45,000 --> 01:32:49,000
不那么教科舒适的介绍

1856
01:32:49,000 --> 01:32:52,000
至少大概就是我的意见

1857
01:32:52,000 --> 01:32:57,000
所以其实如果我们接着拿建筑的例子来做对比的话

1858
01:32:57,000 --> 01:32:59,000
所谓设计模式

1859
01:32:59,000 --> 01:33:02,000
就是说有一堆老师傅告诉你说

1860
01:33:02,000 --> 01:33:03,000
你看我跟你说

1861
01:33:03,000 --> 01:33:05,000
你这个什么

1862
01:33:05,000 --> 01:33:07,000
这个墙的这么气

1863
01:33:07,000 --> 01:33:09,000
他才会稳固才会倒

1864
01:33:09,000 --> 01:33:12,000
你要按你那个方法气也可以

1865
01:33:12,000 --> 01:33:14,000
但是可能就是那个什么

1866
01:33:14,000 --> 01:33:15,000
不太结实

1867
01:33:15,000 --> 01:33:16,000
一推就倒了

1868
01:33:16,000 --> 01:33:22,000
就做的是一个把过往的经验抽象出来

1869
01:33:22,000 --> 01:33:24,000
叫什么来的

1870
01:33:24,000 --> 01:33:29,000
成为一个可以被后人学习的这么一个东西

1871
01:33:29,000 --> 01:33:32,000
对可以这么说

1872
01:33:32,000 --> 01:33:36,000
但我要强调的一点就是设计模式是一个比较

1873
01:33:36,000 --> 01:33:40,000
在更高的抽象层地上工作的这样一种技術

1874
01:33:40,000 --> 01:33:42,000
就是你说的气墙

1875
01:33:42,000 --> 01:33:46,000
我觉得可能更合适的比喻是比如说

1876
01:33:46,000 --> 01:33:48,000
Hacker's Delight 或者是

1877
01:33:50,000 --> 01:33:51,000
Programmar

1878
01:33:51,000 --> 01:33:52,000
就是编程珠机

1879
01:33:52,000 --> 01:33:56,000
这本书里面所讲的那些技巧

1880
01:33:56,000 --> 01:34:00,000
就是在一些比较

1881
01:34:00,000 --> 01:34:04,000
科丽度比较小的级别上面告诉你

1882
01:34:04,000 --> 01:34:06,000
怎样写出质量更好代码

1883
01:34:06,000 --> 01:34:11,000
而设计模式则更多的是在比较高级的层面上

1884
01:34:11,000 --> 01:34:13,000
比如说沿用建筑的比方的话

1885
01:34:13,000 --> 01:34:15,000
那可能建筑模式设计模式

1886
01:34:15,000 --> 01:34:17,000
所以要表达的是比如说

1887
01:34:17,000 --> 01:34:19,000
你要怎样用两个

1888
01:34:19,000 --> 01:34:23,000
怎样有一个长廊连接两个屋子

1889
01:34:23,000 --> 01:34:25,000
然后你把屋子摆成这样

1890
01:34:25,000 --> 01:34:28,000
会给人一种什么样的

1891
01:34:29,000 --> 01:34:31,000
给人一种什么样的印象

1892
01:34:31,000 --> 01:34:34,000
让这个起居者会有怎样的动线

1893
01:34:34,000 --> 01:34:36,000
乃至于你写的

1894
01:34:36,000 --> 01:34:37,000
你造的这个屋子

1895
01:34:37,000 --> 01:34:41,000
要怎样才能跟周围的环境融合起来

1896
01:34:41,000 --> 01:34:44,000
怎样才能保证说你要符合当地的

1897
01:34:45,000 --> 01:34:46,000
比如说风水

1898
01:34:46,000 --> 01:34:48,000
或者是要比如

1899
01:34:48,000 --> 01:34:51,000
要怎样才能不去破坏周围的植被

1900
01:34:51,000 --> 01:34:54,000
乃至于怎样故意的让你的建筑

1901
01:34:54,000 --> 01:34:57,000
和周围的建筑产生一定的反差

1902
01:34:57,000 --> 01:35:01,000
比如说北京的叫什么

1903
01:35:01,000 --> 01:35:03,000
大剧院或者是都一名做的那个

1904
01:35:03,000 --> 01:35:05,000
卢福公的入口

1905
01:35:05,000 --> 01:35:07,000
诸如此类的东西

1906
01:35:07,000 --> 01:35:09,000
设计模式讨论的是这样一种东西

1907
01:35:09,000 --> 01:35:11,000
更接近艺术性的东西

1908
01:35:12,000 --> 01:35:15,000
但是于子彤是他又没有那么的

1909
01:35:16,000 --> 01:35:17,000
飘苗

1910
01:35:17,000 --> 01:35:19,000
就我有时候我觉得

1911
01:35:19,000 --> 01:35:23,000
当然我对建筑者是比较奇怪的

1912
01:35:23,000 --> 01:35:24,000
有比较奇怪的兴趣

1913
01:35:24,000 --> 01:35:26,000
但是有时候我会觉得建筑里面的模式

1914
01:35:26,000 --> 01:35:28,000
是非常难以总结和附用的

1915
01:35:28,000 --> 01:35:31,000
而且建筑的艺术性太强了

1916
01:35:31,000 --> 01:35:33,000
建筑师会倾向于用

1917
01:35:34,000 --> 01:35:36,000
比较有各情况的方法去

1918
01:35:36,000 --> 01:35:39,000
去全是所谓的设计模式

1919
01:35:39,000 --> 01:35:41,000
但是在软件工程的设计模式里面

1920
01:35:41,000 --> 01:35:44,000
基本上每一个模式都是

1921
01:35:45,000 --> 01:35:47,000
不那么风格化的

1922
01:35:47,000 --> 01:35:49,000
就是比如说

1923
01:35:50,000 --> 01:35:52,000
你写 visitor pattern

1924
01:35:52,000 --> 01:35:54,000
我也写 visitor pattern 都一样

1925
01:35:54,000 --> 01:35:56,000
你哪怕起另外一个名字

1926
01:35:56,000 --> 01:35:57,000
玫瑰

1927
01:35:57,000 --> 01:35:58,000
这 1000 种名字

1928
01:35:58,000 --> 01:36:01,000
还是那样一个东西

1929
01:36:01,000 --> 01:36:02,000
如果你能

1930
01:36:02,000 --> 01:36:04,000
如果你接触这个模式的话

1931
01:36:04,000 --> 01:36:05,000
别人哪怕换一个名字来写

1932
01:36:05,000 --> 01:36:07,000
你还是可以意识到

1933
01:36:07,000 --> 01:36:08,000
就是那个模式本身

1934
01:36:08,000 --> 01:36:11,000
他没有那么多的艺术家人

1935
01:36:11,000 --> 01:36:12,000
所以总结来说

1936
01:36:14,000 --> 01:36:15,000
设计模式基本上就是

1937
01:36:15,000 --> 01:36:17,000
比较高层次的

1938
01:36:17,000 --> 01:36:20,000
被总结出来的凝固的 best practice

1939
01:36:20,000 --> 01:36:22,000
然后它的意义就是

1940
01:36:22,000 --> 01:36:24,000
可以在帮助你

1941
01:36:24,000 --> 01:36:26,000
在告诉你在各种情况之下

1942
01:36:26,000 --> 01:36:30,000
怎样能比较好的建构

1943
01:36:30,000 --> 01:36:31,000
构建你的代码

1944
01:36:31,000 --> 01:36:33,000
然后让你的代码之间结合

1945
01:36:33,000 --> 01:36:34,000
因为

1946
01:36:36,000 --> 01:36:39,000
设计模式的两大要素就是

1947
01:36:39,000 --> 01:36:42,000
一个是要 program to interface

1948
01:36:42,000 --> 01:36:44,000
not implementation

1949
01:36:44,000 --> 01:36:48,000
另一个就是 prefer a favor object

1950
01:36:48,000 --> 01:36:51,000
object composition over inheritance

1951
01:36:51,000 --> 01:36:55,000
就是你要针对界面

1952
01:36:55,000 --> 01:36:57,000
而非实现来变成

1953
01:36:57,000 --> 01:36:58,000
另外一方面

1954
01:36:58,000 --> 01:37:01,000
你要更多的使用 object composition

1955
01:37:01,000 --> 01:37:04,000
就是你要让一个 object

1956
01:37:04,000 --> 01:37:06,000
去包含另外一个 object

1957
01:37:06,000 --> 01:37:08,000
而不是让一个 object

1958
01:37:08,000 --> 01:37:10,000
继承自另外一个 object

1959
01:37:10,000 --> 01:37:12,000
这两点其实

1960
01:37:12,000 --> 01:37:14,000
算是过了这么久

1961
01:37:14,000 --> 01:37:17,000
一直顶铺铺铺的两个真理吧

1962
01:37:17,000 --> 01:37:20,000
而且你如果从这个角度去

1963
01:37:20,000 --> 01:37:22,000
反观很多设计的话

1964
01:37:22,000 --> 01:37:25,000
你会觉得很多设计都是有问题

1965
01:37:27,000 --> 01:37:28,000
我不知道你怎么看

1966
01:37:28,000 --> 01:37:31,000
但至少 object composition over inheritance

1967
01:37:31,000 --> 01:37:35,000
这点在 objective C 里面

1968
01:37:35,000 --> 01:37:38,000
体现的非常明显

1969
01:37:38,000 --> 01:37:40,000
应该不应该这么说

1970
01:37:40,000 --> 01:37:42,000
应该说 objective C 的一个 cool

1971
01:37:42,000 --> 01:37:44,000
也就是苹果最苹果用的这个

1972
01:37:44,000 --> 01:37:45,000
coco cool 里面

1973
01:37:45,000 --> 01:37:47,000
这点体现的比较明显

1974
01:37:48,000 --> 01:37:51,000
coco cool 的所有的用力

1975
01:37:51,000 --> 01:37:54,000
基本上都在推荐你使用 composition

1976
01:37:54,000 --> 01:37:56,000
很少会说你来

1977
01:37:56,000 --> 01:38:00,000
继承一下我的这样一个

1978
01:38:00,000 --> 01:38:02,000
跟着的积累

1979
01:38:02,000 --> 01:38:04,000
然后通过继承方法

1980
01:38:04,000 --> 01:38:06,000
来实现你自己的一些营业活动

1981
01:38:06,000 --> 01:38:09,000
可是反过来在活跃黑障

1982
01:38:10,000 --> 01:38:11,000
在摘药世界里面

1983
01:38:11,000 --> 01:38:12,000
你会发现很多人

1984
01:38:12,000 --> 01:38:14,000
尤其在 JT 1 的世界里面

1985
01:38:14,000 --> 01:38:15,000
有很多很多东西

1986
01:38:15,000 --> 01:38:16,000
很多很多时候

1987
01:38:16,000 --> 01:38:19,000
是被逼着使用 inheritance

1988
01:38:19,000 --> 01:38:22,000
然后你会大量的去找

1989
01:38:22,000 --> 01:38:23,000
说目前这个类

1990
01:38:23,000 --> 01:38:26,000
它的 inheritance 的 trace 怎么样的

1991
01:38:26,000 --> 01:38:27,000
它上面继承了谁

1992
01:38:27,000 --> 01:38:29,000
下面又被谁继承了

1993
01:38:29,000 --> 01:38:32,000
然后导致你迁移发而动学生

1994
01:38:32,000 --> 01:38:35,000
然后这个时候你再回头来看

1995
01:38:35,000 --> 01:38:37,000
design pattern 这本书里面

1996
01:38:37,000 --> 01:38:39,000
所强调的 object composition over inheritance

1997
01:38:39,000 --> 01:38:40,000
你会觉得

1998
01:38:42,000 --> 01:38:43,000
何苦

1999
01:38:43,000 --> 01:38:44,000
真的是

2000
01:38:44,000 --> 01:38:45,000
对

2001
01:38:45,000 --> 01:38:46,000
这个可能也是

2002
01:38:46,000 --> 01:38:48,000
就为什么大家一直在黑

2003
01:38:48,000 --> 01:38:50,000
java 的一个重要的原因

2004
01:38:50,000 --> 01:38:52,000
就是你总感

2005
01:38:52,000 --> 01:38:53,000
我总会做一种感觉

2006
01:38:53,000 --> 01:38:55,000
就是 java 的本身还是挺好的

2007
01:38:55,000 --> 01:38:57,000
但是被一堆

2008
01:38:57,000 --> 01:38:59,000
这个被 OP

2009
01:38:59,000 --> 01:39:00,000
邪教

2010
01:39:00,000 --> 01:39:03,000
迷惑了的人在那里

2011
01:39:03,000 --> 01:39:06,000
去在 java 平台上写一些东西

2012
01:39:06,000 --> 01:39:08,000
出来搞得非常雍重不堪

2013
01:39:08,000 --> 01:39:10,000
也不是很灵活

2014
01:39:10,000 --> 01:39:11,000
对

2015
01:39:11,000 --> 01:39:12,000
我前两天在 Hacknews

2016
01:39:12,000 --> 01:39:14,000
看了一个 news group

2017
01:39:14,000 --> 01:39:16,000
里面的八卦

2018
01:39:16,000 --> 01:39:19,000
就是那个 java 设计员的

2019
01:39:19,000 --> 01:39:21,000
java 语言的设计者

2020
01:39:21,000 --> 01:39:22,000
对第二设计者

2021
01:39:22,000 --> 01:39:23,000
就是

2022
01:39:23,000 --> 01:39:26,000
起到了一些

2023
01:39:26,000 --> 01:39:29,000
语法方面的决策作用的一个人叫

2024
01:39:30,000 --> 01:39:31,000
叫什么人

2025
01:39:31,000 --> 01:39:32,000
Norton

2026
01:39:32,000 --> 01:39:33,000
他应该姓 Norton

2027
01:39:33,000 --> 01:39:34,000
他是一个

2028
01:39:34,000 --> 01:39:35,000
制策和技术的名字

2029
01:39:35,000 --> 01:39:36,000
就是因为他的 90 年代末期

2030
01:39:36,000 --> 01:39:38,000
有过一桩非常有名的

2031
01:39:38,000 --> 01:39:39,000
链筒案件

2032
01:39:39,000 --> 01:39:40,000
他去

2033
01:39:40,000 --> 01:39:43,000
他坐着私人的盆栖机去

2034
01:39:44,000 --> 01:39:45,000
Disney

2035
01:39:45,000 --> 01:39:47,000
会一个 13 岁的小女孩

2036
01:39:48,000 --> 01:39:49,000
并且要求

2037
01:39:49,000 --> 01:39:51,000
并且要求这个小女孩

2038
01:39:52,000 --> 01:39:53,000
跳脱衣舞

2039
01:39:54,000 --> 01:39:55,000
还是

2040
01:39:55,000 --> 01:39:57,000
做一些别的什么事情

2041
01:39:58,000 --> 01:39:59,000
然后后来

2042
01:39:59,000 --> 01:40:00,000
这个小女孩

2043
01:40:00,000 --> 01:40:01,000
其实是 FBI 的一个侦探

2044
01:40:02,000 --> 01:40:04,000
看起来比较小

2045
01:40:04,000 --> 01:40:06,000
然后隐藏了自己的认识

2046
01:40:06,000 --> 01:40:08,000
然后这个人被告到法令上

2047
01:40:08,000 --> 01:40:09,000
最后

2048
01:40:10,000 --> 01:40:11,000
最后处罚好像挺荒诞的

2049
01:40:11,000 --> 01:40:14,000
是让他免费为 FBI 工作一年

2050
01:40:16,000 --> 01:40:17,000
之类的证明处

2051
01:40:18,000 --> 01:40:19,000
然后

2052
01:40:19,000 --> 01:40:20,000
对打个叉

2053
01:40:20,000 --> 01:40:22,000
这个人他是 Java 的语言的发明者

2054
01:40:22,000 --> 01:40:23,000
然后他在

2055
01:40:23,000 --> 01:40:24,000
之一

2056
01:40:24,000 --> 01:40:25,000
对

2057
01:40:25,000 --> 01:40:27,000
他在 Newsgroup 里面提到说

2058
01:40:27,000 --> 01:40:29,000
Java 其实受到了

2059
01:40:30,000 --> 01:40:31,000
非常严重的

2060
01:40:31,000 --> 01:40:33,000
Objective C 的影响

2061
01:40:34,000 --> 01:40:36,000
但是这种影响

2062
01:40:36,000 --> 01:40:37,000
很显然

2063
01:40:37,000 --> 01:40:40,000
仅仅局限在这个语言的特性上

2064
01:40:40,000 --> 01:40:42,000
就是比如说他有很多动态的

2065
01:40:43,000 --> 01:40:44,000
机制

2066
01:40:44,000 --> 01:40:46,000
每一个方法都是存储在

2067
01:40:48,000 --> 01:40:50,000
Class 内部的一个 Field 之类

2068
01:40:51,000 --> 01:40:52,000
但是

2069
01:40:52,000 --> 01:40:53,000
这样一种语言所

2070
01:40:53,000 --> 01:40:55,000
衍生出的两个酷

2071
01:40:55,000 --> 01:40:56,000
却是大相敬敬的

2072
01:40:56,000 --> 01:40:57,000
我比如说

2073
01:40:59,000 --> 01:41:00,000
在 Java 的

2074
01:41:01,000 --> 01:41:03,000
整个内酷里面

2075
01:41:03,000 --> 01:41:05,000
在很多时候都是和

2076
01:41:06,000 --> 01:41:08,000
这个 Objective C 所衍生出来的

2077
01:41:08,000 --> 01:41:10,000
最广泛使用的内酷

2078
01:41:10,000 --> 01:41:12,000
完全不相下的一批

2079
01:41:13,000 --> 01:41:15,000
一些设计者学的寂寞

2080
01:41:16,000 --> 01:41:17,000
这些也是我之前在用

2081
01:41:17,000 --> 01:41:19,000
Skala 的时候的

2082
01:41:19,000 --> 01:41:20,000
遇到的一个问题

2083
01:41:20,000 --> 01:41:21,000
就是你 Skala 是

2084
01:41:21,000 --> 01:41:22,000
解剖的这边

2085
01:41:22,000 --> 01:41:23,000
他也是

2086
01:41:24,000 --> 01:41:26,000
比较能够方便调用 Java 的那些

2087
01:41:26,000 --> 01:41:28,000
用 Java 写的那些

2088
01:41:28,000 --> 01:41:29,000
包嘛

2089
01:41:30,000 --> 01:41:31,000
对 目前的

2090
01:41:31,000 --> 01:41:32,000
然后你会发现

2091
01:41:32,000 --> 01:41:33,000
他那个

2092
01:41:33,000 --> 01:41:34,000
一旦到了

2093
01:41:34,000 --> 01:41:35,000
你用别人一个针对

2094
01:41:35,000 --> 01:41:37,000
Java 写了这么一个包的时候

2095
01:41:37,000 --> 01:41:38,000
他的一些接口

2096
01:41:38,000 --> 01:41:39,000
整个设计者学

2097
01:41:39,000 --> 01:41:40,000
就完全是

2098
01:41:40,000 --> 01:41:42,000
一种纯 OP 的思维

2099
01:41:42,000 --> 01:41:43,000
然后

2100
01:41:43,000 --> 01:41:45,000
Skala 它是一个 OP

2101
01:41:45,000 --> 01:41:47,000
加 FP 混合的

2102
01:41:47,000 --> 01:41:48,000
这么一种范式的语言

2103
01:41:49,000 --> 01:41:51,000
就用起来非常非常边缘

2104
01:41:52,000 --> 01:41:53,000
你需要在两个这种思维

2105
01:41:53,000 --> 01:41:54,000
范式之间切获吗

2106
01:41:55,000 --> 01:41:56,000
对 你会有时候

2107
01:41:56,000 --> 01:41:57,000
你会看到

2108
01:41:57,000 --> 01:41:58,000
为什么 Java 这不傻逼吗

2109
01:41:58,000 --> 01:41:59,000
为什么这么设计

2110
01:41:59,000 --> 01:42:00,000
但其实也主要的原因就是说

2111
01:42:01,000 --> 01:42:02,000
加入语言本身

2112
01:42:02,000 --> 01:42:03,000
有一些什么特殊的限制

2113
01:42:03,000 --> 01:42:04,000
导致不那么写

2114
01:42:04,000 --> 01:42:06,000
反而可能重用和

2115
01:42:07,000 --> 01:42:08,000
这个叫什么来着

2116
01:42:09,000 --> 01:42:10,000
代码的构计

2117
01:42:10,000 --> 01:42:11,000
也没有那么灵活

2118
01:42:11,000 --> 01:42:13,000
但是你到一个

2119
01:42:13,000 --> 01:42:16,000
更加灵活的语言里面

2120
01:42:16,000 --> 01:42:17,000
去看

2121
01:42:17,000 --> 01:42:18,000
Java 那种那种设计

2122
01:42:18,000 --> 01:42:19,000
那种限制

2123
01:42:19,000 --> 01:42:20,000
导致出来的

2124
01:42:20,000 --> 01:42:21,000
接口的设计

2125
01:42:21,000 --> 01:42:22,000
其实是非常笨拙

2126
01:42:24,000 --> 01:42:25,000
是

2127
01:42:25,000 --> 01:42:27,000
其实我最近在写 swift 的时候

2128
01:42:27,000 --> 01:42:28,000
有什么感觉

2129
01:42:28,000 --> 01:42:30,000
因为 swift 目前的状态

2130
01:42:30,000 --> 01:42:32,000
还是有

2131
01:42:33,000 --> 01:42:34,000
虽然在诸位减少

2132
01:42:34,000 --> 01:42:35,000
但还是有一部分东西

2133
01:42:35,000 --> 01:42:37,000
是要跟 coco

2134
01:42:38,000 --> 01:42:39,000
或者说跟底层

2135
01:42:39,000 --> 01:42:41,000
Outback to C 的代码

2136
01:42:41,000 --> 01:42:42,000
实现相交互的

2137
01:42:43,000 --> 01:42:44,000
然后这个时候你会发现

2138
01:42:45,000 --> 01:42:47,000
你会感觉到一种

2139
01:42:48,000 --> 01:42:50,000
从文法上面

2140
01:42:50,000 --> 01:42:52,000
不是文法是从

2141
01:42:53,000 --> 01:42:54,000
Litter C 上面

2142
01:42:54,000 --> 01:42:55,000
就可以感受到

2143
01:42:55,000 --> 01:42:58,000
两者的冲撞

2144
01:42:59,000 --> 01:43:00,000
swift 的很多东西

2145
01:43:00,000 --> 01:43:01,000
都是非常简洁的

2146
01:43:01,000 --> 01:43:02,000
比如说 function

2147
01:43:02,000 --> 01:43:03,000
这个词不愿意拼你

2148
01:43:03,000 --> 01:43:04,000
好

2149
01:43:04,000 --> 01:43:05,000
写 funk

2150
01:43:05,000 --> 01:43:06,000
然后

2151
01:43:06,000 --> 01:43:07,000
或者有很多 shortcut

2152
01:43:07,000 --> 01:43:09,000
比如说最新的什么

2153
01:43:09,000 --> 01:43:10,000
for

2154
01:43:10,000 --> 01:43:12,000
x in y

2155
01:43:12,000 --> 01:43:13,000
where

2156
01:43:13,000 --> 01:43:14,000
z

2157
01:43:14,000 --> 01:43:15,000
然后你可以少写一个

2158
01:43:15,000 --> 01:43:16,000
你可以少

2159
01:43:16,000 --> 01:43:17,000
你可以通过这个 filter

2160
01:43:17,000 --> 01:43:19,000
直接在那个

2161
01:43:20,000 --> 01:43:21,000
loop

2162
01:43:22,000 --> 01:43:23,000
体的外面

2163
01:43:23,000 --> 01:43:25,000
就把一些边界条件过去了

2164
01:43:25,000 --> 01:43:26,000
但是当你

2165
01:43:26,000 --> 01:43:28,000
采用这样一种简洁的写法

2166
01:43:28,000 --> 01:43:30,000
写成去正爽的时候

2167
01:43:30,000 --> 01:43:31,000
忽然跳到一个地方

2168
01:43:31,000 --> 01:43:32,000
就需要呼叫一个

2169
01:43:33,000 --> 01:43:34,000
一看就是 objects

2170
01:43:34,000 --> 01:43:35,000
c

2171
01:43:35,000 --> 01:43:36,000
楼下

2172
01:43:36,000 --> 01:43:38,000
16 下的 API 的时候

2173
01:43:38,000 --> 01:43:39,000
对

2174
01:43:39,000 --> 01:43:40,000
这个 API 的名字是怒长了

2175
01:43:41,000 --> 01:43:43,000
觉得很另类

2176
01:43:43,000 --> 01:43:44,000
对

2177
01:43:44,000 --> 01:43:45,000
strain by appending

2178
01:43:45,000 --> 01:43:46,000
another string with format

2179
01:43:46,000 --> 01:43:47,000
之类的

2180
01:43:47,000 --> 01:43:48,000
这样一个

2181
01:43:48,000 --> 01:43:49,000
非常长的

2182
01:43:50,000 --> 01:43:51,000
如果没有

2183
01:43:51,000 --> 01:43:52,000
这自动提示

2184
01:43:52,000 --> 01:43:53,000
真的是

2185
01:43:54,000 --> 01:43:55,000
杀了

2186
01:43:55,000 --> 01:43:56,000
怎么换了

2187
01:43:56,000 --> 01:43:57,000
这样一个寒书名出来

2188
01:43:57,000 --> 01:43:59,000
你就可以明显的感觉到

2189
01:43:59,000 --> 01:44:00,000
这两种

2190
01:44:01,000 --> 01:44:02,000
编程思维

2191
01:44:02,000 --> 01:44:03,000
在冲撞

2192
01:44:04,000 --> 01:44:05,000
对

2193
01:44:05,000 --> 01:44:06,000
当然

2194
01:44:06,000 --> 01:44:07,000
目前看来 swift

2195
01:44:07,000 --> 01:44:08,000
对

2196
01:44:08,000 --> 01:44:09,000
更新速度还是比较快的

2197
01:44:09,000 --> 01:44:10,000
也许在

2198
01:44:10,000 --> 01:44:11,000
比较

2199
01:44:11,000 --> 01:44:12,000
足够近的将来

2200
01:44:12,000 --> 01:44:13,000
我们就可以

2201
01:44:13,000 --> 01:44:15,000
使用一些比较

2202
01:44:15,000 --> 01:44:16,000
更

2203
01:44:17,000 --> 01:44:19,000
有更多的 swiftness

2204
01:44:19,000 --> 01:44:20,000
在里面的 API

2205
01:44:20,000 --> 01:44:22,000
但是现在不是上次

2206
01:44:22,000 --> 01:44:23,000
wc 说的时候

2207
01:44:23,000 --> 01:44:25,000
是他们现在逐渐把那些

2208
01:44:26,000 --> 01:44:27,000
coco

2209
01:44:27,000 --> 01:44:28,000
底层的裤鸭

2210
01:44:28,000 --> 01:44:30,000
叫做 swift 化了

2211
01:44:30,000 --> 01:44:31,000
对

2212
01:44:31,000 --> 01:44:32,000
按照 swift 方法

2213
01:44:32,000 --> 01:44:35,000
给一个新的接口

2214
01:44:35,000 --> 01:44:36,000
就不要用那种原因

2215
01:44:36,000 --> 01:44:37,000
确实很

2216
01:44:37,000 --> 01:44:39,000
用起来真的很别扭

2217
01:44:39,000 --> 01:44:40,000
对

2218
01:44:41,000 --> 01:44:42,000
乐观估计

2219
01:44:42,000 --> 01:44:45,000
这个大概需要 3-5 年的时间

2220
01:44:46,000 --> 01:44:47,000
果然很乐观

2221
01:44:48,000 --> 01:44:49,000
不是 5-10 年吗

2222
01:44:51,000 --> 01:44:52,000
我觉得 3-5 年

2223
01:44:52,000 --> 01:44:53,000
应该差不多

2224
01:44:53,000 --> 01:44:54,000
对

2225
01:44:54,000 --> 01:44:56,000
看他们决心怎么样了

2226
01:44:56,000 --> 01:44:57,000
我觉得还是要看他们

2227
01:44:57,000 --> 01:44:59,000
对于新产品的投入

2228
01:44:59,000 --> 01:45:00,000
以及对于

2229
01:45:00,000 --> 01:45:01,000
改这个

2230
01:45:03,000 --> 01:45:05,000
偿还技术债务的投入

2231
01:45:05,000 --> 01:45:07,000
之间找到的平衡

2232
01:45:07,000 --> 01:45:08,000
怎么样

2233
01:45:08,000 --> 01:45:09,000
但也像你说

2234
01:45:09,000 --> 01:45:11,000
目前他采用这个叫什么 TikTak

2235
01:45:12,000 --> 01:45:13,000
的策略

2236
01:45:15,000 --> 01:45:16,000
一年发布新产品

2237
01:45:16,000 --> 01:45:18,000
一次发布新产品

2238
01:45:18,000 --> 01:45:19,000
另一次

2239
01:45:22,000 --> 01:45:23,000
做维护

2240
01:45:23,000 --> 01:45:25,000
做升级修复技术产品的

2241
01:45:25,000 --> 01:45:26,000
这样的缺陷

2242
01:45:26,000 --> 01:45:28,000
我觉得这个策略还是挺好

2243
01:45:28,000 --> 01:45:29,000
但就看他保持得怎么样

2244
01:45:29,000 --> 01:45:30,000
对

2245
01:45:31,000 --> 01:45:33,000
说回这个设计模式

2246
01:45:33,000 --> 01:45:34,000
其实有一点

2247
01:45:34,000 --> 01:45:36,000
我一直有点疑惑

2248
01:45:36,000 --> 01:45:37,000
其实我也是看很多人

2249
01:45:37,000 --> 01:45:39,000
对这个设计模式的批评

2250
01:45:39,000 --> 01:45:40,000
就是说

2251
01:45:41,000 --> 01:45:42,000
至少在那本书里面

2252
01:45:42,000 --> 01:45:43,000
很多设计模式

2253
01:45:43,000 --> 01:45:44,000
其实很

2254
01:45:44,000 --> 01:45:45,000
它的存在的意义

2255
01:45:46,000 --> 01:45:47,000
仅仅是因为

2256
01:45:47,000 --> 01:45:49,000
加把这个语言本身的一些

2257
01:45:49,000 --> 01:45:50,000
限制所导致的

2258
01:45:50,000 --> 01:45:51,000
不够

2259
01:45:52,000 --> 01:45:54,000
课的模式写出来的时候

2260
01:45:54,000 --> 01:45:55,000
其实是被 CZ 加强

2261
01:45:56,000 --> 01:45:57,000
OK

2262
01:45:57,000 --> 01:45:58,000
之类的

2263
01:45:58,000 --> 01:45:59,000
对

2264
01:45:59,000 --> 01:46:00,000
作为静态语言

2265
01:46:00,000 --> 01:46:01,000
然后有一些

2266
01:46:01,000 --> 01:46:03,000
所谓动态语言

2267
01:46:03,000 --> 01:46:05,000
鼓吹的就说

2268
01:46:05,000 --> 01:46:08,000
你费劲搞那么多各种各样的

2269
01:46:08,000 --> 01:46:09,000
Pattern

2270
01:46:09,000 --> 01:46:10,000
你看我们动态语言里面

2271
01:46:10,000 --> 01:46:12,000
根本不用操心这个问题

2272
01:46:12,000 --> 01:46:13,000
我一个列表

2273
01:46:13,000 --> 01:46:15,000
我就是可以装多种不同类型的元素

2274
01:46:15,000 --> 01:46:16,000
你把我砸地

2275
01:46:16,000 --> 01:46:17,000
对吧

2276
01:46:17,000 --> 01:46:18,000
对

2277
01:46:18,000 --> 01:46:19,000
其实这也是一个

2278
01:46:19,000 --> 01:46:21,000
正确的理解

2279
01:46:21,000 --> 01:46:23,000
就是编程里面的设计模式

2280
01:46:23,000 --> 01:46:24,000
在很多时候

2281
01:46:25,000 --> 01:46:27,000
与其说是一种

2282
01:46:28,000 --> 01:46:30,000
做事情方法

2283
01:46:30,000 --> 01:46:31,000
倒不如说是因为

2284
01:46:31,000 --> 01:46:33,000
语言没有办法让你

2285
01:46:33,000 --> 01:46:35,000
欢快的做某事

2286
01:46:35,000 --> 01:46:39,000
你不得不先以一种比较

2287
01:46:40,000 --> 01:46:42,000
约定俗成的一种比较

2288
01:46:42,000 --> 01:46:44,000
经过考验的

2289
01:46:44,000 --> 01:46:46,000
Best practice

2290
01:46:46,000 --> 01:46:47,000
把这件事情

2291
01:46:47,000 --> 01:46:48,000
做出来

2292
01:46:48,000 --> 01:46:49,000
没错

2293
01:46:49,000 --> 01:46:51,000
每期名曰设计模式

2294
01:46:51,000 --> 01:46:52,000
但其实它只是一个

2295
01:46:54,000 --> 01:46:55,000
就是前人

2296
01:46:55,000 --> 01:46:58,000
前人在这条路上躺过了

2297
01:46:58,000 --> 01:46:59,000
踩了无数个坑

2298
01:46:59,000 --> 01:47:02,000
发现这个坑的副作用是最小的

2299
01:47:02,000 --> 01:47:03,000
那么告诉后人说

2300
01:47:03,000 --> 01:47:05,000
来我插个小瓊在这里

2301
01:47:05,000 --> 01:47:06,000
别走那边那几个坑

2302
01:47:06,000 --> 01:47:07,000
此处有雷的

2303
01:47:07,000 --> 01:47:09,000
请这样绕形

2304
01:47:09,000 --> 01:47:10,000
对

2305
01:47:10,000 --> 01:47:11,000
给人家画了一条

2306
01:47:11,000 --> 01:47:12,000
我们现在抽象出

2307
01:47:12,000 --> 01:47:14,000
脑子这边是一条路

2308
01:47:14,000 --> 01:47:16,000
你要从地图的左下角

2309
01:47:16,000 --> 01:47:17,000
串到右上角去

2310
01:47:17,000 --> 01:47:19,000
但是雷区遍地

2311
01:47:19,000 --> 01:47:20,000
你不知道吗

2312
01:47:20,000 --> 01:47:22,000
新的你可能跟孩子家就死了

2313
01:47:22,000 --> 01:47:24,000
所以前人在踏着

2314
01:47:24,000 --> 01:47:26,000
堆堆白骨的技术上

2315
01:47:26,000 --> 01:47:29,000
总结出一条非常曲折绕的方法

2316
01:47:29,000 --> 01:47:31,000
可以只要到达

2317
01:47:31,000 --> 01:47:33,000
带你顺利到达目的地

2318
01:47:33,000 --> 01:47:34,000
对吧

2319
01:47:34,000 --> 01:47:36,000
这就是我们所有的设计模式

2320
01:47:36,000 --> 01:47:38,000
但是其实我

2321
01:47:38,000 --> 01:47:40,000
就很多对设计模式的批评者来看

2322
01:47:40,000 --> 01:47:41,000
就是说

2323
01:47:41,000 --> 01:47:43,000
那你费那么多钱搞这个

2324
01:47:43,000 --> 01:47:44,000
其实因为你语言不够好

2325
01:47:44,000 --> 01:47:46,000
你换一个好点语言

2326
01:47:46,000 --> 01:47:47,000
不就没这么多事了吗

2327
01:47:47,000 --> 01:47:48,000
对

2328
01:47:48,000 --> 01:47:49,000
就像在

2329
01:47:50,000 --> 01:47:51,000
沿用这个比方的话

2330
01:47:51,000 --> 01:47:53,000
就是你要从 A 点到 B 点

2331
01:47:53,000 --> 01:47:54,000
在你发展中

2332
01:47:54,000 --> 01:47:55,000
飞过去呢

2333
01:47:55,000 --> 01:47:58,000
对你发展出隧道绝尽技术之前

2334
01:47:58,000 --> 01:48:00,000
你不都不在山上绕一圈

2335
01:48:00,000 --> 01:48:02,000
可是如果你把小隧道的话

2336
01:48:02,000 --> 01:48:03,000
就不用了

2337
01:48:03,000 --> 01:48:05,000
比如说

2338
01:48:05,000 --> 01:48:06,000
我觉得这个地方

2339
01:48:06,000 --> 01:48:08,000
其实可以举个例子

2340
01:48:08,000 --> 01:48:10,000
你刚才说的动态语言

2341
01:48:10,000 --> 01:48:13,000
相对来说更为强大

2342
01:48:13,000 --> 01:48:15,000
容器类型是一个好例子

2343
01:48:15,000 --> 01:48:18,000
但另外一方面比如说

2344
01:48:20,000 --> 01:48:24,000
原始的设计模式里面有叫做 Observer 的模式

2345
01:48:24,000 --> 01:48:26,000
一个人做

2346
01:48:26,000 --> 01:48:29,000
一个类作为 Observer 的

2347
01:48:30,000 --> 01:48:32,000
注册者

2348
01:48:32,000 --> 01:48:34,000
他来生产一定的消息

2349
01:48:34,000 --> 01:48:36,000
然后另外一些

2350
01:48:39,000 --> 01:48:44,000
Objects 作为 Observer 来去注册

2351
01:48:45,000 --> 01:48:47,000
对象注册说

2352
01:48:47,000 --> 01:48:49,000
我对你的某一些消息感兴趣

2353
01:48:49,000 --> 01:48:52,000
如果你这个消息请你通知我

2354
01:48:52,000 --> 01:48:53,000
在 Java 里面

2355
01:48:53,000 --> 01:48:54,000
这一边是当作

2356
01:48:54,000 --> 01:48:55,000
或者说在 Java 里面

2357
01:48:55,000 --> 01:48:57,000
是当作一个模式来用

2358
01:48:57,000 --> 01:48:59,000
但是到了 Cycab 这一步

2359
01:48:59,000 --> 01:49:02,000
我们都知道 Cycab 拖抬于 Java

2360
01:49:02,000 --> 01:49:05,000
或者说他急取了 Java 的优点

2361
01:49:05,000 --> 01:49:07,000
如果 Java 有什么优点的话

2362
01:49:09,000 --> 01:49:12,000
Cycab 内置有所谓 delegate event

2363
01:49:12,000 --> 01:49:16,000
这两个在语言上面上实现的

2364
01:49:18,000 --> 01:49:19,000
怎么说呢

2365
01:49:19,000 --> 01:49:20,000
抽象概念

2366
01:49:21,000 --> 01:49:23,000
有了这个语言结构的传言概念

2367
01:49:23,000 --> 01:49:24,000
Observer 模式怎么有用呢

2368
01:49:24,000 --> 01:49:26,000
因为你自己不需要去

2369
01:49:26,000 --> 01:49:27,000
构建这个 Observer 的模式

2370
01:49:27,000 --> 01:49:28,000
你只需要直接使用

2371
01:49:28,000 --> 01:49:31,000
Cycab 内部的这两个

2372
01:49:32,000 --> 01:49:33,000
怎么说的语法堂吧

2373
01:49:33,000 --> 01:49:34,000
对

2374
01:49:36,000 --> 01:49:38,000
你还能想到一个别的

2375
01:49:38,000 --> 01:49:40,000
其实这个事情顺着说下去

2376
01:49:40,000 --> 01:49:42,000
因为这种经常在这种

2377
01:49:42,000 --> 01:49:44,000
设计 UI 界面的情况

2378
01:49:44,000 --> 01:49:46,000
用了非常多

2379
01:49:46,000 --> 01:49:48,000
现在新的思潮是什么来的

2380
01:49:48,000 --> 01:49:49,000
就是什么

2381
01:49:49,000 --> 01:49:50,000
FRP

2382
01:49:50,000 --> 01:49:52,000
Functional Ractical Programming

2383
01:49:52,000 --> 01:49:55,000
它连这种像什么来的

2384
01:49:56,000 --> 01:49:58,000
就是交互式的观察者

2385
01:49:58,000 --> 01:49:59,000
还有被观察者

2386
01:49:59,000 --> 01:50:02,000
注册这种事情都直接就免了

2387
01:50:02,000 --> 01:50:04,000
我们全部单向流

2388
01:50:05,000 --> 01:50:07,000
完全是不同意的

2389
01:50:07,000 --> 01:50:09,000
一种思路在做这个事情

2390
01:50:09,000 --> 01:50:12,000
你会发现有些设计模式

2391
01:50:12,000 --> 01:50:14,000
其实也是非常在观念上

2392
01:50:14,000 --> 01:50:16,000
它是比较成就的一个东西

2393
01:50:17,000 --> 01:50:18,000
当然

2394
01:50:18,000 --> 01:50:20,000
我们现在总是站在一种

2395
01:50:20,000 --> 01:50:24,000
麻烦的角度去说

2396
01:50:24,000 --> 01:50:26,000
设计模式里面有些模式

2397
01:50:26,000 --> 01:50:28,000
其实根本就是在修语语言

2398
01:50:28,000 --> 01:50:31,000
或者是有些模式根本有过时了

2399
01:50:31,000 --> 01:50:33,000
但是在 90 年代的时候

2400
01:50:33,000 --> 01:50:37,000
这本书还是影响了整整一代人

2401
01:50:37,000 --> 01:50:38,000
必须说

2402
01:50:38,000 --> 01:50:40,000
而且在这本书之后

2403
01:50:40,000 --> 01:50:44,000
也其实出现了很多其他的事

2404
01:50:44,000 --> 01:50:48,000
比如说这本书一上来就提到的 MVC 模式

2405
01:50:48,000 --> 01:50:50,000
在接下来的很多年里面

2406
01:50:50,000 --> 01:50:52,000
首先它有很多种不同的解读

2407
01:50:52,000 --> 01:50:54,000
基本上每一个

2408
01:50:54,000 --> 01:50:58,000
每两个程序员对于 MVC 的解读都是不一样的

2409
01:50:59,000 --> 01:51:03,000
甚至后来也有 MVC 衍生出来

2410
01:51:03,000 --> 01:51:04,000
比如什么 MVVM

2411
01:51:04,000 --> 01:51:05,000
或者是

2412
01:51:06,000 --> 01:51:08,000
很多其他莫名其妙

2413
01:51:08,000 --> 01:51:10,000
我现在也想不下的缩写

2414
01:51:10,000 --> 01:51:14,000
都是拖台元的 MVC 这样一种模式的

2415
01:51:14,000 --> 01:51:15,000
对

2416
01:51:16,000 --> 01:51:19,000
以至于很多语言本身也会说

2417
01:51:19,000 --> 01:51:21,000
在使用这种语言的时候

2418
01:51:21,000 --> 01:51:22,000
我会有一个特征的模式

2419
01:51:22,000 --> 01:51:23,000
比如说

2420
01:51:23,000 --> 01:51:25,000
我记得以前看过的

2421
01:51:25,000 --> 01:51:28,000
一个 Python Patterns

2422
01:51:28,000 --> 01:51:31,000
总结了使用 Python 编程的时候

2423
01:51:31,000 --> 01:51:34,000
能够经常使用的一些 Python

2424
01:51:34,000 --> 01:51:36,000
我印象很深的是

2425
01:51:36,000 --> 01:51:40,000
里面有叫做 Cyber 的 Python

2426
01:51:40,000 --> 01:51:43,000
Cyber 就是星际铭行

2427
01:51:43,000 --> 01:51:45,000
Star Trek 里面有一个种族叫 Cyber

2428
01:51:45,000 --> 01:51:50,000
他们的个体没有个体的意识

2429
01:51:50,000 --> 01:51:52,000
然后

2430
01:51:53,000 --> 01:51:55,000
战斗力非常强

2431
01:51:55,000 --> 01:51:57,000
然后他们每征服一个种族

2432
01:51:57,000 --> 01:51:59,000
就把这个种族员的每个个体

2433
01:51:59,000 --> 01:52:04,000
融合到他们的一个 Mastermind

2434
01:52:04,000 --> 01:52:06,000
他们只有一个集体意识

2435
01:52:06,000 --> 01:52:09,000
然后个体服从的集体

2436
01:52:09,000 --> 01:52:12,000
然后 Cyber 这个名字就被借用来

2437
01:52:12,000 --> 01:52:17,000
描述这样一种 Python 的设计模式

2438
01:52:17,000 --> 01:52:24,000
就是很多 objects 共享一个 Global 的 State

2439
01:52:25,000 --> 01:52:29,000
然后还有比如说

2440
01:52:29,000 --> 01:52:34,000
我前年看了一本 Coco Pattern

2441
01:52:34,000 --> 01:52:35,000
Coco Design Pattern

2442
01:52:35,000 --> 01:52:40,000
也是讲在 Coco 里面经常被用到的一些模式

2443
01:52:40,000 --> 01:52:43,000
比如说 Observer 模式

2444
01:52:43,000 --> 01:52:45,000
不是 Observer 模式

2445
01:52:45,000 --> 01:52:46,000
Coco 叫什么

2446
01:52:46,000 --> 01:52:47,000
Divigation 模式

2447
01:52:49,000 --> 01:52:53,000
乃至于在 Coco 下面的 MVC 模式

2448
01:52:54,000 --> 01:52:57,000
以及比如说

2449
01:52:59,000 --> 01:53:00,000
在写 LGX 的时候

2450
01:53:00,000 --> 01:53:03,000
经常会用到一个 Selector

2451
01:53:03,000 --> 01:53:05,000
然后你会说

2452
01:53:05,000 --> 01:53:08,000
我需要延迟一点时间来执行 Selector

2453
01:53:08,000 --> 01:53:10,000
主辞这样一些模式

2454
01:53:10,000 --> 01:53:12,000
在这本书里面介绍的话

2455
01:53:12,000 --> 01:53:16,000
可以说从试着模式这本书开始之后

2456
01:53:16,000 --> 01:53:21,000
陆陆续续人们才开始着眼于总结出

2457
01:53:21,000 --> 01:53:23,000
使用某一种特征工具的时候

2458
01:53:23,000 --> 01:53:27,000
所以应该使用一些最佳实践

2459
01:53:27,000 --> 01:53:29,000
然后把他们总结下来

2460
01:53:29,000 --> 01:53:31,000
把他们汇总出来

2461
01:53:31,000 --> 01:53:36,000
起上某某 Domem 之下的设计模式这样一个名字

2462
01:53:37,000 --> 01:53:38,000
OK

2463
01:53:38,000 --> 01:53:41,000
所以其实我有一点很疑惑的

2464
01:53:41,000 --> 01:53:42,000
就是说

2465
01:53:42,000 --> 01:53:46,000
你觉得对于一个某一个工具

2466
01:53:46,000 --> 01:53:47,000
某一个语言

2467
01:53:47,000 --> 01:53:48,000
新手来说

2468
01:53:48,000 --> 01:53:50,000
设计模式这个东西有多大的意义

2469
01:53:51,000 --> 01:53:53,000
因为我一直是抱着这么一种想法

2470
01:53:54,000 --> 01:53:55,000
刚刚我们说

2471
01:53:55,000 --> 01:53:59,000
这个是一个在一个布满雷区的地图上给你花了条线

2472
01:53:59,000 --> 01:54:00,000
这么一个功能对吧

2473
01:54:00,000 --> 01:54:02,000
但是其实对于很多新手来讲

2474
01:54:02,000 --> 01:54:04,000
你不让他去犯一些错误

2475
01:54:04,000 --> 01:54:06,000
他是永远都不知道为什么会这样

2476
01:54:06,000 --> 01:54:08,000
为什么会用另外一种方式来做

2477
01:54:08,000 --> 01:54:10,000
会更好看起来可能更曲折

2478
01:54:10,000 --> 01:54:12,000
但结果可能会更加好

2479
01:54:12,000 --> 01:54:14,000
没有这么一个学习的过程

2480
01:54:14,000 --> 01:54:17,000
就是我们强行给他灌了一碗鸡汤

2481
01:54:17,000 --> 01:54:19,000
说喝这个对你有意

2482
01:54:19,000 --> 01:54:20,000
别问为什么

2483
01:54:20,000 --> 01:54:22,000
但是他心里一定有无数个为什么

2484
01:54:22,000 --> 01:54:23,000
没错

2485
01:54:23,000 --> 01:54:25,000
就是如果你没有踩过雷的话

2486
01:54:25,000 --> 01:54:27,000
是不知道被雷炸死有多疼

2487
01:54:27,000 --> 01:54:28,000
对

2488
01:54:29,000 --> 01:54:33,000
而设计模式其实并不是一个适合

2489
01:54:33,000 --> 01:54:36,000
你刚刚学会编程的时候就不看的东西

2490
01:54:36,000 --> 01:54:37,000
因为

2491
01:54:37,000 --> 01:54:38,000
我觉得

2492
01:54:39,000 --> 01:54:41,000
我自己可能也是看设计模式的时候

2493
01:54:41,000 --> 01:54:43,000
比较倒性还不够深

2494
01:54:43,000 --> 01:54:44,000
当然我现在倒性也不深

2495
01:54:44,000 --> 01:54:46,000
那时候这更是会觉得

2496
01:54:46,000 --> 01:54:49,000
这些设计模式里面很多地方就是

2497
01:54:50,000 --> 01:54:51,000
脱了裤子放屁嘛

2498
01:54:51,000 --> 01:54:53,000
就是我们明明可以直接一步就做到了

2499
01:54:53,000 --> 01:54:55,000
为什么一定要通过这么周章的

2500
01:54:55,000 --> 01:54:57,000
大肥周章的方式来

2501
01:54:57,000 --> 01:54:59,000
来实现他们

2502
01:54:59,000 --> 01:55:01,000
但是只有你在

2503
01:55:03,000 --> 01:55:07,000
官方话叫的长期的工作实践

2504
01:55:08,000 --> 01:55:10,000
对大关墙是长期的工作实践

2505
01:55:10,000 --> 01:55:12,000
只有你在

2506
01:55:12,000 --> 01:55:14,000
经历过

2507
01:55:15,000 --> 01:55:17,000
因为自己的代码

2508
01:55:17,000 --> 01:55:19,000
越来越大

2509
01:55:19,000 --> 01:55:21,000
让你每次开始写

2510
01:55:21,000 --> 01:55:23,000
它都会产生一种

2511
01:55:23,000 --> 01:55:27,000
恐惧和恶心的情绪的时候

2512
01:55:27,000 --> 01:55:29,000
当你

2513
01:55:29,000 --> 01:55:31,000
因为每天心不在焉

2514
01:55:31,000 --> 01:55:33,000
被你的女朋友们说

2515
01:55:33,000 --> 01:55:35,000
你是不是不爱我

2516
01:55:35,000 --> 01:55:39,000
然后你所能做出的回答只是

2517
01:55:39,000 --> 01:55:41,000
My code doesn't work

2518
01:55:41,000 --> 01:55:42,000
的时候

2519
01:55:42,000 --> 01:55:44,000
你才会体会到

2520
01:55:44,000 --> 01:55:46,000
设计模式其实是一种

2521
01:55:46,000 --> 01:55:48,000
多么伟大的存在

2522
01:55:48,000 --> 01:55:52,000
我觉得其实一个比较合适的切入点是

2523
01:55:52,000 --> 01:55:54,000
你可以写一些程序

2524
01:55:54,000 --> 01:55:57,000
然后总结出你自己觉得

2525
01:55:57,000 --> 01:56:00,000
A 看起来是个不错的

2526
01:56:00,000 --> 01:56:03,000
模式加引号的时候

2527
01:56:03,000 --> 01:56:05,000
再去回头去看一些

2528
01:56:05,000 --> 01:56:07,000
去回头去看

2529
01:56:07,000 --> 01:56:09,000
比如说设计模式这本书

2530
01:56:09,000 --> 01:56:11,000
至于在这本书出版之后

2531
01:56:11,000 --> 01:56:13,000
有很多很多其他的比如说

2532
01:56:14,000 --> 01:56:16,000
Design Partons in C sharp

2533
01:56:16,000 --> 01:56:18,000
或者是 Design Partons

2534
01:56:18,000 --> 01:56:19,000
Implement in JavaScript

2535
01:56:19,000 --> 01:56:20,000
对这些书

2536
01:56:20,000 --> 01:56:22,000
你才会切身理误

2537
01:56:22,000 --> 01:56:24,000
这些设计模式真有意义和在

2538
01:56:25,000 --> 01:56:26,000
对

2539
01:56:26,000 --> 01:56:28,000
所以其实最合适的阅读

2540
01:56:28,000 --> 01:56:30,000
这种设计模式这种思想

2541
01:56:30,000 --> 01:56:34,000
这种比较玄学的书也好

2542
01:56:34,000 --> 01:56:36,000
还是文章也好的时候

2543
01:56:36,000 --> 01:56:38,000
其实是在你有一定的工作积累

2544
01:56:38,000 --> 01:56:39,000
才过不少累

2545
01:56:39,000 --> 01:56:41,000
被炸死过好多次之后

2546
01:56:41,000 --> 01:56:45,000
然后又想进一步提高自己的水平

2547
01:56:45,000 --> 01:56:46,000
又遇到这个瓶颈

2548
01:56:46,000 --> 01:56:48,000
不知道该下来不该怎么走的时候

2549
01:56:48,000 --> 01:56:50,000
来看这个可能有种那种

2550
01:56:50,000 --> 01:56:51,000
提湖冠定的感觉

2551
01:56:53,000 --> 01:56:54,000
对

2552
01:56:57,000 --> 01:56:58,000
然后在

2553
01:57:00,000 --> 01:57:03,000
应该是前年的时候有这样一篇报道

2554
01:57:03,000 --> 01:57:05,000
他们请到了

2555
01:57:05,000 --> 01:57:07,000
Alice Gamma

2556
01:57:07,000 --> 01:57:08,000
Richard Helm

2557
01:57:08,000 --> 01:57:09,000
还有 Raph Johnson

2558
01:57:09,000 --> 01:57:11,000
就是四人帮里面的三个人

2559
01:57:11,000 --> 01:57:14,000
来在这本书出版的十五年之后

2560
01:57:14,000 --> 01:57:20,000
重新讨论设计模式的利语币

2561
01:57:20,000 --> 01:57:22,000
大概是什么意思

2562
01:57:22,000 --> 01:57:23,000
反思汇是吧

2563
01:57:25,000 --> 01:57:26,000
反思汇吗

2564
01:57:28,000 --> 01:57:29,000
算吧

2565
01:57:29,000 --> 01:57:30,000
算是一个对

2566
01:57:30,000 --> 01:57:33,000
老兵俱乐部的这种感觉

2567
01:57:35,000 --> 01:57:37,000
然后在那边

2568
01:57:37,000 --> 01:57:40,000
在这个访谈里面有这样一句话说

2569
01:57:41,000 --> 01:57:44,000
高级的声音

2570
01:57:44,000 --> 01:57:46,000
简单地调整

2571
01:57:46,000 --> 01:57:49,000
设计模式的利语币

2572
01:57:49,000 --> 01:57:51,000
和高级的声音

2573
01:57:51,000 --> 01:57:53,000
设计模式的利语币

2574
01:57:53,000 --> 01:57:58,000
我觉得这也是设计模式比较重要的一点

2575
01:57:58,000 --> 01:57:59,000
就是

2576
01:57:59,000 --> 01:58:01,000
有了设计模式之后

2577
01:58:01,000 --> 01:58:04,000
你可以用很短的句子

2578
01:58:04,000 --> 01:58:08,000
跟别人交流一些比较浓缩的概念

2579
01:58:08,000 --> 01:58:09,000
比如说

2580
01:58:09,000 --> 01:58:11,000
你不用跟别人说

2581
01:58:11,000 --> 01:58:13,000
我在这里想到一个方法

2582
01:58:13,000 --> 01:58:16,000
这个方法的作用就是根据

2583
01:58:16,000 --> 01:58:21,000
实际的类型需求来生产出不同类型的

2584
01:58:21,000 --> 01:58:22,000
object

2585
01:58:22,000 --> 01:58:23,000
你可直接跟他说

2586
01:58:23,000 --> 01:58:27,000
这边是一个 factory

2587
01:58:27,000 --> 01:58:30,000
工厂方法

2588
01:58:30,000 --> 01:58:32,000
这里是一个工厂方法

2589
01:58:32,000 --> 01:58:35,000
然后你甚至可以说

2590
01:58:35,000 --> 01:58:38,000
这是一个 metafactory

2591
01:58:38,000 --> 01:58:39,000
对

2592
01:58:39,000 --> 01:58:41,000
叫做 abstract factory

2593
01:58:41,000 --> 01:58:43,000
这是一个生产工厂的工厂

2594
01:58:43,000 --> 01:58:45,000
应该用非常简单的句子

2595
01:58:45,000 --> 01:58:47,000
表达相对来说

2596
01:58:47,000 --> 01:58:48,000
更加复杂概念

2597
01:58:48,000 --> 01:58:51,000
然后从这个层面来说

2598
01:58:51,000 --> 01:58:53,000
你懂一些设计模式之后

2599
01:58:53,000 --> 01:58:59,000
你也可以更加方便地去表达

2600
01:58:59,000 --> 01:59:02,000
就是理解别人通过一大片代码

2601
01:59:02,000 --> 01:59:05,000
或者是一些很简单的句子

2602
01:59:05,000 --> 01:59:08,000
想要表达的意思

2603
01:59:08,000 --> 01:59:10,000
然后这边

2604
01:59:10,000 --> 01:59:12,000
访谈里面还提到说

2605
01:59:12,000 --> 01:59:14,000
访谈的主持人说

2606
01:59:14,000 --> 01:59:16,000
访谈的主持人也就是

2607
01:59:16,000 --> 01:59:18,000
安德尔不重要

2608
01:59:18,000 --> 01:59:19,000
主持人问说

2609
01:59:19,000 --> 01:59:22,000
在现在这个时代

2610
01:59:22,000 --> 01:59:26,000
我们只需要写异行 PHP 代码

2611
01:59:26,000 --> 01:59:30,000
就可以做出一个网站来

2612
01:59:30,000 --> 01:59:32,000
写着 Hello World

2613
01:59:32,000 --> 01:59:35,000
The time is the time is the time

2614
01:59:35,000 --> 01:59:37,000
这样一个网站出来

2615
01:59:37,000 --> 01:59:39,000
那么在这样一个时代里面

2616
01:59:39,000 --> 01:59:42,000
设定不上一份民意呢

2617
01:59:42,000 --> 01:59:47,000
然后 Richard 说

2618
01:59:47,000 --> 01:59:49,000
I think there has been

2619
01:59:49,000 --> 01:59:52,000
evolution level of sophistication

2620
01:59:52,000 --> 01:59:56,000
也就是说在复杂度的层级上面

2621
01:59:56,000 --> 01:59:58,000
在过去的这 15 年里面

2622
01:59:58,000 --> 02:00:03,000
这些软件有一个非常大的进化

2623
02:00:03,000 --> 02:00:05,000
可以附用的软件

2624
02:00:05,000 --> 02:00:08,000
已经被移制到了比较

2625
02:00:08,000 --> 02:00:10,000
接近底层的位置

2626
02:00:10,000 --> 02:00:13,000
比如说一个 toolkit 或者 framing

2627
02:00:13,000 --> 02:00:16,000
然后这些东西的设计

2628
02:00:16,000 --> 02:00:18,000
应该更多的被

2629
02:00:18,000 --> 02:00:21,000
be left to the experts

2630
02:00:21,000 --> 02:00:22,000
也就是说

2631
02:00:22,000 --> 02:00:25,000
现在大部分写出的设计人都不是 experts

2632
02:00:25,000 --> 02:00:27,000
在沿用这些个

2633
02:00:27,000 --> 02:00:28,000
组合一些

2634
02:00:28,000 --> 02:00:30,000
他们组织的工作只是

2635
02:00:30,000 --> 02:00:33,000
把一些 framing 的东西组合起来

2636
02:00:33,000 --> 02:00:35,000
然后拖拖通控键

2637
02:00:35,000 --> 02:00:36,000
谢谢业务逻辑

2638
02:00:36,000 --> 02:00:38,000
然后就可以用了

2639
02:00:38,000 --> 02:00:41,000
那么在这种情况之下

2640
02:00:41,000 --> 02:00:44,000
the goal for most software developers

2641
02:00:44,000 --> 02:00:47,000
still remains to design for change

2642
02:00:47,000 --> 02:00:49,000
and there are debate

2643
02:00:49,000 --> 02:00:52,000
is do you do it early or later

2644
02:00:52,000 --> 02:00:55,000
in many cases the design should be refactored

2645
02:00:55,000 --> 02:00:58,000
and the patterns provide a target to do this

2646
02:00:58,000 --> 02:01:00,000
也就是说

2647
02:01:00,000 --> 02:01:02,000
即便在这种情况之下

2648
02:01:02,000 --> 02:01:05,000
虽然不直接参与一个框架

2649
02:01:05,000 --> 02:01:08,000
或者是一个弹耳库的开发

2650
02:01:08,000 --> 02:01:10,000
但你仍就需要做出一些决定

2651
02:01:10,000 --> 02:01:12,000
而这些决定也就是

2652
02:01:12,000 --> 02:01:14,000
我们刚才的读者来心里面也提到了

2653
02:01:14,000 --> 02:01:16,000
很大程度上他是一种重构

2654
02:01:16,000 --> 02:01:18,000
然后你在做重构的时候

2655
02:01:18,000 --> 02:01:20,000
你就会发现

2656
02:01:20,000 --> 02:01:22,000
设理模式其实是有大用途的

2657
02:01:22,000 --> 02:01:24,000
你在重构的时候

2658
02:01:24,000 --> 02:01:27,000
你会去看到说

2659
02:01:27,000 --> 02:01:29,000
目前的这块代码

2660
02:01:29,000 --> 02:01:32,000
尤其是在比较敏捷的状况下写出来的代码

2661
02:01:32,000 --> 02:01:35,000
它内部可能存在一些什么样的问题

2662
02:01:35,000 --> 02:01:39,000
而设理模式则可以为你提供一些

2663
02:01:39,000 --> 02:01:41,000
解决这些问题的思路

2664
02:01:41,000 --> 02:01:42,000
我觉得这也是设理模式

2665
02:01:42,000 --> 02:01:45,000
即便在很多年之后

2666
02:01:45,000 --> 02:01:47,000
我们大部分从业者都不是那么

2667
02:01:47,000 --> 02:01:49,000
expert 的情况下

2668
02:01:49,000 --> 02:01:52,000
这些问题就有用了一个例子

2669
02:01:52,000 --> 02:01:54,000
没错

2670
02:01:54,000 --> 02:01:57,000
节目的最后

2671
02:01:57,000 --> 02:01:59,000
我们讲一个跟设计模式相关的

2672
02:01:59,000 --> 02:02:02,000
它的篮身兄弟

2673
02:02:02,000 --> 02:02:04,000
AntiPattern

2674
02:02:04,000 --> 02:02:06,000
这翻译成中文怎么翻

2675
02:02:06,000 --> 02:02:08,000
反模式

2676
02:02:08,000 --> 02:02:10,000
逆模式吧 反模式

2677
02:02:10,000 --> 02:02:12,000
逆模式 反模式

2678
02:02:12,000 --> 02:02:15,000
对 AntiPattern 就是那些

2679
02:02:15,000 --> 02:02:17,000
容易掉进坑吧

2680
02:02:17,000 --> 02:02:19,000
我觉得可以这么说

2681
02:02:19,000 --> 02:02:22,000
有些坑是

2682
02:02:22,000 --> 02:02:24,000
人人避开

2683
02:02:24,000 --> 02:02:26,000
有些坑是人人避开

2684
02:02:26,000 --> 02:02:28,000
有些坑是人人都会掉进去

2685
02:02:28,000 --> 02:02:30,000
我相信

2686
02:02:30,000 --> 02:02:32,000
AntiPattern

2687
02:02:32,000 --> 02:02:34,000
我相信 AntiPattern 的数量是要远远远远

2688
02:02:34,000 --> 02:02:36,000
多于 DesignPattern

2689
02:02:36,000 --> 02:02:39,000
不知道这个假设是不是正确

2690
02:02:39,000 --> 02:02:42,000
至少你去搜 AntiPattern 的话

2691
02:02:42,000 --> 02:02:45,000
你可以找到一些会总的页面

2692
02:02:45,000 --> 02:02:47,000
页面上列出的那个

2693
02:02:47,000 --> 02:02:50,000
Pattern 可能远远远远超于

2694
02:02:50,000 --> 02:02:51,000
超过

2695
02:02:51,000 --> 02:02:52,000
私人帮的

2696
02:02:52,000 --> 02:02:54,000
所以开始给出那 23 个

2697
02:02:54,000 --> 02:02:56,000
比较好的比赛

2698
02:02:56,000 --> 02:03:00,000
具体个例子吧

2699
02:03:00,000 --> 02:03:01,000
第一个例子就是

2700
02:03:01,000 --> 02:03:03,000
我想说就是高的 Object

2701
02:03:03,000 --> 02:03:06,000
对 AntiPattern 其实也是有名字的

2702
02:03:06,000 --> 02:03:09,000
我想说的第一个就是高的 Object

2703
02:03:09,000 --> 02:03:12,000
我不知道各位有没有这样一个阶段

2704
02:03:12,000 --> 02:03:14,000
如果你写过很多程序的话

2705
02:03:14,000 --> 02:03:16,000
成名的程序如果大到一个境界

2706
02:03:16,000 --> 02:03:19,000
你会

2707
02:03:19,000 --> 02:03:21,000
下意识的

2708
02:03:21,000 --> 02:03:24,000
把那些不知道归雷

2709
02:03:24,000 --> 02:03:26,000
不知道归给谁的东西

2710
02:03:26,000 --> 02:03:29,000
归到同一个东西下面

2711
02:03:29,000 --> 02:03:32,000
最常见的就是你会写一个叫做

2712
02:03:32,000 --> 02:03:33,000
Toolkit

2713
02:03:33,000 --> 02:03:35,000
或者是 Utility

2714
02:03:35,000 --> 02:03:37,000
或者是

2715
02:03:37,000 --> 02:03:38,000
Base

2716
02:03:38,000 --> 02:03:39,000
这样一个 Object

2717
02:03:39,000 --> 02:03:41,000
然后里面放了一大堆

2718
02:03:41,000 --> 02:03:42,000
common 之类的

2719
02:03:42,000 --> 02:03:43,000
对 common 点什么什么

2720
02:03:43,000 --> 02:03:45,000
一大堆根本就不知道

2721
02:03:45,000 --> 02:03:47,000
你不知道我刚刚放在那

2722
02:03:47,000 --> 02:03:48,000
全部放在那

2723
02:03:48,000 --> 02:03:50,000
比如说这个 Utility 里面可能有

2724
02:03:50,000 --> 02:03:52,000
一个会图函数

2725
02:03:52,000 --> 02:03:54,000
然后一个打开文件的函数

2726
02:03:54,000 --> 02:03:57,000
一个做网络通信的函数

2727
02:03:57,000 --> 02:04:00,000
然后一个帮你存密码函数

2728
02:04:00,000 --> 02:04:02,000
或者一个帮你烧水的函数

2729
02:04:02,000 --> 02:04:04,000
全部放在里面

2730
02:04:04,000 --> 02:04:05,000
其实这就是一个非常

2731
02:04:05,000 --> 02:04:07,000
非常知名的

2732
02:04:07,000 --> 02:04:08,000
AntiPattern 叫做

2733
02:04:08,000 --> 02:04:09,000
高达 Object

2734
02:04:09,000 --> 02:04:11,000
就是这个 Object 无所不能

2735
02:04:11,000 --> 02:04:12,000
全知全能

2736
02:04:12,000 --> 02:04:14,000
有非常多的

2737
02:04:14,000 --> 02:04:17,000
对其实这个 Pattern 在

2738
02:04:17,000 --> 02:04:20,000
命中式变成里面也会出现

2739
02:04:20,000 --> 02:04:21,000
就是你如果你放了太多的

2740
02:04:21,000 --> 02:04:23,000
全球变量的话

2741
02:04:23,000 --> 02:04:24,000
其实也是一个比较

2742
02:04:24,000 --> 02:04:27,000
比较明显的高达 Object

2743
02:04:27,000 --> 02:04:30,000
它违反了一个原则

2744
02:04:30,000 --> 02:04:32,000
就是你应该提供

2745
02:04:32,000 --> 02:04:34,000
尽量清晰的接口

2746
02:04:35,000 --> 02:04:37,000
你应该尽量让

2747
02:04:37,000 --> 02:04:39,000
每一个 Object 的职合清晰化

2748
02:04:39,000 --> 02:04:41,000
但是在高达 Object 这里

2749
02:04:41,000 --> 02:04:43,000
这一切都被你毁了

2750
02:04:43,000 --> 02:04:44,000
就是你会发现

2751
02:04:44,000 --> 02:04:45,000
这个高达 Object

2752
02:04:45,000 --> 02:04:47,000
这事件是无处不在

2753
02:04:47,000 --> 02:04:48,000
就是个大杂会

2754
02:04:48,000 --> 02:04:50,000
对然后你会发现

2755
02:04:50,000 --> 02:04:51,000
重购物园的非常艰难

2756
02:04:51,000 --> 02:04:52,000
因为你根本就不知道

2757
02:04:52,000 --> 02:04:53,000
哪些业务逻辑

2758
02:04:53,000 --> 02:04:57,000
可以从这个 Object 里面提取出来

2759
02:04:57,000 --> 02:04:58,000
这是一个比较

2760
02:04:58,000 --> 02:04:59,000
这是一个

2761
02:04:59,000 --> 02:05:00,000
我自己能想到的

2762
02:05:00,000 --> 02:05:02,000
第一个比较著名的 AntiPattern

2763
02:05:05,000 --> 02:05:06,000
还有什么

2764
02:05:08,000 --> 02:05:09,000
Golden Hammer

2765
02:05:09,000 --> 02:05:10,000
对 Golden Hammer

2766
02:05:10,000 --> 02:05:14,000
也是一个比较知名的 AntiPattern

2767
02:05:14,000 --> 02:05:17,000
就是这样俗话说

2768
02:05:17,000 --> 02:05:19,000
我有一把锤子

2769
02:05:19,000 --> 02:05:21,000
我看什么都像钉子

2770
02:05:23,000 --> 02:05:25,000
这在如果要把它

2771
02:05:25,000 --> 02:05:26,000
总结一个 Pattern 的话

2772
02:05:26,000 --> 02:05:28,000
那就是你会里没语言

2773
02:05:28,000 --> 02:05:30,000
或者是你掌握了一个库

2774
02:05:30,000 --> 02:05:33,000
你会觉得说

2775
02:05:34,000 --> 02:05:36,000
甚至不一定是一个个人

2776
02:05:36,000 --> 02:05:37,000
可能在一个团队上

2777
02:05:37,000 --> 02:05:39,000
也会体现出这样一种倾向来

2778
02:05:39,000 --> 02:05:40,000
我要用这个工具

2779
02:05:40,000 --> 02:05:41,000
解决一切的问题

2780
02:05:41,000 --> 02:05:42,000
所有的问题都应该

2781
02:05:42,000 --> 02:05:44,000
转化到这个工具上来解决

2782
02:05:44,000 --> 02:05:46,000
或者说所有的

2783
02:05:48,000 --> 02:05:49,000
你是 OP 本身

2784
02:05:49,000 --> 02:05:51,000
就是一个 Golden Hammer 是吧

2785
02:05:51,000 --> 02:05:52,000
对

2786
02:05:52,000 --> 02:05:53,000
你要说了吗

2787
02:05:53,000 --> 02:05:56,000
其实你现在看很多那种

2788
02:05:56,000 --> 02:05:57,000
都是在哪里

2789
02:05:57,000 --> 02:05:59,000
直播上写过这么一段话

2790
02:05:59,000 --> 02:06:01,000
什么时候你觉得 OP 的

2791
02:06:01,000 --> 02:06:03,000
这条路已经走得太远了

2792
02:06:03,000 --> 02:06:05,000
你看到这种语句

2793
02:06:05,000 --> 02:06:08,000
就说 executor.execute

2794
02:06:08,000 --> 02:06:10,000
快好

2795
02:06:10,000 --> 02:06:11,000
开快关

2796
02:06:12,000 --> 02:06:13,000
对

2797
02:06:13,000 --> 02:06:15,000
是你那个

2798
02:06:15,000 --> 02:06:18,000
其实我能想到的就是

2799
02:06:18,000 --> 02:06:19,000
有些面试题

2800
02:06:19,000 --> 02:06:21,000
比如说 feasBus

2801
02:06:22,000 --> 02:06:24,000
这样面试题

2802
02:06:25,000 --> 02:06:27,000
你明明写一个函数

2803
02:06:27,000 --> 02:06:28,000
就可以解决

2804
02:06:28,000 --> 02:06:29,000
你不用写函数

2805
02:06:29,000 --> 02:06:30,000
你写一个 follow

2806
02:06:30,000 --> 02:06:31,000
就给解决的问题

2807
02:06:31,000 --> 02:06:33,000
有些人要先

2808
02:06:33,000 --> 02:06:35,000
因为他只学过面

2809
02:06:35,000 --> 02:06:36,000
对

2810
02:06:36,000 --> 02:06:37,000
因为他只学过面上都这样

2811
02:06:37,000 --> 02:06:39,000
所以他情愧自信的一上来

2812
02:06:39,000 --> 02:06:40,000
要写个类

2813
02:06:40,000 --> 02:06:41,000
不 这个也是加碼害的

2814
02:06:41,000 --> 02:06:43,000
因为加碼没有不是类的东西

2815
02:06:43,000 --> 02:06:44,000
你没有没有没有没有

2816
02:06:44,000 --> 02:06:45,000
没有办法执行的

2817
02:06:45,000 --> 02:06:46,000
对

2818
02:06:46,000 --> 02:06:48,000
加碼连一个程序的入口点

2819
02:06:48,000 --> 02:06:49,000
都要放在一个类里面

2820
02:06:49,000 --> 02:06:50,000
这是何苦

2821
02:06:50,000 --> 02:06:51,000
这是

2822
02:06:51,000 --> 02:06:52,000
程序没

2823
02:06:52,000 --> 02:06:54,000
程序何苦没能程序

2824
02:06:56,000 --> 02:06:57,000
没错

2825
02:06:57,000 --> 02:06:59,000
与 Golden Hammer 相对的

2826
02:06:59,000 --> 02:07:01,000
也有一个 silver bullet

2827
02:07:01,000 --> 02:07:02,000
这也是一个

2828
02:07:02,000 --> 02:07:03,000
一代

2829
02:07:03,000 --> 02:07:04,000
对

2830
02:07:04,000 --> 02:07:05,000
其实 silver bullet

2831
02:07:05,000 --> 02:07:06,000
后来我查了一下

2832
02:07:06,000 --> 02:07:07,000
它是有一个来业的

2833
02:07:07,000 --> 02:07:09,000
只不过这个来业是如此的久远

2834
02:07:09,000 --> 02:07:11,000
也至于我们新生代的

2835
02:07:11,000 --> 02:07:13,000
我们已经是不如中央

2836
02:07:13,000 --> 02:07:14,000
但我们

2837
02:07:14,000 --> 02:07:16,000
在此之后就可以自豪说一声

2838
02:07:16,000 --> 02:07:17,000
我们新生代的成学人

2839
02:07:17,000 --> 02:07:20,000
不知道这个耿来业是挺有可

2840
02:07:20,000 --> 02:07:22,000
就是在 30 年代

2841
02:07:23,000 --> 02:07:25,000
有这样一些故事

2842
02:07:25,000 --> 02:07:27,000
讲述一个叫做

2843
02:07:27,000 --> 02:07:29,000
The Long Ranger

2844
02:07:31,000 --> 02:07:33,000
的西部

2845
02:07:33,000 --> 02:07:35,000
牛仔

2846
02:07:35,000 --> 02:07:36,000
他不是牛的

2847
02:07:36,000 --> 02:07:38,000
他应该是西部的一个检察官

2848
02:07:38,000 --> 02:07:40,000
后来变成了一个

2849
02:07:40,000 --> 02:07:42,000
匡扶正义的侠客这么一个形象

2850
02:07:42,000 --> 02:07:44,000
他有把枪

2851
02:07:44,000 --> 02:07:45,000
骑警吗

2852
02:07:45,000 --> 02:07:47,000
Ranger 就是骑警

2853
02:07:47,000 --> 02:07:48,000
骑的马

2854
02:07:48,000 --> 02:07:50,000
Ranger 最古老的意思

2855
02:07:50,000 --> 02:07:52,000
指的是循灵客

2856
02:07:52,000 --> 02:07:56,000
所以在游戏兵

2857
02:07:56,000 --> 02:07:57,000
嘛

2858
02:07:57,000 --> 02:07:58,000
对

2859
02:07:58,000 --> 02:07:59,000
对

2860
02:07:59,000 --> 02:08:01,000
但不重要

2861
02:08:01,000 --> 02:08:04,000
反正他这个形象最大的决杀

2862
02:08:04,000 --> 02:08:06,000
就是他有一个

2863
02:08:06,000 --> 02:08:07,000
他有把很长的枪

2864
02:08:07,000 --> 02:08:08,000
然后一枪可以射出

2865
02:08:08,000 --> 02:08:09,000
Silver bullet

2866
02:08:09,000 --> 02:08:11,000
Silver bullet 每次

2867
02:08:11,000 --> 02:08:13,000
击中什么东西都是

2868
02:08:13,000 --> 02:08:15,000
所以他是个神枪手

2869
02:08:15,000 --> 02:08:16,000
然后他可以做到

2870
02:08:16,000 --> 02:08:18,000
比如说这个人快被吊死了

2871
02:08:18,000 --> 02:08:20,000
他在两三百米开外

2872
02:08:20,000 --> 02:08:21,000
打一颗银带

2873
02:08:21,000 --> 02:08:22,000
打一颗 Silver bullet

2874
02:08:22,000 --> 02:08:23,000
把那个人的

2875
02:08:23,000 --> 02:08:24,000
把这个人

2876
02:08:24,000 --> 02:08:26,000
把吊这个人的绳子射断

2877
02:08:26,000 --> 02:08:28,000
然后

2878
02:08:28,000 --> 02:08:30,000
或者是

2879
02:08:30,000 --> 02:08:32,000
一枪打爆一个锁

2880
02:08:32,000 --> 02:08:34,000
然后锁偏桥

2881
02:08:34,000 --> 02:08:35,000
就可以弹开

2882
02:08:35,000 --> 02:08:36,000
然后可以让门打开

2883
02:08:36,000 --> 02:08:38,000
这样一种

2884
02:08:38,000 --> 02:08:40,000
非常奇迹引桥的技术

2885
02:08:40,000 --> 02:08:42,000
好像

2886
02:08:42,000 --> 02:08:43,000
最近

2887
02:08:43,000 --> 02:08:44,000
应该是前年

2888
02:08:44,000 --> 02:08:46,000
这个 Long Ranger 这个故事

2889
02:08:46,000 --> 02:08:48,000
还重新被搬上萤幕

2890
02:08:48,000 --> 02:08:50,000
Badass

2891
02:08:50,000 --> 02:08:51,000
对

2892
02:08:51,000 --> 02:08:52,000
John Depp

2893
02:08:52,000 --> 02:08:53,000
对

2894
02:08:53,000 --> 02:08:54,000
这个 Silver bullet

2895
02:08:54,000 --> 02:08:56,000
实际上来自这样一个槽

2896
02:08:56,000 --> 02:08:58,000
然后 Silver bullet 的特点就是

2897
02:08:58,000 --> 02:09:00,000
相信有这样一种技术

2898
02:09:00,000 --> 02:09:02,000
能够可以

2899
02:09:02,000 --> 02:09:04,000
一劳勇一的解决

2900
02:09:04,000 --> 02:09:06,000
所有一些

2901
02:09:06,000 --> 02:09:07,000
对

2902
02:09:07,000 --> 02:09:09,000
无视其

2903
02:09:09,000 --> 02:09:11,000
无视其边界条件的

2904
02:09:11,000 --> 02:09:13,000
难题

2905
02:09:13,000 --> 02:09:15,000
然后这个

2906
02:09:15,000 --> 02:09:17,000
Silver bullet 也是通过人越神话

2907
02:09:17,000 --> 02:09:18,000
对

2908
02:09:18,000 --> 02:09:19,000
发言光耐

2909
02:09:19,000 --> 02:09:20,000
于现在很多

2910
02:09:20,000 --> 02:09:22,000
如果相信大粉丞选

2911
02:09:22,000 --> 02:09:23,000
都应该听过这个名字

2912
02:09:23,000 --> 02:09:24,000
但是

2913
02:09:24,000 --> 02:09:25,000
不太清楚他是怎么排的

2914
02:09:25,000 --> 02:09:26,000
但是像 Silver bullet

2915
02:09:26,000 --> 02:09:27,000
也是一个比较

2916
02:09:27,000 --> 02:09:29,000
比较著名的

2917
02:09:29,000 --> 02:09:30,000
Antipart

2918
02:09:30,000 --> 02:09:31,000
嗯

2919
02:09:31,000 --> 02:09:33,000
看

2920
02:09:33,000 --> 02:09:34,000
这个发言存中

2921
02:09:34,000 --> 02:09:36,000
我应该叫什么来的

2922
02:09:36,000 --> 02:09:38,000
万金油

2923
02:09:38,000 --> 02:09:39,000
对

2924
02:09:39,000 --> 02:09:41,000
Silver bullet 万金油模式

2925
02:09:41,000 --> 02:09:42,000
GOLDEN HEMMOR

2926
02:09:42,000 --> 02:09:43,000
其实也是一个万金油

2927
02:09:43,000 --> 02:09:45,000
用点万金油的意思

2928
02:09:45,000 --> 02:09:46,000
但是 Silver bullet

2929
02:09:46,000 --> 02:09:48,000
Silver bullet 强调的还是

2930
02:09:48,000 --> 02:09:49,000
强调的是这种

2931
02:09:49,000 --> 02:09:52,000
这种解决方案的模法性

2932
02:09:52,000 --> 02:09:53,000
就是这个

2933
02:09:53,000 --> 02:09:54,000
解决方案真的是

2934
02:09:54,000 --> 02:09:56,000
要到并除

2935
02:09:56,000 --> 02:09:58,000
一劳勇异

2936
02:09:58,000 --> 02:09:59,000
而 GOLDEN HEMMOR

2937
02:09:59,000 --> 02:10:01,000
更强调的是这样一种方

2938
02:10:01,000 --> 02:10:03,000
这样某一个方法的普世性

2939
02:10:03,000 --> 02:10:05,000
就是拿它来干什么都可以

2940
02:10:05,000 --> 02:10:06,000
所以应该是 GOLDEN HEMMOR

2941
02:10:06,000 --> 02:10:07,000
等价一万金油

2942
02:10:07,000 --> 02:10:10,000
然后 Silver bullet 是叫什么来的

2943
02:10:10,000 --> 02:10:12,000
林达妙药是不是

2944
02:10:12,000 --> 02:10:14,000
对林达妙药

2945
02:10:14,000 --> 02:10:15,000
还有错

2946
02:10:15,000 --> 02:10:16,000
以后我们可以试着

2947
02:10:16,000 --> 02:10:17,000
把所有的安提帕能都给一个

2948
02:10:17,000 --> 02:10:19,000
本土话的中文名

2949
02:10:21,000 --> 02:10:22,000
要读起来

2950
02:10:22,000 --> 02:10:23,000
你也算很爽

2951
02:10:25,000 --> 02:10:27,000
感谢你收听本期

2952
02:10:27,000 --> 02:10:29,000
IPM podcast 的王老七下的

2953
02:10:29,000 --> 02:10:31,000
IT 技术主题娱乐节目内容文化

2954
02:10:31,000 --> 02:10:32,000
我们号称 Hardcore

2955
02:10:32,000 --> 02:10:33,000
但是也没有干货

2956
02:10:33,000 --> 02:10:34,000
想念的人听

2957
02:10:34,000 --> 02:10:35,000
不想听的人就别听

2958
02:10:35,000 --> 02:10:37,000
您可以为本节目捐款

2959
02:10:37,000 --> 02:10:41,000
捐款历史是 ipm.ls-kernopalmik-donate

2960
02:10:41,000 --> 02:10:42,000
捐款结合随意

2961
02:10:42,000 --> 02:10:43,000
只要是能为 8

2962
02:10:43,000 --> 02:10:44,000
整除了正常数字都可以

2963
02:10:44,000 --> 02:10:46,000
捐款不会为你带来什么

2964
02:10:46,000 --> 02:10:48,000
不捐也不会让你试试什么

2965
02:10:48,000 --> 02:10:49,000
我们的口号是

2966
02:10:49,000 --> 02:10:50,000
no hard feelings

2967
02:10:50,000 --> 02:10:52,000
如果你有什么反馈

2968
02:10:52,000 --> 02:10:53,000
欢迎你发邮件

2969
02:10:53,000 --> 02:10:57,000
到 kernopalmik-at-ipm.li

2970
02:10:57,000 --> 02:10:59,000
如果写的足够长的话

2971
02:10:59,000 --> 02:11:01,000
我们一定会念出来

2972
02:11:01,000 --> 02:11:03,000
同时也欢迎你收听 IPM

2973
02:11:03,000 --> 02:11:05,000
旗下的其他几档节目

2974
02:11:05,000 --> 02:11:07,000
ID 公路未知到

2975
02:11:07,000 --> 02:11:08,000
太一来了

2976
02:11:08,000 --> 02:11:09,000
流行通信

2977
02:11:09,000 --> 02:11:11,000
Hardstory 以及印影项

2978
02:11:11,000 --> 02:11:12,000
我们下期节目再会

2979
02:11:41,000 --> 02:11:47,000
请不吝点赞 订阅 转发 打赏支持明镜与点点栏目

