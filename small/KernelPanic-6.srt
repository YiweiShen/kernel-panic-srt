1
00:00:00,000 --> 00:00:05,000
大家好 欢迎收听第六期的内核恐慌 我是 Rail

2
00:00:05,000 --> 00:00:06,000
我是无陶

3
00:00:06,000 --> 00:00:11,000
在今天节目开始之前呢 我们先去做一下上期的反馈吧

4
00:00:11,000 --> 00:00:12,000
好呀

5
00:00:12,000 --> 00:00:14,000
无陶你又念错字了

6
00:00:18,000 --> 00:00:23,000
对 反正上次我念了一个以石听众

7
00:00:23,000 --> 00:00:27,000
在这里向大家聚工 各位听众 对不起我不应该吃你们

8
00:00:28,000 --> 00:00:33,000
那个字念是想 就是左边一个乡村的乡右边一个食物的食

9
00:00:33,000 --> 00:00:39,000
这个字念以想听众 就是以把什么东西供奉给听众吃

10
00:00:39,000 --> 00:00:41,000
而不是吃掉听众是吧

11
00:00:41,000 --> 00:00:43,000
你是唐狼吗

12
00:00:45,000 --> 00:00:47,000
唐狼只有在交配的出

13
00:00:50,000 --> 00:00:53,000
其实这个事情我觉得也可以理解吧

14
00:00:53,000 --> 00:00:56,000
你说这个字如果你让我来念 我估计也会看

15
00:00:56,000 --> 00:01:00,000
你想那个左边那么小 右边那么大 应该念右边吧

16
00:01:01,000 --> 00:01:04,000
对呀 而且就才念字 念半边嘛

17
00:01:07,000 --> 00:01:08,000
对

18
00:01:08,000 --> 00:01:11,000
其实中文就是有这点不好啊 就是经常有这种

19
00:01:11,000 --> 00:01:14,000
所谓的什么 规律嘛

20
00:01:14,000 --> 00:01:17,000
说如果你不认识这个字 你可以看它 有没有偏旁不守啊

21
00:01:17,000 --> 00:01:21,000
说一般是什么 一边行旁 一个身旁 对吧

22
00:01:22,000 --> 00:01:24,000
先吧 给你一个

23
00:01:24,000 --> 00:01:27,000
中文还是在 我们现在身处在一个中文

24
00:01:27,000 --> 00:01:31,000
从象形文字向评言文字的过渡过程中

25
00:01:31,000 --> 00:01:33,000
当然这个过渡可能永远不会实现了

26
00:01:33,000 --> 00:01:37,000
因为毕竟现在汉字已经是一种文化归宝

27
00:01:37,000 --> 00:01:42,000
它们是不可能 永远不可能实现加冥化的

28
00:01:42,000 --> 00:01:45,000
所以你默默地是支持这件事情的 是吧

29
00:01:48,000 --> 00:01:49,000
也没有吧

30
00:01:50,000 --> 00:01:55,000
但是拉丁化汉字拉丁化那么迹进的方案

31
00:01:57,000 --> 00:02:02,000
也不是都没有实现 就让人觉得非常受不了了

32
00:02:02,000 --> 00:02:05,000
我觉得拉丁化在逻辑上已经实现了

33
00:02:06,000 --> 00:02:08,000
就在事实上已经成立了

34
00:02:09,000 --> 00:02:11,000
你说用拼书法吧

35
00:02:11,000 --> 00:02:13,000
对呀 就是经常会有那种

36
00:02:14,000 --> 00:02:16,000
现在网络上一些用语不方便

37
00:02:16,000 --> 00:02:20,000
直接讲的时候都会在后面注一下拼音

38
00:02:20,000 --> 00:02:23,000
然后大家读一下都知道这个是什么意思 对吧

39
00:02:24,000 --> 00:02:29,000
对 而且对 反正是越来越没有人写字了

40
00:02:29,000 --> 00:02:30,000
这是肯定

41
00:02:30,000 --> 00:02:31,000
对 都在打

42
00:02:31,000 --> 00:02:35,000
但是我还在 07 年

43
00:02:35,000 --> 00:02:36,000
反正 iPhone 出现之前

44
00:02:36,000 --> 00:02:40,000
我还坚持用过落架上面的笔画书法

45
00:02:40,000 --> 00:02:42,000
我觉得至少这样可以让我

46
00:02:42,000 --> 00:02:44,000
是那个九宫阁那个吗

47
00:02:45,000 --> 00:02:47,000
对 九宫阁的笔画书法

48
00:02:47,000 --> 00:02:49,000
其实我一直觉得那个还蛮好的

49
00:02:49,000 --> 00:02:50,000
叫什么 T 9 吧 是不是

50
00:02:52,000 --> 00:02:54,000
好像是叫 T 9

51
00:02:54,000 --> 00:02:55,000
T 9 是拼音吧 不是吧

52
00:02:55,000 --> 00:02:57,000
是吗 T 9 是拼音吗 OK

53
00:02:57,000 --> 00:02:58,000
我怎么觉得

54
00:02:58,000 --> 00:02:59,000
我不记得 不确定

55
00:02:59,000 --> 00:03:01,000
但我记得那个书法只要有五个架而已吧

56
00:03:01,000 --> 00:03:05,000
就横书撇 横书撇 撇

57
00:03:05,000 --> 00:03:09,000
撇就是撇右上到左下

58
00:03:09,000 --> 00:03:11,000
然后横然后书

59
00:03:11,000 --> 00:03:13,000
我觉得那个书法真的挺好的

60
00:03:13,000 --> 00:03:15,000
对 它解决了我很多的倒差笔问题

61
00:03:15,000 --> 00:03:16,000
比如说

62
00:03:16,000 --> 00:03:17,000
全部是倒差笔

63
00:03:18,000 --> 00:03:22,000
就是一个汉字的笔顺

64
00:03:22,000 --> 00:03:24,000
和官方规定的不一样

65
00:03:24,000 --> 00:03:26,000
然后这样我就打不出来

66
00:03:26,000 --> 00:03:28,000
比如说女人的女字吧 好像

67
00:03:28,000 --> 00:03:31,000
对 然后我十次有九次打不出来

68
00:03:31,000 --> 00:03:32,000
所以那个笔画书法

69
00:03:32,000 --> 00:03:34,000
应该是撇折再撇

70
00:03:34,000 --> 00:03:36,000
然后最后一很软

71
00:03:36,000 --> 00:03:37,000
我现在又不记得

72
00:03:37,000 --> 00:03:38,000
也可能是先写好了

73
00:03:38,000 --> 00:03:40,000
对 反正

74
00:03:40,000 --> 00:03:43,000
然后还有所有在走之旁的字

75
00:03:43,000 --> 00:03:44,000
我全都先写走之

76
00:03:44,000 --> 00:03:45,000
对吧

77
00:03:45,000 --> 00:03:46,000
我在这个合理

78
00:03:46,000 --> 00:03:49,000
你先把周围的框画出来

79
00:03:49,000 --> 00:03:51,000
然后在那里面描那个小的

80
00:03:52,000 --> 00:03:54,000
我也是这么觉得

81
00:03:54,000 --> 00:03:56,000
但是据说

82
00:03:56,000 --> 00:03:57,000
如果先写走之的话

83
00:03:57,000 --> 00:03:58,000
整个字很难看

84
00:03:58,000 --> 00:03:59,000
就是

85
00:03:59,000 --> 00:04:01,000
因为那个走之它只是一个配件

86
00:04:01,000 --> 00:04:04,000
然后你先写它就很容易

87
00:04:04,000 --> 00:04:06,000
让接下来写的那东西

88
00:04:06,000 --> 00:04:08,000
很难放在正确的位置

89
00:04:08,000 --> 00:04:11,000
但你知道有些小学生写作文的时候

90
00:04:11,000 --> 00:04:12,000
写字的时候

91
00:04:12,000 --> 00:04:13,000
它不是写的一个小小的

92
00:04:13,000 --> 00:04:16,000
有框的那种本 这上面吗

93
00:04:16,000 --> 00:04:18,000
然后如果你先写了中间

94
00:04:18,000 --> 00:04:20,000
就旁边那个大坨的

95
00:04:20,000 --> 00:04:22,000
然后空间不够怎么办

96
00:04:22,000 --> 00:04:26,000
所以从小就要练架构

97
00:04:26,000 --> 00:04:28,000
不过这个笔画书法

98
00:04:28,000 --> 00:04:29,000
真的挺好的

99
00:04:29,000 --> 00:04:31,000
我有一个例子

100
00:04:31,000 --> 00:04:32,000
我给我爸妈那个时候

101
00:04:32,000 --> 00:04:36,000
教他们用电脑数字

102
00:04:36,000 --> 00:04:39,000
然后无比和平都尝试过

103
00:04:39,000 --> 00:04:41,000
对了他们那代人来说都太难了

104
00:04:41,000 --> 00:04:43,000
但是他们在手机

105
00:04:43,000 --> 00:04:44,000
那个就不是现代的手机

106
00:04:44,000 --> 00:04:45,000
在那个时候的手机上

107
00:04:45,000 --> 00:04:46,000
还是键盘的时候

108
00:04:46,000 --> 00:04:49,000
用横书皮拉这么一笔的写

109
00:04:49,000 --> 00:04:50,000
其实对他们来讲

110
00:04:50,000 --> 00:04:53,000
就跟教写字一样

111
00:04:53,000 --> 00:04:55,000
就是说你记着你先打横书皮拉

112
00:04:55,000 --> 00:04:56,000
你就怎么写字

113
00:04:56,000 --> 00:04:57,000
你就照着那个按钮

114
00:04:57,000 --> 00:04:59,000
就只用进来五个键就可以了

115
00:04:59,000 --> 00:05:03,000
然后加上笔顺纠错的这种功能的话

116
00:05:03,000 --> 00:05:04,000
就大部分场合

117
00:05:04,000 --> 00:05:07,000
还是能把中文字写出来的

118
00:05:07,000 --> 00:05:10,000
下一条就是什么玩意

119
00:05:10,000 --> 00:05:14,000
对上次说到德语

120
00:05:14,000 --> 00:05:16,000
就是上次我念错了一个德语单词

121
00:05:16,000 --> 00:05:19,000
就是当我提到 fe shift

122
00:05:19,000 --> 00:05:23,000
就是那个在德国的车牌上面

123
00:05:23,000 --> 00:05:26,000
所使用的那种字体的时候

124
00:05:26,000 --> 00:05:27,000
车牌字体

125
00:05:27,000 --> 00:05:28,000
对

126
00:05:28,000 --> 00:05:32,000
它的正确的名字叫做 fations and shift

127
00:05:33,000 --> 00:05:39,000
然后我上次念成了 fations and shift

128
00:05:39,000 --> 00:05:41,000
等一下我很好就是谁听出来你念错

129
00:05:41,000 --> 00:05:43,000
当然是我女朋友

130
00:05:43,000 --> 00:05:46,000
原来还有一个铁感粉丝

131
00:05:46,000 --> 00:05:47,000
那可不

132
00:05:47,000 --> 00:05:50,000
他已经开始给贵节目捐钱了

133
00:05:50,000 --> 00:05:52,000
你是说阿基功了吗

134
00:05:52,000 --> 00:05:53,000
对

135
00:05:53,000 --> 00:05:56,000
不是给 B 节目捐钱的

136
00:05:56,000 --> 00:06:00,000
不过 B 节目也有很多听众要求说来信

137
00:06:00,000 --> 00:06:03,000
纷纷来信说要给我们捐钱

138
00:06:03,000 --> 00:06:05,000
拿钱砸晕我们

139
00:06:05,000 --> 00:06:06,000
真的假的

140
00:06:06,000 --> 00:06:07,000
我才不相信

141
00:06:07,000 --> 00:06:08,000
真的

142
00:06:08,000 --> 00:06:09,000
不开玩笑

143
00:06:09,000 --> 00:06:11,000
那我们应该怎样

144
00:06:11,000 --> 00:06:14,000
怎样让我们的捐款页面

145
00:06:14,000 --> 00:06:16,000
显得更加 GEEK 一点呢

146
00:06:16,000 --> 00:06:18,000
你看我的捐款页面都做好了

147
00:06:18,000 --> 00:06:21,000
就得您大比一挥同意

148
00:06:23,000 --> 00:06:24,000
好吧我缺个麦克风

149
00:06:24,000 --> 00:06:27,000
也许可以各位给我凑点经费

150
00:06:27,000 --> 00:06:29,000
搞一个耗点麦克风

151
00:06:29,000 --> 00:06:31,000
让大家可以听到

152
00:06:31,000 --> 00:06:34,000
更加清透的嗓音

153
00:06:34,000 --> 00:06:37,000
更加丰富更加有层次感的声音

154
00:06:37,000 --> 00:06:39,000
有层次感的声音

155
00:06:39,000 --> 00:06:42,000
不过其实现在有的人听不出来

156
00:06:42,000 --> 00:06:45,000
你是用的那个麦克风的内置麦克风在录

157
00:06:45,000 --> 00:06:48,000
因为内置麦克风据说效果非常好

158
00:06:48,000 --> 00:06:52,000
对但是离这个一个专用的麦

159
00:06:52,000 --> 00:06:54,000
还是有比较明显的差别

160
00:06:54,000 --> 00:06:58,000
我在 Instagram 上看到的你用的麦克风

161
00:06:58,000 --> 00:06:59,000
我用的麦克风蛮专用的

162
00:06:59,000 --> 00:07:01,000
我那个也是一个入门级的而已

163
00:07:01,000 --> 00:07:03,000
好

164
00:07:03,000 --> 00:07:04,000
我们可以给你买

165
00:07:04,000 --> 00:07:07,000
如果我们这个节目也开始收钱

166
00:07:07,000 --> 00:07:08,000
打赢

167
00:07:08,000 --> 00:07:09,000
好

168
00:07:09,000 --> 00:07:10,000
我们拿到他的钱

169
00:07:10,000 --> 00:07:12,000
第一件事就先给你买一套

170
00:07:12,000 --> 00:07:13,000
这个好的录音

171
00:07:13,000 --> 00:07:14,000
好的这个设备

172
00:07:14,000 --> 00:07:17,000
也不过

173
00:07:18,000 --> 00:07:19,000
我现在我们就看

174
00:07:19,000 --> 00:07:21,000
到底会不会让给我们钱

175
00:07:21,000 --> 00:07:22,000
好吧

176
00:07:23,000 --> 00:07:24,000
对

177
00:07:25,000 --> 00:07:27,000
然后这不是我唯一念错的德语词

178
00:07:27,000 --> 00:07:30,000
我还念错另外一个叫做

179
00:07:30,000 --> 00:07:33,000
Dortius Institute for Normal

180
00:07:33,000 --> 00:07:36,000
我把它念成了 Dortius Institute for Normal

181
00:07:36,000 --> 00:07:40,000
就是我把 Institut 这个词的词性搞错了

182
00:07:42,000 --> 00:07:44,000
你要先解释一下什么是词性

183
00:07:44,000 --> 00:07:45,000
因为这个不是

184
00:07:45,000 --> 00:07:47,000
比如英文里面就没有这个概念

185
00:07:47,000 --> 00:07:49,000
所以很多人不知道是什么东西

186
00:07:50,000 --> 00:07:51,000
好吧

187
00:07:51,000 --> 00:07:54,000
反正德语作为一种非常繁琐的语言

188
00:07:54,000 --> 00:07:58,000
听起来像某种机器人掉到下水道里面

189
00:07:58,000 --> 00:08:00,000
发出的声音的语言

190
00:08:00,000 --> 00:08:02,000
还有非常多奇怪的地方

191
00:08:02,000 --> 00:08:04,000
比如说其中之一就是

192
00:08:04,000 --> 00:08:06,000
所有的名词要分成三类

193
00:08:06,000 --> 00:08:08,000
音性中性和阳性

194
00:08:08,000 --> 00:08:09,000
如果你学过法语的话

195
00:08:09,000 --> 00:08:11,000
你知道音性和阳性

196
00:08:11,000 --> 00:08:13,000
但是就像拉丁语一样

197
00:08:13,000 --> 00:08:15,000
德语还有中性这个东西

198
00:08:15,000 --> 00:08:18,000
阳性叫做阳性的第 1 个

199
00:08:18,000 --> 00:08:23,000
就是阳性的名词的单数的

200
00:08:23,000 --> 00:08:28,000
主格就有一个贯词叫做 Dare

201
00:08:28,000 --> 00:08:31,000
然后它相当于英语的 D

202
00:08:31,000 --> 00:08:36,000
然后音性的名词的贯词是 D

203
00:08:36,000 --> 00:08:38,000
然后它也相当于英语的 Dare

204
00:08:38,000 --> 00:08:41,000
然后中性的名词的贯词是 Dass

205
00:08:41,000 --> 00:08:43,000
它也相当于英语的 Dare

206
00:08:43,000 --> 00:08:45,000
就是英语只有一个 Dare

207
00:08:45,000 --> 00:08:48,000
然后德语有 Dare D.D.Dass

208
00:08:48,000 --> 00:08:49,000
Dare D.Dass

209
00:08:49,000 --> 00:08:50,000
这是所有的

210
00:08:50,000 --> 00:08:52,000
这个可能听众朋友们

211
00:08:52,000 --> 00:08:54,000
在国内见到最多就是那个

212
00:08:54,000 --> 00:08:55,000
大众的广告

213
00:08:55,000 --> 00:08:57,000
Dass Auto

214
00:08:57,000 --> 00:08:58,000
Dass Auto

215
00:08:58,000 --> 00:09:00,000
对 Dass Auto

216
00:09:00,000 --> 00:09:03,000
然后就是就翻译成一个

217
00:09:03,000 --> 00:09:04,000
The Car 的意思

218
00:09:04,000 --> 00:09:05,000
The Car

219
00:09:05,000 --> 00:09:06,000
Yes

220
00:09:06,000 --> 00:09:10,000
但是 Auto 这个东西是

221
00:09:10,000 --> 00:09:12,000
Auto Mobile 的缩写

222
00:09:12,000 --> 00:09:14,000
所以它是中性的

223
00:09:14,000 --> 00:09:15,000
Somehow Someway

224
00:09:15,000 --> 00:09:18,000
所以是 Dass Auto

225
00:09:18,000 --> 00:09:19,000
Dass Auto

226
00:09:19,000 --> 00:09:20,000
Dass Photo

227
00:09:20,000 --> 00:09:21,000
Auto 和 Photo

228
00:09:21,000 --> 00:09:22,000
Photo 就是 Photo

229
00:09:22,000 --> 00:09:25,000
Photo 和 Auto 都是中性的

230
00:09:25,000 --> 00:09:27,000
但是有很多不合理的地方

231
00:09:27,000 --> 00:09:29,000
比如说太阳吧

232
00:09:29,000 --> 00:09:31,000
它怎么可能会是阴性的呢

233
00:09:31,000 --> 00:09:33,000
结果德语面上它真的是阴性的

234
00:09:33,000 --> 00:09:34,000
对

235
00:09:34,000 --> 00:09:36,000
阴性的越来越是阳性的

236
00:09:36,000 --> 00:09:38,000
当然也是有原因的

237
00:09:38,000 --> 00:09:41,000
因为在古兆尔曼神话里面

238
00:09:41,000 --> 00:09:44,000
太阳是个女神

239
00:09:44,000 --> 00:09:46,000
越来是个男神

240
00:09:46,000 --> 00:09:47,000
越来是个男神

241
00:09:47,000 --> 00:09:50,000
就是跟希腊神话正好相反

242
00:09:50,000 --> 00:09:51,000
对

243
00:09:51,000 --> 00:09:55,000
它是一种比较古老的神话

244
00:09:55,000 --> 00:09:58,000
或者说宗教仪式的言存

245
00:09:58,000 --> 00:09:59,000
可以这么听

246
00:09:59,000 --> 00:10:03,000
但是这跟现在比如说中国的

247
00:10:03,000 --> 00:10:05,000
正常人的一个想法

248
00:10:05,000 --> 00:10:07,000
好像就不太一样

249
00:10:07,000 --> 00:10:08,000
对

250
00:10:08,000 --> 00:10:11,000
中国阳这个东西就没认识

251
00:10:11,000 --> 00:10:12,000
太阳

252
00:10:12,000 --> 00:10:14,000
阳这个东西就是太阳

253
00:10:14,000 --> 00:10:15,000
但

254
00:10:15,000 --> 00:10:16,000
对 阴就是月亮

255
00:10:16,000 --> 00:10:18,000
字里面具有月亮

256
00:10:18,000 --> 00:10:19,000
在德语里面

257
00:10:19,000 --> 00:10:22,000
Moscowlin 这个描述的正确翻译方法

258
00:10:22,000 --> 00:10:23,000
是雄性

259
00:10:23,000 --> 00:10:26,000
就是他们认为太阳是阴性的

260
00:10:26,000 --> 00:10:28,000
月亮是雄性的

261
00:10:28,000 --> 00:10:30,000
就太阳是磁性的

262
00:10:30,000 --> 00:10:32,000
月亮是雄性的

263
00:10:32,000 --> 00:10:36,000
3 号也有也能做出一点意义来的

264
00:10:36,000 --> 00:10:39,000
对 但还是比较奇怪的是

265
00:10:39,000 --> 00:10:40,000
对 关键是我觉得

266
00:10:40,000 --> 00:10:42,000
德语分这个三性完全

267
00:10:42,000 --> 00:10:44,000
任何一点用处也没有

268
00:10:44,000 --> 00:10:45,000
有没有什么实际的用处

269
00:10:45,000 --> 00:10:46,000
我自己自自然想不出来

270
00:10:46,000 --> 00:10:48,000
但是学的时候就很痛苦

271
00:10:48,000 --> 00:10:49,000
所有的

272
00:10:49,000 --> 00:10:50,000
大家如果被英文单词

273
00:10:50,000 --> 00:10:52,000
要被名词的话

274
00:10:52,000 --> 00:10:54,000
你得寄一个单副书 对吧

275
00:10:54,000 --> 00:10:55,000
就完了

276
00:10:55,000 --> 00:10:56,000
然后有些可能特别的什么

277
00:10:56,000 --> 00:10:57,000
单副同行

278
00:10:57,000 --> 00:10:59,000
或者是什么些特殊的

279
00:10:59,000 --> 00:11:00,000
单副同行有什么

280
00:11:00,000 --> 00:11:03,000
People 作为一个种族来讲

281
00:11:03,000 --> 00:11:04,000
对吧

282
00:11:04,000 --> 00:11:05,000
有同性 单副同行

283
00:11:05,000 --> 00:11:07,000
然后有些特殊的一个

284
00:11:07,000 --> 00:11:09,000
比如说我们常讲的数据

285
00:11:09,000 --> 00:11:10,000
Data

286
00:11:10,000 --> 00:11:11,000
其实是一个副书

287
00:11:11,000 --> 00:11:12,000
但是它的

288
00:11:12,000 --> 00:11:13,000
对 答统

289
00:11:13,000 --> 00:11:15,000
对 在德语里面

290
00:11:15,000 --> 00:11:17,000
这个词仍就在使用

291
00:11:17,000 --> 00:11:19,000
其拉丁与单数形式作为单数

292
00:11:19,000 --> 00:11:21,000
就是你说一个数据的时候

293
00:11:21,000 --> 00:11:22,000
你比如说

294
00:11:22,000 --> 00:11:23,000
Andatum

295
00:11:23,000 --> 00:11:25,000
而你不能说 data

296
00:11:25,000 --> 00:11:26,000
这种用法是错的

297
00:11:26,000 --> 00:11:28,000
对 在英语里面已经变成

298
00:11:28,000 --> 00:11:29,000
对 现在英语里面

299
00:11:29,000 --> 00:11:32,000
data 已经变成一个不可数

300
00:11:32,000 --> 00:11:33,000
然后是

301
00:11:33,000 --> 00:11:35,000
就没有副书形式

302
00:11:35,000 --> 00:11:37,000
但是如果你是考古的话

303
00:11:37,000 --> 00:11:38,000
也发现还有一个 data

304
00:11:38,000 --> 00:11:40,000
D-A-T-U-M

305
00:11:40,000 --> 00:11:41,000
单数的形式

306
00:11:41,000 --> 00:11:42,000
但是现在就只要在

307
00:11:42,000 --> 00:11:44,000
现代的文献里面

308
00:11:44,000 --> 00:11:46,000
基本上是看不到这个说法了

309
00:11:46,000 --> 00:11:48,000
当然还有一些更加诡异的

310
00:11:48,000 --> 00:11:50,000
就是单副书

311
00:11:50,000 --> 00:11:51,000
你完全看不出他们之间

312
00:11:51,000 --> 00:11:52,000
有什么区别的东西

313
00:11:52,000 --> 00:11:53,000
对 我记得

314
00:11:53,000 --> 00:11:55,000
前一阵子

315
00:11:55,000 --> 00:11:56,000
风田

316
00:11:56,000 --> 00:11:57,000
有辆日本车

317
00:11:57,000 --> 00:11:58,000
叫什么 叫什么

318
00:11:58,000 --> 00:11:59,000
Prius

319
00:11:59,000 --> 00:12:00,000
对

320
00:12:00,000 --> 00:12:02,000
Prius

321
00:12:02,000 --> 00:12:05,000
然后它的副书形式叫做 Pri

322
00:12:05,000 --> 00:12:06,000
Pri 对

323
00:12:06,000 --> 00:12:08,000
Prii

324
00:12:08,000 --> 00:12:09,000
两个 i

325
00:12:09,000 --> 00:12:10,000
就专门说这是一个拉丁语词

326
00:12:10,000 --> 00:12:12,000
所以它的副书应该叫 i

327
00:12:12,000 --> 00:12:13,000
What the hell

328
00:12:13,000 --> 00:12:14,000
对

329
00:12:14,000 --> 00:12:16,000
英文里面就是很奇怪的事情

330
00:12:16,000 --> 00:12:18,000
但是你想想都还能够接受

331
00:12:18,000 --> 00:12:19,000
起码还能知道说

332
00:12:19,000 --> 00:12:20,000
这个是为了区别

333
00:12:20,000 --> 00:12:21,000
一个和多个

334
00:12:21,000 --> 00:12:23,000
虽然我不能以何在

335
00:12:23,000 --> 00:12:25,000
然后还有就是

336
00:12:25,000 --> 00:12:26,000
但是德语里面的名词

337
00:12:26,000 --> 00:12:29,000
它除了要分单副书之外

338
00:12:29,000 --> 00:12:30,000
它还要分

339
00:12:30,000 --> 00:12:31,000
三个性别

340
00:12:31,000 --> 00:12:32,000
然后这三个性别

341
00:12:32,000 --> 00:12:34,000
Totally make no sense

342
00:12:34,000 --> 00:12:35,000
对

343
00:12:35,000 --> 00:12:37,000
当然可能

344
00:12:37,000 --> 00:12:38,000
我觉得没这么远

345
00:12:38,000 --> 00:12:39,000
都有些复杂度

346
00:12:39,000 --> 00:12:41,000
比如说中文的复杂录就在

347
00:12:41,000 --> 00:12:42,000
它的鞋里面

348
00:12:42,000 --> 00:12:44,000
它的书写是非常复杂的

349
00:12:44,000 --> 00:12:45,000
语法简单要词

350
00:12:45,000 --> 00:12:47,000
但是书写非常非常复杂

351
00:12:47,000 --> 00:12:49,000
对 其实从这个角度上

352
00:12:49,000 --> 00:12:50,000
中文还是蛮不错的

353
00:12:50,000 --> 00:12:52,000
就是不分单副书 对吧

354
00:12:52,000 --> 00:12:54,000
对 不分性书格

355
00:12:54,000 --> 00:12:55,000
这是非常好的一点

356
00:12:55,000 --> 00:12:56,000
对

357
00:12:56,000 --> 00:12:59,000
然后唯一一个要分那个

358
00:12:59,000 --> 00:13:00,000
就有中文有一个不太爽的地方

359
00:13:00,000 --> 00:13:01,000
量词太多

360
00:13:01,000 --> 00:13:02,000
有没有什么用

361
00:13:02,000 --> 00:13:03,000
对

362
00:13:03,000 --> 00:13:04,000
对于外国人来说

363
00:13:04,000 --> 00:13:07,000
最大的困扰之一就是量词

364
00:13:07,000 --> 00:13:08,000
你不像习语

365
00:13:08,000 --> 00:13:09,000
这些东西你不会就罢了

366
00:13:09,000 --> 00:13:11,000
量词你不会的话

367
00:13:11,000 --> 00:13:13,000
就很容易会说错话了

368
00:13:13,000 --> 00:13:14,000
对

369
00:13:14,000 --> 00:13:17,000
而且量词其实也没有太大的

370
00:13:17,000 --> 00:13:19,000
实际作用在我看来

371
00:13:19,000 --> 00:13:20,000
对

372
00:13:20,000 --> 00:13:24,000
它除了对于一些没有固定形状的东西

373
00:13:24,000 --> 00:13:26,000
有一些意义

374
00:13:26,000 --> 00:13:28,000
比如说英语里面也会说一瓶水

375
00:13:28,000 --> 00:13:29,000
一杯咖啡

376
00:13:29,000 --> 00:13:30,000
中文

377
00:13:30,000 --> 00:13:31,000
对

378
00:13:31,000 --> 00:13:33,000
但是除此之外

379
00:13:33,000 --> 00:13:35,000
好像为什么一定要说一匹马

380
00:13:35,000 --> 00:13:36,000
不能说一个马

381
00:13:37,000 --> 00:13:38,000
对

382
00:13:38,000 --> 00:13:39,000
马人一个

383
00:13:39,000 --> 00:13:41,000
不过但是在有些方言里面

384
00:13:41,000 --> 00:13:42,000
就是在方言的口语里面

385
00:13:42,000 --> 00:13:45,000
量词已经被很多情况下被审备掉了

386
00:13:45,000 --> 00:13:47,000
比如说最简单的一次

387
00:13:47,000 --> 00:13:48,000
我们俩人

388
00:13:48,000 --> 00:13:50,000
我们不是我们两个人对吧

389
00:13:50,000 --> 00:13:52,000
我们俩人在这里扯淡

390
00:13:52,000 --> 00:13:53,000
还有那个

391
00:13:53,000 --> 00:13:55,000
对面过来俩狗

392
00:13:57,000 --> 00:13:58,000
对

393
00:13:58,000 --> 00:14:00,000
就有时候还是可以审备的

394
00:14:00,000 --> 00:14:01,000
然后我一直在想

395
00:14:01,000 --> 00:14:04,000
作为一个有性格一点的尝试

396
00:14:04,000 --> 00:14:06,000
可以以后都不说两次

397
00:14:06,000 --> 00:14:07,000
看会有什么效果

398
00:14:07,000 --> 00:14:10,000
老板给我俩苹果

399
00:14:10,000 --> 00:14:11,000
这以后没有做过

400
00:14:11,000 --> 00:14:12,000
老板为了

401
00:14:12,000 --> 00:14:13,000
上俩面

402
00:14:13,000 --> 00:14:14,000
对

403
00:14:14,000 --> 00:14:15,000
上俩面

404
00:14:16,000 --> 00:14:17,000
对 这也不错

405
00:14:18,000 --> 00:14:21,000
老板来武车

406
00:14:23,000 --> 00:14:25,000
对 这种事情就比较诡异了

407
00:14:25,000 --> 00:14:26,000
可以试一下

408
00:14:26,000 --> 00:14:27,000
可以试一下

409
00:14:27,000 --> 00:14:28,000
下一条反轨

410
00:14:28,000 --> 00:14:29,000
是

411
00:14:29,000 --> 00:14:30,000
也是我的

412
00:14:30,000 --> 00:14:32,000
就是我上次说到

413
00:14:32,000 --> 00:14:34,000
伦敦的交通字体

414
00:14:34,000 --> 00:14:36,000
我不确定是 transport

415
00:14:36,000 --> 00:14:37,000
还是

416
00:14:37,000 --> 00:14:40,000
还是 underground 的字体里面

417
00:14:40,000 --> 00:14:41,000
I 小写字母

418
00:14:41,000 --> 00:14:43,000
I 的上面的那一点

419
00:14:43,000 --> 00:14:44,000
是个正方形的话

420
00:14:44,000 --> 00:14:45,000
我说旋转 90 度

421
00:14:45,000 --> 00:14:46,000
它是个零型

422
00:14:46,000 --> 00:14:47,000
但实际上正方形

423
00:14:47,000 --> 00:14:49,000
旋转 90 度还是个正方形

424
00:14:50,000 --> 00:14:51,000
你玩我们呢

425
00:14:54,000 --> 00:14:55,000
俄罗斯方块

426
00:14:55,000 --> 00:14:56,000
俄罗斯方块里面

427
00:14:56,000 --> 00:14:58,000
正方形怎么旋转

428
00:14:58,000 --> 00:14:59,000
都是这样

429
00:14:59,000 --> 00:15:00,000
没有用

430
00:15:00,000 --> 00:15:01,000
你说他写那个

431
00:15:01,000 --> 00:15:03,000
写那个正方形旋转

432
00:15:03,000 --> 00:15:04,000
那个函数

433
00:15:04,000 --> 00:15:06,000
该不会直接就 return

434
00:15:06,000 --> 00:15:07,000
no off

435
00:15:07,000 --> 00:15:08,000
对

436
00:15:08,000 --> 00:15:09,000
应该是我觉得

437
00:15:09,000 --> 00:15:10,000
没有意义

438
00:15:10,000 --> 00:15:11,000
对

439
00:15:13,000 --> 00:15:14,000
然后还有一条是

440
00:15:14,000 --> 00:15:16,000
梁海就认我的说

441
00:15:16,000 --> 00:15:17,000
小写的

442
00:15:17,000 --> 00:15:18,000
小写字母 G 的

443
00:15:18,000 --> 00:15:20,000
双层版本和新拉字母

444
00:15:20,000 --> 00:15:21,000
应该是没有什么关系的

445
00:15:21,000 --> 00:15:22,000
就是我当时想到

446
00:15:22,000 --> 00:15:24,000
他应该可能跟那个

447
00:15:25,000 --> 00:15:27,000
新拉字母有一个叫什么

448
00:15:27,000 --> 00:15:28,000
absolom 之类的

449
00:15:28,000 --> 00:15:30,000
就看起来非常奇怪的一个字母

450
00:15:30,000 --> 00:15:31,000
有点关联

451
00:15:31,000 --> 00:15:33,000
我觉得 G 可能是从那个字母来的

452
00:15:33,000 --> 00:15:34,000
但实际上完全不是

453
00:15:36,000 --> 00:15:38,000
作为什么

454
00:15:38,000 --> 00:15:39,000
tipus beautiful 成员

455
00:15:39,000 --> 00:15:40,000
你是不是要去蹲

456
00:15:40,000 --> 00:15:42,000
强调反思的

457
00:15:42,000 --> 00:15:43,000
三五天之类的

458
00:15:43,000 --> 00:15:45,000
这种事情也不是第一次发生的

459
00:15:45,000 --> 00:15:46,000
我上次在知乎上

460
00:15:46,000 --> 00:15:48,000
展丁解写了说

461
00:15:48,000 --> 00:15:49,000
瑞士高速公路的字牌

462
00:15:49,000 --> 00:15:54,000
瑞士高速公路的自排的

463
00:15:54,000 --> 00:15:57,000
标号牌的字体就是 frutig

464
00:15:57,000 --> 00:15:59,000
然后有人跳出来说

465
00:15:59,000 --> 00:16:01,000
柜网站上面说过

466
00:16:01,000 --> 00:16:03,000
他是 frutig 的一种感性

467
00:16:03,000 --> 00:16:05,000
简直就是自打脸

468
00:16:05,000 --> 00:16:06,000
没错

469
00:16:06,000 --> 00:16:07,000
还好那篇文章

470
00:16:07,000 --> 00:16:09,000
那篇文章不是我意的吧

471
00:16:09,000 --> 00:16:10,000
应该不是我意的吧

472
00:16:10,000 --> 00:16:11,000
如果是我意的话

473
00:16:11,000 --> 00:16:12,000
我就可以去死了

474
00:16:13,000 --> 00:16:14,000
好吧 我们原谅你了

475
00:16:14,000 --> 00:16:15,000
谢谢原谅

476
00:16:16,000 --> 00:16:18,000
我听众原谅你

477
00:16:18,000 --> 00:16:19,000
我不知道

478
00:16:19,000 --> 00:16:20,000
原谅不

479
00:16:22,000 --> 00:16:23,000
sorry

480
00:16:24,000 --> 00:16:25,000
对

481
00:16:25,000 --> 00:16:28,000
然后就是 input 字体

482
00:16:28,000 --> 00:16:29,000
我上一次去看他的时候

483
00:16:29,000 --> 00:16:31,000
发现他有了一个

484
00:16:33,000 --> 00:16:34,000
划扩号的替换版本

485
00:16:34,000 --> 00:16:36,000
就是有一个普通的划扩号

486
00:16:36,000 --> 00:16:37,000
出现了

487
00:16:37,000 --> 00:16:39,000
如果你对划扩号也不爽的话

488
00:16:39,000 --> 00:16:42,000
可以去拥有普通划扩号的版本

489
00:16:42,000 --> 00:16:43,000
所谓普通

490
00:16:43,000 --> 00:16:46,000
就是没有那么扭曲的一个划扩号

491
00:16:46,000 --> 00:16:47,000
就是 input

492
00:16:47,000 --> 00:16:49,000
它会有很多这种

493
00:16:49,000 --> 00:16:51,000
它有一个定制化的界面

494
00:16:51,000 --> 00:16:53,000
你可以选择那些

495
00:16:53,000 --> 00:16:56,000
你喜欢的变种的组合

496
00:16:56,000 --> 00:16:58,000
这样就是反正我总有一个适合你的

497
00:16:58,000 --> 00:17:00,000
然后碰巧你就是喜欢那个

498
00:17:00,000 --> 00:17:03,000
直上直下的大扩号的东西

499
00:17:03,000 --> 00:17:04,000
没错

500
00:17:04,000 --> 00:17:06,000
其实之前那个划扩号我觉得挺好的

501
00:17:08,000 --> 00:17:10,000
还是要强调这一点

502
00:17:10,000 --> 00:17:14,000
下一条反馈是我说错了一个东西

503
00:17:14,000 --> 00:17:16,000
就是我们上次讲到有

504
00:17:16,000 --> 00:17:18,000
以 Counselors, Calibur

505
00:17:18,000 --> 00:17:20,000
还有 Cambria

506
00:17:20,000 --> 00:17:23,000
都会带来的 C 系字体

507
00:17:23,000 --> 00:17:25,000
但是我说它好像是

508
00:17:25,000 --> 00:17:27,000
Soy Office 发布的

509
00:17:27,000 --> 00:17:30,000
但其实它是 Soy Vista 发布的

510
00:17:30,000 --> 00:17:33,000
然后之所以我讲错

511
00:17:33,000 --> 00:17:35,000
这个是因为我用这套字体

512
00:17:35,000 --> 00:17:37,000
就完全是因为在

513
00:17:37,000 --> 00:17:40,000
装了 Mac Office 之后

514
00:17:40,000 --> 00:17:42,000
在我的 Mac 上面才找到的

515
00:17:42,000 --> 00:17:44,000
因为 Vista 我真的是没有用过

516
00:17:44,000 --> 00:17:46,000
遮遮掩掩就直接说我是国粉

517
00:17:46,000 --> 00:17:48,000
不知道是很正常的

518
00:17:48,000 --> 00:17:50,000
这个 Vista 真的很糟糕

519
00:17:50,000 --> 00:17:53,000
他确实出来的时候

520
00:17:53,000 --> 00:17:55,000
不是我的,这个是公认的

521
00:17:55,000 --> 00:17:57,000
所以这个错了

522
00:17:57,000 --> 00:17:58,000
我觉得是情有可原的

523
00:17:58,000 --> 00:17:59,000
你们一定要原谅我

524
00:17:59,000 --> 00:18:01,000
对不起梁海先生

525
00:18:01,000 --> 00:18:03,000
也是梁海救错的

526
00:18:07,000 --> 00:18:09,000
然后其实有一位

527
00:18:09,000 --> 00:18:12,000
亲共在

528
00:18:12,000 --> 00:18:15,000
他是叫孙玉东

529
00:18:15,000 --> 00:18:17,000
对他来邮件说的

530
00:18:17,000 --> 00:18:19,000
上次我们提到

531
00:18:19,000 --> 00:18:21,000
就是微软给学生

532
00:18:21,000 --> 00:18:23,000
有一个特殊的计划叫做 Dream Spark

533
00:18:23,000 --> 00:18:25,000
对,然后 Dream Spark

534
00:18:25,000 --> 00:18:27,000
就可以干嘛呢

535
00:18:27,000 --> 00:18:29,000
比如说你学校参加的这个项目之后

536
00:18:29,000 --> 00:18:31,000
你可以从你学校拿到一个账号

537
00:18:31,000 --> 00:18:32,000
然后你用这个账号可以在

538
00:18:32,000 --> 00:18:33,000
微软的官方网站里面

539
00:18:33,000 --> 00:18:35,000
费的下载到

540
00:18:35,000 --> 00:18:37,000
大部分的微软的产品

541
00:18:37,000 --> 00:18:39,000
然后里面他提供那个叫做

542
00:18:39,000 --> 00:18:41,000
Visual Studio

543
00:18:41,000 --> 00:18:43,000
他是提供的是 Pro 版本

544
00:18:43,000 --> 00:18:46,000
不过

545
00:18:46,000 --> 00:18:48,000
之前我们讲的那个叫什么

546
00:18:48,000 --> 00:18:50,000
那个叫 Community Editions

547
00:18:50,000 --> 00:18:52,000
对,Community C 1

548
00:18:52,000 --> 00:18:54,000
C 1 是一直是免费的

549
00:18:54,000 --> 00:18:56,000
对公众都是免费的

550
00:18:56,000 --> 00:18:58,000
对,而且应该将会一直免费下去

551
00:18:58,000 --> 00:19:01,000
就像之前很多的

552
00:19:01,000 --> 00:19:04,000
比如说 JetBrains 的

553
00:19:04,000 --> 00:19:07,000
IntelligeA 也是有 Community Edition

554
00:19:07,000 --> 00:19:09,000
也是永远免费的

555
00:19:09,000 --> 00:19:11,000
不过说到这个

556
00:19:11,000 --> 00:19:12,000
我想请你一个事

557
00:19:12,000 --> 00:19:14,000
好像有一个商业上的

558
00:19:14,000 --> 00:19:15,000
专门的说法

559
00:19:15,000 --> 00:19:17,000
这种就是把一个产品分那么多

560
00:19:17,000 --> 00:19:19,000
种类版本

561
00:19:19,000 --> 00:19:21,000
一个什么叫做 Product Matrix

562
00:19:21,000 --> 00:19:23,000
对,我也不太清楚

563
00:19:23,000 --> 00:19:24,000
反正就是

564
00:19:24,000 --> 00:19:25,000
就我非常喜欢搞这种事情

565
00:19:25,000 --> 00:19:26,000
大家不知道现在还有

566
00:19:26,000 --> 00:19:27,000
其实现在可能还好点

567
00:19:27,000 --> 00:19:28,000
就像 Vis.com 出来说

568
00:19:28,000 --> 00:19:30,000
大家不知道还有没有印象

569
00:19:30,000 --> 00:19:32,000
好像是有十几个版本

570
00:19:32,000 --> 00:19:33,000
我记得

571
00:19:33,000 --> 00:19:34,000
不只微软

572
00:19:34,000 --> 00:19:36,000
我觉得很多通费产品都有这个特点

573
00:19:36,000 --> 00:19:38,000
Eclipse 不也是吗

574
00:19:38,000 --> 00:19:40,000
Eclipse 的那个下来

575
00:19:40,000 --> 00:19:42,000
就是有一个货架

576
00:19:42,000 --> 00:19:44,000
一大堆版本

577
00:19:44,000 --> 00:19:45,000
什么 Javae 版本

578
00:19:45,000 --> 00:19:46,000
C++版本

579
00:19:46,000 --> 00:19:47,000
对,对

580
00:19:47,000 --> 00:19:48,000
这个版本

581
00:19:48,000 --> 00:19:49,000
这个版本

582
00:19:49,000 --> 00:19:50,000
就不明白了

583
00:19:50,000 --> 00:19:51,000
难道不能提供一个

584
00:19:51,000 --> 00:19:53,000
就是基础版本

585
00:19:53,000 --> 00:19:54,000
然后 What have I

586
00:19:54,000 --> 00:19:55,000
让用户自己去装

587
00:19:55,000 --> 00:19:56,000
该一个装个插线

588
00:19:56,000 --> 00:19:57,000
或者怎么样

589
00:19:57,000 --> 00:19:58,000
对

590
00:19:58,000 --> 00:19:59,000
就我

591
00:19:59,000 --> 00:20:02,000
能想到的有这个所谓 Product Matrix

592
00:20:02,000 --> 00:20:03,000
这种结构

593
00:20:03,000 --> 00:20:04,000
就是把一个产品

594
00:20:04,000 --> 00:20:05,000
就同一个产品

595
00:20:05,000 --> 00:20:06,000
然后根据什么

596
00:20:06,000 --> 00:20:08,000
不同的场景

597
00:20:08,000 --> 00:20:09,000
或者不同功能

598
00:20:09,000 --> 00:20:10,000
这种产品给我的感觉

599
00:20:10,000 --> 00:20:11,000
整个或者这种公司

600
00:20:11,000 --> 00:20:12,000
给我的感觉很差的

601
00:20:12,000 --> 00:20:13,000
因为其实从本质上

602
00:20:13,000 --> 00:20:14,000
你都知道

603
00:20:14,000 --> 00:20:15,000
它就是在

604
00:20:15,000 --> 00:20:16,000
所谓的追

605
00:20:16,000 --> 00:20:17,000
等一下

606
00:20:17,000 --> 00:20:19,000
那个东西叫什么来的

607
00:20:19,000 --> 00:20:21,000
那个叫做

608
00:20:21,000 --> 00:20:22,000
立正绝大花

609
00:20:22,000 --> 00:20:24,000
好像也不太比

610
00:20:24,000 --> 00:20:26,000
就等于是你不愿意

611
00:20:26,000 --> 00:20:28,000
就是我所有这些功能

612
00:20:28,000 --> 00:20:29,000
加在一起

613
00:20:29,000 --> 00:20:31,000
开着这个架你出不起

614
00:20:31,000 --> 00:20:32,000
那我就砍掉一些

615
00:20:32,000 --> 00:20:33,000
然后

616
00:20:33,000 --> 00:20:34,000
对

617
00:20:34,000 --> 00:20:35,000
把那个

618
00:20:35,000 --> 00:20:37,000
你能买的那个价格

619
00:20:37,000 --> 00:20:38,000
介绍给你

620
00:20:38,000 --> 00:20:40,000
但这就像卖车

621
00:20:40,000 --> 00:20:41,000
我就是

622
00:20:41,000 --> 00:20:42,000
就是我很小的时候

623
00:20:42,000 --> 00:20:44,000
总是会有很奇怪说

624
00:20:44,000 --> 00:20:45,000
这为什么

625
00:20:45,000 --> 00:20:47,000
车的广告上面

626
00:20:47,000 --> 00:20:49,000
都不写定价呢

627
00:20:49,000 --> 00:20:51,000
它会写

628
00:20:51,000 --> 00:20:53,000
它会写一个多少多少起吗

629
00:20:53,000 --> 00:20:54,000
对

630
00:20:54,000 --> 00:20:56,000
但那个起是完全全是

631
00:20:56,000 --> 00:20:57,000
的裸车价

632
00:20:57,000 --> 00:20:58,000
真正的

633
00:20:58,000 --> 00:20:59,000
你要去

634
00:20:59,000 --> 00:21:01,000
配那个 configurator

635
00:21:01,000 --> 00:21:02,000
然后才知道

636
00:21:02,000 --> 00:21:03,000
每一个

637
00:21:03,000 --> 00:21:04,000
每加一个 option

638
00:21:04,000 --> 00:21:05,000
要加多少钱

639
00:21:05,000 --> 00:21:06,000
而那个 configurator

640
00:21:06,000 --> 00:21:08,000
你可以花

641
00:21:08,000 --> 00:21:09,000
两天的时间

642
00:21:09,000 --> 00:21:10,000
跟那个

643
00:21:10,000 --> 00:21:11,000
销售代理在那边

644
00:21:11,000 --> 00:21:12,000
讨论这个事情

645
00:21:12,000 --> 00:21:13,000
如果你真的想要

646
00:21:13,000 --> 00:21:14,000
定制一辆

647
00:21:14,000 --> 00:21:15,000
属于自己的车的话

648
00:21:15,000 --> 00:21:16,000
当然这在这种情况

649
00:21:16,000 --> 00:21:17,000
在中国

650
00:21:17,000 --> 00:21:18,000
可能不是很普遍

651
00:21:18,000 --> 00:21:19,000
但在欧洲

652
00:21:19,000 --> 00:21:20,000
很多人会愿意

653
00:21:20,000 --> 00:21:22,000
花两天时间

654
00:21:22,000 --> 00:21:24,000
至少这一下午吧

655
00:21:24,000 --> 00:21:26,000
跟那个销售代表去

656
00:21:26,000 --> 00:21:27,000
讨论这辆车

657
00:21:27,000 --> 00:21:28,000
它要哪些 option

658
00:21:28,000 --> 00:21:29,000
然后

659
00:21:29,000 --> 00:21:30,000
然后定

660
00:21:30,000 --> 00:21:31,000
然后两个月之后

661
00:21:31,000 --> 00:21:32,000
这辆车

662
00:21:32,000 --> 00:21:33,000
才可以送到他手里

663
00:21:33,000 --> 00:21:35,000
但是每一个 option

664
00:21:35,000 --> 00:21:37,000
都是他亲自 check 过的

665
00:21:37,000 --> 00:21:38,000
这才是

666
00:21:38,000 --> 00:21:39,000
就是 metrics

667
00:21:39,000 --> 00:21:42,000
product matrix at it's worth

668
00:21:42,000 --> 00:21:43,000
对

669
00:21:43,000 --> 00:21:44,000
就反正给人感觉

670
00:21:44,000 --> 00:21:45,000
就非常不好

671
00:21:45,000 --> 00:21:47,000
而且就整个是

672
00:21:47,000 --> 00:21:49,000
没有就平板无辜的增加了

673
00:21:49,000 --> 00:21:50,000
这个选择的这个难度

674
00:21:50,000 --> 00:21:51,000
本来就选

675
00:21:51,000 --> 00:21:52,000
选择困难

676
00:21:52,000 --> 00:21:53,000
这已经够严重了

677
00:21:53,000 --> 00:21:54,000
对吧

678
00:21:54,000 --> 00:21:55,000
他还给你搞的那么麻烦

679
00:21:55,000 --> 00:21:57,000
让你真是想撞长死

680
00:21:57,000 --> 00:21:58,000
不过现在

681
00:21:58,000 --> 00:21:59,000
什么 windows 8

682
00:21:59,000 --> 00:22:00,000
还有之后

683
00:22:00,000 --> 00:22:01,000
可能对

684
00:22:01,000 --> 00:22:02,000
他跳过久了

685
00:22:02,000 --> 00:22:03,000
直接的 windows 10

686
00:22:03,000 --> 00:22:04,000
就 8 已经好很多

687
00:22:04,000 --> 00:22:05,000
8 只分了一个

688
00:22:05,000 --> 00:22:07,000
就是 8 和 8 Pro

689
00:22:07,000 --> 00:22:08,000
专业版

690
00:22:08,000 --> 00:22:09,000
对

691
00:22:09,000 --> 00:22:10,000
好像以前

692
00:22:10,000 --> 00:22:11,000
我想想有什么

693
00:22:11,000 --> 00:22:13,000
HOME BASIC

694
00:22:13,000 --> 00:22:15,000
HOME PREMIUM

695
00:22:15,000 --> 00:22:17,000
Professional

696
00:22:17,000 --> 00:22:19,000
有个什么 Ultimate

697
00:22:19,000 --> 00:22:21,000
还有 Enterprise

698
00:22:21,000 --> 00:22:22,000
对

699
00:22:22,000 --> 00:22:25,000
还有一个 HOME PREMIUM 之类的一个词

700
00:22:25,000 --> 00:22:26,000
一个版本

701
00:22:26,000 --> 00:22:28,000
还有什么 Start-up Edition

702
00:22:28,000 --> 00:22:29,000
还有

703
00:22:29,000 --> 00:22:31,000
然后所有的都要乘以 2

704
00:22:31,000 --> 00:22:33,000
因为他分 32 位

705
00:22:33,000 --> 00:22:34,000
还有 64 位不同的东西

706
00:22:34,000 --> 00:22:35,000
不只乘以 2

707
00:22:35,000 --> 00:22:37,000
还要乘以所有的语言

708
00:22:37,000 --> 00:22:38,000
对

709
00:22:38,000 --> 00:22:40,000
我觉得这是非常二的一件事情

710
00:22:40,000 --> 00:22:42,000
就是你不只问

711
00:22:42,000 --> 00:22:43,000
WINDOWS 如此

712
00:22:43,000 --> 00:22:44,000
什么 Blackberry

713
00:22:44,000 --> 00:22:45,000
或者是 Android 的

714
00:22:45,000 --> 00:22:46,000
我不知道

715
00:22:46,000 --> 00:22:48,000
但很多操作性能都一定

716
00:22:48,000 --> 00:22:49,000
他问完那个分语言

717
00:22:49,000 --> 00:22:51,000
是因为他是跟去定价有关系

718
00:22:51,000 --> 00:22:52,000
其实跟这个方法那边取得

719
00:22:52,000 --> 00:22:53,000
本质上也是一个意思

720
00:22:53,000 --> 00:22:54,000
就是

721
00:22:54,000 --> 00:22:55,000
你

722
00:22:55,000 --> 00:22:56,000
看一下

723
00:22:56,000 --> 00:22:58,000
中国这边比较穷

724
00:22:58,000 --> 00:23:01,000
我们把价格定低一点

725
00:23:01,000 --> 00:23:02,000
德国那些人比较有钱

726
00:23:02,000 --> 00:23:04,000
我们把价格定高一点

727
00:23:04,000 --> 00:23:05,000
但是

728
00:23:05,000 --> 00:23:06,000
但是如果

729
00:23:06,000 --> 00:23:07,000
产品是一样的

730
00:23:07,000 --> 00:23:08,000
如果我可以随时

731
00:23:08,000 --> 00:23:10,000
像这个什么 iPhone 一样切换语言

732
00:23:10,000 --> 00:23:11,000
那我还搞屁啊

733
00:23:11,000 --> 00:23:12,000
那我当然直接买中国版

734
00:23:12,000 --> 00:23:14,000
去德国用不就好了对吧

735
00:23:14,000 --> 00:23:15,000
所以他就搞成所有的语言

736
00:23:15,000 --> 00:23:18,000
是不可以随意替换的

737
00:23:18,000 --> 00:23:19,000
但也可以有

738
00:23:19,000 --> 00:23:21,000
有这种工具叫个什么 MU

739
00:23:21,000 --> 00:23:22,000
叫什么

740
00:23:22,000 --> 00:23:24,000
现在已经可以下载语言包了

741
00:23:24,000 --> 00:23:25,000
我记得

742
00:23:25,000 --> 00:23:27,000
语言包从 WISDAW 时代

743
00:23:27,000 --> 00:23:29,000
还是 WIN 7 时代就已经有

744
00:23:29,000 --> 00:23:30,000
XB 都已经有语言包

745
00:23:30,000 --> 00:23:31,000
但是那个语言包

746
00:23:31,000 --> 00:23:32,000
首先是一个

747
00:23:32,000 --> 00:23:34,000
要额外付费买的

748
00:23:34,000 --> 00:23:38,000
就要补齐定价的差异

749
00:23:38,000 --> 00:23:40,000
立马拿出是这样子

750
00:23:40,000 --> 00:23:43,000
然后你还得麻烦去安装

751
00:23:43,000 --> 00:23:44,000
然后就是你装完这个语言包之后

752
00:23:44,000 --> 00:23:45,000
它其实也不

753
00:23:45,000 --> 00:23:46,000
并不等于一个

754
00:23:46,000 --> 00:23:47,000
原生的语言的系统

755
00:23:47,000 --> 00:23:48,000
我自己装过

756
00:23:48,000 --> 00:23:50,000
所以这个是深有体会的

757
00:23:50,000 --> 00:23:54,000
所以你看见这种

758
00:23:54,000 --> 00:23:56,000
语言是不可切换的

759
00:23:56,000 --> 00:23:59,000
然后有各种 Edition 的

760
00:23:59,000 --> 00:24:00,000
你就知道

761
00:24:00,000 --> 00:24:02,000
something is wrong

762
00:24:02,000 --> 00:24:03,000
anyway

763
00:24:03,000 --> 00:24:04,000
吐槽一下

764
00:24:04,000 --> 00:24:06,000
现在已经好多了

765
00:24:06,000 --> 00:24:07,000
刚才讲的

766
00:24:07,000 --> 00:24:09,000
我印象中只有 8

767
00:24:09,000 --> 00:24:12,000
和 8 的 pro 这两个区别

768
00:24:12,000 --> 00:24:14,000
但它有针对 surfaces

769
00:24:14,000 --> 00:24:15,000
还有一个版本在说

770
00:24:15,000 --> 00:24:16,000
然后语言

771
00:24:16,000 --> 00:24:17,000
我不知道现在怎么

772
00:24:17,000 --> 00:24:18,000
什么情况

773
00:24:18,000 --> 00:24:20,000
我至少从刚刚

774
00:24:20,000 --> 00:24:21,000
为了玩文明策

775
00:24:21,000 --> 00:24:26,000
我装了一个 8.1 还是得一版的

776
00:24:26,000 --> 00:24:27,000
我也没有去试

777
00:24:27,000 --> 00:24:28,000
反正就用了

778
00:24:28,000 --> 00:24:29,000
它在空置面板里面

779
00:24:29,000 --> 00:24:31,000
有一个可以选语言

780
00:24:31,000 --> 00:24:32,000
但是我记得是要语言

781
00:24:32,000 --> 00:24:33,000
安装包的

782
00:24:33,000 --> 00:24:34,000
但是安装包怎么来

783
00:24:34,000 --> 00:24:35,000
就是一个问题

784
00:24:35,000 --> 00:24:37,000
Winless 8

785
00:24:37,000 --> 00:24:39,000
我去装了 Winless 8 之后

786
00:24:39,000 --> 00:24:41,000
去重温一下空置面板

787
00:24:41,000 --> 00:24:42,000
我觉得我刚刚看过

788
00:24:42,000 --> 00:24:46,000
怎么会有这么多东西

789
00:24:46,000 --> 00:24:48,000
其实它也不算多了

790
00:24:48,000 --> 00:24:50,000
它只是呈现的不好

791
00:24:50,000 --> 00:24:51,000
你仔细看一下

792
00:24:51,000 --> 00:24:53,000
像 Mac 的叫什么 System Provinces

793
00:24:53,000 --> 00:24:55,000
里面它的选项也蛮多

794
00:24:55,000 --> 00:24:56,000
我记得 Winless 8

795
00:24:56,000 --> 00:24:59,000
从 Winless 8 时代开始

796
00:24:59,000 --> 00:25:02,000
它也试图把功能组合

797
00:25:02,000 --> 00:25:05,000
分成几个大组

798
00:25:05,000 --> 00:25:07,000
然后你可以一个一个点进去

799
00:25:07,000 --> 00:25:08,000
可是找出来它也麻烦了

800
00:25:08,000 --> 00:25:09,000
对

801
00:25:09,000 --> 00:25:11,000
而且它的图形化的程度

802
00:25:11,000 --> 00:25:12,000
不够吗在那里

803
00:25:12,000 --> 00:25:14,000
你还是要读很多字

804
00:25:14,000 --> 00:25:15,000
感觉就觉得有种

805
00:25:15,000 --> 00:25:18,000
很雍重庞大的感觉

806
00:25:18,000 --> 00:25:19,000
对

807
00:25:19,000 --> 00:25:20,000
其实简单来说就一条

808
00:25:20,000 --> 00:25:22,000
图标做的不够漂亮

809
00:25:24,000 --> 00:25:25,000
好了不吐槽这个了

810
00:25:26,000 --> 00:25:28,000
再插播一条小信

811
00:25:28,000 --> 00:25:30,000
做了一个什么

812
00:25:30,000 --> 00:25:31,000
购语员的粉丝

813
00:25:31,000 --> 00:25:33,000
今天购语员发布了

814
00:25:33,000 --> 00:25:35,000
1.4 的版本

815
00:25:35,000 --> 00:25:37,000
然后为什么突然要讲

816
00:25:37,000 --> 00:25:38,000
这件事情呢是因为

817
00:25:38,000 --> 00:25:39,000
在这个版本里面

818
00:25:39,000 --> 00:25:42,000
它正式加入了安卓的支持

819
00:25:42,000 --> 00:25:44,000
所以你可以现在开始

820
00:25:44,000 --> 00:25:46,000
用这些购语员写游戏了

821
00:25:46,000 --> 00:25:47,000
就用 OpenGL 写游戏

822
00:25:47,000 --> 00:25:49,000
当然如果你现在还要写

823
00:25:49,000 --> 00:25:50,000
那种普通的那种 App

824
00:25:50,000 --> 00:25:52,000
需要有这个标准化的界面

825
00:25:52,000 --> 00:25:53,000
可能还要用一下

826
00:25:53,000 --> 00:25:56,000
Gava 的这个东西去去做一下

827
00:25:56,000 --> 00:25:57,000
但如果你只是写游戏的话

828
00:25:57,000 --> 00:25:58,000
完全可以是只要

829
00:25:58,000 --> 00:25:59,000
各位原来的标

830
00:25:59,000 --> 00:26:00,000
大家如果有兴趣

831
00:26:00,000 --> 00:26:02,000
可以去尝试一下

832
00:26:02,000 --> 00:26:04,000
对我记得这个是

833
00:26:04,000 --> 00:26:06,000
今年 4 月份

834
00:26:06,000 --> 00:26:07,000
还是什么时候就已经

835
00:26:07,000 --> 00:26:10,000
还是 6 月份就已经出来的

836
00:26:10,000 --> 00:26:13,000
放出来的风儿吧

837
00:26:13,000 --> 00:26:15,000
对他们在 1.3 的时候

838
00:26:15,000 --> 00:26:17,000
就半年前他已经在

839
00:26:17,000 --> 00:26:19,000
在讲这个会有这个事情

840
00:26:19,000 --> 00:26:20,000
其实 1.3 Beta 的时候

841
00:26:20,000 --> 00:26:21,000
就已经有这个功能

842
00:26:21,000 --> 00:26:24,000
只是没有正式发布而已

843
00:26:24,000 --> 00:26:26,000
我觉得实际上的

844
00:26:26,000 --> 00:26:28,000
其实可能还要更早

845
00:26:28,000 --> 00:26:31,000
因为我记得在

846
00:26:31,000 --> 00:26:32,000
我不确定

847
00:26:32,000 --> 00:26:34,000
好像是在有一次

848
00:26:34,000 --> 00:26:38,000
Google Developer 大会上面

849
00:26:38,000 --> 00:26:40,000
我听到有人在问

850
00:26:40,000 --> 00:26:42,000
说开发安卓

851
00:26:42,000 --> 00:26:43,000
可以用别的语言吗

852
00:26:43,000 --> 00:26:45,000
当时得到的答复

853
00:26:45,000 --> 00:26:47,000
是目前没有计划

854
00:26:47,000 --> 00:26:48,000
但

855
00:26:48,000 --> 00:26:50,000
他不是可以用那个 NDK

856
00:26:50,000 --> 00:26:52,000
然后撕一会谢谢家协吗

857
00:26:52,000 --> 00:26:55,000
那个时候还没有吧

858
00:26:55,000 --> 00:26:56,000
我过去太久了

859
00:26:56,000 --> 00:26:58,000
2012 年可能是

860
00:26:58,000 --> 00:27:00,000
那是今年的

861
00:27:00,000 --> 00:27:02,000
Google I'll 的时候说的

862
00:27:02,000 --> 00:27:03,000
ok

863
00:27:03,000 --> 00:27:04,000
对

864
00:27:04,000 --> 00:27:06,000
所以就是如果你是一个

865
00:27:06,000 --> 00:27:08,000
痛恨和我们一样

866
00:27:08,000 --> 00:27:09,000
痛恨插报的之前

867
00:27:09,000 --> 00:27:11,000
然后又想写安卓的游戏

868
00:27:11,000 --> 00:27:12,000
现在你可以有一个

869
00:27:12,000 --> 00:27:14,000
官方支持的正式的

870
00:27:14,000 --> 00:27:16,000
替代选择了

871
00:27:16,000 --> 00:27:17,000
但

872
00:27:17,000 --> 00:27:18,000
现在肯定是属于

873
00:27:18,000 --> 00:27:20,000
刚发布的一个

874
00:27:20,000 --> 00:27:21,000
不太稳定的阶段

875
00:27:21,000 --> 00:27:25,000
前方坑多自己小心

876
00:27:25,000 --> 00:27:27,000
另外一个比较值得

877
00:27:27,000 --> 00:27:30,000
我挺高兴的事情

878
00:27:30,000 --> 00:27:32,000
是他们决定在下一个版本

879
00:27:32,000 --> 00:27:33,000
就是购 1.5 的时候

880
00:27:33,000 --> 00:27:35,000
也就是大概半年之后发布的时候

881
00:27:35,000 --> 00:27:37,000
他们会加入正式的

882
00:27:37,000 --> 00:27:39,000
iOS 的支持

883
00:27:39,000 --> 00:27:40,000
可是这个是什么

884
00:27:40,000 --> 00:27:43,000
它的具体的意思是什么呢

885
00:27:43,000 --> 00:27:45,000
我可以通过用写用购来

886
00:27:45,000 --> 00:27:49,000
编出一个 iOS 的原生程序吗

887
00:27:49,000 --> 00:27:52,000
它应该可以用

888
00:27:52,000 --> 00:27:54,000
可以编一程一个

889
00:27:54,000 --> 00:27:56,000
C 的原生代码

890
00:27:56,000 --> 00:27:57,000
就基于

891
00:27:57,000 --> 00:27:59,000
就是那个叫什么 ARM 平台的

892
00:27:59,000 --> 00:28:01,000
C 的代码可以直接在那边跑

893
00:28:01,000 --> 00:28:02,000
但至于说

894
00:28:02,000 --> 00:28:04,000
你怎么去封装成一个 App

895
00:28:04,000 --> 00:28:05,000
可能后面还有一些

896
00:28:05,000 --> 00:28:06,000
要用到 Xcode 的东西

897
00:28:06,000 --> 00:28:07,000
对

898
00:28:07,000 --> 00:28:08,000
它怎么才能去调用

899
00:28:08,000 --> 00:28:10,000
Coco 的这对 API

900
00:28:10,000 --> 00:28:12,000
Coco Touch 的这对 API

901
00:28:12,000 --> 00:28:15,000
它会它怎么才能

902
00:28:15,000 --> 00:28:18,000
就是切开苹果这一层

903
00:28:18,000 --> 00:28:20,000
厚厚的壁垒去调用

904
00:28:20,000 --> 00:28:21,000
对这可能

905
00:28:21,000 --> 00:28:22,000
可能会跟这个 Android

906
00:28:22,000 --> 00:28:23,000
情况比较类似

907
00:28:23,000 --> 00:28:24,000
就是可能说是

908
00:28:24,000 --> 00:28:25,000
比如说你可以写游戏

909
00:28:25,000 --> 00:28:26,000
只有 OpenGL 写

910
00:28:26,000 --> 00:28:27,000
你写游戏的话

911
00:28:27,000 --> 00:28:30,000
可以不用那些 Coco 的东西吗

912
00:28:30,000 --> 00:28:31,000
就只有 Metal

913
00:28:31,000 --> 00:28:32,000
Metal

914
00:28:32,000 --> 00:28:33,000
我都不知道它能不能

915
00:28:33,000 --> 00:28:34,000
具体怎么样

916
00:28:34,000 --> 00:28:35,000
它是肯定如果它支持

917
00:28:35,000 --> 00:28:37,000
肯定是先支持 OpenGL

918
00:28:37,000 --> 00:28:38,000
跟 Android 一样

919
00:28:38,000 --> 00:28:39,000
我觉得

920
00:28:39,000 --> 00:28:40,000
就那种你不需要

921
00:28:40,000 --> 00:28:41,000
调用很多系统级别的东西

922
00:28:41,000 --> 00:28:42,000
就存在做一个

923
00:28:42,000 --> 00:28:44,000
自己在那跑的一个应用

924
00:28:44,000 --> 00:28:45,000
但主要就是游戏了

925
00:28:45,000 --> 00:28:46,000
那可能

926
00:28:46,000 --> 00:28:47,000
让它给你放在一个

927
00:28:47,000 --> 00:28:48,000
Container 里面

928
00:28:48,000 --> 00:28:49,000
然后 Container

929
00:28:49,000 --> 00:28:50,000
肯定你好了

930
00:28:50,000 --> 00:28:51,000
有可能就是 Codo

931
00:28:51,000 --> 00:28:53,000
就是走这个路线

932
00:28:53,000 --> 00:28:54,000
对

933
00:28:54,000 --> 00:28:55,000
但如果你要说

934
00:28:55,000 --> 00:28:56,000
你要做一个带什么

935
00:28:56,000 --> 00:28:57,000
就写一个 App

936
00:28:57,000 --> 00:28:58,000
普通的一个 App

937
00:28:58,000 --> 00:28:59,000
然后需要用那 Coco 的

938
00:28:59,000 --> 00:29:00,000
那些东西

939
00:29:00,000 --> 00:29:01,000
不是 Coco

940
00:29:01,000 --> 00:29:02,000
那个叫什么

941
00:29:02,000 --> 00:29:03,000
Swift

942
00:29:03,000 --> 00:29:04,000
Objective C

943
00:29:04,000 --> 00:29:05,000
就是那个 Round Time

944
00:29:05,000 --> 00:29:06,000
不是那个 Round Time

945
00:29:06,000 --> 00:29:07,000
就那些库掉什么

946
00:29:07,000 --> 00:29:08,000
不叫库

947
00:29:08,000 --> 00:29:09,000
UI Kit

948
00:29:09,000 --> 00:29:10,000
UI Kit

949
00:29:10,000 --> 00:29:11,000
然后

950
00:29:11,000 --> 00:29:12,000
你可能还是要写

951
00:29:12,000 --> 00:29:13,000
用那个 Objective C

952
00:29:13,000 --> 00:29:14,000
或者用 Swift 写

953
00:29:14,000 --> 00:29:15,000
然后再 XCode 里面编译

954
00:29:15,000 --> 00:29:16,000
对 大概情况是这样子

955
00:29:16,000 --> 00:29:17,000
OK

956
00:29:17,000 --> 00:29:18,000
然后就会说

957
00:29:18,000 --> 00:29:20,000
这个形容就比较有意思

958
00:29:20,000 --> 00:29:21,000
就说

959
00:29:21,000 --> 00:29:22,000
这个事情我们不知道

960
00:29:22,000 --> 00:29:23,000
将来会怎么样

961
00:29:23,000 --> 00:29:24,000
但是起码

962
00:29:24,000 --> 00:29:25,000
如果它在半年后

963
00:29:25,000 --> 00:29:26,000
真的做了这个

964
00:29:26,000 --> 00:29:27,000
这现在已经是

965
00:29:27,000 --> 00:29:28,000
他们内部已经

966
00:29:28,000 --> 00:29:29,000
放出话来

967
00:29:29,000 --> 00:29:30,000
要做这个事情

968
00:29:30,000 --> 00:29:31,000
但是就等下半会发布

969
00:29:31,000 --> 00:29:32,000
嗯

970
00:29:32,000 --> 00:29:34,000
就说 Google 会有这么一个语言

971
00:29:34,000 --> 00:29:36,000
能够同时间跨平台

972
00:29:36,000 --> 00:29:37,000
就是

973
00:29:37,000 --> 00:29:38,000
Google 的话

974
00:29:38,000 --> 00:29:39,000
它可以编译

975
00:29:39,000 --> 00:29:41,000
里面和 Android

976
00:29:41,000 --> 00:29:42,000
包括以后的 LS

977
00:29:42,000 --> 00:29:44,000
可以用一套原写

978
00:29:44,000 --> 00:29:45,000
一套逻辑

979
00:29:45,000 --> 00:29:46,000
而且服务器

980
00:29:46,000 --> 00:29:47,000
也可以用它写

981
00:29:47,000 --> 00:29:48,000
我觉得这是最妙的一点

982
00:29:48,000 --> 00:29:49,000
对

983
00:29:49,000 --> 00:29:50,000
对

984
00:29:50,000 --> 00:29:52,000
这个其实之前在 Google

985
00:29:52,000 --> 00:29:53,000
Google Inbox

986
00:29:53,000 --> 00:29:54,000
你知道吗

987
00:29:54,000 --> 00:29:55,000
就是它之前写的邮件

988
00:29:55,000 --> 00:29:56,000
的科物端

989
00:29:56,000 --> 00:29:57,000
他们其实在一定程度

990
00:29:57,000 --> 00:29:58,000
已经做这件事情

991
00:29:58,000 --> 00:29:59,000
但不过它是进入 java

992
00:29:59,000 --> 00:30:00,000
就是所有的

993
00:30:00,000 --> 00:30:01,000
业务逻辑

994
00:30:01,000 --> 00:30:03,000
是用 java 来写

995
00:30:03,000 --> 00:30:04,000
然后通过两个技术

996
00:30:04,000 --> 00:30:06,000
然后一个叫做 GWT

997
00:30:06,000 --> 00:30:08,000
把 java 编一成网页版

998
00:30:08,000 --> 00:30:11,000
然后在 Chrome 里面跑

999
00:30:11,000 --> 00:30:13,000
然后另外一个是

1000
00:30:13,000 --> 00:30:14,000
真的

1001
00:30:14,000 --> 00:30:16,000
GWT

1002
00:30:16,000 --> 00:30:17,000
Google 还在用吗

1003
00:30:17,000 --> 00:30:18,000
我不去

1004
00:30:18,000 --> 00:30:20,000
他们很多这个

1005
00:30:20,000 --> 00:30:21,000
Gmail

1006
00:30:21,000 --> 00:30:22,000
好像 Gmail 的后台

1007
00:30:22,000 --> 00:30:24,000
也是这么弄出来的

1008
00:30:24,000 --> 00:30:26,000
我以为

1009
00:30:26,000 --> 00:30:28,000
这个不奇怪

1010
00:30:28,000 --> 00:30:29,000
Google 这么大一个 java 手

1011
00:30:29,000 --> 00:30:31,000
有什么好奇怪

1012
00:30:31,000 --> 00:30:32,000
不

1013
00:30:32,000 --> 00:30:34,000
可是 GWT 不是已经

1014
00:30:34,000 --> 00:30:35,000
早就变成一个

1015
00:30:35,000 --> 00:30:37,000
community 维护的 framework 了吗

1016
00:30:37,000 --> 00:30:39,000
Google 不是自己在主推

1017
00:30:39,000 --> 00:30:41,000
AngloJS 之类的东西吗

1018
00:30:41,000 --> 00:30:42,000
不

1019
00:30:42,000 --> 00:30:43,000
那个是

1020
00:30:43,000 --> 00:30:44,000
就

1021
00:30:44,000 --> 00:30:46,000
我理解好 AngloJS 那些是

1022
00:30:46,000 --> 00:30:48,000
他们纯粹做网页的前端的时候

1023
00:30:48,000 --> 00:30:50,000
用那个没有问题

1024
00:30:50,000 --> 00:30:51,000
但如果你再要涉及到

1025
00:30:51,000 --> 00:30:52,000
这种画平台的东西的话

1026
00:30:52,000 --> 00:30:53,000
他们的就是

1027
00:30:53,000 --> 00:30:54,000
所以的

1028
00:30:54,000 --> 00:30:56,000
canonical version

1029
00:30:56,000 --> 00:30:57,000
还是 java 版本的

1030
00:30:57,000 --> 00:30:58,000
比如说 Gmail 是这样子

1031
00:30:58,000 --> 00:31:00,000
然后那个像 inbox 也是这样子

1032
00:31:00,000 --> 00:31:01,000
然后呢

1033
00:31:01,000 --> 00:31:03,000
他们 inbox 不是也有 ls 版吗

1034
00:31:03,000 --> 00:31:04,000
然后 ls 版的

1035
00:31:04,000 --> 00:31:05,000
就是业务逻辑那一部分

1036
00:31:05,000 --> 00:31:07,000
他们是用一个叫做

1037
00:31:08,000 --> 00:31:10,000
j 2 objectc 还是什么样的

1038
00:31:10,000 --> 00:31:11,000
就是

1039
00:31:11,000 --> 00:31:13,000
把 java 编一成

1040
00:31:13,000 --> 00:31:15,000
objectc 代码的方法

1041
00:31:15,000 --> 00:31:17,000
什么样的

1042
00:31:17,000 --> 00:31:19,000
但是他们这个也有他的道理嘛

1043
00:31:19,000 --> 00:31:21,000
就是你要

1044
00:31:21,000 --> 00:31:23,000
维护同一个产品的业务逻辑

1045
00:31:23,000 --> 00:31:24,000
要保证跨平台

1046
00:31:24,000 --> 00:31:25,000
如果你每个平台单独写了

1047
00:31:25,000 --> 00:31:26,000
写套的话

1048
00:31:26,000 --> 00:31:28,000
那肯定就等于是像什么

1049
00:31:28,000 --> 00:31:29,000
bug 啊

1050
00:31:29,000 --> 00:31:31,000
还有那个说开发量就全部

1051
00:31:31,000 --> 00:31:32,000
每个

1052
00:31:32,000 --> 00:31:33,000
就有多少个平台

1053
00:31:33,000 --> 00:31:34,000
你叫成一多少个数嘛

1054
00:31:34,000 --> 00:31:35,000
他这样的话

1055
00:31:35,000 --> 00:31:37,000
就只用解决一个问题

1056
00:31:37,000 --> 00:31:38,000
就一套代码库

1057
00:31:38,000 --> 00:31:40,000
然后之后都可以

1058
00:31:40,000 --> 00:31:41,000
靠这个编辑

1059
00:31:41,000 --> 00:31:42,000
就是这种跨平台的编辑

1060
00:31:42,000 --> 00:31:43,000
来解决这个问题

1061
00:31:43,000 --> 00:31:44,000
在理想的情况下是没有

1062
00:31:45,000 --> 00:31:46,000
但是

1063
00:31:46,000 --> 00:31:47,000
但是他的那个 uid 那部分

1064
00:31:47,000 --> 00:31:48,000
比如说像 Android 的

1065
00:31:48,000 --> 00:31:50,000
UID 还是用这个

1066
00:31:50,000 --> 00:31:52,000
原生的那个那个 java 来写

1067
00:31:52,000 --> 00:31:54,000
然后在 ls 他使用 objectc 来

1068
00:31:54,000 --> 00:31:55,000
来封装的

1069
00:31:55,000 --> 00:31:56,000
然后

1070
00:31:56,000 --> 00:31:57,000
但是就只说

1071
00:31:57,000 --> 00:31:59,000
就说业务就是跟那种平台的关系

1072
00:31:59,000 --> 00:32:01,000
不是很紧密的业务逻辑那部分

1073
00:32:01,000 --> 00:32:02,000
他们是用一个 java

1074
00:32:02,000 --> 00:32:04,000
然后从这种便宜的方法来实现

1075
00:32:04,000 --> 00:32:06,000
那么同样的道理

1076
00:32:06,000 --> 00:32:08,000
就说如果以后

1077
00:32:08,000 --> 00:32:10,000
go 的话也可以差不多可以

1078
00:32:10,000 --> 00:32:12,000
也许可以做类似的事情

1079
00:32:12,000 --> 00:32:14,000
但是这个事情

1080
00:32:14,000 --> 00:32:17,000
也跟上一期我们讲的那个

1081
00:32:17,000 --> 00:32:19,000
微软的计划有点相关嘛

1082
00:32:19,000 --> 00:32:20,000
就他是要

1083
00:32:20,000 --> 00:32:21,000
要声称是用那个

1084
00:32:21,000 --> 00:32:22,000
donate

1085
00:32:22,000 --> 00:32:23,000
支持

1086
00:32:23,000 --> 00:32:26,000
Android 和 iOS 的跨平台的开发

1087
00:32:26,000 --> 00:32:28,000
但其实我知道他的用心也很

1088
00:32:28,000 --> 00:32:29,000
也很清楚

1089
00:32:29,000 --> 00:32:30,000
就是顺

1090
00:32:30,000 --> 00:32:32,000
顺带甲点私货

1091
00:32:32,000 --> 00:32:34,000
你们都反正都一套代码了

1092
00:32:34,000 --> 00:32:36,000
那不如顺便编一个 Windows Phone 的版本

1093
00:32:36,000 --> 00:32:40,000
一词解决那个什么 Windows Phone 上面

1094
00:32:40,000 --> 00:32:41,000
应用数不足

1095
00:32:41,000 --> 00:32:43,000
然后开发者不愿意开发的

1096
00:32:43,000 --> 00:32:45,000
这么一个尴尬局面吧

1097
00:32:45,000 --> 00:32:46,000
对

1098
00:32:46,000 --> 00:32:48,000
这算是一个机声弹带声机的问题

1099
00:32:48,000 --> 00:32:50,000
就恶性循环

1100
00:32:50,000 --> 00:32:52,000
说你们不想给我声弹

1101
00:32:52,000 --> 00:32:53,000
那我送你一个机

1102
00:32:53,000 --> 00:32:55,000
包生所有的

1103
00:32:55,000 --> 00:32:56,000
对你顺手

1104
00:32:56,000 --> 00:32:58,000
顺手帮我克罗一个弹

1105
00:32:58,000 --> 00:32:59,000
对

1106
00:32:59,000 --> 00:33:01,000
他就是打了那个小算盘

1107
00:33:01,000 --> 00:33:02,000
我觉得

1108
00:33:02,000 --> 00:33:05,000
那个就插播的广告到这里

1109
00:33:05,000 --> 00:33:06,000
这件

1110
00:33:06,000 --> 00:33:09,000
这件正题是什么

1111
00:33:09,000 --> 00:33:11,000
我先放音乐吧

1112
00:33:11,000 --> 00:33:12,000
好

1113
00:33:14,000 --> 00:33:15,000
我实在是太细心了

1114
00:33:15,000 --> 00:33:17,000
Sarcasm Self-Test Complete

1115
00:33:17,000 --> 00:33:19,000
我们本来打算在这里

1116
00:33:19,000 --> 00:33:21,000
插入电子游戏 Portal 的主题曲

1117
00:33:21,000 --> 00:33:24,000
Steel Live 的一个电子合成器版本

1118
00:33:24,000 --> 00:33:27,000
但是经过事后的一番研究发现

1119
00:33:27,000 --> 00:33:29,000
这首歌的授权

1120
00:33:29,000 --> 00:33:32,000
其实并不是像我原先以为的那样

1121
00:33:32,000 --> 00:33:36,000
以创作功用署名非商业写意发布

1122
00:33:36,000 --> 00:33:38,000
原作者张森·卡森

1123
00:33:38,000 --> 00:33:42,000
其实已经将这首歌的版权给了 Portal 游戏的制作商 Wild

1124
00:33:42,000 --> 00:33:45,000
所以我们需要先询问一下 Wild

1125
00:33:45,000 --> 00:33:48,000
是否可以将他用到我们的节目里

1126
00:33:48,000 --> 00:33:51,000
而目前的现状是

1127
00:33:51,000 --> 00:33:55,000
我跟 Rail 在接下来的内容里面

1128
00:33:55,000 --> 00:33:58,000
反复提到 Portal 以及这首歌

1129
00:33:58,000 --> 00:34:00,000
如果你不听一下的话

1130
00:34:00,000 --> 00:34:02,000
可能会有点奇怪

1131
00:34:02,000 --> 00:34:06,000
anyway 和大家说一声抱歉了

1132
00:34:06,000 --> 00:34:08,000
I don't blame you

1133
00:34:09,000 --> 00:34:10,000
北美山的时间

1134
00:34:10,000 --> 00:34:14,000
2006 年 1 月 20 日下午 3 点 04 分 05 秒

1135
00:34:14,000 --> 00:34:17,000
您正在收听的是 IPN podcast

1136
00:34:17,000 --> 00:34:19,000
网络清晓的内核恐慌

1137
00:34:19,000 --> 00:34:21,000
我们号称硬核

1138
00:34:21,000 --> 00:34:23,000
但是也没有什么干货

1139
00:34:23,000 --> 00:34:24,000
想听的人听

1140
00:34:24,000 --> 00:34:26,000
不想听的人就不要听

1141
00:34:27,000 --> 00:34:28,000
好拽啊

1142
00:34:29,000 --> 00:34:30,000
有点怪

1143
00:34:32,000 --> 00:34:34,000
然后就像大家刚才听到了这样

1144
00:34:34,000 --> 00:34:38,000
我们从这一期开始有我们的主题曲了

1145
00:34:42,000 --> 00:34:45,000
原起其实就是看 IT 公论有主题曲

1146
00:34:45,000 --> 00:34:46,000
我挺眼红的

1147
00:34:46,000 --> 00:34:47,000
我也想要

1148
00:34:49,000 --> 00:34:51,000
但是一直拖到

1149
00:34:51,000 --> 00:34:52,000
已经做了五期了

1150
00:34:52,000 --> 00:34:54,000
十个礼拜过去

1151
00:34:54,000 --> 00:34:57,000
才终于找到了这么一个

1152
00:34:57,000 --> 00:34:59,000
也不算非常合意

1153
00:34:59,000 --> 00:35:02,000
但是觉得还不错的主题曲

1154
00:35:02,000 --> 00:35:03,000
当然

1155
00:35:04,000 --> 00:35:05,000
如果你知道它是什么来头

1156
00:35:05,000 --> 00:35:07,000
那已经知道它是什么来头

1157
00:35:07,000 --> 00:35:08,000
如果你不知道的话

1158
00:35:08,000 --> 00:35:11,000
它是一个游戏

1159
00:35:11,000 --> 00:35:15,000
就是如果各位有听前

1160
00:35:15,000 --> 00:35:18,000
三两期的 IT 公论的话

1161
00:35:18,000 --> 00:35:23,000
会注意到 Rail 和留意都在节目之中

1162
00:35:23,000 --> 00:35:25,000
谈到了 Portal 这个游戏

1163
00:35:25,000 --> 00:35:28,000
然后刚才大家听到这段旋律

1164
00:35:28,000 --> 00:35:32,000
就是 Portal 一代里面的主题曲

1165
00:35:32,000 --> 00:35:33,000
应该算

1166
00:35:33,000 --> 00:35:34,000
因为

1167
00:35:34,000 --> 00:35:38,000
虽然整个完整的音乐

1168
00:35:38,000 --> 00:35:40,000
是它是有歌了

1169
00:35:40,000 --> 00:35:44,000
它是在游戏最终打传之后才播出的

1170
00:35:44,000 --> 00:35:46,000
但是其实你一开始游戏

1171
00:35:47,000 --> 00:35:49,000
Spoiler Alert

1172
00:35:49,000 --> 00:35:51,000
就是一开始你在游戏里面

1173
00:35:51,000 --> 00:35:54,000
捡起的声音机里面放的就是这一首曲

1174
00:35:54,000 --> 00:35:56,000
然后在你打爆机的时候

1175
00:35:56,000 --> 00:35:57,000
最后出字幕的时候

1176
00:35:57,000 --> 00:36:00,000
也是放了完整版

1177
00:36:00,000 --> 00:36:03,000
对 整首歌会被正式的唱一点

1178
00:36:03,000 --> 00:36:05,000
其实我第一次听这个歌

1179
00:36:05,000 --> 00:36:07,000
我还没有玩 Portal 这个游戏

1180
00:36:07,000 --> 00:36:10,000
但是有一个什么机缘巧合

1181
00:36:10,000 --> 00:36:11,000
我就听了那个歌

1182
00:36:11,000 --> 00:36:12,000
我觉得好可爱

1183
00:36:12,000 --> 00:36:13,000
真的吗

1184
00:36:13,000 --> 00:36:15,000
你在没有玩这游戏的时候

1185
00:36:15,000 --> 00:36:16,000
你还听过这首歌

1186
00:36:16,000 --> 00:36:17,000
嗯哼

1187
00:36:17,000 --> 00:36:18,000
OK 有意思

1188
00:36:18,000 --> 00:36:20,000
对 然后它有歌词

1189
00:36:20,000 --> 00:36:24,000
然后它有动画效果

1190
00:36:24,000 --> 00:36:25,000
然后你去看

1191
00:36:25,000 --> 00:36:27,000
感觉真的超好

1192
00:36:27,000 --> 00:36:28,000
对

1193
00:36:28,000 --> 00:36:29,000
反正总之

1194
00:36:29,000 --> 00:36:31,000
就像我推荐 Rail

1195
00:36:31,000 --> 00:36:34,000
为什么 Rail 会花一天

1196
00:36:34,000 --> 00:36:37,000
花了一周加一周时间玩了 Portal 一

1197
00:36:37,000 --> 00:36:39,000
然后又花了一整天时间打传 Portal 二呢

1198
00:36:39,000 --> 00:36:42,000
就是因为我向它吐血强力推荐

1199
00:36:42,000 --> 00:36:44,000
我逼着它去玩

1200
00:36:44,000 --> 00:36:45,000
Rail 其实有

1201
00:36:45,000 --> 00:36:48,000
就是玩低震撑射击游戏

1202
00:36:48,000 --> 00:36:51,000
会上吐下不血

1203
00:36:51,000 --> 00:36:53,000
在我的强迫之下

1204
00:36:53,000 --> 00:36:55,000
它还是去玩了一遍

1205
00:36:55,000 --> 00:36:56,000
然后玩的

1206
00:36:56,000 --> 00:36:58,000
对 我推荐它玩的契机

1207
00:36:58,000 --> 00:37:00,000
也就是希望能够选用这首曲子

1208
00:37:00,000 --> 00:37:03,000
来作为游戏主题曲

1209
00:37:03,000 --> 00:37:04,000
作为节目主题曲

1210
00:37:04,000 --> 00:37:07,000
然后希望它能够理解

1211
00:37:07,000 --> 00:37:08,000
这个游戏的

1212
00:37:08,000 --> 00:37:10,000
或者说这个这首音乐的

1213
00:37:10,000 --> 00:37:12,000
有意思的地方在哪

1214
00:37:12,000 --> 00:37:13,000
但其实我要说的

1215
00:37:13,000 --> 00:37:15,000
就是在我玩游戏之前

1216
00:37:15,000 --> 00:37:18,000
我光看那个歌就已经觉得蛮有意思

1217
00:37:18,000 --> 00:37:19,000
但就是说

1218
00:37:19,000 --> 00:37:21,000
只是对里面的有些歌词的部分

1219
00:37:21,000 --> 00:37:22,000
理解不是那么深刻

1220
00:37:22,000 --> 00:37:24,000
不知道为什么它要说那件事

1221
00:37:24,000 --> 00:37:26,000
玩游戏之后你就

1222
00:37:26,000 --> 00:37:27,000
原来是这个意思

1223
00:37:27,000 --> 00:37:28,000
对 比如说

1224
00:37:28,000 --> 00:37:30,000
对 整个歌词里面的每一句

1225
00:37:30,000 --> 00:37:32,000
其实都可以在游戏里面找到线索

1226
00:37:32,000 --> 00:37:33,000
对

1227
00:37:33,000 --> 00:37:35,000
另外这个

1228
00:37:35,000 --> 00:37:40,000
对 另外这个歌曲也本身有点很有那个

1229
00:37:40,000 --> 00:37:42,000
因为它本身就是一个 Gig 写出来

1230
00:37:42,000 --> 00:37:44,000
这首歌的作者是一个

1231
00:37:44,000 --> 00:37:46,000
是在 Gig 解非常有名的一个人

1232
00:37:46,000 --> 00:37:49,000
他叫做 Johnson Colton

1233
00:37:49,000 --> 00:37:53,000
他写了很多说不上快致人口

1234
00:37:53,000 --> 00:37:54,000
但是非常 Gig 的歌

1235
00:37:54,000 --> 00:37:56,000
比如说这首歌的歌词里面有一句是

1236
00:37:58,000 --> 00:38:01,000
We're out of beta, we're released on time

1237
00:38:01,000 --> 00:38:03,000
很有意思

1238
00:38:03,000 --> 00:38:04,000
对

1239
00:38:05,000 --> 00:38:08,000
有时候我们在公司发现

1240
00:38:08,000 --> 00:38:11,000
Deadline 又一次被推迟的时候

1241
00:38:11,000 --> 00:38:13,000
我就会在心里摸摸唱这首歌

1242
00:38:13,000 --> 00:38:17,000
We're out of beta, we're released on time

1243
00:38:17,000 --> 00:38:18,000
对

1244
00:38:18,000 --> 00:38:22,000
在游戏界其实这是非常非常严重的一个问题

1245
00:38:22,000 --> 00:38:26,000
就是游戏作为一种特殊的软件

1246
00:38:26,000 --> 00:38:30,000
其玩家对于跳票的容忍能力是非常非常差的

1247
00:38:31,000 --> 00:38:34,000
除非你是暴雪或者是

1248
00:38:34,000 --> 00:38:40,000
或者是 WOW 这种大公司

1249
00:38:40,000 --> 00:38:47,000
否则你一般很难去面对玩家的愤怒

1250
00:38:47,000 --> 00:38:51,000
而且 Gamer 其实是非常容易印怒的一个人群

1251
00:38:51,000 --> 00:38:54,000
就像之前的 GamerGate 里面

1252
00:38:54,000 --> 00:38:57,000
连暴露出来一个现状一样

1253
00:38:57,000 --> 00:38:59,000
这是一群

1254
00:38:59,000 --> 00:39:01,000
打了鸡血的人

1255
00:39:01,000 --> 00:39:02,000
对

1256
00:39:02,000 --> 00:39:04,000
和耳门无处揮发

1257
00:39:04,000 --> 00:39:07,000
然后又不知道怎么跟女生交流的这样一群人

1258
00:39:09,000 --> 00:39:10,000
他们的情商是非常低的

1259
00:39:10,000 --> 00:39:15,000
所以他们基本上宣扬泄愤的唯一方法就是骂你

1260
00:39:15,000 --> 00:39:19,000
然后游戏公司是被最容易被骂了

1261
00:39:19,000 --> 00:39:21,000
狗血喷头的一方

1262
00:39:21,000 --> 00:39:24,000
所以不能按时交付软件

1263
00:39:24,000 --> 00:39:27,000
其实对于他们来说是非常严重的一种

1264
00:39:27,000 --> 00:39:29,000
所以其实从这一点说来

1265
00:39:29,000 --> 00:39:33,000
像我这种新技玩家还是蛮能等的

1266
00:39:34,000 --> 00:39:39,000
其实咱们都算是休闲性玩家

1267
00:39:39,000 --> 00:39:42,000
就骨灰技玩家等新家已经等的

1268
00:39:42,000 --> 00:39:45,000
已经不知道把泡脚抹抹

1269
00:39:45,000 --> 00:39:46,000
就见个新技

1270
00:39:46,000 --> 00:39:47,000
就慢汗了多少遍了

1271
00:39:47,000 --> 00:39:48,000
对

1272
00:39:48,000 --> 00:39:50,000
所以你玩 Poto 有什么观感

1273
00:39:50,000 --> 00:39:52,000
我先解决那个问题

1274
00:39:52,000 --> 00:39:54,000
我不知道为什么我玩 Poto

1275
00:39:54,000 --> 00:39:57,000
我只能玩就可能不超过半小时了

1276
00:39:57,000 --> 00:39:59,000
不然就会那个头晕想吐

1277
00:39:59,000 --> 00:40:01,000
但是我玩 Poto 2 好像没有这个原因

1278
00:40:01,000 --> 00:40:02,000
但我想不明白为什么

1279
00:40:02,000 --> 00:40:04,000
Poto 2 的引擎和 Poto 1 不一样

1280
00:40:04,000 --> 00:40:08,000
但是我直观的看那个画面的时候

1281
00:40:08,000 --> 00:40:10,000
没有看出太大的区别

1282
00:40:10,000 --> 00:40:13,000
Poto 2 画面的精细程度要有 1 好很多

1283
00:40:13,000 --> 00:40:15,000
是因为你说它精度不够

1284
00:40:15,000 --> 00:40:17,000
所以觉得想头晕想吐

1285
00:40:17,000 --> 00:40:20,000
也有可能是 SOMEHOW 一代的真率不够高

1286
00:40:20,000 --> 00:40:21,000
不可能

1287
00:40:21,000 --> 00:40:25,000
一代的 Poto 1 的 2007 年的机器跑了肯定没问题

1288
00:40:25,000 --> 00:40:28,000
而且我玩游戏它推荐给我的设置

1289
00:40:28,000 --> 00:40:32,000
都还是蛮高的特效的量的

1290
00:40:32,000 --> 00:40:33,000
机器应该不是问题

1291
00:40:33,000 --> 00:40:35,000
这个事情是一个挺贵的

1292
00:40:35,000 --> 00:40:37,000
我玩所有的设计游戏都会

1293
00:40:37,000 --> 00:40:40,000
就第一人称视角的这种算是设计游戏

1294
00:40:40,000 --> 00:40:42,000
都是这个问题

1295
00:40:42,000 --> 00:40:45,000
一天玩 Counter Strike CS 的时候

1296
00:40:45,000 --> 00:40:47,000
也是大概 20 分钟半小时就

1297
00:40:47,000 --> 00:40:49,000
不行了必须再造

1298
00:40:49,000 --> 00:40:52,000
不然就是那个要想吐

1299
00:40:52,000 --> 00:40:54,000
你就是传说中猪眼的队友

1300
00:40:57,000 --> 00:41:00,000
所以你看我我认识着这个头晕想吐这种风险

1301
00:41:00,000 --> 00:41:02,000
去把 Poto 也打完了

1302
00:41:02,000 --> 00:41:04,000
你看都是你真是太高意思了

1303
00:41:05,000 --> 00:41:11,000
会不会是因为一代和二代里面的人的相机视野不一样

1304
00:41:11,000 --> 00:41:13,000
我还真没我还真没看出来

1305
00:41:13,000 --> 00:41:14,000
我比较过于它

1306
00:41:14,000 --> 00:41:17,000
但是没有什么特别明显的区别

1307
00:41:18,000 --> 00:41:21,000
反正这个事情就很让我奇怪

1308
00:41:21,000 --> 00:41:23,000
也可能是说我玩一的时候

1309
00:41:23,000 --> 00:41:25,000
就是什么已经训练过一下了

1310
00:41:25,000 --> 00:41:26,000
然后玩的时候觉得

1311
00:41:26,000 --> 00:41:28,000
刚刚之前已经折腾过那么久了

1312
00:41:28,000 --> 00:41:30,000
这次是不是就好一点

1313
00:41:30,000 --> 00:41:33,000
也有可能是二代的场景相对于

1314
00:41:33,000 --> 00:41:35,000
一代来说更空曠一点

1315
00:41:35,000 --> 00:41:37,000
就可能有有那种纵身感

1316
00:41:37,000 --> 00:41:38,000
就太容易对

1317
00:41:38,000 --> 00:41:41,000
它会大看起来很大一些

1318
00:41:41,000 --> 00:41:43,000
有可能吧

1319
00:41:43,000 --> 00:41:46,000
然后你说你用一天时间打穿的 Poto 2

1320
00:41:46,000 --> 00:41:47,000
我挺惊讶的

1321
00:41:47,000 --> 00:41:52,000
就是我因为 Poto 2 我可能玩过两次三次

1322
00:41:52,000 --> 00:41:53,000
对

1323
00:41:53,000 --> 00:41:57,000
我从来没有说一天再玩这个游戏

1324
00:41:57,000 --> 00:42:02,000
Poto 2 它的场景是比一要大概是四倍左右吧

1325
00:42:02,000 --> 00:42:04,000
我估计就是从我的玩的体验来看

1326
00:42:04,000 --> 00:42:06,000
就是整个你打穿的长度

1327
00:42:06,000 --> 00:42:10,000
因为 Poto 1 的就只有那 19 个 Test Chamber

1328
00:42:10,000 --> 00:42:12,000
其实 Poto 2 不止四倍

1329
00:42:12,000 --> 00:42:15,000
因为 Poto 2 还有一个协作模式

1330
00:42:15,000 --> 00:42:17,000
那个是无限的对吧

1331
00:42:17,000 --> 00:42:18,000
对

1332
00:42:18,000 --> 00:42:20,000
其实也是

1333
00:42:20,000 --> 00:42:21,000
我不是很记得了

1334
00:42:21,000 --> 00:42:26,000
但是我相信它默认带的那些 Temper 也是有限的

1335
00:42:26,000 --> 00:42:28,000
就是如果你有兴趣的话

1336
00:42:28,000 --> 00:42:29,000
以后咱们可以试一下

1337
00:42:29,000 --> 00:42:31,000
就是它可以支持两个好友

1338
00:42:31,000 --> 00:42:32,000
对

1339
00:42:32,000 --> 00:42:36,000
就是在 Poto 2 最后结束的时候又有剧透了

1340
00:42:36,000 --> 00:42:39,000
就是你会看到两个机器人

1341
00:42:39,000 --> 00:42:41,000
一个是成脸

1342
00:42:41,000 --> 00:42:42,000
一个是蓝脸

1343
00:42:42,000 --> 00:42:46,000
然后你可以和自己的同伴各自操作一个

1344
00:42:46,000 --> 00:42:49,000
然后两个机器人各自拿着一把 PotoGun

1345
00:42:49,000 --> 00:42:53,000
然后等于你可以在同一时间里面有四个 Poto

1346
00:42:53,000 --> 00:42:55,000
然后其中两两是互通的

1347
00:42:55,000 --> 00:42:58,000
然后就可以打出更多组合来

1348
00:42:58,000 --> 00:43:00,000
就是你必须在对我的配合之下

1349
00:43:00,000 --> 00:43:02,000
才可以解开一些迷提

1350
00:43:02,000 --> 00:43:03,000
是吧

1351
00:43:03,000 --> 00:43:04,000
那也是有剧情的吗

1352
00:43:04,000 --> 00:43:05,000
没有剧

1353
00:43:05,000 --> 00:43:06,000
那个好像

1354
00:43:06,000 --> 00:43:08,000
就只是一个连机模式

1355
00:43:08,000 --> 00:43:11,000
好像是只是一个协作模式而已

1356
00:43:11,000 --> 00:43:12,000
所以我就说

1357
00:43:12,000 --> 00:43:14,000
单看打单机模式

1358
00:43:14,000 --> 00:43:15,000
单看主线剧情的话

1359
00:43:15,000 --> 00:43:16,000
对

1360
00:43:16,000 --> 00:43:17,000
Poto 2 可能对

1361
00:43:17,000 --> 00:43:19,000
剧情是蛮长

1362
00:43:19,000 --> 00:43:22,000
当时我记得我是跑完了那个

1363
00:43:22,000 --> 00:43:24,000
那个叫什么

1364
00:43:24,000 --> 00:43:27,000
就是从那个地下爬出来

1365
00:43:27,000 --> 00:43:29,000
不是从地下爬出来

1366
00:43:29,000 --> 00:43:30,000
对

1367
00:43:30,000 --> 00:43:32,000
从地下爬出来见到那个最开始

1368
00:43:32,000 --> 00:43:34,000
要剧透了怎么办

1369
00:43:34,000 --> 00:43:35,000
没关系

1370
00:43:35,000 --> 00:43:37,000
就是你找回那个土豆之后

1371
00:43:37,000 --> 00:43:39,000
我觉得那个可能爬出来就完了

1372
00:43:39,000 --> 00:43:41,000
因为之前已经有那个 Test Chamber

1373
00:43:41,000 --> 00:43:42,000
有打过

1374
00:43:42,000 --> 00:43:43,000
然后之后有一个正式的剧情

1375
00:43:43,000 --> 00:43:45,000
你觉得已经蛮长

1376
00:43:45,000 --> 00:43:47,000
最后想不到竟然还有一遍 Test Chamber

1377
00:43:47,000 --> 00:43:48,000
又有一个新一轮的

1378
00:43:48,000 --> 00:43:50,000
就觉得还蛮奇怪的

1379
00:43:50,000 --> 00:43:54,000
因为 Test Chamber 本身也是

1380
00:43:54,000 --> 00:43:56,000
他游戏最大的魅力

1381
00:43:56,000 --> 00:43:57,000
对

1382
00:43:57,000 --> 00:43:59,000
但是我没想到就是

1383
00:43:59,000 --> 00:44:00,000
最开始有一个 Test Chamber

1384
00:44:00,000 --> 00:44:02,000
然后中间有剧情

1385
00:44:02,000 --> 00:44:04,000
完了还有一 Test Chamber

1386
00:44:04,000 --> 00:44:05,000
完全没有

1387
00:44:05,000 --> 00:44:07,000
就是这个是我出户我遇到的一个地方

1388
00:44:07,000 --> 00:44:08,000
然后

1389
00:44:08,000 --> 00:44:10,000
就是会觉得有点

1390
00:44:10,000 --> 00:44:11,000
打到后面就说

1391
00:44:11,000 --> 00:44:13,000
怎么没完没了还没有完

1392
00:44:15,000 --> 00:44:17,000
但是剧情很有意思

1393
00:44:17,000 --> 00:44:18,000
剧情很有趣

1394
00:44:18,000 --> 00:44:20,000
然后也不会觉得很无聊

1395
00:44:20,000 --> 00:44:21,000
OK

1396
00:44:21,000 --> 00:44:23,000
所以你有想明白

1397
00:44:23,000 --> 00:44:25,000
一代和二代

1398
00:44:25,000 --> 00:44:28,000
你知道一代和二代的主角是同一个人吗

1399
00:44:28,000 --> 00:44:29,000
我知道

1400
00:44:29,000 --> 00:44:31,000
就是他从那个最开始介绍的那个

1401
00:44:31,000 --> 00:44:33,000
时间的线看出来就是在

1402
00:44:33,000 --> 00:44:34,000
又看出来吗

1403
00:44:34,000 --> 00:44:35,000
对

1404
00:44:35,000 --> 00:44:37,000
你有想过为什么主角又回去

1405
00:44:37,000 --> 00:44:39,000
重新做实验了

1406
00:44:39,000 --> 00:44:41,000
这个我倒没有想过

1407
00:44:41,000 --> 00:44:42,000
为什么

1408
00:44:42,000 --> 00:44:45,000
就是一代和二代的剧情其实是连着的

1409
00:44:45,000 --> 00:44:47,000
就是一代的结尾

1410
00:44:47,000 --> 00:44:48,000
你

1411
00:44:48,000 --> 00:44:51,000
把 Glados 打爆之后

1412
00:44:51,000 --> 00:44:52,000
到了地面上

1413
00:44:52,000 --> 00:44:53,000
然后看起来

1414
00:44:53,000 --> 00:44:55,000
在一个看起来像停车场的地方

1415
00:44:55,000 --> 00:44:56,000
你会

1416
00:44:56,000 --> 00:44:58,000
就是当时最 Polo 1

1417
00:44:58,000 --> 00:45:00,000
刚刚出

1418
00:45:00,000 --> 00:45:03,000
刚刚出来的时候最终的结局就是

1419
00:45:03,000 --> 00:45:04,000
你看你重新天日

1420
00:45:04,000 --> 00:45:05,000
然后就完了

1421
00:45:05,000 --> 00:45:06,000
那是假的

1422
00:45:06,000 --> 00:45:07,000
然后就暗淡了

1423
00:45:07,000 --> 00:45:08,000
那个也是

1424
00:45:08,000 --> 00:45:10,000
后来我看有一个网上的

1425
00:45:10,000 --> 00:45:12,000
别人做的视频

1426
00:45:12,000 --> 00:45:13,000
就是他从

1427
00:45:13,000 --> 00:45:15,000
就是一个真人版的

1428
00:45:15,000 --> 00:45:17,000
一个小电影

1429
00:45:17,000 --> 00:45:20,000
就说他好像是冲出去之后

1430
00:45:20,000 --> 00:45:21,000
发现周围的那些景物

1431
00:45:21,000 --> 00:45:22,000
看起来是真的

1432
00:45:22,000 --> 00:45:24,000
但其实跑到边来看都是屏幕

1433
00:45:24,000 --> 00:45:25,000
对吧

1434
00:45:25,000 --> 00:45:26,000
不是

1435
00:45:26,000 --> 00:45:28,000
就是在 Polo 2 出现之后

1436
00:45:28,000 --> 00:45:30,000
Polo 1 有了一个 update

1437
00:45:30,000 --> 00:45:31,000
有一个 patch

1438
00:45:31,000 --> 00:45:33,000
结局改了

1439
00:45:33,000 --> 00:45:36,000
就是你重建天日之后

1440
00:45:36,000 --> 00:45:37,000
自己受伤了

1441
00:45:37,000 --> 00:45:39,000
然后你

1442
00:45:39,000 --> 00:45:40,000
你低人生视角会

1443
00:45:40,000 --> 00:45:43,000
感觉到自己正在被一个机器人

1444
00:45:43,000 --> 00:45:45,000
正在被一个什么东西往回托

1445
00:45:45,000 --> 00:45:47,000
然后一个机器人的声音说

1446
00:45:47,000 --> 00:45:50,000
请你保持一个 party submission position

1447
00:45:50,000 --> 00:45:53,000
就是要参加 party 这么一个姿势

1448
00:45:53,000 --> 00:45:55,000
然后他把你慢慢往回托

1449
00:45:55,000 --> 00:45:58,000
然后那个整个的画面才按下去

1450
00:45:58,000 --> 00:46:01,000
然后一代还二代之间的剧情

1451
00:46:01,000 --> 00:46:05,000
其实可以通过一个一部漫画解释

1452
00:46:05,000 --> 00:46:09,000
就是 Wolf 专门发了一本漫画

1453
00:46:09,000 --> 00:46:13,000
叫做 Portal 的 Labyrinth

1454
00:46:13,000 --> 00:46:18,000
然后在这里面解释了整件事情来去卖

1455
00:46:18,000 --> 00:46:20,000
就是如果你玩过 Portal 的话

1456
00:46:20,000 --> 00:46:21,000
你可能会好奇就是

1457
00:46:21,000 --> 00:46:23,000
为什么里面的人都死了

1458
00:46:23,000 --> 00:46:25,000
他们是怎么死的

1459
00:46:25,000 --> 00:46:27,000
然后 Labyrinth 这个漫画

1460
00:46:27,000 --> 00:46:29,000
其实就解释了这一点

1461
00:46:30,000 --> 00:46:35,000
但是这个在 Portal 2 进场的时候

1462
00:46:35,000 --> 00:46:36,000
就最开始那一些的

1463
00:46:36,000 --> 00:46:37,000
不对

1464
00:46:37,000 --> 00:46:40,000
就在 Portal 最后那部分的 Test Chamber

1465
00:46:40,000 --> 00:46:42,000
你每次出来不是一个电梯吗

1466
00:46:42,000 --> 00:46:44,000
然后它电梯墙面上不是有

1467
00:46:44,000 --> 00:46:46,000
一堆破碎的屏幕吗

1468
00:46:46,000 --> 00:46:48,000
能够看出一点端倪吧

1469
00:46:48,000 --> 00:46:50,000
然后机器人什么

1470
00:46:50,000 --> 00:46:52,000
就是突然发飙了

1471
00:46:52,000 --> 00:46:53,000
然后把那些人都干掉了

1472
00:46:53,000 --> 00:46:58,000
其实在 Aperture Science Laboratory 里面

1473
00:46:58,000 --> 00:47:03,000
人们研究出来了真正的人工智能

1474
00:47:03,000 --> 00:47:06,000
Gladoff 这个名字的缩写

1475
00:47:06,000 --> 00:47:11,000
就是整个片中的女人工智能的名字

1476
00:47:11,000 --> 00:47:14,000
Gladoff 他的缩写就是 General Life Form

1477
00:47:14,000 --> 00:47:18,000
and Disk Operations System

1478
00:47:18,000 --> 00:47:20,000
DOS 这个部分就是 DOS

1479
00:47:20,000 --> 00:47:22,000
然后前面是 General Life Form

1480
00:47:22,000 --> 00:47:26,000
它是一种真正有智力的人工智能

1481
00:47:26,000 --> 00:47:28,000
但是人们发现一个问题

1482
00:47:28,000 --> 00:47:31,000
就是在码画里面有讲说

1483
00:47:31,000 --> 00:47:36,000
每一个人工智能被打开之后

1484
00:47:36,000 --> 00:47:38,000
就是把它 Turn On 之后

1485
00:47:38,000 --> 00:47:44,000
大约在 16 分之 1 个 Pico Second 之后

1486
00:47:44,000 --> 00:47:46,000
这个人工智能就会试图把人

1487
00:47:46,000 --> 00:47:49,000
就会开始试图杀人

1488
00:47:49,000 --> 00:47:51,000
对

1489
00:47:51,000 --> 00:47:53,000
然后他们的决定方法就是拼命往

1490
00:47:53,000 --> 00:47:57,000
人工智能上面加 Personality Core

1491
00:47:57,000 --> 00:48:01,000
有一个 Personality Core 是 Moral Core

1492
00:48:01,000 --> 00:48:04,000
让人工智能有道德意识

1493
00:48:04,000 --> 00:48:07,000
让他意识到杀人是不对的

1494
00:48:07,000 --> 00:48:10,000
然后他装成 Core 之后

1495
00:48:10,000 --> 00:48:14,000
人工智能意识到杀人是不对的

1496
00:48:14,000 --> 00:48:16,000
所以他就换了一个方法杀人

1497
00:48:17,000 --> 00:48:20,000
有一个 Event 叫做

1498
00:48:20,000 --> 00:48:23,000
Bring Your Cat To Work

1499
00:48:23,000 --> 00:48:26,000
就是带你的猫来上班的 Event 上面

1500
00:48:26,000 --> 00:48:29,000
把神经毒气接入到通风系统

1501
00:48:29,000 --> 00:48:30,000
然后把所有的人都杀了

1502
00:48:30,000 --> 00:48:32,000
除了一个人

1503
00:48:32,000 --> 00:48:35,000
主角是一个 Test Object

1504
00:48:35,000 --> 00:48:37,000
然后他不是工作人员

1505
00:48:37,000 --> 00:48:39,000
就是 General 杀了所有工作人员

1506
00:48:39,000 --> 00:48:41,000
但是工作人员有一个人活下来

1507
00:48:41,000 --> 00:48:44,000
这个人叫做

1508
00:48:45,000 --> 00:48:46,000
忘了

1509
00:48:46,000 --> 00:48:49,000
但是 Librate 就是以他的视角

1510
00:48:49,000 --> 00:48:52,000
来解释整个 Portal 的 Event

1511
00:48:52,000 --> 00:48:56,000
就是 Glados 杀了所有的工作人员之后

1512
00:48:56,000 --> 00:49:00,000
开始试图想要找到这个工作人员

1513
00:49:00,000 --> 00:49:02,000
然后他继续做实验

1514
00:49:02,000 --> 00:49:05,000
因为 Aparchus Science 在后期

1515
00:49:05,000 --> 00:49:08,000
已经找不到合适的实验对象

1516
00:49:08,000 --> 00:49:11,000
就是如果你有仔细玩

1517
00:49:11,000 --> 00:49:13,000
仔细听 Portal 2 里面的那些对摆的话

1518
00:49:13,000 --> 00:49:15,000
你就会发现 Portal 2 一开始是

1519
00:49:15,000 --> 00:49:18,000
受美国军方的支持

1520
00:49:18,000 --> 00:49:22,000
Portal 2 里面 Aparchus Science 的历史很有意思

1521
00:49:22,000 --> 00:49:26,000
Aparchus Science 一开始是给美国军方提供

1522
00:49:26,000 --> 00:49:30,000
Shower Curtain 的就是育莲类似的公司

1523
00:49:30,000 --> 00:49:38,000
然后他的总裁发现育莲大货成功之后

1524
00:49:38,000 --> 00:49:41,000
开始急速转向

1525
00:49:41,000 --> 00:49:47,000
开始研究这种可以超空间

1526
00:49:47,000 --> 00:49:49,000
打开传送门的装置

1527
00:49:49,000 --> 00:49:51,000
开始研发这种装置

1528
00:49:51,000 --> 00:49:53,000
然后一开始的时候美国

1529
00:49:53,000 --> 00:49:54,000
对

1530
00:49:54,000 --> 00:49:56,000
你会发现美国政府给他提供的

1531
00:49:56,000 --> 00:49:58,000
优秀的军事人才来

1532
00:49:58,000 --> 00:50:02,000
应该是经过挑选的士兵来提供的做实验

1533
00:50:02,000 --> 00:50:06,000
到后来他不得不花钱来顾人做实验

1534
00:50:06,000 --> 00:50:09,000
到最后他连顾人都顾不到了

1535
00:50:09,000 --> 00:50:13,000
只能强迫自己的雇员去做实验

1536
00:50:13,000 --> 00:50:16,000
然后到 Glados 的时候

1537
00:50:16,000 --> 00:50:18,000
这个传统还是延续的下来

1538
00:50:18,000 --> 00:50:22,000
就是 Glados 想要找到唯一仅存的雇员去做实验

1539
00:50:22,000 --> 00:50:26,000
然后这个雇员在机缘桥

1540
00:50:26,000 --> 00:50:31,000
或者说他故意把女主角的名字推到了

1541
00:50:31,000 --> 00:50:34,000
整个实验名单的第一位

1542
00:50:34,000 --> 00:50:36,000
女主角本来是 1600 多个后生人

1543
00:50:36,000 --> 00:50:38,000
然后他一下子变成了第一个人

1544
00:50:38,000 --> 00:50:40,000
然后就被唤醒去做了实验

1545
00:50:40,000 --> 00:50:41,000
ok

1546
00:50:41,000 --> 00:50:42,000
这样

1547
00:50:42,000 --> 00:50:44,000
然后看那个漫画

1548
00:50:44,000 --> 00:50:48,000
对你在这个游戏里面所看到的

1549
00:50:48,000 --> 00:50:51,000
墙壁上的所有的涂鸦也都是这个人画的

1550
00:50:51,000 --> 00:50:53,000
因为他换了精神分裂症

1551
00:50:53,000 --> 00:50:56,000
然后他在他精神不正常的时候

1552
00:50:56,000 --> 00:50:59,000
他认为自己随身带的那个

1553
00:50:59,000 --> 00:51:03,000
就是上面画了新型图案的那个

1554
00:51:03,000 --> 00:51:06,000
Cube 是会跟他对话的

1555
00:51:06,000 --> 00:51:08,000
是他的唯一的 companion

1556
00:51:08,000 --> 00:51:09,000
对

1557
00:51:09,000 --> 00:51:14,000
但是这个亭杰在后面的对白中有意济浩美拿来恶搞

1558
00:51:14,000 --> 00:51:20,000
就是比如说在游戏界

1559
00:51:20,000 --> 00:51:23,000
或者在西方的欧美游戏界最常

1560
00:51:23,000 --> 00:51:27,000
最为人所知的一个 Dragon 就是 the KK's lie

1561
00:51:27,000 --> 00:51:32,000
然后正确的回应是 and the cube must die for it

1562
00:51:33,000 --> 00:51:34,000
对

1563
00:51:34,000 --> 00:51:37,000
就是在 Portal 一代里面

1564
00:51:37,000 --> 00:51:39,000
应该是第 17 关我记得

1565
00:51:39,000 --> 00:51:40,000
Testemper 17

1566
00:51:40,000 --> 00:51:44,000
你用一个上面画了新型的 Cube 去挡了很多

1567
00:51:44,000 --> 00:51:47,000
你用它替你挡了很多子弹

1568
00:51:47,000 --> 00:51:49,000
因为你不拿它挡的话就死了

1569
00:51:49,000 --> 00:51:51,000
然后等到关卡的最结尾

1570
00:51:51,000 --> 00:51:55,000
格拉道斯强迫你把这个 Cube 扔到一个融入里去

1571
00:51:55,000 --> 00:52:00,000
然后你发现自己无论如何都只能把 Cube 扔进融入里面

1572
00:52:00,000 --> 00:52:02,000
然后才能过这个 Testemper

1573
00:52:02,000 --> 00:52:04,000
然后当你把 Cube 扔进去之后

1574
00:52:04,000 --> 00:52:06,000
格拉道斯对你说

1575
00:52:06,000 --> 00:52:11,000
你把它扔进去的速度比其他 90%的人都快

1576
00:52:15,000 --> 00:52:16,000
是挺黑的

1577
00:52:16,000 --> 00:52:18,000
对里面的对白

1578
00:52:18,000 --> 00:52:21,000
我觉得这个是游戏最有魅力的地方

1579
00:52:21,000 --> 00:52:22,000
对

1580
00:52:22,000 --> 00:52:23,000
它通过一种非常

1581
00:52:23,000 --> 00:52:26,000
就是怎么说 dehumanization 的方式

1582
00:52:26,000 --> 00:52:29,000
来让你觉得自己是一个 Test object

1583
00:52:29,000 --> 00:52:32,000
这个人工智能根本不在乎你是谁

1584
00:52:32,000 --> 00:52:35,000
你在其他游戏里面你是主角

1585
00:52:35,000 --> 00:52:38,000
但在这里面你是一个甚至任人摆布的这么一个角色

1586
00:52:38,000 --> 00:52:41,000
而且就是里面的那种对白的那种

1587
00:52:41,000 --> 00:52:44,000
AI 给你对话的那种语气

1588
00:52:44,000 --> 00:52:45,000
不知道怎么回事

1589
00:52:45,000 --> 00:52:48,000
我老是想进你说话的感觉

1590
00:52:48,000 --> 00:52:49,000
真的假的

1591
00:52:49,000 --> 00:52:50,000
超级好

1592
00:52:50,000 --> 00:52:52,000
超级 Match

1593
00:52:52,000 --> 00:52:54,000
你是说格拉道斯

1594
00:52:54,000 --> 00:52:56,000
还是说后面的 Witley

1595
00:52:56,000 --> 00:52:58,000
格拉道斯就已经是这样

1596
00:52:58,000 --> 00:52:59,000
什么

1597
00:52:59,000 --> 00:53:01,000
就觉得很有意思

1598
00:53:01,000 --> 00:53:03,000
你不觉得吗

1599
00:53:03,000 --> 00:53:05,000
是一个语气

1600
00:53:07,000 --> 00:53:09,000
其实我觉得那个那个那个

1601
00:53:09,000 --> 00:53:10,000
那个吊吊以后

1602
00:53:10,000 --> 00:53:11,000
我们可以经常拿来用一下

1603
00:53:11,000 --> 00:53:14,000
我觉得适合我们这个节目

1604
00:53:14,000 --> 00:53:16,000
我不要哭

1605
00:53:16,000 --> 00:53:18,000
没有好感觉

1606
00:53:19,000 --> 00:53:22,000
对 Tarant 和格拉道斯其实同一个人配音

1607
00:53:23,000 --> 00:53:24,000
啊

1608
00:53:24,000 --> 00:53:25,000
对

1609
00:53:25,000 --> 00:53:27,000
Tarant 有材词吗

1610
00:53:27,000 --> 00:53:28,000
有啊就是

1611
00:53:28,000 --> 00:53:30,000
Where are you

1612
00:53:30,000 --> 00:53:32,000
啊

1613
00:53:32,000 --> 00:53:33,000
对

1614
00:53:33,000 --> 00:53:35,000
No heart feelings

1615
00:53:38,000 --> 00:53:40,000
他唱歌也是他吧

1616
00:53:40,000 --> 00:53:41,000
对唱歌也是他

1617
00:53:41,000 --> 00:53:43,000
对那个声音超好

1618
00:53:43,000 --> 00:53:45,000
对

1619
00:53:45,000 --> 00:53:48,000
回到我们的过往

1620
00:53:48,000 --> 00:53:50,000
掉进这个

1621
00:53:50,000 --> 00:53:53,000
有一旦变身成 gamer 就变不回来了

1622
00:53:53,000 --> 00:53:56,000
回到内核恐慌对为什么

1623
00:53:56,000 --> 00:53:57,000
我们要选择这个

1624
00:53:57,000 --> 00:54:00,000
或者说我为什么要选择 Portal 的主题曲来

1625
00:54:00,000 --> 00:54:03,000
做内核恐慌主题曲呢

1626
00:54:03,000 --> 00:54:06,000
我就是因为我觉得

1627
00:54:06,000 --> 00:54:08,000
Portal 的这个剧情设定啊

1628
00:54:08,000 --> 00:54:12,000
就是 artificial intelligence went mad

1629
00:54:12,000 --> 00:54:15,000
跟 cronoponic 多时候有点关联

1630
00:54:15,000 --> 00:54:16,000
对

1631
00:54:16,000 --> 00:54:18,000
就比如说这个内核

1632
00:54:18,000 --> 00:54:22,000
Portal 里面你也会听到比如说那个系统

1633
00:54:22,000 --> 00:54:26,000
抱错说 corruption at 100%

1634
00:54:26,000 --> 00:54:30,000
就和内核恐慌多少有点

1635
00:54:30,000 --> 00:54:32,000
而且你在游戏里面是

1636
00:54:32,000 --> 00:54:35,000
是 literally 把那个

1637
00:54:35,000 --> 00:54:39,000
把格拉道斯身上的 core 一个一个摘下来

1638
00:54:39,000 --> 00:54:42,000
然后然后 dump 到那个容颅里面去

1639
00:54:42,000 --> 00:54:44,000
对真正的 core dump

1640
00:54:44,000 --> 00:54:46,000
对真正的 core dump

1641
00:54:47,000 --> 00:54:49,000
其实这要解释啊

1642
00:54:49,000 --> 00:54:51,000
这个 core 和那个 core 还

1643
00:54:51,000 --> 00:54:53,000
此 core 非 bcore

1644
00:54:53,000 --> 00:54:54,000
对

1645
00:54:54,000 --> 00:54:56,000
为什么

1646
00:54:56,000 --> 00:54:58,000
core dump 叫 core dump

1647
00:54:58,000 --> 00:55:00,000
core 是来自于哪

1648
00:55:00,000 --> 00:55:01,000
curnal

1649
00:55:01,000 --> 00:55:04,000
就 curnal 就已经有两位听众

1650
00:55:04,000 --> 00:55:07,000
把我们的节目叫做叫成硬核恐慌

1651
00:55:07,000 --> 00:55:10,000
hardcore panic

1652
00:55:10,000 --> 00:55:12,000
好 panic

1653
00:55:13,000 --> 00:55:15,000
有 software panic

1654
00:55:15,000 --> 00:55:19,000
因为我们的那个节目介绍里面有提到这两个词嘛

1655
00:55:19,000 --> 00:55:21,000
然后一想起来可能就

1656
00:55:21,000 --> 00:55:24,000
一下就不明白这个组合的顺序了

1657
00:55:24,000 --> 00:55:27,000
也挺合乎

1658
00:55:27,000 --> 00:55:29,000
这个错误还挺常见的

1659
00:55:29,000 --> 00:55:30,000
对

1660
00:55:30,000 --> 00:55:33,000
如果有这个

1661
00:55:33,000 --> 00:55:36,000
不那么 hardcore 的听众需要

1662
00:55:36,000 --> 00:55:38,000
在听我们的节目的话呢大概还是解释一下吧

1663
00:55:38,000 --> 00:55:40,000
就是 hardcore 这个词其实来自

1664
00:55:40,000 --> 00:55:42,000
最早应该是来自于音乐界吧

1665
00:55:42,000 --> 00:55:45,000
就是 hardcore 是指比较

1666
00:55:45,000 --> 00:55:48,000
直接粗暴

1667
00:55:48,000 --> 00:55:50,000
疯狂

1668
00:55:50,000 --> 00:55:52,000
程度更强烈的东西

1669
00:55:52,000 --> 00:55:54,000
就是音乐

1670
00:55:54,000 --> 00:55:56,000
比如 hardcore rock

1671
00:55:56,000 --> 00:55:58,000
或者是 hardcore metal

1672
00:55:58,000 --> 00:56:00,000
就是非常强调

1673
00:56:00,000 --> 00:56:05,000
那种音乐形式的纯粹性和激烈性的

1674
00:56:05,000 --> 00:56:08,000
然后这个词渐

1675
00:56:09,000 --> 00:56:10,000
延伸到了

1676
00:56:10,000 --> 00:56:12,000
就是它最开始是音乐的

1677
00:56:12,000 --> 00:56:14,000
流派就 wrong 了的一种

1678
00:56:14,000 --> 00:56:18,000
但是这个词渐渐延伸到了日常用语里面

1679
00:56:18,000 --> 00:56:21,000
就是形容某种事情非常的强烈

1680
00:56:21,000 --> 00:56:25,000
或者是比酷更加激烈

1681
00:56:25,000 --> 00:56:27,000
程度很高的一种状态

1682
00:56:27,000 --> 00:56:28,000
就叫 hardcore

1683
00:56:28,000 --> 00:56:31,000
比如说你可以说我是一个 hardcore 的国粉

1684
00:56:31,000 --> 00:56:34,000
或者我是一个 hardcore 的真话 programmer

1685
00:56:34,000 --> 00:56:37,000
然后这个词还

1686
00:56:37,000 --> 00:56:41,000
还被逆向衍生

1687
00:56:41,000 --> 00:56:43,000
除了 softcore

1688
00:56:43,000 --> 00:56:45,000
这种衍生词

1689
00:56:45,000 --> 00:56:47,000
就好像 Hamburger

1690
00:56:47,000 --> 00:56:50,000
被派生出什么 cheeseburger 型

1691
00:56:52,000 --> 00:56:53,000
挺有意思的

1692
00:56:53,000 --> 00:56:59,000
但是 hardcore 跟 carnal 是完全

1693
00:56:59,000 --> 00:57:00,000
没有关系的

1694
00:57:00,000 --> 00:57:01,000
两件事情的

1695
00:57:01,000 --> 00:57:04,000
carnal 在计算机方面里面

1696
00:57:04,000 --> 00:57:06,000
一般指操的系统里面

1697
00:57:06,000 --> 00:57:09,000
直接和硬件相关的那部分

1698
00:57:09,000 --> 00:57:12,000
或者说直接管理

1699
00:57:12,000 --> 00:57:15,000
你平时作为一个用户

1700
00:57:15,000 --> 00:57:17,000
所用到的程序的程序

1701
00:57:17,000 --> 00:57:20,000
对不知道这样解释清楚了没有

1702
00:57:20,000 --> 00:57:21,000
但总之

1703
00:57:21,000 --> 00:57:24,000
我觉得可能这里混淆的是

1704
00:57:24,000 --> 00:57:26,000
因为 hardcore 里面有 core 的概念

1705
00:57:26,000 --> 00:57:28,000
然后我马上要说 core dump

1706
00:57:28,000 --> 00:57:29,000
然后又会有 core

1707
00:57:29,000 --> 00:57:32,000
但其实这个 core and thatcore 是没有关系的

1708
00:57:32,000 --> 00:57:41,000
对 core dump 是程序出错之后的一种行为

1709
00:57:41,000 --> 00:57:45,000
尤其是在 unix 下面有些程序

1710
00:57:45,000 --> 00:57:48,000
如果它出错了的话

1711
00:57:48,000 --> 00:57:54,000
它会把自己在内存之中的执行状态存储在硬盘上面

1712
00:57:54,000 --> 00:57:57,000
或者是以某种方式呈现给你

1713
00:57:57,000 --> 00:57:59,000
让你可以

1714
00:57:59,000 --> 00:58:00,000
你试试程序

1715
00:58:00,000 --> 00:58:06,000
让程序员可以去研究这件事情的案发现场

1716
00:58:06,000 --> 00:58:09,000
然后这个行为叫 core dump

1717
00:58:09,000 --> 00:58:11,000
可是为什么要叫 core dump 呢

1718
00:58:11,000 --> 00:58:14,000
因为 core 来自于早期的一种叫做

1719
00:58:14,000 --> 00:58:17,000
磁心存储器的东西

1720
00:58:17,000 --> 00:58:19,000
就是内存的组终

1721
00:58:19,000 --> 00:58:20,000
现代内存的组终

1722
00:58:20,000 --> 00:58:23,000
对什么是磁心存储器呢

1723
00:58:23,000 --> 00:58:28,000
简单来说就是把导线绕在磁圈上面

1724
00:58:28,000 --> 00:58:29,000
磁铁

1725
00:58:29,000 --> 00:58:30,000
对

1726
00:58:30,000 --> 00:58:31,000
就是一个磁的环

1727
00:58:31,000 --> 00:58:32,000
然后你在上面绕导线

1728
00:58:32,000 --> 00:58:33,000
然后三跑三摩

1729
00:58:33,000 --> 00:58:37,000
它就可以存储有磁和无磁两种状态

1730
00:58:37,000 --> 00:58:41,000
就可以表示零和一了吗

1731
00:58:41,000 --> 00:58:42,000
对

1732
00:58:42,000 --> 00:58:43,000
早期的内存就是这样做出来

1733
00:58:43,000 --> 00:58:47,000
我记得我还读过一篇考古文章说

1734
00:58:47,000 --> 00:58:53,000
我国早期五六十年代自行研制器上机的时候

1735
00:58:53,000 --> 00:58:54,000
还

1736
00:58:54,000 --> 00:58:58,000
科学家们的日常工作之一就是绕磁心

1737
00:58:58,000 --> 00:59:02,000
就是把导线在磁铁上面绕

1738
00:59:02,000 --> 00:59:04,000
然后做出一块内存

1739
00:59:04,000 --> 00:59:05,000
对

1740
00:59:05,000 --> 00:59:06,000
而且内存有多大呢

1741
00:59:06,000 --> 00:59:08,000
就是你绕一个磁心

1742
00:59:08,000 --> 00:59:11,000
你可以把导线在磁身上缠一圈

1743
00:59:11,000 --> 00:59:12,000
你可以绕出一个 bit

1744
00:59:12,000 --> 00:59:14,000
然后可以想象一下

1745
00:59:14,000 --> 00:59:17,000
你要绕出 16 k 需要绕多少

1746
00:59:17,000 --> 00:59:19,000
它一个磁心大概就跟一个

1747
00:59:19,000 --> 00:59:21,000
一枚戒指的那个大概差不多

1748
00:59:21,000 --> 00:59:22,000
对

1749
00:59:22,000 --> 00:59:25,000
然后把这么小的东西绕上几千个

1750
00:59:25,000 --> 00:59:27,000
然后你才有了几 k 的内存

1751
00:59:27,000 --> 00:59:29,000
8 k 的内存可以

1752
00:59:29,000 --> 00:59:30,000
对

1753
00:59:30,000 --> 00:59:34,000
所以其实大家可以去找一下

1754
00:59:34,000 --> 00:59:36,000
我们待会给个连接在一个 note 里面

1755
00:59:36,000 --> 00:59:38,000
你可以去找一下相关的图片来看

1756
00:59:38,000 --> 00:59:42,000
反正视觉上就是让你想起在编辩子的感觉

1757
00:59:42,000 --> 00:59:43,000
对

1758
00:59:43,000 --> 00:59:44,000
其实还是相当正常的

1759
00:59:44,000 --> 00:59:46,000
你要仔细想象一下

1760
00:59:46,000 --> 00:59:47,000
当初那么大的一个东西

1761
00:59:47,000 --> 00:59:51,000
现在缩在可能你肉眼看不见的一个尺寸里面

1762
00:59:51,000 --> 00:59:52,000
对

1763
00:59:52,000 --> 00:59:55,000
而且是仅仅过去了五六十两而已

1764
00:59:55,000 --> 00:59:56,000
几十进步

1765
00:59:56,000 --> 00:59:57,000
对

1766
00:59:57,000 --> 01:00:04,000
但是这个 core 这个词就是 magneticcore 里面的 core

1767
01:00:04,000 --> 01:00:08,000
一直延续到今天就是有时候还是会说 core dump

1768
01:00:08,000 --> 01:00:11,000
那么这个 core 最开始的来源就是源自于此

1769
01:00:11,000 --> 01:00:15,000
所以所以就是 core dump 就是内存进向导出来而已吗

1770
01:00:15,000 --> 01:00:16,000
对

1771
01:00:16,000 --> 01:00:17,000
差不多这个意思

1772
01:00:17,000 --> 01:00:18,000
没错

1773
01:00:18,000 --> 01:00:24,000
然后提到 magneticcore 不能不提到一个奇人就是一个华人叫王安

1774
01:00:24,000 --> 01:00:27,000
王安不是李安

1775
01:00:27,000 --> 01:00:28,000
对

1776
01:00:28,000 --> 01:00:29,000
王安不是李安

1777
01:00:29,000 --> 01:00:33,000
现在的王安是现在李安试图输出软的话

1778
01:00:33,000 --> 01:00:36,000
在那个时候的王安是一个传奇人物

1779
01:00:36,000 --> 01:00:40,000
他是民国 1911 年应该是出生在中国

1780
01:00:40,000 --> 01:00:41,000
出生在中国吧

1781
01:00:41,000 --> 01:00:42,000
他出生在中国

1782
01:00:42,000 --> 01:00:44,000
他是中国出生的

1783
01:00:44,000 --> 01:00:45,000
对

1784
01:00:45,000 --> 01:00:46,000
他出生在美国

1785
01:00:46,000 --> 01:00:51,000
三炮三卫成为一个计算机科学家

1786
01:00:51,000 --> 01:00:52,000
对

1787
01:00:52,000 --> 01:00:58,000
他对于我们刚才说的慈兴这种东西做出了巨大的贡献

1788
01:00:58,000 --> 01:01:03,000
他可能有三四十项专利和慈兴相关

1789
01:01:03,000 --> 01:01:09,000
然后 1956 年的时候 IBM 公司用 50 万美元从他手里买了专利

1790
01:01:09,000 --> 01:01:11,000
1956 年的 50 万美元是个什么概念

1791
01:01:11,000 --> 01:01:13,000
大概相当于多少得算一下

1792
01:01:13,000 --> 01:01:14,000
对

1793
01:01:14,000 --> 01:01:17,000
算上通货膨胀的话是一个天文数字

1794
01:01:17,000 --> 01:01:18,000
相逼了吧

1795
01:01:18,000 --> 01:01:19,000
对

1796
01:01:19,000 --> 01:01:30,000
然后他当时创建了王安电脑在美国出的设备叫做自处理器

1797
01:01:30,000 --> 01:01:32,000
其实就是个打字机

1798
01:01:32,000 --> 01:01:36,000
但是你可以先预览自己要打的东西

1799
01:01:36,000 --> 01:01:37,000
然后再来打算

1800
01:01:37,000 --> 01:01:41,000
在别人家都还用一个

1801
01:01:41,000 --> 01:01:43,000
就是有点像计算器一样的显示器

1802
01:01:43,000 --> 01:01:44,000
就是单行

1803
01:01:44,000 --> 01:01:48,000
然后只能显示单个字母的显示器的时候

1804
01:01:48,000 --> 01:01:52,000
他已经出了一个代这个音机摄像人

1805
01:01:52,000 --> 01:01:54,000
音机是 CRT 的这么一个版本

1806
01:01:54,000 --> 01:01:57,000
所以他那个时候是非常非常了不起的一个人

1807
01:01:57,000 --> 01:01:59,000
王氏电脑就是王安吗

1808
01:01:59,000 --> 01:02:00,000
对

1809
01:02:00,000 --> 01:02:01,000
就是王

1810
01:02:01,000 --> 01:02:02,000
蓝底白字的一个王

1811
01:02:02,000 --> 01:02:05,000
就是王安的王安重新的公司

1812
01:02:05,000 --> 01:02:08,000
这个可能在国内有流行过吗

1813
01:02:08,000 --> 01:02:10,000
好像在 90 年代初的时候好像有见过

1814
01:02:10,000 --> 01:02:13,000
那个时候好像是有一个自处理器的

1815
01:02:13,000 --> 01:02:18,000
但是那个自处理器是王安电脑出的吗

1816
01:02:18,000 --> 01:02:25,000
我不但我记得在国内好像我 3 号在哪里有印象说发现

1817
01:02:25,000 --> 01:02:27,000
国内也是有一段时间有进口过

1818
01:02:27,000 --> 01:02:29,000
那个时候应该是

1819
01:02:29,000 --> 01:02:30,000
OK

1820
01:02:30,000 --> 01:02:31,000
那个时候应该是四通

1821
01:02:31,000 --> 01:02:33,000
四通比较

1822
01:02:33,000 --> 01:02:34,000
那个是国产的

1823
01:02:34,000 --> 01:02:38,000
但是王氏没有就有产品进到中国吗

1824
01:02:38,000 --> 01:02:39,000
好像有

1825
01:02:39,000 --> 01:02:40,000
这个我不知道很确定的

1826
01:02:40,000 --> 01:02:42,000
有点久了

1827
01:02:42,000 --> 01:02:43,000
对

1828
01:02:43,000 --> 01:02:45,000
总之大概六七十年代的时候

1829
01:02:45,000 --> 01:02:47,000
王安电脑是非常非常了不起的一个公司

1830
01:02:47,000 --> 01:02:52,000
而且当时他基本上是以一己之力对挑 IBM

1831
01:02:52,000 --> 01:02:55,000
然后来挂掉了是吧

1832
01:02:55,000 --> 01:02:58,000
对很遗憾他没有赶上 Personal Computer 的大潮

1833
01:02:58,000 --> 01:03:00,000
就是他比较

1834
01:03:00,000 --> 01:03:01,000
他比较

1835
01:03:01,000 --> 01:03:04,000
他比较钢币自用版

1836
01:03:04,000 --> 01:03:07,000
他觉得个人计算机和

1837
01:03:07,000 --> 01:03:09,000
微型计算机和

1838
01:03:09,000 --> 01:03:13,000
Mapframe 相比就是玩笑一样东西

1839
01:03:13,000 --> 01:03:15,000
为什么要花费精力在这种东西上面

1840
01:03:15,000 --> 01:03:18,000
但是等到他回过舌来的时候已经开网了

1841
01:03:18,000 --> 01:03:19,000
对

1842
01:03:19,000 --> 01:03:21,000
然后整个帝国就那么垮掉

1843
01:03:21,000 --> 01:03:25,000
还是什么箭矢箭不够有远见

1844
01:03:25,000 --> 01:03:28,000
对如果他能够对我们就不要继续开脑洞

1845
01:03:28,000 --> 01:03:31,000
总之王安这么一个奇人还是

1846
01:03:31,000 --> 01:03:34,000
感兴趣的话有考古兴趣的话可以去了解一下

1847
01:03:34,000 --> 01:03:37,000
对然后选 Poto 另外一个旅游也就是他跟

1848
01:03:37,000 --> 01:03:39,000
他是一个他的主角是个女性嘛

1849
01:03:39,000 --> 01:03:42,000
我觉得这一点对

1850
01:03:42,000 --> 01:03:43,000
对值六位次

1851
01:03:43,000 --> 01:03:48,000
因为我也不知道就在以女性为主角的

1852
01:03:48,000 --> 01:03:50,000
游戏真的不多

1853
01:03:50,000 --> 01:03:53,000
你可能除了那些女性像的

1854
01:03:53,000 --> 01:03:56,000
专门做给女生玩的游戏之外

1855
01:03:56,000 --> 01:03:59,000
专门找一个女性来做主角的

1856
01:03:59,000 --> 01:04:00,000
真的绝无精有

1857
01:04:00,000 --> 01:04:01,000
股不力影

1858
01:04:01,000 --> 01:04:02,000
对

1859
01:04:02,000 --> 01:04:04,000
而且股不力影是一个非常

1860
01:04:06,000 --> 01:04:08,000
就是物化了的在最开始的时候

1861
01:04:08,000 --> 01:04:10,000
股不力影是一个非常

1862
01:04:10,000 --> 01:04:13,000
就做出来给男人看着一个一个一个一个模型

1863
01:04:13,000 --> 01:04:15,000
但是最新一代股不力影大不相同

1864
01:04:15,000 --> 01:04:19,000
但是股不力影最开始的时候就是一个一个

1865
01:04:19,000 --> 01:04:22,000
细腰长腿大胸的妹子手里面拿了两把枪

1866
01:04:22,000 --> 01:04:23,000
然后出现在

1867
01:04:23,000 --> 01:04:25,000
一直在里面见妞啊妞

1868
01:04:25,000 --> 01:04:27,000
对在出现在大臀软件的封面上

1869
01:04:27,000 --> 01:04:30,000
然后让你基本上就是只有男人会去

1870
01:04:30,000 --> 01:04:32,000
会去看着这个

1871
01:04:32,000 --> 01:04:34,000
不知后来就出了那个裸体版吗

1872
01:04:34,000 --> 01:04:35,000
对

1873
01:04:36,000 --> 01:04:37,000
很历史

1874
01:04:39,000 --> 01:04:41,000
我们是怎么能接受那个时代

1875
01:04:41,000 --> 01:04:43,000
640 分分率下来的裸体

1876
01:04:43,000 --> 01:04:44,000
对啊

1877
01:04:44,000 --> 01:04:46,000
上次我还我还跟 Lawrence 吐槽过

1878
01:04:46,000 --> 01:04:49,000
他那个就那个时候的 3 D 特效嘛

1879
01:04:49,000 --> 01:04:52,000
那个汇出来的那个肌肉都是一坨一坨一坨

1880
01:04:52,000 --> 01:04:53,000
有冷脚的嘛

1881
01:04:53,000 --> 01:04:54,000
对

1882
01:04:54,000 --> 01:04:56,000
你会看他的那个胸是一个

1883
01:04:56,000 --> 01:04:58,000
一个圆衰体

1884
01:04:58,000 --> 01:05:00,000
哪是圆衰是一个是一个

1885
01:05:00,000 --> 01:05:01,000
三角角

1886
01:05:01,000 --> 01:05:05,000
四角衰反正就是很奇怪的一个

1887
01:05:05,000 --> 01:05:06,000
一个一个画质

1888
01:05:06,000 --> 01:05:08,000
但现在就大不相同

1889
01:05:08,000 --> 01:05:11,000
不不过 Porto 里面的是看不见

1890
01:05:12,000 --> 01:05:14,000
有一种场合你可以看见

1891
01:05:14,000 --> 01:05:16,000
对你在自己身后开一个 Porto

1892
01:05:16,000 --> 01:05:18,000
对你在自己屁股后面开个 Porto

1893
01:05:18,000 --> 01:05:20,000
或者转角的时候能够看见一个侧脸

1894
01:05:20,000 --> 01:05:22,000
但你肯定是看不见全身本

1895
01:05:22,000 --> 01:05:23,000
就可以端向自己

1896
01:05:24,000 --> 01:05:25,000
对

1897
01:05:25,000 --> 01:05:27,000
然后这个女性也被刻画得非常

1898
01:05:28,000 --> 01:05:32,000
非常非常就像整个游戏的这个

1899
01:05:32,000 --> 01:05:35,000
这个主线就是非常的

1900
01:05:36,000 --> 01:05:37,000
Alienated

1901
01:05:37,000 --> 01:05:39,000
就非常不像一个人

1902
01:05:39,000 --> 01:05:42,000
对他从头到尾都没有一句话对吧

1903
01:05:42,000 --> 01:05:46,000
对这个倒是在 Porto 的 Porto

1904
01:05:46,000 --> 01:05:50,000
其实他是处在那个 Half-Life 的世界里嘛

1905
01:05:50,000 --> 01:05:52,000
Half-Life 的就是半条命

1906
01:05:52,000 --> 01:05:54,000
包括说半衰期

1907
01:05:54,000 --> 01:05:55,000
正确翻译方案

1908
01:05:55,000 --> 01:05:57,000
而半衰期的这个主角

1909
01:05:57,000 --> 01:06:01,000
Golden Freeman 也是 40 之中没有收集一句话的

1910
01:06:01,000 --> 01:06:07,000
就是 Walve 有把主角做成这种沉默的主角的传统

1911
01:06:07,000 --> 01:06:09,000
当然他们可能自己也在取消这一点

1912
01:06:09,000 --> 01:06:12,000
就是在 Porto 2 的有一个地方

1913
01:06:12,000 --> 01:06:16,000
他会让你说 NA 来说 MOK

1914
01:06:16,000 --> 01:06:18,000
然后你 NA 发现你自己跳起来了

1915
01:06:18,000 --> 01:06:23,000
然后和屏幕上的只是完全经本

1916
01:06:23,000 --> 01:06:25,000
然后人工智能会取笑你说

1917
01:06:25,000 --> 01:06:27,000
你很会跳我看到了

1918
01:06:27,000 --> 01:06:28,000
好吧

1919
01:06:28,000 --> 01:06:31,000
好吧我不会再试图叫你说话

1920
01:06:33,000 --> 01:06:36,000
对从来没有说过任何事情

1921
01:06:37,000 --> 01:06:40,000
而且他跟游戏里面也没有什么

1922
01:06:40,000 --> 01:06:41,000
特别的交互

1923
01:06:41,000 --> 01:06:45,000
交互都是拿 Porto 枪去吸起来的

1924
01:06:45,000 --> 01:06:46,000
对

1925
01:06:47,000 --> 01:06:48,000
对还蛮奇怪的

1926
01:06:49,000 --> 01:06:51,000
当然我觉得这个游戏最大的

1927
01:06:51,000 --> 01:06:53,000
可选可点之处还是 Glados

1928
01:06:54,000 --> 01:06:57,000
可能人在所有的游戏里面

1929
01:06:57,000 --> 01:07:00,000
最让人印象深刻的 AI 有两个

1930
01:07:00,000 --> 01:07:01,000
打很排

1931
01:07:01,000 --> 01:07:02,000
对

1932
01:07:02,000 --> 01:07:04,000
印象深刻 AI 有两个

1933
01:07:04,000 --> 01:07:06,000
而且两个碰巧都是女性

1934
01:07:06,000 --> 01:07:09,000
因为是黑漏里面的 Cortana

1935
01:07:09,000 --> 01:07:11,000
或者是微软

1936
01:07:11,000 --> 01:07:12,000
如果不玩黑漏的话

1937
01:07:12,000 --> 01:07:13,000
微软最新出的 Cortana

1938
01:07:13,000 --> 01:07:15,000
就是来自于这个游戏里面的 Cortana

1939
01:07:15,000 --> 01:07:16,000
对

1940
01:07:16,000 --> 01:07:18,000
但那个 Cortana 是有形状的

1941
01:07:18,000 --> 01:07:20,000
而且是有形体的

1942
01:07:20,000 --> 01:07:22,000
就是你可以看到一个东西

1943
01:07:22,000 --> 01:07:25,000
当然这个东西只是他把自己

1944
01:07:25,000 --> 01:07:26,000
把自己

1945
01:07:26,000 --> 01:07:29,000
你可以理解为他是他的交互界面吧

1946
01:07:29,000 --> 01:07:32,000
但至少是个有形体的东西

1947
01:07:32,000 --> 01:07:36,000
而且这个形体也是被逐渐误化的

1948
01:07:36,000 --> 01:07:38,000
就是第一代 Cortana 看起来

1949
01:07:38,000 --> 01:07:39,000
没有什么性别特征

1950
01:07:39,000 --> 01:07:41,000
你只能一期看出来是个女的

1951
01:07:41,000 --> 01:07:45,000
但是最近的一部黑漏里面

1952
01:07:45,000 --> 01:07:48,000
Cortana 也是被塑造成了一个

1953
01:07:48,000 --> 01:07:51,000
精细的大胸长腿的女人

1954
01:07:53,000 --> 01:07:54,000
对

1955
01:07:54,000 --> 01:07:55,000
还是什么

1956
01:07:55,000 --> 01:07:56,000
性别其实还是挺严重的

1957
01:07:56,000 --> 01:07:57,000
没错

1958
01:07:57,000 --> 01:07:58,000
然后

1959
01:07:58,000 --> 01:08:00,000
但是 Glados 就完全不一样

1960
01:08:00,000 --> 01:08:02,000
Glados 就是一个机器

1961
01:08:02,000 --> 01:08:04,000
他只不过有一个女人的声音而已

1962
01:08:04,000 --> 01:08:06,000
但是他的 Personality 是

1963
01:08:06,000 --> 01:08:07,000
中性的吧

1964
01:08:07,000 --> 01:08:08,000
不

1965
01:08:08,000 --> 01:08:09,000
他的 Personality 是

1966
01:08:09,000 --> 01:08:11,000
就是他的性格

1967
01:08:11,000 --> 01:08:15,000
他最开始其实是由 Upshirt Science 的老板

1968
01:08:15,000 --> 01:08:19,000
手下的一个叫 Karoland 的助手

1969
01:08:19,000 --> 01:08:22,000
他把他的性格特征

1970
01:08:22,000 --> 01:08:25,000
进入到了 Glados 里面

1971
01:08:25,000 --> 01:08:26,000
然后 Portal 2 里面

1972
01:08:26,000 --> 01:08:27,000
我记得有一地方

1973
01:08:27,000 --> 01:08:30,000
他主动把这一段回忆给删掉

1974
01:08:30,000 --> 01:08:32,000
就是他拋弃了

1975
01:08:32,000 --> 01:08:35,000
作为那个曾经的人的回忆

1976
01:08:38,000 --> 01:08:40,000
关于 Portal 好像说的有点多

1977
01:08:40,000 --> 01:08:41,000
但是

1978
01:08:41,000 --> 01:08:46,000
总之我对这个游戏有非常深的感情在里面

1979
01:08:46,000 --> 01:08:49,000
所以也决定把它

1980
01:08:49,000 --> 01:08:51,000
作为我们节目的主题曲

1981
01:08:51,000 --> 01:08:53,000
然后

1982
01:08:53,000 --> 01:08:55,000
我们已经看过了

1983
01:08:55,000 --> 01:08:58,000
这个曲子的作者

1984
01:08:58,000 --> 01:09:00,000
把他以

1985
01:09:01,000 --> 01:09:03,000
创作公众授权发布出来

1986
01:09:03,000 --> 01:09:04,000
就是

1987
01:09:04,000 --> 01:09:06,000
这首曲子作者就是

1988
01:09:06,000 --> 01:09:08,000
Johnson Colton

1989
01:09:08,000 --> 01:09:10,000
然后他的

1990
01:09:10,000 --> 01:09:12,000
他的授权是

1991
01:09:12,000 --> 01:09:14,000
CC by

1992
01:09:14,000 --> 01:09:16,000
NC

1993
01:09:16,000 --> 01:09:18,000
就是你必须

1994
01:09:18,000 --> 01:09:20,000
再用到这首歌的时候必须提到

1995
01:09:20,000 --> 01:09:21,000
这个歌是谁写的

1996
01:09:21,000 --> 01:09:23,000
然后就不能把它用作声用度

1997
01:09:23,000 --> 01:09:26,000
我们应该不会把它用作声用度

1998
01:09:26,000 --> 01:09:28,000
我们这个又不拿他来卖

1999
01:09:28,000 --> 01:09:29,000
无所谓

2000
01:09:29,000 --> 01:09:31,000
对我们没有卖我们的节目

2001
01:09:31,000 --> 01:09:33,000
然后我们也

2002
01:09:33,000 --> 01:09:34,000
在可以预显的将来

2003
01:09:34,000 --> 01:09:35,000
不会有

2004
01:09:35,000 --> 01:09:37,000
不会通过做 podcast

2005
01:09:37,000 --> 01:09:39,000
有什么足够多的收入

2006
01:09:39,000 --> 01:09:41,000
所以

2007
01:09:41,000 --> 01:09:42,000
对啊

2008
01:09:42,000 --> 01:09:44,000
你只要不是用他来谋例都可以

2009
01:09:44,000 --> 01:09:45,000
你做个什么小插曲

2010
01:09:45,000 --> 01:09:47,000
而且就算用了

2011
01:09:47,000 --> 01:09:48,000
用了是短时间 30 秒的

2012
01:09:48,000 --> 01:09:49,000
也有那个

2013
01:09:49,000 --> 01:09:50,000
就马上是版权作品

2014
01:09:50,000 --> 01:09:51,000
你也是可以发

2015
01:09:51,000 --> 01:09:52,000
Fair Use 是吗

2016
01:09:52,000 --> 01:09:53,000
对

2017
01:09:53,000 --> 01:09:54,000
Fair Use 是

2018
01:09:54,000 --> 01:09:55,000
对

2019
01:09:55,000 --> 01:09:56,000
Anyway

2020
01:09:56,000 --> 01:09:57,000
总之在 license 方面

2021
01:09:57,000 --> 01:09:58,000
应该是没有什么问题

2022
01:09:58,000 --> 01:09:59,000
我们还是考虑一下

2023
01:09:59,000 --> 01:10:00,000
OK

2024
01:10:00,000 --> 01:10:01,000
所以从

2025
01:10:01,000 --> 01:10:02,000
这一期开始

2026
01:10:02,000 --> 01:10:03,000
我们就有一个

2027
01:10:03,000 --> 01:10:04,000
主题曲了

2028
01:10:04,000 --> 01:10:05,000
大家就不用

2029
01:10:05,000 --> 01:10:06,000
一一开场就觉得

2030
01:10:06,000 --> 01:10:07,000
什么谁

2031
01:10:07,000 --> 01:10:08,000
对

2032
01:10:08,000 --> 01:10:09,000
What

2033
01:10:09,000 --> 01:10:11,000
不会定期听到我的

2034
01:10:11,000 --> 01:10:12,000
What

2035
01:10:14,000 --> 01:10:16,000
好我们终于开始讲

2036
01:10:16,000 --> 01:10:17,000
这一期的正题

2037
01:10:17,000 --> 01:10:18,000
对

2038
01:10:18,000 --> 01:10:19,000
其实我们本来是想把

2039
01:10:19,000 --> 01:10:22,000
这个正题慢慢过渡过来的

2040
01:10:22,000 --> 01:10:24,000
就是刚才提到了

2041
01:10:24,000 --> 01:10:26,000
core dump 提到了

2042
01:10:26,000 --> 01:10:27,000
人工智能

2043
01:10:27,000 --> 01:10:29,000
然后我们想要

2044
01:10:29,000 --> 01:10:32,000
讲的其实就是

2045
01:10:32,000 --> 01:10:33,000
那一条

2046
01:10:33,000 --> 01:10:35,000
Generally

2047
01:10:35,000 --> 01:10:37,000
一个比较 Generally form

2048
01:10:37,000 --> 01:10:39,000
就是生命周期管理

2049
01:10:39,000 --> 01:10:40,000
对

2050
01:10:40,000 --> 01:10:41,000
比如说

2051
01:10:41,000 --> 01:10:42,000
Portal 为什么要

2052
01:10:42,000 --> 01:10:43,000
为什么要

2053
01:10:43,000 --> 01:10:47,000
它为什么要反复提到 science

2054
01:10:47,000 --> 01:10:50,000
或者说为什么要反复提到 test

2055
01:10:50,000 --> 01:10:52,000
其实我觉得它多少有一点

2056
01:10:52,000 --> 01:10:54,000
就是在

2057
01:10:54,000 --> 01:10:57,000
在潮诺或者说在

2058
01:10:57,000 --> 01:11:00,000
套用软件工程里面

2059
01:11:00,000 --> 01:11:02,000
它可以用软件工程的

2060
01:11:02,000 --> 01:11:04,000
做测试这样一个

2061
01:11:04,000 --> 01:11:05,000
QA

2062
01:11:05,000 --> 01:11:06,000
QA

2063
01:11:06,000 --> 01:11:07,000
QA

2064
01:11:07,000 --> 01:11:08,000
QA

2065
01:11:08,000 --> 01:11:09,000
QA

2066
01:11:09,000 --> 01:11:10,000
QA

2067
01:11:10,000 --> 01:11:11,000
QA

2068
01:11:11,000 --> 01:11:12,000
QA

2069
01:11:12,000 --> 01:11:13,000
QA

2070
01:11:13,000 --> 01:11:14,000
QA

2071
01:11:14,000 --> 01:11:15,000
QA

2072
01:11:15,000 --> 01:11:16,000
QA

2073
01:11:16,000 --> 01:11:17,000
QA

2074
01:11:17,000 --> 01:11:18,000
QA

2075
01:11:18,000 --> 01:11:19,000
QA

2076
01:11:19,000 --> 01:11:20,000
QA

2077
01:11:20,000 --> 01:11:21,000
QA

2078
01:11:21,000 --> 01:11:22,000
QA

2079
01:11:22,000 --> 01:11:23,000
QA

2080
01:11:23,000 --> 01:11:24,000
QA

2081
01:11:24,000 --> 01:11:25,000
QA

2082
01:11:25,000 --> 01:11:26,000
QA

2083
01:11:26,000 --> 01:11:27,000
QA

2084
01:11:27,000 --> 01:11:28,000
QA

2085
01:11:28,000 --> 01:11:29,000
QA

2086
01:11:29,000 --> 01:11:30,000
对

2087
01:11:30,000 --> 01:11:32,000
然后

2088
01:11:32,000 --> 01:11:35,000
这个其实就是生命周期管理的一部分

2089
01:11:35,000 --> 01:11:37,000
当然我们可能不会

2090
01:11:37,000 --> 01:11:40,000
我们暂且先不从这么大的角度来说吧

2091
01:11:40,000 --> 01:11:42,000
就是先从

2092
01:11:42,000 --> 01:11:44,000
比较小的

2093
01:11:44,000 --> 01:11:46,000
切入点还着眼

2094
01:11:46,000 --> 01:11:48,000
对

2095
01:11:48,000 --> 01:11:49,000
比如说

2096
01:11:50,000 --> 01:11:52,000
Portal 是一个游戏对吧

2097
01:11:52,000 --> 01:11:53,000
那

2098
01:11:53,000 --> 01:11:55,000
大阪游戏都需要跑

2099
01:11:55,000 --> 01:11:57,000
大阪游戏就和所有程序一样

2100
01:11:57,000 --> 01:11:58,000
都需要跑在计算机上

2101
01:11:58,000 --> 01:12:00,000
然后跑在计算机上的时候

2102
01:12:00,000 --> 01:12:04,000
具体当我们说有一个程序在运行的时候

2103
01:12:04,000 --> 01:12:06,000
所指的到底是什么状态

2104
01:12:06,000 --> 01:12:08,000
其实就是

2105
01:12:10,000 --> 01:12:13,000
我们可以说一个程序在运行的时候

2106
01:12:13,000 --> 01:12:15,000
它活在内存里面

2107
01:12:15,000 --> 01:12:16,000
可以这么说

2108
01:12:16,000 --> 01:12:17,000
可以吧

2109
01:12:17,000 --> 01:12:18,000
我觉得

2110
01:12:18,000 --> 01:12:20,000
当一个程序活在内存里面的时候

2111
01:12:20,000 --> 01:12:21,000
我们就说它正在被运行

2112
01:12:21,000 --> 01:12:24,000
就是一个程序和一个进程的

2113
01:12:24,000 --> 01:12:26,000
具体差异是什么

2114
01:12:26,000 --> 01:12:29,000
一个进程就是活着的程序

2115
01:12:29,000 --> 01:12:31,000
那么程序活着的具体异是什么

2116
01:12:31,000 --> 01:12:34,000
就是它在内存里面并且正在被述行

2117
01:12:34,000 --> 01:12:35,000
或者它正在没有被述行

2118
01:12:35,000 --> 01:12:37,000
但它活在内存里面

2119
01:12:38,000 --> 01:12:39,000
对吧

2120
01:12:40,000 --> 01:12:41,000
所以

2121
01:12:41,000 --> 01:12:43,000
要面临的一个最

2122
01:12:43,000 --> 01:12:45,000
日常我们面临的最常见的一个问题是什么

2123
01:12:45,000 --> 01:12:48,000
就是内存的空间有限吗

2124
01:12:48,000 --> 01:12:49,000
对

2125
01:12:49,000 --> 01:12:50,000
就是内存不够怎么办

2126
01:12:50,000 --> 01:12:51,000
对怎么办

2127
01:12:51,000 --> 01:12:53,000
这个现在可能还好一点

2128
01:12:53,000 --> 01:12:55,000
早期的时候特别明显

2129
01:12:55,000 --> 01:12:57,000
因为现在内存动作就是什么

2130
01:12:57,000 --> 01:12:58,000
4 个 G 8 个 G

2131
01:12:58,000 --> 01:13:00,000
我电脑是 16 个 G 的那时候

2132
01:13:00,000 --> 01:13:01,000
对

2133
01:13:01,000 --> 01:13:04,000
那早期可能大概有多少 512 兆 128 兆的时候

2134
01:13:04,000 --> 01:13:05,000
对

2135
01:13:05,000 --> 01:13:07,000
经常被错误的

2136
01:13:07,000 --> 01:13:11,000
attribute 到 Biergeis 身上的名言是什么

2137
01:13:11,000 --> 01:13:15,000
任何电脑有 640 k 的对策就足够了

2138
01:13:15,000 --> 01:13:16,000
是吧

2139
01:13:16,000 --> 01:13:17,000
其实不是他说的对吧

2140
01:13:17,000 --> 01:13:19,000
其实不是他说的

2141
01:13:19,000 --> 01:13:20,000
而且

2142
01:13:20,000 --> 01:13:22,000
而且到底是谁说的

2143
01:13:22,000 --> 01:13:23,000
好像也没有人找出来的

2144
01:13:23,000 --> 01:13:24,000
反正就是

2145
01:13:24,000 --> 01:13:25,000
反正就是

2146
01:13:25,000 --> 01:13:27,000
反正他就被黑了嘛

2147
01:13:27,000 --> 01:13:28,000
对

2148
01:13:28,000 --> 01:13:29,000
反正大家都喜欢黑他

2149
01:13:29,000 --> 01:13:31,000
跟他脱不了关系了

2150
01:13:34,000 --> 01:13:37,000
为什么 640 k 的那时候就够了

2151
01:13:37,000 --> 01:13:39,000
他那个时候

2152
01:13:39,000 --> 01:13:40,000
九九几年吧

2153
01:13:40,000 --> 01:13:41,000
就是应该出

2154
01:13:41,000 --> 01:13:42,000
确实啊

2155
01:13:42,000 --> 01:13:45,000
你想那个时候有多少一个磁盘

2156
01:13:45,000 --> 01:13:46,000
不叫磁盘 软盘吧

2157
01:13:46,000 --> 01:13:47,000
才多少

2158
01:13:47,000 --> 01:13:48,000
才 720 k 标准的

2159
01:13:48,000 --> 01:13:51,000
后来才翻翻成 1.44 兆嘛

2160
01:13:51,000 --> 01:13:53,000
那年高密

2161
01:13:53,000 --> 01:13:54,000
还灯死你

2162
01:13:54,000 --> 01:13:55,000
对 1.44 兆

2163
01:13:55,000 --> 01:13:56,000
然后有一个

2164
01:13:56,000 --> 01:13:58,000
就你想象一下那个时候

2165
01:13:58,000 --> 01:13:59,000
就就像今天一样

2166
01:13:59,000 --> 01:14:01,000
你的那你的比如你的笔记本的硬盘

2167
01:14:01,000 --> 01:14:03,000
是一个 T 的大小

2168
01:14:03,000 --> 01:14:04,000
然后你有一个 T 的内存

2169
01:14:04,000 --> 01:14:06,000
你当然觉得足够了

2170
01:14:06,000 --> 01:14:07,000
嗯

2171
01:14:07,000 --> 01:14:08,000
对

2172
01:14:08,000 --> 01:14:09,000
但是

2173
01:14:09,000 --> 01:14:10,000
现在后来发现

2174
01:14:10,000 --> 01:14:12,000
哎不对好像不是这样的

2175
01:14:12,000 --> 01:14:13,000
对

2176
01:14:13,000 --> 01:14:14,000
就是随着

2177
01:14:14,000 --> 01:14:17,000
一个程序所需要完成的任务的

2178
01:14:17,000 --> 01:14:19,000
复杂

2179
01:14:19,000 --> 01:14:20,000
逐渐面的复杂

2180
01:14:20,000 --> 01:14:21,000
他

2181
01:14:21,000 --> 01:14:22,000
他所需要的内存

2182
01:14:22,000 --> 01:14:23,000
也就是

2183
01:14:23,000 --> 01:14:25,000
几何几数的

2184
01:14:25,000 --> 01:14:26,000
速度增长

2185
01:14:26,000 --> 01:14:27,000
所以

2186
01:14:27,000 --> 01:14:28,000
呃

2187
01:14:28,000 --> 01:14:29,000
内存不够怎么办

2188
01:14:29,000 --> 01:14:31,000
就变成了一个非常切实的问题

2189
01:14:31,000 --> 01:14:32,000
嗯哼

2190
01:14:32,000 --> 01:14:33,000
所以在一个

2191
01:14:33,000 --> 01:14:35,000
这个要考古的话

2192
01:14:35,000 --> 01:14:36,000
从那个时候最开始

2193
01:14:36,000 --> 01:14:38,000
最开始的操作系统是一个

2194
01:14:38,000 --> 01:14:40,000
就是什么单线单进程的东西啊

2195
01:14:40,000 --> 01:14:41,000
对

2196
01:14:41,000 --> 01:14:42,000
最开始的操作系统

2197
01:14:42,000 --> 01:14:43,000
其实不是个操作系统

2198
01:14:43,000 --> 01:14:44,000
他他

2199
01:14:44,000 --> 01:14:46,000
或者说他没有任何特殊指数

2200
01:14:46,000 --> 01:14:47,000
他只不过就是开机

2201
01:14:47,000 --> 01:14:49,000
这个程序被遵循运行

2202
01:14:49,000 --> 01:14:50,000
然后你可以用这个自动

2203
01:14:50,000 --> 01:14:52,000
用这个程序去找到

2204
01:14:52,000 --> 01:14:53,000
你想要运行的那个程序

2205
01:14:53,000 --> 01:14:55,000
然后运行的那个程序

2206
01:14:55,000 --> 01:14:56,000
在这个过程之中

2207
01:14:56,000 --> 01:14:58,000
你最开始运行的那个程序

2208
01:14:58,000 --> 01:14:59,000
就

2209
01:14:59,000 --> 01:15:00,000
就退出去了

2210
01:15:00,000 --> 01:15:01,000
就不再存在电脑里面了

2211
01:15:01,000 --> 01:15:02,000
然后你

2212
01:15:02,000 --> 01:15:03,000
接下来运行的那个程序

2213
01:15:03,000 --> 01:15:05,000
他独占整个电脑

2214
01:15:05,000 --> 01:15:06,000
他就他认为

2215
01:15:06,000 --> 01:15:08,000
我是活在这个电脑上的

2216
01:15:08,000 --> 01:15:09,000
唯一程序

2217
01:15:09,000 --> 01:15:10,000
而且

2218
01:15:10,000 --> 01:15:11,000
其实

2219
01:15:11,000 --> 01:15:13,000
即便到今天这一点

2220
01:15:13,000 --> 01:15:14,000
多多少少还是成立的

2221
01:15:14,000 --> 01:15:17,000
就是每一个程序都多少认为

2222
01:15:17,000 --> 01:15:19,000
自己拥有整排计算机

2223
01:15:20,000 --> 01:15:21,000
其实这是一个假设

2224
01:15:21,000 --> 01:15:22,000
对

2225
01:15:22,000 --> 01:15:23,000
其实只不过是操作系统

2226
01:15:23,000 --> 01:15:25,000
或者是 CPU

2227
01:15:25,000 --> 01:15:27,000
给它制造出来的一个幻境

2228
01:15:27,000 --> 01:15:28,000
让它活在你的世界

2229
01:15:28,000 --> 01:15:29,000
其实

2230
01:15:29,000 --> 01:15:30,000
对

2231
01:15:30,000 --> 01:15:31,000
在物理意义上

2232
01:15:31,000 --> 01:15:32,000
在实体意义上

2233
01:15:32,000 --> 01:15:34,000
它正在和别人

2234
01:15:34,000 --> 01:15:37,000
共同享用同一块物内存

2235
01:15:37,000 --> 01:15:40,000
这个可能早期用过 DOS 的用户

2236
01:15:40,000 --> 01:15:41,000
还有这个印象

2237
01:15:41,000 --> 01:15:42,000
你看

2238
01:15:42,000 --> 01:15:43,000
开到 DOS

2239
01:15:43,000 --> 01:15:44,000
开到运行进了一个程序

2240
01:15:44,000 --> 01:15:45,000
你要干点别的事

2241
01:15:45,000 --> 01:15:46,000
你还得从那里退出来

2242
01:15:46,000 --> 01:15:47,000
想保存

2243
01:15:47,000 --> 01:15:48,000
然后退出

2244
01:15:48,000 --> 01:15:49,000
另外一个程序

2245
01:15:49,000 --> 01:15:50,000
然后做完那个是保存退出

2246
01:15:50,000 --> 01:15:51,000
再回到之前

2247
01:15:51,000 --> 01:15:54,000
然后后来是在

2248
01:15:54,000 --> 01:15:55,000
Winows 3.2

2249
01:15:55,000 --> 01:15:57,000
还是 95 的时候

2250
01:15:57,000 --> 01:15:58,000
出现了这个

2251
01:15:58,000 --> 01:16:00,000
多任务的这概念

2252
01:16:00,000 --> 01:16:02,000
Winows 3.2 有多任务吗

2253
01:16:02,000 --> 01:16:04,000
我不太清楚

2254
01:16:04,000 --> 01:16:05,000
等一下

2255
01:16:05,000 --> 01:16:07,000
其实我好像没有用 Winows 3.2

2256
01:16:07,000 --> 01:16:09,000
Winows 3.2

2257
01:16:09,000 --> 01:16:11,000
是专门为中国市场做的

2258
01:16:11,000 --> 01:16:12,000
其实就是 Winows 3.2

2259
01:16:12,000 --> 01:16:13,000
其实是一个汉化吧

2260
01:16:13,000 --> 01:16:15,000
Winows 3.1 的汉化吧

2261
01:16:15,000 --> 01:16:16,000
OK

2262
01:16:16,000 --> 01:16:17,000
对

2263
01:16:17,000 --> 01:16:19,000
3.1 有多任务

2264
01:16:19,000 --> 01:16:20,000
我们好像没有吧

2265
01:16:20,000 --> 01:16:22,000
我不并不确切的记得

2266
01:16:22,000 --> 01:16:24,000
自己曾经在 Winows 3.1 的时候

2267
01:16:24,000 --> 01:16:26,000
按过 Out of the Table

2268
01:16:26,000 --> 01:16:28,000
Out of the Table 这个组合

2269
01:16:28,000 --> 01:16:30,000
切换任务的

2270
01:16:30,000 --> 01:16:32,000
应该是没有吧

2271
01:16:32,000 --> 01:16:34,000
但至少很确定

2272
01:16:34,000 --> 01:16:36,000
Winows 9.5 肯定是一个

2273
01:16:36,000 --> 01:16:37,000
多任务的系统

2274
01:16:37,000 --> 01:16:38,000
Winows 9.5

2275
01:16:38,000 --> 01:16:41,000
我还记得我最晚

2276
01:16:41,000 --> 01:16:43,000
是在研究生时代

2277
01:16:43,000 --> 01:16:45,000
还教过一个人

2278
01:16:45,000 --> 01:16:46,000
用 Out of the Table

2279
01:16:46,000 --> 01:16:48,000
切换到其他程序里面去

2280
01:16:48,000 --> 01:16:49,000
他大为惊讶

2281
01:16:49,000 --> 01:16:50,000
你知道吗

2282
01:16:50,000 --> 01:16:52,000
他说原来

2283
01:16:52,000 --> 01:16:53,000
可以这么玩

2284
01:16:53,000 --> 01:16:55,000
原来我切换到

2285
01:16:55,000 --> 01:16:56,000
原来这样按一下

2286
01:16:56,000 --> 01:16:58,000
原来就是我刚才在做的事情

2287
01:16:58,000 --> 01:17:00,000
还在继续被做

2288
01:17:02,000 --> 01:17:04,000
但其实这里也是看

2289
01:17:04,000 --> 01:17:06,000
你看就除了这个程序的认知上

2290
01:17:06,000 --> 01:17:07,000
有一个过渡

2291
01:17:07,000 --> 01:17:10,000
就是我们作为用户的认知上

2292
01:17:10,000 --> 01:17:11,000
其实也是需要一个过渡的

2293
01:17:11,000 --> 01:17:13,000
本来想一个机器

2294
01:17:13,000 --> 01:17:14,000
只能干一件事情

2295
01:17:14,000 --> 01:17:15,000
对吧

2296
01:17:15,000 --> 01:17:16,000
能够同时干几件事情

2297
01:17:16,000 --> 01:17:17,000
还是蛮奇怪的

2298
01:17:17,000 --> 01:17:19,000
一个认知上的变化

2299
01:17:19,000 --> 01:17:20,000
对

2300
01:17:21,000 --> 01:17:23,000
但回到游戏上面

2301
01:17:23,000 --> 01:17:24,000
其实在到此时代

2302
01:17:24,000 --> 01:17:26,000
已经有很多游戏可以

2303
01:17:26,000 --> 01:17:27,000
比如说

2304
01:17:27,000 --> 01:17:28,000
或者说游戏给你观感

2305
01:17:28,000 --> 01:17:30,000
你可以一边放音乐

2306
01:17:30,000 --> 01:17:32,000
至少游戏的背景音乐

2307
01:17:32,000 --> 01:17:33,000
在播放

2308
01:17:33,000 --> 01:17:35,000
然后你还可以操纵里面的人

2309
01:17:35,000 --> 01:17:36,000
在走路

2310
01:17:36,000 --> 01:17:41,000
然后好像也没有那么的让人

2311
01:17:41,000 --> 01:17:43,000
但是起码就是说

2312
01:17:43,000 --> 01:17:45,000
他在对这个东西的认识上

2313
01:17:45,000 --> 01:17:47,000
他在玩这个游戏

2314
01:17:47,000 --> 01:17:48,000
他不能在玩这个游戏的时候

2315
01:17:48,000 --> 01:17:49,000
同时去

2316
01:17:50,000 --> 01:17:51,000
就出了一个什么文字

2317
01:17:51,000 --> 01:17:52,000
编辑

2318
01:17:52,000 --> 01:17:53,000
一个文本之类的

2319
01:17:54,000 --> 01:17:55,000
对

2320
01:17:55,000 --> 01:17:56,000
虽然那个时候也有什么

2321
01:17:56,000 --> 01:17:58,000
常驻内存的工具

2322
01:17:58,000 --> 01:18:00,000
比如说有些游戏修改工具

2323
01:18:00,000 --> 01:18:02,000
会自己缩在内存一角

2324
01:18:02,000 --> 01:18:03,000
然后让你去漏了一个

2325
01:18:04,000 --> 01:18:05,000
按一个什么快捷键

2326
01:18:05,000 --> 01:18:06,000
按一个热键

2327
01:18:06,000 --> 01:18:07,000
整个游戏

2328
01:18:07,000 --> 01:18:10,000
就冻结了那一面

2329
01:18:10,000 --> 01:18:11,000
然后这个时候

2330
01:18:11,000 --> 01:18:13,000
你就可以用这个小工具来修改内存

2331
01:18:13,000 --> 01:18:15,000
然后等你改好的时候

2332
01:18:15,000 --> 01:18:16,000
再重新继续游戏

2333
01:18:16,000 --> 01:18:18,000
其实就是一个第八个

2334
01:18:18,000 --> 01:18:19,000
对

2335
01:18:19,000 --> 01:18:20,000
然后重新游戏

2336
01:18:20,000 --> 01:18:22,000
反正自己忽然有了几万块钱

2337
01:18:24,000 --> 01:18:26,000
有了什么金蝉骨

2338
01:18:27,000 --> 01:18:28,000
对

2339
01:18:28,000 --> 01:18:29,000
这些游戏

2340
01:18:29,000 --> 01:18:31,000
那个时候如此熟悉

2341
01:18:31,000 --> 01:18:33,000
怎么现在好像

2342
01:18:33,000 --> 01:18:35,000
这些工具那个时候

2343
01:18:35,000 --> 01:18:37,000
那么耳熟能相信

2344
01:18:37,000 --> 01:18:38,000
现在好像一个想不出来

2345
01:18:38,000 --> 01:18:39,000
我只想起一个

2346
01:18:39,000 --> 01:18:41,000
只能像那个 PC tools

2347
01:18:41,000 --> 01:18:42,000
我也想不出来

2348
01:18:42,000 --> 01:18:43,000
Anyway

2349
01:18:43,000 --> 01:18:45,000
回头再去考古吧

2350
01:18:45,000 --> 01:18:46,000
好呀

2351
01:18:46,000 --> 01:18:47,000
然后就温度

2352
01:18:47,000 --> 01:18:48,000
就起码我们能够确切的

2353
01:18:48,000 --> 01:18:49,000
叫做温度直转

2354
01:18:49,000 --> 01:18:51,000
我开始搭载一个什么多任务的系统

2355
01:18:51,000 --> 01:18:53,000
不过它那个多任务和我们现在的多任务

2356
01:18:53,000 --> 01:18:56,000
还是在机制上还是有很大不一样的

2357
01:18:57,000 --> 01:18:58,000
它是一个所谓的

2358
01:18:58,000 --> 01:19:00,000
非常认识

2359
01:19:00,000 --> 01:19:02,000
协作式多任务吧

2360
01:19:02,000 --> 01:19:03,000
对

2361
01:19:03,000 --> 01:19:04,000
简单来说就是

2362
01:19:04,000 --> 01:19:06,000
你是一个程序

2363
01:19:06,000 --> 01:19:07,000
我是一个程序

2364
01:19:07,000 --> 01:19:09,000
然后我们两个必须

2365
01:19:09,000 --> 01:19:10,000
比较有默契

2366
01:19:10,000 --> 01:19:12,000
一定要说你放唱吧我登场

2367
01:19:12,000 --> 01:19:14,000
然后我先用

2368
01:19:14,000 --> 01:19:16,000
用到我觉得可以不用的时候

2369
01:19:16,000 --> 01:19:19,000
我要主动放弃机器的控制权

2370
01:19:19,000 --> 01:19:20,000
交给

2371
01:19:20,000 --> 01:19:21,000
交给别人

2372
01:19:21,000 --> 01:19:22,000
对

2373
01:19:22,000 --> 01:19:24,000
这个就有点跟

2374
01:19:24,000 --> 01:19:25,000
做个类比的话

2375
01:19:25,000 --> 01:19:27,000
跟现在哪个事情比较像

2376
01:19:27,000 --> 01:19:29,000
像现在跟那个做

2377
01:19:29,000 --> 01:19:31,000
我觉得像唱 K 一样吧

2378
01:19:31,000 --> 01:19:33,000
就是你

2379
01:19:33,000 --> 01:19:34,000
埋爸

2380
01:19:34,000 --> 01:19:36,000
对你要做埋爸的话

2381
01:19:36,000 --> 01:19:37,000
埋爸这种东西招人讨厌

2382
01:19:37,000 --> 01:19:39,000
就是因为没有一个更强大的

2383
01:19:39,000 --> 01:19:40,000
那个

2384
01:19:40,000 --> 01:19:43,000
一个裁判机制站在那儿说

2385
01:19:43,000 --> 01:19:44,000
你唱够了

2386
01:19:44,000 --> 01:19:45,000
你把埋给我

2387
01:19:45,000 --> 01:19:46,000
我把它给别人

2388
01:19:47,000 --> 01:19:48,000
对

2389
01:19:48,000 --> 01:19:50,000
当时温泽九五就有点像

2390
01:19:50,000 --> 01:19:52,000
一群程序的唱 K

2391
01:19:52,000 --> 01:19:54,000
你唱一会我唱一会

2392
01:19:54,000 --> 01:19:55,000
我们要轮流换对吧

2393
01:19:55,000 --> 01:19:56,000
但如果有一个人

2394
01:19:56,000 --> 01:19:58,000
爸着埋爸不放的话

2395
01:19:58,000 --> 01:20:00,000
有可能就用户就说

2396
01:20:00,000 --> 01:20:02,000
哎呀怎么又没有想赢了

2397
01:20:02,000 --> 01:20:04,000
系统自愿独占了他

2398
01:20:04,000 --> 01:20:06,000
对啊怎么这么卡呀

2399
01:20:06,000 --> 01:20:07,000
重新一下吧

2400
01:20:07,000 --> 01:20:08,000
然后对

2401
01:20:08,000 --> 01:20:09,000
大家都没歌唱

2402
01:20:10,000 --> 01:20:11,000
协作室多人物其实在

2403
01:20:11,000 --> 01:20:13,000
现在我们日常的

2404
01:20:13,000 --> 01:20:14,000
这个编程过程中

2405
01:20:14,000 --> 01:20:16,000
还有一个比较相关的

2406
01:20:16,000 --> 01:20:17,000
一个东西啊就是比如说

2407
01:20:17,000 --> 01:20:18,000
在那个 note 里面

2408
01:20:18,000 --> 01:20:19,000
你要因为 note 是一个

2409
01:20:19,000 --> 01:20:20,000
单进程的东西嘛

2410
01:20:20,000 --> 01:20:21,000
然后你要做一些

2411
01:20:21,000 --> 01:20:23,000
稍微复杂一点的

2412
01:20:23,000 --> 01:20:24,000
或者是需要等待的操作

2413
01:20:24,000 --> 01:20:26,000
比如说你要做 iO 的时候

2414
01:20:26,000 --> 01:20:27,000
你得用一个所谓的这个

2415
01:20:27,000 --> 01:20:28,000
回调嘛 callback

2416
01:20:28,000 --> 01:20:30,000
其实那个时候就是一个

2417
01:20:30,000 --> 01:20:31,000
所谓的这个协作室多人物的

2418
01:20:31,000 --> 01:20:32,000
一个体现

2419
01:20:32,000 --> 01:20:34,000
就说哎我现在能

2420
01:20:34,000 --> 01:20:35,000
我之前能做的那些

2421
01:20:35,000 --> 01:20:36,000
什么加点存出的计算都

2422
01:20:36,000 --> 01:20:37,000
做完了

2423
01:20:37,000 --> 01:20:38,000
现在我要做一个

2424
01:20:38,000 --> 01:20:39,000
可能我不能马上执行东西

2425
01:20:39,000 --> 01:20:41,000
因为等那个 iO 返回嘛

2426
01:20:41,000 --> 01:20:42,000
我先把这个所谓这个

2427
01:20:42,000 --> 01:20:43,000
控制权让出来

2428
01:20:43,000 --> 01:20:44,000
然后我先给你一个回调

2429
01:20:44,000 --> 01:20:46,000
还说等这个东西

2430
01:20:46,000 --> 01:20:48,000
就告诉这个调度器说

2431
01:20:48,000 --> 01:20:51,000
等这个我要的这个 iO

2432
01:20:51,000 --> 01:20:52,000
结果回来之后

2433
01:20:52,000 --> 01:20:53,000
你再换行

2434
01:20:53,000 --> 01:20:55,000
我接着执行这个回调程序

2435
01:20:55,000 --> 01:20:56,000
但现在开始我就把这个

2436
01:20:56,000 --> 01:20:57,000
控制权让出去了

2437
01:20:57,000 --> 01:20:58,000
这个就是一个

2438
01:20:58,000 --> 01:21:00,000
协作多人物的一个体现

2439
01:21:00,000 --> 01:21:01,000
对

2440
01:21:01,000 --> 01:21:02,000
然后在 Windows 95 的时代

2441
01:21:02,000 --> 01:21:03,000
就所有的程序

2442
01:21:03,000 --> 01:21:05,000
你要进行这个系统

2443
01:21:05,000 --> 01:21:06,000
资源的共享的话

2444
01:21:06,000 --> 01:21:09,000
你这是要做类似的事情

2445
01:21:09,000 --> 01:21:11,000
但是那个时候

2446
01:21:11,000 --> 01:21:12,000
其实当我们说到

2447
01:21:12,000 --> 01:21:13,000
Windows 95 的时候

2448
01:21:13,000 --> 01:21:14,000
内存已经不是什么

2449
01:21:14,000 --> 01:21:15,000
太大问题了

2450
01:21:15,000 --> 01:21:17,000
在 Windows 95 之前的

2451
01:21:17,000 --> 01:21:19,000
很长一段时间里面

2452
01:21:19,000 --> 01:21:21,000
怎样优化使用

2453
01:21:21,000 --> 01:21:22,000
现在内存

2454
01:21:22,000 --> 01:21:23,000
简直是

2455
01:21:23,000 --> 01:21:25,000
每一个程序员的必求可

2456
01:21:25,000 --> 01:21:26,000
我觉得 Windows 95 图在

2457
01:21:26,000 --> 01:21:27,000
也是

2458
01:21:27,000 --> 01:21:28,000
就起码到

2459
01:21:28,000 --> 01:21:29,000
到现在都是

2460
01:21:29,000 --> 01:21:30,000
我觉得

2461
01:21:30,000 --> 01:21:33,000
现在其实还是有很多

2462
01:21:33,000 --> 01:21:34,000
就是有些程序员

2463
01:21:34,000 --> 01:21:36,000
可以一辈子不碰

2464
01:21:36,000 --> 01:21:38,000
或者在你的从业过程之中

2465
01:21:38,000 --> 01:21:39,000
可能

2466
01:21:39,000 --> 01:21:42,000
你可以一两年不去碰

2467
01:21:42,000 --> 01:21:44,000
任何和内存管理有关的话题

2468
01:21:44,000 --> 01:21:45,000
比如说

2469
01:21:45,000 --> 01:21:46,000
那个时候是做不到的

2470
01:21:46,000 --> 01:21:47,000
对

2471
01:21:47,000 --> 01:21:48,000
现在的话

2472
01:21:48,000 --> 01:21:49,000
你只要用一个所谓的

2473
01:21:49,000 --> 01:21:51,000
managed language

2474
01:21:51,000 --> 01:21:53,000
就是管理过的语言

2475
01:21:53,000 --> 01:21:54,000
比如说 CeShar

2476
01:21:54,000 --> 01:21:56,000
不用那个什么指针

2477
01:21:56,000 --> 01:21:57,000
不安全指针叫什么

2478
01:21:57,000 --> 01:21:58,000
对

2479
01:21:58,000 --> 01:21:59,000
unsafe

2480
01:21:59,000 --> 01:22:00,000
unsafe pointer 对吧

2481
01:22:00,000 --> 01:22:01,000
然后

2482
01:22:01,000 --> 01:22:03,000
你说你用这个 java

2483
01:22:03,000 --> 01:22:04,000
用 jvm 上面跑

2484
01:22:04,000 --> 01:22:05,000
或者像什么刚才讲 node

2485
01:22:05,000 --> 01:22:06,000
还有像很多这种

2486
01:22:06,000 --> 01:22:07,000
脚本语言拍照都是

2487
01:22:07,000 --> 01:22:09,000
就是你都不需要去

2488
01:22:09,000 --> 01:22:11,000
手工的直接去管理

2489
01:22:11,000 --> 01:22:12,000
分配内存

2490
01:22:12,000 --> 01:22:13,000
这都是这个系统

2491
01:22:13,000 --> 01:22:14,000
或者这个预性识

2492
01:22:14,000 --> 01:22:15,000
帮你解决了

2493
01:22:15,000 --> 01:22:16,000
然后甚至像

2494
01:22:16,000 --> 01:22:17,000
你都是

2495
01:22:17,000 --> 01:22:18,000
这不是手工管理

2496
01:22:18,000 --> 01:22:19,000
包括你不用去申请

2497
01:22:19,000 --> 01:22:21,000
你不用去分配

2498
01:22:21,000 --> 01:22:22,000
然后你也不用去担心

2499
01:22:22,000 --> 01:22:24,000
这个叫什么

2500
01:22:24,000 --> 01:22:25,000
返回的

2501
01:22:25,000 --> 01:22:26,000
不叫返回

2502
01:22:26,000 --> 01:22:27,000
释放的问题

2503
01:22:27,000 --> 01:22:28,000
但是如果你像在

2504
01:22:28,000 --> 01:22:30,000
还是用 C 类的语言

2505
01:22:30,000 --> 01:22:32,000
比如说你用 CeShar

2506
01:22:32,000 --> 01:22:33,000
或者是

2507
01:22:33,000 --> 01:22:34,000
现在大家还在寫

2508
01:22:34,000 --> 01:22:35,000
Obsc

2509
01:22:35,000 --> 01:22:36,000
你还是要在很多程度上

2510
01:22:36,000 --> 01:22:38,000
是要手工管理内存的

2511
01:22:38,000 --> 01:22:39,000
所以现在有什么

2512
01:22:39,000 --> 01:22:40,000
你去考虑这件事情

2513
01:22:40,000 --> 01:22:41,000
这是什么

2514
01:22:41,000 --> 01:22:42,000
就算你不去

2515
01:22:42,000 --> 01:22:43,000
亲自去做这件事

2516
01:22:43,000 --> 01:22:44,000
你这时候去考虑这件事

2517
01:22:44,000 --> 01:22:46,000
swift 还是需要

2518
01:22:46,000 --> 01:22:47,000
手工管理内存吗

2519
01:22:47,000 --> 01:22:48,000
swift 不需要

2520
01:22:48,000 --> 01:22:49,000
OK

2521
01:22:49,000 --> 01:22:51,000
它是一个 managed language

2522
01:22:51,000 --> 01:22:52,000
它是有 GC

2523
01:22:52,000 --> 01:22:53,000
所以在

2524
01:22:53,000 --> 01:22:54,000
手工管理内存的时候

2525
01:22:54,000 --> 01:22:56,000
需要做一些什么事情

2526
01:22:56,000 --> 01:22:57,000
就是我记得那时代

2527
01:22:57,000 --> 01:22:59,000
看过一些手工管理内存的

2528
01:22:59,000 --> 01:23:00,000
书会提到

2529
01:23:00,000 --> 01:23:02,000
比如说你一个程序

2530
01:23:02,000 --> 01:23:05,000
比如说你只有一兆内存可以用

2531
01:23:05,000 --> 01:23:07,000
然后你需要

2532
01:23:07,000 --> 01:23:10,000
调用一堆函数

2533
01:23:10,000 --> 01:23:12,000
所有这些函数加在一起

2534
01:23:12,000 --> 01:23:14,000
可能有两兆

2535
01:23:14,000 --> 01:23:17,000
那怎么办呢

2536
01:23:17,000 --> 01:23:19,000
你可以把

2537
01:23:19,000 --> 01:23:20,000
这个需要时候

2538
01:23:20,000 --> 01:23:21,000
就需要你精进去

2539
01:23:21,000 --> 01:23:23,000
规划函数的分布

2540
01:23:23,000 --> 01:23:25,000
你要把一些函数

2541
01:23:25,000 --> 01:23:27,000
打包包在一个正好是

2542
01:23:27,000 --> 01:23:28,000
比如说

2543
01:23:28,000 --> 01:23:30,000
500 k 的这么一个

2544
01:23:30,000 --> 01:23:32,000
就是动态

2545
01:23:32,000 --> 01:23:33,000
所谓动态库里面吧

2546
01:23:33,000 --> 01:23:35,000
然后你运行

2547
01:23:35,000 --> 01:23:36,000
比如说你再写一个游戏

2548
01:23:36,000 --> 01:23:37,000
然后这个游戏里面

2549
01:23:37,000 --> 01:23:39,000
跑这个关卡的时候

2550
01:23:39,000 --> 01:23:41,000
关卡

2551
01:23:41,000 --> 01:23:43,000
我说对了

2552
01:23:43,000 --> 01:23:44,000
跑这个关卡的时候

2553
01:23:44,000 --> 01:23:45,000
你需要用到这些函数

2554
01:23:45,000 --> 01:23:46,000
那你就

2555
01:23:46,000 --> 01:23:47,000
在这个时候把

2556
01:23:47,000 --> 01:23:49,000
这 512 k 的库

2557
01:23:49,000 --> 01:23:51,000
调入内存

2558
01:23:51,000 --> 01:23:52,000
然后去调用这些函数

2559
01:23:52,000 --> 01:23:53,000
然后等到你

2560
01:23:53,000 --> 01:23:54,000
打完这个关卡之后

2561
01:23:54,000 --> 01:23:55,000
这些函数不需要了

2562
01:23:55,000 --> 01:23:57,000
然后再把另外一个

2563
01:23:57,000 --> 01:23:58,000
函数

2564
01:23:58,000 --> 01:23:59,000
另外一个库调进来

2565
01:23:59,000 --> 01:24:00,000
然后就等于你手工

2566
01:24:00,000 --> 01:24:02,000
要去在你的程序里面

2567
01:24:02,000 --> 01:24:04,000
实现一个内存管理器

2568
01:24:04,000 --> 01:24:06,000
实现一个动态夹杂性

2569
01:24:06,000 --> 01:24:07,000
诸如此类的

2570
01:24:07,000 --> 01:24:09,000
诸如此类的细节

2571
01:24:09,000 --> 01:24:10,000
那个时候我觉得

2572
01:24:10,000 --> 01:24:12,000
哇靠这些都是黑魔法

2573
01:24:12,000 --> 01:24:13,000
实在是

2574
01:24:13,000 --> 01:24:14,000
现在可能也多少

2575
01:24:14,000 --> 01:24:15,000
绝对有点黑魔法

2576
01:24:15,000 --> 01:24:16,000
因为我其实

2577
01:24:16,000 --> 01:24:17,000
个人来讲

2578
01:24:17,000 --> 01:24:18,000
从来没有做过

2579
01:24:18,000 --> 01:24:20,000
任何内存优化方面的东西

2580
01:24:20,000 --> 01:24:22,000
就我就已经长大了

2581
01:24:22,000 --> 01:24:24,000
就已经直接进入机废时代了

2582
01:24:24,000 --> 01:24:25,000
就已经幸运的

2583
01:24:25,000 --> 01:24:26,000
进入了 Gavel Recollection

2584
01:24:26,000 --> 01:24:28,000
无处不在的时代

2585
01:24:28,000 --> 01:24:29,000
而我相信现在

2586
01:24:29,000 --> 01:24:30,000
很多神学院可能

2587
01:24:30,000 --> 01:24:32,000
从入门到尤其是

2588
01:24:32,000 --> 01:24:34,000
如果你不是学

2589
01:24:34,000 --> 01:24:36,000
计算机科班出身的话

2590
01:24:36,000 --> 01:24:38,000
你可能完全有机会

2591
01:24:38,000 --> 01:24:40,000
就是完全没有

2592
01:24:40,000 --> 01:24:42,000
接触过什么是内存管理

2593
01:24:42,000 --> 01:24:43,000
比如说我就是

2594
01:24:43,000 --> 01:24:45,000
我本科读的不是这个

2595
01:24:45,000 --> 01:24:47,000
其实我

2596
01:24:47,000 --> 01:24:48,000
等我接触这些东西的时候

2597
01:24:48,000 --> 01:24:51,000
那些都停留在课本上的概念

2598
01:24:51,000 --> 01:24:52,000
就是我知道

2599
01:24:52,000 --> 01:24:53,000
怎么一回事儿

2600
01:24:53,000 --> 01:24:54,000
原理怎么

2601
01:24:54,000 --> 01:24:55,000
但是我自己其实

2602
01:24:55,000 --> 01:24:57,000
没有亲身去操作过

2603
01:24:57,000 --> 01:24:58,000
那个东西

2604
01:24:58,000 --> 01:25:00,000
这是变相的修年庆福

2605
01:25:00,000 --> 01:25:01,000
不

2606
01:25:01,000 --> 01:25:03,000
这个是变相修这个事情

2607
01:25:03,000 --> 01:25:04,000
底气不足

2608
01:25:04,000 --> 01:25:05,000
不能多说

2609
01:25:05,000 --> 01:25:06,000
好吧

2610
01:25:06,000 --> 01:25:08,000
咱俩其实都比较

2611
01:25:08,000 --> 01:25:09,000
底气不足

2612
01:25:09,000 --> 01:25:10,000
混蛋你是科班出身

2613
01:25:10,000 --> 01:25:12,000
怎么能够说你底气不足

2614
01:25:12,000 --> 01:25:14,000
可我也没有写过

2615
01:25:14,000 --> 01:25:15,000
只一个

2616
01:25:15,000 --> 01:25:16,000
好吧

2617
01:25:16,000 --> 01:25:17,000
我还是做过一点

2618
01:25:17,000 --> 01:25:19,000
但正儿八经的在工作

2619
01:25:19,000 --> 01:25:22,000
或者在实践之中

2620
01:25:22,000 --> 01:25:24,000
利用内存管理的知识

2621
01:25:24,000 --> 01:25:25,000
解决一个实际的问题

2622
01:25:25,000 --> 01:25:26,000
可能绝无见用

2623
01:25:26,000 --> 01:25:27,000
但你之前写

2624
01:25:27,000 --> 01:25:28,000
这个 LS 的时候

2625
01:25:28,000 --> 01:25:29,000
不需要用这个吗

2626
01:25:29,000 --> 01:25:31,000
不需要修工管理内存吗

2627
01:25:31,000 --> 01:25:33,000
这 LS 的所谓管理内存

2628
01:25:33,000 --> 01:25:35,000
你只是需要操心

2629
01:25:35,000 --> 01:25:37,000
不要泄露内存而已

2630
01:25:37,000 --> 01:25:39,000
根本不需要去优化内存使用

2631
01:25:39,000 --> 01:25:40,000
对

2632
01:25:40,000 --> 01:25:41,000
对

2633
01:25:41,000 --> 01:25:43,000
就 LS 已经是一个非常非常先进的

2634
01:25:43,000 --> 01:25:44,000
这个

2635
01:25:44,000 --> 01:25:45,000
或者说

2636
01:25:45,000 --> 01:25:48,000
Object-C Cocoa 这个运行时

2637
01:25:48,000 --> 01:25:50,000
已经是非常非常先进的一套东西

2638
01:25:50,000 --> 01:25:53,000
你不需要去考虑自己的

2639
01:25:53,000 --> 01:25:56,000
Object-C 在内存里面是怎么样对齐的

2640
01:25:56,000 --> 01:25:57,000
或者是

2641
01:25:57,000 --> 01:25:59,000
怎样

2642
01:25:59,000 --> 01:26:01,000
就很多 C 时代

2643
01:26:01,000 --> 01:26:02,000
什么

2644
01:26:02,000 --> 01:26:05,000
这个 Struct-Align 那种东西

2645
01:26:05,000 --> 01:26:06,000
对

2646
01:26:06,000 --> 01:26:07,000
这些东西

2647
01:26:07,000 --> 01:26:08,000
什么 Petting 啊

2648
01:26:08,000 --> 01:26:09,000
什么什么

2649
01:26:09,000 --> 01:26:10,000
乃至

2650
01:26:12,000 --> 01:26:13,000
C 里面还有一种黑魔法

2651
01:26:13,000 --> 01:26:15,000
是使用 Union 类型来

2652
01:26:15,000 --> 01:26:17,000
解决什么东西

2653
01:26:17,000 --> 01:26:18,000
我记得之前

2654
01:26:18,000 --> 01:26:20,000
以前学 C 看老谈的书的时候

2655
01:26:20,000 --> 01:26:22,000
还挺

2656
01:26:22,000 --> 01:26:24,000
对这块还挺觉得挺新奇的

2657
01:26:24,000 --> 01:26:27,000
对那个时候真的是为了省一两个 byte

2658
01:26:27,000 --> 01:26:30,000
可以脚筋脑汁想好走

2659
01:26:30,000 --> 01:26:31,000
那个什么

2660
01:26:31,000 --> 01:26:34,000
真正的 Primature Optimization

2661
01:26:34,000 --> 01:26:36,000
这个已经不是

2662
01:26:36,000 --> 01:26:37,000
我也不知道

2663
01:26:37,000 --> 01:26:39,000
可是那个时代

2664
01:26:39,000 --> 01:26:41,000
你如果不能

2665
01:26:41,000 --> 01:26:43,000
精细的去使用内存的话

2666
01:26:43,000 --> 01:26:45,000
就没有什么多的内存可以给你有了

2667
01:26:45,000 --> 01:26:47,000
对 平常就会直接 OM 了

2668
01:26:47,000 --> 01:26:48,000
对啊

2669
01:26:48,000 --> 01:26:50,000
就没有虚拟存这种东西对吧

2670
01:26:50,000 --> 01:26:53,000
也没有一个运行时

2671
01:26:53,000 --> 01:26:55,000
或者是没有操作系统来替你去

2672
01:26:55,000 --> 01:26:57,000
去操心这些事情

2673
01:26:57,000 --> 01:26:58,000
你只能一切动手

2674
01:26:58,000 --> 01:27:00,000
一切一切的自己动手

2675
01:27:00,000 --> 01:27:02,000
对 其实现在的话

2676
01:27:02,000 --> 01:27:03,000
很多做这个

2677
01:27:03,000 --> 01:27:04,000
Centrum-10 开发的朋友

2678
01:27:04,000 --> 01:27:05,000
他还是要做很多

2679
01:27:05,000 --> 01:27:06,000
这种刚才我们讲的那种工作

2680
01:27:06,000 --> 01:27:08,000
要考虑

2681
01:27:08,000 --> 01:27:09,000
因为 Centrum-10 是一种

2682
01:27:09,000 --> 01:27:11,000
Centrum-10 跑的硬件的水平都非常

2683
01:27:11,000 --> 01:27:13,000
按今天的标准来看

2684
01:27:13,000 --> 01:27:14,000
都是非常糟糕的

2685
01:27:14,000 --> 01:27:16,000
上次我还看说

2686
01:27:16,000 --> 01:27:17,000
现在不是要流行一个

2687
01:27:17,000 --> 01:27:19,000
Internet of Saints

2688
01:27:19,000 --> 01:27:20,000
物联网的时代

2689
01:27:20,000 --> 01:27:22,000
有很多传感器

2690
01:27:22,000 --> 01:27:23,000
这种小芯片什么的

2691
01:27:23,000 --> 01:27:25,000
我上次看 ARM 出了一个

2692
01:27:25,000 --> 01:27:26,000
很常用的芯片

2693
01:27:26,000 --> 01:27:28,000
只有 2 KB 的内存

2694
01:27:30,000 --> 01:27:32,000
就是那种很小的

2695
01:27:32,000 --> 01:27:34,000
传感器的那种好的芯片

2696
01:27:34,000 --> 01:27:36,000
只有 2 KB 的内存想

2697
01:27:36,000 --> 01:27:38,000
怎么用

2698
01:27:38,000 --> 01:27:41,000
而且 2 KB 不仅要装

2699
01:27:42,000 --> 01:27:44,000
装数据还要装成去本身

2700
01:27:44,000 --> 01:27:46,000
它那个存蓄是放在 ROM 里面的

2701
01:27:46,000 --> 01:27:48,000
2 KB 是正儿发行的内存

2702
01:27:48,000 --> 01:27:50,000
对 只是运行用

2703
01:27:50,000 --> 01:27:52,000
但是 2 KB

2704
01:27:53,000 --> 01:27:54,000
我觉得可能

2705
01:27:54,000 --> 01:27:57,000
Centrum-10 开发还有一个

2706
01:27:59,000 --> 01:28:01,000
有一个不那么让它

2707
01:28:01,000 --> 01:28:02,000
更复杂的东西

2708
01:28:02,000 --> 01:28:04,000
就是它很少会涉及到

2709
01:28:04,000 --> 01:28:06,000
从一个更大的存属器上

2710
01:28:06,000 --> 01:28:08,000
调用数据到内存里面

2711
01:28:08,000 --> 01:28:09,000
这样一个动作

2712
01:28:09,000 --> 01:28:11,000
它是直接

2713
01:28:11,000 --> 01:28:13,000
对 您一开始在写的时候

2714
01:28:13,000 --> 01:28:15,000
就知道整个 CPU 的

2715
01:28:15,000 --> 01:28:17,000
或者整个 ROM 的

2716
01:28:17,000 --> 01:28:20,000
整个存属器的分布会是怎么样的

2717
01:28:20,000 --> 01:28:21,000
你有多少东西可以用

2718
01:28:21,000 --> 01:28:23,000
然后里面可能有一个小小的

2719
01:28:23,000 --> 01:28:24,000
不存楼的

2720
01:28:24,000 --> 01:28:25,000
然后其他所有的空间都是你的

2721
01:28:25,000 --> 01:28:27,000
然后主要是放在你的东西

2722
01:28:27,000 --> 01:28:29,000
而且它是一个绝对的单人物的系统

2723
01:28:29,000 --> 01:28:31,000
没有人和你抢

2724
01:28:31,000 --> 01:28:33,000
抢资源什么的

2725
01:28:33,000 --> 01:28:36,000
整个芯片都是你的

2726
01:28:37,000 --> 01:28:39,000
对 规划方面的

2727
01:28:39,000 --> 01:28:41,000
头疼的问题

2728
01:28:41,000 --> 01:28:42,000
可能还少一些

2729
01:28:42,000 --> 01:28:45,000
但是早期的 PCC 变成

2730
01:28:45,000 --> 01:28:47,000
真的是相当复杂的

2731
01:28:47,000 --> 01:28:49,000
这个是我应该说那句话的

2732
01:28:49,000 --> 01:28:51,000
这个芯片我已经为你预留了

2733
01:28:52,000 --> 01:28:54,000
这个芯片我已经承包了

2734
01:28:58,000 --> 01:29:01,000
但是到我们现在的

2735
01:29:01,000 --> 01:29:02,000
一些主流的一些开发的话

2736
01:29:02,000 --> 01:29:03,000
其实这块

2737
01:29:03,000 --> 01:29:04,000
如你所说

2738
01:29:04,000 --> 01:29:06,000
其实是没有什么概念

2739
01:29:06,000 --> 01:29:09,000
甚至说连内存本身的物理尺寸

2740
01:29:09,000 --> 01:29:11,000
都已经被抽象掉了

2741
01:29:11,000 --> 01:29:13,000
就是因为有训练内存的东西

2742
01:29:15,000 --> 01:29:18,000
操作系统给程序展现的是

2743
01:29:18,000 --> 01:29:20,000
一个所谓一个连续的

2744
01:29:20,000 --> 01:29:23,000
庞大的内存的地址空间

2745
01:29:23,000 --> 01:29:25,000
但是其实操作系统的

2746
01:29:25,000 --> 01:29:27,000
在内存实际分配的时候

2747
01:29:27,000 --> 01:29:28,000
并不是说

2748
01:29:28,000 --> 01:29:29,000
真的有无限大的一块内存

2749
01:29:29,000 --> 01:29:31,000
给一个程序使用的对吧

2750
01:29:32,000 --> 01:29:34,000
对 我觉得这个问题

2751
01:29:34,000 --> 01:29:36,000
可以从程序源的角度

2752
01:29:36,000 --> 01:29:38,000
就是从一个操作系统的

2753
01:29:38,000 --> 01:29:40,000
使用者的角度来看

2754
01:29:40,000 --> 01:29:42,000
就是它简化了变成模型

2755
01:29:42,000 --> 01:29:45,000
就是如果没有迅遂存的话

2756
01:29:45,000 --> 01:29:47,000
你将不得不面对

2757
01:29:47,000 --> 01:29:49,000
我的程序应该放在那儿这个问题

2758
01:29:49,000 --> 01:29:50,000
对

2759
01:29:50,000 --> 01:29:53,000
就是我的程序在运行时

2760
01:29:53,000 --> 01:29:56,000
处于内存的什么地方

2761
01:29:56,000 --> 01:29:59,000
难道是一件要我自己来操心的事情吗

2762
01:29:59,000 --> 01:30:00,000
对

2763
01:30:00,000 --> 01:30:01,000
如果没有迅遂存的话

2764
01:30:01,000 --> 01:30:03,000
你将不得不面对这个问题

2765
01:30:03,000 --> 01:30:06,000
就像早期的

2766
01:30:06,000 --> 01:30:10,000
就重新回到了单机程序的

2767
01:30:10,000 --> 01:30:12,000
这么一个状态里面

2768
01:30:12,000 --> 01:30:14,000
就我要和其他的程序共存吗

2769
01:30:14,000 --> 01:30:16,000
因为就像我刚才说的

2770
01:30:16,000 --> 01:30:19,000
修改内存的小工具一样

2771
01:30:19,000 --> 01:30:21,000
它显然是要考虑自己

2772
01:30:21,000 --> 01:30:23,000
要把自己放在什么地方

2773
01:30:23,000 --> 01:30:24,000
然后它必须跟另外一个程序

2774
01:30:24,000 --> 01:30:26,000
共同享用实体内存

2775
01:30:26,000 --> 01:30:27,000
但是迅遂存的时候

2776
01:30:27,000 --> 01:30:28,000
现在就解决这个问题

2777
01:30:28,000 --> 01:30:31,000
简单来说一个程序

2778
01:30:31,000 --> 01:30:32,000
如果它是 32 位的

2779
01:30:32,000 --> 01:30:37,000
它会认为自己有将近 4 G 的内存空间

2780
01:30:37,000 --> 01:30:44,000
就是从 0 X 0008 个 0 吧

2781
01:30:44,000 --> 01:30:45,000
它只有 2 GB 吧

2782
01:30:45,000 --> 01:30:49,000
没有 32 位的就不能到 4 GB 的空间

2783
01:30:49,000 --> 01:30:51,000
32 位不是 4 GB

2784
01:30:51,000 --> 01:30:54,000
但是好像我记得是在

2785
01:30:54,000 --> 01:30:57,000
就超级多位预留到一部分

2786
01:30:57,000 --> 01:31:00,000
对 超级总应该会占用

2787
01:31:00,000 --> 01:31:02,000
超级总会占用一部分地址的空间

2788
01:31:02,000 --> 01:31:03,000
对 但肯定也不到 4 GB 的

2789
01:31:03,000 --> 01:31:06,000
能够实际使用的地址空间

2790
01:31:06,000 --> 01:31:08,000
对 因为它不是从 0 X 000 开始吗

2791
01:31:08,000 --> 01:31:10,000
所以肯定是到不到 4 GB 的

2792
01:31:10,000 --> 01:31:15,000
对 就大概有 3 GB 的空间是可以用的

2793
01:31:15,000 --> 01:31:25,000
对 然后我记得 Windows 上面的

2794
01:31:25,000 --> 01:31:30,000
默认空间好像只有 2 GB 左右

2795
01:31:30,000 --> 01:31:34,000
因为那个时候我记得 Windows 有一个启动参数

2796
01:31:34,000 --> 01:31:38,000
就是你还记得 boot.ini 这个东西吗

2797
01:31:38,000 --> 01:31:39,000
我不知道

2798
01:31:39,000 --> 01:31:40,000
好古鲁

2799
01:31:40,000 --> 01:31:41,000
又暴露年龄了

2800
01:31:41,000 --> 01:31:42,000
就是在 boot.ini 里面

2801
01:31:42,000 --> 01:31:44,000
你可以给 Windows 的启动

2802
01:31:44,000 --> 01:31:47,000
加上一个 slash 3 G 这个选项

2803
01:31:47,000 --> 01:31:51,000
而且这是 XP 都有了一个参数

2804
01:31:51,000 --> 01:31:52,000
对

2805
01:31:52,000 --> 01:31:54,000
你加了这个参数之后

2806
01:31:54,000 --> 01:31:59,000
操作系统的虚拟地址空间

2807
01:31:59,000 --> 01:32:02,000
才会减少到 1 G 应该是

2808
01:32:02,000 --> 01:32:04,000
然后在这种情况下

2809
01:32:04,000 --> 01:32:07,000
程序才有将近 3 G 的空间可以用

2810
01:32:07,000 --> 01:32:08,000
就哪怕是现在

2811
01:32:08,000 --> 01:32:09,000
如果我没记错的话

2812
01:32:09,000 --> 01:32:11,000
现在就比较现在

2813
01:32:11,000 --> 01:32:12,000
我没用过 Windows 8 了

2814
01:32:12,000 --> 01:32:15,000
就之前的 Windows 的机器

2815
01:32:15,000 --> 01:32:16,000
如果它是 32 位的版本的话

2816
01:32:16,000 --> 01:32:19,000
你插上超过 4 G 的内存

2817
01:32:19,000 --> 01:32:20,000
实际可以使用的

2818
01:32:20,000 --> 01:32:21,000
也只有 3 个 Gb

2819
01:32:21,000 --> 01:32:22,000
对

2820
01:32:22,000 --> 01:32:23,000
我记得好像是这样子

2821
01:32:23,000 --> 01:32:24,000
对

2822
01:32:26,000 --> 01:32:27,000
不过后来有个什么扩展

2823
01:32:27,000 --> 01:32:31,000
用 48 位的地址来扩展一下

2824
01:32:31,000 --> 01:32:35,000
然后也可以用到很多

2825
01:32:35,000 --> 01:32:36,000
就超过 4 Gb 的内存

2826
01:32:36,000 --> 01:32:39,000
但这个跟今天的话题没什么关系

2827
01:32:39,000 --> 01:32:40,000
对

2828
01:32:40,000 --> 01:32:41,000
对

2829
01:32:41,000 --> 01:32:43,000
可以这么说吧

2830
01:32:43,000 --> 01:32:46,000
386 这个系列

2831
01:32:46,000 --> 01:32:49,000
就是我们今天所使用的 32 位

2832
01:32:49,000 --> 01:32:51,000
或者说我们曾经在过去

2833
01:32:51,000 --> 01:32:52,000
很长一段时间里面

2834
01:32:52,000 --> 01:32:55,000
所使用的 32 位的 CPU

2835
01:32:55,000 --> 01:33:01,000
其实和最古老的 8086 系列是

2836
01:33:01,000 --> 01:33:04,000
基本可以说是异志兼容的

2837
01:33:04,000 --> 01:33:06,000
但是为了保持这种兼容性

2838
01:33:06,000 --> 01:33:07,000
也不得不付出很多代价

2839
01:33:07,000 --> 01:33:10,000
其中之一就是在

2840
01:33:10,000 --> 01:33:12,000
比如说后面的寻止模式上面

2841
01:33:13,000 --> 01:33:15,000
或者是很多其他地方都有

2842
01:33:15,000 --> 01:33:17,000
不得不做出很多妥协

2843
01:33:17,000 --> 01:33:20,000
然后刚才所说的这个寻止

2844
01:33:20,000 --> 01:33:25,000
其实也是妥协的一种形式

2845
01:33:25,000 --> 01:33:30,000
然后英特尔在推出 64 位处理器的时候

2846
01:33:30,000 --> 01:33:33,000
曾经想要一劳永逸的解决这个问题

2847
01:33:33,000 --> 01:33:34,000
但是

2848
01:33:34,000 --> 01:33:38,000
那个叫做安腾是吧

2849
01:33:38,000 --> 01:33:41,000
对安腾处理器想要解决这个问题

2850
01:33:41,000 --> 01:33:45,000
但是为此要付出一个

2851
01:33:45,000 --> 01:33:50,000
打破向后兼容性的这么一个代价

2852
01:33:50,000 --> 01:33:52,000
所以它最终可持的失败

2853
01:33:52,000 --> 01:33:53,000
对

2854
01:33:53,000 --> 01:33:56,000
假如听众还不太清楚这件事情的话

2855
01:33:56,000 --> 01:33:58,000
我们现在用的所谓 64 位处理器

2856
01:33:58,000 --> 01:34:01,000
其实并不是真正以上的 64 位

2857
01:34:01,000 --> 01:34:07,000
它只是有 AMD 来做出了一个

2858
01:34:07,000 --> 01:34:09,000
64 位系统

2859
01:34:10,000 --> 01:34:12,000
对 它是一个兼容模式

2860
01:34:12,000 --> 01:34:17,000
对 它扩展了我们之前使用 32 位的 CPU

2861
01:34:17,000 --> 01:34:20,000
然后让它可以处理

2862
01:34:20,000 --> 01:34:21,000
就是怎么说呢

2863
01:34:21,000 --> 01:34:26,000
简单来说就是 AMD 64 位的 CPU

2864
01:34:26,000 --> 01:34:29,000
可以运行 32 位的处理器的运用程序

2865
01:34:29,000 --> 01:34:32,000
但是安腾的也是一个纯粹 64 位的处理器

2866
01:34:32,000 --> 01:34:33,000
其实是不行的

2867
01:34:33,000 --> 01:34:36,000
对 这会导致它就有一个什么

2868
01:34:36,000 --> 01:34:37,000
这颗弹的问题

2869
01:34:37,000 --> 01:34:41,000
说你有 64 位的机器了

2870
01:34:41,000 --> 01:34:43,000
可是我们 64 位的程序要跑

2871
01:34:43,000 --> 01:34:45,000
那我要你 64 位机器来干什么

2872
01:34:45,000 --> 01:34:48,000
于是它那个产品线就刮掉了

2873
01:34:48,000 --> 01:34:52,000
对 这就是为什么各位还在用 Windows 的朋友们

2874
01:34:52,000 --> 01:34:57,000
你们的 Program Files 下面会有两个文件

2875
01:34:57,000 --> 01:34:59,000
一个叫做 Program Files

2876
01:34:59,000 --> 01:35:02,000
Program Files X 6 还是 X 3 R

2877
01:35:02,000 --> 01:35:03,000
X 86 吧

2878
01:35:03,000 --> 01:35:04,000
X 86 对

2879
01:35:04,000 --> 01:35:05,000
对

2880
01:35:05,000 --> 01:35:07,000
IAS 3 R X 86

2881
01:35:07,000 --> 01:35:09,000
对 就是这样子

2882
01:35:09,000 --> 01:35:14,000
对 其中一个里面装着 32 位的程序运用程序

2883
01:35:14,000 --> 01:35:17,000
另一个装着的准 64 位的运用程序

2884
01:35:17,000 --> 01:35:21,000
等一下 这个在 32 位版的 Windows 上面有这个区别吗

2885
01:35:21,000 --> 01:35:22,000
我不太清楚

2886
01:35:22,000 --> 01:35:27,000
在 32 位版的 Windows 上面不会有 Program Files

2887
01:35:27,000 --> 01:35:30,000
不不会有 Program Files X 64

2888
01:35:30,000 --> 01:35:35,000
因为 Mode 任就只有 X 86

2889
01:35:35,000 --> 01:35:37,000
对 就只有一个 Program Files

2890
01:35:37,000 --> 01:35:44,000
对 刚才讲到虚拟内存的一个最主要的用途就是让编程的模型解化

2891
01:35:44,000 --> 01:35:48,000
就是不用去考虑说你的东西在哪

2892
01:35:48,000 --> 01:35:53,000
然后这个剩下的调度的问题是交给内核来操作的

2893
01:35:53,000 --> 01:35:54,000
对

2894
01:35:54,000 --> 01:35:56,000
这里就有一个概念叫做 Memory Hierarchy

2895
01:35:56,000 --> 01:36:01,000
就是内存的存储器的等级

2896
01:36:01,000 --> 01:36:04,000
就叫等级

2897
01:36:04,000 --> 01:36:06,000
内存成级

2898
01:36:06,000 --> 01:36:07,000
对

2899
01:36:07,000 --> 01:36:10,000
其实我们知道在这个计算机里面

2900
01:36:10,000 --> 01:36:14,000
内存其实也不是一个非常高级别的 也不叫高级

2901
01:36:14,000 --> 01:36:18,000
就怎么说最快的一个存储设备吧

2902
01:36:18,000 --> 01:36:24,000
最快存储设备其实是在 CPU 里面叫做计存器的东西

2903
01:36:24,000 --> 01:36:25,000
Register

2904
01:36:25,000 --> 01:36:28,000
然后它访问大概是多少一个速度

2905
01:36:28,000 --> 01:36:32,000
在现代的一个 CPU 上

2906
01:36:32,000 --> 01:36:34,000
访问计存器应该就是

2907
01:36:34,000 --> 01:36:36,000
真的 这个有点迷糊了

2908
01:36:36,000 --> 01:36:38,000
0.5 nm

2909
01:36:38,000 --> 01:36:41,000
那个是 L 1

2910
01:36:41,000 --> 01:36:43,000
访问计存器的速度

2911
01:36:43,000 --> 01:36:45,000
对 访问计存器的速度是多少的一个量

2912
01:36:45,000 --> 01:36:47,000
访问计存器需要时间吗

2913
01:36:47,000 --> 01:36:50,000
那肯定是在物理上是需要时间的

2914
01:36:50,000 --> 01:36:52,000
那么它要等电路反应

2915
01:36:52,000 --> 01:36:55,000
但是是一个非常快速的时间

2916
01:36:55,000 --> 01:37:01,000
对 可能只需要几个时钟 几个载口

2917
01:37:01,000 --> 01:37:02,000
不用载口吧

2918
01:37:02,000 --> 01:37:03,000
一个载口就是读到

2919
01:37:03,000 --> 01:37:06,000
一个载口就可以读一个 Register 吗

2920
01:37:06,000 --> 01:37:07,000
这个我不是很确定

2921
01:37:07,000 --> 01:37:11,000
需要回去做工资

2922
01:37:11,000 --> 01:37:15,000
我们暴露出了两个人底气不足的状况

2923
01:37:15,000 --> 01:37:17,000
就是没有做做工资

2924
01:37:17,000 --> 01:37:20,000
毕竟不是 毕竟是个已经很多年了

2925
01:37:20,000 --> 01:37:21,000
我们没有想到

2926
01:37:21,000 --> 01:37:23,000
我们没有想到会讲这么低层

2927
01:37:23,000 --> 01:37:25,000
这个就顺便提一下

2928
01:37:25,000 --> 01:37:28,000
然后在 CPU 内部

2929
01:37:28,000 --> 01:37:31,000
还要一个叫做 LE 就是 Layer 1

2930
01:37:31,000 --> 01:37:35,000
Layer 1 Cache 的这么一个

2931
01:37:35,000 --> 01:37:37,000
就是一几缓存这么一个概念

2932
01:37:37,000 --> 01:37:39,000
一几缓存在现代意义上

2933
01:37:39,000 --> 01:37:41,000
我们是有一个相对好的度量的

2934
01:37:41,000 --> 01:37:43,000
就是大概是 0.5

2935
01:37:43,000 --> 01:37:45,000
Nano second

2936
01:37:45,000 --> 01:37:46,000
Nano second

2937
01:37:46,000 --> 01:37:48,000
一 Nano second

2938
01:37:48,000 --> 01:37:50,000
多少

2939
01:37:50,000 --> 01:37:55,000
一秒等于 10 的 9 字方各 Nano

2940
01:37:55,000 --> 01:37:58,000
然后你访问一个一几缓存的话

2941
01:37:58,000 --> 01:38:00,000
是半个 Nano 的时间

2942
01:38:00,000 --> 01:38:01,000
对

2943
01:38:01,000 --> 01:38:04,000
然后 但如果有一几缓存

2944
01:38:04,000 --> 01:38:05,000
那么自然而然也会有

2945
01:38:05,000 --> 01:38:07,000
所有的二几缓存

2946
01:38:07,000 --> 01:38:09,000
二几缓存在现代 CPU 上

2947
01:38:09,000 --> 01:38:13,000
通常也是在 CPU 芯片上的

2948
01:38:13,000 --> 01:38:15,000
但只是离那个

2949
01:38:15,000 --> 01:38:17,000
所谓的计算的内部

2950
01:38:17,000 --> 01:38:19,000
那个芯片的距离要远一点

2951
01:38:19,000 --> 01:38:22,000
然后它的容量也会稍微大一点

2952
01:38:22,000 --> 01:38:24,000
一几缓存通常也就是一两

2953
01:38:24,000 --> 01:38:28,000
多少 K 吧 32 K 64 K 的 NK

2954
01:38:28,000 --> 01:38:29,000
对

2955
01:38:29,000 --> 01:38:33,000
然后 LE 要大有时候大一点点

2956
01:38:33,000 --> 01:38:37,000
而且 LE 缓存的大小往往

2957
01:38:37,000 --> 01:38:39,000
决定了 CPU 的售价

2958
01:38:39,000 --> 01:38:41,000
LE 也是

2959
01:38:41,000 --> 01:38:43,000
就越大的要依的价格

2960
01:38:43,000 --> 01:38:44,000
一般越贵

2961
01:38:44,000 --> 01:38:45,000
这个肯定是相关的

2962
01:38:45,000 --> 01:38:49,000
因为确实做那个的成本很高

2963
01:38:49,000 --> 01:38:51,000
但是 LE 的话

2964
01:38:51,000 --> 01:38:53,000
通常也是 KB 级别吧

2965
01:38:53,000 --> 01:38:55,000
有时候大一点的服务器的处理器

2966
01:38:55,000 --> 01:38:57,000
回到一两兆 应该是没有问题的

2967
01:38:57,000 --> 01:39:00,000
就每个 core 的 LE 都换车

2968
01:39:00,000 --> 01:39:03,000
但是它的读取的时间

2969
01:39:03,000 --> 01:39:05,000
就会要高一个数量级的

2970
01:39:05,000 --> 01:39:06,000
然后比如说它会在

2971
01:39:06,000 --> 01:39:08,000
可能几个那秒的左右

2972
01:39:08,000 --> 01:39:09,000
比如说这里我们有一个数据

2973
01:39:09,000 --> 01:39:10,000
好 这里是给的

2974
01:39:10,000 --> 01:39:11,000
是 7 个

2975
01:39:11,000 --> 01:39:12,000
这个文档文明证

2976
01:39:12,000 --> 01:39:14,000
这个文档我们会放在

2977
01:39:14,000 --> 01:39:16,000
note 里面

2978
01:39:16,000 --> 01:39:17,000
这个文档也非常重要

2979
01:39:17,000 --> 01:39:19,000
如果你是一个程序员的话

2980
01:39:19,000 --> 01:39:20,000
这个文档的名称叫做

2981
01:39:20,000 --> 01:39:23,000
Latency Numbers Every Program Should Know

2982
01:39:23,000 --> 01:39:24,000
你是这个 program

2983
01:39:24,000 --> 01:39:26,000
所以你 should know

2984
01:39:26,000 --> 01:39:30,000
就 LE 的读取时间大概就是几个那秒左右

2985
01:39:30,000 --> 01:39:32,000
当然还有一些处理机会

2986
01:39:32,000 --> 01:39:34,000
有像什么所谓三级缓存

2987
01:39:34,000 --> 01:39:36,000
没有见过四级缓存的东西

2988
01:39:36,000 --> 01:39:37,000
好像没有

2989
01:39:37,000 --> 01:39:38,000
四级缓存

2990
01:39:38,000 --> 01:39:39,000
就到内存了

2991
01:39:39,000 --> 01:39:41,000
对 四级缓存本来

2992
01:39:41,000 --> 01:39:43,000
应该就已经是很难说

2993
01:39:43,000 --> 01:39:45,000
应该可能也有

2994
01:39:45,000 --> 01:39:46,000
我没有见过实用的系统上

2995
01:39:46,000 --> 01:39:48,000
有四级缓存

2996
01:39:48,000 --> 01:39:51,000
OK CQ 一般最多也就是三

2997
01:39:51,000 --> 01:39:53,000
缓存这个东西一般是会和 CPU

2998
01:39:53,000 --> 01:39:54,000
做在一起的

2999
01:39:54,000 --> 01:39:56,000
对 但是等你

3000
01:39:56,000 --> 01:39:57,000
还不太一样

3001
01:39:57,000 --> 01:39:58,000
三级缓存有很多

3002
01:39:58,000 --> 01:40:00,000
就在主板上面的

3003
01:40:00,000 --> 01:40:01,000
什么

3004
01:40:01,000 --> 01:40:02,000
你还记得吗

3005
01:40:02,000 --> 01:40:04,000
在这个早年就是 90 年代末的时候

3006
01:40:04,000 --> 01:40:06,000
有 LE L 20 在板上了

3007
01:40:06,000 --> 01:40:07,000
这是一个芯片上面

3008
01:40:07,000 --> 01:40:09,000
但是三级缓存有很多这种

3009
01:40:09,000 --> 01:40:10,000
廉价的

3010
01:40:10,000 --> 01:40:11,000
那不叫廉价的主板

3011
01:40:11,000 --> 01:40:12,000
算吧 就是那种

3012
01:40:12,000 --> 01:40:14,000
就平民向的主板

3013
01:40:14,000 --> 01:40:16,000
会把它做在主板上

3014
01:40:16,000 --> 01:40:17,000
对 这样的话

3015
01:40:17,000 --> 01:40:20,000
它就可以买一个比较便宜的 CPU

3016
01:40:20,000 --> 01:40:22,000
不带三级缓存

3017
01:40:22,000 --> 01:40:23,000
对 anyway

3018
01:40:23,000 --> 01:40:25,000
这个是一个工业上的区别

3019
01:40:25,000 --> 01:40:27,000
对 这逻辑上是没有任何区别

3020
01:40:27,000 --> 01:40:28,000
对

3021
01:40:28,000 --> 01:40:31,000
就总体来说缓存越快

3022
01:40:31,000 --> 01:40:33,000
就是这个存储区越快

3023
01:40:33,000 --> 01:40:34,000
它的容量越小

3024
01:40:34,000 --> 01:40:36,000
比如计存器就只有几个 Word 对吧

3025
01:40:36,000 --> 01:40:39,000
在一个现在的 CPU 里面

3026
01:40:39,000 --> 01:40:41,000
就 100 多个计存器

3027
01:40:41,000 --> 01:40:42,000
不得了了

3028
01:40:42,000 --> 01:40:45,000
然后就是大致速度非常快

3029
01:40:45,000 --> 01:40:48,000
但是就价格最贵

3030
01:40:48,000 --> 01:40:50,000
然后一级缓存就几十 K

3031
01:40:50,000 --> 01:40:53,000
价格次值 速度也次值

3032
01:40:53,000 --> 01:40:54,000
然后以此类推

3033
01:40:54,000 --> 01:40:55,000
差不多都是

3034
01:40:55,000 --> 01:40:56,000
对

3035
01:40:56,000 --> 01:41:00,000
每跨越一个缓存的级别

3036
01:41:00,000 --> 01:41:03,000
它就至少是有一个数量级的

3037
01:41:03,000 --> 01:41:07,000
容量和访问速度的变化

3038
01:41:07,000 --> 01:41:08,000
对

3039
01:41:08,000 --> 01:41:09,000
大概是这个意思

3040
01:41:09,000 --> 01:41:11,000
但现在就一般来说

3041
01:41:11,000 --> 01:41:12,000
编程的话

3042
01:41:12,000 --> 01:41:15,000
我们是看不到说一级缓存

3043
01:41:15,000 --> 01:41:17,000
和二级缓存的实体的

3044
01:41:17,000 --> 01:41:18,000
这个是编形的

3045
01:41:18,000 --> 01:41:20,000
对 你们也没有办法去具体的写一个程序

3046
01:41:20,000 --> 01:41:22,000
说这个程序只用了一级缓存

3047
01:41:22,000 --> 01:41:23,000
对

3048
01:41:23,000 --> 01:41:24,000
这是不可能的

3049
01:41:24,000 --> 01:41:25,000
因为这个是在 叫什么

3050
01:41:25,000 --> 01:41:27,000
这个是超级种硬件

3051
01:41:27,000 --> 01:41:28,000
这个是即算是硬件

3052
01:41:28,000 --> 01:41:30,000
帮你去调度解决的问题

3053
01:41:30,000 --> 01:41:31,000
当然你哈

3054
01:41:31,000 --> 01:41:33,000
会边可以做到

3055
01:41:33,000 --> 01:41:35,000
去选择性的使用

3056
01:41:35,000 --> 01:41:37,000
就像什么 聚存器那种东西

3057
01:41:37,000 --> 01:41:38,000
那是另外一说

3058
01:41:38,000 --> 01:41:39,000
对

3059
01:41:39,000 --> 01:41:41,000
但是其实就是说

3060
01:41:41,000 --> 01:41:42,000
对一个普通程序来讲

3061
01:41:42,000 --> 01:41:43,000
暴露给你的

3062
01:41:43,000 --> 01:41:45,000
始终就只是一个内存地址

3063
01:41:45,000 --> 01:41:46,000
这么一个概念

3064
01:41:46,000 --> 01:41:48,000
然后当然我们说内存

3065
01:41:48,000 --> 01:41:49,000
它是一贯机就没了嘛

3066
01:41:49,000 --> 01:41:51,000
所以你还是要把东西放在一个

3067
01:41:51,000 --> 01:41:52,000
可以持久化的存储

3068
01:41:52,000 --> 01:41:53,000
比如说磁板

3069
01:41:53,000 --> 01:41:55,000
或者现在是 SSD 上面去

3070
01:41:55,000 --> 01:41:56,000
但是刚才吴涛也讲

3071
01:41:56,000 --> 01:41:57,000
你要把这些东西

3072
01:41:57,000 --> 01:41:58,000
load 进内存里面

3073
01:41:58,000 --> 01:41:59,000
才可以用

3074
01:41:59,000 --> 01:42:00,000
才有一个地址

3075
01:42:00,000 --> 01:42:01,000
可以执行

3076
01:42:01,000 --> 01:42:02,000
对

3077
01:42:02,000 --> 01:42:04,000
在这个页面上很方便了

3078
01:42:04,000 --> 01:42:05,000
它把这个

3079
01:42:05,000 --> 01:42:06,000
它在下面有一个

3080
01:42:06,000 --> 01:42:08,000
有一个非常形象的类比

3081
01:42:08,000 --> 01:42:09,000
对

3082
01:42:09,000 --> 01:42:13,000
它把所有的时间都成了

3083
01:42:13,000 --> 01:42:16,000
一个 bid

3084
01:42:16,000 --> 01:42:17,000
十亿倍

3085
01:42:17,000 --> 01:42:18,000
对

3086
01:42:18,000 --> 01:42:20,000
那么 in nanosecond

3087
01:42:20,000 --> 01:42:21,000
成上十亿

3088
01:42:21,000 --> 01:42:23,000
就变成了一秒

3089
01:42:23,000 --> 01:42:24,000
对

3090
01:42:24,000 --> 01:42:28,000
那么 le 缓存的存取时间

3091
01:42:28,000 --> 01:42:29,000
大概是半秒钟

3092
01:42:29,000 --> 01:42:31,000
就是心跳一下

3093
01:42:31,000 --> 01:42:32,000
心跳一下

3094
01:42:32,000 --> 01:42:34,000
然后二几缓存的存取时间

3095
01:42:34,000 --> 01:42:35,000
大概是七秒钟

3096
01:42:35,000 --> 01:42:37,000
就是你打一个长长的哈切

3097
01:42:37,000 --> 01:42:39,000
大概二几缓存就到了

3098
01:42:39,000 --> 01:42:40,000
七秒钟

3099
01:42:40,000 --> 01:42:41,000
如果你生活在

3100
01:42:41,000 --> 01:42:42,000
七层级世界里

3101
01:42:42,000 --> 01:42:43,000
可以

3102
01:42:43,000 --> 01:42:44,000
对

3103
01:42:44,000 --> 01:42:45,000
访问内存的时间

3104
01:42:45,000 --> 01:42:46,000
其实

3105
01:42:46,000 --> 01:42:47,000
我们都常常觉得内存

3106
01:42:47,000 --> 01:42:48,000
访问挺快了

3107
01:42:48,000 --> 01:42:49,000
因为比磁盘快多少

3108
01:42:49,000 --> 01:42:50,000
但其实你跟

3109
01:42:50,000 --> 01:42:51,000
像机身器

3110
01:42:51,000 --> 01:42:52,000
1 G 缓存

3111
01:42:52,000 --> 01:42:53,000
2 G 缓存比起来

3112
01:42:53,000 --> 01:42:55,000
还是非常非常慢的

3113
01:42:55,000 --> 01:42:56,000
一个东西

3114
01:42:56,000 --> 01:42:58,000
刚才那个比方

3115
01:42:58,000 --> 01:43:00,000
这里访问内存的话

3116
01:43:00,000 --> 01:43:01,000
现在现代的计算

3117
01:43:01,000 --> 01:43:02,000
计算大概是 100 秒的时候

3118
01:43:02,000 --> 01:43:03,000
对

3119
01:43:03,000 --> 01:43:04,000
如果存上十亿的话

3120
01:43:04,000 --> 01:43:06,000
一两分钟左右

3121
01:43:06,000 --> 01:43:07,000
对

3122
01:43:07,000 --> 01:43:10,000
这段时间已经够你刷牙了

3123
01:43:10,000 --> 01:43:11,000
对

3124
01:43:11,000 --> 01:43:13,000
这个类比还挺有意思的

3125
01:43:13,000 --> 01:43:14,000
大家可以去看一下

3126
01:43:14,000 --> 01:43:15,000
如果

3127
01:43:15,000 --> 01:43:16,000
还有包括像

3128
01:43:16,000 --> 01:43:17,000
如果你发一个数据包

3129
01:43:17,000 --> 01:43:18,000
会怎么样

3130
01:43:18,000 --> 01:43:19,000
就是

3131
01:43:19,000 --> 01:43:20,000
它这里给了一个例子

3132
01:43:20,000 --> 01:43:22,000
就是从加州发一个数据包

3133
01:43:22,000 --> 01:43:23,000
到荷兰

3134
01:43:23,000 --> 01:43:24,000
然后再返回来

3135
01:43:24,000 --> 01:43:25,000
就是一个绕旋

3136
01:43:25,000 --> 01:43:27,000
大概就是五年的时间

3137
01:43:27,000 --> 01:43:29,000
不可想象

3138
01:43:29,000 --> 01:43:30,000
网络是很慢的

3139
01:43:30,000 --> 01:43:31,000
没错

3140
01:43:31,000 --> 01:43:32,000
对

3141
01:43:32,000 --> 01:43:35,000
所以在很多时候里面

3142
01:43:35,000 --> 01:43:37,000
很多场景里面

3143
01:43:37,000 --> 01:43:38,000
就是一个程序

3144
01:43:38,000 --> 01:43:40,000
百无聊耐的在那里死等

3145
01:43:40,000 --> 01:43:42,000
等 I.O

3146
01:43:42,000 --> 01:43:44,000
等对方

3147
01:43:44,000 --> 01:43:46,000
发送一个数据包回来

3148
01:43:46,000 --> 01:43:47,000
对

3149
01:43:47,000 --> 01:43:48,000
这里其实我们也可以看到了

3150
01:43:48,000 --> 01:43:49,000
刚才那个是说

3151
01:43:49,000 --> 01:43:50,000
等网络是很慢的

3152
01:43:50,000 --> 01:43:51,000
当然我们看一下

3153
01:43:51,000 --> 01:43:52,000
等的一个磁盘

3154
01:43:52,000 --> 01:43:54,000
就是访问一个

3155
01:43:54,000 --> 01:43:56,000
磁盘上的文件

3156
01:43:56,000 --> 01:43:57,000
就是读一个文件

3157
01:43:57,000 --> 01:43:58,000
如果它还没有在内存里面的话

3158
01:43:58,000 --> 01:44:00,000
是大概是

3159
01:44:00,000 --> 01:44:02,000
16 周左右

3160
01:44:02,000 --> 01:44:04,000
16 周就是 4 个月吧

3161
01:44:04,000 --> 01:44:05,000
差不多

3162
01:44:05,000 --> 01:44:06,000
对

3163
01:44:06,000 --> 01:44:07,000
如果你学完也蛮客

3164
01:44:07,000 --> 01:44:08,000
对

3165
01:44:08,000 --> 01:44:09,000
所以你看我们现在

3166
01:44:09,000 --> 01:44:10,000
做很多

3167
01:44:10,000 --> 01:44:11,000
做这个什么异步的

3168
01:44:11,000 --> 01:44:12,000
就是现在编程

3169
01:44:12,000 --> 01:44:14,000
很多你要做一些

3170
01:44:14,000 --> 01:44:16,000
就是所谓 I.O. Heavy 的

3171
01:44:16,000 --> 01:44:17,000
一些应用

3172
01:44:17,000 --> 01:44:18,000
像 Node 这种东西

3173
01:44:18,000 --> 01:44:20,000
你都要走异步的方法

3174
01:44:20,000 --> 01:44:21,000
就是因为你可以看到

3175
01:44:21,000 --> 01:44:24,000
如果你每次 I.O.都要等同步的话

3176
01:44:24,000 --> 01:44:26,000
你这个程序就没法玩了

3177
01:44:26,000 --> 01:44:27,000
对

3178
01:44:27,000 --> 01:44:28,000
你无心之中浪费了

3179
01:44:28,000 --> 01:44:30,000
非常非常多保卫的 CPU

3180
01:44:30,000 --> 01:44:32,000
大部分时间都是在显示的

3181
01:44:35,000 --> 01:44:39,000
所以有 Memory 内存的层级

3182
01:44:39,000 --> 01:44:40,000
就是要

3183
01:44:40,000 --> 01:44:42,000
如果我们直接把这么多层级

3184
01:44:42,000 --> 01:44:44,000
暴露给开发久的话

3185
01:44:44,000 --> 01:44:45,000
显然这个软件工程

3186
01:44:45,000 --> 01:44:46,000
就不用玩了

3187
01:44:46,000 --> 01:44:47,000
天哪里

3188
01:44:47,000 --> 01:44:48,000
第 8 个内存错

3189
01:44:48,000 --> 01:44:50,000
内存的问题都已经够你

3190
01:44:50,000 --> 01:44:52,000
玩上去这次了

3191
01:44:52,000 --> 01:44:54,000
所以我们把这东西通过

3192
01:44:54,000 --> 01:44:55,000
像一些

3193
01:44:55,000 --> 01:44:56,000
首先比如说

3194
01:44:56,000 --> 01:44:57,000
硬件上

3195
01:44:57,000 --> 01:44:59,000
层面上直接隐藏掉

3196
01:44:59,000 --> 01:45:00,000
一级二级缓存

3197
01:45:00,000 --> 01:45:02,000
然后通过这个虚拟内存

3198
01:45:02,000 --> 01:45:04,000
这个干人隐藏掉

3199
01:45:04,000 --> 01:45:06,000
磁盘和内存之间的区别

3200
01:45:06,000 --> 01:45:07,000
这样的话

3201
01:45:07,000 --> 01:45:09,000
可以把这个编程模型大幅度解化

3202
01:45:09,000 --> 01:45:10,000
让我们这种

3203
01:45:10,000 --> 01:45:11,000
平庸之辈

3204
01:45:11,000 --> 01:45:13,000
也能够开开心心的写上程序

3205
01:45:16,000 --> 01:45:17,000
或者应该是

3206
01:45:17,000 --> 01:45:18,000
应该反过来说

3207
01:45:18,000 --> 01:45:19,000
应该是

3208
01:45:19,000 --> 01:45:21,000
这种进化之会存在

3209
01:45:21,000 --> 01:45:22,000
是因为

3210
01:45:22,000 --> 01:45:23,000
试图让平庸之辈

3211
01:45:23,000 --> 01:45:24,000
写出来的程序

3212
01:45:24,000 --> 01:45:25,000
也可以在

3213
01:45:25,000 --> 01:45:27,000
也可以比较体面的跑在那上

3214
01:45:27,000 --> 01:45:29,000
否则真的是慢得不得了

3215
01:45:29,000 --> 01:45:31,000
或者说是直接就 crash 掉

3216
01:45:31,000 --> 01:45:32,000
对

3217
01:45:33,000 --> 01:45:34,000
不过这里就

3218
01:45:34,000 --> 01:45:35,000
其实还是牵涉到

3219
01:45:35,000 --> 01:45:36,000
有一个概念就是

3220
01:45:36,000 --> 01:45:38,000
为什么我们要分

3221
01:45:38,000 --> 01:45:40,000
这么多内存的

3222
01:45:40,000 --> 01:45:41,000
层级

3223
01:45:42,000 --> 01:45:43,000
其实也就是因为穷嘛

3224
01:45:43,000 --> 01:45:44,000
对

3225
01:45:44,000 --> 01:45:46,000
因为内存造价实在是太高了

3226
01:45:46,000 --> 01:45:47,000
就是你如果

3227
01:45:47,000 --> 01:45:48,000
大家都做成

3228
01:45:48,000 --> 01:45:50,000
首先物理上做不到

3229
01:45:50,000 --> 01:45:51,000
因为你要做成技存器的话

3230
01:45:51,000 --> 01:45:53,000
你得所有东西都在那个新片里面

3231
01:45:53,000 --> 01:45:54,000
对吧

3232
01:45:54,000 --> 01:45:56,000
但是得靠近那个什么技术元气

3233
01:45:56,000 --> 01:45:57,000
件

3234
01:45:57,000 --> 01:45:58,000
那个物理空间是有限的

3235
01:45:58,000 --> 01:45:59,000
也不可能做到

3236
01:45:59,000 --> 01:46:00,000
第二个就是说

3237
01:46:00,000 --> 01:46:01,000
就如果能做到

3238
01:46:01,000 --> 01:46:02,000
比如说

3239
01:46:02,000 --> 01:46:03,000
我们都用

3240
01:46:03,000 --> 01:46:05,000
把一击缓存做成 500 招

3241
01:46:05,000 --> 01:46:07,000
而且能做成一个击

3242
01:46:08,000 --> 01:46:09,000
也可以

3243
01:46:09,000 --> 01:46:10,000
但是

3244
01:46:10,000 --> 01:46:12,000
这个成本就不吃天文数字了

3245
01:46:12,000 --> 01:46:13,000
不可以想象

3246
01:46:13,000 --> 01:46:14,000
对 可能

3247
01:46:15,000 --> 01:46:17,000
比尔盖斯也只能买两台而已

3248
01:46:18,000 --> 01:46:20,000
买了起半台都不错了

3249
01:46:21,000 --> 01:46:22,000
但是

3250
01:46:23,000 --> 01:46:25,000
就是说内存层级搞这么复杂

3251
01:46:25,000 --> 01:46:26,000
也是为了像

3252
01:46:26,000 --> 01:46:28,000
现实的一个妥协嘛

3253
01:46:28,000 --> 01:46:29,000
就是在

3254
01:46:29,000 --> 01:46:30,000
我们怎么把这个东西做

3255
01:46:30,000 --> 01:46:31,000
尽量便宜那么

3256
01:46:31,000 --> 01:46:33,000
越慢的东西越便宜对吧

3257
01:46:33,000 --> 01:46:34,000
对

3258
01:46:34,000 --> 01:46:35,000
那就慢一点

3259
01:46:35,000 --> 01:46:37,000
那就要通过这种

3260
01:46:37,000 --> 01:46:39,000
分层级的方式来隐藏掉

3261
01:46:39,000 --> 01:46:41,000
我们实际上用一个很便宜

3262
01:46:41,000 --> 01:46:42,000
很慢的一个设备

3263
01:46:42,000 --> 01:46:43,000
对

3264
01:46:43,000 --> 01:46:45,000
然后把剩余的好钢都

3265
01:46:45,000 --> 01:46:46,000
用在刀上

3266
01:46:46,000 --> 01:46:47,000
不刀尖上

3267
01:46:48,000 --> 01:46:49,000
其实我刚才

3268
01:46:49,000 --> 01:46:50,000
想了一下

3269
01:46:51,000 --> 01:46:52,000
假设一个晶圆

3270
01:46:52,000 --> 01:46:54,000
一个圆形的晶圆

3271
01:46:54,000 --> 01:46:57,000
完全用来做缓存

3272
01:46:58,000 --> 01:46:59,000
大概要多少钱呢

3273
01:47:00,000 --> 01:47:01,000
一个晶圆片吗

3274
01:47:02,000 --> 01:47:03,000
对

3275
01:47:03,000 --> 01:47:05,000
就整个一大片晶圆

3276
01:47:05,000 --> 01:47:07,000
做成一个缓存

3277
01:47:08,000 --> 01:47:09,000
然后像太阳能板那样

3278
01:47:09,000 --> 01:47:10,000
装在什么地方

3279
01:47:10,000 --> 01:47:11,000
然后把它

3280
01:47:12,000 --> 01:47:14,000
把它插在 CPU 的什么地方

3281
01:47:15,000 --> 01:47:16,000
这个我还不太

3282
01:47:16,000 --> 01:47:17,000
可恶

3283
01:47:17,000 --> 01:47:18,000
首先有个物理的限制

3284
01:47:18,000 --> 01:47:21,000
你访问它的速度是很定的

3285
01:47:22,000 --> 01:47:24,000
打发你变大了之后

3286
01:47:24,000 --> 01:47:26,000
你访问边缘上的那一部分

3287
01:47:26,000 --> 01:47:27,000
必然是要等的

3288
01:47:28,000 --> 01:47:29,000
那就把它做出立体的吧

3289
01:47:30,000 --> 01:47:31,000
对我小时候有这种

3290
01:47:31,000 --> 01:47:32,000
雨水的想法

3291
01:47:32,000 --> 01:47:33,000
没错

3292
01:47:33,000 --> 01:47:34,000
这是一个很好的想法

3293
01:47:34,000 --> 01:47:35,000
三维步线

3294
01:47:35,000 --> 01:47:36,000
对 三维步线

3295
01:47:36,000 --> 01:47:37,000
也是一个很常用的思路

3296
01:47:37,000 --> 01:47:38,000
但是问题就是说

3297
01:47:38,000 --> 01:47:39,000
这个始终是一个

3298
01:47:39,000 --> 01:47:40,000
你无非是从二维变成了三维

3299
01:47:40,000 --> 01:47:42,000
你的这个种的空间始终

3300
01:47:42,000 --> 01:47:43,000
还是有限

3301
01:47:43,000 --> 01:47:45,000
就不可能无限制的

3302
01:47:45,000 --> 01:47:48,000
不管是从物理限时的角度考虑

3303
01:47:48,000 --> 01:47:49,000
还是从一个经济的角度考虑

3304
01:47:49,000 --> 01:47:51,000
都一定是存在这么一个

3305
01:47:51,000 --> 01:47:53,000
不同等级的存储

3306
01:47:53,000 --> 01:47:56,000
都要访问时间和容量的限制

3307
01:47:57,000 --> 01:47:58,000
除非你在

3308
01:47:58,000 --> 01:47:59,000
可以在非常微小的尺度上

3309
01:47:59,000 --> 01:48:01,000
开一大堆 Portals

3310
01:48:01,000 --> 01:48:02,000
然后

3311
01:48:02,000 --> 01:48:04,000
可以开高维空间

3312
01:48:05,000 --> 01:48:06,000
就彻底解决了

3313
01:48:06,000 --> 01:48:07,000
访问速度的问题

3314
01:48:08,000 --> 01:48:09,000
这个作弊了

3315
01:48:10,000 --> 01:48:12,000
回到我们正常的限时世界

3316
01:48:12,000 --> 01:48:13,000
对

3317
01:48:13,000 --> 01:48:16,000
但有一个挺麻烦的问题

3318
01:48:16,000 --> 01:48:17,000
就是说内存

3319
01:48:17,000 --> 01:48:19,000
我们现在用的主要的内存

3320
01:48:19,000 --> 01:48:21,000
它是一个叫做意识性的内存

3321
01:48:21,000 --> 01:48:23,000
叫做 Volatile 的内存

3322
01:48:23,000 --> 01:48:24,000
什么意思呢

3323
01:48:24,000 --> 01:48:26,000
Volatile 这个词本意是挥发吧

3324
01:48:26,000 --> 01:48:27,000
我记得

3325
01:48:27,000 --> 01:48:28,000
对

3326
01:48:28,000 --> 01:48:29,000
就是挥发的意思

3327
01:48:29,000 --> 01:48:30,000
挥化肥 挥挥发

3328
01:48:31,000 --> 01:48:32,000
内存挥挥发

3329
01:48:33,000 --> 01:48:34,000
就是这个意思

3330
01:48:34,000 --> 01:48:35,000
对

3331
01:48:35,000 --> 01:48:36,000
所谓的意识性就是说

3332
01:48:36,000 --> 01:48:38,000
你一旦断电之后

3333
01:48:38,000 --> 01:48:39,000
内存里面存的东西

3334
01:48:39,000 --> 01:48:40,000
BIR 就没有了

3335
01:48:40,000 --> 01:48:41,000
对

3336
01:48:41,000 --> 01:48:42,000
BIR 这么快

3337
01:48:42,000 --> 01:48:43,000
就因为我记得

3338
01:48:43,000 --> 01:48:45,000
还是有个残留的

3339
01:48:45,000 --> 01:48:46,000
对

3340
01:48:46,000 --> 01:48:47,000
2010 年左右

3341
01:48:47,000 --> 01:48:48,000
有一群

3342
01:48:49,000 --> 01:48:52,000
有一个安全实验室的人展示了

3343
01:48:52,000 --> 01:48:53,000
一个电脑关机之后

3344
01:48:53,000 --> 01:48:55,000
立刻用液弹去

3345
01:48:55,000 --> 01:48:56,000
冷冻它

3346
01:48:56,000 --> 01:48:57,000
应该没有液弹吧

3347
01:48:57,000 --> 01:48:58,000
应该没有液弹

3348
01:48:58,000 --> 01:49:00,000
是液弹吗

3349
01:49:00,000 --> 01:49:01,000
就是立刻把它冷冻住

3350
01:49:01,000 --> 01:49:05,000
然后去直接搜内存里面的数据

3351
01:49:05,000 --> 01:49:07,000
然后还能读出来些许的

3352
01:49:07,000 --> 01:49:08,000
对

3353
01:49:08,000 --> 01:49:12,000
它可以把电子的状态

3354
01:49:12,000 --> 01:49:13,000
在低温状态下

3355
01:49:13,000 --> 01:49:15,000
能够维持一段时间吗

3356
01:49:15,000 --> 01:49:16,000
对

3357
01:49:16,000 --> 01:49:17,000
对

3358
01:49:17,000 --> 01:49:18,000
然后回忆

3359
01:49:18,000 --> 01:49:19,000
我们刚才讲的 Latency

3360
01:49:20,000 --> 01:49:22,000
这些所有的数据都在东面

3361
01:49:23,000 --> 01:49:24,000
东面了十几年

3362
01:49:24,000 --> 01:49:27,000
然后被挖出来了

3363
01:49:27,000 --> 01:49:28,000
对

3364
01:49:28,000 --> 01:49:29,000
但是

3365
01:49:30,000 --> 01:49:31,000
我们日常就出开

3366
01:49:31,000 --> 01:49:32,000
刚才无法讲那种

3367
01:49:32,000 --> 01:49:34,000
极端变态的场景之外

3368
01:49:34,000 --> 01:49:35,000
但正常情况下

3369
01:49:35,000 --> 01:49:36,000
你断电之后

3370
01:49:36,000 --> 01:49:37,000
内存的东西的数据

3371
01:49:37,000 --> 01:49:38,000
已经没有了

3372
01:49:38,000 --> 01:49:39,000
就清零了

3373
01:49:39,000 --> 01:49:40,000
对

3374
01:49:40,000 --> 01:49:41,000
然后你在通电的时候里面

3375
01:49:41,000 --> 01:49:42,000
它这些什么

3376
01:49:42,000 --> 01:49:43,000
不记得了

3377
01:49:44,000 --> 01:49:46,000
这个很明显就是一个问题

3378
01:49:46,000 --> 01:49:47,000
比如说你电脑关机之后

3379
01:49:47,000 --> 01:49:48,000
什么资料都没有了

3380
01:49:48,000 --> 01:49:49,000
那你搞什么

3381
01:49:49,000 --> 01:49:50,000
白搞了

3382
01:49:50,000 --> 01:49:51,000
对

3383
01:49:51,000 --> 01:49:54,000
这也就是我们为什么会需要软盘

3384
01:49:54,000 --> 01:49:56,000
或者说需要外置磁盘这种东西

3385
01:49:56,000 --> 01:49:57,000
对

3386
01:49:57,000 --> 01:49:58,000
就是一盘

3387
01:49:58,000 --> 01:49:59,000
之前的软盘也好

3388
01:49:59,000 --> 01:50:00,000
它都是一个所谓的

3389
01:50:00,000 --> 01:50:02,000
non-volatile 的存储界

3390
01:50:02,000 --> 01:50:04,000
非意识性的存储

3391
01:50:04,000 --> 01:50:06,000
断电之后还在

3392
01:50:06,000 --> 01:50:07,000
对

3393
01:50:07,000 --> 01:50:10,000
但其实这两个中间是有一定的

3394
01:50:10,000 --> 01:50:11,000
障碍的

3395
01:50:11,000 --> 01:50:12,000
刚才我们讲的

3396
01:50:12,000 --> 01:50:13,000
因为计算机并

3397
01:50:13,000 --> 01:50:15,000
就起码操作系统并不能直接

3398
01:50:15,000 --> 01:50:16,000
执行硬盘上面的东西

3399
01:50:16,000 --> 01:50:18,000
它得先读到内存里面去

3400
01:50:18,000 --> 01:50:19,000
所以每次都会有这么一个

3401
01:50:19,000 --> 01:50:21,000
很变态的这么一个

3402
01:50:21,000 --> 01:50:22,000
读取

3403
01:50:22,000 --> 01:50:23,000
然后写内存

3404
01:50:23,000 --> 01:50:25,000
然后的一个过程

3405
01:50:25,000 --> 01:50:26,000
然后

3406
01:50:26,000 --> 01:50:27,000
作为一个软件的开发者来讲

3407
01:50:27,000 --> 01:50:29,000
你也要做一些很奇怪的事情

3408
01:50:29,000 --> 01:50:30,000
比如说

3409
01:50:30,000 --> 01:50:32,000
我们做这个

3410
01:50:32,000 --> 01:50:34,000
所谓会有一个序略化解

3411
01:50:34,000 --> 01:50:35,000
序略化的东西

3412
01:50:35,000 --> 01:50:37,000
你把一个数据文件

3413
01:50:37,000 --> 01:50:39,000
读到内存中

3414
01:50:39,000 --> 01:50:40,000
然后你要保存的时候

3415
01:50:40,000 --> 01:50:41,000
你还得想办法

3416
01:50:41,000 --> 01:50:43,000
它把它写回磁盘

3417
01:50:43,000 --> 01:50:44,000
然后写回磁盘的中间

3418
01:50:44,000 --> 01:50:46,000
你都会想怎么把内存中的一个结构

3419
01:50:46,000 --> 01:50:49,000
变成磁盘上面的一个

3420
01:50:49,000 --> 01:50:51,000
一组的二斤制的流

3421
01:50:51,000 --> 01:50:52,000
对吧

3422
01:50:52,000 --> 01:50:53,000
对

3423
01:50:53,000 --> 01:50:55,000
不一定是二一之的

3424
01:50:55,000 --> 01:50:56,000
但

3425
01:50:56,000 --> 01:50:57,000
最后

3426
01:50:57,000 --> 01:50:59,000
最后不会变成一种

3427
01:50:59,000 --> 01:51:01,000
就核心要点是说

3428
01:51:01,000 --> 01:51:03,000
这个数据结构在内存中

3429
01:51:03,000 --> 01:51:06,000
是存在一定形态的一个方式

3430
01:51:06,000 --> 01:51:07,000
和结构组织

3431
01:51:07,000 --> 01:51:08,000
通过这个指针的方式

3432
01:51:08,000 --> 01:51:09,000
对

3433
01:51:09,000 --> 01:51:10,000
你不是想办法把这个结构

3434
01:51:10,000 --> 01:51:12,000
转化为某种

3435
01:51:12,000 --> 01:51:14,000
可以复原的

3436
01:51:14,000 --> 01:51:17,000
一个字节串

3437
01:51:17,000 --> 01:51:19,000
或者是二斤制的串

3438
01:51:19,000 --> 01:51:20,000
对

3439
01:51:20,000 --> 01:51:21,000
所以有这么一个

3440
01:51:21,000 --> 01:51:22,000
序略化解序略化的过程

3441
01:51:22,000 --> 01:51:23,000
其实这点

3442
01:51:23,000 --> 01:51:25,000
是挺折腾的

3443
01:51:25,000 --> 01:51:26,000
就是为什么

3444
01:51:26,000 --> 01:51:27,000
假设你想想

3445
01:51:27,000 --> 01:51:29,000
如果我们把内存作为

3446
01:51:29,000 --> 01:51:30,000
做成一个叫做

3447
01:51:30,000 --> 01:51:32,000
非意识的

3448
01:51:32,000 --> 01:51:33,000
就是内存关机之后

3449
01:51:33,000 --> 01:51:34,000
它在开

3450
01:51:34,000 --> 01:51:35,000
就断电之后再通电

3451
01:51:35,000 --> 01:51:36,000
还能记住之前内容

3452
01:51:36,000 --> 01:51:37,000
那你想象一下

3453
01:51:37,000 --> 01:51:38,000
我们这个日常使用的

3454
01:51:38,000 --> 01:51:40,000
计算机就是一个很爽的状态

3455
01:51:40,000 --> 01:51:41,000
开机不用等

3456
01:51:41,000 --> 01:51:43,000
你想不用的时候按掉

3457
01:51:43,000 --> 01:51:44,000
拔掉电源线

3458
01:51:44,000 --> 01:51:45,000
就是你不用关机

3459
01:51:45,000 --> 01:51:46,000
电池拔掉的没问题

3460
01:51:46,000 --> 01:51:48,000
然后你插电之后

3461
01:51:48,000 --> 01:51:50,000
又回到那个画面了

3462
01:51:50,000 --> 01:51:51,000
一模一样

3463
01:51:51,000 --> 01:51:52,000
我有个问题

3464
01:51:52,000 --> 01:51:53,000
就是比如说

3465
01:51:53,000 --> 01:51:54,000
MP 3 不放弃

3466
01:51:54,000 --> 01:51:56,000
或者是

3467
01:51:56,000 --> 01:51:58,000
就比如说

3468
01:51:58,000 --> 01:51:59,000
单片机有

3469
01:51:59,000 --> 01:52:01,000
有些单片机使用

3470
01:52:01,000 --> 01:52:03,000
的存储器的确是

3471
01:52:03,000 --> 01:52:04,000
非

3472
01:52:04,000 --> 01:52:05,000
non-volatile

3473
01:52:05,000 --> 01:52:07,000
对有这种

3474
01:52:07,000 --> 01:52:08,000
有很

3475
01:52:08,000 --> 01:52:10,000
这种叫什么

3476
01:52:10,000 --> 01:52:11,000
比较小的情况下

3477
01:52:11,000 --> 01:52:13,000
它会有这种应用

3478
01:52:13,000 --> 01:52:14,000
就是它能够关掉

3479
01:52:14,000 --> 01:52:15,000
然后重启之后

3480
01:52:15,000 --> 01:52:16,000
它还在那个状态

3481
01:52:16,000 --> 01:52:17,000
对

3482
01:52:17,000 --> 01:52:18,000
所以这种机器

3483
01:52:18,000 --> 01:52:20,000
实际上是没有

3484
01:52:20,000 --> 01:52:22,000
这个问题存在的

3485
01:52:22,000 --> 01:52:24,000
就是它无所谓

3486
01:52:24,000 --> 01:52:25,000
什么东西

3487
01:52:25,000 --> 01:52:26,000
它完全不会区分

3488
01:52:26,000 --> 01:52:28,000
什么是一个程序

3489
01:52:28,000 --> 01:52:29,000
在运行的状态

3490
01:52:29,000 --> 01:52:30,000
以及什么是一个程序

3491
01:52:30,000 --> 01:52:33,000
被折疊起来的

3492
01:52:33,000 --> 01:52:34,000
对

3493
01:52:34,000 --> 01:52:35,000
被折疊起来

3494
01:52:35,000 --> 01:52:36,000
被存储起来的状态

3495
01:52:36,000 --> 01:52:37,000
对

3496
01:52:37,000 --> 01:52:38,000
就是如果它是用这种

3497
01:52:38,000 --> 01:52:39,000
非意识性的内存

3498
01:52:39,000 --> 01:52:40,000
它就是真的

3499
01:52:40,000 --> 01:52:41,000
可以做到这一点

3500
01:52:41,000 --> 01:52:42,000
而且

3501
01:52:42,000 --> 01:52:43,000
但是这个硬件上

3502
01:52:43,000 --> 01:52:44,000
具体怎么样

3503
01:52:44,000 --> 01:52:45,000
我们先不说

3504
01:52:45,000 --> 01:52:46,000
但我们就只讨论这种

3505
01:52:46,000 --> 01:52:47,000
这种如果

3506
01:52:47,000 --> 01:52:48,000
这种是一个主流的方式

3507
01:52:48,000 --> 01:52:49,000
到我们作为一个

3508
01:52:49,000 --> 01:52:50,000
开发者

3509
01:52:50,000 --> 01:52:51,000
作为一个程序员

3510
01:52:51,000 --> 01:52:52,000
的编程模型就很爽了

3511
01:52:52,000 --> 01:52:53,000
比如说

3512
01:52:53,000 --> 01:52:54,000
你不用想什么

3513
01:52:54,000 --> 01:52:56,000
什么持久化

3514
01:52:56,000 --> 01:52:57,000
就经常我们现在

3515
01:52:57,000 --> 01:52:58,000
比如说做什么

3516
01:52:58,000 --> 01:52:59,000
后端开发

3517
01:52:59,000 --> 01:53:00,000
比如说内存

3518
01:53:00,000 --> 01:53:02,000
这个机器死机了

3519
01:53:02,000 --> 01:53:03,000
就服务器当机了

3520
01:53:03,000 --> 01:53:04,000
我内存中的数据

3521
01:53:04,000 --> 01:53:05,000
不就没了吗

3522
01:53:05,000 --> 01:53:06,000
我又没写到

3523
01:53:06,000 --> 01:53:07,000
那磁盘上面不就丢了吗

3524
01:53:07,000 --> 01:53:08,000
对吧

3525
01:53:08,000 --> 01:53:09,000
就会有这种

3526
01:53:09,000 --> 01:53:10,000
很担心

3527
01:53:10,000 --> 01:53:11,000
然后会用各种方法

3528
01:53:11,000 --> 01:53:13,000
去想办法

3529
01:53:13,000 --> 01:53:14,000
掩盖

3530
01:53:14,000 --> 01:53:15,000
就是去处理

3531
01:53:15,000 --> 01:53:16,000
针对这种内存

3532
01:53:16,000 --> 01:53:17,000
收进已经处理

3533
01:53:17,000 --> 01:53:18,000
但是如果你的内存

3534
01:53:18,000 --> 01:53:19,000
是非意识的话

3535
01:53:19,000 --> 01:53:20,000
就很爽了

3536
01:53:20,000 --> 01:53:21,000
那就直接

3537
01:53:21,000 --> 01:53:23,000
再重启一下

3538
01:53:23,000 --> 01:53:24,000
对吧

3539
01:53:24,000 --> 01:53:25,000
还就再通电

3540
01:53:25,000 --> 01:53:27,000
还是那个状态

3541
01:53:27,000 --> 01:53:28,000
我们也不用去考虑

3542
01:53:28,000 --> 01:53:30,000
什么序列化解

3543
01:53:30,000 --> 01:53:31,000
序列化就开机干讲

3544
01:53:31,000 --> 01:53:32,000
序列化解决

3545
01:53:32,000 --> 01:53:33,000
就是要

3546
01:53:33,000 --> 01:53:34,000
就是我们开机

3547
01:53:34,000 --> 01:53:36,000
要等那么长的一个时间

3548
01:53:36,000 --> 01:53:37,000
的最主要的原因

3549
01:53:37,000 --> 01:53:38,000
你要等那个东西

3550
01:53:38,000 --> 01:53:39,000
从磁盘上

3551
01:53:39,000 --> 01:53:40,000
夹着的内存里面去

3552
01:53:40,000 --> 01:53:41,000
要把那个

3553
01:53:41,000 --> 01:53:43,000
一个序列化的一个压宿

3554
01:53:43,000 --> 01:53:44,000
你可以想象

3555
01:53:44,000 --> 01:53:45,000
它比较压缩

3556
01:53:45,000 --> 01:53:46,000
变成一个

3557
01:53:46,000 --> 01:53:47,000
转写的结构

3558
01:53:47,000 --> 01:53:49,000
再变成内存中的一个结构

3559
01:53:49,000 --> 01:53:50,000
这个是要花时间

3560
01:53:50,000 --> 01:53:51,000
等的

3561
01:53:51,000 --> 01:53:52,000
但是序列化

3562
01:53:52,000 --> 01:53:53,000
其实还有另外一个用途

3563
01:53:53,000 --> 01:53:54,000
或者说序列化

3564
01:53:54,000 --> 01:53:56,000
也比较主要的用途

3565
01:53:56,000 --> 01:53:57,000
就是数据传输

3566
01:53:57,000 --> 01:53:58,000
为了传输数据

3567
01:53:58,000 --> 01:53:59,000
你不得不把它

3568
01:54:00,000 --> 01:54:01,000
序列化

3569
01:54:01,000 --> 01:54:03,000
就是传输媒介本身是

3570
01:54:03,000 --> 01:54:04,000
传输的时候

3571
01:54:04,000 --> 01:54:05,000
肯定是要进行序列化

3572
01:54:05,000 --> 01:54:06,000
但是就是说

3573
01:54:06,000 --> 01:54:07,000
如果你是作为一个

3574
01:54:07,000 --> 01:54:08,000
比如说你操系统

3575
01:54:08,000 --> 01:54:09,000
你每天启动的时候

3576
01:54:09,000 --> 01:54:10,000
你不需要和别人传输

3577
01:54:10,000 --> 01:54:11,000
什么的

3578
01:54:11,000 --> 01:54:12,000
你这操系统不是从另外一个

3579
01:54:12,000 --> 01:54:14,000
网络上传过来的吗

3580
01:54:14,000 --> 01:54:15,000
对吧

3581
01:54:15,000 --> 01:54:16,000
大部分情况下

3582
01:54:16,000 --> 01:54:17,000
但也有那种什么 Netboot

3583
01:54:17,000 --> 01:54:19,000
那个情况再说

3584
01:54:19,000 --> 01:54:20,000
就说

3585
01:54:20,000 --> 01:54:23,000
你启动你的电脑的时候

3586
01:54:23,000 --> 01:54:25,000
你的操系统是不需要等网络

3587
01:54:25,000 --> 01:54:26,000
才能启动的

3588
01:54:26,000 --> 01:54:27,000
所以

3589
01:54:27,000 --> 01:54:28,000
所以这个时候

3590
01:54:28,000 --> 01:54:29,000
如果我们能做到一个

3591
01:54:29,000 --> 01:54:30,000
非议师的内存的话

3592
01:54:30,000 --> 01:54:31,000
一切都是爽

3593
01:54:31,000 --> 01:54:33,000
开机就可以有了

3594
01:54:33,000 --> 01:54:34,000
关机就可以走了

3595
01:54:36,000 --> 01:54:38,000
但传统上这个是做

3596
01:54:38,000 --> 01:54:39,000
传统上我们做不到

3597
01:54:39,000 --> 01:54:40,000
因为也是一个

3598
01:54:40,000 --> 01:54:42,000
工业现实和成本的考量

3599
01:54:43,000 --> 01:54:44,000
非议师的内存是有的

3600
01:54:44,000 --> 01:54:46,000
但是一个是比较贵

3601
01:54:46,000 --> 01:54:47,000
然后另外一个就是

3602
01:54:47,000 --> 01:54:48,000
它的访问速度

3603
01:54:48,000 --> 01:54:50,000
存取速度不尽如人意

3604
01:54:51,000 --> 01:54:52,000
最大的问题就还是太慢了

3605
01:54:53,000 --> 01:54:54,000
对 慢和贵

3606
01:54:54,000 --> 01:54:56,000
就是要么都是

3607
01:54:56,000 --> 01:54:57,000
要么就是

3608
01:54:57,000 --> 01:54:59,000
你要求其中一个的臂臂

3609
01:54:59,000 --> 01:55:01,000
然后最近有一个

3610
01:55:01,000 --> 01:55:03,000
所谓的什么地

3611
01:55:03,000 --> 01:55:04,000
你知道传统那么

3612
01:55:04,000 --> 01:55:05,000
三大类电容

3613
01:55:05,000 --> 01:55:07,000
不叫什么电器

3614
01:55:07,000 --> 01:55:10,000
电容电组和电导

3615
01:55:10,000 --> 01:55:12,000
就是导线呗

3616
01:55:12,000 --> 01:55:13,000
不是三大元气键吗

3617
01:55:13,000 --> 01:55:14,000
我记得

3618
01:55:14,000 --> 01:55:15,000
三大导线

3619
01:55:15,000 --> 01:55:17,000
电容电组和电

3620
01:55:17,000 --> 01:55:19,000
其实这块

3621
01:55:19,000 --> 01:55:21,000
马上就要暴露出

3622
01:55:21,000 --> 01:55:23,000
这个是 9 倍不足的

3623
01:55:23,000 --> 01:55:24,000
因为这个

3624
01:55:24,000 --> 01:55:25,000
因为不是做 1

3625
01:55:25,000 --> 01:55:26,000
不是做 1 1 的

3626
01:55:26,000 --> 01:55:27,000
这块真的是完全不太懂

3627
01:55:27,000 --> 01:55:28,000
但是

3628
01:55:28,000 --> 01:55:29,000
我的电路不考过

3629
01:55:30,000 --> 01:55:31,000
我都没学过

3630
01:55:31,000 --> 01:55:33,000
你比我还好

3631
01:55:33,000 --> 01:55:34,000
还比我还好一些

3632
01:55:34,000 --> 01:55:35,000
不 反正就是

3633
01:55:35,000 --> 01:55:37,000
传统上有那么那几种

3634
01:55:37,000 --> 01:55:38,000
元气键

3635
01:55:38,000 --> 01:55:40,000
电组 电容 电感

3636
01:55:40,000 --> 01:55:41,000
没错

3637
01:55:41,000 --> 01:55:42,000
还是三大类没记错

3638
01:55:42,000 --> 01:55:43,000
所以存在说

3639
01:55:43,000 --> 01:55:45,000
第四类的这种元气键

3640
01:55:45,000 --> 01:55:46,000
英文叫做

3641
01:55:46,000 --> 01:55:48,000
Memory

3642
01:55:48,000 --> 01:55:50,000
Memory

3643
01:55:50,000 --> 01:55:52,000
Memory

3644
01:55:52,000 --> 01:55:53,000
然后中文

3645
01:55:53,000 --> 01:55:55,000
这里为几百课的发音叫做

3646
01:55:55,000 --> 01:55:57,000
易祖气

3647
01:55:57,000 --> 01:55:59,000
就是记忆的意义

3648
01:55:59,000 --> 01:56:00,000
然后

3649
01:56:00,000 --> 01:56:01,000
电阻的阻

3650
01:56:01,000 --> 01:56:02,000
易祖气

3651
01:56:02,000 --> 01:56:03,000
对 它有一些

3652
01:56:03,000 --> 01:56:05,000
它有一些奇怪的

3653
01:56:05,000 --> 01:56:07,000
这种物理学电气的特性

3654
01:56:07,000 --> 01:56:09,000
然后我是看不太懂

3655
01:56:09,000 --> 01:56:10,000
但是我知道

3656
01:56:10,000 --> 01:56:12,000
它的作用是什么

3657
01:56:12,000 --> 01:56:14,000
就是对于一个程序员来讲

3658
01:56:14,000 --> 01:56:15,000
它的作用就可以让你

3659
01:56:15,000 --> 01:56:16,000
实现所谓的

3660
01:56:16,000 --> 01:56:17,000
刚刚讲

3661
01:56:17,000 --> 01:56:19,000
一个是非易诗的内存

3662
01:56:20,000 --> 01:56:21,000
这是对我来说

3663
01:56:21,000 --> 01:56:22,000
很重要的一点

3664
01:56:22,000 --> 01:56:23,000
然后这个

3665
01:56:24,000 --> 01:56:25,000
就可以实现说

3666
01:56:25,000 --> 01:56:27,000
你的内存和你的硬盘

3667
01:56:27,000 --> 01:56:28,000
是同一个气节

3668
01:56:29,000 --> 01:56:31,000
对 这是非常非常对

3669
01:56:31,000 --> 01:56:32,000
粗听没什么

3670
01:56:32,000 --> 01:56:34,000
但其实是一个非常重要的

3671
01:56:35,000 --> 01:56:37,000
如果这个东西可以被

3672
01:56:37,000 --> 01:56:38,000
研发出来

3673
01:56:38,000 --> 01:56:39,000
并且大规模使用的话

3674
01:56:39,000 --> 01:56:41,000
它将会彻底改变

3675
01:56:41,000 --> 01:56:42,000
我们变成模型

3676
01:56:42,000 --> 01:56:43,000
对

3677
01:56:43,000 --> 01:56:44,000
然后另外一个

3678
01:56:44,000 --> 01:56:46,000
更牛逼的用途

3679
01:56:46,000 --> 01:56:47,000
但是现在我这个

3680
01:56:47,000 --> 01:56:48,000
还是没太搞明白

3681
01:56:48,000 --> 01:56:49,000
这个就也是因为什么

3682
01:56:49,000 --> 01:56:51,000
电气功

3683
01:56:51,000 --> 01:56:52,000
这叫电气工程

3684
01:56:52,000 --> 01:56:53,000
电气工程基础

3685
01:56:53,000 --> 01:56:54,000
不够好的一个元素

3686
01:56:54,000 --> 01:56:55,000
电子工程

3687
01:56:55,000 --> 01:56:56,000
电子工程

3688
01:56:56,000 --> 01:56:58,000
这个不去纠结

3689
01:56:58,000 --> 01:57:00,000
那么多细节的名词

3690
01:57:00,000 --> 01:57:01,000
对 还有一个就是说

3691
01:57:01,000 --> 01:57:02,000
它这个易主气

3692
01:57:02,000 --> 01:57:05,000
可以取代那种传统的电路

3693
01:57:05,000 --> 01:57:06,000
就是我们传统的

3694
01:57:06,000 --> 01:57:08,000
组合的方式

3695
01:57:08,000 --> 01:57:09,000
比如说你要做一个

3696
01:57:09,000 --> 01:57:10,000
那个什么 NAND gate

3697
01:57:11,000 --> 01:57:12,000
你可以用这个

3698
01:57:12,000 --> 01:57:13,000
去构成一种

3699
01:57:13,000 --> 01:57:15,000
那种计算的元气件

3700
01:57:15,000 --> 01:57:17,000
然后它会实现更小的体积

3701
01:57:17,000 --> 01:57:19,000
然后更

3702
01:57:19,000 --> 01:57:20,000
就更低的功耗吧

3703
01:57:20,000 --> 01:57:21,000
大概是这个意思

3704
01:57:22,000 --> 01:57:23,000
但是这个对

3705
01:57:23,000 --> 01:57:24,000
计算来讲

3706
01:57:24,000 --> 01:57:25,000
就对它

3707
01:57:25,000 --> 01:57:26,000
它所暴露出来的

3708
01:57:26,000 --> 01:57:27,000
边际模型的改变

3709
01:57:27,000 --> 01:57:28,000
我觉得这个要小一些

3710
01:57:28,000 --> 01:57:30,000
这个是从硬面层面的

3711
01:57:30,000 --> 01:57:32,000
就 CPU 的模型

3712
01:57:32,000 --> 01:57:33,000
暴露出来的使用模型

3713
01:57:33,000 --> 01:57:34,000
是没有变化的

3714
01:57:34,000 --> 01:57:35,000
这使用模型就是说

3715
01:57:35,000 --> 01:57:36,000
对于一个

3716
01:57:36,000 --> 01:57:37,000
普通开发者来讲

3717
01:57:37,000 --> 01:57:38,000
可能最大的变化还是说

3718
01:57:38,000 --> 01:57:40,000
没有这个

3719
01:57:40,000 --> 01:57:43,000
这个内存和这个磁盘

3720
01:57:43,000 --> 01:57:44,000
就没有

3721
01:57:44,000 --> 01:57:47,000
然后一回发现的内存

3722
01:57:47,000 --> 01:57:49,000
和不一回发现的内存的区别

3723
01:57:49,000 --> 01:57:52,000
就是你可以不去再去考虑

3724
01:57:52,000 --> 01:57:54,000
内存管理和从四排开门

3725
01:57:54,000 --> 01:57:55,000
调问文件

3726
01:57:55,000 --> 01:57:57,000
对 因为就只有内存管理

3727
01:57:57,000 --> 01:57:58,000
这一件事

3728
01:57:58,000 --> 01:58:00,000
对 而且那个时候也不用

3729
01:58:00,000 --> 01:58:01,000
刚才讲了也不用考虑

3730
01:58:01,000 --> 01:58:02,000
序列化解序列化的东西

3731
01:58:02,000 --> 01:58:04,000
因为你直接操作的

3732
01:58:04,000 --> 01:58:07,000
就是内存中的这个数据结构

3733
01:58:07,000 --> 01:58:08,000
然后这个数据结构关机

3734
01:58:08,000 --> 01:58:11,000
后也是会被持久化下来的

3735
01:58:11,000 --> 01:58:12,000
存下来的

3736
01:58:12,000 --> 01:58:13,000
然后这样

3737
01:58:13,000 --> 01:58:14,000
你开机的女孩

3738
01:58:14,000 --> 01:58:16,000
还是回到那个程序原先的状态

3739
01:58:16,000 --> 01:58:17,000
这样的话

3740
01:58:17,000 --> 01:58:21,000
不是 就可以在物理层面

3741
01:58:21,000 --> 01:58:22,000
层面上实现

3742
01:58:22,000 --> 01:58:24,000
我们现在用操作系统

3743
01:58:24,000 --> 01:58:26,000
通过虚拟内存来做的事情

3744
01:58:26,000 --> 01:58:27,000
对

3745
01:58:27,000 --> 01:58:29,000
我觉得这个对编程模型的改变

3746
01:58:29,000 --> 01:58:30,000
还是蛮大的

3747
01:58:30,000 --> 01:58:32,000
不过这边其实也有一些问题

3748
01:58:32,000 --> 01:58:33,000
就是说如果你讲

3749
01:58:33,000 --> 01:58:35,000
假设这个内存是

3750
01:58:35,000 --> 01:58:37,000
叫做非一师的话

3751
01:58:37,000 --> 01:58:40,000
那么如果中间哪里错了

3752
01:58:40,000 --> 01:58:43,000
然后导致那个内存状态不对

3753
01:58:43,000 --> 01:58:46,000
就这个结果还是蛮奇怪的

3754
01:58:46,000 --> 01:58:48,000
对 忽然之间你好像没有一个

3755
01:58:48,000 --> 01:58:51,000
非常好的手段去 reset 了

3756
01:58:51,000 --> 01:58:52,000
对

3757
01:58:52,000 --> 01:58:54,000
就以前那个叫什么

3758
01:58:54,000 --> 01:58:56,000
IT crowd 里面尝试

3759
01:58:59,000 --> 01:59:01,000
对 就是遇到问题

3760
01:59:01,000 --> 01:59:03,000
现在重开机重启试试了

3761
01:59:03,000 --> 01:59:04,000
重启没问题

3762
01:59:04,000 --> 01:59:05,000
就还可以

3763
01:59:05,000 --> 01:59:07,000
因为重启就掉电了

3764
01:59:07,000 --> 01:59:08,000
掉电的话

3765
01:59:08,000 --> 01:59:09,000
这些重来

3766
01:59:09,000 --> 01:59:13,000
就有一个所谓的 clean start

3767
01:59:13,000 --> 01:59:15,000
对 就是如果

3768
01:59:15,000 --> 01:59:17,000
计算机是一个状态机的话

3769
01:59:17,000 --> 01:59:18,000
那么重启

3770
01:59:18,000 --> 01:59:19,000
就可以让它回复到

3771
01:59:19,000 --> 01:59:20,000
状态机的原点

3772
01:59:20,000 --> 01:59:22,000
一般来说

3773
01:59:22,000 --> 01:59:24,000
程序不稳定都是

3774
01:59:24,000 --> 01:59:25,000
这个状态机走进了一个

3775
01:59:25,000 --> 01:59:27,000
没有被遇见的状态里面去

3776
01:59:27,000 --> 01:59:28,000
但是通过重启

3777
01:59:28,000 --> 01:59:30,000
你可以让它重新回到

3778
01:59:30,000 --> 01:59:32,000
至少是造计算机的人

3779
01:59:32,000 --> 01:59:33,000
所预想的

3780
01:59:33,000 --> 01:59:35,000
可以被控制

3781
01:59:35,000 --> 01:59:36,000
并且也知道

3782
01:59:36,000 --> 01:59:38,000
它可以走向何处的地方

3783
01:59:38,000 --> 01:59:39,000
所以

3784
01:59:39,000 --> 01:59:41,000
但是如果这样讲

3785
01:59:41,000 --> 01:59:42,000
如果是一个内存是

3786
01:59:42,000 --> 01:59:43,000
肺一事的话

3787
01:59:43,000 --> 01:59:44,000
这一点就行不通了

3788
01:59:44,000 --> 01:59:45,000
就还肯定要采取一些

3789
01:59:45,000 --> 01:59:47,000
极端的手段来做

3790
01:59:47,000 --> 01:59:49,000
灾难恢复

3791
01:59:49,000 --> 01:59:51,000
还是故障修复之类的事情

3792
01:59:51,000 --> 01:59:53,000
对

3793
01:59:53,000 --> 01:59:55,000
不过 但是这个样子讲

3794
01:59:55,000 --> 01:59:58,000
不管是用 memraster

3795
01:59:58,000 --> 01:59:59,000
memraster

3796
01:59:59,000 --> 02:00:00,000
一组气

3797
02:00:00,000 --> 02:00:03,000
还是说通过讯内存这一点

3798
02:00:03,000 --> 02:00:05,000
我们都是在试图说

3799
02:00:05,000 --> 02:00:10,000
减化开发者的对开发难度

3800
02:00:10,000 --> 02:00:13,000
就通过这种减少

3801
02:00:13,000 --> 02:00:15,000
层级的方式来实现的

3802
02:00:15,000 --> 02:00:17,000
其实现在的程序员

3803
02:00:17,000 --> 02:00:18,000
所唯一需要

3804
02:00:18,000 --> 02:00:19,000
或者也不是

3805
02:00:19,000 --> 02:00:23,000
就还是拯救需要操心一件事情

3806
02:00:23,000 --> 02:00:25,000
就是序列化和反序列化

3807
02:00:25,000 --> 02:00:26,000
对

3808
02:00:26,000 --> 02:00:30,000
但从整个编程的发展的方向来看

3809
02:00:30,000 --> 02:00:33,000
也许这件事情将来也是要

3810
02:00:33,000 --> 02:00:36,000
被淘汰掉了

3811
02:00:36,000 --> 02:00:39,000
或者说人们可以完全不用再去操心

3812
02:00:39,000 --> 02:00:41,000
序列化和反序列化这件事情

3813
02:00:41,000 --> 02:00:42,000
对不对

3814
02:00:42,000 --> 02:00:43,000
有的可能

3815
02:00:43,000 --> 02:00:44,000
其实现在已经有这种

3816
02:00:44,000 --> 02:00:48,000
各种方法可以做一定的这种事情了

3817
02:00:48,000 --> 02:00:50,000
对

3818
02:00:50,000 --> 02:00:53,000
还是先说手工管理存在

3819
02:00:53,000 --> 02:00:56,000
因为我刚才又缅怀了一下自己

3820
02:00:56,000 --> 02:00:58,000
当初写 C 程序的时候

3821
02:00:58,000 --> 02:01:01,000
会在一张纸上写说

3822
02:01:01,000 --> 02:01:03,000
有个东西我在什么地方把它

3823
02:01:03,000 --> 02:01:05,000
AMLOCK

3824
02:01:05,000 --> 02:01:07,000
然后要记得

3825
02:01:07,000 --> 02:01:10,000
应该在什么恰当的时候

3826
02:01:10,000 --> 02:01:13,000
把它序掉

3827
02:01:13,000 --> 02:01:18,000
就是 C 远其实给你提供了一个

3828
02:01:18,000 --> 02:01:21,000
比较贴近硬件的编程模型

3829
02:01:21,000 --> 02:01:23,000
但是它仍就把

3830
02:01:24,000 --> 02:01:26,000
分配内存这一部分

3831
02:01:26,000 --> 02:01:27,000
给帮你藏起来的

3832
02:01:27,000 --> 02:01:29,000
比如说你有想过

3833
02:01:29,000 --> 02:01:32,000
AMLOCK 究竟做了什么吗

3834
02:01:32,000 --> 02:01:35,000
我们会说一个东西分配在对上

3835
02:01:35,000 --> 02:01:36,000
一个东西分配在站上

3836
02:01:36,000 --> 02:01:39,000
可是堆和站这两个东西

3837
02:01:41,000 --> 02:01:43,000
你站你可以通过后面语来操作

3838
02:01:43,000 --> 02:01:46,000
可是堆这个东西怎么通过后面语来操作呢

3839
02:01:46,000 --> 02:01:47,000
其实是不行的

3840
02:01:47,000 --> 02:01:48,000
不是吗

3841
02:01:48,000 --> 02:01:50,000
堆这个东西其实是

3842
02:01:51,000 --> 02:01:52,000
操作系统替你

3843
02:01:52,000 --> 02:01:55,000
虚拟出来的这么一块内存区域而已

3844
02:01:55,000 --> 02:01:58,000
而站则是一个

3845
02:01:59,000 --> 02:02:02,000
站其实也是有操作系统替你出来的

3846
02:02:02,000 --> 02:02:05,000
但你不用手工去管理它吗

3847
02:02:05,000 --> 02:02:12,000
堆和站的抽象层级

3848
02:02:12,000 --> 02:02:14,000
其实是不太一样的

3849
02:02:14,000 --> 02:02:15,000
可以这么说吗

3850
02:02:15,000 --> 02:02:16,000
对

3851
02:02:16,000 --> 02:02:17,000
对

3852
02:02:17,000 --> 02:02:20,000
但是在那个时候

3853
02:02:20,000 --> 02:02:21,000
你调用一个函数的时候

3854
02:02:21,000 --> 02:02:23,000
你在函数里面生命了一个本地面量

3855
02:02:23,000 --> 02:02:24,000
然后本地面量

3856
02:02:24,000 --> 02:02:26,000
其实就是默认分配在站上

3857
02:02:26,000 --> 02:02:27,000
就是站这个东西

3858
02:02:27,000 --> 02:02:29,000
你是没有一个持关的印象说

3859
02:02:29,000 --> 02:02:30,000
这个东西在站上

3860
02:02:30,000 --> 02:02:33,000
你只有去研究这个源的原理的时候

3861
02:02:33,000 --> 02:02:35,000
你才会明白什么是站

3862
02:02:35,000 --> 02:02:37,000
但是堆这个东西

3863
02:02:37,000 --> 02:02:40,000
你会有显示的至少两个 API 去操作它

3864
02:02:40,000 --> 02:02:42,000
一个是 Alock

3865
02:02:42,000 --> 02:02:44,000
Mlock 或 Clock

3866
02:02:44,000 --> 02:02:45,000
然后一个是 free

3867
02:02:45,000 --> 02:02:48,000
就是你会通过 Mlock 这件事情

3868
02:02:48,000 --> 02:02:50,000
拿到一个内存的地址

3869
02:02:50,000 --> 02:02:52,000
但是站是没有这个东西的

3870
02:02:52,000 --> 02:02:53,000
站是不会给你一个东西

3871
02:02:53,000 --> 02:02:56,000
就让你显示的是铺蛇 poked 对吧

3872
02:02:56,000 --> 02:02:57,000
对

3873
02:02:57,000 --> 02:02:59,000
说这个 poked dispatch

3874
02:02:59,000 --> 02:03:02,000
我们的友台节目

3875
02:03:02,000 --> 02:03:05,000
总是让我觉得是出战分发

3876
02:03:05,000 --> 02:03:06,000
很 Hotcore

3877
02:03:06,000 --> 02:03:10,000
Message 对比我们 Curtain PanicHotcore 多了

3878
02:03:10,000 --> 02:03:13,000
出战分发的 Message

3879
02:03:13,000 --> 02:03:15,000
Message dispatch

3880
02:03:15,000 --> 02:03:16,000
对

3881
02:03:16,000 --> 02:03:19,000
可是现在的成全就幸福很多了

3882
02:03:19,000 --> 02:03:20,000
至少从

3883
02:03:20,000 --> 02:03:21,000
比如说

3884
02:03:21,000 --> 02:03:25,000
当然 CG 加省去还是要去操心

3885
02:03:25,000 --> 02:03:29,000
一个类的那个

3886
02:03:29,000 --> 02:03:30,000
叫什么

3887
02:03:30,000 --> 02:03:32,000
它要有地址

3888
02:03:32,000 --> 02:03:34,000
construct 中国是什么

3889
02:03:34,000 --> 02:03:35,000
构造器

3890
02:03:35,000 --> 02:03:36,000
对 构造寒树的

3891
02:03:36,000 --> 02:03:39,000
你还需要去考虑一个类的构造寒树

3892
02:03:39,000 --> 02:03:40,000
discord

3893
02:03:40,000 --> 02:03:41,000
C 購寒树

3894
02:03:41,000 --> 02:03:42,000
对

3895
02:03:42,000 --> 02:03:45,000
我想说觉得这个名字好屌

3896
02:03:45,000 --> 02:03:47,000
C 購寒树

3897
02:03:47,000 --> 02:03:49,000
然后

3898
02:03:49,000 --> 02:03:51,000
在 Objective-C 里面

3899
02:03:51,000 --> 02:03:55,000
你也需要去考虑

3900
02:03:55,000 --> 02:03:56,000
什么是

3901
02:03:56,000 --> 02:03:59,000
就是你需要显示的去写一个

3902
02:03:59,000 --> 02:04:02,000
一个

3903
02:04:02,000 --> 02:04:04,000
interface 的

3904
02:04:04,000 --> 02:04:05,000
implementation 里面

3905
02:04:05,000 --> 02:04:06,000
然后写这个玩意

3906
02:04:06,000 --> 02:04:08,000
在被 Dialogue 的时候

3907
02:04:08,000 --> 02:04:09,000
要做的事情

3908
02:04:09,000 --> 02:04:11,000
但是你从来不需要去

3909
02:04:11,000 --> 02:04:13,000
显示的去调用 Dialogue

3910
02:04:13,000 --> 02:04:15,000
这一点和 CG 加应该是一样的

3911
02:04:15,000 --> 02:04:17,000
对 它会帮你去 call 那个

3912
02:04:17,000 --> 02:04:19,000
但是你还是得要记住

3913
02:04:19,000 --> 02:04:20,000
什么的顺序关系

3914
02:04:20,000 --> 02:04:22,000
你写的时候就要留意这一点

3915
02:04:22,000 --> 02:04:23,000
对

3916
02:04:23,000 --> 02:04:26,000
然后 C 帮你

3917
02:04:26,000 --> 02:04:28,000
帮程序员在某种程度上

3918
02:04:28,000 --> 02:04:32,000
减轻了内存管理的

3919
02:04:32,000 --> 02:04:34,000
业务逻辑

3920
02:04:34,000 --> 02:04:36,000
你只需要自己去记住这个东西

3921
02:04:36,000 --> 02:04:38,000
如果有别人还在用

3922
02:04:38,000 --> 02:04:39,000
只要 retain 一次

3923
02:04:39,000 --> 02:04:41,000
如果有别人已经不在用了

3924
02:04:41,000 --> 02:04:43,000
你就把它 release 一下就好了

3925
02:04:43,000 --> 02:04:45,000
然后只要还有一个人在用

3926
02:04:45,000 --> 02:04:47,000
就不会被

3927
02:04:47,000 --> 02:04:49,000
运行时真正的销毁掉

3928
02:04:49,000 --> 02:04:52,000
它就是个 ARC 吗

3929
02:04:52,000 --> 02:04:54,000
这是 ARC 没有 A

3930
02:04:54,000 --> 02:04:56,000
reference counting

3931
02:04:56,000 --> 02:04:58,000
人要自己去在那里算

3932
02:04:58,000 --> 02:05:00,000
release 了多少次

3933
02:05:00,000 --> 02:05:02,000
以及 retain 了多少次

3934
02:05:02,000 --> 02:05:04,000
然后 ARC 帮你解决的这个问题

3935
02:05:04,000 --> 02:05:06,000
就是你不用再去显示的 release

3936
02:05:06,000 --> 02:05:08,000
reten 了

3937
02:05:08,000 --> 02:05:10,000
系统帮你数吗

3938
02:05:10,000 --> 02:05:11,000
对

3939
02:05:11,000 --> 02:05:14,000
OJC 会在编译期帮你数一遍

3940
02:05:14,000 --> 02:05:16,000
这应该不是在运行时数的

3941
02:05:16,000 --> 02:05:17,000
对

3942
02:05:17,000 --> 02:05:18,000
编译期的时候会帮你数一遍

3943
02:05:18,000 --> 02:05:19,000
你这个东西

3944
02:05:19,000 --> 02:05:21,000
所有的用的地方

3945
02:05:21,000 --> 02:05:23,000
它就会帮你自动 retain 一次

3946
02:05:23,000 --> 02:05:25,000
然后所有

3947
02:05:25,000 --> 02:05:27,000
它觉得你已经不会再用的地方

3948
02:05:27,000 --> 02:05:29,000
它就帮你 release 一下

3949
02:05:29,000 --> 02:05:33,000
所以那个还是一个比较原始的方式

3950
02:05:33,000 --> 02:05:34,000
对

3951
02:05:34,000 --> 02:05:39,000
如果说手动的管理的存是一个

3952
02:05:39,000 --> 02:05:40,000
老式步枪的话

3953
02:05:40,000 --> 02:05:42,000
你需要自己打一发上一仓

3954
02:05:42,000 --> 02:05:43,000
打一下枪穿

3955
02:05:43,000 --> 02:05:47,000
ARC 就有点像半自动了

3956
02:05:47,000 --> 02:05:49,000
现在就是

3957
02:05:49,000 --> 02:05:51,000
手工管理内存的时代

3958
02:05:51,000 --> 02:05:53,000
基本上已经是过去了

3959
02:05:53,000 --> 02:05:55,000
除非你有什么特别

3960
02:05:55,000 --> 02:05:59,000
除非你是自己是写训理机

3961
02:05:59,000 --> 02:06:01,000
或者是编译器的人

3962
02:06:01,000 --> 02:06:03,000
否则你一般是不需要去操心

3963
02:06:03,000 --> 02:06:05,000
怎么手工管理内存这件事

3964
02:06:05,000 --> 02:06:07,000
它有一些那种

3965
02:06:07,000 --> 02:06:09,000
表现成功的东西的时候

3966
02:06:09,000 --> 02:06:12,000
它会用 C 或者 C 接约来写的时候

3967
02:06:12,000 --> 02:06:15,000
就还会考虑内存管理的问题

3968
02:06:15,000 --> 02:06:16,000
对

3969
02:06:16,000 --> 02:06:18,000
或者是在面试的时候

3970
02:06:18,000 --> 02:06:21,000
告诉你说你不能使用额外的内存

3971
02:06:21,000 --> 02:06:22,000
你应该怎么回答

3972
02:06:22,000 --> 02:06:23,000
你应该怎么办

3973
02:06:23,000 --> 02:06:26,000
写给 mlog

3974
02:06:26,000 --> 02:06:28,000
对

3975
02:06:28,000 --> 02:06:32,000
现在主流的是一个垃圾回收的机制

3976
02:06:32,000 --> 02:06:35,000
对 垃圾回收可以说是

3977
02:06:35,000 --> 02:06:37,000
进一步解放了

3978
02:06:37,000 --> 02:06:42,000
程序就是你有更加清晰而简化

3979
02:06:42,000 --> 02:06:44,000
变成模型

3980
02:06:44,000 --> 02:06:47,000
当然由此也就降低了

3981
02:06:47,000 --> 02:06:49,000
降低了变成

3982
02:06:49,000 --> 02:06:50,000
怎么说呢

3983
02:06:50,000 --> 02:06:53,000
提高了你写出烂带马的几率

3984
02:06:53,000 --> 02:06:54,000
应该这么说

3985
02:06:54,000 --> 02:06:56,000
你说门凯滴了吗

3986
02:06:56,000 --> 02:06:58,000
门凯滴有种负面的意味在

3987
02:06:58,000 --> 02:07:00,000
门凯滴了就好吃

3988
02:07:00,000 --> 02:07:01,000
好吧

3989
02:07:01,000 --> 02:07:03,000
你是从比较正面的角度

3990
02:07:03,000 --> 02:07:04,000
理解的这些事情

3991
02:07:04,000 --> 02:07:06,000
但我总觉得就是门凯滴的

3992
02:07:06,000 --> 02:07:08,000
这容易让更多平庸的人写出

3993
02:07:08,000 --> 02:07:10,000
平庸但是 work 的带马

3994
02:07:10,000 --> 02:07:11,000
对

3995
02:07:11,000 --> 02:07:13,000
但是时间一久

3996
02:07:13,000 --> 02:07:15,000
甚至可以这么说

3997
02:07:15,000 --> 02:07:17,000
就是变成模型的简化

3998
02:07:17,000 --> 02:07:21,000
使得大规模的软件协作成为可能

3999
02:07:21,000 --> 02:07:22,000
对

4000
02:07:22,000 --> 02:07:24,000
不是大家都是大牛的情况

4001
02:07:24,000 --> 02:07:25,000
也能把这个事情做出

4002
02:07:25,000 --> 02:07:26,000
对 有一群平庸的人

4003
02:07:26,000 --> 02:07:28,000
也可以写出一个

4004
02:07:28,000 --> 02:07:32,000
工业级别建状的东西来给大家用

4005
02:07:32,000 --> 02:07:35,000
而不再需要一群先驱者

4006
02:07:35,000 --> 02:07:36,000
还可以去

4007
02:07:36,000 --> 02:07:38,000
只有他们才可以写出一个

4008
02:07:38,000 --> 02:07:39,000
真正的

4009
02:07:39,000 --> 02:07:42,000
居然可以工作的程序来

4010
02:07:42,000 --> 02:07:43,000
对

4011
02:07:43,000 --> 02:07:46,000
GC 的逻辑其实也蛮

4012
02:07:46,000 --> 02:07:48,000
讲起来是蛮好讲的

4013
02:07:48,000 --> 02:07:49,000
就是它会

4014
02:07:49,000 --> 02:07:51,000
运行时会去

4015
02:07:51,000 --> 02:07:53,000
检查你每一个内部的指针

4016
02:07:53,000 --> 02:07:54,000
怎么样

4017
02:07:54,000 --> 02:07:55,000
然后去算

4018
02:07:55,000 --> 02:07:57,000
哪些区是没有

4019
02:07:57,000 --> 02:07:59,000
不可能再被用到了

4020
02:07:59,000 --> 02:08:00,000
然后它就直接把那些区

4021
02:08:00,000 --> 02:08:02,000
标记为可以回收掉的

4022
02:08:02,000 --> 02:08:03,000
对

4023
02:08:03,000 --> 02:08:06,000
然后在下一段里面把它回收掉

4024
02:08:06,000 --> 02:08:07,000
对

4025
02:08:07,000 --> 02:08:10,000
当然 GC 有很多不同的类型

4026
02:08:10,000 --> 02:08:13,000
我们可以找机会再讲

4027
02:08:13,000 --> 02:08:14,000
你刚才说到

4028
02:08:14,000 --> 02:08:16,000
Go 出了 1.4

4029
02:08:16,000 --> 02:08:21,000
我去看了一下它的 Release Note

4030
02:08:21,000 --> 02:08:25,000
里面有一节写到说 Change to Run Time

4031
02:08:25,000 --> 02:08:29,000
它里面写说 1.4 之前

4032
02:08:29,000 --> 02:08:33,000
Runtime 就是什么 GC

4033
02:08:33,000 --> 02:08:35,000
Concurrency 的支持

4034
02:08:35,000 --> 02:08:36,000
Interface Management

4035
02:08:36,000 --> 02:08:39,000
Maps, Slices, Strings, etc

4036
02:08:39,000 --> 02:08:42,000
在 1.4 之前基本上是以 C 来写了

4037
02:08:42,000 --> 02:08:43,000
对

4038
02:08:43,000 --> 02:08:47,000
然后包括某些部分用了

4039
02:08:47,000 --> 02:08:48,000
会边代码

4040
02:08:48,000 --> 02:08:50,000
然后从 1.4 开始

4041
02:08:50,000 --> 02:08:52,000
大部分 Runtime 都用

4042
02:08:52,000 --> 02:08:54,000
Go 来重写了一遍

4043
02:08:54,000 --> 02:08:55,000
对

4044
02:08:55,000 --> 02:08:56,000
然后一次

4045
02:08:56,000 --> 02:08:57,000
对

4046
02:08:57,000 --> 02:09:00,000
所以一起来带来了一个提升

4047
02:09:00,000 --> 02:09:03,000
Garbage Collector can scan the stacks

4048
02:09:03,000 --> 02:09:05,000
of the programs in the runtime

4049
02:09:05,000 --> 02:09:07,000
and get accurate information about

4050
02:09:07,000 --> 02:09:09,000
what variables are active

4051
02:09:09,000 --> 02:09:10,000
对,它之前是

4052
02:09:10,000 --> 02:09:12,000
因为它拿不到运行时的有些东西

4053
02:09:12,000 --> 02:09:13,000
所以它的 GC

4054
02:09:13,000 --> 02:09:14,000
就是它的那个内存

4055
02:09:14,000 --> 02:09:15,000
那就会说

4056
02:09:15,000 --> 02:09:17,000
是 imprecise

4057
02:09:17,000 --> 02:09:18,000
就是不是很精确的

4058
02:09:18,000 --> 02:09:20,000
有时候会漏掉一些东西

4059
02:09:20,000 --> 02:09:22,000
但是整体来说还可以吧

4060
02:09:22,000 --> 02:09:24,000
它现在变成一个

4061
02:09:24,000 --> 02:09:25,000
就是完全精确的

4062
02:09:25,000 --> 02:09:27,000
一定知道哪些指针是

4063
02:09:27,000 --> 02:09:31,000
可以被安全回收的

4064
02:09:31,000 --> 02:09:32,000
然后他们还要做

4065
02:09:32,000 --> 02:09:34,000
下方他们要做另外一件事情

4066
02:09:34,000 --> 02:09:35,000
就是要把这个垃圾回收

4067
02:09:35,000 --> 02:09:37,000
做一个完全必行化的东西

4068
02:09:37,000 --> 02:09:38,000
因为现在的它的垃圾回收

4069
02:09:38,000 --> 02:09:40,000
还是一个叫做 stop the war 的

4070
02:09:40,000 --> 02:09:43,000
加上 JVM 有这个

4071
02:09:43,000 --> 02:09:46,000
这个句话要说严谨一点

4072
02:09:46,000 --> 02:09:49,000
主流的 JVM

4073
02:09:49,000 --> 02:09:50,000
还有这个

4074
02:09:50,000 --> 02:09:51,000
对,有这个问题

4075
02:09:51,000 --> 02:09:52,000
就是它在垃圾回收

4076
02:09:52,000 --> 02:09:54,000
机制运行的期间

4077
02:09:54,000 --> 02:09:57,000
承续的其他部分是暂停的

4078
02:09:57,000 --> 02:09:59,000
对,这就是为什么

4079
02:09:59,000 --> 02:10:01,000
这就是为什么一 CLEAN FIMO 卡

4080
02:10:01,000 --> 02:10:03,000
延续吧

4081
02:10:03,000 --> 02:10:06,000
对,这个对很多应用来说

4082
02:10:06,000 --> 02:10:07,000
这个就是不可以接受的

4083
02:10:07,000 --> 02:10:09,000
比如说你写一个什么

4084
02:10:09,000 --> 02:10:11,000
这个股票的实施交易的应用

4085
02:10:11,000 --> 02:10:12,000
那你可能

4086
02:10:12,000 --> 02:10:14,000
就那可能几十毫秒

4087
02:10:14,000 --> 02:10:15,000
100 毫秒的差别

4088
02:10:15,000 --> 02:10:16,000
那就是上百万的

4089
02:10:16,000 --> 02:10:18,000
这个经济的损失对吧

4090
02:10:18,000 --> 02:10:20,000
所以你肯定不可避免

4091
02:10:20,000 --> 02:10:22,000
所以他们有些做金融交易的

4092
02:10:22,000 --> 02:10:25,000
有些就直接用那个什么 CGR

4093
02:10:25,000 --> 02:10:27,000
就这样不需要去考虑 GC 的问题

4094
02:10:27,000 --> 02:10:28,000
或者是他用那个 JVM

4095
02:10:28,000 --> 02:10:30,000
他是用改良过的这种

4096
02:10:30,000 --> 02:10:32,000
就是所谓的 concurrent

4097
02:10:32,000 --> 02:10:35,000
或者 powerGC 就是并行的 GC

4098
02:10:35,000 --> 02:10:36,000
GC 过程中他可以不用停下来

4099
02:10:36,000 --> 02:10:37,000
一个组成续

4100
02:10:37,000 --> 02:10:38,000
现在勾的他里面

4101
02:10:38,000 --> 02:10:40,000
还是这个 stop the war 这种情况

4102
02:10:40,000 --> 02:10:41,000
但是他马上

4103
02:10:41,000 --> 02:10:42,000
他是说 1.5 吧

4104
02:10:42,000 --> 02:10:43,000
我记得

4105
02:10:43,000 --> 02:10:44,000
就下半版的时候

4106
02:10:44,000 --> 02:10:45,000
他会变成那个 concurrent

4107
02:10:45,000 --> 02:10:47,000
对

4108
02:10:47,000 --> 02:10:49,000
这就回到了刚才说的这个

4109
02:10:49,000 --> 02:10:51,000
就是整个内存管理的方向

4110
02:10:51,000 --> 02:10:53,000
还是朝着让

4111
02:10:53,000 --> 02:10:56,000
越来越省心的方向来

4112
02:10:56,000 --> 02:10:57,000
对

4113
02:10:57,000 --> 02:10:58,000
来眼尽的

4114
02:10:58,000 --> 02:11:00,000
但是同时也就造成了

4115
02:11:00,000 --> 02:11:01,000
在真正那些

4116
02:11:01,000 --> 02:11:03,000
仍旧还是需要

4117
02:11:03,000 --> 02:11:05,000
就像你说的那个股票操作系统

4118
02:11:05,000 --> 02:11:07,000
mission critical 的场合

4119
02:11:07,000 --> 02:11:09,000
还是需要手动管理的生意啊

4120
02:11:09,000 --> 02:11:11,000
就有些事情还是

4121
02:11:11,000 --> 02:11:13,000
不得不依靠的手动管理

4122
02:11:13,000 --> 02:11:15,000
因为手动管理才可以

4123
02:11:15,000 --> 02:11:16,000
达到

4124
02:11:16,000 --> 02:11:17,000
那个

4125
02:11:17,000 --> 02:11:18,000
so-signal performance

4126
02:11:18,000 --> 02:11:19,000
对

4127
02:11:19,000 --> 02:11:20,000
那个

4128
02:11:20,000 --> 02:11:21,000
beana

4129
02:11:21,000 --> 02:11:22,000
是什么叫

4130
02:11:22,000 --> 02:11:23,000
beana store store

4131
02:11:23,000 --> 02:11:24,000
对

4132
02:11:24,000 --> 02:11:26,000
就是 C++的创始人在

4133
02:11:26,000 --> 02:11:28,000
我忘了是那本书里面

4134
02:11:28,000 --> 02:11:29,000
他吐槽 C

4135
02:11:29,000 --> 02:11:31,000
吐槽扎吧说

4136
02:11:31,000 --> 02:11:33,000
他有点炫耀的意思

4137
02:11:33,000 --> 02:11:34,000
就是说

4138
02:11:34,000 --> 02:11:35,000
你知道

4139
02:11:35,000 --> 02:11:37,000
joined strike fighter jseph

4140
02:11:37,000 --> 02:11:38,000
战斗机

4141
02:11:38,000 --> 02:11:40,000
他是一台 C++战斗机

4142
02:11:40,000 --> 02:11:42,000
就是上面所有的代码都是跑的

4143
02:11:42,000 --> 02:11:43,000
都是 C++

4144
02:11:43,000 --> 02:11:45,000
然后火星探测器

4145
02:11:45,000 --> 02:11:46,000
你知道吗

4146
02:11:46,000 --> 02:11:47,000
C++写的

4147
02:11:47,000 --> 02:11:49,000
是你用扎吧给我写一个看看

4148
02:11:49,000 --> 02:11:51,000
大意就是这样对

4149
02:11:51,000 --> 02:11:54,000
对那些的应用场合就比较极大吗

4150
02:11:54,000 --> 02:11:55,000
性能和这个

4151
02:11:55,000 --> 02:11:57,000
环境要求比较恶劣

4152
02:11:57,000 --> 02:11:59,000
对在这种情况之下

4153
02:11:59,000 --> 02:12:01,000
你还是必不得不

4154
02:12:01,000 --> 02:12:02,000
手动

4155
02:12:02,000 --> 02:12:04,000
在加银号的手动去管理那些存

4156
02:12:04,000 --> 02:12:07,000
不过这个也有做到

4157
02:12:07,000 --> 02:12:08,000
就是

4158
02:12:08,000 --> 02:12:11,000
就是在这个技术进步的

4159
02:12:11,000 --> 02:12:12,000
之后也有说

4160
02:12:12,000 --> 02:12:14,000
这个程序还没回光时来

4161
02:12:14,000 --> 02:12:15,000
没有

4162
02:12:15,000 --> 02:12:18,000
就是没有适应用到最新的这种方法

4163
02:12:18,000 --> 02:12:19,000
去做了

4164
02:12:19,000 --> 02:12:20,000
这里有一个很简单的理智

4165
02:12:20,000 --> 02:12:21,000
之前我们提到了

4166
02:12:21,000 --> 02:12:22,000
这个

4167
02:12:22,000 --> 02:12:23,000
蓄烈化解

4168
02:12:23,000 --> 02:12:24,000
蓄烈化的问题

4169
02:12:24,000 --> 02:12:26,000
但我们要做一些事情的时候

4170
02:12:26,000 --> 02:12:27,000
那

4171
02:12:27,000 --> 02:12:29,000
你有一些文件

4172
02:12:29,000 --> 02:12:30,000
你要在内存里面

4173
02:12:30,000 --> 02:12:31,000
去展现

4174
02:12:31,000 --> 02:12:34,000
但是内存又不如这个磁盘大吗

4175
02:12:34,000 --> 02:12:35,000
对

4176
02:12:35,000 --> 02:12:36,000
那么有些人就说

4177
02:12:36,000 --> 02:12:37,000
那我怎么才能在

4178
02:12:37,000 --> 02:12:39,000
内存里面去

4179
02:12:39,000 --> 02:12:40,000
超

4180
02:12:40,000 --> 02:12:41,000
因为只有到内存里面

4181
02:12:41,000 --> 02:12:42,000
只有超

4182
02:12:42,000 --> 02:12:43,000
那个 CPU

4183
02:12:43,000 --> 02:12:44,000
才可以去操作那些数据

4184
02:12:44,000 --> 02:12:45,000
所以我有一个

4185
02:12:45,000 --> 02:12:46,000
从磁盘里面

4186
02:12:46,000 --> 02:12:47,000
读数据

4187
02:12:47,000 --> 02:12:48,000
读到内存里面去

4188
02:12:48,000 --> 02:12:49,000
然后再处理

4189
02:12:49,000 --> 02:12:51,000
然后再处理完毕

4190
02:12:51,000 --> 02:12:53,000
再读下一段这么一个过程

4191
02:12:53,000 --> 02:12:54,000
但其实在

4192
02:12:54,000 --> 02:12:55,000
现在超小的

4193
02:12:55,000 --> 02:12:56,000
这件事情

4194
02:12:56,000 --> 02:12:57,000
也已经很大程度上

4195
02:12:57,000 --> 02:12:59,000
可以完全被避免掉了

4196
02:12:59,000 --> 02:13:00,000
就是通过所谓的

4197
02:13:00,000 --> 02:13:02,000
使用这个叫做

4198
02:13:02,000 --> 02:13:03,000
Memory Map

4199
02:13:03,000 --> 02:13:04,000
Memory Mapping

4200
02:13:04,000 --> 02:13:06,000
内存印射这个概念

4201
02:13:06,000 --> 02:13:07,000
对

4202
02:13:07,000 --> 02:13:09,000
内存印射大概是什么事情呢

4203
02:13:09,000 --> 02:13:10,000
就超多种提问了这么一个机制

4204
02:13:10,000 --> 02:13:11,000
它可以说

4205
02:13:11,000 --> 02:13:13,000
你可以指着磁盘上的

4206
02:13:13,000 --> 02:13:16,000
一个文件大小随意

4207
02:13:16,000 --> 02:13:17,000
说

4208
02:13:17,000 --> 02:13:19,000
我要把这一块文件

4209
02:13:19,000 --> 02:13:21,000
印射到内存地址里面去

4210
02:13:21,000 --> 02:13:23,000
这样的话我超过这种

4211
02:13:23,000 --> 02:13:25,000
我的程序可以直接在

4212
02:13:25,000 --> 02:13:27,000
起码在界面上

4213
02:13:27,000 --> 02:13:28,000
我直接操纵内存的

4214
02:13:28,000 --> 02:13:30,000
一个区块就好了

4215
02:13:30,000 --> 02:13:32,000
但是具体的数据

4216
02:13:32,000 --> 02:13:35,000
那个时候并不在内存里面

4217
02:13:35,000 --> 02:13:36,000
然后这个时候是由

4218
02:13:36,000 --> 02:13:37,000
超多系统去负责

4219
02:13:37,000 --> 02:13:40,000
去把你要访问的

4220
02:13:40,000 --> 02:13:41,000
内存区块的内容

4221
02:13:41,000 --> 02:13:44,000
从磁盘上夹载过来

4222
02:13:44,000 --> 02:13:45,000
然后再管理

4223
02:13:45,000 --> 02:13:49,000
如果说内存物理空间不足的情况下

4224
02:13:49,000 --> 02:13:50,000
再把那些没有用到的

4225
02:13:50,000 --> 02:13:51,000
那些内存区块

4226
02:13:51,000 --> 02:13:53,000
再放回磁盘上去

4227
02:13:53,000 --> 02:13:55,000
内存印射就做这么一件事

4228
02:13:55,000 --> 02:13:57,000
然后其实就

4229
02:13:57,000 --> 02:13:59,000
这个对我们开发者来讲

4230
02:13:59,000 --> 02:14:00,000
就是一个启发

4231
02:14:00,000 --> 02:14:02,000
这一篇很好的文章

4232
02:14:02,000 --> 02:14:04,000
我会放在 Note 里面

4233
02:14:04,000 --> 02:14:06,000
这个是 Varnish Cache

4234
02:14:06,000 --> 02:14:07,000
这个软件

4235
02:14:07,000 --> 02:14:08,000
就是一个反向带理的常用

4236
02:14:08,000 --> 02:14:10,000
如现在你跑夫妻后端的话

4237
02:14:10,000 --> 02:14:12,000
可能会经常接触到这个软件

4238
02:14:12,000 --> 02:14:14,000
他们的开发者写了一个

4239
02:14:14,000 --> 02:14:16,000
他的标题叫做

4240
02:14:16,000 --> 02:14:19,000
What's Wrong with 1975 Programming

4241
02:14:19,000 --> 02:14:21,000
就是他说 1975 年的

4242
02:14:21,000 --> 02:14:23,000
编程模型有什么问题

4243
02:14:23,000 --> 02:14:24,000
那么讲的最主要的一个问题

4244
02:14:24,000 --> 02:14:26,000
就是说刚才一个

4245
02:14:26,000 --> 02:14:28,000
就是内存

4246
02:14:28,000 --> 02:14:29,000
1975 年的时候

4247
02:14:29,000 --> 02:14:31,000
还没有虚拟内存的概念

4248
02:14:31,000 --> 02:14:32,000
你真的是需要

4249
02:14:32,000 --> 02:14:34,000
承计员手工去考虑

4250
02:14:34,000 --> 02:14:35,000
怎么去从自然而然

4251
02:14:35,000 --> 02:14:37,000
加裁一个文件到内存里面去

4252
02:14:37,000 --> 02:14:38,000
然后再进行操作

4253
02:14:38,000 --> 02:14:40,000
然后再写回去做一个过程

4254
02:14:40,000 --> 02:14:41,000
但是到现在

4255
02:14:41,000 --> 02:14:43,000
已经有虚拟内存

4256
02:14:43,000 --> 02:14:44,000
这个操作系统

4257
02:14:44,000 --> 02:14:46,000
就绝大部分操作系统都已经支持这个东西了

4258
02:14:46,000 --> 02:14:48,000
不然那个 M-Lock 也没法写好

4259
02:14:50,000 --> 02:14:51,000
在这种情况下

4260
02:14:51,000 --> 02:14:52,000
那么我们写程序的时候

4261
02:14:52,000 --> 02:14:54,000
就可以不用考虑一些东西

4262
02:14:54,000 --> 02:14:56,000
比如说最简单的一个

4263
02:14:56,000 --> 02:14:57,000
刚才讲的一个持久化和

4264
02:14:57,000 --> 02:14:59,000
非持久化的问题

4265
02:14:59,000 --> 02:15:01,000
持久化和蓄力化的问题

4266
02:15:01,000 --> 02:15:03,000
就是你可以不用考虑说

4267
02:15:03,000 --> 02:15:04,000
我从内存里面读出

4268
02:15:04,000 --> 02:15:06,000
一个比如说一个竖状结构

4269
02:15:06,000 --> 02:15:09,000
然后把它写成一个串流

4270
02:15:09,000 --> 02:15:10,000
再写到磁盘上

4271
02:15:10,000 --> 02:15:11,000
那你直接说

4272
02:15:11,000 --> 02:15:13,000
我在内存上分配一个

4273
02:15:13,000 --> 02:15:15,000
比如说一个 Gb 的空间

4274
02:15:15,000 --> 02:15:17,000
来持久化这个数据

4275
02:15:17,000 --> 02:15:18,000
我直接把这个空间

4276
02:15:18,000 --> 02:15:19,000
印设到我内存里面去

4277
02:15:19,000 --> 02:15:20,000
然后直接在里面

4278
02:15:20,000 --> 02:15:22,000
建我的那个内存结构

4279
02:15:22,000 --> 02:15:23,000
然后操作系统

4280
02:15:23,000 --> 02:15:24,000
会在适当的时候

4281
02:15:24,000 --> 02:15:26,000
把那些内存里面的数据

4282
02:15:26,000 --> 02:15:28,000
持久化到磁盘上面去

4283
02:15:28,000 --> 02:15:30,000
从而实现持久化的效果

4284
02:15:30,000 --> 02:15:31,000
但是作为一个程序员

4285
02:15:31,000 --> 02:15:33,000
你又并不用担心自己在去

4286
02:15:33,000 --> 02:15:36,000
真的就是写那个蓄力化的过程

4287
02:15:37,000 --> 02:15:38,000
没错

4288
02:15:38,000 --> 02:15:41,000
而且一个需要避免的

4289
02:15:41,000 --> 02:15:43,000
或者说一个需要避免的

4290
02:15:43,000 --> 02:15:45,000
过早优化就是

4291
02:15:46,000 --> 02:15:48,000
尽量也不要总觉得自己

4292
02:15:48,000 --> 02:15:51,000
有些东西放在内存里面

4293
02:15:51,000 --> 02:15:53,000
好像没有什么用

4294
02:15:53,000 --> 02:15:55,000
应该先把它从里面

4295
02:15:55,000 --> 02:15:56,000
挪出来的时候

4296
02:15:56,000 --> 02:15:58,000
放在一个磁盘上的什么地方

4297
02:15:58,000 --> 02:15:59,000
然后以此来达到

4298
02:15:59,000 --> 02:16:00,000
结成我内存的目的

4299
02:16:00,000 --> 02:16:02,000
这些都应该加盖操作系统

4300
02:16:02,000 --> 02:16:04,000
对 这件事情也通空

4301
02:16:04,000 --> 02:16:06,000
应该让操作系统来完成

4302
02:16:06,000 --> 02:16:09,000
对 其实说到蓄力化

4303
02:16:09,000 --> 02:16:13,000
其实现在有很多网上的云端服务

4304
02:16:13,000 --> 02:16:15,000
都体重了这样一种变成接口

4305
02:16:15,000 --> 02:16:17,000
就是你可以在程序里面说

4306
02:16:17,000 --> 02:16:21,000
比如说我用什么 JavaScript

4307
02:16:21,000 --> 02:16:24,000
我 JavaScript 交给你这样一个数据

4308
02:16:24,000 --> 02:16:26,000
然后你就把它存下来

4309
02:16:26,000 --> 02:16:27,000
然后我给你要的时候

4310
02:16:27,000 --> 02:16:29,000
你把它原样交还给我

4311
02:16:30,000 --> 02:16:31,000
诸如此类

4312
02:16:31,000 --> 02:16:32,000
对

4313
02:16:32,000 --> 02:16:34,000
这个不光是在网页上

4314
02:16:34,000 --> 02:16:36,000
如果你开发 iOS 的话

4315
02:16:36,000 --> 02:16:38,000
应该它有一个 core data

4316
02:16:38,000 --> 02:16:40,000
对 也是做类似的事情

4317
02:16:40,000 --> 02:16:42,000
对 core data 的编程模型

4318
02:16:42,000 --> 02:16:46,000
我是觉得不是非常的直观

4319
02:16:46,000 --> 02:16:47,000
你可以理解

4320
02:16:47,000 --> 02:16:50,000
你可以看到它试图位置

4321
02:16:50,000 --> 02:16:52,000
做出一个比较简单用的接口来

4322
02:16:52,000 --> 02:16:55,000
但是用起来还是挺麻烦的

4323
02:16:55,000 --> 02:16:56,000
我觉得

4324
02:16:56,000 --> 02:16:58,000
麻烦的点主要在哪里呢

4325
02:16:58,000 --> 02:17:00,000
罗索是一方面

4326
02:17:00,000 --> 02:17:01,000
但另外一方面

4327
02:17:01,000 --> 02:17:03,000
那个是因为 Object C 的语法不好

4328
02:17:03,000 --> 02:17:05,000
对 它是对

4329
02:17:05,000 --> 02:17:07,000
Inheritly 不可避免的

4330
02:17:07,000 --> 02:17:10,000
但我觉得整个想法

4331
02:17:10,000 --> 02:17:13,000
就是把序列化和持久化这一层

4332
02:17:13,000 --> 02:17:17,000
从程序的界面里面分离开来

4333
02:17:17,000 --> 02:17:19,000
我觉得这个是一个挺好的想法

4334
02:17:19,000 --> 02:17:21,000
对 这是没错的

4335
02:17:21,000 --> 02:17:24,000
所以还是说具体到实现的问题

4336
02:17:24,000 --> 02:17:27,000
怎么去实现这一点

4337
02:17:28,000 --> 02:17:31,000
可能我还是 core data 用的不够多吧

4338
02:17:31,000 --> 02:17:35,000
不够 core data 的吐槽大人也不少

4339
02:17:35,000 --> 02:17:38,000
你绝对不是唯一的

4340
02:17:38,000 --> 02:17:39,000
对

4341
02:17:39,000 --> 02:17:42,000
OK 那么今天的

4342
02:17:42,000 --> 02:17:44,000
罗索说说讲了这么多

4343
02:17:44,000 --> 02:17:47,000
对 讲的其实还是有点

4344
02:17:47,000 --> 02:17:49,000
对你不算

4345
02:17:49,000 --> 02:17:52,000
我觉得可能还是咱们两个工体不够

4346
02:17:52,000 --> 02:17:55,000
完了 以后我们还是少碰那种

4347
02:17:55,000 --> 02:17:57,000
比较 hardcore 的东西比较好

4348
02:17:57,000 --> 02:17:59,000
大而硬的话题

4349
02:17:59,000 --> 02:18:01,000
对 我还是应该只谈风月

4350
02:18:01,000 --> 02:18:02,000
如果要做这个话题的话

4351
02:18:02,000 --> 02:18:03,000
我觉得我们可以

4352
02:18:03,000 --> 02:18:05,000
比如说准备个两三个月

4353
02:18:05,000 --> 02:18:08,000
然后写个脚本出来

4354
02:18:08,000 --> 02:18:09,000
然后你说什么我说什么

4355
02:18:09,000 --> 02:18:12,000
每一句都要精确的

4356
02:18:12,000 --> 02:18:14,000
有按可查

4357
02:18:14,000 --> 02:18:16,000
然后每个数据都要

4358
02:18:16,000 --> 02:18:18,000
每个数据都要合对过

4359
02:18:18,000 --> 02:18:19,000
对吧

4360
02:18:19,000 --> 02:18:20,000
比如说

4361
02:18:20,000 --> 02:18:23,000
二 K 吃的典型尺寸是多少

4362
02:18:23,000 --> 02:18:26,000
我们居然不能脱口而出

4363
02:18:26,000 --> 02:18:27,000
太丢人了

4364
02:18:27,000 --> 02:18:29,000
一照两照这个我知道

4365
02:18:29,000 --> 02:18:31,000
OK 两照

4366
02:18:31,000 --> 02:18:32,000
对

4367
02:18:32,000 --> 02:18:33,000
对

4368
02:18:33,000 --> 02:18:37,000
然后这一期的话题之所以会出现

4369
02:18:37,000 --> 02:18:40,000
其实完全是受到 portal 的启发

4370
02:18:40,000 --> 02:18:41,000
我必须承认

4371
02:18:41,000 --> 02:18:44,000
另外一方面也是我之前有一波

4372
02:18:44,000 --> 02:18:47,000
由此我想到了一个很

4373
02:18:48,000 --> 02:18:51,000
有名的科幻作家叫做

4374
02:18:51,000 --> 02:18:52,000
Ted Chang

4375
02:18:52,000 --> 02:18:53,000
Ted Chang

4376
02:18:53,000 --> 02:18:54,000
对

4377
02:18:54,000 --> 02:18:56,000
中国名叫江峰男

4378
02:18:56,000 --> 02:18:57,000
如果你读科幻小说的话

4379
02:18:57,000 --> 02:18:58,000
应该会知道这个

4380
02:18:58,000 --> 02:19:00,000
他这个人写过非常多的

4381
02:19:00,000 --> 02:19:01,000
很有意思的科幻小说

4382
02:19:01,000 --> 02:19:03,000
他有一部就叫

4383
02:19:03,000 --> 02:19:07,000
The Life Cycle of Software Objects

4384
02:19:07,000 --> 02:19:09,000
怎么说

4385
02:19:09,000 --> 02:19:13,000
软件对象的生命周期

4386
02:19:13,000 --> 02:19:14,000
对

4387
02:19:14,000 --> 02:19:16,000
里面讲的就是

4388
02:19:16,000 --> 02:19:19,000
当然这个剧情

4389
02:19:19,000 --> 02:19:21,000
从现在看起来好像有点老

4390
02:19:21,000 --> 02:19:23,000
但他写的时候应该是挺新的

4391
02:19:23,000 --> 02:19:26,000
就是大致就是讲有这么一个

4392
02:19:26,000 --> 02:19:29,000
像 Second Life 这么一个具体世界

4393
02:19:29,000 --> 02:19:32,000
然后里面有一个公司

4394
02:19:32,000 --> 02:19:34,000
培养出了一大堆人工智能

4395
02:19:34,000 --> 02:19:37,000
人工智能是活在 Second Life

4396
02:19:37,000 --> 02:19:38,000
这个世界里面的

4397
02:19:38,000 --> 02:19:40,000
当然他不叫 Second Life

4398
02:19:41,000 --> 02:19:43,000
Digital Terrain

4399
02:19:43,000 --> 02:19:44,000
数字地球之类的

4400
02:19:44,000 --> 02:19:45,000
这么一个

4401
02:19:45,000 --> 02:19:47,000
一个虚拟世界里面

4402
02:19:47,000 --> 02:19:49,000
然后在这个虚拟世界里面

4403
02:19:49,000 --> 02:19:50,000
跑着一些人工智能

4404
02:19:50,000 --> 02:19:52,000
然后这些人工智能

4405
02:19:52,000 --> 02:19:54,000
是真正的智能

4406
02:19:54,000 --> 02:19:56,000
就是生下来的时候

4407
02:19:56,000 --> 02:19:58,000
这些人工智能诞生的时候

4408
02:19:58,000 --> 02:20:00,000
是没有什么技能的

4409
02:20:00,000 --> 02:20:01,000
然后需要一群

4410
02:20:01,000 --> 02:20:03,000
需要一群人类在里面

4411
02:20:03,000 --> 02:20:04,000
训练他们学习

4412
02:20:04,000 --> 02:20:06,000
然后教他们做游戏

4413
02:20:06,000 --> 02:20:08,000
然后把他们

4414
02:20:08,000 --> 02:20:09,000
就是他们有各种各样的形体

4415
02:20:09,000 --> 02:20:10,000
比如说有些人的技术能形状

4416
02:20:10,000 --> 02:20:12,000
有些人是压子的形状

4417
02:20:12,000 --> 02:20:15,000
然后除此来

4418
02:20:15,000 --> 02:20:16,000
然后就讲的是

4419
02:20:16,000 --> 02:20:18,000
人工智能被培育起来的事情

4420
02:20:18,000 --> 02:20:20,000
然后这个文章也是

4421
02:20:20,000 --> 02:20:23,000
这块文章也是女性视角

4422
02:20:23,000 --> 02:20:26,000
在三号很奇怪的女性视角

4423
02:20:26,000 --> 02:20:29,000
然后讲的故事也比较

4424
02:20:29,000 --> 02:20:31,000
其实你读的话

4425
02:20:31,000 --> 02:20:32,000
你会觉得他说的很多事情

4426
02:20:32,000 --> 02:20:33,000
都很平淡

4427
02:20:33,000 --> 02:20:34,000
比如就讲这个主角

4428
02:20:34,000 --> 02:20:36,000
是怎么带着这些小人工智能们

4429
02:20:36,000 --> 02:20:38,000
陪他们玩

4430
02:20:38,000 --> 02:20:40,000
然后看他们的一点点的

4431
02:20:40,000 --> 02:20:41,000
和用户互动

4432
02:20:41,000 --> 02:20:43,000
然后直到后来

4433
02:20:43,000 --> 02:20:46,000
把他们装到就是实体世界里面

4434
02:20:46,000 --> 02:20:47,000
做出来的机器人

4435
02:20:47,000 --> 02:20:50,000
就把他们下载到机器人里面

4436
02:20:50,000 --> 02:20:52,000
然后带着他们去看

4437
02:20:52,000 --> 02:20:54,000
去体验实体的世界

4438
02:20:54,000 --> 02:20:57,000
然后以及最后人们是

4439
02:20:57,000 --> 02:20:59,000
怎么样他们的用户是怎样失去了

4440
02:20:59,000 --> 02:21:02,000
对这种人工智能的兴趣

4441
02:21:02,000 --> 02:21:04,000
然后就把这些人工智能

4442
02:21:04,000 --> 02:21:06,000
要退还

4443
02:21:06,000 --> 02:21:08,000
或者是要冻结

4444
02:21:08,000 --> 02:21:10,000
乃至销毁的这么一个过程

4445
02:21:10,000 --> 02:21:14,000
对这块文章也是有引发我

4446
02:21:14,000 --> 02:21:18,000
做这样一期主题的冻机之一

4447
02:21:18,000 --> 02:21:20,000
但是很显然可能

4448
02:21:20,000 --> 02:21:25,000
出于这个资历和背景的缘故

4449
02:21:25,000 --> 02:21:26,000
还能准备比较仓促

4450
02:21:26,000 --> 02:21:29,000
做的不是特别的介绍人物

4451
02:21:29,000 --> 02:21:32,000
不过下次吧

4452
02:21:32,000 --> 02:21:35,000
以后对下次补过来吧

4453
02:21:35,000 --> 02:21:38,000
好那今天的节目就到这里结束了

4454
02:21:38,000 --> 02:21:41,000
对然后我们应该会

4455
02:21:41,000 --> 02:21:44,000
请大家听一遍这个

4456
02:21:44,000 --> 02:21:47,000
Still Alive 我们的主题曲

4457
02:21:47,000 --> 02:21:50,000
那就下期再见吧

4458
02:21:50,000 --> 02:21:51,000
拜拜

4459
02:21:51,000 --> 02:21:54,000
对忘了这期播出时间的

4460
02:21:54,000 --> 02:21:57,000
播出之后应该就要圣诞节了吧

4461
02:21:57,000 --> 02:21:58,000
我想想

4462
02:21:58,000 --> 02:22:01,000
我们下下期应该是

4463
02:22:01,000 --> 02:22:02,000
圣诞节的那个周末

4464
02:22:02,000 --> 02:22:04,000
我们应该没有节目

4465
02:22:04,000 --> 02:22:06,000
我们是隔一周播一次嘛对吧

4466
02:22:06,000 --> 02:22:07,000
这个在意吧

4467
02:22:07,000 --> 02:22:08,000
对

4468
02:22:08,000 --> 02:22:09,000
对

4469
02:22:09,000 --> 02:22:14,000
按理为如果下一周你过圣诞节的话

4470
02:22:14,000 --> 02:22:15,000
圣诞快乐

4471
02:22:15,000 --> 02:22:18,000
OK

4472
02:22:18,000 --> 02:22:20,000
就这样

4473
02:22:20,000 --> 02:22:21,000
拜拜

